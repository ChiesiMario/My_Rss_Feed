<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 10 Jan 2024 14:27:39 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[ToolLearning Eval：CodeFuse 發佈首箇中文 Function Call 的大語言模型評測基準]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><h2><img alt="hjdfsbg.png" src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/98756342/1704878404965-d1c416d5-59da-4867-bcbf-ed5f2f607f42.png?x-oss-process=image%2Fresize%2Cw_900%2Climit_0" width="900" referrerpolicy="no-referrer"></h2><span id="OSC_h2_1"></span><h2><span>1.<span>&nbsp;</span></span><span style="color:#000000">背景</span></h2><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">隨着 ChatGPT 等通用大模型的出現，它們可以生成令人驚歎的自然語言，使得機器能夠更好地理解和迴應人類的需求，但在特定領域的任務上僅靠通用問答是無法滿足日常工作需要。隨着 OpenAI 推出了 Function Call 功能，工具學習能力越來越作為開源模型的標配，目前業界較有影響力的是 ToolBench 的英文數據集。但是中文數據集的稀缺，使得我們很難判斷各個模型在中文型工具上 Function Call 的能力差異。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">為彌補這一不足，CodeFuse 發佈了首個面向 ToolLearning 領域的中文評測基準 ToolLearning-Eval，以幫助開發者跟蹤 ToolLearning 領域大模型的進展，並瞭解各個 ToolLearning 領域大模型的優勢與不足。ToolLearning-Eval 按照 Function Call 流程進行劃分，包含工具選擇、工具調用、工具執行結果總結這三個過程，方便通用模型可以對各個過程進行評測分析。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">目前，我們已發佈了第一期的評測榜單，首批評測大模型包含 CodeFuse、Qwen、Baichuan、Internlm、CodeLLaMa 等開源大語言模型；我們歡迎相關從業者一起來共建 ToolLearning Eval 項目，持續豐富 ToolLearning 領域評測題目或大模型，我們也會定期更新評測集和評測榜單。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#000000">GitHub 地址：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-devops-eval" target="_blank" rel="nofollow"><span style="color:#000000">https://github.com/codefuse-ai/codefuse-devops-eval</span></a></p><p style="margin-left:0; margin-right:0"><span style="color:#000000">ModelScope 地址：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmodelscope.cn%2Fdatasets%2Fcodefuse-ai%2Fdevopseval-exam%2Fsummary" target="_blank" rel="nofollow"><span style="color:#000000">https://modelscope.cn/datasets/codefuse-ai/devopseval-exam/summary</span></a></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_2"></span><h2><span>2.<span>&nbsp;</span></span><span style="color:#000000">評測數據</span></h2><span id="OSC_h3_3"></span><h3><span>2.1.<span>&nbsp;</span></span><span style="color:#000000">數據來源</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">ToolLearning-Eval 最終生成的樣本格式都為 Function Call 標準格式，採用此類格式的原因是與業界數據統一，不但能夠提高樣本收集效率，也方便進行其它自動化評測。經過統計，該項目的數據來源可以分為 3 類：</span></p><ol><li><span style="color:#000000">開源數據：對開源的 ToolBench 原始英文數據進行清洗；</span></li><li><span style="color:#000000">英譯中：選取高質量的 ToolBench 數據，並翻譯為中文；</span></li><li><span style="color:#000000">大模型生成：採用 Self-Instruct 方法構建了中文 Function Call 訓練數據&amp;評測集；</span></li></ol><p style="margin-left:0; margin-right:0"><span style="color:#000000">我們希望越來越多的團隊能參與到中文的 functioncall 數據構建，共同優化模型調用工具的能力。我們也會不斷地強化這部分開源的數據集。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h3_4"></span><h3><span>2.2.<span>&nbsp;</span></span><span style="color:#000000">數據類別</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">ToolLearning-Eval 裏麪包含了兩份評測集，fcdata-zh-luban 和 fcdata-zh-codefuse。裏面總共包含 239 種工具類別，涵蓋了 59 個領域，包含了 1509 條評測數據。ToolLearning-Eval 的具體數據分佈可見下圖</span></p><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/238517/1701934951404-984f915c-550e-4da6-93c0-3bcc70efe66d.png" width="793" referrerpolicy="no-referrer"></p><span id="OSC_h3_5"></span><h3><span>2.3.<span>&nbsp;</span></span><span style="color:#000000">數據樣例</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">在數據上我們完全兼容了 OpenAI Function Calling，具體格式如下：</span></p><p style="margin-left:0; margin-right:0"><strong><span>Function Call 的數據格式</span></strong></p><p style="margin-left:0; margin-right:0"><img alt="截屏 2024-01-10 15.00.51.png" src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/98756342/1704878469274-e7c2e86e-d595-4095-b7e5-cb4b0c12b2fb.png" width="1516" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong><span>chatrounds 的數據格式</span></strong></p><p style="margin-left:0; margin-right:0"><img alt="截屏 2024-01-10 15.00.19.png" src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/98756342/1704878469290-acf7e74e-449a-4244-b911-0cf2273b7aff.png" width="1516" referrerpolicy="no-referrer"></p><pre><code>{
    "functions":
    [
        {
            "name": "get_fudan_university_scoreline",
            "description": "查詢復旦大學往年分數線，例如：查詢 2020 年復旦大學的分數線",
            "parameters":
            {
                "type": "object",
                "properties":
                {
                    "year":
                    {
                        "type": "string",
                        "description": "年份，例如：2020，2019，2018"
                    }
                },
                "required":
                [
                    "year"
                ]
            }
        }
    ],
    "chatrounds":
    [
        {
            "role": "system",
            "content": "CodeFuse 是一個面向研發領域的智能助手，旨在中立的、無害的幫助用户解決開發相關的問題，所有的回答均使用 Markdown 格式返回。\n 你能利用許多工具和功能來完成給定的任務，在每一步中，你需要分析當前狀態，並通過執行函數調用來確定下一步的行動方向。你可以進行多次嘗試。如果你計劃連續嘗試不同的條件，請每次嘗試一種條件。若給定了 Finish 函數,則以 Finish 調用結束，若沒提供 Finish 函數，則以不帶 function_call 的對話結束。"
        },
        {
            "role": "user",
            "content": "查詢 2020 年復旦大學的分數線"
        },
        {
            "role": "assistant",
            "content": null,
            "function_call":
            {
                "name": "get_fudan_university_scoreline",
                "arguments": "{\n  \"year\": \"2020\"\n}"
            }
        },
        {
            "role": "function",
            "name": "get_fudan_university_scoreline",
            "content": "{\n    \"scoreline\":{\n        \"文科一批\": 630,    \n        \"文科二批\": 610,  \n        \"理科一批\": 650,  \n        \"理科二批\": 630  \n    }\n}"
        },
        {
            "role": "assistant",
            "content": "2020 年復旦大學的分數線如下：\n\n- 文科一批：630 分\n- 文科二批：610 分\n- 理科一批：650 分\n- 理科二批：630 分"
        }
    ]
}</code></pre><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#000000">上述 Function Call 的數據樣例為給定特定工具集後，用於回答用户查詢某高校錄取分數線的問題。此外限於篇幅，此處不再其它工具使用樣例，具體可以查看 HuggingFace 數據集。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h3_6"></span><h3><span>2.4.<span>&nbsp;</span></span><span style="color:#000000">數據下載</span></h3><ul><li><span style="color:#000000">方法一： 直接下載（用瀏覽器打開下面的鏈接）</span></li></ul><p style="margin-left:0; margin-right:0"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmodelscope.cn%2Fdatasets%2Fcodefuse-ai%2Fdevopseval-exam%2Ffiles" target="_blank" rel="nofollow"><span style="color:#000000">https://modelscope.cn/datasets/codefuse-ai/devopseval-exam/files</span></a></p><ul><li><span style="color:#000000">方法二：使用 ModelScope datasets 庫函數</span></li></ul><pre><code>from modelscope.msdatasets import MsDataset
MsDataset.clone_meta(dataset_work_dir='./xxx', dataset_id='codefuse-ai/devopseval-exam')
</code></pre><p style="margin-left:0; margin-right:0">&nbsp;</p><pre><code>sample_data
|- sampleData.json   # 數據樣例
train_data
|- fcdata_toolbenchG1.jsonl  # 72783 toolbenchG1 整理數據
|- fcdata_toolbenchG2.jsonl  # 29417 toolbenchG2 整理數據
|- fcdata_toolbenchG3.jsonl  # 24286 toolbenchG3 整理數據
|- fcdata_toolbenchG1_zh.jsonl # 16335 toolbenchG1 部分中文翻譯數據
|- fcdata_zh_train_v1.jsonl # 72032 自有采集生成的數據 V1
|- fcdata_zh_train_luban.jsonl  # 10214 自有采集生成的數據 luban
 test_data
 |- fcdata_zh_test_v1.jsonl # 1250 自有采集生成的測試數據 V1
|- fcdata_zh_test_luban.jsonl # 259 自有采集生成的測試數據 luban</code></pre><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_7"></span><h2><span>3.<span>&nbsp;</span></span><span style="color:#000000">評測設置</span></h2><span id="OSC_h3_8"></span><h3><span>3.1.<span>&nbsp;</span></span><span style="color:#000000">評測模型</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">一期我們選取了比較熱門的不同參數大小、不同機構發佈的通用大模型和 CodeFuse 大模型，具體細節如下表。後續我們也會評測更多其他的大模型。</span></p><p style="margin-left:0; margin-right:0"><img alt="截屏 2024-01-10 15.29.03.png" src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/98756342/1704878469347-f387ec7e-4b93-4600-9f00-6b43aba426e0.png" width="1124" referrerpolicy="no-referrer"></p><span id="OSC_h3_9"></span><h3><span>3.2.<span>&nbsp;</span></span><span style="color:#000000">評測指標</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">由於一般通用模型無法具備工具調用的能力，因此在進行 Tool Learn-Eval 評測之前需要對通用模型進行微調，先讓模型學會工具使用的基本範式</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#000000">下面，我們定義了幾種評估工具使用的指標：</span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000"><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/e4f3eb9ec0085945e108c444bd8744d4.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000"><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/c00744c5d702dc52dd785c699051efe0.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000"><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/329076d813a344136a96bf6f06ad6e41.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000"><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/0bc2c431ba13d7463377259786f2f8b1.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000"><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/e1c18467331bc0bd1d2d7bf1ea6c4a4c.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#000000"><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/2aeea17ffa6d1d6e8ae8275cbc63de33.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000">②③④⑤的和為 1，代表工具調用失敗的總數，⑤工具幻覺是工具名識別失敗的一種特殊情況</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span>在此基礎上，我們提供了一個相應的評測腳本，具體評測過程歡迎到 Github 項目中進一步瞭解。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_10"></span><h2><span>4.<span>&nbsp;</span></span><span style="color:#000000">評測結果</span></h2><span id="OSC_h3_11"></span><h3><span>4.1.<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-devops-eval%23-leaderboard" target="_blank" rel="nofollow"><span>🏆</span></a><span style="color:#1f2328"><span>&nbsp;</span>fcdata_luban_zh 數據集評測</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">如下圖所示，在 fcdata_luban_zh 的評測結果中，不同模型在指令微調後 function call 能力存在一定的分化現象。Qwen-14B-Chat 在工具調用準確率 fccr 和 aar 的得分最高，説明通過 Qwen-14B-Chat 遵循指令微調的能力最好，同時也可以看到 Qwen-7b-chat 的 fccr 也基本與 Qwen-14b-chat 持平。Internlm-7B-Base 評分較低相對其它模型的指令微調能力較弱。從總體上來看，各模型經過 FunctionCall 的訓練數據微調後，分數區分度不大。</span></p><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/14156567/1702348998847-95a5ff09-da9b-496e-b3fd-5475ed2f0fed.png" width="1461" referrerpolicy="no-referrer"></p><span id="OSC_h3_12"></span><h3><span>4.2.<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-devops-eval%23-leaderboard" target="_blank" rel="nofollow"><span>🏆</span></a><span style="color:#1f2328"><span>&nbsp;</span></span><strong><span>fcdata_zh</span></strong><span style="color:#1f2328">數據集評測</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">如下圖所示，在 fcdata_zh 的評測結果中，不同模型在指令微調後 function call 能力不存在太大差異。同時也可以看到在 fcdata_zh 數據集上的 arr 評分相較於 luban 數據集有較大的提升，可能是 luban 評測集表述上與整體訓練集上的回答存在較大差異，模型無法做出與 luban 數據匹配的合理回答。最好的 aar 得分模型分別是 CodeLLaMa 和 CodeFuse-7b-16k，而 CodeFuse-7b-16k 比 4k 要好也説明長 Token 模型擁有對工具進行總結的更優能力。</span></p><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/14156567/1702348993031-375fb821-ec90-49e8-99aa-77e04075676f.png" width="1461" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_13"></span><h2><span>5.<span>&nbsp;</span></span><span style="color:#000000">未來展望</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#000000">Tool Learning 現在已然成為大模型領域的研究熱點，大模型與 Tool Learning 能碰撞出什麼火花也是當前行業內最關心的話題。未來我們將持續對 ToolLearning-Eval 項目進行優化，主要優化方向包括以下幾點：</span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000">1）不斷優化評測數據集：</span></p><ul><li><ul><li><span style="color:#000000">目前 ToolLearning-Eval 已涵蓋日常領域常見的工具集合，後續將繼續增加不同領域的 Tool 集合，直至覆蓋全領域的所有智能化任務；</span></li><li><span style="color:#000000">Tool Learning 的數據質量決定了模型掌握工具學習範式的上限，後面將通過更完善的數據構造方法和人工評測手段來生成更高質量的數據</span></li></ul></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#000000">2）拓展多工具多輪對話數據集：</span></p><ul><li><ul><li><span style="color:#000000">當前工具評測任務僅限於單工具的評測，對於不同類別之間的數據量存在較大差異，需要持續補充數據集，平衡各類別的數據量；</span></li></ul></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#000000">3）持續增加評測模型：</span></p><ul><li><ul><li><span style="color:#000000">一期主要評測了一些主流的、規模不是很大的開源模型，後續將覆蓋更多的模型，並重點跟蹤評測面向相關領域的大模型。</span></li></ul></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#000000">希望大家一起來共建 ToolLearning-Eval，期待在大家的努力下，建立更準確、更全面的 ToolLearning 領域大模型評測體系，推動 ToolLearning 領域大模型技術的不斷髮展與創新。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_14"></span><h2><span>6.<span>&nbsp;</span></span><strong><span style="color:#000000">聯繫我們</span></strong></h2><p style="margin-left:0; margin-right:0"><span style="color:rgba(0, 0, 0, 0.9)">歡迎使用&amp;討論&amp;共建</span><br><span>（1）Eval - DevOps 領域 LLM 行業標準評測：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-devops-eval" target="_blank" rel="nofollow"><span>https://github.com/codefuse-ai/codefuse-devops-eval</span></a><br><span>（2）ChatBot - 開箱即用的 DevOps 智能助手：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-chatbot" target="_blank" rel="nofollow"><span>https://github.com/codefuse-ai/codefuse-chatbot</span></a><br><span>（3）Model - DevOps 領域專屬大模型：</span><span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-DevOps-Model" target="_blank" rel="nofollow">https://github.com/codefuse-ai/CodeFuse-DevOps-Model</a><br> &nbsp;&nbsp;</span><span>(4) CodeFuse 官網：<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcodefuse.alipay.com%2Fwelcome%2Fproduct" target="_blank" rel="nofollow"><span>https://codefuse.alipay.com</span></a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 11:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6942768/blog/10759392</guid>
            <link>https://my.oschina.net/u/6942768/blog/10759392</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[袁進輝新公司再獲王慧文等 5000 萬投資]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#000000">硅基流動（SiliconFlow) <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FW0SAITjjpiJItGe4dYvMCQ" target="_blank">宣佈</a></span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">於近日完成 5000 萬元天使輪融資。本輪融資由創新工場領投，耀途資本、奇績創壇以及王慧文等科技界知名人士跟投，華興資本擔任獨家財務顧問；</span><span style="background-color:#ffffff; color:#000000">投後估值為數億元人民幣。</span></p><p><span style="background-color:#ffffff; color:#000000">硅基流動是</span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">一流科技（OneFlow）</span><span style="background-color:#ffffff; color:#000000">創始人、光年之外聯合創始人袁進輝於 </span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">2023 年 8 月</span><span style="background-color:#ffffff; color:#000000">成立的一個新公司，</span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">致力於打造大模型時代的 AI 基礎設施（AI Infra），降低大模型應用成本和開發門檻，加速 AGI 普惠人類。</span></p><p><img height="283" src="https://oscimg.oschina.net/oscnet/up-21d1e3f3e5cd348650171057db95e4847a6.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#000000">袁進輝在接受《晚點 LatePost》採訪時表示，</span><span><span style="color:#000000">新公司延續 OneFlow 的方向，做 AI Infra（AI 基礎設施）層中的 「框架」。</span></span></p><div style="text-align:start"><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">AI 框架介於算力層和模型層之間，是一種系統軟件，就像電腦操作系統能使普通用户直接用鼠標和鍵盤操作應用，AI 框架能幫開發者簡單方便地設計模型或使用模型，而無需操心底層算力資源的調配。</span></span></p></div><div style="text-align:start"><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">不同的是，OneFlow 當年以通用訓練框架為主，服務深度模型的生產；硅基流動則專注做推理框架，服務大模型的應用。</span></span></p></div><div style="text-align:start"><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">袁進輝認為，服務大模型應用比服務大模型生產更容易做出標準化產品，市場空間也大得多：模型生產是階段性的，且由少數公司主導；大模型應用則會遍佈各行各業、無處不在，被各種行業和規模的企業需要。</span></span></p></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 10:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275107</guid>
            <link>https://www.oschina.net/news/275107</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[重慶大學 | 面向 RISC-V 架構的 AI 開發框架構建與優化大賽宣講會成功舉辦]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">1 月 10 日，</span><strong>面向 RISC-V 架構的 AI 開發框架構建與優化大賽第八場宣講會</strong><span style="color:#000000">在</span><strong>重慶大學</strong><span style="color:#000000">舉行，重慶大學國家卓越工程師學院副院長劉凱、計算機學院副院長鍾將、助理教授李榮振、助理教授李楚昭，openKylin 社區秘書長餘傑博士、技術委員會委員王文竹博士</span><span style="color:#000000">參與活動。本次宣講會旨在進一步加深同學們對大賽的瞭解，鼓勵和動員更多同學參與到比賽中來。</span></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-e2ac0aa8c27173ea72ce9d177d889d9b978.jpg" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000"><span style="color:#000000">宣講會上，openKylin 社區技術委員會委員王文竹</span><span style="color:#000000">圍繞大賽概述、賽道設置、賽程安排、參賽要求等方面向同學們介紹了面向 RISC-V 架構的 AI 開發框架構建與優化大賽</span><span style="color:#000000">，並向同學們講解介紹了一系列</span><span style="color:#000000">實踐案例</span><span style="color:#000000">，幫助同學解讀賽題，理清參賽思路，鼓勵同學們積極參與報名。</span></span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000"><span style="color:#000000"><span style="color:#000000">希望通過</span><span style="color:#000000">此次宣講會，能夠</span><span style="color:#000000">幫助同學們更好地瞭解面向 RISC-V 架構的 AI 開發框架構建與優化大賽的相關內容和參賽規則，激發同學們的參賽熱情。</span></span></span></p><p><strong>關於大賽</strong></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">面向 RISC-V 架構的 AI 開發框架構建與優化大賽是開放原子開源大賽設立的賽道，由 openKylin 社區、麒麟軟件有限公司承辦，國防科技大學、信創海河實驗室協辦，玄鐵、北京算能科技有限公司、廣東賽昉科技有限公司贊助。通過本項賽事，旨在探索如何將人工智能技術與 RISC-V 架構相結合，以實現高性能和低功耗的目標。各相關單位、高校、個人等均可免費報名參賽，目前正在火熱報名中~</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 09:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275095</guid>
            <link>https://www.oschina.net/news/275095</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Atuin 作者宣佈辭職，全職從事開源項目]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">流行的 Shell 歷史記錄管理工具 Atuin 作者 Ellie Huxtable 於近日發文<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fellie.wtf%2Fposts%2Fi-quit-my-job-to-work-full-time-on-my-open-source-project" target="_blank">宣佈</a>，已經在 2023 年 12 月 22 日辭去了 PostHog 基礎設施團隊的領導工作。接下來，她將成立一家公司，全職服務於 Atuin 項目。</span></p><p><span style="color:#000000">「Atuin 將繼續開源並以當前形式作為自託管工具免費提供。通過全職運營，我希望可以專注於為高級用户添加新的高級託管功能，並開始支持商業用途。」</span></p><p><span style="color:#000000">Atuin 是一款可跨設備同步的 Shell 歷史記錄工具。可使用 SQLite 數據庫取代你現有的 shell 歷史，併為你的命令記錄額外的內容。此外，它還通過 Atuin 服務器，在機器之間提供可選的、完全加密的歷史記錄同步功能。</span></p><p><span style="color:#000000"><img alt="" height="222" src="https://oscimg.oschina.net/oscnet/up-204accc133a02e4d3372505f70244790d01.webp" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><img alt="" height="222" src="https://oscimg.oschina.net/oscnet/up-ff8b1563ecf919bb0341a800b897e2de8d4.webp" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">Ellie 表示，促使她作出這一決定的原因是她開始意識到，付出與收穫是成正比的。因為受工作牽絆，她只能在在上班前抽空處理 Atuin 上的問題；但即便如此，很多時候甚至連公開的 PR 和 issue 都沒時間處理，遑論開發需要的新 features/fixes。</span></p><p><span style="color:#000000">久而久之，她感覺自己與 Atuin 之間已經漸行漸遠。在這一過程中，她的朋友 Conrad 也退出了項目的維護工作。</span></p><blockquote><p><span style="color:#000000">我覺得自己在辜負項目的期望，忽略了自己的社交生活，並且在工作中極力避免分心。</span></p><p><span style="color:#000000">為了按照我的意願發展這個項目，我需要在全職工作的同時投入更多的時間。</span></p><p><span style="color:#000000">所以，我正在創辦一家公司，全職開發 Atuin。</span></p><p><span style="color:#000000">我一直想經營自己的公司，這幾乎是我一生的夢想。但我不想為了創業而創業。我想做一些人們喜歡的、有用的東西。</span></p></blockquote><p><span style="color:#000000">談到資金問題，Ellie 則表示一直在自掏腰包運行 Atuin 服務器；「雖然數額不是很大，但也不小」。直至 2022 年底，她在朋友建議下開通了&nbsp;GitHub 贊助渠道，並收穫了意料之外的金額 ——&nbsp;足夠支付服務器費用，並抵消她迄今為止所支付的部分費用。</span></p><p><span style="color:#000000">但有一個弊端是，她需要經常提及贊助渠道的存在，否則就容易被遺忘。「這讓我感到很奇怪，因為這感覺就像是在乞討」。而有着與她相同感受的開發者並不在少數。因此，Ellie 引用了&nbsp;Sidekiq 創建者 Mike Perham 的兩句話：</span></p><blockquote><p><span style="color:#000000">「最終，OSS 的倦怠將扼殺任何具有吸引力的免費項目」</span></p><p><span style="color:#000000">「如果你創造了一些有價值的東西，那就為它收費」</span></p></blockquote><p><span style="color:#000000">展望未來，Ellie 希望能在現有功能的基礎上，開發出一些有價值的商業功能。同時將&nbsp;Atuin 發展到可以傳承下去的地步，並對一些提供過幫助的項目和人提供資助。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 08:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275092/atuin-full-time-on-open-source-project</guid>
            <link>https://www.oschina.net/news/275092/atuin-full-time-on-open-source-project</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Sealos：在公有云和私有云之間，我選擇第三條路]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span style="color:#494949"><span style="background-color:#ffffff"><span style="background-color:#ffffff">【創造者説】&nbsp;Created in the name of FOSS.</span></span></span></p><p style="text-align:center"><img height="450" src="https://oscimg.oschina.net/oscnet/up-aeccf4cfa39fbccb3b91bcb94207696b175.png" width="1080" referrerpolicy="no-referrer"></p><p>前段時間，上雲和下雲的爭議如火如荼，公有云的價格、安全和透明度備受拷問，私有云的服務、維護成本又深受質疑。就在雙方互掐不分上下的時候，一個新項目引起了我們的注意——Sealos，一個雲操作系統，在公有云和私有云之間，他選擇了第三條路——把公有云私有云抽象到一起。</p><p>Sealos 的作者方海濤，曾在訊飛擔任容器平台負責人，後來在阿里雲負責雲原生集成平台，主導了 sealer 項目並捐獻給 CNCF 社區。他覺得自己「骨子裏就是個創業者」，早在 2016 年就開始了第一次創業，可惜沒成。Sealos 每年翻倍的發展速度，讓他看到了新的希望。拿到奇績創壇的投資後，他火速拉上自己的老朋友和同事，出來成立了環界雲計算公司。產品 Sealos 自從 2023 年 6 月份上線以來，<strong>僅半年時間註冊用户已經突破 8 萬，月收入超過 30w。</strong></p><p>方海濤認為，現在的公有云和私有云雖然吵得兇，但其實各有各的問題，也各有各的適用場景，脱離場景談優勢毫無意義。他認為，公有云和私有云並無本質區別，都是連接計算資源，<strong>可以做個</strong><strong>像安卓一樣好用的雲</strong><strong>操作系統</strong><strong>，誰要用雲就裝一個就行</strong>。而現在，這個想法實現了。</p><p>&nbsp;</p><span id="OSC_h1_1"></span><h1>01 創業的齒輪重新轉動</h1><p>第一次創業失敗後，方海濤迴歸了單純的程序員身份。一天晚上，為瞭解決 K8s 早期版本的安裝和高可用等問題，方海濤把自己寫的一個安裝腳本放在了阿里雲市場上，命名為「 kubeinit 」，15 塊錢一份。沒想到的是，還真有人買。看着進賬，方海濤很興奮，彷彿看到了未來的商業帝國。可是，這第一個版本問題太多了，程序也十分複雜，方海濤不得不花了一整天時間為這位客户提供售後服務，電影院裏還在幫用户解決問題。</p><p style="text-align:center"><img height="1454" src="https://oscimg.oschina.net/oscnet/up-de8b59708266427e5953e8b36da03e20ebc.png" width="808" referrerpolicy="no-referrer"></p><p>不過，這個好開頭，讓方海濤重拾了一點創業的信心。隨着銷量暴增，方海濤也藉此換了一部新手機 iPhone 8。但不幸的是，問題也越來越多了，方海濤都抽不出時間進行售後維護。於是，他重寫了一個基於 Ansible 的 v2 版本，但 Ansible 也只是使用起來方便許多，並沒有解決根本的安裝複雜度問題，很多用户安裝失敗，尤其是在離線環境中更容易出錯，需要把 Ansible 放到 Docker 中。</p><p>為瞭解決這個問題，方海濤思考了很長時間，最後在 kube-proxy 源碼上找到了靈感。借用負載均衡器的實現方式，去掉很重的組件，使整個腳本變得簡單，於是第三個版本 Golang 解決了以往的問題，在安裝方面做到簡單極致，一條命令解決一切——這就是後來的 Sealos。</p><p>大概是眾人都苦於 K8s 安裝久矣，Sealos 口碑打開之後，在 Github 的趨勢榜上連續霸榜了一週，可見需求之旺盛。這樣出色的表現，也吸引了陸奇團隊的注意。2022 年 3 月，Sealos 獲得了陸奇團隊 200 萬的天使投資。方海濤的創業之路，也重新開啓了。</p><p>&nbsp;</p><span id="OSC_h1_2"></span><h1>02 獨樹一幟的設計</h1><p>「上雲是未來」雖已達成共識，但上的是公有云還是私有云，卻存在分歧。尤其是在今年的公有云故障事件之後，私有云的聲音也響亮了起來。畢竟，公有云乾的本就是租賃的活兒，不少軟件還是開源的，卻還賣這麼貴，難免讓用户心生「割韭菜」的懷疑。而私有云，建設成本又太高，無論是採購還是自建，花銷都少不了：採購起步上千萬，自建少説 30 人。這也是當下用户糾結的原因。有評論説得好：<strong>雲就是一座圍城，外面的人想進去，裏面的人想出來。</strong></p><p>不過面對這種 A or B 的難題，Sealos 卻選擇了第三條路：把公有云和私有云抽象到一起，集公有云的彈性、敏捷和私有云的安全可控於一身，同時再把價格給打下去。</p><p>還有這種好事？</p><p>怎麼做到的？</p><p><strong>Sealos 將 Kubernetes 作為 「雲內核」，基於這個雲內核做一個可以運行在多台服務器上的雲</strong><strong>操作系統</strong><strong>發行版，系統之上 「一切皆應用」。最終可以把整個數據中心所有服務器變成一台 「邏輯計算機」，讓用雲變得像用 PC 一樣簡單：</strong></p><p style="text-align:center"><img height="1974" src="https://oscimg.oschina.net/oscnet/up-1e1316ef681c726943f82545a53d490dd1f.png" width="3840" referrerpolicy="no-referrer"></p><p><strong>雲的架構也從傳統的 </strong><strong>IaaS</strong><strong>、</strong><strong>PaaS</strong><strong>、SaaS 三層架構，轉向以 Kubernetes 為雲內核的新架構：</strong></p><p style="text-align:center"><img height="590" src="https://oscimg.oschina.net/oscnet/up-be50dc03448ab6ce8c8b0188df4657401ce.png" width="1060" referrerpolicy="no-referrer"></p><p>最終，Sealos 和 Kubernetes 之間的關係，就像 Red Hat 和 Linux 內核之間的關係，只不過與單機操作系統的區別是，Sealos 是裝在整個數據中心的，Sealos 上跑的也不是 QQ 微信這些單機應用，而是開發者需要用到的各種分佈式應用。有了 Sealos，整個數據中心就不再是一台一台孤立的服務器，而是一個整體，變成一台超級邏輯計算機。這個時候再去用雲，就像是在用一台服務器一樣簡單。</p><p><strong>哪家企業需要用雲，就直接裝一個雲</strong><strong>操作系統</strong><strong>就搞定了。</strong></p><p>在方海濤看來，雲計算的本質在於將計算資源（包括硬件、軟件和網絡等）通過互聯網等方式提供給用户使用，連接單個數據中心的算力資源只給自己用就是私有云，通過公網讓大家都能用就是公有云。至於功能上，公有云能做到的理論上私有云都能做到，並無本質區別。未來，公有云和私有云也許會走到一起，變成同一個東西。</p><p>在 Sealos 的設計中，也處處秉承了這樣的理念。公有云與私有云是同一套代碼，同一個抽象，只是配置與安裝的應用不同，運行在企業自己機房就是私有云，對公網提供服務就是公有云。</p><p>兩邊的用户一手抓了。</p><p>這樣的設計還使得 Sealos 簡潔又簡單，避免了傳統用雲的「屎山」體驗。</p><p><strong>而在高度抽象的架構下，一切具體能力都通過應用去擴展。</strong>用户需要啥就裝啥，不要就卸掉，自由靈活，雲操作系統也不會隨着軟件功能的增加而增加複雜度。這樣，不管懂不懂 Kubernetes 都能愉快地使用 Sealos 了，雲原生專家可以打開終端敲各種原生命令，DBA 也可以直接使用數據庫應用，極其靈活。</p><p>「用户需要關心 Kubernetes 嗎？其實不需要。我們只要想辦法把用户最終需要的應用直接交付給用户就行了，就像你去用 Linux 的時候你很少關心 Kernel 一樣，雲也是一樣的道理，開發者需要用到的能力才是最重要的，未來沒有多少人需要再去關心這個內核了。」方海濤説。</p><p>&nbsp;</p><span id="OSC_h1_3"></span><h1>03 學習 Linux，成為 Linux</h1><p>在 Sealos 的成長過程中，不難發現，很多產品思路都學習了 Linux。在採訪過程中，方海濤也對 Linux 極為推崇。他認為，Linux 簡單易用，運行穩定，幾乎不用投入太高成本，也基本不需要定製化開發。而 Openstack 專業人士三天都不一定能裝起來，還得改一堆代碼才能用，實在是太複雜了，不應該成為私有云的代表。Linux 才是學習的榜樣。</p><p>「Linux 在哪裏用都是同一個 Linux，雲也應該這樣。否則一味地堆積很多亂七八糟的東西進來，變成一個大雜燴，那 Sealos 只會變成又一個失敗的 PaaS 平台。」方海濤説。</p><p><strong>Sealos 目前只有一套</strong><strong>開源</strong><strong>代碼，哪個版本都一樣，沒有分支</strong>。而它能得到眾多開發者的歡迎，也是因為它像 Linux 一樣低成本、易用和標準化。</p><p>「其實雲都是大差不差的，Sealos 能解決的問題，其他的雲基本上也能解決。但 Sealos 現在這麼受歡迎，就在於它的易用性。」方海濤介紹，「同樣的事情，如果放在 Sealos，K8s 集羣已經有了，只需點一下按鈕 CBT 就能起來。但是如果基於虛擬機去搭的話，你可能需要搞後端的數據庫，再去搭建負載均衡，去搞備份恢復等等，才能把整套東西搞起來。成本差異就在這。」</p><p>在運維方面，Sealos 也很穩定。「在我們的理念中，不應該有運維這種角色的存在，整個系統是自運維的，就像 PC 操作系統運行起來很少發生問題的。」</p><p style="text-align:left">而且 Sealos 最小隻有 300M，企業裝了 Sealos 便能在各種環境中擁有完全屬於自己的雲。</p><p>「另外，Sealos 有標準化的應用市場。很多人需要的其實只是上層的應用，我們把這些應用封裝好，直接給到他們去用就行了。一些雲廠商可能也有類似的 Marketplace，可是這些 Marketplace 缺乏標準，軟件的生產者跟消費者之間協作就很麻煩。我們以雲操作系統的思維，在做這個事情的時候，我們會 follow 雲原生生態的事實標準，讓軟件的生產者和消費者連接起來，相互協作，達成良性循環。」</p><p style="text-align:left">這種以操作系統的思維來做雲最終也會改變生產關係，讓雲的生態可以像安卓生態一樣，不再是單一廠商來提供雲應用，而是形成多對多的網狀協作關係。</p><p>&nbsp;</p><span id="OSC_h1_4"></span><h1>04 神奇的項目：開源、商業不分家</h1><p>截至目前，Sealos 在 Github 上已經擁有了 12000+的 star。良好的羣眾基礎，也給 Sealos 打開了一條絲滑的商業化道路。</p><p>跟別的開源項目不同，Sealos 並沒有走「先開源，後收費」的路子，而是從誕生起，就開始收費了。最早期時是賣安裝包，代碼開源但是安裝包收費，如果用户自己根據源碼去構建安裝包可能需要一週時間，而花 50-168 元就可以立馬下載，所以賣了很多，裝機量超過 150 萬次。</p><p>出來創業之後，Sealos 也開始了正式的商業化。目前主要的商業模式有兩大塊：公有云和私有云。<strong>但有意思的是，</strong><strong>不管是標準版還是商業版</strong><strong>，不管是公有云還是私有云，Sealos 都只有一套代碼。開源和商業化不分家。</strong>那 Sealos 是怎麼盈利的呢？</p><p>公有云很簡單，打開瀏覽器，註冊登錄充值就可以用，按量計費。但真正的盈利點是：<strong>雲服務</strong><strong>。</strong></p><p>「很多做開源項目的公司都會有這樣的困惑：開源做得太好，用户就不付錢了？為瞭解決這個問題，很多公司就會做兩個版本，一個是開源版，功能少一點；一個是商業版，放一些很強的功能。我就非常不喜歡這樣的做法。因為維護兩個版本是很累的事，每次都需要考慮哪些東西合併企業版，哪些東西不合並，時間一久兩個版本就直接分叉了，後面直接索性開源版不投入了，這種方式很彆扭，不高級。</p><p>我喜歡把所有的好東西都開源出去，讓開源和商業化儘可能形成合力。那怎麼規避'開源做得足夠好之後，用户不願意掏錢'這個問題？很簡單——雲服務。」方海濤説。</p><p style="text-align:left">即便 Sealos 的開源做得非常完美，用户搭建的時候還是需要掏錢買虛擬機。既然這樣，不如直接把這個錢充值給 Sealos。「本質上是成本轉移，但是這種模式對三方都好。」對用户來説：</p><ul><li><p><strong>使用上更簡單可以打開瀏覽器直接用，省去自己搭建。</strong></p></li><li><p><strong>專門的團隊維護肯定比自己維護專業。</strong></p></li><li><p><strong>用户一多每個用户成本會下降，花錢更少。</strong></p></li><li><p><strong>持續升級更新。</strong></p></li></ul><p>因此，公有云的用户，有非常大的可能性會使用雲服務。用户在 Sealos 上花的錢多了，但需要支出的總成本很可能還降低了。Sealos 也獲得了更多的資金去做新功能，擴大規模效應。</p><p>另一個商業模式就是私有云。有些用户買了服務器放在自己機房，這時候 Sealos 就延續了一開始的商業模式，但不是收安裝包的下載費用，而是在 Sealos 內部實現了計量系統，按量計費，賬户餘額用完了就得充值了。</p><p>這種方式實現了公有云和私有云計費方式的完全統一，順便一起解決了企業內部人員配額問題。針對大小不同的客户都有合理的價格，不會出現小客用不起，大客不敢用的情況。</p><p>至於這樣收費會不會讓用户反感？</p><p>「我還是覺得提供價值合理收費天經地義，原則也是儘可能找到<strong>讓客户與項目整體利益最大化的點</strong>，收費貴了傷害了用户利益，收費便宜了我們沒法快速前進，要平衡好這中間的利益關係，是個矛盾統一體。現在這種商業模式，能夠讓開源和商業化形成合力，我們也能放心大膽地投入，把開源做好，而不會有擔心用户不付費的顧慮。」方海濤説。</p><p>&nbsp;</p><span id="OSC_h1_5"></span><h1>05 像開源模式的商業團隊</h1><p>Sealos 不僅產品有趣，背後的團隊也很有意思。</p><p>如今的環界雲只有 21 個人，其中 20 個人都是寫代碼的，包括方海濤自己。即使是運營，也是技術出身。除了在商務方面分工明確一點，其餘時候，環界雲更像一個開源社區，每個人都在為這個開源項目貢獻代碼，只是負責的模塊不同。這種去中心化的開源協作方式一直順利運行至今，其中一個很重要的原因是：環界雲不太依賴銷售，大部分的客户都是自己主動找上門的，因此整個團隊得以單純地搞技術，少了很多傳統企業的條條框框。</p><p>當然，這種「人在家中坐，錢從天上來」的舒坦，離不開開源本身給項目帶來的流量。Sealos 在社區裏的好口碑和高知名度，已經成為了環界雲最大的獲客點。目前的數據顯示，高達 90% 的收入都是來自於社區裏這些主動找來的客户。因為他們是主動來尋求解決方案的，因此這也意味着他們對產品的接受度和成交率都相對較高。</p><p>目前，除了 Sealos 之外，環界雲還孵化出了兩個爆款開源項目：Laf 和 FastGPT。Laf 是個函數計算平台，可以在線直接寫代碼，至今已有 6000 的 star。FastGPT 是個基於 LLM 大模型的 AI 知識庫問答平台，把企業內部的私有化數據跟大模型結合，能變成企業內部的智能問答系統，目前已有 8000+的 star。</p><p style="text-align:center"><img height="184" src="https://oscimg.oschina.net/oscnet/up-f83ed0b7f4872bb32ae1a977145bcbda30b.png" width="438" referrerpolicy="no-referrer"></p><p style="text-align:left">Laf 和 FastGPT 為 Sealos 提供了豐富的應用，FastGPT 和 Laf 之間相互提供了 AI 自動編碼能力和插件開發能力，Sealos 則為 Laf 提供擴展、使 FastGPT 得以運行。三個產品相互補充，緊密協同，已形成了一個完整的生態系統。</p><p><strong>三個產品上線半年，環界雲計算已累計 8.4 萬的註冊用户，且擁有 10% 的付費率和超過 70% 的續費率。更難能可貴的是，Sealos 和 Laf 已成功支撐了多款百萬註冊用户級別的應用，其運行成本僅為傳統</strong><strong>雲服務</strong><strong>的 1/20。</strong></p><p>Laf 的作者王福根和 FastGPT 的作者餘金隆，都是方海濤的創業合夥人。我們發現，環界雲招募團隊成員和社區貢獻者的方式沒什麼區別，都是按照招募合夥人的方式招的。</p><p>Sealos 的一位開發主力+長期貢獻者，原是 Sealos 的用户。當時方海濤做了一個「分享有獎」的活動推廣 Sealos，他給社區掙了 100 塊，方海濤卻獎勵他 1500，他覺得這個社區好生奇怪，於是就留了下來。方海濤則認為，一個開源項目背後沒有商業化支撐，會走得很慢。而且，開源的貢獻者也理應得到回報。於是，為了吸引開源社區，方海濤專門寫了一個激勵系統，來回饋社區的項目貢獻者：當需求被合併完了之後，錢就會自動打到貢獻者的支付寶賬户裏面。這一傳統也保留到了現在。</p><p>「那個時候在項目掙到的錢幾乎都回饋到社區了。要麼給開發者了，要麼買服務器提供更好的體驗了。」方海濤説，「但我覺得這是挺好玩的一件事情，這個模式形成了一種良性循環，這樣項目就會滾滾向前，其實非常好。」</p><p style="text-align:center"><img height="1125" src="https://oscimg.oschina.net/oscnet/up-0fed2c5356b827e053d2ce179e81c714791.png" width="1500" referrerpolicy="no-referrer"></p><p style="text-align:center"><span style="color:#999999">環界雲計算團隊</span></p><p>&nbsp;</p><span id="OSC_h1_6"></span><h1>06 小項目準備挑戰大考驗</h1><p>目前，Sealos 社區用户 10 萬+，不乏各種大企業。</p><p style="text-align:center"><img height="1855" src="https://oscimg.oschina.net/oscnet/up-1be0d9a7470266e6fbb03554af9e5903e0c.png" width="2000" referrerpolicy="no-referrer"></p><p>上線兩個月時間註冊用户就已破萬，雲服務共計運行 7000+應用。</p><p>應用的類型也很多，GPT 相關的、大模型、遊戲、企業官網和業務系統等等，不一而足。</p><p>但 Sealos 的宏圖不止於此，它的目標是進化為一款無所不在的雲操作系統，為人們提供如同使用個人電腦般簡易的雲服務體驗。</p><p>方海濤透露，接下來，Sealos 會有兩個進化方向：</p><p>一個是產品的穩定性。因為雲本質上是一個信任問題。如果產品不穩定，那用户一定不會深度使用，可能就淺嘗輒止一下，或者把一些不重要的東西如博客論壇等等往裏放。Sealos 剛上線的時候，都是開發者在用，頂多充個十塊二十塊的。但經過時間的積累，市場上認可了 Sealos 的穩定性之後，慢慢地有企業進來使用，充值數額也上去了。所以説，產品的穩定性才是核心。</p><p>但是，想把穩定性建設得足夠好，其實是有一定挑戰的，尤其是達到了一定規模之後。「我舉個例子，現在市面上幾乎所有的雲原生網關都不能滿足我們的需求，幾乎都被我們打爆了。這個時候就需要我們去建設網關，把魯棒性搞得更強。或者挑一個上下游的開源社區，幫他們做優化，一起變得更好。」方海濤説。</p><p>第二個要做的就是生態建設。「現在已經有不少的應用支持容器和 Kubernetes 了，那首先要做的就是把它們上架到我們的應用市場，拓展應用的寬度跟深度，再把 deploy on Sealos 反饋到社區。這種跟上下游開源項目之間的合作，大家都挺歡迎的。因為一方面 Sealos 有龐大的用户流量，可以給這個開源項目導流。另一方面，這個開源項目也可以為 Sealos 導流，所以是個完全互利互惠的事情。」</p><p>路漫漫其修遠兮，這個小項目未來會如何，讓我們拭目以待吧。</p><div><hr><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span><span style="background-color:#ffffff"><span><strong><strong><span><span style="background-color:#ffffff"><span><span style="color:#27ae60"><span><strong><span><span>【創造者説】</span></span></strong></span></span></span></span></span></strong></strong></span></span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span><span style="background-color:#ffffff"><span><span><span>OSCHINA 全新開源創企訪談欄目【創造者説】。</span></span></span></span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span><span style="background-color:#ffffff"><span><span><span>開源社區需要創造者，他可以是個人，也可以是由個人組成的公司。開源軟件發展 20 餘年，來自公司的開源貢獻者已經成為中堅力量，更是有一批公司圍繞開源軟件而創辦。本欄目將聚焦開源創企和他們的創始人，探討當下的開源現狀，分享開源商業故事，為開源社區添磚加瓦。</span></span></span></span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="background-color:#ffffff; color:#333333">往期回顧：</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><a href="https://my.oschina.net/oscpyaqxylk/blog/5578009" target="_blank">一個技術人 「誤入歧途」，做了個向量數據庫新物種</a></p></div><div><p style="margin-left:0px; margin-right:0px; text-align:start"><a href="https://my.oschina.net/oscpyaqxylk/blog/5548404" target="_blank">90 後，辭職創業，説要卷死雲數據庫</a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 08:24:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6852546/blog/10758980</guid>
            <link>https://my.oschina.net/u/6852546/blog/10758980</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[網易有道 Qanything 開源：探索個性化問答的新紀元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong>網易有道最新開源力作：QAnything 引擎。</strong>是基於 RAG（Retrieval Augmentated Generation) 的引擎，可以用於建立本地知識庫做問答，解鎖本土 ChatGPT 般的問答體驗。☝</p><p><strong>「QAynthing」<strong>是一個成熟的系統，有着準確率高、速度快、純離線，易於使用（一鍵部署），佔用資源小</strong>（只要 16G 顯存即可）的特點。</strong></p><p>目前，<strong>「QAynthing」</strong>已經在有道的多個產品中落地應用，包括有道詞典的文檔問答，有道速讀，以及有道課程業務（高中、少兒圍棋等）的客服系統等，在有道合作的 2B 客户的場景中已經落地應用。</p><p>&nbsp;<img alt="" src="https://oscimg.oschina.net/oscnet/up-3a44e1a3842061c69c8d841262c86d5ea68.png" referrerpolicy="no-referrer"></p><p>chatgpt 的大模型能力很強，但其訓練耗時很長，無法利用用户的私有數據，且有胡亂編造的幻覺問題。</p><p><strong><strong>與 ChatGPT 相比，<strong><strong><strong><strong>有道自研的</strong></strong></strong></strong>「<strong><strong><strong><strong>Q</strong></strong></strong></strong>Aynthing</strong>」有自己的突出優勢。</strong>它能夠快速塞入各種格式的文檔，如 doc、ppt、excel、圖片、pdf 等，系統將在很短的時間內對這些文檔進行處理並根據語義建立知識庫，用户可以基於這樣的知識庫做各種問答。系統將理解用户的意圖，在全庫中尋找相關的內容，理解、提取用户關心的要點，並加以總結後呈現給用户。</p><p>&nbsp;<img alt="" src="https://oscimg.oschina.net/oscnet/up-28dd89cb825ae0ca3ded8dd7b632f332405.png" referrerpolicy="no-referrer"></p><p><strong>「QAynthing」</strong>包含的模型和系統代碼，我們都全面開源了。此次開源還包含了一個應用系統，用户可以通過前端頁面上傳文檔，直接使用。也可以通過我們提供的 API 接口做二次開發，搭建諸如智能客服等應用。用户直接一鍵下載我們的代碼和模型即可開始使用。</p><p>&nbsp;</p><p>&nbsp;&nbsp;<img alt="" height="500" src="https://oscimg.oschina.net/oscnet/up-b05477f7eac27220217144c83707d9f1048.png" width="1000" referrerpolicy="no-referrer"></p><p><strong><strong>在模型部分</strong></strong>，我們開源了有道自研的 BCE embedding 和 rerank，用來做語義檢索和相關性排序。得益於有道在翻譯領域的積累，有道自研的 embedding/rerank 模型在跨語種場景下表現尤其好。比如知識庫的文檔有中文、英文混合語種的內容，當用中文去問問題的時候，我們能夠很好的檢索出英文內容。目前所有的開源 embedding 模型都忽略了跨語種檢索的問題，在跨語種上表現不佳。此外，開源的 embedding 很多時候忽略了 RAG 的問題，只是單純追求語義相似。<strong>而<strong>我們的 embedding 和 rerank 模型專門針對 RAG 的場景做了訓練，所以有着更高的準確率</strong></strong>。</p><p><img alt="" height="456" src="https://oscimg.oschina.net/oscnet/up-c8fb3f4f844d6a2d5ac3608bae03fc309f2.png" width="1000" referrerpolicy="no-referrer"></p><p>在<strong><strong>系統部分</strong></strong>，我們對文檔的解析、切片、建庫、embedding/LLM 的推理做了大量的優化，具有<strong><strong>穩定、速度快、易於安裝</strong></strong>使用的特點。</p><p><strong><strong>目前該項目還處於<strong><strong><strong><strong>不斷迭代的階段</strong></strong></strong></strong>，<strong><strong><strong><strong>歡迎大家參與開發，並給予</strong></strong></strong></strong>我們更多反饋</strong></strong>。</p><p>官網地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fnetease-youdao%2FQAnything" target="_blank"><u>https://github.com/netease-youdao/QAnything</u></a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 06:39:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/youdaotech/blog/10739178</guid>
            <link>https://my.oschina.net/youdaotech/blog/10739178</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[中文 JDK 教程網站正式上線，助力開發者掌握 Java 編程語言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#d1d5db; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">為了滿足日益增長的 Java 開發者學習需求，對官方英文文檔理解困難，致力於提供優質編程教育的網站《存在碼》宣佈推出全新的中文 JDK 教程網站。這一網站的上線標誌着學習 Java 編程語言的全新起點，為開發者們提供了豐富而易於理解的學習資源。</span></p><p style="color:#d1d5db; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>網站特色：</strong></span></p><ol><li><p style="margin-left:0; margin-right:0"><strong>全面教程：</strong> 中文 JDK 教程網站提供了覆蓋 Java 各個方面的詳盡教程，旨在幫助開發者建立堅實的編程基礎。</p></li><li><p style="margin-left:0; margin-right:0"><strong>實用示例：</strong> 數百個實用的示例代碼將幫助開發者深入理解 Java 語言的概念和技巧，實踐中學習。</p></li><li><p style="margin-left:0; margin-right:0"><strong>學習路徑：</strong> 精心設計的學習路徑，從入門到精通，讓開發者能夠有系統地提升技能水平。</p></li><li><p style="margin-left:0; margin-right:0"><strong>及時更新：</strong> 網站內容將根據 Java 平台的最新發展和技術趨勢進行及時翻譯更新，確保學習者始終保持與行業同步。</p></li></ol><p style="color:#d1d5db; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>網站創始人表示：</strong>「我們創建這個網站的目標是為中文用户提供一個高質量、易於理解的 Java 教育平台。我們深知學習編程的挑戰，希望通過這個平台讓更多人輕鬆入門，深入學習 Java 編程語言。」</span></p><p style="color:#d1d5db; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">現在，開發者們可以通過訪問 </span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjava.cunzaima.cn" target="_blank">中文 JDK 教程網站</a><span style="color:#000000">開始他們的 Java 編程之旅。</span></p><p style="color:#d1d5db; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>關於中文 JDK 教程網站：</strong> 中文 JDK 教程網站是一個專注於為中文用户提供 Java 編程語言教育的在線學習平台。通過清晰易懂的教程和實用的示例代碼，我們致力於幫助開發者輕鬆學習 Java，並在編程領域取得成功。訪問我們的網站：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjava.cunzaima.cn" target="_blank"><span style="color:#2980b9">https://java.cunzaima.cn/</span></a></p><p><strong>網站截圖：</strong></p><p><img height="763" src="https://oscimg.oschina.net/oscnet/up-a4908099ab2cb02c513eecfbe99f50213fd.png" width="1050" referrerpolicy="no-referrer"></p><p><img height="852" src="https://oscimg.oschina.net/oscnet/up-2059c6f708e6ff8119fcdbb4866fa34a17c.png" width="1888" referrerpolicy="no-referrer"></p><p><img height="733" src="https://oscimg.oschina.net/oscnet/up-d84726feca2fd514680bc5a7aaf4848b0a0.png" width="1910" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 05:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275053</guid>
            <link>https://www.oschina.net/news/275053</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[上海 AI 實驗室聯合港中大（深圳）開源音頻生成平台 Amphion]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>上海人工智能實驗室（上海 AI 實驗室）與香港中文大學（深圳）聯合團隊<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FCjsutc54MgqANMtZj3pOKg" target="_blank">推出</a> AI 音頻生成平台安菲翁（Amphion）。現已開源並提供免費商用。</p><p>其不僅具備語音及歌聲合成轉換、音效及音樂生成等多種能力，更可實現轉換過程可視化，有效地降低了應用門檻，助力更廣泛的開發者進行 AI 音頻研發。</p><p>Amphion 為古希臘神話中的傳奇音樂家，傳説其彈奏的優美琴聲可讓頑石感靈。上海 AI 實驗室聯合團隊藉此為 AI 音頻生成平台命名，希望通過 AI 技術的創新為音頻領域注入全新的研究思路，開源開放，「聲」生不息。</p><p><img height="195" src="https://oscimg.oschina.net/oscnet/up-50aec28c64a629ade537a270d95c38ed10e.png" width="500" referrerpolicy="no-referrer"></p><h4><strong>集成經典模型架構，實現多項生成任務</strong></h4><p>為幫助初級開發者入門 AI 音頻生成研究並使研究過程可復現，Amphion 將當前多個經典模型架構集中於統一平台，使其可實現多項音頻生成任務。</p><p><strong>歌聲轉換 （SVC, Singing Voice Conversion）</strong></p><p>歌聲轉換是指通過 AI 技術，將一位演唱者的音色轉變為另一位演唱者。該技術涉及信號處理、機器學習、深度學習等領域。</p><p>Amphion 系統集成了經典的特徵提取模型用於 SVC 任務，包括經典的擴散模型、VITS 模型及 OpenAI 的 Whisper 模型等。基於擴散的架構使用雙向擴張 CNN 作為後端，並支持 DDPM、DDIM、PNDM 等多種採樣算法。此外，Amphion 還支持基於一致性模型的單步推理。</p><p>目前，Amphion 的特徵設計已被當前業內流行的音頻生成項目 So-VITS-SVC 5.0 借鑑。</p><p><img height="213" src="https://oscimg.oschina.net/oscnet/up-43ddb9355908a681234f663d7e8c32eb864.png" width="700" referrerpolicy="no-referrer"></p><p><strong>文生語音（TTS, Text To Speech）</strong></p><p>文生語音即輸入文字轉成相應語音的技術。當前，該模塊主要採用了深度學習技術，將文本轉換成自然流暢的高擬真度語音。在 TTS 任務模塊，Amphion 系統集成了經典 FastSpeech2 模型、VITS 模型以及 zero-shot 語音合成技術，即 Vall-E，NaturalSpeech2。</p><p><img height="196" src="https://oscimg.oschina.net/oscnet/up-34bba51d4fba3469ce72f4d2904a953e523.png" width="700" referrerpolicy="no-referrer"></p><p><strong>文生音頻（TTA, Text To Audio）</strong></p><p>文生音頻指將文字輸入轉為音樂、場景音效等特定音頻的技術。Amphion 集成了當下主流的文本驅動音頻生成模型架構，即基於 VAE Encoder、Decoder 和 Latent Diffusion 的文本驅動的音頻生成算法。在該架構下，Latent Diffusion 擴散模型以 T5 編碼後的文本為輸入，根據文本的指引生成對應的音頻效果。</p><p>文生音頻模型或將對文化創作產生積極深遠的影響，從業者或可利用此項技術，根據特定需求生成場景音效，省去從頭採集環節，提升生產效率。</p><p><img height="166" src="https://oscimg.oschina.net/oscnet/up-5675245eb7699e52230f19025f4a496385e.png" width="500" referrerpolicy="no-referrer"></p><p>聲碼器（Vocoder）是產生高質量音頻信號的重要模塊。為確保所生成音頻的高音質輸出，Amphion 集成了目前廣泛使用的神經聲碼器（Neural Vocoders），包括 BigVGAN、HiFi-GAN、DiffWave 等主流聲碼器。</p><p>技術報告顯示，Amphion 中的 HiFi-GAN 聲碼器在多項指標上領先於當前熱門開源工具。</p><p><img height="189" src="https://oscimg.oschina.net/oscnet/up-df33b9c0a05c5f8d220f0d8aaf44e960d53.png" width="500" referrerpolicy="no-referrer"></p><h4><strong>可視化功能</strong></h4><p>與傳統的音頻開源工具不同，Amphion 提供了生成過程可視化及音頻可視化功能。聯合團隊旨在通過可視化，使初級開發者者更好地理解模型的原理和細節。下圖為在擴散模型中的 SVC 任務，形象地呈現出由一位歌手音色轉換為另外一位歌手音色的漸變過程。</p><p><img height="242" src="https://oscimg.oschina.net/oscnet/up-a8cbbee92c42b4d6f600a91d234509595e5.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 03:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275031</guid>
            <link>https://www.oschina.net/news/275031</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Solus 4.5 發佈，棄用 MATE 轉向 XFCE 版本]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Solus 4.5 「Resilience」 現已<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgetsol.us%2F2024%2F01%2F08%2Fsolus-4-5-released%2F" target="_blank">發佈</a>。此版本帶來了更新的應用程序和內核、更新的軟件堆棧、新的安裝程序以及採用 XFCE 桌面環境的新 ISO 版本。</span></p><p><span style="color:#000000"><img alt="" height="281" src="https://oscimg.oschina.net/oscnet/up-23a81b7291d2daba437ec478767f1973ee5.jpg" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">Solus 4.5 帶來了使用 Calamares 安裝程序的全新安裝體驗。與此前相比，現在利用 Calamares 可以更輕鬆地在不同配置中設置 Solus，例如 Btrfs 根文件系統和其他配置。這也是擺脱舊版 os-installer 所使用的 Python 2 的重要一步。</span></p><p><span style="color:#000000">與此同時，新版本默認使用 Pipewire 媒體框架取代了 JACK 和 PulseAudio；UI 方面不會產生太大差異，但是會帶來一些性能方面的改進，例如更好、更可靠的藍牙音頻。以及：</span></p><ul><li><span style="color:#000000">為使用受支持的 AMD 硬件的用户打包了 ROCm 5.5。</span></li><li><span style="color:#000000">附帶 Linux kernel 6.6.9 以提供最新的硬件支持。</span></li><li><span style="color:#000000">Mesa 已升級至 23.3.2，以提供最新的開源圖形驅動程序</span></li></ul><p><span style="color:#000000">桌面環境方面，Solus 4.5 提供了最新版本的 Budgie / GNOME / Plasma，並針對這些桌面環境提供了許多更新；同時發佈了 XFCE 的第一個版本。Solus 4.4 發佈公告曾宣佈計劃棄用 MATE 版本，轉而使用新的 XFCE 版本。XFCE 版的目標是填補與 MATE 版相同的空白：喜歡更輕量級桌面體驗的用户。</span></p><p><span style="color:#000000">鑑於這是 XFCE 版本的首次發佈，可能會存在一些明顯的不足，所以官方將 4.5 版 XFCE 定義為 beta 版本。新的 XFCE 版本包括：</span></p><ul><li><span style="color:#000000">XFCE version 4.18</span></li><li><span style="color:#000000">Mousepad 0.6.1</span></li><li><span style="color:#000000">Parole 4.18.0</span></li><li><span style="color:#000000">Ristretto 0.13.1</span></li><li><span style="color:#000000">Thunar 4.18.6</span></li><li><span style="color:#000000">Whiskermenu 2.8.0</span></li></ul><p><span style="color:#000000">XFCE 版本採用傳統的桌面佈局，帶有底部面板和 Whiskermenu 作為應用程序菜單。使用 Qogir GTK 主題和 Papirus 圖標主題，打造時尚現代的外觀。並已安裝 Blueman，可滿足用户對藍牙的所有需求。「這一版本耗費了大量心血，我們很高興能與大家分享！」</span></p><p><span style="color:#000000">此外，官方仍在努力為 MATE 桌面的現有用户提供無縫過渡路徑。從廣義上講，將為用户提供一種將其 MATE 安裝遷移到 Budgie 或 XFCE 的方法。在成熟的過渡計劃出爐之前，MATE 將繼續為現有用户提供支持。</span></p><p>展望 2024，項目團隊計劃在 Plasma 中提供 Discover，並在 GNOME 中提供 Software Center，以實現具有集成 Flatpak 支持的軟件管理。以及將通過修復錯誤、更新系統組件和完成從 python2 的遷移來償還技術債務。還計劃探索如何開始遷移到 Serpent 工具，為 5.0 版本做好準備。</p><p>更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgetsol.us%2F2024%2F01%2F08%2Fsolus-4-5-released%2F" target="_blank">查看官方公告</a>。</p><p><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgetsol.us%2Fdownload" target="_blank">下載</a></strong></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 02:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275026/solus-4-5-released</guid>
            <link>https://www.oschina.net/news/275026/solus-4-5-released</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GitHub 多項服務出現故障]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>GitHub 多項服務昨天出現了故障，具體表現為眾多 API 都出現了 HTTP 5xx 錯誤，錯誤率上升了 1%~5%，涉及的服務包括但不限於：</p><ul><li>Codespaces</li><li>Packages</li><li>Webhooks</li><li>Git 操作</li><li>Pages</li><li>API 請求</li><li>Actions</li><li>Pull Requests</li></ul><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.githubstatus.com%2Fincidents%2Fpxg3dz4yg7lp" target="_blank">從事故報告頁面來看</a></u>，GitHub 當時的解決方案是<strong>將相關問題隔離到一個數據中心進行處理</strong>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-ed70f2066fa0d8193dd82f9badfeb155b0a.png" referrerpolicy="no-referrer"></p><p>不知道 GitHub 最近頻發故障是否跟升級 MySQL 有關？<br><u><em><a href="https://www.oschina.net/news/270460/upgrading-github-com-to-mysql-8-0" target="news">GitHub.com 跑了 1200 多台 MySQL 主機，如何無縫升級到 8.0？</a></em></u></p><p><em>延伸閲讀：<u><a href="https://www.oschina.net/news/188164/github-recent-service-disruptions" target="news">GitHub 解釋近期頻繁宕機原因：MySQL 不堪重負</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 02:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275025/github-incident-20230109</guid>
            <link>https://www.oschina.net/news/275025/github-incident-20230109</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Extism v1.0.0 發佈， WebAssembly 插件實現框架]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Extism v1.0.0 已正式發佈。Extism 是一個 WebAssembly 插件實現框架，它可以給你的應用開發出各種各樣的 WebAssembly 插件，支持多種編程語言。</p><p><img src="https://oscimg.oschina.net/oscnet/up-5d37397b3cababa42f8754739726d916b86.png" referrerpolicy="no-referrer"></p><p>新版本主要變化：</p><ul><li>採用 Go 重寫新的 Extism CLI</li><li>Rust SDK 和 C SDK 仍保留在<code>extism/extism</code></li><li>Go SDK 通過 Wazero、JS SDK 使用原生 WASM 引擎來運行 JS 運行時（node、deno、bun、瀏覽器）</li><li>Extism 主機函數的模塊命名空間已更改為&nbsp;<code>extism:host/env</code>&nbsp;，用户定義的主機函數現在默認位於&nbsp;<code>extism:host/user</code>&nbsp;中</li></ul><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fextism%2Fextism%2Freleases%2Ftag%2Fv1.0.0" target="_blank">詳情</a></u>。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 02:13:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275021/extism-1-0-0</guid>
            <link>https://www.oschina.net/news/275021/extism-1-0-0</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[全球領先的向量數據庫公司，過去一年都做了哪些事情？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img src="https://oscimg.oschina.net/oscnet/up-2c30b522dd3a9e1d13170c70fc3ed0b22c3.png" alt="" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-41ac69b2f61c0f7f629df531803918e3884.png" alt="" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-4b03e70caa6f70b95fe4992b8e5ab15d675.png" alt="" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 02:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4209276/blog/10740359</guid>
            <link>https://my.oschina.net/u/4209276/blog/10740359</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Jan —— ChatGPT 的開源替代軟件]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Jan 是 ChatGPT 的開源替代軟件，可在電腦上 100% 離線運行。</p><p>Jan 可以在任何硬件上運行。從 PC 到多 GPU 集羣，Jan 支持通用架構：</p><ul><li>Nvidia GPUs (fast)</li><li>Apple M-series (fast)</li><li>Apple Intel</li><li>Linux Debian</li><li>Windows x64</li></ul><p><strong>桌面應用程序</strong></p><p>通過可定製的 AI &nbsp;助手、全局熱鍵和內聯 AI 將工作效率提高 10 倍。</p><p><strong>移動應用（即將推出）</strong></p><p>隨身攜帶你的人工智能助手。具有優雅的功能，無縫集成到你的移動工作流程中 。</p><h4 style="margin-left:0px; margin-right:0px; text-align:left"><strong><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:rgb(0 0 0/var(--tw-text-opacity))"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>兼容 OpenAI</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></h4><p style="margin-left:0px; margin-right:0px; text-align:left">Jan 在&nbsp;<strong style="color:#52525b">localhost:&nbsp;</strong><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><strong><span style="background-color:rgb(37 99 235/var(--tw-bg-opacity))"><span style="color:rgb(255 255 255/var(--tw-text-opacity))"><span><span><span><span><span><span><span><span><span><span><span><span><span>1337&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>提供了一個與 OpenAI 等效的 API 服務器，可以用作兼容應用程序的直接替代品。</p><p style="margin-left:0px; margin-right:0px; text-align:left"><img height="339" src="https://static.oschina.net/uploads/space/2024/0104/164324_Vw4l_4252687.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:left"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#1c1e21"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>從本質上講，Jan 是一個跨平台、本地優先的 AI 原生框架，可用於構建任何東西。事實上，當前的功能都是在此核心 SDK 之上作為第三方擴展實現的。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0px; margin-right:0px; text-align:left"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#1c1e21"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>項目團隊的目標是建立一個類似 VSCode 或 Obsidian 的框架，允許開發人員在 15 分鐘內根據其特定需求構建和定製複雜的 AI 應用程序。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>&nbsp;</p></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 02:10:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/jan</guid>
            <link>https://www.oschina.net/p/jan</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 面向 C# 程序員的 Visual Studio 效率提升器 Codist]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-codist" class="anchor" href="https://gitee.com/wmjordan/Codist#codist"></a>Codist</h1><p><em>Codist</em> is a Visual Studio extension which strives to provide better coding experience and productivity for C# programmers.
Codist 是一個致力於為 C# 程序員提供更佳的編碼體驗和效率的 Visual Studio 擴展。</p><h1><a id="user-content-features" class="anchor" href="https://gitee.com/wmjordan/Codist#features"></a>Features</h1><p>Here's a brief but not complete demonstration of <em>Codist</em>'s enhancement to Visual Studio.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/preview.png" alt="Feature overview" referrerpolicy="no-referrer"></p><p>Check out this list to see what <em>Codist</em> can do for you.</p><ul><li><a href="https://gitee.com/wmjordan/Codist#advanced-c-syntax-highlight">Advanced Syntax Highlight</a> ANY LANGUAGES, and <a href="https://gitee.com/wmjordan/Codist#comment-tagger-and-styles"><em>Comment Tagger</em></a> highlights <code>to-do</code> style comments
<img src="https://gitee.com/wmjordan/Codist/raw/master/doc/feature-brief-syntax-highlight.png" alt="" referrerpolicy="no-referrer"></li><li><a href="https://gitee.com/wmjordan/Codist#super-quick-info">Super Quick Info</a> with extended XML Doc, symbol tool-tips, selectable contents, appearance customization, etc.
<img src="https://gitee.com/wmjordan/Codist/raw/master/doc/feature-brief-super-quick-info.png" alt="Feature Brief Super Quick Info" referrerpolicy="no-referrer"></li><li><a href="https://gitee.com/wmjordan/Codist#navigation-bar">Navigation Bar</a> with a drag-and-drop and filter enabled member list
<img src="https://gitee.com/wmjordan/Codist/raw/master/doc/feature-brief-navigation-bar.png" alt="Feature Brief Navigation Bar" referrerpolicy="no-referrer"></li><li><a href="https://gitee.com/wmjordan/Codist#smart-bar">Smart Bar</a> with common edit commands, C# code refactoring and symbol reference analyzers
<img src="https://gitee.com/wmjordan/Codist/raw/master/doc/feature-brief-smart-bar.png" alt="Feature Brief Smart Bar" referrerpolicy="no-referrer"></li><li><a href="https://gitee.com/wmjordan/Codist#scrollbar-marker">Scrollbar Marker</a> draws a powerful mini code map
<img src="https://gitee.com/wmjordan/Codist/raw/master/doc/feature-brief-scrollbar-marker.png" alt="Feature Brief Scrollbar Marker" referrerpolicy="no-referrer"></li><li><a href="https://gitee.com/wmjordan/Codist#auto-changing-version-numbers">Auto Changing Version Numbers</a></li><li><a href="https://gitee.com/wmjordan/Codist#display-enhancements">Display Enhancements</a></li><li><a href="https://gitee.com/wmjordan/Codist#jump-list-shortcuts">Jump List Shortcuts</a></li><li><a href="https://gitee.com/wmjordan/Codist#auto-pair-punctuations">Auto Pair Punctuations</a></li><li><a href="https://gitee.com/wmjordan/Codist#codist-in-your-language">Codist in Your Language</a></li><li><a href="https://gitee.com/wmjordan/Codist#other-features">Others</a></li><li><a href="https://gitee.com/wmjordan/Codist#feature-control">Comprehensive Configurations</a></li><li><a href="https://gitee.com/wmjordan/Codist#acknowledgements">Acknowledgements</a></li><li><a href="https://gitee.com/wmjordan/Codist#license">License</a>, <a href="https://gitee.com/wmjordan/Codist#bugs-and-suggestions">Bugs and Suggestions</a>, <a href="https://gitee.com/wmjordan/Codist#support-codist-by-donation">Donate</a></li></ul><p><em>Codist</em> supports localization into other languages and it has both English and Chinese now.</p><h2><a id="user-content-advanced-c-syntax-highlight" class="anchor" href="https://gitee.com/wmjordan/Codist#advanced-c-syntax-highlight"></a>Advanced C# Syntax Highlight</h2><p>The advanced syntax highlight function highlights every aspect of C# language elements with diverse styles, including using various font families and text styles, underline styles, enlarging or shrinking font sizes, changing foreground or background colors and transparency.</p><p>You can change syntax highlight styles in any languages, such as Visual BASIC, F#, SASS, and so on, even if they are not recognized by Codist.</p><p>The following screenshots of the <code>TestPage.cs</code> file in the source code project demonstrates possible syntax highlight effects in the Light theme.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/highlight1.png" alt="Syntax highlight" referrerpolicy="no-referrer"></p><ul><li>The font size and font family for each syntax style can be changed, so it is much easier to spot them. This feature is helpful for color-blind people.</li><li>Syntax highlight can be applied to braces and parentheses.</li><li>Various syntax identifiers have different styles, temporary elements such as method parameters and local variables are italic, <code>static</code> symbols are underlined.</li><li>Comment content can be tagged (e.g. <em>todo</em>, <em>note</em>) and highlighted with individual style.</li><li>Unnecessary code can be marked strike-through.</li><li>Keywords are categorized and highlighted with various styles (e.g. <code>abstract</code> and <code>sealed</code>, <code>return</code> and <code>throw</code>, etc.).</li><li>Overriding members (such as <code>ToString</code>) can be painted with gradient background color, so at a glance we know that the marked implementations have overridden their base classes.</li><li>Imported symbols (from external assemblies, e.g. <code>NotImplementedException</code>, <code>ToString</code>) can be marked with a different style (bold here), distinguishing from symbols defined in your code.</li><li>All the above styles are customizable.</li></ul><h3><a id="user-content-default-syntax-highlight-themes" class="anchor" href="https://gitee.com/wmjordan/Codist#default-syntax-highlight-themes"></a>Default Syntax Highlight Themes</h3><p>To quickly get started with advanced syntax highlight, open a C# project, then click the <em>Customize Codist Syntax Highlighting</em> command under the <em>Tools</em> menu.</p><p>A window will pop up, click buttons at the left side of the dialog under the <strong>Predefined themes</strong> and see changes in effect. The styles on the right of the dialog immediately lists effects of corresponding syntax elements. Don't forget to click the <em>Save</em> button at the bottom of the dialog to confirm the changes.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/syntax-highlight-customization-window.png" alt="Load Theme" referrerpolicy="no-referrer"></p><p>With the <strong>Save</strong> and <strong>Load</strong> buttons, you can backup and share your own syntax highlight settings.</p><p>If you mess up your syntax highlight styles, you can press the <strong>Reset</strong> button to reset all settings to default, or reapply predefined themes by clicking buttons at the left bottom.</p><p><strong>Note</strong>: There is a known issue in <em>Codist</em> that <strong>if you change the theme of Visual Studio, you may have to restart it to make syntax highlight settings to work properly</strong>. If the <strong>Reset</strong> button does not work, please try restarting Visual Studio.</p><h3><a id="user-content-customization-of-syntax-highlight-styles" class="anchor" href="https://gitee.com/wmjordan/Codist#customization-of-syntax-highlight-styles"></a>Customization of Syntax Highlight Styles</h3><p>To customize and tweak the desired syntax highlight styles, click or select the text in the document window, and click the <em>Customize Codist Syntax Highlighting</em> command under the <em>Tools</em> menu.</p><p>The customization window will pop up and listing syntax classifications applied to the active text.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/syntax-highlight-customizing-selected.png" alt="Syntax Highlight Customizing Selected" referrerpolicy="no-referrer"></p><p>Click the style in the Syntax Styles list, adjustment controls will be displayed at the bottom of the dialog, where you can change the style. As you change the style, you can immediately see how it appears in the code document window.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/syntax-highlight-customization-preview.png" alt="Syntax Highlight Customization Preview" referrerpolicy="no-referrer"></p><p>Underline styles can be customized. Firstly assign a color for the <strong>Line</strong>, afterwards, more configuration elements will appear.</p><p>If you want to change another syntax element, click on the place where it is applied in the code document window. If the customization window is still opened, and the <em>Selected Code</em> section under <em>Syntax Categories</em> is selected, the list will display the corresponding syntax styles for the place you clicked immediately.</p><p>You can explore other syntax categories by clicking the list on the left of the dialog.</p><p>Syntax definitions in the <em>All languages</em> section will list all syntax styles for any languages installed; those under <em>Tagged comments</em> section apply to <a href="https://gitee.com/wmjordan/Codist#comment-tagger-and-styles">comment taggers</a>, others apply to corresponding languages accordingly.</p><p><strong>Note</strong>: <em>Font size</em> is relative value to editor default font size. Partially checked checkboxes denote default syntax styles are used.</p><p><strong>A Side Note for Editor Font</strong>: You may consider substituting the font used by Visual Studio code editor with professionally designed fonts for programming, for instance, <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FIBM%2Fplex">IBM Plex Mono</a>, <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Ftonsky%2FFiraCode">Fira Code</a>, etc. Employing <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fsnowie2000%2Fmactype">MacType</a> can significantly enhance system-wide textual display quality, especially for Chinese, Japanese and Korean programmers.</p><h3><a id="user-content-my-symbols-and-external-symbols" class="anchor" href="https://gitee.com/wmjordan/Codist#my-symbols-and-external-symbols"></a>My Symbols and External Symbols</h3><p><em>Codist</em> can identify symbols which are defined in your source C# code and which are imported from external assemblies. This feature is so unique that you may not find it elsewhere.</p><p>You can customize it in the <em>symbol markers</em> section under the <em>C#</em> section in the <em>Syntax Highlight Configurations</em> dialog. Style <em>C#: User symbol</em> is used for symbols from your code, and <em>C#: Metadata symbol</em> is used for symbols imported from external assemblies.</p><p><strong>Note</strong>: some predefined themes have defined external symbols with <strong>bold</strong> style, as the above screenshot shows.</p><h2><a id="user-content-comment-tagger-and-styles" class="anchor" href="https://gitee.com/wmjordan/Codist#comment-tagger-and-styles"></a>Comment Tagger and Styles</h2><ul><li><p>The comment tagger highlights comments to your specific styles, according to the first token inside the comment.</p><p>Here are the effects how they are applied.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/syntax-highlight-comments.png" alt="Comment syntax highlight" referrerpolicy="no-referrer"></p><p>To configure the comment tags, which identify comment types, click the <em>tags</em> section, under the <em>Tagged comments</em> section in the <em>Syntax Highlight Configurations</em> dialog, where you can add, remove or modify comment tags.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/syntax-highlight-comment-tags.png" alt="Syntax Highlight Comment Tags" referrerpolicy="no-referrer"></p><p>To disable comment tagger, open the <em>Options</em> dialog, find the <em>Codist/Syntax Highlight</em> section and  uncheck the check box labeled <em>Enable comment tagger</em> in the <em>Syntax Highlight</em> option page.</p></li></ul><h2><a id="user-content-super-quick-info" class="anchor" href="https://gitee.com/wmjordan/Codist#super-quick-info"></a>Super Quick Info</h2><p>The quick info (the tool-tip shown when you hover your mouse pointer on your C# source code) can be enhanced by <em>Codist</em>.</p><h3><a id="user-content-general-quick-info" class="anchor" href="https://gitee.com/wmjordan/Codist#general-quick-info"></a>General Quick Info</h3><p>To customize the <em>Super Quick Info</em>, adjust the settings in the options page.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-options.png" alt="Super Quick Info Options" referrerpolicy="no-referrer"></p><p>Options in the <em>General</em> page apply to all code editor windows.</p><ul><li><p><strong>Hide Quick Info until Shift key is pressed</strong></p><p>By default, <em>Quick Info</em> appears when you hover your mouse over a symbol or syntax token in code editor. Some programmers think this behavior interferes their workflow. Checking this option will suppress the <em>Quick Info</em> until Shift key is pressed.</p></li><li><p><strong>Selection info</strong></p><p>This option will show how many characters and lines in your selection (if your selection spans over multiple lines). So you don't have to count characters one by one.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-selection-length.png" alt="Super Quick Info Selection Length" referrerpolicy="no-referrer"></p></li><li><p><strong>Color info</strong></p><p>This option enables you preview color values. It works for hex color values (such as <code>#00FF00</code>，<code>#33993300</code>), named colors (such as <code>Black</code>, <code>White</code>, etc.). The 12 sample blocks under color values list the color as the foreground or background against various gray scale colors to help designers to determine the best readability.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-color.png" alt="Super Quick Info - Color" referrerpolicy="no-referrer"></p><p>In C# code editor, Codist can also analyze system colors (such as <code>SystemColors.WindowColor</code>, <code>SystemColors.Control</code>, etc.), <code>Color.FromArgb</code> or <code>Color.FromRgb</code> expression with constant values as well.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-csharp-color.png" alt="Super Quick Info - C# Color" referrerpolicy="no-referrer"></p><p>The color info not only works in code windows, but also in debugger <em>Watch</em> window.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-debugger-watch.png" alt="Super Quick Info - Color" referrerpolicy="no-referrer"></p></li><li><p><strong>Quick Info size</strong></p><p>From version 7.5 on, it is possible to limit the size of the Quick Info popup, so the window won't cover your whole screen.</p><p>By default, <em>Codist</em> does not apply size limitations. You must manually set the <em>Max width</em> and <em>Max height</em> here. If the contents exceed the width, they are wrapped, and scrollbars will appear when necessary, as the screenshot below demonstrates.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-size.png" alt="Super Quick Info - Size" referrerpolicy="no-referrer"></p></li><li><p><strong>Display Delay</strong></p><p>From version 7.5 on, Codist can delay the display of Quick Info, so it won't get into your way when you move your mouse in the document window.</p></li><li><p><strong>Background</strong></p><p>The background color of the Quick Info can be changed. Click the <strong>Background</strong> button and pick your favorite color.</p></li></ul><h3><a id="user-content-c-quick-info" class="anchor" href="https://gitee.com/wmjordan/Codist#c-quick-info"></a>C# Quick Info</h3><p><em>Super Quick Info</em> especially enhances programming experience for C# programmers. There are plenty of options available in the options page.</p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-csharp-options.png" title="" alt="Super Quick Info - Options" width="617" referrerpolicy="no-referrer"><ul><li><p><strong>Use enhanced symbol signature style</strong> is a new setting in version 6.6, enabled by default, which optimizes the display of symbol signatures with a reorganized layout. The layout is especially optimized for long and complex signatures, yet ordinary short symbols can also benefit from it. The following is an example for the style. A large icon on the top-left part of the quick info can be clicked and brings out a menu for symbol analysis. Next to the icon is the name of the symbol standing out with larger text. Clicking on the name can jump to its definition. The parameters for the method are listed next. The reorganized layout never breaks the parameter type from its name, so it is easier to find out and locate each parameter type and name. Beneath the signature is the containing type of the symbol, as well the kind of the symbol. And the member type (return value) of the symbol is under the containing type.
<img src="https://gitee.com/wmjordan/Codist/raw/master/doc/csharp-optimized-quick-info.png" alt="C# optimized quick info" referrerpolicy="no-referrer"></p></li><li><p><strong>Highlight current syntax node in code editor</strong> will draw polygonal markers the syntax node related to the place where Quick Info is triggered.</p></li><li><p>A <strong>Context menu</strong> with many symbol analysis commands will show up when you right click the signature of the symbol definition or any symbol that appears in the Super Quick Info.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-csharp-menu.png" alt="Super Quick Info Csharp Menu" referrerpolicy="no-referrer"></p></li><li><p><strong>Override XML Documentation</strong></p><p>The overridden XML Documentation makes the following changes to displayed documentation.</p><ul><li>More syntax colors (adopting syntax highlight colors) for symbols.</li><li>Icons for documentation parts.</li><li>Selectable content of the documentation.</li><li>Copyable quick info content (First select text with your mouse, then press <code>Ctrl + C</code> shortcut key, or right click to show up a context menu with Copy command).</li><li>Concise form of members (without leading namespace or containing type names, hover your mouse over a symbol to view its full definition).</li><li>Extra tags, such as <code>&lt;b&gt;</code> (for bold), <code>&lt;i&gt;</code> (for italic) and <code>&lt;u&gt;</code> (for underline) are supported.</li><li>Extra information from documentations (see below).</li></ul></li></ul><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-override-doc.png" alt="Super Quick Info Override Doc" referrerpolicy="no-referrer"></p><p>When <em>Override XML Documentation</em> checkbox is checked in the options page, it is also possible to activate options under it.</p><ul><li><p><strong>Inherit from base type or interfaces</strong> option will show documentation description from base <code>class</code>es or implemented <code>interface</code>s if the XML Doc description of the current symbol is absent.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-inherit-base.png" alt="Super Quick Info - Inherit Base" referrerpolicy="no-referrer"></p></li><li><p><strong>Inherit from <code>&lt;inheritdoc cref="MemberName"/&gt;</code> target</strong> option will borrow description from the referenced <code>MemberName</code>.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-inheritdoc.png" alt="Super Quick Info Inheritdoc" referrerpolicy="no-referrer"></p></li><li><p><strong>Show <code>&lt;returns&gt;</code> XML Doc</strong> and <strong>Show <code>&lt;remarks&gt;</code> XML Doc</strong> will add content of those tags.</p></li><li><p><strong>Override <code>&lt;exception&gt;</code> XML Doc</strong> option adds back documentations for exceptions to the Quick Info.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-override-exception.png" alt="Super Quick Info - Override Exception" referrerpolicy="no-referrer"></p></li></ul><p><em>Codist</em> shows XML Doc for those <code>namespace</code>s with an embedded <code>NamespaceDoc</code> class, like what is done in <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FEWSoftware%2FSHFB">SandCastle</a>.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-csharp-namespace.png" alt="Super Quick Info Csharp Namespace" referrerpolicy="no-referrer"></p><h3><a id="user-content-additional-quick-info-items" class="anchor" href="https://gitee.com/wmjordan/Codist#additional-quick-info-items"></a>Additional Quick Info Items</h3><p>A dozen of additional quick info items could be displayed in the <em>Additional Quick Info Items</em> options page.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-csharp-items.png" alt="Super Quick Info Csharp Items" referrerpolicy="no-referrer"></p><ul><li><p><strong>Attributes</strong> option shows attributes of a symbol.</p></li><li><p><strong>Base type</strong> and <strong>Interfaces</strong> options shows inheritance and implementation info of a type. It is recommended to check <strong>All ancestor types</strong> and <strong>Inherited interfaces</strong> to display the complete info of the hierarchy of a type.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-attribute-base-interface.png" alt="Super Quick Info Attribute Base Interface" referrerpolicy="no-referrer"></p><p><strong>Note</strong>: the <code>IDisposable</code> interface has special importance in .NET programming, thus it is assigned a special icon and pinned to the top of the interface list.</p></li><li><p><strong>Declaration</strong> option shows modifiers to a symbol when it is not a public instance one.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-declaration.png" alt="Super Quick Info Declaration" referrerpolicy="no-referrer"></p></li><li><p><strong>Interface implementation</strong> option shows if a member implements any interface.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-interface-implementation.png" alt="Super Quick Info Interface Implementation" referrerpolicy="no-referrer"></p></li><li><p><strong>Method overload</strong> options shows possible overloads of a method (including applicable extension methods).</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-method-overloads.png" alt="Super Quick Info - Method Overloads" referrerpolicy="no-referrer"></p><p>This option also helps you find out correct overloads when any argument passed to a method is incorrect.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-param-candidate.png" alt="Super Quick Info Param Candidate" referrerpolicy="no-referrer"></p></li><li><p><strong>Parameter of method</strong> options shows whether a token or an expression is the parameter of a method in the argument list. What is more, the documentation of the parameter is also displayed.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-param.png" alt="Super Quick Info - Param" referrerpolicy="no-referrer"></p></li><li><p><strong>Type parameter</strong> option shows information and documentation about type parameters.</p></li><li><p><strong>Symbol location</strong> shows where a symbol is defined.</p></li><li><p><strong>Numeric forms</strong> shows decimal, hexadecimal and binary forms for constant integer and <code>Enum</code> values.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-const.png" alt="Super Quick Info Const" referrerpolicy="no-referrer"></p><p>The binary form is useful when working with bit flags.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-enum.png" alt="Super Quick Info Enum" referrerpolicy="no-referrer"></p></li><li><p><strong>String length and Hash codes</strong> for string constants.
(Hint: We can use Hash codes to quickly compare whether two strings that look alike are identical)</p></li></ul><h2><a id="user-content-navigation-bar" class="anchor" href="https://gitee.com/wmjordan/Codist#navigation-bar"></a>Navigation Bar</h2><p><em>Navigation bar</em> locates at the top of the code editor window. It overrides the original navigation bar. When the <em>Navigation Bar</em> is loaded, it hides two drop-down lists on the original Navigation Bar, but preserves the project drop-down list.</p><p>Basically, the <em>Navigation Bar</em> serves the same purpose of the original one comes with Visual Studio, displaying symbol information where the caret is placed.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-overview.png" alt="Navigation Bar Overview" referrerpolicy="no-referrer"></p><p><strong>Note</strong>: Navigation Bar works with both C# code documents and Markdown documents.</p><p>Nodes on the <em>Navigation Bar</em> are clickable.</p><ol><li><p>Clicking on the left-most <strong>Search Document node</strong> will popup a menu, displaying namespaces and types defined in the active document.</p><p>On top of the menu, there is a <strong>Search Declaration</strong> box, within which you can type and search declarations.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-search.png" alt="Navigation Bar Namespace Types" referrerpolicy="no-referrer"></p><p>Besides the <em>Search Declaration</em> box, there are three buttons. The first one is pressed by default, which restricts the search scope to active document. If the second one is pressed, it pops up the first button and expands the search scope to current project (see screen shot below). The third button clears the search box and reverts the items back to unfiltered namespaces and types.</p><p><strong>Note</strong>: Press <code>-</code> or <code>=</code> key on keyboard to switch search scope between current document and current project.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-search-declaration.png" alt="Navigation Bar Search Declaration" referrerpolicy="no-referrer"></p><p><strong>Note</strong>: If the first character in the search box is an upper case one, the search will be <strong>case-sensitive</strong>, otherwise, it is case-insensitive.</p><p>You can <strong>drag and drop</strong> items in the menu to reorder types within the document.</p></li><li><p>Clicking on the <strong>global namespace node</strong>, which has a house as the icon, will popup a menu, displaying all root namespaces defined in the project and referenced assemblies, as well as types without any namespace. You can click namespaces to check out its sub-namespaces and types.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-global-namespaces.png" alt="Global namespaces" referrerpolicy="no-referrer"></p><p>There is also a search box in this menu, which filters content of the menu.</p><p>There are several buttons beside the search box. Numbers on the buttons counts corresponding items within the type. Hover your mouse cursor over the button, you can read meanings of them. Pressing down those buttons filters members within the menu to corresponding ones.</p><p>You can right click items on the menu to bring out a context menu for corresponding members.</p></li><li><p>Clicking a <strong>Namespace node</strong> which follows the Document node will popup a menu, displaying namespaces and types defined in the corresponding namespace. You can click on those items and jump to the beginning of corresponding definitions.</p></li><li><p>Clicking on a <strong>Type node</strong> will popup a menu, displaying members and regions defined within the type. You can click on those items and jump to the definition of the corresponding member.</p><p>You can <strong>drag and drop</strong> items in the menu to reorder members, nested types and <code>#region</code>s within the document. If a <code>partial</code> type spans over several code files, it is also possible to rearrange members among them.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-fields.png" alt="Navigation Bar Fields" referrerpolicy="no-referrer"></p><p>The current symbol where the caret is on is highlighted.</p><p>Field values and auto-property expressions are also displayed on this menu. So, you can read the initial value of fields immediately.</p><p>You can right click items to bring out a context menu for the symbol.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-context-menu.png" alt="Navigation Bar Fields" referrerpolicy="no-referrer"></p><ol start="5"><li><p>Clicking on a <strong>Member node</strong> will select the whole member. If you have the <em>Smart Bar</em> feature on and let it appear when selection is changed, <em>Smart Bar</em> will be displayed and let you perform actions onto the member.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-select.png" alt="Navigation Bar Select" referrerpolicy="no-referrer"></p></li></ol></li></ol><h3><a id="user-content-customization" class="anchor" href="https://gitee.com/wmjordan/Codist#customization"></a>Customization</h3><p>The <em>Navigation Bar</em> can be configure via the options page.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-options.png" alt="Navigation Bar Options" referrerpolicy="no-referrer"></p><ul><li><p>If <strong>Syntax detail</strong> option is set, the <em>Navigation Bar</em> not only shows available types and declarations in the code window like the original navigation bar, but also syntax nodes such as statements and expressions containing the caret.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-syntax-details.png" alt="Navigation Bar Syntax Details" referrerpolicy="no-referrer"></p></li><li><p>If <strong>Symbol info tip</strong> option is set, you can read information about a symbol when you hover your mouse onto a node.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-symbol-info.png" alt="Navigation Bar Symbol Info" referrerpolicy="no-referrer"></p></li><li><p>If <strong>Highlight syntax range</strong> option is set, when you hover the mouse over the node on the bar, corresponding span of the node will be highlighted in the editor.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-node-range.png" alt="Navigation Bar Node Range" referrerpolicy="no-referrer"></p><ul><li>If <strong>Region</strong> option is set, <code>#region</code> names will be displayed on the Navigation Bar. If you pad region names with some non-alphabetic characters like "<code>#region [====== private methods ======]</code>", you can check the <strong>Trim non-letter characters in region</strong> checkbox so only alphabetic part like "<code>private methods</code>" will be displayed on the <em>Navigation Bar</em>.</li></ul><p>To customize drop-down menus of the <em>Navigation Bar,</em> change options in the <em>Drop-down Menu</em> tab.</p></li></ul><h3><a id="user-content-markdown-navigation-bar" class="anchor" href="https://gitee.com/wmjordan/Codist#markdown-navigation-bar"></a>Markdown Navigation Bar</h3><p>The Markdown navigation bar lists all titles appear in a Markdown document.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-markdown.png" alt="Navigation Bar Markdown" referrerpolicy="no-referrer"></p><p>Similarly, you can type in the search box to filter down the titles.</p><p>From version 7.8 on, there are buttons near the search box to limit displaying titles to specific levels.</p><h2><a id="user-content-smart-bar" class="anchor" href="https://gitee.com/wmjordan/Codist#smart-bar"></a>Smart Bar</h2><p>The <em>Smart Bar</em> is a context-aware tool bar that appears automatically when you select some text, or double tap the <em>Shift</em> key on your keyboard.</p><p>There are two toolbars on <em>Smart Bar</em>. The top bar contains general editing commands for all file types. Buttons on the bottom bar changes according to file types.</p><p>Buttons on the <em>Smart Bar</em> changes according to your selection, typical buttons are editing operations (e.g. <em>Cut</em>, <em>Copy</em>, <em>Paste</em>,  <em>Delete</em>, <em>Duplicate</em>, <em>Formatting</em>, <em>Find</em>, etc.), code analysis operations (e.g. <em>Go to definition</em>, <em>Find references</em>), refactoring operations (e.g. <em>Rename</em>, <em>Extract method</em>, etc.)</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar.png" alt="Smart Bar" referrerpolicy="no-referrer"></p><p>Each button on <em>Smart Bar</em> usually has multiple functions. Left clicking, right clicking, Ctrl+clicking and Shift+clicking trigger different commands. For details, see the tool-tip for the buttons. Right clicking a button usually expands the effective range of a command to the whole line, or brings out a pop-up menu for more commands.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-2.png" alt="Smart Bar" referrerpolicy="no-referrer"></p><p>There are multiple predefined <strong>web search</strong> commands in the menu when you right click the Find button, which will launch your browser to search the text you select in document window. So, it is handier to look for answers from the web or find code examples in <em>GitHub</em>.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-search.png" alt="Smart Bar Search" referrerpolicy="no-referrer"></p><p>You can specify what browser you prefer to use in the options page.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-search-options.png" alt="Smart Bar Search Options" referrerpolicy="no-referrer"></p><h3><a id="user-content-c-specific-commands" class="anchor" href="https://gitee.com/wmjordan/Codist#c-specific-commands"></a>C# Specific Commands</h3><p>When you select a symbol, you may probably see a <em>Smart Bar</em> like below.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar.png" alt="Smart Bar" referrerpolicy="no-referrer"></p><p>The C# commands are on the second row.</p><p>The first one is <strong>Go to Definition</strong>, that behaves the same as the keyboard <code>F12</code> command. With this, you no longer need hitting the <code>F12</code> key to go to definition.</p><p>The second one is the <strong>Analyze symbol...</strong> button, a menu will pop up showing possible symbol analysis commands for the symbol. Since some commands require considerable amount of calculation, items ending with "..." will require a mouse click to expand. For instance, clicking the <strong>Find Callers</strong> command in the following screen shot will search the source code and list at what places are calling the selected method in a symbol list. In the symbol list, you can filter items like the what you can do in the <em>Navigation Bar</em>, click items on the sub-menu and jump to the corresponding location.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-symbol-analysis.png" alt="Smart Bar Symbol Analysis" referrerpolicy="no-referrer"></p><p>Various commands will be conditionally listed under the <strong>Analyze symbol...</strong> menu. Here is a list of commands for an interface.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-symbol-analysis-2.png" alt="Smart Bar Symbol Analysis 2" referrerpolicy="no-referrer"></p><p>The <strong>Find Members</strong> command under <strong>Analyze symbol...</strong> lists all members defined within a type. For some special types, for instance, <code>SystemColors</code>, <code>Colors</code>, <code>Brushes</code>, etc. The preview is shown on the list.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-member-colors.png" alt="Smart Bar Member Colors" referrerpolicy="no-referrer"></p><p>For Visual Studio extension developers, the preview offers more, for instances, it allows previewing images of <code>KnownImageIds</code>, colors in <code>VsBrush</code>, etc.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-member-knownimageids.png" alt="Smart Bar Member KnownImageIds" referrerpolicy="no-referrer"></p><p>The <strong>Find Implementations</strong> command for an interface type will display all types that implement that interface. The same command will also appear for interface members, which finds out corresponding members that implement the specific interface member.</p><p>When we begin to work with new libraries, we usually have to learn new types and APIs. Two typical scenario are that "<em>what methods, properties return specific instance of a type?</em>" and "<em>what methods can an instance of a given type can be passed into?</em>". Thus, <em>Smart Bar</em> provides <em>Find Instance Producer</em> and <em>Find Instance as Parameter</em> for type names. The following screen shot demonstrates the result of finding instance producers which returns an instance of <code>IWpfTextView</code>.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-instance-producer.png" alt="Smart Bar Instance Producer" referrerpolicy="no-referrer"></p><p>There are two buttons on the top right corner in the result list of symbol analysis commands. The <em>Pin</em> button will keep the list on the screen. And you can use your mouse to drag those lists around.</p><h3><a id="user-content-code-refactorings" class="anchor" href="https://gitee.com/wmjordan/Codist#code-refactorings"></a>Code Refactorings</h3><p>From version 7.0 on, quite a few code refactorings are provided via a button on the C# Smart Bar.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-refactoring.png" alt="Smart Bar Code Refactoring" referrerpolicy="no-referrer"></p><p>You can access the menu from keyboard by assigning a shortcut key to the <code>Refactor.RefactoringCode</code> command.</p><h3><a id="user-content-symbol-marker" class="anchor" href="https://gitee.com/wmjordan/Codist#symbol-marker"></a>Symbol Marker</h3><p><em>Symbol marker</em> draws markers for C# symbols.</p><p>Typically, you can double click a symbol in the C# source code, select the <em>Mark Symbol</em> command on the <em>Smart Bar</em> and choose the desired highlight marker on the drop-down menu.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/symbolmarker.png" alt="Symbol Marker" referrerpolicy="no-referrer"></p><p>After applying the command, all occurrences of the marked symbol will be marked with a different style.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/symbolmarker-effect.png" alt="Symbol Marker Effect" referrerpolicy="no-referrer"></p><p>To remove symbol marker, click the <em>Remove symbol mark</em> command in the drop-down menu of the <em>Mark symbol</em> command.</p><p>Symbol markers will be cleared when the solution is unloaded.</p><p><strong>Note</strong>: The style of symbol markers can be customized in the <em>Syntax highlight Configurations</em> dialog. The default colors are listed below. You also need to turn on the <em>Syntax Highlight</em> feature in order to make this feature work.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/symbolmarker-options.png" alt="Symbol marker Options" referrerpolicy="no-referrer"></p><h3><a id="user-content-behavior-of-smart-bar" class="anchor" href="https://gitee.com/wmjordan/Codist#behavior-of-smart-bar"></a>Behavior of Smart Bar</h3><p>By default, <em>Smart Bar</em> appears after selection changes, you can alter the behavior in the options page by unchecking the <em>Show Smart Bar when selection is changed</em> checkbox.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-options.png" alt="Smart Bar Options" referrerpolicy="no-referrer"></p><p><em>Smart Bar</em> automatically disappears when you move your mouse cursor away from it, or execute a certain commands on the <em>Smart Bar</em>, or click somewhere else in the code editor window, emptying the selection.</p><p>To make the <em>Smart Bar</em> reappear, you can tap the <code>Shift</code> key on your keyboard twice within a second. This behavior can also be suppressed by unchecking the <strong>Show/hide Smart Bar with Shift key</strong> checkbox.</p><h3><a id="user-content-smart-bar-in-other-windows" class="anchor" href="https://gitee.com/wmjordan/Codist#smart-bar-in-other-windows"></a>Smart Bar in Other Windows</h3><p><em>Smart Bar</em> also works on <em>Output</em>, <em>C# Interactive</em>, <em>Immediate (Debug)</em>, <em>Find Results</em> and some other text selectable window panes. If you select a path within those windows, extra commands will pop up allowing you to open it directly or locate it in <em>Windows Explorer</em>.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-file-operations.png" alt="Smart Bar File Operations" referrerpolicy="no-referrer"></p><h2><a id="user-content-scrollbar-marker" class="anchor" href="https://gitee.com/wmjordan/Codist#scrollbar-marker"></a>Scrollbar Marker</h2><p><em>Scrollbar Marker</em> draws extra glyphs and shapes on the vertical scrollbar for the following syntax elements:</p><ul><li><strong>Line numbers</strong> (marked with gray dashed lines and numbers, from version 7.4 on, total line count is displayed at the bottom of the scroll bar)</li><li>Selection range (marked with semi-transparent color blocks over the bar)</li><li>Special comments tagged by comment tagger (marked with small squares)</li><li>C# <code>class</code>/<code>struct</code>/<code>interface</code>/<code>enum</code><strong>declarations</strong> (marked with lines indicating their ranges and a square, and their names indicating their declaration locations)</li><li>C# compiler directives, e.g. <code>#if</code>, <code>#else</code>, <code>#region</code>, <code>#pragma</code>, etc. (marked with a gray spot)</li><li>C# symbol match marker (matches symbol under the caret, marked with an aqua square)</li></ul><p>Please see the first screenshot of this article. The markers can be toggled via the options page.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/scrollbar-marker-options.png" alt="Scrollbar Marker Options" referrerpolicy="no-referrer"></p><h2><a id="user-content-auto-changing-version-numbers" class="anchor" href="https://gitee.com/wmjordan/Codist#auto-changing-version-numbers"></a>Auto Changing Version Numbers</h2><p>Codist can automatically change version numbers for output assemblies before build.</p><p>To activate the behavior, right click the project in the Solution Explorer and select the <em>Auto Build Version Numbers...</em> command.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/auto-version.png" alt="Auto Build Version" referrerpolicy="no-referrer"></p><p>On the left side of the dialog, build configurations are listed. "&lt;Any&gt;" configuration applies to all build configuration scenarios. Others applies to the corresponding scenarios respectively.</p><p>On the right side of the dialog, current version numbers are listed. And four drop-down list controls specify the behavior how version number parts are changed.</p><p>Once you change the drop-down list control to a value rather than "Unchanged", the new version number will be displayed next to the current version number as a preview how it will be changed before next build.</p><p>Press the "Save" button to save the settings and Codist will change build numbers for you before future builds.</p><p><strong>Note</strong>: The build settings are saved in the <em>obj</em> folder where the project file locates.</p><h2><a id="user-content-display-enhancements" class="anchor" href="https://gitee.com/wmjordan/Codist#display-enhancements"></a>Display Enhancements</h2><p>In the <em>Display</em> tab of the <em>General</em> options page, several display enhancement options are offered.</p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/display-options.png" title="" alt="General Options Display" width="783" referrerpolicy="no-referrer"><p>Within the <em>Extra line margins</em> group box, you can adjust margins between lines to make code lines more readable.</p><p>Programmers who do not like <em>ClearType</em> rendering, which made text blurry and colorful, may want to try <em>Force Grayscale Text Rendering</em> options.</p><p>From version 6.6 on, resource monitors can be used to monitorCPU, disk and memory usage via the status bar on Visual Studio. Checking the <em>Monitor CPU</em>, <em>Monitor disk</em> or <em>Monitor memory</em> check box enables the corresponding monitors.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/resource-monitors.png" alt="Resource Monitors" referrerpolicy="no-referrer"></p><p>It is possible to use Compact menu like <em>Visual Studio 2019</em> in <em>Visual Studio 2017</em>. Simply checking the <em>Move main menu to title bar</em> option will do.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/compact-menu.png" alt="Compact Menu" referrerpolicy="no-referrer"></p><p>By checking the check boxes started with "Hide...", it is possible to hide some elements from the user interface of Visual Studio from options under the <em>Layout Override</em> section.</p><h2><a id="user-content-jump-list-shortcuts" class="anchor" href="https://gitee.com/wmjordan/Codist#jump-list-shortcuts"></a>Jump List Shortcuts</h2><p>Jump List is a menu section that appears when you right click the Visual Studio button on the task bar. It lists your recently opened solutions, projects or documents.</p><p>If you are using Open-Shell or other similar Start Menu applications, Codist can add three shortcuts to the Quick Start list of Visual Studio when you check the <em>Jump List Shortcuts</em> option. Those shortcuts start Visual Studio in a special mode.</p><ol><li><em>Non-scaling mode</em>: disables DPI-awareness of Visual Studio and let you design WinForm applications with 100% scaling.</li><li><em>Safe mode</em>: disables most extensions in Visual Studio. If an extension keeps crashing the development environment, you can use the Safe mode to enter Visual Studio to disable or uninstall it.</li><li><em>Presentation mode</em>: opens a particular instance of Visual Studio which has its own settings and layouts.</li></ol><h2><a id="user-content-auto-pair-punctuations" class="anchor" href="https://gitee.com/wmjordan/Codist#auto-pair-punctuations"></a>Auto Pair Punctuations</h2><p>From version 7.6 on, Codist can automatically "pair" punctuations around selections.</p><p>To make this work, follow the steps below:</p><ol><li>Check the <em>Auto Pair Punctuation</em> option in the option page, which is off by default.</li><li>Select some text in the code editor.</li><li>Type an "opening" punctuation, for instance, <code>(</code>, <code>&lt;</code>, <code>{</code>, <code>[</code>, <code>"</code> or <code>'</code>.</li><li>When this option is turned off, the typed character will replace the selection; when this option is turned on, typed character will be inserted in front of the selection, and their counterpart--that is, <code>)</code>, <code>&gt;</code>, <code>}</code>, <code>]</code>, <code>"</code> or <code>'</code>--will be appended behind the selection. For example, if you select <code>abc</code> in the code, and type <code>"</code>, you will get <code>"abc"</code>; if you select <code>x + y</code> in the code, and type <code>(</code>, you will get <code>(x + y)</code>.</li><li>Once the first character is typed,
a. If you actually want the typed character to replace the selection, press the <em>Delete</em> or <em>Backspace</em> key, the selection and the automatically inserted counterpart will be erased;
b. If more characters are to be inserted after the first character, just keep typing, the not-yet-removed content as well as the punctuation counterpart will be replaced.
c. If the automatically inserted paired punctuation is what you need, that is what you get now.</li><li>When we edit Markdown documents, the <tt>`</tt>, <code>*</code>, <code>_</code> and <code>~</code> are also auto-paired.</li><li>For Chinese users, Chinese full width punctuations are also auto-paired.</li></ol><p>You can always turn off this feature by unchecking the <em>Auto Pair Punctuation</em> option in the option page.</p><h2><a id="user-content-codist-in-your-language" class="anchor" href="https://gitee.com/wmjordan/Codist#codist-in-your-language"></a>Codist in Your Language</h2><p>It is possible to localize <em>Codist</em> to other language. Simplified Chinese (簡體中文) and English are provided by default.</p><p>The interface of <em>Codist</em> will change according to the <em>International</em> settings of <em>Visual Studio</em>.</p><h2><a id="user-content-other-features" class="anchor" href="https://gitee.com/wmjordan/Codist#other-features"></a>Other Features</h2><p>From version 7.4 on, extra menu commands to open build output target folder are added to the <em>Build</em> menu.</p><p>It is possible to output a time stamp after each build.</p><p>For VSIX developers, there is also an option to automatically increment version number for your VSIX manifest file.</p><h1><a id="user-content-feature-control" class="anchor" href="https://gitee.com/wmjordan/Codist#feature-control"></a>Feature Control</h1><p>Open the <em>Codist</em> section in the <em>Tools-&gt;Options</em> dialog. In the <em>General</em> section you can toggle features of <em>Codist</em>.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/general-options.png" alt="General customization" referrerpolicy="no-referrer"></p><ol><li><p><em>Feature controllers</em> contains check boxes which can be used to enable/disable features of <em>Codist</em>.</p><p>Someone who does not like the syntax highlight or use another syntax highlighter can also turn off the <em>Syntax Highlight</em> feature individually here.</p><p>These <strong>options will take effect on new document windows</strong>. Existing document windows won't be affected.</p></li><li><p>To share or backup your settings of Codist, you can use the <em>Save</em> and <em>Load</em> buttons.</p></li></ol><h1><a id="user-content-acknowledgements" class="anchor" href="https://gitee.com/wmjordan/Codist#acknowledgements"></a>Acknowledgements</h1><p>I have learned a lot from the following extension projects (sorted by the time when I learned from them). Codist would not be what you see today without them.</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmhoumann%2FCommentsPlus">CommentsPlus</a>, <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fomsharp%2FBetterComments">Better comments</a>, <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fjgyo%2Fremarker">Remarker</a>: syntax tagger</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FOceanware%2FFontSizer">Font Sizer</a>: changing font size in syntax styles</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FMicrosoft%2FVS-PPT">Visual Studio Productivity Power Tools</a>: extending code window margin</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Ftunnelvisionlabs%2FInheritanceMargin">Inheritance Margin</a>: extending code window margin</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FGeorgeAlexandria%2FCoCo">CoCo</a>: extensive syntax highlighting</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FKhaosCoders%2FVSCodeBlockEndTag">CodeBlockEndTag</a>: adornments</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fcpmcgrath%2FUntabifyReplacement">UntabifyReplacement</a>: replacing text in code window</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmadskristensen%2FExtensibilityTools">Extensibility Tools</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fcodecadwallader%2Fcodemaid">CodeMaid</a>: how to support multi-language localization</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2F2mas%2FSelectNextOccurrence">Select Next Occurrence</a>: code navigation</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmike-ward%2FVSColorOutput">VSColorOutput</a>: extending output window pane</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FNuGet%2FNuGet.Build.Packaging">NuGet</a>: build events</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FGordianDotNet%2FGoToImplementation">GoToImplementation</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fdotnet%2Froslyn">Roslyn</a>: lots about code analysis</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FVsixCommunity%2FCommunity.VisualStudio.Toolkit">Community.VisualStudio.Toolkit</a>: VS extension points</li><li>ReviewBoard: code.google.com/p/reviewboardvsx</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmadskristensen%2FTweakster">Tweaks</a>: VS tweaks</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmadskristensen%2FVsStatus">VsStatus</a>: hacking the status bar</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FJosefPihrt%2FRoslynator">Roslynator</a>: hundreds of code refactorings and analyzers</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmadskristensen%2FShowTheShortcut">ShowTheShortcut</a>: discovering identifiers of executed commands</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DMadsKristensen.CopyNice">Copy Nice</a>: copying text without indentation</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.codeproject.com%2FArticles%2F131708%2FWPF-Color-Picker-Construction-Kit">WPF Color Picker Construction Kit</a>: color picker with spectrum</li></ul><p>And thank you, every donators, beta testers, feedback providers to this project.</p><h1><a id="user-content-license" class="anchor" href="https://gitee.com/wmjordan/Codist#license"></a>License</h1><p><em>Codist</em> comes from the open source community and it goes back to the community.</p><p><em>Codist</em> is <strong>free</strong> software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p><p>You should have received a copy of the GNU General Public License along with this program. If not, see "<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.gnu.org%2Flicenses">https://www.gnu.org/licenses</a>".</p><h1><a id="user-content-bugs-and-suggestions" class="anchor" href="https://gitee.com/wmjordan/Codist#bugs-and-suggestions"></a>Bugs and Suggestions</h1><p>Please <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fwmjordan%2FCodist%2Fissues">post New Issue</a> in the <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fwmjordan%2FCodist">GitHub project</a> if you find any bug or have any suggestion.</p><p>Your vote and feedback on the <a href="https://gitee.com/link?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Dwmj.Codist">Visual Studio Extension Marketplace</a> are also welcomed.</p><h1><a id="user-content-support-codist-by-donation" class="anchor" href="https://gitee.com/wmjordan/Codist#support-codist-by-donation"></a>Support Codist by Donation</h1><p>If you like <em>Codist</em>, consider <a href="https://gitee.com/link?target=https%3A%2F%2Fpaypal.me%2Fwmzuo%2F19.99">buying me a cup of Chinese tea</a>.</p><p>You can donate any amount of money as you like. The recommended amount of donation is <code>$19.99</code>.</p><p>6 donations have been received so far :)</p><p>Well, you have already reached here. Why not give Codist a ★★★★★ rating on the <a href="https://gitee.com/link?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Dwmj.Codist">Visual Studio Extension Marketplace</a>?</p>]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 01:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/wmjordan/Codist</guid>
            <link>https://gitee.com/wmjordan/Codist</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | DDD 落地實踐 - 架構師眼中的餐廳]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100019057" data-ratio="0.22676579925650558" src="https://oscimg.oschina.net/oscnet/be541383-3ac2-4c3d-ab96-d48400b38902.gif" data-type="gif" data-w="1076" style="" referrerpolicy="no-referrer"></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">本文以餐廳場景為敍事主線，以領域驅動為核心思想，結合架構設計與功能設計方法論。是從領域分析到落地的全過程案例，內容偏重於落地，因此不乏一些探討，歡迎指正。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">文章較長、全程乾貨、耐心讀完、必有收穫。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">本文不針對餐廳的實現細節，重在探討設計思想和方法。</span></p><span id="OSC_h1_1"></span><h1 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1、領域設計</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h1><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">讓我們拋開技術人員的本能技術視角、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">站在純業務視角來分析領域問題</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">領域設計的核心是分而治之，<span style="font-size: 15px;color: rgb(0, 82, 255);">目的是<span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">實現業務領域的自治性</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">就像你平時不會將枕頭和被子放在廚房或衞生間一樣，你的牀上不會放着大米白麪，否則你想睡覺是一件很複雜的事情，軟件系統也是如此，這就是我們要解決的問題。</span><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><span id="OSC_h2_2"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1.1 宏觀流程</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">假如我要設計一個餐廳，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">由於分而治之的需要，我會首先從宏觀流程去分析</span>，</span>可以幫我們迅速找到重要的區域。</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024662" data-ratio="0.1361111111111111" src="https://oscimg.oschina.net/oscnet/1995e109-8620-4e1e-841d-607a4bc8a114.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">因此會得到幾個明確的行為區域，我將餐廳劃分為「菜品域」，「訂單域」，「廚房域」，「用餐域」，這是業務級別的領域劃分，後續應該針對每個區域單獨分析。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物是：宏觀流程和參與角色</span></p><span id="OSC_h2_3"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1.2 統一語言</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">語言貫穿於整個開發過程，從需求分析到設計、從設計到編碼，因此好的語言非常重要，好的語言<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">體現了清晰的業務概念</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">在這個階段，我們需要通過梳理，找到業務中都有哪些實體與行為，對其做一些歸納。我們的核心問題是：<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">「誰」通過什麼「行為」影響了「誰」</span>，</span>其中的三個要素分別是：角色、行為、實體。我的建議是先<span style="font-size: 15px;color: rgb(0, 82, 255);">找到 「角色」、「實體」、「行為」，並對其歸類，</span>我常常關注角色以及具體身份、實體以及實體實例，功能以及包含的重要步驟。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">角色：是施事主語、是名詞，是主動發起行為的一類實體。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">行為：是動詞、是做了什麼事情，是行為本身。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">實體：是名詞，是除「角色」之外的其他實體。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">推薦使用腦圖畫出來，我認為歸納後的腦圖有助於我們識別根本要素，有利於抽象。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物是：名詞、概念定義、相關腦圖。</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024663" data-ratio="0.8055555555555556" src="https://oscimg.oschina.net/oscnet/3a551592-572d-4f16-bb95-006b67d18d1d.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><span id="OSC_h2_4"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1.3 用例分析</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">在這一步、我們使用相對宏觀的分析，不需要進入用例的細節分析，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">掌握角色與行為之間的關係，理清誰在做什麼，角色的職責差異是什麼</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物：用例圖</span><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">以做菜為例，如圖</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024666" data-ratio="0.7333333333333333" src="https://oscimg.oschina.net/oscnet/719968e8-a2f2-4e2f-94ab-5d80df8c3497.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"></p><span id="OSC_h2_5"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1.4 領域劃分</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我們在分析宏觀流程時，劃分了幾個行為區域，但那是業務級別的。在那基礎之上，我們需要拉進某個區域的視角，再結合之前的用例分析，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">按照「功能相關性」、「角色相關性」進一步劃分領域</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">功能相關性：是<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">用例與領域之間的關係</span>，</span>任何業務的領域都是由一套用例組成的，所以領域劃分以功能相關性為主，例如與做菜相關的用例都應該歸屬於廚房，所以我們確認了廚房域，確認了廚房域包含的用例，這是很自然的事。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">角色相關性：其次是角色，常用於劃分子域，某個區域涉及多個角色參與，可以按照角色的分工，拆分為多個子域，從而滿足不同角色的個性化需要。例如廚房的採購人員負責買菜、刀工負責切菜、大廚負責烹飪。我們就會考慮將廚房劃分為「採購域」、「加工域」、「烹飪域」。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">通常來説，<span style="font-size: 15px;color: rgb(0, 82, 255);">子域不具備獨立的問題空間，不會作為獨立的領域存在。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物：領域、子域</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">以廚房域為例，如圖</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024665" data-ratio="0.6148148148148148" src="https://oscimg.oschina.net/oscnet/47930a5b-4f34-4ab2-9f17-d9d4163e22b7.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><span id="OSC_h2_6"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1.5 領域建模</span></strong></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">這是大家比較熟知的階段，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">重點分析實體與領域之間關係（領域聚合），實體與實體的關係（OO 聚合）</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">領域模型是實現功能的基石、需要有對功能的本質理解，才能找到最核心的實體，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">實體之間的 OO 聚合關係決定了功能的擴展性</span>，</span>OO 聚合是最重要的核心點。</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024664" data-ratio="0.7805555555555556" src="https://oscimg.oschina.net/oscnet/e4372046-ee12-481f-a38b-f2d3b8549773.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">組合、聚合</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">聚合（aggregation）：聚合關係是一種弱的關係，整體和部分可以相互獨立。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">組合（composition）：組合關係是一種強的整體和部分的關係，整體和部分具有相同的生命週期。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">可以使用如下案例，既能表達領域聚合，又能表達 OO 聚合的關係。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">﻿</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024669" data-ratio="0.8277511961722488" src="https://oscimg.oschina.net/oscnet/0d0f7028-5be7-4b87-a5c8-62f466df112a.png" data-type="png" data-w="836" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物：聚合、實體、值對象、實體的屬性</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">（領域服務和事件在後續的功能設計中提供）</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><br></p><span id="OSC_h2_7"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1.6 領域上下游</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">領域上下游關係，不是領域的依賴關係，依賴關係指的是能力的依賴，是共用了某些能力，依賴關係是固定的。領域上下游關係，也不是調用關係，調用關係是與用例相關的，並非描述領域處境的。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">領域上下游關係指的是影響力的關係，</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">上游影響下游，影響力分為「邏輯影響」和「數據影響」，一般説來我們更應該關注「數據影響」，所以<span style="font-size: 15px;color: rgb(0, 82, 255);">領域上下游關係是一種數據流向的限定，是業務發生的順序限定，</span>用於規定該領域所使用的數據，是下游領域依賴上游領域「準備就緒」的體現。合理的上下游限定，有助於減少領域之間的不必要依賴，有利於數據的複用並減少重複計算。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">領域上下游是與場景相關的，</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">並不是一成不變的，不同的場景存在不同的上下游，各場景應該獨立説明。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物：各場景的上下游説明</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">例：在【菜品管理】場景下</span></strong></p><p><img class="rich_pages wxw-img" data-imgfileid="100024670" data-ratio="0.15065502183406113" src="https://oscimg.oschina.net/oscnet/dae06ae3-c3f4-4895-af71-27f6442af29d.png" data-type="png" data-w="916" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">如果廚房的某些食材不足了，或者某個廚師休假了，就會影響到菜品的展示，從而影響到客户的訂單。</span><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">例：在【客户消費】場景下</span></strong></p><p><img class="rich_pages wxw-img" data-imgfileid="100024668" data-ratio="0.29259259259259257" src="https://oscimg.oschina.net/oscnet/a4ffc3a9-e55e-4ee4-811a-5e6adfe115c2.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">客户的訂單、影響廚房生產的菜，從而影響刀工的行為，也影響到了採購。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">請對比下面兩個圖，用於理解領域的上下游</span></strong></p><p><img class="rich_pages wxw-img" data-imgfileid="100024671" data-ratio="0.37222222222222223" src="https://oscimg.oschina.net/oscnet/e785c504-4faf-4ccb-b87e-b7151c9bbcb0.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"></p><p><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">﻿﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">實際上，廚師不應該依賴採購人員的採購功能，也不依賴刀工的切菜功能，他只是依賴「初加工食材」而已，而「初加工食材」就是被處理好的數據，廚師在做飯時，「初加工食材」就已經被處理好了，上面的圖例只是為了説明一個關於領域上下游的問題，這是業務<strong><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">發生順序</span></strong>以及<strong><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">數據來源</span></strong>的問題。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我們常常使用領域事件串聯業務流程，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">在使用領域事件時，不止要關注點對點的解耦，更應該使業務流程符合領域上下游限定</span>，</span>讓各個領域獨立運行，減少領域之間的功能依賴，降低領域之間的耦合，減少業務變化帶來的影響。</span></p><span id="OSC_h1_8"></span><h1 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">2、架構設計</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h1><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">架構設計是為了<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">解決軟件系統複雜度帶來的問題，找到系統中的元素並搞清楚他們之間關係</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">架構的目標是用於管理複雜性、易變性和不確定性，以確保在長期的系統演化過程中，一部分架構的變化不會對其它部分產生不必要的負面影響。這樣做可以確保業務和研發效率的敏捷，讓應用的易變部分能夠頻繁地變化，對應用的其它部分的影響儘可能地小。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">架構設計三原則：合適原則、簡單原則、演化原則</span><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><span id="OSC_h2_9"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">2.1 分層架構</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我們需要<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">按照，接口層、領域層（領域用例層、領域模型層）</span>、<span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">依賴層、基礎層，構建架構模型</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">接口層：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">為外部提供服務的入口，是適配層的北向網關。不實現任何業務邏輯，也不處理事務，是跨領域的，是流程編排層，是門面服務。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">領域用例層：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">是領域服務層，是領域用例的實現層、隸屬於某個領域、是業務邏輯層，是事務層，業務邏輯應該在這層完整體現，不要分散到其他層級。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">領域模型層：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">是領域模型（實體、值對象、聚合）的所在位置，專注於領域模型自身的能力，不包含業務功能，可以處理事務，是原子化的能力，是領域對象的自我實現<em style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">。</em></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">依賴層：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">是連接外部服務的出口，是適配層的南向網關。包括倉儲，端點、RPC 等，主要作用是領域和外部解耦，用於保持領域的獨立性，是跨領域的。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">基礎層：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">與業務無關的，與領域無關的，通用的技術能力，技術組件等。</span></p><span id="OSC_h2_10"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">2.2 架構映射</span></strong></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">架構的視角，從大到小依次是：系統-&gt;應用（微服務）-&gt;模塊（包）-&gt;子模塊，這樣的從大到小的層級。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">業務領域映射：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我們將劃分好的領域，按照對應的視角映射為對應的元素，領域模型映射到架構模型時，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">應該是視角對等的</span>，</span>如果餐廳是系統、那麼廚房就是應用，如果餐廳是應用、那麼廚房就是模塊。<span style="font-size: 15px;color: rgb(0, 82, 255);">也應該層級匹配的，</span>將用例的實現映射到用例層，將領域模型的實現映射到領域模型層。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">技術和抽象問題：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">有時候、業務領域分析不能體現那些共性的技術問題，所以需要適當結合技術視角，可能需要對領域模型微調。同時、我們需要找到共同需要的基礎能力，例如「水」、「電」、「煤氣」等等，將這些作為額外的考慮因素，要做到<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">業務問題與技術問題解耦，不要將技術問題和業務邏輯揉成一團</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">領域設計，類似餐廳設計師，他設計餐廳有幾個區域，區域的用途是什麼。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">架構設計，類似建築設計師，他設計如何走水電煤氣、如何施工等。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">產出物：分層架構圖</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">以廚房為視角，其架構如下</span></strong></p><p><img class="rich_pages wxw-img" data-imgfileid="100024667" data-ratio="0.568039950062422" src="https://oscimg.oschina.net/oscnet/27a6f4f5-c098-49fd-b107-29a2889433ed.png" data-type="png" data-w="801" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">以餐廳為視角，其架構如下</span></strong></p><p><img class="rich_pages wxw-img" data-imgfileid="100024672" data-ratio="0.5816203143893591" src="https://oscimg.oschina.net/oscnet/57e1f389-d39a-4c65-a624-60ea4946afc6.png" data-type="png" data-w="827" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">分層架構圖，體現邏輯上的層級分佈，而不是代表組件的具體含義，組件是應用還是模塊、需要結合實際情況而定。</span></p><span id="OSC_h2_11"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">2.3 必要的約束</span></strong></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">1、分層架構越往下層就越是穩定的：下層是被上層依賴的，下層不可以反向依賴上層（擴展點除外）。因為分層架構的核心原則是將容易變化的邏輯上浮，將共性的、原子化的、通用的邏輯下沉，被依賴的下層應該是穩定的，這要求上層承接更多業務變化。下層離開上層應該是可以獨立存在的，例如在接口層定義的 DTO 不可以在下層被使用，但領域層定義的實體可以被上層使用。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">2、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">在使用充血模型時，應該符合面向對象編程原則</span>：</span>不要隨意的將一些能力都充到領域實體模型中。以「菜」為例，重量和規格是「菜」的自身的屬性，激發味蕾是「菜」的能力，「菜」可以維護自身的持久化狀態。但是、請注意、「菜」不可以「炒菜」，因為「炒菜」的時候，「菜」還沒有出現呢，「菜」不是自己的上帝，「菜」需要被做出來，所以「菜」被做出來之前是沒有「菜」的，這是個時間上的概念，不要錯把「炒菜」的能力放在「菜」的身上。「炒菜」用到的「水+電+氣+食材+調料+廚具」不應該是「菜」的屬性範圍，這些元素都在「廚房」的範圍中，<span style="font-size: 15px;color: rgb(0, 82, 255);">不要讓領域的模型包含不屬於自身的元素，領域的實體模型只是領域的一部分，只用於實現通用的模型能力。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">3、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">接口層和依賴層是與領域無關的</span>：</span>他們是與技術相關的層級，不屬於任何領域，這兩層不能包含業務邏輯。有時候我們可以把接口層拆為兩層（接口層+應用層），也可以把依賴層拆分為兩個（模型依賴、服務依賴）。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">4、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">領域層是與環境無關的</span>：</span>無論某個領域是應用還是模塊，都應該具備獨立的用例層和獨立的模型層，即使多個領域在同一個應用當中，也要按照他們是分別獨立去看待，無論某個領域是應用還是模塊，<span style="font-size: 15px;color: rgb(0, 82, 255);">領域對外部的交互，不可以繞過依賴層和接口層。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">5、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">領域應該是最小完備的</span>：</span>把一個領域拆分為子域、子子域、子子子...... 無限拆分，拆分到一定程度之後，某個子域就不完整了，<span style="font-size: 15px;color: rgb(0, 82, 255);">不完整的子域是不可以獨立存在的。</span>拆分不不夠或者過度拆分，都是不符合低耦合高內聚原則的。<span style="font-size: 15px;color: rgb(0, 82, 255);">當一個領域的內部子域不具備獨立性時，他們之間不必嚴格解耦，不需要通過依賴層訪問本領域的其他子域，他們之間可以直接調用。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">6、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">領域服務層就是領域用例層</span>：</span>他們倆是同一回事兒，都是用於實現領域內的用例的。<span style="font-size: 15px;color: rgb(0, 82, 255);">不要將領域服務與領域用例視為兩個獨立的層，也不要將領域服務與領域模型視為同一層，</span>否則會導致邏輯的分散（一部分在領域服務層、一部分在領域模型層、還有一部分可能在用例層），也會導致每個層的職責不明確，容易搞亂。如果將業務邏輯寫在領域模型中，會導致業務邏輯進一步下沉，業務邏輯的不確定性太大，是不適合下沉的，是違反分層架構原則的。<span style="font-size: 15px;color: rgb(0, 82, 255);">領域模型對應的是實體、領域服務對應的是用例。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">7、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">領域用例層只能承接符合自身領域的用例</span>：</span>我們劃分出領域的目的，就是為了區分每個領域的職責所在，因此他們必須嚴格按照職責辦事，我們在之前已明確了用例和領域之間的關係，需要嚴格遵守。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">8、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">領域模型層遵循最小依賴原則</span>：</span>只可以依賴必要的資源，必要資源指的是領域模型實現自身能力需要的資源，不包括實現業務邏輯包含的資源。例如領域模型需要依賴 DB 完成持久化，可以依賴數據訪問資源，但不應該依賴其他領域資源、不可以依賴 RPC 資源等。</span></p><span id="OSC_h2_12"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">2.4 微服務劃分</span></strong></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">服務劃分以領域劃分為參考，主要看我們要拆分到什麼粒度，這 <span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">應該符合低耦合高內聚原則，不破壞領域實體的聚合關係</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物：微服務</span><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">例如餐廳：是有必要拆分的，餐廳的「菜品域」，「訂單域」，「廚房域」有獨立的問題空間。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">例如廚房：是沒有必要拆分的，廚師與刀工的耦合非常高，他們都在做飯，分開之後是不完整的，分開就是沒有必要的。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">所以餐廳被拆分為：廚房（Kitchen）、菜品（Category）、訂單（Order）三個微服務。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">基於此、我們單獨拿出<strong><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">餐廳門面服務</span></strong>作為接口層應用，再單獨拿出<strong><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">餐廳基礎服務</span></strong>作為水電煤氣的應用。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">一般情況下，依賴層不會作為單獨的服務提供，會被以組件的形式嵌入到其他服務中。</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024673" data-ratio="0.4546296296296296" src="https://oscimg.oschina.net/oscnet/a75f1afb-0c1f-4d71-8cb5-b6e8c1b0bfec.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"></p><span id="OSC_h1_13"></span><h1 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3、功能設計（用例實現）</span></strong></h1><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">如果説領域設計是餐廳的設計師、架構設計是餐廳的建築師、那麼功能設計就是餐廳的廚師或服務員。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">任何設計都要落地到功能設計，如果廚師不守規則，偏偏要去洗手間洗菜，最後的結果依然是一團亂，最終會導致設計無法落地。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">功能設計是實現 「面向擴展開放、面向修改關閉」 的途徑，是指導研發落地必備環節。</span></p><span id="OSC_h2_14"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.1 功能的概念</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">功能迭代時，功能會發生一些變化，所以他的含義是可能變化的，所以我們需要再次審視功能的概念，及時加以調整。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">例如、我們實現了一個「做蛋炒飯」的功能，後來又實現了一個「做辣椒炒蛋」的功能，那麼我們應該將功能升級為「炒菜」，甚至是「製作菜品」等。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">明確功能的概念，是功能設計的前提。</span><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物：更新語言庫，更新腦圖</span></p><span id="OSC_h2_15"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.2 用例的位置</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我們在領域分析章節，已明確了<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">用例與角色的關係，用例與領域的關係</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">然而一個新功能的加入，我們仍然要再次評估，以確保他處於正確的位置。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物：更新用例圖</span><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><span id="OSC_h2_16"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.3 事件風暴</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">我們需要深入功能的細節，首推的方法是事件風暴，適用於解構複雜功能。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">事件風暴的作用並不限於功能分析，只是我覺得很適用於功能分析，事件風暴的一張圖包含很多內容，正好是功能設計所需要的。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">將功能拆分為多個子功能（步驟）。</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">（在後續使用）</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">確認參與該步驟的角色和領域。</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">（在後續的 3.6 章節落地）</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">確認步驟的串聯流程和領域事件。</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">（在後續的 3.6 章節落地）</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">確認參與該步驟的領域實體。</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">（在後續的 3.7 章節落地）</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物：事件風暴模型</span></p><span id="OSC_h2_17"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.4 用例分析</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">我們暫且收回思路，首先要關注共性和差異問題，以確保功能的擴展性。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">確認用例的泛化+差異點，實現功能的擴展。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">尋找共同包含的步驟，實現邏輯的複用。</span><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物：用例分析圖</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">例：製作菜品（做大拌菜、做鐵鍋燉、做炒雞蛋、做蒸米飯、做炒米飯）</span></strong></p><p><img class="rich_pages wxw-img" data-imgfileid="100024674" data-ratio="0.590443686006826" src="https://oscimg.oschina.net/oscnet/3d972a5e-7349-4ac8-b30a-4da19b1aa1d5.png" data-type="png" data-w="879" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"></p><p><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">﻿﻿</span><strong style="font-size: 16px;letter-spacing: 0.034em;"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.5 用例實現類（領域服務類）結構圖</span></strong></p><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">專注於用例層的類設計，實現「面相修改關閉，面相擴展開放」。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">用例的類結構圖是用例分析圖的一種映射。</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">出物：用例層的類結構圖</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024676" data-ratio="0.7601851851851852" src="https://oscimg.oschina.net/oscnet/efec1931-71d9-4241-9f9b-dfc1c268782f.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><span id="OSC_h2_18"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.6 用例流程圖</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">我們接回思路，更進一步，將事件風暴模型落實到代碼層面。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我們<span style="font-size: 15px;color: rgb(0, 82, 255);">將步驟分配到實現類中、步驟就是該類的一個方法，</span>進一步明確由哪個類和方法來實現該步驟，從而就規定了步驟所在的領域。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我們<span style="font-size: 15px;color: rgb(0, 82, 255);">將步驟和領域事件串聯起來，規定了業務實現流程。</span>推薦使用泳道圖表達上述內容。泳道的縱向組件是用例的實現類。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">這是真實業務流程的映射。</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物：用例流程圖</span><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">以炒雞蛋為例，其用例流程圖如下</span></strong><span style="font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024675" data-ratio="0.5287037037037037" src="https://oscimg.oschina.net/oscnet/0fdde59e-7025-468d-89b7-746265e0220c.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><span id="OSC_h2_19"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.7 活動圖（時序圖）</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我們進一步將事件風暴模型落實到代碼層面，我們<span style="font-size: 15px;color: rgb(0, 82, 255);">使用時序圖，體現依賴和調用關係，規定了步驟與領域實體模型的關係，</span>進一步説明用例是如何實現的。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">這時候，為了簡便、我們可以收起領域服務類（用例層）的泳道。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">產出物：時序圖、活動圖</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024677" data-ratio="0.7818361303060217" src="https://oscimg.oschina.net/oscnet/6cbb7948-b8d2-4075-aeab-c0939bed59da.png" data-type="png" data-w="1013" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"><em style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">試想一下、假如把業務邏輯放在領域模型當中（例如聚合），如何實現「面相擴展開放、面相修改關閉」呢？</em></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><span id="OSC_h1_20"></span><h1 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">4、編碼實現</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h1><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">編碼實現...... &nbsp;我決定還是...... &nbsp;偷個懶吧...... &nbsp;哈哈哈。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">但是我們回顧一下之前的內容，是否足夠了？不同的研發人員依照設計去編碼，是否會寫出不一樣的代碼？</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">最後、我們的目標是「解決軟件複雜度帶來的問題」，而實現這個目標的途徑是「設計指導研發落地」。</span><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><p><br></p><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公眾號 - 京東雲開發者（JDT_Developers）。<br>如有侵權，請聯繫 support@oschina.cn 刪除。<br>本文參與「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源創計劃</a>」，歡迎正在閲讀的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 01:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10675650</guid>
            <link>https://my.oschina.net/u/4090830/blog/10675650</link>
            <author>
                <![CDATA[京東雲開發者]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[探索 Zadig 自測模式，一套環境多人協同，釋開發者創造力！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><div><div><div><div><div><div><p style="margin-left:0; margin-right:0"><img alt="" src="https://oscimg.oschina.net/oscnet/up-0d0eca0dd098c1cd307613306af4a974609.png" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">在日常開發中，研發工程師經常遇到環境不足、環境管理混亂以及互相搶佔環境的問題，這種情況不僅使得研發工程在等待環境準備和切換中花費大量寶貴的工作時間，無法充分發揮創造性，還直接影響了項目的進度和質量。對於業務架構簡單、服務數量較少的情況，往往會選擇擴展出一套完整的新環境來滿足不同研發同時自測聯調的訴求，減少不必要的等待時間。而面對複雜的業務場景，一套測試環境中可能包含成千上百個服務，額外搭建這樣一套完整的環境成本極高，甚至由於一些服務的基礎架構的原因，複製多套環境幾乎不可能。</p><div><img height="940" src="https://pic1.zhimg.com/80/v2-aaa680bac5f2ab99ffc7ac984730c2d4_1440w.webp" width="976" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">為了應對上述痛點問題，Zadig 提出了一種低成本搭建子環境的解決方案。在 Zadig 自測模式的子環境中，只需部署少量服務，並與基準服務進行交互，實現了更為高效的開發和聯調流程。</p><p style="margin-left:0; margin-right:0">在本文中，我們將深入探討 Zadig 自測模式的基本原理、應用場景、管理員操作細節和工程師在日常使用中的實際操作等。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_1"></span><h2><strong>基本原理</strong></h2><div><img src="https://pic4.zhimg.com/80/v2-3569090a3b2610750992ee5a07320383_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">自測模式是 Zadig 為降低環境管理複雜度和部署成本而推出的一種面向開發者的功能模塊。當開啓了環境的自測模式後，該環境則成為基準環境，該環境擁有完整的服務調用鏈。沒有灰度標的請求會在基準環境中進行調用，調用鏈路為<em><strong><span>&nbsp;</span><span style="background-color:#dddddd">A -&gt; B -&gt; C</span></strong></em>。</p><p style="margin-left:0; margin-right:0">當開發者需要進行開發、聯調時，比如涉及到到 A 和 C 兩個服務的變更，可以基於基準環境新建 dev1 子環境，該子環境中僅部署變更後的 A 和 C 服務，即 A' 和 C'。聯調時請求加上灰度標，如在 http header 中設定<strong><em><span>&nbsp;</span><span style="background-color:#dddddd">x-env=dev1&nbsp;</span></em></strong>的灰度標，此時請求會按照<span>&nbsp;</span><strong><em><span style="background-color:#dddddd">A' -&gt; B -&gt; C'</span></em></strong><span style="background-color:#dddddd">&nbsp;</span>進行。</p><p style="margin-left:0; margin-right:0">同理，當開發、聯調時僅涉及到 B 和 C 兩個服務的變更時，可以基於基準環境新建 dev2 子環境，該子環境僅部署變更後的 B 和 C 服務，即 B'' 和 C''。聯調時加上灰度標<span style="background-color:#dddddd">&nbsp;</span><em><strong><span style="background-color:#dddddd">x-env=dev2</span></strong></em>，這樣請求按照<span>&nbsp;</span><em><strong><span style="background-color:#dddddd">A -&gt; B'' -&gt; C''</span></strong></em><span style="background-color:#dddddd">&nbsp;</span>進行。</p><span id="OSC_h2_2"></span><h2>&nbsp;</h2><span id="OSC_h2_3"></span><h2><strong>應用場景</strong></h2><p style="margin-left:0; margin-right:0">Zadig 的自測模式支持用較低成本快速拉起包括部分服務的子環境，在子環境中開發、變更目標服務，並和包括全量服務的基準環境交互來實現自測聯調，企業可使用自測模式解決的問題包括但不限於：</p><p style="margin-left:0; margin-right:0">1. 開發頻率快，業務驗證需求旺盛，亟需小快跑的方式迭代業務，但缺乏相關工程底座建設。</p><p style="margin-left:0; margin-right:0">2. 微服務的數量大，業務複雜度高，導致建設一套完整的環境成本高，代價大。</p><p style="margin-left:0; margin-right:0">3. 部分微服務因基礎技術架構等原因，無法完整地複製出多套完整環境，導致多個團隊綁定在一個環境中，環境穩定性難保障。</p><p style="margin-left:0; margin-right:0">4. ......</p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_4"></span><h2><strong>如何使用</strong></h2><p style="margin-left:0; margin-right:0">下面以<em><strong><span>&nbsp;</span><span style="color:#3498db"><span style="background-color:#dddddd">simple-service</span></span><span>&nbsp;</span></strong></em>為例來説明如何配置和使用 Zadig 自測模式。項目背景以及自測聯調需求説明如下：</p><p style="margin-left:0; margin-right:0">1. 項目中共包括 3 個微服務 a、b、c，服務調用鏈路：a -&gt; b -&gt; c</p><p style="margin-left:0; margin-right:0">2.<em>dev<span>&nbsp;</span></em>環境為日常完整穩定的測試環境，包括全部微服務 a、b、c</p><p style="margin-left:0; margin-right:0">3. 日常會對 a 服務進行高頻改動，希望能對 a 服務進行充分自測，確保其變更可交付</p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h3_5"></span><h3><strong>管理員：配置自測模式</strong></h3><p style="margin-left:0; margin-right:0"><strong>步驟 1：開啓自測模式</strong></p><p style="margin-left:0; margin-right:0">訪問<span style="background-color:#dddddd">&nbsp;</span><em><strong><span style="background-color:#dddddd">dev</span></strong></em><span style="background-color:#dddddd">&nbsp;</span>環境 &gt; 更多 &gt; 點擊開啓自測模式</p><div><img src="https://pic4.zhimg.com/80/v2-7b890f74b62982518abdaf65c03685a7_1440w.webp" width="690" referrerpolicy="no-referrer"></div><div><img src="https://pic2.zhimg.com/80/v2-86baeb0dc983dc5f93a90ed2feba0b81_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">這時會對自測模式的依賴條件做檢查：</p><p style="margin-left:0; margin-right:0">1. 業務架構實現全鏈路數據透傳能力或者使用 Tracing 組件。系統無法自動檢查，需要管理員自行確保，此處支持較為廣泛應用的 SkyWalking、Zipkin、Jaeger 等。</p><p style="margin-left:0; margin-right:0">2. 系統會對 Istio 是否安裝做自動檢查，如果沒有請在環境所在集羣進行安裝</p><p style="margin-left:0; margin-right:0">3. 服務調用鏈自動檢查，主要依據是有 K8s Service 類型的資源和服務 a、b、c 對應</p><p style="margin-left:0; margin-right:0">當開啓自測模式後，<em><span style="background-color:#dddddd">dev&nbsp;</span></em>環境即成為基準環境。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><strong>步驟 2：配置入口服務</strong></p><p style="margin-left:0; margin-right:0">若需要在子環境中添加並聯調入口服務，即本項目中<em><span>&nbsp;</span><strong><span style="background-color:#dddddd">a&nbsp;</span></strong></em>服務，則需要在基準環境中，配置入口服務的 Istio 網關。並將配置的訪問地址解析到集羣 istio-ingressgateway service 的外網訪問地址上，如下圖所示。</p><div><img src="https://pic2.zhimg.com/80/v2-7d041ec097ffe3fe94015bbe8f537165_1440w.webp" width="690" referrerpolicy="no-referrer"></div><div><img src="https://pic2.zhimg.com/80/v2-14f4bd70d8f00152a5eb358b250679c9_1440w.webp" width="690" referrerpolicy="no-referrer"></div><span id="OSC_h3_6"></span><h3>&nbsp;</h3><span id="OSC_h3_7"></span><h3><strong>工程師：日常自測聯調</strong></h3><p style="margin-left:0; margin-right:0"><strong>創建子環境</strong></p><p style="margin-left:0; margin-right:0">在 dev 基準環境中通過點擊<span>&nbsp;</span><em><strong><span style="background-color:#dddddd">創建子環境</span></strong></em>，選擇 a 服務可創建包含 a 服務的子環境<span>&nbsp;</span><em><strong><span style="background-color:#dddddd">dev-subenv1</span></strong></em>。</p><div><img src="https://pic4.zhimg.com/80/v2-454a167d92a068bc2feea3a3c61556db_1440w.webp" width="690" referrerpolicy="no-referrer"></div><div><img src="https://pic1.zhimg.com/80/v2-e68c0d0aab9efaf0e0a63f250860ada8_1440w.webp" width="690" referrerpolicy="no-referrer"></div><div><img src="https://pic4.zhimg.com/80/v2-585b3bba48ecaf31b7c53f1454006177_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><strong>請求驗證</strong></p><p style="margin-left:0; margin-right:0">當需要請求服務 a 時，在請求頭部加入<span>&nbsp;</span><em><strong><span style="background-color:#dddddd">x-env=dev-subenv1</span></strong></em><span style="background-color:#dddddd">&nbsp;</span>即可將請求流量轉發到子環境<span>&nbsp;</span><em><strong><span style="background-color:#dddddd">dev-subenv1</span></strong></em><span style="background-color:#dddddd">&nbsp;</span>中，實現子環境和<strong><span>&nbsp;</span></strong><em><span style="background-color:#dddddd">dev</span></em><span>&nbsp;</span>環境的自測聯調。測試效果如下所示：</p><p style="margin-left:0; margin-right:0">1. 增加<span>&nbsp;</span><em><strong><span style="background-color:#dddddd">x-env=dev-subenv1</span></strong></em><span style="background-color:#dddddd">&nbsp;</span>請求頭訪問服務 a，子環境中的服務 a 會接收到請求並給出響應，對於請求鏈路上的 b 和 c 服務，<em><span style="background-color:#dddddd">dev</span></em><span>&nbsp;</span>環境中的服務會給出正常響應。</p><div><img src="https://pic1.zhimg.com/80/v2-f4d69dfe4cd4ba380ebc2f696852b2b4_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">子環境 dev-subenv1 中&nbsp;<em><strong><span style="background-color:#dddddd">a</span></strong><span style="background-color:#dddddd">&nbsp;</span></em>服務的日誌：</p><div><img src="https://pic2.zhimg.com/80/v2-2bbe8c22df5df855985ff74c49a765b9_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">2. 執行不帶任何頭部信息的請求，直接請求服務 a，<em><strong><span style="background-color:#dddddd">dev</span></strong><span>&nbsp;</span></em>環境中的服務 a、b、c 會處理請求，子環境中無請求流量輸入。</p><div><img src="https://pic4.zhimg.com/80/v2-a1d064a8b4dd98a88c0e72ff3a1820f3_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">基準環境 dev 中<em><strong><span>&nbsp;</span>a<span>&nbsp;</span></strong></em>服務的日誌：</p><div><img src="https://pic4.zhimg.com/80/v2-e770e666e0996145de47c3e3447f0817_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">Zadig 的自測模式是為開發者量身定製的解決方案，適用於多人協同開發、業務規模大、服務相互關聯、日常變更頻繁的場景。傳統測試環境所帶來的有限資源、高成本、複雜性等問題，在 Zadig 的自測模式下迎刃而解。</p><p style="margin-left:0; margin-right:0">通過低成本搭建子環境、靈活部署少量服務，Zadig 的自測模式使開發者能夠在獨立的測試環境中進行高效工作，擺脱了對同一測試環境的爭奪，提升了開發流程的質量和效率。</p><p style="margin-left:0; margin-right:0">歡迎大家下載試用，體驗更高效的開發方式！</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center">&nbsp;</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">立即體驗 Zadig V2.0 新架構，開啓高效交付之旅！🚀&nbsp;</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><strong><span style="color:#ff2968">Zadig 開放，鏈接，專業</span></strong></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-16e6b25cd9b3c92bc711c17b21e99e9b040.png" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491363%26idx%3D1%26sn%3Dd6ccb8938f4702f560f28d5b79324cf3%26chksm%3Dcfb45383f8c3da9540c0c3eb1080f729fa2545db2063159b5fb05ddeb818f082e21adb2f9189%26token%3D1376697300%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow">閲讀原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank" rel="nofollow">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig" rel="nofollow">Zadig 在 Gitee</a></p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><strong>推薦閲讀 :&nbsp;</strong><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491441%26idx%3D1%26sn%3D3eb5d7125489434ff567d60ae48ef5e5%26chksm%3Dcfb453d1f8c3dac7a9ba2de20d6d8d37f94ea5a0812030843cde5d9512bd93deb208073ff1bf%26scene%3D21%23wechat_redirect" target="_blank" rel="nofollow">只有大廠才可以有 DevOps 平台？</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank" rel="nofollow">Zadig vs. Jenkins 詳細比對：時代的選擇與開發者之選</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491437%26idx%3D1%26sn%3D4bfa94daef9e61087984cb2ab9e9a6d9%26chksm%3Dcfb453cdf8c3dadbaabff32876f84646767db645228c14c84279b706139db4de6081ed4376e6%26scene%3D21%23wechat_redirect" target="_blank" rel="nofollow">基於 Istio + Zadig，零負擔實現雲原生全鏈路灰度發佈</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491474%26idx%3D1%26sn%3D5f7c40d430e16fcbfa69104c4a46a797%26chksm%3Dcfb45332f8c3da247c792998c84b0885a3b40a534cfd2011e0e7ea30a51cadeeabb37fdba14d%26scene%3D21%23wechat_redirect" target="_blank" rel="nofollow">阿里雲 MSE + Zadig，面向開發者的全鏈路灰度發佈解決方案</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491336%26idx%3D1%26sn%3D805f7d2c44c96cab529ffef120d84ca0%26chksm%3Dcfb453a8f8c3dabe83163a873135f2a72cdddcb9faeecefe5e40f20a358681304484c56cce51%26scene%3D21%23wechat_redirect" target="_blank" rel="nofollow">ZADIG 專家版傾情上線：一鍵高效發佈，119 元/人月起，社區老友享年終福利！</a></p></div></div></div></div></div></div></div><div>
  &nbsp; 
</div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 01:46:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/koderover/blog/10676758</guid>
            <link>https://my.oschina.net/koderover/blog/10676758</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[sms4j 3.1.0 終於發佈啦！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h1>📣📣sms4j 3.1.0 終於發佈啦！📣📣</h1><p>2023 年轉瞬即逝，sms4j 項目在這段時間裏取得了令人矚目的成就。截至目前，我們已經獲得了超過 1300 個 star，這離不開大家對 sms4j 項目的支持和關注，我代表整個開發團隊向大家表示衷心的感謝！</p><p>同時，我很高興地告訴大家，我們的開發團隊正在不斷壯大，並迎來了一批新的成員加入。他們的加入為項目注入了新的活力和創造力。此外，我們還收到了許多建設性的意見和建議，這些寶貴的反饋將有助於我們進一步提升 sms4j 的功能和性能。</p><p>接下來，讓我們一起來瞭解一下本次 3.1.0 版本的更新內容，以及認識一下團隊的新成員吧！在這個版本中，我們增加了一些新的特性和功能，以滿足用户不斷增長的需求。同時，我們也修復了一些已知的問題和 bug，提升了系統的穩定性和可靠性。</p><p>如果我們的項目對你產生了幫助，或者你覺得還算值得鼓勵，請用你發財的小手幫助點上一個 start</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsms4j.com" target="_blank">官網地址</a></p><p><a href="https://gitee.com/dromara/sms4j">gitee 倉庫</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdromara%2Fsms4j" target="_blank">github 倉庫</a></p><h2>新增功能：</h2><ul><li><p>聯麓短信：我們新增了對聯麓短信的支持，現在可以像使用其他廠商一樣方便地進行使用。</p></li><li><p>鼎眾短信：我們還新增了對鼎眾短信的支持，鼎眾短信可以發送無模板短信，有需要的小夥伴可以嘗試一下。</p></li><li><p>OA 通知：在 3.1 版本中，我們正式加入了對 OA 通知的支持，兼容釘釘、飛書和企業微信。</p></li></ul><h2>優化功能：</h2><ul><li><p>郵件功能優化：現在郵件發送可以直接發送 HTML 字符串，並且可以存在模板變量。</p></li><li><p>標準短信方法優化：我們添加了一個方法，該方法用於發送固定模板下的多參數模板短信。</p></li><li><p>全局黑名單功能優化：在這次的更新中，我們重構了底層對於短信失敗重試和短信黑名單的功能，現在它變得更加輕量、更加穩定。</p></li><li><p>新增方法 reload 和 reloadAll：我們在核心工廠類（SmsFactory）中新增了方法 reload 和 reloadAll，用於重新從接口實現中讀取並重新實例化短信對象。這樣可以極大地減少對於重新讀取配置的工作量。</p></li></ul><h2>修復問題：</h2><ul><li><p>合一短信 HMAC 模式下簽名無效的問題：我們修復了合一短信在 HMAC 模式下簽名無效的問題。</p></li><li><p>郵件插件 JDK17 的適配：我們修復了郵件插件在 JDK17 上的適配問題。</p></li><li><p>容聯雲短信發送失敗問題：我們修復了容聯雲短信發送失敗的問題。</p></li><li><p>阿里雲短信在個別情況下報簽名錯誤問題：我們修復了阿里雲短信在個別情況下報簽名錯誤的問題。</p></li><li><p>雲片短信在無模板下報錯的問題：我們修復了雲片短信在無模板下報錯的問題。</p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 00:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275005/sms4j-3-1-0-released</guid>
            <link>https://www.oschina.net/news/275005/sms4j-3-1-0-released</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[2023 年中國軟件名城評估結果公佈：深圳、杭州、北京獲得最高三星評級]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>工信部近日印發《工業和信息化部關於 2023 年中國軟件名城評估結果的通告》，<strong>確定了 2023 年中國軟件名城評估結果</strong>。</p><p>1、<strong><span style="background-color:#e67e22">深圳</span></strong>：★★★</p><p>2、<strong><span style="background-color:#e67e22">杭州</span></strong>：★★★</p><p>3、<strong><span style="background-color:#e67e22">北京</span></strong>：★★★</p><p>4、南京：★★</p><p>5、上海：★★</p><p>6、成都：★★</p><p>7、濟南：★★</p><p>8、武漢：★★</p><p>9、廣州：★★</p><p>10、蘇州：★★</p><p>11、青島：★★</p><p>12、廈門：★★</p><p>13、福州：★★</p><p>14、無錫：★★</p><hr><p>工信部 2017 年印發了《中國軟件名城創建管理辦法（試行）》，目前已授牌&nbsp;14 個名城。</p><p>申請創建中國軟件名城的城市需為<strong>地級及以上</strong>。同時需具備以下條件：</p><ul><li><p>一是軟件和信息技術服務業基礎良好、規模較大、發展潛力較強，對國民經濟的貢獻程度較高，擁有若干全國知名度較高的骨幹軟件企業和若干全國市場佔有率較高的軟件產品，創新能力較強，產業特色鮮明、生態較好；</p></li><li><p>二是軟件和信息技術服務業帶動效應明顯，對拉動經濟增長、促進就業、加速傳統行業數字化轉型，以及提升城市管理和社會服務水平具有重要支撐作用，對城市文化塑造及品牌提升具有積極影響；</p></li><li><p>三是產業政策支持力度較大，具有較為豐富的科技、教育、人才等資源條件和良好的城市人文環境，具有較為完善的適合軟件和信息技術服務業集聚發展的物理載體環境，產業基地園區、公共服務平台等建設情況良好。</p></li><li><p>此外，申請城市及所屬省級人民政府要對發展軟件和信息技術服務業高度重視，並積極主動開展名城創建工作。</p></li></ul><p>2022 年 12 月，<strong><u><a href="https://www.oschina.net/news/221868">工信部發布了關於印發中國軟件名城（園）管理辦法的通知</a></u></strong>，進一步規範名城、名園管理工作，新的管理辦法將對中國軟件名城、名園動態管理實行<strong>退出機制</strong>。</p><p>通過每年組織開展評估工作，以星級體現（最高級為三星，星級越高發展質量越好）評估結果，充分調動地方發展軟件和信息技術服務業的積極性。<strong>對評估結果為一星的名城、名園，工業和信息化部給予提醒，責令整改；對連續兩年評估結果為一星的，公告退出</strong>。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 10:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274956</guid>
            <link>https://www.oschina.net/news/274956</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[工信部：到 2027 年，制定雲計算國家標準和行業標準達 50 項以上]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>工信部<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fgzcy%2Fyjzj%2Fart%2F2024%2Fart_0dba24687491428a8939060c79ee358a.html" target="_blank">徵集</a>對《雲計算綜合標準化體系建設指南》（徵求意見稿）（以下簡稱《指南》）的意見。</p><p><img height="264" src="https://oscimg.oschina.net/oscnet/up-249312eb4a023d062a0a406036a6f3ae7a6.png" width="500" referrerpolicy="no-referrer"></p><p>《指南》明確，到 2025 年，雲計算標準體系更加完善。推進修訂參考架構、術語等基礎標準，優先制定雲計算創新技術產品、新型服務應用和重要缺失領域的關鍵標準。開展雲原生、邊緣雲、混合雲、分佈式雲等重點技術與產品標準研製，制定一批新型雲服務標準，面向製造、軟件和信息技術服務、信息通信、金融、政務等重點行業領域開展應用標準建設。</p><p>到 2027 年，制定雲計算國家標準和行業標準達 50 項以上，基本覆蓋基礎、技術與產品、服務、應用、管理、安全等各類研製方向，有效滿足我國產業標準化新階段需求。結合雲計算產業發展情況及各行業用户上雲用雲需求，推動雲計算國行團標落地實施。提高國際標準參與度與轉化率，協同推進互聯互通與標準開放。</p><p>《指南》指出，立足我國雲計算產業發展及生態系統建設新階段，總結現階段雲計算標準體系建設成效，結合國內外雲計算技術演進趨勢和關鍵挑戰，研究分析各領域方向的標準制定和缺失情況，在《雲計算綜合標準化體系建設指南》（工信廳信軟〔2015〕132 號）基礎上，修訂更新雲計算綜合標準化體系，以指導具體標準的立項與制定。修訂後的雲計算綜合標準化體系結構見圖 1，包括「01 基礎標準」、「02 技術與產品標準」、「03 服務標準」、「04 應用標準」、「05 管理標準」和「06 安全標準」六個部分。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 10:10:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274952</guid>
            <link>https://www.oschina.net/news/274952</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[雲原生週刊：K8sGPT 加入 CNCF]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>開源項目推薦</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbackube%2Fvolsync" target="_blank">VolSync</a></h3><p>VolSync 使用 rsync 或 rclone 在集羣之間異步複製 Kubernetes 持久卷。它還支持通過 Restic 創建持久卷的備份。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopenclarity%2Fkubeclarity" target="_blank">KubeClarity</a></h3><p>KubeClarity 是一種用於檢測和管理軟件物料清單 (SBOM) 以及容器映像和文件系統漏洞的工具。它掃描運行時 K8s 集羣和 CI/CD 管道，以增強軟件供應鏈的安全性。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmariadb-operator%2Fmariadb-operator" target="_blank">mariadb-operator</a></h3><p>以雲原生方式運行和操作 MariaDB。使用 Kubernetes CRD 而不是命令式命令以聲明方式管理 MariaDB 。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpadok-team%2Fburrito" target="_blank">Burrito</a></h3><p>Burrito 是 TACoS（Terraform 自動化協作軟件）Kubernetes 運營商。它解決了管理基礎架構狀態漂移、為 Terraform 編寫 CI/CD 流水線以及提供 Terraform 狀態修改可見性的挑戰。</p><h2>文章推薦</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmedium.com%2F%40kylelzk%2Fkubernetes-theory-understanding-kubernetes-components-a-deep-dive-ac31b7463df2" target="_blank">理解 Kubernetes 組件：深入探討</a></h3><p>這篇文章深入介紹了 Kubernetes 組件，幫助讀者全面瞭解這個強大的容器編排平台。文章首先介紹了 Kubernetes 的架構，包括主要組件和它們的功能，如 kube-apiserver、etcd、kube-scheduler、kube-controller-manager 和 cloud-controller-manager。接下來，文章討論了運行在每個節點上的節點組件，如 kubelet、kube-proxy 和容器運行時。然後，文章介紹了一些附加組件，如 DNS、Web UI（Dashboard）、容器資源監控和集羣級別的日誌記錄。最後，文章討論了網絡組件和存儲組件，包括 CNI、Ingress、Service、Persistent Volumes 和 Storage Classes。通過深入瞭解這些組件的作用和功能，開發人員和管理員可以充分利用 Kubernetes 的功能，有效地管理和擴展他們的應用程序。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcollabnix.com%2Fwhats-new-in-kubernetes-1-29-mandala-the-universe%2F" target="_blank">Kubernetes 1.29 新增功能：PersistentVolume 訪問模式、節點卷擴展、KMS 加密、調度程序優化等</a></h3><p>這篇文章介紹了 Kubernetes 1.29 版本的新功能和改進。其中包括持久卷訪問模式、節點卷擴展、KMS 加密、調度器優化等方面的內容。文章強調了 Kubernetes 社區的協作精神，並概述了各個穩定、測試和實驗性功能的特點和用途。這些新功能提供了更好的持久性、存儲靈活性和加密能力，同時通過優化調度效率和改進節點生命週期管理，提升了集羣的性能和可靠性。全文通過 Mandala 主題來展示 Kubernetes 的發展和創新，鼓勵讀者參考官方發佈説明，全面瞭解 Kubernetes 1.29 版本的變化，並共同探索容器編排的未來。</p><h2>雲原生動態</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fk8sgpt.ai%2Fblog%2Fpost-7%2F" target="_blank">K8sGPT 加入 CNCF</a></h3><p>K8sGPT 是一個用於掃描您的 Kubernetes 集羣、以簡單的英語診斷和處理問題的工具。它將 SRE 經驗編碼到其分析器中，並幫助提取最相關的信息，並結合人工智能來豐富分析結果。</p><p>K8sGPT 項目獲選加入 CNCF，成為第一個被接受的 AI + Kubernetes 工具。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpicluster.ricsanfre.com%2Fblog%2F2024%2F01%2F04%2Fannouncing-release-1.8%2F" target="_blank">Kubernetes Pi Cluster 發佈 v1.8</a></h3><p>Kubernetes Pi Cluster 項目的第八個版本（v1.8）發佈了。該版本的主要特性和改進包括：</p><ul><li>K3S 高可用配置：使用 3 個主節點實現高可用性部署，並採用嵌入式 etcd 數據存儲。為了提供 Kubernetes API 的高可用性，使用網絡負載均衡器 HAProxy。</li><li>遷移 Ingress Controller：從 Traefik 遷移到 NGINX。這個遷移的主要原因是使用標準的 Ingress 資源，簡化 Linkerd 集成配置。</li><li>單點登錄（Single Sign-on）：基於 OAuth2.0/OpenID Connect 標準，部署了一個基於 Keycloak 的單點登錄解決方案。Keycloak 是一個開源的身份訪問管理解決方案，支持集中身份驗證和授權服務。</li><li>新增 Kafka 服務：添加 Kafka 作為事件流平台，實現面向數據驅動的微服務架構。部署 Kafka Schema Registry，用於集中管理 Kafka 生產者和消費者的模式。</li></ul><blockquote><p>本文由博客一文多發平台 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenwrite.cn%3Ffrom%3Darticle_bottom" target="_blank">OpenWrite</a> 發佈！</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 09:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4197945/blog/10726775</guid>
            <link>https://my.oschina.net/u/4197945/blog/10726775</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
    </channel>
</rss>
