<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 17 Nov 2023 03:15:34 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[微軟確認為 Windows 10 引入 AI 助手 Copilot]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/news/265760">與之前的傳言相印證</a></u>，微軟宣佈計劃在 Windows 10 版本 22H2 中添加 AI 助手 Copilot。Copilot 將包含在 Windows 10 家庭版和專業版中。該更新的發佈日期尚未公佈，預計在不久的將來發布。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2023%2F11%2F16%2F23963576%2Fmicrosoft-copilot-windows-10-ai-features-release-preview" target="_blank">在一份新聞稿中</a></u>，<strong>微軟表示在向 Windows 11 用户提供 Copilot 時收到了"很好的反饋"</strong>。與之前不為 Windows 10 22H2 提供主要功能升級的計劃不同，微軟現在決定"進行額外投資，以確保每個人都能從他們的 Windows PC 中獲得最大價值，包括 Windows 中的 Copilot（預覽版）"。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-6116c383b7c3be2c7b4c9bf35cc44cda3ea.png" referrerpolicy="no-referrer"></p><p>值得注意的是，<strong>並非所有 Windows 10 電腦都能運行 Copilot</strong>。根據微軟的要求，<strong>您的設備必須配備 720p 顯示屏（或更高分辨率）和至少 4GB 內存</strong>。此外，某些 Windows 10 版本將無法使用 Copilot，至少暫時無法使用。</p><p>由組織管理的版本為 22H2 的 Windows 10 專業版設備將不包含在 Copilot 在 Windows 中的初始推廣中。版本 22H2 的 Windows 10 企業版和教育版設備也不會被納入 Copilot in Windows 的初始推廣範圍。</p><p>微軟所使用的措辭提供了一種可能性，即在某些時候，Copilot 可能會被添加到 Windows 10 的這些版本中。不過，Windows 10 的支持終止日期保持不變。該操作系統的生命週期將於 2025 年 10 月 14 日結束。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e281fe6f97375c953a2fe93f6baebeb2533.png" referrerpolicy="no-referrer"></p><p>除了在不久的將來將 Copilot 引入 Windows 10 之外，微軟還將添加一項新功能，讓用户能夠儘快使用 Copilot 以及其他可能的重要新功能和改進。微軟將在"設置"的"Windows 更新"部分為"發佈預覽版"內部用户添加"一旦有最新更新，立即獲取"切換選項。</p><p>微軟補充説："這將在未來幾個月內通過受控功能推出（CFR）的方式分階段推出。"</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 17 Nov 2023 03:05:55 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266876</guid>
            <link>https://www.oschina.net/news/266876</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Rust 1.74.0 發佈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff"><span style="color:#333333">Rust 1.74.0 穩定版已正式</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.rust-lang.org%2F2023%2F11%2F16%2FRust-1.74.0.html" target="_blank">發佈</a><span style="background-color:#ffffff"><span style="color:#333333">，主要帶來以下變化：</span></span></p><h4 style="text-align:start"><strong><span style="color:#000000"><span style="background-color:#ffffff">通過 Cargo 進行 Lint 配置</span></span></strong></h4><p style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">正如&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frust-lang.github.io%2Frfcs%2F3389-manifest-lint.html" target="_blank">RFC 3389</a>&nbsp;所提議，<code>Cargo.toml</code>manifest&nbsp;現在支持一個<code>[lints]</code>表來配置來自編譯器和其他工具的 lints 的報告級別（禁止、拒絕、警告、允許）。因此，不要使用</span></span><code>-F</code><span style="background-color:#ffffff"><span style="color:#000000">/</span></span><code>-D</code><span style="background-color:#ffffff"><span style="color:#000000">/</span></span><code>-W</code><span style="background-color:#ffffff"><span style="color:#000000">/</span></span><code>-A</code><span style="color:#000000"><span style="background-color:#ffffff">設置 RUSTFLAGS（這會影響整個構建過程），或者使用 crate-level 的屬性，例如：</span></span></p><pre style="text-align:start"><code class="language-rust"><span style="color:#b65611">#![forbid(unsafe_code)]</span><span style="color:#b65611">#![deny(clippy::enum_glob_use)]</span></code></pre><p style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">現在可以將這些寫入 </span></span><span style="color:#000000"><span style="background-color:#ffffff">package manifest&nbsp;</span></span><span style="color:#000000"><span style="background-color:#ffffff">中以供 Cargo 處理：</span></span></p><pre style="text-align:start"><code class="language-toml"><span style="color:#6684e1">[lints.rust]</span>
unsafe_code = <span style="color:#60ac39">"forbid"</span><span style="color:#6684e1">
[lints.clippy]</span>
enum_glob_use = <span style="color:#60ac39">"deny"</span></code></pre><p style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">這些也可以在<code>[workspace.lints]</code>表中配置，然後像許多其他工作區設置一樣由<code>[lints] workspace = true</code>繼承。在決定哪些&nbsp;crates&nbsp;需要重建時，Cargo 還將跟蹤這些設置的更改。</span></span></p><p style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">有關詳細信息，可參閲 Cargo 參考手冊中的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fcargo%2Freference%2Fmanifest.html%23the-lints-section" target="_blank"><code>lints</code></a>和<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fcargo%2Freference%2Fworkspaces.html%23the-lints-table" target="_blank"><code>workspace.lints</code></a>部分。</span></span></p><h4 style="text-align:start"><strong><span style="color:#000000"><span style="background-color:#ffffff">Cargo Registry Authentication</span></span></strong></h4><p style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">此版本中還包含兩個相關的 Cargo 功能：credential providers 和 authenticated private registries。</span></span></p><p style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">Credential providers&nbsp;允許配置 Cargo 如何獲取註冊表的憑證。Built-in providers&nbsp;用於 Linux、macOS 和 Windows 上特定於操作系統的安全秘密存儲。此外，可以編寫自定義 providers 來支持存儲或生成令牌的任意方法。使用安全的 credential provider&nbsp;可以降低註冊表令牌泄漏的風險。</span></span></p><p style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">Registries 現在可以選擇要求對所有操作進行身份驗證，而不僅僅是發佈。這使得 private Cargo registries 能夠提供更安全的 crates 託管。使用 private registries&nbsp;需要配置 credential provider。</span></span></p><p style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">有關更多信息，可參閲&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fbeta%2Fcargo%2Freference%2Fregistry-authentication.html" target="_blank">Cargo 文檔</a>。</span></span></p><h4 style="text-align:start"><strong><span style="color:#000000"><span style="background-color:#ffffff">Projections in opaque return types</span></span></strong></h4><p style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">有關返回「return type cannot contain a projection or Self that references lifetimes from a parent scope」錯誤信息的問題現在已經解決。編譯器現在允許在 opaque return types 中提及<code>Self</code>和關聯類型，例如<code>async fn</code>和<code>-&gt; impl Trait</code>。即使你對"projection"之類的術語一無所知，這種功能也能讓 Rust 更接近你所期望的工作方式。</span></span></p><p style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">不過該功能目前有一個不穩定的 feature gate，因為它的實現最初沒有正確處理 captured lifetimes。有關更多技術細節，可參閲</span></span>&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frust-lang%2Frust%2Fpull%2F115659" target="_blank">stabilization pull request</a><span style="color:#000000"><span style="background-color:#ffffff">。示例：</span></span></p><pre style="text-align:start"><code class="language-rust"><span style="color:#b854d4">struct</span><span style="color:#6684e1">Wrapper</span>&lt;<span style="color:#60ac39">'a</span>, T&gt;(&amp;<span style="color:#60ac39">'a</span> T);

<span style="color:#aaaaaa">// Opaque return types that mention `Self`:</span><span style="color:#b854d4">impl</span> Wrapper&lt;<span style="color:#60ac39">'_</span>, ()&gt; {
    <span style="color:#b854d4">async</span><span style="color:#b854d4">fn</span><span style="color:#6684e1">async_fn</span>() -&gt; <span style="color:#b854d4">Self</span> { <span style="color:#aaaaaa">/* ... */</span> }
    <span style="color:#b854d4">fn</span><span style="color:#6684e1">impl_trait</span>() -&gt; <span style="color:#b854d4">impl</span><span style="color:#b65611">Iterator</span>&lt;Item = <span style="color:#b854d4">Self</span>&gt; { <span style="color:#aaaaaa">/* ... */</span> }
}

<span style="color:#b854d4">trait</span><span style="color:#6684e1">Trait</span>&lt;<span style="color:#60ac39">'a</span>&gt; {
    <span style="color:#b854d4">type</span><span style="color:#6684e1">Assoc</span>;
    <span style="color:#b854d4">fn</span><span style="color:#6684e1">new</span>() -&gt; Self::Assoc;
}
<span style="color:#b854d4">impl</span> Trait&lt;<span style="color:#60ac39">'_</span>&gt; <span style="color:#b854d4">for</span> () {
    <span style="color:#b854d4">type</span><span style="color:#6684e1">Assoc</span> = ();
    <span style="color:#b854d4">fn</span><span style="color:#6684e1">new</span>() {}
}

<span style="color:#aaaaaa">// Opaque return types that mention an associated type:</span><span style="color:#b854d4">impl</span>&lt;<span style="color:#60ac39">'a</span>, T: Trait&lt;<span style="color:#60ac39">'a</span>&gt;&gt; Wrapper&lt;<span style="color:#60ac39">'a</span>, T&gt; {
    <span style="color:#b854d4">async</span><span style="color:#b854d4">fn</span><span style="color:#6684e1">mk_assoc</span>() -&gt; T::Assoc { <span style="color:#aaaaaa">/* ... */</span> }
    <span style="color:#b854d4">fn</span><span style="color:#6684e1">a_few_assocs</span>() -&gt; <span style="color:#b854d4">impl</span><span style="color:#b65611">Iterator</span>&lt;Item = T::Assoc&gt; { <span style="color:#aaaaaa">/* ... */</span> }
}
</code></pre><h4 style="text-align:start"><strong>Stabilized APIs</strong></h4><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fnum%2Fstruct.Saturating.html" target="_blank"><code>core::num::Saturating</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprocess%2Fstruct.Stdio.html%23impl-From%253CStdout%253E-for-Stdio" target="_blank"><code>impl From&lt;io::Stdout&gt; for std::process::Stdio</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprocess%2Fstruct.Stdio.html%23impl-From%253CStderr%253E-for-Stdio" target="_blank"><code>impl From&lt;io::Stderr&gt; for std::process::Stdio</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprocess%2Fstruct.Stdio.html%23impl-From%253CStderr%253E-for-Stdio" target="_blank"><code>impl From&lt;OwnedHandle&gt; for std::process::Child{Stdin, Stdout, Stderr}</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprocess%2Fstruct.Stdio.html%23impl-From%253CStderr%253E-for-Stdio" target="_blank"><code>impl From&lt;OwnedFd&gt; for std::process::Child{Stdin, Stdout, Stderr}</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fffi%2Fstruct.OsString.html%23method.from_encoded_bytes_unchecked" target="_blank"><code>std::ffi::OsString::from_encoded_bytes_unchecked</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fffi%2Fstruct.OsString.html%23method.into_encoded_bytes" target="_blank"><code>std::ffi::OsString::into_encoded_bytes</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fffi%2Fstruct.OsStr.html%23method.from_encoded_bytes_unchecked" target="_blank"><code>std::ffi::OsStr::from_encoded_bytes_unchecked</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fffi%2Fstruct.OsStr.html%23method.as_encoded_bytes" target="_blank"><code>std::ffi::OsStr::as_encoded_bytes</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fio%2Fstruct.Error.html%23method.other" target="_blank"><code>std::io::Error::other</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.u16.html%23impl-TryFrom%253Cchar%253E-for-u16" target="_blank"><code>impl TryFrom&lt;char&gt; for u16</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fvec%2Fstruct.Vec.html%23impl-From%253C%2526%255BT%3B%2BN%255D%253E-for-Vec%253CT%2C%2BGlobal%253E" target="_blank"><code>impl&lt;T: Clone, const N: usize&gt; From&lt;&amp;[T; N]&gt; for Vec&lt;T&gt;</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fvec%2Fstruct.Vec.html%23impl-From%253C%2526mut%2B%255BT%3B%2BN%255D%253E-for-Vec%253CT%2C%2BGlobal%253E" target="_blank"><code>impl&lt;T: Clone, const N: usize&gt; From&lt;&amp;mut [T; N]&gt; for Vec&lt;T&gt;</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fsync%2Fstruct.Arc.html%23impl-From%253C%255BT%3B%2BN%255D%253E-for-Arc%253C%255BT%255D%2C%2BGlobal%253E" target="_blank"><code>impl&lt;T, const N: usize&gt; From&lt;[T; N]&gt; for Arc&lt;[T]&gt;</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Frc%2Fstruct.Rc.html%23impl-From%253C%255BT%3B%2BN%255D%253E-for-Rc%253C%255BT%255D%2C%2BGlobal%253E" target="_blank"><code>impl&lt;T, const N: usize&gt; From&lt;[T; N]&gt; for Rc&lt;[T]&gt;</code></a></li></ul><p style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff"><span style="color:#000000">這些 API 現在在 const contexts 中是穩定的：</span></span></span></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fmem%2Ffn.transmute_copy.html" target="_blank"><code>core::mem::transmute_copy</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.str.html%23method.is_ascii" target="_blank"><code>str::is_ascii</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.is_ascii" target="_blank"><code>[u8]::is_ascii</code></a></li></ul><h4 style="text-align:start"><strong><span style="color:#000000"><span style="background-color:#ffffff">兼容性説明</span></span></strong></h4><ul><li>正如<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.rust-lang.org%2F2023%2F09%2F25%2FIncreasing-Apple-Version-Requirements.html" target="_blank">之前所宣佈的</a>，Rust 1.74 提高了對 Apple 平台的要求。現在最低版本是： 
  <ul><li>macOS：10.12 Sierra（2016 年首次發佈）</li><li>iOS：10（2016 年首次發佈）、</li><li>tvOS：10（2016 年首次發佈）</li></ul></li></ul><h4 style="text-align:start"><strong><span style="color:#000000"><span style="background-color:#ffffff">其他變化</span></span></strong></h4><p style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">查看&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frust-lang%2Frust%2Freleases%2Ftag%2F1.74.0" target="_blank">Rust</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frust-lang%2Fcargo%2Fblob%2Fmaster%2FCHANGELOG.md%23cargo-174-2023-11-16" target="_blank">Cargo</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frust-lang%2Frust-clippy%2Fblob%2Fmaster%2FCHANGELOG.md%23rust-174" target="_blank">Clippy</a>&nbsp;中發生的所有變化。</span></span></p><p><span style="background-color:#ffffff"><span style="color:#333333">詳情可</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.rust-lang.org%2F2023%2F11%2F16%2FRust-1.74.0.html" target="_blank">查看官方公告</a><span style="background-color:#ffffff"><span style="color:#333333">。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 17 Nov 2023 03:03:55 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266875/rust-1-74-0-released</guid>
            <link>https://www.oschina.net/news/266875/rust-1-74-0-released</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Unity 6 將於 2024 年發佈，下一個 LTS 版本]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Unity 公司在今天舉辦的 Unite 2023 上<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Funity%2Fstatus%2F1725080342636192251" target="_blank">宣佈</a></u>，2024 年將發佈重大版本更新&nbsp;<strong>Unity 6</strong>，並表示其為下一個長期支持版本 (LTS)。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a6955e1397b32b26e403a1c0cdd519dc6fa.png" referrerpolicy="no-referrer"></p><p>Unity 在大會上演示了全新的 Unity 6 引擎，並通過 Syncy Studios 採用 Unity 6 製作的《幻想王國（Fantasy Kingdom）》Demo 進行了<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fyoutu.be%2FyggoHVLd01c" target="_blank">演示</a></u></em>，強調 Unity 6 的性能與畫面改進。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3fd8486e8d8b61d16fec201e834d5fd2ba3.png" referrerpolicy="no-referrer"></p><p><img height="1302" src="https://oscimg.oschina.net/oscnet/up-5d7463e58f86e8e5cae6592b2bfc92aa80c.png" width="2348" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-daf8fe34d603bc0c73addb3fda72e81707d.png" referrerpolicy="no-referrer"></p><p><img height="1316" src="https://oscimg.oschina.net/oscnet/up-220b5372a5f614527cfd3b4da88df5a3dc3.png" width="2360" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-9fa7c45bc268f01ef3b71f6aec5e2ae2bd2.png" referrerpolicy="no-referrer"></p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.unity.com%2Fnews%2Funite-2023-keynote-game-development-unity-6" target="_blank">Unity 公司稱</a></u> Unity 6 將帶來顯著的性能增強、提升創建多人遊戲的速度，以及對 XR 設備更深入的支持。此外還解鎖了新渲染功能的支持，實現了更高水平的圖形保真度。</p><ul><li>以驚人的性能提供先進的視覺效果</li><li>加速多人遊戲的創建和規模化</li><li>利用 AI 工具探索新的創意可能性</li><li>通過下一代移動功能和創新的 VR 設備支持讓玩家隨時隨地接觸</li></ul><p>Untiy&nbsp;提到的 AI 工具為 Sentis，允許開發者在&nbsp;Unity&nbsp;運行時導入&nbsp;AI&nbsp;模型，從而創建基於&nbsp;AI&nbsp;的 NPC。Sentis&nbsp;的獨特之處在於 AI 模型最終在用户設備上本地運行，不需要開發者額外配置雲服務器。</p><p>Unity 6 還將帶來對全新 WebGPU 圖形後端的初步支持。從 Unity 6 開始，玩家將能夠在網絡上的任何位置運行 Unity 遊戲，包括在原生應用程序內或瀏覽器內的 Web 視圖中。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 17 Nov 2023 02:42:55 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266869/unity-6-unite-2023</guid>
            <link>https://www.oschina.net/news/266869/unity-6-unite-2023</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[pyvideotrans —— 視頻翻譯和配音工具]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#1f2328">這是一個視頻翻譯工具，可將一種語言的視頻翻譯為另一種語言和配音的視頻。 語音識別基於<span>&nbsp;</span></span><code>openai-whisper</code><span style="background-color:#ffffff; color:#1f2328"><span>&nbsp;</span>離線模型、文字翻譯使用</span><code>google|baidu|chatGPT</code><span style="background-color:#ffffff; color:#1f2328">翻譯接口，文字合成語音使用<span>&nbsp;</span></span><code>Microsoft Edge tts</code><span style="background-color:#ffffff; color:#1f2328">。</span></p><p><img height="407" src="https://static.oschina.net/uploads/space/2023/1107/143850_zTPQ_4252687.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>使用預編譯版本方法</strong></p><ol start="0"><li><p>只可用於 win10 win11 系統 (編譯版非最新，建議源碼部署)</p></li><li><p>從 release 中下載最新版，解壓，雙擊 sp.exe</p></li><li><p>原始視頻目錄：選擇 mp4 視頻；</p></li><li><p>輸出視頻目錄：如果不選擇，則默認生成在同目錄下的<span>&nbsp;</span><code>_video_out</code></p></li><li><p>選擇翻譯：可選 google、百度、chatGPT，後兩者需要點擊「設置翻譯 key」，設置相應信息</p></li><li><p>網絡代理地址：如果你所在地區無法直接訪問 google，需要在軟件界面，網絡代理，中設置代理，比如若使用 v2ray ，則填寫<span>&nbsp;</span><code>http://127.0.0.1:10809</code>,若 clash，則填寫<span>&nbsp;</span><code>http://127.0.0.1:7890</code>. 如果你修改了默認端口或使用的其他代理軟件，則按需填寫</p></li><li><p>視頻原始語言：選擇待翻譯視頻裏的語言種類</p></li><li><p>翻譯目標語言：選擇希望翻譯到的語言種類</p></li><li><p>選擇配音：選擇翻譯目標語言後，可從配音選項中，選擇配音角色；</p><p>硬字幕: 是指始終顯示字幕，不可隱藏，如果希望網頁中播放時也有字幕，請選擇硬字幕嵌入</p><p>軟字幕: 如果播放器支持字幕管理，可顯示或者隱藏字幕，該方式網頁中播放時不會顯示字幕，某些國產播放器可能不支持,需要將生成的視頻同名 srt 文件和視頻放在一個目錄下才會顯示</p><p><strong>不能「既不嵌入字幕又不選擇配音角色」</strong></p></li><li><p>文字識別模型: 選擇 base/small/medium/large, 識別效果越來越好，但識別速度越來越慢，第一次將需要下載模型，默認 base,可以預先單獨下載模型後，放到<span>&nbsp;</span><code>當前軟件目錄/models</code>目錄下.</p><p><strong>模型單獨下載地址</strong></p><p><a href="https://openaipublic.azureedge.net/main/whisper/models/65147644a518d12f04e32d6f3b26facc3f8dd46e5390956a9424a650c0ce22b9/tiny.pt">tiny 模型</a></p><p><a href="https://openaipublic.azureedge.net/main/whisper/models/ed3a0b6b1c0edf879ad9b11b1af5a0e6ab5db9205f891f668f8b0e6c6326e34e/base.pt">base 模型</a></p><p><a href="https://openaipublic.azureedge.net/main/whisper/models/9ecf779972d90ba49c06d968637d720dd632c55bbf19d441fb42bf17a411e794/small.pt">small 模型</a></p><p><a href="https://openaipublic.azureedge.net/main/whisper/models/345ae4da62f9b3d59415adc60127b97c714f32e89e936602e85993674d08dcb1/medium.pt">medium 模型</a></p><p><a href="https://openaipublic.azureedge.net/main/whisper/models/e4b87e7e0bf463eb8e6956e646f1e277e901512310def2c24bf0e11bd3c28e9a/large.pt">large 模型</a></p></li><li><p>配音語速：填寫 -90 到+90 之間的數字，同樣一句話在不同語言語音下，所需時間是不同的，因此配音後可能聲畫字幕不同步，可以調整此處語速，負數代表降速，正數代表加速播放。</p></li><li><p>自動加速: 如果翻譯後的語音時長大於原時長，並且這裏確認選中，那麼將強制加速播放該片段，以縮小時長</p></li><li><p>靜音片段: 填寫 100 到 2000 的數字，代表毫秒，默認 500，即以大於等於 500ms 的靜音片段為區間分割語音</p></li><li><p>點擊，開始按鈕，底部會顯示當前進度和日誌，右側文本框內顯示字幕</p></li></ol><blockquote><p>原始視頻統一使用 mp4 格式，處理速度快，網絡兼容性好</p><p>採用軟合成字幕：字幕作為單獨文件嵌入視頻，可再次提取出，如果播放器支持，可在播放器字幕管理中啓用或禁用字幕；</p><p>默認會在，原始視頻目錄，下生成同名的字幕文件，視頻名.srt</p><p>對於無法識別的語音將直接複製原語音</p></blockquote></div>
                                                                ]]>
            </description>
            <pubDate>Fri, 17 Nov 2023 02:26:55 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/pyvideotrans</guid>
            <link>https://www.oschina.net/p/pyvideotrans</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 基於一致性緩存的分佈式事務應用框架 Zeze]]>
            </title>
            <description>
                <![CDATA[<p>What Is Zeze?</p><p>Zeze 是一個基於一致性緩存的分佈式事務應用框架，詳見 doc/zeze.docx</p>]]>
            </description>
            <pubDate>Fri, 17 Nov 2023 02:23:55 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/e2wugui/zeze</guid>
            <link>https://gitee.com/e2wugui/zeze</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 視覺 BEV 基本原理和方案解析]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>BEV(Bird’s-Eye-View) 是一種鳥瞰視圖的傳感器數據表示方法，它的相關技術在自動駕駛領域已經成了「標配」，紛紛在新能源汽車、芯片設計等行業相繼量產落地。BEV 同樣在高德多個業務場景使用，例如：<strong>高精地圖地面要素識別</strong>、<strong>車道線拓撲構建</strong>、<strong>車端融合定位</strong>中都扮演了重要角色。如圖 1‑1 所示：</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-6877926e4fd053ef08b19049d51767f8_1440w.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 1‑1 BEV 在高德應用場景（僅列舉部分）a) 高精底圖 b) 地面要素識別 c) 車道線拓撲構建[1] d) 車端融合定位 (BEV 特徵和底圖匹配)[2]</p><p>本文分享的內容主要包括兩個部分：視覺 BEV 基本原理、方案解析。</p><p><strong>1.BEV 基礎</strong></p><p><strong>1.1.引言</strong></p><p>如圖 1‑2 所示，BEV 具有如下優勢：</p><p><strong>1) BEV 視圖尺度變化小</strong>。在 PV 空間（即透視圖，類似通常行車記錄儀所採集的車輛前視圖）中，物體近大遠小，物體的大小和類別、遠近都有關，而在 BEV 空間中，物體的大小隻和類別有關；</p><p><strong>2) BEV 空間是決策友好空間</strong>。BEV 空間更接近 3D 真實空間的平面空間，而 PV 空間是真實物理世界在透視投影下的視圖，以圖 1‑2 的車道線舉例，在真實世界中平行的兩條車道線，在 BEV 空間下還是平行的，在 PV 空間卻是相交的。相比之下，BEV 空間下的信息能更方便地被下游規控模塊理解和使用。</p><p>本章將介紹 BEV 基礎知識。首先介紹 BEV 的核心**「視角轉換模塊」的基本原理**，包括 2D-&gt;3D 和 3D-&gt;2D 兩種路線，然後介紹 BEV 使用的<strong>魔法「可形變模塊」</strong>，最後介紹<strong>BEV 方案中常用的損失函數</strong>。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-a9e4e534bb87131577673960410b5677_1440w.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 1‑2 BEV 空間和 PV 空間的圖像可視化，a) BEV 空間 b) PV 空間</p><p><strong>1.2.視角轉換</strong></p><p>如 1.1 所述，在 BEV 空間下進行數據處理和操作具有尺度變化小、決策友好的優勢，但原始的圖像數據是在 PV 空間下的，如何將 PV 空間的數據轉換到 BEV 空間或者是 3D 空間（有 3D 空間下的數據，將其拍扁就能轉到 BEV 空間）呢？這就是視角轉換模塊要乾的事。</p><p><strong>1.2.1. 2D-&gt;3D 轉換模塊</strong></p><p>2D-&gt;3D 轉換模塊基本思想是從 2D 像素或者特徵出發去找 3D 空間下的對應表示，類似深度估計。下面介紹主流的 2D-&gt;3D 轉換方法。</p><p>LSS(Lift-Splat-and-Shot)[3]是主流的 2D-&gt;3D 轉換方法，如圖 1‑3 所示，Lift 指對各相機的圖像顯式地估計特徵點的深度分佈，得到包含圖像特徵的視錐（點雲）；Splat——結合相機內外參把所有相機的視錐（點雲）分配到 BEV 空間的網格中，對每個格子中的多個視錐點進行 pooling 計算，形成 BEV 特徵圖；Shoot——用 task head 處理 BEV 特徵圖，輸出感知結果。最後將 C 維的特徵和 D 維的深度分佈做外積，得到每個深度下的特徵，深度概率越大，對應特徵響應就越強。</p><p style="text-align:center"><img alt="" src="https://pica.zhimg.com/80/v2-43d4c71faf7a138576f6ba06458e22aa_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 1‑3 LSS 示意，每個特徵點生成系列離散深度點，再為深度點生成特徵[3]</p><p>Pseudo-LiDAR 是另一種 2D-&gt;3D 轉換方法，如圖 1‑4 所示，相比 LSS 為特徵點預測一系列離散深度，Pseudo-LiDAR 直接預測深度圖，每個像素都有且僅有一個深度。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-53fd09fd23b24641939a1b729c035932_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 1‑4 Pseudo-LiDAR 示意，預測深度圖，根據原始圖像和深度圖映射至 3D 空間[4]</p><p><strong>1.2.2. 3D-&gt;2D 轉換模塊</strong></p><p>3D-&gt;2D 轉換模塊基本思想是根據 3D 點查找對應的 2D 特徵，類似 3D 空間投影到 PV 空間。下面介紹主流的 3D-&gt;2D 轉換方法。</p><p>如圖 1‑5 所示，將 3D 參考點根據成像原理投影到 PV 空間獲取對應圖像特徵的方式可以認為是顯式映射，這裏的參考點可以使用預設的 BEV 空間的參考點，也可以使用網絡生成。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-cc01c8996b31566d84f9db31ce62143e_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 1‑5 顯式映射[5]</p><p>相比顯式映射，隱式映射不再通過投影映射，而是讓網絡自己學特徵和 3D 座標的映射。如圖 1‑6 所示，它先生成視錐空間下的一系列點，再轉換到 3D 空間下，然後將提取的圖像特徵和 3D 點傳入 encoder，encoder 處理後輸出的就是帶有 3D 座標信息的特徵。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-015461e8177d0ce576c5768410dcb80b_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 1‑6 隱式映射[6]</p><p><strong>1.3. 可形變模塊</strong></p><p>要介紹的可形變模塊有兩種，<strong>可形變卷積</strong>和<strong>可形變注意力</strong>，可形變模塊的作用更容易通過可形變卷積理解，所以先介紹可形變卷積。</p><p>可形變卷積是在卷積的基礎上添加 offset 得到的，如圖 1‑7 最左邊的 a) 所示，普通卷積通過人工設計的 pattern 整合 pattern 內採樣點的信息，其 pattern 設計好後就是固定的，可形變卷積，如圖 1‑7 b) 所示，可以計算出每個採樣點的 offset，採樣點+offset 才是真實的採樣點，使得卷積的 pattern 形式更加靈活，且一定程度上可學習。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-25ee3e549c4c201ec23b27b2927ed7f0_1440w.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 1‑7 可形變卷積示意，a) 普通卷積 b) 可形變卷積[7]</p><p>如圖 1‑8 所示，注意力機制需要通過 Q (query) 找到 K (key)，獲得 K 的信息，這個過程也存在可變形的操作空間，讓網絡自己學習參考點的偏移量。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-ae9b641901f4aabf7cd99d5cbbea4c9d_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 1‑8 可變形注意力示意[8]</p><p><strong>1.4. 損失函數</strong></p><p>損失函數大部分與任務相關，且大同小異，這裏集中介紹下後續方案解析需要用到的一些共性的損失函數。</p><p>Box Loss (包圍盒損失函數) 是目標檢測常用的幾何損失函數，常採用 L1 Loss 的形式：</p><p><img alt="" src="https://pic1.zhimg.com/80/v2-7cd755ebefb004c45aa1d2f8ed391d17_1440w.jpg" referrerpolicy="no-referrer"></p><p>Focal Loss 是交叉熵損失函數的拓展，常用於分類問題。普通交叉熵損失函數在正負樣本不均衡時表現不佳，因此引入平衡交叉熵。另外普通交叉熵損失函數對於難例無法重點學習，因此引入難例聚焦。最終形式為：</p><p><img alt="" src="https://picx.zhimg.com/80/v2-7b684f60a21cd467d25d4dc4a869d7d9_1440w.jpg" referrerpolicy="no-referrer"></p><p><strong>2. 視覺 BEV 方案解析</strong></p><p><strong>2.1. 引言</strong></p><p>第一章的內容為第二章的方案解析打下知識基礎，接下來第二章主要解析具有代表性的視覺 BEV 方案，主要根據視角轉換模塊的類型對方案進行分類，首先介紹 2D-&gt;3D 的代表性方案，然後介紹 3D-&gt;2D 的代表性方案。</p><p><strong>2.2. 2D-&gt;3D 代表性方案解析</strong></p><p>2D-&gt;3D 的代表性 BEV 方案有<strong>BEVDet</strong>和<strong>BEVDepth</strong>，下面我們逐一介紹。</p><p><strong>2.2.1. BEVDet</strong></p><p>3D 目標檢測跟蹤由基於 PV 空間的方法主導，BEV 語義分割跟蹤由基於 BEV 空間的方法主導，那麼 PV 空間和 BEV 空間哪個更適合做自動駕駛感知呢？是否可以在同一的框架下做這些任務？作者為了回答這兩個問題，提出瞭如圖 2‑1 所示的基於 BEV 空間的 3D 目標檢測框架，BEVDet。BEVDet 主要由四個部分組成，分別為圖像特徵編碼器，視角轉換模塊，BEV 特徵編碼器，檢測頭。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-1e60694f26d5751b2879bb3b208d9895_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 2‑1 BEVDet 框架[9]</p><p>圖像特徵編碼器 (Image-view Encoder) 使用 2D Backbone 網絡，如 ResNet、SwinTransformer 等，對輸入的多視角圖像做多尺度特徵提取，得到多尺度特徵。</p><p>視角轉換模塊 (View Transformer) 對輸入的多視角圖像特徵使用 LSS 進行離散深度分佈預測，獲得 3D 視錐特徵。</p><p>3D 視錐特徵經過 pooling 操作拍扁到 BEV 空間，BEV 特徵編碼器 (BEV Encoder) 對 BEV 空間下的特徵做多尺度特徵提取，得到 BEV 特徵。</p><p>最後送入檢測頭進行 3D 目標檢測，分類監督使用的損失函數為 Focal loss，包圍盒監督使用的損失函數為 L1 loss。</p><p><strong>2.2.2. BEVDepth</strong></p><p>作者實驗發現 LSS 估計的深度替換成隨機值影響不大，而採用真值深度對指標提升很大，因此得出 LSS 估計深度不準的結論，如圖 2‑2 所示，在沒有明確的深度監督的情況下，很難輸出準確，泛化性強的深度感知結果，要想獲得更好的檢測結果，需要更準的深度，因此引入深度監督訓練深度子網絡。</p><p style="text-align:center"><img alt="" src="https://pica.zhimg.com/80/v2-81044f858876fb86f021267da764c5b7_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 2‑2 LSS 的深度預測結果和 BEVDepth 的深度預測結果的對比[10]</p><p>圖 2‑3 是 BEVDepth 的框架，也能大致分為圖像特徵編碼器，視角轉換模塊，BEV 特徵編碼器，檢測頭四個部分。圖像特徵編碼模塊大同小異，後續不再展開説明。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-a4ad33f6e9c360247e91b77932b374e5_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 2‑3 BEVDepth 框架[10]</p><p>視角轉換模塊的核心是深度估計，深度估計網絡 DepthNet 的框架如圖 2‑4 所示，首先使用 MLP 對相機內參進行特徵化，然後用 SE (Squeeze-and-Extraction) 對圖像特徵進行通道加權，然後經過 3 個殘差塊以及可形變卷積，得到深度。深度再與圖像特徵進行外積，得到 3D 視錐特徵。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-fa606fad900b85501db561a22819eef8_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 2‑4 深度估計網絡框架[10]</p><p>相機和用於監督的點雲之間的外參可能不準，內參也可能不準，都會導致深度估計有偏，因此 BEV 特徵編碼器引入深度修正對 3D 視錐特徵的深度進行修正，然後進行高效體素池化獲得 BEV 特徵。</p><p>檢測頭所使用的損失函數和 BEVDet 是一致的，不做贅述。深度監督使用的損失函數為二分類交叉熵。</p><p><strong>2.3. 3D-&gt;2D 代表性方案解析</strong></p><p>前面介紹的 2D-&gt;3D 的方案始終繞不過深度估計，深度估計難免會引入誤差，換個思路，先有 3D 點，再根據 3D 點找 2D 特徵的方式無需進行深度估計，避免了這部分誤差。3D-&gt;2D 的代表性方案有 Detr3D、BEVFormer 和 PETR。</p><p><strong>2.3.1. Detr3D</strong></p><p>如圖 2‑5 所示，Detr3D 是 Detr 在 3D 目標檢測的擴展，也是使用 query 進行特徵獲取，然後進行檢測。Detr3D 的圖像特徵編碼器大同小異，不再贅述。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-aecefc46ac607f6b9cfe9a8c72d878cb_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 2‑5 Detr3D 框架[5]</p><p>特徵轉換模塊首先使用 object query 生成 3D 參考點，將參考點投影到 PV 空間獲取圖像特徵，獲取到的圖像特徵能進一步優化物體的 3D 表徵，得到物體的 3D 特徵。</p><p>將特徵送入檢測頭進行目標檢測，可以得到一系列的檢測結果。普遍地，大家會用 NMS 等後處理方式獲得最終用於 Loss 計算的檢測結果，如圖 2‑6 所示，Detr3D 繼承了 Detr 的做法，採用雙邊圖匹配獲得與真值一一對應的檢測結果。損失函數與前面所述並未本質差異，不做贅述了。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-ecb60b683e331a3662bddef87ba2deed_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 2‑6 雙邊圖匹配獲得與真值一一對應的檢測結果[11]</p><p><strong>2.3.2. BEVFormer</strong></p><p>行車過程有天然的時序特點，當前幀看到的車道線，在後續幾幀大概率也是存在且可見的，如何利用這個時序特點是前述方案沒有考慮的。BEVFormer 引入時序信息進一步增強 BEV 的檢測能力。BEVFormer 的圖像特徵編碼模塊和前述大同小異，不做贅述。</p><p>BEVFormer 的核心是中間的 BEV 特徵編碼模塊，BEV 特徵編碼模塊的核心是時序自注意力 (Temporal Self-Attention) 和空間交叉注意力 (Spatial Cross-Attention)，時序注意力是為了利用歷史幀 BEV 特徵增強當前幀 BEV 特徵，空間交叉注意力則是為了從圖像特徵獲取信息。</p><p style="text-align:center"><img alt="" src="https://pica.zhimg.com/80/v2-f3bbe02646e521461ad36b8e2d4e159f_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 2‑7 BEVFormer 框架[12]</p><p>具體地，BEVFormer 的時序自注意力首先利用車輛運動信息將當前幀 BEV 特徵和歷史幀 BEV 特徵進行對齊，然後再使用自注意力融合兩者信息，由於車輛運動信息可能不準，不同時刻周圍的可利用信息分佈也不一致，所以具體使用的是圖 2‑8 所示的可變形注意力機制。</p><p style="text-align:center"><img alt="" src="https://pica.zhimg.com/80/v2-4f86254bec875df7b4c8b27b3c7d1484_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 2‑8 時序可變形自注意力[12]</p><p>BEVFormer 的空間交叉注意力首先為每個格子在 Z 方向上採樣 4 個值，得到一個格子上的 4 個參考點，然後與圖像特徵進行交叉注意力，獲得圖像特徵。如圖 2‑9 所示，這裏的交叉注意力也採用可變形注意力機制。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-b65c4f416dedc9b27608bc42b4d8f0b2_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 2‑9 空間可變形交叉注意力[12]</p><p>損失函數的計算和 Detr3D 一致，不再贅述。</p><p><strong>2.3.3. PETR</strong></p><p>3D-&gt;2D 的方案一般都需要將參考點投影到 PV 空間，再取圖像特徵，PETR 避免了複雜的 3D-&gt;2D 轉換及特徵採樣，直接讓網絡自己學習 2D-3D 的映射。PETR 的框架如圖 2‑10 所示，包括圖像特徵編碼器、3D 座標生成器、3D 特徵編碼器 (3D Position Encoder)、3D 特徵解碼器和檢測頭。圖像特徵編碼器大同小異，不再贅述。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-3bd06c74ccb12b7e4de4e16d317b7cb0_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 2‑10 PETR 框架[6]</p><p>3D 座標生成器生成視錐空間的一系列 3D 點，具體地，首先將相機視錐空間離散成大小為的網格，網格中的每一點用表示。3D 空間中一個點用表示。通過相機內外參可以將相機視錐空間轉換到 3D 空間中。最後再進行歸一化。</p><p>2D 圖像特徵和 3D 座標一起送入到 3D 特徵編碼器中，2D 特徵進行卷積通道降維，3D 座標進行位置編碼，然後將處理後的 2D 特徵和 3D 座標編碼整合，最後特徵展平。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-ec98be180482b7f680c1edfa0471e7e0_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 2‑11 3D 特徵編碼器[6]</p><p>3D 特徵解碼器先在 3D 空間生成一系列隨機點，再通過 MLP 生成可學習的 query，query 在 3D 特徵中取特徵，最後使用檢測頭進行檢測。損失函數與 Detr3D 大同小異，不再贅述。</p><p><strong>3. 總結展望</strong></p><p>本文從 BEV 的基礎出發，介紹了視覺 BEV 具有代表性的方案。視覺 BEV 已經展現出強大的場景理解能力。但是還存在很多值得探索且有挑戰的方向[13]：</p><p>深度估計是 BEV 的核心，LSS、Pseudo-LiDAR、激光蒸餾、立體視覺或運動恢復結構等都是有前景的方向。</p><p>如何融合傳感器的信息也是至關重要的，使用 Transformer 的自注意力、交叉注意力融合不同模態的特徵已經被證明是個可行的方向。多模態中 CLIP 的文本-圖像對也是個很有啓發的思路。</p><p>泛化性是深度學習亙古不變的話題和努力的方向，在一個設備（數據）上訓練好的模型在另一個設備（數據）表現是否一樣好。每個設備都要付出訓練成本是讓人難以接受的。如何將模型和設備解耦在未來一段時間都將是重要的研究方向。</p><p>大模型或者基礎模型已經在不同領域上取得令人印象深刻的結果，並一舉成為 SOTA。在 BEV 感知中如何利用大模型中豐富的知識，在更多的任務上取得更好的效果，這將會逐步引起人們的重視。</p><p><strong>4. 參考文獻</strong></p><p>[1] Bencheng Liao, Shaoyu Chen, Xinggang Wang, et al. Maptr: Structured modeling and learning for online vectorized hd map construction[J]. arXiv preprint arXiv:2208.14437,2022,</p><p>[2] Yuzhe He, Shuang Liang, Xiaofei Rui, et al. EgoVM: Achieving Precise Ego-Localization using Lightweight Vectorized Maps[J]. arXiv preprint arXiv:2307.08991,2023,</p><p>[3] Jonah Philion and Sanja Fidler. Lift, splat, shoot: Encoding images from arbitrary camera rigs by implicitly unprojecting to 3d[A]. Springer: 194-210</p><p>[4] Yan Wang, Wei-Lun Chao, Divyansh Garg, et al. Pseudo-lidar from visual depth estimation: Bridging the gap in 3d object detection for autonomous driving[A]. 8445-8453</p><p>[5] Yue Wang, Vitor Campagnolo Guizilini, Tianyuan Zhang, et al. Detr3d: 3d object detection from multi-view images via 3d-to-2d queries[A]. PMLR: 180-191</p><p>[6] Yingfei Liu, Tiancai Wang, Xiangyu Zhang, et al. Petr: Position embedding transformation for multi-view 3d object detection[A]. Springer: 531-548</p><p>[7] Jifeng Dai, Haozhi Qi, Yuwen Xiong, et al. Deformable convolutional networks[A]. 764-773</p><p>[8] Xizhou Zhu, Weijie Su, Lewei Lu, et al. Deformable detr: Deformable transformers for end-to-end object detection[J]. arXiv preprint arXiv:2010.04159,2020,</p><p>[9] Junjie Huang, Guan Huang, Zheng Zhu, et al. Bevdet: High-performance multi-camera 3d object detection in bird-eye-view[J]. arXiv preprint arXiv:2112.11790,2021,</p><p>[10] Yinhao Li, Zheng Ge, Guanyi Yu, et al. BEVDepth: Acquisition of Reliable Depth for Multi-View 3D Object Detection[J]. Proceedings of the AAAI Conference on Artificial Intelligence,2023,37(2): 1477-1485</p><p>[11] Nicolas Carion, Francisco Massa, Gabriel Synnaeve, et al. End-to-end object detection with transformers[A].Springer: 213-229</p><p>[12] Zhiqi Li, Wenhai Wang, Hongyang Li, et al. Bevformer: Learning bird’s-eye-view representation from multi-camera images via spatiotemporal transformers[A].Springer: 1-18</p><p>[13] Hongyang Li, Chonghao Sima, Jifeng Dai, et al. Delving into the Devils of Bird's-eye-view Perception: A Review, Evaluation and Recipe[J]. arXiv preprint arXiv:2209.05324,2022,</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 17 Nov 2023 02:16:55 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/amaptech/blog/10143491</guid>
            <link>https://my.oschina.net/amaptech/blog/10143491</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Spring Framework 6.1 正式 GA]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Spring Framework 6.1<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspring.io%2Fblog%2F2023%2F11%2F16%2Fspring-framework-6-1-goes-ga" target="_blank"> 已正式發佈</a></u>。</p><p><strong>主要變化</strong></p><ul><li>支持 JDK 21 LTS</li><li>支持虛擬線程</li><li>支持恢復 JVM Checkpoint</li><li>引入「資源生命週期管理」</li><li>引入「數據綁定和驗證」</li><li>新增&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.spring.io%2Fspring-framework%2Fdocs%2F6.1.x%2Fjavadoc-api%2Forg%2Fspringframework%2Fweb%2Fclient%2FRestClient.html" target="_blank">RestClient</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.spring.io%2Fspring-framework%2Fdocs%2F6.1.x%2Fjavadoc-api%2Forg%2Fspringframework%2Fjdbc%2Fcore%2Fsimple%2FJdbcClient.html" target="_blank">JdbcClient</a>&nbsp;API</li></ul><p>公告寫道，就 HotSpot JVM 上的高效部署選項而言，Spring Framework 6.1 與 Project CRaC 緊密集成以實現 JVM checkpoint 部署：查看&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.spring.io%2Fspring-framework%2Freference%2F6.1%2Fintegration%2Fcheckpoint-restore.html" target="_blank">JVM Checkpoint Restore</a></u>。此外，Spring 用户還可以採用 JDK 21 中最新的 AppCDS 功能，與 OpenJDK 的 Project Leyden 預先保持一致。</p><p>此外，Spring Framework 6.1 在運行時方面針對 JDK 21 和 Jakarta EE 10 上提供了一級支持，同時保留了 JDK 17 和 Jakarta EE 9 基線。Spring 還通過精細的元數據推理跟蹤 GraalVM for JDK 21 的演變，同時暫時保持與 GraalVM 22.3 的兼容性。</p><hr><p>文檔<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-framework%2Fwiki%2FWhat%2527s-New-in-Spring-Framework-6.x">顯示</a>，Spring 6.1 已全面兼容虛擬線程 (<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-framework%2Fissues%2F23443">Virtual Threads</a>) 和 JDK 21。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/0817/140919_ppSy_2720166.png" referrerpolicy="no-referrer"></p><p>虛擬線程配置選項：專用的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.spring.io%2Fspring-framework%2Fdocs%2F6.1.0-SNAPSHOT%2Fjavadoc-api%2Forg%2Fspringframework%2Fcore%2Ftask%2FVirtualThreadTaskExecutor.html">VirtualThreadTaskExecutor</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.spring.io%2Fspring-framework%2Fdocs%2F6.1.0-SNAPSHOT%2Fjavadoc-api%2Forg%2Fspringframework%2Fcore%2Ftask%2FSimpleAsyncTaskExecutor.html%23setVirtualThreads%28boolean%29">SimpleAsyncTaskExecutor 上的虛擬線程模式</a>，以及類似的具有 new-thread-per-task strategy 和虛擬線程模式的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.spring.io%2Fspring-framework%2Fdocs%2F6.1.0-SNAPSHOT%2Fjavadoc-api%2Forg%2Fspringframework%2Fscheduling%2Fconcurrent%2FSimpleAsyncTaskScheduler.html">SimpleAsyncTaskScheduler</a>。</p><p>詳情查看&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-framework%2Fwiki%2FWhat%27s-New-in-Spring-Framework-6.x" target="_blank">What's New 頁面</a></u>。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 17 Nov 2023 02:13:01 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266858/spring-framework-6-1-ga</guid>
            <link>https://www.oschina.net/news/266858/spring-framework-6-1-ga</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Dromara 社區新晉開源項目 - Akali(阿卡麗)，輕量化的熱點&降級處理框架！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img height="383" src="https://oscimg.oschina.net/oscnet/up-be8fcabf525c0668386e7be6a812d46264e.png" width="900" referrerpolicy="no-referrer"></p><h2>前言</h2><p>Dromara 社區再添一個成員項目！</p><p>今天為大家介紹的是——Akali。</p><p>它輕量小巧，來無影去無蹤，不足 500 行代碼，卻能解決高流量場景中主要的問題：熱點處理和降級處理。</p><h2>介紹</h2><p>Akali（阿卡麗）是一個輕量級本地化熱點檢測/降級框架，適用於大流量場景，可輕鬆解決業務中超高流量的併發查詢等場景。並且接入和使用極其簡單，10 秒鐘即可接入使用！</p><p>Akali 框架的理念就是小巧，實用，絲血團戰，滿血退場，所到之處，皆為虛無。</p><p>Gitee：<a href="https://gitee.com/dromara/Akali">https://gitee.com/dromara/Akali</a></p><p>Github：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbryan31%2FAkali" target="_blank">https://github.com/bryan31/Akali</a></p><p>官方網站：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fakali.yomahub.com%2F" target="_blank">https://akali.yomahub.com/</a></p><h2>使用</h2><p>引入依賴：</p><pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.yomahub&lt;/groupId&gt;
  &lt;artifactId&gt;akali&lt;/artifactId&gt;
  &lt;version&gt;1.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h2>對任意方法進行熱點處理</h2><p>只需要加上<code>@AkaliHot</code>這個標註，任意方法均可以獲得熱點檢測，並在熱點期間用熱點數據進行返回，在熱點過後，又會自動調用原本業務邏輯。</p><p>舉例：比如有一個商品查詢的業務，傳入 SkuCode，返回商品信息。當某個商品進行促銷時，訪問的量就會增加，但是對於相同的 SkuCode 而言，其短時間窗口內返回的 SkuInfo 是一致的，我們的目標是當某個商品 sku 被大量查詢時，框架能夠在短時間內把這個商品 sku 提為熱點數據，並通過對其進行緩存返回來降低對下游業務的壓力。而當熱點值過後，框架又能夠自動摘除這個熱點值，使其按照原有方式進行查詢。</p><p>其本質相當於實時的監測了熱點，並對其熱點數據做了一個短時間內的緩存。</p><p>以下示例代表了：當相同的 skuCode 在 5 秒內超過 50 次調用時，會自動把這個 skuCode 的值提為熱點，並用最後一次的返回值直接返回。當調用低於 5 秒 50 次調用時，框架會自動的摘除掉這個熱點。使其正常的調用你原有代碼進行邏輯計算並返回。這一切都是自動的。</p><pre><code>@AkaliHot(grade = FlowGradeEnum.FLOW_GRADE_QPS, count = 50, duration = 5)
public SkuInfo getSkuInfo(String skuCode){
  //do your biz and return sku info
}
</code></pre><p>其中<code>grade</code>參數除了有以<code>QPS</code>作為維度統計，還有以<code>Thread</code>個數作為維度統計。比如：</p><pre><code>@AkaliHot(grade = FlowGradeEnum.FLOW_GRADE_THREAD, count = 50, duration = 5)
public SkuInfo getSkuInfo(String skuCode){
  //do your biz and return sku info
}
</code></pre><p>這就代表了，如果某個 skuCode 在 5 秒之內有超過 50 個線程正在運行，那麼就提為熱點，並用熱點數據直接返回。</p><p>對開源項目比較熟悉的同學看到這肯定想到了京東的框架-<code>hotkey</code>，<code>Akali</code>不同於<code>hotkey</code>，完全是本地運行的，不依賴於服務端，而且接入比<code>hotkey</code> 方便多了。性能完全相當於<code>hotkey</code>。</p><h2>對任意方法進行降級</h2><p>只需要加上<code>@AkaliFallback</code>註解。任意方法均可獲得降級功能。</p><p>舉例：某一個方法需要調用外部的接口，但是外部的接口性能不佳，耗時高。當併發一高時，線程池就會吃滿，線程池隊列也會逐漸堆積從而導致超時，或者丟棄，嚴重時會拖垮整個系統。</p><p>這時，我們只要對這個方法加上<code>@AkaliFallback</code>標註，即可解決。</p><pre><code>@AkaliFallback(grade = FlowGradeEnum.FLOW_GRADE_THREAD, count = 100)
public String sayHi(String name){
  return "hi,"+name;
}

public String sayHiFallback(String name){
  return "fallback str";
}
</code></pre><p>以上註解表示了，當這個方法的同時運行的線程超過 100 個時，觸發降級，降級會自動調用<code>原方法名+Fallback</code>方法名 (並且參數要一致)，當降級觸發後會直接返回<code>fallback str</code>，當線程數小於 100 時，框架也會自動摘除降級，還是輸出<code>hi,xxxx</code>。</p><p>如果你的類中沒有定義 fallback 方法，那麼觸發降級時會報錯，當然你可以在降級方法中去拋錯，來讓上游系統知道你這個方法已經達到了瓶頸。</p><h2>注意事項</h2><p>Akali 只針對於 Springboot，Spring 環境，並且所有標註了<code>@AkaliHot</code>或者<code>@AkaliFallback</code>的類一定得註冊到 spring 上下文中。</p><p>Akali 在 springboot 中會自動掃描所有標註的類，您無需做任何配置，在 spring 中，你需要配置：</p><pre><code>&lt;bean class="com.yomahub.akali.strategy.FallbackStrategy"/&gt;
&lt;bean class="com.yomahub.akali.strategy.MethodHotspotStrategy"/&gt;
&lt;bean class="com.yomahub.akali.spring.AkaliScanner"/&gt;
</code></pre><h2>最後</h2><p>如果大家感興趣的話，請在 Gitee 上為 Akali 點上小星星哦。</p><p>Gitee：<a href="https://gitee.com/dromara/Akali">https://gitee.com/dromara/Akali</a></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 17 Nov 2023 01:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266848</guid>
            <link>https://www.oschina.net/news/266848</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[🎉Solon v2.6 榮耀發佈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>先吹牛！</h2><p style="color:#24292e; text-align:start">在 v2.6 這個新的里程碑節點，Solon 又完成了幾件驚天大事（每一件，都是經歷了漫長時間打磨與積累）：</p><h4>（1）Solon Native，有了第一個開源案例：<a href="https://gitee.com/dromara/neutrino-proxy">dromara/neutrino-proxy</a><span>&nbsp;</span>（它是 2021 年起頭的二級項目）</h4><p style="color:#24292e; text-align:start">Solon 估計是國內唯搞 AOT 和 Java 原生編譯的。或許，這塊的友商只能是 Micronaut、Quarkus 和 Spring Native。</p><h4>（2）99% 換血重構了：<span>&nbsp;</span><a href="https://gitee.com/noear/socketd">Socket.D 通訊應用協議</a><span>&nbsp;</span>（它是 Solon 的二級項目，已孵化兩年）</h4><p style="color:#24292e; text-align:start">它是一種通訊應用協議，也是一個網絡開發框架。未來， 必會成為各種網絡開發場景的優選。開發 Mq, Im, Rpc 就跟玩似的。</p><h4>（3）重新設計了 Solon 的 WebSocket 接口標準</h4><p style="color:#24292e; text-align:start">這次的設計很專業、很純血。未來 10 年，估計都不用再動了。動它，是下了很大決心的</p><h4>（4）封裝了微 FaaS 引擎：<a href="https://gitee.com/noear/luffy">Luffy FaaS 引擎</a>（它也是 Solon 的二級項目，已孵化三年）</h4><p style="color:#24292e; text-align:start">隨時可能更新代碼，又不想重啓的場景。可以考慮用它了<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsolon.noear.org%2Farticle%2F664" target="_blank">luffy-solon-plugin</a>。<span style="background-color:#f1c40f">官網將推出全新的學習頻道：Solon Faas 開發</span>。</p><h4>（5）設定 Smart-Http 為 solon-api 的默認 http-server（它也打磨幾年了）</h4><p style="color:#24292e; text-align:start">smart-http ？它可能是國內唯一完整支持 http 1.1 協議的原創 http-server。換它，國產純血度大升級！</p><h2>Solon 是什麼框架？</h2><p style="color:#24292e; text-align:start"><strong>Java 新的"生態級"應用開發框架</strong>。<span style="background-color:#f1c40f">從零開始構建，有自己的標準規範與開放生態</span>（歷時五年，具備全球第二級別的生態規模）。Solon 生態的友商是 Spring 生態。Solon 的友商很強，所以很有意思。未來也將會在國際上照面。</p><h2>相對於 Spring，有什麼特點？</h2><ul><li>啓動快 5 ～ 10 倍。<span>&nbsp;</span><strong>（更快）</strong></li><li>qps 高 2～ 3 倍。<span>&nbsp;</span><strong>（更高）</strong></li><li>低流量內存節省 1/3 ~ 1/2。<span>&nbsp;</span><strong>（更少）</strong></li><li>打包可以縮小到 1/2 ~ 1/10；比如，300Mb 的變成了 23Mb。<span>&nbsp;</span><strong>（更小）</strong></li><li>同時支持 jdk8, jdk11, jdk17, jdk21,<span>&nbsp;</span><strong>graalvm native image</strong></li></ul><h2>入門探索視頻（用户錄製）：</h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><iframe frameborder="0" height="400" scrolling="no" src="https://player.bilibili.com/player.html?aid=938467339&amp;bvid=BV1RT4y1a7U5&amp;cid=583394292&amp;page=1" style="box-sizing: border-box; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; color: rgb(36, 41, 46); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; text-align: start; background-color: rgb(255, 255, 255);" width="700" referrerpolicy="no-referrer"></iframe></p><h2>最近更新了什麼？</h2><ul><li><span style="background-color:#f1c40f">設定 smart-http 為 solon-api 快捷組合包的默認 http-server</span></li><li>重構 socketd 適配，升為 v2.0</li><li>重構 websocket 適配，升為 v2.0</li><li>新增 solon.net 模塊用於定義網絡接口，分離 websocket 與 socketd 的接口（分開後，用户層面更清爽）</li><li>新增 solon.boot.socketd 插件</li><li>新增 sa-token-dao-redisson-jackson 插件</li><li>添加 SolonApp::filterIfAbsent,routerInterceptorIfAbsent 接口</li><li>添加 AppContext::getBeansMapOfType 接口</li><li>添加 websocket context-path 過濾處理機制</li><li>添加<span>&nbsp;</span><code>@Cache</code><span>&nbsp;</span>緩存註解處理對動態開關的支持（之前，只能在啓動時決定）</li><li>添加<span>&nbsp;</span><code>@Tran</code><span>&nbsp;</span>事務註解處理對動態開關的支持（之前，只能在啓動時決定）</li><li>添加 solon.boot.smarthttp 外部優先級處理（成為默認後，要方便外部替換它）</li><li>調整 smart-http,jetty,undertow 統一使用 server.http.idleTimeout 配置</li><li>調整<span>&nbsp;</span><code>@ProxyComponent</code><span>&nbsp;</span>棄用提示為直接提示（之前為 debug 模式下）</li><li>移除 AopContext（完成更名 AppContext 的第二步動作）</li><li>移除 PathLimiter （已無用，留着有誤導性）</li><li>移除 SolonApp::enableWebSocketD,enableWebSocketMvc,enableSocketMvc（已無用，留着有誤導性）</li><li>優化 http context-path 過濾器處理機制</li><li>優化 solon.test 的<span>&nbsp;</span><code>@Rollback</code><span>&nbsp;</span>註解處理，支持 web 的事務控制</li><li>優化 solon.scheduling.simple 保持與 jdk 調度服務的策略一致</li><li>刪除 socketd v1.0 相關的 10 多個插件（v2.0 獨立倉庫）</li><li>jackson 升為 2.15.2</li><li>pagehelper 升為 5.3.3</li><li>liteflow 升為 2.11.3</li><li>activemq 升為 5.16.7</li><li>redisx 升為 1.6.2</li><li>minio8 升為 8.5.3</li><li>sqltoy 升為 5.2.81</li><li>fastjson2 升為 2.0.42</li><li>luffy 升為 1.6.9</li><li>water 升為 2.12.0</li></ul><h2>項目倉庫地址？</h2><ul><li>gitee：<a href="https://gitee.com/noear/solon">https://gitee.com/noear/solon</a></li><li>github：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fnoear%2Fsolon" target="_blank">https://github.com/noear/solon</a></li></ul><p>&nbsp;</p><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 17 Nov 2023 00:56:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266845/solon-2-6-released</guid>
            <link>https://www.oschina.net/news/266845/solon-2-6-released</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微軟推出全新「Windows App」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">微軟在&nbsp;Ignite 2023 上宣佈推出一款適用於 iOS、iPadOS、Web 和 Windows 的全新「Windows App」，目前正以預覽版形式提供。</span></p><p><span style="color:#000000">用户可以通過該 APP 連接 Windows 365、Azure 虛擬桌面、Microsoft Dev Box 或個人遠程桌面 PC。在手機或 iPad 上，用户無需下載或安裝任何內容即可啓動 Windows 環境。</span></p><p><span style="color:#000000"><img alt="" height="309" src="https://oscimg.oschina.net/oscnet/up-6de517b3878e038efe903ec950a3f14d987.webp" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">新的 Windows APP 帶來了多項新功能：如支持多顯示器、自定義顯示分辨率、動態顯示縮放、網絡攝像頭、音頻和打印機的設備重定向等。用户可以固定最喜歡的應用程序，以便快速訪問，還可以在不同賬户之間輕鬆切換。</span></p><p><span style="color:#000000">雖然微軟官方表示該應用程序僅上架 iOS、Windows、macOS 以及網頁端，但提供的屏幕截圖顯示 Android&nbsp;平板上也能運行該應用。或許 Android 版本將會在不久的未來推出。</span></p><p><span style="color:#000000">不過，該 Windows APP 僅面向微軟企業用户提供，個人賬户無法訪問相關服務。但有跡象表明，微軟計劃通過 Windows 365 為普通消費者提供雲 PC。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 09:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266787/microsoft-windows-app-launched-run-cloud-pc</guid>
            <link>https://www.oschina.net/news/266787/microsoft-windows-app-launched-run-cloud-pc</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[ClickHouse 聯合創始人、前 Google 副總裁 Yury 到訪杭州玖章算術公司，雙方建立生態合作]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span><span style="color:#000000">10 月 31 日，ClickHouse 聯合創始人 Yury 到訪未來科技城，與玖章算術創始人葉正盛和國際總經理 Ni Demai 展開溝通與推進合作。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-3abad57e89ff8fcc5278d96ff167a2bf87d.jpg" width="1707" referrerpolicy="no-referrer"></p><p style="color:#999999; margin-left:0; margin-right:0; text-align:center">圖片備註：Ni Demai(左),Yury(中),葉正盛 (右)</p></div><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">ClickHouse 是深受開發者青睞的實時分析型數據庫，成立 2 年就發展成為基礎軟件領域的獨角獸，玖章算術核心產品 NineData 則是中國數據庫工具領域的佼佼者。通過本次溝通，</span><span style="color:#f04142">ClickHouse 將繼續增加其在生態能力上的投入，引入玖章算術成為 ClickHouse 全球正式合作伙伴</span><span style="color:#000000">，NineData 將提供數據複製、SQL 開發等能力，幫助開發者更加便捷、穩定地使用 ClickHouse。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">ClickHouse 中國區負責人王楠（Tracy）、玖章算術首席產品經理蔡冬者參與了本次會議，雙方深度交流了 NineData 幫助 ClikHouse 完成數據複製的實踐場景，將在 ClickHouse 中國社區發展深度合作。</span></span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="1659" src="https://oscimg.oschina.net/oscnet/up-29fbbc98347ec5e04fcc19c903bdcbea0d0.jpg" width="2091" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">Yury 作為 ClickHouse 的聯合創始人、產品和工程總裁，是前谷歌、Netflix 的副總裁。<span style="color:#f04142">本次代表 ClickHouse 與玖章算術 CEO 葉正盛進行溝通，旨在加強兩家公司之間的合作，增強 ClickHouse 的生態能力建設，幫助開發者更好地使用 ClickHouse。</span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="1080" src="https://oscimg.oschina.net/oscnet/up-d6908642b538092775611c1383c849b5928.jpg" width="2301" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">葉正盛是玖章算術創始人，在數據庫生態工具產品裏有 20 年經驗，是國內把數據庫生態工具體系做成專業產品的第一人。後續，</span><span style="color:#f04142">NineData 將快速支持 ClickHouse 最新版本，適配 ClickHouse Cloud，同時會更大力度投入中國 ClickHouse 社區建設。</span></span></p><div><p style="text-align:center"><img alt="" height="1080" src="https://oscimg.oschina.net/oscnet/up-e0d4a2d815c5fc2bf9daf62ae54c45c901c.jpg" width="2301" referrerpolicy="no-referrer"></p><p style="color:#999999; margin-left:0; margin-right:0; text-align:center">玖章算術創始人葉正盛（中）</p></div><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">NineData 提供企業級 SQL 開發能力，包括數據庫堡壘機、生產變更服務，以及細粒度權限管控、審計、敏感數據脱敏處理等功能。並集成了大模型 AI 技術，提供智能 SQL 編寫、SQL 優化和數據庫專業知識問答，能夠幫助客户提高 DBA 與技術團隊及 ISV 夥伴的合作效率。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">NineData 的數據複製能力可應用於多種場景，包括在線數據庫到數據倉庫實時同步、數據庫國產化替換、數據上雲、數據容災等，支持 1000 公里數據實時同步，複製性能超過 10 萬 TPS，領先於市場主流產品。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">NineData 的創始團隊由阿里雲、華為、IBM 等公司資深數據庫專家組成。NineData 支持 MySQL、Oracle、PostgreSQL、ClickHouse、Redis、MongoDB、Doris 等 60 種主流數據源。</span></span></p><div><p style="text-align:center"><img alt="" height="1332" src="https://oscimg.oschina.net/oscnet/up-7e72cd287ff75493e4b1730da64f74e22f5.png" width="2878" referrerpolicy="no-referrer"></p><p style="color:#999999; margin-left:0; margin-right:0; text-align:center">NineData 支持 60 種主流數據源</p></div><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">目前，NineData 已經為上萬開發者提供服務，在中國移動、沃爾沃、綠城集團等大型企業上線，與華為雲、阿里雲、騰訊雲、百度雲、移動雲、AWS、Apache Doris、SelectDB 等平台建立了緊密合作關係。NineData 的目標是讓企業各個數據源之間的數據自由流動，讓數據管理與研發流程更安全、更高效。</span></span></p><p style="margin-left:0px; margin-right:0px"><span><strong><span style="color:#000000">結束語：</span></strong><span style="color:#000000"><span>&nbsp;</span>ClickHouse 與玖章算術 NineData 的合作將促進其生態系統的發展，NineData 將更好地支持 ClickHouse 數據庫複製、SQL 開發等。這一合作將為中國的 ClickHouse 社區帶來更多支持和創新，進一步推動社區發展，幫助開發者更好的使用 ClickHouse，發掘數據價值，推進企業業務發展。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 09:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266785</guid>
            <link>https://www.oschina.net/news/266785</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GitHub 報告：TypeScript 取代 Java 成為第三受歡迎語言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">GitHub 發佈了 2023 年度&nbsp;Octoverse 開源狀態報告。主要研究了圍繞 AI、雲和 Git 的開源活動如何改變開發人員體驗，以及如何在開發者和企業中產生越來越大的影響。</span></p><p><span style="color:#000000">報告發現了三大趨勢：</span></p><ul><li><span style="color:#000000"><strong>開發人員正在大量使用生成式 AI 進行構建。</strong>越來越多的開發人員嘗試使用 OpenAI 和其他 AI 公司的基礎模型，開源生成式 AI 項目甚至在 2023 年進入了按貢獻者數量排名的十大最受歡迎的開源項目。幾乎所有開發人員 (92%) 都在使用或嘗試藉助 AI 編碼工具。</span></li><li><span style="color:#000000"><strong>開發人員正在大規模運行雲原生應用程序。</strong>使用基於 Git 的基礎設施即代碼 (IaC) 工作流的聲明式語言越來越多，雲部署的標準化程度更高，開發人員使用 Dockerfile 和容器、IaC 以及其他雲原生技術的速度也急劇加快。</span></li><li><span style="color:#000000"><strong>2023 年 first-time 開源貢獻者數量最多。</strong>其中，有商業支持的開源項目依舊最受貢獻者歡迎。但生成式 AI 項目在今年進入了 first-time 貢獻者最受歡迎的的十大項目之列。GitHub 上的私人項目顯着增長，同比增長 38%，佔 GitHub 上所有活動的 80% 以上。</span></li></ul><p><span style="color:#000000"><strong>全球開發者社區</strong>繼續增長。美國擁有 2020 萬開發者，開發者人數在去年增長了 21%，仍然是全球最大的開發者社區。亞太地區、非洲、南美洲和歐洲的開發者社區規模逐年擴大，其中印度、巴西和日本處於領先地位。</span></p><p><span style="color:#000000">預計到 2027 年，印度將取代美國成為 GitHub 上最大的開發者社區。新加坡今年是亞太地區開發者人數增長最快的國家，並且是開發者佔總人口的比例最高的第地區（全球範圍內）。報告指出，由於日本在技術和初創企業方面的進一步投資，明年日本的開發者將有持續增長。</span></p><p><img alt="" height="281" src="https://oscimg.oschina.net/oscnet/up-ac720a0e760e91cc5b2eb3fbe5912621880.webp" width="500" referrerpolicy="no-referrer"></p><p><img height="356" src="https://oscimg.oschina.net/oscnet/up-80f62228356fcbdefb478e041a0eac39e37.png" width="400" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><strong>生成式 AI </strong>在 2023 年經歷了爆發式增長，僅半年內湧現出的生成式 AI 項目數量就已達到了 2022 年全年的兩倍之多。開發人員也開始更多地嘗試使用 AI 模型。前幾年，開發人員常使用 tensorflow/tensorflow、pytorch/pytorch 等機器學習庫構建項目；現在則更多嘗試使用 AI 模型和 LLM（如 ChatGPT API）。</span></p><p><img height="270" src="https://oscimg.oschina.net/oscnet/up-7496f60e2ee0f94240f5faf6341e5262a5b.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">報告分析了 GitHub 上排名前 20 位的開源生成式 AI 項目，發現其中一些頂級項目都是由個人所有。生成式 AI 項目中的個人貢獻者正在全球範圍內大幅飆升，同比增長幅度達到了 148%，而生成式 AI 項目總數也同比增長 248%。</span></p><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">美國、印度和日本在開發者社區中處於領先地位，</span><span style="background-color:#ffffff; color:#24292f">香港特別行政區</span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">、英國和巴西緊隨其後。</span></p><p><img height="257" src="https://oscimg.oschina.net/oscnet/up-24b4f2b8554174e97591f4e9b11183c4b8e.png" width="500" referrerpolicy="no-referrer"></p><p><strong style="color:rgba(0, 0, 0, 0.9)">最流行的編程語言</strong></p><p><img height="144" src="https://oscimg.oschina.net/oscnet/up-3a0a14c95ce1e310f742e6ce36ad9af9795.png" width="500" referrerpolicy="no-referrer"></p><p>報告指出，<span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">自 2019 年雲原生開發大規模增長以來，IaC 在開源領域持續增長。2023 年，Shell 和 Hashicorp 配置語言（HCL）再次成為開源項目中的頂級語言，</span><span style="background-color:#ffffff; color:#24292f">HCL 採用率同比增長 36%；「表明運維和 IaC 工作在開源領域越來越受到重視」。</span></p><p><img height="263" src="https://oscimg.oschina.net/oscnet/up-72dde2bf24c363d79ba454d8df65c964a2b.png" width="500" referrerpolicy="no-referrer"></p><ul style="list-style-type:disc; margin-left:0; margin-right:0"><li><span style="color:#000000">JavaScript 仍然是 GitHub 上最常用的語言，其次是 Python。</span></li><li><span style="color:#000000">TypeScript 越來越受歡迎，<span style="background-color:#ffffff">首次取代 Java 成為 GitHub 上 OSS 項目中第三大最受歡迎的語言，其用户羣增長了 37%。</span></span></li><li><span style="color:#000000">用於數據分析和操作的流行語言和框架明顯增加。T-SQL 和 TeX 等古老的語言在 2023 年均有所增長，凸顯了數據科學家、數學家和分析師越來越多地使用開源平台和工具。「<span style="background-color:#ffffff">編程語言不再僅僅侷限於傳統軟件開發領域</span>」。</span></li><li><span style="color:#000000"><span style="background-color:#ffffff">在 GitHub 上一些較新的項目中，Kotlin、Rust、Go 和 Lua 的採用出現了較大的增長。「Rust 和 Lua 都以內存安全和高效著稱，而且都可用於系統和嵌入式系統編程，這也是它們增長的原因。而 Go 最近的增長則是由 Kubernetes 和 Prometheus 等雲原生項目的推動。」</span></span></li></ul><p><img height="262" src="https://oscimg.oschina.net/oscnet/up-58e41eb95e2505a64d2a2a8a7b46fdf4ee6.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">其他一些發現還包括：</span></span></p><ul><li><span style="color:#000000"><span style="background-color:#ffffff">與 2022 年相比，2023 年開源代碼開發人員合併的針對易受攻擊軟件包的自動 Dependabot 拉取請求增加了 60%</span></span></li><li><span style="color:#000000"><span style="background-color:#ffffff">2023 年，</span><span style="background-color:#ffffff">開發者</span><span style="background-color:#ffffff">為 GitHub 上的開源項目做出了 3.01 億次貢獻，這些項目既有像 Mastodon 這樣的熱門項目，也有像 Stable Diffusion 和 LangChain 這樣的生成式 AI 項目。</span></span></li><li><span style="color:#000000"><span style="background-color:#ffffff">2023 年有 430 萬個存儲庫使用了 Docker。Linux 發行版 NixOS/nixpkgs 在過去兩年中一直位居開源項目貢獻者榜首。</span></span></li></ul><p><span style="background-color:#ffffff; color:#333333">更多詳情可</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.blog%2F2023-11-08-the-state-of-open-source-and-ai%2F" target="_blank">查看完整報告</a><span style="background-color:#ffffff; color:#333333">。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 07:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266757/2023-state-of-the-octoverse</guid>
            <link>https://www.oschina.net/news/266757/2023-state-of-the-octoverse</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[李開復再回應爭議：受益於開源也貢獻開源]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>針對旗下「零一萬物」 開源的 Yi 大模型近日被質疑照搬 Llama 架構，只對兩個張量（Tensor）名稱做了修改的風波，李開復在朋友圈<span style="color:#030303">轉發了「</span><a href="https://www.oschina.net/news/266597" target="news">零一萬物對 Yi-34B 訓練過程的説明</a><span style="color:#030303">」文章，並配文</span>迴應稱：</p><blockquote><p><span style="color:#030303">零一萬物 Yi-34B 模型訓練的説明也迴應這兩天大家對於模型架構的探討。全球大模型架構一路從 GPT2--&gt;Gopher--&gt;Chinchilla--&gt;Llama2-&gt;Yi，行業逐漸形成大模型的通用標準（就像做一個手機 app 開發者不會去自創 iOS、Android 以外的全新基礎架構）。01.AI 起步受益於開源，也貢獻開源，從社區中虛心學習，我們會持續進步。</span></p></blockquote><p><img height="290" src="https://static.oschina.net/uploads/space/2023/1116/141708_SLoh_4252687.png" width="300" referrerpolicy="no-referrer"></p><p><strong>相關閲讀：</strong></p><ul><li><a href="https://www.oschina.net/news/266377">李開復旗下 AI 公司 「零一萬物」 開源的 Yi 大模型照搬 Llama 架構</a></li><li><a href="https://www.oschina.net/news/266525">「零一萬物」 迴應 Yi 開源大模型 「套殼」 Llama</a></li><li><p style="margin-left:0px; margin-right:0px; text-align:start"><a href="https://www.oschina.net/news/266597" target="_blank">零一萬物對 Yi-34B 訓練過程的説明</a></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 06:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266727</guid>
            <link>https://www.oschina.net/news/266727</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[.NET 8.0 中有哪些新的變化？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong>1 性能提升</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fperformance-improvements-in-aspnet-core-8%2F" target="_blank">.NET 8 在整個</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fdotnet-8-performance-improvements-in-dotnet-maui%2F" target="_blank">堆棧</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fthis-arm64-performance-in-dotnet-8%2F" target="_blank">中</a>帶來了數千項性能<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fperformance-improvements-in-net-8%2F" target="_blank">改進</a> 。默認情況下會啓用一種名為動態配置文件引導優化 (PGO) 的新代碼生成器，它可以根據實際使用情況優化代碼，並且可以將應用程序的性能提高高達 20%。現在支持的 AVX-512 指令集能夠對 512 位數據向量執行並行操作，這意味着可以在更短的時間內處理更多的數據。原始類型（數字及其他類型）現在實現了新的可格式化和可解析接口，這使它們能夠直接格式化和解析為 UTF-8，而無需任何轉碼開銷。 <img src="https://img-blog.csdnimg.cn/img_convert/b91071a2632a5da242e53238fb844e52.png" alt="" referrerpolicy="no-referrer"></p><p><strong>2.NET Aspire</strong></p><p>.NET Aspire 是一個用於使用 .NET 構建彈性、可觀察和可配置的雲原生應用程序的堆棧。它包括一組針對雲原生而增強的精選組件，默認情況下包括遙測、彈性、配置和運行狀況檢查。結合複雜而簡單的本地開發人員體驗，.NET Aspire 可以在第 1 天和第 100 天輕鬆發現、獲取和配置雲原生應用程序的基本依賴項。</p><p>點擊這裏查看.NET Aspire 的預覽版本。 <img src="https://img-blog.csdnimg.cn/img_convert/ba664a021af354f1fc46c013578b8946.png" alt="" referrerpolicy="no-referrer"></p><p><strong>3.NET 8 容器增強功能 – 更安全、更緊湊、更高效</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fsecuring-containers-with-rootless%2F" target="_blank">使用 .NET 比以往更輕鬆、更安全地使用容器</a>打包應用程序。每個 .NET 映像都包含一個非 root 用户，從而通過單行配置啓用更安全的容器。.NET SDK 工具無需 Dockerfile 即可發佈容器映像，並且默認情況下是非 root 的。由於 .NET 基礎映像更小，因此可以更快地部署容器化應用程序 - 包括我們映像的新實驗變體，這些變體可為本機 AOT 提供真正最小的應用程序大小。選擇使用新的 Chiseled Ubuntu 映像變體進行更多安全強化，以進一步減少攻擊面。使用 Dockerfile 或 SDK 工具，為任何架構構建應用程序和容器映像。 <img src="https://img-blog.csdnimg.cn/img_convert/16b65a6962356cd1e24f164cf66ead3c.png" alt="" referrerpolicy="no-referrer"></p><p><strong>4 原生 AoT – 邁向更高密度可持續計算的旅程</strong></p><p>無需等待 JIT（即時）編譯器在運行時編譯代碼。無需部署 JIT 編譯器和 IL 代碼。AOT 應用程序僅部署應用程序所需的代碼。應用程序現在可以在不允許使用 JIT 編譯器的受限環境中運行。 <img src="https://img-blog.csdnimg.cn/img_convert/5037b084ad2c4e26f6696f6c7b74712a.png" alt="" referrerpolicy="no-referrer"></p><p><strong>5 人工智能 – 將 AI 融入您的 .NET 應用程序</strong></p><p>生成式人工智能和大型語言模型正在改變人工智能領域，使開發人員能夠在其應用程序中創建獨特的人工智能體驗。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgist.github.com%2FLadyNaggaga%2F5b0a708f2b945f5c8ca8ade4974665ff" target="_blank">.NET 8 可以</a>通過 .NET SDK 中一流的開箱即用 AI 功能以及與多種工具的無縫集成來輕鬆利用 AI。</p><p>.NET 8 為該，庫帶來了多項增強功能，以提高其與生成式 AI 工作負載的兼容性，例如集成 Tensor Primitives。隨着人工智能應用程序的興起，新的工具和 SDK 出現了。我們與眾多內部和外部合作伙伴合作，例如 Azure OpenAI、Azure Cognitive Search、Milvus、Qdrant 和 Microsoft Teams，以確保 .NET 開發人員可以通過各自的 SDK 輕鬆訪問各種 AI 模型、服務和平台。此外，開源語義內核 SDK 簡化了這些 AI 組件與新的和現有應用程序的集成，以幫助您提供創新的用户體驗。System.Numerics</p><p>現在提供各種示例和參考模板，展示模式和實踐，以便開發人員輕鬆入門：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdotnet%2FeShop" target="_blank">客户聊天機器人</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAzure-Samples%2Fazure-search-openai-demo-csharp" target="_blank">檢索增強生成</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fdemystifying-retrieval-augmented-generation-with-dotnet%2F" target="_blank">使用 Azure AI 服務開發應用程序</a><img src="https://img-blog.csdnimg.cn/img_convert/892b90ec5d84e0bf792f8dba707dce58.png" alt="" referrerpolicy="no-referrer"></li></ul><p><strong>6Blazor – 使用 .NET 構建全棧 Web 應用程序</strong></p><p>.NET 8 中的 Blazor 可以同時使用服務器和客户端來處理您的所有 Web UI 需求。這是全棧 Web UI！通過專注於優化頁面加載時間、可擴展性和提升用户體驗的多項新增強功能，開發人員現在可以在同一應用程序中使用 Blazor Server 和 Blazor WebAssembly，在運行時自動將用户從服務器轉移到客户端。得益於新的基於「Jiterpreter」的運行時和新的內置組件，您的 .NET 代碼在 WebAssembly 上的運行速度顯着加快。作為增強.NET 8 中整體身份驗證、授權和身份管理的一部分，Blazor 現在支持生成完整的基於 Blazor 的身份 UI。 <img src="https://img-blog.csdnimg.cn/img_convert/f0563b1ef218bb7b09130df55e5de700.png" alt="" referrerpolicy="no-referrer"></p><p><strong>7.NET MAUI – 提升性能、可靠性和開發人員體驗</strong></p><p>.NET MAUI 提供單一項目系統和單一代碼庫來構建 WinUI、Mac Catalyst、iOS 和 Android 應用程序。本機 AOT（實驗性）現在支持針對類似 iOS 的平台。適用於 .NET MAUI 的新 Visual Studio Code 擴展為您提供了開發跨平台 .NET 移動和桌面應用程序所需的工具。現在支持 Xcode 15 和 Android API 34，允許您瞄準最新版本的 iOS 和 Android。在性能、控件和 UI 元素以及特定於平台的行為方面進行了大量的質量改進，例如桌面交互添加了更好的點擊處理、鍵盤偵聽器等。 <img src="https://img-blog.csdnimg.cn/img_convert/130807a5e11b784d65aa556290afda0d.png" alt="" referrerpolicy="no-referrer"></p><p><strong>8 C# 12 功能 – 簡化語法以提高開發人員的工作效率</strong></p><p>C# 12 讓您的編碼體驗更加高效和愉快。現在，您可以使用簡單而優雅的語法在任何類和結構中創建主構造函數。不再需要樣板代碼來初始化您的字段和屬性。使用簡潔且富有表現力的語法創建數組、跨度和其他集合類型時會感到高興。對 lambda 表達式中的參數使用新的默認值。不再需要重載或空檢查來處理可選參數。您甚至可以使用 usingalias 指令為任何類型添加別名，而不僅僅是命名類型！</p><p><strong>8.1 集合表達式</strong></p><p>在 C# 12 之前，創建集合需要針對不同場景使用不同的語法。初始化所需的與 or 不同的語法。以下是創建集合的幾種方法：List&lt;int&gt;int[]Span&lt;int&gt;</p><pre><code class="language-C#">int[] x1 = new int[] { 1, 2, 3, 4 };
int[] x2 = Array.Empty&lt;int&gt;();
WriteByteArray(new[] { (byte)1, (byte)2, (byte)3 });
List&lt;int&gt; x4 = new() { 1, 2, 3, 4 };
Span&lt;DateTime&gt; dates = stackalloc DateTime[] { GetDate(0), GetDate(1) };
WriteByteSpan(stackalloc[] { (byte)1, (byte)2, (byte)3 });
</code></pre><p><strong>8.2 任何類或結構上的主構造函數</strong></p><p>C# 12 擴展了主構造函數以適用於所有類和結構，而不僅僅是記錄。主構造函數允許在聲明類時定義構造函數參數：</p><pre><code class="language-C#">public class BankAccount(string accountID, string owner)
{
    public string AccountID { get; } = accountID;
    public string Owner { get; } = owner;

    public override string ToString() =&gt; $"Account ID: {AccountID}, Owner: {Owner}";
}
</code></pre><p>主構造函數參數最常見的用途是：</p><ul><li>作為 base() 構造函數調用的參數。</li><li>初始化成員字段或屬性。</li><li>在實例成員中引用構造函數參數。</li><li>刪除依賴注入中的樣板。</li></ul><p><strong>8.3 別名任意類型</strong></p><p>別名類型是從代碼中刪除複雜類型簽名的便捷方法。using 從 C# 12 開始，其他類型在別名指令中有效。例如，這些別名在早期版本的 C# 中無效：</p><pre><code class="language-C#">using intArray = int[]; // Array types.
using Point = (int x, int y);  // Tuple type
using unsafe ArrayPtr = int*;  // Pointer type (requires "unsafe")
</code></pre><p><strong>8.4 默認 lambda 參數</strong></p><p>從 C# 12 開始，您可以在 lambda 表達式中聲明默認參數：</p><pre><code class="language-C#">var IncrementBy = (int source, int increment = 1) =&gt; source + increment;

Console.WriteLine(IncrementBy(5)); // 6
Console.WriteLine(IncrementBy(5, 2)); // 7
</code></pre><p><strong>8.5 內聯數組</strong></p><p>運行時團隊和其他庫作者使用內聯數組來提高應用的性能。 內聯數組使開發人員能夠創建固定大小的 struct 類型數組。 具有內聯緩衝區的結構應提供類似於不安全的固定大小緩衝區的性能特徵。 你可能不會聲明自己的內聯數組，但當它們從運行時 API 作為 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.span-1" target="_blank">System.Span&lt;T&gt;</a> 或 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.readonlyspan-1" target="_blank">System.ReadOnlySpan&lt;T&gt;</a> 對象公開時，你將透明地使用這些數組。</p><pre><code class="language-C#">[System.Runtime.CompilerServices.InlineArray(10)]
public struct Buffer
{
    private int _element0;
}
</code></pre><p>它們的用法與任何其他數組類似：</p><pre><code class="language-C#">var buffer = new Buffer();
for (int i = 0; i &lt; 10; i++)
{
    buffer[i] = i;
}

foreach (var i in buffer)
{
    Console.WriteLine(i);
}
</code></pre><p>區別在於編譯器可以利用有關內聯數組的已知信息。 你可能會像使用任何其他數組一樣使用內聯數組。 有關如何聲明內聯數組的詳細信息，請參閲有關 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fcsharp%2Flanguage-reference%2Fbuiltin-types%2Fstruct%23inline-arrays" target="_blank">struct</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fcsharp%2Flanguage-reference%2Fbuiltin-types%2Fstruct%23inline-arrays" target="_blank">類型</a>的語言參考。</p><p><strong>9.反射改進</strong></p><p>.NET 5 中引入了函數指針，但當時未添加對反射的相應支持。 對函數指針使用 typeof 或反射時（例如分別使用 typeof(delegate*&lt;void&gt;()) 或 FieldInfo.FieldType），返回了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.intptr" target="_blank">IntPtr</a>。 從 .NET 8 開始，將改為返回 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.type" target="_blank">System.Type</a> 對象。 此類型提供對函數指針元數據的訪問，包括調用約定、返回類型和參數。</p><p>新功能目前僅在 CoreCLR 運行時和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.reflection.metadataloadcontext" target="_blank">MetadataLoadContext</a> 中實現。已將新的 API 添加到 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.type" target="_blank">System.Type</a>（例如 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.type.isfunctionpointer%23system-type-isfunctionpointer" target="_blank">IsFunctionPointer</a>）以及 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.reflection.propertyinfo" target="_blank">System.Reflection.PropertyInfo</a>、System.Reflection.FieldInfo 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.reflection.parameterinfo" target="_blank">System.Reflection.ParameterInfo</a>。 以下代碼演示如何使用一些新 API 進行反射。</p><pre><code class="language-C#">// Sample class that contains a function pointer field.
public unsafe class UClass
{
    public delegate* unmanaged[Cdecl, SuppressGCTransition]&lt;in int, void&gt; _fp;
}

// ...

FieldInfo fieldInfo = typeof(UClass).GetField(nameof(UClass._fp));

// Obtain the function pointer type from a field.
Type fpType = fieldInfo.FieldType;

// New methods to determine if a type is a function pointer.
Console.WriteLine($"IsFunctionPointer: {fpType.IsFunctionPointer}");
Console.WriteLine($"IsUnmanagedFunctionPointer: {fpType.IsUnmanagedFunctionPointer}");

// New methods to obtain the return and parameter types.
Console.WriteLine($"Return type: {fpType.GetFunctionPointerReturnType()}");

foreach (Type parameterType in fpType.GetFunctionPointerParameterTypes())
{
    Console.WriteLine($"Parameter type: {parameterType}");
}

// Access to custom modifiers and calling conventions requires a "modified type".
Type modifiedType = fieldInfo.GetModifiedFieldType();

// A modified type forwards most members to its underlying type.
Type normalType = modifiedType.UnderlyingSystemType;

// New method to obtain the calling conventions.
foreach (Type callConv in modifiedType.GetFunctionPointerCallingConventions())
{
    Console.WriteLine($"Calling convention: {callConv}");
}

// New method to obtain the custom modifiers.
foreach (Type modreq in modifiedType.GetFunctionPointerParameterTypes()[0].GetRequiredCustomModifiers())
{
    Console.WriteLine($"Required modifier for first parameter: {modreq}");
}
</code></pre><p>輸出：</p><pre><code class="language-C#">IsFunctionPointer: True
IsUnmanagedFunctionPointer: True
Return type: System.Void
Parameter type: System.Int32&amp;
Calling convention: System.Runtime.CompilerServices.CallConvSuppressGCTransition
Calling convention: System.Runtime.CompilerServices.CallConvCdecl
Required modifier for first parameter: System.Runtime.InteropServices.InAttribute
</code></pre><p><strong>10.配置綁定源生成器</strong></p><p>.NET 8 引入了一個源生成器，用於在 ASP.NET Core 中提供 AOT 和適合剪裁的配置。 該生成器是現有的基於反射的實現的替代方法。</p><p>源生成器探測 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fmicrosoft.extensions.options.configureoptions-1.configure%23microsoft-extensions-options-configureoptions-1-configure%28-0%29" target="_blank">Configure(TOptions)</a>、Bind 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fmicrosoft.extensions.configuration.configurationbinder.get" target="_blank">Get</a> 調用來從中檢索類型信息。 在項目中啓用生成器後，編譯器將隱式選擇生成的方法，而非預先存在的基於反射的框架實現。</p><p>無需更改源代碼即可使用生成器。 AOT Web 應用中默認啓用該生成器。 對於其他項目類型，源生成器默認關閉，但你可通過在項目文件中將 EnableConfigurationBindingGenerator 屬性設置為 true 來選擇使用它：</p><pre><code class="language-XML">&lt;PropertyGroup&gt;
    &lt;EnableConfigurationBindingGenerator&gt;true&lt;/EnableConfigurationBindingGenerator&gt;
&lt;/PropertyGroup&gt;
</code></pre><p>以下代碼演示了調用綁定器的示例：</p><pre><code class="language-C#">using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

WebApplicationBuilder builder = WebApplication.CreateBuilder(args);
IConfigurationSection section = builder.Configuration.GetSection("MyOptions");

// !! Configure call - to be replaced with source-gen'd implementation
builder.Services.Configure&lt;MyOptions&gt;(section);

// !! Get call - to be replaced with source-gen'd implementation
MyOptions options0 = section.Get&lt;MyOptions&gt;();

// !! Bind call - to be replaced with source-gen'd implementation
MyOptions options1 = new MyOptions();
section.Bind(options1);

WebApplication app = builder.Build();
app.MapGet("/", () =&gt; "Hello World!");
app.Run();

public class MyOptions
{
    public int A { get; set; }
    public string S { get; set; }
    public byte[] Data { get; set; }
    public Dictionary&lt;string, string&gt; Values { get; set; }
    public List&lt;MyClass&gt; Values2 { get; set; }
}

public class MyClass
{
    public int SomethingElse { get; set; }
}
</code></pre><p><strong>11.針對 Android 應用的 AOT 編譯</strong></p><p>為了減小應用大小，面向 Android 的 .NET 和 .NET MAUI 應用在發佈模式下構建時使用分析的預先 (AOT) 編譯模式。 與常規 AOT 編譯相比，分析的 AOT 編譯所影響的方法更少。 .NET 8 引入了 &lt;AndroidStripILAfterAOT&gt; 屬性，你可使用它進一步對 Android 應用進行 AOT 編譯，從而更進一步減少應用大小。</p><pre><code class="language-XML">&lt;PropertyGroup&gt;
  &lt;AndroidStripILAfterAOT&gt;true&lt;/AndroidStripILAfterAOT&gt;
&lt;/PropertyGroup&gt;
</code></pre><p>默認情況下，將 AndroidStripILAfterAOT 設置為 true 會替代默認的 AndroidEnableProfiledAot 設置，從而允許剪裁已 AOT 編譯的（幾乎）所有方法。 還可通過將兩個屬性都顯式設置為 true 來結合使用分析的 AOT 和 IL 條帶化：</p><pre><code class="language-XML">&lt;PropertyGroup&gt;
  &lt;AndroidStripILAfterAOT&gt;true&lt;/AndroidStripILAfterAOT&gt;
  &lt;AndroidEnableProfiledAot&gt;true&lt;/AndroidEnableProfiledAot&gt;
&lt;/PropertyGroup&gt;
</code></pre><p><strong>12.代碼分析</strong></p><p>.NET 8 包括幾個新的代碼分析器和修復程序，可幫助驗證是否正確且高效地使用 .NET 庫 API。 下表總結了新的分析器。</p><table><thead><tr><th>規則 ID</th><th>類別</th><th>説明</th></tr></thead><tbody><tr><td>CA1856</td><td>性能</td><td>未在參數上正確應用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.diagnostics.codeanalysis.constantexpectedattribute" target="_blank">ConstantExpectedAttribute</a> 屬性時觸發。</td></tr><tr><td>CA1857</td><td>性能</td><td>當參數使用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.diagnostics.codeanalysis.constantexpectedattribute" target="_blank">ConstantExpectedAttribute</a> 添加批註但提供的參數不是常量時觸發。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1858" target="_blank">CA1858</a></td><td>性能</td><td>若要確定字符串是否以給定前綴開頭，最好調用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.string.startswith" target="_blank">String.StartsWith</a>，而不是調用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.string.indexof" target="_blank">String.IndexOf</a>，然後將結果與零進行比較。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1859" target="_blank">CA1859</a></td><td>性能</td><td>此規則建議儘可能將特定局部變量、字段、屬性、方法參數和方法返回類型從接口或抽象類型升級到具體類型。 使用具體類型可生成更高質量的代碼。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1860" target="_blank">CA1860</a></td><td>性能</td><td>若要確定集合類型是否具有任何元素，最好使用 Length、Count 或 IsEmpty，而不是調用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.linq.enumerable.any" target="_blank">Enumerable.Any</a>。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1861" target="_blank">CA1861</a></td><td>性能</td><td>重複調用時，不會重複使用作為參數傳遞的常量數組，這意味着每次都會創建一個新數組。 若要提高性能，請考慮將數組提取到靜態只讀字段。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1865-ca1867" target="_blank">CA1865-CA1867</a></td><td>性能</td><td>對於單字符串，char 重載的性能更好。</td></tr><tr><td>CA2021</td><td>可靠性</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.linq.enumerable.cast%23system-linq-enumerable-cast-1%28system-collections-ienumerable%29" target="_blank">Enumerable.Cast(IEnumerable)</a> 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.linq.enumerable.oftype%23system-linq-enumerable-oftype-1%28system-collections-ienumerable%29" target="_blank">Enumerable.OfType(IEnumerable)</a> 需要兼容的類型才能正常運行。 泛型類型不支持擴大轉換和用户定義的轉換。</td></tr><tr><td>CA1510-CA1513</td><td>可維護性</td><td>在構造新的異常實例方面，引發幫助程序比 if 塊更簡單、更高效。 這四個分析器是為以下例外情況創建的：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.argumentnullexception" target="_blank">ArgumentNullException</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.argumentexception" target="_blank">ArgumentException</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.argumentoutofrangeexception" target="_blank">ArgumentOutOfRangeException</a> 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.objectdisposedexception" target="_blank">ObjectDisposedException</a>。</td></tr></tbody></table><p><strong>13.Core .NET 庫</strong></p><p><strong>13.1 時間抽象</strong></p><p>新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.timeprovider" target="_blank">TimeProvider</a> 類和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.itimer" target="_blank">ITimer</a> 接口添加了時間抽象功能，讓你可以在測試方案中模擬時間。 此外，還可以使用時間抽象，通過 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.tasks.task.delay" target="_blank">Task.Delay</a> 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.tasks.task.waitasync" target="_blank">Task.WaitAsync</a> 來模擬依賴於時間進度的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.tasks.task" target="_blank">Task</a> 操作。 時間抽象支持以下基本時間操作：</p><ul><li>檢索本地和 UTC 時間</li><li>獲取用於測量性能的時間戳</li><li>創建計時器</li></ul><p>以下代碼片段演示了一些使用情況示例。</p><pre><code class="language-C#">// Get system time.
DateTimeOffset utcNow = TimeProvider.System.GetUtcNow();
DateTimeOffset localNow = TimeProvider.System.GetLocalNow();

// Create a time provider that works with a
// time zone that's different than the local time zone.
private class ZonedTimeProvider : TimeProvider
{
    private TimeZoneInfo _zoneInfo;

    public ZonedTimeProvider(TimeZoneInfo zoneInfo) : base()
    {
        _zoneInfo = zoneInfo ?? TimeZoneInfo.Local;
    }

    public override TimeZoneInfo LocalTimeZone =&gt; _zoneInfo;

    public static TimeProvider FromLocalTimeZone(TimeZoneInfo zoneInfo) =&gt;
        new ZonedTimeProvider(zoneInfo);
}

// Create a timer using a time provider.
ITimer timer = timeProvider.CreateTimer(callBack, state, delay, Timeout.InfiniteTimeSpan);

// Measure a period using the system time provider.
long providerTimestamp1 = TimeProvider.System.GetTimestamp();
long providerTimestamp2 = TimeProvider.System.GetTimestamp();

var period = GetElapsedTime(providerTimestamp1, providerTimestamp2);
</code></pre><p><strong>13.2UTF8 改進</strong></p><p>如果要啓用將類型的類似字符串的表示形式寫出到目標範圍，請在類型上實現新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.iutf8spanformattable" target="_blank">IUtf8SpanFormattable</a> 接口。 此新接口與 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.ispanformattable" target="_blank">ISpanFormattable</a> 密切相關，但面向 UTF8 和 Span&lt;byte&gt;，而不是 UTF16 和 Span&lt;char&gt;。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.iutf8spanformattable" target="_blank">IUtf8SpanFormattable</a> 已在所有基元類型（以及其他）上實現，無論是面向 string、Span&lt;char&gt; 還是 Span&lt;byte&gt;，其共享邏輯完全一致。 它完全支持所有格式（包括新的「B」二進制説明符）和所有區域性。 這意味着現在可以從 Byte、Complex、Char、DateOnly、DateTime、DateTimeOffset、Decimal、Double、Guid、Half、IPAddress、IPNetwork、Int16、Int32、Int64、Int128、IntPtr、NFloat、SByte、Single、Rune、TimeOnly、TimeSpan、UInt16、UInt32、UInt64、UInt128、UIntPtr 和 Version 直接格式化為 UTF8。</p><p>新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.text.unicode.utf8.trywrite" target="_blank">Utf8.TryWrite</a> 方法向現有 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.memoryextensions.trywrite" target="_blank">MemoryExtensions.TryWrite</a> 方法（基於 UTF16）提供基於 UTF8 的對應方法。 可以使用內插字符串語法將複雜表達式直接格式化為 UTF8 字節範圍，例如：</p><pre><code class="language-C#">static bool FormatHexVersion(
    short major,
    short minor,
    short build,
    short revision,
    Span&lt;byte&gt; utf8Bytes,
    out int bytesWritten) =&gt;
    Utf8.TryWrite(
        utf8Bytes,
        CultureInfo.InvariantCulture,
        $"{major:X4}.{minor:X4}.{build:X4}.{revision:X4}",
        out bytesWritten);
</code></pre><p><strong>13.3 加密</strong></p><p>.NET 8 添加了對 SHA-3 哈希基元的支持。 （目前，具有 OpenSSL 1.1.1 或更高版本和 Windows 11 Build 25324 或更高版本的 Linux 支持 SHA-3。）可在其中使用 SHA-2 的 API 現在提供對 SHA-3 的補充。 對於哈希，這包括 SHA3_256、SHA3_384 和 SHA3_512；對於 HMAC，這包括 HMACSHA3_256、HMACSHA3_384 和 HMACSHA3_512；對於其中可配置算法的哈希，這包括 HashAlgorithmName.SHA3_256、HashAlgorithmName.SHA3_384 和 HashAlgorithmName.SHA3_512；對於 RSA OAEP 加密，這包括 RSAEncryptionPadding.OaepSHA3_256、RSAEncryptionPadding.OaepSHA3_384 和 RSAEncryptionPadding.OaepSHA3_512。</p><p>以下示例演示如何使用 API（包括 SHA3_256.IsSupported 屬性）來確定平台是否支持 SHA-3。</p><pre><code class="language-C#">// Hashing example
if (SHA3_256.IsSupported)
{
    byte[] hash = SHA3_256.HashData(dataToHash);
}
else
{
    // ...
}

// Signing example
if (SHA3_256.IsSupported)
{
     using ECDsa ec = ECDsa.Create(ECCurve.NamedCurves.nistP256);
     byte[] signature = ec.SignData(dataToBeSigned, HashAlgorithmName.SHA3_256);
}
else
{
    // ...
}
</code></pre><p><strong>13.4 基於流的 ZipFile 方法</strong></p><p>.NET 8 包含 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.io.compression.zipfile.createfromdirectory" target="_blank">ZipFile.CreateFromDirectory</a> 的新重載，通過它可以收集目錄中包含的所有文件並壓縮這些文件，然後將生成的 zip 文件存儲到提供的流中。 同樣，通過新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.io.compression.zipfile.extracttodirectory" target="_blank">ZipFile.ExtractToDirectory</a> 重載，可提供包含壓縮文件的流，並將其內容提取到文件系統中。 下面是新的重載：</p><pre><code class="language-C#">namespace System.IO.Compression;

public static partial class ZipFile
{
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination);
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, CompressionLevel compressionLevel, bool includeBaseDirectory);
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, CompressionLevel compressionLevel, bool includeBaseDirectory, Encoding? entryNameEncoding);

    public static void ExtractToDirectory(Stream source, string destinationDirectoryName) { }
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, bool overwriteFiles) { }
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, Encoding? entryNameEncoding) { }
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, Encoding? entryNameEncoding, bool overwriteFiles) { }
}
</code></pre><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fdeveloper%2Factivereports" target="_blank">ActiveReports</a>是一款專注於 .NET 和 .NET Core 平台的報表控件。通過拖拽式報表設計器， 可以快速地設計 Excel 表格、Word 文檔、圖表、數據過濾、數據鑽取、精準套打等類型報表， 全面滿足 WinForm、ASP.NET、ASP.NET MVC、WPF 平台中各種報表的開發需要。 同時，通過豐富的 API 可以靈活的實現報表創建、加載和運行時的個性化自定義需求。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fsolutions%2Fwyn" target="_blank">Wyn 商業智能</a>是基於葡萄城 20 多年數據分析技術積累打造的全新一代嵌入式 BI 產品，旨在提供可與應用系統深度集成的數據分析功能，能夠與企業現有業務系統 OA， ERP，MES，CRM 等應用系統深度集成，整合、分析多個業務系統的數據，自助式分析業務數據、實時分析決策，全面提升企業競爭力。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fdeveloper%2Fspreadstudio" target="_blank">Spread .NET</a>是一個功能、佈局與 Excel 高度類似的 .NET 表格控件，可全面滿足 WinForm、ASP.NET、XAML 和 WinRT 等平台下表格數據處理、數據可視化開發需求。Spread .NET 支持 462 種 Excel 公式，提供可嵌入系統的類 Excel 設計器和全面開放的 API，為 .NET 開發人員構建企業級表格應用程序提供更加專業的選擇。</p><p>參考資料：</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fcore%2Fwhats-new%2Fdotnet-8%23networking" target="_blank">https://learn.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-8#networking</a></p><p><strong>擴展鏈接：</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fblogs%2Fexcel-io-spreadjs-blazor" target="_blank">如何使用 Blazor 框架在前端瀏覽器中導入/導出 Excel XLSX</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fblogs%2Fcreate-flow-chart-dotnet" target="_blank">如何在.NET 電子表格應用程序中創建流程圖</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fblogs%2Fsjs-realtime-data-refresh-part1" target="_blank">如何將實時數據顯示在前端電子表格中</a></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 06:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/powertoolsteam/blog/10143465</guid>
            <link>https://my.oschina.net/powertoolsteam/blog/10143465</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米推出 Xiaomi Vela 快應用開發工具：Aiot-IDE]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米在今天舉辦的《2023&nbsp;小米 IoT 生態夥伴大會》上<a href="https://www.oschina.net/news/266688/xiaomi-vela-opensource">宣佈</a>全面開源&nbsp;Xiaomi Vela。</p><p><img alt="" height="667" src="https://oscimg.oschina.net/oscnet/up-2e4d78299513d8dd8e48dd44f9f1c80cbea.png" width="500" referrerpolicy="no-referrer"></p><blockquote><p>Xiaomi Vela 是小米基於開源實時操作系統&nbsp;<strong><a href="https://www.oschina.net/p/nuttx">NuttX</a></strong>&nbsp;打造的物聯網嵌入式軟件平台，Vela 在各種物聯網硬件平台上提供統一的軟件服務，支持豐富的組件和易用的框架，打通碎片化的物聯網應用場景。</p></blockquote><p>隨 Xiaomi Vela 一同發佈的還有 Aiot-IDE，官方稱這是用於開發<strong> Xiaomi Vela 快應用</strong>的工具。據介紹，在小米智能穿戴 (Wearable) 設備上進行應用開發，此類應用統稱為 <strong>Xiaomi Vela 快應用</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8c26527175a6a981cbd609b6b5fa67209b5.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-642ef5598b7a4dfdf8d448948a0b32a4fbc.png" referrerpolicy="no-referrer"></p><p>官方稱 Aiot-IDE 基於 VS Code 進行開發，此外快應用的開發也類似網頁開發。感興趣可以下載安裝體驗：</p><ul><li><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fiot.mi.com%2Fvela%2Fquickapp%2Fzh%2Fcontent%2Fguide%2Fstart%2Fuse-ide.html" target="_blank">Aiot-IDE 下載地址</a></u>（該&nbsp;IDE 只支持在<code>Ubuntu 20.04</code>下進行 vela 項目的開發）</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 06:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266723</guid>
            <link>https://www.oschina.net/news/266723</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[BifroMQ-v2.0.0 版本重磅發佈：支持標準集羣模式（StandardCluster）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0px; margin-right:0px">2023 年 7 月，百度天工 AIoT 團隊正式開源高性能分佈式 MQTT 物聯網消息中間件，並將其全新命名為 BifroMQ。自 BifroMQ 首個版本發佈以來，獲得海量社區的廣泛關注，其中，BifroMQ 的集羣能力一直備受期待。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">通過近三個月的不懈努力，如今正式推出 BifroMQ-v2.0.0 版本，新版本首次支持集羣模式，我們將其稱為標準集羣 StandardCluster（以下簡稱 StandardCluster）。新版本主要有以下特性：</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">🌍 集羣模式全面支持 MQTT 協議：在集羣模式下，每個節點均具備完整的 MQTT 協議功能，提供更高的可用性和擴展性。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">🌍&nbsp;新增 HTTP API 支持：除 MQTT 外，本版本新增對 HTTP API 的支持，更加靈活多變。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">🚀 高性能不減：專注於在大規模負載環境下的高性能 MQTT 協議。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">🛠️ 模塊化架構進一步優化：適應各種業務需求的分佈式集羣管理。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">📊 強力可擴展性：目標支持大規模多租户的 Serverless 雲服務。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">詳情介紹，繼續閲讀</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span><strong>BifroMQ 的集羣架構解析</strong></span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3498db"><strong>▌StandardCluster 的整體結構</strong></span></p><p style="margin-left:0; margin-right:0">在過往介紹 BifroMQ 整體架構的文章（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbifromq.io%2Fzh-Hans%2Fblog%2Fbifromq-tech-architecture%2F" target="_blank">https://bifromq.io/zh-Hans/blog/bifromq-tech-architecture/</a>）中，曾提到 BifroMQ 將邏輯上的 MQTT 功能從負載的角度分解為若干子服務，每個子服務對應一類關鍵負載：</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3e3e3e">·bifromq-mqtt：負責 MQTT 協議連接負載</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3e3e3e">·bifromq-dist：負責訂閲和消息路由分發負載</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3e3e3e">·bifromq-inbox：負責持久會話中的離線消息隊列負載</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3e3e3e">·bifromq-retain：負責 Retain 消息存取負載</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">從部署的角度出發，BifroMQ StandardCluster 是將這些獨立負載的服務模塊"封裝"到一個節點服務進程的集羣模式，從邏輯上來説，此為 Standalone 運行模式的抽象（BifroMQ Standalone 可以看作是單個節點的 BifroMQ StandardCluster）。與其他支持集羣的 MQTT Broker 不同，BifroMQ 內置分佈式持久化功能，因此單個 BifroMQ 節點是"有狀態的"（Stateful）。</p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-6d871c8ad8353d28f90b010ef0e2e4b0a09.png" width="792" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:center">▲ 標準集羣的整體結構</p><p style="margin-left:0; margin-right:0; text-align:justify">注：本文所有插圖中括號內的﻿bifromq-xxx﻿，即為代碼中對應的模塊名稱</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3498db"><strong>▌消息分發能力的水平擴展</strong></span></p><p style="margin-left:0; margin-right:0">在 StandardCluster 集羣模式下，每個節點進程內的分發負載模塊（ 以下簡稱 Dist Service ）構成邏輯上的負載子集羣（Dist-SubCluster）。Dist Service 將訂閲信息存儲在內置的持久化引擎中，並通過持久化引擎的分佈式功能在節點之間同步路由信息。在 StandardCluster 模式下，通過增加節點的方式，即可以實現消息分發能力的水平擴展，特別是在 CleanSession 為 True 的情況下，這一點非常明顯，詳見官網測試報告。</p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-42840b4de22478548ca6934ee24df62ec21.png" width="792" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:center">▲ bifromq-dist 結構</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3498db"><strong>▌離線消息隊列的持久化、擴展性及高可靠性</strong></span></p><p style="margin-left:0; margin-right:0">與 Dist Service 模塊類似，節點進程內負責 MQTT 持久會話中離線消息隊列的 Inbox Service 模塊構成了另一個邏輯上的負載子集羣（以下簡稱 Inbox-SubCluster）。Inbox Service 將離線隊列消息持久化到內置的存儲引擎中，可以極大程度地減少因節點故障導致的數據丟失。在存儲方面，Inbox Service 利用內置存儲引擎的分片功能，在實現存儲規模和處理能力水平擴展的同時，通過靜態配置或運行時策略動態增加分片的副本數，可以進一步提高離線消息數據的可靠性，這對某些對數據可靠性要求更高的應用場景尤為重要。</p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-a071612e0fe715b733bad98bb4ca1353b8d.png" width="792" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:center">▲ bifromq-inbox 結構</p><p style="margin-left:0; margin-right:0; text-align:justify">注 1：由於增加分片副本數對 MQTT CleanSession 為 False 的消息負載有不可忽視的影響，需要根據實際需求確定資源投入以達到預期效果。因此，默認副本數為 1，該設置可以通過 JVM 啓動參數&nbsp;﻿inbox_store_range_voter_count﻿&nbsp;進行調整</p><p style="margin-left:0; margin-right:0; text-align:justify">注 2：Inbox Service 提供了離線消息隊列的全局訪問能力，因此 MQTT 客户端重新連接到任何集羣節點時都可以訪問所屬隊列中的離線消息，無需引入在其他 MQTT Broker 集羣實現中常見的 sticky session 或 session migration 方案</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3498db"><strong>▌</strong><strong>Inbox 服務的基於負載的拆分策略</strong></span></p><p style="margin-left:0; margin-right:0">如前文所述，在 StandardCluster 部署下，單個節點進程內的 Inbox Service 利用了內置存儲引擎的分片功能來實現存儲規模和處理能力的水平擴展。然而，分片策略對實際運行效果有着決定性的影響。在 BifroMQ StandardCluster 版本中，已內置開箱即用的基於負載的拆分策略（以下簡稱 Load-based Splitting）。該策略通過統計最近一段時間內的負載情況來決定對 KV Range 的劃分，可以視為一種"後驗"拆分策略。當使用場景已經對離線消息負載的分佈有提前規劃和了解時，提前劃分 Range 往往能在負載到來時帶來更穩定的性能表現，而對於深度使用 BifroMQ 的用户，可以通過 SPI 機制實現此類"先驗"拆分策略。</p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="600" src="https://oscimg.oschina.net/oscnet/up-46576e818cdeb9a1b9aafe883169c0428aa.png" width="400" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:center">▲inbox 服務拆分策略</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3498db"><strong>▌</strong><strong>HTTP API 模塊</strong></span></p><p style="margin-left:0; margin-right:0">BifroMQ StandardCluster 版本同時引入了 HTTP API 功能，每個集羣節點均可通過配置開放 API 訪問端口。BifroMQ HTTP API 作為無狀態的全局接口，旨在支持業務層面的管理控制邏輯集成，訪問任何一個節點的 API 都可以實現對整個集羣的操作，詳見官網 API 使用指南</p><p style="margin-left:0; margin-right:0; text-align:center"><img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-d65f5da4462a78d93bd53c50c1b80d118c8.png" width="792" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:center">▲HTTP API 模塊結構</p><p style="margin-left:0px; margin-right:0px; text-align:center">&nbsp;</p><p style="margin-left:0; margin-right:0"><span><strong>混合負載對性能的影響</strong></span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#3e3e3e">在 StandardCluster 部署下，單個節點具備完整的 MQTT 協議功能，承擔各種類型的負載。因此，這種模式非常適用於以下兩類企業級應用場景：</span></p><p style="margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#3e3e3e">·業務產生的負載類型相對單一</span></p><p style="margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#3e3e3e">·</span><span style="color:#3e3e3e">業務產生的負載類型多元化，但產生時間相對分散。對於負載形式複雜且在時間維度上有集中產生的情況，我們建議用户通過模擬負載測試來獲得單個 BifroMQ StandardCluster 集羣下的最佳資源配置和參數設置，或者考慮使用多個 BifroMQ StandardCluster 來承載不同類型的業務負載。另外，您還可以與我們聯繫，獲取 BifroMQ 商業版本的獨立負載集羣支持。</span></p><p style="margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="margin-left:0; margin-right:0"><span><strong>簡單部署和簡化運維</strong></span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">在以往 BifroMQ 技術架構文章中，曾提及 BifroMQ 集羣建立在一套內置的去中心化技術之上（base-cluster），無需依賴外部節點註冊和發現服務。因此，構建 BifroMQ StandardCluster 的部署過程非常簡單，只需指定任何一個集羣中的節點作為種子節點，即可完成新節點的加入。此外，BifroMQ 還內置了集羣分裂後的自愈能力，可以極大地簡化出現網絡分區（Network Partition）等故障時的運維操作。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span><strong>相關鏈接</strong></span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">·BifroMQ 官網（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbifromq.io%2F" target="_blank">https://bifromq.io/</a>）</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">·安裝包地址（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbaidu%2Fbifromq%2Freleases%2Ftag%2Fv2.0.0" target="_blank">https://github.com/baidu/bifromq/releases/tag/v2.0.0</a>）</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">·部署指南（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbifromq.io%2Fzh-Hans%2Fdocs%2F2.0.0%2Fdeploy%2Fcluster%2F" target="_blank">https://bifromq.io/zh-Hans/docs/2.0.0/deploy/cluster/</a>）</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span><strong>未來展望</strong></span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">BifroMQ 團隊一直秉持技術中立理念，致力於大規模實現 MQTT 協議，從而提高可靠性和可維護性。我們期待更多社區參與和深入使用反饋，共同推動這一技術的成熟。此外，您還可以通過掃描下方二維碼加入開發者交流社區，與廣大同行進行交流學習。</p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="250" src="https://oscimg.oschina.net/oscnet/up-87a63b79b2a9bc4215a5e13869541f206e1.png" width="450" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 04:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266713</guid>
            <link>https://www.oschina.net/news/266713</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[開源中國將在年末推出大模型託管平台，大量人才招募中]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">Gitee 正在招募大量人才，歡迎加入。</span></span></p><p><img alt="" height="1348" src="https://static.oschina.net/uploads/space/2023/1116/151453_9FSP_3820517.jpg" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">開源中國於 2023 年 6 月完成了&nbsp;</span><strong><span style="background-color:#ffffff">7.75 億元&nbsp;</span></strong></span><span style="color:#000000">B+ 輪戰略融資</span><span style="color:#000000">，公司創始團隊重新成為實際控制人，經此股份重組企業成為完全中立平台。目前，開源中國員工共計 300 餘人，其中研發團隊佔比 85% 以上。</span></p><p><span style="color:#000000"><strong><span style="background-color:#ffffff">開源中國將在年末推出大模型託管平台</span></strong><span style="background-color:#ffffff">，在 AI 時代為廣大開發者和企業提供更高質量的服務。從軟件應用到 AI 時代，開源中國將堅持幫助國內開發者和企業共同發展，創造健康的生態環境。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Gitee 是開源中國旗下，國內第一大企業級研發效能平台和全球第二大開源代碼託管平台。經過 10 年發展，Gitee 已經擁有超過 1100 萬開發者，託管超過 2500 萬個代碼倉庫，服務 26 萬家企業（含 1200 家中大型私有化部署企業）和 2000 多所高校，為他們提供優質的 DevOps 產品服務。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 03:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266707/gitee-hiring</guid>
            <link>https://www.oschina.net/news/266707/gitee-hiring</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[金山辦公 WPS AI 開啓公測]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>金山辦公<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FcSKhX3tqmZgdw7EfTid_TA" target="_blank">宣佈</a>旗下只能辦公助手 WPS AI 開啓公測，即日起面向全體用户陸續開放體驗。WPS AI 是一款生成式人工智能應用，具備了大語言模型能力。它提供起草、改寫、總結、潤色等功能，可以提高辦公創作效率。</p><p>用户可前往 <strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fai.wps.cn%2F" target="_blank">WPS AI 官網</a></strong>申請權益，並下載最新版 WPS PC 客户端限時體驗文字/智能文檔、表格/智能表格、PPT 演示組件的 AI 能力，安卓、iOS 和 Mac 端預計將於 11 月底陸續開放。</p><p><img alt="" height="376" src="https://oscimg.oschina.net/oscnet/up-9b4717aaa45d58081e02785ba28fc5dda23.png" width="300" referrerpolicy="no-referrer"></p><p><img alt="" height="354" src="https://oscimg.oschina.net/oscnet/up-fa29542a7d817329492fdc62024e16f7025.png" width="300" referrerpolicy="no-referrer"></p><p><img alt="" height="379" src="https://oscimg.oschina.net/oscnet/up-f98e75322933cd6c5d3e5239be36401148e.png" width="300" referrerpolicy="no-referrer"></p><p>更多詳細功能介紹可查看 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhome.wps.cn%2Ftopic%2F10254" target="_blank">WPS AI 能力介紹（11 月最新版）</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 03:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266706</guid>
            <link>https://www.oschina.net/news/266706</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微軟將 Bing Chat 更名為 Copilot in Bing]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">在 Ignite 2023 大會上，微軟宣佈將今年早些時候在 Bing 上推出的 AI 聊天機器人 Bing Chat 更名為 Copilot in Bing。與此同時，Bing Chat 的高端企業版（之前稱為 Bing Chat Enterprise）也已更名為 Copilot。</span></p><p><span style="color:#000000">目前該公司現在約有十幾種產品共享 Copilot 品牌，微軟方面表示，此次改名並不是為了造成混淆。其通信總監 Caitlin Roulston 解釋稱，「將 Bing Chat Enterprise 更名為 Copilot 反映了我們為消費者和商業客户打造統一的 Copilot 體驗的願景。」</span></p><p><span style="color:#000000">科技媒體 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2023%2F11%2F15%2Fbing-chat-is-now-copilot%2F" target="_blank">TechCrunch</a> 認為，雖然 Roulston 的言論有一定的道理。但也不排除是因為 Bing Chat 並沒有給 Bing 帶來多大的推動，所以微軟希望將這項技術與推出它的搜索引擎剝離開來的原因。StatCounter 8 月份的一份報告指出，在 Bing Chat 推出六個月後，Bing 未能從 Google 手中奪取任何市場份額；不過微軟方面對這一調查結果提出異議。</span></p><p><img height="279" src="https://oscimg.oschina.net/oscnet/up-3a23b972d5c87805c49dd110d3b0bb06145.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">除了改名之外，從 12 月 1 日起，使用企業賬户（準確地説，是 Microsoft Entra ID）登錄 Bing 的用户在 Bing 中使用 Copilot 時，將享受"商業數據保護"的好處。Roulston 稱，這意味着用户的數據不會被保存、不會被用於訓練人工智能模型，且微軟也無法訪問這些數據。</span></p><p><span style="color:#000000">「Copilot 將於 12 月 1 日更新商業條款和條件，以反映它是微軟的通用產品。作為其中的一部分，它將繼承微軟在線服務的通用許可條款……隨着時間的推移，微軟將免費向更多的 Entra ID 用户提供具有商業數據保護功能的 Copilot。」</span></p><p><span style="color:#000000">除了 Copilot.Microsoft.com 和 Bing 之外，現在還可以在 Windows 中訪問 Copilot，並在 Microsoft 的一系列企業訂閲計劃（Microsoft 365 E、E5、Business Premium 和 Business Standard）中提供，無需額外付費。Copilot 將從 12 月 1 日起包含在 Microsoft 365 F3 中。對於所有其他客户，它將以每月 5 美元的價格提供服務。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 03:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266700/bing-chat-rename-copilot</guid>
            <link>https://www.oschina.net/news/266700/bing-chat-rename-copilot</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[阿里雲 11.12 故障原因曝光：訪問密鑰服務 (Access Key) 異常]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>針對阿里雲 11.12 的重大服務故障， 該公司發給客户的一份「官方故障報告」昨天在網上被廣泛流傳。</span></p><blockquote><p><span>事件回顧：</span><u><a href="https://www.oschina.net/news/266144">阿里雲嚴重故障，全線產品受影響（已恢復）</a></u></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-12e038da50562b9fb7806fac53534a272ac.png" referrerpolicy="no-referrer"></p><hr><p style="margin-left:0; margin-right:0"><strong><span>影響範圍</span></strong></p><p><span style="color:#021eaa"><strong><span style="color:#021eaa">1、OSS、OTS、SLS、MNS 等產品的部分服務受到影響，大部分產品如 ECS、RDS、網絡等運行不受影響。</span></strong></span></p><p><span style="color:#0052ff"><strong><span>2、雲產品控制枱、管控 API 等功能受到影響。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span>時間</span></strong></p><p><span style="color:#0052ff"><strong><span>2023 年 11 月 12 日 17:39～19.20，</span></strong></span><span style="color:#021eaa"><strong><span>故障時間為 1 小時 41 分。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span style="color:rgba(0, 0, 0, 0.9)">問題概況</span></strong></p><p><span style="color:#0052ff"><strong><span>2023 年 11 月 12 日 17:39 起，阿里云云產品控制枱訪問及管控 API 調用出現異常、部分雲產品服務訪問異常，工程師排查故障原因與訪問密鑰服務 (AK) 異常有關。工程師修訂白名單版本後，採取分批重啓 AK 服務的措施，於 18:35 開始陸續恢復，19:20 絕大部分 Region 產品控制枱和管控 API 恢復。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span style="color:rgba(0, 0, 0, 0.9)">處理過程</span></strong></p><p><span>17:39：阿里云云產品控制枱訪問及管控 API 調用出現異常。</span></p><p><span>17:50：工程師確認故障是 AK 服務異常導致，影響雲產品控制枱、管控 API 調<span>用異常，以及依賴 AK 服務的雲產品服務運行異常。</span></span></p><p><span>18:01：工程師定位到根因。</span></p><p><span>18:07：開始執行恢復措施，包括修訂白名單版本、重啓 AK 服務。</span></p><p><span>18:35：杭州等 Region 開始恢復正常。</span></p><p><span>19:20：絕大部分 Region 的雲產品控制枱和管控 API 調用恢復正常。</span></p><p style="margin-left:0; margin-right:0"><strong><span>原因</span></strong></p><p><span style="color:#021eaa"><strong><span>訪問密鑰服務 (AK）在讀取白名單數據時出現讀取異常，因處理讀取異常的代碼存在邏輯缺陷，生成了一份不完整白名單，導致不在此白名單中的有效請求失敗，影響雲產品控制枱及管控 API 服務出現異常，同時部分依賴 AK 服務的產品因不完整的白名單出現部分服務運行異常。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span>改進措施</span></strong></p><p><span>1、增加 AK 服務白名單生成結果的校驗及告警攔截能力。</span></p><p><span>2、增加 AK 服務白名單更新的灰度驗證邏輯，提前發現異常。</span></p><p><span>3、增加 AK 服務白名單的快速恢復能力。</span></p><p><span>4、加強雲產品側的聯動恢復能力。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 03:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266694</guid>
            <link>https://www.oschina.net/news/266694</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
