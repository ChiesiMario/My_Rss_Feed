<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 02 Nov 2023 02:47:13 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[蘋果 M3 芯片首個 Geekbench 跑分出爐]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>iMac 2023 已經出現在了 Geekbench 上。這款 iMac 搭載了 <strong>4.05 GHz 的基礎版 M3 芯片</strong>，配備 16GB 內存，運行 macOS 14.1，單核最高 3076 分，多核 11863 分。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-966efdd0f8e637293209051e4e7778eb47d.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9e898b0752bd8dd21c976fd8a07c2fa8397.png" referrerpolicy="no-referrer"></p><p>作為對比，目前 Geekbench 中收錄的 Mac 單核最高分為 Mac Studio (2023) 的 2803 分（M2 Max），多核為 21316 分（M2 Ultra）。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d660971c507ccf85d086bf70470a9bad4be.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-c8c00a499453f65a78223339cd941c947bd.png" referrerpolicy="no-referrer"></p><p><strong>相關閲讀：<u><a href="https://www.oschina.net/news/264233/apple-m3-silicon">蘋果發佈 M3 系列芯片，採用 3nm 工藝、支持「動態緩存」技術</a></u></strong></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 02:44:10 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264561</guid>
            <link>https://www.oschina.net/news/264561</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Sermant 1.2.0 release 版本新特性速覽]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>本文分享自華為雲社區《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%2F413986%3Futm_source%3Doschina%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent" target="_blank" rel="nofollow">重磅更新！Sermant 1.2.0 release 版本新特性速覽</a>》，作者：華為雲開源。</p><p>10 月，Sermant 社區正式發佈了 1.2.0 release 版本，距離上一次的大版本發佈僅三個月。本次新版本帶來了多個令人興奮的新特性，主要包含 Sermant Agent 框架能力的優化和提升以及新增了流量標籤透傳插件，將極大地提升用户和開發者的體驗，幫助大家將 Sermant 運用到更多的流量治理場景中。</p><p><strong>（Sermant 官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsermant.io%2Fzh" rel="nofollow" target="_blank">https://sermant.io/zh</a>）</strong></p><span id="OSC_h1_1"></span><h1>一、Sermant Agent 框架能力提升</h1><p>1.2.0 release 版本中，對諸多能力進行了優化或新增，包括支持 Sermant Agent 框架和插件的動態安裝和動態卸載、支持動態配置服務對接 Nacos 配置中心、更好的類隔離能力、JDK11 和 JDK17 的兼容等。在框架加持這些新版本特性後，可以使 Sermant 的開發和體驗更加友好，同時也拓展出更多的 Sermant 的使用場景。</p><span id="OSC_h2_2"></span><h2>1.1 Sermant Agent 框架以及插件的動態安裝/卸載</h2><p>新版本中，Sermant 將原本默認的通過 premain 來啓動 Sermant Agent 的方式改進為支持 premain 和 agentmain 兩種方式啓動，其中 premain 方式與此前版本使用方式一致。</p><p>新增的 agentmain 啓動方式是為了支持 Agent 和插件的熱部署方式，premain 方式需要在應用程序啓動時掛載 Agent，而 agentmain 可以在應用程序運行時進行動態掛載 Agent，也可以在運行時動態地卸載 Sermant，在故障注入等需要動態進行字節碼增強的場景中起到非常重要的作用。動態安裝/卸載插件和動態安裝/卸載 Agent 一樣，用於服務治理場景中需要在應用運行時動態添加或移除額外功能的場景，例如在故障注入場景中通過動態地掛載不同的插件來實現注入不同的故障類型。</p><p>下圖為 Sermant 的熱插拔能力的示意圖，在初始狀態可以通過動態掛載 Agent 的能力安裝字節碼增強框架，然後可以通過動態掛載/卸載插件的能力在運行態增減所需服務治理能力，也可以直接將整個 Agent 進行卸載。</p><p><img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtybbs/519/984/817/2850086000519984817.20231031112130.66449741674660850648477742923963:50001231000000:2800:783EB78C84A7C56ED6FB79C911AC306EA74080AB3A7A46A4A78325B413B6FE03.png" referrerpolicy="no-referrer">​</p><p>圖 - Sermant Agent 框架和插件的熱插拔示意圖</p><p>此項關鍵能力的更新使得 Sermant 的部署形態更加多樣，適用場景更加廣泛，使用者不再僅限於在啓動時再掛載 Sermant，業務可以實現不停機注入服務治理能力。</p><span id="OSC_h2_3"></span><h2>1.2 支持動態配置服務對接 Nacos 配置中心</h2><p>動態配置中心為 Sermant 動態配置服務的配套組件，動態配置服務允許 Sermant 從動態配置中心拉取配置以實現豐富多樣的服務治理能力。以往版本 Sermant 的支持的動態配置中心有 Zookeeper 和 Kie，新版本適配了 nacos 的數據模型，支持從 nacos 下發配置並監聽。</p><ul><li><strong>Sermant 動態配置模型基於 Nacos 配置中心的實現方式</strong></li></ul><p>Nacos 自身的數據模型如下，通過 Namespace、Group、Date ID 能夠定位到一個配置集：</p><p><img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtybbs/519/984/817/2850086000519984817.20231031112130.94919115110128519717355386037211:50001231000000:2800:725C15EDC238B97EACFA43F52C6D7093EE90C97A369EC8463EDE953F752968A9.png" referrerpolicy="no-referrer">​</p><p>圖 - Nacos 數據模型</p><p><strong>Sermant 動態配置的 Group（分組信息）：</strong>將 Nacos 的 Namespace（命名空間）和配置分組（Group）組合起來作為 Sermant 的動態配置模型的分組信息。</p><p><strong>Sermant 動態配置的 Key（配置項名稱）：<span>&nbsp;</span></strong>Nacos 的配置集 ID（Data Id）作為 Sermant 的動態配置模型的配置項名稱。</p><p>配置集（Data Id）可以通過不同的 Namespace（命名空間）和配置分組（Group）進行隔離，不同的 Namespace（命名空間）和配置分組（Group）下可以存在名稱相同的配置集（Data Id）。保證 Sermant 通過不同的 Group（分組信息）來對配置項進行隔離，同一個 Group（分組信息）下可以有相同 Key（配置項名稱）。</p><ul><li><strong>使用 Nacos 作為 Sermant 的動態配置中心</strong></li></ul><p>將 Sermant 1.2.0 release 包中的/agent/config/config.properties 配置文件中的相關配置修改如下，即可使用 Nacos 作為動態配置中心：</p><ol><li># 指定配置中心的服務端地址，修改為 nacos 的地址</li><li>dynamic.config.serverAddress=127.0.0.1:8848</li><li># 指定動態配置中心類型, 取值範圍為 NOP(無實現)、ZOOKEEPER、KIE、NACOS</li><li>dynamic.config.dynamicConfigType= NACOS</li></ol><p>Sermant 中動態配置的模型和接口是統一抽象的，開發者對於動態配置節點的監聽器的開發與此前版本保持一致。動態配置中心在 Sermant 中的角色和作用可以閲讀相關博客《如何利用動態配置中心在 JavaAgent 中實現微服務的多樣化治理》。</p><span id="OSC_h2_4"></span><h2>1.3 更好的類隔離能力</h2><p>Sermant 在 1.2.0 版本中對此前的類隔離框架和機製做了全面的優化，不僅保證了不向宿主服務引入類衝突問題，避免在開箱即用時對宿主服務造成負面影響，同時也了保障框架與插件、插件與插件之間不會引入類衝突問題，避免插件開發者因為和其他服務治理插件產生類衝突問題而苦惱。</p><ul><li><strong>新版本的類隔離結構</strong></li></ul><p><img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtybbs/519/984/817/2850086000519984817.20231031112130.03262753633836709743319426991113:50001231000000:2800:7C7B04FC8522592AC3F6A4DDB2EDA768041F21831F8DE3C3577F22A6B32D27F3.png" referrerpolicy="no-referrer">​</p><p>圖 – Sermant 的類隔離結構</p><ul><li>SermantClassLoader，破壞雙親委派，用於加載 Sermant 框架核心邏輯，並在 AppClassLoader 下隔離出 Sermant 的類加載模型。避免受到宿主服務自身複雜類加載結構的影響，減少應對不同類加載結構服務的適配需求。</li><li>FrameworkClassLoader，破壞雙親委派，主要作用是隔離 Sermant 核心能力所引入的三方依賴，避免向宿主服務及服務治理插件引入類衝突問題。目前的主要場景 ①用於隔離 Sermant 的日誌系統，避免對宿主服務的日誌系統產生影響 ②隔離 Sermant 框架的核心服務（心跳、動態配置、統一消息網關）所需三方依賴。</li><li>PluginClassLoader，遵循雙親委派，主要用於隔離 Sermant 各服務治理插件，避免不同服務治理插件之間產生類衝突問題。</li><li>ServiceClassLoader，破壞雙親委派，主要用於隔離插件中的依賴，通過該類加載器加載插件服務的相關 lib（插件服務會在插件加載時被 Sermant 初始化），開發者可任意引入三方依賴，無需關心對插件主邏輯的影響。</li></ul><p>其中的 PluginClassloader 和 ServiceClassloader 不僅在類隔離中起到至關重要的作用，更是一種長遠的考慮，為每個插件設計獨立的類加載器，使得 Sermant 可以平滑的進行插件動態安裝&amp;卸載以及插件熱更新。更詳細的類隔離機制的介紹可以參閲相關博客《Sermant 類隔離架構解析——解決 JavaAgent 場景類衝突的實踐》。</p><span id="OSC_h1_5"></span><h1>二、插件能力提升</h1><span id="OSC_h2_6"></span><h2>2.1 流量標籤透能力</h2><p>在微服務架構中，流量標籤用於對流量進行標記和分類，能夠在微服務之間實現更精細的路由、負載均衡和流控等流量治理能力。Sermant 新版本插件部分本次主要新增了流量標籤透傳插件。該插件着手於解決流量標籤在各種不同傳媒介中 (通信協議、進程內外) 進行透傳的問題，基於此能力可以實現全鏈路灰度發佈、基於流量標籤的流量控制等高階服務治理功能。</p><ul><li><strong>流量標籤透傳插件簡介</strong></li></ul><p>Sermant 對於流量標籤透傳分為兩大類：跨進程透傳和進程內透傳。跨進程透傳是指在不同的服務實例進程中傳遞流量標記，例如 http 請求的客户端和服務端。進程內透傳是指在一個服務實例的進程內傳遞流量標籤，包括線程內傳遞和跨線程傳遞。</p><p><img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtybbs/519/984/817/2850086000519984817.20231031112130.59757034719402065622390169640105:50001231000000:2800:76293BD5EDF4982F53CC195AC06C0B4057E47E5C52E020D17E8B91FD98E2F2BC.png" referrerpolicy="no-referrer">​圖 – Sermant 中 http/rpc 請求的標籤透傳過程</p><p><img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtybbs/519/984/817/2850086000519984817.20231031112130.96749315765046642733872549374631:50001231000000:2800:ABB2456FD592DE4549BD6EF19232F17C017B9CC36132B4CB581F22FE398BD5B6.png" referrerpolicy="no-referrer">​</p><p>圖 – Sermant 中消息隊列的標籤透傳過程</p><p>新版本發佈的流量標籤透插件實現了上述兩類標籤的透傳，並且支持了 http 協議、rpc 協議、消息隊列中間件，目前支持的組件包括 Apache HttpClient、OKHttp、Dubbo、GRPC、Kafka 等。</p><ul><li><strong>流量標籤透傳插件使用方式</strong></li></ul><p>該插件的使用支持靜態配置和動態配置，只需將需要透傳的流量標籤做好配置，標籤即可在全鏈路中進行透傳，具體使用方式可參考官網使用文檔。</p><p>流量標籤透傳作為 JavaAgent 中進行流量治理的基礎能力，可以將其運用在全鏈路灰度發佈、標籤流控等複雜的流量治理場景，相關介紹可以參閲相關博客<span style="background-color:#ffffff; color:#333333">《</span><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%2F411848" rel="nofollow" target="_blank">流量治理的基石——基於字節碼增強的全鏈路流量標籤透傳》</a></u></p><span id="OSC_h1_7"></span><h1>三、總結</h1><p>本次更新主要帶來了 Sermant Agent 框架和插件的動態掛載/卸載的支持、動態配置服務對 nacos 的支持、類隔離機制的優化以及流量標籤透傳能力的支持等。基於上述能力，Sermant 可以在諸如故障注入、流量治理、動態配置等服務治理的場景發揮更關鍵的作用。</p><span id="OSC_h1_8"></span><h1>結束語</h1><p>Sermant 作為專注於服務治理領域的字節碼增強框架，致力於提供高性能、可擴展、易接入、功能豐富的服務治理體驗，並會在每個版本中做好性能、功能、體驗的看護，廣泛歡迎大家的加入。</p><ul><li>Sermant 官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsermant.io%2Fzh" rel="nofollow" target="_blank">https://sermant.io/zh</a></li><li>GitHub 倉庫地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fhuaweicloud%2FSermant" rel="nofollow" target="_blank">https://github.com/huaweicloud/Sermant</a></li></ul><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%3Futm_source%3Doschina%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent" rel="nofollow" target="_blank"><strong>點擊關注，第一時間瞭解華為雲新鮮技術~</strong></a></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 02:28:10 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4526289/blog/10140232</guid>
            <link>https://my.oschina.net/u/4526289/blog/10140232</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[何為「玲瓏」，它從哪裏來又要到哪裏去？| 帶你一文揭秘]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>2020 年，借鑑沙箱/容器的技術方案，玲瓏原型的核心開發悄然完成；</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>2022 年，作為 deepin 發行版未來的核心特性，玲瓏隨 deepin v23 預覽版共同發佈，初步具備可用性；</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>2023 年，我們將玲瓏項目代碼、玲瓏官網、玲瓏商店等資產捐贈給開放原子開源基金會，欲匯聚更多產業力量，攜手推動玲瓏發展，加速生態建設......</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>那麼到底何為「玲瓏」？它從哪裏來？又要到哪裏去？接下來，此文為你一一揭秘。</span></p><h2><span>前言：軟件包管理器的演進</span></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>Linux 操作系統一直以其開源性質和靈活性而聞名，而要使 Linux 系統能夠順利安裝並運行所需的軟件，最關鍵的部分就是軟件包管理器。&nbsp;</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>顧名思義，Linux 軟件包管理器是一種在 Linux 操作系統上用於安裝、更新和卸載軟件包的工具。它的歷史可以追溯到上世紀 90 年代，此時 Linux 正處於起步階段，軟件的安裝必須手動下載源代碼並編譯，這對非技術用户來説是一項繁瑣且困難的任務。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>這種情況下，先後催生了 dpkg 和 rpm，然而由於不能自動解決依賴關係，其使用起來依舊不便。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>直到 Debian 的 apt、Red Hat 的 up2date 的發佈，包管理器可用性有了很大的提升。它們採用了一種被稱為「依賴關係解決器」的算法，能夠自動解決軟件包之間的依賴關係，從而簡化軟件的安裝和升級過程。但這在另一方面大大增加了複雜度，維護者們需要非常謹慎小心地處理，稍有不慎就會陷入「依賴地獄」，導致軟件包系統發生故障。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>此外，還有許多其他的軟件包管理器，如 yum、portage 和 pacman 等。包管理器的多樣性給用户帶來了更多選擇，但缺點也十分顯著：它們的軟件包無法互通，這意味着一款軟件要在其他發行版上使用，可能需要被重複打包。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>隨着 Linux 內核對容器的支持、Docker 的誕生，Snap、Flatpak 等一批容器思想的包管理器也開始嶄露頭角。這類格式的軟件包與系統環境幾乎完全解耦，不再依賴系統上的庫文件（AppImage 也是如此），應用分發開始逐步變得簡單起來。但磁盤、內存佔用較高，啓動時間被不斷延長等問題也隨之而來，至今仍未被解決。</span></p><h2><span>探索：「玲瓏」應運而生</span></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>deepin 自 2015 年放棄基於 Ubuntu 作為上游，選擇 Ubuntu 的非商業上游社區 Debian 作為研發的基礎起，我們便收到了眾多用户關於軟件包管理上的問題反饋，常見的有：</span></p><ul><li><span>系統上能用的應用太少，可用的應用版本太老；</span></li><li><span>系統更新後，某些應用無法正常使用；</span></li><li><span>從其他來源獲取某些應用軟件安裝後，包管理器無法正常工作，甚至系統無法繼續使用。</span></li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>以上這些問題有一個共性原因：<strong>依賴關係綁定太強。</strong>因系統底層庫的關係，應用無法隨意更新，在底層庫有接口變動時，應用需要重新適配才能正常工作。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>在意識到這些問題後，我們開始嘗試使用新的軟件包管理器。</span></p><ul><li><span>在 deepin 上適配 Snap：由於 Snap 在除 Ubuntu 系統環境外有諸多兼容性問題，遂放棄。</span></li><li><span>將部分自研應用轉化為 AppImage：AppImage 有着不錯的可移植性，這些應用可以很輕鬆地在其他發行版上使用。但它沒有集中的倉庫存儲和軟件包管理功能，也不提供 Snap、Flatpak 同一級別的沙箱，安全性無法保障，不適合作為操作系統的默認軟件包管理方式。</span></li><li><span>2017 年，deepin 對 Flatpak 格式進行了跟進，完成了 100+ 的軟件包構建工作，後因其應用體積較大，磁盤佔用過多、Bug 修復緩慢等各種原因沒有繼續適配。&nbsp;</span></li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>在經歷過種種「折騰」後，基於對各類包管理器的瞭解，我們決定自己設計一套軟件包管理系統。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>在經過 3 個多月的技術調研，1 年多的原型驗證、技術方案完善和產品打磨後，<strong>最終一套先進的解決方案——「玲瓏」應運而生。</strong></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><img alt="" height="500" src="https://www.deepin.org/wp-content/uploads/2023/08/1-1-300x192.png" width="782" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span>頂層組件關係圖</span></p><ul><li><span>應用沙箱 (ll-box) ：按照 OCI 標準設計的應用沙箱運行環境，利用內核 Cgroup、Namespace 特性將應用與宿主機環境隔離，限制系統資源的使用。</span></li><li><span>應用管理服務 (ll-service/ll-cli) ：提供應用沙箱環境創建，系統兼容性問題處理等功能。完成對應用的安裝狀態/運行狀態管理。</span></li><li><span>權限管理代理服務 (ll-dbus-proxy/ll-fuse-proxy) ：提供權限管理功能，包括 DBus 接口以及文件接口。</span></li><li><span>應用構建工具（ll-builder）：提供容器化的應用構建環境，方便開發者在不同的環境上構建出一致性的應用。</span></li><li><span>單獨打包格式（uab/AppBundle）：Uniontech Application Bundle，應用包封裝格式，提供可直接運行的二進制包格式。</span></li><li><span>倉庫系統（ll-repo-server）：提供包上傳、下載、信息統計、查詢等功能，底層存儲使用 OSTree。</span></li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span><img alt="" height="409" src="https://www.deepin.org/wp-content/uploads/2023/08/2-300x172.png" width="713" referrerpolicy="no-referrer"></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span>運行視圖</span></p><h2><span>成果：解決兼容性問題、性能大幅提升</span></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>此前，國內軟件生態建設尚不成熟，軟件兼容性、安全性問題頻出，在面向不同的操作系統進行應用打包和分發時，會額外耗費大量的時間和資源。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>而玲瓏的出現，無疑為解決這一難題提供了新思路。玲瓏的隔離技術可以將應用與系統進行完全解耦，從而徹底解決系統與應用、應用與應用之間因升級引起的兼容性問題 ，同時減少不同操作系統下分發時的打包次數。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span><img alt="" height="418" src="https://www.deepin.org/wp-content/uploads/2023/08/3-300x133.png" width="943" referrerpolicy="no-referrer"></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span>傳統架構 Vs 玲瓏架構</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>當前，玲瓏的基礎設施已較為完善，衍生出了 5 個項目，共 9 個組件。</span></p><ol><li><img alt="" height="447" src="https://www.deepin.org/wp-content/uploads/2023/08/4-300x145.png" width="925" referrerpolicy="no-referrer"></li></ol><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span>項目組件概述</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">&nbsp;</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>相比其他類似軟件包格式，玲瓏在啓動速度、資源佔用方面具有許多優勢：</span></p><ul><li><span>使用非全量運行時（宿主系統+Runtime），整體體積較小；</span></li><li><span>由於複用宿主系統上的庫，可以使用到部分已經加載到內存中的庫文件，啓動速度會更快，同一應用在玲瓏下啓動速度提升顯著；</span></li><li><span>提供開發庫託管服務，類似 NuGet，方便開發者進行開發；</span></li><li><span>支持 Rootless（無特權）沙箱。</span></li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span><img alt="" height="348" src="https://www.deepin.org/wp-content/uploads/2023/08/5-300x108.png" width="967" referrerpolicy="no-referrer"></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span>軟件包大小統計</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span><img alt="" height="555" src="https://www.deepin.org/wp-content/uploads/2023/08/6-300x214.png" width="778" referrerpolicy="no-referrer"></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span>軟件包啓動耗時統計</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>在最新版本 deepin v23 上，已預裝十多款左右玲瓏格式自研應用。玲瓏網頁商店內，常用應用已上架 120 餘款，如 QQ、微信、網易雲音樂、迅雷等，累計下載量當前已達 40w+。</span></p><h2><span>未來：助力操作系統軟件包生態健康發展</span></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>未來，我們將從權限管控、用户交互及可用軟件數量等方面着手，對玲瓏進行進一步加強優化。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>1、權限管控</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>當前玲瓏文件訪問文件的權限較為單一，只能在應用啓動前處理目錄的掛載，未掛載的目錄無法被啓動後的應用訪問到。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>未來將會支持文件訪問權限的動態管控，無論應用啓動與否均可管理，同時控制中心會同步適配玲瓏的權限管控，提供應用權限管理界面。&nbsp;</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>2、用户交互</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>目前玲瓏應用的更新需要用户手動命令行更新，需要一定的 Linux 基礎。且當軟件包出現問題時，無法直接查詢到構建源頭的信息，如 git 項目的 hash 值。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>未來，應用商店將支持玲瓏應用更新。同時支持溯源，對開發者來説能快速查詢到軟件包使用的源文件 hash 值，更容易追蹤和解決問題。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>3、軟件包生態</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>生態建設需要大家共同發力，我們目前已在着手開發相關軟件包轉換工具，可以將現有的 deb、appimage 等格式軟件包輕鬆地轉換成玲瓏應用。同時也在推動已有合作軟件廠商對玲瓏的適配。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>與其踽踽獨行，不如結伴而行，生態建設需要大家共同努力。此前，deepin 開源社區已和北京航空航天大學開展暑期共建開源生態合作，已有眾多北航學子參與到生態共建中來。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span>我們衷心希望玲瓏能夠解決多發行版應用分發困難的問題，同時也期待更多的感興趣的朋友加入我們，共建應用分發體系，為操作系統軟件生態健康發展貢獻力量。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 02:27:10 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264558</guid>
            <link>https://www.oschina.net/news/264558</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vLLM —— 快速易用的 LLM 推理和服務庫]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>vLLM 是一個快速且易於使用的 LLM 推理和服務庫。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>vLLM 的速度很快：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>最先進的服務吞吐量</li><li><strong>使用 PagedAttention&nbsp;</strong>高效管理 <span style="background-color:#ffffff; color:#1f2328">attention key 和 value memory</span></li><li>連續批處理傳入請求</li><li>優化的 CUDA 內核</li></ul><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>vLLM 靈活且易於使用：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>與流行的 Hugging Face 模型無縫集成</li><li>高吞吐量服務與各種解碼算法，包括<em>並行採樣</em>、<em>波束搜索</em>等</li><li>對分佈式推理的張量並行支持</li><li>流輸出</li><li>兼容 OpenAI 的 API 服務器</li></ul><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>vLLM 無縫支持許多 Hugging Face 模型，包括以下架構：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>Aquila &amp; Aquila2 (<code>BAAI/AquilaChat2-7B</code>,<span>&nbsp;</span><code>BAAI/AquilaChat2-34B</code>,<span>&nbsp;</span><code>BAAI/Aquila-7B</code>,<span>&nbsp;</span><code>BAAI/AquilaChat-7B</code>, etc.)</li><li>Baichuan (<code>baichuan-inc/Baichuan-7B</code>,<span>&nbsp;</span><code>baichuan-inc/Baichuan-13B-Chat</code>, etc.)</li><li>BLOOM (<code>bigscience/bloom</code>,<span>&nbsp;</span><code>bigscience/bloomz</code>, etc.)</li><li>Falcon (<code>tiiuae/falcon-7b</code>,<span>&nbsp;</span><code>tiiuae/falcon-40b</code>,<span>&nbsp;</span><code>tiiuae/falcon-rw-7b</code>, etc.)</li><li>GPT-2 (<code>gpt2</code>,<span>&nbsp;</span><code>gpt2-xl</code>, etc.)</li><li>GPT BigCode (<code>bigcode/starcoder</code>,<span>&nbsp;</span><code>bigcode/gpt_bigcode-santacoder</code>, etc.)</li><li>GPT-J (<code>EleutherAI/gpt-j-6b</code>,<span>&nbsp;</span><code>nomic-ai/gpt4all-j</code>, etc.)</li><li>GPT-NeoX (<code>EleutherAI/gpt-neox-20b</code>,<span>&nbsp;</span><code>databricks/dolly-v2-12b</code>,<span>&nbsp;</span><code>stabilityai/stablelm-tuned-alpha-7b</code>, etc.)</li><li>InternLM (<code>internlm/internlm-7b</code>,<span>&nbsp;</span><code>internlm/internlm-chat-7b</code>, etc.)</li><li>LLaMA &amp; LLaMA-2 (<code>meta-llama/Llama-2-70b-hf</code>,<span>&nbsp;</span><code>lmsys/vicuna-13b-v1.3</code>,<span>&nbsp;</span><code>young-geng/koala</code>,<span>&nbsp;</span><code>openlm-research/open_llama_13b</code>, etc.)</li><li>Mistral (<code>mistralai/Mistral-7B-v0.1</code>,<span>&nbsp;</span><code>mistralai/Mistral-7B-Instruct-v0.1</code>, etc.)</li><li>MPT (<code>mosaicml/mpt-7b</code>,<span>&nbsp;</span><code>mosaicml/mpt-30b</code>, etc.)</li><li>OPT (<code>facebook/opt-66b</code>,<span>&nbsp;</span><code>facebook/opt-iml-max-30b</code>, etc.)</li><li>Qwen (<code>Qwen/Qwen-7B</code>,<span>&nbsp;</span><code>Qwen/Qwen-7B-Chat</code>, etc.)</li></ul></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 02:25:10 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/vllm</guid>
            <link>https://www.oschina.net/p/vllm</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 跨平台迷你計算視覺庫 YMCV]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-ymcv 簡介" class="anchor" href="https://gitee.com/yao_mi/ymcv#ymcv%E7%AE%80%E4%BB%8B"></a>YMCV 簡介</h1><p>庫名中文簡稱 <strong>妖米 CV</strong>，英文全稱 <strong>your mini computer vision</strong>，意為你的迷你計算機視覺，含義有雙重，第一重含義是：一個迷你的 CV 庫；第二重含義是：可用於迷你計算機（如嵌入式計算機）的視覺庫。</p><p>這個庫是跨平台的，源碼由 C 語言編寫，可以在任意平台編譯，這個庫也可以通過選擇開啓部分功能從而實現將庫裁剪到你所必須的大小，降低對小型計算機的源碼空間佔用</p><img title="" src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/%E5%8A%9F%E8%83%BD%E9%80%89%E6%8B%A9%E7%BC%96%E8%AF%91.png" alt="" referrerpolicy="no-referrer"><h2><a id="user-content-項目起源" class="anchor" href="https://gitee.com/yao_mi/ymcv#%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%BA%90"></a>項目起源</h2><p>起源於我的個人需要，於 2019 年暑假完成了 YMKV 圖像處理庫編寫，當時主要為了運行在 stm32 上，編寫環境是 MDK。</p><p>而後為了方便驗證算法，將其移植到 PC 環境上開發，除了算法以外，諸如顯示，鼠標位置獲取，輸入等這些交互的內容，借用 EGE 庫來完成。老粉估計知道，最初我使用 CodeBlocks 開發，但考慮很多人不怎麼用它，後面換到了 vs2019 上進行開發。目前提供了 windows 環境下的 X86 和 STM32 版本的 Demo，以及 Linux 環境下的 ubuntu20.04-amd64 以及 esp32 版本的 Demo，大家可以自行測試。</p><blockquote><p>需要説明一下，windows 版本的 Demo 中文件編碼默認編碼是 gbk/gb2312，而 Linux 版本用的是 utf-8 編碼，如果要在工程中創建文件，需要確保文件編碼格式一致</p></blockquote><h2><a id="user-content-項目架構" class="anchor" href="https://gitee.com/yao_mi/ymcv#%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84"></a>項目架構</h2><p>這個項目的架構經過多次改良，目前確定了一款耦合度最小的架構，方便與任意平台兼容；另一方面為了方便大家使用，和原始的庫相比，採用面向對象的方式進行了重構。</p><p><img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/YMCV%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84.png" alt="" referrerpolicy="no-referrer"></p><p>項目分為三層架構，頂層是用户層，它是對核心層的包裹，方便用户對他進行調用，核心層的內容為左邊那列內容，其中黑體的 QRcode 是二維碼相關的編碼和解碼功能，這部分我是將第三方庫進行了壓縮打包，底層 congfig 是配置信息，內存管理以及 IO 文件接口的定義。</p><blockquote><p>文件接口是由宏定義來完成，由於讀寫圖片，如果移植到嵌入式可用我之前發佈的 uFatfs 文件系統，他是基於 Fatfs 的封裝，以便兼容 c 標準庫 stdio 的文件系統。圖中右側文件 IO 以及 Debug 都是獨立於核心層的，只依賴底層的配置。</p></blockquote><h2><a id="user-content-項目代碼命名規則" class="anchor" href="https://gitee.com/yao_mi/ymcv#%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"></a>項目代碼命名規則</h2><p>為了方便辨認數據類型，我約定的命名規則，平台通用數據類型用全小寫</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">int8，int16，uint8，uint16，uint32，float32,.....</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>自定義數據類型的話，需要加 CV 頭：</p><blockquote><p>結構體採用 CV+小寫</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">//圖像</span></span><span id="LC2" class="line"><span class="k">typedef</span><span class="k">struct</span></span><span id="LC3" class="line"><span class="p">{</span></span><span id="LC4" class="line"><span class="n">uint16</span><span class="n">width</span><span class="p">;</span></span><span id="LC5" class="line"><span class="n">uint16</span><span class="n">height</span><span class="p">;</span></span><span id="LC6" class="line"><span class="n">CVImgType</span><span class="n">type</span><span class="p">;</span></span><span id="LC7" class="line"><span class="n">_color8_t</span><span class="o">*</span><span class="n">data</span><span class="p">;</span></span><span id="LC8" class="line"><span class="p">}</span><span class="n">CVimage</span><span class="p">;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>結構體指針採用 CV+大寫</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">typedef</span><span class="n">CVimage</span><span class="o">*</span><span class="n">CVIMAGE</span><span class="p">;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>枚舉類型 CV+大小寫混合（單詞首字大寫）</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">//圖像類型</span></span><span id="LC2" class="line"><span class="k">typedef</span><span class="k">enum</span></span><span id="LC3" class="line"><span class="p">{</span></span><span id="LC4" class="line"><span class="n">CVBinaryType</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="c1">// 二值圖</span></span><span id="LC5" class="line"><span class="n">CVTrimapType</span><span class="p">,</span><span class="c1">//三色圖</span></span><span id="LC6" class="line"><span class="n">CVGrayType</span><span class="p">,</span><span class="c1">//灰度圖</span></span><span id="LC7" class="line"><span class="n">CVRgb16Type</span><span class="p">,</span><span class="c1">//RGB565</span></span><span id="LC8" class="line"><span class="n">CVFGrayType</span><span class="p">,</span><span class="c1">//float gray</span></span><span id="LC9" class="line"><span class="n">CVIGrayType</span><span class="p">,</span><span class="c1">//int gray</span></span><span id="LC10" class="line"><span class="n">CVCGrayType</span><span class="p">,</span><span class="c1">//complex gray</span></span><span id="LC11" class="line"><span class="p">}</span><span class="n">CVImgType</span><span class="p">;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>函數名： YMCV+首字母大寫</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">//創建一張空圖像</span></span><span id="LC2" class="line"><span class="n">CVIMAGE</span><span class="nf">YMCV_Creat_Img_Creat</span><span class="p">(</span><span class="n">uint16</span><span class="n">width</span><span class="p">,</span><span class="n">uint16</span><span class="n">height</span><span class="p">,</span><span class="n">CVImgType</span><span class="n">Imgform</span><span class="p">)</span></span><span id="LC3" class="line"><span class="p">{</span></span><span id="LC4" class="line"><span class="p">....</span></span><span id="LC5" class="line"><span class="p">....</span></span><span id="LC6" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div></blockquote><h2><a id="user-content-項目文件分佈説明" class="anchor" href="https://gitee.com/yao_mi/ymcv#%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%88%86%E5%B8%83%E8%AF%B4%E6%98%8E"></a>項目文件分佈説明</h2><p>打開項目我們能看到如下幾個文件夾，其中最重要的是 YMCV 部分，移植庫只需要該部分</p><blockquote><p>-- EGELIB ：交互和顯示的庫
-- EGE_LCD：基於 ege 庫，搭建用於 YMCV 的顯示和交互功能，函數
-- ImageSource：用於演示的圖片數據，這裏是 c 的數組文件</p><p>-- Demo：用於演示庫的使用例程，裏面有大部分函數的使用方法。我為這個庫配備了 150 多個 Demo 供大家使用參考</p><p>-- YMCV：算法庫的源碼部分</p></blockquote><p>打開 YMCV 文件夾，文件列表如下：</p><blockquote><p>-- -- CONFIG：算法庫的配置，移植其他平台的話只需要修改該文件夾的內容</p><p>-- -- OPOBJ：算法使用到的對象管理，對象創建和銷燬</p><p>-- -- CORE：算法核心源碼部分</p><p>-- -- USER：用户層封裝，可以使用 YMCV.funName(...) 方式調用函數</p><p>-- -- DEBUG：調試工具，可以提示錯誤信息</p><p>-- -- IOFILE：和文件相關的操作，該庫使用到的文件讀寫部分都在這邊，比如圖片和視頻的讀寫</p><p>-- -- Code：jpeg，avi，gif 等的編碼和解碼</p><p>-- -- QRCODE：條碼，二維碼，AprilTag 相關的內容</p></blockquote><h1><a id="user-content-項目使用説明" class="anchor" href="https://gitee.com/yao_mi/ymcv#%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"></a>項目使用説明</h1><h2><a id="user-content-運行 windows-x86 示例 demo" class="anchor" href="https://gitee.com/yao_mi/ymcv#%E8%BF%90%E8%A1%8Cwindows-x86%E7%A4%BA%E4%BE%8Bdemo"></a>運行 windows-X86 示例 demo</h2><p>首先你需要安裝一下 vs2019，然後下載這個項目並打開（x86-Debug 模式），配置你的 EGE 庫路徑 (目前已經換成相對路徑，下載完不配置也可以運行，如果要移植到你個人的項目中才需要做下面的配置)：</p><blockquote><p>選擇 YMCV 項目，右鍵，選擇屬性
<img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE0.png" alt="" referrerpolicy="no-referrer">
更換附加包含目錄，我的文件下載下來放在 D:\Documents\GitFiles\YMCV_LIB，所以配置如下圖所示
<img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE1.png" alt="" referrerpolicy="no-referrer">
同樣更換附加庫目錄
<img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE2.png" alt="" referrerpolicy="no-referrer">
注意這裏有兩個路徑，可以通過編輯展開看到：
<img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE3.png" alt="" referrerpolicy="no-referrer"></p></blockquote><p>然後就配置完了，接着選擇相應的 demo 運行，展開 demo 篩選器：</p><p><img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/demo0.png" alt="" referrerpolicy="no-referrer"></p><p>如先運行環境測試，鼠標移到 0、EGE_Test.c 上，右鍵，並選擇屬性，就能看到</p><p><img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%9F%A5%E7%9C%8B.png" alt="" referrerpolicy="no-referrer"></p><p>然後將 <strong>是</strong>  改成  <strong>否</strong>  即可，然後點擊運行，能出現如下畫面即可：</p><p><img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/demoOk.png" alt="" referrerpolicy="no-referrer"></p><p>測試完成後，將其屬性重新設置為從生成中排除，選擇你要運行的 Demo，將排除屬性選擇否即可。</p><h2><a id="user-content-運行 windows-stm32 示例 demo" class="anchor" href="https://gitee.com/yao_mi/ymcv#%E8%BF%90%E8%A1%8Cwindows-stm32%E7%A4%BA%E4%BE%8Bdemo"></a>運行 windows-stm32 示例 demo</h2><p>首先你需要安裝一下 Keil-MDK5，然後下載這個項目並打開，配置你的路徑 (目前已經換成相對路徑，下載完不配置也可以運行，如果要移植到你個人的項目中才需要做下面的配置)：</p><blockquote><p><img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/stm32-cfg.png" alt="" referrerpolicy="no-referrer"></p></blockquote><p>也就是和配置相關的頭文件路徑添加，YMCV 內部採用相對路徑，可以不需要添加和 YMCV 文件夾相關的路徑</p><p>選擇要運行的 Demo 編號</p><blockquote><p><img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/stm32demoChose.png" alt="" referrerpolicy="no-referrer">
所有的 Demo 文件名都放置在 DemoChose.txt 中，可以通過它瀏覽具體運行的是哪個 Demo</p></blockquote><p>查看當前 Demo 源碼</p><blockquote><p><img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/stm32scandemo.png" alt="" referrerpolicy="no-referrer"></p></blockquote><p>選擇對應的 Demo，右鍵即可打開，會自動跳轉到相應文件中</p><p>運行 Demo</p><blockquote><p>這個我就不細説了吧，能看到這裏相信你應該不是小白了，具體情況請去看 stm32 的教程</p></blockquote><h2><a id="user-content-運行 ubuntu-amd64 示例 demo" class="anchor" href="https://gitee.com/yao_mi/ymcv#%E8%BF%90%E8%A1%8Cubuntu-amd64%E7%A4%BA%E4%BE%8Bdemo"></a>運行 ubuntu-amd64 示例 demo</h2><p>首先你需要安裝一個 Ubuntu 系統，我的是 Ubuntu20.04，然後你克隆這個項目到本地上。這裏我提供了兩種方式運行，其中一種是需要安裝一個 vscode，然後用 vscode 打開目錄所在文件夾</p><blockquote><p>左上角-&gt;文件-&gt;打開文件夾-&gt;選擇 Linux-YMCV 文件夾，然後打開就可以了</p></blockquote><p>選擇 Demo 並運行（當然前提是你需要去安裝一下 C/C++開發環境的插件，這個大家自己網上查一下怎麼安裝吧，安裝很簡單的）</p><blockquote><p>直接點擊 Demo 展開，點擊一下你要運行的 Demo，它會跳到窗口上，然後點擊運行
<img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/ubuntuDemoChose.png" alt="" referrerpolicy="no-referrer">
之所以要這麼做，是由.vscode 下面的 task.json 文件決定的
<img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/ubuntuDemo-cfg.png" alt="" referrerpolicy="no-referrer"></p></blockquote><p>其中綠色的箭頭就是我們上面要選擇的調試器的名稱，紅色的箭頭即是將當前活動窗口的文件添加編譯，若沒有選擇 Demo 則會報錯，所以當你查看其他文件以後，要運行整個項目前需要先將活動窗口切換回 Demo 文件</p><p>運行成功之後便會得到如下畫面</p><blockquote><p><img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/ubuntuDemoResult.png" alt="" referrerpolicy="no-referrer"></p></blockquote><p>另一種是直接使用 CMakeLists.txt 運行，你只需要運行腳本文件 makefast.sh，並且後面跟上要運行的 Demo 即可，命令如下：</p><blockquote><p>sh ./makefast.sh  ./Demo/xxxdemo.c
(小提示：xxxdemo 不用完全自己輸入，比如選擇 1.1、xxxdemo.c，只要輸入「1.1、」然後按 Tab 鍵即可自動補全)
<img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/ubuntuDemo-shRun.png" alt="" referrerpolicy="no-referrer"></p></blockquote><h2><a id="user-content-運行 ubuntu-esp32 示例 demo" class="anchor" href="https://gitee.com/yao_mi/ymcv#%E8%BF%90%E8%A1%8Cubuntu-esp32%E7%A4%BA%E4%BE%8Bdemo"></a>運行 ubuntu-esp32 示例 demo</h2><p>首先，你需要安裝一下樂鑫的 ESP32 開發環境，ubuntu20.04 安裝我參考的是<a href="https://gitee.com/link?target=https%3A%2F%2Fblog.csdn.net%2Fweixin_41594119%2Farticle%2Fdetails%2F121364800">Ubuntu20.04 下 ESP32 環境搭建_Fpits 的博客-CSDN 博客</a></p><p>然後在你的 VScode 上配置開發環境，這些我就詳細説了。環境安裝好了以後，你可以克隆本項目到本地，然後用 vscode 打開目錄所在文件夾</p><blockquote><p>左上角-&gt;文件-&gt;打開文件夾-&gt;選擇 ESP32-YMCV 文件夾，然後打開就可以了</p></blockquote><p>將你的 LCD 連接到板子上，我使用的安可信的 esp32-cam 板子，對應 LCD 連接引腳為：</p><blockquote><p>CLK -&gt;IO12</p><p>SDIN -&gt;IO13</p><p>RST -&gt;IO15</p><p>DC -&gt;IO14</p><p>BLK -&gt;IO2</p><p>另外需要注意的是，安可信的板子上：</p><p>IO0 實際上是作為攝像頭的 xclk，所以使用攝像頭時該引腳務必懸空</p><p>IO4 是攝像頭 LED 引腳，該端口也不能接其他器件</p></blockquote><p>選擇 Demo 並運行（這個移植的 STM32 版本的 Demo，怎麼選擇可以參考那邊，即下圖的箭頭 1 處）</p><blockquote><p><img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/esp32demoChose.png" alt="" referrerpolicy="no-referrer"></p></blockquote><p>然後點擊箭頭 2 所指的圓桶進行編譯。編譯結束後可以箭頭 3 所指的小閃電下載到你的 esp32 上。</p><blockquote><p>當然，下載時會有一些細節，比如説選擇對應的 USB 端口，波特率，以及需要 IO0 端口接地然後按復位鍵等等，大家自行參考 ESP32 官方資料</p></blockquote><p>順帶一提，YMCV 庫位於 ESP32 工程的組件目錄下。</p><h2><a id="user-content-demo 分類及説明" class="anchor" href="https://gitee.com/yao_mi/ymcv#demo%E5%88%86%E7%B1%BB%E5%8F%8A%E8%AF%B4%E6%98%8E"></a>demo 分類及説明</h2><p>0 - 基礎環境測試</p><blockquote><p>0、EGE_Test : YMCV 基礎環境測試，EGE 依賴測試</p></blockquote><p>1 - 基礎圖像操作</p><blockquote><p>1.1、ImageShowTest : 圖像顯示測試</p><p>1.2、ImageCopyTest : 圖像拷貝測試</p><p>1.3、ImageFormChange : 圖像格式轉換</p><p>1.4、ImageAreaFill : 圖像區域填充</p><p>1.5、ImageSeedFill : 圖像種子填充</p><p>1.6、ImageRead : 圖像文件讀取</p></blockquote><p>2 - 圖像通道渲染</p><blockquote><p>2.1、ChannelGray2binTest : 灰度圖像二值化</p><p>2.2、ChannelGrayExposeAndColorTo : 灰度圖曝光與染色</p><p>2.3、ChannelGrayInversAndBright : 灰度圖反色與亮度增強</p><p>2.4、ChannelGrayContractAndLiner : 灰度圖對比度增強與分段線性增強</p><p>2.5、ChannelGrayLogAndExp : 灰度圖 log 對數、exp 指數增強</p><p>2.6、ChannelGrayGamaAndScurve : 灰度圖γ曲線，S 曲線增強</p><p>2.7、ChannelGrayCstomAndHeatPalette : 灰度圖自定義染色函數增強與熱力圖調色板渲染</p><p>2.8、ChannelRgb2binTest : 彩色圖像二值化</p><p>2.9、ChannelRgbExposeAndColor : 彩色圖像曝光與染色</p><p>2.10、ChannelRgbInversAndBright : 彩色圖像反色與亮度增強</p><p>2.11、ChannelRgbContractAndLiner :  彩色圖像對比度增強與分段線性增強</p><p>2.12、ChannelRgbLogAndExp : 彩色圖像 log 對數、exp 指數增強</p><p>2.13、ChannelRgbGamaAndScurve : 彩色圖像γ曲線，S 曲線增強</p><p>2.14、ChannelRgbCstom : 彩色圖像自定義染色函數增強</p><p>2.15、ChannelRgbInversAndBright_1Param : 單通道渲染器 (反色、亮度增強) 渲染彩色圖像</p><p>2.16、ChannelRgbContractAndLiner_1Param : 單通道渲染器 (對比度增強、分段線性增強) 渲染彩色圖像</p><p>2.17、ChannelRgbLogAndExp_1Param : 單通道渲染器 (log 對數、exp 指數增強) 渲染彩色圖像</p><p>2.18、ChannelRgbGamaAndScurve_1Param : 單通道渲染器 (γ曲線，S 曲線增強) 渲染彩色圖像</p></blockquote><p>3 - 圖像直方圖</p><blockquote><p>3.1、HistGrayHistEq : 灰度圖直方圖均衡化</p><p>3.2、HistGrayLocalHistEq : 灰度圖局部直方圖均衡化</p><p>3.3、HistGrayHistMapTo : 灰度圖直方圖規定化</p><p>3.4、HistRgbHistEq : 彩色圖像直方圖均衡化</p><p>3.5、HistRgbHistMapTo : 彩色圖像直方圖規定化</p><p>3.6、HistBackProject : 灰度圖直方圖反投影</p></blockquote><p>4 - 圖像空域渲染</p><blockquote><p>4.1、SpaceGrayGaussFilter : 灰度圖空域高斯濾波</p><p>4.2、SpaceGrayLogFilter : 灰度圖空域拉普拉斯-高斯濾波</p><p>4.3、SpaceGrayBilateralFilter : 灰度圖空域雙邊濾波</p><p>4.4、SpaceGrayLocalMSEFilter : 灰度圖空域局部均方差濾波</p><p>4.5、SpaceGrayAverAndMedFilter : 灰度圖空域均值與中值濾波</p><p>4.6、SpaceGrayMinAndMaxFilter : 灰度圖空域極大值與極小值濾波</p><p>4.7、SpaceGrayModeAndMidPointFilter : 灰度圖空域眾數與中點濾波</p><p>4.8、SpaceGrayMeanShiftFilter : 灰度圖空域均值漂移濾波</p><p>4.9、SpaceGraySurfaceBlurFilter : 灰度圖空域表面模糊濾波</p><p>4.10、SpaceGrayGuideFilter : 灰度圖空域導向濾波</p><p>4.11、SpaceGrayCustomKernelFilter : 灰度圖空域均自定義濾波核濾波</p><p>4.12、SpaceBinaryMorpRateFilter : 二值圖形態學濾波</p></blockquote><p>5 - 圖像頻域渲染</p><blockquote><p>5.1、FreqGrayFFTAndIFFT : 灰度圖像頻域 FFT 與 IFFT 變換</p><p>5.2、FreqGrayGaussHFilter : 灰度圖像頻域高斯高通濾波</p><p>5.3、FreqGrayGaussLFilter : 灰度圖像頻域高斯低通濾波</p><p>5.4、FreqGrayButtterWorthHFilter : 灰度圖像頻域巴特沃斯高通濾波</p><p>5.5、FreqGrayButterWorthLFilter : 灰度圖像頻域巴特沃斯低通濾波</p><p>5.6、FreqGrayBandPassFilter : 灰度圖像頻域帶通濾波</p><p>5.7、FreqGrayBandStopFilter : 灰度圖像頻域帶阻濾波</p><p>5.8、FreqGrayDCTAndIDCT : 灰度圖像頻域 DCT 和 IDCT 變換</p><p>5.9、FreqGrayHarrDWTAndIDWT : 灰度圖像頻域 Harr 小波變換 DWT 和 IDWT</p><p>5.10、FreqGrayHarrHardThreshold : 灰度圖像頻域 Harr 小波硬閾值去噪</p></blockquote><p>6 - 圖像幾何變換</p><blockquote><p>6.1、GeomGrayStretch : 灰度圖像最鄰近插值拉伸</p><p>6.2、GeomGrayStretchL2 : 灰度圖像線性插值拉伸</p><p>6.3、GeomGrayRotateWauto : 灰度圖像旋轉 (自適應動態窗口輸出)</p><p>6.4、GeomGrayRotateWconst : 灰度圖像旋轉 (固定窗口輸出)</p><p>6.5、GeomGrayLinerPolarAndInverse : 灰度圖像線性極座標變換及其逆變換</p><p>6.6、GeomGrayLogPolarAndInverse : 灰度圖像對數極座標變換及其逆變換</p><p>6.7、GeomGrayPerspective : 灰度圖像透視投影變換</p></blockquote><p>7 - 圖像分割</p><blockquote><p>7-1.1、BinaryGraySingleThresh : 灰度圖像單閾值二值化</p><p>7-1.2、BinaryGrayDoubleThresh : 灰度圖像雙閾值二值化</p><p>7-1.3、BinaryGrayHistThresh : 灰度圖像直方圖 Otsu 閾值二值化</p><p>7-1.4、BinaryGrayIntegralThresh : 灰度圖像積分圖二值化</p><p>7-1.5、BinaryRGBDoubleThresh : 彩色圖像 RGB 雙閾值二值化</p><p>7-1.6、BinaryLABDoubleThresh : 彩色圖像 LAB 雙閾值二值化</p><p>7-1.7、BinaryLogicCal : 二值圖邏輯運算 (與、或、非 )</p><p>7-1.8、BinaryMaskCal : 二值圖掩碼保留</p></blockquote><blockquote><p>7-2.1、EdgeGraySobel : 灰度圖像二值化 Sobel 邊緣檢測</p><p>7-2.2、EdgeGrayLog : 灰度圖像，拉普拉斯-高斯，邊緣檢測</p><p>7-2.3、EdgeGrayLaplace : 灰度圖像拉普拉斯邊緣檢測</p><p>7-2.4、EdgeGrayCanny : 灰度圖像 Canny 邊緣檢測</p><p>7-2.5、EdgeGraySobelConnect : 灰度圖像 Sobel 邊緣檢測 (帶局部相似連接)</p></blockquote><blockquote><p>7-3.1、RegionGrayGrowing : 灰度圖像區域生長</p><p>7-3.2、RegionGraySplitandAndMerge : 灰度圖像區域分裂與合併</p><p>7-3.3、RegionGrayKmeansSegment : 灰度圖像 Kmeans 聚類</p><p>7-3.4、RegionGrayGMMSegment : 灰度圖像 GMM 聚類</p><p>7-3.5、RegionGrayDistanceTransform : 灰度圖像距離變換</p><p>7-3.6、RegionGrayTriMap : 灰度圖像 Trimap 三色圖生成</p><p>7-3.7、RegionGrayWatershed : 灰度圖像分水嶺分割</p><p>7-3.8、RegionGraySnake : 灰度圖像 snake 輪廓提取</p><p>7-3.9、RegionGrayGrabCut : 灰度圖像 grabCut 圖割</p><p>7-3.10、RegionBinaryXY_AxisProjSeg : 二值圖 xy 軸投影分割</p></blockquote><p>8 - 圖像特徵提取</p><blockquote><p>8.1、ImageColorBoxFind : 圖像雙閾值色塊提取 (一個色塊)</p><p>8.2、ImageColorBolosFind : 圖像雙閾值色塊提取 (多個色塊，最多 8 種色塊)</p><p>8.3、BinaryAreaSave : 二值圖大面積區域保留</p><p>8.4、BinaryWormFindLine : 二值圖 Worm 直線查找 (支持 1 像素斷裂)</p><p>8.5、ImageEDFindEdge : 灰度圖 ED 邊緣檢測</p><p>8.6、ImageEDFindShape : 灰度圖 ED 形狀識別</p><p>8.7、ImageEDFindLines : 灰度圖 ED 直線檢測</p><p>8.8、ImageGrayHogFind : 灰度圖 HOG 描述符提取</p><p>8.9、ImageGrayFaceLbpDesc : 灰度圖人臉 LBP 直方圖描述符提取</p><p>8.10、BinaryLinerRegressCal : 二值圖像素迴歸 (最小二乘、泰爾森、RANSAC)</p><p>8.11、BinaryBoneThinAndCut : 二值圖骨架細化與剪枝</p><p>8.12、BinaryEdgeTrance : 二值圖邊界跟蹤</p><p>8.13、ImageFeatureMap : 灰度圖特徵圖提取 (LBP、MRLBP、USAN)</p><p>8.14、GrayFeaturePointGet : 灰度圖特徵點提取 (susan、fast-9、agast、harris)</p><p>8.15、GrayFeatureDescribeGet : 灰度圖 brief 特徵描述符提取</p><p>8.16、BinaryHoughGet : 二值圖霍夫變換</p><p>8.17、GrayRandonGet : 灰度圖拉東變換及其逆變換</p><p>8.18、GrayStereoLM : 灰度圖立體匹配 LineMatching</p></blockquote><p>9 - 圖像目標匹配</p><blockquote><p>9.1、ImageGraySSIMCal : 灰度圖結構相似性匹配</p><p>9.2、ImageGrayTemplate : 灰度圖模板匹配</p><p>9.3、ImageGrayFaceCascade : 灰度圖人臉 cascade</p><p>9.4、ImageGrayLBPClassify : 灰度圖人臉 LBP 特徵分類</p><p>9.5、ImageBinaryNumberDecisonTree : 灰度圖數字決策樹分類</p><p>9.6、ImageGrayPhaseCorrelate : 灰度圖相位相關匹配</p><p>9.7、ImageFeatureDescribeMatch : 灰度圖 brief 描述符匹配與單應性矩陣矯正</p><p>9.8、ImageGrayMeanShift : 灰度圖 MeanShift 跟蹤</p><p>9.9、ParticleFilterTracking : 灰度圖粒子濾波跟蹤</p><p>9.10、ImageGrayFacePointDect : 灰度圖 40 點人臉特徵點檢測</p></blockquote><p>10 - 修復&amp;特效</p><blockquote><p>10.1、GrayRemovalFog : 灰度圖何凱明暗通道去霧</p><p>10.2、BadImageColor : 灰度圖污漬效果</p><p>10.3、GrayInPainting : 灰度圖 inpaint 修復</p><p>10.4、ImageFishEye : 灰度圖魚眼效果及其矯正</p><p>10.5、ImageCartoon : 灰度圖卡通效果</p><p>10.6、ImageRigidDeformation : 灰度圖剛性變形效果</p></blockquote><p>11 - 數據處理&amp;機器學習</p><blockquote><p>11.1、FFT1d_Test : 一維 FFT 及 IFFT 處理數據測試</p><p>11.2、DCT1d_Test : 一維 DCT 及 IDCT 處理數據測試</p><p>11.3、DWT1d_Test : 一維 Harr 小波 DWT 及 IDWT 處理數據測試</p><p>11.4、FMat_Test : 矩陣運算測試 (轉置、乘法、逆、偽逆、雅可比旋轉法特徵值和特徵向量、Cholesky 分解、快速自乘法、初等變換、SVD 分解等等)</p><p>11.5、KmeansTest : Kmeans 數據分類訓練和測試</p><p>11.6、GMM_Test : GMM 數據分類訓練和測試</p><p>11.7、DecisionTree_Test : ID3 決策樹數據分類訓練和測試</p><p>11.8、LineSegmentsMerge : 線段合併測試</p><p>11.9、DelauneyTriangle : 由點集創建 Delauney 三角形</p></blockquote><p>12 - 條碼&amp;二維碼識別</p><blockquote><p>12.1、AprilTagDecode : 灰度圖四月標籤 (AprilTag) 識別</p><p>12.2、DataMatrixDecode : 灰度圖 DM 碼識別</p><p>12.3、QRDecode : 灰度圖 QR 碼 (二維碼) 識別</p><p>12.4、BarDecode : 灰度圖 bar 碼 (條形碼) 識別</p><p>12.5、QR_Encode : 灰度圖 QR 碼編碼 (二維碼生成)</p></blockquote><p>13 - 其他項目應用</p><blockquote><p>13.1、Scoring_System : 得分系統，自動判卷系統</p><p>13.2、Table_Recognize : 表格識別，表格線提取</p><p>13.3、Calibrating_Data : 40 點人臉特徵點數據標定</p><p>13.4、FacePoint_Train : 40 點人臉特徵點數據模型訓練</p></blockquote><h2><a id="user-content-demo 運行結果展示" class="anchor" href="https://gitee.com/yao_mi/ymcv#demo%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA"></a>demo 運行結果展示</h2><p>我把所有 demo 的運行結果示例都錄成一個簡短的視頻，放在「例程測試結果」文件夾下，大家可以自行對照查看
<img src="https://gitee.com/yao_mi/ymcv/raw/master/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE%E7%89%87/%E4%BE%8B%E7%A8%8B%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="" referrerpolicy="no-referrer"></p><p>另外，大家可以先看看 0-1.MP4，這裏面有 demo 切換的示例，從 demo0 切換到 demo1 如何配置（這個切換後面我就給切了，後面就沒有了）。</p><h2><a id="user-content-移植其他平台" class="anchor" href="https://gitee.com/yao_mi/ymcv#%E7%A7%BB%E6%A4%8D%E5%85%B6%E4%BB%96%E5%B9%B3%E5%8F%B0"></a>移植其他平台</h2><p>如移植 stm32 平台，首先需要將 YMCV 文件夾拷貝走</p><p>添加到你的項目下</p><p>然後打開 CONFIG 文件夾下的文件進行修改</p><p>首先我們打開 YMCV_Mem.c 文件，該文件管理則 YMCV 庫的動態計算內存，我們將其改為自己的內存函數</p><p>然後我們打開 YMCV_PubDefine.h 文件，該文件管理着一些常數定義，如果我們用到文件操作，需要修改文件系統定義部分，換成我們自己平台下的文件系統函數（若使用 Fatfs，可以使用我封裝過的 uFatfs）</p><p>最後打開 YMCV_PubType.h 文件看一眼，大部分時候該文件都不會需要修改</p><p>最後我們直接編譯即可
....</p><p><strong>當然，這裏我直接提供了 STM32 平台的 Demo，大家不用自己移植了，可以照着 Demo 移植到其他平台上，需要移植其他平台也可以聯繫我</strong>，當然我有時間可以幫忙移植，大家一起共築應用生態，完結撒花。</p><h2><a id="user-content-更多教程" class="anchor" href="https://gitee.com/yao_mi/ymcv#%E6%9B%B4%E5%A4%9A%E6%95%99%E7%A8%8B"></a>更多教程</h2><p><a href="https://gitee.com/link?target=https%3A%2F%2Fspace.bilibili.com%2F314022084">嗶哩嗶哩 - 妖米貓人主頁</a></p><p>我比較懶，估計更新的比較慢，幫我剪視頻的小夥伴工作了時間也不多，更新的就更慢了。。。我自己剪的比較拉跨，也沒什麼太大動力感覺。</p>]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 02:22:10 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/yao_mi/ymcv</guid>
            <link>https://gitee.com/yao_mi/ymcv</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 如何充分發揮 SQL 能力？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote>
  如何充分發揮 SQL 能力，是本篇文章的主題。本文嘗試獨闢蹊徑，強調通過靈活的、發散性的數據處理思維，就可以用最基礎的語法，解決複雜的數據場景。 
</blockquote><span id="OSC_h3_1"></span><h3>一、前言</h3><span id="OSC_h4_2"></span><h4><strong>1.1 初衷</strong></h4><p><strong>如何高效地使用 MaxCompute（ODPS）SQL ，將基礎 SQL 語法運用到極致。</strong></p><p>在大數據如此流行的今天，不只是專業的數據人員，需要經常地跟 SQL 打交道，即使是產品、運營等非技術同學，也會或多或少地使用到 SQL ，如何高效地發揮 SQL 的能力，繼而發揮數據的能力，變得尤為重要。</p><p>MaxCompute（ODPS）SQL 發展到今天已經頗為成熟，作為一種 SQL 方言，其 SQL 語法支持完備，具有非常豐富的內置函數，支持開窗函數、用户自定義函數、用户自定義類型等諸多高級特性，可以高效地應用在各種數據處理場景。</p><p>如何充分發揮 SQL 能力，是本篇文章的主題。本文嘗試獨闢蹊徑，<strong>強調通過靈活的、發散性的數據處理思維，就可以用最基礎的語法，解決複雜的數據場景。</strong></p><span id="OSC_h4_3"></span><h4><strong>1.2 適合人羣</strong></h4><p>不論是初學者還是資深人員，本篇文章或許都能有所幫助，不過更適閤中級、高級讀者閲讀。</p><p>本篇文章重點介紹數據處理思維，並沒有涉及到過多高階的語法，同時為了避免主題發散，文中涉及的函數、語法特性等，不會花費篇幅進行專門的介紹，讀者可以按自身情況自行了解。</p><span id="OSC_h4_4"></span><h4><strong>1.3 內容結構</strong></h4><p>本篇文章將圍繞數列生成、區間變換、排列組合、連續判別等主題進行介紹，並附以案例進行實際運用講解。每個主題之間有輕微的前後依賴關係，依次閲讀更佳。</p><span id="OSC_h4_5"></span><h4><strong>1.4 提示信息</strong></h4><p>本篇文章涉及的 SQL 語句只使用到了 MaxCompute（ODPS）SQL 基礎語法特性，理論上所有 SQL 均可以在當前最新版本中運行，同時特意註明，運行環境、兼容性等問題不在本篇文章關注範圍內。</p><span id="OSC_h3_6"></span><h3>二、數列</h3><p>數列是最常見的數據形式之一，實際數據開發場景中遇到的基本都是有限數列。本節將從最簡單的遞增數列開始，找出一般方法並推廣到更泛化的場景。</p><span id="OSC_h4_7"></span><h4><strong>2.1 常見數列</strong></h4><p><strong>2.1.1 一個簡單的遞增數列</strong></p><p>首先引出一個簡單的遞增整數數列場景：</p><ul><li>從數值 0 開始；</li><li>之後的每個數值遞增 1 ；</li><li>至數值 3 結束；</li></ul><p>如何生成滿足以上三個條件的數列？即 [0,1,2,3] 。</p><p>實際上，生成該數列的方式有多種，此處介紹其中一種簡單且通用的方案。</p><pre><code>-- SQL - 1
select
    t.pos as a_n
from (
    select posexplode(split(space(3), space(1), false))
) t;</code></pre><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-7732deab4da1ae67f9bc4a298e28b182_720w.webp" referrerpolicy="no-referrer"></p><p>通過上述 SQL 片段可得知，生成一個遞增序列只需要三個步驟：</p><p>1）生成一個長度合適的數組，數組中的元素不需要具有實際含義；</p><p>2）通過 UDTF 函數 posexplode 對數組中的每個元素生成索引下標；</p><p>3）取出每個元素的索引下標。以上三個步驟可以推廣至更一般的數列場景：等差數列、等比數列。下文將以此為基礎，直接給出最終實現模板。</p><p><strong>2.1.2 等差數列</strong></p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-8416443479890cdc2d3ec834f9d51a6d_720w.webp" referrerpolicy="no-referrer"></p><p>SQL 實現：</p><pre><code>-- SQL - 2
select
    a + t.pos * d as a_n
from (
    select posexplode(split(space(n - 1), space(1), false))
) t;</code></pre><p><strong>2.1.3 等比數列</strong></p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-bbe3a0faeb782d6f2f136214bc67c888_720w.webp" referrerpolicy="no-referrer"></p><p>SQL 實現：</p><pre><code>-- SQL - 3
select
    a * pow(q, t.pos) as a_n
from (
    select posexplode(split(space(n - 1), space(1), false))
) t;</code></pre><p>提示：亦可直接使用 MaxCompute（ODPS）系統函數 sequence 快速生成數列。</p><pre><code>-- SQL - 4
select sequence(1, 3, 1);

-- result
[1, 2, 3]</code></pre><span id="OSC_h4_8"></span><h4><strong>2.2 應用場景舉例</strong></h4><p><strong>2.2.1 還原任意維度組合下的維度列簇名稱</strong></p><p>在多維分析場景下，可能會用到高階聚合函數，如&nbsp;<em>cube</em>&nbsp;、&nbsp;<em>rollup</em>&nbsp;、&nbsp;<em>grouping sets</em>&nbsp;等，可以針對不同維度組合下的數據進行聚合統計。</p><p><strong>場景描述</strong></p><p>現有用户訪問日誌表 visit_log ，每一行數據表示一條用户訪問日誌。</p><pre><code>-- SQL - 5
with visit_log as (
    select stack (
        6,
        '2024-01-01', '101', '湖北', '武漢', 'Android',
        '2024-01-01', '102', '湖南', '長沙', 'IOS',
        '2024-01-01', '103', '四川', '成都', 'Windows',
        '2024-01-02', '101', '湖北', '孝感', 'Mac',
        '2024-01-02', '102', '湖南', '邵陽', 'Android',
        '2024-01-03', '101', '湖北', '武漢', 'IOS'
    ) 
    -- 字段：日期，用户，省份，城市，設備類型
    as (dt, user_id, province, city, device_type)
)
select * from visit_log;</code></pre><p>現針對省份 province , 城市 city, 設備類型 device_type 三個維度列，通過<em>grouping sets</em>聚合統計得到了不同維度組合下的用户訪問量。問：1）如何知道一條統計結果是根據哪些維度列聚合出來的？</p><p>2）想要輸出&nbsp;<strong>聚合的維度列的名稱</strong>，用於下游的報表展示等場景，又該如何處理？</p><p><strong>解決思路</strong></p><p><strong>可以藉助</strong>&nbsp;<strong>MaxCompute（ODPS）提供的 GROUPING__ID 來解決，核心方法是對 GROUPING__ID 進行逆向實現。</strong></p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-bd703256ba0eb478e33155b84482ed35_720w.webp" referrerpolicy="no-referrer"></p><p><strong>一、準備好所有的 GROUPING__ID 。</strong></p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-cf58be1174387bcf38b8c32c235f300b_720w.webp" referrerpolicy="no-referrer"></p><table><tbody><tr><td>GROUPING__ID</td><td>bits</td></tr><tr><td>0</td><td>{ ..., 0, 0, 0 }</td></tr><tr><td>1</td><td>{ ..., 0, 0, 1 }</td></tr><tr><td>2</td><td>{ ..., 0, 1, 0 }</td></tr><tr><td>3</td><td>{ ..., 0, 1, 1 }</td></tr><tr><td>...</td><td>...</td></tr><tr><td>2n2n</td><td>...</td></tr></tbody></table><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-03b742e72cf1234c12320f956ea32e54_720w.webp" referrerpolicy="no-referrer"></p><p><strong>二、準備好所有維度名稱。</strong></p><p style="text-align:center"><img src="https://pic3.zhimg.com/v2-84c04cdfe86b38c60d16d3239d86a09e_r.jpg" referrerpolicy="no-referrer"></p><pre><code>{ dim_name_1, dim_name_2, ..., dim_name_n }</code></pre><p><strong>三、將 GROUPING__ID 映射到維度列名稱。</strong></p><p>對於 GROUPING__ID 遞增數列中的每個數值，將該數值的 2 進制每個比特位與維度名稱序列的下標進行映射，輸出所有對應比特位 0 的維度名稱。例如：</p><pre><code>GROUPING__ID：3 =&gt; { 0, 1, 1 }
維度名稱序列：{ 省份, 城市, 設備類型 }

映射：{ 0:省份, 1:城市, 1:設備類型 }

GROUPING__ID 為 3 的數據行聚合維度即為：省份</code></pre><p><strong>SQL 實現</strong></p><pre><code>-- SQL - 6
with group_dimension as (
    select -- 每種分組對應的維度字段
        gb.group_id, concat_ws(",", collect_list(case when gb.placeholder_bit = 0 then dim_col.val else null end)) as dimension_name
    from (
        select groups.pos as group_id, pe.*
        from (
            select posexplode(split(space(cast(pow(2, 3) as int) - 1), space(1), false))
        ) groups -- 所有分組
        lateral view posexplode(regexp_extract_all(lpad(conv(groups.pos,10,2), 3, "0"), '(0|1)')) pe as placeholder_idx, placeholder_bit -- 每個分組的 bit 信息
    ) gb
    left join ( -- 所有維度字段
        select posexplode(split("省份,城市,設備類型", ','))
    ) dim_col on gb.placeholder_idx = dim_col.pos
    group by gb.group_id
)
select 
    group_dimension.dimension_name,
    province, city, device_type,
    visit_count
from (
    select
        grouping_id(province, city, device_type) as group_id,
        province, city, device_type,
        count(1) as visit_count
    from visit_log b
    group by province, city, device_type
    GROUPING SETS(
        (province),
        (province, city),
        (province, city, device_type)
    )
) t
join group_dimension on t.group_id = group_dimension.group_id
order by group_dimension.dimension_name;</code></pre><table><tbody><tr><td>dimension_name</td><td>province</td><td>city</td><td>device_type</td><td>visit_count</td></tr><tr><td>省份</td><td>湖北</td><td>NULL</td><td>NULL</td><td>3</td></tr><tr><td>省份</td><td>湖南</td><td>NULL</td><td>NULL</td><td>2</td></tr><tr><td>省份</td><td>四川</td><td>NULL</td><td>NULL</td><td>1</td></tr><tr><td>省份,城市</td><td>湖北</td><td>武漢</td><td>NULL</td><td>2</td></tr><tr><td>省份,城市</td><td>湖南</td><td>長沙</td><td>NULL</td><td>1</td></tr><tr><td>省份,城市</td><td>湖南</td><td>邵陽</td><td>NULL</td><td>1</td></tr><tr><td>省份,城市</td><td>湖北</td><td>孝感</td><td>NULL</td><td>1</td></tr><tr><td>省份,城市</td><td>四川</td><td>成都</td><td>NULL</td><td>1</td></tr><tr><td>省份,城市,設備類型</td><td>湖北</td><td>孝感</td><td>Mac</td><td>1</td></tr><tr><td>省份,城市,設備類型</td><td>湖南</td><td>長沙</td><td>IOS</td><td>1</td></tr><tr><td>省份,城市,設備類型</td><td>湖南</td><td>邵陽</td><td>Android</td><td>1</td></tr><tr><td>省份,城市,設備類型</td><td>四川</td><td>成都</td><td>Windows</td><td>1</td></tr><tr><td>省份,城市,設備類型</td><td>湖北</td><td>武漢</td><td>Android</td><td>1</td></tr><tr><td>省份,城市,設備類型</td><td>湖北</td><td>武漢</td><td>IOS</td><td>1</td></tr></tbody></table><span id="OSC_h3_9"></span><h3>三、區間</h3><p>區間相較數列具有不同的數據特徵，不過在實際應用中，數列與區間的處理具有較多相通性。本節將介紹一些常見的區間場景，並抽象出通用的解決方案。</p><span id="OSC_h4_10"></span><h4><strong>3.1 常見區間操作</strong></h4><p><strong>3.1.1 區間分割</strong></p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-6ba7d81f19eff5e8606c559b54f40ad1_720w.webp" referrerpolicy="no-referrer"></p><p>SQL 實現：</p><pre><code>-- SQL - 7
select
    a + t.pos * d as sub_interval_start, -- 子區間起始值
    a + (t.pos + 1) * d as sub_interval_end -- 子區間結束值
from (
    select posexplode(split(space(n - 1), space(1), false))
) t;</code></pre><p><strong>3.1.2 區間交叉</strong></p><p>已知兩個日期區間存在交叉 ['2024-01-01', '2024-01-03'] 、 ['2024-01-02', '2024-01-04']。問：</p><p>1）如何合併兩個日期區間，並返回合併後的新區間？</p><p>2）如何知道哪些日期是交叉日期，並返回該日期交叉次數？</p><p>解決上述問題的方法有多種，此處介紹其中一種簡單且通用的方案。核心思路是結合數列生成、區間分割方法，先將日期區間分解為最小處理單元，即多個日期組成的數列，然後再基於日期粒度做統計。具體步驟如下：</p><p>1）獲取每個日期區間包含的天數；2）按日期區間包含的天數，將日期區間拆分為相應數量的遞增日期序列；</p><p>3）通過日期序列統計合併後的區間，交叉次數。</p><p>SQL 實現：</p><pre><code>-- SQL - 8
with dummy_table as (
    select stack(
        2,
        '2024-01-01', '2024-01-03',
        '2024-01-02', '2024-01-04'
    ) as (date_start, date_end)
)
select 
    min(date_item) as date_start_merged, 
    max(date_item) as date_end_merged, 
    collect_set( -- 交叉日期計數
        case when date_item_cnt &gt; 1 then concat(date_item, ':', date_item_cnt) else null end
    ) as overlap_date
from (
    select 
        -- 拆解後的單個日期
        date_add(date_start, pos) as date_item,
        -- 拆解後的單個日期出現的次數
        count(1) over (partition by date_add(date_start, pos)) as date_item_cnt
    from dummy_table
    lateral view posexplode(split(space(datediff(date_end, date_start)), space(1), false)) t as pos, val
) t;</code></pre><table><tbody><tr><td>date_start_merged</td><td>date_end_merged</td><td>overlap_date</td></tr><tr><td>2024-01-01</td><td>2024-01-04</td><td>["2024-01-02:2","2024-01-03:2"]</td></tr></tbody></table><p><strong>增加點兒難度！</strong></p><p>如果有多個日期區間，且區間之間交叉狀態未知，上述問題又該如何求解。即：</p><p>1）如何合併多個日期區間，並返回合併後的多個新區間？</p><p>2）如何知道哪些日期是交叉日期，並返回該日期交叉次數？</p><p>SQL 實現：</p><pre><code>-- SQL - 9
with dummy_table as (
    select stack(
        5,
        '2024-01-01', '2024-01-03',
        '2024-01-02', '2024-01-04',
        '2024-01-06', '2024-01-08',
        '2024-01-08', '2024-01-08',
        '2024-01-07', '2024-01-10'
    ) as (date_start, date_end)
)
select
    min(date_item) as date_start_merged, 
    max(date_item) as date_end_merged,
    collect_set( -- 交叉日期計數
        case when date_item_cnt &gt; 1 then concat(date_item, ':', date_item_cnt) else null end
    ) as overlap_date
from (
    select 
        -- 拆解後的單個日期
        date_add(date_start, pos) as date_item,
        -- 拆解後的單個日期出現的次數
        count(1) over (partition by date_add(date_start, pos)) as date_item_cnt,
        -- 對於拆解後的單個日期，重組為新區間的標記
        date_add(date_add(date_start, pos), 1 - dense_rank() over (order by date_add(date_start, pos))) as cont
    from dummy_table
    lateral view posexplode(split(space(datediff(date_end, date_start)), space(1), false)) t as pos, val
) t
group by cont;</code></pre><table><tbody><tr><td>date_start_merged</td><td>date_end_merged</td><td>overlap_date</td></tr><tr><td>2024-01-01</td><td>2024-01-04</td><td>["2024-01-02:2","2024-01-03:2"]</td></tr><tr><td>2024-01-06</td><td>2024-01-10</td><td>["2024-01-07:2","2024-01-08:3"]</td></tr></tbody></table><span id="OSC_h4_11"></span><h4><strong>3.2 應用場景舉例</strong></h4><p><strong>3.2.1 按任意時段統計數據</strong></p><p><strong>場景描述</strong></p><p>現有用户還款計劃表 user_repayment ，該表內的一條數據，表示用户在指定日期區間內 [date_start, date_end] ，每天還款 repayment 元。</p><pre><code>-- SQL - 10
with user_repayment as (
    select stack(
        3,
        '101', '2024-01-01', '2024-01-15', 10,
        '102', '2024-01-05', '2024-01-20', 20,
        '103', '2024-01-10', '2024-01-25', 30
    ) 
    -- 字段：用户，開始日期，結束日期，每日還款金額
    as (user_id, date_start, date_end, repayment)
)
select * from user_repayment;</code></pre><p>如何統計任意時段內（如：2024-01-15 至 2024-01-16）每天所有用户的應還款總額？</p><p><strong>解決思路</strong></p><p>核心思路是將日期區間轉換為日期序列，再按日期序列進行彙總統計。</p><p><strong>SQL 實現</strong></p><pre><code>-- SQL - 11
select 
    date_item as day, 
    sum(repayment) as total_repayment
from (
    select 
        date_add(date_start, pos) as date_item,
        repayment
    from user_repayment
    lateral view posexplode(split(space(datediff(date_end, date_start)), space(1), false)) t as pos, val
) t
where date_item &gt;= '2024-01-15' and date_item &lt;= '2024-01-16'
group by date_item
order by date_item;</code></pre><table><tbody><tr><td>day</td><td>total_repayment</td></tr><tr><td>2024-01-15</td><td>60</td></tr><tr><td>2024-01-16</td><td>50</td></tr></tbody></table><span id="OSC_h3_12"></span><h3>四、排列組合</h3><p>排列組合是針對離散數據常用的數據組織方法，本節將分別介紹排列、組合的實現方法，並結合實例着重介紹通過組合對數據的處理。</p><span id="OSC_h4_13"></span><h4><strong>4.1 常見排列組合操作</strong></h4><p><strong>4.1.1 排列</strong></p><p>已知字符序列 [ 'A', 'B', 'C' ] ，每次從該序列中可重複地選取出 2 個字符，如何獲取到所有的排列？</p><p>藉助多重 lateral view 即可解決，整體實現比較簡單。</p><pre><code>-- SQL - 12
select 
    concat(val1, val2) as perm
from (select split('A,B,C', ',') as characters) dummy
lateral view explode(characters) t1 as val1
lateral view explode(characters) t2 as val2;</code></pre><table><tbody><tr><td>perm</td></tr><tr><td>AA</td></tr><tr><td>AB</td></tr><tr><td>AC</td></tr><tr><td>BA</td></tr><tr><td>BB</td></tr><tr><td>BC</td></tr><tr><td>CA</td></tr><tr><td>CB</td></tr><tr><td>CC</td></tr></tbody></table><p><strong>4.1.2 組合</strong></p><p>已知字符序列 [ 'A', 'B', 'C' ] ，每次從該序列中可重複地選取出 2 個字符，如何獲取到所有的組合？</p><p>藉助多重 lateral view 即可解決，整體實現比較簡單。</p><pre><code>-- SQL - 13
select 
    concat(least(val1, val2), greatest(val1, val2)) as comb
from (select split('A,B,C', ',') as characters) dummy
lateral view explode(characters) t1 as val1
lateral view explode(characters) t2 as val2
group by least(val1, val2), greatest(val1, val2);</code></pre><table><tbody><tr><td>comb</td></tr><tr><td>AA</td></tr><tr><td>AB</td></tr><tr><td>AC</td></tr><tr><td>BB</td></tr><tr><td>BC</td></tr><tr><td>CC</td></tr></tbody></table><p><br> 提示：亦可直接使用 MaxCompute（ODPS）系統函數 combinations 快速生成組合。</p><pre><code>-- SQL - 14
select combinations(array('foo', 'bar', 'boo'),2);

-- result
[['foo', 'bar'], ['foo', 'boo']['bar', 'boo']]</code></pre><span id="OSC_h4_14"></span><h4><strong>4.2 應用場景舉例</strong></h4><p><strong>4.2.1 分組對比統計</strong></p><p><strong>場景描述</strong></p><p>現有投放策略轉化表，該表內的一條數據，表示一天內某投放策略帶來的訂單量。</p><pre><code>-- SQL - 15
with strategy_order as (
    select stack(
        3,
        '2024-01-01', 'Strategy A', 10,
        '2024-01-01', 'Strategy B', 20,
        '2024-01-01', 'Strategy C', 30
    ) 
    -- 字段：日期，投放策略，單量
    as (dt, strategy, order_cnt)
)
select * from strategy_order;</code></pre><p>如何按投放策略建立兩兩對比組，按組對比展示不同策略轉化單量情況？</p><table><tbody><tr><td>對比組</td><td>投放策略</td><td>轉化單量</td></tr><tr><td>Strategy A-Strategy B</td><td>Strategy A</td><td>xxx</td></tr><tr><td>Strategy A-Strategy B</td><td>Strategy B</td><td>xxx</td></tr></tbody></table><p><strong>解決思路</strong></p><p>核心思路是從所有投放策略列表中不重複地取出 2 個策略，生成所有的組合結果，然後關聯 strategy_order 表分組統計結果。</p><p><strong>SQL 實現</strong></p><pre><code>-- SQL - 16
select /*+ mapjoin(combs) */
    combs.strategy_comb,
    so.strategy,
    so.order_cnt
from strategy_order so
join ( -- 生成所有對比組
    select 
        concat(least(val1, val2), '-', greatest(val1, val2)) as strategy_comb,
        least(val1, val2) as strategy_1, greatest(val1, val2) as strategy_2
    from (
        select collect_set(strategy) as strategies
        from strategy_order
    ) dummy
    lateral view explode(strategies) t1 as val1
    lateral view explode(strategies) t2 as val2
    where val1 &lt;&gt; val2
    group by least(val1, val2), greatest(val1, val2)
) combs on 1 = 1
where so.strategy in (combs.strategy_1, combs.strategy_2)
order by combs.strategy_comb, so.strategy;</code></pre><table><tbody><tr><td>對比組</td><td>投放策略</td><td>轉化單量</td></tr><tr><td>Strategy A-Strategy B</td><td>Strategy A</td><td>10</td></tr><tr><td>Strategy A-Strategy B</td><td>Strategy B</td><td>20</td></tr><tr><td>Strategy A-Strategy C</td><td>Strategy A</td><td>10</td></tr><tr><td>Strategy A-Strategy C</td><td>Strategy C</td><td>30</td></tr><tr><td>Strategy B-Strategy C</td><td>Strategy B</td><td>20</td></tr><tr><td>Strategy B-Strategy C</td><td>Strategy C</td><td>30</td></tr></tbody></table><span id="OSC_h3_15"></span><h3>五、連續</h3><p>本節主要介紹連續性問題，重點描述了常見連續活躍場景。對於靜態類型的連續活躍、動態類型的連續活躍，分別闡述了不同的實現方案。</p><span id="OSC_h4_16"></span><h4><strong>5.1 普通連續活躍統計</strong></h4><p><strong>場景描述</strong></p><p>現有用户訪問日誌表 visit_log ，每一行數據表示一條用户訪問日誌。</p><pre><code>-- SQL - 17
with visit_log as (
    select stack (
        6,
        '2024-01-01', '101', '湖北', '武漢', 'Android',
        '2024-01-01', '102', '湖南', '長沙', 'IOS',
        '2024-01-01', '103', '四川', '成都', 'Windows',
        '2024-01-02', '101', '湖北', '孝感', 'Mac',
        '2024-01-02', '102', '湖南', '邵陽', 'Android',
        '2024-01-03', '101', '湖北', '武漢', 'IOS'
    ) 
    -- 字段：日期，用户，省份，城市，設備類型
    as (dt, user_id, province, city, device_type)
)
select * from visit_log;</code></pre><p>如何獲取連續訪問大於或等於 2 天的用户？</p><p>上述問題在分析連續性時，<strong>獲取連續性的結果以超過固定閾值為準</strong>，此處歸類為&nbsp;<strong>連續活躍大於 N 天閾值的普通連續活躍場景統計</strong>。</p><p><strong>SQL 實現</strong></p><p><strong>基於相鄰日期差實現（ lag / lead 版）</strong></p><p>整體實現比較簡單。</p><pre><code>-- SQL - 18
select user_id
from (
    select 
        *,
        lag(dt, 2 - 1) over (partition by user_id order by dt) as lag_dt
    from (select dt, user_id from visit_log group by dt, user_id) t0
) t1
where datediff(dt, lag_dt) + 1 = 2
group by user_id;</code></pre><table><tbody><tr><td>user_id</td></tr><tr><td>101</td></tr><tr><td>102</td></tr></tbody></table><p><strong>基於相鄰日期差實現（排序版）</strong></p><p>整體實現比較簡單。</p><pre><code>-- SQL - 19
select user_id
from (
    select *, 
        dense_rank() over (partition by user_id order by dt) as dr
    from visit_log
) t1
where datediff(dt, date_add(dt, 1 - dr)) + 1 = 2
group by user_id;</code></pre><table><tbody><tr><td>user_id</td></tr><tr><td>101</td></tr><tr><td>102</td></tr></tbody></table><p><strong>基於連續活躍天數實現</strong></p><p>可以視作&nbsp;<strong>基於相鄰日期差實現（排序版）</strong>&nbsp;的衍生版本，該實現能獲取到更多信息，如連續活躍天數。</p><pre><code>-- SQL - 20
select user_id
from (
    select 
        *,
        -- 連續活躍天數
        count(distinct dt) 
            over (partition by user_id, cont) as cont_days
    from (
        select 
            *, 
            date_add(dt, 1 - dense_rank() 
                over (partition by user_id order by dt)) as cont
        from visit_log
    ) t1
) t2
where cont_days &gt;= 2
group by user_id;</code></pre><table><tbody><tr><td>user_id</td></tr><tr><td>101</td></tr><tr><td>102</td></tr></tbody></table><p><strong>基於連續活躍區間實現</strong></p><p>可以視作&nbsp;<strong>基於相鄰日期差實現（排序版）</strong>&nbsp;的衍生版本，該實現能獲取到更多信息，如連續活躍區間。</p><pre><code>-- SQL - 21
select user_id
from (
    select 
        user_id, cont, 
        -- 連續活躍區間
        min(dt) as cont_date_start, max(dt) as cont_date_end
    from (
        select 
            *, 
            date_add(dt, 1 - dense_rank() 
                over (partition by user_id order by dt)) as cont
        from visit_log
    ) t1
    group by user_id, cont
) t2
where datediff(cont_date_end, cont_date_start) + 1 &gt;= 2
group by user_id;</code></pre><table><tbody><tr><td>user_id</td></tr><tr><td>101</td></tr><tr><td>102</td></tr></tbody></table><span id="OSC_h4_17"></span><h4><strong>5.2 動態連續活躍統計</strong></h4><p><strong>場景描述</strong></p><p>現有用户訪問日誌表 visit_log ，每一行數據表示一條用户訪問日誌。</p><pre><code>-- SQL - 22
with visit_log as (
    select stack (
        6,
        '2024-01-01', '101', '湖北', '武漢', 'Android',
        '2024-01-01', '102', '湖南', '長沙', 'IOS',
        '2024-01-01', '103', '四川', '成都', 'Windows',
        '2024-01-02', '101', '湖北', '孝感', 'Mac',
        '2024-01-02', '102', '湖南', '邵陽', 'Android',
        '2024-01-03', '101', '湖北', '武漢', 'IOS'
    ) 
    -- 字段：日期，用户，省份，城市，設備類型
    as (dt, user_id, province, city, device_type)
)
select * from visit_log;</code></pre><p>如何獲取最長的 2 個連續活躍用户，輸出用户、最長連續活躍天數、最長連續活躍日期區間？</p><p>上述問題在分析連續性時，<strong>獲取連續性的結果不是且無法與固定的閾值作比較，而是各自以最長連續活躍作為動態閾值</strong>，此處歸類為&nbsp;<strong>動態連續活躍場景統計</strong>。</p><p><strong>SQL 實現</strong></p><p>基於&nbsp;<strong>普通連續活躍場景統計</strong>&nbsp;的思路進行擴展即可，此處直接給出最終 SQL ：</p><pre><code>-- SQL - 23
select
    user_id, 
    -- 最長連續活躍天數
    datediff(max(dt), min(dt)) + 1 as cont_days,
    -- 最長連續活躍日期區間
    min(dt) as cont_date_start, max(dt) as cont_date_end
from (
    select 
        *, 
        date_add(dt, 1 - dense_rank() 
            over (partition by user_id order by dt)) as cont
    from visit_log
) t1
group by user_id, cont
order by cont_days desc
limit 2;</code></pre><table><tbody><tr><td>user_id</td><td>cont_days</td><td>cont_date_start</td><td>cont_date_end</td></tr><tr><td>101</td><td>3</td><td>2024-01-01</td><td>2024-01-03</td></tr><tr><td>102</td><td>2</td><td>2024-01-01</td><td>2024-01-02</td></tr></tbody></table><span id="OSC_h3_18"></span><h3>六、擴展</h3><p>引申出更復雜的場景，是本篇文章前面章節內容的結合與變種。</p><span id="OSC_h4_19"></span><h4><strong>6.1 區間連續（最長子區間切分）</strong></h4><p><strong>場景描述</strong></p><p>現有用户掃描或連接 WiFi 記錄表 user_wifi_log ，每一行數據表示某時刻用户掃描或連接 WiFi 的日誌。</p><pre><code>-- SQL - 24
with user_wifi_log as (
    select stack (
        9,
        '2024-01-01 10:01:00', '101', 'cmcc-Starbucks', 'scan', -- 掃描
        '2024-01-01 10:02:00', '101', 'cmcc-Starbucks', 'scan',
        '2024-01-01 10:03:00', '101', 'cmcc-Starbucks', 'scan',
        '2024-01-01 10:04:00', '101', 'cmcc-Starbucks', 'conn', -- 連接
        '2024-01-01 10:05:00', '101', 'cmcc-Starbucks', 'conn',
        '2024-01-01 10:06:00', '101', 'cmcc-Starbucks', 'conn',
        '2024-01-01 11:01:00', '101', 'cmcc-Starbucks', 'conn',
        '2024-01-01 11:02:00', '101', 'cmcc-Starbucks', 'conn',
        '2024-01-01 11:03:00', '101', 'cmcc-Starbucks', 'conn'
    ) 
    -- 字段：時間，用户，WiFi，狀態（掃描、連接）
    as (time, user_id, wifi, status)
)
select * from user_wifi_log;</code></pre><p>現需要進行用户行為分析，如何<strong>劃分用户不同 WiFi 行為區間</strong>？滿足：</p><p>1）行為類型分為兩種：連接（scan）、掃描（conn）；</p><p>2）行為區間的定義為：相同行為類型，且相鄰兩次行為的時間差不超過 30 分鐘；</p><p>3）不同行為區間在滿足定義的情況下應取到最長；</p><table><tbody><tr><td>user_id</td><td>wifi</td><td>status</td><td>time_start</td><td>time_end</td><td>備註</td></tr><tr><td>101</td><td>cmcc-Starbucks</td><td>scan</td><td>2024-01-01 10:01:00</td><td>2024-01-01 10:03:00</td><td>用户掃描了 WiFi</td></tr><tr><td>101</td><td>cmcc-Starbucks</td><td>conn</td><td>2024-01-01 10:04:00</td><td>2024-01-01 10:06:00</td><td>用户連接了 WiFi</td></tr><tr><td>101</td><td>cmcc-Starbucks</td><td>conn</td><td>2024-01-01 11:01:00</td><td>2024-01-01 11:02:00</td><td>距離上次連接已經超過 30 分鐘，認為是一次新的連接行為</td></tr></tbody></table><p><br> 上述問題稍顯複雜，可視作&nbsp;<strong>動態連續活躍統計</strong>&nbsp;中介紹的&nbsp;<strong>最長連續活躍</strong>&nbsp;的變種。可以描述為&nbsp;<strong>結合連續性閾值與行為序列中的上下文信息，進行最長子區間的劃分</strong>&nbsp;的問題<strong>。</strong></p><p><strong>SQL 實現</strong></p><p>核心邏輯：以用户、WIFI 分組，結合連續性閾值與行為序列上下文信息，劃分行為區間。</p><p>詳細步驟：</p><p>1）以用户、WIFI 分組，在分組窗口內對數據按時間正序排序；2）依次遍歷分組窗口內相鄰兩條記錄，若兩條記錄之間的時間差超過 30 分鐘，或者兩條記錄的行為狀態（掃描態、連接態）發生變更，則以該臨界點劃分行為區間。直到遍歷所有記錄；</p><p>3）最終輸出結果：用户、WIFI、行為狀態（掃描態、連接態）、行為開始時間、行為結束時間；</p><pre><code>-- SQL - 25
select 
    user_id, 
    wifi,
    max(status) as status,
    min(time) as start_time, 
    max(time) as end_time
from (
    select *,
        max(if(lag_status is null or lag_time is null or status &lt;&gt; lag_status or datediff(time, lag_time, 'ss') &gt; 60 * 30, rn, null)) 
            over (partition by user_id, wifi order by time) as group_idx
    from (
        select *,
            row_number() over (partition by user_id, wifi order by time) as rn,
            lag(time, 1) over (partition by user_id, wifi order by time) as lag_time,
            lag(status, 1) over (partition by user_id, wifi order by time) as lag_status
        from user_wifi_log
    ) t1
) t2
group by user_id, wifi, group_idx
;</code></pre><table><tbody><tr><td>user_id</td><td>wifi</td><td>status</td><td>start_time</td><td>end_time</td></tr><tr><td>101</td><td>cmcc-Starbucks</td><td>scan</td><td>2024-01-01 10:01:00</td><td>2024-01-01 10:03:00</td></tr><tr><td>101</td><td>cmcc-Starbucks</td><td>conn</td><td>2024-01-01 10:04:00</td><td>2024-01-01 10:06:00</td></tr><tr><td>101</td><td>cmcc-Starbucks</td><td>conn</td><td>2024-01-01 11:01:00</td><td>2024-01-01 11:03:00</td></tr></tbody></table><p><br> 該案例中的連續性判別條件可以推廣到更多場景，例如基於日期差值、時間差值、枚舉類型、距離差值等作為連續性判別條件的數據場景。</p><span id="OSC_h3_20"></span><h3>結語</h3><p><strong>通過靈活的、散發性的數據處理思維，就可以用基礎的語法，解決複雜的數據場景</strong>&nbsp;是本篇文章貫穿全文的思想。文中針對數列生成、區間變換、排列組合、連續判別等常見的場景，給出了相對通用的解決方案，並結合實例進行了實際運用的講解。</p><p>本篇文章嘗試獨闢蹊徑，強調靈活的數據處理思維，希望能讓讀者覺得眼前一亮，更希望真的能給讀者產生幫助。同時畢竟個人能力有限，思路不一定是最優的，甚至可能出現錯誤，歡迎提出意見或建議。</p><p>作者 | 裏戈</p><blockquote><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fclick.aliyun.com%2Fm%2F1000373503%2F" target="_blank"><span style="color:#ff9900">點擊立即免費試用雲產品，開啓雲上實踐之旅！</span></a></strong></blockquote><p><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1360381%3Futm_content%3Dg_1000382602" target="_blank">原文鏈接</a></strong></p><p><strong>本文為阿里雲原創內容，未經允許不得轉載。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 02:18:10 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10139796</guid>
            <link>https://my.oschina.net/yunqi/blog/10139796</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[客服發送一條消息背後的技術和思考]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h1>一、引言</h1><p>在企業客服場景中，客服發送一條消息的背後，需要考慮網絡通信、前端展示、後端存儲以及安全性等多個方面的技術支持，單從前端層面來説，就需要考慮到消息的顯示、狀態更新、穩定傳輸以及極限操作消息不卡頓等場景，隨着 IM 系統的不斷更新迭代，已經實現了從外採到自研再到一站式全場景工作台的搭建，我們能夠很明顯地感知到客服對於 IM 的體驗要求越來越高了，因此客服發送一條消息背後所涉及的技術和思考也越來越重要。本文將探秘客服發送一條消息背後的技術和思考，幫助大家瞭解如何在 IM 聊天場景中提供高效、安全、可靠和良好的用户體驗。</p><h1>二、IM 聊天消息的重要性</h1><p>IM 聊天消息是客服和用户之間最快速、最直觀、最高效的雙向溝通方式之一。IM 聊天的重要性體現在以下幾個方面：</p><ul><li>即時響應：及時地解答用户諮詢的問題，更快捷的服務用户，提高用户滿意度。</li><li>個性化互動：可以根據用户的需求快速做出個性化迴應，從而更好地滿足用户需求。</li><li>數據處理和分析：通過對 IM 聊天消息的處理分析，可以洞察用户需求、用户行為，幫助改進服務質量。</li></ul><p>綜上，IM 聊天消息的重要性在於提高用户滿意度、提高客服作業效率，這也意味着 IM 消息的可靠、高效、安全尤為重要，接下來本文就從前端視角對客服發送一條消息背後的技術和思考進行詳細的講述。</p><h1>三、客服 IM 消息發展歷程</h1><p>以下是客服 IM 消息發展的歷程，列舉的都是核心技術專項的里程碑節點。 <img src="https://oscimg.oschina.net/oscnet/up-584d1aa46f5bc07e2c715235ac116ca64f0.jpg" alt="" referrerpolicy="no-referrer"></p><p>在這個過程中，我們積累了一定的經驗和技能，同時也遇到了各種各樣的問題和挑戰。比如：消息丟失、消息發送失敗、消息重複、消息亂序等等方面的問題，針對這些問題我們也都通過技術專項的方式去逐個解決並達到了預期效果，我們相信，隨着技術的不斷髮展和創新，我們可以更好地提供更加高效便捷的服務。</p><h1>四、技術和思考的細節</h1><p>站在用户/客服角度，發送消息不就是輸入消息後點擊回車鍵或點擊發送按鈕就完成了嗎，看似非常簡單，但是從開始輸入消息到對方收到消息這個過程實際上有非常強大的技術在高效、穩定支撐。我們客服 IM 消息鏈路會涉及到三個核心端口，發出方、IM 網關以及接收方。以下將以客服發送一條消息到 IM 網關這個過程簡單描述一下涉及到的技術點，反之用户側發送消息也是類似的。 <img src="https://oscimg.oschina.net/oscnet/up-b5cfea2555b27d0ea3e3bd134cd0efa18fe.jpg" alt="" referrerpolicy="no-referrer"></p><p>從上述流程圖中可以看到一條消息的旅程還是非常豐富的，當然其中有一些細節點還沒有完全列舉出來，例如：IM 網關的超時重推機制、前端的異常處理 (網絡異常、超時異常、重試無果等)。我們可以很清晰地看到當客服開始輸入消息的時候就開始進行通知對方正常輸入，觸發消息發送後需要進行消息體的創建、排序、去重檢測、網絡檢測、聊天列表渲染、推入超時重試隊列、放入消息攔截器中統一進行消息格式轉化併發送，到這裏只僅僅是完成了前端層面的發送工作而已，此時消息是否發送成功還是未知的，還需要監聽消息的發送結果，如果在一定時間未收到響應結果會進行第二次消息的重發，直到發送成功或到達最大重試次數就表示該消息的生命週期結束。一旦收到消息的響應結果就會對消息的狀態進行更新 (此時消息已完成了排序，不需要進行二次排序)，至此第一個環節就完成了處理，IM 網關到客户端也會有類似的處理過程。</p><p>縱觀整個消息發送以及接收鏈路，任何一個環節出現問題都會導致消息發送出現問題，就需要非常穩定可靠的技術手段進行保障，主要從以下幾個方面講解一下。</p><h2>消息的可靠性傳遞</h2><p>消息的可靠性傳遞確保了消息收發雙方信息的一致性。這也是我們為什麼把消息可靠性傳遞放在第一個進行講解。我們試想一下這樣一個場景，經常有消息丟失，客服頻繁反饋，每次都要投入研發資源去排查問題，這還是次要的，有可能因為消息的丟失導致用户體驗的急劇下降，這就得不償失了。所有消息的可靠性傳遞是非常有必要的，而且也是必須的。那麼何為可靠性傳遞？至少要滿足 3 個方面：</p><h3>1.1 消息的實時性</h3><p>我們使用 IM 最重要的一方面就是希望對方能夠實時接收到我們發送的消息並能夠給予回覆，這對於提升用户體驗尤為重要。如果不在乎實時性我們完全可以使用其他方式，例如郵件、寫信甚至飛鴿傳書…</p><p>一條消息發送給 IM 網關，網關大致需要經歷以下 5 個環節的處理：</p><ul><li>驗證消息：敏感詞驗證、風控送審 (同步審核)</li><li>消息的存儲：排序、去重驗證等</li><li>給發送消息方回覆一個 ACK 響應 (成功、失敗)</li><li>把消息發送給接收方，如果存在多端登錄的場景，還需要保障消息多端同步</li><li>超時重試、處理接收方返回的 ACK 等</li></ul><p>從消息的實時性的來説，沒有絕對的實時，只能儘量優化。核心的處理邏輯都在 IM 網關，無論是前端還是客户端，處理過程都是非常快的，都在毫秒級別。我們 IM 網關是 Go 語言開發的，併發處理的能力也是非常高的，所以整個閉合鏈路的耗時還是非常低的。 <img src="https://oscimg.oschina.net/oscnet/up-5099c14837901bd35052c87dcaa6bdc2893.jpg" alt="" referrerpolicy="no-referrer"></p><h3>1.2 消息的可靠性</h3><p>眾所周知，TCP 本身就是具有可靠性的，但是它只能保障傳輸層可靠，而應用層之間的可靠性並不能保證，我們後續會有針對性的專項文章進行發表，本次就不再贅述。</p><p>那我們該如何保障應用之間的可靠性呢? 可靠性的保障就是讓發送方知道接收方接收到了消息，這樣就表示消息成功傳遞了。我們再回頭看一下上面講述消息丟失的場景，消息丟失的問題也是我們在 IM 消息研發過程中遇到的一個讓人頭疼的問題，排查一個問題需要投入的技術資源是非常巨大的，需要涉及到 H5、IM 網關、服務端以及客户端，對於用户以及客服的使用體驗是非常差的。很簡單的一個場景，用户發了消息，客服沒有收到，沒有回覆用户，用户以為客服故意不回覆，會影響到用户的滿意度。</p><p>那這個問題該如何解決呢？大家可以看下<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkxNTE3ODU0NA%3D%3D%26mid%3D2247489429%26idx%3D1%26sn%3D0f7c0c2062c56abe6fb69944b6d48fa3%26chksm%3Dc16242caf615cbdc799cb6a073946a42bc4932dc9695e1f9b80f6afc0c8c1b768745614bb88f%26scene%3D21%23wechat_redirect" target="_blank">得物客服 IM 消息通信 SDK 自研之路</a>，其中有講解過，核心是參考 TCP 協議的 ACK 機制，實現一套基於業務層的 ACK 協議。這裏特別的要注意的是針對批量消息 (客服刷新會話、新會話進線等場景)，我們採用的是批量 ACK 機制，如果每一個消息都回復 ACK，成本會比較高。我們當初是通過一個 IM 架構升級技術專項協同各端完成了 IM 整體消息觸達實現 0 丟失，保證觸達，滿足 At least once（通過數據埋點驗證後得到 100% 的觸達率）。上線後該場景符合預期效果，相應的問題排查投入也減少了至少 70%+。</p><h3>1.3 消息的有序性</h3><p>在開發 IM 過程中有這樣一個非常常見的場景，用户問 A 問題後又問題了 B 問題，在客服側 B 問題排到 A 問題的前面，導致客服的回覆也出現了錯亂。當然這只是 IM 消息亂序的一種場景而已。諸如此類的還有很多。消息亂序產生的原因有很多，例如發送文件後再立即發送消息，文件需要前端先上傳到 OSS 獲取到 URL 後再發送給用户，上傳文件這個過程，用户以及客服都是可以發送消息的，這種場景處理不好就極易出現消息亂序。</p><p>不做 IM 是真不會想到客服操作的效率會有多高，之前在處理消息亂序問題的時候有遇到客服連續發送了 2 條消息，間隔只有 300 毫秒，這種高頻密集的操作場景在客服的工作場景下是持續性的。</p><p>看似一個亂序問題，不考慮清楚用户羣體、極限場景、臨界值等都不會徹底解決掉這個問題。</p><p>再説回我們客服 IM，我們是如何處理消息排序的呢？在整個開發過程也是比較曲折的，最終是以 IM 網關維護的 Seq 為準，然後返回到發送方，發送再根據消息序號進行排序，確保發送方和接收方消息的排序是一致的。前端處理的流程如下： <img src="https://oscimg.oschina.net/oscnet/up-f6983e465f7b364799f924e55d8345ea887.jpg" alt="" referrerpolicy="no-referrer"></p><h3>1.4 消息的冪等性</h3><p>説到消息的冪等性，我們要思考一個問題，為什麼會收到多條 (&gt;1) 相同的消息呢？肯定是發送方重複發送導致的，那在什麼場景下會重複發送？前面剛講過應用層的 ACK 機制，如果沒有收到對方的 ACK，會在超時時間到達後繼續重複發送直到最大重試次數。參考下面的截圖會更容易理解，只是模擬消息重試，真實場景中執行頻次肯定要比這個時間更久一些。 <img src="https://oscimg.oschina.net/oscnet/up-9fbc97a0f4430757c05319b8fe94d293131.jpg" alt="" referrerpolicy="no-referrer"></p><p>既然要保證消息的可靠性，消息的重複就是無法避免的。就有可能出現消息冪等性問題。那怎麼解決呢？我們是利用消息的 Message ID 做去重的，這裏會涉及到一個性能問題，排序、去重以及風控信息驗證等都需要一定的計算成本，如何保證處理過程系統不卡頓是一個核心問題。想要了解我們客服 IM 是如何做的，請繼續向下看。</p><h2>消息處理的卡頓優化策略</h2><p>我們來想一下為什麼會出現卡頓？什麼樣的場景才能夠被視為卡頓呢？我們一般都會説是因為在 16ms 內無法完成渲染導致的。那麼為什麼需要在 16ms 內完成呢？這裏我們就要了解一下刷新率（RefreshRate）與幀率（FrameRate）。</p><ul><li><strong>刷新率</strong>指的是屏幕每秒刷新的次數，是針對硬件而言的。瀏覽器刷新率都在 60Hz（屏幕每秒鐘刷新 60 次）。</li><li><strong>幀率</strong>是每秒繪製的幀數，是針對軟件而言的。通常只要幀率與刷新率保持一致，我們看到的畫面就是流暢的。所以幀率在 60FPS 時我們就不會感覺到卡。</li></ul><p>如果幀率為每秒鐘 60 幀，而屏幕刷新率為 30Hz，那麼就會出現屏幕上半部分還停留在上一幀的畫面，屏幕的下半部分渲染出來的就是下一幀的畫面，這種情況被稱為畫面撕裂。相反，如果幀率為每秒鐘 30 幀，屏幕刷新率為 60Hz，那麼就會出現相連兩幀顯示的是同一畫面，這就出現了卡頓。所以單方面的提升幀率或者刷新率是沒有意義的，需要兩者同時進行提升。瀏覽器都採用的 60Hz 的刷新率，為了使幀率也能達到 60FPS，那麼就要求在 16.67ms 內要完成一幀的繪製（1000ms/60Frame = 16.666ms / Frame)。</p><p>IM 消息處理中出現卡頓的情況非常常見，到一定的量級都是一個很難避免的問題，對比我們經常使用電腦，打開多個瀏覽器頁籤，稍微時間長點不關機重啓，也會感覺到卡頓，但對於 IM 消息處理還是有很多方式進行優化的，<strong>主要涉及以下幾方面的優化策略：</strong></p><h3>2.1 異步處理</h3><p>眾所周知 JS 是單線程的，所以採用異步處理機制可以將優先級低的任務推入異步任務隊列，讓出主線程給優先級高的任務。比如：客服在輸入完消息後需要立即顯示的聊天頁面，如果存在短暫的不顯示，會被認為是系統卡頓了，所以發送消息的優先級是高於接收消息的。我們對各場景任務優先級做了區分，低優先級的任務都通過異步的方式進行處理。</p><h3>2.2 分段加載</h3><p>這裏主要針對聊天消息列表，對於大量消息的會話處理，只渲染可視區域的消息降低瀏覽器的負擔，提升響應速度。列表優化的方案有很多。如下：</p><p><strong>方案 1：</strong> 使用定時器 setTimeout 來實現分批渲染，這種方式我們一般不推薦，因為在 setTimeout 中對 DOM 進行操作，必須要等到屏幕下次繪製時才能更新到屏幕上，如果兩者步調不一致，就可能導致中間某一幀的操作被跨越過去，而直接更新下一幀的元素，從而導致丟幀現象。</p><p><strong>方案 2：</strong> 採用 requestAnimationFrame，相比之下，requestAnimationFrame 的優勢還是非常明顯的，主要體現在<strong>以下幾個方面：</strong></p><ul><li>requestAnimationFrame 會把每一幀中的所有 DOM 操作集中起來，再一次重繪或迴流中就完成，並且重繪或迴流的時間間隔緊緊跟隨瀏覽器的刷新頻率。</li><li>在隱藏或不可見的元素中，requestAnimationFrame 將不會進行重繪或迴流，這當然就意味着更少的 CPU、GPU 和內存使用量。</li><li>requestAnimationFrame 是由瀏覽器專門為動畫提供的 API，在運行時瀏覽器會自動優化方法的調用，並且如果頁面不是激活狀態下的話，動畫會自動暫停，有效節省了 CPU 開銷。</li><li>與 setTimeout 相比，requestAnimationFrame 最大的優勢是<strong>由系統來決定回調函數的執行時機。</strong></li><li>requestAnimationFrame 的步伐跟着系統的刷新步伐走。它能保證回調函數在屏幕每一次的刷新間隔中只被執行一次，這樣就不會引起丟幀現象。</li></ul><p><strong>方案 3：</strong> 採用 IntersectionObserver，IntersectionObserver 接口 (從屬於 Intersection Observer API) 為開發者提供了一種可以異步監聽目標元素與其祖先或視窗 (viewport) 交叉狀態的手段。祖先元素與視窗 (viewport) 被稱為根 (root)。 <img src="https://oscimg.oschina.net/oscnet/up-d965531bd2f894fbcbc70fdb8be422da791.jpg" alt="" referrerpolicy="no-referrer"></p><p>可以看到，交叉了就是説明當前元素在視窗裏，當前就是可見的了。是代替監聽滾動加載的不錯方案。</p><p>當然還有其他方案，還是要根據實際的業務場景選擇合適的方案，IM 消息分段加載的難點在於消息的不定高 (多種不同類型的消息)，計算成本還是有一些昂貴的。所以優化還是要驗證一下臨界值的，有時候優化不一定會有效。</p><h3>2.3 消息遍歷</h3><p>上面我們講到消息排序、去重以及消息狀態更新等等，多個會話大量的聊天消息，如果處理不當，卡頓是必現的，可以先看一下我們優化之前的處理流程，採用的是第三方的 SDK，一堆 for 循環，消息量大一些基本卡住沒反應了。 <img src="https://oscimg.oschina.net/oscnet/up-3fed2d242eb5a6037ecf275fd18b342189f.jpg" alt="" referrerpolicy="no-referrer"></p><p>那我們是如何處理這個問題的呢？基於現有的業務場景重寫三方 SDK，將會話維護成獨立的實例，核心算法就是採用二分法。感興趣的同學可以看之前的這篇文章&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkxNTE3ODU0NA%3D%3D%26mid%3D2247489429%26idx%3D1%26sn%3D0f7c0c2062c56abe6fb69944b6d48fa3%26scene%3D21%23wechat_redirect" target="_blank">得物客服 IM 消息通信 SDK 自研之路</a>，講述得比較詳細。重寫了 IM SDK 之後，客服再也沒有反饋過聊天相關的卡頓，聊天首響提升了 20%，成果還是比較顯著的。</p><h2>消息安全方面的考慮</h2><p>在 IM 系統中，消息的安全性是非常重要，開發同學需要具備較強的安全意識，將安全融入到開發流程中，增強系統的安全性和健壯性。消息安全性方面的事情我們做了很多，這裏也不再詳細講解了。</p><h2>消息發送和接收的延遲</h2><p>消息發送和接收的延遲直接影響用户的使用體驗和溝通效率，在上面我們已經分析過一條消息的旅程，出現延遲的原因也比較好分析，主要有以下 4 點：</p><ul><li><strong>網絡延遲：</strong> IM 消息的發送和接收是以長鏈接的方式進行網絡傳輸的，而網絡傳輸過程中會產生一定的延遲。如果網絡延遲高，就會導致消息發送和接收較慢。</li><li><strong>系統負載：</strong> 客服在一對多的情況下，多個用户同時在線，系統需要處理大量的消息和請求，導致系統響應速度較慢，這會對客服的體驗造成影響。</li><li><strong>前端延遲：</strong> 需要經過本地消息隊列、緩存等處理，可能導致消息的延遲。</li><li><strong>消息編碼和解碼：</strong> 部分消息需要對數據進行編碼和解碼，也會消耗一定的時間，從而導致延遲。</li></ul><p>既然能分析出原因，我們就能對症下藥，可以通過一些優化策略來降低發送和接收的延遲，目前規劃從<strong>以下 2 個方面來進行優化：</strong></p><ul><li><p><strong>前端方面：</strong> 延遲主要在消息的處理和編解碼方面，目前我們 IM 消息的數據格式是 JSON，存在序列化和反序列化的過程，這裏我們會採用 ProtoBuf 替換 JSON，目前已完成了相關技術調研和測試驗證。我們簡單來看一下 ProtoBuf(Protocol Buffers) 和 JSON 處理耗時的對比：</p><p>編碼時間：ProtoBuf 的編碼時間比 JSON 快得多，因為 ProtoBuf 的編碼是二進制的，不需要進行編碼轉換以及無需進行冗餘類型的轉換。相對而言，JSON 的編碼時間較慢。</p><p>解碼時間：相比編碼，ProtoBuf 的解碼效率要稍微低一些。但是，由於 ProtoBuf 的優勢在數據量大、結構複雜的情況下更為明顯，對於小型數據解碼時，兩者的效率差異可能不太明顯。</p></li><li><p><strong>網絡延遲：</strong> 網絡延遲我們很難控制，但是可以通過降低消息傳輸體積進行相關優化，剛講了 Protobuf 替換 JSON，Protobuf 是二進制格式，比 JSON 格式更加緊湊，能夠使數據包大小大幅度減小，在網絡傳輸中能夠減少帶寬佔用和流量費用。在 IM 系統中，由於用户數量龐大，消息發送頻繁，在數據佔用和網絡帶寬方面是一個巨大的問題，使用 ProtoBuf 能夠顯著地減少網絡帶寬消耗，提高系統的性能。還有一方面就是消息壓縮，但是壓縮的深度和壓縮算法需要慎重選擇、驗證。</p></li></ul><p>所以使用 ProtoBuf 格式代替 JSON 格式基本可以解掉一大半延遲問題，也是接下來 IM 優化的一個方向。</p><h2>坐席體驗和交互的考慮</h2><p>説到坐席體驗和交互方面，我們還是積累了不少經驗的，不僅僅是 IM，體驗和交互是所有產品都無法繞開的一個話題，自從做 IM 以來，體驗可謂是鞭策我們不斷前進的動力，卡頓是一直環繞在我耳邊的一個話題。客服理解的卡頓和我們正常理解的卡頓還是有點不一樣的，前期我們也以為是系統卡住導致無法使用了，類似掉幀的場景，實際卻不是，接口請求慢了、有錯誤的 Tip 提示、頁面切換有短暫空白顯示、輸入消息回車後消息未立刻顯示到聊天頁面、圖片上傳的 Loading 提示等等，都會被歸為卡頓。針對這些方面我們也是不斷的進行職場調研、數據分析、優化，客服的滿意度提升到了 18%。可能在大家看來做了這麼久提升 18% 並不是一個比較好的數據，但是針對客服域，提升 18% 也是一個相對比較難逾越的數據了。主要的原因在 2 個方面：第一個方面是很多客服都是 3 個月以內入職的，對於我們做的一些功能優化對比體驗是無法感知或缺少功能使用對比的；第二個方面是很多一線客服都來自一線大廠的客服服務團隊。其實反過來想一下，這也是一種正向的驅動，至少我們每次調研都能收集到新的反饋，同更加成熟、優秀產品的體驗差距。</p><p>體驗不是一蹴而就的，不要想着一下子就做到位，一個優秀的用户體驗和交互設計需要始終與用户需求和反饋相結合，並不斷改進和完善。在實際設計和開發過程中，需要進行不斷的測試和優化，以確保系統的質量和可接受性。同時，需要與用户進行積極的溝通和反饋，以便更好地理解用户需求和意見，這一點我們之前是做的不夠好的，尤其是新版本的推廣，系統的易用性並未達到客服的期望，也是我們後期需要持續改進的一個方面。</p><p>體驗是以絕大數用户需求為核心的，不能僅僅為了一小部分用户而去犧牲其他用户的使用體驗，尤其不能因為某一個用户的反饋意見而做出過多的改變或者犧牲其他用户的利益。體驗優化過程的不妥協也是非常重要的策略，在體驗優化過程中，必須保持理性和客觀，根據用户調研和數據分析進行合理的權衡和決策，以實現最佳的用户體驗。</p><p>一些小細節的優化也可以起到事半功倍的效果，在 IM 系統中，一些細節的優化包括：及時的消息提示、清晰的消息展示、精確的消息發送時間等等。這些小細節的優化可以直接提高客服的使用效率和體驗，從而提高客服滿意度。IM 的體驗優化我們會一直做下去，有志者事竟成。</p><h1>五、後續規劃</h1><p>上述技術和思考的細節中有講到消息的可靠性傳遞、卡頓優化處理、安全性、效率以及體驗等，接下來的一段時間我們還是以這幾個方面為主線進行，持續優化、完善 IM 相關能力。主要考慮以下幾個方面的規劃：</p><ul><li><strong>體驗優化：</strong> 體驗是我們一如既往要做的事情，會持續挖掘視覺、交互等層面的優化點，從細節入手，比如：顏色搭配，按鍵選擇等，提供良好的坐席體驗。</li><li><strong>ProtoBuf 替換 JSON：</strong> 降低消息編碼時間、提升解碼效率、減少數據包體積、減少網絡帶寬消耗，提高系統的性能。</li><li><strong>消息壓縮：</strong> 尤其是針對歷史消息、批量消息，使用壓縮技術，可以有效的減少數據包的體積。</li><li><strong>功能擴展：</strong> 持續完善機器人消息類型，尤其是針對售前導購、坐席輔助。逐步支持消息引用、標記等功能。</li><li><strong>多語言能力支持：</strong> 雖然目前還沒有接入國際化業務，但在設計層面還是要具備快速擴展的能力。</li></ul><p>上述幾個方面我們會優先去做重要且緊急的技術改造，並不會一味的創新、優化，還是會以業務為主，緊緊圍繞業務和坐席體驗展開。</p><h1>六、總結</h1><p>客服發送一條消息在 IM 應用中看似簡單，背後需要考慮的技術細節點是很多的。首先，這需要考慮到消息的發送機制和可靠性。即使是一條簡單的消息，也需要經過一系列的加密、編碼、傳輸、安全合規等等處理才能被成功接收。</p><p>最重要的是要考慮到數據實時性的問題，各種極限場景下的操作，客服發送的消息需要被及時展示到聊天頁並傳輸給用户，客服同學在一對多的場景下工作，需要確保各會話消息不會出現不一致 (丟失、重複)，還有消息攔截和異常情況等問題。</p><p>因此，客服發送一條消息不僅需要技術能力和數據處理能力，還需要思考坐席體驗和數據實時性等方面的問題。開發過程中需要細緻入微地處理各種問題並持續優化，從而為客服提供一個穩定、流暢、安全、友好的 IM 應用。</p><p>參考文章：</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkxNTE3ODU0NA%3D%3D%26mid%3D2247489429%26idx%3D1%26sn%3D0f7c0c2062c56abe6fb69944b6d48fa3%26scene%3D21%23wechat_redirect" target="_blank">得物客服 IM 消息通信 SDK 自研之路</a></p><p>*文 / WWQ</p><p>本文屬得物技術原創，更多精彩文章請看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.dewu.com" target="_blank">得物技術官網</a></p><p>未經得物技術許可嚴禁轉載，否則依法追究法律責任！</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 10:41:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/10140300</guid>
            <link>https://my.oschina.net/u/5783135/blog/10140300</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[公益組織請願微軟延長 Windows 10 支持]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">美國公共利益研究組織 (PIRG) 近日向微軟 CEO 薩蒂亞·納德拉 (Satya Nadella) 發起一項<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpirg.org%2Ftake-action%2Ftell-microsoft-dont-leave-millions-of-computers-behind%2F" target="_blank">請願</a>，呼籲該公司重新考慮在 2025 年 10 月終止 Windows 10 支持的舉措。</span></p><p><span style="color:#000000">該組織認為，<span style="background-color:#ffffff">在目前使用 </span>Windows 10&nbsp;<span style="background-color:#ffffff">的 10 億台設備中，有超過 4 億台設備不滿足&nbsp;</span>Windows 11&nbsp;<span style="background-color:#ffffff">系統的升級要求。</span>Windows 10 生命週期的結束將意味着它們會失去微軟的支持，從而走向報廢<span style="background-color:#ffffff">；由此產生的巨量電子垃圾，也</span>與該公司在環保方面的立場相悖。</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">「微軟需要重新考慮這一決定，繼續為數億無法升級電腦的用户提供安全更新，這既是為了他們的經濟利益，也是為了保護環境。」</span></span></p><p><span style="color:#000000">請願書內容如下：</span></p><blockquote><p><span style="color:#000000">尊敬的微軟首席執行官薩蒂亞·納德拉，</span></p><p><span style="color:#000000">不要讓數億台電腦報廢。微軟決定終止對 Windows 10 的支持可能會導致垃圾電腦數量出現有史以來最大的增幅，並使微軟無法實現其可持續發展目標。新版操作系統對硬件的嚴格要求可能導致 40% 的在用電腦被拋棄。</span></p><p><span style="color:#000000">微軟決定停止為醫院、企業和家庭中數億台功能正常的電腦提供支持，這對那些希望自己的昂貴設備能夠經久耐用的客户來説，是一個不公平的交易。</span></p><p><span style="color:#000000">所有軟件都會有停止支持的時候，但如果會對我們的環境造成嚴重的負面影響，我們就不應該接受。</span></p></blockquote><p><img alt="" height="375" src="https://oscimg.oschina.net/oscnet/up-b960c9a173a51ef51f32995e73b51017405.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">微軟尚未發佈有關 Windows 10 支持終止的公開聲明，但外界猜測其可能複製 Windows 7 支持到期時的做法；允許<span style="background-color:#ffffff">專業版和企業版</span>有償延長支持最長三年，但家庭版除外。</span></p><p><span style="color:#000000">PIRG 的 Designed to Last 活動總監 Lucas Rockett Gutterman <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpirg.org%2Fmedia-center%2F20000-call-on-microsoft-to-save-400-million-pcs%2F" target="_blank">指出</a>，微軟過去曾擴展過對舊操作系統的支持。譬如 Windows XP 用户就收到了長達 13 年的安全更新，當其支持結束時，仍然可以在全球 30% 的計算機上運行。<span style="background-color:#ffffff">Windows 10 發佈</span>後&nbsp;，在很大程度上是「向後兼容」的，這意味着當微軟終止對其現有 Windows 系統的支持時，大多數舊計算機都能夠運行新操作系統。</span></p><p><span style="color:#000000">「考慮到微軟過去的這些行為，該公司強行過渡到 Windows 11 實在令人吃驚。這不僅對消費者不利，也對地球不利，因為這些過時的電腦將增加我們日益堆積的有毒電子垃圾。」</span></p><p><span style="color:#000000">也有人<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theregister.com%2F2023%2F10%2F27%2Fmicrosoft_petitioned_to_keep_windows%2F" target="_blank">提出</a>了或許可以轉用其他操作系統的想法。對此，Gutterman 則解釋稱，雖然開源社區一直都有在努力支持被其他廠商放棄的硬件，<span style="background-color:#ffffff">但對於學校和醫院等依賴僅適用於 Windows 的軟件的機構來説，這種轉變更為複雜。</span></span></p><p><span style="color:#000000">「<span style="background-color:#ffffff">對於微軟來説，推動這些機構處置和更換那些功能正常、且仍在幫助學生和患者的個人電腦是沒有意義的。最簡單的解決方案就是微軟擴展支持。</span>」</span></p><p><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpirg.org%2Ftake-action%2Ftell-microsoft-dont-leave-millions-of-computers-behind%2F" target="_blank">請願書地址</a></strong></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 09:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264497/pigc-microsoft-extends-windows-10-support</guid>
            <link>https://www.oschina.net/news/264497/pigc-microsoft-extends-windows-10-support</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[項目捐給了開源基金會，作者手上還剩了什麼？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#3498db"><strong>原標題：Apache 軟件基金會項目孵化過程中知識產權轉移的討論</strong></span></p><ul><li><p>作者：張偉玲，譚中意</p></li><li><p>審核：姜寧，張亮</p></li></ul><p style="margin-left:0px; margin-right:0px; text-align:start">作者簡介：</p><p style="color:#333333; text-align:start"><em>張偉玲，多年大型互聯網知識產權法律經驗，擅長商標、開源、著作權等知識產權法律領域的合規制度建設、 培訓和訴訟支持，在互聯網信息網絡傳播/合規/品牌等領域有豐富實戰經驗。</em></p></blockquote><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>討論背景：</strong></p><p style="color:#333333; text-align:start">自 2002 年 Apache Software Foundation（<strong>ASF</strong>）開始孵化項目以來，ASF 至今已經畢業了 200 多個頂級項目。在這些項目中，無論是個人捐贈還是企業捐贈的，都必須嚴格遵守其孵化流程和政策要求。尤其是近幾年來，越來越多的國人發起的開源項目進入 Apache 基金會孵化，並有不斷的項目畢業，Apache 開源基金會在國內的影響力越來越大。而它作為一個國際範圍內 host 項目最多的開源基金會，它的各種政策和流程也越來越為更多人熟悉。</p><p style="color:#333333; text-align:start"><img src="https://alc-beijing.github.io/alc-site/images/apache_incubator_IP_policy/apache_incubator_ip_1.png" referrerpolicy="no-referrer"></p><p style="color:#333333; text-align:start">而其中最重要的一個流程—項目孵化，在知識產權方面也有很獨特的政策。那麼，作為項目所有者的您，在面對這些政策和可能會遇到各種文件時，是否有過困惑「我簽署了什麼？項目的知識產權還是我的嗎？或者説我還剩些什麼權利呢？…」，為瞭解決這些困惑，本文會對您可能遇到的問題進行初步討論分析，當然本人是從公開發表的資料和文檔，並結合親身經歷的項目捐獻和孵化過程中總結，也有些認識不到位的地方，請多多討論，有問題可跟本人微信號<strong>weiweizhang0410</strong>討論，thanks。</p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>先説結論：</strong></p><p style="color:#333333; text-align:start">總的來説，捐獻項目給 Apache 基金會，Apache 基金會需要您的「版權授權 + 專利授權 + 商標轉讓」。</p><p style="color:#333333; text-align:start">知識產權即人們常説的 IP（Intellectual Property）,跟開源軟件相關的主要有如下三項：版權（即 Copyright），專利（即 Patent），商標（即 Trademark ）。根據 Apache 基金會的 IP 政策，個人或者公司捐獻項目給它，該項目的專利和版權必須授權給它，商標必須要轉讓給它。</p><p style="color:#333333; text-align:start">即它既要商標的所有權（owner），又要專利的使用授權，還要版權的使用授權。</p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>具體解釋：</strong></p><p style="color:#333333; text-align:start">開源項目要進入 Apache 基金會進行孵化，原有版權所有人必須要簽署如下兩個文件，一個是 SGA（Software Grant Agreement），另外一個是 CCLA/ICLA（公司或者個人貢獻協議 ICLA: Individual Contributor License Agreement，CCLA: Corporate Contributor License Agreement）。我們一起來看看這兩個文件的內容。</p><p style="color:#333333; text-align:start">先看看 SGA（Software Grant Agreement），以下是協議原文信息：<img src="https://alc-beijing.github.io/alc-site/images/apache_incubator_IP_policy/apache_incubator_IP_2.png" referrerpolicy="no-referrer"></p><p style="color:#333333; text-align:start">下面我們來仔細看下這篇文檔的重點部分。</p><p style="color:#333333; text-align:start"><em>「WHEREAS, Licensor owns or has sufficient rights to contribute the software source code and other related intellectual property as itemized on Exhibit A (「Software」) under the terms of this agreement to the Foundation for use within Foundation software development projects (「Projects」).</em></p><p style="color:#333333; text-align:start">首先，實務操作中需要簽署人必須有足夠的授權來貢獻代碼和相關的 IP。默認規則下該簽署人至少是該公司高級總監以上的職位。</p><p style="color:#333333; text-align:start">然後看關鍵的部分：<span>&nbsp;</span><em><strong>「Subject to the terms and conditions of this License, Licensor hereby grants to the Foundation:</strong></em></p><p style="color:#333333; text-align:start"><em><strong>a) a non-exclusive, worldwide, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, distribute and sublicense, internally and externally, the Software and such derivative works, in source code and object code form; and</strong></em></p><p style="color:#333333; text-align:start"><em><strong>b) a non-exclusive, worldwide, royalty-free, irrevocable patent license under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Software in source code and object code form. 「Licensed Patents」 mean patent claims owned by Licensor which are necessarily infringed by the use or sale of the Software alone.</strong></em></p><p style="color:#333333; text-align:start"><strong>許可人授予基金會如下權利:</strong></p><ul><li><p>a） 以源代碼和目標代碼的形式在全球範圍內複製、準備衍生作品、公開展示、公開表演、分發和再授權軟件及其衍生作品的非排他性、免版税、不可撤銷的版權許可；以及，</p></li><li><p>b） 非排他性的、全球範圍內的、免版税的、不可撤銷的專利許可證，根據許可專利以源代碼和目標代碼的形式獲得、使用、銷售、許諾銷售、進口和以其他方式轉讓該軟件。」</p></li></ul><p style="color:#333333; text-align:start">我們再看下 CCLA（Corporate Contributor License Agreement），原文相對較長，截取原文知識產權重點部分：</p><p style="color:#333333; text-align:start"><img src="https://alc-beijing.github.io/alc-site/images/apache_incubator_IP_policy/apache_incubator_IP_3.png" referrerpolicy="no-referrer"><img src="https://alc-beijing.github.io/alc-site/images/apache_incubator_IP_policy/apache_incubator_ip_4.png" referrerpolicy="no-referrer"></p><p style="color:#333333; text-align:start"><strong>簡單摘要如下：</strong></p><p style="color:#333333; text-align:start"><em>「感謝您對 Apache 軟件基金會（「基金會」）的關注。為了闡明由任何個人或實體提供的貢獻所授予的知識產權許可，基金會須具有由每個貢獻者簽署的「貢獻者許可協議」（CLA），以表明同意以下許可條款。該許可證是為了保護您作為貢獻者，以及保護基金會及其用户；它不會改變您將自己的貢獻用於任何其他目的的權利。</em><span>&nbsp;</span>。。。。</p><p style="color:#333333; text-align:start">2.授予版權許可。在遵守本協議前提下，授予接收者永久的，全球的，非獨佔的，免費的，免版税，不可撤銷的版權許可，以複製、公開展示、公開表演，再許可、分發您的作品以及此類的衍生作品。</p><p style="color:#333333; text-align:start">3.授予專利許可。在遵守本協議前提下，授予接收者永久的，全球的，非獨佔的，免費的，免版税，不可撤銷的專利許可（本節所述除外）獲得、使用，銷售，許諾銷售，進口和以其他方式轉讓作品。。。</p><p style="color:#333333; text-align:start">綜上所述，作為項目協議來説，這份兩份許可是較簡短的，但是從其內容來看卻已經足以明晰 ASF 的需求和項目所有者的義務： 項目所有者作為軟件權利人，需要授予 ASF 兩項權利，即：版權和專利權。 也就是説在這個階段，ASF 所需要的是您的版權和專利的授權，是在全球範圍的 ASF 可以免費複製、分發、再授權等的權利。</p><p style="color:#333333; text-align:start">根據 ASF 孵化政策，項目畢業前需轉讓項目商標，該審核一般由 ASF 品牌管理負責部門進行審批，在該階段審批，一般是出於若畢業後再更名，會需要來自技術團隊的大量支持，因此，從 ASF 角度會要求儘早提起商標的轉讓審核。</p><p style="color:#333333; text-align:start">經過上述初步分析來看，無論是簽署的協議文件，還是孵化過程中的商標轉讓義務，ASF 未要求項目所有者對於版權和專利的所有權的轉讓，作為項目所有者需要承擔的義務主要為：版權授權 + 專利授權 + 商標轉讓。</p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>發版説明：</strong></p><p style="color:#333333; text-align:start">可能有的同學要問，既然捐獻過程中沒有發生版權的轉移，但是為什麼 Apache 畢業項目的 Copyright Owner 都是 Apache Foundation 呢，例如看 apache kafka（這是 linkedin 捐獻給 Apache 基金會的項目），每個源碼文件的 license header 都指向 Notice 文件。https://github.com/apache/kafka/blob/trunk/NOTICE</p><pre><code>Apache Kafka
Copyright 2020 The Apache Software Foundation.

This product includes software developed at
The Apache Software Foundation (https://www.apache.org/).
</code></pre><p style="color:#333333; text-align:start">再看 apache beam 項目（這是 google 捐獻給 apache 基金會的項目），每個源碼文件的 license header 都指向 notice 文件，<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fbeam%2Fblob%2Fmaster%2FNOTICE" rel="nofollow" target="_blank">https://github.com/apache/beam/blob/master/NOTICE</a><span>&nbsp;</span>文件內容如下：</p><pre><code>Apache Beam
Copyright 2016-2018 The Apache Software Foundation

This product includes software developed at
The Apache Software Foundation (http://www.apache.org/).
</code></pre><p style="color:#333333; text-align:start">那是因為按照 Apache 基金會發版的要求，每個項目在發佈軟件版本的時候，是需要把源碼中的每個文件的頭部都加上 Apache 基金會指定的 License Header，而這個 License Header 的內容統一指向該項目的 NOTICE 文件。（當然如果包含了其他第三方開源代碼，需要按照該開源項目許可證的要求，在 Header 上保留源作者的版權申明的，詳見 https://www.apache.org/legal/src-headers.html#3party。）</p><pre><code>/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0

 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
</code></pre><p style="color:#333333; text-align:start">而該 NOTICE 文件一般內容都是指明當前的 Copyright Owner 是 Apache 基金會。但是在該 NOTICE 文件中，是可以保留一些之前版本的 Copyright Owner 的聲明的。 例如 Netbeans 這個項目，它最早的 Owner 是 Sun Microsystem，之後 Sun 被 Oracle 收購後，Copyright Owner 變成 Oracle，而之後 Oracle 把這個項目捐獻給 Apache 基金會。為了保護各個 Owner 的知識產權，把各個時期的 Copyright Owner 都列了出來，所以現在的內容 https://github.com/apache/netbeans/blob/master/NOTICE 如下：</p><pre><code>Apache Netbeans
Copyright 2017-2020 The Apache Software Foundation

This product includes software developed at
The Apache Software Foundation (http://www.apache.org/).

The code is based on NetBeans, that has been kindly donated to the Apache
Software Foundation by Oracle.

The code was Copyright 1997-2016 Oracle and/or its affiliates.  The Initial
Developer of the Original Software was Sun Microsystems, Inc. Portions
Copyright 1997-2006 Sun Microsystems, Inc.
</code></pre><p style="color:#333333; text-align:start">從上面的文件中能看出，該文件的 Copyright 按照時間列出了前後幾個，1997-2006 為 Sun Microsystems，1997-2016 為 Oracle，2017-2020 為 Apache foundation。</p><p style="color:#333333; text-align:start">我們追溯 ASF 在 2004 年的董事會記錄，發現，上述操作是基金會為瞭解決「用户在向 ASF 提供授權時，ASF 文件中版權聲明卻歸他人持有人時的不一致情況」，根據董事會方案： 「版權者的首選處理方式是刪除此類聲明，或將其放在單獨的位置歸檔，以包含在每個項目的 COPYRIGHT 文件中，或在貢獻中包含基金會的書面許可，以進行通知的刪除或重新安置；被許可給 ASF 的文件應有版權聲明，並進行適當修改，以反映貢獻年份和原始發行的任何後續年份。」</p><p style="color:#333333; text-align:start">因此，作為項目所有人的版權信息，有的會在 NOTICE 部分予以體現。但是 Apache 的發版和畢業政策都會約定最新版本的 Copyright Owner 聲明是 Apache 基金會，雖然可以保留之前版本的 Copyright 説明。只有統一被授權方均為 Apache 基金會，該軟件的用户基於對 Apache 基金會的品牌和信心，才會持續在該項目上進行投入，不擔心出現該軟件的主導公司未來的某一天把該軟件閉源的情況。因為即使出現該軟件主導方不再繼續投入，或者另起爐灶的情況，Apache 的知識產權制度保證了還有社區的其他人在繼續維護。而該軟件最新版本的 Copyright Owner 是 Apache 基金會，則在法律上減少了該社區在繼續維護上的知識產權糾紛。</p><p style="color:#333333; text-align:start">這是 Apache 開源基金會精心的知識產權政策的設計，為了保證它旗下的項目是一個可信賴的產品，因為知識產權問題已經理清，持續維護的問題也已經解決，所以 Apache 的項目才會如此受到歡迎，所以才會有更多的公司或者個人把項目捐獻給 Apache 基金會。</p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>總結：</strong></p><p style="color:#333333; text-align:start">綜合上面的説明來看，當有新的項目需要經 ASF 孵化畢業，作為項目所有人需要承擔的義務主要在於版權授權、專利授權和商標轉讓，版權原始權利並未轉讓，因此，在項目的實際操作中請記得根據 ASF 的官方格式保留自己的權利聲明。 本文主要是基於實踐操作和 ASF 官方規定作出的一些討論，在您具體項目確定孵化或捐贈之前，請一定與您的律師進行個案的綜合評估以保障您的權益哦。當然也歡迎微信聯繫跟本人共同溝通討論。</p><p style="margin-left:0px; margin-right:0px; text-align:start">參考資料：</p><ul><li><p>ASF Contributor agreement<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.apache.org%2Flicenses%2Fcontributor-agreements.html" rel="nofollow" target="_blank">http://www.apache.org/licenses/contributor-agreements.html</a></p></li><li><p>ASF SGA template<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.apache.org%2Flicenses%2Fsoftware-grant-template.pdf" rel="nofollow" target="_blank">http://www.apache.org/licenses/software-grant-template.pdf</a></p></li><li><p>ASF CCLA<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.apache.org%2Flicenses%2Fcla-corporate.pdf" rel="nofollow" target="_blank">http://www.apache.org/licenses/cla-corporate.pdf</a></p></li><li><p>Apache 文件頭説明<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.apache.org%2Flegal%2Fsrc-headers.html" rel="nofollow" target="_blank">https://www.apache.org/legal/src-headers.html</a></p></li><li><p>ASF 2004 Board meeting 記錄<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.apache.org%2Ffoundation%2Frecords%2Fminutes%2F2004%2Fboard_minutes_2004_11_14.txt" rel="nofollow" target="_blank">https://www.apache.org/foundation/records/minutes/2004/board_minutes_2004_11_14.txt</a></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 09:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/oscpyaqxylk/blog/10140275</guid>
            <link>https://my.oschina.net/oscpyaqxylk/blog/10140275</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[優惠券 10 幾萬元，中國首款商用可重構 5G 頻射收發芯片上架淘寶]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>近日，國資委淘寶店鋪「國資小新」上架了一款售價為 999999 元的硬核商品 ——</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0c0dfda1faab2057d6c1cd71a911022e482.png" referrerpolicy="no-referrer"></p><p>根據商品圖介紹，該款芯片名為「破風 8676」，是「中國首款商用可重構 5G 頻射收發芯片」，定價 999999 元人民幣。這款芯片因獨特的用途和「硬核」的定價被網友戲稱為「雙十一」期間最「硬核」的國貨。</p><p>報道稱，該芯片由中國移動研究院自主研發。產品介紹信息顯示，「破風 8676」可重構 5G 射頻收發芯片支持 1.7GHZ~6GHz 頻段範圍，能夠適配全球主流 4/5G 頻段、WiFi 及國內車聯網頻段：支持 2 個射頻通道，通道帶寬 200MHz；集成 DPD （數字預失真） 、CFR （削峯） 、高階 FIR （有限長單位衝激響應）濾波等功能。</p><p>公開信息顯示，上架這款芯片的店鋪「國資小新」由國務院國有資產監督管理委員會下屬機構負責運營。該賬號店鋪內還上架了由中國航發研製的「太行 110」重型燃氣輪機、由中國鐵建研製的全球最大豎井掘進機、航空工業集團研製直-20 直升機以及中核集團建設的全球首個陸上小型模塊化反應堆等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d3dff2bf8551179267c8ac2ee3cc6613cf1.png" referrerpolicy="no-referrer"></p><p>和「破風 8676」一樣，店鋪將上述產品均定價為 999999 元，並提示消費者該商品「僅展示可加購勿拍」。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 07:41:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264470</guid>
            <link>https://www.oschina.net/news/264470</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[深秋，寒露：是時候和 Zadig 説再見了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank"><img alt="" src="https://oscimg.oschina.net/oscnet/up-672c752071cec6bcdf28b3468d5bde60d1a.png" referrerpolicy="no-referrer"></a></p><div><div style="text-align:center"><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank">閲讀原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig">Zadig 在 Gitee</a></p><p><strong>推薦閲讀：</strong><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490415%26idx%3D1%26sn%3D1914c7fd25aac5d33b98663571bbb744%26chksm%3Dcfb457cff8c3ded9c02809aad88012fa802eac55222eebe70b8c637ca2c86a101045aa81e73a%26scene%3D21%23wechat_redirect" target="_blank">是時候和 Jenkins 説再見了</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank">Zadig vs. Jenkins 詳細比對：時代的選擇與開發者之選</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247489682%26idx%3D1%26sn%3Df4ac5ceb38547542061477a45d8dc86d%26chksm%3Dcfb45432f8c3dd24b727e0fb6db276b2d63b2751933e63a25b00b9d9fac2dd68efbd2cbd3863%26scene%3D21%23wechat_redirect" target="_blank">平台工程和 AI 時代的新 10 億開發者</a></p></div><div style="text-align:center">
   2023 年 11 月 1 日 
 </div><div style="text-align:center">
   秋風起，露成霜，正是一年最美時 
 </div><div style="text-align:center">
   Zadig 團隊踏入了 
 </div><div style="text-align:center">
   創業的第五個年頭 
 </div><div style="text-align:center">
   開源的第 888 天 
 </div><div style="text-align:center">
   然而今天 
 </div><div style="text-align:center">
   我們要向 Zadig 
 </div><div style="text-align:center">
   説再見了 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   深秋外象趨冷 
 </div><div style="text-align:center">
   實則萬物蟄伏 
 </div><div style="text-align:center">
   在孕育着新的生機 
 </div><div style="text-align:center">
   今天，我們向 Zadig 1.0 告別 
 </div><div style="text-align:center"><span style="color:#fd2968"><strong>迎來全新的 Zadig 2.0!</strong></span></div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   回顧開源的這兩年多時間裏 
 </div><div style="text-align:center">
   Zadig 1.0 已完成了 2 萬 6 千多次的企業下載 
 </div><div style="text-align:center">
   發佈了 21 個開源版本，10 個企業版本 
 </div><div style="text-align:center">
   在 2 千多家企業和團隊深度使用 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   我們創作了 157 篇原創技術和產品文章 
 </div><div style="text-align:center">
   製作了 52 個獨創的短視頻 
 </div><div style="text-align:center">
   與 100 多位國內外商業、技術和產品領域的同仁夥伴建立了深厚的鏈接 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   今天，Zadig 已不再是嬰兒 
 </div><div style="text-align:center">
   是一個堅定自信的少年 
 </div><div style="text-align:center">
   走進數千家企業和團隊的日常工作中 
 </div><div style="text-align:center">
   讓他們的工作更加高效愉悦 
 </div><div style="text-align:center">
   這段旅程，Zadig 背後的團隊和社區一起 
 </div><div style="text-align:center">
   合作共創 
 </div><div style="text-align:center">
   品味挫折 
 </div><div style="text-align:center">
   分享喜悦 
 </div><div style="text-align:center">
   追逐自由 
 </div></div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-fbb18b0ecc053068d166ea1f637149f273f.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-e94bae5f521bce7e3f5326d76218df7912c.png" referrerpolicy="no-referrer"></p><div><div style="text-align:center">
   今天，2023 年 11 月 1 日 
 </div><div style="text-align:center">
   我們團隊決定再度邁出一大步 
 </div><div style="text-align:center">
   正式宣佈： 
 </div><div style="text-align:center">
   開源 Zadig 與，企業版 ZadigX 產品合併！ 
 </div><div style="text-align:center">
   並全面啓用企業版功能，提供一鍵試用 
 </div><div style="text-align:center">
   與此同時，我們做出了重大的決定 
 </div><div style="text-align:center">
   全部開放服務端源代碼 
 </div><div style="text-align:center">
   接下來我們還將發佈嶄新的文檔站 
 </div><div style="text-align:center">
   並推出更加易用的新手在線教程 
 </div></div><span id="OSC_h1_1"></span><h1><span style="color:#fd2968"><em><strong>01</strong></em><strong>為何做出這一選擇？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-e6678f7e349d8523888cb8b7d3e0659b69a.png" referrerpolicy="no-referrer"></strong></p><div><div style="text-align:center">
   首先，我們希望通過更開放的方式 
 </div><div style="text-align:center">
   為這個不平凡的時代注入信心 
 </div><div style="text-align:center">
   在過去的三年中，我們共同經歷了許多挑戰 
 </div><div style="text-align:center">
   包括疫情、經濟動盪，資本衰退、互聯網紅利時代的結束，AI 時代的到來 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   其次，我們希望通過這次開放性嘗試，帶給每位 IT 從業者更多力量！ 
 </div><div style="text-align:center">
   開源 2 年半以來，社區裏的每個人，不論是 80 後、90 後還是 00 後 
 </div><div style="text-align:center">
   都經歷了前所未有的技術和經濟週期 
 </div><div style="text-align:center">
   似乎沒有人準備好，但這些挑戰都如期而至： 
 </div><div style="text-align:center">
   互聯網大規模的裁員和失業潮影響了我們每個人和每個家庭 
 </div><div style="text-align:center">
   「IT 行業的未來在哪裏？ 
 </div><div style="text-align:center">
   IT 人的未來在何方？ 
 </div><div style="text-align:center">
   什麼是時代需要的創新？ 
 </div><div style="text-align:center">
   什麼是適閤中國特色的 IT 創新之路？ 
 </div><div style="text-align:center">
   如何用技術讓這個世界更美好？」 
 </div></div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-7643c8b8c38bf97523b3e001c3806795bac.png" referrerpolicy="no-referrer"></p><p>作為 Zadig 的創始人，我會經常思考這些問題。顯然並沒有標準答案，有一點可以肯定：真正的創新是思想的進步和對他人帶來的積極影響。其實，開源代碼從來不是核心資產，我們希望用更開放的心態，和社區、用户、客户的小夥伴們更為緊密的配合，找到最佳的姿勢幫助到最需要的人，與同行者一起面對每一次成長和變化，直面每一次恐懼和不安。</p><p>同時，通過這次版本發佈和源碼開放，我們希望能夠讓更多的開發者看到 Zadig 的企業級全部功能，為希望成為客户的用户提供更為簡單的升級方式，從根本上提供更多安全感。通過新版本 Zadig，企業客户可以一鍵輸入試用授權，快速實驗 Zadig 專業版能力，企業客户更放心地嘗試新技術和新產品，助力各個行業、產業 IT 的數字化升級。</p><p>作為軟件交付和研發鏈路中重要的連接者，我們希望通過這次 Zadig V2.0.0 的開源和版本發佈，與同行的基礎軟件開發者們一起嘗試新模式，為建立新的開源商業秩序開一個頭。</p><span id="OSC_h1_2"></span><h1><span style="color:#fd2968"><em>02&nbsp;&nbsp;</em><strong>Zadig 產品具體有哪些變化？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-a6a559045246e08f1857b0e8666bab21df8.png" referrerpolicy="no-referrer"></strong></p><p>從源代碼層面上，本次產品合併以開源 Zadig v1.18.0（最新版） 為基礎，合併了原 ZadigX v1.8.0（即企業版）全部新功能代碼，統稱為 Zadig，產品版本正式定義為 Zadig v2.0.0，同時服務端代碼在 GitHub 上全部開源，產品功能差異通過授權區分基礎版和專業版。</p><p>對於已經在大規模使用 Zadig 的小夥伴，如果期待了解和親自體驗專業版功能，可以在平滑升級後免費激活並體驗專業版功能長達 30 天，到期後專業版產生的數據不刪除，原有基礎版功能仍可正常使用。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-d6ad9eba6f9b41f1d391901be2fd3ae39c0.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_3"></span><h1><span style="color:#fd2968"><em>03&nbsp;&nbsp;</em><strong>對現有用户有哪些影響？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-91c5dba9d5f03113d993ebe2fa94c7638cd.png" referrerpolicy="no-referrer"></strong></p><p>對於社區開源用户而言，將在原有開源基礎功能上進一步獲得更多企業級功能，包括環境管理睡眠進一步做資源成本的削減，同時支持服務級測試管理、自定義工作流也一次性開放了大量企業內置最佳實踐模板。同時 Zadig v2.0.0 在過去 V1.x 架構的基礎上架構的基礎上改進了易用性和性能，優化了安全細節，顯著提高了工作流並行和複雜場景的執行效率，效率提升高達 50%，Zadig 的資源運行成本也降低了近 30%。在之後迭代中，用户也將持續獲得產品底層能力的可靠性，這些更新將幫助到更多企業，提升開發測試階段的雲原生持續交付能力，為開發者提供更出色的體驗。</p><p>對於企業客户，我們用 ZadigX 品牌代表包含企業級功能和專業服務的解決方案，"X"代表為企業客户提供更高質量的服務和保障，根據企業的具體難點和需求，接下來我們會面向企業推出一系列 DevOps 專家培訓、DevOps 效能提升、雲原生轉型、IT 數字化升級等企業級解決方案。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-8c8a7c1737a91a1e0f819e9dcb9a3c82b9c.png" referrerpolicy="no-referrer"></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-5b2c672b70e514e6133d7b885270d5fc71c.png" referrerpolicy="no-referrer"></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank">閲讀原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig">Zadig 在 Gitee</a></p><p><strong>推薦閲讀</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490415%26idx%3D1%26sn%3D1914c7fd25aac5d33b98663571bbb744%26chksm%3Dcfb457cff8c3ded9c02809aad88012fa802eac55222eebe70b8c637ca2c86a101045aa81e73a%26scene%3D21%23wechat_redirect" target="_blank">是時候和 Jenkins 説再見了</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank">Zadig vs. Jenkins 詳細比對：時代的選擇與開發者之選</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247489682%26idx%3D1%26sn%3Df4ac5ceb38547542061477a45d8dc86d%26chksm%3Dcfb45432f8c3dd24b727e0fb6db276b2d63b2751933e63a25b00b9d9fac2dd68efbd2cbd3863%26scene%3D21%23wechat_redirect" target="_blank">平台工程和 AI 時代的新 10 億開發者</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 07:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/koderover/blog/10140233</guid>
            <link>https://my.oschina.net/koderover/blog/10140233</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[阿里雲推出 AI 編碼助手：通義靈碼]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">阿里雲推出了一款基於通義大模型的智能編碼輔助工具 —— <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftongyi.aliyun.com%2Flingma%2F" target="_blank">通義靈碼</a>，提供行級/函數級實時續寫、自然語言生成代碼、單元測試生成、代碼註釋生成、代碼解釋、研發智能問答、異常報錯排查等能力，並針對阿里雲 SDK/OpenAPI 的使用場景調優，助力開發者高效、流暢的編碼。</span></p><p><span style="color:#000000">根據官網介紹，通義靈碼兼容 Visual Studio Code、JetBrains IDEs 等主流 IDE；且支持 Java、Python、Go、C/C++、JavaScript、TypeScript、PHP、Ruby、Rust、Scala 等主流編程語言。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>核心場景</strong></span></h4><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代碼智能生成</strong></span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000">經過海量優秀開源代碼數據訓練，可根據當前代碼文件及跨文件的上下文，為你生成行級/函數級代碼、單元測試、代碼註釋等。沉浸式編碼心流，秒級生成速度，讓你更專注在技術設計，高質高效地完成編碼工作。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>研發智能問答</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">基於海量研發文檔、產品文檔、通用研發知識、阿里雲的雲服務文檔和 SDK/OpenAPI 文檔等進行問答訓練，為你答疑解惑，助你輕鬆解決研發問題。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>產品優勢</strong></span></h4><ul style="margin-left:0; margin-right:0"><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>跨文件感知讓代碼生成更貼合業務場景：</strong>客户端和模型層同步優化針對代碼跨文件上下文感知能力，生成代碼更加貼合當前代碼庫的業務場景。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>阿里雲服務使用場景友好：</strong>專門針對阿里雲的雲服務使用、SDK/OpenAPI 的使用等場景調優，編碼時能夠更加便捷地使用阿里雲服務；在對阿里雲使用有疑問時，智能編碼助手的回答也將更加有效。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>適配多 IDE 的原生設計，符合開發者使用習慣：</strong>適配 IDE 原生主題、交互模式，讓開發者感受到 IDE 原生的視覺和交互體驗，更符合開發者使用習慣。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>研發問答、文檔/代碼搜索能力，打造沉浸式編碼：</strong>無需切換工具，IDE 客户端內即可滿足開發者編碼場景中的技術資料檢索、技術難題解答的訴求，打造開發者沉浸式編碼體驗。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>雙模引擎，自由切換：</strong>支持極速本地模型、雲端大模型兩種代碼補全模型，支持一鍵切換，滿足不同網絡環境、不同補全強度的場景訴求。</span></p></li></ul><h2 style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>功能介紹</strong></span></h2><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>行級/函數級實時續寫</strong></span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000">根據當前語法和跨文件的代碼上下文，實時生成行、函數建議代碼。</span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000"><img alt="" height="182" src="https://oscimg.oschina.net/oscnet/up-145ecbcb5413f83c4f6512faeb7572d39ba.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>自然語言生成代碼</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">通過自然語言描述你想要的功能，可直接在編輯器區生成代碼，編碼心流不間斷。</span></p><p><span style="color:#000000"><img alt="" height="186" src="https://oscimg.oschina.net/oscnet/up-515b87e9afaf2bfb1f9200538f114663d20.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>單元測試生成</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">支持根據 JUnit、Mockito、Spring Test、unit test、pytest 等框架生成單元測試。</span></p><p><span style="color:#000000"><img alt="" height="198" src="https://oscimg.oschina.net/oscnet/up-6512237992e15393d3abbc2c8e3c77d4063.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代碼註釋生成</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">一鍵生成方法註釋及行間註釋，節省你寫代碼註釋的時間，並能夠有效提升代碼可讀性。</span></p><p><span style="color:#000000"><img alt="" height="192" src="https://oscimg.oschina.net/oscnet/up-bd96048c8e3e6d01aa66c1136d8ca7ff355.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代碼解釋</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">支持 30 多種語言的識別，選中代碼後可自動識別編程語言並生成代碼解釋。跨越語言的邊界，讓你閲讀代碼更高效。</span></p><p><span style="color:#000000"><img alt="" height="154" src="https://oscimg.oschina.net/oscnet/up-615f625c27c7e8afe87ad83e1e7df085c76.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>研發領域自由問答</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">遇到編碼疑問、技術難題時，一鍵喚起通義靈碼，無需離開 IDE 客户端，即可快速獲得答案和解決思路。聚焦研發領域知識的問答，幫助開發者快速解決問題。</span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><img alt="" height="214" src="https://oscimg.oschina.net/oscnet/up-70413ee56236fdc009f429692be9593d05b.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>異常報錯智能排查（Java）</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">當運行出現異常報錯時，一鍵啓動報錯排查的智能答疑，可結合運行代碼、異常堆棧等報錯上下文，快速給出排查思路或修復建議代碼。</span></p><p><span style="color:#000000"><img alt="" height="309" src="https://oscimg.oschina.net/oscnet/up-87d6c9327ffeb245c28f22c1c979fae8172.png" width="500" referrerpolicy="no-referrer"></span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>支持 IDE 及操作系統</strong></span></h4><ul style="margin-left:0; margin-right:0"><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">Windows 7 及以上、macOS、Linux</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">JetBrains IDEs （IntelliJ IDEA、PyCharm、GoLand、WebStorm 等）2020.3 及以上</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">Visual Studio Code 1.75.1 及以上</span></p></li></ul><p><span style="color:#000000">目前，通義靈碼已面向所有開發者開放公測，各大 IDE 插件市場均已上線。</span></p><p><span style="color:#000000">更多詳情<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftongyi.aliyun.com%2Flingma%2F" target="_blank">可查看官網</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 06:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264459</guid>
            <link>https://www.oschina.net/news/264459</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 開源藍心大模型-7B：70 億參數、適閤中國開發者]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在 2023 vivo 開發者大會上，vivo 宣佈開源 70 億參數級的藍心大模型-7B，以及對應的微調框架。據稱是行業首家開源大模型的手機廠商。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-27161d355f59c839fc4c9b6bb433e37dff3.png" referrerpolicy="no-referrer"></p><p>vivo 介紹道，他們提供<strong>藍心大模型開發套件 BlueKit</strong>，讓開發者不必考慮使用成本，專注於創新產品體驗。此外，vivo 還推出藍心開發者激勵計劃，<strong>提供一億元資源支持，包含技術、運營、品牌三大方面。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-93548b2298b63f816adaa7f7c40b07b00f0.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0c711a4b9bd565a2eb78daee566e4475c80.png" referrerpolicy="no-referrer"></p><hr><p>藍心大模型-7B 是 vivo 自研通用大模型矩陣中的其中一款。</p><p><img height="646" src="https://static.oschina.net/uploads/space/2023/1101/143959_y0Ws_2720166.png" width="1834" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1101/144435_2CXR_2720166.png" referrerpolicy="no-referrer"></p><p>整體如下：</p><ul><li><p>1B：端側大模型</p></li><li><p>7B：端雲兩用模型（開源）</p></li><li><p>70B：雲端主力模型</p></li><li><p>130B：雲端大模型</p></li><li><p>175B：雲端大模型</p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 06:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264455</guid>
            <link>https://www.oschina.net/news/264455</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Incus 0.2 發佈，系統容器和虛擬機管理器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 是一個現代、安全且強大的系統容器和虛擬機管理器，它為在容器或虛擬機內運行和管理完整的 Linux 系統提供了統一的體驗。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 以&nbsp;C</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>umulonimbus incus 或 anvil cloud&nbsp;<span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>命名，是 Canonical LXD 的社區分支。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>該分叉是為了迴應&nbsp;<a href="https://www.oschina.net/news/248011/lxd-under-canonical">Canonical&nbsp;從 Linux<span>&nbsp;</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><a href="https://www.oschina.net/news/248011/lxd-under-canonical">Containers community&nbsp;</a><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><a href="https://www.oschina.net/news/248011/lxd-under-canonical">接管 LXD 項目</a>的舉措。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 0.2 現已發佈，</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#222222">此版本整合了 LXD 5.19 中的大部分更改，並引入了一些額外的功能和改進。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span style="background-color:#ffffff; color:#222222"><img alt="" height="333" src="https://static.oschina.net/uploads/space/2023/1101/142856_LLE7_4252687.png" width="500" referrerpolicy="no-referrer"></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span style="background-color:#ffffff; color:#222222">一些亮點更新內容如下：</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><strong><span style="background-color:#ffffff; color:#222222">虛擬機中的 NVME 存儲支持</span></strong></p><p><span style="background-color:#ffffff; color:#222222">虛擬機的磁盤類型設備新增了</span><code>io.bus</code><span style="background-color:#ffffff; color:#222222">configuration key。</span></p><p><span style="background-color:#ffffff; color:#222222">默認設置為</span><code>virtio-scsi</code><span style="background-color:#ffffff; color:#222222"><span>&nbsp;</span>，但現在也可以設置為</span><code>nvme</code><span style="background-color:#ffffff; color:#222222">，以便在虛擬機中將磁盤顯示為 NVME SSD。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>從 LXD 遷移的集羣支持</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>遷移工具<code>lxd-to-incus</code>現在支持集羣環境。此外，它還進行了更新以支持 LXD 5.19 作為源版本。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>這意味着任何使用 LXD 4.0 及更高版本（直到 5.19）的人現在都可以通過安裝 Incus 並運行<code>lxd-to-incus</code>輕鬆遷移到 Incus。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>非特權容器的新鏡像要求</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>當添加對 NixOS 作為容器鏡像的支持時，發現該特定鏡像當前無法在特權容器內運行。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>因此添加一個新的鏡像要求。可以將<code>requirements.privileged</code>設置為<code>false</code>，以防止該鏡像與特權容器一起使用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><pre><code>stgraber@dakara:~$ incus launch images:nixos nixos-priv -c security.privileged=true
Creating nixos-priv
Starting nixos-priv
Error: The image used by this instance is incompatible with privileged containers. Please unset security.privileged on the instance
Try `incus info --show-log local:nixos-priv` for more info
stgraber@dakara:~$</code></pre><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>服務器端自定義卷複製</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 現在支持自定義卷的服務器端副本。這消除了客户端充當中繼的需要，從而顯着加快了自定義卷的複製速度。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>命令行工具會自動檢測對此的支持並在可用時使用它。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>該功能首次在 LXD 中引入。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>靜態二進制文件現在可用於 64 位 Arm</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>作為發佈和測試的一部分提供的所有靜態二進制文件，現在都適用於 Intel 64 位和 Arm 64 位。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdiscuss.linuxcontainers.org%2Ft%2Fincus-0-2-has-been-released%2F18185" target="_blank">查看官方公告</a>。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 06:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264451/incus-0-2-released</guid>
            <link>https://www.oschina.net/news/264451/incus-0-2-released</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 發佈自研操作系統藍河 (BlueOS)，系統框架採用 Rust 編寫]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 vivo 開發者大會今天正式開始。大會上，vivo 發佈了自研操作系統<strong>藍河 (BlueOS)</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-15a70d97c2f8f3654e7d6f94c8c92df5505.png" referrerpolicy="no-referrer"></p><p>vivo 稱「藍河操作系統」是面向通用人工智能時代的自研智慧操作系統 —— 底層接入了 AI 大模型，支持基於自然交互方式的應用開發。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135537_Q43j_2720166.png" referrerpolicy="no-referrer"></p><p>vivo 還表示，藍河操作系統<strong>採用 Rust 編寫「系統框架」</strong>——從源頭避免了內存使用不當引起的安全漏洞。據稱是行業首家<strong>。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f21c3eb7d2568b66e3cebdf8f628b9bb78b.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135659_sEFQ_2720166.png" referrerpolicy="no-referrer"></p><p>運行要求方面，在低至 200Mhz 主頻 32MB 內存，高至 4GHz 主頻 24GB 內存的各種設備上，藍河都能流暢運行。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/142454_nhO4_2720166.png" referrerpolicy="no-referrer"></p><p>據瞭解，藍河操作系統目前不會在 vivo 手機上提供，首款搭載藍河操作系統的 vivo 設備是 vivo Watch3 智能手錶。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b5c944705e833222c61dc1c96c7713648ca.png" referrerpolicy="no-referrer"></p><p>此外，<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1668726803%2FNqydVxKTF%3Frefer_flag%3D1001030103_" target="_blank">據稱藍河操作系統是基於 Linux/RTOS 的自研架構</a></u>，因此不兼容 Android 應用。不過它兼容 hapjs，以獲得更好的生態支持。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/152743_iniv_2720166.png" referrerpolicy="no-referrer"></p><blockquote><p>hapjs 項目是由開放原子開源基金會孵化及運營的開源項目，<strong>是快應用標準的開源實現</strong>，是基於智能硬件平台的輕型應用形態，由多智能硬件廠商組成的快應用聯盟聯合制定標準共同驅動。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1ed767bef366be3bde87f6dbd714fdbd581.png" referrerpolicy="no-referrer"></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 06:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264444</guid>
            <link>https://www.oschina.net/news/264444</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[macOS Sonoma 黑屏 bug，影響 Asahi Linux]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Asahi Linux 發佈了一篇文檔，説明瞭近期 macOS 黑屏情況。</p><blockquote><p><span style="color:#333333">Asahi Linux 項目致力於將 Linux 操作系統移植到蘋果的 Apple Silicon Macs 系列電腦設備上。</span></p><ul><li><a href="https://www.oschina.net/news/125751/asahi-linux-set-up" target="_blank">可移植蘋果 M1 的 Asahi Linux 項目正式啓</a></li></ul></blockquote><p>Asahi 解釋，macOS Sonoma 和 macOS Ventura 13.6 在其升級和啓動過程中發佈了多個嚴重的錯誤。這些錯誤結合在一起，可以創建出一種情況，即無論使用何種電源按鈕按壓組合，機器總是啓動到黑屏。這使用户陷入困境，唯一的解決方案就是使用 DFU 恢復。</p><p>在某些設置和特定型號下，這種情況可能會發生，即多個 macOS 版本並行安裝（一個 Sonoma，一個更早的版本）。由於 Asahi Linux 的行為就像是 macOS 12.3/12.4/13.5（取決於型號和安裝時間），所以 macOS Sonoma 和 Asahi Linux 的雙啓動安裝會產生相同的問題。對於 macOS 13.6，這種情況甚至不需要雙啓動系統，只要作為唯一安裝的操作系統就可以觸發。</p><p>目前 Asahi Linux 安裝程序已經更新，現在它可以在啓動時自動進行完整性檢查並診斷系統。要運行它，請將此命令粘貼到 macOS 的終端中：</p><p style="text-align:start"><code>curl https://alx.sh | sh</code></p><p style="text-align:start">進入主菜單，用户可以退出安裝程序，而不對系統做任何更改。</p><p style="text-align:start">Asahi Linux 具體説明瞭 macOS 啓動失敗的原因：</p><ul><li><p>macOS Sonoma 的升級使用先前安裝的版本作為系統恢復。這在某種程度上是有道理的，但並未考慮到舊版 RecoveryOS 與新固件之間的向後兼容性問題。如果這種不匹配導致 recoveryOS 無法啓動，那麼系統恢復將無法使用。</p></li><li><p>對於 14 英寸和 16 英寸的型號：一旦系統固件更新到 macOS Sonoma 版本，如果顯示器的刷新率設置為非 ProMotion，則該系統將無法正確地啓動舊版本的 macOS 安裝程序和 Asahi Linux。這包括當這些系統被設置為默認啓動操作系統時的恢復模式，以及至少在下一次操作系統升級之前的系統恢復。</p></li></ul><p>影響設備、系統：</p><ul><li><p>配備 ProMotion 顯示屏的 MacBook Pro 型號（14 英寸和 16 英寸）受到黑屏啓動錯誤的影響。</p></li><li><p>macOS Sonoma 14.0+（截至 2023 年 10 月 31 日尚未修復）</p></li><li><p>macOS Ventura 13.6+ (使用 14.0 固件)</p></li><li><p>可能受影響：macOS Monterey 12.7（未經確認）</p></li></ul><p><strong>如果還沒升級到 Sonoma，Asahi Linux&nbsp;<span style="background-color:#ffffff; color:#1f2328">建議等到蘋果解決這些問題後再進行升級。</span></strong></p><p>更多細節查看 Asahi 發佈的説明：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAsahiLinux%2Fdocs%2Fwiki%2FmacOS-Sonoma-Boot-Failures" target="_blank">https://github.com/AsahiLinux/docs/wiki/macOS-Sonoma-Boot-Failures</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 04:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264432/macos-sonoma-boot-failures</guid>
            <link>https://www.oschina.net/news/264432/macos-sonoma-boot-failures</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微信 iOS 版「史詩級」更新：「發送」按鈕獨立]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>微信 iOS 版昨天發佈了 8.0.43 更新，更新日誌一如既往地是「修復了一些已知問題」。</p><blockquote><p><img height="780" src="https://static.oschina.net/uploads/space/2023/1101/121221_VGwW_2720166.png" width="1810" referrerpolicy="no-referrer"></p></blockquote><p>不過熱心網友發現的一項重要變化衝上了微博熱搜：<span style="color:#e67e22"><strong>#微信新增獨立發送按鈕#</strong></span>。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-12f6e066aebe74a1bd7440aa69ef266c4b9.png" referrerpolicy="no-referrer"></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-877e90cea0d617b8694aa9a040acdc2080e.png" referrerpolicy="no-referrer"></p><p>沒錯，微信 for iOS 8.0.43 新增了「使用獨立的發送按鈕」開關。開啓後，iOS 自帶輸入法的「發送」按鍵變成「換行」按鍵，而輸入框右側增加了獨立的「發送」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-410e4a667b0d00dcd7c363e6c756adad620.png" referrerpolicy="no-referrer"></p><p>對使用 iOS 自帶輸入法用户來説，這屬實是「史詩級」更新。</p><p>畢竟此前在輸入文字的時候如果想換行，需要在輸入框輕點或者長按呼出換行開關。現在「換行」和「發送」終於都有了獨立按鍵，感謝 Allen Zhang : )</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 04:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264431</guid>
            <link>https://www.oschina.net/news/264431</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gateway API v1.0：GA 版本出爐]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Gateway API v1.0 版本現已發佈。公告指出，此版本是該項目的一個重要里程碑。幾個關鍵的 API 已經升級為 GA（generally available，一般可用），同時其他重要功能已添加到實驗（Experimental）通道。</span></p><h4><span style="color:#000000"><strong>新增內容</strong></span></h4><p><span style="color:#000000"><strong>升級到 v1</strong></span></p><p><span style="color:#000000">此版本將 Gateway、GatewayClass 和 HTTPRoute 升級為 v1，意味着它們現在是一般可用的。這個 API 版本表示對 API 表面具有高度的信心，並提供向後兼容的保證。需要注意的是，雖然標準（Standard）通道中包含的這些 API 版本現在被認為是穩定的，但這並不意味着它們是完整的。這些 API 將繼續通過實驗通道接收新的功能，以滿足升級的標準。</span></p><p><span style="color:#000000"><strong>Logo</strong></span></p><p><span style="color:#000000">Gateway API 現在有了自己的 Logo！這個 Logo 是通過協作過程設計的，旨在代表這是一組用於在 Kubernetes 中進行南北向和東西向流量路由的 API：</span></p><p><img height="135" src="https://oscimg.oschina.net/oscnet/up-b9aa4cb25f206b6a9cd7b73608e412f035b.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><strong>CEL 驗證</strong></span></p><p><span style="color:#000000">過去，Gateway API 作為安裝 API 的一部分綁定了驗證 webhook。從 v1.0 開始，webhook 的安裝是可選的，僅建議在 Kubernetes 1.24 上使用。Gateway API 現在將 CEL ]驗證規則作為 CRDs 的一部分進行了包含。這種新形式的驗證在 Kubernetes 1.25+中得到支持，因此在大多數安裝中不再需要驗證 webhook。</span></p><p><span style="color:#000000"><strong>標準通道</strong></span></p><p><span style="color:#000000">此版本的主要重點是確保現有的 beta API 定義明確，並足夠穩定，可以升級為 GA。這導致了各種規範的澄清，以及一些改進，以提高與 Gateway API 交互時的整體用户體驗。</span></p><p><span style="color:#000000"><strong>實驗通道</strong></span></p><p><span style="color:#000000">此版本中包含的大部分更改都限於實驗通道，包括 HTTPRoute 超時、從 Gateway 到後端的 TLS 配置、WebSocket 支持、Gateway 基礎設施標籤等。</span></p><hr><p><span style="color:#000000">接下來，項目團隊將繼續致力於努力穩定和升級 API 的其他實驗性功能。包括支持服務網格]、額外的路由類型（GRPCRoute、TCPRoute、TLSRoute[17]、UDPRoute）以及各種實驗性功能。</span></p><p><span style="color:#000000">以及將 ReferenceGrant 移入內置的 Kubernetes API 中，使其可以用於不僅僅是 Gateway API。「在 Gateway API 中，我們使用這個資源來安全地啓用跨命名空間引用，而這個概念現在被其他 SIGs 採納。這個 API 的新版本將歸 SIG Auth 所有，並且在遷移到內置的 Kubernetes API 時可能包含至少一些修改。」</span></p><p><span style="color:#000000">更多詳情可查看：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubernetes-sigs%2Fgateway-api%2Freleases%2Ftag%2Fv1.0.0" target="_blank">https://github.com/kubernetes-sigs/gateway-api/releases/tag/v1.0.0</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 03:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264423/gateway-api-1-0-released</guid>
            <link>https://www.oschina.net/news/264423/gateway-api-1-0-released</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[四維縱橫完成超億元 B 輪融資]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">新一代超融合數據庫廠商四維縱橫<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fq_l-0lQ_GJxLTEXTjF30ag" target="_blank">宣佈</a>完成了上億元人民幣的 B 輪融資，本輪融資由用友、順義產業基金領投，廣州同創基金跟投。該公司表示，</span><span style="background-color:#ffffff">此次募集資金將會主要用於研發核心技術，建設商業生態鏈等方面。</span></span></p><p><span style="color:#000000"><img height="251" src="https://oscimg.oschina.net/oscnet/up-ecefb2dbc5ddf668afa56fccacfa3960e27.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">四維縱橫是一家成立於 2020 年的數據庫公司，以超融合數據庫 YMatrix 為企業提供集「分析、事務、時序」為一體的企業級數據庫產品服務。目前，四維縱橫，以 YMatrix 為核心，自研了全棧向量化執行器、分佈式數據庫災備、MARS3 存儲引擎、MatrixShift 遷移工具、MatrixGate 高性能寫入組件、MatrixUI 圖形化界面等一系列商業化套件。</span></p><p><span style="color:#000000"><img height="345" src="https://oscimg.oschina.net/oscnet/up-c609ba963a02c51a5f6c10587fc68105704.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">當前，YMatrix 已經被應用到證券、通信、銀行、保險、智能製造、車聯網等多個行業領域中，服務的客户包括浪潮、中興、理想汽車、寧德時代、三一重工等多個頭部企業。</span></span></p><p><span style="color:#000000">公告指出，在本輪融資之後，四維縱橫將會以目前 YMatrix 產品技術能力為根基，以超融合理念為發展方向，繼續拓展新的應用領域，將 YMatrix 超融合數據庫產品應用於更多的場景中。另外，四維縱橫將進一步加快並夯實技術團隊的人員建設和技術基礎，為全球用户提供更加全面的超融合解決方案。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264414</guid>
            <link>https://www.oschina.net/news/264414</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度上線「文心一言」會員，開通可解鎖文心大模型 4.0]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>百度大模型文心一言現已上線會員模式，開通後可解鎖文心大模型 4.0。</p><p><strong>目前文心一言基礎版功能依舊免費開放使用</strong>，可以滿足用户的日常需求，如交互對話、問答等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-523eef7bc90f0772422e76d8d238e5a06f5.png" referrerpolicy="no-referrer"></p><p>據介紹，文心一言會員單月購買價格為 59.9 元，<strong>連續包月價格為 49.9 元</strong>（次月以 49.9 元 / 月自動續費，可隨時取消）。此外，百度還推出了文心一言 + 文心一格（白銀）的聯合會員，價格為 99 元 / 月。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2e89f249c9e05e483bc3e37a5c145a0001d.png" referrerpolicy="no-referrer"></p><p><strong>文心一言會員權益：</strong></p><ul><li><p>模型能力：文心大模型 4.0</p></li><li><p>圖片生成：文生圖能力全面升級</p></li><li><p>插件權益 （網頁端）：高階插件</p></li><li><p>靈感值 （App 端）：單月贈送 600 靈感值</p></li></ul><p><strong>文心一格會員權益：</strong></p><ul><li><p>極速生成多尺寸高清圖像</p></li><li><p>創作海報和藝術字</p></li><li><p>白銀會員權益：AI 編輯改圖修圖</p></li></ul><hr><p><u><a href="https://www.oschina.net/news/262086">文心大模型 4.0 於上個月正式亮相</a></u>，李彥宏表示，<strong>這是迄今為止最強大的文心大模型</strong>，實現了基礎模型的全面升級，在理解、生成、邏輯和記憶能力上都有着明顯提升，綜合水平「與 GPT-4 相比毫不遜色」。</p><p><img alt="up-cb21975862a8f7b014aeea47cbab52da1df.png" src="https://oscimg.oschina.net/oscnet/up-cb21975862a8f7b014aeea47cbab52da1df.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264412</guid>
            <link>https://www.oschina.net/news/264412</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
