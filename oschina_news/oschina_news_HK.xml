<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 08 Nov 2023 22:30:35 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[目標智能體社會，MetaGPT 攜手 Jürgen Schmidhuber 團隊]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6a26cdfc68540cd8ce50fd07f1d06aa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1267&amp;h=530&amp;s=59164&amp;e=webp&amp;b=fcfbfb" referrerpolicy="no-referrer"><img alt="" height="335" src="https://oscimg.oschina.net/oscnet/up-35f95b18cb984ecd9e8659b66778355d901.jpg" width="800" referrerpolicy="no-referrer"></p><p>過去數月，MetaGPT [1] 的智能體（Agents）軟件公司實例讓人印象深刻，它迅速在 GitHub 獲得了 30k star，也獲得了數十個全球專業媒體與大 V 報道。但智能體軟件公司只是智能體社會（Agent Society）的一個縮影。智能體社會或許會有軟件公司、電商公司、遊戲公司，也會擁有大量的獨立智能體提供生產力。現代人工智能之父 Jürgen Schmidhuber 也非常認可智能體社會的理念，他與其團隊對 MetaGPT 做出了顯著貢獻，列入了 MetaGPT 作者名單。</p><p>早在 1986 年，馬文·明斯基以《心智社會》（Society of Mind, SOM）[2] 之作引領了人工智能領域的一場思想革命。他提出了一個極具創見的理論：心智不需由具有智能的單獨部件構成，反而是由一系列簡單部件的相互作用集結而成的複雜系統，正是這種集結，催生了我們所認識的智能和意識。這一理念對於構建自主智能體以及其後續發展，產生了不可估量的深遠影響。</p><p>隨着人工智能技術至 2023 年的飛躍，我們現在可以設想，如果每個微小部件本身都擁有一定程度的智能，它們將如何相互作用，產生何種層次的集體智能。2023 年上半年關於自然語言心智社會（NLSOM, Language Agent Society）的研究論文 [3] 中，來自阿卜杜拉國王科技大學、瑞士人工智能實驗室、牛津大學以及蘇黎世聯邦理工學院等知名研究機構的科學家們共同探討了智能體社羣的可能性。</p><p>他們提出，構建成由語言驅動的智能體社區，能夠協同完成單一智能體無法或難以獨立完成的任務。研究中提出了一系列實驗構想，這些實驗構想不僅僅是概念驗證，它們被視作邁向一個包含萬億級智能體社會的先導，這個社會可能也會包括人類成員。</p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21644b3cc3a84c2db0d0da75652a0cb0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=981&amp;h=1280&amp;s=170610&amp;e=webp&amp;b=fcfbfb" referrerpolicy="no-referrer"><img alt="" height="1044" src="https://oscimg.oschina.net/oscnet/up-2ee6f8c420b35e61bc71e31c9228d6fcd13.png" width="800" referrerpolicy="no-referrer"></p><p>在 2023 年的 CogX Festival 上，Jürgen 向聽眾展示了他對於大型語言模型（LLMs）的深刻見解。他在討論智能體（Agents）相關的話題時，提到了構建自我改進系統的多種途徑，包括通用圖靈機（Universal Turing Machine）[4] 和哥德爾機（Gödel machines）[5]。他指出，目前的大語言模型為我們提供了一種全新的思維模式 — 通過使用通用符號語言（例如：自然語言或編程代碼）作為接口，來串聯不同的模型。這些模型能夠與其他語言模型進行交流，共同構建起一個自然語言心智社會（NLSOM）的範例。</p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51d8e153f5514d13820c1d67539ede46~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920&amp;h=1080&amp;s=66142&amp;e=webp&amp;b=7d5c3e" referrerpolicy="no-referrer"><img alt="" height="450" src="https://oscimg.oschina.net/oscnet/up-f4af29afe3864c3625875a198b225f27628.jpg" width="800" referrerpolicy="no-referrer"></p><p>Jürgen Schmidhuber 教授是瑞士人工智能實驗室 (IDSIA) 的科學主任，以及阿卜杜拉國王科技大學人工智能中心 (AI Initiative, KAUST) 的主任。他的工作對強化學習（Reinforcement Learning），元學習（Meta Learning），以及神經網絡（Neural Network）等重要人工智能方向有着深刻的影響。</p><p>截止目前，Schmidhuber 教授的谷歌學術引用為 21 萬，其中作為共同發明人的長短時記憶（LSTM）論文單篇引用過 9 萬。他在 15 歲就希望能開發一種比它聰明並且能夠自我完善的人工智能，然後他就可以退休了。DeepMind 創始初期四人中的兩人以及他們招募的第一個人工智能博士都來自 Jürgen Schmidhuber 的實驗室。</p><p>在 Jürgen 構想的這一社會中，所有的交流都是透明且易於解釋的。他提到了一個被稱作「Mindstorm」的概念，即當給定一個問題時，這個自然語言心智社會能夠協同合作進行解答。</p><p>在這個過程中，社會中的每個成員可能會有不同的想法和視角，它們將收集並整合這些不同的思路，從而做出集體決策。</p><p>這種方式特別適合於解決那些單個智能體無法有效解決的問題。Jürgen 進一步舉例説明，這種問題可以是編程性質的，如使用 Python 語言解決一個具體的編程難題。通過這種協同作用，智能體社會的智能集結，將能夠實現超越個體能力的解決方案。</p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc7dc94e9a64bebb63187c960442abd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1269&amp;h=635&amp;s=49620&amp;e=webp&amp;b=fdfaf9" referrerpolicy="no-referrer"><img alt="" height="401" src="https://oscimg.oschina.net/oscnet/up-0a2e1cb3557ba4e33b63ccceca6b4647eb2.png" width="800" referrerpolicy="no-referrer"></p><p>此次 MetaGPT 項目的迭代獲得了 Jürgen 直接指導，其團隊也在代碼、寫作、工程上做了大量支持。</p><p>接下來，本文將詳細解析 MetaGPT 論文的更新內容，以便讓讀者能夠更加深入地理解其細節。</p><p><strong>1、論文與框架更新</strong></p><p>論文 3.1 節更新：闡述了 MetaGPT 框架中的角色專業化設計和角色分工概念，説明瞭單個智能體在 MetaGPT 中的行為模式和 SOPs 下的組織方式。</p><p>論文 3.2 節更新：介紹 MetaGPT 框架中的通信機制，包括結構化通信接口設計和發佈-訂閲機制。</p><p>論文 3.3 節更新：引入了可執行反饋機制，它是一種在代碼執行過程中進行持續迭代和自我糾正的機制。</p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52272b7b6df4434589d9071492e7d736~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1267&amp;h=636&amp;s=82808&amp;e=webp&amp;b=fdfcfc" referrerpolicy="no-referrer"><img alt="" height="401" src="https://oscimg.oschina.net/oscnet/up-47bacc68b62b046bdc40b461241d7a1ab26.jpg" width="800" referrerpolicy="no-referrer"></p><p>Fig.2. 通信協議示例（左）和運行中可執行反饋的迭代編程示例（右）。左圖：Agents 使用共享消息池發佈結構化消息。它們還可以根據自己的配置訂閲相關消息。右圖：生成初始代碼後，工程師 Agent 可執行代碼並檢查運行中是否報錯。如果出現報錯，Agent 會檢查執行結果，並將它們與 PRD、系統設計和代碼文件進行比較，進行代碼的重寫和優化。</p><p><strong>1.1、智能體通信協議</strong></p><p>目前大部分多智能體都是通過以自然語言為主的對話形式來完成協作，但這對於解決具體特定任務而言並不是最優的方式。</p><p>沒有約束和特定要求的自然語言輸出，可能會導致信息內容的失真或者語義焦點的偏移。</p><p>因此，結構化的通信內容和接口形式有助於智能體之間進行快速準確的任務要求理解，也有利於信息內容的最大化保留。參考人類 SOPs 中對不同崗位的角色要求，我們給每個角色設定了符合人類對應崗位專家的輸出規範，要求智能體將原始自然語言信息轉換為更結構化的表達（如下圖所示），如數據結構、API 設計和時序圖。</p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39c4bc32ea9644b9b0f383b5b9810d81~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1267&amp;h=1235&amp;s=146554&amp;e=webp&amp;b=ddecfb" referrerpolicy="no-referrer"><img alt="" height="779" src="https://oscimg.oschina.net/oscnet/up-3cb7baa9146b4b2f65471d6d5f4e2f4f4a7.jpg" width="800" referrerpolicy="no-referrer"></p><p>Fig.3 MetaGPT 軟件開發流程示意圖，表明結構化的 SOPs 可以帶來較好的效果 。更詳細的演示見附錄 B</p><p>在後續的實驗中，我們對比了 MetaGPT 和 ChatDev（使用聊天形式的溝通協作機制）來進行軟件開發的這一複雜任務的實際解決效果，結果説明結構化的通信接口設計對於智能體協作能帶來顯著效果。</p><p><strong>發佈-訂閲機制</strong></p><p>在多智能體的通信過程中，僅僅依賴 1v1 的單點通信方式不僅會加劇通信拓撲的複雜度，導致協作的效率低下，也會急劇增加開發成本。因此，我們通過【發佈-訂閲】的消息機制，在框架內實現了共享消息池和基於興趣的訂閲方式。</p><p>具體來説，環境提供共享的消息池，智能體可以從中直接獲取信息，無需逐一詢問其他智能體。與此同時，智能體可根據自己興趣/關注的行為來進行消息的過濾和篩選，從而減少消息/記憶的過載。如圖 3 所示，架構師主要關注產品經理的 PRD 文檔輸出，而對測試工程師的文檔則關注較少。</p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f4cb736da0047778cb331c48db14fb9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1266&amp;h=705&amp;s=29794&amp;e=webp&amp;b=f9fbfe" referrerpolicy="no-referrer"><img alt="" height="445" src="https://oscimg.oschina.net/oscnet/up-fa141e11ff2fb59723d29e9be1259680890.jpg" width="800" referrerpolicy="no-referrer"></p><p><strong>1.2、可執行迭代反饋設計</strong></p><p>調試和執行反饋在日常編程任務中發揮着重要作用。然而，現有方法往往缺乏自我糾正機制，僅通過代碼審查和評審機制進行代碼可行性評估。為了進一步減少 LLM 在生成代碼上的幻覺問題，我們引入了可執行反饋機制，對代碼進行迭代改進。通過自動的代碼執行測試結果反饋，進行代碼可行性評估和判斷，促進 LLM 進行自我的迭代和優化。如圖 2 所示，工程師可根據代碼執行結果持續更新代碼，迭代測試，直到測試通過或者最大 N 次重試退出。</p><p><strong>2、實驗更新</strong></p><p>在實驗部分，我們增加了對 SOPs 引入多智能體框架效果的探索實驗，和可執行迭代反饋帶來的代碼質量的提升實驗。在數據集上：</p><ol><li>針對代碼質量的效果評估：我們使用了兩個公共基準數據集：HumanEval 和 MBPP。<br> 1）HumanEval 包括 164 個手寫編程任務。這些任務包括功能説明、描述、參考代碼和測試。<br> 2）MBPP 包含 427 個 Python 任務。這些任務涵蓋核心概念和標準庫功能，幷包括説明、參考代碼和自動測試。</li><li>我們提出了更具有挑戰性的軟件開發任務的基準數據集 SoftwareDev：我們的 SoftwareDev 數據集收集了 70 個具有代表性的軟件開發任務實例，每個實例都有自己的任務提示（見論文表 5）。這些任務的範圍多種多樣（見論文圖 5），如迷你遊戲、圖像處理算法、數據可視化等。它們為真實的開發任務提供了一個強大的測試平台。與之前的數據集不同，SoftwareDev 側重於工程方面。在比較中，我們隨機選擇了七個具有代表性的任務進行評估。</li></ol><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a63997ca887a49a1a619d93e208c164d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=703&amp;h=727&amp;s=87524&amp;e=webp&amp;b=fbfafa" referrerpolicy="no-referrer"><img alt="" height="620" src="https://oscimg.oschina.net/oscnet/up-762eec7feede0d100b7ae1c5039f8331f71.jpg" width="600" referrerpolicy="no-referrer"></p><p><strong>2.1、可執行迭代反饋設計</strong></p><p>圖 4 表明，MetaGPT 在 HumanEval 和 MBPP 基準測試中均優於之前的所有方法。當 MetaGPT（使用 GPT-4 作為基礎模型），與 GPT-4 相比，它在 HumanEval 基準測試中的 Pass @1 顯著提高。它在這兩個公共基準測試中達到了 85.9% 和 87.7%（考慮到實驗成本，部分模型的數值結果直接使用的 Dong et al. (2023). 所提供的結果 [6]）。</p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6749bae368dd4f4d86ac44a57ace9c82~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1280&amp;h=382&amp;s=31468&amp;e=webp&amp;b=fdfdfd" referrerpolicy="no-referrer"><img alt="" height="239" src="https://oscimg.oschina.net/oscnet/up-55fc3e480ea87fb5c5872f15472848bf135.jpg" width="800" referrerpolicy="no-referrer"></p><p>Figure 4: Pass rates on the MBPP and HumanEval with a single attempt.</p><p><strong>2.2、軟件開發任務數據集 &amp; 評價指標</strong></p><p>對於 SoftwareDev，我們優先考慮生成項目的實際可用性，並通過人工評估（A、E）或統計分析（B、C、D）來評估性能，我們通過可視化示例展示了 MetaGPT 的自主軟件生成能力（論文圖 5）。有關其他實驗和分析，可參閲論文附錄 C：</p><p>（A）可執行性：該指標將生成代碼從 1（失敗/無功能）到 4（無缺陷）進行評級。1 代表無功能，2 代表可運行但不完美，3 代表接近完美，4 代表無缺陷。</p><p>（B）成本：這裏的成本評估包括（1）項目運行時間（2）Token 消耗量和（3）實際費用。</p><p>（C）代碼統計信息：包括（1）代碼文件數量（2）每個文件的平均代碼行數，以及（3）總代碼行數。</p><p>（D）生產效率：基本定義為 Token 使用量除以代碼行數，即每行代碼消耗的 Token，該數值越小説明代碼生產效率越高。</p><p>（E）人工修訂成本：以確保代碼順利運行所需的修訂輪數來量化，這表示人工幹預的頻率，如調試或導入依賴等修訂。</p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cce3f4c622541ea856eb3dc0e1fd9b8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1266&amp;h=761&amp;s=58372&amp;e=webp&amp;b=f8f7f7" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-58d8c9338be9e954eee491611053ad8b451.png" width="800" referrerpolicy="no-referrer"></p><p><strong>2.3、SOPs vs ChatChain</strong></p><p>在解決特定任務的場景中，為了探索 SOPs 對多智能體協作的效果，我們選擇了開源工作中支持軟件開發任務的智能體框架 ChatDev 作為實驗比較對象。ChatDev 是基於 ChatChain 和軟件開發瀑布流的角色分工進行智能體組織和協作的框架。我們從 SoftwareDev 選擇了 7 個任務進行對比，並比較了上述的相關指標來説明差異。</p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c3560be06bd46feab9b37a51b03e6aa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1267&amp;h=741&amp;s=67220&amp;e=webp&amp;b=ffffff" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-06aa7e7223004b9c3b2ca38b88efa69b92d.png" width="800" referrerpolicy="no-referrer"></p><p>如論文表 1 所示，在具有挑戰性的 SoftwareDev 數據集上，MetaGPT 幾乎在所有指標上都優於 ChatDev。</p><p>例如：在可執行性方面，MetaGPT 得到了 3.75 分，非常接近 4 分（完美無缺）。此外，它花費的時間（503 秒）也明顯少於 ChatDev。</p><p>在代碼統計和人工修改的成本上也明顯優於 ChatDev。雖然 MetaGPT 需要更多的 Token（24,613 或 31,255，而 ChatDev 為 19,292 ），但它只需要 126.5/124.3 個 Tokens 就能生成一行代碼。相比之下，ChatDev 使用了 248.9 個 Tokens。</p><p>這些結果凸顯了 SOPs 在多智能體協作中的優勢。</p><p><img alt="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c8b076075554df5a425342a9c1940e7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=817&amp;h=263&amp;s=24046&amp;e=webp&amp;b=f4f4f4" referrerpolicy="no-referrer"><img alt="" height="258" src="https://oscimg.oschina.net/oscnet/up-b7e033a3dab2d9dbc88391df2712d572478.jpg" width="800" referrerpolicy="no-referrer"></p><p><strong>3、致謝</strong></p><p>感謝來自 KAUST AI 中心的執行秘書 Sarah Salhi，博士後王宇輝，以及博士生王文一對於此論文提供的建議以及幫助。</p><p>[1] <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Farxiv.org%252Fpdf%252F2308.00352.pdf" target="_blank">arxiv.org/pdf/2308.00…</a></p><p>[2] <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Fen.wikipedia.org%252Fwiki%252FSociety_of_Mind" target="_blank">en.wikipedia.org/wiki/Societ…</a></p><p>[3] <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Farxiv.org%252Fpdf%252F2305.17066.pdf" target="_blank">arxiv.org/pdf/2305.17…</a></p><p>[4] <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Fen.wikipedia.org%252Fwiki%252FUniversal_Turing_machine" target="_blank">en.wikipedia.org/wiki/Univer…</a></p><p>[5] <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Fen.wikipedia.org%252Fwiki%252FG%2525C3%2525B6del_machine" target="_blank">en.wikipedia.org/wiki/Gödel_…</a></p><p>[6] <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Farxiv.org%252Fabs%252F2304.07590" target="_blank">arxiv.org/abs/2304.07…</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 10:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265625</guid>
            <link>https://www.oschina.net/news/265625</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[華為與西工大合作，發佈首款流體力學大模型「秦嶺・翱翔」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>華為近日宣佈，與西北工業大學聯合研發的首個面向飛行器的流體力學大模型「秦嶺・翱翔」現已正式發佈。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ff4d245868c9104fe5ffe5ca0fd9c6111a1.png" referrerpolicy="no-referrer"></p><p>秦嶺・翱翔大模型是西工大流體力學智能化國際聯合研究所攜手華為 AI4Sci Lab 在國產開源流體計算軟件風雷的基礎上，依託昇騰 AI 澎湃算力及昇思 MindSpore AI 框架共同研發的面向飛行器流體仿真的智能化模型。</p><p>大模型通過打造智能通用的流體力學軟件平台與流體工業全場景應用底座，旨在實現全場景流場準確預測。同時結合業界領先的數據同化、AI 湍流模型、流場快速預測等技術，支撐流體力學大模型的基礎構架。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d498c2db0add1f15cf241f0aff43d998bfb.png" referrerpolicy="no-referrer"></p><p>具體來説，大模型採用自研多級分佈式並行自適應框架，多層級融合流體力學經典理論和人工智能方法，構造數學物理關聯特徵、開展多範式一體化建模、搭建不變性可實現性多模態統一框架。同時，在模型算法設計、混合精度加速，以及數值求解耦合並行優化等方面進行了創新與驗證，實現了高置信度流場重構、全速域湍流場求解和複雜流場近實時預測。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 08:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265612</guid>
            <link>https://www.oschina.net/news/265612</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[著名硬件黑客黃欣國：美國限制 RISC-V 只會適得其反]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">美國立法者繼續施壓限制中國使用 RISC-V 的舉措已經引起質疑。著名硬件黑客黃欣國近日就針對此事，寫了一封至白宮、<span style="background-color:#ffffff">美國商務部和國會議員</span>的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bunniestudios.com%2Fblog%2F%3Fp%3D6862" target="_blank">公開信</a>，敦促不要對 RISC-V 技術的共享施加任何限制。</span></p><p><span style="color:#000000">他認為，增添限制只會減少美國對一項重要新興技術的參與，同時鞏固 ARM 作為嵌入式 CPU 近乎壟斷的現有供應商的地位。</span></p><blockquote><p><span style="color:#000000">我是一名出生於密歇根州的美國人，擁有麻省理工學院電子工程博士學位。我還是一個設計和製造電子產品的小企業主。我寫信敦促你們不要對 RISC-V 技術的共享施加任何限制。</span></p><p><span style="color:#000000">我的產品 CPU 基於開源的 RISC-V 標準。RISC-V 的開放性特別有利於像我這樣的小企業。我從開源社區獲得工具和設計，並將自己的改進回饋給社區。無障礙地參與這個充滿活力的開源生態系統可以降低開銷，使我能夠在殘酷的硬件行業中保持競爭力。</span></p></blockquote><p><span style="color:#000000">作為一個全球性項目，RISC-V 並不是美國的單獨所有，其很多貢獻都來自歐盟、印度、中國等地。黃欣國指出，譬如他所使用的&nbsp;VexRiscv，就是由歐盟開發的一個 RISC-V 實現。「<strong>對美國人的參與設置任何障礙都只會延緩美國在開發和採用該技術方面的進展。其效果將與立法者的初衷背道而馳</strong>」。另一個微妙之處在於，RISC-V 只是一種標準，對既定標準的使用進行監管也不切實際。</span></p><p><img height="318" src="https://oscimg.oschina.net/oscnet/up-211d8f4d387a1aadc108064451b71db8e29.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">黃欣國認為，美國立法者和政策制定者普遍對開源缺乏瞭解。並<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theregister.com%2F2023%2F11%2F07%2Fproposed_restrictions_riscv" target="_blank">表示</a>他最大的擔憂在於，美國的這一限制可能會造成寒蟬效應，迫使企業和組織決定不採用或停止為 RISC-V 做貢獻，暫停 RISC-V 生態系統的參與。因為所面臨的違反美國出口管制的風險太大 —— 包括最高 25 萬美元的民事處罰、20 年監禁的刑事處罰和最高 100 萬美元的罰款。</span></p><p><span style="color:#000000">「這將使 RISC-V 世界變得更加匱乏：至少來自美國人的創新和貢獻會減少，其他人使用它的動力以及開發它的理由也會減少......這將使美國失去強有力的第三選擇 ISA。」</span></p><p><span style="color:#000000">此外，黃欣國還認為，美國的這一限制很大程度上將促使中國結束對西方技術的依賴，轉而把錢花在自研芯片上。他在信中總結稱：</span></p><blockquote><p><span style="color:#000000">總之，對美國人共享 RISC-V 技術施加任何限制都只會削弱美國作為技術領導者的作用。過於寬泛的限制可能會剝奪教育工作者在美國校園向學生傳授計算機知識時使用的流行工具，因為他們擔心也會意外地向被禁運的實體傳授知識。即使是對 RISC-V 的狹義限制，也會使那些有可能進入中國市場的美國科技公司失去獲得高性價比、高性能 CPU 技術的機會，迫使它們向近乎壟斷的現有供應商 ARM Holdings plc 支付專利費，而 ARM Holdings plc 並非美國公司。這削弱了美國的競爭力，最終損害了美國的最佳利益。</span></p><p><span style="color:#000000">如果政府認為 RISC-V 是一項對美國經濟和軍事利益至關重要的技術，值得特別關注，那麼它就不應該試圖通過聯邦強制許可制度來限制 RISC-V 的表達，而應該投資於開發更多美國本土 RISC-V 芯片製造商成功案例的項目。在美國現有的法律框架和 RISC-V 合同框架內，公司可以選擇開發 RISC-V CPU 的專有實施方案。在美國，有許多公司在開放標準的界限內遊刃有餘，並有在不需要聯邦指導的情況下取得成功的先例： Intel 和 AMD 都是美國工業巨頭，它們都是通過專有技術實現原本公開的"x86"計算機標準而建立起來的。美國需要的是對 ARM Holdings plc 的壟斷做出迴應，而這一回應來自於對接受 RISC-V 的美國公司的投資。</span></p><p><span style="color:#000000">拜登總統，我懇請您：對美國的創新充滿信心。相信美國的價值觀。不要對共享 RISC-V 技術施加任何限制。我們可以共同努力，創造更多美國芯片製造商的成功案例，同時擁抱言論自由的美國價值觀！</span></p></blockquote><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bunniestudios.com%2Fblog%2F%3Fp%3D6862" target="_blank"><strong>公開信地址&nbsp;</strong></a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 08:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265608/bunnie-restrictions-riscv</guid>
            <link>https://www.oschina.net/news/265608/bunnie-restrictions-riscv</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[龍芯中科董事長、總經理胡偉武答網友與投資者]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>龍芯中科 2023 年第三季度業績説明會於昨日召開，在與投資者和網友互動問答環節，<span style="background-color:#ffffff; color:#333333">龍芯中科董事長、總經理胡偉武解答了許多問題。</span></p><p><span style="background-color:#ffffff; color:#333333">下文摘錄了部分問答（回答者均為龍芯中科</span>董事長、總經理，胡偉武<span style="background-color:#ffffff; color:#333333">）。</span></p><p>完整回顧：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frsc.sseinfo.com%2FroadshowIndex.do%3Fid%3D16536" target="_blank">https://rsc.sseinfo.com/roadshowIndex.do?id=16536</a></u></em></p><hr><h4><strong>開源、技術相關</strong></h4><p>您好！先前路演中，提過龍芯對於開源（個人理解為免費授權）與收費的思考，圈子裏很多同學對關於「不開源」的論述有顧忌。能否藉此機會明確下：龍芯法務對第三方獨立完成的龍架構軟硬件實現，以及善意的二次創作（如將指令集手冊整理為方便查閲的網站等）持何種態度？</p><p>另外社區 Linux 發行版能否打包龍芯原創軟件（如 Lbrowser、LATX、應用合作社等）？目前這些軟件缺乏 EULA，保守起見是不能打包的，對這些系統的用户不太友好。</p><blockquote><p>在 11 月底的發佈會上，龍芯會與使用龍芯 IP 及架構的開放授權客户簽約，敬請關注。</p><p>開源與兼容是一個矛盾，Linux 沒打敗 Windows、OpenCL 在 Cuda 面前輸得一塌糊塗，主要是參與者沒有形成合力。我們正在找到一條既開源又兼容的路徑，使得大量基於龍架構做芯片的人軟件是兼容的。</p><p>感謝你關於 Linux 發行版的建議，我們會認真考慮。</p></blockquote><p>&nbsp;</p><p>關於生態建設方面，目前雖説龍芯 Loongnix 被官方稱作「開源社區」，但它工單系統、代碼倉庫等不公開，協作渠道只有 service@loongnix.cn 一個郵箱，很難想像如何組織起有效的第三方參與。</p><p>作為國內為數不多的「根社區」，龍芯是否考慮將相關設施開放公開訪問，為其他行業參與者樹立樣板？</p><blockquote><p>我們正在改進，建設統一入口的龍芯生態社區。</p></blockquote><p>&nbsp;</p><p>請問龍芯有無計劃開發 ARM 的二進制翻譯, 在什麼契機下面向市場和社會公開?</p><blockquote><p>有。目前重點是在龍芯平台上運行 X86/Windows 應用，下一步要在龍芯平台上運行 ARM/Android 應用（已經開始部署）。</p><p>我以前説過要通過指令系統的創新消滅指令系統差異，一步步都會做到的。</p></blockquote><p>&nbsp;</p><p>龍芯的編程框架、二進制編譯進展如何了？編程框架大概何時能發佈？軟件的可通用性在開放市場很重要。</p><blockquote><p>二進制翻譯在別的問題回答過了。通用編程框架計劃隨龍芯 GPGPU 同步推出。</p></blockquote><p>&nbsp;</p><p>二進制翻譯目前進展怎麼樣，什麼時候可以產品化</p><blockquote><p>X86/Linux 的二進制翻譯趨於穩定。X86/Windows 的打印機、IE 瀏覽器兼容問題基本解決，正在做通用平台，最近有很多應用可用了，而且比較流暢，但這是個大工程。</p><p>我希望，二進制翻譯結合 3B6000 的推出可以到個人電腦的開放市場試試看。</p></blockquote><p>&nbsp;</p><p>胡老師好，請問：<br> 1，龍芯 3 系調頻技術何時能夠實現？<br> 2，龍芯系統（Loongnix）何時能夠升級至新世界？<br> 3，後續是否有推動商業軟件遷移至新世界的計劃？ 謝謝！</p><blockquote><p>Loongnix 升級至新世界與 Debian 對龍芯的支持同步，請關注 Debian 對龍架構的支持。</p><p>我們已經基本解決了在新世界上運行老世界應用的兼容性問題，正與統信等操作系統企業合作，爭取下一版操作系統支持新世界。</p></blockquote><p>&nbsp;</p><p>龍芯有無計劃結合自身 JIT 方面優勢做一些產品的適配和服務器或高性能領域的研發?</p><blockquote><p>感謝肯定與建議，是可以在這方面做工作，甚至未來可以做些芯片級的加速。</p></blockquote><p>&nbsp;</p><p>很期待公司的 GPGPU，能否適當吐露一些進展或者目標嗎？比如是否會研發自己的神經網絡框架？專門的 gpgpu 產品的計算能力大概在多少 (如 int8 或 float32)？</p><blockquote><p>在 2K3000 中 INT8 大概 8TOPS，在 9A1000 中 INT8 大概 32TOPS。同時，多個 9A1000 通過龍鏈互連形成更高性能。</p></blockquote><p>&nbsp;</p><p>請問可以説明一下龍鏈技術有哪些優勢嗎？</p><blockquote><p>一般高速互連包括物理、鏈路、協議層，像 PCIE 這樣的接口協議每一層都要打包拆包，nvlink 及 CXL 這樣的協議，協議層直接面向物理層設計，提高了效率。龍鏈跟 3A5000 的片間互聯協議比，片間互聯延遲成倍降低，帶寬提高了好幾倍，大大提高多片協同工作的性能。</p><p>龍鏈跟 nvlink 比，速率還低一些（目前每位速率是 16Gbps，下一步將提高到 32Gbps），但效率已經不錯了。</p></blockquote><h4>&nbsp;</h4><h4>行業、政策相關</h4><p>請問胡老師，3A6000 何時正式發佈？龍芯能否跳過 3B6000 直接研發 7nm 的 3A7000, 時不我待！</p><blockquote><p>3A6000 將於 11 月底正式發佈，十幾家整機/ODM 企業將發佈其整機產品。</p><p>我感覺在目前的工藝上還應該提高性能 20%-30%。換個新工藝也就提高這麼多。7nm 流片費用很高，一次得上億元，不能用該工藝試錯，用已有工藝完成結構試錯後再改到更先進工藝。</p><p>另外，龍芯堅持 IP 的自主研發，在新工藝上，要研製 DDR5 PHY、PCIE PHY、各類寄存器堆、鎖相環等 IP，現在已經開展對新工藝的評估，2024 年將研製這些 IP 並開展測試片研製，等這些 IP 成熟了，3B6000 也完成了對新結構的驗證，時間是對得上的。</p></blockquote><p>&nbsp;</p><p>對於目前信創的主要競爭對手海光和華為各自的競爭力如何看？</p><blockquote><p>（1）商業模式不同，龍芯可以比作 Intel，華為是整機企業可以比作 IBM，海光與曙光也形成了事實上的 IBM 模式。<br> （2）龍芯做生態，他們做產品，這是主要不同。<br> （3）龍芯把信創作為走向開放市場路上的驛站，作為試錯場景，最終面向開放市場和海外市場。</p></blockquote><p>&nbsp;</p><p>目前在龍芯桌面主機上還是看到一些挑內存現象，請問後續龍芯這方面有沒有優化計劃，儘可能做到市場主流品牌的內存插上即用。</p><blockquote><p>感謝你的問題。我們會進行持續改進。</p></blockquote><p>&nbsp;</p><p>您認為龍芯的銷售是否存在不接地氣的情況呢？</p><blockquote><p>理論上，龍芯主要面對整機企業，在整機企業積極性不足的情況下直接推動一些用户單位。</p><p>過去確實存在對計算機產業鏈不熟悉的情況，過去一年多已經有較大進步，從整機、渠道、應用單位三個環節完善產業鏈。</p></blockquote><p>&nbsp;</p><p>作為一個國產愛好者，請問龍芯 3a6000 對國產的電腦配件適配情況怎麼樣？比如長江致鈦、摩爾線程、金百達等的適配情況。</p><blockquote><p>我們與自主內存、硬盤、顯卡的很多合作伙伴都已經完成適配或者正在適配。</p></blockquote><p>&nbsp;</p><p>請問胡老師，龍芯與俄羅斯方面的合作是否會更深入，我個人認為龍芯應該積極與俄方合作，有利於雙方打破僵局</p><blockquote><p>謝謝你的建議。 目前龍芯的營收均來自境內客户。</p><p>龍芯是一個通用 CPU 企業，會聯合一帶一路國家打造獨立於 X86 和 ARM 體系的第三套體系。</p></blockquote><p>&nbsp;</p><p>龍芯 cpu 的性能還是不錯的，但是絕大部分人對於專業軟件的測試成績是沒有概念的。可否在線下設立一些龍芯電腦體驗店，或者開放一些遠程桌面？讓有心支持國產的消費者親身體驗下是否能夠滿足自身需求來決定購買。</p><blockquote><p>謝謝建議。我們會認真考慮實施。</p></blockquote><p>&nbsp;</p><p>胡老師，很看好龍芯的 gpgpu 發展，相信有一天也會跟龍芯的 CPU 一樣在國內一騎絕塵，請問龍芯有沒有在車機或者智能芯片佈局的計劃，做出像高通 8155 車機芯片，地平線征程系列那樣的智駕芯片計劃？</p><blockquote><p>龍芯目前主要做面向推理的 AI 芯片，形成 CPU+GPGPU 的最佳解決方案。</p><p>我相信，隨着應用的拓展，龍芯芯片的 AI 應用會很普遍。</p></blockquote><p>&nbsp;</p><p>胡老師您好！請問 2022/2023 年政策性市場停滯的原因主要是什麼？2024/2025 年政策性市場能否像預期一樣放量？</p><blockquote><p>感覺 2023Q4，政務類政策性市場部分回暖。我自己對 2024/2025 年預期不變。</p></blockquote><p>&nbsp;</p><p>龍芯以前介紹過車規級 mcu 印象説的好像是流片了，目前有沒有新進展？龍芯對於新能源汽車領域有沒有大的佈局？感覺這塊是一個大的市場，特別是當前形勢下，龍芯這種有硬實力的 CPU 企業在國產替代大有可為。</p><blockquote><p>已經與部分汽車企業開展 MCU 替換工作。龍芯會把電機驅動作為重點方向。</p></blockquote><p>&nbsp;</p><p>1、可否簡單介紹一下一帶一路國家市場整體佈局節奏和規劃？<br> 2、農村包圍城市的大策略是對的，不過如果整機終端有標杆性大客户是否可以更好的帶動芯片銷售？<br> 3、龍芯芯片整體性能不錯的情況下，解決特定的某一項或兩項需求痛點，形成差異化優勢，也許可以脱穎而出？&nbsp;</p><blockquote><p>總體上説，龍芯要聯合一帶一路國家形成新型信息技術體系和產業生態，在不斷探索中。</p><p>信創市場會帶動龍芯技術進步，同時也有不少品牌整機客户支持龍芯，整機客户主要是看性價比。</p><p>我相信，如果龍芯性價比達到一定水平，肯定會有越來越多的品牌整機使用。同時，要做第三套生態，一定要重構產業鏈。 感謝你的建議，我最近多次講的「點面結合」中的「點」與你的第三點建議是一致的。</p></blockquote><p>&nbsp;</p><p>能否加快 GPGPU 的研發，不要怕花錢，這是一個新興市場，速度越快越好。</p><blockquote><p>待 2K3000 中得到驗證後，會加速研發的。主要是自主研發需要迭代。</p></blockquote><p>&nbsp;</p><p>有企業採購和技術人員表示龍芯銷售人員很不專業，沒法解釋龍芯的特點和優點，沒法迴應對手的攻擊銷售術語，沒銷售技巧，有的地區銷售人員甚至已經消失了很長時間。請問龍芯銷售人員是否熟悉龍芯產品，日常是否使用過龍芯自家的產品，以後怎麼提高。</p><blockquote><p>龍芯公司包括辦公電腦、郵件服務器、網站服務器、OA 服務器、ERP 服務器、網絡安全產品，均使用龍芯 CPU。</p><p>龍芯的銷售需要改進的地方挺多的，正在改進中。但我要求銷售要有底線。</p><p>總體上，龍芯發展的主要矛盾還是產品能否滿足市場需求的矛盾，主要體現在系統性價比和軟件生態。</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 07:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265392</guid>
            <link>https://www.oschina.net/news/265392</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[「開源 Windows」 ReactOS 改進 UEFI 引導，支持更多硬件]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>ReactOS 開發團隊<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Freactos.org%2Fblogs%2Fnewsletter-103%2F" target="_blank">宣佈</a></u> 64 位（AMD64 和 ARM64）UEFI 引導功能現在可以在更多設備上使用了。這些設備包括個人電腦、諾基亞的 Lumia、蘋果的 iPhone 和 Valve 的 Steam Deck 等。</p><p><img src="https://static.oschina.net/uploads/space/2023/1108/144126_Cm3T_2720166.png" referrerpolicy="no-referrer"></p><p>從今年年初開始，開發團隊就着手將 ReactOS 的默認引導加載程序 FreeLoader 過渡到支持 x86 和 AMD64 以及 ARM32 和 ARM64 的 UEFI。ReactOS 核心開發者 Hermès 一直在開發一個用於傳遞 UEFI 幀緩衝區信息的系統，使 Windows XP 可以在 UEFI 系統上運行，而 Justin Miller (TheDarkFire) 則一直在開發 UEFI FreeLoader 構建。</p><p>除了支持引導 ReactOS 外，團隊還在開發其他功能，如 EFI 連鎖加載和 FreeLoader 的 bootmgfw 兼容構建。這些功能將增加引導管理功能，並允許現代 Windows 系統引導用户最喜歡的引導加載器。</p><p>除此之外，ReactOS 團隊還表示正在慢慢改善 NT6+ 應用程序的兼容性和支持。NT6+ 是一個術語，包括基於較新 NT 架構設計的 Vista、7、8、8.1、10 和 11 等 Windows 操作系統。</p><p>由於許多軟件開發商不再支持舊版本的 Windows 系統，因此日常使用的大多數應用程序都無法在 ReactOS 上運行。不過，這種情況將會改變。</p><p>目前，ReactOS 主要侷限於用户模式，內核模式的升級計劃稍後進行。目前還沒有預計的發佈時間。</p><blockquote><p>ReactOS 項目的主要目標就是提供一個與 Windows 環境二進制兼容的操作系統。它能讓你的 Windows 應用程序和驅動程序如同在 Windows 上一樣運行。</p><p>此外，由於應用了 Windows 操作系統的外觀特性，已經熟悉 Windows 用户界面的用户在使用 ReactOS 時將駕輕就熟。ReactOS 的終極目標是使你能夠在感覺不到最終用户體驗變化的前提下，使用 ReactOS 來替代 Windows。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2019/0306/073550_CIxD_2720166.png" referrerpolicy="no-referrer"></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 06:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265587</guid>
            <link>https://www.oschina.net/news/265587</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[解密 deepin-IDE：如何實現簡單靈活的調試技術？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p>前不久深度科技旗下 deepin 社區發佈了自己的 IDE：deepin-IDE，得到了全網用户尤其是開源社區用户的廣泛關注，目前在 GitHub（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flinuxdeepin%2Fdeepin-unioncode" target="_blank">https://github.com/linuxdeepin/deepin-unioncode</a>）倉庫的 star 數量已經達到 600 多個，説明大家的熱情還是很高漲的。</p><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922163311.png" referrerpolicy="no-referrer"></div><p>為了從技術層面給大家的熱情做一個反饋，本文試着將 deepin-IDE 內部的一些實現方法進行分享，希望能夠解答友友們的疑惑並得到積極的反饋。</p><p>本篇挑了大家關心的「調試」部分進行分享。需要説明的是，deepin-IDE 的調試功能是選用 DAP（Debug Adapter Protocol ）調試適配協議實現的，所以整體架構是圍繞該協議搭建的，至於<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>具體是什麼，讓我們帶着問號往下看。</p><h2>什麼是<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>協議</h2><p><code>DAP</code><span>&nbsp;</span>即調試適配協議 ( Debug Adapter Protocol )，顧名思義，它是用來對多種調試器進行抽象統一的適配層，將原有<span>&nbsp;</span><code>IDE</code><span>&nbsp;</span>和調試工具直接交互的模式更改為和<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>進行交互。該模式可以讓<span>&nbsp;</span><code>IDE</code><span>&nbsp;</span>集成多種調試器變得更簡單，且靈活性更好。</p><p>在<span>&nbsp;</span><code>IDE</code><span>&nbsp;</span>中的調試功能有許多小功能組成，包括單步執行、斷點、查看變量值等，常規的實現方式是在每個<span>&nbsp;</span><code>IDE</code><span>&nbsp;</span>中去實現這些邏輯，且因為調試工具的接口不同，還需要為每個調試工具做一些適配工作，這將導致大量且重複的工作，如下圖所示：</p><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922164609.png" referrerpolicy="no-referrer"></div><p>調試適配器協議背後的想法是標準化一個抽象協議，用於開發工具如何與具體調試器通信。這個思想和<span>&nbsp;</span><code>LSP</code>(Language Server Protocol) 和<span>&nbsp;</span><code>BSP</code>(Build Server Protocol) 類似，都是通過協議去統一相同功能在不同工具之間的差異性。其所處位置如下圖所示，其中左邊為不同的開發工具，右邊為不能同的調試器，不同於開發工具和調試器直接交互的方式，<code>DAP</code><span>&nbsp;</span>將這些交互統一了起來，讓開發工具和調試工具都面向<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>編程。</p><p>上圖中的交互是通過協議進行，所以不會像通過<span>&nbsp;</span><code>API</code><span>&nbsp;</span>的方式存在語言限制，可以更好的適應調試器的集成。</p><h2>DAP 如何工作</h2><p>以下部分解釋了開發工具（例如<span>&nbsp;</span><code>IDE</code><span>&nbsp;</span>或編輯器）和調試適配器之間的交互，包括具體的協議格式説明、交互流程等。</p><h3>調試會話</h3><p>開發工具有兩種基礎的方式和調試器進行交互，分別是:</p><p>【單會話模式】</p><p>在這種模式下，開發工具啓動一個調試適配器作為一個單獨的進程並且通過標準的 std 接口進行通信。在調試會話的結束時調試適配器就終止，對於當前的調試會話，開發工具往往需要實現多個調試適配。</p><p>【多會話模式】</p><p>在這種模式下，開發工具不會啓動調試適配器，而是假定它已經在運行並且會在特定端口上偵聽連接嘗試，對於每個調試會話，開發工具在特定端口上啓動一個新的通信會話並在會話結束時斷開連接。</p><p>在與調試適配器建立連接後，開發工具和調試適配器之間通過基礎協議進行通信。</p><h3>基礎協議</h3><p>基礎協議由兩部分組成，包括頭和內容 (類似於 HTTP)，頭部和內容部分通過「\r\n」進行分割：</p><p>【協議頭】</p><p>協議頭部分由字段組成， 每個頭字段由一個鍵和一個值組成，用‘:’（一個冒號和一個空格）分隔， 每個頭字段都以「\r\n「結尾。由於最後一個協議頭字段和整個協議頭本身都以 \r\n 終止，並且由於協議頭是強制性的，所以消息的內容部分總是在（並唯一標識）兩個 \r\n 序列之前。當前只支持一個協議頭字段：</p><table style="border-spacing:0px; max-width:100%"><tbody><tr><th style="text-align:left">頭字段名</th><th style="text-align:left">值類型</th><th style="text-align:left">描述</th></tr></tbody><tbody><tr><td style="border-style:double; border-width:1px; text-align:left">Content-Length</td><td style="border-style:double; border-width:1px; text-align:left">數字</td><td style="border-style:double; border-width:1px; text-align:left">這個字段是必須的，用來記錄內容字段的長度，單位是字節。</td></tr></tbody></table><p>協議頭部分使用的是「ASCII」編碼。</p><p>【內容部分】</p><p>內容部分包含了實際要傳輸的數據，這些數據用<span>&nbsp;</span><code>JSON</code><span>&nbsp;</span>格式來描述請求、響應和事件。內容部分用的是<span>&nbsp;</span><code>utf-8</code><span>&nbsp;</span>編碼</p><p>為了有個具體的認識，這裏舉個簡單的例子。在調試過程中，開發人員經常會使用到下一步操作，在<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>中其協議為：</p><div><pre><code class="language-plain">Content-Length: 119\r\n
\r\n
{
 &nbsp; &nbsp;"seq": 153,
 &nbsp; &nbsp;"type": "request",
 &nbsp; &nbsp;"command": "next",
 &nbsp; &nbsp;"arguments": {
 &nbsp; &nbsp; &nbsp; &nbsp;"threadId": 3
 &nbsp;  }
}
</code></pre></div><p>類型是「請求」，命令是下一步，參數部分可以攜帶多個，這裏是用的線程 Id。 這個協議看着挺簡單的，是吧？接下來就講講如何使用它。</p><h3>使用方法</h3><p>詳細的使用方法這裏就不涉及，因為用一個時序圖就可以説明：</p><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922164954.png" referrerpolicy="no-referrer"></div><p>可以看到，初始化、請求、響應等必要的步驟都在圖中。其中調試適配器可以理解為調試器的抽象，調試功能的最終執行者是由對應語言的調試工具實現的。</p><h2>在 deepin-IDE 中的實現</h2><p>在 deepin-IDE 中，調試功能的實現是結合<span>&nbsp;</span><code>cppdap</code><span>&nbsp;</span>+<span>&nbsp;</span><code>debugmanager</code><span>&nbsp;</span>實現的。</p><p><code>cppdap</code><span>&nbsp;</span>是一款基於 C++ 開發的<span>&nbsp;</span><code>SDK</code>，基本實現了<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>的全量協議。 deepin-IDE 的客户端和服務端都是應用的該<span>&nbsp;</span><code>SDK</code><span>&nbsp;</span>進行開發，據此可以實現以下功能：</p><p>1.通信功能，包括服務端的 TCP 監聽，客户端的 TCP 連接等；</p><p>2.<code>DAP</code><span>&nbsp;</span>協議的封裝，並實現協議的串行化和解串行化；</p><p>3.提供註冊回調功能，從而可以在回調內處理各種事件、請求等；</p><p>它的層級結構如下：</p><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922165226.png" referrerpolicy="no-referrer"></div><p>用<span>&nbsp;</span><code>cppdap</code><span>&nbsp;</span>可以減少客户端和服務端不少工作量，也統一了兩邊的協議數據。而 debugmanager 可以理解為調試器的抽象，包含所有必要的調試要素。整體結構如下：</p><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922165251.png" referrerpolicy="no-referrer"></div><p>左邊是客户端，右邊是服務端，內部實現如下：</p><h3>客户端實現</h3><p>客户端包含了兩個個主要功能，一個是和<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>服務端進行交互，發送調試命令或處理返回的數據；另一個是將<code>DAP</code><span>&nbsp;</span>數據轉換後顯示到用户界面，並響應界面發送的事件。概括起來就包含業務模塊、事件模塊、<code>DAP</code><span>&nbsp;</span>模塊和界面 4 個部分。</p><p>業務模塊</p><ul><li><p>業務模塊包含了插件類、調試參數、調試管理類等，其中插件類負責插件加載、初始化、獲取上下文等，調試管理類用來組合事件、<code>DAP</code>、界面幾個模塊。 事件模塊</p></li><li><p>事件模塊包含兩個子模塊，分別是事件發送和事件接收，比如頁面跳轉事件、添加\移除斷點事件等。<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>模塊</p></li></ul><p><code>DAP</code><span>&nbsp;</span>模塊基於<span>&nbsp;</span><code>cppdap</code><span>&nbsp;</span>開發，採用層級結構，底層是原始<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>協議封裝，中間層是針對業務做的進一步封裝，簡化了向外提供的接口，最上層是對整個調試功能的整合，包括數據緩存、界面元素、命令收發。</p><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922165331.png" referrerpolicy="no-referrer"></div><ul><li>界面部分，界面模塊包含堆棧界面、變量界面、斷點列表、異步對話框等，用於<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>的數據展示。</li></ul><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922165342.png" referrerpolicy="no-referrer"></div><ul><li>如上圖所示，灰色部分為<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>客户端的界面呈現。</li></ul><h3>服務端實現</h3><p>服務端的功能分為兩個部分，一個是基於<span>&nbsp;</span><code>cppdap</code><span>&nbsp;</span>實現命令的收發，另一個是與<span>&nbsp;</span><code>gdb</code><span>&nbsp;</span>交互，實現調試程序的啓動、暫停、退出等一系列動作。</p><p>DAP</p><ul><li><p>和客户端一樣，服務端也是基於<code>cppdap</code>實現的通信和協議封裝和解析。 調試工具</p></li><li><p>和調試工具的交互是通過進程調用的方式實現，接收進程輸出得到返回信息。如果調試工具本身支持<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>協議，則可以直接交互。</p></li></ul><p>至此，本次的分享就到這兒啦！不知道你對<span>&nbsp;</span><code>deepin-IDE</code><span>&nbsp;</span>中的調試功能有所瞭解了嗎？</p><p>温馨提示，deepin-IDE 還包含很多有意思的功能，如果大家感興趣可以積極反饋，後續有機會再進行分享。</p><h2>參考文檔</h2><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmicrosoft.github.io%2Fdebug-adapter-protocol%2Foverview" target="_blank">debug-adapter-protocol</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwiki.deepin.org%2Fzh%2F05_HOW-TO%2F02_%25E5%25BC%2580%25E5%258F%2591%25E7%259B%25B8%25E5%2585%25B3%2Fdeepin-unioncode" target="_blank">deepin-IDE 使用手冊</a></p><p>內容來源：deepin 社區</p><p>內容作者：deepin-mozart、toberyan</p></div></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 06:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265585/deepin-ide-debug</guid>
            <link>https://www.oschina.net/news/265585/deepin-ide-debug</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[蘋果暫停 iPhone 和 Mac 的系統新功能開發工作，專注修復 bug]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>彭博社報道稱，蘋果公司罕見地暫停了明年 iPhone、iPad、Mac 和其他設備的軟件更新開發工作，以便根除代碼中的 bug。</p><p><img src="https://static.oschina.net/uploads/space/2023/1108/141600_8Btu_2720166.png" referrerpolicy="no-referrer"></p><p>via <em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2023-11-07%2Fapple-delays-work-on-ios-18-macos-15-watchos-11-due-to-problems-with-bugs" target="_blank">彭博社</a></u></em></p><p>蘋果上週在內部向員工宣佈了這一決定，<strong>公司工程師現在的主要任務不是添加新功能而是修復 bug 和改進性能</strong>。</p><p>在準備明年發佈的新操作系統時，軟件工程管理團隊在內部測試中發現了太多的<strong>"escapes"</strong>問題（內部測試期間遺漏的錯誤）。由於數千名不同的蘋果員工在各種操作系統和設備上工作，這些操作系統和設備需要無縫協作，因此很容易出現故障。</p><p>因此他們採取了不同尋常的做法，暫停新功能開發一週，專注於修 bug。雖然暫停一週，但發版時間仍按原計劃進行。</p><p>目前還不清楚此次暫停開發一週對上述系統來説存在哪些影響，彭博社稱這是蘋果非常罕見的舉動。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 06:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265579</guid>
            <link>https://www.oschina.net/news/265579</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 跨平台終端仿真軟件 quardCRT]]>
            </title>
            <description>
                <![CDATA[<p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Fwindows.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/windows.yml?branch=main&amp;logo=windows" alt="Windows ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Flinux.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/linux.yml?branch=main&amp;logo=linux" alt="Linux ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Fmacos.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/macos.yml?branch=main&amp;logo=apple" alt="Macos ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.codefactor.io%2Frepository%2Fgithub%2Fqqxiaoming%2FquardCRT"><img src="https://img.shields.io/codefactor/grade/github/qqxiaoming/quardCRT.svg?logo=codefactor" alt="CodeFactor" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/license/qqxiaoming/quardCRT.svg?colorB=f48041&amp;logo=gnu" alt="License" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Freleases"><img src="https://img.shields.io/github/tag/QQxiaoming/quardCRT.svg?logo=git" alt="GitHub tag (latest SemVer)" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Freleases"><img src="https://img.shields.io/github/downloads/QQxiaoming/quardCRT/total.svg?logo=pinboard" alt="GitHub All Releases" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/stars/QQxiaoming/quardCRT.svg?logo=github" alt="GitHub stars" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/forks/QQxiaoming/quardCRT.svg?logo=github" alt="GitHub forks" referrerpolicy="no-referrer"></a><a href="https://gitee.com/QQxiaoming/quardCRT"><img src="https://gitee.com/QQxiaoming/quardCRT/badge/star.svg?theme=dark" alt="Gitee stars" referrerpolicy="no-referrer"></a><a href="https://gitee.com/QQxiaoming/quardCRT"><img src="https://gitee.com/QQxiaoming/quardCRT/badge/fork.svg?theme=dark" alt="Gitee forks" referrerpolicy="no-referrer"></a></p><h1><a id="user-content-quardcrt" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#quardcrt"></a>quardCRT</h1><p><a href="https://gitee.com/QQxiaoming/quardCRT/blob/main/README.md">English</a> | 簡體中文</p><p>quardCRT 一款終端仿真軟件，支持多種後端協議，無依賴跨平台使用，windows/linux/mac 使用體驗完全一致，支持多標籤頁和歷史記錄管理。</p><table><thead><tr><th align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/windows.png" alt="img2" referrerpolicy="no-referrer"></th></tr></thead><tbody><tr><td align="center">Windows</td></tr><tr><td align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/macos.png" alt="img1" referrerpolicy="no-referrer"></td></tr><tr><td align="center">MacOS</td></tr><tr><td align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/linux.png" alt="img3" referrerpolicy="no-referrer"></td></tr><tr><td align="center">Linux</td></tr></tbody></table><p>其他協議選擇界面：</p><p><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/img.png" alt="img" referrerpolicy="no-referrer"></p><h2><a id="user-content-功能描述" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E5%8A%9F%E8%83%BD%E6%8F%8F%E8%BF%B0"></a>功能描述</h2><ul><li><p>目前支持的終端協議包括：</p><ul><li>telnet (支持帶 websocket 封裝)</li><li>serial</li><li>loaclshell</li><li>rawsocket</li><li>windows:NamedPipe（linux/macos:unix domain socket）</li></ul></li><li><p>多標籤頁管理，標籤頁克隆，標籤頁拖拽排序</p></li><li><p>雙列分屏</p></li><li><p>工作目錄書籤</p></li><li><p>自動化發送</p></li><li><p>HEX 顯示</p></li><li><p>會話記錄管理</p></li><li><p>終端樣式配置（配色方案，字體）</p></li><li><p>終端背景圖片配置（支持透明度設置，支持 gif 動畫和視頻）</p></li><li><p>終端滾動行數設置</p></li><li><p>支持深色/淺色主題</p></li><li><p>支持多語言（中文/英文/日文）</p></li></ul><h2><a id="user-content-貢獻" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E8%B4%A1%E7%8C%AE"></a>貢獻</h2><p>如果您對本項目有建議或想法，歡迎在 GitHub 或 Gitee 上提交 issue 和 pull requests。</p><p>目前項目建議使用版本 Qt6.2.0 及更高版本。</p><h2><a id="user-content-特別" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E7%89%B9%E5%88%AB"></a>特別</h2><p>項目目前為個人業餘時間開發，為提高開發效率，本項目較為大量的使用了 GitHub Copilot 協助代碼編寫，部分代碼的人類可讀性可能不是很好，作者也會盡量在後續版本中進行優化。</p><h2><a id="user-content-感謝" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E6%84%9F%E8%B0%A2"></a>感謝</h2><p>本項目代碼引用或部份參考或依賴了以下開源項目，項目完全尊重原項目開源協議，並在此表示感謝。</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FColinDuquesnoy%2FQDarkStyleSheet">QDarkStyleSheet</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fdridk%2FQFontIcon">QFontIcon</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fsilderan%2FQTelnet">QTelnet</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Flxqt%2Fqtermwidget">qtermwidget</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fkafeg%2Fptyqt">ptyqt</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fbitmeal%2Fargv_split">argv_split</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmbadolato%2FiTerm2-Color-Schemes">iTerm2-Color-Schemes</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Frprichard%2Fwinpty">winpty</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FSM-nzberg%2FQtFancyTabWidget">QtFancyTabWidget</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fteknoraver%2Fqtftp">qtftp</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FJuliaStrings%2Futf8proc">utf8proc</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Ffcitx%2Ffcitx-qt5">fcitx-qt5</a></li></ul>]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 06:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/QQxiaoming/quardCRT</guid>
            <link>https://gitee.com/QQxiaoming/quardCRT</link>
        </item>
        <item>
            <title>
                <![CDATA[M3 MacBook Pro 無法從預裝的 'Ventura' 系統升級至 'Sonoma']]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>配備標準 M3 芯片的新款入門級 14 英寸 MacBook Pro 已經開始發貨。部分用户發現，這款新產品預裝的是 macOS Ventura (13.5)，目前無法通過 OTA 升級的方式升級至 macOS Sonoma (14)。</p><p>這些用户<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Faaronp613%2Fstatus%2F1721742053170684065" target="_blank">表示</a></u>，他們嘗試在「系統設置」中更新到 macOS Sonoma 時，系統提示 macOS Ventura 13.5 是可用的最新版本，而非 macOS Sonoma 14.1。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1108/115949_tV93_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>via<em><u>&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2FZONEofTECH%2Fstatus%2F1721868285732344224" target="_blank">https://twitter.com/ZONEofTECH/status/1721868285732344224</a></u></em></p><p>目前尚不清楚蘋果何時會解決這個問題。軟件研究員 Nicolás Álvarez 表示，受影響用户可以下載 <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fswcdn.apple.com%2Fcontent%2Fdownloads%2F54%2F11%2F042-41700-A_6GDS7ETYNV%2Fzxpkgymp3w9bm3py7ybs9n9ud27qwnwx7u%2FInstallAssistant.pkg" target="_blank">macOS Sonoma 14.1 安裝助手</a></u>（兼容 M3 版本）並手動安裝更新。</p><p>據稱這個問題也會<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F9to5mac.com%2F2023%2F11%2F07%2Fm3-macbook-pro-imac-sonoma-fails%2F" target="_blank">影響</a></u>搭載 M3 芯片的新款 iMac。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 04:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265559/macbook-pro-m3-macos-sonoma-update-issue</guid>
            <link>https://www.oschina.net/news/265559/macbook-pro-m3-macos-sonoma-update-issue</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[IBM 推出 5 億美元企業 AI 風險投資基金]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">IBM&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.prnewswire.com%2Fnews-releases%2Fibm-launches-500-million-enterprise-ai-venture-fund-301979178.html" target="_blank">宣佈</a>計劃對專注於企業 AI 的初創公司進行更多投資，將啓動一項 5 億美元的風險投資基金。該基金將投資「一系列&nbsp;AI&nbsp;公司 —— 從早期階段到高速增長的初創公司 —— 專注於加速企業的生成式 AI 技術和研究。」</span></p><p><span style="color:#000000">今年 8 月份，IBM&nbsp;還參與了開源 AI 平台 Hugging Face 的 2.35 億美元 D 輪融資。並在近期參投了 AI 模型和資產安全廠商 HiddenLayer 的 5000 萬美元 A 輪融資，此輪融資也是今年專注於保護 AI 的網絡安全公司籌集的最大一筆 A 輪融資。</span></p><p><img height="188" src="https://oscimg.oschina.net/oscnet/up-4118d3cd5048d2cdd19ef109bc0e70b828e.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000">IBM 方面表示，其企業 AI 風險基金將投資於當前和未來的&nbsp;AI&nbsp;領導者，幫助世界各地的企業實現 AI 的商業潛力。該基金由 IBM 的一支專業團隊領導，為每家初創公司提供與 IBM 建立有意義的合作伙伴關係的機會，同時獲得產品和工程以及上市方面的運營專業知識策略。</span></p><p><span style="color:#000000">IBM 軟件高級副總裁兼首席商務官 Rob Thomas 稱，</span></p><p><span style="color:#000000">「到 2030 年，&nbsp;AI&nbsp;預計將創造近 16 萬億美元的生產力。隨着 IBM 企業&nbsp;AI&nbsp;風險投資基金的推出，我們正在開闢另一個渠道，利用 AI 革命的巨大潛力，為 IBM 和我們所投資的公司帶來實實在在的積極成果。這筆基金是我們通過 watsonx 加倍履行我們對負責任的 AI&nbsp;創新的承諾，並幫助企業將這一變革性技術付諸實踐的又一方式。」</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 03:37:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265552/ibm-500-million-enterprise-ai-venture-fund</guid>
            <link>https://www.oschina.net/news/265552/ibm-500-million-enterprise-ai-venture-fund</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[蘋果副總裁迴應「黃金內存」：「統一內存架構」的 8GB 近似於其它系統的 16GB]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>B 站 up 主 @林亦 LYi 最近採訪了蘋果全球產品營銷副總裁 Bob Borchers，期間聊到了大家關心的「祖傳黃金 8GB 內存」問題。</p><p>針對蘋果入門級 MacBook Pro 只給 8GB 內存的問題，Bob Borchers 表示蘋果 MacBook Pro 採用了統一內存架構，所以它與其它系統的內存並不完全相同。因為蘋果內存利用率更高，再加上蘋果的內存壓縮技術，蘋果 M3 款 MacBook Pro 中&nbsp;8GB 內存和其它系統的 16GB 表現接近，所以不能只看紙面參數，要關注實際體驗。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-93ec8d8aebc69057228bb55fb8b7229e485.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a317c842c946aae94e3674f1efda6cef21e.png" referrerpolicy="no-referrer"></p><p>【8G 內存？蘋果高管怎麼看 M3 MacBook Pro？】<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV16M411Q7BG%2F" target="_blank">https://www.bilibili.com/video/BV16M411Q7BG/</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 03:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265547</guid>
            <link>https://www.oschina.net/news/265547</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Fedora 39 正式發佈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Fedora 39 已正式發佈。此版本採用 Linux 6.5 內核，更新的版本將作為穩定版更新發布。</p><p><img src="https://static.oschina.net/uploads/space/2023/1108/111228_g9O6_2720166.png" referrerpolicy="no-referrer"></p><p><strong>下載地址</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fworkstation%2Fdownload%2F" target="_blank">Fedora Workstation 39</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fserver%2Fdownload%2F" target="_blank">Fedora Server 39</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fiot%2Fdownload%2F" target="_blank">Fedora IoT 39</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fcloud%2Fdownload%2F" target="_blank">Fedora Cloud 39</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fcoreos%2Fdownload%3Fstream%3Dnext" target="_blank">Fedora CoreOS 「next」 stream</a></li></ul><p>Fedora Workstation 39 搭載 GNOME 45 桌面環境、LibreOffice 7.6 辦公套件、LLVM 17 編譯器棧以及許多其他可用的更新軟件包。</p><p>Fedora 39 還有各種工具鏈升級，如 GCC 13.2 和 GNU Binutils 2.40、Glibc 2.38 以及其他更新，如 Python 3.12 和 RPM 4.19。Fedora Onyx 也將作為 Fedora 不可變變體與 Budgie 桌面正式亮相。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d3bc4d25724768ddc84dd034104a3f7e4e9.png" referrerpolicy="no-referrer"></p><p><strong>以下是官方介紹譯文：</strong></p><p>2003 年 11 月 6 日，Fedora 項目發佈了 Fedora Core 1。二十年後的今天 Fedora Linux 39 正式發佈，這是為台式機、筆記本電腦、服務器、雲、邊緣設備以及您能想到的任何其他設備打造的完整的社區操作系統。</p><p>Fedora 工作站現在採用 GNOME 45，它帶來了更好的性能和許多可用性增強功能，包括一個新的工作區切換器和一個大為改進的圖片查看器。</p><p>如果您正在尋找不同的桌面體驗，Budgie 特別興趣小組已經創建了 Fedora Onyx，這是一個基於 Budgie 的"原子"桌面，與 Fedora Silverblue 的精神一脈相承。</p><p>當然，這還不是全部，系統還提供了 KDE Plasma 桌面、Xfce、Cinnamon 等桌面。</p><p>Fedora 雲鏡像將在 Microsoft Azure（除了 Google Cloud 和 AWS 之外）正式可用。此外，我們的雲鏡像現在已配置為 cloud-init（由您選擇）安裝更新，並在首次調配時重啓，這樣您就可以知道您正在運行的是最新的安全更新。</p><p>一如既往，Fedora 39 更新了很多很多其他軟件包，包含 gcc 13.2、binutils 2.40、glibc 2.38、gdb 13.2 和 rpm 4.19。它還更新了流行的編程語言棧，包括 Python 3.12 和 Rust 1.73。</p><p>特別值得一提的是，系統包含了 Inkscape 的最新版本，這是一款流行的矢量圖形插圖和繪圖工具。Inkscape 昨天也滿 20 週歲了。</p><p>原文：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoramagazine.org%2Fannouncing-fedora-linux-39%2F" target="_blank">https://fedoramagazine.org/announcing-fedora-linux-39/</a></u></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 02:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265540/fedora-linux-39</guid>
            <link>https://www.oschina.net/news/265540/fedora-linux-39</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[騰訊開源高性能輕量級跨平台 QUIC 協議庫-TQUIC]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">騰訊開源了一個<span style="background-color:#ffffff">基於 RUST 語言開發的 QUIC 協議庫 -&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FwRC2htPOMYevTgfxIY1uWw" target="_blank">TQUIC</a>，<span style="background-color:#ffffff">旨在打造一個穩定、快速、高性能並具有廣泛技術影響力的傳輸協議庫。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">「</span>由於 QUIC 所具備的廣泛性、長期性、創新性特點，我們開源了自研的 TQUIC 協議庫，也希望借 TQUIC 開源的機會, 吸引更多的同學共建，一起促進傳輸協議的發展，提升互聯網快速和安全的傳輸體驗。<span style="background-color:#ffffff">」</span></span></p><p style="color:#353535; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">TQUIC 協議庫具有如下的優勢：</span></p><ul><li style="text-align:start"><span style="color:#000000"><strong>快傳輸：</strong>TQUIC 是業界支持擁塞控制算法最豐富的協議庫，在全部場景下表現符合 RFC 預期，在弱網和部分場景下傳輸效果領先 2%-30%。</span></li><li style="text-align:start"><span style="color:#000000"><strong>高性能：</strong>TQUIC 在大部分測試場景下的單機處理性能優於同類開源產品 5%，部分場景下單機處理性能領先 20%。</span></li><li style="text-align:start"><span style="color:#000000"><strong>高質量<span style="background-color:#ffffff">：</span></strong>QUIC 協議棧涵蓋 10+篇核心的 RFC 標準或草案，同時涉及到傳輸層、安全層、應用層，複雜度遠大於 TCP。TQUIC 單元測試覆蓋率 95% 以上，與業界四個主流 QUIC 實現的互操性測試用例通過率為 100%， 同時採用基於形式化規範 (SIGCOMM2019 論文成果）的測試方法，嚴格保障了協議一致性。</span></li><li style="text-align:start"><span style="color:#000000"><strong>易用性：</strong>TQUIC 易於使用，支持靈活的配置和豐富的可觀察性；TQUIC 提供了 Rust/C/C++多語言接口，未來計劃進一步提供 Kotlin/Swift 等語言接口。</span></li><li style="text-align:start"><span style="color:#000000"><strong>基於 RUST<span style="background-color:#ffffff">：</span></strong>TQUIC 基於內存安全語言編寫，不受緩衝區溢出漏洞和其他與內存相關缺陷影響。</span></li><li style="text-align:start"><span style="color:#000000"><strong>豐富特性<span style="background-color:#ffffff">：</span></strong>TQUIC 支持所有 QUIC 和 HTTP/3 規範的重要特性。</span></li></ul><p>架構圖：</p><p><img alt="" height="373" src="https://oscimg.oschina.net/oscnet/up-96c0da66ae752f38efa3109e35055f2ffe9.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#353535; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">TQUIC 將跨平台兼容及多併發模型支持作為關鍵的設計目標。TQUIC 核心採用了網絡 IO 及事件循環抽象化設計。TQUIC 核心並不依賴於套接字，而是通過用户提供的回調來實現。同時，TQUIC 核心沒有強加特定的事件循環要求，它提供了幫助用户調度事件的函數。TQUIC 的靈活性使得易於在各種系統中的定製和集成。</span></p><p style="color:#353535; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">TQUIC 接口層提供了面向主流平台編程語言的高層級封裝接口，支持同步、異步語義接口，兼容不同的併發模型，並簡化用户的使用。</span></p><p><span style="color:#000000"><strong>後續規劃：</strong></span></p><ul><li style="text-align:start"><span style="color:#000000">對接開源技術生態，擴大 TQUIC 使用場景，進一步提升 TQUIC 使用體驗。</span></li><li style="text-align:start"><span style="color:#000000">發表相關論文，並逐步開源更多 TQUIC 高級特性和算法。</span></li><li style="text-align:start"><span style="color:#000000">追蹤 QUIC 協議的演進和創新，並持續提升 TQUIC 核心能力。</span></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 02:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265538</guid>
            <link>https://www.oschina.net/news/265538</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Bun 招募運行時工程師，要求 C/C++ 或 Zig 經驗，可遠程]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Bun 公司正在招聘運行時工程師。Bun 是速度極快的 JavaScript 運行時，採用 Zig 編寫，集打包器、轉譯器和包管理器於一身。</p><h4><strong>任職要求</strong></h4><ul><li><p>在系統編程語言如 Zig 或 C/C++方面有豐富的經驗</p></li><li><p>對互聯網技術如 JavaScript/TypeScript 和 HTTP 有深入理解</p></li><li><p>熱衷於編寫快速高效的代碼</p></li></ul><h4><strong>加分項</strong></h4><ul><li><p>具有 Zig 的經驗（大部分的 Bun 都是用 Zig 編寫的）</p></li><li><p>具有 JavaScript 運行時深入層面的經驗：JavaScriptCore、V8、SpiderMonkey</p></li><li><p>理解 UNIX 系統、內核、TCP/UDP 網絡</p></li><li><p>理解如何構建多租户，大規模分佈式系統</p></li><li><p>開源軟件的維護者或頻繁的貢獻者</p></li></ul><h4><strong>福利</strong></h4><ul><li><p>位置：舊金山市中心有自己的辦公室，並且每天提供免費午餐</p></li><li><p>遠程工作 OK：如果願意搬到舊金山，會提供額外的獎金，但可以在任何地方遠程辦公</p></li><li><p>薪酬：提供具有競爭力的薪酬，包括創業公司的股權，並根據貢獻提供成長空間</p></li><li><p>醫療保健：提供靈活的健康計劃，涵蓋身體和精神健康護理</p></li><li><p>休假：每年享有四周的帶薪休假，包括靈活的病假、家庭假和心理健康假</p></li><li><p>補貼：通勤到辦公室，電腦硬件，辦公室設置，以及健身習慣等方面提供支持</p></li></ul><p><img height="1762" src="https://static.oschina.net/uploads/space/2023/1108/103613_dUzY_3820517.png" width="1458" referrerpolicy="no-referrer"></p><p>詳情查看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fapply.workable.com%2Foven%2Fj%2FA7A1388873%2F" target="_blank">https://apply.workable.com/oven/j/A7A1388873</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 02:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265534/bun-hiring-runtime-engineer</guid>
            <link>https://www.oschina.net/news/265534/bun-hiring-runtime-engineer</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[HelloGitHub 社區動態，開啓新的篇章！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107191851907-206780890.png" alt="" referrerpolicy="no-referrer"></p><p>今天這篇文章是 HelloGitHub 社區動態的第一篇文章，所以我想多説兩句，聊聊為啥開啓這個系列。</p><p>我是 2016 年創建的 HelloGitHub，它從最初的一份分享開源項目的月刊，現如今已經成長為 7w+ Star 的開源項目、1w+ 用户的開源社區、全網 50w+ 的自媒體。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185115225-596937695.png" alt="" referrerpolicy="no-referrer"></p><p>我本是一名普通的程序員，三流的技術水平、毫無文筆、開源門外漢，起初連 Git 都不會，也不知道什麼是開源，就一個猛子扎進來做了 HelloGitHub。為了想讓更多人看到 HelloGitHub 月刊，稀裏糊塗地就做起了「自媒體」。我為了圓自己的站長夢，餓着肚子咬牙重構了 HelloGitHub.com 網站，從最初的 Web 1.0 的月刊展示，升級到了 Web 2.0 的開源社區。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231108085617330-199475160.png" alt="" referrerpolicy="no-referrer"></p><p>聰明的人追着風口跑，很容易就賺到錢了。像我這種愚笨的人，只做「分享開源項目」這一件事情，就花了 7 年的事情，錢沒賺到人還瘦了兩圈😂。</p><p>有人説我不會玩流量，確實我不會，因為在我眼裏每一次點擊、每一個閲讀、每一位粉絲背後都是我的一位朋友。説起來真是慚愧，就是我和朋友們的溝通太少了，因為<strong>我總想一個人、一台電腦、一把鍵盤，做出讓人拍手稱讚的事情</strong>。這件事我試過了，我自己搞不了！</p><p>有錯就要認，捱打要立正。所以，我決定經常和朋友們説説關於 HelloGitHub 社區的事情，<strong>希望通過這個系列打開一個窗口，讓社區成員瞭解項目的發展方向，想加入進來的人知道自己能做些什麼</strong>，同時我也能多瞭解大家的想法，多和朋友們討論，凝聚更多人的力量。</p><p>所以，就有了這篇「HelloGitHub 社區動態」的文章，我是這樣想的：以後每個月月初寫一下上個月關於 HelloGitHub 社區發生的事兒、未來要做的事兒、大家一起能做的事兒。<strong>一羣人做一件值得驕傲的事情</strong>，這事兒沒準能成！</p><p>我要説的就這些，下面正文開始。</p><h2>一、介紹</h2><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185411363-1285676789.gif" alt="" referrerpolicy="no-referrer"></p><p>HelloGitHub 是一個分享 GitHub 上有趣、入門級開源項目的開源社區，由一羣熱愛開源的小夥伴運營，我們<strong>因開源而相聚，為興趣而付出</strong>，希望通過分享和講解開源項目，幫助大家找到編程的樂趣、輕鬆搞定問題的技術方案、令人驚歎的開源神器，從而順應內心的渴望，毫無保留地踏上開源之旅。</p><h2>二、社區動態</h2><p>接下來，我將和「在座」的各位彙報下 10 月份的 HelloGitHub 開源社區的項目進展、貢獻者和未來計劃，歡迎朋友們為社區的建設提供建議、反饋和做貢獻，讓我們並肩攜手共創 HelloGitHub 社區。</p><ul><li>項目進展：介紹主要項目的最新進展情況，包括新增功能、修復的問題、</li><li>貢獻者：表彰和讚揚過去一個月對項目做出傑出貢獻的個人，歡迎新加入開源社區的貢獻者，以及在做的事情和經驗分享。</li><li>下一步計劃：聊一聊接下來要做的事情。</li></ul><h3>2.1 項目進展</h3><p>HelloGitHub 的項目概覽：</p><ol><li>月刊：這裏有好玩、有趣、入門級的開源項目，每月 28 號發刊。</li><li>熱點速遞：每週一更新的週刊，分享和介紹 GitHub 過去一週的熱點項目。</li><li>講解系列：通過一篇文章的篇幅帶你入門一款開源項目，不定期更新。</li><li>社區網站：圍繞開源項目建立的社區，大家可以在這裏分享、發現、評論、打分、收藏感興趣的開源項目。</li></ol><p><strong>社區網站</strong></p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185145824-1576267720.gif" alt="" referrerpolicy="no-referrer"></p><p>上個月主要做了用户反饋最多的「標籤功能」的優化，入口在 PC 端訪問社區的左側「管理標籤」按鈕（需登錄）。詳情如下：</p><ol><li>為標籤設置了分組，分成了編程語言、技術棧、應用類型、其它共 4 組，方便用户更快地找到自己感興趣的標籤，對於沒有編程能力的朋友也可以通過桌面應用、Android、Windows、macOS 等標籤找到開箱即用的應用。</li><li>支持拖拽的方式選擇標籤和排序。</li><li>新增 PHP、Ruby、Flutter、嵌入式、Docker、Vue 等 13 個標籤。</li></ol><blockquote><p>地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhellogithub.com%2F" target="_blank">https://hellogithub.com/</a></p></blockquote><p><strong>內容</strong></p><p>HelloGitHub 自媒體 10 月份共發佈了 4 篇 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzA5MzYyNzQ0MQ%3D%3D%26action%3Dgetalbum%26album_id%3D1332112026222641153%26scene%3D173%26from_msgid%3D2247516881%26from_itemidx%3D1%26count%3D3%26nolastread%3D1%23wechat_redirect" target="_blank">GitHub 熱點速遞</a>、1 篇<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzA5MzYyNzQ0MQ%3D%3D%26action%3Dgetalbum%26album_id%3D1332147780885856258%26scene%3D173%26from_msgid%3D2247516865%26from_itemidx%3D1%26count%3D3%26nolastread%3D1%23wechat_redirect" target="_blank">講解開源項目的文章</a>、1 篇 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzA5MzYyNzQ0MQ%3D%3D%26action%3Dgetalbum%26album_id%3D1331197538447310849%26scene%3D173%26from_msgid%3D2247516838%26from_itemidx%3D1%26count%3D3%26nolastread%3D1%23wechat_redirect" target="_blank">HelloGitHub 月刊</a>。</p><h3>2.2 貢獻者</h3><p>因為這是第一篇社區動態，所以我必須要感謝下 2023 至今的所有貢獻者，他們的每個貢獻對於我來説都是雪中送炭，主要集中於 HelloGitHub 社區前端代碼的貢獻。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185421588-1660267532.png" alt="" referrerpolicy="no-referrer"></p><ul><li>@胤玄、@cqh：完成管理標籤功能的設計和優化</li><li>@胤玄：修復月刊目錄的問題、修復了彈出對話框後背景頁面滾動的問題</li><li>@GJSSS：修復圖片預覽時沒有關閉圖標的問題、主題切換按鈕的樣式</li><li>@Maidang：修復黑暗主題下點擊詳情頁的問題</li></ul><p><strong>如何貢獻</strong></p><p>如果你會寫代碼可以加入到 HelloGitHub 社區的開發中，前後端都需要。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185426160-863675536.png" alt="" referrerpolicy="no-referrer"></p><blockquote><p>需求列表：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FHelloGitHub-Team%2Fgeese%2Fissues%2F38" target="_blank">https://github.com/HelloGitHub-Team/geese/issues/38</a></p></blockquote><p>如果你喜歡寫文章歡迎投稿到 HelloGitHub，可以是你上手開源項目的經過、開源項目評測對比、有趣的開源項目集合等，不用擔心寫得不夠好，只要是用心寫的內容，我會和你一同完成它。</p><p>如果你發現了優秀的開源項目，歡迎分享到 HelloGitHub 讓更多人知道。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185430278-2003963940.gif" alt="" referrerpolicy="no-referrer"></p><p>希望 HelloGitHub 能成為你開源之路的第一站，讓我們一同成長，一起做值得驕傲的事情。</p><h3>2.3 下一步計劃</h3><p>為了能讓「社區動態」持續更新，所以每個月必須做出點成績來，才能向大家彙報。第一期我就説一下我自己下一步的打算，後面會結合朋友們的想法，來制定下一步計劃：</p><ol><li>幫助新加入的貢獻者為 HelloGitHub 做貢獻，多溝通、提供保姆級幫助。</li><li>完成網站搜索功能的優化，打通公眾號，即在公眾號發消息也能得到開源項目搜索結果。</li><li>為網站加入 AIGC 的功能，比如：根據自然語言描述推薦開源項目。</li><li>我想採訪一些「民間」做開源的人，講出他們的故事。</li><li>做視頻自媒體，這個事情我一直想做但始終沒有走出第一步，希望有人能推我一把。</li><li>天冷了是時候吃一頓火鍋了，搞一個線下的「開源人火鍋局」，互認識一下聊聊開源的酸甜苦辣，看看有沒有臭味相投的人。</li></ol><p>對上面的計劃感興趣的小夥伴，歡迎與我聯繫一起搞事情，也可以留言説出你的想法。</p><h2>三、最後</h2><p>如果把開源當成是一個愛好的話，就不會去深究為什麼要花時間在上面，因為從中能得到快樂和滿足感，就夠了。</p><p>最後，希望有了大家的陪伴，我們彼此的開源之路不再孤單和苦悶，而是充滿更多的歡聲笑語。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 02:17:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/HelloGitHub/blog/10141490</guid>
            <link>https://my.oschina.net/HelloGitHub/blog/10141490</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[LME - 日誌記錄和保護性監控解決方案]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Logging Made Easy (LME) 是一個免費、開放的日誌記錄和保護性監控解決方案，為所有組織提供服務。</p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Logging Made Easy 最初由 NCSC 創建，現在由 CISA 維護，是一個為小型組織提供的自助安裝教程，旨在為 Windows 客户端獲得基本級別的集中安全日誌記錄並提供檢測攻擊的功能。它是多個免費和開放軟件平台的結合，LME 幫助讀者將它們集成在一起以產生端到端的日誌記錄功能。還提供了一些預製的配置文件和腳本。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>該項目可以：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>顯示已註冊設備上運行管理命令的位置</li><li>查看誰在使用哪台機器</li><li>結合威脅報告，可以以策略、技術和程序 (TTP) 的形式查詢攻擊者的存在</li></ul><p><img height="229" src="https://static.oschina.net/uploads/space/2023/1101/164801_RGai_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 01:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/lme</guid>
            <link>https://www.oschina.net/p/lme</link>
        </item>
        <item>
            <title>
                <![CDATA[Xmake v2.8.5 發佈，支持鏈接排序和單元測試]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake" target="_blank">Xmake</a><span>&nbsp;</span>是一個基於 Lua 的輕量級跨平台構建工具。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它非常的輕量，沒有任何依賴，因為它內置了 Lua 運行時。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它使用 xmake.lua 維護項目構建，相比 makefile/CMakeLists.txt，配置語法更加簡潔直觀，對新手非常友好，短時間內就能快速入門，能夠讓用户把更多的精力集中在實際的項目開發上。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們能夠使用它像 Make/Ninja 那樣可以直接編譯項目，也可以像 CMake/Meson 那樣生成工程文件，另外它還有內置的包管理系統來幫助用户解決 C/C++ 依賴庫的集成使用問題。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">目前，Xmake 主要用於 C/C++ 項目的構建，但是同時也支持其他 native 語言的構建，可以實現跟 C/C++ 進行混合編譯，同時編譯速度也是非常的快，可以跟 Ninja 持平。</p><div><pre><code>Xmake = Build backend + Project Generator + Package Manager + [Remote|Distributed] Build + Cache
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">儘管不是很準確，但我們還是可以把 Xmake 按下面的方式來理解：</p><div><pre><code>Xmake ≈ Make/Ninja + CMake/Meson + Vcpkg/Conan + distcc + ccache/sccache
</code></pre></div><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake" target="_blank">項目源碼</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fxmake.io%2F%23%2Fzh-cn%2F" target="_blank">官方文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fxmake.io%2F%23%2Fzh-cn%2Fabout%2Fcourse" target="_blank">入門課程</a></li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><img src="https://github.com/xmake-io/xmake-docs/raw/master/assets/img/index/package.gif" width="650px" referrerpolicy="no-referrer"></p><h2>新特性介紹</h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在介紹新特性之前，我們有一個好消息要告訴大家，Xmake 最近進入了 Debian 的官方倉庫：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpackages.debian.org%2Fsid%2Fxmake" target="_blank">https://packages.debian.org/sid/xmake</a>， 等到明年 4 月份 Ubuntu 24.04 發佈，我們應該就能直接通過<span>&nbsp;</span><code>apt install xmake</code><span>&nbsp;</span>命令去快速安裝 Xmake 了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">同時也感謝 @Lance Lin 的幫助，他全程幫助我們維護並上傳 Xmake 包到 Debian 倉庫，真的非常感謝！</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">接下來，我們來介紹下 2.8.5 版本引入的一些改動，這個版本帶來了很多的新特性，尤其是對鏈接排序，鏈接組的支持，還有對<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>內置單元測試的支持。 另外，我們還新增了 Apple XROS 平台的構建支持，可以用於構建蘋果新的 VisionOS 上的程序，還有我們還提供了更加靈活通用的<span>&nbsp;</span><code>check_sizeof</code><span>&nbsp;</span>檢測接口，用於快速檢測類型的大小。</p><h3>鏈接重排序支持</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這是一個存在了兩年多的需求，主要用於調整 target 內部的鏈接順序。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">由於 xmake 提供了<span>&nbsp;</span><code>add_links</code>,<span>&nbsp;</span><code>add_deps</code>,<span>&nbsp;</span><code>add_packages</code>,<span>&nbsp;</span><code>add_options</code><span>&nbsp;</span>接口，可以配置目標、依賴，包和選項中的鏈接，儘管<span>&nbsp;</span><code>add_links</code><span>&nbsp;</span>本身的鏈接順序可以根據添加順序來調整。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是 links，deps 和 packages 之間的鏈接順序，只能按固定順序生成，無法靈活調整，這對於一些複雜的項目，就有點顯得力不從心了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">而我們在這個版本，徹底解決了這個問題，新增了<span>&nbsp;</span><code>add_linkorders</code><span>&nbsp;</span>接口，可用於配置目標、依賴、包、選項、鏈接組引入的各種鏈接順序。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">更多詳情和背景，請見：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F1452" target="_blank">#1452</a></p><h4>排序鏈接</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">為了更加靈活的調整 target 內部的各種鏈接順序，我們可以通過<span>&nbsp;</span><code>add_linkorders</code><span>&nbsp;</span>這個新接口來實現，例如：</p><div><pre><code><span style="color:#000000">add_links</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><span style="color:#ff00ff">"c"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>,</strong><span style="color:#ff00ff">"e"</span><strong>)</strong><em>-- e -&gt; b -&gt; a</em><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"e"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><span style="color:#ff00ff">"a"</span><strong>)</strong><em>-- e -&gt; d</em><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"e"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">add_links 是配置的初始鏈接順序，然後我們通過 add_linkorders 配置了兩個局部鏈接依賴<span>&nbsp;</span><code>e -&gt; b -&gt; a</code><span>&nbsp;</span>和<span>&nbsp;</span><code>e -&gt; d</code><span>&nbsp;</span>後。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">xmake 內部就會根據這些配置，生成 DAG 圖，通過拓撲排序的方式，生成最終的鏈接順序，提供給鏈接器。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">當然，如果存在循環依賴，產生了環，它也會提供警告信息。</p><h4>排序鏈接和鏈接組</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，對於循環依賴，我們也可以通過<span>&nbsp;</span><code>add_linkgroups</code><span>&nbsp;</span>配置鏈接組的方式也解決。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">並且<span>&nbsp;</span><code>add_linkorders</code><span>&nbsp;</span>也能夠對鏈接組進行排序。</p><div><pre><code><span style="color:#000000">add_links</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><span style="color:#ff00ff">"c"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>,</strong><span style="color:#ff00ff">"e"</span><strong>)</strong><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"c"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>,</strong><strong>{</strong><span style="color:#000000">name</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">group</span><strong>=</strong><strong>true</strong><strong>})</strong><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"e"</span><strong>,</strong><span style="color:#ff00ff">"linkgroup::foo"</span><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果要排序鏈接組，我們需要對每個鏈接組取個名，<code><span>{</span><span>name</span><span><span>&nbsp;</span></span><span>=</span><span><span>&nbsp;</span></span><span>"foo"</span><span>}</span></code><span>&nbsp;</span>，然後就能在<span>&nbsp;</span><code>add_linkorders</code><span>&nbsp;</span>裏面通過<span>&nbsp;</span><code>linkgroup::foo</code><span>&nbsp;</span>去引用配置了。</p><h4>排序鏈接和 frameworks</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以排序鏈接和 macOS/iPhoneOS 的 frameworks。</p><div><pre><code><span style="color:#000000">add_links</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><span style="color:#ff00ff">"c"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>,</strong><span style="color:#ff00ff">"e"</span><strong>)</strong><span style="color:#000000">add_frameworks</span><strong>(</strong><span style="color:#ff00ff">"Foundation"</span><strong>,</strong><span style="color:#ff00ff">"CoreFoundation"</span><strong>)</strong><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"e"</span><strong>,</strong><span style="color:#ff00ff">"framework::CoreFoundation"</span><strong>)</strong></code></pre></div><h4>完整例子</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">相關的完整例子，我們可以看下：</p><div><pre><code><span style="color:#000000">add_rules</span><strong>(</strong><span style="color:#ff00ff">"mode.debug"</span><strong>,</strong><span style="color:#ff00ff">"mode.release"</span><strong>)</strong><span style="color:#000000">add_requires</span><strong>(</strong><span style="color:#ff00ff">"libpng"</span><strong>)</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"bar"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"shared"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/foo.cpp"</span><strong>)</strong><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"m"</span><strong>,</strong><span style="color:#ff00ff">"pthread"</span><strong>,</strong><strong>{</strong><span style="color:#000000">whole</span><strong>=</strong><strong>true</strong><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"foo"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"static"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/foo.cpp"</span><strong>)</strong><span style="color:#000000">add_packages</span><strong>(</strong><span style="color:#ff00ff">"libpng"</span><strong>,</strong><strong>{</strong><span style="color:#000000">public</span><strong>=</strong><strong>true</strong><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"demo"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">add_deps</span><strong>(</strong><span style="color:#ff00ff">"foo"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/main.cpp"</span><strong>)</strong><span style="color:blue">if</span><span style="color:#000000">is_plat</span><strong>(</strong><span style="color:#ff00ff">"linux"</span><strong>,</strong><span style="color:#ff00ff">"macosx"</span><strong>)</strong><span style="color:blue">then</span><span style="color:#000000">add_syslinks</span><strong>(</strong><span style="color:#ff00ff">"pthread"</span><strong>,</strong><span style="color:#ff00ff">"m"</span><strong>,</strong><span style="color:#ff00ff">"dl"</span><strong>)</strong><span style="color:blue">end</span><span style="color:blue">if</span><span style="color:#000000">is_plat</span><strong>(</strong><span style="color:#ff00ff">"macosx"</span><strong>)</strong><span style="color:blue">then</span><span style="color:#000000">add_frameworks</span><strong>(</strong><span style="color:#ff00ff">"Foundation"</span><strong>,</strong><span style="color:#ff00ff">"CoreFoundation"</span><strong>)</strong><span style="color:blue">end</span><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"framework::Foundation"</span><strong>,</strong><span style="color:#ff00ff">"png16"</span><strong>,</strong><span style="color:#ff00ff">"foo"</span><strong>)</strong><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"dl"</span><strong>,</strong><span style="color:#ff00ff">"linkgroup::syslib"</span><strong>)</strong><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"m"</span><strong>,</strong><span style="color:#ff00ff">"pthread"</span><strong>,</strong><strong>{</strong><span style="color:#000000">name</span><strong>=</strong><span style="color:#ff00ff">"syslib"</span><strong>,</strong><span style="color:#000000">group</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">完整工程在：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fblob%2Fmaster%2Ftests%2Fprojects%2Fc%252B%252B%2Flinkorders%2Fxmake.lua" target="_blank">linkorders example</a></p><h3>鏈接組支持</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，這個版本，我們還新增了鏈接組的原生支持，它目前主要用於 linux 平台的編譯，僅支持 gcc/clang 編譯器。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">需要注意的是 gcc/clang 裏面的鏈接組概念主要特指：<code>-Wl,--start-group</code></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">而 Xmake 對齊進行了封裝，做了進一步抽象，並且不僅僅用於處理<span>&nbsp;</span><code>-Wl,--start-group</code>，還可以處理<span>&nbsp;</span><code>-Wl,--whole-archive</code><span>&nbsp;</span>和<span>&nbsp;</span><code>-Wl,-Bstatic</code>。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">下面我們會一一對其進行講解。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">更多詳情見：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F1452" target="_blank">#1452</a></p><h4>–start-group 支持</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><code>-Wl,--start-group</code><span>&nbsp;</span>和<span>&nbsp;</span><code>-Wl,--end-group</code><span>&nbsp;</span>是用於處理複雜庫依賴關係的鏈接器選項，確保鏈接器可以解決符號依賴併成功連接多個庫。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 xmake 中，我們可以通過下面的方式實現：</p><div><pre><code><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它會對應生成<span>&nbsp;</span><code>-Wl,--start-group -la -lb -Wl,--end-group</code><span>&nbsp;</span>鏈接選項。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果 a 和 b 庫之間有符號的循環依賴，也不會報鏈接錯誤，能夠正常鏈接成功。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">對於不支持的平台和編譯，會退化成<span>&nbsp;</span><code>-la -lb</code></p><h4>–whole-archive 支持</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><code>--whole-archive</code><span>&nbsp;</span>是一個鏈接器選項，通常用於處理靜態庫。 它的作用是告訴鏈接器將指定的靜態庫中的所有目標文件都包含到最終可執行文件中，而不僅僅是滿足當前符號依賴的目標文件。 這可以用於確保某些庫的所有代碼都被鏈接，即使它們在當前的符號依賴關係中沒有直接引用。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">更多信息，可以參考 gcc/clang 的文檔。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 xmake 中，我們可以通過下面的方式實現：</p><div><pre><code><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><strong>{</strong><span style="color:#000000">whole</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它會對應生成<span>&nbsp;</span><code>-Wl,--whole-archive -la -lb -Wl,--no-whole-archive</code><span>&nbsp;</span>鏈接選項。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">對於不支持的平台和編譯，會退化成<span>&nbsp;</span><code>-la -lb</code></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，我們可以同時配置 group/whole：</p><div><pre><code><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><strong>{</strong><span style="color:#000000">whole</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">group</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><h4>-Bstatic 支持</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><code>-Bstatic</code><span>&nbsp;</span>也是用於編譯器（如 gcc）的選項，用於指示編譯器在鏈接時只使用靜態庫而不使用共享庫。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">更多信息，可以參考 gcc/clang 的文檔。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 xmake 中，我們可以通過下面的方式實現：</p><div><pre><code><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><strong>{</strong><span style="color:#000000">static</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它會對應生成<span>&nbsp;</span><code>-Wl,-Bstatic -la -lb -Wl,-Bdynamic</code><span>&nbsp;</span>鏈接選項。</p><h3>單元測試支持</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">新版本中，我們還增加了一個內置的測試命令：<code>xmake test</code>，我們只需要在需要測試的 target 上通過 add_tests 配置一些測試用例，就可以自動執行測試。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">即使當前 target 被設置成了<span>&nbsp;</span><code>set_default(false)</code>，在執行測試的時候，xmake 也還是會先自動編譯它們，然後自動運行所有的測試。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們可以先看個整體的例子，大概知道下它是怎麼樣子的。</p><div><pre><code><span style="color:#000000">add_rules</span><strong>(</strong><span style="color:#ff00ff">"mode.debug"</span><strong>,</strong><span style="color:#ff00ff">"mode.release"</span><strong>)</strong><span style="color:blue">for</span><span style="color:#000000">_</span><strong>,</strong><span style="color:#000000">file</span><span style="color:blue">in</span><span style="color:black">ipairs</span><strong>(</strong><span style="color:#000000">os</span><strong>.</strong><span style="color:#000000">files</span><strong>(</strong><span style="color:#ff00ff">"src/test_*.cpp"</span><strong>))</strong><span style="color:blue">do</span><span style="color:blue">local</span><span style="color:#000000">name</span><strong>=</strong><span style="color:#000000">path</span><strong>.</strong><span style="color:#000000">basename</span><strong>(</strong><span style="color:#000000">file</span><strong>)</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#000000">name</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/"</span><strong>..</strong><span style="color:#000000">name</span><strong>..</strong><span style="color:#ff00ff">".cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"default"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"args"</span><strong>,</strong><strong>{</strong><span style="color:#000000">runargs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#ff00ff">"bar"</span><strong>}})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"pass_output"</span><strong>,</strong><strong>{</strong><span style="color:#000000">trim_output</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">runargs</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello foo"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"fail_output"</span><strong>,</strong><strong>{</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"hello2 .*"</span><strong>,</strong><span style="color:#ff00ff">"hello xmake"</span><strong>}})</strong><span style="color:blue">end</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這個例子，自動掃描源碼目錄下的<span>&nbsp;</span><code>test_*.cpp</code><span>&nbsp;</span>源文件，然後每個文件自動創建一個測試目標，它被設置成了<span>&nbsp;</span><code>set_default(false)</code>，也就是正常情況下，默認不會編譯它們。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是，如果執行<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>進行測試，它們就會被自動編譯，然後測試運行，運行效果如下：</p><div><pre><code>ruki-2:test ruki<span style="color:black">$ </span>xmake <span style="color:black">test
</span>running tests ...
<strong>[</strong>  2%]: test_1/args        .................................... passed 7.000s
<strong>[</strong>  5%]: test_1/default     .................................... passed 5.000s
<strong>[</strong>  8%]: test_1/fail_output .................................... passed 5.000s
<strong>[</strong> 11%]: test_1/pass_output .................................... passed 6.000s
<strong>[</strong> 13%]: test_2/args        .................................... passed 7.000s
<strong>[</strong> 16%]: test_2/default     .................................... passed 6.000s
<strong>[</strong> 19%]: test_2/fail_output .................................... passed 6.000s
<strong>[</strong> 22%]: test_2/pass_output .................................... passed 6.000s
<strong>[</strong> 25%]: test_3/args        .................................... passed 7.000s
<strong>[</strong> 27%]: test_3/default     .................................... passed 7.000s
<strong>[</strong> 30%]: test_3/fail_output .................................... passed 6.000s
<strong>[</strong> 33%]: test_3/pass_output .................................... passed 6.000s
<strong>[</strong> 36%]: test_4/args        .................................... passed 6.000s
<strong>[</strong> 38%]: test_4/default     .................................... passed 6.000s
<strong>[</strong> 41%]: test_4/fail_output .................................... passed 5.000s
<strong>[</strong> 44%]: test_4/pass_output .................................... passed 6.000s
<strong>[</strong> 47%]: test_5/args        .................................... passed 5.000s
<strong>[</strong> 50%]: test_5/default     .................................... passed 6.000s
<strong>[</strong> 52%]: test_5/fail_output .................................... failed 6.000s
<strong>[</strong> 55%]: test_5/pass_output .................................... failed 5.000s
<strong>[</strong> 58%]: test_6/args        .................................... passed 7.000s
<strong>[</strong> 61%]: test_6/default     .................................... passed 6.000s
<strong>[</strong> 63%]: test_6/fail_output .................................... passed 6.000s
<strong>[</strong> 66%]: test_6/pass_output .................................... passed 6.000s
<strong>[</strong> 69%]: test_7/args        .................................... failed 6.000s
<strong>[</strong> 72%]: test_7/default     .................................... failed 7.000s
<strong>[</strong> 75%]: test_7/fail_output .................................... failed 6.000s
<strong>[</strong> 77%]: test_7/pass_output .................................... failed 5.000s
<strong>[</strong> 80%]: test_8/args        .................................... passed 7.000s
<strong>[</strong> 83%]: test_8/default     .................................... passed 6.000s
<strong>[</strong> 86%]: test_8/fail_output .................................... passed 6.000s
<strong>[</strong> 88%]: test_8/pass_output .................................... failed 5.000s
<strong>[</strong> 91%]: test_9/args        .................................... passed 6.000s
<strong>[</strong> 94%]: test_9/default     .................................... passed 6.000s
<strong>[</strong> 97%]: test_9/fail_output .................................... passed 6.000s
<strong>[</strong>100%]: test_9/pass_output .................................... passed 6.000s

<span style="color:#8f5902">80% </span>tests passed, 7 tests failed out of 36, spent 0.242s
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><img alt="" src="https://tboox.org/assets/img/manual/xmake-test1.png" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以執行<span>&nbsp;</span><code>xmake test -vD</code><span>&nbsp;</span>查看詳細的測試失敗的錯誤信息：</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><img alt="" src="https://tboox.org/assets/img/manual/xmake-test2.png" referrerpolicy="no-referrer"></p><h4>運行指定測試目標</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以指定運行指定 target 的某個測試：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test </span>targetname/testname
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">或者按模式匹配的方式，運行一個 target 的所有測試，或者一批測試：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test </span>targetname/<span style="color:blue">*</span><span style="color:#8f5902">$ </span>xmake <span style="color:black">test </span>targetname/foo<span style="color:blue">*</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">也可以運行所有 target 的同名測試：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span><span style="color:blue">*</span>/testname
</code></pre></div><h4>並行化運行測試</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">其實，默認就是並行化運行的，但是我們可以通過<span>&nbsp;</span><code>-jN</code><span>&nbsp;</span>調整運行的並行度。</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -jN
</code></pre></div><h4>分組運行測試</h4><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -g <span style="color:#ff00ff">"foo"</span><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -g <span style="color:#ff00ff">"foo*"</span></code></pre></div><h4>添加測試到目標（無參數）</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果沒有配置任何參數，僅僅配置了測試名到<span>&nbsp;</span><code>add_tests</code>，那麼僅僅測試這個目標程序的是否會運行失敗，根據退出代碼來判斷是否通過測試。</p><div><pre><code>target("test")
    add_tests("testname")
</code></pre></div><h4>配置運行參數</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過<span>&nbsp;</span><code><span>{</span><span>runargs</span><span><span>&nbsp;</span></span><span>=</span><span><span>&nbsp;</span></span><span>{</span><span>"arg1"</span><span>,</span><span><span>&nbsp;</span></span><span>"arg2"</span><span>}}</span></code><span>&nbsp;</span>的方式，給<span>&nbsp;</span><code>add_tests</code><span>&nbsp;</span>配置指定測試需要運行的參數。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，一個 target 可以同時配置多個測試用例，每個測試用例可獨立運行，互不衝突。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">runargs</span><strong>=</strong><span style="color:#ff00ff">"arg1"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">runargs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"arg1"</span><strong>,</strong><span style="color:#ff00ff">"arg2"</span><strong>}})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果我們沒有配置 runargs 到<span>&nbsp;</span><code>add_tests</code>，那麼我們也會嘗試從被綁定的 target 中，獲取<span>&nbsp;</span><code>set_runargs</code><span>&nbsp;</span>設置的運行參數。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">set_runargs</span><strong>(</strong><span style="color:#ff00ff">"arg1"</span><strong>,</strong><span style="color:#ff00ff">"arg2"</span><strong>)</strong></code></pre></div><h4>配置運行目錄</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過 rundir 設置測試運行的當前工作目錄，例如：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">rundir</span><strong>=</strong><span style="color:#000000">os</span><strong>.</strong><span style="color:#000000">projectdir</span><strong>()})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果我們沒有配置 rundir 到<span>&nbsp;</span><code>add_tests</code>，那麼我們也會嘗試從被綁定的 target 中，獲取<span>&nbsp;</span><code>set_rundir</code><span>&nbsp;</span>設置的運行目錄。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">set_rundir</span><strong>(</strong><span style="color:#ff00ff">"$(projectdir)"</span><strong>)</strong></code></pre></div><h4>配置運行環境</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過 runenvs 設置一些運行時候的環境變量，例如：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">runenvs</span><strong>=</strong><strong>{</strong><span style="color:#000000">LD_LIBRARY_PATH</span><strong>=</strong><span style="color:#ff00ff">"/lib"</span><strong>}})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果我們沒有配置 runenvs 到<span>&nbsp;</span><code>add_tests</code>，那麼我們也會嘗試從被綁定的 target 中，獲取<span>&nbsp;</span><code>add_runenvs</code><span>&nbsp;</span>設置的運行環境。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">add_runenvs</span><strong>(</strong><span style="color:#ff00ff">"LD_LIBRARY_PATH"</span><strong>,</strong><span style="color:#ff00ff">"/lib"</span><strong>)</strong></code></pre></div><h4>匹配輸出結果</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">默認情況下，<code>xmake test</code><span>&nbsp;</span>會根據測試運行的退出代碼是否為 0，來判斷是否測試通過。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">當然，我們也可以通過配置測試運行的輸出結果是否滿足我們的指定的匹配模式，來判斷是否測試通過。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">主要通過這兩個參數控制：</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#f8f8fd; border-bottom:2px solid #777777; border-collapse:collapse; border-top:2px solid #777777; color:#333333; font-family:&quot;Helvetica Neue&quot;,Helvetica,Arial,&quot;Microsoft YaHei&quot;,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin:8px 0px; orphans:2; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; word-spacing:0px"><tbody><tr><th style="text-align:left">參數</th><th style="text-align:left">説明</th></tr></tbody><tbody><tr><td>pass_outputs</td><td>如果輸出匹配，則測試通過</td></tr><tr><td>fail_outputs</td><td>如果輸出匹配，則測試失敗</td></tr></tbody></table><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">傳入<span>&nbsp;</span><code>pass_outputs</code><span>&nbsp;</span>和<span>&nbsp;</span><code>fail_outputs</code><span>&nbsp;</span>的是一個 lua 匹配模式的列表，但模式稍微做了一些簡化，比如對<span>&nbsp;</span><code>*</code><span>&nbsp;</span>的處理。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果要匹配成功，則測試通過，可以這麼配置：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname1"</span><strong>,</strong><strong>{</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname2"</span><strong>,</strong><strong>{</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello *"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname3"</span><strong>,</strong><strong>{</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"hello"</span><strong>,</strong><span style="color:#ff00ff">"hello *"</span><strong>}})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果要匹配成功，則測試失敗，可以這麼配置：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname1"</span><strong>,</strong><strong>{</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname2"</span><strong>,</strong><strong>{</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello *"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname3"</span><strong>,</strong><strong>{</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"hello"</span><strong>,</strong><span style="color:#ff00ff">"hello *"</span><strong>}})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以同時配置它們：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">由於一些測試輸出的結果，尾部會有一些換行什麼的空白字符，幹擾匹配模式，我們可以再配置<span>&nbsp;</span><code>trim_output = true</code>，先截斷空白字符後，再做匹配。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">trim_output</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們還可以配置<span>&nbsp;</span><code><span>{</span><span>plain</span><span><span>&nbsp;</span></span><span>=</span><span><span>&nbsp;</span></span><span>true</span><span>}</span></code><span>&nbsp;</span>是禁用 lua 模式匹配，僅僅做最基礎的平坦文本匹配。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">plain</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong></code></pre></div><h4>配置測試組</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過<span>&nbsp;</span><code>group = "foo"</code><span>&nbsp;</span>來配置一個測試組，進行分組測試：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname1"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname2"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname3"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><span style="color:#ff00ff">"bar"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname4"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><span style="color:#ff00ff">"bae"</span><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">其中 testname1/testname2 是一個組 foo，另外兩個是在另外一個組。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">然後，我們就可以使用<span>&nbsp;</span><code>xmake test -g groupname</code><span>&nbsp;</span>來進行分組測試了。</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -g <span style="color:#ff00ff">"foo"</span><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -g <span style="color:#ff00ff">"foo*"</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">!&gt; 運行分組，也是支持模式匹配的。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，如果沒有設置<span>&nbsp;</span><code>group</code><span>&nbsp;</span>參數給<span>&nbsp;</span><code>add_tests</code>，我們也可以默認獲取綁定到 target 的組名。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">set_group</span><strong>(</strong><span style="color:#ff00ff">"foo"</span><strong>)</strong></code></pre></div><h4>自定義測試腳本</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們還新增了<span>&nbsp;</span><code>before_test</code>,<span>&nbsp;</span><code>on_test</code><span>&nbsp;</span>和<span>&nbsp;</span><code>after_test</code><span>&nbsp;</span>配置腳本，用户可以在 rule 和 target 域，自定義配置它們實現定製化的測試執行。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">on_test</span><strong>(</strong><span style="color:blue">function</span><strong>(</strong><span style="color:#000000">target</span><strong>,</strong><span style="color:#000000">opt</span><strong>)</strong><span style="color:black">print</span><strong>(</strong><span style="color:#000000">opt</span><strong>.</strong><span style="color:#000000">name</span><strong>,</strong><span style="color:#000000">opt</span><strong>.</strong><span style="color:#000000">runenvs</span><strong>,</strong><span style="color:#000000">opt</span><strong>.</strong><span style="color:#000000">runargs</span><strong>,</strong><span style="color:#000000">opt</span><strong>.</strong><span style="color:#000000">pass_outputs</span><strong>)</strong><em>-- do test</em><em>-- ...</em><em>-- passed</em><span style="color:blue">return</span><strong>true</strong><em>-- failied</em><span style="color:blue">return</span><strong>false</strong><strong>,</strong><span style="color:#000000">errors</span><span style="color:blue">end</span><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">其中，opt 裏面可以獲取到所有傳入<span>&nbsp;</span><code>add_tests</code><span>&nbsp;</span>的參數，我們在 on_test 裏面自定義測試邏輯，然後返回 true 就是測試通過，返回 false 就是測試失敗，然後繼續返回測試失敗的錯誤信息。</p><h4>自動化構建</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">由於測試目標在正常開發構建階段，通常是不需要被構建的，因此我們會設置<span>&nbsp;</span><code>set_default(false)</code>。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是運行<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>進行測試時候，這些測試對應的 target 還是會被自動構建，確保能夠被運行。</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span><strong>[</strong> 25%]: cache compiling.release src/main.cpp
<strong>[</strong> 50%]: linking.release <span style="color:black">test
</span>running tests ...
<strong>[</strong>100%]: <span style="color:black">test</span>/testname .................................... passed 6.000s

<span style="color:#8f5902">100% </span>tests passed, 0 tests failed out of 1, spent 0.006s
</code></pre></div><h4>首次測試失敗就終止</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">默認情況下，<code>xmake test</code><span>&nbsp;</span>會等到所有測試都運行完，不管裏面有多少是沒通過的。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">而有時候，我們想在第一個測試沒通過，就直接中斷測試，那麼我們可以通過下面的配置啓用：</p><div><pre><code><span style="color:#000000">set_policy</span><strong>(</strong><span style="color:#ff00ff">"test.return_zero_on_failure"</span><strong>,</strong><strong>true</strong><strong>)</strong></code></pre></div><h4>測試失敗返回 0</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">默認情況下，只要有一個測試沒通過，等到<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>運行完成，它都會返回非 0 退出代碼，這對於一些 CI 環境非常有用，可以中斷 CI 的其他腳本繼續運行。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">然後觸發信號告訴 CI，我們需要生成測試報告和告警了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">然後，如果我們想要壓制這種行為，可以強制將<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>的退出代碼總是設置成 0。</p><div><pre><code><span style="color:#000000">set_policy</span><strong>(</strong><span style="color:#ff00ff">"test.return_zero_on_failure"</span><strong>,</strong><strong>true</strong><strong>)</strong></code></pre></div><h4>僅僅測試編譯</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">有時候，我們僅僅想要測試代碼是否通過編譯，或者沒有通過編譯，不需要運行它們，那麼可以通過配置<span>&nbsp;</span><code>build_should_pass</code><span>&nbsp;</span>和<span>&nbsp;</span><code>build_should_fail</code><span>&nbsp;</span>來實現。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_10"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/compile.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"compile_fail"</span><strong>,</strong><strong>{</strong><span style="color:#000000">build_should_fail</span><strong>=</strong><strong>true</strong><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_11"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/compile.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"compile_pass"</span><strong>,</strong><strong>{</strong><span style="color:#000000">build_should_pass</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這通常用於一些測試代碼中帶有<span>&nbsp;</span><code>static_assert</code><span>&nbsp;</span>的場景，例如：</p><div><pre><code><span style="color:blue">template</span><strong>&lt;</strong><span style="color:blue">typename</span><span style="color:#000000">T</span><strong>&gt;</strong><span style="color:blue">bool</span><span style="color:#000000">foo</span><strong>(</strong><span style="color:#000000">T</span><span style="color:#000000">val</span><strong>)</strong><strong>{</strong><span style="color:blue">if</span><span style="color:blue">constexpr</span><strong>(</strong><span style="color:#000000">std</span><strong>::</strong><span style="color:#000000">is_same_v</span><strong>&lt;</strong><span style="color:#000000">T</span><strong>,</strong><span style="color:blue">int</span><strong>&gt;</strong><strong>)</strong><strong>{</strong><span style="color:#000000">printf</span><strong>(</strong><span style="color:#ff00ff">"int!</span><span style="color:#ff00ff">\n</span><span style="color:#ff00ff">"</span><strong>);</strong><strong>}</strong><span style="color:blue">else</span><span style="color:blue">if</span><span style="color:blue">constexpr</span><strong>(</strong><span style="color:#000000">std</span><strong>::</strong><span style="color:#000000">is_same_v</span><strong>&lt;</strong><span style="color:#000000">T</span><strong>,</strong><span style="color:blue">float</span><strong>&gt;</strong><strong>)</strong><strong>{</strong><span style="color:#000000">printf</span><strong>(</strong><span style="color:#ff00ff">"float!</span><span style="color:#ff00ff">\n</span><span style="color:#ff00ff">"</span><strong>);</strong><strong>}</strong><span style="color:blue">else</span><strong>{</strong><span style="color:blue">static_assert</span><strong>(</strong><span style="color:black">false</span><strong>,</strong><span style="color:#ff00ff">"unsupported type"</span><strong>);</strong><strong>}</strong><strong>}</strong><span style="color:blue">int</span><span style="color:#000000">main</span><strong>(</strong><span style="color:blue">int</span><strong>,</strong><span style="color:blue">char</span><strong>**</strong><strong>)</strong><strong>{</strong><span style="color:#000000">foo</span><strong>(</strong><span style="color:#ff00ff">"BAD"</span><strong>);</strong><span style="color:blue">return</span><strong>0</strong><strong>;</strong><strong>}</strong></code></pre></div><h4>配置額外的代碼編譯</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們還可以在配置測試用例的時候，對每個測試配置額外需要編譯的代碼，以及一些宏定義，實現內聯測試。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">xmake 會為每個測試單獨編譯一個獨立的可執行程序去運行它，但這並不會影響到 target 在生產環境的編譯結果。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_13"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/test_1.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"stub_1"</span><strong>,</strong><strong>{</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#ff00ff">"tests/stub_1.cpp"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"STUB_1"</span><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_14"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/test_2.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"stub_2"</span><strong>,</strong><strong>{</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#ff00ff">"tests/stub_2.cpp"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"STUB_2"</span><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_15"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/test_1.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"stub_n"</span><strong>,</strong><strong>{</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#ff00ff">"tests/stub_n*.cpp"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"STUB_N"</span><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">以 doctest 為例，我們可以在不修改任何 main.cpp 的情況下，外置單元測試：</p><div><pre><code><span style="color:#000000">add_rules</span><strong>(</strong><span style="color:#ff00ff">"mode.debug"</span><strong>,</strong><span style="color:#ff00ff">"mode.release"</span><strong>)</strong><span style="color:#000000">add_requires</span><strong>(</strong><span style="color:#ff00ff">"doctest"</span><strong>)</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"doctest"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/*.cpp"</span><strong>)</strong><span style="color:blue">for</span><span style="color:#000000">_</span><strong>,</strong><span style="color:#000000">testfile</span><span style="color:blue">in</span><span style="color:black">ipairs</span><strong>(</strong><span style="color:#000000">os</span><strong>.</strong><span style="color:#000000">files</span><strong>(</strong><span style="color:#ff00ff">"tests/*.cpp"</span><strong>))</strong><span style="color:blue">do</span><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#000000">path</span><strong>.</strong><span style="color:#000000">basename</span><strong>(</strong><span style="color:#000000">testfile</span><strong>),</strong><strong>{</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#000000">testfile</span><strong>,</strong><span style="color:#000000">remove_files</span><strong>=</strong><span style="color:#ff00ff">"src/main.cpp"</span><strong>,</strong><span style="color:#000000">languages</span><strong>=</strong><span style="color:#ff00ff">"c++11"</span><strong>,</strong><span style="color:#000000">packages</span><strong>=</strong><span style="color:#ff00ff">"doctest"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN"</span><strong>})</strong><span style="color:blue">end</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">定義 DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN 會引入額外的 main 入口函數，因此我們需要配置 remove_files 去移除已有的 main.cpp 文件。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">運行效果如下：</p><div><pre><code>ruki-2:doctest ruki<span style="color:black">$ </span>xmake <span style="color:black">test
</span>running tests ...
<strong>[</strong> 50%]: doctest/test_1 .................................... failed 0.009s
<strong>[</strong>100%]: doctest/test_2 .................................... passed 0.009s

<span style="color:#8f5902">50% </span>tests passed, 1 tests failed out of 2, spent 0.019s
ruki-2:doctest ruki<span style="color:black">$ </span>xmake <span style="color:black">test</span> -v
running tests ...
<strong>[</strong> 50%]: doctest/test_1 .................................... failed 0.026s
<strong>[</strong>doctest] doctest version is <span style="color:#ff00ff">"2.4.11"</span><strong>[</strong>doctest] run with <span style="color:#ff00ff">"--help"</span><span style="color:blue">for </span>options
<strong>===============================================================================</strong>
tests/test_1.cpp:7:
TEST CASE:  testing the factorial <span style="color:blue">function

</span>tests/test_1.cpp:8: ERROR: CHECK<strong>(</strong> factorial<strong>(</strong>1<strong>)</strong><strong>==</strong> 10 <strong>)</strong> is NOT correct!
  values: CHECK<strong>(</strong> 1 <strong>==</strong> 10 <strong>)</strong><strong>===============================================================================</strong><strong>[</strong>doctest] <span style="color:black">test </span>cases: 1 | 0 passed | 1 failed | 0 skipped
<strong>[</strong>doctest] assertions: 4 | 3 passed | 1 failed |
<strong>[</strong>doctest] Status: FAILURE!

run failed, <span style="color:black">exit </span>code: 1
<strong>[</strong>100%]: doctest/test_2 .................................... passed 0.010s

<span style="color:#8f5902">50% </span>tests passed, 1 tests failed out of 2, spent 0.038s
</code></pre></div><h4>測試動態庫</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">通常，<code>add_tests</code><span>&nbsp;</span>僅用於對可執行程序進行運行測試，運行動態庫需要有一個額外的 main 主入口，因此我們需要額外配置一個可執行程序去加載它，例如：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"doctest_shared"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"shared"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/foo.cpp"</span><strong>)</strong><span style="color:blue">for</span><span style="color:#000000">_</span><strong>,</strong><span style="color:#000000">testfile</span><span style="color:blue">in</span><span style="color:black">ipairs</span><strong>(</strong><span style="color:#000000">os</span><strong>.</strong><span style="color:#000000">files</span><strong>(</strong><span style="color:#ff00ff">"tests/*.cpp"</span><strong>))</strong><span style="color:blue">do</span><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#000000">path</span><strong>.</strong><span style="color:#000000">basename</span><strong>(</strong><span style="color:#000000">testfile</span><strong>),</strong><strong>{</strong><span style="color:#000000">kind</span><strong>=</strong><span style="color:#ff00ff">"binary"</span><strong>,</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#000000">testfile</span><strong>,</strong><span style="color:#000000">languages</span><strong>=</strong><span style="color:#ff00ff">"c++11"</span><strong>,</strong><span style="color:#000000">packages</span><strong>=</strong><span style="color:#ff00ff">"doctest"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN"</span><strong>})</strong><span style="color:blue">end</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">通過<span>&nbsp;</span><code>kind = "binary"</code><span>&nbsp;</span>可以將每個單元測試改為 binary 可執行程序，並通過<span>&nbsp;</span><code>DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN</code><span>&nbsp;</span>引入 main 入口函數。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這樣就能實現動態庫目標中外置可運行的單元測試。</p><h3>新增類型大小檢測</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在先前的版本中，我們可以通過<span>&nbsp;</span><code>check_csnippets</code><span>&nbsp;</span>和<span>&nbsp;</span><code>output = true</code><span>&nbsp;</span>的方式，來實現類型檢測。</p><div><pre><code><span style="color:#000000">check_csnippets</span><strong>(</strong><span style="color:#ff00ff">"INT_SIZE"</span><strong>,</strong><span style="color:#ff00ff">'printf("%d", sizeof(int)); return 0;'</span><strong>,</strong><strong>{</strong><span style="color:#000000">output</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">number</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是這種方式，是通過嘗試運行測試代碼，然後獲取運行輸出結果，提取類型大小信息。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這對於交叉編譯，就不適用了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 2.8.5 版本中，我們新增了<span>&nbsp;</span><code>check_sizeof</code><span>&nbsp;</span>輔助接口，可以通過直接解析測試程序的二進制文件，提取類型大小信息。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">由於不需要運行測試，這種方式不僅可以支持交叉編譯，而且對檢測效率也有極大的提升，使用也更加的簡單。</p><div><pre><code><span style="color:#000000">includes</span><strong>(</strong><span style="color:#ff00ff">"@builtin/check"</span><strong>)</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"static"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"*.cpp"</span><strong>)</strong><span style="color:#000000">check_sizeof</span><strong>(</strong><span style="color:#ff00ff">"LONG_SIZE"</span><strong>,</strong><span style="color:#ff00ff">"long"</span><strong>)</strong><span style="color:#000000">check_sizeof</span><strong>(</strong><span style="color:#ff00ff">"STRING_SIZE"</span><strong>,</strong><span style="color:#ff00ff">"std::string"</span><strong>,</strong><strong>{</strong><span style="color:#000000">includes</span><strong>=</strong><span style="color:#ff00ff">"string"</span><strong>})</strong></code></pre></div><div><pre><code><span style="color:#8f5902">$ </span>xmake f -c
checking <span style="color:blue">for </span>LONG_SIZE ... 8
checking <span style="color:blue">for </span>STRING_SIZE ... 24
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，我也可以通過<span>&nbsp;</span><code>target:check_sizeof</code><span>&nbsp;</span>在腳本域進行檢測。</p><h3>新增 Apple XROS 平台</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">蘋果在 Xcode15 中新增了 visionOS 設備的構建支持，因此我們也在第一時間對其進行了支持，只需要執行：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake f -p applexros
<span style="color:#8f5902">$ </span>xmake
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">就可以完成 visionOS/XROS 平台的構建。</p><h3>支持代碼合併</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">最後，我們還提供了一個小工具模塊，它可以用於快速合併指定 target 裏面的所有 c/c++ 和，頭文件源碼到單個源文件。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">會生成類似 sqlite3.c 的這種單源碼文件，用户可以根據自己的實際需求來決定是否使用這個功能。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">而在做合併的時候，Xmake 會將內部 includes 頭文件全部展開，並生成 DAG，通過拓撲排序引入。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">默認它會處理所有 target 的合併，例如：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake l cli.amalgamate
build/tbox.c generated!
build/tbox.h generated!
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以指定合併需要的目標：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake l cli.amalgamate tbox
build/tbox.c generated!
build/tbox.h generated!
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">也可以在合併每個源文件時候，指定一個自定義的 unique ID 的宏定義，來處理符號衝突問題。</p><div><pre><code><span style="color:#8f5902">$ </span>xmake l cli.amalgamate -u MY_UNIQUEU_ID
build/tbox.c generated!
build/tbox.h generated!
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果多個源文件內部有重名符號，就可以判斷這個<span>&nbsp;</span><code>MY_UNIQUEU_ID</code><span>&nbsp;</span>宏是否被定義，如果定義了，説明是在單文件中，就自己在源碼中處理下重名符號。</p><div><pre><code><em>#ifdef MY_UNIQUEU_ID
</em><em>// do some thing
</em><em>#endif
</em></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以指定輸出位置：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake l cli.amalgamate -o /xxx
/xxx/tbox.c generated!
/xxx/tbox.h generated!
</code></pre></div><h3>新增 windows.manifest.uac 策略</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">通過這個策略，我們可以快速方便的設置並啓用 Windows UAC。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它支持以下幾個 Level：</p><ul><li>invoker: asInvoker</li><li>admin: requireAdministrator</li><li>highest: highestAvailable</li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">例如：</p><div><pre><code><span style="color:#000000">set_policy</span><strong>(</strong><span style="color:#ff00ff">"windows.manifest.uac"</span><strong>,</strong><span style="color:#ff00ff">"admin"</span><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它等價於設置</p><div><pre><code><span style="color:blue">if</span><span style="color:#000000">is_plat</span><strong>(</strong><span style="color:#ff00ff">"windows"</span><strong>)</strong><span style="color:blue">then</span><span style="color:#000000">add_ldflags</span><strong>(</strong><span style="color:#ff00ff">"/manifest:embed"</span><strong>,</strong><strong>{</strong><span style="color:#ff00ff">"/manifestuac:level='requireAdministrator' uiAccess='false'"</span><strong>},</strong><strong>{</strong><span style="color:#000000">force</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">expand</span><strong>=</strong><strong>false</strong><strong>})</strong><span style="color:blue">end</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是更加方便簡潔，並且不需要判斷平台，其他平台自動忽略。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過<span>&nbsp;</span><code>windows.manifest.uac.ui</code><span>&nbsp;</span>策略，設置 Windows UAC 的 uiAccess，如果沒有設置它，默認是 false。</p><div><pre><code><span style="color:#000000">set_policy</span><strong>(</strong><span style="color:#ff00ff">"windows.manifest.uac.ui"</span><strong>,</strong><strong>true</strong><strong>)</strong></code></pre></div><h2>更新日誌</h2><h3>新特性</h3><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F1452" target="_blank">#1452</a>: 支持鏈接順序調整，鏈接組</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F1438" target="_blank">#1438</a>: 支持代碼 amalgamation</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F3381" target="_blank">#3381</a>: 添加<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>支持</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F4276" target="_blank">#4276</a>: 支持自定義域 API</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fpull%2F4286" target="_blank">#4286</a>: 添加 Apple XROS 支持</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F4345" target="_blank">#4345</a>: 支持檢測類型大小 sizeof</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fpull%2F4369" target="_blank">#4369</a>: 添加 windows.manifest.uac 策略</li></ul><h3>改進</h3><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F4284" target="_blank">#4284</a>: 改進內置 includes 模塊</li></ul><h3>Bugs 修復</h3><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F4256" target="_blank">#4256</a>: 為 vsxmake 生成器修復 c++ modules intellisense</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 01:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265506/xmake-v2-8-5</guid>
            <link>https://www.oschina.net/news/265506/xmake-v2-8-5</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Mozilla Firefox 開發將完全轉向 Git，放棄 Mercurial]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Mozilla 負責工作流和發佈管理的高級工程經理&nbsp;Glob&nbsp;在 firefox-dev 郵件列表中<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgroups.google.com%2Fa%2Fmozilla.org%2Fg%2Ffirefox-dev%2Fc%2FQnfydsDj48o%2Fm%2F8WadV0_dBQAJ" target="_blank">表示</a>，Firefox 開發正在從 Mercurial 轉向 GIT，以減輕開發團隊的壓力。</span></p><blockquote><p><span style="color:#000000">長期以來，Firefox Desktop 開發一直同時支持 Mercurial 和 Git 用户。這種雙 SCM 要求給部分已經捉襟見肘的團隊帶來了沉重負擔。我們已經決定將 Firefox 開發轉移到 Git。</span></p><ul><li><span style="color:#000000">我們將繼續使用 Bugzilla、moz-phab、Phabricator 和 Lando。</span></li><li><span style="color:#000000">儘管我們將在 GitHub 上託管版本庫，但我們的貢獻工作流程將保持不變，而且我們目前不會接受拉取請求。</span></li></ul></blockquote><p><span style="color:#000000">目前相關事項仍在規劃中，預計至少六個月後才會開始全面的 Git 過渡。過渡完成後，Mercurial 將從 Firefox 開發工作流程中完全淘汰。</span></p><p><img height="225" src="https://oscimg.oschina.net/oscnet/up-4b4cc1a8fcad1764d254f09eae44065f9c2.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">根據介紹，這項工作將分為兩個部分進行：首先是面向開發人員的工作。項目團隊將把主倉庫從 Mercurial 切換到 Git，同時在開發人員的工作站上移除對 Mercurial 的支持。開發人員將需要在本地使用 Git，並繼續使用 moz-phab 提交補丁以供審核。</span></p><p><span style="color:#000000">然後是後端基礎架構的零散遷移。各個團隊計劃逐步將 Mercurial 上的基礎架構遷移到 Git 上。在這一階段結束時，預計可實現從基礎架構中完全移除對 Mercurial 的支持。</span></p><p><span style="color:#000000">Mercurial 是一款開源的分佈式源代碼控制管理工具，採用 Python 語言實現，易於學習和使用，擴展性強。它可以有效地處理任何規模的項目，並提供簡單直觀的界面。Mercurial 由 Olivia Mackall 於 2005 年創建，作為 BitKeeper 的替代品用於管理 Linux 內核的源代碼，以應對 BitKeeper 免費版的停產。</span></p><p><span style="color:#000000">更多詳細信息可查看</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgroups.google.com%2Fa%2Fmozilla.org%2Fg%2Ffirefox-dev%2Fc%2FQnfydsDj48o%2Fm%2F8WadV0_dBQAJ" target="_blank">郵件列表公告</a><span style="color:#000000">。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 10:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265431/firefox-going-git</guid>
            <link>https://www.oschina.net/news/265431/firefox-going-git</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[DALL·E 3 繪圖來啦，開源 AI 聊天、繪圖軟件 AIdea 現已支持 DALL·E 3]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p style="color:inherit; margin-left:0; margin-right:0">昨晚 OpenAI 的開發者大會後開放了 DALL·E 3 的 API，今天花了一點時間在 AIdea 中增加了對 DALL·E 3 的支持。</p><blockquote><p style="color:inherit; margin-left:0; margin-right:0">簡單來説，AIdea 類似於 POE，它是一款集成了主流大語言模型以及繪圖模型的開源 APP。如果你還不知道它，那麼可以簡單看看這篇文章 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzA3NTU1NDk4Mg%3D%3D%26mid%3D2454663369%26idx%3D1%26sn%3Dfc5ae7e09e5da885fecbe90747900bc9%26chksm%3D88d55900bfa2d016578008ec30550acbab49cf9ed5cd0b454c3ce8d308ff7cc1ab9416637f19%23rd" target="_blank">花了小半年開發了一個 AI 套殼 APP，然而大勢已過，直接開源了</a>。</p><p style="color:inherit; margin-left:0; margin-right:0">AIdea 項目前後端所有代碼均採用 MIT 協議開源。</p></blockquote><img alt="operate-note" src="https://ssl.aicode.cc/ai-server/assets/broadcast/dalle-preview.jpg" referrerpolicy="no-referrer"><p>operate-note</p><img alt="image" src="https://ssl.aicode.cc/ai-server/assets/broadcast/dalle-preview-result.png" referrerpolicy="no-referrer"><p>image</p><p style="color:inherit; margin-left:0; margin-right:0">下載體驗地址</p><p style="color:inherit; margin-left:0; margin-right:0">https://aidea.aicode.cc/</p><blockquote><p style="color:inherit; margin-left:0; margin-right:0">注意：AIdea 項目前後端所有代碼均採用 MIT 協議開源，但是在線體驗服務並不免費（PS. 很多大語言模型每日都有免費使用次數）。</p></blockquote><p style="color:inherit; margin-left:0; margin-right:0">AIdea 是一款集成了主流大語言模型以及繪圖模型的 APP ， 採用 Flutter + Golang 開發，代碼完全開源，支持以下功能：</p><ul><li><span style="color:inherit">OpenAI 的 GPT-3.5 ，GPT-4 大語言模型</span></li><li><span style="color:inherit">Anthropic 的 Claude instant ，Claude 2.0 大語言模型</span></li><li><span style="color:inherit">國產模型：通義千問，文心一言，訊飛星火，商湯日日新，騰訊混元，百川 53B ，360 智腦</span></li><li><span style="color:inherit">開源模型：Llama2 ，ChatGLM2 ，AquilaChat 7B ，Bloomz 7B 等，後續還將開放更多</span></li><li><span style="color:inherit">文生圖、圖生圖、超分辨率、黑白圖片上色等功能，集成 Stable Diffusion 模型，支持 SDXL 1.0</span></li></ul><p style="color:inherit; margin-left:0; margin-right:0">Github 地址：</p><ul><li><span style="color:inherit">客户端（ Flutter ）： https://github.com/mylxsw/aidea</span></li><li><span style="color:inherit">服務端（ Golang ）： https://github.com/mylxsw/aidea-server</span></li></ul></div></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 09:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265412</guid>
            <link>https://www.oschina.net/news/265412</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[極致性能優化：前端 SSR 渲染利器 Qwik.js | 京東雲技術團隊]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://my.oschina.net/u/3859945/blog/10141334" target="_blank">答開源創業 15 問：選協議、維權、公關、找錢······ <img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><span id="OSC_h1_1"></span><h1><span><span><span>引言</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>前端性能已成為網站和應用成功的關鍵要素之一。用户期望快速加載的頁面和流暢的交互，而前端框架的選擇對於實現這些目標至關重要。然而，傳統的前端框架在某些情況下可能面臨性能挑戰且存在技術壁壘。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在這個充滿挑戰的背景下，我們引入了 Qwik.js 框架。Qwik.js 不僅是一個前端框架，更是一種前端性能的終極解決方案。它不僅提供了卓越的性能，還以其獨特的特點和優勢脱穎而出。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>讓我們一起深入探索 Qwik.js，發現它如何超越傳統，成為前端性能優化的新標杆。</span></span></span></p><span id="OSC_h1_2"></span><h1><span><span><span>一、現有框架的問題</span></span></span></h1><span id="OSC_h4_3"></span><h4><span>1.</span><span><span><span><span>傳統 CSR 方案</span></span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>慢加載時間：</span></strong></span></span><span><span><span> CSR 技術通常要求在瀏覽器中加載和渲染整個頁面，這導致初始頁面加載時間較長。用户必須等待頁面完全加載才能進行交互。 </span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>搜索引擎優化（SEO）問題：</span></strong></span></span><span><span><span> 由於頁面內容是在客户端生成的，搜索引擎爬蟲可能無法正確解析和索引頁面內容，這影響了網站的 SEO 效果。 </span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>不利於低帶寬用户：</span></strong></span></span><span><span><span> 對於低帶寬用户或網絡條件較差的用户，CSR 頁面加載時間更長，用户體驗更差。 </span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>首屏渲染延遲：</span></strong></span></span><span><span><span> CSR 通常需要等待 JavaScript 文件的下載和執行，這導致了首屏渲染的延遲，影響了用户的第一印象。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>問題分析</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>A. 渲染階段耗時分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="108" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-13xZmbiiPDHyfVKHl.png" width="588" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>B. 請求鏈路分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="311" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-14Jn48bC9MLjg7uj48.png" width="291" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>C. 瀏覽器執行渲染分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="230" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-15HAl9koUb6m9MG98.png" width="345" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h4_4"></span><h4><span><span><span>2. 傳統 SSR 方案</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>複雜的水合過程：</span></strong></span></span><span><span><span> 涉及複雜的水合過程，包括將數據傳輸到客户端並在客户端重新渲染頁面。這增加了頁面加載時間和網絡開銷。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>A. 請求鏈路分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="366" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-27a6p7RKalKkQgqE12.png" width="275" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>B. 瀏覽器執行渲染分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="236" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-23GQJadOUFvz9gVjT.png" width="387" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h4_5"></span><h4><span><span><span>什麼是水合（Hydration）？</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>"hydration"（水合）是指通過客户端 JavaScript 將靜態 HTML 網頁轉化為動態網頁的過程，以實現對 HTML 元素的事件處理。這個過程可以通過將事件處理程序附加到 HTML 元素上來完成</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="304" src="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F4f48568655904e4586ba34b413beb790?width=580" width="390" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>深入瞭解水合（hydration）過程，水合的難點在於知道我們需要什麼事件處理程序以及它們應該附加到哪裏。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>WHAT（什麼）</span></strong></span></span><span><span><span>：事件處理程序是一個封閉包，包含了事件處理程序的行為。它定義了當用户觸發此事件時應該發生什麼。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>WHERE（哪裏）</span></strong></span></span><span><span><span>：指的是需要將 WHAT（事件處理程序）附加到的 DOM 元素的位置，這包括了事件類型。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>更復雜的部分在於，WHAT（事件處理程序）是一個封閉包，它封閉了 APP_STATE（應用程序狀態）和 FRAMEWORK_STATE（框架內部狀態）：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>APP_STATE（應用程序狀態）</span></strong></span></span><span><span><span>：這是應用程序的狀態。APP_STATE 通常是人們所説的狀態。沒有 APP_STATE，您的應用程序將無法向用户展示任何動態內容。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>FRAMEWORK_STATE（框架內部狀態）</span></strong></span></span><span><span><span>：這是框架的內部狀態。沒有 FRAMEWORK_STATE，框架不知道應該更新哪些 DOM 節點以及何時應該更新它們。這包括組件樹和對渲染函數的引用等內容。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>那麼，我們如何恢復 WHAT（APP_STATE + FRAMEWORK_STATE）和 WHERE 呢？方法是通過下載並執行當前 HTML 中的組件。在 HTML 中下載和執行已渲染的組件是水合的昂貴部分。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>換句話説，水合是一種通過在瀏覽器中急切地執行應用程序代碼來恢復 APP_STATE 和 FRAMEWORK_STATE 的方法，它涉及以下步驟：</span></span></span></p><ol><li><span><span><span><span>下載組件代碼。</span></span></span></span></li><li><span><span><span><span>執行組件代碼。</span></span></span></span></li><li><span><span><span><span>恢復 WHAT（事件處理程序閉包）和 WHERE（DOM 元素），以獲取事件處理程序閉包。</span></span></span></span></li><li><span><span><span><span>將 WHAT（事件處理程序閉包）附加到 WHERE（DOM 元素）。</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這個過程的關鍵是將 APP_STATE 和 FRAMEWORK_STATE 從已渲染的組件中恢復，以確保應用程序在客户端獲得正確的狀態和行為。這對於實現前端與後端的協同工作以提供動態用户體驗至關重要。</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="298" src="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F0e1bbc52c75747328b846dcfa76c28f2?width=905" width="660" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_6"></span><h1><span><span><span>二、Qwik.js 框架的特點</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可恢復性（Resumability）：一種無開銷的水合替代方案，那麼，如何設計一個沒有水合且沒有開銷的系統呢？</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>為了消除開銷，框架不僅必須避免恢復（RECOVERY），還必須避免上述所提到的第四步。第四步是將 WHAT 附加到 WHERE，這是可以避免的成本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>要避免這種成本，您需要三樣東西：</span></span></span></p><ol><li><span><span><span><span>將所有所需的信息序列化為 HTML 的一部分。序列化的信息需要包括 WHAT、WHERE、APP_STATE 和 FRAMEWORK_STATE。</span></span></span></span></li><li><span><span><span><span>一個全局事件處理程序，依賴事件冒泡來攔截所有事件。事件處理程序需要是全局的，這樣我們就不需要急切地在特定的 DOM 元素上單獨註冊所有事件。</span></span></span></span></li><li><span><span><span><span>一個工廠函數，可以延遲恢復事件處理程序（WHAT）。</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這種方法的關鍵是在 HTML 中序列化所有必需的信息，以及使用全局事件處理程序來攔截和處理事件，而不必顯式將事件處理程序附加到特定的 DOM 元素上。這樣可以避免昂貴的步驟四，從而提供無開銷的可恢復性，同時仍能實現前端的互動性和性能優化。</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="304" src="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F04681212764f4025b2b5f5c6a258ad6e?width=905" width="675" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>A. 渲染階段耗時分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="118" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-28K9JFlwTqhvJg8Ai.png" width="500" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>B. 請求鏈路分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="383" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-28R2YSlad187SVu7u.png" width="207" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>C. 瀏覽器執行渲染分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="229" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-51g7EMHDw7dtR18CZV.png" width="342" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-11-19-32gB18uqO0IYVB18KxX.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_7"></span><h1><span><span><span>四、效果和成果</span></span></span></h1><div><img alt="" height="371" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-15-06LfwBVIHYE9RvLeU.png" width="823" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-11-20-00jYipo69U6Njn9Sm.gif" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_8"></span><h1><span><span><span>五、挑戰</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Qwik.js 無水合方案可能會帶來一些挑戰，其中包括以下幾個方面：</span></span></span></p><ol><li><span><span><span><strong><span>新技術的學習曲線</span></strong></span></span><span><span><span>： 採用新的前端架構或技術，如 Qwik.js，通常需要團隊成員學習和適應新的工作流程和最佳實踐。這可能需要一些時間和培訓來確保團隊熟練掌握新技術。</span></span></span></span></li><li><span><span><span><strong><span>服務器開銷增加</span></strong></span></span><span><span><span>： 在無水合方案中，服務器可能需要更多的計算資源來序列化和提供所需的信息，以及處理全局事件處理程序。這可能會導致服務器開銷的增加，特別是在大量併發請求的情況下。</span></span></span></span></li><li><span><span><span><strong><span>Node.js 併發挑戰</span></strong></span></span><span><span><span>： 對於 Node.js 服務器，處理大量併發請求可能會帶來挑戰。在無水合方案中，服務器可能需要同時處理多個請求，因此需要考慮服務器的併發性能和擴展性。</span></span></span></span></li></ol><blockquote><p>作者：京東創新零售，李健</p><p>來源：京東雲開發者社區，轉載請註明來源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 01:55:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10141047</guid>
            <link>https://my.oschina.net/u/4090830/blog/10141047</link>
            <author>
                <![CDATA[京東雲開發者]]>
            </author>
        </item>
    </channel>
</rss>
