<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 24 Nov 2023 01:00:08 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Rust Web 框架 Rocket 發佈 v0.5：支持異步、SSE、WebSockets 等]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>歷經四年多，四個 RC 版本、一千次 commit、一千多個 issue、討論和 PR 之後，<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frocket.rs%2Fv0.5%2Fnews%2F2023-11-17-version-0.5%2F" target="_blank">Rocket v0.5 正式發佈了</a></u></strong>。</p><blockquote><p>Rocket 是支持異步的後端 Rust Web 框架，專注於可用性、安全性、可擴展性和性能。它使編寫安全的 Web 應用程序變得簡單，而不會犧牲生產力或性能。</p></blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-749db50b650e7b26e57cb9b7f418e05b004.png" referrerpolicy="no-referrer"></p><p>Rocket v0.5 部分重要新功能包括：</p><ol><li><p><strong>支持穩定的 Rust 編譯器</strong>：Rocket v0.5 基於 Rust 穩定版本進行編譯和構建，開發者現在可以使用穩定發佈通道中的<code>rustc</code>編譯和構建 Rocket 應用程序，不再需要使用<code>#![feature(..)]</code>crate<strong>&nbsp;</strong>屬性。<br> &nbsp;</p><pre><code>#[macro_use] extern crate rocket;

#[get("/&lt;name&gt;/&lt;age&gt;")]
fn hello(name: &amp;str, age: u8) -&gt; String {
    format!("Hello, {} year old named {}!", age, name)
}

#[launch]
fn rocket() -&gt; _ {
    rocket::build().mount("/hello", routes![hello])
}</code></pre><p>&nbsp;</p></li><li><p><strong>支持異步 I/O</strong>：Rocket v0.5 重新構建了核心請求處理部分，利用了 Rust 中最新的異步網絡功能。Rocket 現在可以自動在機器上的所有可用核心上多路複用請求處理，使路由處理程序可以聲明為異步並使用 await 語法。<br> &nbsp;</p><pre><code>use rocket::tokio;
use rocket::data::{Data, ToByteUnit};

#[post("/debug", data = "&lt;data&gt;")]
async fn debug(data: Data&lt;'_&gt;) -&gt; std::io::Result&lt;()&gt; {
    // Stream at most 512KiB all of the body data to stdout.
    data.open(512.kibibytes())
        .stream_to(tokio::io::stdout())
        .await?;

    Ok(())
}</code></pre><p>&nbsp;</p></li><li><p><strong>支持 Sentinels</strong>：Rocket v0.5 引入了 Sentinels，這是 Rocket 框架獨有的功能。Sentinels 提供了一種自動的最後防線，可以在出現無效條件時中止應用程序的啓動。Sentinels 可以在 Rocket 之外實現，並且應該儘可能地使用它們。<br> &nbsp;</p><pre><code>use rocket::{Rocket, Ignite, Sentinel};

impl Sentinel for MyResponder {
    fn abort(r: &amp;Rocket&lt;Ignite&gt;) -&gt; bool {
        r.state::&lt;T&gt;().is_none() || !r.catchers().any(|c| c.code == Some(400))
    }
}</code></pre><p>&nbsp;</p></li><li><p><strong>支持流和 SSE</strong>：Rocket v0.5 引入了實時的、類型化的異步流。Rocket 的新異步流部分包含了更多詳細信息，我們鼓勵所有感興趣的人查看新的實時、多房間聊天示例。</p></li><li><p><strong>支持 WebSockets</strong>：Rocket v0.5 通過新的升級 API 引入了對 HTTP 連接升級的支持。這個 API 允許響應器在現有的 HTTP 連接中控制與客户端的原始 I/O，從而允許將 HTTP 連接升級到任何協議，包括 WebSockets。</p></li><li><p><strong>全面的表單功能支持</strong>：Rocket v0.5 完全改進了表單支持，支持多部分上傳、任意嵌套的集合、即時驗證等。Rocket 的新表單協議允許應用程序表達任何結構，任意嵌套和集合，無需任何自定義代碼。</p></li></ol><p>除了上述功能之外，Rocket v0.5 還引入了其他 40 多個新功能和重大改進，包括安全和隱私頭、優雅的關閉、靈活的配置系統、類型系統強制的數據限制等。</p><p>Rocket v0.5 的發佈是一個重要的里程碑，為 Rust 開發者提供了一個強大而易用的 Web 框架。我們鼓勵所有用户升級到 Rocket v0.5，並<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frwf2%2FRocket%2Fblob%2Fv0.5.0%2FCHANGELOG.md" target="_blank">查看完整的 CHANGELOG</a></u>以瞭解所有新功能和改進。</p><p>請注意，Rocket v0.4 仍然會得到支持和安全更新，直到 Rocket v0.6 發佈為止。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 11:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267838/rocketrs-0-5-released</guid>
            <link>https://www.oschina.net/news/267838/rocketrs-0-5-released</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux 內核放棄支持過時的圖形驅動基礎設施]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Linux 內核正在準備刪除支持舊的和過時的圖形驅動程序的基礎設施。</p><p>早在 Linux 6.3 內核中就已經移除了許多舊版的 DRM 驅動程序，現在的補丁進一步刪除了支持這些舊的用户空間模式設置圖形/顯示驅動程序的基礎設施。</p><p>在 Linux 6.3 內核中，ATI Rage 128、3Dfx、S3 Savage、Intel 810、SiS、VIA 和 Matrox MGA DRM 驅動程序被淘汰。這是為了清除 DRI1 時代過時 GPU 驅動程序的努力的一部分。</p><p>現在，SUSE 工程師 Thomas Zimmermann 計劃進一步刪除用户空間模式設置的基礎設施。他認為，由於 Linux 6.6 是今年的長期支持版本（LTS）內核。現在是一個很好的時機來刪除這個基礎設施。如果有人仍在使用這些舊的驅動程序或類似的驅動程序，他們可以繼續使用 Linux 6.6 LTS。</p><p>Zimmermann<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Fdri-devel%2F20231122122449.11588-1-tzimmermann%40suse.de%2F" target="_blank">在 dri-devel 上寫道</a></u>：</p><blockquote><p>舊的用户空間模式設置驅動程序已經在 Linux v6.3 中被刪除。沒有人抱怨或要求它們的恢復。現在是時候從 DRM 核心中刪除這些驅動程序的基礎設施了。</p><p>最近的 Linux v6.6 已被指定為長期支持版本，因此任何剩餘的用户還有幾年時間來購買新的顯卡。通過簡單的 drm 仍然支持這些舊設備。將適當的驅動程序與內核模式設置合併也是一個選擇。</p><p>補丁 1 到 7 修復了在刪除驅動程序過程中被遺忘的一些微不足道的問題。</p><p>補丁 8 和 9 刪除了舊的 ioctl 接口。其中一個操作與其他操作不同，因此它有自己的補丁。</p><p>補丁 10 到 12 從 DRM 中刪除了舊的源代碼。隨着這些代碼的消失，補丁 13 中的 AGP 代碼也可以簡化。以前有一個用於用户空間模式設置的設備文件/dev/agpgart，現在已經過時了。</p><p>這 14 個補丁在直接渲染管理器子系統中消除了另外 8000 行舊代碼。如果沒有提出異議，這個舊的用户空間模式設置基礎設施的刪除可能會在新的一年的 Linux 6.8 內核週期中發生。</p></blockquote><p>這項工作主要是為了清除過時的 GPU 驅動程序，併為用户提供更好的性能和穩定性。對於依賴舊版驅動程序的用户，他們可以繼續使用 Linux 6.6 LTS，直到他們準備好升級到支持新的圖形驅動程序的版本。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 10:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267831/linux-drop-old-ums-drm-infra</guid>
            <link>https://www.oschina.net/news/267831/linux-drop-old-ums-drm-infra</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux 6.8 將更新 Zstd 代碼以獲得更好的壓縮性能]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FZstd-1.5.5-Patches-Linux-Kernel" target="_blank">根據 Phoronix 的報道</a></u>，Linux 6.8 內核計劃在明年升級其 Zstd 代碼，以提供更好的壓縮性能。</p><p>在 Linux 6.2 中，內核的 Zstd 壓縮/解壓縮代碼已經根據 Zstd 1.5 的最新狀態進行了更新。而在 Linux 6.8 內核中，計劃升級到 Zstd 1.5.5 版本，這將提供更好的壓縮性能。</p><p>這次 Zstd 升級對 Linux 內核的動力之一是英特爾希望在 Linux 內核中使用更新的 Zstd 版本，因為它公開了 Zstd 的外部匹配提供程序 API，從而允許 QuickAssist 技術（QAT）加速 LZ 匹配查找階段。這對於那些擁有 QAT 硬件或將 QAT 加速集成到 Xeon Sapphire Rapids 和即將推出的 Emerald Rapids 處理器的用户來説是個好消息。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b673c0555866551114bd2e08b4c9c512046.png" referrerpolicy="no-referrer"></p><p>除了滿足英特爾的需求之外，內核中更新的 Zstd 代碼經過測試，發現在寫入+壓縮時間上可以減少約 6%。然而，讀取+解壓縮時間略有增加。Zstd 1.5.5 本身是在今年 4 月發佈的，其中包含了一些性能改進、修復和其他變更。</p><p>目前可以在郵件列表的補丁中找到適用於 Linux 內核的 Zstd 1.5.5 版本，內核維護者計劃在 Linux 6.8 合併窗口提交這項工作。</p><p>這次 Zstd 代碼的升級將為 Linux 內核帶來更好的壓縮性能，這對於文件系統驅動程序的透明文件系統壓縮/解壓縮、將各種內核資源壓縮為 Zstd 格式等方面都是有益的。</p><p>詳情查看&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Flkml%2F20231121010318.524570-1-nickrterrell%40gmail.com%2FT%2F%23m693429838032e235560212b8339b315dcaa02460" target="_blank">https://lore.kernel.org/lkml/</a></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 10:22:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267826/zstd-1-5-5-patches-linux-kernel</guid>
            <link>https://www.oschina.net/news/267826/zstd-1-5-5-patches-linux-kernel</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[TQUIC - 高性能輕量級跨平台 QUIC 協議庫]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#1f2328; text-align:start">TQUIC 是 IETF QUIC 協議的實現。它是一個高性能、輕量級、跨平台的 QUIC 庫。</p><h4 style="text-align:start"><strong>特性及優點</strong></h4><ul><li><p><strong>高性能</strong>：TQUIC 是為高性能和低延遲而設計的。相關細節可以參考<a href="https://tquic.net/zh/docs/further_readings/benchmark">基準測試結果</a>。</p></li><li><p><strong>可插拔擁塞控制</strong>：TQUIC 支持多種擁塞控制算法，包括 CUBIC，BBR，BBRv3，COPA。</p></li><li><p><strong>多路徑傳輸</strong>：TQUIC 支持多路徑，一個連接可同時使用多個路徑提高性能及可靠性。</p></li><li><p><strong>易用性</strong>：TQUIC 提供易用的接口，支持靈活的配置參數，提供豐富的可觀測性。</p></li><li><p><strong>跨平台</strong>：TQUIC 可運行在 Rust 語言支持的各種平台，同時提供了 Rust/C/C++語言接口。</p></li><li><p><strong>基於 Rust</strong>：TQUIC 基於用內存安全語言編寫，可避免緩衝區溢出漏洞和其他內存相關錯誤的影響。</p></li><li><p><strong>高質量</strong>：TQUIC 包括充分的自動化測試，包括單元測試、模糊測試、集成測試、性能基準測試、互操作性測試等。</p></li><li><p><strong>協議一致性</strong>：TQUIC 已通過基於 Ivy 的形式化規範驗證。同時通過了 IETF 互操作性測試。</p></li><li><p><strong>豐富的功能</strong>：TQUIC 支持所有 QUIC、HTTP/3 規範中的重大功能。</p></li></ul><h4><strong>架構</strong></h4><p><img height="383" src="https://static.oschina.net/uploads/space/2023/1108/104746_mwuM_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 07:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/tquic</guid>
            <link>https://www.oschina.net/p/tquic</link>
        </item>
        <item>
            <title>
                <![CDATA[特斯拉「完全開源」初代 Roadster 設計和工程]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">埃隆·馬斯克 (Elon Musk)<span>&nbsp;在社交平台發文<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Felonmusk%2Fstatus%2F1727392569238159491" target="_blank">宣佈</a>，已將</span></span><span style="background-color:#ffffff; color:#222222">特斯拉 (Tesla) 初代 Roadster 跑車的設計和工程細節「完全開源」，併發布了所有人都可以訪問的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fservice.tesla.com%2Froadster" target="_blank">研發文件</a>。</span></p><blockquote><p><span style="color:#000000">「我們擁有的一切，現在你也擁有。」</span></p></blockquote><p><img height="312" src="https://oscimg.oschina.net/oscnet/up-34c1eef102f415f2e8a40190a16e4475a65.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">所披露的研發文件下方聲明指出：</span></span></p><blockquote><div><span style="color:#000000">此處提供的信息是為了向 Roadster 愛好者提供的，是在 Roadster 的研發設計階段創建的。它不是製造商的參考資料或維修保養材料，可能無法準確反映實際生產的車型或銷售的部件。如果您使用這些信息，您有責任確保遵守所有法律和安全協議，因為無論您是否使用此處提供的信息，我們都不對非特斯拉人員所做的任何工作提供任何保證。您還需瞭解，如果您根據此信息製造或設計零件或創建新的維修或程序，我們將不對它們負責，並且它們不是正品 Tesla 零件或配件或 Tesla 批准的程序。</span>&nbsp;
 </div></blockquote><p><span style="color:#000000"><span style="background-color:#ffffff">開源 Roadster 藍圖和技術細節的決定，被<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fteslanorth.com%2F2023%2F11%2F22%2Ftesla-opens-up-original-roadster-design-and-engineering-to-public%2F" target="_blank">視為</a>特斯拉促進電動汽車行業創新與合作的戰略步驟。此舉允許世界各地的個人、公司和研究人員訪問、研究特斯拉首款電動跑車所採用的技術，並在此基礎上進行開發。「這標誌着特斯拉對其專有技術的態度發生了重大轉變。」</span></span></p><p><span style="color:#000000">特斯拉初代 <span style="background-color:#ffffff">Roadster&nbsp;</span>於 2008 年推出，是電動汽車行業的里程碑式車型。它是第一輛在高速公路上合法使用鋰離子電池的純電動汽車，也是<span style="background-color:#ffffff">第一款</span>每次充電行駛里程超過 200 英里的電動汽車。</span></p><p><span style="color:#000000">但是特斯拉<span style="background-color:#ffffff">初代 Roadster 當時只生產了 2000 多輛，且已經有十多年沒有進行量產。特斯拉</span><span style="background-color:#ffffff">新一代的 Roadster&nbsp;曾在 </span><span style="background-color:#ffffff">2017 年 11 月的</span><span style="background-color:#ffffff">一場活動中亮相，但在經歷了多次推遲之後，至今仍未正式推出。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 06:56:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267767/roadster-open-source</guid>
            <link>https://www.oschina.net/news/267767/roadster-open-source</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[長安汽車基於 Apache Doris 的車聯網數據分析平台建設實踐]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>導讀：隨着消費者更安全、更舒適、更便捷的駕駛體驗需求不斷增長，汽車智能化已成必然趨勢。長安汽車智能化研究院作為長安汽車集團有限責任公司旗下的研發機構，專注於汽車智能化技術的創新與研究。為滿足各業務部門的數據分析需求，長安汽車基於 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fdoris" target="_blank">Apache Doris</a> 升級了車聯網數據分析平台，支撐單日百億級別數據實時處理，並實現十億級別數據查詢秒級響應，為長安汽車在提升用户用車體驗、實時預警車輛故障、保證車輛安全駕駛等方面帶來顯著成果，為其在智能化方向的技術創新提供了有力支持。</p><p>作者｜長安汽車智能化研究院</p></blockquote><p>智能化是汽車工業進程中的一場革命，它旨在利用大數據、人工智能、雲計算、物聯網等前沿數字技術，對汽車設備和系統的運行狀態進行全方位的感知、分析、決策和控制，從而提高汽車的安全性、舒適性、便捷性和節能性。</p><p>長安汽車智能化研究院作為長安汽車集團有限責任公司旗下的研發機構，專注於汽車智能化技術的創新與研究，其願景是通過持續創新和技術突破，實現汽車智能駕駛、智能網聯和智能交通的全面發展，為消費者提供更安全、更便捷、更智能的出行體驗，並致力於成為中國汽車智能化領域的領軍企業。</p><p>實現汽車智能化的關鍵之一，是需要建立穩定、高效的數據平台，以承載和利用海量的車聯網數據。作為智能化發展的重要支撐，長安汽車智能化研究院肩負着整個長安汽車集團車聯網數據的匯聚、處理和應用工作。為滿足各業務部門提出的數據支持需求，目前已經構建了車聯網數據分析平台，並在業務指標分析、質量管理系統、智慧能耗、智能診斷、智慧運營等多個重點領域實現數據應用。</p><p>本文將詳細介紹長安汽車車聯網數據分析平台的演進歷程及實踐經驗，<strong>分享長安汽車基於 Apache Doris 支撐單日百億級別數據實時處理、實現十億級別數據查詢秒級響應的實踐經驗</strong>。此外，<strong>Apache Doris 的引入還為長安汽車在用户用車體驗提升、駕駛安全保障等方面帶來顯著收益，為長安汽車從機電化到智能化轉型發展提供有力支持</strong>。</p><h1>汽車智能化所面臨的挑戰</h1><p>近些年來，長安汽車取得了令人矚目的銷量增長成績。1-8 月，長安汽車自主乘用車累計銷量超百萬輛、保持持續上升的發展勢頭，以深藍、阿維塔、啓源為代表的新能源系列品牌力和產品競爭力不斷提升，自主新能源車累計銷量約為 25.6 萬輛、同比增長 102.44%，成為銷量增長新動能。</p><p>在汽車銷量快速攀升的背後，車聯網數據更是呈現爆發式增長的態勢，其中最為核心的即車輛 CAN 總線數據。CAN 即 Controller Area Network，通過 CAN 總線可以對車輛上的各類電子控制系統進行統一通信，在實際車輛運行過程中 ，CAN 總線數據是車輛安全性、可靠性和高性能的重要保證：</p><ul><li>車輛系統監測和控制：CAN 總線數據可用於監測和控制系統中的各種設備和組件。傳感器通過 CAN 總線發送其測量值，如温度、壓力、位置等，以便其他設備或控制器實時監測和採取相應的措施。同時，控制器可以通過 CAN 總線向執行器發送控制指令，如調節閥門、驅動電機等，以實現對系統的控制。</li><li>車輛信息實時反饋：CAN 總線數據可用於提供實時反饋信息。例如在車輛控制系統中，傳感器通過 CAN 總線傳輸車速、轉向角度、制動狀態等數據，控制器可以根據這些數據進行實時決策和調整，以確保車輛的安全性和性能。</li><li>數據共享和協調：CAN 總線數據允許不同設備之間進行數據共享和協調。通過 CAN 總線，不同的控制器和設備可以交換信息，共享狀態和控制命令，有利於提高系統的整體性能和效率。</li><li>網絡管理和故障診斷：CAN 總線數據用於網絡管理和故障診斷。通過 CAN 總線，可以進行設備的自動識別、配置和監控，以便進行網絡管理和故障排查，提高系統的可靠性和可維護性。</li></ul><p><strong>隨着網聯車銷量不斷增長，車輛每天將產生千億級別的 CAN 數據，清洗處理後的數據也在 50 億級別</strong>，面對如此龐大且持續膨脹的數據規模，如何從海量數據中快速提取挖掘有價值的信息，為研發、生產、銷售等部門提供數據支持，成為當前亟需解決的問題。</p><p>而想要提供良好的數據支持及服務，首先需要應對以下幾大挑戰：</p><ul><li><strong>大規模數據實時寫入及處理</strong>：為實現智能化，汽車的車門、座椅、剎車燈設備被設置了大量的傳感器，每個傳感器收集一種或者多種信號數據，數據被匯聚後進一步加工處理。目前長安汽車需要支持至少 400 萬輛車的鏈接，車聯網數據每秒吞吐量已達百萬級 TPS ，每日新增數據規模高達數十 TB ，且還在持續增長中。如何對數據進行實時寫入成為了長安汽車首要面臨的挑戰。</li><li><strong>準確及時的實時數據分析需求</strong>：車聯網場景下數據分析通常要求實時性，快速獲取分析結果是實時監控、故障診斷、預警和實時決策等服務的重要保障。例如在智能診斷中，車企需要近實時地收集相關信號數據，並快速定位故障原因。通過分析車輛傳感器數據、行駛記錄等，可以提前發現潛在故障，進行預防性維護，提高車輛的可靠性和安全性。</li><li><strong>更加低廉的數據存儲和計算成本</strong>：面對快速增長的的數據以及日益強烈的全量寫入和計算需求，導致數據存儲和計算成本不斷攀升。這就要求數據平台具備低成本存儲和計算的能力，以降低使用成本；同時需具備彈性伸縮能力，以便用户在業務高峯期快速擴容，提升海量數據計算場景的分析效率。</li></ul><p>為給用户提供更優質的駕車體驗、為業務部門提供更準確高效的數據支持，長安汽車開始對大數據平台的建設進行探索和實踐。</p><h1>Hive 離線數據倉庫難以支撐超大規模實時數據服務</h1><p><img src="https://cdn.selectdb.com/static/Hive_17776ddfed.jpg" alt="長安汽車車聯網-Hive 離線數倉.jpg" referrerpolicy="no-referrer"></p><p>長安汽車最早以 Hive 為核心構建了數據平台架構，所處理數據包括車輛 CAN 總線數據和埋點數據，這些數據通過 4G 網絡從車端傳送至長安雲端網關，然後由網關將數據寫入 Kafka。考慮到數據量級和存儲空間的限制，早期架構中的數據處理流程是將 Kafka 採集到的數據直接通過 Flink 進行處理，並通過 ETL 將結果存儲到 Hive 中。下游應用使用 Spark SQL 進行逐層離線計算，並通過 Sqoop 將彙總數據導出到 MySQL 中。最終由 Hive 和 MySQL 分別為應用層提供數據服務。</p><p>儘管該架構在早期基本滿足了數據處理需求，但隨着車輛銷量不斷增長，當需要面對每天千億級別的數據處理分析工作時，架構的問題逐步暴露出來：</p><ul><li><strong>數據時效性無法保證</strong>：Hive 的導入速度較慢，尤其在處理大規模數據時，導入時間明顯增加；同時部分業務依賴 T+1 離線任務，無法滿足實時數據處理需求；此外， Hive 只支持分區覆蓋，不支持主鍵級別的數據更新，無法滿足特殊場景的數據更新需求。</li><li><strong>數據查詢分析延遲較高</strong>：對於 10 億級別以上大規模表查詢，Hive 查詢性能較慢。通過 SparkSQL 進行數倉分層運算時，啓動和任務執行時間較長，對查詢響應也會產生影響。此外，數據看板、BI 展示應用無法直接從 Hive 中查詢，需要將 Hive 中數據導出到 MySQL 中，由 MySQL 提供服務，受限於 Hive 導數性能，當數據量較大時，導出到 MySQL 耗時大幅增加，進而導致查詢響應時間變長。此外，通過 Java 後端查詢 MySQL 時，數據量過大也會影響數據的響應時間。</li></ul><p>追根究底，產生這些問題的根本原因在於早期架構無法滿足超大規模實時數據場景下的數據需求，這迫使長安汽車必須進行平台升級改造。</p><h1>技術調研與選型</h1><p>長安汽車經過深入調研，決定引入開源實時數據倉庫 Apache Doris ，在導入性能、實時查詢等方面具有顯著優勢：</p><ul><li><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.selectdb.com%2Fblog%2F106" target="_blank">豐富的數據導入方式</a></strong>：Doris 提供了豐富的內置導入方式，如 Broker Load 和 Stream Load 等，可以滿足實時和離線場景中數據導入需求。</li><li><strong>支持實時查詢分析</strong>：Doris 大表 Join 能力突出，提供了多種分佈式 Join 方式，使 Join SQL 編寫具備高度靈活性，極大提升數據分析的效率。此外，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.selectdb.com%2Fblog%2F56" target="_blank">Doris 支持單節點上萬 QPS 的超高併發</a>，可解決早期架構由於前端併發量過大導致查詢失敗的問題。</li><li><strong>較低的使用成本</strong>：Doris 兼容 MySQL 協議，開發人員可以更高效便捷的使用 MySQL 編寫和執行查詢語句，有效提高開發效率。基於 Doris 極簡的架構，不僅讓部署運維更加簡單，也讓擴縮容操作變的更加方便彈性。同時，Doris 擁有良好的上下游生態，可為用户提供靈活高效的數據管理和分析體驗。這些優勢和特性都極大的降低了 Doris 的使用成本。</li></ul><p>除此以外，<strong>開源社區的活躍度也是我們考慮的重要因素之一</strong> 。Apache Doris 吸引了大量的開發者及用户參與社區，共同貢獻代碼和改進 Doris，這對質量和穩定性的提高起關鍵作用。同時，Doris 社區為用户提供了全面的文檔資料和技術支持，任何問題都可以快速得到解答和幫助。Apache Doris 的活躍程度使我們在使用時更加放心，解決了技術方面的後顧之憂。</p><h1>基於 Apache Doris 車聯網數據分析平台</h1><p><img src="https://cdn.selectdb.com/static/_50f5a17a88.jpg" alt="長安汽車車聯網-車聯網數據分析平台.jpg" referrerpolicy="no-referrer"></p><p>在新的車聯網數據分析平台中，通過 Flink 結合 Doris 的 Stream Load 功能，可直接將 Kafka 數據實時寫入 Doris，同時，利用 Doris Broker Load 功能可以將 Hive 中數據導入到 Doris 中進行分析計算。在這個架構中，Apache Doris 承擔了實時數據部分的計算和處理，還作為結果端直接輸出數據給上游業務平台調用。</p><p>這一升級在系統上縮短了數據處理的路徑，保證了大規模數據導入的時效性。此外，Apache Doris 的引入為上游應用層提供統一數據服務支持，這對於查詢分析效率的提升至關重要。具體收益如下：</p><ul><li>便捷進行數據寫入和遷移：Doris 支持豐富的數據導入形式，可輕鬆從不同的數據源中導入數據。其次，Doris 支持通過 insert into select 快速導入數據，無需進行繁重的數據遷移配置以及引入外部同步組件。</li><li>統一數據服務，秒級查詢響應：通過 Doris Multi-Catalog 功能，數據分析師可直接從 Doris 上查詢數據，實現秒級別查詢響應。其次，Doris Join 能力優異，對於超過 1000 萬的結果表查詢也可實現秒級返回結果。</li><li>降低存儲和計算成本：在早期架構中，使用 Flink 實時寫入數據並進行壓縮時需要消耗大量的計算資源。而引入 Apache Doris 後，藉助 Doris ZSTD 壓縮算法（3-5 倍壓縮率提升），可有效降低計算和存儲所需的資源，還可以將壓縮處理流程放到 Doris 內部進行，無需消耗 Flink 計算資源。</li></ul><h1>從 T+1 到 T+0，實時數據提升智能駕駛體驗</h1><p>CAN 總線數據在車輛分析中扮演着關鍵的角色，通過 CAN 總線可以讀取車輛的各種狀態信息，例如車速、轉速、水温等。這些數據對於分析車輛的行駛數據具有重要的價值，為整車研發單位提供寶貴的參考信息。</p><p>在早期架構中，車輛 CAN 數據是按照 CAN ID 作為維度進行上傳的，而在實際使用中，通常需要將不同 CAN ID 的信號按照時間對齊形成一個寬表。過去的數倉架構解決方案會先將 Kafka 中的數據寫入到 Hive，此時不同 CAN ID 的數據被存儲在不同的行中，需要使用 SparkSQL T+1 將數據轉換為幾個不同業務域的寬表。然而，這種計算方式耗時較長，SQL 語句難以維護，且數據的實時性較差。</p><p>在引入 Apache Doris 之後，我們在 Doris 中基於 Aggregate 聚合模型建立了業務域的寬表，將車輛和時間等作為主鍵，其他的信號字段都用<code>REPLACE_IF_NOT_NULL</code>定義。具體如下：</p><p><img src="https://cdn.selectdb.com/static/_c3afa33c84.jpg" alt="長安汽車車聯網-實時數據.jpg" referrerpolicy="no-referrer"></p><p>首先，可以使用 Flink 來消費 Kafka 中按 CAN ID 維度的數據，在 Flink 中根據業務域寬表的配置對數據進行分流，將同一個 CAN ID 上的信號分配到相應的業務域寬表中。當同一個車輛在同一時間內不同 CAN ID 的數據到達同一個業務域寬表時，可以將這些數據填充到同一行中的不同 CAN ID 的信號數據字段中，實現寬表的構建（如上圖 Doris 的表示例）。</p><p>在這種方式中，主要通過 Flink 對數據進行分流，將數據發送到不同的 Doris 業務域寬表中（每個寬表約有 200 個字段）。寬表的生成邏輯被放在了 Doris 中，而不是在 Flink 中進行寬表對齊的操作。這樣設計的原因是不同 CAN ID 的數據上傳存在一定的時間差，時間窗口過大時，使用 Flink 根據車輛和時間進行聚合可能會導致資源開銷過高。</p><p><strong>通過以上方案，可以將數據的新鮮度從 T+1 提高到 T+0 。同時，對於包含約 10 億行數據的寬表，可以達到秒級的查詢效率，即在進行單車查詢時，可以快速地獲取查詢結果。</strong></p><h1>10 億級別 DTC 故障碼實時查詢，保障車輛駕駛安全</h1><p>DTC 屬於 CAN 數據中的故障報文，因此對其進行單獨的業務數據存儲。每天的 DTC 數據量級可以達到 10 億條，為了讓業務端便捷高效的使用這些數據，快速進行故障診斷，提升車輛安全性，需要將 DTC 故障碼明細數據與一張 MySQL 業務配置表進行關聯。</p><p>在早期架構中，開發人員每天都需要將海量 DTC 數據先寫入到 Kafka 中，然後通過 Flink 進行實時處理，並將結果存儲到 Hive 中。而這種處理方式存在一些問題：</p><ul><li>面對 10 億級數據量的表，難以將其導入 MySQL 進行實時查詢。如果直接查詢 Hive，則查詢反饋時間會非常長，難以滿足業務需求。</li><li>由於無法直接關聯 MySQL 的配置表，不得不定時將配置表導入 Hive 數倉。這樣做雖然能夠滿足數據處理的需求，但卻丟失了 DTC 配置的實時性。</li></ul><p><img src="https://cdn.selectdb.com/static/_98e4700c50.jpg" alt="長安汽車車聯網-實時查詢.jpg" referrerpolicy="no-referrer"></p><p>在引入 Apache Doris 後，採用上圖所示處理方式成功解決了早期架構存在的問題。首先將 Hive 的 DTC 明細數據通過 HDFS 文件導入的方式導入到 Doris 中，然後創建對應的 MySQL Catalog 連接，最後使用後端 Java 通過 MyBatis 連接 Doris 數據庫，並使用 SQL 通過 Catalog 連接 MySQL 的 DTC 配置表進行 Join 操作，可直接實時查詢返回結果。</p><p>通過 Apache Doris 成功完成了 10 億級別數據的實時查詢，並且可以對關聯的 MySQL 配置表進行直接關聯查詢，成功實現了<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.selectdb.com%2Fblog%2F31" target="_blank">配置的實時更新</a>。</p><h1>總結與規劃</h1><p><strong>憑藉 Apache Doris 卓越的性能，目前在長安汽車已經部署數十台機器，支撐了近十條業務線，每天處理數據規模達到百億級別。</strong> Apache Doris 的引入為長安汽車在提升用户用車體驗、實時預警車輛故障、保證車輛安全駕駛等方面帶來顯著成果，為其在智能化方向的技術創新提供了有力支持。</p><p>未來，長安汽車將進一步將 Apache Doris 應用在標籤和指標業務，實現以下需求：</p><ul><li>自動識別冷熱數據：將熱數據存儲在 Apache Doris 中，冷數據存儲在 Hive 中，通過這種方式實現更高效的數據訪問和管理。</li><li>擴大業務範圍：對現有的 Doris 業務 SQL 代碼進行優化，利用 Doris 的某些特性和功能，將適合這些特性的業務遷移到 Doris 中，從而提高數據處理和查詢的效率。</li><li>共建社區：積極嘗試使用 Doris 最新版本及新功能，在與社區保持同步的同時，不斷探索和應用新的技術，反哺社區、為社區發展做出貢獻。</li></ul><p>最後，衷心感謝 Apache Doris 社區和<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.selectdb.com%2F" target="_blank">飛輪科技技術團隊</a>的積極支持，期待未來與大家繼續深入合作，推動長安汽車智能化發展，為用户提供更好的駕車體驗！</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 03:29:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5735652/blog/10143334</guid>
            <link>https://my.oschina.net/u/5735652/blog/10143334</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Node.js v20.10.0 (LTS)]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Node.js v20.10.0 已正式發佈，代號 'Iron'。根據發佈時間表，由於上月&nbsp;Node.js 21 已正式發佈，因此&nbsp;Node.js 20 就變成了長期支持版本 (LTS)。</p><p><strong>新版本主要變化</strong></p><ul><li><strong>引入新的<code>--experimental-default-type</code>flag，用於改變 Node.js 的默認 module</strong><br> 通過設置 <strong><code>--experimental-default-type=module</code></strong>，可以將原本隱式的 CommonJS 模塊解釋為 ES 模塊。</li><li><strong>引入新的<code>--experimental-detect-module</code>flag</strong>，用於檢測 JavaScript 中不明確的 ESM 語法<br> 該 flag 用來自動檢測 ES 模塊的語法。對於「模稜兩可」的文件，Node.js 會解析文件以檢測是否包含 ES 模塊語法，如果檢測到，則將其作為 ES 模塊運行，否則將其作為 CommonJS 模塊運行。</li><li><strong>為文件系統函數引入新的&nbsp;<code>flush</code>&nbsp;選項</strong><br> 在寫入文件時，可能會出現數據不立即刷新到永久存儲的情況。為瞭解決這個問題，fs.writeFile 系列函數新增了 flush 選項，可以在成功寫入操作結束時強制刷新數據。</li><li><strong>新增實驗性的 WebSocket 客户端</strong><br> 使用&nbsp;<strong><code>--experimental-websocket</code></strong>&nbsp;flag，可以添加一個全局的 WebSocket 對象，符合 WHATWG 的標準。</li><li>修復 vm.Script 的 V8 編譯緩存支持</li></ul><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnodejs.org%2Fen%2Fblog%2Frelease%2Fv20.10.0" target="_blank">詳情查看發佈公告</a></u>。</p><p>延伸閲讀：<u><em><a href="https://www.oschina.net/news/262268/nodejs-v21-release-released" target="news">Node.js 21 正式發佈</a></em></u></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 02:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267730/nodejs-v20-10-0-lts</guid>
            <link>https://www.oschina.net/news/267730/nodejs-v20-10-0-lts</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Git 2.43 值得關注的新特性]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Git 發佈了最新版本 2.43，新增了許多改進和新功能。</p><p>以下是 Git 2.43 的部分亮點：</p><ol><li><p><strong><code>git repack</code>的新功能</strong>：在 Git 2.43 中，git repack 學會了一些新技巧。git repack 用於重新組織倉庫中的 pack 文件。在這個版本中，git repack 支持使用多個 cruft pack，並且可以通過對象過濾器將倉庫的內容拆分為多個部分。</p></li><li><p><strong>多 cruft pack</strong>：在過去，Git 將無法訪問的對象存儲在單個 cruft pack 中。但是，這樣做會導致在每次重新打包操作時都需要重寫整個 cruft pack，從而浪費大量的 I/O 時間。在 Git 2.43 中，引入了對多個 cruft pack 的本地支持，可以將無法訪問的對象拆分為多個 pack，從而提高性能。</p></li><li><p><strong>使用對象過濾器拆分倉庫</strong>：Git 的「partial clone」機制允許在包含有限對象子集的倉庫中進行交互。在 Git 2.43 中，git repack 學會了使用對象過濾器規範重新打包倉庫，並可以選擇將過濾後的對象移動到其他位置。這使得可以根據需要輕鬆地過濾和移除不需要的對象。</p></li><li><p><strong>針對 revert 多次回滾的改進</strong>：在過去的 Git 版本中，當多次回滾時，每次回滾都會在提交消息中添加"Revert"，導致提交消息變得冗長。在 Git 2.43 中，Git 意識到進行多次回滾時，會生成更簡潔的提交消息。</p></li></ol><p>詳情查看&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.blog%2F2023-11-20-highlights-from-git-2-43%2F" target="_blank">https://github.blog/2023-11-20-highlights-from-git-2-43/</a></u></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 10:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267835/git-2-43-highlights</guid>
            <link>https://www.oschina.net/news/267835/git-2-43-highlights</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[雲安全之盾：ZStack 雲主機安全防護解決方案全方位保護雲環境]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0.0001pt; margin-right:0px"><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#000000">隨着雲計算的蓬勃發展，網絡威脅愈發複雜，涵蓋了從勒索病毒到 APT 攻擊的各種威脅類型。在這一風雲變幻的網絡安全環境下，雲主機安全不再僅僅是一個選項，它是信息系統安全的核心要素。</span></span></span><span><span><span style="color:#000000">雲軸科技</span></span></span><span><span><span style="color:#000000">ZStack&nbsp;雲主機安全</span></span></span><span><span><span style="color:#000000">防護</span></span></span><span><span><span style="color:#000000">解決方案是為了滿足這一需求而生的，與 ZStack</span></span></span><span><span><span style="color:#000000">&nbsp;Cloud</span></span></span><span><span><span style="color:#000000">雲</span></span></span><span><span><span style="color:#000000">平台</span></span></span><span><span><span style="color:#000000">全面</span></span></span><span><span><span style="color:#000000">兼容、殺毒性能卓越、具備全面的安全特性，同時支持多部署模式和多操作系統。該方案不僅僅是一個安全防護措施，更是一種安全保障的完整體系，保護</span></span></span><span><span><span style="color:#000000">企業級客户</span></span></span><span><span><span style="color:#000000">的數據和應用安全。<img alt="" height="597" src="https://oscimg.oschina.net/oscnet/up-f056bf758422a99c12e7e04c28f227e5b3a.png" width="1031" referrerpolicy="no-referrer"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0.0001pt; margin-right:0px"><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#000000">在雲計算環境下，雲主機承載着關鍵數據和核心業務系統，一旦遭受攻擊，最重要的部分可能會被盜取或破壞。而傳統的殺毒模式資源佔用過多，影響生產系統的性能。因此，一個與底層雲計算平台兼容、功能全面且同時具備穩定性和高性能的雲主機安全解決方案至關重要。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><strong><span><span><span style="color:#000000">ZStack&nbsp;雲主機安全防護解決方案</span></span></span></strong><strong><span><span><span style="color:#000000">亮點</span></span></span></strong></li><li><span><span><span style="color:#000000">雲主機安全</span></span></span><span><span><span style="color:#000000">防護解決方案</span></span></span><span><span><span style="color:#000000">與</span></span></span><span><span><span style="color:#000000">ZStack Cloud</span></span></span><span><span><span style="color:#000000">雲</span></span></span><span><span><span style="color:#000000">平台深度融合，確保雲計算環境的穩定運行。</span></span></span></li><li><span><span><span style="color:#000000">支持無代理模式，通過虛擬化層直接進行病毒查殺，降低性能損耗。</span></span></span></li><li><span><span><span style="color:#000000">支持 0day 漏洞在線補丁修復，保證業務連續性。</span></span></span></li><li><span><span><span style="color:#000000">具備全生命週期的安全能力，包括事前預防、事中防禦和事後溯源。</span></span></span></li><li><span><span><span style="color:#000000">多部署模式支持，兼容多類型操作系統，靈活方案選擇，降低管理成本。</span></span></span></li></ul><p><span><span><span style="color:#000000"><img alt="" height="573" src="https://oscimg.oschina.net/oscnet/up-e5916906c1b1392e81c3895d25fe7c3a429.png" width="1255" referrerpolicy="no-referrer"></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:start"><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#000000">ZStack 雲主機安全</span></span></span><span><span><span style="color:#000000">防護</span></span></span><span><span><span style="color:#000000">解決方案適用於不停機補丁修復、雲主機無代理殺毒、宿主機加固防護以及雲主機安全綜合防護等多個應用場景。能夠降低黑客攻擊帶來的損失，提高運維效率，構建閉環安全系統，為</span></span></span><span><span><span style="color:#000000">雲主機提供全面保護。為數據中心雲平台提供事前防禦措施，事中威脅處理和事後攻擊溯源能力，應對網絡威脅升級帶來的安全挑戰。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:start"><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#000000">ZStack 將繼續改進和創新，以提供更完整的產品和解決方案，支撐和</span></span></span><span><span><span style="color:#000000">保護客户的數據</span></span></span><span><span><span style="color:#000000">和業務，迎接未來的業務和安全挑戰</span></span></span><span><span><span style="color:#000000">。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 10:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267832</guid>
            <link>https://www.oschina.net/news/267832</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Ubuntu 在新 AMD Zen 4 Threadripper 上的性能比 Windows 11 高約 20%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Freview%2Fthreadripper-7995wx-windows-linux" target="_blank">根據 Phoronix 的報道</a></u>，對於最新的 AMD Zen 4 Threadripper 處理器，運行 Ubuntu 會比 Windows 11 獲得更好的性能，前者較後者大約提升了 20% 的性能。這項測試是在一台配置了 HP Z6 G5 A 工作站的 96 核 AMD Ryzen Threadripper PRO 7995WX 處理器上進行的。</p><p><img src="https://oscimg.oschina.net/oscnet/up-c4adb3609ed3dba446e73d67cbfe76cf0a3.png" referrerpolicy="no-referrer"></p><p>測試結果顯示，Linux 在處理高核心數處理器時的性能優勢比 Windows 更明顯。這主要歸功於 Linux 內核調度程序在處理大核心數處理器時的優秀表現。此外，Linux 在處理這類高端台式機和工作站上的性能方面也比 Windows 更出色。</p><p>測試中，HP Z6 G5 A 工作站分別運行了預裝的 Windows 11 Pro 和 Ubuntu 23.10 操作系統。在運行了一系列適用於高端台式機和工作站的基準測試後，結果顯示 Ubuntu Linux 在大部分測試中都表現出更好的性能。這表明 Ubuntu Linux 在處理高核心數處理器時能夠更好地利用硬件資源，從而提供更高的性能。</p><p>需要注意的是，這項測試是在特定硬件配置下進行的，因此結果可能會因為不同的硬件配置而有所不同。此外，這項測試只涉及到 Ubuntu 23.10 操作系統，其他 Linux 發行版的性能可能會有所不同。</p><p>總的來説，根據這項測試結果，如果你在使用 AMD Zen 4 Threadripper 處理器的高端台式機或工作站，選擇 Ubuntu Linux 作為操作系統可能會獲得更好的性能。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 10:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267827</guid>
            <link>https://www.oschina.net/news/267827</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌將於 2024 年 6 月開始禁用 Manifest V2]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">谷歌<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.chrome.com%2Fblog%2Fresuming-the-transition-to-mv3%2F" target="_blank">宣佈</a>恢復&nbsp;<span style="background-color:#ffffff">Manifest V2 的</span><span style="background-color:#ffffff">棄用時間表，以繼續向 Manifest V3 邁進從而提供更高的安全性和隱私保障。</span>計劃最早將於 2024 年 6 月開始在 Chrome 127 及更高版本的 pre-stable 版（開發版、金絲雀版和測試版）中禁用 Manifest V2 擴展。</span></p><p><span style="color:#000000">生效後，Manifest V2 擴展程序將在瀏覽器中被自動禁用，並且無法再從 Chrome 網上商城安裝 Manifest V2 擴展程序。與此同時，Manifest V2 擴展程序將失去 Chrome 網上商城中的精選徽章（如果目前有的話）。</span></p><p><img height="311" src="https://static.oschina.net/uploads/space/2023/1123/174712_jZM4_4252687.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">此前谷歌曾宣佈 Chrome 瀏覽器將在 2023 年 1 月停止支持 Manifest V2 擴展，並且也不再支持更新。但後續卻因為 Bug 太多，導致</span></span><a href="https://www.oschina.net/news/221452/google-delays-chrome-manifest-v3">多次推遲發佈</a><span style="background-color:#ffffff; color:#333333"><span>&nbsp;</span></span><span style="color:#000000"><span style="background-color:#ffffff">Manifest V3 版本，延長&nbsp;Manifest V2 的使用日期，</span>並於去年 12 月宣佈暫停了 Manifest V2 的棄用計劃。</span></p><p><span style="color:#000000">在這將近一年的時間裏，項目團隊表示已根據反饋對 Manifest V3 進行了一系列修改，解決了開發人員反饋的問題併為遷移提供了更好的解決方案。</span></p><p><span style="color:#000000">該公司計劃逐步推出這一變更，同時收集用户反饋並收集數據，以確保 Chrome 瀏覽器用户充分了解詳情並尋找到可替代的擴展。預計變更從 pre-stable 版推廣到 Chrome 穩定版至少需要一個月的時間，具體時間可能會根據收集到的數據而有所不同。</span></p><p><span style="color:#000000">對於那些使用 ExtensionManifestV2Availability 策略來確保 Manifest V2 擴展在其組織中持續運行的企業，將有額外一年的時間（直到 2025 年 6 月）來遷移其組織中的 Manifest V2 擴展。在此之前，啓用了該策略的瀏覽器不會受到停用的影響。</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">對於仍在發佈 Manifest V2 擴展的開發者，谷歌方面強烈建議他們在 2024 年 6 月之前完成向 Manifest V3 的遷移，並提供了一份</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%2Fmigrating%2F" target="_blank">遷移指南</a>。</p><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.chrome.com%2Fblog%2Fresuming-the-transition-to-mv3%2F" target="_blank">查看官方公告</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 09:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267820/google-resuming-the-transition-to-mv3</guid>
            <link>https://www.oschina.net/news/267820/google-resuming-the-transition-to-mv3</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[快來查收 KCL 社區開源快訊 | 雲原生模型、語言和工具鏈更新速遞!]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img height="258" src="https://oscimg.oschina.net/oscnet/up-10a425f008580d122921fd1db5cbadc672c.jpg" width="520" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:left"><strong>雙週同步開源進展</strong></p><p style="color:#000000; text-align:left"><strong>歡迎加入 KCL 社區進行互動～</strong></p><p style="color:#000000; text-align:left">KCL 是一個&nbsp;CNCF 基金會託管的基於約束的記錄及函數語言，期望通過成熟的編程語言技術和實踐來改進對大量繁雜配置比如雲原生 Kubernetes 配置場景的編寫，致力於構建圍繞配置的更好的模塊化、擴展性和穩定性，更簡單的邏輯編寫，以及更簡單的自動化和生態工具集成。</p><p style="color:#000000; text-align:left">本欄目將會雙週更新 KCL 語言社區最新動態，包括功能、官網更新和最新的社區動態等，幫助大家更好地瞭解 KCL 社區！</p><p style="color:#000000; text-align:left"><em><strong>KCL 官網：<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fkcl-lang.io%2F" target="_blank">https://kcl-lang.io</a></strong></em></p><h2>內容概述</h2><p style="color:#000000; text-align:left">感謝所有貢獻者過去兩週 (2023 11.09 - 11.23) 的傑出工作，以下是重點內容概述</p><p style="color:#000000; text-align:left"><strong>📦 模型更新</strong></p><ul><li>KCL 模型數量新增至<span>&nbsp;</span><strong>200 個</strong>，主要新增與<span>&nbsp;</span><code>Pod</code>,<span>&nbsp;</span><code>RBAC</code><span>&nbsp;</span>相關的校驗模型及 Kubernetes 1.14-1.28 版本的模型參考文檔</li><li>可以在<span>&nbsp;</span><code>Artifact Hub</code><span>&nbsp;</span>中搜索瀏覽到所有模型的文檔及使用方式:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fartifacthub.io%2Fpackages%2Fsearch%3Forg%3Dkcl%26sort%3Drelevance%26page%3D1" target="_blank">https://artifacthub.io/packages/search?org=kcl&amp;sort=relevance&amp;page=1</a></em></li></ul><p style="color:#000000; text-align:left"><strong>💬 語言更新</strong></p><ul><li><strong>體驗改進</strong><ul><li>優化配置代碼塊的語法縮進檢查，不再強制報錯</li><li>支持通過文件路徑通配符作為編譯入口</li></ul></li><li><strong>錯誤修復</strong><ul><li>修復部分場景字典類型的類型推導錯誤</li><li>修復 Schema 參數數量的檢查</li></ul></li></ul><p style="color:#000000; text-align:left"><strong>🔧 工具鏈更新</strong></p><ul><li><strong>測試工具發佈</strong><ul><li>支持使用 KCL 函數編寫單元測試並使用工具執行測試</li><li>支持使用正則表達式過濾待測試用例</li><li>支持單元測試快速失敗功能</li></ul></li><li><strong>導入工具更新</strong><ul><li>修復 patterns 到正則匹配表達式的生成:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-openapi%2Fpull%2F70" target="_blank">https://github.com/kcl-lang/kcl-openapi/pull/70</a></em></li><li>修復 minItems/maxItems 到字段長度校驗規則的生成:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-openapi%2Fpull%2F69" target="_blank">https://github.com/kcl-lang/kcl-openapi/pull/69</a></em></li><li>修復 0 或空字符串為默認值的生成:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-openapi%2Fpull%2F69" target="_blank">https://github.com/kcl-lang/kcl-openapi/pull/69</a></em></li><li>修復 Kubernetes CRD 到 KCL Package 轉換中包名的生成為：<code>${apiVersion}_${kind}</code>:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-openapi%2Fpull%2F68" target="_blank">https://github.com/kcl-lang/kcl-openapi/pull/68</a></em></li></ul></li><li><strong>包管理工具更新</strong><ul><li>新增 update 命令用於自動更新本地依賴:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkpm%2Fpull%2F212" target="_blank">https://github.com/kcl-lang/kpm/pull/212</a></em></li></ul></li></ul><p style="color:#000000; text-align:left"><strong>💻 IDE 更新</strong></p><ul><li><strong>體驗改進</strong><ul><li>支持包管理工具引入的外部包依賴 import 語句補全</li></ul></li><li><strong>錯誤修復</strong><ul><li>修復函數參數未定義類型錯誤顯示位置</li></ul></li></ul><p style="color:#000000; text-align:left"><strong>🏄 API 更新</strong></p><ul><li>新增 KCL 單元測試 API:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fpull%2F904" target="_blank">https://github.com/kcl-lang/kcl/pull/904</a></em></li><li>新增 KCL 符號重命名 API:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fpull%2F890" target="_blank">https://github.com/kcl-lang/kcl/pull/890</a></em></li></ul><p style="color:#000000; text-align:left"><strong>🔥 架構升級</strong></p><ul><li>KCL 設計並重構了新的語義模型以及支持最近符號查找和符號語義信息查詢 API</li><li>IDE 補全，跳轉和懸停等功能實現遷移至新語義模型，顯著降低 IDE 功能開發難度和代碼量</li></ul><p style="color:#000000; text-align:left"><strong>🚀 性能提升</strong></p><ul><li>KCL 編譯器支持語法增量解析以及語義增量檢查，大部分場景提升 KCL 編譯構建和 IDE 插件使用性能<span>&nbsp;</span><strong>5-10 倍</strong></li></ul><h2>特別鳴謝</h2><p style="color:#000000; text-align:left">以下排名不分先後</p><ul><li>感謝 @cr7258 對 KCL 模型庫以及 KCL 文檔的貢獻 🙌 
  <ul><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-lang.io%2Fpull%2F203" target="_blank">https://github.com/kcl-lang/kcl-lang.io/pull/203</a></em></li><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-lang.io%2Fpull%2F209" target="_blank">https://github.com/kcl-lang/kcl-lang.io/pull/209</a></em></li><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-lang.io%2Fpull%2F210" target="_blank">https://github.com/kcl-lang/kcl-lang.io/pull/210</a></em></li><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-lang.io%2Fpull%2F211" target="_blank">https://github.com/kcl-lang/kcl-lang.io/pull/211</a></em></li><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fmodules%2Fpull%2F67" target="_blank">https://github.com/kcl-lang/modules/pull/67</a></em></li></ul></li><li>感謝 @XiaoK29 為 KCL IDE 的懸停和引用查找功能代碼架構重構以及 KCL 文檔的貢獻 🙌 
  <ul><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fpull%2F887" target="_blank">https://github.com/kcl-lang/kcl/pull/887</a></em></li><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fpull%2F899" target="_blank">https://github.com/kcl-lang/kcl/pull/899</a></em></li><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-lang.io%2Fpull%2F205" target="_blank">https://github.com/kcl-lang/kcl-lang.io/pull/205</a></em></li></ul></li><li>感謝 @MeenuyD, @negz 對&nbsp;<strong>Crossplane KCL Composition Functions</strong>&nbsp;集成的討論與支持 🙌 
  <ul><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fissues%2F885" target="_blank">https://github.com/kcl-lang/kcl/issues/885</a></em></li></ul></li><li>感謝 @kolloch 對&nbsp;<strong>Bazel KCL</strong>&nbsp;構建規則腳本的寶貴反饋 🙌 
  <ul><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Frules_kcl%2Fpull%2F2" target="_blank">https://github.com/kcl-lang/rules_kcl/pull/2</a></em></li></ul></li><li>感謝 @陸雲, @Even Solberg, @Prahalad Ramji @Matt Gowie, @ddh 和 @mouuii 在使用推廣 KCL 過程中的交流與寶貴反饋 🙌</li></ul><h2>精選更新</h2><h3>在 Artifact Hub 上檢索 KCL 代碼包及雲原生模型</h3><ul><li>通過 k8s 模型編寫或者校驗 Kubernetes 配置</li></ul><p style="color:#000000; text-align:left">&nbsp;</p><p><img height="413" src="https://oscimg.oschina.net/oscnet/up-be579d3f163ed2a9ef989f516169d64f9b1.png" width="1080" referrerpolicy="no-referrer"></p><ul><li>通過 Open Application Model (OAM) 開放應用模型配合 KubeVela 控制器進行應用發佈與運維</li></ul><p style="color:#000000; text-align:left">&nbsp;</p><p><img height="770" src="https://oscimg.oschina.net/oscnet/up-8a2737b64f74b1d5a27733ce7a5a084a195.png" width="1080" referrerpolicy="no-referrer"></p><ul><li>查找 KCL 代碼庫如&nbsp;<code>jsonpatch</code>&nbsp;進行配置操作</li></ul><p><img height="718" src="https://oscimg.oschina.net/oscnet/up-15703cf81898b8126bed226fd3e1c45141a.png" width="1080" referrerpolicy="no-referrer"></p><ul><li>通過引入 KusionStack Modules 模型生態並配合 KusionStack 增強客户端的應用交付體驗：<em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FKusionStack%2Fcatalog" target="_blank">https://github.com/KusionStack/catalog</a></em></li></ul><p><img height="697" src="https://oscimg.oschina.net/oscnet/up-16ff10fe152afe1ca5321397a39a1b5b41d.png" width="1080" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:left">想了解更多？🤔️ 後續我們會通過一系列文章講解各個模型更具體使用場景以及工作流程，敬請期待! 此外，200+ 模型的源代碼位於&nbsp;<em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fmodules" target="_blank">https://github.com/kcl-lang/modules</a></em>，歡迎社區的小夥伴進行共建。❤️</p><h2>其他資源</h2><p style="color:#000000; text-align:left">❤️ 感謝所有 KCL 用户和社區小夥伴在社區中提出的寶貴反饋與建議。預計&nbsp;11 月底我們會正式發佈 KCL v0.7 新版本，敬請期待!</p><p style="color:#000000; text-align:left">更多其他資源請參考：</p><ul><li><p>KCL 網站<span>&nbsp;</span><em>:</em><span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fkcl-lang.io%2F" target="_blank">https://kcl-lang.io/</a></em></p></li><li><p>KusionStack 網站:&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fkusionstack.io%2F" target="_blank">https://kusionstack.io/</a></p></li><li><p>KCL 2023 路線規劃:<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fkcl-lang.io%2Fdocs%2Fcommunity%2Frelease-policy%2Froadmap" target="_blank">https://kcl-lang.io/docs/community/release-policy/roadmap</a></p></li><li><p>KCL v0.7.0 Milestone:<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fmilestone%2F7" target="_blank">https://github.com/kcl-lang/kcl/milestone/7</a></p></li><li><p>KCL v0.8.0 Milestone:<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fmilestone%2F8" target="_blank">https://github.com/kcl-lang/kcl/milestone/8</a></p></li><li><p>KCL Github Issues:<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fissues" target="_blank">https://github.com/kcl-lang/kcl/issues</a></p></li><li><p>KCL Github Discussion:<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Forgs%2Fkcl-lang%2Fdiscussions" target="_blank">https://github.com/orgs/kcl-lang/discussions</a></p></li><li><p>👉&nbsp;戳鏈接加入 KCL 社區:<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fcommunity" target="_blank">https://github.com/kcl-lang/community</a></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 09:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267815</guid>
            <link>https://www.oschina.net/news/267815</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[feilong 4.0.3 發佈了，讓 Java 開發更簡便的工具庫]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#1f2328; text-align:start">feilong 4.0.3 發佈了，讓 Java 開發更簡便的工具庫</p><ol><li>讓你從大量重複的底層代碼中脱身,提高開發效率;</li><li>讓你的代碼<code>更簡煉</code>，<code>易寫</code>、<code>易讀</code>、<code>易於維護</code>;</li></ol><p style="color:#1f2328; text-align:start">文檔地址:<span>&nbsp;</span><a href="http://feilong-core.mydoc.io/">http://feilong-core.mydoc.io/</a></p><p style="color:#1f2328; text-align:start">maven 依賴配置:</p><div><pre>&lt;<span style="color:var(--color-prettylights-syntax-entity-tag)">dependency</span>&gt;
     &lt;<span style="color:var(--color-prettylights-syntax-entity-tag)">groupId</span>&gt;com.github.ifeilong&lt;/<span style="color:var(--color-prettylights-syntax-entity-tag)">groupId</span>&gt;
     &lt;<span style="color:var(--color-prettylights-syntax-entity-tag)">artifactId</span>&gt;feilong&lt;/<span style="color:var(--color-prettylights-syntax-entity-tag)">artifactId</span>&gt;
     &lt;<span style="color:var(--color-prettylights-syntax-entity-tag)">version</span>&gt;4.0.3&lt;/<span style="color:var(--color-prettylights-syntax-entity-tag)">version</span>&gt;
&lt;/<span style="color:var(--color-prettylights-syntax-entity-tag)">dependency</span>&gt;</pre><div>
  &nbsp;
 </div></div><p style="color:#1f2328; text-align:start">Gradle 依賴配置:</p><div><pre><span style="color:var(--color-prettylights-syntax-storage-modifier-import)">com</span>.<span style="color:var(--color-prettylights-syntax-storage-modifier-import)">github</span>.<span style="color:var(--color-prettylights-syntax-storage-modifier-import)">ifeilong</span>:<span>feilong</span>:<span style="color:var(--color-prettylights-syntax-constant)">4.0</span><span style="color:var(--color-prettylights-syntax-constant)">.3</span></pre><div>
  &nbsp;
 </div></div><p style="color:#1f2328; text-align:start">本次升級共有<span>&nbsp;</span><code>12</code><span>&nbsp;</span>處變更, 具體參見<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fmilestone%2F37%3Fclosed%3D1" target="_blank">4.0.3 milestone</a></p><h2>🐛<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Abug%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">bug</a></h2><p style="color:#1f2328; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F626" target="_blank">#626</a><span>&nbsp;</span>log 動態參數，最後一個 e 沒有生效 [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Afeilong-net-bot%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">feilong-net-bot</a>]</p><h2>🍑<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Afeilong-core%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">feilong-core</a></h2><p style="color:#1f2328; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F624" target="_blank">#624</a><span>&nbsp;</span>✨ 新建 com.feilong.core.lang.ThreadUtil.execute(List, Map&lt;String, ?&gt;, PartitionPerHandler) [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]</p><p style="color:#1f2328; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F635" target="_blank">#635</a><span>&nbsp;</span>PartitionEachSizeThreadConfigBuilder 新增 javadoc [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Ajavadoc%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">javadoc</a>]<br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F636" target="_blank">#636</a><span>&nbsp;</span>✨ 新建 com.feilong.core.lang.ThreadUtil.execute(List, PartitionPerHandler) [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]<br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F630" target="_blank">#630</a><span>&nbsp;</span>✨ 新建 com.feilong.core.net.URLUtil.transformHttpsToHttp(String) [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]<br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F631" target="_blank">#631</a><span>&nbsp;</span>✨ 新建 com.feilong.core.net.URLUtil.transformProtocol(String, String, String) [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]<br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F627" target="_blank">#627</a><span>&nbsp;</span>✨ 新建 com.feilong.core.net.URLUtil.transformHttpToHttps(String) [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]<br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F632" target="_blank">#632</a><span>&nbsp;</span>標識 PartitionEachSizeBuilder<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FFunctionalInterface" target="_blank">@FunctionalInterface</a><br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F633" target="_blank">#633</a><span>&nbsp;</span>標識 PartitionPerHandler<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FFunctionalInterface" target="_blank">@FunctionalInterface</a><br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F634" target="_blank">#634</a><span>&nbsp;</span>標識 PartitionRunnableBuilder<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FFunctionalInterface" target="_blank">@FunctionalInterface</a></p><h2>🍷<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Afeilong-net%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">feilong-net</a></h2><p style="color:#1f2328; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F629" target="_blank">#629</a><span>&nbsp;</span>✨ RequestByteArrayBody 支持字符串格式的 MimeType [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]</p><h2><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Afeilong-net-bot%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">feilong-net-bot</a></h2><p style="color:#1f2328; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F625" target="_blank">#625</a><span>&nbsp;</span>✨ 新建個帶簽名類似於短信 [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]</p><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 08:27:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267802/feilong-4-0-3</guid>
            <link>https://www.oschina.net/news/267802/feilong-4-0-3</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Fortran 2023 發佈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Fortran 2023 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.iso.org%2Fstandard%2F82170.html" target="_blank">已發佈</a>。Fortran 2023 是 Fortran 語言的最新版本，它在性能、易用性和並行編程方面都有顯著的改進。如果您正在編寫一個需要對大型數值數組進行快速計算的程序或庫，Fortran 2023 是您的最佳選擇。</p><p>Fortran 2023 根據 ISO/IEC 1539-1:2023 標準發佈。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/1123/163021_T3nW_2720166.png" referrerpolicy="no-referrer"></p><p>Fortran 2023 是 Fortran 編程語言的最新版本。它是一種高性能並行編程語言，專為科學和工程計算而設計。Fortran 2023 具有許多強大的特性，使得它成為處理大規模數值數組的快速計算的理想工具。</p><ol><li><p>高性能：Fortran 2023 針對科學和工程計算應用進行了優化，具有成熟且經過實戰驗證的編譯器和庫，可以編寫接近底層的高效二進制代碼。</p></li><li><p>靜態和強類型：Fortran 是一種靜態和強類型的語言，這使得編譯器能夠在早期捕捉到許多編程錯誤。這也使得編譯器能夠生成高效的二進制代碼。</p></li><li><p>易學易用：Fortran 是一種相對簡單的語言，學習和使用起來非常容易。通過將大多數數學和算術操作表達為方程式，可以輕鬆地處理大型數組。</p></li><li><p>多功能：Fortran 允許您以最適合問題的方式編寫代碼：命令式、過程式、面向數組、面向對象或函數式。</p></li><li><p>本地並行：Fortran 是一種本地並行編程語言，具有直觀的類似數組的語法，用於在 CPU 之間傳遞數據。您可以在單個 CPU 上、共享內存多核系統上或分佈式內存的 HPC 或基於雲的系統上運行幾乎相同的代碼。Coarrays、teams、events 和集體子程序允許您表達最適合當前問題的不同並行編程模式。</p></li></ol><p>有關語法變更的摘要，查看：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffortran.bcs.org%2F2022%2FAGM22_Reid.pdf" target="_blank">https://fortran.bcs.org/2022/AGM22_Reid.pdf</a></u>。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/1123/162951_mnjD_2720166.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 08:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267801/fortran-2023</guid>
            <link>https://www.oschina.net/news/267801/fortran-2023</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 如何做好架構設計，架構設計有章可循嗎？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><em><span>設計一個系統的過程，就是建造一座大廈的過程，架構設計的質量直接決定了大廈的質量。</span></em></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在我們進行系統的架構設計時，總是會遇到一系列的問題，比如一個大型系統的架構應該如何起步，從哪裏開始設計？系統是否應該劃分成多個模塊，應該怎麼劃分模塊才更加的合理？亦或是覺得產品提出的需求非常不合理，完全影響我們正常的架構設計！對於非功能性的需求，我們是否可以得過且過，不去重視？</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>這些問題，讓我們在剛開始架構設計時手足無措，但是隨着我們完成一個又一個的系統架構設計以後，發現架構設計是有章法可循的，只要我們學習這些章法和套路，並且在工作過程中不斷的積累與沉澱，就會行成一個完整的架構設計方法論，面對新的大型系統架構設計，也會一步一步有節奏進行，最終完成整體的架構設計。</span></span></span></p><span id="OSC_h1_1"></span><h1><span><span><span style="background-color:#b7eb8f">架構設計的原則</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>架構設計需要遵循一些原則：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span style="color:black">1、架構設計需要方法體系</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>架構設計並不是一個」單一的方法「，直接拿來進行架構設計，而是多個各具特色的方法，組成的「方法體系」，並且這個體系隨着新技術的發展還會不斷進化。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span style="color:black">2、架構設計是質疑驅動</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>架構設計是質疑驅動的過程，在」需求驅動「的基礎上，我們需要不斷的質疑我們架構設計的中間成果，進一步通過「質疑」，引入更多的「質量屬性」及更多「功能場景」。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span style="color:black">3、多階段下的多視圖</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>架構設計，是多階段還是多視圖？架構設計首先是「多階段的」，我們將架構設計劃分成多個階段，在每個階段中才會考慮」視圖「這個維度。</span></span></span></p><span id="OSC_h3_2"></span><h3><span><span><em><span>架構設計的三個階段</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>階段一、 預備階段</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>預備階段的目標：全面理解需求，把握需求特點，確定架構設計驅動力。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在預備階段，我們需要全面的梳理與理解需求，不放過任何一個需求細節。同時分析需求產生的各項質量屬性與系統約束，同時兼顧這些約束進行架構設計，才能不遺漏重大的架構屬性。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>階段二、 概念架構</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>概念架構，必須考慮包括</span></span></span><span><span><strong><span>功能</span></strong></span></span><span><span><strong><span>，</span></strong></span></span><span><span><strong><span>質量</span></strong></span></span><span><span><strong><span>，</span></strong></span></span><span><span><strong><span>約束</span></strong></span></span><span><span><span>在內的所有方面的需求。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>階段三、 細化架構</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在細化架構階段，我們從五個不同的角度出發，設計五個視圖，完成整個系統全方位的設計。</span></span></span></p><span id="OSC_h3_3"></span><h3><span><span><em><span>架構設計的一個貫穿環節</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><strong><span>對非功能需求的考慮</span></strong></span></span><span><span><span style="color:black">：</span></span></span><span><span><span>非功能需求無法一蹴而就，因為在設計的過程當中，會有新的需求不斷的被發現，即使設計完成，在開發階段，都會有影響非功能需求的約束出現，所以在整個階段，都應該注意非功能需求。</span></span></span></p><span id="OSC_h1_4"></span><h1><span><span><span style="background-color:#b7eb8f">預備架構階段分析</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><em><span>預備架構的最重要的目標，是建立需求大局觀，把握需求特點，確定架構設計驅動力。通過對需求的詳細分析，有一個宏觀的需求感知，同時還要兼顧系統的質量要求和約束對系統設計造成的制約條件。</span></em></span></span></p><span id="OSC_h3_5"></span><h3><span><span><em><span>需求結構化</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>需求是有結構的，而不是零散的需求點，只有將分析後的需求結構化，才能宏觀的感知整個需求。可以藉助 ADMEMS 二維矩陣，將架構影響因素，梳理脈絡。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如以下矩陣分析，將需求劃分為多個維度，橫向上從」廣義功能「」，質量「」，約束「三個方面分析，廣義功能是指需求需要滿足的基本功能，及產品或業務人員的直接要求。質量維度則是系統設計時需要考慮的高併發，高可用，可拓展等技術設計維護，保證系統在滿足基本需求的同時，同時對後續系統進化發展以及極端場景（例如：用户量激增，秒殺）等的滿足。約束則是系統設計時的一些制約，例如上線日期，上線環境，開發人員技能水平等。縱向上劃分為」業務級需求「」，用户級需求「」，開發級需求「三個維護」，業務級需求「是指產品或業務人員提出的基本要求」，用户級需求「則是從系統的使用用户角度出發，發現的例如用户電腦操作水平，用户使用習慣等潛在需求，而」開發級需求「，則是從研發人員角度出發，發現的例如可拓展，可測試，技術環境等不同維度的需求。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>通過將需求結構化，我們可以全面的分析整體的需求，對需求進行整體的理解，同時也可以從不同的角度發現系統制約條件，在系統設計的最開始階段就着手設計，防止遺漏重大約束導致架構設計失敗。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-21F216gXpb11EiRfhbt.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h3_6"></span><h3><span><span><em><span>分析約束影響</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>約束分析的幾個方面：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 來自產品或運營人員的約束性需求</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>系統的非功能需求，例如：上線時間，預算，工期要求等</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>業務領域相關的限制，例如業務規則或業務限制，相關法律，專利等。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 來自</span></span></span><span><span><strong><span>用户</span></strong></span></span><span><span><span>的約束性需求</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>系統的用户，同樣會產生約束性需求，比如用户的計算機水平，年齡段，使用偏好，國家等。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如用户計算機水平整體較弱的話，在開發交互方式時就不應太過複雜，同時要兼顧系統的魯棒性，防止系統被用户搞掛。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>用户使用產品時的外部環境同樣可能產生約束條件，比如訪問環境是內網或是外網，則決定了系統提供訪問鏈接不同的網絡權限。訪問環境信號強度若，則系統的性能要求則更高。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、 來自</span></span></span><span><span><strong><span>開發或運維人員</span></strong></span></span><span><span><span>的約束性需求</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>開發團隊的技術水平，磨合程度，同樣制約着系統的開發，如果開發人員均是高級研發人員且對當前技術棧有深入的瞭解，則開發進度就會更快，如果是新團隊，且需要對技術棧進行學習才可以介入開發，則在工期或系統風險層面需要額外考慮。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>4、 業界</span></span></span><span><span><strong><span>當前技術環境</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>當前技術環境中間件的成熟程度，編程語言及流行度，優缺點等，都會對架構設計產生約束條件。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>約束的分類：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 直接約束</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如：系統運行於 linux 平台。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 轉換為功能需求的約束</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於這種約束，可以直接轉換為功能需求</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如：供應商擁有自己的一套城市信息表 -&gt; 引出的功能需求：需要進行城市轉換</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如：供應商服務器性能差，tps 最大 10 -&gt; 引出的功能需求：需要進行限流請求</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、 轉換為質量屬性需求的約束</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如：系統使用者計算機水平不高</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>轉換為質量屬性：易用性（否則不會用），魯棒性（系統被搞癱）</span></span></span></p><span id="OSC_h3_7"></span><h3><span><span><em><span>確定關鍵質量</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><em><span>系統的關鍵質量是需要進行取捨的，需要確認業務人員更注重那方面或在滿足需求的基礎上，確定哪些是必須的，哪些是可以適當忽略的。</span></em></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>我們需要首先確定架構重點支持哪些質量屬性，然後對於相互矛盾的質量屬性，進行權衡折中。例如當滿足性能這個質量屬性時，同時就會因為引入新的方案或組件，導致可維護性，可測試性降低；提高可拓展性時，就會對系統的性能和安全性產生影響等等，我們需要做的，就是在各個關鍵質量中進行取捨。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-22LELMr9d22zFXatK50.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span></p><span id="OSC_h3_8"></span><h3><span><span><em><span>確定關鍵功能</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>確定關鍵功能的 4 個方面</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 核心功能</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 必做功能</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、 高風險功能</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>4、 獨特功能</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>其他常見系統不存在的功能</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><strong><span>注意衍生需求：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>從需求轉入設計時，因方案制定過程的複雜，會產生大量的衍生需求，衍生需求是原始需求的數倍。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><em><span>舉例：</span></em></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>原始需求：定時拉取供應商數據。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>衍生需求：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 由於供應商數量較多，需要引入分佈式定時任務，集羣併發拉取</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 由於供應商數據量大，需要分庫分表設計</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、需要快速搜索，引入存儲引擎組件等等</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-24DBopViOOSWkb7SO.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span>這些衍生需求我們必須要考慮，雖然業務需求沒有體現，但缺失架構設計的關鍵影響因素。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>架構驅動力對比：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>業務需求驅動架構：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-25pbrXAR24YnLHpXB21.png" width="284" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span>重大需求驅動架構：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-2511lKgKmtlkleQWxu.png" width="284" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span>由此可以看出，通過重大需求驅動的架構，更能考慮到更關鍵的部分，設計的架構更能滿足需求的要求，架構設計成功的概率會更高。</span></span></span></p><span id="OSC_h1_9"></span><h1><span><span><span style="background-color:#b7eb8f">概念架構階段分析</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><em><span>概念架構階段，對系統進行適當的分解，而不陷入細節</span></em></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>概念架構的過程是，先根據關鍵功能進行初步設計，然後對設計的系統進行高層分割，接下來考慮非功能性需求（關鍵質量和約束），然後修改自己的初步設計，循環往復，在不斷的質疑和優化過程中，完善架構設計。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-26T7A52xvPwdCSGT7q.png" width="474" referrerpolicy="no-referrer"></div><p>&nbsp;</p><span id="OSC_h3_10"></span><h3><span><span><em><span>初步設計</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>初步設計的目標是發現職責，無需展開細節設計。基於關鍵功能，進行初步設計，</span></span></span><span><span><strong><span>基於主流程，關鍵流程，黃金流程等進行流轉圖設計，從而發現職責。</span></strong></span></span></p><span id="OSC_h3_11"></span><h3><span><span><em><span>高層分割</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>切分複雜系統，為多個二級系統。或者直接切分為具體子系統。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>高層分割的兩種方式：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 系統切分</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>切分的考慮點，包括系統功能、部署環境、語言、系統規模等</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如一個大型系統，切分為訂單，商品，供應鏈等系統。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 系統內切分</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>根據系統的職責、調用關係、通用性等，進行系統內部切分。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>最常見的就是分層，例如一個系統，切分為網關層，服務層，搜索模塊，man 端等。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>分層的角度</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 邏輯分層</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>邏輯分層重視職責的劃分，職責直接常常是上層使用下層的關係，上層和下層，可以是分佈在不同的機器，也可以分佈在同一台機器。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 物理分層</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>分佈在不同機器上的軟件單元。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、 通用性分層</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>通用性不同的，劃分為不同的層，一般通用性越大，所處的層次越靠下。</span></span></span></p><span id="OSC_h3_12"></span><h3><span><span><em><span>考慮非功能需求</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>具體方法是：採用</span></span></span><span><span><strong><span>目標-場景-決策表</span></strong></span></span><span><span><span>，見下圖：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>架構設計是質疑驅動的，例如，質疑係統的可用性，考慮系統可能宕機，則引入集羣部署設計，考慮下游接口可能超時或出現異常，則引入接口降級的設計等。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-30khnlGt6Qe939QO21.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span>考慮場景的 5 個要素</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 影響來源，來自系統內部還是系統外部</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 如何影響的</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、 受影響的對象</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>4、 有什麼問題或有什麼價值</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>5、 所處的環境為何</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>對場景的權衡因素：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>價值，代價，開發難度，出現幾率。對於某些場景，經過全面的權衡和思考，可以不支持，並不是所有的場景都要支持，否則可能存在過度設計。</span></span></span></p><span id="OSC_h1_13"></span><h1><span><span><span style="background-color:#b7eb8f">細化架構階段分析</span></span></span></h1><span id="OSC_h3_14"></span><h3><span><span><span style="color:black">邏輯視圖</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>邏輯視圖是對系統的不同部分</span></span></span><span><span><strong><span>職責</span></strong></span></span><span><span><span>的劃分，根據職責不同，可以將系統進行細粒度的拆分，劃分為多個子系統。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span style="background-color:#87e8de">分層的細化</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>根據系統設計的需要，可以將系統的分層進行細化，例如展示層 -&gt; 業務層 -&gt; 數據層，可以細化為：展示層 -&gt; 控制層 -&gt; 接口層 -&gt; 接口實現層 -&gt; 數據層。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-32iq0B11mN3f32twUqC.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span style="background-color:#87e8de">分區的引入</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>分區的概念是業務流程相關的，分區的依據是：</span></span></span><span><span><strong><span>職責</span></strong></span></span><span><span><span>，比如結算流程可以作為一個分區，下單流程可以作為一個分區。將系統劃分為多個分區，一方面可以支持並行開發，另一方面也將系統劃分為多個子域，有利於業務概念和業務流程的收斂。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-33tPJdWeJMDcvCT5c.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span style="background-color:#87e8de">機制的提取</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>機制是指系統可以抽象的公共部分，例如公共工具，公共組件，公共流程等，提取這些公共部分，對於架構設計是至關重要的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>劃分子系統的原則：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 職責不同的單元，劃分為不同的子系統</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 通用性不同的單元，劃分為不同的子系統</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、 需要不同開發技能的單元，劃分為不同的子系統兼顧工作量，進一步切分太大的系統</span></span></span></p><span id="OSC_h3_15"></span><h3><span><span><span style="color:black">開發視圖</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>開發架構視圖的任務，是將「邏輯職責」映射為「程序單元」，例如：要自主編寫的「源程序」，可重用的庫，框架等；同時進行開發技術選型，例如：開發語言，開發工具等，然後也需要確立程序單元間的關係，project 劃分，目錄結構，編譯依賴關係等。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-37jm117lDma8m21KTOo.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span></span></span></span></p><span id="OSC_h3_16"></span><h3><span><span><span>運行視圖</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>運行架構設計的工作內容，是確定引入哪些控制流：進程，線程等；確定每條控制流的任務，同時還要處理相關問題，例如控制流的創建，銷燬，通信機制等，控制流之間的同步關係，是否有資源爭用，是否需要加鎖等也需要考慮。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-37xeumJqiBEAkn0Su.png" width="284" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h3_17"></span><h3><span><span><span>物理視圖</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>物理架構設計的 3 項任務</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1. 硬件的選擇與物理拓撲</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2. 軟件到硬件的映射關係</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3. 方案的優化</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>思維要點：「開銷」和「爭用」是核心，應避免爭用，降低開銷。</span></span></span></p><span id="OSC_h3_18"></span><h3><span><span><span>數據視圖</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>數據視圖是系統的數據存儲設計，根據對系統的分析，確定一種或多種數據策略，常見的數據分佈策略如下 6 種：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>1、獨立的 Schema</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>不同系統應用，使用不同的數據 schema，數據完全獨立，一般界限清晰的不同系統可以採用這種方式。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-38IAcR6ctu568BXqUB.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span style="color:black">2</span></span></span><span><span><span style="color:black">、集中</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span style="color:black">不同的系統應用，使用同一個數據庫，一般具有關聯屬性的應用可以採用這種方式，比如一個系統分為服務端和管理端，但都屬於一個系統，則可以使用同一個數據庫。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-39lOCEP39j21zaVHggv.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span style="color:black">3</span></span></span><span><span><span style="color:black">、分區</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>水平分區</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>水平分區即我們常見的分表方案，當一個 schema 無法滿足我們的數據量要求時，可以劃分為多個分區，每個分區存儲一部分數據。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-396Zrt9eYBraZnGV0.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span style="color:black">垂直分區</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span style="color:black">垂直分區是分區策略的另外一個維度，當我們單庫無法承載巨大的數據量時，也可以根據數據的類別，進行垂直分區。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-40EKfhbfQ13Rmif3x.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>4、複製</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span style="color:black">多個數據庫保存相同的數據，根據制定的更新策略保證不同庫之間的數據同步，</span></span></span><span><span><span>我們常用的讀寫庫分離，即為此方案，主庫提供寫能力，從庫提供讀能力，其中從庫的數據是根據主庫數據同步而來。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-40LnrTouVj21EUvpx0.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span>5、子集</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>根據一些特殊的場景要求，需要保存原數據的部分數據，例如 application1 保存全量訂單，application2 只需要部分出票成功的訂單，進行後續分析操作，則可以使用子集的策略進行數據視圖設計。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-40Moxg9UObMUth8l9.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span>6、重組</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span style="color:black">通過多個不同的 application 作為數據來源，異構至其他 application，用於數據的分析或後續流程使用。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-41RIaqyVykQOqcxwX.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span></p><span id="OSC_h1_19"></span><h1><span><span><span>總結</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>架構設計的三個階段：預備架構階段；概念架構階段；細化架構階段</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>架構設計的四個要素：需求結構化；分析約束的影響；確定關鍵質量；確定關鍵功能</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>概念架構的三個步驟：基於關鍵功能初步設計；系統高層分割；分析非功能需求</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>細化架構的五個視圖：邏輯視圖；開發視圖；運行視圖；物理視圖；數據視圖</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>一個貫穿環節：非功能需求的考慮</span></span></span></p><span id="OSC_h3_20"></span><h3><span><span><span>參考資料</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1.《一線架構設計指南》</span></span></span></p><blockquote><p>作者：京東零售&nbsp;馮曉濤</p><p>來源：京東雲開發者社區，轉載請註明來源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 07:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10149764</guid>
            <link>https://my.oschina.net/u/4090830/blog/10149764</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[程序員篡改 ETC 餘額，一年私吞 260 餘萬元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>上海網警公眾號今日報道了一起程序員的違法犯罪案件。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrSUrzlxsrEHgzp0dqhXH1A" target="_blank">據介紹</a></u>，2023 年 9 月上海警方接到某科技公司員工張女士報案稱，其公司發現計算機系統被他人篡改數據，導致公司賬户錢款損失。</p><p>民警對公司後台電子數據出現的異常賬户進行提取，蒐證中發現，<strong>操作者很有可能是管理網站後台系統的員工，監守自盜的可能性較大</strong>。</p><p>民警隨即展開工作，最終嫌疑人曹某迫於壓力主動投案自首。</p><p><img height="810" src="https://static.oschina.net/uploads/space/2023/1123/140254_7G6Y_2720166.png" width="1080" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1123/140427_D2nm_2720166.png" referrerpolicy="no-referrer"></p><p>曹某是該公司的軟件工程師，他坦白稱，<strong>去年 8 月發現公司網站後台的漏洞，用母親和朋友身份證註冊了兩個 ETC 賬户。</strong></p><p><strong>一年內兩個賬户分別從公司提取來了 230 餘萬元和 36 萬元，總計 260 餘萬元。</strong>目前其因涉嫌盜竊罪已被依法刑事拘留，案件正在進一步審理中。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 06:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267760</guid>
            <link>https://www.oschina.net/news/267760</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[9 月國內手機市場出貨量 3327.7 萬部，5G 手機佔比 86.3%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>中國信通院<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FhtODPwuYMGpG0LLkXScHqw" target="_blank">發佈</a>了 2023 年 9 月國內手機市場運行分析報告，具體情況如下：</p><h4 style="margin-left:0px; margin-right:0px"><strong>一、國內手機市場總體情況</strong></h4><p style="margin-left:0; margin-right:0">2023 年 9 月，國內市場手機出貨量 3327.7 萬部，同比增長 59.0%，其中，5G 手機 2871.7 萬部，同比增長 90.1%，佔同期手機出貨量的 86.3%。</p><p style="margin-left:0; margin-right:0">2023 年 1-9 月，國內市場手機總體出貨量累計 2.0 億部，同比增長 2.2%，其中，5G 手機出貨量 1.62 億部，同比增長 5.5%，佔同期手機出貨量的 80.7%。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="288" src="https://oscimg.oschina.net/oscnet/up-69c95e09317725c4f7ffc7ef79b2f4738ff.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>圖 1&nbsp; 國內手機市場出貨量及 5G 手機佔比</strong></p><p style="margin-left:0; margin-right:0">2023 年 9 月，國內手機上市新機型 42 款，同比增長 23.5%，其中 5G 手機 20 款，同比增長 33.3%，佔同期手機上市新機型數量的 47.6%。</p><p style="margin-left:0; margin-right:0">2023 年 1-9 月，上市新機型累計 335 款，同比增長 9.8%，其中 5G 手機 153 款，同比下降 1.9%，佔同期手機上市新機型數量的 45.7%。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="294" src="https://oscimg.oschina.net/oscnet/up-c560fe8a7f746252f0eb067442a16f4a434.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>圖 2&nbsp; 國內手機上市新機型數量及 5G 手機佔比</strong></p><h4 style="margin-left:0px; margin-right:0px"><strong>二、國內手機市場國內外品牌構成</strong></h4><p style="margin-left:0; margin-right:0">2023 年 9 月，國產品牌手機出貨量 2494.6 萬部，同比增長 36.1%，佔同期手機出貨量的 75.0%；上市新機型 41 款，同比增長 36.7%，佔同期手機上市新機型數量的 97.6%。</p><p style="margin-left:0; margin-right:0">2023 年 1-9 月，國產品牌手機出貨量累計 1.63 億部，同比下降 3.9%，佔同期手機出貨量的 81.4%；上市新機型累計 307 款，同比增長 10.4%，佔同期手機上市新機型數量的 91.6%。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="229" src="https://oscimg.oschina.net/oscnet/up-f96594c4ab35fa2f58a6f38fc849910fae5.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>圖 3&nbsp; 國產品牌手機出貨量及佔比</strong></p><h4 style="margin-left:0px; margin-right:0px"><strong>三、國內智能手機發展情況</strong></h4><p style="margin-left:0; margin-right:0">2023 年 9 月，智能手機出貨量 3193.4 萬部，同比增長 60.9%，佔同期手機出貨量的 96.0%。2023 年 1-9 月，智能手機出貨量 1.92 億部，同比增長 0.3%，佔同期手機出貨量的 95.6%。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="260" src="https://oscimg.oschina.net/oscnet/up-914d590bdbd5b0ede95fa2c8e1f6e33b3f8.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>圖 4&nbsp; 國內智能手機出貨量及佔比</strong></p><p style="margin-left:0; margin-right:0">2023 年 9 月，智能手機上市新機型 32 款，同比增長 14.3%，佔同期手機上市新機型數量的 76.2%。2023 年 1-9 月，智能手機上市新機型累計 279 款，同比增長 8.6%，佔同期上市新機型數量的 83.3%。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 03:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267742</guid>
            <link>https://www.oschina.net/news/267742</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[俄羅斯操作系統 ALT Linux 支持龍芯處理器 (LoongArch)]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>根據俄媒 CNews 的<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnews.ru%2Fnews%2Ftop%2F2023-11-16_rossiyane_vpervye_nauchili" target="_blank">報道</a></u>，ALT Linux 操作系統已經正式添加對龍芯處理器的適配，支持龍芯 3A5000、龍芯 3A6000 等 CPU。得益於龍芯 CPU 出口限制已經被解除，<strong>俄羅斯相關部門可以採購這些 CPU 來替代 AMD 和英特爾的產品</strong>。</p><p><img src="https://static.oschina.net/uploads/space/2023/1123/113827_V5RM_2720166.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b019b0af83f74abe941843b40680ea69e8a.png" referrerpolicy="no-referrer"></p><p>ALT Linux 由俄羅斯公司 Basalt SPO 開發，其桌面環境基於 KDE Plasma 及 Xfce 構建，設計風格和 Windows 類似。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6090cfdcee56fe3b264b7d1c10ce5b543eb.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-5842fd873798b6510a44b29f117b94c0961.png" referrerpolicy="no-referrer"></p><p>報道稱，Basalt SPO 的開發團隊非常高效，只花了 9 個月時間，就將 ALT Linux 移植到了龍芯 LoongArch 架構。</p><p>Basalt SPO 表示，目前支持龍芯的 ALT Linux 已開始提供不穩定的測試分支，<strong>預計穩定的 11.0 正式版將在明年第一季度發佈，採用 Xfce 桌面環境</strong>。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 03:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267741/russia-alt-os-linux-loongson-loongarch</guid>
            <link>https://www.oschina.net/news/267741/russia-alt-os-linux-loongson-loongarch</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[博通宣佈成功收購 VMware]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">博通（Broadcom）宣佈已經獲得<span style="background-color:#ffffff">收購所需的所有必要監管批准，成功</span>完成了對雲計算公司 VMware 的收購。</span></p><p><span style="color:#000000">中國方面於 2023 年 11 月 21 日批准了該收購，不過附帶了額外的限制性條件。聲明明確指出，VMWare 的服務器軟件應與本地硬件保持兼容，收購不得對客户購買和使用博通的硬件產品（包括存儲適配器）施加限制。</span></p><p><span style="color:#000000"><img height="266" src="https://oscimg.oschina.net/oscnet/up-304e8a97c668a6833abc83fd09a46010735.png" width="700" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">收購完成後，該公司將致力於開發解決方案，幫助客户優化其私有云、混合雲和多雲環境，並從任何地方運行應用程序和服務。公告表示，博通未來的工作重點將聚焦在幫助企業客户創建並現代化其私有云和混合雲環境。</span></p><p><span style="color:#000000">該公司計劃投資 VMware Cloud Foundation，<span style="background-color:#ffffff">這是一個作為私有云和混合雲基礎的軟件堆棧。</span>作為收購的一部分，VMware 將在 VMware Cloud Foundation 之上提供一系列服務。</span></p><p><span style="color:#000000">博通針對 VMware Tanzu 的計劃是通過加速跨各種雲環境的應用程序開發、交付和管理來增強客户的業務敏捷性。該解決方案適用於 VMware Cloud Foundation 和主要的超大規模提供商，為 Spring 等應用程序開發框架提供優化。Tanzu 提高了開發人員的工作效率，同時使平台團隊能夠執行標準、維護安全性和跟蹤性能。</span></p><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.broadcom.com%2Fblog%2Fbroadcom-announces-successful-acquisition-of-vmware" target="_blank">查看官方公告</a>。</span></p><p><strong><span style="color:#000000">相關閲讀：</span></strong></p><ul><li><a href="https://www.oschina.net/news/197527/broadcom-vmware-61-billion" target="_blank">博通擬以 610 億美元收購 VMware</a></li><li><a href="https://www.oschina.net/news/249166/eu-approves-broadcom-vmware-acquisition" target="news">博通 610 億美元收購 VMware 已獲歐盟委員會批准</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 03:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267737/broadcom-successful-acquisition-of-vmware</guid>
            <link>https://www.oschina.net/news/267737/broadcom-successful-acquisition-of-vmware</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[PHP 8.3 GA]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>PHP 8.3 <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.php.net%2Freleases%2F8.3%2Fzh.php" target="_blank">已正式發佈</a></u>。主要變化包括：</p><ul><li>類常量顯式類型 (Typed class constants)</li><li>只讀屬性深拷貝</li><li>新增<code>#[\Override]</code>屬性</li><li>新增<code>json_validate()</code>函數</li><li>添加<code>Randomizer::getBytesFromString()</code>方法</li><li>添加<code>Randomizer::getFloat()</code>和<code>Randomizer::nextFloat()</code>方法</li><li>以及更好的性能、更好的語法、改進類型安全</li></ul><p><img height="1114" src="https://static.oschina.net/uploads/space/2023/1123/110607_AwYL_2720166.png" width="2552" referrerpolicy="no-referrer"></p><p>下面介紹部分語法的變化。</p><ul><li><strong>類型化類常量</strong></li></ul><p>PHP &lt; 8.3</p><pre><code class="language-php">interface I {
    // We may naively assume that the PHP constant is always a string.
    const PHP = 'PHP 8.2';
}

class Foo implements I {
    // But implementing classes may define it as an array.
    const PHP = [];
}</code></pre><p>PHP 8.3</p><pre><code class="language-php">interface I {
    const string PHP = 'PHP 8.3';
}

class Foo implements I {
    const string PHP = [];
}

// Fatal error: Cannot use array as value for class constant
// Foo::PHP of type string</code></pre><ul><li><strong>動態獲取類常量</strong></li></ul><p>PHP &lt; 8.3</p><pre><code class="language-php">class Foo {
    const PHP = 'PHP 8.2';
}

$searchableConstant = 'PHP';

var_dump(constant(Foo::class . "::{$searchableConstant}"));</code></pre><p>PHP 8.3</p><pre><code class="language-php">class Foo {
    const PHP = 'PHP 8.3';
}

$searchableConstant = 'PHP';

var_dump(Foo::{$searchableConstant});</code></pre><ul><li><strong>只讀屬性深拷貝</strong></li></ul><p><code>readonly</code>屬性現在可以在魔術方法<code>__clone</code>中被修改一次，以此實現只讀屬性的深拷貝。</p><p>PHP &lt; 8.3</p><pre><code class="language-php">class PHP {
    public string $version = '8.2';
}

readonly class Foo {
    public function __construct(
        public PHP $php
    ) {}

    public function __clone(): void {
        $this-&gt;php = clone $this-&gt;php;
    }
}

$instance = new Foo(new PHP());
$cloned = clone $instance;

// Fatal error: Cannot modify readonly property Foo::$php</code></pre><p>PHP 8.3</p><pre><code class="language-php">class PHP {
    public string $version = '8.2';
}

readonly class Foo {
    public function __construct(
        public PHP $php
    ) {}

    public function __clone(): void {
        $this-&gt;php = clone $this-&gt;php;
    }
}

$instance = new Foo(new PHP());
$cloned = clone $instance;

$cloned-&gt;php-&gt;version = '8.3';</code></pre><ul><li><strong>新增<code>#[\Override]</code>屬性</strong></li></ul><p>通過給方法添加<code>#[\Override]</code>屬性，PHP 將確保在父類或實現的接口中存在同名的方法。<br> 添加該屬性表示明確説明覆蓋父方法是有意為之，並且簡化了重構過程，因為刪除被覆蓋的父方法將被檢測出來。</p><p>PHP &lt; 8.3</p><pre><code class="language-php">use PHPUnit\Framework\TestCase;

final class MyTest extends TestCase {
    protected $logFile;

    protected function setUp(): void {
        $this-&gt;logFile = fopen('/tmp/logfile', 'w');
    }

    protected function taerDown(): void {
        fclose($this-&gt;logFile);
        unlink('/tmp/logfile');
    }
}

// The log file will never be removed, because the
// method name was mistyped (taerDown vs tearDown).</code></pre><p>PHP 8.3</p><pre><code class="language-php">use PHPUnit\Framework\TestCase;

final class MyTest extends TestCase {
    protected $logFile;

    protected function setUp(): void {
        $this-&gt;logFile = fopen('/tmp/logfile', 'w');
    }

    #[\Override]
    protected function taerDown(): void {
        fclose($this-&gt;logFile);
        unlink('/tmp/logfile');
    }
}

// Fatal error: MyTest::taerDown() has #[\Override] attribute,
// but no matching parent method exists</code></pre><ul><li><strong>新增<code>json_validate()</code>函數</strong></li></ul><p><code>json_validate()</code>可以檢查一個字符串是否為語法正確的 JSON，比<code>json_decode()</code>更有效。</p><p>PHP &lt; 8.3</p><pre><code class="language-php">function json_validate(string $string): bool {
    json_decode($string);

    return json_last_error() === JSON_ERROR_NONE;
}

var_dump(json_validate('{ "test": { "foo": "bar" } }')); // true</code></pre><p>PHP 8.3</p><pre><code class="language-php">var_dump(json_validate('{ "test": { "foo": "bar" } }')); // true</code></pre><hr><p>此外，PHP 8.0 的生命週期即將結束。早在 2022 年 11 月 26 日，PHP 8.0 結束了積極支持，而安全支持也將在 PHP 8.3 正式發佈三天後——2023 年 11 月 26 日停止。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267734/php-8-3-ga</guid>
            <link>https://www.oschina.net/news/267734/php-8-3-ga</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
