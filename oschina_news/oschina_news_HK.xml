<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 14 Dec 2023 02:47:05 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Linux 內核刪除「高齡」驅動補丁，但它支持的設備似乎從未存在過？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>英特爾多年來一直為其硬件產品提供非常及時的 Linux 上游支持。通常來説，他們會在產品計劃公開發布很早之前就啓動相關工作。</p><p>在許多情況下，這就意味着英特爾在 Linux 內核中添加了某些硬件支持補丁——<strong>但這些硬件最終不會面向消費者發佈</strong>。比如最近的 Thunder Bay 支持，在明確 SoC 永遠不會發布後，內核就刪除了對該硬件的支持。</p><p>但現在出現了一個更極端的情況，<strong>一個驅動程序在主線內核中存在了 15 年，卻是為了支持從未發佈的硬件</strong>。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Flkml%2F20231208224703.1603264-1-willy%40infradead.org%2F" target="_blank">根據 Linux 內核最近的提交</a></u>，維護者準備刪除支持英特爾"Carillo Ranch"硬件產品的&nbsp;<span>2000 多行驅動程序代碼（</span>fbdev 驅動，和 backlight 驅動）<span>，刪除的原因是</span>"Carillo Ranch"<span>似乎根本就不存在。</span></p><p><img src="https://oscimg.oschina.net/oscnet/up-5fcc2aa84734ff67c32a2166c1742c636e4.png" referrerpolicy="no-referrer"></p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FLinux-Drop-Intel-Carillo-Ranch" target="_blank">據瞭解</a></u>，Carillo Ranch 是一款 90 納米的 32 位單核處理器，主頻為 1.2GHz，熱設計功耗為 19 瓦，適用於嵌入式設備。</p><blockquote><p>「據任何人所知，這款產品從未發佈。即使發佈了，它也是在 2007 年推出的，再也沒有人能夠使用它了。」</p></blockquote><p>早在 2007 年，英特爾就資助了 Tungsten Graphics（該公司在被 VMware 收購之前推動了 Mesa 的開發），為 Carillo Ranch 開發<strong>幀緩衝區 (FBDEV) 驅動程序</strong>。還有一個<strong> MTD Carillo Ranch 驅動程序</strong>，英特爾在 2006 年資助 MontaVista 開發該驅動程序。</p><p>如果在谷歌搜索"Intel Carillo Range"以尋找出處，會被重定向至「Intel Carrillo Range」(注意多了個字母 r)，而唯一的搜索結果會跳轉到 MontaVista 的一份聯繫方式表格。表格裏有一句話：「我們希望聽到關於這款主板的更多信息：Intel Carrillo Range，兼容奔騰 M，Vermillion Range。」</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 14 Dec 2023 02:44:01 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270960/linux-drop-intel-carillo-ranch</guid>
            <link>https://www.oschina.net/news/270960/linux-drop-intel-carillo-ranch</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[cprobe —— All-in-One 的探針採集器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:start">cprobe 是一個縫合怪，整合 Prometheus 服務發現的能力以及各類 Exporter 的能力，預期是做一個 All-in-One 的探針採集器。為何有此想法呢？主要是社區裏各類 Exporter 存在以下問題：</p><ul><li>良莠不齊：有的 Exporter 寫的非常棒，有的則並不完善，有些監控類別甚至有多個 Exporter，選擇困難</li><li>寫法各異：Exporter 所用的日誌庫、配置文件管理方式、命令行傳參方式各異</li><li>倚重邊車模式：有些 Exporter 和採集目標之間是一對一的關係，有幾個採集目標就需要部署幾個 Exporter，在 Kubernetes 環境下相對容易管理，在物理機虛擬機環境下管理起來就比較複雜了，而且多個 Exporter 還會帶來資源成本的提升</li><li>配置文件切分：對於非邊車模式的 Exporter，即一個 Exporter 對應多個採集目標的，通常很難做到不同的採集目標不同的配置，期望能有一種配置文件切分 INCLUDE 機制，不同的採集目標採用不同的配置</li><li>缺乏監控目標服務發現：對於支持 /probe 模式的 Exporter，服務發現就通過 Prometheus + relabel 模式來實現了，如果不支持 /probe 模式的 Exporter 則缺乏監控目標的服務發現機制</li></ul><p>要是能有一個統一的採集器把這些能力集成起來，統一規範化設計就好了，cprobe 應運而生。</p><h2 style="text-align:start">對比</h2><p style="color:#1f2328; text-align:start">社區有一些其他採集器，比如 grafana-agent，也是一個縫合怪，也是把各類 Exporter 的能力整合在一起，但是整合的非常生硬，缺少統一化設計，對目標實例的服務發現支持較弱；telegraf 和 categraf 則自成一派，指標體系沒有擁抱 Prometheus exporter 生態，相關儀表盤、告警規則資源匱乏，另外服務發現機製做的也不好。datadog-agent 確實比較完備，但是生態上也是自成一派，服務於自身的 SaaS 服務，較少有開源用户採用。</p><p style="color:#1f2328; text-align:start">以我當前的認知，監控數據的採集大抵需要三個角色，一個是部署在所有的目標機器上的，比如使用 categraf，中心端需要兩個採集器，一個用於採集 Prometheus 協議的端點數據，可以使用 vmagent 或 Prometheus agent mode，另外一個用於採集所有非 Prometheus 協議的端點數據，計劃就是 cprobe。</p><h2 style="text-align:start">當前進展</h2><p style="color:#1f2328; text-align:start">cprobe 剛剛起步，目前主要是在完善基礎框架，框架層面已經達到 GA 的水平，插件已經整合進來了 mysql_exporter、redis_exporter、kafka_exporter、blackbox_exporter。這個時候的代碼是最為簡單清晰的最小功能集，如果大家想要參與，建議閲讀此時的代碼。</p><p style="color:#1f2328; text-align:start">代碼倉庫：<a href="https://github.com/cprobe/cprobe">https://github.com/cprobe/cprobe</a></p><h2 style="text-align:start">安裝</h2><p style="color:#1f2328; text-align:start">到 cprobe 的 releases 頁面<span>&nbsp;</span><a href="https://github.com/cprobe/cprobe/releases">https://github.com/cprobe/cprobe/releases</a><span>&nbsp;</span>下載發佈包。解包之後核心就是那個二進制 cprobe，通過如下命令安裝：</p><div style="text-align:start"><pre>./cprobe --install
./cprobe --start
</pre></div><p style="color:#1f2328; text-align:start">如果是支持 systemd 的 OS，上面的安裝過程實際就是自動創建了 service 文件，你可以通過下面的命令查看：</p><div style="text-align:start"><pre>systemctl status cprobe
</pre></div><p style="color:#1f2328; text-align:start">如果不是 systemd 的 OS，會採用其他進程管理方式，比如 Windows，會創建 cprobe 服務。</p><h2 style="text-align:start">配置</h2><p style="color:#1f2328; text-align:start">解壓縮之後應該可以看到 conf.d 目錄，這是配置文件所在目錄，未來的規劃是 writer.yaml + 一堆插件目錄，當然項目起步階段，所以只有 writer.yaml + mysql，因為只有 mysql 一個插件得到支持。</p><p style="color:#1f2328; text-align:start">writer.yaml 是配置 remote write 地址（不知道什麼是 remote write 地址，請自行 Google：Prometheus remote write），可以配置多個，默認配置如下：</p><div style="text-align:start"><pre><span style="color:var(--color-prettylights-syntax-entity-tag)">global</span>:
  <span style="color:var(--color-prettylights-syntax-entity-tag)">extra_labels</span>:
    <span style="color:var(--color-prettylights-syntax-entity-tag)">colld</span>: <span style="color:var(--color-prettylights-syntax-string)">cprobe</span><span style="color:var(--color-prettylights-syntax-entity-tag)">writers</span>:
- <span style="color:var(--color-prettylights-syntax-entity-tag)">url</span>: <span style="color:var(--color-prettylights-syntax-string)">http://127.0.0.1:9090/api/v1/write</span></pre></div><p style="color:#1f2328; text-align:start">這是一個極簡配置，也基本夠用，實際 writer.yaml 中還可以配置不同時序庫後端的認證信息以及 relabel 的配置，同級目錄下有個 backup.yaml 可以看到一些配置樣例。</p><p style="color:#1f2328; text-align:start">不同的插件的配置會散落在各個插件目錄裏，以 mysql 插件舉例，相關配置在<span>&nbsp;</span><code>conf.d/mysql</code><span>&nbsp;</span>下面，入口文件是 main.yaml，用於定義需要採集的 mysql target，計劃至少提供三種 service discovery 機制：static_configs、http_sd_configs、file_sd_configs，這個配置和 Prometheus 的 scrape 配置基本保持一致。</p><p style="color:#1f2328; text-align:start">在 cprobe 場景下，cprobe 會直連監控目標，比如 mysql 的監控，Prometheus 是從 mysqld_exporter 獲取監控數據，而 cprobe 是直連 mysql，所以 main.yaml 中要配置一些採集規則，即 scrape_rule_files。scrape_rule_files 是個數組，即可以把配置文件切分管理，這提供了極大的管理靈活性，各位自行發揮了。</p><p style="color:#1f2328; text-align:start">mysql 的採集插件 fork 自 mysqld_exporter，所以相關指標體系、儀表盤都可以複用。當然，也做了一些改造，原來 mysqld_exporter 是一套採集規則應用到所有的 target，在 cprobe 這裏，不同的 target 可以採用不同的 scrape_rules，修改了原來通過命令行傳參的機制以支持併發。另外就是擴展了自定義 SQL 能力，通過自定義 SQL 來抓取更多監控指標。更多信息可以參考：<a href="https://github.com/cprobe/cprobe/tree/main/conf.d/mysql/doc">mysql 插件文檔</a>。</p><h2 style="text-align:start">後續規劃</h2><p style="color:#1f2328; text-align:start">最核心的是增加更多插件，不同的插件要整理儀表盤、告警規則。框架層面，希望增加更多自埋點數據，通過 HTTP 的方式暴露更多調試信息。另外就是完善中英文文檔。當然，大家如有建議也歡迎留言給我們。</p></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 14 Dec 2023 02:00:47 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/cprobe</guid>
            <link>https://www.oschina.net/p/cprobe</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 自主開發的網絡協議棧 onps]]>
            </title>
            <description>
                <![CDATA[<h1><a id="onps 網絡協議棧" class="anchor" href="https://gitee.com/Neo-T/open-npstack#onps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88"></a>onps 網絡協議棧</h1><h4><a id="背景" class="anchor" href="https://gitee.com/Neo-T/open-npstack#%E8%83%8C%E6%99%AF"></a>背景</h4><p>大約是 06 年，因項目之需我開始接觸應用於單片機系統的國外開源 tcp/ip 協議棧——LwIP，並藉此順勢創作了我的第一本印成鉛字的書——《嵌入式網絡系統設計——基於 Atmel ARM7 系列》。這本書的反響還不錯，好多人給我發 msn（可惜這麼好的一個即時通訊工具就這麼被微軟放棄了，好多聯繫人就此失聯， <img class="emoji" alt=":persevere:" style="vertical-align: middle" src="https://cn-assets.gitee.com/assets/emoji/persevere-1f8fa05847efd349c0f2c62b1cee5bd1.png" width="14" height="14" referrerpolicy="no-referrer"> ）或郵件諮詢相關問題。在我原來的寫作計劃中，這本書的出版只是一個開始，接下來還要寫第二本——系統介紹 LwIP 包含的 ppp 協議棧的移植、應用及設計實現等相關內容。但，事與願違，這本書跳票了，且這一跳就是十二年……</p><p>細細想來，當初跳票的主因有二：其一，因家庭、工作等致可支配時間太少；其二，缺乏足夠的 ppp 協議相關知識及技術儲備致信心不足，畏首畏尾，裹足不前。但，這件事始終是我的一個遺憾。十二年的時間，不長亦不短，但足夠讓心底的遺憾變成一粒小小的種子並茁壯成長為一棵夢想的參天大樹。</p><p>如今，世界來到了疫情肆虐的二零年代。我的可支配時間多了起來，技術能力亦遠非當年可比。夢想之樹到了開花結果的時候了。遙想當初，入行還沒幾年，技術能力有限，我只能站在大神的肩膀上研究如何移植、使用 LwIP，ppp 棧碰都沒敢碰。現在，如果還只是延續十幾年前的工作，那這件事做起來就無甚意義。基於對自身技術實力的準確認識，我決定自己從零開始搭建一個完整的網絡協議棧。終，歷 6 個月餘，onps 協議棧（onps，open net protocol stack）完成初版開發，並內部測試通過。十餘年的遺憾今日得償。另，從業 20 餘年，內心終有一個做核心基礎軟件的夢。今，這二之夢想亦藉此得償。</p><p>新鶯初啼，總免不了會有諸多不盡如人意的地方。開源，則可與志趣相投者共享、共用、共研，歷諸位嚴苛手段使之快速迭代，快速成熟，比肩 LwIP 可期 <img class="emoji" alt=":blush:" style="vertical-align: middle" src="https://cn-assets.gitee.com/assets/emoji/blush-85d11d8b7459d18f70eab0659c19a266.png" width="14" height="14" referrerpolicy="no-referrer"> 。</p><h4><a id="簡介" class="anchor" href="https://gitee.com/Neo-T/open-npstack#%E7%AE%80%E4%BB%8B"></a>簡介</h4><p>onps 是一個開源且完全自主開發的國產網絡協議棧，適用於資源受限的單片機系統，提供完整地 ethernet/ppp/tcp/ip 協議族實現，同時提供 sntp、dns、ping 等網絡工具，支持以太網環境下 dhcp 動態 ip 地址申請，也支持動態及靜態路由表。協議棧還封裝實現了一個伯克利套接字（Berkeley sockets）層。該層並沒有完全按照 Berkeley sockets 標準設計實現，而是我根據以往 socket 編程經驗，以方便用户使用、簡化用户編碼為設計目標，重新聲明並定義了一組常見 socket 接口函數：</p><ul><li>socket：創建一個 socket，目前僅支持 udp 和 tcp 兩種類型</li><li>close：關閉一個 socket，釋放當前佔用的協議棧資源</li><li>connect：與目標 tcp 服務器建立連接（阻塞型）或綁定一個固定的 udp 服務器地址</li><li>connect_nb：與目標 tcp 服務器建立連接（非阻塞型）</li><li>is_tcp_connected：獲取當前 tcp 鏈路的連接狀態</li><li>send：數據發送函數，tcp 鏈路下為阻塞型</li><li>send_nb：數據發送函數，非阻塞型</li><li>is_tcp_send_ok：數據是否已成功送達 tcp 鏈路的對端（收到 tcp ack 報文）</li><li>sendto：udp 數據發送函數，發送數據到指定目標地址</li><li>recv：數據接收函數，udp/tcp 鏈路通用</li><li>recvfrom：數據接收函數，用於 udp 鏈路，接收數據的同時函數會返回數據源的地址信息</li><li>socket_set_rcv_timeout：設定 recv() 函數接收等待的時長，單位：秒</li><li>bind：綁定一個固定端口、地址</li><li>listen：tcp 服務器進入監聽狀態</li><li>accept：接受一個到達的 tcp 連接請求</li><li>tcpsrv_recv_poll：tcp 服務器專用函數，等待任意一個或多個 tcp 客户端數據到達信號</li><li>socket_get_last_error：獲取 socket 最近一次發生的錯誤信息</li><li>socket_get_last_error_code：獲取 socket 最近一次發生的錯誤編碼</li></ul><p>協議棧簡化了傳統 BSD socket 編程需要的一些繁瑣操作，將一些不必要的操作細節改為底層實現，比如 select/poll 模型、阻塞及非阻塞讀寫操作等。簡化並不意味着推翻，socket 接口函數的基本定義、主要參數、使用方法並沒有改變，你完全可以根據以往經驗及編程習慣快速上手並熟練使用 onps 棧 sockets。 <strong>無須過多關注協議棧底層，利用 socket api 編程即可完全滿足複雜通訊應用的需求，而不像 LwIp 一樣需要使用它自定義的一組接口函數才能達成同樣的目標。</strong></p><p>為了適應單片機系統對內存使用極度變態的苛刻要求，onps 協議棧在設計之初即考慮採用寫時零複製（zero copy）技術。用户層數據在向下層協議傳遞過程中，協議棧採用 buf list 鏈表技術將它們鏈接到一起，直至將其發送出去，均無須任何內存複製操作。另外，協議棧採用 buddy 算法提供安全、可靠的動態內存管理功能，以期最大限度地提高協議棧運行過程中的內存利用率並儘可能地減少內存碎片。</p><p>不同於本世紀 00 到 10 年代初，單片機的應用場景中 ucosii 等 rtos 尚未大規模普及，前後台系統還大行其道的時代，現如今大部分的應用場景下開發人員選擇使用 rtos 已成為主流。因此，協議棧在設計之初即不支持前後台模式，其架構設計建立在時下流行的 rtos（RT-Thread、ucosii/iii 等）之上。協議棧移植的主要工作也就自然是針對不同 rtos 編寫相關 os 適配層功能函數了。當然，如果你有着極其特定的應用場景，需要將 onps 棧移植到採用前後台模式的單片機上，我的建議是保留 tcp/udp 之下協議層的通訊處理邏輯，調整上層的系統架構使其適應目標系統運行模式。</p><h4><a id="軟件架構" class="anchor" href="https://gitee.com/Neo-T/open-npstack#%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"></a>軟件架構</h4><p>onps 棧設計實現了一套完整的 tcp/ip 協議模型。從數據鏈路層到 ip 層，再到 tcp/udp 層以及之上的伯克利 socket 層，最後是用户自己的通訊應用層，onps 棧實現了全棧覆蓋，能夠滿足絕大部分的網絡編程需求。其架構如下：
<img src="https://gitee.com/Neo-T/open-npstack/raw/master/onps%E6%A0%88%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="onps 棧架構" referrerpolicy="no-referrer"></p><p>可以看出，其與傳統的網絡編程模型並沒有什麼不同，用户仍然是繼續利用 socket api 編寫常見的 tcp 及 udp 網絡應用。同時你還可以利用協議棧提供的幾個網絡工具進行網絡校時、dns 查詢等操作。</p><h4><a id="目錄結構" class="anchor" href="https://gitee.com/Neo-T/open-npstack#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"></a>目錄結構</h4><table><thead><tr><th>名稱</th><th>描述</th></tr></thead><tbody><tr><td>bsd</td><td>伯克利 sockets 層的相關接口函數實現源文件</td></tr><tr><td>ethernet</td><td>以太網協議族如 ethernet-ii/arp 及 emac 層、dhcp 客户端等的相關實現源文件</td></tr><tr><td>include</td><td>協議棧的頭文件</td></tr><tr><td>ip</td><td>ip 及其上層 icmp/tcp/udp 協議族的相關實現源文件</td></tr><tr><td>mmu</td><td>協議棧內存管理模塊的相關實現源文件</td></tr><tr><td>net_tools</td><td>網絡工具實現源文件，如 dns 查詢、網絡校時、ping、telnet 等</td></tr><tr><td>netif</td><td>網卡及路由管理等相關接口實現源文件</td></tr><tr><td>port</td><td>協議棧移植相關的源文件</td></tr><tr><td>ppp</td><td>ppp 鏈路層相關實現源文件，包括 lcp/ipcp/chap/pap 等協議族的實現源文件</td></tr><tr><td>TcpServerForStackTesting</td><td>用於協議棧測試的 tcp 服務器，IDE 為 vs2015 開發，目標系統為 win7 及以上</td></tr><tr><td>test_code</td><td>linux 下的 ppp 撥號原理驗證文件</td></tr></tbody></table><h4><a id="移植及使用説明" class="anchor" href="https://gitee.com/Neo-T/open-npstack#%E7%A7%BB%E6%A4%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"></a>移植及使用説明</h4><p>協議棧支持主流的 ARM Cortex 系列 MCU，支持 Keil MDK、IAR 等常見 IDE。移植的核心工作就是完成 RTOS 模擬層的編寫及適配，詳細的移植説明請參考《onps 網絡協議棧移植及使用説明 v1.0》一文，點此<a href="https://gitee.com/Neo-T/open-npstack/releases/download/v1.0.0.221017/onps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%A7%BB%E6%A4%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8Ev1.0.7z">下載</a>。本説明提供了 STM32F103RCT6 及 STM32F407VET6 兩種硬件平台的移植樣例，每種樣例分別針對 RT-Thread 和 ucosii 兩種 RTOS。樣例工程經過了嚴格的內部測試，可以直接使用。</p><p>如果你沒有太多時間，或者樣例工程與你的目標平台並不匹配，你可以直接參考協議棧移植的一般性指導文件<a href="https://gitee.com/Neo-T/open-npstack/raw/master/onps%E6%A0%88%E7%A7%BB%E6%A4%8D%E6%89%8B%E5%86%8C.pdf">《onps 棧移植手冊》</a>。</p><p>協議棧開發的一般性指導文件請參考<a href="https://gitee.com/Neo-T/open-npstack/raw/master/onps%E6%A0%88API%E6%8E%A5%E5%8F%A3%E6%89%8B%E5%86%8C.pdf">《onps 棧 API 接口手冊》</a>及<a href="https://gitee.com/Neo-T/open-npstack/raw/master/onps%E6%A0%88%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.pdf">《onps 棧用户使用手冊》</a>。</p><h4><a id="移植樣例" class="anchor" href="https://gitee.com/Neo-T/open-npstack#%E7%A7%BB%E6%A4%8D%E6%A0%B7%E4%BE%8B"></a>移植樣例</h4><p><strong>STM32F407VET6 平台</strong> ：
<a href="https://gitee.com/Neo-T/onps-rtthread">RT-Thread 移植樣例</a><a href="https://gitee.com/Neo-T/onps-ucosii">ucos-ii 移植樣例</a></p><p><strong><a href="https://gitee.com/Neo-T/Onps-WCH-CH32V307">沁恆 CH32V307 平台</a></strong> ：
<a href="https://gitee.com/Neo-T/Onps-WCH-CH32V307/tree/master/HarmonyOS/LiteOS_m">鴻蒙 LiteOS-M 移植樣例</a><a href="https://gitee.com/Neo-T/Onps-WCH-CH32V307/tree/master/FreeRTOS">Free-rtos 移植樣例</a><a href="https://gitee.com/Neo-T/Onps-WCH-CH32V307/tree/master/rt-thread">RT-Thread 移植樣例</a></p><h4><a id="社區支持" class="anchor" href="https://gitee.com/Neo-T/open-npstack#%E7%A4%BE%E5%8C%BA%E6%94%AF%E6%8C%81"></a>社區支持</h4><p>您可以隨時訪問<a href="https://gitee.com/link?target=http%3A%2F%2Fwww.onps.org.cn"><strong>onps 棧官方網站</strong></a>，獲取協議棧研發進度、後續計劃、最新版本等相關信息。<br>如您在使用過程中遇到任何問題或建議，您可以到 <strong><a href="https://gitee.com/link?target=http%3A%2F%2Fneo.onps.org.cn">onps 棧交流社區</a></strong> 提出您的建議或問題，新版本發佈也會在交流社區第一時間通知。<br>您也可以加入 QQ 羣進行在線技術交流：<br><img src="https://gitee.com/Neo-T/open-npstack/raw/master/onps%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81%E7%BE%A4%E7%BE%A4%E4%BA%8C%E7%BB%B4%E7%A0%81.png" alt="qq 交流羣" referrerpolicy="no-referrer"></p><h4><a id="許可協議" class="anchor" href="https://gitee.com/Neo-T/open-npstack#%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE"></a>許可協議</h4><p>Apache License 2.0 開源許可協議</p><h4><a id="通過 oscs 安全認證" class="anchor" href="https://gitee.com/Neo-T/open-npstack#%E9%80%9A%E8%BF%87oscs%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81"></a>通過 OSCS 安全認證</h4><p><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.murphysec.com%2Faccept%3Fcode%3D64bea0edfe145ac454cc464b23659406%26type%3D1%26from%3D2%26t%3D2"><img src="https://www.murphysec.com/platform3/v3/badge/1615596818625232896.svg?t=1" alt="Security Status" referrerpolicy="no-referrer"></a></p><h4><a id="後續計劃" class="anchor" href="https://gitee.com/Neo-T/open-npstack#%E5%90%8E%E7%BB%AD%E8%AE%A1%E5%88%92"></a>後續計劃</h4><ul><li>更多目標平台的適配工作， 提供相應移植樣例</li><li>重構部分代碼， 進一步降低代碼尺寸及內存消耗</li><li>支持 ftp 客户端/服務器</li><li>支持 http 客户端/服務器</li></ul><h4><a id="捐贈" class="anchor" href="https://gitee.com/Neo-T/open-npstack#%E6%8D%90%E8%B5%A0"></a>捐贈</h4><p>為了項目能夠持續下去，期望得到您的支持，您可以掃描下面的二維碼通過支付寶/微信向本項目捐款：</p><p><img src="https://gitee.com/Neo-T/open-npstack/raw/master/alipayn.jpg" alt="支付寶" referrerpolicy="no-referrer"><img src="https://gitee.com/Neo-T/open-npstack/raw/master/tencentpay.jpg" alt="微信" referrerpolicy="no-referrer"></p>]]>
            </description>
            <pubDate>Thu, 14 Dec 2023 01:51:47 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/Neo-T/open-npstack</guid>
            <link>https://gitee.com/Neo-T/open-npstack</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 深度解讀 Cascades 查詢優化器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>數據庫中查詢優化器是數據庫的核心組件，其決定着 SQL 查詢的性能。Cascades 優化器是 Goetz 在 volcano optimizer generator 的基礎上優化之後誕生的一個搜索框架。</p><p>本期技術貼將帶大家瞭解 Cascades 查詢優化器。首先介紹 SQL 查詢優化器，接着分析查詢優化基本原理，最後對 Cascades 查詢優化器進行重點介紹。</p><span id="OSC_h1_1"></span><h1>一、SQL 查詢優化器</h1><p>用户與數據庫交互時只需要輸入聲明式 SQL 語句，數據庫優化器則負責將用户輸入的 SQL 語句進行各種規則優化，生成最優的執行計劃，並交由執行器執行。優化器對於 SQL 查詢具有十分重要的意義。</p><p>如圖 1 所示，SQL 語句經過語法和詞法解析生成抽象語法樹 (AST)，經過**基於規則的查詢優化（Rule-Based Optimizer）<strong>和</strong>基於代價的查詢優化（Cost-Based Optimizer）**生成可執行計劃。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-2f53e715e5e2dc13da2ae7593b5a622c7a2.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 1</p><ul><li><p><strong>基於規則的優化算法</strong>:&nbsp;基於規則的優化方法的要點在於結構匹配和替換。應用規則的算法一般需要先在關係代數結構上匹配一部分局部的結構，再根據結構的特點進行變換乃至替換操作。</p></li><li><p><strong>基於成本的優化算法</strong>:&nbsp;現階段主流的方法都是基於成本（Cost）估算的方法。給定某一關係代數代表的執行方案，對這一方案的執行成本進行估算，最終選擇估算成本最低的方案。儘管被稱為基於成本的方法，這類算法仍然往往要結合規則進行方案的探索。基於成本的方法其實是通過不斷的應用規則進行變換得到新的執行方案，然後對比方案的成本優劣進行最終選擇。</p></li></ul><span id="OSC_h1_2"></span><h1>二、查詢優化的基本原理</h1><p>優化器一般由三個組件組成：<strong>統計信息收集</strong>、<strong>開銷模型</strong>、<strong>計劃列舉</strong>。</p><p>如圖 2 所示，開銷模型使用收集到的統計信息以及構造的不同開銷公式，估計某個特定查詢計劃的成本，幫助優化器從眾多備選方案中找到開銷最低的計劃。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-74c10d3f0e3e2443c51805fe0a0d7742ec4.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 2</p><p><strong>SQL 語句查詢優化基於關係代數這一模型：</strong></p><ul><li><p>SQL 查詢可以轉化為關係代數；</p></li><li><p>關係代數可以進行局部的等價變換，變換前後返回的結果不變但是執行成本不同；</p></li><li><p>通過尋找執行成本最低的關係代數表示，我們就可以將一個 SQL 查詢優化成更為高效的方案。</p></li></ul><p>尋找執行成本最低的關係代數表示，可以分為<strong>基於動態規劃的自底向上</strong>和<strong>基於 Cascades/Volcano 的自頂向下</strong>兩個流派。</p><ul><li><p><strong>自底向上搜索</strong>：從葉子節點開始計算最低成本，並利用已經計算好的子樹成本計算出母樹的成本，就可以得到最優方案；</p></li><li><p><strong>自頂向下搜索</strong>：先從關係算子樹的頂層開始，以深度優先的方式來向下遍歷，遍歷過程中進行剪枝。</p></li></ul><p>自底向上的優化器從零開始構建最優計劃，這類方法通常採用動態規劃策略進行優化，採用這類方法的優化器包括&nbsp;IBMSystem R。自頂向下的優化策略的優化器包括基於 Volcano 和 Cascades 框架的優化器。</p><span id="OSC_h1_3"></span><h1>三、Cascades 查詢優化器</h1><p>Cascades 查詢優化器採用自頂向下的搜索策略，並在搜索過程中利用 Memo 結構保存搜索的狀態。</p><p><strong>Cascades 關鍵組件構成：</strong></p><ul><li><p><strong>Expression</strong>：Expression 表示一個邏輯算子或物理算子。如 Scan、Join 算子；</p></li><li><p><strong>Group</strong>：表示等價 Expression 的集合，即同一個 Group 中的 Expression 在邏輯上等價。Expression 的每個子節點都是以一個 Group 表示的。一個邏輯算子可能對應多個物理算子，例如一個邏輯算子 Join(a,b)，它對應的物理算子包括{HJ(a, b), HJ(b, a), MJ(a, b), MJ(b, a), NLJ(a, b), NLJ(b, a)}。我們將這些邏輯上等價的物理算子稱為一個 Group（組）。注：HJ 表示 HashJoin 算子，MJ 表示 MergeJoin 算子，NLJ 表示 NestLoopJoin 算子；</p></li><li><p><strong>Memo</strong>：由於 Cascades 框架採用自頂向下的方式進行枚舉，因此，枚舉過程中可能產生大量的重複計劃。為了防止出現重複枚舉，Cascades 框架採用 Memo 數據結構。Memo 採用一個類似樹狀（實際是一個圖狀）的數據結構，它的每個節點對應一個組，每個組的成員通過鏈表組織起來；</p></li><li><p><strong>Transformation Rule</strong>：是作用於 Expression 和 Group 上的等價變化規則，用來擴大優化器搜索空間。</p></li></ul><p>Cascades 首先將整個 Operator Tree 按節點拷貝到一個 Memo 的數據結構中，Memo 由一系列的 Group 構成，每個算子放在一個 Group，對於有子節點的算子來説，將原本對算子的直接引用，變成對 Group 的引用。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-8f15c28ea323e3c6c3812cb4345b2668089.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 3</p><p>如圖 3 所示，生成該語法樹的 Memo 初始結構。Memo 結構中一個圓角框代表一個算子，圓角框右下角是對其 Children’s Groups 的引用，左下角是唯一標識符。生成初始的 Memo 結構後，可以採用 transform rule 進行邏輯等價轉換，規則如下：</p><ul><li><p>對於一個邏輯算子，其所有基於關係代數的等價表達式保存在同一個 Group 內，例如 join(A,B) -&gt; join(B,A)；</p></li><li><p>在一個 Group 內，對於一個邏輯算子，會生成一個或多個物理算子，例如 join -&gt; hash join,merge join，NestLoop join；</p></li><li><p>一個 Group 內，一個算子，其輸入（也可以理解為 subplan）可以來自多個 Group 的表達式。</p></li></ul><p>在圖 4 中，描述了一個部分擴展的 Memo&nbsp;結構，與圖 1 中的初始 Memo 相比，在同一個 Group 內，增加了等價的邏輯算子，以及對應的物理算子。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-be8b645c303e9167ab3ab1936afe751448f.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖 4</p><p>在探索的過程中，優化器就會通過開銷模型 Coster 藉助統計信息來計算子步驟的開銷，遍歷完每個 Memo Group 之後，歸總得到每個完整計劃的總開銷，最終選擇 Memo 中開銷最低的計劃。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-11ec37fc83f5aeeb91f0464308b62d14ecb.png" referrerpolicy="no-referrer"></p><p style="text-align:center">圖&nbsp;5</p><p>圖 5 中有三個 Group，分別對應三個邏輯算子：Join(a, b), GET(a) 和 GET(b)。Group 1（Group 2）中包含了所有對應 GET(a) （GET(b)）的物理算子，我們可以估算每個物理算子的代價，選取其中最優的算子保留下來。</p><p>為了防止枚舉過程出現重複枚舉某個表達式，Memo 結構體中還包含一個哈希表（exprHT），它以表達式為哈希表的鍵，用來快速查找某個表達式是否已經存在於 Memo 結構體中。</p><p>Cascades 採用自頂向下的方式來進行優化，以計劃樹的根節點為輸入，遞歸地優化每個節點或表達式組。如圖所示，整個優化過程從 Group 0 開始，實際上要先遞歸地完成兩個子節點（Group 1 和 Group 2）的優化。</p><p>因此，實際的優化完成次序是 Group 1 -&gt; Group2 -&gt; Group 0。在優化每個 Group 時，依次優化每個組員；在優化每個組員時，依次遞歸地優化每個子節點。依次估算當前組裏每個表達式 e 的代價 cost(e)，選擇最低得代價結果保存在 bestHT 中。優化結束時，查詢 Join(a,b) 對應的 Memo 結構體，獲取最低的執行計劃。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 14 Dec 2023 01:46:47 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5148943/blog/10320570</guid>
            <link>https://my.oschina.net/u/5148943/blog/10320570</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Soul 上線自研語言大模型 SoulX]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>社交平台 Soul 正式上線自研語言大模型 SoulX。作為生成式人工智能最基礎、最核心的工具，SoulX 將作為 Soul 「AIGC+社交」佈局的重要基建，垂直應用於平台上多元社交互動場景，例如智能對話機器人「AI 苟蛋」、AI 輔助聊天、虛擬陪伴等諸多工具和創新功能，進一步豐富平台用户的社交體驗。</p><p>根據介紹，該模型基於海量數據訓練，具備 prompt 驅動、條件可控生成、上下文理解、多模態理解等能力。在保證對話流暢、自然、具備情感温度的同時，SoulX 覆蓋百種細粒度風險類別，通過訓練數據安全篩選、安全 SFT 數據構造、RLHF 安全對齊、推理攔截等策略來構建安全體系，保證了大模型的內容生產質量和安全性。</p><p><img height="444" src="https://oscimg.oschina.net/oscnet/up-83bee0805ad5819554ad5c4bf7d1885d136.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 10:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270889</guid>
            <link>https://www.oschina.net/news/270889</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[MegEngine 正式支持 XLA 啦！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>XLA（Accelerated Linear Algebra）是 Google 提出的一個神經網絡編譯器，可以用於加速 AI 模型的訓練和推理。MegEngine 1.13.1 中也已經支持了 XLA，在訓練模型時可以選擇開啓此項功能，不同的模型可以獲得 10%~80% 不等的速度提升。</p><h2>主要的目標場景</h2><p>MegEngine 現在是動態執行的，即 python 中每一個 mge.functional 的調用都對應着底層 gpu 上的一次 kernel 執行。這種模式的好處在於實際的執行方式與代碼邏輯一致，所見即所得，非常的靈活；不過其問題是難以優化，性能可能不是最優。</p><p>而 XLA 採取靜態執行的方式，會將模型計算過程表達成一張靜態計算圖，稱為 「HLO」 （High-Level Optimized）。HLO 中包含計算圖的相關操作，張量的數據流程和形狀等信息。XLA 隨後會對 HLO 進行一系列的優化，並最終生成一個更優的計算圖，從而更快的完成計算。而 XLA 的侷限性就在於不夠靈活，對於 Tensor Shape 改變或者控制流等信息無法很好的表達。</p><p>現在 MegEngine 中已經支持了 XLA，模型訓練中一些比較靜態的場景，我們可以使用 XLA 來進行加速，從而縮短整個訓練過程的時間。</p><h2>使用方法與效果</h2><p>在使用 MegEngine 進行訓練時，可以通過對原來的訓練函數增加 xla_trace/partial_trace 裝飾器來啓用 XLA 編譯優化。</p><p>當整個模型是完全靜態時，我們可以使用 xla_trace 將整張網絡表達成一張靜態圖，然後交由 XLA 做後續的優化編譯，後續的執行過程將執行這張優化後的計算圖提升速度。</p><p>而如果我們模型中有一些動態性，比如訓練過程中一些 Tensor Shape 會發生變化，亦或者是存在控制流，我們可以使用 partial_trace，將網絡中靜態的部分 trace 成一些子圖並分別交給 XLA 進行編譯優化，而網絡中其他部分仍然保持動態執行，同時保證性能與靈活性。</p><p>下面展示了在 MegEngine 中，XLA 功能開啓前後，主流的神經網絡模型性能變化。其中藍色為 XLA 開啓之前的訓練速度，橙色為 XLA 開啓之後的訓練速度。在開啓 XLA 後，大部分模型的性能可以獲得 10%~40% 的提升，最多可以超過 80%。 <img src="https://data.megengine.org.cn/engine-website/assets/images/38f415d8-9963-11ee-a7f5-8272bed56fd1.png" alt="1.png" referrerpolicy="no-referrer"></p><p>關於 XLA 的更多信息及具體的使用方法可以參考 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.megengine.org.cn%2Fdoc%2Fstable%2Fzh%2Fuser-guide%2Fmodel-development%2Fjit%2Fxla.html" target="_blank">https://www.megengine.org.cn/doc/stable/zh/user-guide/model-development/jit/xla.html</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 10:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5265910/blog/10321024</guid>
            <link>https://my.oschina.net/u/5265910/blog/10321024</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[麟卓發佈多平台軟件安裝包構建系統，支持 Windows 和 Linux]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>北京麟卓<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F9I8Xo7H_LLHPmSy_HMY24A" target="_blank">宣佈推出</a></u>「多平台軟件安裝包構建系統」，用於解決 Windows 和 Linux 系統中傳統軟件封裝、安裝過程繁瑣、平台差異嚴重等諸多問題。</p><p>據介紹，該工具提供「一站式構建、安裝」功能，讓用户能夠輕鬆製作軟件安裝包程序，提升工作效率，簡化軟件封裝、安裝以及卸載流程。</p><blockquote><strong>下載地址：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linzhuotech.com%2FProduct%2FDownLoadWindows" target="_blank">https://www.linzhuotech.com/Product/DownLoadWindows</a></u></em></strong></blockquote><p>「多平台軟件安裝包構建系統」是利用統一交互界面和配置機制生成多平台軟件安裝包的系統，支持在 Windows、Linux 平台上進行目標軟件的多層級模塊化封裝以及安裝功能，主要具備以下優勢：</p><ul><li>軟件安裝便捷：簡化傳統軟件安裝流程中的解壓、拷貝以及配置環境等繁瑣操作。</li><li>人機交互統一：在不同的操作系統平台上，具備統一人機交互，方便用户進行多平台封裝。</li><li>功能操作簡單：具備多層級可選控制、安裝信息配置、自定義安裝腳本、環境配置等豐富功能的同時保證軟件操作簡潔，易學易用。</li></ul><p><img height="779" src="https://oscimg.oschina.net/oscnet/up-346f799048871759324d7ded950e159fa0d.png" width="1280" referrerpolicy="no-referrer"><img src="https://static.oschina.net/uploads/space/2023/1213/174623_Cjur_2720166.png" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-401cdffba4679c3bdb8ae9bb0feea96f222.png" referrerpolicy="no-referrer"></p><ul></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 09:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270878</guid>
            <link>https://www.oschina.net/news/270878</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微軟推出小模型 Phi-2，性能優於 Llama 2/Mistral 7B]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">微軟<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.microsoft.com%2Fen-us%2Fresearch%2Fblog%2Fphi-2-the-surprising-power-of-small-language-models%2F" target="_blank">宣佈</a>推出一個 27 億參數的語言模型 Phi-2，並聲稱其性能可與大 25 倍的模型相匹配或優於。「展示了出色的推理和語言理解能力，展示了參數少於 130 億的基礎語言模型中最先進的性能。」</span></p><p><span style="color:#000000">其基準測試結果表明，只需 27 億個參數，Phi-2 就能在各種綜合基準測試中超越 Mistral 和 Llama-2 模型在 7B 和 13B 參數下的性能。與大 25 倍的 Llama-2-70B 模型相比，Phi-2 在多步推理任務（即編碼和數學）上實現了更好的性能。</span></p><p><span style="color:#000000">此外，Phi-2 的性能與最近發佈的 Google Gemini Nano 2 不相上下，甚至更勝一籌。</span></p><p><img height="179" src="https://oscimg.oschina.net/oscnet/up-195920a0bfb4c87cd5ca00cc5d3edd0c25d.png" width="500" referrerpolicy="no-referrer"></p><p><img height="101" src="https://oscimg.oschina.net/oscnet/up-00457009ea9fb83c5e5802e175d784bd463.png" width="500" referrerpolicy="no-referrer"></p><p>且<span style="background-color:#ffffff; color:#000000">與經過調整的現有開源模型相比，</span><span style="color:#000000">Phi-2 </span><span style="color:#1a202c">響應中的「毒性」和偏差也要更少。</span></p><p><span style="color:#1a202c"><img alt="" height="243" src="https://oscimg.oschina.net/oscnet/up-36ec3b182b6104dcd29d01e7b450d2cb42c.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">此前，谷歌發佈的 Gemini 演示視頻曾展示了其解決複雜物理問題，以及對學生進行糾錯的能力。微軟研究人員也將&nbsp;Phi-2 進行了同樣的測試，並表示它同樣能夠正確回答問題，和使用相同的提示糾錯。</span></p><p><img height="282" src="https://oscimg.oschina.net/oscnet/up-11a57788ae91ebd7277cc00ee2b3ab55339.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Phi-2 是微軟「小語言模型（SLM）」系列中的最新版本。第一個版本是擁有 13 億參數的 Phi-1，針對基本的 Python 編碼任務進行了微調。9 月，該公司將重點擴展到常識推理和語言理解，推出了一個新的 13 億參數模型 Phi-1.5，性能可與大 5 倍的模型相媲美。</span></p><p><span style="color:#000000">微軟表示，Phi-2 的效率使其成為想要探索增強人工智能安全性、可解釋性和語言模型道德發展等領域的研究人員的理想平台。目前，</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fml.azure.com%2Fregistries%2Fazureml-msr%2Fmodels%2Fmicrosoft-phi-2%2Fversion%2F3%3Ftid%3D72f988bf-86f1-41af-91ab-2d7cd011db47%23overview" target="_blank">Phi-2</a><span style="color:#000000"> 現已通過 Microsoft Azure AI Studio 的模型目錄發佈。</span></p><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.microsoft.com%2Fen-us%2Fresearch%2Fblog%2Fphi-2-the-surprising-power-of-small-language-models%2F" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 06:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270831/microsoft-phi-2-small-language-model</guid>
            <link>https://www.oschina.net/news/270831/microsoft-phi-2-small-language-model</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Wi-Fi 7 將於 2024 年初全面登場，速度比 Wi-Fi 6 提升 5 倍]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#262626">WiFi 聯盟<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wi-fi.org%2Fdiscover-wi-fi%2Fwi-fi-certified-7" target="_blank">宣佈</a></u>將在明年 1 月 9 日至 12 日參加 CES 2024，並確認基於 IEEE 802.11be 的 Wi-Fi CERTIFIED 7 認證標準將於第一季度末之前正式推出。</span>與目前的 Wi-Fi 6 標準相比，該標準有望提供千兆位速度和其他改進。</p><p><img src="https://oscimg.oschina.net/oscnet/up-bf8bb1d4062d6abcdd5bde367ecbe4cc108.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0cc0e98c02c1b0b058bc6ac02b0b37ea771.png" referrerpolicy="no-referrer"></p><p>英特爾（Intel）和博通（Broadcom）去年展示的 Wi-Fi 7（也稱 802.11be）速度高達 5 Gbps，大大超過了 Wi-Fi 6 的典型最高速度約 1.7 Gbps。<strong>Wi-Fi 7 允許在 2.4GHz、5GHz 和 6GHz 頻率之間無縫切換</strong>，兼容設備可同時使用這些頻率，從而實現了這一目標。</p><p>此外，6GHz 頻譜可提供 320MHz 的超寬信道，吞吐量比 Wi-Fi 6 翻了一番，這是速度提升的關鍵因素。通過從 1024 QAM 升級到 4K QAM，新標準還將傳輸速率提高了 20%。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-68acdc34185024028d7aabf4f9b688fd47e.png" referrerpolicy="no-referrer"></p><p>Wi-Fi 7 連接也有望比以前的規格更加穩定。多鏈路操作可智能平衡流量，使網絡能有效容納更多設備。聯盟表示，新標準將非常適合增強現實和虛擬現實應用。美國聯邦通信委員會（FCC）最近初步批准了 6GHz 頻譜上的超高速 Wi-Fi 關聯，這是使 VR 和 AR 設備能夠利用 Wi-Fi 7 的重要一步。</p><p>2024 年的推出日期與英特爾 2022 年的預測基本吻合。該公司計劃從明年開始推出支持 Wi-Fi 7 的個人電腦，並於 2025 年在市場上普及。高通公司也對 Wi-Fi 7 持樂觀態度，並將其與 5G 一起納入了 FastConnect 計劃。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 05:55:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270823/wi-fi-certified-7</guid>
            <link>https://www.oschina.net/news/270823/wi-fi-certified-7</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Log4Shell 兩週年，仍有不少項目使用包含漏洞的版本]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Log4Shell 是 Log4j 2.0（Log4J2）的一個 0day 遠程代碼執行漏洞，被定性為「過去十年來最大、最關鍵的漏洞」，最早由阿里巴巴集團於 2021 年 11 月 24 日發現並報告給 Apache 軟件基金會。</p><p>儘管已經過去了兩年，<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.veracode.com%2Fblog%2Fresearch%2Fstate-log4j-vulnerabilities-how-much-did-log4shell-change" target="_blank">但根據安全公司 Veracode 的報告</a></u></strong>，該漏洞的影響仍然存在。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-73861b3642e119baf3ccca3f3a037679b4f.png" referrerpolicy="no-referrer"></p><p>Veracode 分析了 2023 年 8 月 15 日至 11 月 15 日期間 90 天內的軟件掃描數據，針對 3,866 個組織運行 Log4j 版本 1.1 至 3.0.0-alpha1 的 38,278 個獨特應用程序。</p><p>在 Log4j 1.1 到 3.0.0-alpha1 版本中，有超過三分之一的應用程序使用了存在漏洞的 Log4j 版本。具體來説：</p><ul><li>2.8% 的應用程序仍在使用 Log4j2 2.0-beta9 到 2.15.0 之間的版本，這些版本存在 Log4Shell 漏洞。</li><li>另外 3.8% 的應用程序使用的是 Log4j2 2.17.0 版本，雖然該版本已修復了 Log4Shell 漏洞，但仍然存在 CVE-2021-44832 漏洞，這是一個高危的遠程代碼執行漏洞。</li><li>還有 32% 的應用程序使用的是 Log4j2 1.2.x 版本，這個版本在 2015 年 8 月已經停止維護，但在 2022 年 1 月 ASF 宣佈了三個影響該版本的關鍵漏洞。</li></ul><p>這些數據表明，儘管各方對 Log4Shell 漏洞進行了大規模的修復工作，但仍然存在許多應用程序使用了存在漏洞的 Log4j 版本。</p><p>Veracode 的研究還發現，許多開發者在將第三方庫引入到代碼後從未更新過這些庫。這也解釋了為什麼有如此大比例的應用程序在運行已經停止維護的 Log4j 版本。</p><p>此外，研究還發現，一旦開發者通過掃描發現了漏洞，他們通常會相對迅速地進行修復。但是，一些外部因素會拖慢開發人員的修復速度，例如缺乏信息或資源。</p><hr><p>延伸閲讀</p><ul><li><a href="https://www.oschina.net/news/173273/log4j-maintainer-response" target="_blank">Log4j 維護者：為向後兼容沒移除導致漏洞的舊功能</a></li><li><a href="https://www.oschina.net/news/174752/impact-of-apache-log4j" target="_blank">Apache Log4j 漏洞的影響規模</a></li><li><a href="https://www.oschina.net/news/203874/log4j-the-pain-just-keeps-going-and-going" target="_blank">「核彈級」 Log4j 漏洞仍普遍存在，並造成持續影響</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 03:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270803/state-log4j-vulnerabilities-2023</guid>
            <link>https://www.oschina.net/news/270803/state-log4j-vulnerabilities-2023</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Windows 11 記事本的底部狀態欄將顯示「字符數統計」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Windows 11 內置的文本編輯器「記事本」添加了一項重要功能：在底部狀態欄顯示<strong>字符數統計</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-876aae8d39e39c30417766c1912f6ab4e65.png" referrerpolicy="no-referrer"></p><p>該功能會顯示使用者輸入的<strong>字符總數</strong>，包括字母、數字、符號、空格、標點符號等。「字符統計」與「字數統計」不一樣，字數統計僅計算文檔中的單詞總數，有人會覺得它比字符數統計更有用。</p><p>根據微軟的<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ghacks.net%2F2023%2F12%2F08%2Fwindows-11s-notepad-is-getting-a-character-count-on-the-status-bar%2F" target="_blank">公告</a></u>，記事本中的字符數統計有兩種工作方式。默認情況下，文本編輯器將在窗口底部的狀態欄上顯示文檔的字符數。如果使用者在文檔中選擇了文本，記事本將分別顯示所選文本的字符數和文檔的總計數。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270799/windows-11s-notepad-character-count-on-the-status-bar</guid>
            <link>https://www.oschina.net/news/270799/windows-11s-notepad-character-count-on-the-status-bar</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[國產數據庫的出現和消失，都不是技術問題]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><blockquote><p>最近，關於數據庫國產化替代的話題甚是熱門。OSCHINA 開源中國特別邀請了<strong>歐冶雲商股份有限公司數據庫首席薛曉剛</strong>就這一話題發表看法。</p></blockquote><span id="OSC_h2_1"></span><h2><span style="color:#2980b9">為什麼要替代 Oracle?</span></h2><p>去 IOE 的背景，要從阿里巴巴去 IOE 談起，I 是 IBM 小型機大型機，O 是 Oracle 數據庫，E 是 EMC 存儲。這幾個搭配起來使得阿里輕鬆走過了最初的技術發展階段。這個配置組合也是當年這條街最靚的仔。這個穿搭在大型銀行和運營商中也很常見。這種組合的好處是就穩定，而且非常穩定。<strong>缺點可能只有一個，就是貴。</strong></p><p>隨着阿里業務的增加，阿里人考慮繼續這樣使用的成本很高。再加上阿里開始了雲計算的規劃，所以提出了去 IOE 的口號。這個在其他互聯網公司是不可能有的。因為其他互聯網公司一開始就沒有 IOE 所以不需要去。只有阿里一開始的架構是這樣的。所以只有阿里提出了。</p><p>阿里做阿里雲，希望用户上雲。上雲的核心就是數據上雲。數據上雲後存在哪裏？自然是數據庫中，如果用的數據庫是 Oracle 的，那麼可能要分給 Oracle 利潤（要採購許可）。所以阿里打算用 MySQL 以及後來自研替代 Oracle。</p><p>從最開始的去 IOE，直到現在還經常看到各種大會上提到去 O，這用了十幾年，去掉了 I 和 E。有些企業完成了去 O，而有些企業還在使用 O。</p><p><strong>那麼為什麼只提去 O，那不用去 DB2 和 SQLServer 嗎？本質上也要去的。</strong>只是其他的數據庫不如 Oracle 的使用廣泛，例如現在使用和維護 DB2 的人是很少了。之所以沒人提去 DB2，是因為從總體來説 DB2，已經被去掉了。所以狹義去 O 是去掉 Oracle 數據庫，而廣義的去 O 其實可以擴大為去 M（美國化）。</p><p>在今天不少人觀點認為用 MySQL 去替代 Oracle 是無意義的。因為 MySQL 和 Oracle 同屬於甲骨文公司。甚至在有的場閤中還會提到要去掉 MySQL。</p><span id="OSC_h2_2"></span><h2><span style="color:#2980b9">當前數據庫國產化進程情況如何?</span></h2><p>當前在信創和安可這些趨勢下，國產數據庫如雨後春筍般出現。在國內某權威數據庫排行榜上，已經有 280 多個數據庫了。實際上的數字可能比這個還要多一點。</p><p>在一些政府、金融、運營商行業都有一些國產化替換。這些替換其實不僅僅是數據庫了，還包括服務器、CPU、操作系統等等。從宣傳上看有些是全棧替換，有些是部分替換。也還有一些公司或者企業沒有替換。然而這些都是國產廠商的宣傳，至於實際的替換情況只有用户自己知道。而即使替換的用户也沒有進行相關的宣傳，這就使得整個情況非常的模糊。不過這個過程還在繼續，還是會有一些系統從 Oracle、DB2、SQLServer 等數據庫切換到國產化上來的。只是現在不確定因素太多了。</p><p>今年年初，TiDB、TDengine、TDSQL、OceanBase 四位數據庫界掌門人在一場直播中大致達成一致，三年後在中國健康運營的數據庫不超過 20 家。所謂健康運營是，企業能有正常營收，員工發薪正常。目前國產數據庫有 280 多個產品，有的一個公司有幾個產品。即使這樣也是有絕大部分產品或者公司會因為無法盈利而退出舞台。用户現在也意識到了這一點，也在等情況明朗後再去選擇。沒有企業願意看到花了很大代價切換的數據庫無人維護了，不得不繼續再次替換。</p><p>國產數據庫有完全自研的，例如達夢、OceanBase 等，也有一些是基於 MySQL 做改造的，還有一些事基於 PostgreSQL 改造的，還有購買外國源碼然後進行修改的。</p><span id="OSC_h2_3"></span><h2><span style="color:#2980b9">替代 Oracle 的難點在哪裏?</span></h2><p>技術上，Oracle 確實領先，在數據庫領域是一個標杆一樣的存在。即使我們國產數據庫的頭部企業都認為自己和 Oracle 有較大的差距，作為學習者不斷地在向 Oracle 學習。</p><p>Oracle 領先的其實不僅僅是技術，還有設計理念和前瞻性。2020 年信通院發佈的白皮書中寫了數據庫的未來幾大趨勢，而在那時候這幾個趨勢當時 Oracle 已經部分實現和深度實現了。其實 Oracle 產品線很多，不僅僅是數據庫。其中間件、硬件、操作系統等等是全方面的輸出。</p><p><strong>具體到幾個方面：</strong></p><p><strong>兼容性</strong><strong>。</strong>對於替換國產數據庫，兼容性是一件繞不開的話題，特別是對於存量系統來説，大多數重要系統是運行在 Oracle 數據庫上的，那麼對於 Oracle 的<strong>基本</strong><strong>SQL</strong><strong>語法、</strong><strong>PL</strong><strong>/SQL、存儲過程、觸發器等</strong>的兼容性肯定是十分重要的，畢竟這涉及代碼變更的問題。如果在國產數據庫替換過程中出現業務適配新數據庫代碼變更量太大、數據庫功能缺失需要業務側代碼補充、適配分佈式數據庫過程中對數據庫設計和業務邏輯變更等現象的話，開發層面對國產數據庫的牴觸會非常大。</p><p><strong>性能。</strong>性能和硬件以及優化器都有很大的關係。優化器這方面目前沒有能超過 Oracle 優化器的。因為這些底層都是數學算法。2021 年信通院發佈的數據庫發展白皮書顯示，我國數據庫企業針對數據庫領域的平均專利數量（含國內外專利）為 38 個，最高為 500 個左右規模，數量為 0 的企業個數是 19 個，佔比 24%。擁有專利數 0-4 個的企業佔比最高為 51%，專利數 5-10 個的企業次之，佔比 14%，專利數 21-50 個的企業數量排名第三，佔比 12%。從企業專利數量上看，Oracle 以 1.4 萬個全球領先，SAP 居次席。</p><p><strong>穩定性。</strong>Oracle 的穩定性還是毋庸置疑的，這也就是為什麼在過去那麼多年中，其一直佔據着領導地位，以及使用如此廣泛。企業負責人都不希望看到自己的數據庫經常出問題，每次數據庫的問題都可能導致故障，從而影響到在線業務。不僅僅要面對直接和間接的經濟損失，還有問責的壓力。</p><p>Oracle 等國外數據庫有足夠的全球市場，專心在技術上投入做數據庫，而國產數據庫廠商只能在國內有限的數據庫市場內卷，需要投入大量的內卷、惡性競爭和關係處理上，無法專心把全部精力放在做數據庫上。甚至還是為瞭如何生存而謀劃。</p><p>國產數據庫的出現並不是技術問題，而是其他因素。</p><p>數據庫領域的人都知道，在信創活動結束之後就沒有替換動力了。而最終國內市場無法容得下幾百家供應商，所以大部分國產數據庫的消失也不是技術問題。</p><span id="OSC_h2_4"></span><h2><span style="color:#2980b9"><strong>有哪些能夠替代 Oracle 的國產數據庫？</strong></span></h2><p>這個替代要講清楚是怎麼替代？如果説就是把系統關停，然後把數據導過來，然後再修改數據庫的連接字符串就可以和之前一樣正常使用而且穩定的。目前沒見過也沒聽説過。</p><p>如果説換了一個國產數據庫，然後把鏈接這個數據庫的所有業務系統的軟件代碼進行修改（這個修改可能是 30-100%），即軟件重寫適配數據庫或者部分需求和功能放棄，那麼這樣的替換還是有一些的。OceanBase、TiDB、TDSQL 等都有在不同程度上有，具體的都是應實際情況而定。</p><p>這些替換的優勢，可能在於滿足了政治要求。</p><p><strong>這些替換的劣勢，有多方面：</strong></p><p>由於同等硬件下不如 Oracle 的性能，所以增加硬件導致成本的上升。或者分佈式數據庫的硬件就是比集中式硬件的多導致的硬件成本上升。</p><p>由於數據庫特性和功能的缺失，所以應用程序需要改造的成本上升。這部分可能佔替換總成本的 60%-80%。因為這是調動大量應用開發人員重寫適配的過程。</p><p>由於穩定性上不如 Oracle，所以需要增加大量運維人員，導致運維的成本上升。</p><p>由於部分國產數據庫需要許可才可以運行，所以增加了大量的許可費用。相比較之前很少採購 Oracle 許可或者甚至不採購許可來説，這部分採購費用佔比很大。</p><p>以上這些成本可能會是使用 Oracle 數據庫的數倍甚至幾十倍甚至上百倍。而很多計算中都忽略了第二和第三項的成本。</p><span id="OSC_h2_5"></span><h2><span style="color:#2980b9">現有國產數據庫跟 Oracle 相比，有多大的差距?</span></h2><p>從技術上來説，我們和 Oracle 相比有代差。</p><p>可能不同的人有不同的見解。我個人感覺有以下多方面的差距（但是不限於此）：</p><p><strong>數據庫的</strong><strong>優化器</strong><strong>上：</strong>有人説為什麼 Oracle 快，你可能不知道多少滿頭白髮的數學教授在那裏研究着這些。有人説：你別逼我，逼急了我什麼都做的出來。」 「是嗎？，那你把這道數學題給做做？」 人被逼急了還真不是什麼都做的出來，起碼數學就不是。各種複雜查詢的核心是優化器和統計信息。而這全部都是數學問題。沒有在數學上的基礎投入是無法在這個領域攻堅克難的。</p><p><strong>體系架構上：</strong>如今越來越多的國產數據庫考慮 RAC 架構。在經歷了互聯網的分佈式數據庫的洗禮後，越來越多的用户覺得集中式更加適合自己。所以才有了各種國產數據庫廠商開始實現 RAC 的計劃，達夢、優炫等。即使分佈式數據庫廠商在研發過程中發現 Oracle 的各種體系設計，沒有一個是多餘的，都是設計極其精妙的。而這些很多設計都是 30 年前甚至更早就已經設計到位的。</p><p><strong>與</strong><strong>操作系統</strong><strong>的融合上：</strong>數據庫是運行在操作系統之上的，如何與 CPU 打交道？SQL 調用指令集的多少都是有講究的。甚至有些操作是繞過操作系統直接操作的。這些都是需要深耕操作系統才能解決的。</p><p><strong>與硬件的融合上：</strong>數據庫必然要和存儲設備打交道。數據庫的優化幾乎等同於 IO 優化。所以 Oracle 直接做出來自己的存儲。這些存儲上都是帶有 CPU 的，更好的存儲和讀取數據上發揮了很大的作用。做數據庫是從上至下的深入解決。</p><p><strong>趨勢把握上：</strong>數據庫的多模和超融合這些都是 Oracle 在引領着數據庫技術的前進方向。我們定義為趨勢的，Oracle 基本都是已經實現的。而很多理念從設計到實現需要 8-10 年的過程。</p><span id="OSC_h2_6"></span><h2><span style="color:#2980b9"><strong>國產數據庫未來要怎麼走?</strong></span></h2><p>我個人角度認為，應該靜下心來踏實的做技術。</p><p>最好是沒有政治因素的幹擾去市場上競爭，避免大躍進式的百家齊放，而是規範市場，讓國內外數據庫廠商同台競爭。用户結合自己的預算進行抉擇，是選擇廉價的還是性價比高的，讓一切迴歸到技術本身來。而不能用政策限制其他產品進入，只能強制使用國產。這樣會導致自我封閉和外部的排斥。既然我們用政策限制其他人，那麼對等的就會出現別人限制我們。從而更加無法走出去。</p><p>如果真正能走出去，在國外用得起來，那麼就是國產數據庫的成功。中國的高鐵就是因為走出去了才成為了中國的一張名片。</p><blockquote><p><strong>作者簡介：</strong></p><p>薛曉剛，現任歐冶雲商股份有限公司數據庫首席。曾服務於政府、公安、交通、安防行業，從事過大型項目管理，設計和運維多個單表 100 億，單機 100TB 的數據庫。目前負責高可用、業務連續性和高併發數據架構設計和運維管理。</p><p>Oracle ACE-Pro（Oracle 和 MySQL 方向），Oracle OCP/MySQL OCP 及 OCP 講師。PostgreSQL 的 PGCE 和 PCP 認證，PostgreSQL ACE Partner。墨天輪 MVP，TiDB MVA，ITPUB 論壇內存數據庫版主、核心專家、金牌顧問，墨天輪社區特聘金牌講師，機械工業出版社專家委員會委員。</p><p><img height="483" src="https://oscimg.oschina.net/oscnet/up-db67ea17186e0146cd30e998dbd09b31b55.png" width="500" referrerpolicy="no-referrer"></p><p><strong>聯繫作者：</strong></p><p><img height="249" src="https://oscimg.oschina.net/oscnet/up-783ed80bb94f3f8e33fb256e9e56a3413e6.png" width="500" referrerpolicy="no-referrer"></p></blockquote><p>&nbsp;</p></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 03:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/3859945/blog/10321019</guid>
            <link>https://my.oschina.net/u/3859945/blog/10321019</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[FFmpeg CLI 支持多線程 —— 數十年來「最複雜的重構」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>FFmpeg CLI 近日迎來重大改進 —— 合併了<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fffmpeg.org%2Fpipermail%2Fffmpeg-devel%2F2023-November%2F316552.html" target="_blank">多線程轉碼管道</a></u>&nbsp;</strong>(multi-threaded transcoding pipelines)，預計在明年發佈的&nbsp;FFmpeg 7.0 中提供。</p><p><img src="https://oscimg.oschina.net/oscnet/up-69e8f13ce3a5ed36727e8f9c13a6d4cf9a0.png" referrerpolicy="no-referrer"></p><p>來源：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fffmpeg.org%2Findex.html%23cli_threading" target="_blank">https://ffmpeg.org/index.html#cli_threading</a></em></u></p><p>其開發團隊表示，這項工作是「數十年來 FFmpeg CLI 最複雜的重構之一」，主要內容包括添加了線程感知的轉碼調度基礎設施、將編碼任務移動到獨立線程，以及各種其他底層更改。這意味着 FFmpeg 現在可以實現並行處理任務，這將提高吞吐量和 CPU 利用率，降低延遲。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0f082465774090329fe668d4160939f9c33.png" referrerpolicy="no-referrer"></p><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fup.khirnov.net%2F7m.pdf" target="_blank">https://up.khirnov.net/7m.pdf</a></u></em></p><p>據介紹，這次更新並不是針對編解碼器本身進行多線程處理，因為現代編解碼器通常已經支持多線程處理。相反，FFmpeg 決定並行化的是 ffmpeg 本身，包括過濾器等。這意味着 FFmpeg CLI 現在可以更高效地處理視頻轉碼任務。</p><p>Hacker News 上有開發者提出了一些關於視頻編碼的<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D38613219" target="_blank">想法</a></u>，例如將關鍵幀分段獨立處理，以實現更好的多核性能。這種方法可以在一定程度上提高編碼效率，但也需要考慮內存和編碼邏輯的複雜性。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:29:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270790/ffmpeg-cli-multi-threading-merged</guid>
            <link>https://www.oschina.net/news/270790/ffmpeg-cli-multi-threading-merged</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[HyperDX —— 開發者友好的 Datadog 替代品]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>HyperDX&nbsp;是<span style="background-color:#ffffff; color:#1f2328">一個</span>基於雲的生產監控和調試工具<span style="background-color:#ffffff; color:#1f2328">，統一會話重放、日誌、指標、跟蹤和錯誤。</span>通過將日誌、指標、跟蹤、異常和會話重播集中並關聯到一處，幫助工程師更快地找出生產中斷的原因。Datadog 和 New Relic 的開源且開發人員友好的替代方案。</p><ul><li>端到端關聯，只需點擊幾下即可從瀏覽器會話重放到日誌和跟蹤</li><li>由 Clickhouse 提供支持的極快性能</li><li>直觀的全文搜索和屬性搜索語法（例如<code>level:err</code>）</li><li>自動對數十億個事件中的事件模式進行聚類</li><li>儀錶板高基數事件，無需複雜的查詢語言</li><li>只需點擊幾下即可設置警報</li><li>自動解析 JSON/結構化日誌</li><li>OpenTelemetry native</li></ul><p><img height="702" src="https://static.oschina.net/uploads/space/2023/0920/163847_4VuB_4252687.png" width="1220" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/hyperdx</guid>
            <link>https://www.oschina.net/p/hyperdx</link>
        </item>
        <item>
            <title>
                <![CDATA[小米迴應餘承東「龍骨轉軸」抄襲華為言論]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>「小米公司發言人」官方微博近日發佈聲明，就餘承東所述「龍骨轉軸」抄襲華為言論做出澄清稱：</p><blockquote><p>近日，餘承東先生無端針對我司龍骨轉軸技術發佈不實言論，與事實嚴重不符。我們請餘承東先生遵循「科學與嚴謹」的基本規則，請勿再抹黑同行、誤導公眾。</p></blockquote><p>聲明指出，無論是設計思路還是機械結構，小米自研的龍骨轉軸與餘承東所宣稱的所謂雙旋水滴較鏈都完全不同。</p><p>且龍骨轉軸於 2020 年 9 月 18 日申請專利，並於 2021 年 1 月 5 日獲得專利授權，在 2023 年 8 月於 XiaomiMIXFold 了上首發應用。雙旋水滴較鏈則於 2019 年 12 月 13 日申請的專利，2021 年 6 月 18 日才公開。「由此可知，餘承東先生的言論，完全不符合事實。」</p><p><img alt="" height="1349" src="https://oscimg.oschina.net/oscnet/up-31b05e591ed808bedd4150f1214bc51f38d.jpg" width="500" referrerpolicy="no-referrer"></p><p>專利圖：</p><p><img alt="" height="368" src="https://static.oschina.net/uploads/space/2023/1213/100457_fh3o_4252687.jpg" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270776</guid>
            <link>https://www.oschina.net/news/270776</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 物聯網智能網關係統，物聯大師]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-物聯大師" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E7%89%A9%E8%81%94%E5%A4%A7%E5%B8%88"></a>物聯大師</h1><p><strong>注意，[V3.0]版本與<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Ftree%2Fv2">V2.0</a>
和<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Ftree%2Fv1">V1.0</a>有較大差異，不可以直接升級！！！</strong></p><h3><a id="user-content-説明文檔--演示 demo-賬號密碼-admin-123456" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3--%E6%BC%94%E7%A4%BAdemo-%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81-admin-123456"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fiot-master.com%2Fmanual">説明文檔</a><a href="https://gitee.com/link?target=http%3A%2F%2Fdemo.iot-master.com%3A8080%2F">演示 demo</a> 賬號密碼 admin 123456</h3><p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Factions%2Fworkflows%2Fgo.yml"><img src="https://github.com/zgwit/iot-master/actions/workflows/go.yml/badge.svg" alt="Go" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Factions%2Fworkflows%2Fcodeql-analysis.yml"><img src="https://github.com/zgwit/iot-master/actions/workflows/codeql-analysis.yml/badge.svg" alt="Go" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fcodecov.io%2Fgh%2Fzgwit%2Fiot-master"><img src="https://codecov.io/gh/zgwit/iot-master/branch/main/graph/badge.svg?token=AK5TD8KQ5C" alt="codecov" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fpkg.go.dev%2Fgithub.com%2Fzgwit%2Fiot-master"><img src="https://pkg.go.dev/badge/github.com/zgwit/iot-master.svg" alt="Go Reference" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgoreportcard.com%2Freport%2Fgithub.com%2Fzgwit%2Fiot-master"><img src="https://goreportcard.com/badge/github.com/zgwit/iot-master" alt="Go Report Card" referrerpolicy="no-referrer"></a></p><p>物聯大師是<a href="https://gitee.com/link?target=https%3A%2F%2Flabs.zgwit.com">無錫真格智能科技有限公司</a>
推出的開源且免費的物聯網操作系統，內置 MQTT、TCP Server/Client、UDP Server/Client、串口等接入服務，
系統集成標準 Modbus，水務（SL651、SZY206），電力（DL/T645、IEC101、102、103、104、61850）以及一些主流 PLC 協議，
系統可以通過插件支持數據採集、公式計算、定時控制、異常報警、自動控制策略、流量監控、遠程調試、Web 組態等功能，
適用於大部分物聯網或工業互聯網應用場景。
系統採用 Golang 編程實現，支持多種操作系統和 CPU 架構，可以運行在智能網關上，也可以安裝在現場的電腦或工控機上，還能部署到雲端服務器。</p><p>項目摒棄複雜的平台架構思維，遠離微服務，從真實需求出發，注重用户體驗，做到簡捷而不簡單，真正解決物聯網缺乏靈魂的問題。</p><p>我們的宗旨是：<strong>讓物聯網實施變成一件簡單的事情!!!</strong></p><h2><a id="user-content-項目的優勢" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BC%98%E5%8A%BF"></a>項目的優勢</h2><ul><li>開源免費，商業應用也不限制</li><li>單一程序文件，不需要配置運行環境，不依賴第三方服務，放服務器上就能跑</li><li>極小內存佔用，對於一百節點以內的物聯網項目，只需要幾十兆內存足夠了，<del>比起隔壁 Java 動輒大幾百兆內存簡直太省了</del></li><li>支持工控機和智能網關，邊緣計算也沒問題</li><li>支持大屏展示，Web 組態，3D 數據孿生 <del>畢竟很多物聯網項目都是面子工程</del></li><li>在線產品庫、模板庫、組件庫，小白也能分分鐘搞得有模有樣【還在努力建設中】</li></ul><h2><a id="user-content-項目示例" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E9%A1%B9%E7%9B%AE%E7%A4%BA%E4%BE%8B"></a>項目示例</h2><p><img src="https://iot-master.com/web1.jpg" alt="web" referrerpolicy="no-referrer"><img src="https://iot-master.com/hmi-editor.png" alt="scada" referrerpolicy="no-referrer"></p><h2><a id="user-content-諮詢服務" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E5%92%A8%E8%AF%A2%E6%9C%8D%E5%8A%A1"></a>諮詢服務</h2><p><strong>本公司目前提供免費的物聯網方案諮詢服務，結合我們十多年的行業經驗，給您提供最好的建議，請聯繫 15161515197（微信同號）</strong></p><blockquote><p>PS. 提供此服務的主要目的是讓用户少走彎路，為物聯網行業的健康發展盡綿薄之力。
總結一下常見的彎路：</p><ol><li>前期使用某個物聯網雲平台，後期沒辦法繼續，二次開發受限</li><li>花了幾千元買了工業網關，用着一百元 DTU 的功能</li><li>找多個外包公司，低價拿單，結果做出屎一樣的東西</li><li>盲目使用開源項目，最終被開源項目所累</li><li>硬件選型失敗，效果差強人意</li><li>自身技術人員能力有限，架構設計有問題</li><li>不支持高併發量，市場爆發了，平台反而跟不上</li><li>等等</li></ol></blockquote><h2><a id="user-content-聯繫方式" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F"></a>聯繫方式</h2><ul><li>郵箱：<a href="mailto:jason@zgwit.com">jason@zgwit.com</a></li><li>手機：<a>15161515197</a>(微信同號)</li></ul><table><thead><tr><th>技術交流羣</th><th>微信</th></tr></thead><tbody><tr><td><img src="https://iot-master.com/tech.png" alt="微信羣" referrerpolicy="no-referrer"></td><td><img src="https://iot-master.com/jason.jpg" alt="微信" referrerpolicy="no-referrer"></td></tr></tbody></table><h2><a id="user-content-開源協議" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE"></a>開源協議</h2><p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Fblob%2Fmain%2FLICENSE">GPL v3</a></p><p>補充：任何組織或個人都可以免費使用或做二次開發，但不得用於商業售賣，如有需求請聯繫我們。</p><h3><a id="user-content-官方插件" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E5%AE%98%E6%96%B9%E6%8F%92%E4%BB%B6"></a>官方插件</h3><p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Forgs%2Fiot-master-contrib%2Frepositories">插件庫</a></p><table><thead><tr><th>插件</th><th>完成</th><th>正式版</th></tr></thead><tbody><tr><td>歷史統計【內置】</td><td>✅</td><td>⬜</td></tr><tr><td>異常報警【內置】</td><td>✅</td><td>⬜</td></tr><tr><td>Influxdb 時序數據庫</td><td>✅</td><td>⬜</td></tr><tr><td>Modbus 通訊協議</td><td>✅</td><td>⬜</td></tr><tr><td>WebRTC 接入攝像頭</td><td>✅</td><td>⬜</td></tr><tr><td>Web 組態</td><td>✅</td><td>⬜</td></tr><tr><td>3D 數據孿生</td><td>⬜</td><td>⬜</td></tr><tr><td>阿里雲通知</td><td>✅</td><td>⬜</td></tr><tr><td>DLT645-2007，電力規約</td><td>⬜</td><td>⬜</td></tr><tr><td>西門子 PLC，S7 系統，PPI，MPI，FetchWrite</td><td>✅</td><td>⬜</td></tr><tr><td>三菱 PLC</td><td>✅</td><td>⬜</td></tr><tr><td>歐姆龍 PLC，Hostlink，Fins</td><td>✅</td><td>⬜</td></tr><tr><td>TDEngine</td><td>⬜</td><td>⬜</td></tr><tr><td>OpenTSDB</td><td>⬜</td><td>⬜</td></tr><tr><td>流式計算</td><td>⬜</td><td>⬜</td></tr><tr><td>報表引擎</td><td>⬜</td><td>⬜</td></tr></tbody></table>]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 01:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/zgwit_labs/iot-master</guid>
            <link>https://gitee.com/zgwit_labs/iot-master</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 雙十一彈性能力支撐 - ECI 穩定性建設]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h3_1"></span><h3>一、關於 ECI</h3><p style="text-align:justify">背景從 2018 年正式發佈，<strong>ECI 已經打磨了整整 4 個年頭</strong>，如今也已經快速成長為了阿里雲 serverless 容器的基礎設施，服務着阿里內外眾多的公有云客户與雲產品，每天承接着數百萬的彈性容器創建。</p><p style="text-align:justify">然而，ECI 這些年卻未參與到集團雙十一大促，雙十一可以説是阿里技術人的閲兵，能不能承接住雙十一的流量成為了檢驗一個產品是否穩定可靠的重要標準。但一切都是水到渠成，就在今年，ASI 開始與 ECI 對接，嘗試讓 ECI 承接雙十一大促的彈性的 30W 核算力，我們都知道雙十一大促對於整個阿里集團的意義，使命將至，我們必將全身心地投入到對接、壓測、護航的工作中。經過長達兩個多月的業務適配、壓測、備戰，最終完成了雙十一大促的彈性容器的圓滿交付。這背後，離不開 ASI、ECI 以及參與到其中的每一位腳踏實地、用心鑽研、保駕護航的同學的努力。ECI 今年首次作為集團大促彈性基礎設施，根據線上數據統計，大促期間 ECI 彈性資源使用共計約 400W 核，從資源的瞬時彈性、保有規模、系統穩定性等多方面對雲原生系統都是一次巨大的考驗。作為底層的計算單元，ECI 此次也成功頂住了雙十一彈性流量洪峯的考驗，在感嘆 serverless、容器這些技術發展迅猛的同時，對於全新的系統架構穩定性的考驗也不小。</p><p style="text-align:justify">如今再回過頭來看 ECI 的第一次雙十一，我們有必要做一次全面的總結，我們為集團彈性保障做了哪些工作，哪些是將來可以複用的工作，哪些是可以給其他的團隊作為借鑑的技術和經驗，以及哪些地方還可以做的更好，為下一次大促做準備。</p><p style="text-align:justify">本文我們將為大家介紹，<strong>ECI 這些年在穩定性方面做了哪些工作，以及是如何來為集團雙十一保駕護航的。</strong></p><span id="OSC_h3_2"></span><h3>二、遇到的挑戰</h3><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-484afd33bc5b8c5f4774ab7fddf53a98_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">大規模併發帶來的穩定性挑戰遇到的最大挑戰首先是大規模併發帶來的。容器保有量增多之後，從容器實例生產方面來看對於雲管控系統是不小的考驗，尤其是對於彈性場景來講，需要在極短的時間進行實例的生產，鏡像的大規模拉取，進而保障容器的成功啓動。</p><p style="text-align:justify"><strong>如何能保障實例的大規模成功生產</strong>，如何先於線上發現問題，以及即使出現了問題如何第一時間止血並進行故障恢復，這對於集團雙十一期間的業務重保都是尤為重要的。除此之外，對於公有云環境來講，不能影響到其他的公有云客户也是需要重點關注的，因此需要具備一套完整的穩定性保障體系以及故障應對方案以確保雙十一期間的業務能夠順利進行。實例生產系統穩定性 ECI 和 ECS 共用一套資源調度系統，相對於 ECS 容忍度為分鐘級別的應用來講，ECI 實例頻繁的創建刪除對調度系統的要求更為苛刻，對系統容量以及穩定性保障方面提了更高的要求。服務可用性保障 ECI 安全沙箱由於某種原因異常（OOM/物理機宕機/kernel panic），導致不健康情況。這種情況下，k8s 層面如果不從 endpoint 上摘除這個 ECI Pod，會導致請求通過負載均衡依然可以路由到這台不健康的 ECI 上，會導致業務請求成功率下降，因此對於集團業務服務可用性保障也是尤為重要的。</p><span id="OSC_h3_3"></span><h3>三、ECI 穩定性技術建設</h3><p style="text-align:justify">穩定性保障從需求收集準備階段開始，雙十一大促持續兩個月之久，為了配合集團全鏈路驗收，ECI 自身的穩定性保障工作也隨之緊鑼密鼓地進行。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-353460c616617e11f187c76359272f10_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">穩定性的保障貫穿了整個大促過程，大促前慎重/減少系統變更以排除人為因素的幹擾，敬畏發佈，多次壓測演預案確保系統穩定性，不斷提升系統抵抗力穩定性和系統恢復力穩定性，以保障大促的順利進行，最後通過問題覆盤沉澱出可複製的大客户重保策略，這對於未經過雙十一實戰演練具有積極的意義。</p><p style="text-align:justify">因此我們梳理出了整個大促期間圍繞穩定性方面做的主要工作，主要包括風險控制、關鍵業務依賴梳理、技術保障、壓測預案、運行時保障、故障運維能力、以及最後的覆盤優化，希望以此能對今後的大促工作作為指導，並沉澱出穩定性治理的經驗。接下來我們對此次大促涉及到的主要穩定性保障方法以及如何應用進行介紹。</p><p style="text-align:justify">實例生產保障 VM 複用技術實例生產行為的保障是集團彈性使用 ECI 的重中之重。一個典型的實例生產過程如圖所示，<strong>ECS 和 ECI 在控制面共用一套管控系統，</strong>ECI 管控側調用資源調度系統之後會分配計算資源之後會調用 pync（阿里雲單機管控組件），進而調用 avs(阿里雲單機網絡組件) 和 tdc(阿里雲單機存儲組件) 分別生產網卡與磁盤。在此過程中，對於調用 ECS 依賴的 open api 接口較重，在大規模創建刪除場景很快成為系統瓶頸，此前我們專門針對容器實例高頻創建刪除場景開發了 VM 複用功能，對於高頻場景刪除容器實例的場景，延遲 vm 的回收，並複用容器實例的網卡、鏡像、計算資源，降低對管控系統整體的衝擊，以此來保障實例生產系統的穩定性，從此次雙十一的實戰演練效果來看，vm 複用取得了很好的效果，管控系統容量整體處於正常水位，保障了集團雙十一實例穩定的彈性能力。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-dcd697c3f23312c91e09c0272f34fbd8_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">重調度機制對於庫存不足或者遠程服務調用超時等情況，為了保障實例生產的最終一致性，對於 ECI 實例生產我們設計了相應的故障處理策略策略，取值如下：fail-back：失敗自動恢復。即 Pod 創建失敗後自動嘗試重新創建 fail-over：失敗轉移。效果等同於 fail-backfail-fast：快速失敗。即 Pod 創建失敗後直接報錯故障處理策略本質上是一種重調度的策略。原生的 k8s 調度支持重調度，即調度失敗後會將 pod 重新放入調度隊列等待下次調度，類比 k8s 的重調度行為，當 eci 管控系統收到創建請求的時候，首先會進入一個隊列，然後有個異步定時任務會將創建從隊列中撈起，提交到異步工作流進行實際的資源生產、以及容器的啓動等。即便是結合了多可用區和多規格的優化，異步工作流依然有可能失敗的，比如資源的爭搶、內網 ip 不足、啓動失敗等，這時候就需要將創建請求再次重回隊列，等待被重新調度生產。</p><p style="text-align:justify">我們目前對於<strong>故障處理策略</strong>：</p><p style="text-align:justify">1、失敗的任務會一直重試，但是我們會計算每個任務的執行週期，重試次數越多，執行週期越長，以達到退避效果。</p><p style="text-align:justify">2、優先級策略會考慮用户級別、任務類型、任務上次失敗的原因等因素，優先級高的任務優先提交執行。</p><p style="text-align:justify">3、每次調度失敗的原因都會以標準事件的方式通知到 k8s 集羣。隊列裏的任務的整個執行流程的狀態機如下：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-e09200aea1a82cf515617f061a7bb54a_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">所有執行失敗的任務都會重新進入隊列，等待被再次調度。由於任務會在任何一步失敗，所以所有生產出來的資源都會回滾，回滾結束後，進入初始狀態。初始狀態的任務會被拉起執行，然後提交到異步生產。如果生產失敗，就會再次回到等待調度的狀態。如果生產成功，任務就結束，到達終態。基於我們的重調度機制，可以極大的減少由於生產系統抖動造成實例生產失敗的情況，對於容器啓動成功率要求高的場景可以保障實例生產的最終一致性，對於容器啓動成功率要求不那麼嚴格的場景可以快速失敗，由上層業務進行處理。</p><p style="text-align:justify">服務容錯降級對於故障場景，系統依賴服務的降級也是十分重要的。大多數進行限流降級的方案主要關注點在服務的穩定性，當調用鏈路中某個資源依賴出現異常，例如，表現為 timeout，異常比例升高的時候，則對這個資源的調用進行限制，並讓請求快速失敗或返回預設靜態值，避免影響到其它的資源，最終產生雪崩的效果。ECI 目前實現了基於歷史日誌自學習進行無損降級、本地 cache 降級、流控降級 3 級降級機制框架，ECS/ECI openapi 全面接入，內部依賴 200+接口接入，根據每個接口的調用頻率、RT 分佈、超時時間設置來單獨分析，選擇合適的降級策略，設置合理的閥值，能讓系統出問題時，智能降級從而進行系統保護。<strong>一個典型的降級機制實現過程如圖：</strong></p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-1239ddaa0f4eab60e7996e6fec9fe364_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>當有非資源類核心 API 新請求進入</strong>，如果歷史緩存數據未過期則直接返回緩存數據，結束業務邏輯反之則請求遠程接口。如果請求成功，返回數據，對數據進行緩存，同時將緩存數據以日誌方式存入 sls cache log 日誌用於未來降級，結束業務邏輯當遠程請求失敗時觸發降級策略：如果失敗指標（例如指定時間內異常比例）在預設時間窗口內未達到配置的降級策略閾值，則直接拋出相應業務異常，結束業務邏輯如達到降級策略閾值則按以下順序實行降級策略：從 sls 緩存日誌查找歷史日誌數據作為降級返回值，同時將返回值重新寫入緩存，結束業務邏輯如果 sls 緩存日誌沒有相應日誌則返回：預設靜態值或空值，結束業務邏輯對於一些跟用户資源無關，更新少，屬於全局參數的服務/接口，以上通用降級策略和方案可能因為降級規則閾值難以界定而無法有效執行。</p><p style="text-align:justify">針對這些接口採用 dubbo 異常直接降級的策略涉及到降級或熔斷的條件：自動降級 (可選利用 Sentinal 進行自動降級)： 超時，異常，限流手動開關支持核心非資源 api 直接進行 openapi 本地降級 cache 對於嚴重的系統故障，可以將核心幾個 describe api 進行 openapi 本地 cache，發生故障，或有雪崩出現時，全部切到 openapi 本地 cache，在降級影響面的同時，也能減輕對下層服務的調用壓力來贏取恢復時間。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-0ce94b0355dad7e7cbc7463c70e8ad87_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">依賴服務非創建鏈路 dubbo 或 http 請求進行本地 moc 對於幾乎不會頻繁變化的依賴服務，通過每日 sls 分析進行 kv 的存儲，當故障發生時，降級為備用，讓降級影響面趨向於 0。其他服務降級機制大分頁流控 cache 創建類 api 進行依賴 dubbo 或 http 服務降級，<strong>異步補償操作類 api 進行鏈路降級，</strong>取消非必需依賴數據庫降級 ro 庫流量降級隔離，用户級別流量切到灰度 api 級別流量切到灰度/獨立線程池日誌 debug 及調用鏈路跟蹤使用 apicontext 實現詳細日誌 debug 及調用全鏈路跟蹤能力核心 api debug 日誌建設，支持按用户開啓 debug 日誌打印 requestId 貫穿到 dao，支持隨時採樣，及時發現 dao 異常調用服務依賴降級容錯機制可以在保障服務穩定性的前提上，利用相關接口的歷史緩存數據，基於 SLS 日誌無損降級，當 SLS 無數據的時候也可以採用本地靜態數據兜底，構建有效返回值，在服務觸發流控降級熔斷後，大部分用户不會感知到服務異常。</p><p style="text-align:justify">在內部的多次故障演練中，服務降級機制可以有效保護系統由於發生故障帶來的系統癱瘓。服務可用性保障在傳統的 Kubernetes 集羣中，如果 Node 變得不可用且達到時間閾值，那麼會將 Node 上的 Pod 進行驅逐，重新在其他 Node 上拉起新的 Pod。而在 Serverless 場景下，ECI 管控會通過異步檢測機制檢測不健康 ECI，修改狀態為不可用，同時增加導致不可用的事件，告知 ECI 用户，之後 ECI 會通過主動運維的手段治癒不健康 ECI，之後觸發控制面將 ECI 恢復為 Ready 狀態，<strong>主要過程如圖所示：</strong></p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-790b2ccc925edb4964dede90b43256af_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>處理不健康 ECI 的流程：</strong></p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-4e6eaa3bddc8488957271e480923d34a_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>恢復 Ready ECI 流程預案&amp;壓測除了技術方面的保障，故障注入、應急預案、壓測演練在穩定性建設中也尤為重要。</strong>在雙十一活動期間我們內部進行了多次壓測演練，對系統中常見的性能瓶頸進行故障注入，用以模擬故障的發生，同時制定應急預案，以此應對故障已經發生時的場景。通過多次的壓測摸高，一方面可以評估系統容量的承載上限，另一方面可以藉此機會進行大規模壓測演練，驗證系統降級方案並對系統穩定性進行評估。預警&amp;監控大促進行時，預警和監控是保證系統運行時穩定性的重要措施。通過監控和預警可以及時發現系統故障，進而快速進行恢復。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-bfb30f596763e9976d35e307e15d74a2_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-c27bfedd2fd094067dc495bbdab8340a_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h3_4"></span><h3>四、系統的健壯性</h3><p style="text-align:justify">思考沉澱一個健壯的系統不僅需要減少問題的發生，同時要具備故障發現以及故障快速恢復的能力。除了預警和監控，運維能力建設也十分重要。</p><p style="text-align:justify"><strong>一個系統的健壯性體現在系統的容量，</strong>系統的容錯能力以及系統依賴的各個資源的 sla，尤其是在雲上覆雜的資源環境下，由於「木桶效應」，某一項依賴資源的很可能造成整個系統的直接不可用。因此，隨着系統不斷完善，我們需要通過混沌工程等方法來找出當前系統的「弱點」進而對其進行專項優化，進而提升整個系統的健壯性；其二對於系統的故障恢復以及降級能力也很重要，歷史上 ECS/ECI 管控多次由於單用户或系統某個環節變慢，導致系統全鏈路雪崩，最終導致 P1P2 故障，ECS/ECI 管控是阿里雲最複雜的管控系統，複雜的業務邏輯，內部系統依賴，非常多的環節出問題都有可能導致全鏈路某個應用雪崩進而全局不可用，因此，對於故障已經來臨時，依賴降級能力能非常有效的保護我們的系統，這也是穩定性建設的一個十分重要的方向。</p><span id="OSC_h3_5"></span><h3>五、總結</h3><p style="text-align:justify">未來展望隨着雙十一最後一波流量高峯結束，ECI 順利通過了對阿里人最嚴苛的技術考驗--雙十一，本文圍繞此次參與雙十一活動的經歷做出總結，希望可以為今後 ECI 穩定性方面的建設積累經驗，當然，這對 ECI 來説也僅僅是一步試金石，作為雲原生時代的基礎設施，ECI 任重而道遠，共勉！</p><p style="text-align:justify">本文出品及鳴謝： 柳密、羽雲、景奇、存誠、 煜楓、景止、皓瑜、月懸、佐井、尚哲、湧泉、十刀、 木名、秉辰、易觀、冬島、不物、瀟洛、 懷歡、 嘗君、寒亭、伯琰。</p><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1389034%3Futm_content%3Dg_1000385342" target="_blank">原文鏈接</a></strong></p><p style="text-align:justify"><strong>本文為阿里雲原創內容，未經允許不得轉載。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 01:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10319647</guid>
            <link>https://my.oschina.net/yunqi/blog/10319647</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[AutoMQ 社區雙週精選第二期（11.20-12.01）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>本期概要</h2><p>在開源的第二個雙週裏，作為一個成長中的開源項目，AutoMQ 做了很多的優化和重構，以下是相關重點動態的總結。<br> AutoMQ Kafka：寫鏈路耗時優化、快慢讀隔離、Spot 實例強制回收容災。<br> AutoMQ RocketMQ：歷史數據冷讀優化、LogCache 讀寫耗時優化、發佈 v0.0.3-alpha 版本、發佈 Helm Chart、發佈文檔站。</p><h2>AutoMQ Kafka 精選動態</h2><h3>寫鏈路耗時優化</h3><p>原來所有的寫入和回調都會放到一個單線程線程池去進行處理來確保數據安全，該方式存在線程上下文切換通信、單線程處理排隊兩個問題。本次優化將寫入流程中的數據結構改造成線程併發安全模式，使得不同 stream 之間可以併發進行寫入，AutoMQ Kafka 客户端平均寫入耗時<strong>下降 0.3ms</strong>。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F728" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/728</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F729" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/729</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F743" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/743</a></p><h3>快慢讀隔離</h3><p>隔離從 Cache 讀取的快讀和從 S3 的讀取的慢讀，避免慢讀佔滿快讀的線程池影響快讀。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-kafka%2Fpull%2F472" target="_blank">https://github.com/AutoMQ/automq-for-kafka/pull/472</a></p><p><strong>Spot 實例強制回收容災</strong></p><p>在上期精選中提及進度的 Spot 實例強制回收容災已經完成。Spot（競價實例）相比按需實例可以便宜至多 90 %，但問題是它可能不經通知就強制回收。該特性支持 Spot 實例強制回收的情況下，仍舊可以將數據卷掛載到存活的機器，進行<strong>秒級容災恢復</strong>。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-kafka%2Fissues%2F447" target="_blank">https://github.com/AutoMQ/automq-for-kafka/issues/447</a></p><h2>AutoMQ RocketMQ 精選動態</h2><h3>Stream 模塊性能優化</h3><h4>歷史數據冷讀優化</h4><p>歷史數據追趕讀優化，Fetch 請求（50MB &amp; 50 stream）冷讀穿透到 S3 場景，單次 Fetch 耗時從 4s 優化到 100ms。即使是完全穿透冷讀，S3 讀取吞吐效率也是很高的。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F766" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/766</a></p><h4>LogCache 讀寫耗時優化</h4><p>增加上次 Cache 讀取位點記錄，避免每次從 LogCache 讀取數據都需要二分查找定位，10W 個消息下 10W 次查詢時間從 71s 優化到 86ms。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F731" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/731</a> 通過讀寫鎖，將 LogCache 升級成線程併發安全的數據結構，提升 LogCache 讀取併發效率。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F701" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/701</a></p><h3>發佈 v0.0.3-alpha 版本</h3><p>這個版本包含了以下功能和優化： 1）穩定性與性能提升：修復了潛在的 OOM 問題以及提升 stream 模塊性能，詳見 Changelog：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fcompare%2Fv0.0.2-alpha...v0.0.3-alpha" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/compare/v0.0.2-alpha...v0.0.3-alpha</a> 2）工程化建設：引入 Nightly build 和&nbsp;E2E test CI <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhub.docker.com%2Fr%2Fautomqinc%2Fautomq-for-rocketmq%2Ftags" target="_blank">https://hub.docker.com/r/automqinc/automq-for-rocketmq/tags</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Factions%2Fworkflows%2Fbuild-ci.yml" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/actions/workflows/build-ci.yml</a> 3）可觀測性提升：為 stream 模塊引入 Metrics；為 Proxy、Store 模塊引入 Trace <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F766" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/766</a></p><h3>發佈 Helm Chart</h3><p>現在可以使用 Helm Chart 快速在 Kubernetes 中創建 AutoMQ RocketMQ 集羣。</p><pre><code class="language-cs">$ helm repo add automq https://charts.automq.com
$ helm search repo automq                                                                                                                                                            
NAME                            CHART VERSION   APP VERSION     DESCRIPTION                                                                                                           
automq/automq-for-rocketmq      0.0.4           v0.0.3-alpha    A Helm chart for automq-for-rocketmq
</code></pre><p>部署該 Chart 會創建一個 AutoMQ RocketMQ Broker 以及依賴的 MySQL 與 Minio 組件。後續會陸續加入可選的可觀測性依賴組件。</p><h3>發佈文檔站</h3><p>介紹了 AutoMQ RocketMQ 基本使用方式，包含：本地構建、使用 docker compose 部署、在 Kubernetes 上部署。以及使用 CLI 運維集羣模式，管理 Topic 等資源。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.automq.com%2Fzh%2Fdocs%2Fautomq-rocketmq%2FRmuXwhb5Xi9zjCkrInRcCz0UnTe" target="_blank">https://docs.automq.com/zh/docs/automq-rocketmq/RmuXwhb5Xi9zjCkrInRcCz0UnTe</a></p><h2>More Things</h2><p>與小紅書的同學共創對象存儲跨地域容災方案 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-kafka%2Fissues%2F477" target="_blank">https://github.com/AutoMQ/automq-for-kafka/issues/477</a></p><p>以上是第二期《雙週精選》的內容，歡迎關注我們的公眾號，我們會定期更新 AutoMQ 社區的進展。同時，也誠邀各位開源愛好者持續關注我們社區，跟我們一起構建雲原生消息中間件！</p><p><strong>END</strong></p><h3>關於我們</h3><p>AutoMQ 是一家專業的消息隊列和流存儲軟件服務供應商。AutoMQ 開源的 AutoMQ Kafka 和 AutoMQ RocketMQ 基於雲對 Apache Kafka、Apache RocketMQ 消息引擎進行重新設計與實現，在充分利用雲上的競價實例、對象存儲等服務的基礎上，兑現了雲設施的規模化紅利，帶來了下一代更穩定、高效的消息引擎。此外，AutoMQ 推出的 RocketMQ Copilot 專家系統也重新定義了 RocketMQ 消息運維的新範式，賦能消息運維人員更好的管理消息集羣。&nbsp;</p><p>🌟&nbsp;GitHub 地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ" target="_blank">https://github.com/AutoMQ</a></p><p>💻&nbsp;官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.automq.com" target="_blank">https://www.automq.com</a></p><p>👀&nbsp;B 站：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspace.bilibili.com%2F3546572478482870" target="_blank">AutoMQ 官方賬號</a></p><p>🔍&nbsp;視頻號：AutoMQ&nbsp;</p><p><strong>👉 掃二維碼</strong>加入我們的社區羣</p><p><img src="https://oscimg.oschina.net/oscnet/up-c4c6b2be9441c750e268dd2d48294131af7.png" alt="" referrerpolicy="no-referrer"></p><p>關注我們，一起學習更多雲原生乾貨</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 01:46:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6990971/blog/10320900</guid>
            <link>https://my.oschina.net/u/6990971/blog/10320900</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[雲原生週刊：Kubernetes v1.29 新特性一覽]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>開源項目推薦</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwerf%2Fkubedog" title="kubedog" target="_blank">kubedog</a></h3><p>Kubedog 是一個用於在 CI/CD 部署管道中監視和跟蹤 Kubernetes 資源的庫。</p><p>這個庫被用於 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwerf%2Fwerf" title="werf CI/CD" target="_blank">werf CI/CD</a> 工具中，在部署過程中跟蹤資源。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frunwhen-contrib%2Frunwhen-local" title="RunWhen Local" target="_blank">RunWhen Local</a></h3><p>runwhen-local 是一個工具，用於在本地環境中運行 runwhen 腳本。runwhen 是一個靈活的任務調度工具，可以根據條件和時間表來執行任務。通過 runwhen-local，開發者可以在本地測試和調試 runwhen 腳本，以確保其正確運行。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubewharf%2Fkubegateway" title="KubeGateway" target="_blank">KubeGateway</a></h3><p>kube-gateway 是字節跳動內部管理海量 kubernetes 集羣的最佳實踐。 它是為 kube-apiserver 的 HTTP2 流量專門設計並定製的七層負載均衡代理。 目標是為海量的大規模 kubernetes 集羣（千級 node 以上）提供靈活的穩定的流量治理方案。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fflannel-io%2Fflannel" title="flannel" target="_blank">flannel</a></h3><p>Flannel 是為 Kubernetes 設計的一種簡單且易於配置的第三層網絡結構的解決方案。</p><h2>文章推薦</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmoelove.info%2F2023%2F12%2F10%2FKubernetes-v1.29-%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7%25E4%25B8%2580%25E8%25A7%2588%2F" target="_blank">Kubernetes v1.29 新特性一覽</a></h3><p>這篇文章介紹了 Kubernetes v1.29 版本的新特性。該版本包含了 49 個主要的更新，其中有 19 個增強功能進入 Alpha 階段，19 個升級到 Beta 階段，還有 11 個升級到穩定版。</p><p>文章重點介紹了兩個重要的特性：基於 CEL 的 CRD 規則校驗和為動態和靜態分配預留 NodePort 端口範圍。基於 CEL 的 CRD 規則校驗是一種在 CRD 聲明中編寫校驗規則的方式，簡化了開發和維護成本。而為動態和靜態分配預留 NodePort 端口範圍的特性解決了在創建 NodePort 時可能產生的端口衝突問題。總體而言，Kubernetes v1.29 版本的新特性為用户提供了更好的功能擴展和更可靠的輸入校驗。</p><h3>[Kubernetes：Pod 和 WorkerNodes – 控制 Pod 在節點上的放置</h3><p>](<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frtfm.co.ua%2Fen%2Fkubernetes-pods-and-workernodes-control-the-placement-of-the-pods-on-the-nodes%2F" target="_blank">https://rtfm.co.ua/en/kubernetes-pods-and-workernodes-control-the-placement-of-the-pods-on-the-nodes/</a>)</p><p>這篇文章介紹了在 Kubernetes 中如何控制 Pods 在 WorkerNodes 上的部署位置。它提供了四種主要的方法來實現這種控制：</p><ul><li>配置節點</li><li>Taints 和 Tolerations</li><li>配置 Pod 本身</li><li>Pod 親和性和反親和性</li></ul><p>此外，文章還提到了 Pod 拓撲分佈約束（Pod Topology Spread Constraints），即根據失敗域（regions、可用區或節點）的規則來放置 Pod。</p><p>文章還提供了一些使用 kubectl explain 命令來查看相關參數和資源文檔的技巧。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmedium.com%2F%40geoffrey.muselli%2Fargocd-multi-tenancy-strategy-94d72183c94" title="ArgoCD：多租户策略" target="_blank">ArgoCD：多租户策略</a></h3><p>這篇文章介紹了使用 ArgoCD 實現多租户策略的方法。在使用 ArgoCD 時，通常會允許所有用户自由操作，直到進入生產環境後才意識到某個人通過刪除應用程序而刪除了命名空間或 CRD。為瞭解決這個問題，需要使用訪問控制和多租户策略。文章詳細介紹瞭如何利用 ArgoCD 的原生功能實現多租户策略，並提供了一個示例來演示如何在大型組織中使用企業敏捷框架（例如 SAFe）來實施。文章還討論了 ArgoCD 中的 AppProject、RBAC 和命名空間等概念，以及如何配置和使用它們來實現多租户策略。最後，文章提供了一個具體的示例，展示瞭如何根據團隊和項目的需求來配置 AppProject 和 RBAC。</p><h2>雲原生動態</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io%2Fblog%2F2023%2F12%2F05%2Fkyverno-completes-third-party-security-audit%2F" title="Kyverno 完成第三方安全審計" target="_blank">Kyverno 完成第三方安全審計</a></h3><p>Kyverno 項目宣佈完成了第三方安全審計。該審計是由 Ada Logics 與 Kyverno 維護人員、開源技術改進基金合作進行，由 CNCF 資助。</p><p>該安全審計是一個全面的安全審計，有以下四個目標：</p><ul><li>為 Kyverno 定義一個正式的威脅模型。</li><li>對代碼進行手動安全漏洞審計。</li><li>根據威脅模型評估 Kyverno 的模糊測試套件。</li><li>針對 SLSA 評估 Kyverno 的供應鏈風險。</li></ul><blockquote><p>本文由博客一文多發平台 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenwrite.cn%3Ffrom%3Darticle_bottom" target="_blank">OpenWrite</a> 發佈！</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 11:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4197945/blog/10320847</guid>
            <link>https://my.oschina.net/u/4197945/blog/10320847</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[.NET 8 極致性能優化 - Reflection（反射）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><strong><span style="color:#3c70c6">前言</span></strong></span></h1><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>反射一直是性能的瓶頸，所以無論哪個.NET 版本反射的優化必然少不了。主要是集中在兩個方面優化，分配和緩存。.NET8 自然也不例外。本篇看下。</span></p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">原文:<u><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5NDYwNjU4MA%3D%3D%26mid%3D2247485722%26idx%3D1%26sn%3Da126d8687afbc4b980533ec7fd239026%26chksm%3Dc01c4481f76bcd97a92c031859b0327a4460f7b4c73dad11cb0f45fa9c283954e5c95f442eec%26token%3D322944710%26lang%3Dzh_CN%23rd" rel="nofollow" target="_blank">.NET8 極致性能優化 Reflection</a></strong></u></p><span id="OSC_h1_2"></span><h1><span><strong><span style="color:#3c70c6">概述</span></strong></span></h1><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>比如針對 GetCustomAttributes 通過反射獲取屬性的優化，以下例子</span></p><pre><code><span><em>// dotnet run -c Release -f net7.0 --filter "*" --runtimes net7.0 net8.0</em></span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">Tests</span></span></code><code><span>{</span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">object</span>[] <span style="color:#dd1144">GetCustomAttributes</span>()</span> =&gt; <span style="color:#ca7d37">typeof</span>(C).GetCustomAttributes(<span style="color:#ca7d37">typeof</span>(MyAttribute), inherit: <span style="color:#0e9ce5">true</span>);</span></code><code><span>    [<span style="color:#afafaf">My(Value1 = 1, Value2 = 2)</span>]</span></code><code><span><span style="color:#ca7d37">class</span><span style="color:#dd1144">C</span> { }</span></code><code><span>    [<span style="color:#afafaf">AttributeUsage(AttributeTargets.All)</span>]</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">MyAttribute</span> : <span style="color:#dd1144">Attribute</span></span></code><code><span>    {</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">int</span> Value1 { <span style="color:#ca7d37">get</span>; <span style="color:#ca7d37">set</span>; }</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">int</span> Value2 { <span style="color:#ca7d37">get</span>; <span style="color:#ca7d37">set</span>; }</span></code><code><span>    }</span></code><code><span>}</span></code></pre><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>.NET7 和.NET8 明顯的差異，它主要是優化了</span><span>避免分配一個 object[1]數組來設置屬性的值</span></p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,BlinkMacSystemFont,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:17px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:676.989px; word-spacing:0px"><tbody><tr><th>方法</th><th>運行時</th><th>平均值</th><th>比率</th><th>分配</th><th>分配比率</th></tr></tbody><tbody><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">GetCustomAttributes</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1,287.1 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">296 B</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">GetCustomAttributes</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">994.0 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.77</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">232 B</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.78</td></tr></tbody></table><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">其它的比如減少反射堆棧中的分配，比如通過更自由的 spans。改進了 Type 上的泛型處理，從而提升各種與泛型相關的成員性能，比如 GetGenericTypeDefinition，它的結果現在被緩存在了 Type 對象上​​​​​​​</p><pre><code><span><em>// dotnet run -c Release -f net7.0 --filter "*" --runtimes net7.0 net8.0</em></span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">Tests</span></span></code><code><span>{</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span> Type _type = <span style="color:#ca7d37">typeof</span>(List&lt;<span style="color:#ca7d37">int</span>&gt;);</span></code><code><span>&nbsp;&nbsp;&nbsp;&nbsp;<span><span style="color:#ca7d37">public</span>&nbsp;Type&nbsp;<span style="color:#dd1144">GetGenericTypeDefinition</span>()</span>&nbsp;=&gt;&nbsp;_type.GetGenericTypeDefinition();</span></code><code><span>}</span></code></pre><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>.NET7 和.NET8 如下</span></p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,BlinkMacSystemFont,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:17px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:676.989px; word-spacing:0px"><tbody><tr><th>方法</th><th>運行時</th><th>平均值</th><th>比</th></tr></tbody><tbody><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">GetGenericTypeDefinition</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">47.426 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">GetGenericTypeDefinition</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">3.289 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.07</td></tr></tbody></table><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span><span style="background-color:#ffffff">這</span>些<span style="background-color:#ffffff">都是細枝末節，影響反射性能最大的一塊是 MethodBase.Invoke。</span><span style="background-color:#ffffff">當在編譯的時候，知道方法的簽名並且通過反射來調用方法。</span><span style="background-color:#ffffff">就可以通過使用</span></span><span style="background-color:#ffffff">CreateDelegate</span><span>來獲取和緩存該方法的委託，然後通過該委託執行所有的調用。從而實現性</span><span>能最佳化，但是如果在編譯的時候你不知道</span><span>方法的簽名，則需要依賴動態的方法。比如 MethodBase.Invoke，這個方法降低性能並且更耗</span><span>時。一些比較瞭解.NET 開</span><span>發的人員會用 emit 避免這種開銷。.NET7 裏面採用這種方式。.NET8 裏面，為許多這樣的情況進行了改進，以前，emitter 總是生成可以容納 ref/out 參數的代碼，但許多方法不提供這樣的參數，當不需要考慮這些因素時，生成的代碼可以更高效。</span>​​​​​​​</p><pre><code><span><em>// If you have .NET 6 installed, you can update the csproj to include a net6.0 in the target frameworks, and then run:</em></span></code><code><span><em>//     dotnet run -c Release -f net6.0 --filter "*" --runtimes net6.0 net7.0 net8.0</em></span></code><code><span><em>// Otherwise, you can run:</em></span></code><code><span><em>//     dotnet run -c Release -f net7.0 --filter "*" --runtimes net7.0 net8.0</em></span></code><code><span><span style="color:#ca7d37">using</span> BenchmarkDotNet.Attributes;</span></code><code><span><span style="color:#ca7d37">using</span> BenchmarkDotNet.Running;</span></code><code><span><span style="color:#ca7d37">using</span> System.Reflection;</span></code><code><span>BenchmarkSwitcher.FromAssembly(<span style="color:#ca7d37">typeof</span>(Tests).Assembly).Run(args);</span></code><code><span>[<span style="color:#afafaf">HideColumns(<span>"Error"</span>, <span>"StdDev"</span>, <span>"Median"</span>, <span>"RatioSD"</span>)</span>]</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">Tests</span></span></code><code><span>{</span></code><code><span><span style="color:#ca7d37">private</span> MethodInfo _method0, _method1, _method2, _method3;</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span>[] _args1 = <span style="color:#ca7d37">new</span><span style="color:#ca7d37">object</span>[] { <span style="color:#0e9ce5">1</span> };</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span>[] _args2 = <span style="color:#ca7d37">new</span><span style="color:#ca7d37">object</span>[] { <span style="color:#0e9ce5">2</span>, <span style="color:#0e9ce5">3</span> };</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span>[] _args3 = <span style="color:#ca7d37">new</span><span style="color:#ca7d37">object</span>[] { <span style="color:#0e9ce5">4</span>, <span style="color:#0e9ce5">5</span>, <span style="color:#0e9ce5">6</span> };</span></code><code><span>    [<span style="color:#afafaf">GlobalSetup</span>]</span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Setup</span>()</span></span></code><code><span>    {</span></code><code><span>        _method0 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod0"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>        _method1 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod1"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>        _method2 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod2"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>        _method3 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod3"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>    }</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>] <span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Method0</span>()</span> =&gt; _method0.Invoke(<span style="color:#0e9ce5">null</span>, <span style="color:#0e9ce5">null</span>);</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>] <span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Method1</span>()</span> =&gt; _method1.Invoke(<span style="color:#0e9ce5">null</span>, _args1);</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>] <span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Method2</span>()</span> =&gt; _method2.Invoke(<span style="color:#0e9ce5">null</span>, _args2);</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>] <span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Method3</span>()</span> =&gt; _method3.Invoke(<span style="color:#0e9ce5">null</span>, _args3);</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod0</span>()</span> { }</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod1</span>(<span><span style="color:#ca7d37">int</span> arg1</span>)</span> { }</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod2</span>(<span><span style="color:#ca7d37">int</span> arg1, <span style="color:#ca7d37">int</span> arg2</span>)</span> { }</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod3</span>(<span><span style="color:#ca7d37">int</span> arg1, <span style="color:#ca7d37">int</span> arg2, <span style="color:#ca7d37">int</span> arg3</span>)</span> { }</span></code><code><span>}</span></code></pre><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>.NET6 以及 7 和 8 的情況分別如下：</span></p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,BlinkMacSystemFont,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:17px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:676.989px; word-spacing:0px"><tbody><tr><th>方法</th><th>運行時</th><th>平均值</th><th>比率</th></tr></tbody><tbody><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 6.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">91.457 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">7.205 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.08</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">5.719 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.06</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method1</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 6.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">132.832 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method1</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">26.151 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.20</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method1</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">21.602 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.16</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method2</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 6.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">172.224 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method2</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">37.937 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.22</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method2</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">26.951 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.16</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method3</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 6.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">211.247 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method3</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">42.988 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.20</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method3</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">34.112 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.16</td></tr></tbody></table><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">這裏有一些問題，每次調用都會涉及到一些性能開銷，每次調用都會重複。如果我們可以提取這些重複性的工作，對它們進行緩存。就可以實現更好的性能。.NET8 裏面通過 MethodInvoker 和 ConstructorInvoker 類型中實現了這些功能。這些並沒有包含所有 MethodBase.Invoke 處理的不常見錯誤（如特別識別和處理 Type.Missing），但對於其他所有情況，它為優化在構建時未知簽名的方法的重複調用提供了一個很好的解決方案。​​​​​​​</p><pre><code><span><em>// dotnet run -c Release -f net8.0 --filter "*"</em></span></code><code><span><span style="color:#ca7d37">using</span> BenchmarkDotNet.Attributes;</span></code><code><span><span style="color:#ca7d37">using</span> BenchmarkDotNet.Running;</span></code><code><span><span style="color:#ca7d37">using</span> System.Reflection;</span></code><code><span>BenchmarkSwitcher.FromAssembly(<span style="color:#ca7d37">typeof</span>(Tests).Assembly).Run(args);</span></code><code><span>[<span style="color:#afafaf">HideColumns(<span>"Error"</span>, <span>"StdDev"</span>, <span>"Median"</span>, <span>"RatioSD"</span>)</span>]</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">Tests</span></span></code><code><span>{</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span> _arg0 = <span style="color:#0e9ce5">4</span>, _arg1 = <span style="color:#0e9ce5">5</span>, _arg2 = <span style="color:#0e9ce5">6</span>;</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span>[] _args3 = <span style="color:#ca7d37">new</span><span style="color:#ca7d37">object</span>[] { <span style="color:#0e9ce5">4</span>, <span style="color:#0e9ce5">5</span>, <span style="color:#0e9ce5">6</span> };</span></code><code><span><span style="color:#ca7d37">private</span> MethodInfo _method3;</span></code><code><span><span style="color:#ca7d37">private</span> MethodInvoker _method3Invoker;</span></code><code><span>    [<span style="color:#afafaf">GlobalSetup</span>]</span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Setup</span>()</span></span></code><code><span>    {</span></code><code><span>        _method3 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod3"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>        _method3Invoker = MethodInvoker.Create(_method3);</span></code><code><span>    }</span></code><code><span>    [<span style="color:#afafaf">Benchmark(Baseline = true)</span>] </span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MethodBaseInvoke</span>()</span> =&gt; _method3.Invoke(<span style="color:#0e9ce5">null</span>, _args3);</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>]</span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MethodInvokerInvoke</span>()</span> =&gt; _method3Invoker.Invoke(<span style="color:#0e9ce5">null</span>, _arg0, _arg1, _arg2);</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod3</span>(<span><span style="color:#ca7d37">int</span> arg1, <span style="color:#ca7d37">int</span> arg2, <span style="color:#ca7d37">int</span> arg3</span>)</span> { }</span></code><code><span>}</span></code></pre><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>.NET8 的情況如下</span></p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,BlinkMacSystemFont,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:17px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:676.989px; word-spacing:0px"><tbody><tr><th>方法</th><th>平均值</th><th>比率</th></tr></tbody><tbody><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">MethodBaseInvoke</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">32.42 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">MethodInvokerInvoke</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">11.47 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.35</td></tr></tbody></table><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>這些類型被 Microsoft.Extensions.DependencyInjection.Abstractions 中的 ActivatorUtilities.CreateFactory 方法使用，以進一步提高 DI 服務構建性能。通過添加額外的緩存層進一步改進，進一步避免每次構建時的反射。</span></p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">&nbsp;</p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">作者:jianghupt</p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><strong>歡迎關注公眾號 (jianghupt），文章首發地。</strong></p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span><img alt="" height="430" src="https://oscimg.oschina.net/oscnet/up-3243ba74c89867eabc4277de83aa83aa7bb.png" width="430" referrerpolicy="no-referrer"></span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 09:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5407571/blog/10320411</guid>
            <link>https://my.oschina.net/u/5407571/blog/10320411</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
    </channel>
</rss>
