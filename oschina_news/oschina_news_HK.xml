<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 30 Nov 2023 14:41:37 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Furion 商業化探索得罪了誰？v4.9.1.8]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>嘿，大家好，我是百小僧，最近頗為熱鬧啊，因為 Furion 商業化探索引起了騷動，誠惶誠恐。</p><p>看到大家都開貼刷流量，我作為本人順便發一個新版本，也説點啥。</p><blockquote><p style="color:var(--color-fg-default); margin-left:0px; margin-right:0px; text-align:left"><strong>🚩 截止 2023 年 11 月 30 日 18 時 00 分 00 秒，註冊用户 6711 個，VIP 服務用户 399 個，開通文檔用户 3458 個，針對 .NET 初學者、學生或教育工作者免費開通賬號 743 個。</strong></p></blockquote><p style="color:var(--color-fg-default); margin-left:0px; margin-right:0px; text-align:left">再次感謝大家的支持。</p><h2>.NET 恥辱柱</h2><blockquote><p>因為部分文檔收費問題，有人把我釘在了 .NET 恥辱柱上，我是榜上第一名。</p><p>我想説的是：</p><p><strong>他們是恥辱，我是擎天柱。把我釘在恥辱柱，那是恥辱柱的恥辱。😊</strong></p></blockquote><h2>命運的安排</h2><blockquote><p style="color:rgba(0, 0, 0, 0.8); margin-left:0em; margin-right:0em; text-align:start"><strong>山雨欲來風滿樓，黑雲壓城城欲摧。</strong></p><p style="color:rgba(0, 0, 0, 0.8); margin-left:0; margin-right:0; text-align:start">如果 Furion 和，百小僧這三年日日夜夜的努力，每天 18 小時待命，340 萬字的文檔的付出不值得，那便交給時間去評判了。</p><p style="color:rgba(0, 0, 0, 0.8); margin-left:0; margin-right:0; text-align:start">人活在這個世界上，每個人的認知都是有限的，覺到、悟到、看到的都只是世界的一小面，包括認識百小僧的大家，也只是看到了百小僧的一面，那都不是完整的世界，完整的百小僧。</p><p style="color:rgba(0, 0, 0, 0.8); margin-left:0; margin-right:0; text-align:start"><strong>如果 Furion 對您有所幫助，並且您希望 Furion 能夠繼續發展下去，那麼便考慮支持它。如果它對您毫無價值，那便各自安好，無需惡語相向。</strong></p><p style="color:rgba(0, 0, 0, 0.8); margin-left:0; margin-right:0; text-align:start">開源不易，每個人都很不易，多份理解，多份寬容。唯有做的便是見天地，見眾生，見自己。</p><p style="color:rgba(0, 0, 0, 0.8); margin-left:0; margin-right:0; text-align:start"><strong>我一直相信釋迦牟尼説的一句話：</strong></p><p style="color:rgba(0, 0, 0, 0.8); margin-left:0; margin-right:0; text-align:start"><strong>「無論你遇見誰，他都是你生命該出現的人，絕非偶然，他一定會教會你一些什麼」。</strong></p><p style="color:rgba(0, 0, 0, 0.8); margin-left:0em; margin-right:0em; text-align:start"><strong>所以我也相信：「無論我走到哪裏，那都是我該去的地方，經歷一些我該經歷的事，遇見我該遇見的人」。</strong></p></blockquote><hr><p><img height="1328" src="https://oscimg.oschina.net/oscnet/up-fc02c4f7da7c7a5e13adb731952e7717a7c.png" width="1718" referrerpolicy="no-referrer"></p><h2>自我價值</h2><blockquote><p><strong>智商高的人可以把事情做精，情商高的人能把事情做大。</strong></p><p>還是尼采説得好：「更高級的哲人獨處着，這並不是因為他想孤獨，而是因為在他的周圍找不着他的同類」。</p><p><strong>又想起了天道芮小丹的話：「如果我的能力只能讓我窮困潦倒，那窮困潦倒便是我的價值。」。</strong></p></blockquote><h2>孤芳自賞</h2><blockquote><p><strong>縱你閲人何其多，再無一人恰似我。</strong></p></blockquote><h2>本期更新</h2><ul><li><p style="margin-left:0; margin-right:0"><strong>新特性</strong></p><ul><li>[新增]<span>&nbsp;</span><code>JSON.IsValid(jsonString)</code><span>&nbsp;</span>判斷<span>&nbsp;</span><code>JSON</code><span>&nbsp;</span>字符串有效性<span>&nbsp;</span>4.9.1.8<span>&nbsp;</span>⏱️2023.11.30<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/commit/22bc69bd4a445f81833c082da7c99f4a5c518012">22bc69b</a></li><li>[新增] 規範化處理自動過濾<span>&nbsp;</span><code>SSE</code><span>&nbsp;</span>請求、文件請求、圖片請求<span>&nbsp;</span>4.9.1.6<span>&nbsp;</span>⏱️2023.11.22<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/issues/I8IP6D">#I8IP6D</a></li><li>[新增]<span>&nbsp;</span><code>[AppDbContext]</code><span>&nbsp;</span>特性支持<span>&nbsp;</span><code>UseSnakeCaseNaming</code><span>&nbsp;</span>屬性配置表名使用蛇形命名<span>&nbsp;</span>4.9.1.5<span>&nbsp;</span>⏱️2023.11.20<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/issues/I8HGR2">#I8HGR2</a><span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/pulls/863">!863</a></li><li>[新增] 時間戳模型綁定器將時間戳轉換為<span>&nbsp;</span><code>DateTime/DateTimeOffset</code><span>&nbsp;</span>類型<span>&nbsp;</span>4.9.1.5<span>&nbsp;</span>⏱️2023.11.20<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/commit/df3053cf081d5e4d8eb63d567ed95c45267e0969">df3053c</a></li><li>[新增]<span>&nbsp;</span><code>Newtonsoft.Json</code><span>&nbsp;</span>自動將時間戳轉換為<span>&nbsp;</span><code>DateTime/DateTimeOffset</code><span>&nbsp;</span>類型<span>&nbsp;</span>4.9.1.3<span>&nbsp;</span>⏱️2023.11.17<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/commit/78a589d99eb5985b576e4c96acd6e4890391d6ff">78a589d</a></li><li>[新增]<span>&nbsp;</span><code>System.Text.Json</code><span>&nbsp;</span>自動將時間戳轉換為<span>&nbsp;</span><code>DateTime/DateTimeOffset</code><span>&nbsp;</span>類型<span>&nbsp;</span>4.9.1.2<span>&nbsp;</span>⏱️2023.11.17<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/commit/abd5196f5c5160a5df96dad80c7c5aa51b96d5b9">abd5196</a></li><li>[新增]<span>&nbsp;</span><code>IRepositoryFactory&lt;TEntity, TDbContextLocator&gt;</code><span>&nbsp;</span>倉儲功能，解決在<span>&nbsp;</span><code>Blazor</code><span>&nbsp;</span>中使用<span>&nbsp;</span><code>EFCore</code><span>&nbsp;</span>問題<span>&nbsp;</span>4.9.1.1<span>&nbsp;</span>⏱️2023.11.16<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/commit/4285ec0b8debc2d71c7f978126cb3dc394a8ad30">4285ec0</a><span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Faspnet%2Fcore%2Fblazor%2Fblazor-ef-core%3Fview%3Daspnetcore-7.0" target="_blank">文檔説明</a></li><li>[新增] 補償策略模塊功能<span>&nbsp;</span>4.9.1<span>&nbsp;</span>⏱️2023.11.15<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/tree/v4/framework/Furion/RescuePolicy">【源碼地址】</a><span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/commit/dfc63e7f0ffd2e03653f11a3e49a21646902ddc4">dfc63e7</a></li></ul></li><li><p style="margin-left:0; margin-right:0"><strong>突破性變化</strong></p><ul><li>[升級]<span>&nbsp;</span><code>Serilog</code><span>&nbsp;</span>拓展包依賴至<span>&nbsp;</span><code>8.0.0</code><span>&nbsp;</span>版本，<strong>移除<span>&nbsp;</span><code>.NET8.0</code><span>&nbsp;</span>的<span>&nbsp;</span><code>IWebHostBuilder.UseSerilogDefault</code><span>&nbsp;</span>拓展方法</strong><span>&nbsp;</span>4.9.1.1<span>&nbsp;</span>⏱️2023.11.16<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/commit/5ab3e43722a298db56a86792dde301adf1f3fe7f">5ab3e43</a></li><li>[升級]<span>&nbsp;</span><strong>框架底層適配<span>&nbsp;</span><code>.NET8.0</code><span>&nbsp;</span>正式版</strong><span>&nbsp;</span>4.9.1<span>&nbsp;</span>⏱️2023.11.15</li><li>[升級]<span>&nbsp;</span><strong>框架腳手架適配<span>&nbsp;</span><code>.NET8.0</code><span>&nbsp;</span>正式版</strong><span>&nbsp;</span>4.9.1<span>&nbsp;</span>⏱️2023.11.15</li></ul></li><li><p style="margin-left:0; margin-right:0"><strong>問題修復</strong></p><ul><li>[修復]<span>&nbsp;</span><code>Scoped.CreateUowAsync</code><span>&nbsp;</span>內部異常上層應用不能捕獲問題<span>&nbsp;</span>4.9.1.8<span>&nbsp;</span>⏱️2023.11.30<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/commit/3c859e83c0ed6f07fcf191973fe465599a823224">3c859e8</a></li><li>[修復] 定時任務設置觸發器<span>&nbsp;</span><code>Result</code><span>&nbsp;</span>後作業執行異常不能重置問題<span>&nbsp;</span>4.9.1.7<span>&nbsp;</span>⏱️2023.11.24<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/commit/147215f1631f58fca900f17cca5695f9431555e5">147215f</a></li><li>[修復]<span>&nbsp;</span><code>JWTEncryption.GetJWTSettings()</code><span>&nbsp;</span>獨立使用時無法獲取自定義配置<span>&nbsp;</span>4.9.1.4<span>&nbsp;</span>⏱️2023.11.18<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/commit/c045e084670a98f71d5ea5ed55ca5cbbfc981e0b">c045e08</a></li></ul></li><li><p style="margin-left:0; margin-right:0"><strong>文檔</strong></p><ul><li>[更新] 倉儲文檔、<code>Db</code><span>&nbsp;</span>靜態類文檔、腳手架文檔、<code>.NET7</code><span>&nbsp;</span>升級<span>&nbsp;</span><code>.NET8</code><span>&nbsp;</span>文檔、<code>JSON</code><span>&nbsp;</span>序列化文檔、<code>Docker</code><span>&nbsp;</span>部署文檔、數據庫上下文文檔、虛擬文件文檔、遠程請求文檔、<code>HttpContext</code><span>&nbsp;</span>文檔、<code>JSON</code><span>&nbsp;</span>靜態類文檔</li></ul></li><li><p style="margin-left:0; margin-right:0"><strong>貢獻者</strong></p><ul><li>zuohuaijun (<a href="https://gitee.com/zuohuaijun">@zuohuaijun</a>)<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/pulls/865">!865</a></li><li>anliuty (<a href="https://gitee.com/www.fengyunmy.com">@anliuty</a>)<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/pulls/863">!863</a></li><li>風雲明月 (<a href="https://gitee.com/www.fengyunmy.com">@www.fengyunmy.com</a>)<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/pulls/862">!862</a></li></ul></li></ul><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 10:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268876/furion-4-9-1-8-released</guid>
            <link>https://www.oschina.net/news/268876/furion-4-9-1-8-released</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[NixOS 23.11 發佈，桌面 Linux 發行版]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">NixOS 23.11「Tapir」&nbsp;</span>版本現已<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnixos.org%2Fblog%2Fannouncements.html%23nixos-23.11" target="_blank">發佈</a>，該版本將在 7 個月內（直至 2024-06-30）接受錯誤修復和安全更新。自上一版本發佈以來，23.11 版本包含了來自&nbsp;2162 位貢獻者的 40024 次 commit。</span></p><p><span style="color:#000000">此次發佈的 Nixpkgs 中新增了 9147 個軟件包，更新了 18700 個軟件包。以及刪除了 4015 個軟件包，以保持軟件包集的可維護性和安全性。</span></p><p><span style="color:#000000">除軟件包外，NixOS 發行版還具有模塊和測試功能。本次發佈新增了 113 個模塊，刪除了 18 個模塊。在此過程中添加了 1565 個選項，刪除了 362 個。</span></p><h4><span style="color:#000000"><strong>GNOME 45</strong></span></h4><p><span style="color:#000000">GNOME 已更新至第 45 版 "Rīga"，其中引入了一個新的 image viewer、一個新的 camera app 以及一些其他更改。更多詳細信息可參閲</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frelease.gnome.org%2F45%2F" target="_blank">發行説明。</a></p><h4><span style="color:#000000"><strong>默認 LLVM 版本</strong></span></h4><p><span style="color:#000000">在 Linux 和 Darwin 上，LLVM 軟件包集的默認版本已更新至 16（從 11），其中引入了大量新功能和改進。有關變更的完整列表，請參見此處（LLVM）和此處（Clang）。完整的更改列表可</span>&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Freleases.llvm.org%2F16.0.0%2Fdocs%2FReleaseNotes.html" target="_blank">在此處 (LLVM)</a>&nbsp;<span style="color:#000000">和&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Freleases.llvm.org%2F16.0.0%2Ftools%2Fclang%2Fdocs%2FReleaseNotes.html" target="_blank">此處 (Clang)</a>&nbsp;<span style="color:#000000">獲取。</span></p><h4><strong><span style="color:#000000">Highlights</span></strong></h4><div><ul><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>FoundationDB 現在默認為主要版本 7。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>PostgreSQL 現在默認主要版本 15。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>GNOME 已更新至版本 45，詳細信息參閲<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frelease.gnome.org%2F45%2F" target="_blank">發行説明</a>。值得注意的是，Loupe 已取代 Eye of GNOME 作為默認 </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="color:#000000">image viewer</span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>，Snapshot 已取代 Cheese 作為默認 </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="color:#000000">camera app</span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>，並且將不再安裝 Photos。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>hostapd 軟件包支持 WiFi6（IEEE 802.11ax）和 WPA3-SAE-PK，同時對 hostapd 模塊進行了重大修改。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>LXD 現在支持虛擬機實例以補充現有的容器支持</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span><code>nixos-rebuild</code>命令新增了一個<code>list-generations</code>子命令。參閲<code>man nixos-rebuild</code>瞭解更多詳情。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsystemd.io%2F" target="_blank">systemd</a>&nbsp;已從 v253 更新到 v254，有關更改的更多信息參閲<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsystemd%2Fsystemd%2Fblob%2Fv254%2FNEWS%23L3-L659" target="_blank">發行説明。</a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><ul><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>如果不是 EFI 模式，則必須在休眠時指定 boot.resumeDevice。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>systemd 可能會就 ESP 分區（often /boot）的權限問題向系統發出警告，暫時可以忽略該警告，項目團隊正在研究解決該問題的方法。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>建議使用 nixos-rebuild 啓動和重啓進行更新，因為在極少數情況下，在實時系統上切換到新一代 nixos-rebuild 可能會因掛載單元丟失而失敗。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li></ul></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>現在支持用 Rust 重新實現 sudo 的 sudo-rs 模塊。新增了一個實驗性模塊 security.sudo-rs。由於 sudo-rs 當前的侷限性，切換到該模塊（通過 security.sudo-rs.enable = true;）會帶來 sudo 行為的細微變化：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><ul><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>​​​​​​​​​​​​​​與 terminfo 相關的環境變量不會為 root 和 wheel 保存；</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>不允許 root 和 wheel 設置（或保留）任意環境變量。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li></ul></li></ul><p><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span><span><span><strong>注意：</strong>sudo-rs 模塊僅通過 security.sudo-rs 進行配置，尤其不會自動使用先前設置的規則；例如，可以通過</span></span><code>security.sudo-rs.extraRules = security.sudo.extraRules;</code><span><span>來實現。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>​​​​​​​</p><ul><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.gnu.org%2Fsoftware%2Flibc%2F" target="_blank">glibc</a>&nbsp;已從版本 2.37 更新到 2.38，參閲<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsourceware.org%2Fglibc%2Fwiki%2FRelease%2F2.38" target="_blank">發行説明</a>瞭解更改內容。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span><code>linuxPackages_testing_bcachefs</code>現已被<code>linuxPackages_testing</code>軟棄用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><ul><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>​​​​​​​建議考慮將 NixOS 配置的 boot.kernelPackages 更改為 linuxPackages_testing，直到發佈支持 bcachefs 的穩定內核。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li></ul></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>所有&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frocm.docs.amd.com%2Fen%2Flatest%2F" target="_blank">ROCm</a>&nbsp;軟件包均已更新至 5.7.0。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><ul><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>​​​​​​​​​​​​​​ROCm 軟件包屬性集的版本號為：rocmPackages -&gt; rocmPackages_5。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li></ul></li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span><code>yarn-berry</code>已更新至 4.0.1。這意味着它不再支持小於 18.12 的 NodeJS 版本。更多詳細信息參見<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fyarnpkg%2Fberry%2Fblob%2Fmaster%2FCHANGELOG.md" target="_blank">上游變更日誌</a>。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li>如果用户通過 users.users.${USERNAME}.shell = ${CUSTOMSHELL} 啓用了自定義 shell，則斷言會要求他們同時設置 programs.${CUSTOMSHELL}.enable=true。這通常是安全的行為，但對於需要退出檢查的用户來説，users.users.${USERNAME}.ignoreShellProgramCheck = true 就可以完成這項工作。</li><li><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>Cassandra 現在默認為 4.x，從 3.11.x 更新。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li></ul></div><p>更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnixos.org%2Fblog%2Fannouncements.html%23nixos-23.11" target="_blank">查看官方博客</a>。&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 10:29:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268873/nixos-23-11-released</guid>
            <link>https://www.oschina.net/news/268873/nixos-23-11-released</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Unity 裁員 265 人]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Unity 在 2021 年以 16.25 億美元收購了 Peter Jackson 聯合創辦的視覺特效公司 Weta Digital 的工程技術部門，與美術部門 Weta FX 達成服務協議。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reuters.com%2Ftechnology%2Funity-software-cut-38-staff-company-reset-2023-11-28%2F" target="_blank">根據路透社的報道</a></u>，現在作為公司重組 (company reset) 的一部分它宣佈<strong>終止服務協議裁掉相關的 265 名員工，約佔員工總數的 3.8%</strong>。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1130/170155_SD5i_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>Unity 是規模最大的遊戲引擎開發商，目前還有 7000 名員工。它同時宣佈將關閉部分辦事處，縮小辦公面積，不再強制要求員工每週前往辦公室工作三天。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">9 月份，Unity 宣佈了新的收費規則，此舉引起業內人士的強烈不滿。之後 Unity 向公眾和業內人士道歉，並調整了收費規則。</p><ul><li><u><em><a href="https://www.oschina.net/news/257929/unity-runtime-fee">Unity 引擎明年起根據遊戲安裝量收費 (runtime fee)</a></em></u></li><li><u><em><a href="https://www.oschina.net/news/258513/unity-apologize-for-runtime-fee">Unity 道歉：將修改 "runtime fee" 收費政策</a></em></u></li><li><u><em><a href="https://www.oschina.net/news/258477/wait-is-unity-allowed-to-just-change-its-fee-structure-like-that">走近 「收費門」：互相矛盾的服務條款導致 Unity 面臨被起訴的風險</a></em></u></li></ul><p>Unity CEO John Riccitiello 上個月因受爭議的運行時費用而<u><a href="https://www.oschina.net/news/261101/unity-ceo-john-riccitiello-is-retiring">離職</a></u>，前 IBM 總裁 Jim Whitehurst 擔任臨時 CEO，Whitehurst 表示為了重新專注於公司業務，更多的變化即將到來。雖然這對受影響的員工來説是一個挑戰，但對於公司來説，這可能是一個重新調整和提高效率的機會。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 08:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268858/unity-software-cut-38-staff</guid>
            <link>https://www.oschina.net/news/268858/unity-software-cut-38-staff</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微軟 2023 款醜毛衣：基於 WinXP 藍天白雲壁紙]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Windows <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.windows.com%2Fwindowsexperience%2F2023%2F11%2F28%2Fwindows-brings-nostalgia-to-the-holidays-with-the-return-of-windows-ugly-sweaters-this-year-featuring-the-bliss-backdrop%2F" target="_blank">宣佈</a>推出 2023 新款醜毛衣 (Windows Ugly Sweater)：基於經典 WinXP 系統中標誌性的 Bliss 壁紙 —— 藍天白雲青草地。</span></p><p><span style="color:#000000">這張照片由攝影師 Charles O'Rear 在 1996 年拍攝於加利福尼亞州索諾瑪縣，微軟在 2000 年以「不到六位數」的價格買下了版權。微軟於 2018 年首次推出 Windows 醜毛衣，今年是連續推出的第 6 年。</span></p><p><span style="color:#000000">毛衣尺碼涵蓋 S-3XL，在微軟 Xbox Gear Shop <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgear.xbox.com%2Fproducts%2Fwindows-merry-blissmas-knit-holiday-sweater" target="_blank">官網上限量發售</a>（目前已售罄）。售價在人民幣 500 元左右，微軟方面表示售出所得全部收益將捐給大自然保護協會。預計購買者將於 12 月 2 日至 17 日期間收到貨。</span></p><p><span style="color:#000000"><img alt="" height="266" src="https://oscimg.oschina.net/oscnet/up-93a909038c76d1e72eb6c4f2167c779fde2.jpg" width="300" referrerpolicy="no-referrer"><img alt="" height="260" src="https://oscimg.oschina.net/oscnet/up-a1683a329b2c046f9927ac467d8e74448cd.jpg" width="300" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><img alt="" height="276" src="https://oscimg.oschina.net/oscnet/up-c476b2849bbc0f49e47b35265dbace5e969.jpg" width="275" referrerpolicy="no-referrer">&nbsp;<img alt="" height="276" src="https://oscimg.oschina.net/oscnet/up-44dd702c39368126e2e5e120bc91a44071b.jpg" width="300" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><img alt="" height="298" src="https://oscimg.oschina.net/oscnet/up-bbe8781e5f77acb8ce6d5bc96add615538c.jpg" width="300" referrerpolicy="no-referrer">&nbsp;<img alt="" height="302" src="https://oscimg.oschina.net/oscnet/up-7dc53486d194b5b6bebdb5e2dd92ae46c79.jpg" width="300" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">微軟還發布了新版的 Bliss 壁紙，感興趣的用户可前往&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgear.xbox.com%2Fpages%2Fwindows" target="_blank">Xbox Gear Shop</a><span style="background-color:#ffffff; color:#000000"><span>&nbsp;</span></span>進行下載。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 08:56:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268857/windows-2023-ugly-sweater</guid>
            <link>https://www.oschina.net/news/268857/windows-2023-ugly-sweater</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Coreboot 4.22 發佈，將啓用新的版本命名規則]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Coreboot 4.22 &amp; 4.22.01 現已<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.coreboot.org%2Fblog%2F2023%2F11%2F28%2Fcoreboot-4-22-4-22-01-have-been-released%2F" target="_blank">發佈</a>。項目團隊在 4.22 發佈週期中發現了 sandybridge/ivybridge 平台上存在未初始化變量錯誤，因此決定納入 4.22.01 發佈包。<span style="background-color:#ffffff">下一個版本計劃於 2024 年 2 月 19 日發佈。</span></span></p><p><span style="color:#000000">新版本的一些<strong>更新亮點包括：</strong></span></p><ul><li><span style="color:#000000">x86 對預內存階段 .data 部分的支持、對預內存階段和 ramstage 的 CBFS 緩存的支持</span></li><li><span style="color:#000000">允許 romstage 合併到 bootblock 中</span></li><li><span style="color:#000000">soc/intel/cmn/gfx：添加 API 來報告外部顯示器的存在</span></li><li><span style="color:#000000">device/pci_rom：填充 VFCT 表時設置 VBIOS 校驗和</span></li><li><span style="color:#000000">將所有「select」語句從 Kconfig.name 文件移至 Kconfig</span></li><li><span style="color:#000000">acpigen 現在生成可變長度的 PkgLength 字段，而不是固定的 3 字節大小，以提高兼容性並與 IASL 保持一致</span></li><li><span style="color:#000000">支持在更多基於 Coreboot 的 Chromebook 上運行 Microsoft Windows</span></li><li><span style="color:#000000">一般清理和重新格式化</span></li><li><span style="color:#000000">添加初始 AMD openSIL 實現</span></li><li><span style="color:#000000">添加適用於 ARM64 的 ACPI 表生成</span></li><li><span style="color:#000000">即使標記為無效，在 s3 恢復期間也停止重置 CMOS</span></li><li><span style="color:#000000">修復 SMM get_save_state 計算，該計算在啓用 STM 時被破壞</span></li><li><span style="color:#000000">SNB+MRC boards：將 MRC 設置遷移到 devicetree</span></li><li><span style="color:#000000">適用於所有平台的&nbsp;chipset devicetrees</span></li></ul><p><span style="color:#000000"><strong><span style="background-color:#ffffff">新增 17 塊主板</span></strong></span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">AMD Onyx</span></li><li><span style="color:#000000">Google: Anraggar</span></li><li><span style="color:#000000">Google: Brox</span></li><li><span style="color:#000000">Google: Chinchou</span></li><li><span style="color:#000000">Google: Ciri</span></li><li><span style="color:#000000">Google: Deku</span></li><li><span style="color:#000000">Google: Deku4ES</span></li><li><span style="color:#000000">Google: Dexi</span></li><li><span style="color:#000000">Google: Dochi</span></li><li><span style="color:#000000">Google: Nokris</span></li><li><span style="color:#000000">Google: Quandiso</span></li><li><span style="color:#000000">Google: Rex4ES EC ISH</span></li><li><span style="color:#000000">Intel: Meteorlake-P RVP with Chrome EC for non-Prod Silicon</span></li><li><span style="color:#000000">Purism Librem 11</span></li><li><span style="color:#000000">Purism Librem L1UM v2</span></li><li><span style="color:#000000">Siemens FA EHL</span></li><li><span style="color:#000000">Supermicro X11SSW-F</span></li></ul><p><span style="color:#000000"><strong><span style="background-color:#ffffff">coreboot 版本命名更新</span></strong></span></p><p><span style="color:#000000">值得注意的是，此版本是使用遞增 4.xx 版本名稱方案的最後一個版本。對於未來的版本，coreboot 將切換到 Year.Month.Sub-version 命名方案。因此，計劃於 2024 年 2 月發佈的下一個版本將編號為 24.02，子版本為 00。如果項目團隊需要對 24.02 版本進行修復或將來發布，他們會將值 .01、.02 等附加到初始版本值。</span></p><p><span style="color:#000000"><strong><span style="background-color:#ffffff">coreboot 默認分支更新</span></strong></span></p><p><span style="color:#000000">4.21 版本發佈後，coreboot 項目已經將默認 git 分支從「master」更改為「main」。在更改後的前幾個月，master 分支每天與 main 分支同步幾次，以便大家有時間更新腳本。截至 2023 年 11 月 1 日，同步率已減慢至每週一次；該頻率計劃將持續到下一個版本，屆時 master 分支將被刪除。</span></p><p><span style="background-color:#ffffff; color:#333333">更多詳情可</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.coreboot.org%2Fblog%2F2023%2F11%2F28%2Fcoreboot-4-22-4-22-01-have-been-released%2F" target="_blank">查看官方博客</a><span style="background-color:#ffffff; color:#333333">。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 07:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268837/coreboot-4-22-4-22-01-released</guid>
            <link>https://www.oschina.net/news/268837/coreboot-4-22-4-22-01-released</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Roundcube 與 Nextcloud 合併]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">開源電子郵件項目&nbsp;Roundcube 已與 Nextcloud 完成合並。公告<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnextcloud.com%2Fblog%2Fopen-source-email-pioneer-roundcube-comes-aboard-nextcloud%2F" target="_blank">指出</a>，合併完成後的</span><span style="background-color:#ffffff; color:#121212">短期內計劃是改進集成和加速開發，包括</span>擴展 Roundcube 團隊，以及支持和​​發展貢獻社區，邀請新人才來促進項目的發展和健康。</p><p><span style="background-color:#ffffff; color:#121212">除此之外，Roundcube 和 Nextcloud </span><span style="background-color:#ffffff; color:#050404">之間的直接合並尚未計劃</span><span style="background-color:#ffffff; color:#121212">。</span><span style="color:#000000">Roundcube 不會取代 Nextcloud Mail，反之亦然。Nextcloud Mail 將按原計劃發展，專注於在 Nextcloud 中的使用；Roundcube 則將繼續作為獨立的安全郵件客户端為其活躍用户和新用户提供服務。</span></p><p><span style="background-color:#ffffff; color:#121212">2024 年，Nextcloud 將持續投資<span>&nbsp;</span>Roundcube，對該項目進行調整和改進，以創建適合廣大用户的完整產品。</span></p><p><span style="background-color:#ffffff; color:#121212"><img alt="" height="313" src="https://oscimg.oschina.net/oscnet/up-97ca74865ebcea22f7fe4d93ba5e30eb8af.webp" width="500" referrerpolicy="no-referrer"></span></p><blockquote><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">Roundcube 是一款多語言 IMAP 客户端，具有類似應用程序的用户界面，支持 MIME、地址簿、文件夾、郵件搜索和拼寫檢查。提供充分的安全和隱私保護，包括 PGP、XSS 抵禦和暴力保護。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">Nextcloud&nbsp;是一套用於創建網絡硬盤的客户端－服務器軟件。其功能與 Dropbox 相近，但 Nextcloud 是自由及開放源代碼軟件，每個人都可以在私人服務器上安裝並運行它。</span></p></blockquote><p><span style="color:#000000">Nextcloud 創始人&nbsp;Frank Karlitschek 稱，「此次合併不僅彰顯了開源社區的集體力量，還突出了我們對隱私、安全和用户授權的持久承諾。」</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnextcloud.com%2Fblog%2Fopen-source-email-pioneer-roundcube-comes-aboard-nextcloud%2F" target="_blank">查看官方公告</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 06:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268830/roundcube-comes-aboard-nextcloud</guid>
            <link>https://www.oschina.net/news/268830/roundcube-comes-aboard-nextcloud</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[為什麼會有人去 DDoS 攻擊 Blender？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#000000">Blender 上週發佈</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.blender.org%2Fnews%2Fcyberattack-november-2023%2F" target="_blank">公告稱</a><span style="background-color:#ffffff; color:#000000">，blender.org 網站在 2023 年 11 月 18 日至 23 日期間持續受到 DDoS 攻擊，攻擊者通過不斷髮送請求致使網站服務器超載而癱瘓，導致網站運營嚴重中斷。除了 blender.org 主網站外，其他一些服務也無法使用。</span></p><blockquote><p><strong><em><u><a href="https://www.oschina.net/news/267990/blender-cyberattack-2023" target="_blank">Blender 連續 5 天遭受大規模 DDoS 攻擊</a></u></em></strong></p></blockquote><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">該攻擊由具有數百個 IP 地址的殭屍網絡執行，發送超過 15 億個惡意請求，峯值速率為 10 萬 rps（每秒請求）。網站斷斷續續的可用了幾天，但即使在攻擊者暫停攻擊的短時間內，Blender 的基礎設施仍然因大量待處理的合法請求而超載，導致服務器難以跟上。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">在經過四天的抵禦攻擊之後 (11 月 21 日) 後，Blender 決定將其網站轉移到了 CloudFlare，以減少攻擊的影響。目前尚未有人聲稱對這次襲擊負責，動機也未知。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img alt="up-affc1ae024c2e2724c7542ba5f0d983081b.png" src="https://oscimg.oschina.net/oscnet/up-affc1ae024c2e2724c7542ba5f0d983081b.png" referrerpolicy="no-referrer"></p><p>問題來了，為什麼像 Blender 這樣沒有商業價值的網站也會遭遇 DDoS 攻擊？</p><p>HN 上的一名網友<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D38454048" target="_blank">發表了自己的看法</a></u><strong>：提供 DDoS 服務的攻擊者需要向黑市「展示」能力</strong>，以證明它們自己的能力。恰好，Blender 是一個理想的目標——知名度高，團隊有技術專家，而且擁有足夠的技術專業知識來發布和覆盤 DDoS 的詳細信息。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3b538a86727834eae0b853e70980a29a231.png" referrerpolicy="no-referrer"></p><p>所以，並不是有人想要傷害 Blender 本身，只是 DDoS 服務供應商/駭客組織想要公開展示自己並宣傳他們的服務。剛好這次 Blender 被選中了。</p><p>對於「無辜」的開源項目（如 Blender）受到無端攻擊，各位有什麼看法？歡迎在評論區討論交流。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 06:13:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268827</guid>
            <link>https://www.oschina.net/news/268827</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[工信部印發《2023 年 5G 工廠名錄》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#333333">工業和信息化部近日印發《</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fzwgk%2Fzcwj%2Fwjfb%2Ftz%2Fart%2F2023%2Fart_53532488d3394047b85116f5b29b3e32.html" target="_blank">2023 年 5G 工廠名錄</a><span style="background-color:#ffffff; color:#333333">》。</span></p><blockquote><p><span style="color:#070707">為深入推進「5G+工業互聯網」創新發展，打造 5G 工廠中國品牌，各地依據《5G 全連接工廠建設指南》（工信廳信管〔2022〕23 號）加快推動 5G 工廠建設，取得積極成效。經省級工業和信息化主管部門、通信管理局推薦，工業互聯網戰略諮詢專家委評審以及公示等程序，確定了 2023 年 5G 工廠名錄，現予以公佈。</span></p></blockquote><p><span style="color:#070707"><img alt="" height="4404" src="https://oscimg.oschina.net/oscnet/up-5a849aef64cd677596498f4b34767f9b5b8.jpg" width="500" referrerpolicy="no-referrer"></span></p><hr><h4 style="margin-left:0px; margin-right:0px"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fzwgk%2Fzcjd%2Fart%2F2023%2Fart_1741388b2be2476b819199c8b1127b5e.html" target="_blank"><strong>一圖讀懂《2023 年 5G 工廠名錄》</strong></a></h4><p style="margin-left:0px; margin-right:0px"><strong><img alt="" height="5541" src="https://oscimg.oschina.net/oscnet/up-3998b1700458d5f0a87e0f258eb9f38c9dc.jpg" width="500" referrerpolicy="no-referrer"></strong></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 03:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268811</guid>
            <link>https://www.oschina.net/news/268811</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gradle 8.5 發佈，支持 Java 21]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#333333">Gradle 8.5&nbsp;現已<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.gradle.org%2F8.5%2Frelease-notes.html" target="_blank">發佈</a>。Gradle&nbsp;是一個基於&nbsp;Apache Ant&nbsp;和&nbsp;Apache Maven&nbsp;概念的項目自動化構建工具，支持依賴管理和多項目，類似&nbsp;Maven，但比之簡單輕便。它使用一種基於&nbsp;Groovy&nbsp;的特定領域語言來聲明項目設置，而不是傳統的&nbsp;XML。</span></p><p><span style="background-color:#ffffff; color:#333333">Gradle&nbsp;</span>現在支持<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.gradle.org%2F8.5%2Frelease-notes.html%23java-21" target="_blank">在 Java 21 上運行</a>。<span><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>此版本對&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.gradle.org%2F8.5%2Frelease-notes.html%23kotlin-dsl" target="_blank">Kotlin DSL 進行了改進</a>，包括<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.gradle.org%2F8.5%2Frelease-notes.html%23faster-first-use" target="_blank">更快的 first use</a>&nbsp;以及<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.gradle.org%2F8.5%2Frelease-notes.html%23catalog-precompiled" target="_blank">預編譯 Kotlin 腳本插件中的版本目錄支持</a>。此外還提供了更多有用的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.gradle.org%2F8.5%2Frelease-notes.html%23error-reporting" target="_blank">錯誤和告警消息</a>、改進了&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.gradle.org%2F8.5%2Frelease-notes.html%23build-init" target="_blank">build&nbsp;init </a>和<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.gradle.org%2F8.5%2Frelease-notes.html%23dependency-verification" target="_blank">依賴項驗證</a>，以及為構建和插件作者提供的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.gradle.org%2F8.5%2Frelease-notes.html%23build-authoring-improvements" target="_blank">幾個新 API</a>。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><strong><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>完整的 Java 21 支持</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Gradle 8.4 支持使用 Java 工具鏈編譯和測試 Java 21，但還不支持在 Java 21 上運行 Gradle 本身。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>新版本發佈後，Gradle 現在完全支持在 Java 21&nbsp;上編譯、測試和運行。</p><p style="text-align:start">詳情可參閲完整的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.gradle.org%2F8.5%2Fuserguide%2Fcompatibility.html%23java" target="_blank">兼容性文檔</a>。</p><p style="text-align:start"><strong><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Kotlin DSL 改進</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>與傳統的 Groovy DSL 相比，Gradle 的 Kotlin DSL 在支持的 IDE 中提供了更好的編輯體驗：自動完成、智能內容輔助、快速訪問文檔、源代碼導航和上下文感知重構。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li style="text-align:start"><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>首次使用速度更快：首次使用 Gradle 版本時，Gradle 會比以前更快地開始編譯構建邏輯。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li></ul><p style="text-align:start"><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><img alt="" height="309" src="https://oscimg.oschina.net/oscnet/up-b000b4fa01dd3c0116148a5be5e8bf560a1.png" width="500" referrerpolicy="no-referrer"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li style="text-align:start"><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>預編譯腳本中的版本目錄 API：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><code>versionCatalogs</code>擴展訪問器現在可用於 Kotlin DSL 預編譯腳本。</li></ul><pre style="text-align:start"><code class="language-kotlin">// buildSrc/src/main/kotlin/my-convention-plugin.gradle.kts
versionCatalogs                   // This is the extension now available
    .named("libs")                // Assumes there is a libs catalog, throws exception otherwise
    .findLibrary("assertj-core")  // Search the catalog for an assertj-core entry
    .ifPresent { assertjCore -&gt;   // If there is one ... 
        dependencies {            // ... Add a dependency to it 
            testImplementation(assertjCore) 
        }
    }
</code></pre><ul><li style="text-align:start"><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>能夠為腳本編譯啓用 Kotlin 元數據版本檢查</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li></ul><p style="text-align:start"><strong><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>錯誤和告警報告改進</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><ul><li style="text-align:start"><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>改進了使用 reserved names 創建配置時的棄用消息。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#02303a">棄用警告示例：</span></li></ul><pre style="text-align:start"><span><span><span><span style="background-color:#f7f7f8"><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span><code> Configure project : The configuration customCompileOnly was created explicitly. This configuration name is reserved for creation by Gradle. This behavior has been deprecated. This behavior is scheduled to be removed in Gradle 9.0. Do not create a configuration with the name customCompileOnly. Consult the upgrading guide for further information: https://docs.gradle.org/8.5/userguide/upgrading_version_8.html#configurations_allowed_usage When creating configurations during sourceSet custom setup, Gradle found that configuration customCompileOnly already exists with permitted usage(s): Consumable - this configuration can be selected by another project as a dependency Resolvable - this configuration can be resolved by this project to a set of files Declarable - this configuration can have dependencies added to it Yet Gradle expected to create it with the usage(s): Declarable - this configuration can have dependencies added to it Gradle will mutate the usage of configuration customCompileOnly to match the expected usage. This may cause unexpected behavior. Creating configurations with reserved names has been deprecated. This will fail with an error in Gradle 9.0. Create source set custom prior to creating or accessing the configurations associated with it. For more information, please refer to https://docs.gradle.org/8.5/userguide/building_java_projects.html#sec:implicit_sourceset_configurations in the Gradle documentation. </code></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre><ul><li style="text-align:start"><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>改進了運行測試時對封裝斷言錯誤的處理</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li style="text-align:start"><span><span><span><span style="color:#02303a"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>無法刪除文件時提供更好的診斷：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>當 Gradle 無法刪除文件時，它現在將提供擴展診斷。這有助於解決鎖定文件、併發寫入等問題。</li></ul><p>更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.gradle.org%2F8.5%2Frelease-notes.html" target="_blank">查看發佈公告</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 03:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268809/gradle-8-5-released</guid>
            <link>https://www.oschina.net/news/268809/gradle-8-5-released</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微軟發佈跨平台機器學習框架 ML.NET 3.0]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>微軟近日<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fannouncing-ml-net-3-0%2F" target="_blank">正式發佈</a></u> ML.NET 3.0，帶來了許多新功能和改進。</p><blockquote><p>ML.NET 是一個開源、跨平台的機器學習框架，專為 .NET 開發者設計，可以將自定義的機器學習模型集成到 .NET 應用程序中。</p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-375e72816abb7630cd510c6acc58fe425c3.png" referrerpolicy="no-referrer"></p><p>在這個版本中，深度學習方案得到了大幅擴展——引入了目標檢測 (Object Detection)、命名實體識別 (Named Entity Recognition) 和問答 (Question Answering) 等新功能。這些功能得以實現，得益於與 TorchSharp 和 ONNX 模型的集成和互操作性。同時，該版本還將集成的 LightGBM 升級到了最新版本。</p><p>數據處理方面也有很大的改進，DataFrame 引入了一系列增強和錯誤修復，使得數據的加載、檢查、轉換和可視化等步驟更加強大。</p><p>在 ML.NET 3.0 中，開發者可以利用這些先進的功能來處理深度學習、自然語言處理等機器學習任務。例如，可以使用 ML.NET 的目標檢測 API 來定位和分類圖像中的實體，還可以使用 ML.NET 的命名實體識別和問答訓練器來處理自然語言處理任務。</p><p>此外，ML.NET 3.0 還引入了 Intel oneDAL 的訓練加速功能，可以加快訓練過程。Intel oneDAL 是一個用於數據分析的庫，通過提供高度優化的算法構建塊，加速數據分析和機器學習過程。它通過利用 64 位架構中的 SIMD 擴展，支持 Intel 和 AMD 的 CPU。</p><p>自動機器學習 (AutoML) 也是 ML.NET 3.0 的一個重要功能。AutoML 可以自動化應用機器學習到數據的過程，簡化了模型構建的流程。ML.NET 3.0 的 AutoML 針對多個新功能進行了增強，包括支持判斷句子相似性、問答和目標檢測等任務。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdotnet%2Fmachinelearning%2Fblob%2Fmain%2Fdocs%2Frelease-notes%2F3.0%2Frelease-3.0.0.md" target="_blank">詳情查看 Release Notes</a></u>。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 03:25:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268807/ml-net-3-0</guid>
            <link>https://www.oschina.net/news/268807/ml-net-3-0</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[蘋果每台設備的 Arm 專利費比塑料薄膜還便宜]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theinformation.com%2Farticles%2Fhow-a-lopsided-apple-deal-got-under-arms-skin">根據 The Information 的報道</a></u>，蘋果每年銷售數億部 iPhone、iPad、Mac 和 Apple Watch 和其他使用 Arm 芯片的智能設備，但每台設備只向 Arm 支付不到 30 美分（約合人民幣 2.15 元）的版權專利費用。</p><blockquote><p><img height="736" src="https://static.oschina.net/uploads/space/2023/1130/105919_wrxb_2720166.png" width="1768" referrerpolicy="no-referrer"></p></blockquote><p><strong>在所有獲得 Arm 授權的芯片設計公司裏，蘋果支付的費率最低，每年支付的費用不到 Arm 收入的 5%。相比之下，Arm 最大的兩個客户高通和聯發科，支付的費用比蘋果高一倍</strong>。</p><p>這種不平衡的交易對於 Arm 來説是一個問題，因為它無法從蘋果這個重要客户那裏獲得足夠的收入。文章提到，軟銀首席執行官孫正義曾在 2017 年的一次會議上向 Arm 的高管們抱怨蘋果的低費用，並以 iPhone 上的塑料保護膜來強調這一觀點——孫正義告訴與會者，<strong>蘋果為保護新 iPhone 屏幕的塑料薄膜支付的費用比為 Arm 知識產權授權的費用還要高</strong>。</p><p>然而，多年過去了，這個問題仍然存在。</p><p>據瞭解，軟銀集團在 2016 年收購 Arm 時，首席執行官孫正義希望能重新談判並提高費率，不過並沒有成功。Arm 最初是由多家科技公司投資的合資企業，蘋果是其創始成員之一，未來雙方也沒有分開的打算。</p><p>Arm 遞交的美國 IPO 文件顯示：蘋果公司與 Arm 就芯片技術簽署新版長期性協議，「雙邊合作關係將延續至 2040 年之後」。遠遠超過科技領域通常的五年期限。</p><p>除了 Arm 架構外，蘋果也在研究開源的 RISC-V 架構，過往曾有發佈相關的招聘信息。一方面 RISC-V 架構不需要支付任何專利費，可進一步降低成本，另一方面可以作為與 Arm 等其他公司合作的籌碼。從目前情況來看，蘋果和 Arm 複雜的合作關係可能會持續數十年。</p><ul><li><u><em><a href="https://www.oschina.net/news/158746/apple-looking-for-risc-v-programmers">蘋果正在招聘 RISC-V 開發者</a></em></u></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268797</guid>
            <link>https://www.oschina.net/news/268797</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[幻方量化旗下 DeepSeek 發佈 67B 開源大模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">知名私募巨頭幻方量化<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZj7gPGqJ8UTTxp1umfWjKQ" target="_blank">宣佈</a>，其探索 AGI（通用人工智能）的新組織「深度求索（DeepSeek）」繼 11 月初發布 Coder 代碼模型之後，正式發佈通用大語言模型：DeepSeek LLM 67B。模型已完全開源，同時服務已經全面開放內測。</span></p><p><span style="color:#000000">目前 DeepSeek 已同時開源 7B 和 67B 的兩種規模模型，均含基礎模型（base）和指令微調模型（chat）。無需申請，免費商用。同時，項目團隊還將訓練中途的 9 個模型 checkpoints 開放下載。</span></p><p><span style="color:#000000">相比開源的同級別模型 LLaMA2 70B，DeepSeek LLM 67B 在近 20 箇中英文的公開評測榜單上表現更佳。尤其突出的是推理、數學、編程等能力（如：HumanEval、MATH、CEval、CMMLU）。</span></p><p><img height="412" src="https://oscimg.oschina.net/oscnet/up-90b96f11cad1cebc1a6f8ed065af941752e.png" width="500" referrerpolicy="no-referrer"></p><p><img height="418" src="https://oscimg.oschina.net/oscnet/up-b18e003f54e25e5fcb9112b2733d0c1afc3.png" width="500" referrerpolicy="no-referrer">&nbsp;</p><p><img height="418" src="https://oscimg.oschina.net/oscnet/up-ae3911e345f12b177ff22551b6f2adfd615.png" width="500" referrerpolicy="no-referrer"></p><p><img height="432" src="https://oscimg.oschina.net/oscnet/up-fb75c7324ae7131702fad2abdc8a6f96af6.png" width="500" referrerpolicy="no-referrer"></p><p><img height="288" src="https://oscimg.oschina.net/oscnet/up-2f23eeacbc701e424120f6c2507412d23de.png" width="500" referrerpolicy="no-referrer"></p><p><img height="418" src="https://oscimg.oschina.net/oscnet/up-4e497e6c1d9e0cb35dfd6f064c7ad2f7ea0.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:25:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268792</guid>
            <link>https://www.oschina.net/news/268792</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[助力 AI 開發，openKylin AI 框架安裝助手正式發佈！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0; margin-right:0; text-align:justify"><span>當前，以大模型為代表的人工智能技術迅猛發展，成為全球技術焦點，越來越多的開發者投入到人工智能技術的學習和應用中。AI 框架是 AI 算法模型設計、訓練和驗證的一套標準接口、特性庫和工具包，集成了算法的封裝、數據的調用以及計算資源的使用，同時面向開發者提供了開發界面和高效的執行平台，是現階段 AI 算法開發的必備工具。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span>目前在操作系統上安裝 AI 框架並不是件容易的事情，需要安裝合適的顯卡驅動、加速工具、依賴軟件以及配置系統環境等。每一個環節出問題都會導致 AI 框架安裝失敗。</span><strong><span>為了讓 AI 開發者能夠更快的投入到算法設計和 AI 開發當中，openKylin 社區 AI4OS SIG 組開發了 AI 框架安裝助手</span></strong><strong><span>，助力 AI 開發者實現一鍵安裝 AI 框架</span></strong><span>。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span>AI 框架安裝助手採用前後端分離架構：前端負責檢測系統硬件，自動推薦安裝方式，提供安裝選擇，獲取安裝選項，顯示安裝信息及進度；後端執行具體任務並向前端及時反饋信息。該架構提高了開發效率、可維護性和可擴展性，同時也提供了更好的用户體驗。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><strong><span>openKylin AI 框架安裝助手具有以下特點：</span></strong></p><ol><li><span style="color:#0052ff"><strong>智能推薦</strong></span>，用户只需選擇需要安裝的 AI 框架，應用根據系統硬件智能推薦最佳安裝方式，同時支持用户選擇。</li><li><span style="color:#0052ff"><strong>一鍵自動</strong></span>，軟件自動安裝最適合的硬件驅動，加速工具，依賴軟件，並且配置好系統環境。免去了繁複的安裝過程和系統環境配置。</li><li><span style="color:#0052ff"><strong>無需值守</strong></span>，由於網絡等原因造成的安裝失敗，能自動恢復繼續安裝。</li><li><span style="color:#0052ff"><strong>過程可見</strong></span><span>，軟件顯示安裝的各個步驟，以及各個步驟的進度等信息。</span></li><li><span style="color:#0052ff"><strong>節省資源</strong></span><span>，支持資源斷點繼續下載，過程斷點繼續安裝。</span></li><li><span style="color:#0052ff"><strong><span>支持</span>熱更新</strong></span><span>，確保能及時更新 AI 框架版本以及安裝方式，同時能以最快的速度解決軟件可能存在的 BUG。</span></li><li><span style="color:#0052ff"><strong>界面友好</strong></span><span>，採用簡潔、直觀的 AI 框架選項，並提供良好的安裝過程反饋。</span></li></ol><p style="text-align:center"><img alt="" height="1800" src="https://oscimg.oschina.net/oscnet/up-e6dc32eede425550f426b66a8c26400aaee.png" width="2880" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>目前，openKylin AI 框架安裝助手已上架至軟件商店。後續，AI4OS SIG 也將持續開發，優化 openKylin AI 框架安裝助手交互界面、支持更多主流 AI 框架及其套件等等，緊跟人工智能技術發展的潮流，更好地助力 AI 開發者！</span></p><p><span>AI4OS SIG 致力於為 openKylin 社區適配主流的 AI 框架，同時將人工智能（AI）與操作系統（OS）相結合，以實現 openKylin 操作系統的智能化和性能優化，歡迎感興趣的小夥伴加入！</span></p><ul><li><p style="margin-left:0; margin-right:0; text-align:justify"><span>項目地址：</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#0052ff">https://gitee.com/openkylin/ai-frame-installer</span></p></li><li><p><span>AI4OS SIG 主頁：</span></p><p><span style="color:#0052ff">https://gitee.com/openkylin/community/tree/master/sig/AI4OS</span></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268789</guid>
            <link>https://www.oschina.net/news/268789</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 正式宣佈 Sam Altman 迴歸擔任 CEO]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenAI 今天<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Fblog%2Fsam-altman-returns-as-ceo-openai-has-a-new-initial-board">正式宣佈</a></u>，Sam Altman 迴歸 OpenAI 擔任 CEO 一職。與此同時，Mira Murati 仍將繼續擔任 CTO 一職，Greg Brockman 也將繼續擔任 OpenAI 總裁。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a1347c1ff57c70bc945b594b050d3a5203b.png" referrerpolicy="no-referrer"></p><p>此外，OpenAI 成立全新董事會，董事會主席由 Bret Taylor 擔任。其他的董事會成員還包括 Larry Summers 以及 Adam D'Angelo。</p><p>Ilya Sutskever 、Tasha McCauley 以及 Helen Toner 將退出董事會。不過 Sam Altman 表示，<strong>正在討論如何讓 Ilya Sutskever 繼續在 OpenAI 工作</strong>。</p><p>OpenAI 還讓微軟以「<strong>無投票權觀察員</strong>」的身份加入董事會，他們將有更多機會瞭解公司的內部運作，但在重大決策中沒有正式投票權。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:17:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268788/altman-returns-as-ceo-openai-has-a-new-initial-board</guid>
            <link>https://www.oschina.net/news/268788/altman-returns-as-ceo-openai-has-a-new-initial-board</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[MobSlide —— 將智能手機變成演示文稿遙控器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>MobSlide 是一個可將你的將智能手機變成演示文稿遙控器的工具。</p><p><img alt="" height="225" src="https://static.oschina.net/uploads/space/2023/1122/142007_UPpG_4252687.png" width="300" referrerpolicy="no-referrer">&nbsp;<img alt="" height="225" src="https://static.oschina.net/uploads/space/2023/1122/142018_XS3R_4252687.png" width="300" referrerpolicy="no-referrer"></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>適用於 MacOS 和 Windows。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Tauri for Linux 不支持 webrtc，因此目前不支持 Linux</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>用法</strong></p><p><span style="background-color:#ffffff; color:#1f2328">使用智能手機掃描二維碼並打開鏈接。</span></p><p><img alt="" height="225" src="https://static.oschina.net/uploads/space/2023/1122/141937_4l9Z_4252687.png" width="300" referrerpolicy="no-referrer"></p><p><strong>特性：</strong></p><ul><li>掃描二維碼。無需安裝</li><li>輕量級應用程序<code>~2.5M</code></li><li>簡約而有效的設計</li></ul></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:16:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/mobslide</guid>
            <link>https://www.oschina.net/p/mobslide</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 內存型消息中間件 FolkMQ]]>
            </title>
            <description>
                <![CDATA[<h1 align="center"><a id="user-content---folkmq" class="anchor" href="https://gitee.com/noear/folkmq#--folkmq"></a>
  FolkMQ
</h1><p align="center"><strong>一個內存型消息中間件（支持快照持久化、Broker 集羣），目前為預覽階段</strong></p><p align="center"><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fsearch.maven.org%2Fartifact%2Forg.noear%2Ffolkmq"><img src="https://img.shields.io/maven-central/v/org.noear/folkmq.svg?label=Maven%20Central" alt="Maven" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.apache.org%2Flicenses%2FLICENSE-2.0.txt"><img src="https://img.shields.io/:license-Apache2-blue.svg" alt="Apache 2" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjavase-jdk8-downloads.html"><img src="https://img.shields.io/badge/JDK-8-green.svg" alt="jdk-8" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk11-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-11-green.svg" alt="jdk-11" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk17-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-17-green.svg" alt="jdk-17" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk21-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-21-green.svg" alt="jdk-21" referrerpolicy="no-referrer"></a><br><a target="_blank" href="https://gitee.com/noear/folkmq/stargazers"><img src="https://gitee.com/noear/folkmq/badge/star.svg" alt="gitee star" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fnoear%2Ffolkmq%2Fstargazers"><img src="https://img.shields.io/github/stars/noear/folkmq.svg?logo=github" alt="github star" referrerpolicy="no-referrer"></a></p><br><p align="center"><a href="https://gitee.com/link?target=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3DkjB5JNiC"><img src="https://img.shields.io/badge/QQ%E4%BA%A4%E6%B5%81%E7%BE%A4-870505482-orange" referrerpolicy="no-referrer"></a></p><hr><h2><a id="user-content-簡介" class="anchor" href="https://gitee.com/noear/folkmq#%E7%AE%80%E4%BB%8B"></a>簡介</h2><ul><li>採用，類似 Redis 的策略（內存運行 + 快照持久化）</li><li>功能，訂閲、取消訂閲、發佈消息、發佈定時消息、ACK，自動重試、延時策略、Qos0、Qos1</li><li>集羣，採用 Socket.D Broker 集羣模式</li><li>支持，使用 ws,udp 通訊（或許，也可用於物聯網）</li></ul><h2><a id="user-content-特點" class="anchor" href="https://gitee.com/noear/folkmq#%E7%89%B9%E7%82%B9"></a>特點</h2><ul><li>快、是真的快（大約 100_000 TPS）。有點像 Redis 之於 MySql。</li></ul><img src="https://gitee.com/noear/folkmq/raw/main/DEV-TEST.png" width="600" referrerpolicy="no-referrer"><p>//使用 MacBook pro 2020 + JDK8 本機測試，單客户端發與收（跑分難免有波動，我是選了好看點的）</p><ul><li>簡單的管理後台</li></ul><img src="https://gitee.com/noear/folkmq/raw/main/DEV-PREVIEW.png" width="600" referrerpolicy="no-referrer"><h3><a id="user-content-加入到社區交流羣" class="anchor" href="https://gitee.com/noear/folkmq#%E5%8A%A0%E5%85%A5%E5%88%B0%E7%A4%BE%E5%8C%BA%E4%BA%A4%E6%B5%81%E7%BE%A4"></a>加入到社區交流羣</h3><table><thead><tr><th>QQ 交流羣：316697724</th><th>微信交流羣（申請時輸入：FolkMQ）</th></tr></thead><tbody><tr><td></td><td><img src="https://gitee.com/noear/folkmq/raw/main/group_wx.png" width="120" referrerpolicy="no-referrer"></td></tr></tbody></table><h2><a id="user-content-開發過程視頻記錄" class="anchor" href="https://gitee.com/noear/folkmq#%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%A7%86%E9%A2%91%E8%AE%B0%E5%BD%95"></a>開發過程視頻記錄</h2><ul><li>開發過程視頻：<a href="https://gitee.com/noear/folkmq/blob/main/DEV-RECORD.md">《DEV-RECORD.md》</a></li><li>成果展示：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1mc411D7pY%2F">《[FolkMQ] 一個新的內存型消息隊列（快，特別的快）》</a></li><li>快速入門：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1Yj411L7fB%2F">《FolkMQ - Helloworld 入門》</a></li></ul><h2><a id="user-content-服務端容器鏡像" class="anchor" href="https://gitee.com/noear/folkmq#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F"></a>服務端容器鏡像</h2><table><thead><tr><th>鏡像</th><th>説明</th></tr></thead><tbody><tr><td>noearorg/folkmq-server:1.0.10</td><td>服務端（主端口：8602，消息端口：18602）</td></tr><tr><td>noearorg/folkmq-broker:1.0.10</td><td>服務端（主端口：8602，消息端口：18602）</td></tr></tbody></table><p>當使用 broker 集羣時，把 folkmq-server 端口改成：8601</p><ul><li>可選配置</li></ul><table><thead><tr><th>屬性或環境變量</th><th>默認值</th><th></th></tr></thead><tbody><tr><td><code>server.port</code></td><td>8602</td><td>主端口 (http，管理用)</td></tr><tr><td></td><td>18602</td><td>消息端口 (tcp)，等於主端口+10000</td></tr><tr><td><code>folkmq.admin</code></td><td>admin</td><td>管理密碼</td></tr></tbody></table><ul><li>添加消息訪問賬號：</li></ul><p>添屬性或環境變量，例： <code>folkmq.access.ak1=sk1</code>，<code>folkmq.access.ak2=sk2</code></p><h2><a id="user-content-helloworld" class="anchor" href="https://gitee.com/noear/folkmq#helloworld"></a>Helloworld</h2><h3><a id="user-content-1 啓動服務-更多部署參考部署説明" class="anchor" href="https://gitee.com/noear/folkmq#1%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1-%E6%9B%B4%E5%A4%9A%E9%83%A8%E7%BD%B2%E5%8F%82%E8%80%83%E9%83%A8%E7%BD%B2%E8%AF%B4%E6%98%8E"></a>1、啓動服務 (更多部署參考：<a href="https://gitee.com/noear/folkmq/blob/main/deploy">部署説明</a>)</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker run -p 18602:18602 -p 8602:8602 noearorg/folkmq-server:1.0.10 </span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-2 編寫客户端代碼" class="anchor" href="https://gitee.com/noear/folkmq#2%E7%BC%96%E5%86%99%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"></a>2、編寫客户端代碼</h3><ul><li>maven import</li></ul><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;dependencies&gt;</span></span><span id="LC2" class="line"><span class="c">&lt;!-- 可選包：java-tcp（90kb 左右）, smartsocket（260Kb 左右）, netty（2.5Mb 左右） --&gt;</span></span><span id="LC3" class="line"><span class="nt">&lt;dependency&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;groupId&gt;</span>org.noear<span class="nt">&lt;/groupId&gt;</span></span><span id="LC5" class="line"><span class="nt">&lt;artifactId&gt;</span>folkmq-transport-java-tcp<span class="nt">&lt;/artifactId&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;version&gt;</span>1.0.10<span class="nt">&lt;/version&gt;</span></span><span id="LC7" class="line"><span class="nt">&lt;/dependency&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;/dependencies&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><ul><li>client(consumer + producer) use</li></ul><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">public</span><span class="kd">class</span><span class="nc">ClientDemo1</span><span class="o">{</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kd">static</span><span class="kt">void</span><span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span><span class="n">args</span><span class="o">)</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC3" class="line"><span class="c1">//客户端（鑑權為可選。服務端，不添加則不鑑權）</span></span><span id="LC4" class="line"><span class="nc">MqClient</span><span class="n">client</span><span class="o">=</span><span class="nc">FolkMQ</span><span class="o">.</span><span class="na">createClient</span><span class="o">(</span><span class="s">"folkmq://127.0.0.1:18602?ak=folkmq&amp;sk=YapLHTx19RlsEE16"</span><span class="o">)</span></span><span id="LC5" class="line"><span class="o">.</span><span class="na">connect</span><span class="o">();</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="c1">//訂閲（consumer = ip or cluster name）</span></span><span id="LC8" class="line"><span class="n">client</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="s">"demo"</span><span class="o">,</span><span class="s">"demoapp"</span><span class="o">,</span><span class="n">message</span><span class="o">-&gt;</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">);</span></span><span id="LC10" class="line"><span class="o">});</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">//發佈</span></span><span id="LC13" class="line"><span class="n">client</span><span class="o">.</span><span class="na">publish</span><span class="o">(</span><span class="s">"demo"</span><span class="o">,</span><span class="s">"helloworld!"</span><span class="o">).</span><span class="na">get</span><span class="o">();</span></span><span id="LC14" class="line"><span class="o">}</span></span><span id="LC15" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-自動重試與延時策略" class="anchor" href="https://gitee.com/noear/folkmq#%E8%87%AA%E5%8A%A8%E9%87%8D%E8%AF%95%E4%B8%8E%E5%BB%B6%E6%97%B6%E7%AD%96%E7%95%A5"></a>自動重試與延時策略</h2><table><thead><tr><th>派發次數</th><th>自動延時</th><th></th></tr></thead><tbody><tr><td>0</td><td>0s</td><td>相當於馬上發</td></tr><tr><td>1</td><td>5s</td><td></td></tr><tr><td>2</td><td>30s</td><td></td></tr><tr><td>3</td><td>3m</td><td></td></tr><tr><td>4</td><td>9m</td><td></td></tr><tr><td>5</td><td>15m</td><td></td></tr><tr><td>6</td><td>30m</td><td></td></tr><tr><td>7</td><td>1h</td><td></td></tr><tr><td>n..</td><td>2h</td><td>第 8 次之後都是 2 小時</td></tr></tbody></table><h2><a id="user-content-客户端接口字典" class="anchor" href="https://gitee.com/noear/folkmq#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%8F%A3%E5%AD%97%E5%85%B8"></a>客户端接口字典</h2><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">//消息客户端接口</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kd">interface</span><span class="nc">MqClient</span><span class="o">{</span></span><span id="LC3" class="line"><span class="c1">//連接</span></span><span id="LC4" class="line"><span class="nc">MqClient</span><span class="nf">connect</span><span class="o">()</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC5" class="line"></span><span id="LC6" class="line"><span class="c1">//斷開連接</span></span><span id="LC7" class="line"><span class="kt">void</span><span class="nf">disconnect</span><span class="o">()</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">//客户端配置</span></span><span id="LC10" class="line"><span class="nc">MqClient</span><span class="nf">config</span><span class="o">(</span><span class="nc">ClientConfigHandler</span><span class="n">configHandler</span><span class="o">);</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">//自動回執</span></span><span id="LC13" class="line"><span class="nc">MqClient</span><span class="nf">autoAcknowledge</span><span class="o">(</span><span class="kt">boolean</span><span class="n">auto</span><span class="o">);</span></span><span id="LC14" class="line"></span><span id="LC15" class="line"><span class="c1">//訂閲主題</span></span><span id="LC16" class="line"><span class="kt">void</span><span class="nf">subscribe</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">consumer</span><span class="o">,</span><span class="nc">MqConsumeHandler</span><span class="n">consumerHandler</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC17" class="line"></span><span id="LC18" class="line"><span class="c1">//取消訂閲主題</span></span><span id="LC19" class="line"><span class="kt">void</span><span class="nf">unsubscribe</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">consumer</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC20" class="line"></span><span id="LC21" class="line"><span class="c1">//發佈消息</span></span><span id="LC22" class="line"><span class="k">default</span><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">{</span></span><span id="LC23" class="line"><span class="k">return</span><span class="nf">publish</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span><span class="n">content</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span></span><span id="LC24" class="line"><span class="o">}</span></span><span id="LC25" class="line"></span><span id="LC26" class="line"><span class="c1">//發佈消息</span></span><span id="LC27" class="line"><span class="k">default</span><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">,</span><span class="kt">int</span><span class="n">qos</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">{</span></span><span id="LC28" class="line"><span class="k">return</span><span class="nf">publish</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span><span class="n">content</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="n">qos</span><span class="o">);</span></span><span id="LC29" class="line"><span class="o">}</span></span><span id="LC30" class="line"></span><span id="LC31" class="line"><span class="c1">//發佈消息</span></span><span id="LC32" class="line"><span class="k">default</span><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">,</span><span class="nc">Date</span><span class="n">scheduled</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">{</span></span><span id="LC33" class="line"><span class="k">return</span><span class="nf">publish</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span><span class="n">content</span><span class="o">,</span><span class="n">scheduled</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span></span><span id="LC34" class="line"><span class="o">}</span></span><span id="LC35" class="line"></span><span id="LC36" class="line"><span class="c1">//發佈消息</span></span><span id="LC37" class="line"><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">,</span><span class="nc">Date</span><span class="n">scheduled</span><span class="o">,</span><span class="kt">int</span><span class="n">qos</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC38" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div>]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/noear/folkmq</guid>
            <link>https://gitee.com/noear/folkmq</link>
        </item>
        <item>
            <title>
                <![CDATA[關於 deepin V23 的發熱、續航問題，我們做了電源配置優化]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>之前一些用户反饋，在使用 deepin （深度）操作系統過程中遇到了 CPU 功耗過高導致的設備發熱、續航較差情況，而在這些負載場景下，CPU 的佔用往往不高。為瞭解決這個痛點，deepin 團隊特別成立專項計劃，對於 deepin 的電源進行專項優化。</p><p>在對電源進行專項優化之前，首先對 deepin （深度）操作系統進行了深入調查和分析，以瞭解其在負載場景下的實際運行情況。</p><p>經過對 CPU 使用率和功耗的監測，我們發現了一個令人驚訝的事實：儘管在高負載場景下 CPU 的佔用率不高，但其功耗卻持續升高，最終導致設備發熱並影響續航。也就是説，我們前期做的省電優化工作，不僅無效，還起了反作用。那麼到底該如何解決這一問題呢？</p><p>在剛剛結束的 DDUC 2023 上，deepin（深度）社區用户 fslong 從社區參與共創的角度，分享了幫助 deepin 團隊一起完成優化工作的故事。那麼，本文就讓我們從 deepin 團隊研發工程師的角度來回顧解決這一問題的歷程吧！</p><h2><strong>&nbsp;找到問題的根源&nbsp;</strong></h2><p><strong>1.內核</strong><br> 最開始發現問題的地方在內核。有用户將 deepin 的內核和 Ubuntu 的內核進行對比後發現，雖然二者性能相差無幾，但是在發熱和續航上，較 Ubuntu 落後較多。有用户在 deepin （深度）操作系統上使用 Ubuntu 和其他開源 Linux 發行版的配置文件分別編譯內核，發現 deepin 的主要問題在於發熱控制上。deepin 團隊的測試夥伴高度重視這一社區反饋，對該問題進行復現，佐證了這一現象。</p><p>於是，我們立即聯繫了內核研發的夥伴，並邀請部分對內核配置有一定研究的社區用户共同參與，合力排查後發現，deepin V23 中提供的 HWE 內核存在部分 debug 和無用的內核選項被開啓的情況，並且部分節電功能實際未能獲得啓用，這些都在一定程度上導致了 deepin V23 的續航表現不佳。</p><p><strong>2. 系統</strong><br> 系統層面，重新審視了 dde-daemon 提供的電源調度模塊，並且對比內核文檔提供的文件接口，分析用户使用的電源模式，發現其中存在可以優化的空間。這是本文着重講解的內容之一。</p><h2><strong>一些前置知識&nbsp;</strong></h2><h3><strong>1.ACPI</strong></h3><p>ACPI（Advanced Configuration and Power Interface）是一種計算機硬件和操作系統之間交換能源相關信息的接口規範。它定義了計算機硬件的能源相關信息，如電源供應器狀態、設備功耗、設備功率因數等。ACPI 是操作系統控制計算機硬件能源管理的標準，同時也是硬件廠商和操作系統之間通信的標準。<br> 在 deepin （深度）操作系統中，ACPI 負責處理計算機硬件的能源管理，與電源管理模塊進行交互，以實現對計算機硬件的能源管理。</p><p>在分析系統層面的問題時，需要了解 ACPI 和電源管理模塊的作用和功能，以及它們是如何協同工作的。本文將會詳細講解 ACPI 的工作原理以及 deepin （深度）操作系統中的電源調度模塊工作模式，並提出可行優化建議。</p><p>ACPI 的工作原理是：當計算機硬件發生電源變化時，ACPI 會收集硬件信息，並向操作系統發送電源請求。操作系統收到電源請求後，會根據用户配置自動調整各個硬件的電源策略。</p><p>deepin （深度）操作系統的電源模塊則是幫助用户生成配置來調整 ACPI 的行為。所以在這一方面，我們能做的就是向 ACPI 提供合理的電源策略，在保證性能的同時，降低設備温度並提升續航表現。</p><h3><strong>2.平台電源配置</strong></h3><p>相關內核文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.kernel.org%2Fuserspace-api%2Fsysfs-platform_profile.html" target="_blank">https://docs.kernel.org/userspace-api/sysfs-platform_profile.html</a></p><p>UEFI ACPI 文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fuefi.org%2Fhtmlspecs%2FACPI_Spec_6_4_html%2Findex.html" target="_blank">https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/index.html</a></p><p>平台電源配置是電源管理模塊的重要組成部分，用於管理計算機平台硬件（指所有支持 ACPI 的設備）的電源狀態。CPU 也屬於 ACPI 設備的一部分，不過 CPU 是計算機的核心發熱大户，對於其使用平台電源管理可能粒度較粗，所以 APCI 引入了一些 CPU 獨有的性能管理方式，在下一小節將詳細説明。</p><p>平台電源配置提供了三種可選模式：performance（性能模式），balance（平衡模式），low-power（節能模式）。一般情況下，用户使用平衡模式就可以。在台式機和 mini 主機類（對於功耗和發熱沒有任何要求）設備上默認提供性能模式，在筆記本等移動設備上默認提供平衡模式。默認不提供節能模式，因為某些 ACPI 設備在節能模式工作過程中可能出現「睡死現象」，所以為了避免此問題，默認不提供 low-power 節電模式。</p><h3><strong>3.CPU 電源配置</strong></h3><p>傳統電源模式（SCalling）內核文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.kernel.org%2Fdoc%2Fhtml%2Fv6.1%2Fadmin-guide%2Fpm%2Fcpufreq.html" target="_blank">https://www.kernel.org/doc/html/v6.1/admin-guide/pm/cpufreq.html</a></p><p>Intel PState 內核文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.kernel.org%2Fdoc%2Fhtml%2Fv6.1%2Fadmin-guide%2Fpm%2Fintel_pstate.html" target="_blank">https://www.kernel.org/doc/html/v6.1/admin-guide/pm/intel_pstate.html</a></p><p>AMD PState 內核文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.kernel.org%2Fadmin-guide%2Fpm%2Famd-pstate.html" target="_blank">https://docs.kernel.org/admin-guide/pm/amd-pstate.html</a></p><p>如果有時間，可以自行研讀上述電源文檔，就很容易理解 CPU 電源配置相關內容。作者在這裏的講述將忽略大量技術細節和實現方式，僅表述如何調整 CPU 的電源模式。</p><p>在 /sys/devices/system/cpu/cpufreq 目錄下有許多文件名為 policy&lt;x&gt;（x 代表核心編號），這些文件對應着電腦上的 CPU 核心，而 CPU 的電源調度細節就在這些文件夾裏。在 policy&lt;x&gt; 目錄下有一個文件`scaling_driver`，使用 cat 或其他方式訪問它，得到的結果就是當前使用的調度器：</p><ul><li>intel_cpufreq / acpi_cpufreq : 使用 scaling freq 調度；</li><li>intel_pastate : 使用 Intel PState 調度；</li><li>amd-pstate : 使用 AMD PState 調度。</li></ul><p><strong>&nbsp;scalling freq 調度</strong></p><p>這是最傳統的 CPU 調度方式，可以在 policy 文件夾下的 scaling_available_governors 獲取可選電源模式：</p><p style="text-align:center"><img height="742" src="https://oscimg.oschina.net/oscnet/up-30d23181f6f0f60ab32af9f63d163238aa5.png" width="765" referrerpolicy="no-referrer"></p><p>其實這些平衡模式的作用都是是一樣的：平衡性能和續航，不過使用的算法可能不同。</p><p><strong>Intel PState</strong></p><p>這是 Intel 近幾代 CPU 獨享的 moment，內核開啓 Intel PState 後（deepin V23 內核默認開啓），在 policy 文件夾下多了幾個文件：</p><p>我們只需要關注：</p><ul><li>energy_performance_available_perference : 可用的 PState 電源調度；</li><li>energy_performance_perference：當前選定的 PState 電源調度，可以更改此文件內容來更改電源調度。</li></ul><p>在 Intel PState 中出現了兩個新的調度方案：</p><ul><li>balance_performance : 平衡偏性能，平時工作頻率不高，在負載增大時能快速響應；</li><li>balance_power : 平衡偏節能，電源策略較為保守，在部分電腦上還有 default 方案，此方案就是經過 PState 優化過的 balance 策略。具體 PState 使用的黑魔法以及主動模式和被動模式的調度策略，可以參照內核文檔進行分析。</li></ul><p><strong>AMD PState</strong></p><p>這是 AMD ZEN2 以上用户，以及支持 kernel 6.4.x 用户獨享的 moment。其實 AMD 在 6.1 內核已經做了 PState 的支持，不過是被動模式。</p><ul><li>（Actvie Mode）主動模式</li></ul><p>Active Mode 僅在內核版本大於 6.4 以上，且內核選項打開 AMD PState 時可用。可能需要在 grub 內加入啓動參數以打開此功能：amd_pstate=active，也可以修改文件實現 Active Mode 的電源策略和 Intel PStatewi 類似。</p><ul><li>（Passive Mode）被動模式</li></ul><p>Passtive Mode 僅在內核大於 6.1 以上，且內核選項打開 AMD PState 時可用。可能需要在 grub 加入啓動參數開啓此功能：amd_pstate=passive，也可修改文件實現。</p><p>Passive Mode 提供兩種電源模式，在/sys/device/system/cpu/cpufreq/scaling_governor 文件進行調整：</p><p>（1）performance 使用 platform_profile 進行配置，調度積極性較高；<br> （2）scheutils 在/sys/device/system/cpu/cpufreq/schedutil/rate_limit_us 文件中調整調度粒度（兩次調度的間隔時間）和 ACPI 的 scheutils 類 &nbsp;/sys/device/system/cpu/cpufreq/scaling_governor 。</p><ul><li>（Guided Mode）引導模式</li></ul><p>Guided Mode 僅在內核大於 6.1 以上，且內核選項打開 AMD PState 時可用。可能需要在 grub 加入啓動參數開啓此功能：amd_pstate=guided，也可修改文件實現。這就類似汽車的自動擋，驅動程序請求最低和最大性能級別，平台自動選擇此範圍內適合當前工作負荷的性能級別。</p><h3><strong>4.GPU 電源管理部分</strong></h3><p><strong>&nbsp;AMD GPU</strong></p><p>如果是 AMD GPU 則需要更改兩個文件（使用 tee 命令進行寫入）：</p><ul><li>/sys/class/drm/card0/device/power_dpm_state（這是一個遺留接口，目的是向後兼容）；</li><li>performance 高性能模式；</li><li>balance 平衡模式；</li><li>battery 節能模式；</li><li>/sys/class/drm/card0/device/power_dpm_force_performance_level 。</li></ul><p>以下設置來自 AMD 官方驅動文檔：</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdri.freedesktop.org%2Fdocs%2Fdrm%2Fgpu%2Famdgpu.html%23power-dpm-force-performance-level" target="_blank">https://dri.freedesktop.org/docs/drm/gpu/amdgpu.html#power-dpm-force-performance-level</a></p><pre><code>power_dpm_force_performance_level:</code></pre><p>AMD GPU 驅動程序提供了一個 sysfs API，用於調整某些與功率相關的參數。文件 power-dpm-force-performance-level 將用於執行此操作。它接受以下參數：</p><ul><li>auto：當選擇 auto 時，設備將嘗試針對驅動中的當前條件動態選擇最佳功率曲線；</li><li>low：當選擇低時，GPU 被強制到最低功率狀態；</li><li>high：當選擇高時，GPU 被強制到最高功率狀態；</li><li>manual：當選擇手動時，用户可以通過 sysfs pp_dpm_mclk、pp_dpm_sclk 和 pp_dpm_pcie 文件手動調整每個時鐘域啓用的電源狀態，並通過 pp_power_profile_mode sysfs 文件調整電源狀態轉換方式；</li><li>profile_standard 固定時鐘級別分析模式。此模式將時鐘設置為固定級別，該級別因 ASIC 而異。這對於分析特定工作負載很有用（不常用）；</li><li>profile_min_sclk 最小 SCLK 分析模式。此模式將 SCLK 強制設置為最低級別。這對於分析最小功耗的場景很有用（不常用）；</li><li>profile_min_mclk 最小 MCLK 分析模式。此模式將 MCLK 強制設置為最低級別。這對於分析最小功耗的場景很有用（不常用）；</li><li>profile_peak 峯值分析模式。此模式將所有時鐘（MCLK、SCLK、PCIe）設置為最高級別。這對於分析最大性能的場景很有用（不常用）。</li></ul><p><strong>測試：</strong></p><ul><li>Low 模式的跑分</li></ul><p style="text-align:center"><img height="527" src="https://oscimg.oschina.net/oscnet/up-a7c7db000560426ab1a9b7c748e27c0a1b7.png" width="905" referrerpolicy="no-referrer"></p><ul><li>Auto 模式的跑分</li></ul><p style="text-align:center"><img height="368" src="https://oscimg.oschina.net/oscnet/up-5bb4cd6ed50bbcdc27d0be3b221b6393b32.png" width="715" referrerpolicy="no-referrer"></p><ul><li><p>High 模式的跑分</p></li></ul><p><img height="482" src="https://oscimg.oschina.net/oscnet/up-34be1d83b01eab80986cba3af73de7fbe2d.png" width="885" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><strong>Intel GPU</strong></p><p>Intel GPU 使用的 i915 驅動，並不希望你對其做出調整，因為其驅動自帶的電源策略已經足夠聰明。不過你也可以通過 Intel 提供的 intel-gpu-tools 進行調整和獲取信息。</p><pre><code>sudo apt install intel-gpu-tools &nbsp; </code></pre><p>然後使用</p><pre><code>sudo intel_gpu_frequency</code></pre><p>來獲取當前頻率（當前使用的是 Intel A750）。</p><p style="text-align:center"><img height="133" src="https://oscimg.oschina.net/oscnet/up-8f915468117bd14d8fe8cefa8f8035b08d6.png" width="594" referrerpolicy="no-referrer"></p><p>可以看到 Intel 的顯卡驅動是在 600 MHz 到 2400 MHz 之間動態調整（如上圖）。</p><p>測試筆記本下 Intel 核顯跑分如下：</p><p style="text-align:center"><img height="490" src="https://oscimg.oschina.net/oscnet/up-97908337d81f9e30651c110d9dddbf88129.png" width="732" referrerpolicy="no-referrer"></p><p><strong>NVIDIA</strong></p><p>由於 NVIDIA 驅動不開源，所以在系統層面無法對其做控制。</p><h2><strong>應用級別的省電&nbsp;</strong></h2><p>應用級別的省電，應該就是在保證用户使用流暢度的情前提下節省性能。之前也有用户提出過，是否能參照某手機廠商的不公平調度算法來實現優化，畢竟安卓系統的底層也是 Linux，理論上實現難度不大。</p><p>Cgroups，全稱 Control Groups，是 Linux 內核提供的一種資源管理機制，用於對進程分組並對其資源進行限制和隔離。Cgroups 可以用於限制進程的 CPU、內存、磁盤、網絡等資源，也可以用於限制進程的優先級和 IO 權限。利用其提供的能力，很容易實現類似不公平調度算法（新的 AM 天然支持 Cgroups 的操作），但是還有一些顧慮：</p><ul><li>不同於手機操作系統，計算機操作系統是多任務並行的，在多數窗口管理器下，我們並沒有一個明顯的前台應用，此時使用不公平調度可能存在隱患；</li><li>容易引發人機對抗。在我的觀念裏面，計算機是為人服務的，那麼用户的意志必定是第一優先級，所以我們不應改變用户的行為，如果使用不平衡調度和用户預期不一致，會極大降低用户體驗；</li><li>使用前後台區分應用，可能導致開銷和收益比下降，性價比不高。Linux 桌面不像安卓設備有明顯前後台，用户頻繁切換應用的操作將導致調度器頻繁切換調度，使得開銷過大。最佳的解決方案是：提供能力，但不提供方案。可以提供基於 Cgroups 方式修改應用組的優先級，然後讓用户自己選擇什麼應用優先級更高，什麼應用優先級低，以實現調度（比如在 dock 上右鍵選擇優先級）或提供一套配置以供用户自由選擇。</li></ul><p>如果一個電腦需要使用不平衡調度來保證使用流暢性，可能這並不是一個操作系統能解決的問題，而更應該考慮硬件是否需要更換，以保證多任務使用的流暢性。</p><h4><strong>附錄——常用的調試測試工具</strong></h4><p>1. S-tui</p><p>可以看到 CPU 頻率變化，配合 stress 可以對 CPU 進行壓力測試。</p><p style="text-align:center"><img height="553" src="https://oscimg.oschina.net/oscnet/up-9035dd7df12eda9d831c879f89d1e2f3230.png" width="1025" referrerpolicy="no-referrer"></p><p>2. intel-gpu-tools</p><p>可以使用 intel_gpu_frequency 來獲取和調整 i965 的驅動頻率。</p><p>3. GLMark2</p><p>GPU 跑分軟件。</p><p>4. stress-ng</p><p>CPU 壓力測試軟件。</p><p>5. PowerTOP</p><p>電源測試軟件，可以看到電源的功耗和使用情況。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268783</guid>
            <link>https://www.oschina.net/news/268783</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | Promise 規範與原理解析]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><span><span>摘要</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Promise 對象用於清晰的處理異步任務的完成，返回最終的結果值，本次分享主要介紹 Promise 的基本屬性以及 Promise 內部的基礎實現，能夠幫我們更明確使用場景、更快速定位問題。</span></span></span></p><span id="OSC_h1_2"></span><h1><span><span><span>Promise 出現的原因</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>首先我們先來看一段代碼：異步請求的層層嵌套</span></span></span></p><pre><code><span><span><span>function fn1(params) {
  const xmlHttp = new XMLHttpRequest();
  xmlHttp.onreadystatechange = function(){
    if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
      const fn1Data = {name: 'fn1'}
      console.log(fn1Data, 'fn1Data');
      // 請求 2
      (function fn2() {
        xmlHttp.onreadystatechange = function(){
        if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
          const fn2Data = {name: `${fn1Data.name}-fn2`}
          console.log(fn2Data, 'fn2Data');
          // 請求 3
          (function fn2() {
            xmlHttp.onreadystatechange = function(){
            if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
              const fn3Data = {name: `${fn2Data.name}-fn3`}
              console.log(fn3Data, 'fn3Data');
            }
          }
          xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
          xmlHttp.send();
          })()
        }
      }
      xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
      xmlHttp.send();
      })()
    }
  }
  xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
  xmlHttp.send();
}

fn1()

</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>或者我們可以將上面的代碼優化為下面這樣</span></span></span></p><pre><code><span><span><span>function fn1(params) {
  console.log(`我是 fn1，我在函數${params}中執行！！！`);
}
  
function fn2(params) {
  try {
    const xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function(){
      if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
        console.log(`我是 fn2，我在函數${params}中執行！！！結果是：`,params.data);
        fn1('fn2')
      }
    }
    xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
    xmlHttp.send();
  } catch (error) {
    console.error(error);
  }
}
  
function fn3() {
  try {
    const xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function(){
      if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
          console.log('fn3 請求已完成');
          fn2('fn3')
      }
    }
    xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
    xmlHttp.send();
    console.log('我是 f3 函數呀');
  } catch (error) {
    console.error(error);
  }
}
  
fn3()

</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>由上面的兩種寫法的請求可見，在 promise 之前，為了進行多個異步請求並且依賴上一個異步請求的結果時，我們必須進行層層嵌套，大多數情況下，我們又對異步結果進行數據處理，這樣使得我們的代碼非常難看，並且難以維護，這就形成了回調地獄，由此 Promise 開始出現了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>回調地獄缺點</span></span></span></p><ul><li><span><span><span><span>代碼臃腫</span></span></span></span></li><li><span><span><span><span>可讀性差</span></span></span></span></li><li><span><span><span><span>耦合性高</span></span></span></span></li><li><span><span><span><span>不好進行異常處理</span></span></span></span></li></ul><span id="OSC_h1_3"></span><h1><span><span><span>Promise 的基本概念</span></span></span></h1><span id="OSC_h3_4"></span><h3><span><span><span>含義</span></span></span></h3><ol><li><span><span><span><span>ES6 將其寫進了語言標準裏統一了用法，是一個構造函數，用來生成 Promise 實例</span></span></span></span></li><li><span><span><span><span>參數為一個執行器函數 (執行器函數是立即執行的),該函數有兩個函數作為參數，第一個參數是成功時的回調,第二個參數是失敗時的回調</span></span></span></span></li><li><span><span><span><span>函數的方法有 resolve(可以處理成功和失敗)、reject(只處理失敗)、all 等方法</span></span></span></span></li><li><span><span><span><span>then、catch、finally 方法為 Promise 實例上的方法</span></span></span></span></li></ol><span id="OSC_h3_5"></span><h3><span><span><span>狀態</span></span></span></h3><ol><li><span><span><span><span>pending --- 等待狀態</span></span></span></span></li><li><span><span><span><span>Fulfilled --- 執行狀態 （resolve 回調函數，then）</span></span></span></span></li><li><span><span><span><span>Rejected --- 拒絕狀態 (reject 回調函數，catch)</span></span></span></span></li><li><span><span><span><span>狀態一旦改變就不會再變，狀態只可能是兩種改變，從 pending-&gt;Fulfilled，pending-&gt;Rejected</span></span></span></span></li><li><span><span><span><span>有兩個關鍵的屬性：PromiseState --- 狀態改變，PromiseResult --- 結果數據改變</span></span></span></span></li></ol><pre><code><span><span><span>const p1 = Promise.resolve(64)
const p2 = Promise.reject('我錯了')
const p3 = Promise.then()
const p4 = Promise.catch()

// 狀態改變 PromiseState 結果改變 PromiseResult
console.log(new Promise(()=&gt;{}), 'Promise');  // PromiseState='pending' PromiseResult=    
console.log(p1,'p1');  // PromiseState='Fulfilled' PromiseResult=64
console.log(p2,'p2');  // PromiseState="Rejected" PromiseResult='我錯了'
console.log(p3, 'p3'); // then 為實例上的方法，報錯
console.log(p4, 'p4');  // catch 為實例上的方法，報錯
</span></span></span></code></pre><div><img alt="" height="457" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-14-14-59d8dPWcg59hoiOwx59.png" width="705" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h3_6"></span><h3><span><span><span>特點</span></span></span></h3><div><span>1.</span><span><span><span><span>錯誤信息清晰定位：可以在外層捕獲異常信息（網絡錯誤、語法錯誤都可以捕獲），有「冒泡」性質，會一直向後傳遞，直到被捕獲，所以在最後寫一個 catch 就可以了</span></span></span></span></div><div><span>2.</span><span><span><span><span>鏈式調用：每一個 then 和 catch 都會返回一個新的 Promise，把結果傳遞到下一個 then/catch 中，因此可以進行鏈式調用 --- 代碼簡潔清晰</span></span></span></span></div><span id="OSC_h3_7"></span><h3><span><span><span>結果由什麼決定</span></span></span></h3><span id="OSC_h4_8"></span><h4><span><span><span>resolve</span></span></span></h4><ol><li><span><span><span><span>如果傳遞的參數是非 Promise 類型的對象，則返回的結果是成功狀態的 Promise 對象，進入下一個 then 裏面</span></span></span></span></li><li><span><span><span><span>如果傳遞的參數是 Promise 類型的對象，則返回的結果由返回的 Promise 決定，如果返回的是 resolve 則是成功的狀態，進入下一個 then 裏，如果返回的是 reject 則是失敗的狀態，進入下一個 catch 裏</span></span></span></span></li></ol><span id="OSC_h4_9"></span><h4><span><span><span>reject</span></span></span></h4><ol><li><span><span><span><span>如果傳遞的參數是非 Promise 類型的對象，則返回的結果是拒絕狀態的 Promise 對象，進入下一個 catch 裏面或者是下一個 then 的第二個參數 reject 回調裏面</span></span></span></span></li><li><span><span><span><span>如果傳遞的參數是 Promise 類型的對象，則返回的結果由返回的 Promise 決定，如果返回的是 resolve 則是成功的狀態，進入下一個 then 裏，如果返回的是 reject 則是拒絕的狀態，進入下一個 catch 裏面或者是下一個 then 的第二個參數 reject 回調裏面</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這在我們自己封裝的 API 裏面也有體現：為什麼 code 為 1 時都是 then 接收，其他都是 catch 接收，就是因為在 then 裏面也就是 resolve 函數中對 code 碼進行了判斷，如果是 1 則返回 Promise.resolve()，進入 then 裏處理，如果是非 1 則返回 Promise.reject()，進入 catch 裏處理。</span></span></span></p><span id="OSC_h3_10"></span><h3><span><span><span>流程圖</span></span></span></h3><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-14-14-59rKXgoFvRLU89IXE.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h3_11"></span><h3><span><span><span>簡單使用</span></span></span></h3><pre><code><span><span><span>// 模擬一個 promise 的 get 請求
let count = 0
function customGet(url){
    count += 1
    return new Promise((resolve, reject)=&gt;{
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.open("GET",url, true);
        xmlHttp.onload = ()=&gt;{
          console.log(xmlHttp, 'xmlHttp---onload');
          if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
            console.log('customGet 請求成功了');
            // 返回非 Promise，結果為成功狀態
            resolve({data:`第${count}次請求獲取數據成功`})

            // 返回 Promise，結果由 Promise 決定
            // resolve(Promise.reject('resolve 中返回 reject'))
          } else {
            reject('customGet 請求錯誤了')
          }
        }

        // Promise 狀態改變就不會再變
        // onreadystatechange 方法會被執行四次
        // 當地次進來的時候，readyState 不等於 4，執行 else 邏輯，執行 reject，狀態變為 Rejected，所以即使再執行 if，狀態之後不會再改變
        // xmlHttp.onreadystatechange = function(){
        //   console.log(xmlHttp,'xmlHttp---onreadystatechange')
        //   if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
        //     console.log('customGet 請求成功了');
        //     resolve({data:`第${count}次請求獲取數據成功`})
        //   } else {
        //     reject('customGet 請求錯誤了')
        //   }
        // }
        xmlHttp.send();
      })
 }

// 使用 Promise，並且進行鏈式調用
customGet('https://v0.yiketianqi.com/api/cityall?appid=&amp;appsecret=').then((res)=&gt;{
   console.log(res.data);
   return '第一次請求處理後的數據'
}).then((data)=&gt;{
   console.log(data)
   // console.log(data.toFixed());
   return customGet('https://v0.yiketianqi.com/api/cityall?appid=&amp;appsecret=')
}).then((res)=&gt;{
   console.log(res.data);
}).catch((err)=&gt;{
    // 以類似'冒泡'的性質再外層捕獲所有的錯誤
   console.error(err, '這是 catch 裏的錯誤信息');
})

</span></span></span></code></pre><span id="OSC_h3_12"></span><h3><span><span><span>手寫實現簡單的 Promise</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>通過上面的回顧，我們已經瞭解了 Promise 的關鍵屬性和特點，下面我們一起來實現一個簡單的 Promise 吧</span></span></span></p><pre><code><span><span><span>  // 1、封裝一個 Promise 構造函數，有一個函數參數
  function Promise(executor){
    // 7、添加對象屬性 PromiseState PromiseResult
    this.PromiseState = 'pending'
    this.PromiseResult = null

    // 14、創建一個保存成功失敗回調函數的屬性
    this.callback = null

    // 8、this 指向問題
    const that = this

    // 4、executor 有兩個函數參數（resolve，reject）
    function resolve(data){
      // 10、Promise 狀態只能修改一次（同時記得處理 reject 中的狀態）
      if(that.PromiseState !== 'pending') return

      // console.log(this, 'this');
      // 5、修改對象的狀態 PromiseState
      that.PromiseState = 'Fulfilled'

      // 6、修改對象的結果 PromiseResult
      that.PromiseResult = data

      // 15、異步執行 then 裏的回調函數
      if(that.callback?.onResolve){
        that.callback.onResolve(that.PromiseResult)
      }
    }
    function reject(data){
      console.log(that.PromiseState, 'that.PromiseState');
      if(that.PromiseState !== 'pending') return

      // 9、處理失敗函數狀態
      that.PromiseState = 'Rejected'
      that.PromiseResult = data
      console.log(that.PromiseResult, 'that.PromiseResult');
      console.log(that.PromiseState, 'that.PromiseState');

      // 16、異步執行 then 裏的回調函數
      if(that.callback?.onReject){
        that.callback.onReject(that.PromiseResult)
      }
    }
    // 3、執行器函數是同步調用的，並且有兩個函數參數
    executor(resolve,reject)
  }
  // 2、函數的實例上有方法 then
  Promise.prototype.then = function(onResolve,onReject){
    // 20、處理 onReject 沒有的情況
    if(typeof onReject !== 'function'){
      onReject = reason =&gt; {
        throw reason
      }
    }
    // 21、處理 onResolve 沒有的情況
    if(typeof onResolve !== 'function'){
      onResolve = value =&gt; value
    }
    // 17、每一個 then 方法都返回一個新的 Promise，並且把上一個 then 返回的結果傳遞出去
    return new Promise((nextResolve,nextReject)=&gt;{
      // 11、處理成功或失敗
      if(this.PromiseState === 'Fulfilled'){
        // 12、將結果傳遞給函數
        // onResolve(this.PromiseResult)

        // 18、拿到上一次執行完後返回的結果,判斷是不是 Promise
        const result = onResolve(this.PromiseResult)
        if(result instanceof Promise){
          result.then((v)=&gt;{
            nextResolve(v)
          },(r)=&gt;{
            nextReject(r)
          })
        } else {
          nextResolve(result)
        }
      }
      // 當你一步步寫下來的時候有沒有懷疑過為什麼不用 else
       if(this.PromiseState === 'Rejected'){
            // 第 12 步同時處理此邏輯
            // onReject(this.PromiseResult)

            // 22、處理 catch 異常穿透捕獲錯誤
            try {
              const result = onReject(this.PromiseResult)
              if(result instanceof Promise){
                result.then((v)=&gt;{
                  nextResolve(v)
                }).catch((r)=&gt;{
                  nextReject(r)
                })
              } else {
                nextReject(result)
              }
            } catch (error) {
              nextReject(this.PromiseResult)
            }
         }
  
      // 13、異步任務時處理成功或失敗,想辦法等異步任務執行完成後才去執行這兩個函數
      if(this.PromiseState === 'pending'){
        this.callback = {
          onResolve,
          onReject
        }
        console.log(this.callback, 'this.callback');
      }
    })
  }
  // 19、函數實例上有方法 catch
  Promise.prototype.catch = function(onReject) {
    return this.then(null,onReject)
  }

  // 使用自定義封裝的 Promise
  const customP = new Promise((resolve,reject)=&gt;{
    // 模擬異步執行請求
    // const xmlHttp = new XMLHttpRequest();
    // xmlHttp.open("GET",'https://v0.yiketianqi.com/api/cityall?appid=&amp;appsecret=', true);
    // xmlHttp.onload = ()=&gt;{
    //   if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
    //     resolve('success')
    //   } else {
    //     reject('error')
    //   }
    // }
    // xmlHttp.send();

    // 同步執行
    resolve('success')
    // reject('error')
  })

  console.log(customP, 'customP');
  customP.then((res)=&gt;{
    console.log(res, 'resolve 回調');
    return '第一次回調'
    // return new Promise((resolve,reject)=&gt;{
    //   reject('錯錯錯')
    // })
  },(err)=&gt;{
    console.error(err, 'reject 回調');
    return '2121'
  }).then(()=&gt;{
    console.log('then 裏面輸出');
  }).then().catch((err)=&gt;{
    console.error(err, 'catch 裏的錯誤');
  })

</span></span></span></code></pre><span id="OSC_h4_13"></span><h4><span><span><span>針對 resolve 中返回 Promise 對象時的內部執行順序</span></span></span></h4><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-14-15-00IiDMseqfyk0DroM.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_14"></span><h1><span><span><span>總結</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>以上就是我們常用的 Promise 基礎實現，在實現過程中對比了 Promise 和函數嵌套處理異步請求的優缺點，Promise 仍存在缺點，但是的確方便很多，同時更清晰的理解到錯誤處理如何進行異常穿透的，也能幫助我們更規範的使用 Promise 以及快速定位問題所在。</span></span></span></p><blockquote><p>作者：京東物流&nbsp;孫琦</p><p>來源：京東雲開發者社區，自猿其説 Tech 轉載請註明來源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10150936</guid>
            <link>https://my.oschina.net/u/4090830/blog/10150936</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[國內首個農業開源鴻蒙操作系統]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0px; margin-right:0px; text-align:start">11 月 29 日，在全球首個以供應鏈為主題的國家級展會——中國國際供應鏈促進博覽會上，中信農業科技股份有限公司（簡稱「中信農業」）聯合深圳開鴻數字產業發展有限公司（簡稱「深開鴻」）、華為技術有限公司（簡稱「華為」）正式對外發布了<strong>國內首個自主可控的農業開源鴻蒙操作系統。</strong></p><p style="margin-left:0px; margin-right:0px; text-align:start">據介紹，農業開源鴻蒙是致力於維護農業數據安全，打造自主可控的農業操作系統。</p><p><img src="https://static.oschina.net/uploads/space/2023/1129/170904_6My8_2720166.png" referrerpolicy="no-referrer"></p><p>下圖是農業開源鴻蒙操作系統的演示：</p><p><img height="906" src="https://static.oschina.net/uploads/space/2023/1129/171101_l9cl_2720166.png" width="2232" referrerpolicy="no-referrer"></p><p><img height="928" src="https://static.oschina.net/uploads/space/2023/1129/171017_86bC_2720166.png" width="2226" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-116c65e954d843c9b90f6fb5ba8f83258c5.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-c8e4bc96284803ab6547db6797684372387.png" referrerpolicy="no-referrer"></p><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fj4EIO_8RPUdwqLJBhsozAQ" target="_blank">https://mp.weixin.qq.com/s/j4EIO_8RPUdwqLJBhsozAQ</a></u></em></p><p>深開鴻 CEO 王成錄博士介紹道，農業開源鴻蒙操作系統是基於 KaihongOS 的新一代面向數字農業領域的萬物智聯操作系統，為大小不一、類型多樣設備的互聯和協同提供統一的數字底座，讓所有農業設備都用統一的操作系統，講同一種語言，而且全棧關鍵核心技術均為國產自主研發，從底層操作系統源頭上保證了數據的安全可靠。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 09:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268706</guid>
            <link>https://www.oschina.net/news/268706</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Go 語言微服務框架重磅升級：dubbo-go v3.2.0 -alpha 版本預覽]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:justify">隨着 Dubbo3 在雲原生微服務方向的快速發展，Dubbo 的 go 語言實現迎來了 Dubbo3 版本以來最全面、最大幅度的一次升級，這次升級是全方位的，涉及 API、協議、流量管控、可觀測能力等。總的來説，新版本的 dubbo-go：</p><ul><li><strong>全面升級 Triple 協議，</strong>兼容 gRPC、標準 HTTP 客户端，提供簡單明瞭的 API 用於編寫 RPC server 與 client，解決組件間的基本通信問題。</li><li><strong>針對微服務場景，提供了完善的服務治理能力，</strong>這包括配置管理、可觀測性、流量管控規則、生態集成與適配等的全面升級。</li></ul><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-c4c6b5317adb83a4b234eb8fcd15d8c9_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h3_1"></span><h3>全新升級的 Triple 協議</h3><p style="text-align:justify">基於 dubbo-go 實現的 Triple 協議，你可以輕鬆編寫瀏覽器、gRPC 兼容的 RPC 服務，並讓這些服務同時運行在 HTTP/1 和 HTTP/2 上。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-8146beb5d33000f7180c25928e62fba0_720w.webp" referrerpolicy="no-referrer"></p><p>如上圖所示，你可以使用 "http+json" 的標準形式訪問 dubbo-go 發佈的後端 triple 服務，基於這一特性， 我們可以在 dubbo 客户端在瀏覽器頁面、移動設備上訪問後端服務，使用標準 cURL 工具訪問服務，也可以讓比如 Spring 體系的應用輕鬆的調通 Dubbo 服務。</p><p style="text-align:justify">由於 Triple 協議完全兼容 gRPC 協議，Dubbo 後端服務有可以直接調通標準的 gRPC 服務，它們之間可以無縫的互通，不論是 unary 還是 streaming 通信模式。</p><span id="OSC_h4_2"></span><h4>發佈一個 triple rpc 服務</h4><p style="text-align:justify">為了體驗升級後的 triple 協議，我們接下來會嘗試啓動一個 dubbo-go server，併發佈一個基於 triple 協議的服務。</p><p style="text-align:justify">創建一個新的 server 並啓動 server，它將在指定的端口監聽 triple 協議請求。</p><pre><code>func main() {
  srv, err := server.NewServer(
    server.WithServerProtocol(
      protocol.WithTriple(),
      protocol.WithPort(50051),
    ),
  )
  if err != nil {
    panic(err)
  }
  if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
  }
  if err := srv.Serve(); err != nil {
    panic(err)
  }
}</code></pre><span id="OSC_h4_3"></span><h4>cURL 訪問服務</h4><p style="text-align:justify">Triple 服務啓動完成之後，最簡單方式是使用 HTTP/1.1 POST 訪問服務，參數則作以標準 JSON 格式作為 HTTP 負載傳遞。如下是使用 cURL 命令的訪問示例：</p><pre><code>curl \
    --header "Content-Type: application/json" \
    --data '{"name": "Dubbo"}' \
    http://localhost:50051/greet.GreetService/Greet</code></pre><p style="text-align:justify">Triple 協議的一項重大升級是支持標準 http 工具直接訪問，通過 cURL 可以極大的降低 dubbo-go 服務的測試驗證、前端接入成本。</p><span id="OSC_h3_4"></span><h3>簡單明瞭的 API</h3><p style="text-align:justify">Dubbo Go SDK 支持使用 IDL 或編程語言特有的方式定義服務，並提供一套輕量的 API 來發布或調用這些服務。在上一節的示例中，我們已經看到了部分 dubbo-go API 的使用方式，接下來，讓我們更仔細全面的看一下新版本的 API 設計。</p><span id="OSC_h4_5"></span><h4>RPC Server 與 Client</h4><p style="text-align:justify">對於一些 RPC 通信的場景，開發者只需要使用 dubbo-go 編寫一個最簡單的 RPC server 或者 RPC client，這在新版本 dubbo-go 中只需要幾行代碼即可完成。</p><p style="text-align:justify">通常，我們會使用 Protocol Buffer (IDL) 來定義一個 Dubbo 服務。</p><pre><code>syntax = "proto3";
package greet;

message GreetRequest {
  string name = 1;
}

message GreetResponse {
  string greeting = 1;
}

service GreetService {
  rpc Greet(GreetRequest) returns (GreetResponse) {}
}</code></pre><p style="text-align:justify">使用 Protocol Buffers Compiler 從 IDL 生成 stub 代碼（篇幅關係，我們不在此展示，具體請參見官網 dubbo-go 快速開始）。接下來，我們實現 greettriple.GreeterClient 接口並提供自定義服務實現。</p><pre><code>type GreeterServer struct {
}

func (s *GreeterServer) SayHello(ctx context.Context, in *greet.HelloRequest) (*greet.User, error) {
  return &amp;greet.User{Name: "Hello " + in.Name, Id: "12345", Age: 21}, nil
}</code></pre><p style="text-align:justify">以下是一個簡單的 RPC server 示例，執行協議信息，並註冊服務到 server 中：</p><pre><code>func main() {
  srv, err := server.NewServer(
    server.WithServer_Protocol(
      protocol.WithTriple(),
      protocol.WithPort(50052),
    ),
  )
  if err != nil {
    panic(err)
  }
  if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
  }
  if err := srv.Serve(); err != nil {
    panic(err)
  }
}</code></pre><p style="text-align:justify">如前面 Triple 協議一節所述，你可以使用 cURL 直接測試以上 server 服務運行正常。與此同時，對應的 RPC client 示例如下：</p><pre><code>func main() {
  // for the most brief RPC case
  cli, err := client.NewClient(
    client.WithURL("tri://127.0.0.1:50052"),
  )
  if err != nil {
    panic(err)
  }
  svc, err := greettriple.NewGreetService(cli)
  if err != nil {
    panic(err)
  }

  common.TestClient(svc)
}</code></pre><span id="OSC_h4_6"></span><h4>微服務開發</h4><p style="text-align:justify">如果你正在開發微服務應用，那麼除了 RPC 通信之外，你通常還需要為應用配置一些服務治理能力，比如 retistry 註冊中心、配置中心、可觀測能力等。</p><p style="text-align:justify">以下展示瞭如何使用 dubbo-go 開發一個微服務應用。</p><p style="text-align:justify">首先，創建一個代表微服務的應用 Server，將服務註冊給它，添加註冊中心等服務治理配置。</p><pre><code>func main() {
  // configure global configurations and common modules
  ins, err := dubbo.NewInstance(
    dubbo.WithName("dubbo_test"),
    dubbo.WithRegistry(
      registry.WithZookeeper(),
      registry.WithAddress("127.0.0.1:2181"),
    ),
    dubbo.WithProtocol(
      protocol.WithTriple(),
      protocol.WithPort(50052),
    ),
  )
    // create a server with registry and protocol set above
  srv, err := ins.NewServer()
  if err != nil {
    panic(err)
  }
    // register a service to server
  if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
  }
    // start the server
  if err := srv.Serve(); err != nil {
    panic(err)
  }
}</code></pre><p style="text-align:justify">其中，Instance 是我們在新版本中引入的全局配置，你可以將所有微服務全局配置在這裏進行初始化。這裏，我們設置了微服務通信協議 protocol 和註冊中心 registry，如以下代碼片段所示：</p><pre><code>ins, err := dubbo.NewInstance(
    dubbo.WithName("dubbo_test"),
    dubbo.WithRegistry(
        registry.WithZookeeper(),
        registry.WithAddress("127.0.0.1:2181"),
    ),
    dubbo.WithProtocol(
        protocol.WithTriple(),
        protocol.WithPort(50052),
    ),
)</code></pre><p style="text-align:justify">接下來的操作就非常簡單明瞭了，我們創建一個 server，將服務註冊給它並啓動，如下所示。如果有更多的服務，則可以依次註冊到 server 後再啓動。</p><pre><code>// create a server with registry and protocol set above
srv, err := ins.NewServer()
// register a service to server
if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
}
// start the server
if err := srv.Serve(); err != nil {
    panic(err)
}</code></pre><p style="text-align:justify">以上就是一個微服務應用的基本開發過程，如果你的微服務應用要調用一些遠程 Dubbo 服務，那麼你只需要參照以下方式創建一個 client 就行了。</p><p style="text-align:justify">下面的代碼示例創建了一個 client，緊接着生成了一個 GreetService 遠程服務代理，之後，就可以像調用本地方法一樣調用遠端 Dubbo 服務了。client 將基於註冊中心實現 server 實例的自動發現並自動為流量應用負載均衡策略。</p><pre><code>func main() {
  // configure global configurations and common modules
  ins, err := dubbo.NewInstance(
    dubbo.WithName("dubbo_test"),
    dubbo.WithRegistry(
      registry.WithZookeeper(),
      registry.WithAddress("127.0.0.1:2181"),
    ),
  )
  
  // configure the params that only client layer cares
  cli, err := ins.NewClient()
  if err != nil {
    panic(err)
  }

  svc, err := greettriple.NewGreetService(cli)
  if err != nil {
    panic(err)
  }

  resp, err := svc.Greet(context.Background(), &amp;greet.GreetRequest{Name: "triple"})
  if err != nil {
    return err
  }
  logger.Infof("TRIPLE unary call resp: %s", resp.Greeting)
}</code></pre><span id="OSC_h3_7"></span><h3>企業級服務治理能力</h3><span id="OSC_h4_8"></span><h4>動態配置</h4><p style="text-align:justify">除了 API 模式之外，Dubbo-go 支持基於配置文件驅動的編碼方式，這對於一些更大規模的微服務開發場景非常適用。在這種模式下，我們將 registry、protocol 等組件配置，甚至包括服務聲明等都放在 dubbogo.yml 文件中，框架會在啓動過程中完成配置文件加載。</p><p style="text-align:justify">以下是一個基於 dubbogo.yml 的微服務應用的開發示例：</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-7420aaf1df69816f650d9fafc20a94e5_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">其中，server.go 定義如下：</p><pre><code>func main() {
  greettriple.SetProviderService(&amp;GreeterServiceImpl{})
  if err := dubbo.Load(); err != nil {
    panic(err)
  }
}</code></pre><p style="text-align:justify">dubbogo.yml 示例內容如下：</p><pre><code>dubbo:
  application: # 應用信息，服務啓動後會將相關信息註冊到註冊中心，可被客户端從 url 中識別
    name: myApp
  registries:
    nacos:
      protocol: nacos # 註冊中心選擇 nacos 
      address: 127.0.0.1:8848 # nacos ip
      group: DEFAULT_GROUP # nacos group, 默認 DEFAULT_GROUP
      namespace: 9fb00abb-278d-42fc-96bf-e0151601e4a1 # nacos namespaceID, should be created before. 默認 public
      username: abc
      password: abc
  protocols:
    dubbo:
      name: tri
      port: 20000
  provider:
    services:
      UserProviderWithCustomGroupAndVersion: # 接口三元組：接口名、版本號、分組。client 和 server 需要保持一致。
        interface: org.apache.dubbo.UserProvider.Test # 接口名必填
        version: myInterfaceVersion # 默認為空
        group: myInterfaceGroup # 默認為空</code></pre><p style="text-align:justify">可以看到相比於之前的 API 編碼方式，這裏的 server.go 只有兩行代碼，dubbo.Load() 會完成所有配置的自動組裝並啓動相關組件，我們只需要在啓動應用時指定 export DUBBO_GO_CONFIG_PATH=$ABSOLUTE_PATH/conf/dubbogo.yml 即可。</p><span id="OSC_h4_9"></span><h4>可觀測性</h4><p style="text-align:justify">自 3.2.0 版本開始，dubbo-go 重點升級了內置 metrics 指標採集能力，提供 RPC 調用（RT、QPS、調用量、請求成功數、請求失敗數、併發請求數等）、註冊中心、元數據中心、配置中心交互統計等豐富的內置採集埋點，支持多維度的指標聚合。</p><p style="text-align:justify">dubbo-go 內置 metrics 指標導出到 Prometheus + Grafana 體系的能力，以下是 dubbo-go v3.2.0 示例在 Grafana 的監控效果圖，具體示例我們將與隨後發佈在 dubbo-go-samples/metrics。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-b4ec54c1891c2d1f09b91227746c751e_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_10"></span><h4>流量管控</h4><p style="text-align:justify">Dubbo 提供了豐富的流量管控策略：</p><ul><li><strong>地址發現與負載均衡，</strong>地址發現支持服務實例動態上下線，負載均衡確保流量均勻的分佈到每個實例上。</li><li><strong>基於路由規則的流量管控，</strong>路由規則對每次請求進行條件匹配，並將符合條件的請求路由到特定的地址子集。</li></ul><p style="text-align:justify">服務發現保證調用方看到最新的提供方實例地址，服務發現機制依賴註冊中心 (Zookeeper、Nacos、Istio 等) 實現。在消費端，Dubbo 提供了多種負載均衡策略，如隨機負載均衡策略、一致性哈希負載、基於權重的輪詢、最小活躍度優先、P2C 等。</p><p style="text-align:justify">Dubbo 的流量管控規則可以基於應用、服務、方法、參數等粒度精準的控制流量走向，根據請求的目標服務、方法以及請求體中的其他附加參數進行匹配，符合匹配條件的流量會進一步的按照特定規則轉發到一個地址子集。以下是 dubbo-go 流量管控規則可以實現的一些具體管控場景示例：</p><ul><li>基於權重的比例流量分發</li><li>灰度驗證</li><li>金絲雀發佈</li><li>按請求參數的路由</li><li>同區域優先</li><li>超時時間調整</li><li>重試</li><li>限流降級</li></ul><p style="text-align:justify">以下是一個基於 dubbo-go 實現的全鏈路灰度示例：</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-d3af29d517bd1d38914a8b7df29c0384_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">以下是一個基於 dubbo-go 實現的按比例流量轉發示例：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-4688342e32359c6fa7e25ef3bc3c22b6_720w.webp" referrerpolicy="no-referrer"></p><p>關於 dubbo-go 流量管控，我們以一個商城系統提供了一個完整的 demo 示例，感興趣的讀者可以參考詳細信息：</p><ul><li>流量管控規則詳情<strong>[1]</strong></li><li>流量管控商場示例解讀<strong>[2]</strong></li></ul><span id="OSC_h4_11"></span><h4>生態</h4><p style="text-align:justify">dubbo-go 總體上遵循框架內核+插件的的設計理念，左側的框架內核定義了 dubbo-go 作為微服務框架的一些核心概念，右側的插件部分則提供了核心概念擴展實現。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-c4c6b5317adb83a4b234eb8fcd15d8c9_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">框架內核，可分為 4 個層次，從上到下依次為：</p><ul><li><strong>API 層</strong></li></ul><p style="text-align:justify">dubbo-go 同時支持基於 IDL、interface/struct 的服務契約定義，兼顧跨語言與易用性訴求；支持基於純 yaml 文件的微服務配置模式；提供了同步、異步、單次 (unary)、流式 (streaming) 等 RPC 通信與編碼模型。</p><ul><li><strong>服務治理層</strong></li></ul><p style="text-align:justify">dubbo-go 內置了多維度的服務治理能力抽象，確保滿足微服務開發與集羣治理的核心訴求，這包括地址發現（Service Discovery）、負載均衡（Load Balancing）、可觀測指標（Metrics）、流量管控（Traffic Management）、全鏈路追蹤（Tracing）等。</p><ul><li><strong>RPC 協議層</strong></li></ul><p style="text-align:justify">dubbo-go 實現的最核心的 RPC 協議是 - triple 協議，triple 可同時工作在 http1/2 之上 (支持 CURL 直接訪問)，兼容 gRPC；從設計上，dubbo-go 還提供了多協議發佈服務的支持，你可以在一個進程內同時發佈 triple、dubbo2、rest、jsonRPC 等多種不同通信協議的服務。</p><ul><li><strong>傳輸層</strong></li></ul><p style="text-align:justify">支持 HTTP1/2、TCP 傳輸層，兼顧性能與通用性，同時支持多種序列化方式。</p><p style="text-align:justify">插件體系極大的豐富了 dubbo-go 功能與生態，社區內置提供了大量的內置擴展實現，同時，開發者可以非常容易的根據需求增加擴展實現。以下是一些典型的插件定義：</p><ul><li><strong>Protocol</strong></li></ul><p style="text-align:justify">dubbo-go 基於 protocol 插件內置提供了 triple、dubbo2、rest 等協議支持，通過擴展 protocol 可以為 dubbo-go 擴展更多協議。</p><ul><li><strong>Service Discovery</strong></li></ul><p style="text-align:justify">支持 Nacos、Zookeeper、Polaris 等主流注冊中心集成。</p><ul><li><strong>Traffic Management</strong></li></ul><p style="text-align:justify">dubbo-go 支持 Dubbo 體系定義的流量規則，可以實現在運行期動態的調整服務行為如超時時間、重試次數、限流參數等，通過控制流量分佈可以實現 A/B 測試、金絲雀發佈、多版本按比例流量分配、條件匹配路由、黑白名單等。</p><ul><li><strong>Metrics</strong></li></ul><p style="text-align:justify">提供 RPC 調用（RT、QPS、調用量、請求成功數、請求失敗數、併發請求數等）、註冊中心、元數據中心、配置中心交互統計等豐富的內置採集埋點，支持多維度的指標聚合。</p><ul><li><strong>Logging</strong></li></ul><p style="text-align:justify">提供通用的日誌採集接口定義，內置 Zap、Logrus 支持</p><ul><li><strong>Tracing</strong></li></ul><p style="text-align:justify">提供分佈式鏈路追蹤能力，通過此插件擴展可接入 Zipkin、Jaeger、Skywalking 等鏈路追蹤系統。</p><span id="OSC_h3_12"></span><h3>總結</h3><p style="text-align:justify">dubbo-go 3.2.0 的首個 alpha 版本將於 11 月底發佈，本文是發版前的搶先預覽，感興趣的讀者也可以訪問源碼嚐鮮：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fapache%2Fdubbo-go%2Ftree%2Ffeature-triple%2Fprotocol%2Ftriple%2Finternal%253Fspm%253Da2c6h.13046898.publish-article.3.79d66ffahA9acR" target="_blank">https://github.com/apache/dubbo-go/tree/feature-triple/protocol/triple/internal</a></em></u></p><p style="text-align:justify">接下來，我們將持續推進 3.2.0 版本迭代並計劃與 2 月份發佈正式穩定版本，詳細 Roadmap 請關注項目倉庫：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fapache%2Fdubbo-go%253Fspm%253Da2c6h.13046898.publish-article.4.79d66ffahA9acR" target="_blank">https://github.com/apache/dubbo-go</a></em></u></p><p style="text-align:justify"><strong>相關鏈接：</strong></p><p style="text-align:justify">[1] 流量管控規則詳情</p><p style="text-align:justify"><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Ftraffic%2F%253Fspm%253Da2c6h.13046898.publish-article.5.79d66ffahA9acR" target="_blank">https://cn.dubbo.apache.org/zh-cn/overview/core-features/traffic/</a></em></u></p><p style="text-align:justify">[2] 流量管控商場示例解讀</p><p style="text-align:justify"><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Ftasks%2Ftraffic-management%2F%253Fspm%253Da2c6h.13046898.publish-article.6.79d66ffahA9acR" target="_blank">https://cn.dubbo.apache.org/zh-cn/overview/tasks/traffic-management/</a></em></u></p><p style="text-align:justify"><em>作者：王宇軒， Apache Dubbo Committer</em></p><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1380725%3Futm_content%3Dg_1000384715" target="_blank">原文鏈接</a></strong></p><p style="text-align:justify"><strong>本文為阿里雲原創內容，未經允許不得轉載。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 06:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10314426</guid>
            <link>https://my.oschina.net/yunqi/blog/10314426</link>
            <author>
                <![CDATA[阿里云云棲號]]>
            </author>
        </item>
    </channel>
</rss>
