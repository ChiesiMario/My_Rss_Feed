<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 08 Nov 2023 08:14:28 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 跨平台終端仿真軟件 quardCRT]]>
            </title>
            <description>
                <![CDATA[<p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Fwindows.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/windows.yml?branch=main&amp;logo=windows" alt="Windows ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Flinux.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/linux.yml?branch=main&amp;logo=linux" alt="Linux ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Fmacos.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/macos.yml?branch=main&amp;logo=apple" alt="Macos ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.codefactor.io%2Frepository%2Fgithub%2Fqqxiaoming%2FquardCRT"><img src="https://img.shields.io/codefactor/grade/github/qqxiaoming/quardCRT.svg?logo=codefactor" alt="CodeFactor" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/license/qqxiaoming/quardCRT.svg?colorB=f48041&amp;logo=gnu" alt="License" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Freleases"><img src="https://img.shields.io/github/tag/QQxiaoming/quardCRT.svg?logo=git" alt="GitHub tag (latest SemVer)" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Freleases"><img src="https://img.shields.io/github/downloads/QQxiaoming/quardCRT/total.svg?logo=pinboard" alt="GitHub All Releases" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/stars/QQxiaoming/quardCRT.svg?logo=github" alt="GitHub stars" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/forks/QQxiaoming/quardCRT.svg?logo=github" alt="GitHub forks" referrerpolicy="no-referrer"></a><a href="https://gitee.com/QQxiaoming/quardCRT"><img src="https://gitee.com/QQxiaoming/quardCRT/badge/star.svg?theme=dark" alt="Gitee stars" referrerpolicy="no-referrer"></a><a href="https://gitee.com/QQxiaoming/quardCRT"><img src="https://gitee.com/QQxiaoming/quardCRT/badge/fork.svg?theme=dark" alt="Gitee forks" referrerpolicy="no-referrer"></a></p><h1><a id="user-content-quardcrt" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#quardcrt"></a>quardCRT</h1><p><a href="https://gitee.com/QQxiaoming/quardCRT/blob/main/README.md">English</a> | 簡體中文</p><p>quardCRT 一款終端仿真軟件，支持多種後端協議，無依賴跨平台使用，windows/linux/mac 使用體驗完全一致，支持多標籤頁和歷史記錄管理。</p><table><thead><tr><th align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/windows.png" alt="img2" referrerpolicy="no-referrer"></th></tr></thead><tbody><tr><td align="center">Windows</td></tr><tr><td align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/macos.png" alt="img1" referrerpolicy="no-referrer"></td></tr><tr><td align="center">MacOS</td></tr><tr><td align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/linux.png" alt="img3" referrerpolicy="no-referrer"></td></tr><tr><td align="center">Linux</td></tr></tbody></table><p>其他協議選擇界面：</p><p><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/img.png" alt="img" referrerpolicy="no-referrer"></p><h2><a id="user-content-功能描述" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E5%8A%9F%E8%83%BD%E6%8F%8F%E8%BF%B0"></a>功能描述</h2><ul><li><p>目前支持的終端協議包括：</p><ul><li>telnet (支持帶 websocket 封裝)</li><li>serial</li><li>loaclshell</li><li>rawsocket</li><li>windows:NamedPipe（linux/macos:unix domain socket）</li></ul></li><li><p>多標籤頁管理，標籤頁克隆，標籤頁拖拽排序</p></li><li><p>雙列分屏</p></li><li><p>工作目錄書籤</p></li><li><p>自動化發送</p></li><li><p>HEX 顯示</p></li><li><p>會話記錄管理</p></li><li><p>終端樣式配置（配色方案，字體）</p></li><li><p>終端背景圖片配置（支持透明度設置，支持 gif 動畫和視頻）</p></li><li><p>終端滾動行數設置</p></li><li><p>支持深色/淺色主題</p></li><li><p>支持多語言（中文/英文/日文）</p></li></ul><h2><a id="user-content-貢獻" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E8%B4%A1%E7%8C%AE"></a>貢獻</h2><p>如果您對本項目有建議或想法，歡迎在 GitHub 或 Gitee 上提交 issue 和 pull requests。</p><p>目前項目建議使用版本 Qt6.2.0 及更高版本。</p><h2><a id="user-content-特別" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E7%89%B9%E5%88%AB"></a>特別</h2><p>項目目前為個人業餘時間開發，為提高開發效率，本項目較為大量的使用了 GitHub Copilot 協助代碼編寫，部分代碼的人類可讀性可能不是很好，作者也會盡量在後續版本中進行優化。</p><h2><a id="user-content-感謝" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E6%84%9F%E8%B0%A2"></a>感謝</h2><p>本項目代碼引用或部份參考或依賴了以下開源項目，項目完全尊重原項目開源協議，並在此表示感謝。</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FColinDuquesnoy%2FQDarkStyleSheet">QDarkStyleSheet</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fdridk%2FQFontIcon">QFontIcon</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fsilderan%2FQTelnet">QTelnet</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Flxqt%2Fqtermwidget">qtermwidget</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fkafeg%2Fptyqt">ptyqt</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fbitmeal%2Fargv_split">argv_split</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmbadolato%2FiTerm2-Color-Schemes">iTerm2-Color-Schemes</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Frprichard%2Fwinpty">winpty</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FSM-nzberg%2FQtFancyTabWidget">QtFancyTabWidget</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fteknoraver%2Fqtftp">qtftp</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FJuliaStrings%2Futf8proc">utf8proc</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Ffcitx%2Ffcitx-qt5">fcitx-qt5</a></li></ul>]]>
            </description>
            <pubDate>Wed, 08 Nov 2023 06:05:57 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/QQxiaoming/quardCRT</guid>
            <link>https://gitee.com/QQxiaoming/quardCRT</link>
        </item>
        <item>
            <title>
                <![CDATA[騰訊開源高性能輕量級跨平台 QUIC 協議庫-TQUIC]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">騰訊開源了一個<span style="background-color:#ffffff">基於 RUST 語言開發的 QUIC 協議庫 -&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FwRC2htPOMYevTgfxIY1uWw" target="_blank">TQUIC</a>，<span style="background-color:#ffffff">旨在打造一個穩定、快速、高性能並具有廣泛技術影響力的傳輸協議庫。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">「</span>由於 QUIC 所具備的廣泛性、長期性、創新性特點，我們開源了自研的 TQUIC 協議庫，也希望借 TQUIC 開源的機會, 吸引更多的同學共建，一起促進傳輸協議的發展，提升互聯網快速和安全的傳輸體驗。<span style="background-color:#ffffff">」</span></span></p><p style="color:#353535; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">TQUIC 協議庫具有如下的優勢：</span></p><ul><li style="text-align:start"><span style="color:#000000"><strong>快傳輸：</strong>TQUIC 是業界支持擁塞控制算法最豐富的協議庫，在全部場景下表現符合 RFC 預期，在弱網和部分場景下傳輸效果領先 2%-30%。</span></li><li style="text-align:start"><span style="color:#000000"><strong>高性能：</strong>TQUIC 在大部分測試場景下的單機處理性能優於同類開源產品 5%，部分場景下單機處理性能領先 20%。</span></li><li style="text-align:start"><span style="color:#000000"><strong>高質量<span style="background-color:#ffffff">：</span></strong>QUIC 協議棧涵蓋 10+篇核心的 RFC 標準或草案，同時涉及到傳輸層、安全層、應用層，複雜度遠大於 TCP。TQUIC 單元測試覆蓋率 95% 以上，與業界四個主流 QUIC 實現的互操性測試用例通過率為 100%， 同時採用基於形式化規範 (SIGCOMM2019 論文成果）的測試方法，嚴格保障了協議一致性。</span></li><li style="text-align:start"><span style="color:#000000"><strong>易用性：</strong>TQUIC 易於使用，支持靈活的配置和豐富的可觀察性；TQUIC 提供了 Rust/C/C++多語言接口，未來計劃進一步提供 Kotlin/Swift 等語言接口。</span></li><li style="text-align:start"><span style="color:#000000"><strong>基於 RUST<span style="background-color:#ffffff">：</span></strong>TQUIC 基於內存安全語言編寫，不受緩衝區溢出漏洞和其他與內存相關缺陷影響。</span></li><li style="text-align:start"><span style="color:#000000"><strong>豐富特性<span style="background-color:#ffffff">：</span></strong>TQUIC 支持所有 QUIC 和 HTTP/3 規範的重要特性。</span></li></ul><p>架構圖：</p><p><img alt="" height="373" src="https://oscimg.oschina.net/oscnet/up-96c0da66ae752f38efa3109e35055f2ffe9.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#353535; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">TQUIC 將跨平台兼容及多併發模型支持作為關鍵的設計目標。TQUIC 核心採用了網絡 IO 及事件循環抽象化設計。TQUIC 核心並不依賴於套接字，而是通過用户提供的回調來實現。同時，TQUIC 核心沒有強加特定的事件循環要求，它提供了幫助用户調度事件的函數。TQUIC 的靈活性使得易於在各種系統中的定製和集成。</span></p><p style="color:#353535; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">TQUIC 接口層提供了面向主流平台編程語言的高層級封裝接口，支持同步、異步語義接口，兼容不同的併發模型，並簡化用户的使用。</span></p><p><span style="color:#000000"><strong>後續規劃：</strong></span></p><ul><li style="text-align:start"><span style="color:#000000">對接開源技術生態，擴大 TQUIC 使用場景，進一步提升 TQUIC 使用體驗。</span></li><li style="text-align:start"><span style="color:#000000">發表相關論文，並逐步開源更多 TQUIC 高級特性和算法。</span></li><li style="text-align:start"><span style="color:#000000">追蹤 QUIC 協議的演進和創新，並持續提升 TQUIC 核心能力。</span></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 08 Nov 2023 02:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265538</guid>
            <link>https://www.oschina.net/news/265538</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[HelloGitHub 社區動態，開啓新的篇章！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107191851907-206780890.png" alt="" referrerpolicy="no-referrer"></p><p>今天這篇文章是 HelloGitHub 社區動態的第一篇文章，所以我想多説兩句，聊聊為啥開啓這個系列。</p><p>我是 2016 年創建的 HelloGitHub，它從最初的一份分享開源項目的月刊，現如今已經成長為 7w+ Star 的開源項目、1w+ 用户的開源社區、全網 50w+ 的自媒體。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185115225-596937695.png" alt="" referrerpolicy="no-referrer"></p><p>我本是一名普通的程序員，三流的技術水平、毫無文筆、開源門外漢，起初連 Git 都不會，也不知道什麼是開源，就一個猛子扎進來做了 HelloGitHub。為了想讓更多人看到 HelloGitHub 月刊，稀裏糊塗地就做起了「自媒體」。我為了圓自己的站長夢，餓着肚子咬牙重構了 HelloGitHub.com 網站，從最初的 Web 1.0 的月刊展示，升級到了 Web 2.0 的開源社區。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231108085617330-199475160.png" alt="" referrerpolicy="no-referrer"></p><p>聰明的人追着風口跑，很容易就賺到錢了。像我這種愚笨的人，只做「分享開源項目」這一件事情，就花了 7 年的事情，錢沒賺到人還瘦了兩圈😂。</p><p>有人説我不會玩流量，確實我不會，因為在我眼裏每一次點擊、每一個閲讀、每一位粉絲背後都是我的一位朋友。説起來真是慚愧，就是我和朋友們的溝通太少了，因為<strong>我總想一個人、一台電腦、一把鍵盤，做出讓人拍手稱讚的事情</strong>。這件事我試過了，我自己搞不了！</p><p>有錯就要認，捱打要立正。所以，我決定經常和朋友們説説關於 HelloGitHub 社區的事情，<strong>希望通過這個系列打開一個窗口，讓社區成員瞭解項目的發展方向，想加入進來的人知道自己能做些什麼</strong>，同時我也能多瞭解大家的想法，多和朋友們討論，凝聚更多人的力量。</p><p>所以，就有了這篇「HelloGitHub 社區動態」的文章，我是這樣想的：以後每個月月初寫一下上個月關於 HelloGitHub 社區發生的事兒、未來要做的事兒、大家一起能做的事兒。<strong>一羣人做一件值得驕傲的事情</strong>，這事兒沒準能成！</p><p>我要説的就這些，下面正文開始。</p><h2>一、介紹</h2><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185411363-1285676789.gif" alt="" referrerpolicy="no-referrer"></p><p>HelloGitHub 是一個分享 GitHub 上有趣、入門級開源項目的開源社區，由一羣熱愛開源的小夥伴運營，我們<strong>因開源而相聚，為興趣而付出</strong>，希望通過分享和講解開源項目，幫助大家找到編程的樂趣、輕鬆搞定問題的技術方案、令人驚歎的開源神器，從而順應內心的渴望，毫無保留地踏上開源之旅。</p><h2>二、社區動態</h2><p>接下來，我將和「在座」的各位彙報下 10 月份的 HelloGitHub 開源社區的項目進展、貢獻者和未來計劃，歡迎朋友們為社區的建設提供建議、反饋和做貢獻，讓我們並肩攜手共創 HelloGitHub 社區。</p><ul><li>項目進展：介紹主要項目的最新進展情況，包括新增功能、修復的問題、</li><li>貢獻者：表彰和讚揚過去一個月對項目做出傑出貢獻的個人，歡迎新加入開源社區的貢獻者，以及在做的事情和經驗分享。</li><li>下一步計劃：聊一聊接下來要做的事情。</li></ul><h3>2.1 項目進展</h3><p>HelloGitHub 的項目概覽：</p><ol><li>月刊：這裏有好玩、有趣、入門級的開源項目，每月 28 號發刊。</li><li>熱點速遞：每週一更新的週刊，分享和介紹 GitHub 過去一週的熱點項目。</li><li>講解系列：通過一篇文章的篇幅帶你入門一款開源項目，不定期更新。</li><li>社區網站：圍繞開源項目建立的社區，大家可以在這裏分享、發現、評論、打分、收藏感興趣的開源項目。</li></ol><p><strong>社區網站</strong></p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185145824-1576267720.gif" alt="" referrerpolicy="no-referrer"></p><p>上個月主要做了用户反饋最多的「標籤功能」的優化，入口在 PC 端訪問社區的左側「管理標籤」按鈕（需登錄）。詳情如下：</p><ol><li>為標籤設置了分組，分成了編程語言、技術棧、應用類型、其它共 4 組，方便用户更快地找到自己感興趣的標籤，對於沒有編程能力的朋友也可以通過桌面應用、Android、Windows、macOS 等標籤找到開箱即用的應用。</li><li>支持拖拽的方式選擇標籤和排序。</li><li>新增 PHP、Ruby、Flutter、嵌入式、Docker、Vue 等 13 個標籤。</li></ol><blockquote><p>地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhellogithub.com%2F" target="_blank">https://hellogithub.com/</a></p></blockquote><p><strong>內容</strong></p><p>HelloGitHub 自媒體 10 月份共發佈了 4 篇 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzA5MzYyNzQ0MQ%3D%3D%26action%3Dgetalbum%26album_id%3D1332112026222641153%26scene%3D173%26from_msgid%3D2247516881%26from_itemidx%3D1%26count%3D3%26nolastread%3D1%23wechat_redirect" target="_blank">GitHub 熱點速遞</a>、1 篇<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzA5MzYyNzQ0MQ%3D%3D%26action%3Dgetalbum%26album_id%3D1332147780885856258%26scene%3D173%26from_msgid%3D2247516865%26from_itemidx%3D1%26count%3D3%26nolastread%3D1%23wechat_redirect" target="_blank">講解開源項目的文章</a>、1 篇 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzA5MzYyNzQ0MQ%3D%3D%26action%3Dgetalbum%26album_id%3D1331197538447310849%26scene%3D173%26from_msgid%3D2247516838%26from_itemidx%3D1%26count%3D3%26nolastread%3D1%23wechat_redirect" target="_blank">HelloGitHub 月刊</a>。</p><h3>2.2 貢獻者</h3><p>因為這是第一篇社區動態，所以我必須要感謝下 2023 至今的所有貢獻者，他們的每個貢獻對於我來説都是雪中送炭，主要集中於 HelloGitHub 社區前端代碼的貢獻。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185421588-1660267532.png" alt="" referrerpolicy="no-referrer"></p><ul><li>@胤玄、@cqh：完成管理標籤功能的設計和優化</li><li>@胤玄：修復月刊目錄的問題、修復了彈出對話框後背景頁面滾動的問題</li><li>@GJSSS：修復圖片預覽時沒有關閉圖標的問題、主題切換按鈕的樣式</li><li>@Maidang：修復黑暗主題下點擊詳情頁的問題</li></ul><p><strong>如何貢獻</strong></p><p>如果你會寫代碼可以加入到 HelloGitHub 社區的開發中，前後端都需要。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185426160-863675536.png" alt="" referrerpolicy="no-referrer"></p><blockquote><p>需求列表：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FHelloGitHub-Team%2Fgeese%2Fissues%2F38" target="_blank">https://github.com/HelloGitHub-Team/geese/issues/38</a></p></blockquote><p>如果你喜歡寫文章歡迎投稿到 HelloGitHub，可以是你上手開源項目的經過、開源項目評測對比、有趣的開源項目集合等，不用擔心寫得不夠好，只要是用心寫的內容，我會和你一同完成它。</p><p>如果你發現了優秀的開源項目，歡迎分享到 HelloGitHub 讓更多人知道。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185430278-2003963940.gif" alt="" referrerpolicy="no-referrer"></p><p>希望 HelloGitHub 能成為你開源之路的第一站，讓我們一同成長，一起做值得驕傲的事情。</p><h3>2.3 下一步計劃</h3><p>為了能讓「社區動態」持續更新，所以每個月必須做出點成績來，才能向大家彙報。第一期我就説一下我自己下一步的打算，後面會結合朋友們的想法，來制定下一步計劃：</p><ol><li>幫助新加入的貢獻者為 HelloGitHub 做貢獻，多溝通、提供保姆級幫助。</li><li>完成網站搜索功能的優化，打通公眾號，即在公眾號發消息也能得到開源項目搜索結果。</li><li>為網站加入 AIGC 的功能，比如：根據自然語言描述推薦開源項目。</li><li>我想採訪一些「民間」做開源的人，講出他們的故事。</li><li>做視頻自媒體，這個事情我一直想做但始終沒有走出第一步，希望有人能推我一把。</li><li>天冷了是時候吃一頓火鍋了，搞一個線下的「開源人火鍋局」，互認識一下聊聊開源的酸甜苦辣，看看有沒有臭味相投的人。</li></ol><p>對上面的計劃感興趣的小夥伴，歡迎與我聯繫一起搞事情，也可以留言説出你的想法。</p><h2>三、最後</h2><p>如果把開源當成是一個愛好的話，就不會去深究為什麼要花時間在上面，因為從中能得到快樂和滿足感，就夠了。</p><p>最後，希望有了大家的陪伴，我們彼此的開源之路不再孤單和苦悶，而是充滿更多的歡聲笑語。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 08 Nov 2023 02:17:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/HelloGitHub/blog/10141490</guid>
            <link>https://my.oschina.net/HelloGitHub/blog/10141490</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[龍芯中科董事長、總經理胡偉武答網友與投資者]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>龍芯中科 2023 年第三季度業績説明會於昨日召開，在與投資者和網友互動問答環節，<span style="background-color:#ffffff; color:#333333">龍芯中科董事長、總經理胡偉武解答了許多問題。</span></p><p><span style="background-color:#ffffff; color:#333333">下文摘錄了部分問答（回答者均為龍芯中科</span>董事長、總經理，胡偉武<span style="background-color:#ffffff; color:#333333">）。</span></p><p>完整回顧：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frsc.sseinfo.com%2FroadshowIndex.do%3Fid%3D16536" target="_blank">https://rsc.sseinfo.com/roadshowIndex.do?id=16536</a></u></em></p><hr><h4><strong>開源、技術相關</strong></h4><p>您好！先前路演中，提過龍芯對於開源（個人理解為免費授權）與收費的思考，圈子裏很多同學對關於「不開源」的論述有顧忌。能否藉此機會明確下：龍芯法務對第三方獨立完成的龍架構軟硬件實現，以及善意的二次創作（如將指令集手冊整理為方便查閲的網站等）持何種態度？</p><p>另外社區 Linux 發行版能否打包龍芯原創軟件（如 Lbrowser、LATX、應用合作社等）？目前這些軟件缺乏 EULA，保守起見是不能打包的，對這些系統的用户不太友好。</p><blockquote><p>在 11 月底的發佈會上，龍芯會與使用龍芯 IP 及架構的開放授權客户簽約，敬請關注。</p><p>開源與兼容是一個矛盾，Linux 沒打敗 Windows、OpenCL 在 Cuda 面前輸得一塌糊塗，主要是參與者沒有形成合力。我們正在找到一條既開源又兼容的路徑，使得大量基於龍架構做芯片的人軟件是兼容的。</p><p>感謝你關於 Linux 發行版的建議，我們會認真考慮。</p></blockquote><p>&nbsp;</p><p>關於生態建設方面，目前雖説龍芯 Loongnix 被官方稱作「開源社區」，但它工單系統、代碼倉庫等不公開，協作渠道只有 service@loongnix.cn 一個郵箱，很難想像如何組織起有效的第三方參與。</p><p>作為國內為數不多的「根社區」，龍芯是否考慮將相關設施開放公開訪問，為其他行業參與者樹立樣板？</p><blockquote><p>我們正在改進，建設統一入口的龍芯生態社區。</p></blockquote><p>&nbsp;</p><p>請問龍芯有無計劃開發 ARM 的二進制翻譯, 在什麼契機下面向市場和社會公開?</p><blockquote><p>有。目前重點是在龍芯平台上運行 X86/Windows 應用，下一步要在龍芯平台上運行 ARM/Android 應用（已經開始部署）。</p><p>我以前説過要通過指令系統的創新消滅指令系統差異，一步步都會做到的。</p></blockquote><p>&nbsp;</p><p>龍芯的編程框架、二進制編譯進展如何了？編程框架大概何時能發佈？軟件的可通用性在開放市場很重要。</p><blockquote><p>二進制翻譯在別的問題回答過了。通用編程框架計劃隨龍芯 GPGPU 同步推出。</p></blockquote><p>&nbsp;</p><p>二進制翻譯目前進展怎麼樣，什麼時候可以產品化</p><blockquote><p>X86/Linux 的二進制翻譯趨於穩定。X86/Windows 的打印機、IE 瀏覽器兼容問題基本解決，正在做通用平台，最近有很多應用可用了，而且比較流暢，但這是個大工程。</p><p>我希望，二進制翻譯結合 3B6000 的推出可以到個人電腦的開放市場試試看。</p></blockquote><p>&nbsp;</p><p>胡老師好，請問：<br> 1，龍芯 3 系調頻技術何時能夠實現？<br> 2，龍芯系統（Loongnix）何時能夠升級至新世界？<br> 3，後續是否有推動商業軟件遷移至新世界的計劃？ 謝謝！</p><blockquote><p>Loongnix 升級至新世界與 Debian 對龍芯的支持同步，請關注 Debian 對龍架構的支持。</p><p>我們已經基本解決了在新世界上運行老世界應用的兼容性問題，正與統信等操作系統企業合作，爭取下一版操作系統支持新世界。</p></blockquote><p>&nbsp;</p><p>龍芯有無計劃結合自身 JIT 方面優勢做一些產品的適配和服務器或高性能領域的研發?</p><blockquote><p>感謝肯定與建議，是可以在這方面做工作，甚至未來可以做些芯片級的加速。</p></blockquote><p>&nbsp;</p><p>很期待公司的 GPGPU，能否適當吐露一些進展或者目標嗎？比如是否會研發自己的神經網絡框架？專門的 gpgpu 產品的計算能力大概在多少 (如 int8 或 float32)？</p><blockquote><p>在 2K3000 中 INT8 大概 8TOPS，在 9A1000 中 INT8 大概 32TOPS。同時，多個 9A1000 通過龍鏈互連形成更高性能。</p></blockquote><p>&nbsp;</p><p>請問可以説明一下龍鏈技術有哪些優勢嗎？</p><blockquote><p>一般高速互連包括物理、鏈路、協議層，像 PCIE 這樣的接口協議每一層都要打包拆包，nvlink 及 CXL 這樣的協議，協議層直接面向物理層設計，提高了效率。龍鏈跟 3A5000 的片間互聯協議比，片間互聯延遲成倍降低，帶寬提高了好幾倍，大大提高多片協同工作的性能。</p><p>龍鏈跟 nvlink 比，速率還低一些（目前每位速率是 16Gbps，下一步將提高到 32Gbps），但效率已經不錯了。</p></blockquote><h4>&nbsp;</h4><h4>行業、政策相關</h4><p>請問胡老師，3A6000 何時正式發佈？龍芯能否跳過 3B6000 直接研發 7nm 的 3A7000, 時不我待！</p><blockquote><p>3A6000 將於 11 月底正式發佈，十幾家整機/ODM 企業將發佈其整機產品。</p><p>我感覺在目前的工藝上還應該提高性能 20%-30%。換個新工藝也就提高這麼多。7nm 流片費用很高，一次得上億元，不能用該工藝試錯，用已有工藝完成結構試錯後再改到更先進工藝。</p><p>另外，龍芯堅持 IP 的自主研發，在新工藝上，要研製 DDR5 PHY、PCIE PHY、各類寄存器堆、鎖相環等 IP，現在已經開展對新工藝的評估，2024 年將研製這些 IP 並開展測試片研製，等這些 IP 成熟了，3B6000 也完成了對新結構的驗證，時間是對得上的。</p></blockquote><p>&nbsp;</p><p>對於目前信創的主要競爭對手海光和華為各自的競爭力如何看？</p><blockquote><p>（1）商業模式不同，龍芯可以比作 Intel，華為是整機企業可以比作 IBM，海光與曙光也形成了事實上的 IBM 模式。<br> （2）龍芯做生態，他們做產品，這是主要不同。<br> （3）龍芯把信創作為走向開放市場路上的驛站，作為試錯場景，最終面向開放市場和海外市場。</p></blockquote><p>&nbsp;</p><p>目前在龍芯桌面主機上還是看到一些挑內存現象，請問後續龍芯這方面有沒有優化計劃，儘可能做到市場主流品牌的內存插上即用。</p><blockquote><p>感謝你的問題。我們會進行持續改進。</p></blockquote><p>&nbsp;</p><p>您認為龍芯的銷售是否存在不接地氣的情況呢？</p><blockquote><p>理論上，龍芯主要面對整機企業，在整機企業積極性不足的情況下直接推動一些用户單位。</p><p>過去確實存在對計算機產業鏈不熟悉的情況，過去一年多已經有較大進步，從整機、渠道、應用單位三個環節完善產業鏈。</p></blockquote><p>&nbsp;</p><p>作為一個國產愛好者，請問龍芯 3a6000 對國產的電腦配件適配情況怎麼樣？比如長江致鈦、摩爾線程、金百達等的適配情況。</p><blockquote><p>我們與自主內存、硬盤、顯卡的很多合作伙伴都已經完成適配或者正在適配。</p></blockquote><p>&nbsp;</p><p>請問胡老師，龍芯與俄羅斯方面的合作是否會更深入，我個人認為龍芯應該積極與俄方合作，有利於雙方打破僵局</p><blockquote><p>謝謝你的建議。 目前龍芯的營收均來自境內客户。</p><p>龍芯是一個通用 CPU 企業，會聯合一帶一路國家打造獨立於 X86 和 ARM 體系的第三套體系。</p></blockquote><p>&nbsp;</p><p>龍芯 cpu 的性能還是不錯的，但是絕大部分人對於專業軟件的測試成績是沒有概念的。可否在線下設立一些龍芯電腦體驗店，或者開放一些遠程桌面？讓有心支持國產的消費者親身體驗下是否能夠滿足自身需求來決定購買。</p><blockquote><p>謝謝建議。我們會認真考慮實施。</p></blockquote><p>&nbsp;</p><p>胡老師，很看好龍芯的 gpgpu 發展，相信有一天也會跟龍芯的 CPU 一樣在國內一騎絕塵，請問龍芯有沒有在車機或者智能芯片佈局的計劃，做出像高通 8155 車機芯片，地平線征程系列那樣的智駕芯片計劃？</p><blockquote><p>龍芯目前主要做面向推理的 AI 芯片，形成 CPU+GPGPU 的最佳解決方案。</p><p>我相信，隨着應用的拓展，龍芯芯片的 AI 應用會很普遍。</p></blockquote><p>&nbsp;</p><p>胡老師您好！請問 2022/2023 年政策性市場停滯的原因主要是什麼？2024/2025 年政策性市場能否像預期一樣放量？</p><blockquote><p>感覺 2023Q4，政務類政策性市場部分回暖。我自己對 2024/2025 年預期不變。</p></blockquote><p>&nbsp;</p><p>龍芯以前介紹過車規級 mcu 印象説的好像是流片了，目前有沒有新進展？龍芯對於新能源汽車領域有沒有大的佈局？感覺這塊是一個大的市場，特別是當前形勢下，龍芯這種有硬實力的 CPU 企業在國產替代大有可為。</p><blockquote><p>已經與部分汽車企業開展 MCU 替換工作。龍芯會把電機驅動作為重點方向。</p></blockquote><p>&nbsp;</p><p>1、可否簡單介紹一下一帶一路國家市場整體佈局節奏和規劃？<br> 2、農村包圍城市的大策略是對的，不過如果整機終端有標杆性大客户是否可以更好的帶動芯片銷售？<br> 3、龍芯芯片整體性能不錯的情況下，解決特定的某一項或兩項需求痛點，形成差異化優勢，也許可以脱穎而出？&nbsp;</p><blockquote><p>總體上説，龍芯要聯合一帶一路國家形成新型信息技術體系和產業生態，在不斷探索中。</p><p>信創市場會帶動龍芯技術進步，同時也有不少品牌整機客户支持龍芯，整機客户主要是看性價比。</p><p>我相信，如果龍芯性價比達到一定水平，肯定會有越來越多的品牌整機使用。同時，要做第三套生態，一定要重構產業鏈。 感謝你的建議，我最近多次講的「點面結合」中的「點」與你的第三點建議是一致的。</p></blockquote><p>&nbsp;</p><p>能否加快 GPGPU 的研發，不要怕花錢，這是一個新興市場，速度越快越好。</p><blockquote><p>待 2K3000 中得到驗證後，會加速研發的。主要是自主研發需要迭代。</p></blockquote><p>&nbsp;</p><p>有企業採購和技術人員表示龍芯銷售人員很不專業，沒法解釋龍芯的特點和優點，沒法迴應對手的攻擊銷售術語，沒銷售技巧，有的地區銷售人員甚至已經消失了很長時間。請問龍芯銷售人員是否熟悉龍芯產品，日常是否使用過龍芯自家的產品，以後怎麼提高。</p><blockquote><p>龍芯公司包括辦公電腦、郵件服務器、網站服務器、OA 服務器、ERP 服務器、網絡安全產品，均使用龍芯 CPU。</p><p>龍芯的銷售需要改進的地方挺多的，正在改進中。但我要求銷售要有底線。</p><p>總體上，龍芯發展的主要矛盾還是產品能否滿足市場需求的矛盾，主要體現在系統性價比和軟件生態。</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 07:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265392</guid>
            <link>https://www.oschina.net/news/265392</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[「開源 Windows」 ReactOS 改進 UEFI 引導，支持更多硬件]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>ReactOS 開發團隊<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Freactos.org%2Fblogs%2Fnewsletter-103%2F" target="_blank">宣佈</a></u> 64 位（AMD64 和 ARM64）UEFI 引導功能現在可以在更多設備上使用了。這些設備包括個人電腦、諾基亞的 Lumia、蘋果的 iPhone 和 Valve 的 Steam Deck 等。</p><p><img src="https://static.oschina.net/uploads/space/2023/1108/144126_Cm3T_2720166.png" referrerpolicy="no-referrer"></p><p>從今年年初開始，開發團隊就着手將 ReactOS 的默認引導加載程序 FreeLoader 過渡到支持 x86 和 AMD64 以及 ARM32 和 ARM64 的 UEFI。ReactOS 核心開發者 Hermès 一直在開發一個用於傳遞 UEFI 幀緩衝區信息的系統，使 Windows XP 可以在 UEFI 系統上運行，而 Justin Miller (TheDarkFire) 則一直在開發 UEFI FreeLoader 構建。</p><p>除了支持引導 ReactOS 外，團隊還在開發其他功能，如 EFI 連鎖加載和 FreeLoader 的 bootmgfw 兼容構建。這些功能將增加引導管理功能，並允許現代 Windows 系統引導用户最喜歡的引導加載器。</p><p>除此之外，ReactOS 團隊還表示正在慢慢改善 NT6+ 應用程序的兼容性和支持。NT6+ 是一個術語，包括基於較新 NT 架構設計的 Vista、7、8、8.1、10 和 11 等 Windows 操作系統。</p><p>由於許多軟件開發商不再支持舊版本的 Windows 系統，因此日常使用的大多數應用程序都無法在 ReactOS 上運行。不過，這種情況將會改變。</p><p>目前，ReactOS 主要侷限於用户模式，內核模式的升級計劃稍後進行。目前還沒有預計的發佈時間。</p><blockquote><p>ReactOS 項目的主要目標就是提供一個與 Windows 環境二進制兼容的操作系統。它能讓你的 Windows 應用程序和驅動程序如同在 Windows 上一樣運行。</p><p>此外，由於應用了 Windows 操作系統的外觀特性，已經熟悉 Windows 用户界面的用户在使用 ReactOS 時將駕輕就熟。ReactOS 的終極目標是使你能夠在感覺不到最終用户體驗變化的前提下，使用 ReactOS 來替代 Windows。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2019/0306/073550_CIxD_2720166.png" referrerpolicy="no-referrer"></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 06:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265587</guid>
            <link>https://www.oschina.net/news/265587</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[解密 deepin-IDE：如何實現簡單靈活的調試技術？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p>前不久深度科技旗下 deepin 社區發佈了自己的 IDE：deepin-IDE，得到了全網用户尤其是開源社區用户的廣泛關注，目前在 GitHub（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flinuxdeepin%2Fdeepin-unioncode" target="_blank">https://github.com/linuxdeepin/deepin-unioncode</a>）倉庫的 star 數量已經達到 600 多個，説明大家的熱情還是很高漲的。</p><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922163311.png" referrerpolicy="no-referrer"></div><p>為了從技術層面給大家的熱情做一個反饋，本文試着將 deepin-IDE 內部的一些實現方法進行分享，希望能夠解答友友們的疑惑並得到積極的反饋。</p><p>本篇挑了大家關心的「調試」部分進行分享。需要説明的是，deepin-IDE 的調試功能是選用 DAP（Debug Adapter Protocol ）調試適配協議實現的，所以整體架構是圍繞該協議搭建的，至於<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>具體是什麼，讓我們帶着問號往下看。</p><h2>什麼是<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>協議</h2><p><code>DAP</code><span>&nbsp;</span>即調試適配協議 ( Debug Adapter Protocol )，顧名思義，它是用來對多種調試器進行抽象統一的適配層，將原有<span>&nbsp;</span><code>IDE</code><span>&nbsp;</span>和調試工具直接交互的模式更改為和<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>進行交互。該模式可以讓<span>&nbsp;</span><code>IDE</code><span>&nbsp;</span>集成多種調試器變得更簡單，且靈活性更好。</p><p>在<span>&nbsp;</span><code>IDE</code><span>&nbsp;</span>中的調試功能有許多小功能組成，包括單步執行、斷點、查看變量值等，常規的實現方式是在每個<span>&nbsp;</span><code>IDE</code><span>&nbsp;</span>中去實現這些邏輯，且因為調試工具的接口不同，還需要為每個調試工具做一些適配工作，這將導致大量且重複的工作，如下圖所示：</p><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922164609.png" referrerpolicy="no-referrer"></div><p>調試適配器協議背後的想法是標準化一個抽象協議，用於開發工具如何與具體調試器通信。這個思想和<span>&nbsp;</span><code>LSP</code>(Language Server Protocol) 和<span>&nbsp;</span><code>BSP</code>(Build Server Protocol) 類似，都是通過協議去統一相同功能在不同工具之間的差異性。其所處位置如下圖所示，其中左邊為不同的開發工具，右邊為不能同的調試器，不同於開發工具和調試器直接交互的方式，<code>DAP</code><span>&nbsp;</span>將這些交互統一了起來，讓開發工具和調試工具都面向<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>編程。</p><p>上圖中的交互是通過協議進行，所以不會像通過<span>&nbsp;</span><code>API</code><span>&nbsp;</span>的方式存在語言限制，可以更好的適應調試器的集成。</p><h2>DAP 如何工作</h2><p>以下部分解釋了開發工具（例如<span>&nbsp;</span><code>IDE</code><span>&nbsp;</span>或編輯器）和調試適配器之間的交互，包括具體的協議格式説明、交互流程等。</p><h3>調試會話</h3><p>開發工具有兩種基礎的方式和調試器進行交互，分別是:</p><p>【單會話模式】</p><p>在這種模式下，開發工具啓動一個調試適配器作為一個單獨的進程並且通過標準的 std 接口進行通信。在調試會話的結束時調試適配器就終止，對於當前的調試會話，開發工具往往需要實現多個調試適配。</p><p>【多會話模式】</p><p>在這種模式下，開發工具不會啓動調試適配器，而是假定它已經在運行並且會在特定端口上偵聽連接嘗試，對於每個調試會話，開發工具在特定端口上啓動一個新的通信會話並在會話結束時斷開連接。</p><p>在與調試適配器建立連接後，開發工具和調試適配器之間通過基礎協議進行通信。</p><h3>基礎協議</h3><p>基礎協議由兩部分組成，包括頭和內容 (類似於 HTTP)，頭部和內容部分通過「\r\n」進行分割：</p><p>【協議頭】</p><p>協議頭部分由字段組成， 每個頭字段由一個鍵和一個值組成，用‘:’（一個冒號和一個空格）分隔， 每個頭字段都以「\r\n「結尾。由於最後一個協議頭字段和整個協議頭本身都以 \r\n 終止，並且由於協議頭是強制性的，所以消息的內容部分總是在（並唯一標識）兩個 \r\n 序列之前。當前只支持一個協議頭字段：</p><table style="border-spacing:0px; max-width:100%"><tbody><tr><th style="text-align:left">頭字段名</th><th style="text-align:left">值類型</th><th style="text-align:left">描述</th></tr></tbody><tbody><tr><td style="border-style:double; border-width:1px; text-align:left">Content-Length</td><td style="border-style:double; border-width:1px; text-align:left">數字</td><td style="border-style:double; border-width:1px; text-align:left">這個字段是必須的，用來記錄內容字段的長度，單位是字節。</td></tr></tbody></table><p>協議頭部分使用的是「ASCII」編碼。</p><p>【內容部分】</p><p>內容部分包含了實際要傳輸的數據，這些數據用<span>&nbsp;</span><code>JSON</code><span>&nbsp;</span>格式來描述請求、響應和事件。內容部分用的是<span>&nbsp;</span><code>utf-8</code><span>&nbsp;</span>編碼</p><p>為了有個具體的認識，這裏舉個簡單的例子。在調試過程中，開發人員經常會使用到下一步操作，在<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>中其協議為：</p><div><pre><code class="language-plain">Content-Length: 119\r\n
\r\n
{
 &nbsp; &nbsp;"seq": 153,
 &nbsp; &nbsp;"type": "request",
 &nbsp; &nbsp;"command": "next",
 &nbsp; &nbsp;"arguments": {
 &nbsp; &nbsp; &nbsp; &nbsp;"threadId": 3
 &nbsp;  }
}
</code></pre></div><p>類型是「請求」，命令是下一步，參數部分可以攜帶多個，這裏是用的線程 Id。 這個協議看着挺簡單的，是吧？接下來就講講如何使用它。</p><h3>使用方法</h3><p>詳細的使用方法這裏就不涉及，因為用一個時序圖就可以説明：</p><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922164954.png" referrerpolicy="no-referrer"></div><p>可以看到，初始化、請求、響應等必要的步驟都在圖中。其中調試適配器可以理解為調試器的抽象，調試功能的最終執行者是由對應語言的調試工具實現的。</p><h2>在 deepin-IDE 中的實現</h2><p>在 deepin-IDE 中，調試功能的實現是結合<span>&nbsp;</span><code>cppdap</code><span>&nbsp;</span>+<span>&nbsp;</span><code>debugmanager</code><span>&nbsp;</span>實現的。</p><p><code>cppdap</code><span>&nbsp;</span>是一款基於 C++ 開發的<span>&nbsp;</span><code>SDK</code>，基本實現了<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>的全量協議。 deepin-IDE 的客户端和服務端都是應用的該<span>&nbsp;</span><code>SDK</code><span>&nbsp;</span>進行開發，據此可以實現以下功能：</p><p>1.通信功能，包括服務端的 TCP 監聽，客户端的 TCP 連接等；</p><p>2.<code>DAP</code><span>&nbsp;</span>協議的封裝，並實現協議的串行化和解串行化；</p><p>3.提供註冊回調功能，從而可以在回調內處理各種事件、請求等；</p><p>它的層級結構如下：</p><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922165226.png" referrerpolicy="no-referrer"></div><p>用<span>&nbsp;</span><code>cppdap</code><span>&nbsp;</span>可以減少客户端和服務端不少工作量，也統一了兩邊的協議數據。而 debugmanager 可以理解為調試器的抽象，包含所有必要的調試要素。整體結構如下：</p><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922165251.png" referrerpolicy="no-referrer"></div><p>左邊是客户端，右邊是服務端，內部實現如下：</p><h3>客户端實現</h3><p>客户端包含了兩個個主要功能，一個是和<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>服務端進行交互，發送調試命令或處理返回的數據；另一個是將<code>DAP</code><span>&nbsp;</span>數據轉換後顯示到用户界面，並響應界面發送的事件。概括起來就包含業務模塊、事件模塊、<code>DAP</code><span>&nbsp;</span>模塊和界面 4 個部分。</p><p>業務模塊</p><ul><li><p>業務模塊包含了插件類、調試參數、調試管理類等，其中插件類負責插件加載、初始化、獲取上下文等，調試管理類用來組合事件、<code>DAP</code>、界面幾個模塊。 事件模塊</p></li><li><p>事件模塊包含兩個子模塊，分別是事件發送和事件接收，比如頁面跳轉事件、添加\移除斷點事件等。<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>模塊</p></li></ul><p><code>DAP</code><span>&nbsp;</span>模塊基於<span>&nbsp;</span><code>cppdap</code><span>&nbsp;</span>開發，採用層級結構，底層是原始<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>協議封裝，中間層是針對業務做的進一步封裝，簡化了向外提供的接口，最上層是對整個調試功能的整合，包括數據緩存、界面元素、命令收發。</p><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922165331.png" referrerpolicy="no-referrer"></div><ul><li>界面部分，界面模塊包含堆棧界面、變量界面、斷點列表、異步對話框等，用於<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>的數據展示。</li></ul><div><img src="https://wiki.deepin.org/05_HOW-TO/deepin-unioncode/img-20230922165342.png" referrerpolicy="no-referrer"></div><ul><li>如上圖所示，灰色部分為<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>客户端的界面呈現。</li></ul><h3>服務端實現</h3><p>服務端的功能分為兩個部分，一個是基於<span>&nbsp;</span><code>cppdap</code><span>&nbsp;</span>實現命令的收發，另一個是與<span>&nbsp;</span><code>gdb</code><span>&nbsp;</span>交互，實現調試程序的啓動、暫停、退出等一系列動作。</p><p>DAP</p><ul><li><p>和客户端一樣，服務端也是基於<code>cppdap</code>實現的通信和協議封裝和解析。 調試工具</p></li><li><p>和調試工具的交互是通過進程調用的方式實現，接收進程輸出得到返回信息。如果調試工具本身支持<span>&nbsp;</span><code>DAP</code><span>&nbsp;</span>協議，則可以直接交互。</p></li></ul><p>至此，本次的分享就到這兒啦！不知道你對<span>&nbsp;</span><code>deepin-IDE</code><span>&nbsp;</span>中的調試功能有所瞭解了嗎？</p><p>温馨提示，deepin-IDE 還包含很多有意思的功能，如果大家感興趣可以積極反饋，後續有機會再進行分享。</p><h2>參考文檔</h2><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmicrosoft.github.io%2Fdebug-adapter-protocol%2Foverview" target="_blank">debug-adapter-protocol</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwiki.deepin.org%2Fzh%2F05_HOW-TO%2F02_%25E5%25BC%2580%25E5%258F%2591%25E7%259B%25B8%25E5%2585%25B3%2Fdeepin-unioncode" target="_blank">deepin-IDE 使用手冊</a></p><p>內容來源：deepin 社區</p><p>內容作者：deepin-mozart、toberyan</p></div></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 06:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265585/deepin-ide-debug</guid>
            <link>https://www.oschina.net/news/265585/deepin-ide-debug</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[蘋果暫停 iPhone 和 Mac 的系統新功能開發工作，專注修復 bug]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>彭博社報道稱，蘋果公司罕見地暫停了明年 iPhone、iPad、Mac 和其他設備的軟件更新開發工作，以便根除代碼中的 bug。</p><p><img src="https://static.oschina.net/uploads/space/2023/1108/141600_8Btu_2720166.png" referrerpolicy="no-referrer"></p><p>via <em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2023-11-07%2Fapple-delays-work-on-ios-18-macos-15-watchos-11-due-to-problems-with-bugs" target="_blank">彭博社</a></u></em></p><p>蘋果上週在內部向員工宣佈了這一決定，<strong>公司工程師現在的主要任務不是添加新功能而是修復 bug 和改進性能</strong>。</p><p>在準備明年發佈的新操作系統時，軟件工程管理團隊在內部測試中發現了太多的<strong>"escapes"</strong>問題（內部測試期間遺漏的錯誤）。由於數千名不同的蘋果員工在各種操作系統和設備上工作，這些操作系統和設備需要無縫協作，因此很容易出現故障。</p><p>因此他們採取了不同尋常的做法，暫停新功能開發一週，專注於修 bug。雖然暫停一週，但發版時間仍按原計劃進行。</p><p>目前還不清楚此次暫停開發一週對上述系統來説存在哪些影響，彭博社稱這是蘋果非常罕見的舉動。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 06:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265579</guid>
            <link>https://www.oschina.net/news/265579</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[極致性能優化：前端 SSR 渲染利器 Qwik.js]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><span><span>引言</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>前端性能已成為網站和應用成功的關鍵要素之一。用户期望快速加載的頁面和流暢的交互，而前端框架的選擇對於實現這些目標至關重要。然而，傳統的前端框架在某些情況下可能面臨性能挑戰且存在技術壁壘。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在這個充滿挑戰的背景下，我們引入了 Qwik.js 框架。Qwik.js 不僅是一個前端框架，更是一種前端性能的終極解決方案。它不僅提供了卓越的性能，還以其獨特的特點和優勢脱穎而出。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>讓我們一起深入探索 Qwik.js，發現它如何超越傳統，成為前端性能優化的新標杆。</span></span></span></p><span id="OSC_h1_2"></span><h1><span><span><span>一、現有框架的問題</span></span></span></h1><span id="OSC_h4_3"></span><h4><span>1.</span><span><span><span><span>傳統 CSR 方案</span></span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>慢加載時間：</span></strong></span></span><span><span><span> CSR 技術通常要求在瀏覽器中加載和渲染整個頁面，這導致初始頁面加載時間較長。用户必須等待頁面完全加載才能進行交互。 </span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>搜索引擎優化（SEO）問題：</span></strong></span></span><span><span><span> 由於頁面內容是在客户端生成的，搜索引擎爬蟲可能無法正確解析和索引頁面內容，這影響了網站的 SEO 效果。 </span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>不利於低帶寬用户：</span></strong></span></span><span><span><span> 對於低帶寬用户或網絡條件較差的用户，CSR 頁面加載時間更長，用户體驗更差。 </span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>首屏渲染延遲：</span></strong></span></span><span><span><span> CSR 通常需要等待 JavaScript 文件的下載和執行，這導致了首屏渲染的延遲，影響了用户的第一印象。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>問題分析</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>A. 渲染階段耗時分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="108" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-13xZmbiiPDHyfVKHl.png" width="588" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>B. 請求鏈路分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="311" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-14Jn48bC9MLjg7uj48.png" width="291" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>C. 瀏覽器執行渲染分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="230" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-15HAl9koUb6m9MG98.png" width="345" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h4_4"></span><h4><span><span><span>2. 傳統 SSR 方案</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>複雜的水合過程：</span></strong></span></span><span><span><span> 涉及複雜的水合過程，包括將數據傳輸到客户端並在客户端重新渲染頁面。這增加了頁面加載時間和網絡開銷。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>A. 請求鏈路分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="366" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-27a6p7RKalKkQgqE12.png" width="275" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>B. 瀏覽器執行渲染分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="236" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-23GQJadOUFvz9gVjT.png" width="387" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h4_5"></span><h4><span><span><span>什麼是水合（Hydration）？</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>"hydration"（水合）是指通過客户端 JavaScript 將靜態 HTML 網頁轉化為動態網頁的過程，以實現對 HTML 元素的事件處理。這個過程可以通過將事件處理程序附加到 HTML 元素上來完成</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="304" src="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F4f48568655904e4586ba34b413beb790?width=580" width="390" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>深入瞭解水合（hydration）過程，水合的難點在於知道我們需要什麼事件處理程序以及它們應該附加到哪裏。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>WHAT（什麼）</span></strong></span></span><span><span><span>：事件處理程序是一個封閉包，包含了事件處理程序的行為。它定義了當用户觸發此事件時應該發生什麼。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>WHERE（哪裏）</span></strong></span></span><span><span><span>：指的是需要將 WHAT（事件處理程序）附加到的 DOM 元素的位置，這包括了事件類型。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>更復雜的部分在於，WHAT（事件處理程序）是一個封閉包，它封閉了 APP_STATE（應用程序狀態）和 FRAMEWORK_STATE（框架內部狀態）：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>APP_STATE（應用程序狀態）</span></strong></span></span><span><span><span>：這是應用程序的狀態。APP_STATE 通常是人們所説的狀態。沒有 APP_STATE，您的應用程序將無法向用户展示任何動態內容。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>FRAMEWORK_STATE（框架內部狀態）</span></strong></span></span><span><span><span>：這是框架的內部狀態。沒有 FRAMEWORK_STATE，框架不知道應該更新哪些 DOM 節點以及何時應該更新它們。這包括組件樹和對渲染函數的引用等內容。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>那麼，我們如何恢復 WHAT（APP_STATE + FRAMEWORK_STATE）和 WHERE 呢？方法是通過下載並執行當前 HTML 中的組件。在 HTML 中下載和執行已渲染的組件是水合的昂貴部分。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>換句話説，水合是一種通過在瀏覽器中急切地執行應用程序代碼來恢復 APP_STATE 和 FRAMEWORK_STATE 的方法，它涉及以下步驟：</span></span></span></p><ol><li><span><span><span><span>下載組件代碼。</span></span></span></span></li><li><span><span><span><span>執行組件代碼。</span></span></span></span></li><li><span><span><span><span>恢復 WHAT（事件處理程序閉包）和 WHERE（DOM 元素），以獲取事件處理程序閉包。</span></span></span></span></li><li><span><span><span><span>將 WHAT（事件處理程序閉包）附加到 WHERE（DOM 元素）。</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這個過程的關鍵是將 APP_STATE 和 FRAMEWORK_STATE 從已渲染的組件中恢復，以確保應用程序在客户端獲得正確的狀態和行為。這對於實現前端與後端的協同工作以提供動態用户體驗至關重要。</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="298" src="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F0e1bbc52c75747328b846dcfa76c28f2?width=905" width="660" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_6"></span><h1><span><span><span>二、Qwik.js 框架的特點</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可恢復性（Resumability）：一種無開銷的水合替代方案，那麼，如何設計一個沒有水合且沒有開銷的系統呢？</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>為了消除開銷，框架不僅必須避免恢復（RECOVERY），還必須避免上述所提到的第四步。第四步是將 WHAT 附加到 WHERE，這是可以避免的成本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>要避免這種成本，您需要三樣東西：</span></span></span></p><ol><li><span><span><span><span>將所有所需的信息序列化為 HTML 的一部分。序列化的信息需要包括 WHAT、WHERE、APP_STATE 和 FRAMEWORK_STATE。</span></span></span></span></li><li><span><span><span><span>一個全局事件處理程序，依賴事件冒泡來攔截所有事件。事件處理程序需要是全局的，這樣我們就不需要急切地在特定的 DOM 元素上單獨註冊所有事件。</span></span></span></span></li><li><span><span><span><span>一個工廠函數，可以延遲恢復事件處理程序（WHAT）。</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這種方法的關鍵是在 HTML 中序列化所有必需的信息，以及使用全局事件處理程序來攔截和處理事件，而不必顯式將事件處理程序附加到特定的 DOM 元素上。這樣可以避免昂貴的步驟四，從而提供無開銷的可恢復性，同時仍能實現前端的互動性和性能優化。</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="304" src="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F04681212764f4025b2b5f5c6a258ad6e?width=905" width="675" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>A. 渲染階段耗時分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="118" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-28K9JFlwTqhvJg8Ai.png" width="500" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>B. 請求鏈路分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="383" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-28R2YSlad187SVu7u.png" width="207" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>C. 瀏覽器執行渲染分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="229" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-51g7EMHDw7dtR18CZV.png" width="342" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-11-19-32gB18uqO0IYVB18KxX.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_7"></span><h1><span><span><span>四、效果和成果</span></span></span></h1><div><img alt="" height="371" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-15-06LfwBVIHYE9RvLeU.png" width="823" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-11-20-00jYipo69U6Njn9Sm.gif" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_8"></span><h1><span><span><span>五、挑戰</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Qwik.js 無水合方案可能會帶來一些挑戰，其中包括以下幾個方面：</span></span></span></p><ol><li><span><span><span><strong><span>新技術的學習曲線</span></strong></span></span><span><span><span>： 採用新的前端架構或技術，如 Qwik.js，通常需要團隊成員學習和適應新的工作流程和最佳實踐。這可能需要一些時間和培訓來確保團隊熟練掌握新技術。</span></span></span></span></li><li><span><span><span><strong><span>服務器開銷增加</span></strong></span></span><span><span><span>： 在無水合方案中，服務器可能需要更多的計算資源來序列化和提供所需的信息，以及處理全局事件處理程序。這可能會導致服務器開銷的增加，特別是在大量併發請求的情況下。</span></span></span></span></li><li><span><span><span><strong><span>Node.js 併發挑戰</span></strong></span></span><span><span><span>： 對於 Node.js 服務器，處理大量併發請求可能會帶來挑戰。在無水合方案中，服務器可能需要同時處理多個請求，因此需要考慮服務器的併發性能和擴展性。</span></span></span></span></li></ol><blockquote><p>作者：京東創新零售，李健</p><p>來源：京東雲開發者社區，轉載請註明來源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 05:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10141047</guid>
            <link>https://my.oschina.net/u/4090830/blog/10141047</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[M3 MacBook Pro 無法從預裝的 'Ventura' 系統升級至 'Sonoma']]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>配備標準 M3 芯片的新款入門級 14 英寸 MacBook Pro 已經開始發貨。部分用户發現，這款新產品預裝的是 macOS Ventura (13.5)，目前無法通過 OTA 升級的方式升級至 macOS Sonoma (14)。</p><p>這些用户<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Faaronp613%2Fstatus%2F1721742053170684065" target="_blank">表示</a></u>，他們嘗試在「系統設置」中更新到 macOS Sonoma 時，系統提示 macOS Ventura 13.5 是可用的最新版本，而非 macOS Sonoma 14.1。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1108/115949_tV93_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>via<em><u>&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2FZONEofTECH%2Fstatus%2F1721868285732344224" target="_blank">https://twitter.com/ZONEofTECH/status/1721868285732344224</a></u></em></p><p>目前尚不清楚蘋果何時會解決這個問題。軟件研究員 Nicolás Álvarez 表示，受影響用户可以下載 <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fswcdn.apple.com%2Fcontent%2Fdownloads%2F54%2F11%2F042-41700-A_6GDS7ETYNV%2Fzxpkgymp3w9bm3py7ybs9n9ud27qwnwx7u%2FInstallAssistant.pkg" target="_blank">macOS Sonoma 14.1 安裝助手</a></u>（兼容 M3 版本）並手動安裝更新。</p><p>據稱這個問題也會<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F9to5mac.com%2F2023%2F11%2F07%2Fm3-macbook-pro-imac-sonoma-fails%2F" target="_blank">影響</a></u>搭載 M3 芯片的新款 iMac。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 04:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265559/macbook-pro-m3-macos-sonoma-update-issue</guid>
            <link>https://www.oschina.net/news/265559/macbook-pro-m3-macos-sonoma-update-issue</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[IBM 推出 5 億美元企業 AI 風險投資基金]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">IBM&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.prnewswire.com%2Fnews-releases%2Fibm-launches-500-million-enterprise-ai-venture-fund-301979178.html" target="_blank">宣佈</a>計劃對專注於企業 AI 的初創公司進行更多投資，將啓動一項 5 億美元的風險投資基金。該基金將投資「一系列&nbsp;AI&nbsp;公司 —— 從早期階段到高速增長的初創公司 —— 專注於加速企業的生成式 AI 技術和研究。」</span></p><p><span style="color:#000000">今年 8 月份，IBM&nbsp;還參與了開源 AI 平台 Hugging Face 的 2.35 億美元 D 輪融資。並在近期參投了 AI 模型和資產安全廠商 HiddenLayer 的 5000 萬美元 A 輪融資，此輪融資也是今年專注於保護 AI 的網絡安全公司籌集的最大一筆 A 輪融資。</span></p><p><img height="188" src="https://oscimg.oschina.net/oscnet/up-4118d3cd5048d2cdd19ef109bc0e70b828e.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000">IBM 方面表示，其企業 AI 風險基金將投資於當前和未來的&nbsp;AI&nbsp;領導者，幫助世界各地的企業實現 AI 的商業潛力。該基金由 IBM 的一支專業團隊領導，為每家初創公司提供與 IBM 建立有意義的合作伙伴關係的機會，同時獲得產品和工程以及上市方面的運營專業知識策略。</span></p><p><span style="color:#000000">IBM 軟件高級副總裁兼首席商務官 Rob Thomas 稱，</span></p><p><span style="color:#000000">「到 2030 年，&nbsp;AI&nbsp;預計將創造近 16 萬億美元的生產力。隨着 IBM 企業&nbsp;AI&nbsp;風險投資基金的推出，我們正在開闢另一個渠道，利用 AI 革命的巨大潛力，為 IBM 和我們所投資的公司帶來實實在在的積極成果。這筆基金是我們通過 watsonx 加倍履行我們對負責任的 AI&nbsp;創新的承諾，並幫助企業將這一變革性技術付諸實踐的又一方式。」</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 03:37:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265552/ibm-500-million-enterprise-ai-venture-fund</guid>
            <link>https://www.oschina.net/news/265552/ibm-500-million-enterprise-ai-venture-fund</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[蘋果副總裁迴應「黃金內存」：「統一內存架構」的 8GB 近似於其它系統的 16GB]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>B 站 up 主 @林亦 LYi 最近採訪了蘋果全球產品營銷副總裁 Bob Borchers，期間聊到了大家關心的「祖傳黃金 8GB 內存」問題。</p><p>針對蘋果入門級 MacBook Pro 只給 8GB 內存的問題，Bob Borchers 表示蘋果 MacBook Pro 採用了統一內存架構，所以它與其它系統的內存並不完全相同。因為蘋果內存利用率更高，再加上蘋果的內存壓縮技術，蘋果 M3 款 MacBook Pro 中&nbsp;8GB 內存和其它系統的 16GB 表現接近，所以不能只看紙面參數，要關注實際體驗。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-93ec8d8aebc69057228bb55fb8b7229e485.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a317c842c946aae94e3674f1efda6cef21e.png" referrerpolicy="no-referrer"></p><p>【8G 內存？蘋果高管怎麼看 M3 MacBook Pro？】<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV16M411Q7BG%2F" target="_blank">https://www.bilibili.com/video/BV16M411Q7BG/</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 03:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265547</guid>
            <link>https://www.oschina.net/news/265547</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度向華為訂購 1600 片昇騰 910B AI 芯片，60% 訂單已交付]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reuters.com%2Ftechnology%2Fbaidu-placed-ai-chip-order-huawei-shift-away-nvidia-sources-2023-11-07%2F">根據路透社的報道</a></u>，百度為 200 台服務器訂購了 1600 片昇騰 (Ascend) 910B AI 芯片。到 10 月份，華為已向百度交付了超過 60% 的訂單。</p><p>消息人士稱，訂單總價值約為 4.5 億元人民幣（6183 萬美元），華為將在今年年底前交付所有芯片。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-fb485132e1507877526a821c6e4d46168e9.png" referrerpolicy="no-referrer"></p></blockquote><p>分析稱，與過去通常從英偉達訂購的數千顆芯片相比，儘管這個訂單量規模較小，但知情人士表示它具有重要意義。</p><p>據瞭解，百度與騰訊和阿里巴巴等中國同行一樣，都是英偉達的長期客户。不過百度此前並不是華為的 AI 芯片客户。</p><p>儘管華為的 Ascend 芯片在性能上仍被認為遠不如 NVIDIA 的芯片，但消息人士稱，華為的 Ascend 芯片是中國目前最先進的國產芯片，並表示："他們訂購 910B 芯片是為了應對未來可能無法再從 NVIDIA 購買芯片的情況。"</p><p>根據華為網站的公開信息，自 2020 年以來，華為一直與百度合作，使其人工智能平台與華為硬件兼容。今年 8 月，兩家公司表示將深化百度 Ernie AI 模型與華為 Ascend 芯片之間的兼容性。</p><p>天風證券點評稱，昇騰 910B 為 910 的半代升級款，<strong>其性能對標英偉達 A100</strong>，此前星火一體機是 910B 芯片首個對外商業化應用產品。據測算，英偉達限令升級後 2024 年 AI 國產芯片新增市場空間 700 億 +。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 02:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265543</guid>
            <link>https://www.oschina.net/news/265543</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Fedora 39 正式發佈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Fedora 39 已正式發佈。此版本採用 Linux 6.5 內核，更新的版本將作為穩定版更新發布。</p><p><img src="https://static.oschina.net/uploads/space/2023/1108/111228_g9O6_2720166.png" referrerpolicy="no-referrer"></p><p><strong>下載地址</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fworkstation%2Fdownload%2F" target="_blank">Fedora Workstation 39</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fserver%2Fdownload%2F" target="_blank">Fedora Server 39</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fiot%2Fdownload%2F" target="_blank">Fedora IoT 39</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fcloud%2Fdownload%2F" target="_blank">Fedora Cloud 39</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fcoreos%2Fdownload%3Fstream%3Dnext" target="_blank">Fedora CoreOS 「next」 stream</a></li></ul><p>Fedora Workstation 39 搭載 GNOME 45 桌面環境、LibreOffice 7.6 辦公套件、LLVM 17 編譯器棧以及許多其他可用的更新軟件包。</p><p>Fedora 39 還有各種工具鏈升級，如 GCC 13.2 和 GNU Binutils 2.40、Glibc 2.38 以及其他更新，如 Python 3.12 和 RPM 4.19。Fedora Onyx 也將作為 Fedora 不可變變體與 Budgie 桌面正式亮相。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d3bc4d25724768ddc84dd034104a3f7e4e9.png" referrerpolicy="no-referrer"></p><p><strong>以下是官方介紹譯文：</strong></p><p>2003 年 11 月 6 日，Fedora 項目發佈了 Fedora Core 1。二十年後的今天 Fedora Linux 39 正式發佈，這是為台式機、筆記本電腦、服務器、雲、邊緣設備以及您能想到的任何其他設備打造的完整的社區操作系統。</p><p>Fedora 工作站現在採用 GNOME 45，它帶來了更好的性能和許多可用性增強功能，包括一個新的工作區切換器和一個大為改進的圖片查看器。</p><p>如果您正在尋找不同的桌面體驗，Budgie 特別興趣小組已經創建了 Fedora Onyx，這是一個基於 Budgie 的"原子"桌面，與 Fedora Silverblue 的精神一脈相承。</p><p>當然，這還不是全部，系統還提供了 KDE Plasma 桌面、Xfce、Cinnamon 等桌面。</p><p>Fedora 雲鏡像將在 Microsoft Azure（除了 Google Cloud 和 AWS 之外）正式可用。此外，我們的雲鏡像現在已配置為 cloud-init（由您選擇）安裝更新，並在首次調配時重啓，這樣您就可以知道您正在運行的是最新的安全更新。</p><p>一如既往，Fedora 39 更新了很多很多其他軟件包，包含 gcc 13.2、binutils 2.40、glibc 2.38、gdb 13.2 和 rpm 4.19。它還更新了流行的編程語言棧，包括 Python 3.12 和 Rust 1.73。</p><p>特別值得一提的是，系統包含了 Inkscape 的最新版本，這是一款流行的矢量圖形插圖和繪圖工具。Inkscape 昨天也滿 20 週歲了。</p><p>原文：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoramagazine.org%2Fannouncing-fedora-linux-39%2F" target="_blank">https://fedoramagazine.org/announcing-fedora-linux-39/</a></u></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 02:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265540/fedora-linux-39</guid>
            <link>https://www.oschina.net/news/265540/fedora-linux-39</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Bun 招募運行時工程師，要求 C/C++ 或 Zig 經驗，可遠程]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Bun 公司正在招聘運行時工程師。Bun 是速度極快的 JavaScript 運行時，採用 Zig 編寫，集打包器、轉譯器和包管理器於一身。</p><h4><strong>任職要求</strong></h4><ul><li><p>在系統編程語言如 Zig 或 C/C++方面有豐富的經驗</p></li><li><p>對互聯網技術如 JavaScript/TypeScript 和 HTTP 有深入理解</p></li><li><p>熱衷於編寫快速高效的代碼</p></li></ul><h4><strong>加分項</strong></h4><ul><li><p>具有 Zig 的經驗（大部分的 Bun 都是用 Zig 編寫的）</p></li><li><p>具有 JavaScript 運行時深入層面的經驗：JavaScriptCore、V8、SpiderMonkey</p></li><li><p>理解 UNIX 系統、內核、TCP/UDP 網絡</p></li><li><p>理解如何構建多租户，大規模分佈式系統</p></li><li><p>開源軟件的維護者或頻繁的貢獻者</p></li></ul><h4><strong>福利</strong></h4><ul><li><p>位置：舊金山市中心有自己的辦公室，並且每天提供免費午餐</p></li><li><p>遠程工作 OK：如果願意搬到舊金山，會提供額外的獎金，但可以在任何地方遠程辦公</p></li><li><p>薪酬：提供具有競爭力的薪酬，包括創業公司的股權，並根據貢獻提供成長空間</p></li><li><p>醫療保健：提供靈活的健康計劃，涵蓋身體和精神健康護理</p></li><li><p>休假：每年享有四周的帶薪休假，包括靈活的病假、家庭假和心理健康假</p></li><li><p>補貼：通勤到辦公室，電腦硬件，辦公室設置，以及健身習慣等方面提供支持</p></li></ul><p><img height="1762" src="https://static.oschina.net/uploads/space/2023/1108/103613_dUzY_3820517.png" width="1458" referrerpolicy="no-referrer"></p><p>詳情查看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fapply.workable.com%2Foven%2Fj%2FA7A1388873%2F" target="_blank">https://apply.workable.com/oven/j/A7A1388873</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 02:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265534/bun-hiring-runtime-engineer</guid>
            <link>https://www.oschina.net/news/265534/bun-hiring-runtime-engineer</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[LME - 日誌記錄和保護性監控解決方案]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Logging Made Easy (LME) 是一個免費、開放的日誌記錄和保護性監控解決方案，為所有組織提供服務。</p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Logging Made Easy 最初由 NCSC 創建，現在由 CISA 維護，是一個為小型組織提供的自助安裝教程，旨在為 Windows 客户端獲得基本級別的集中安全日誌記錄並提供檢測攻擊的功能。它是多個免費和開放軟件平台的結合，LME 幫助讀者將它們集成在一起以產生端到端的日誌記錄功能。還提供了一些預製的配置文件和腳本。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>該項目可以：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>顯示已註冊設備上運行管理命令的位置</li><li>查看誰在使用哪台機器</li><li>結合威脅報告，可以以策略、技術和程序 (TTP) 的形式查詢攻擊者的存在</li></ul><p><img height="229" src="https://static.oschina.net/uploads/space/2023/1101/164801_RGai_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 01:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/lme</guid>
            <link>https://www.oschina.net/p/lme</link>
        </item>
        <item>
            <title>
                <![CDATA[Xmake v2.8.5 發佈，支持鏈接排序和單元測試]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake" target="_blank">Xmake</a><span>&nbsp;</span>是一個基於 Lua 的輕量級跨平台構建工具。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它非常的輕量，沒有任何依賴，因為它內置了 Lua 運行時。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它使用 xmake.lua 維護項目構建，相比 makefile/CMakeLists.txt，配置語法更加簡潔直觀，對新手非常友好，短時間內就能快速入門，能夠讓用户把更多的精力集中在實際的項目開發上。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們能夠使用它像 Make/Ninja 那樣可以直接編譯項目，也可以像 CMake/Meson 那樣生成工程文件，另外它還有內置的包管理系統來幫助用户解決 C/C++ 依賴庫的集成使用問題。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">目前，Xmake 主要用於 C/C++ 項目的構建，但是同時也支持其他 native 語言的構建，可以實現跟 C/C++ 進行混合編譯，同時編譯速度也是非常的快，可以跟 Ninja 持平。</p><div><pre><code>Xmake = Build backend + Project Generator + Package Manager + [Remote|Distributed] Build + Cache
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">儘管不是很準確，但我們還是可以把 Xmake 按下面的方式來理解：</p><div><pre><code>Xmake ≈ Make/Ninja + CMake/Meson + Vcpkg/Conan + distcc + ccache/sccache
</code></pre></div><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake" target="_blank">項目源碼</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fxmake.io%2F%23%2Fzh-cn%2F" target="_blank">官方文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fxmake.io%2F%23%2Fzh-cn%2Fabout%2Fcourse" target="_blank">入門課程</a></li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><img src="https://github.com/xmake-io/xmake-docs/raw/master/assets/img/index/package.gif" width="650px" referrerpolicy="no-referrer"></p><h2>新特性介紹</h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在介紹新特性之前，我們有一個好消息要告訴大家，Xmake 最近進入了 Debian 的官方倉庫：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpackages.debian.org%2Fsid%2Fxmake" target="_blank">https://packages.debian.org/sid/xmake</a>， 等到明年 4 月份 Ubuntu 24.04 發佈，我們應該就能直接通過<span>&nbsp;</span><code>apt install xmake</code><span>&nbsp;</span>命令去快速安裝 Xmake 了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">同時也感謝 @Lance Lin 的幫助，他全程幫助我們維護並上傳 Xmake 包到 Debian 倉庫，真的非常感謝！</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">接下來，我們來介紹下 2.8.5 版本引入的一些改動，這個版本帶來了很多的新特性，尤其是對鏈接排序，鏈接組的支持，還有對<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>內置單元測試的支持。 另外，我們還新增了 Apple XROS 平台的構建支持，可以用於構建蘋果新的 VisionOS 上的程序，還有我們還提供了更加靈活通用的<span>&nbsp;</span><code>check_sizeof</code><span>&nbsp;</span>檢測接口，用於快速檢測類型的大小。</p><h3>鏈接重排序支持</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這是一個存在了兩年多的需求，主要用於調整 target 內部的鏈接順序。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">由於 xmake 提供了<span>&nbsp;</span><code>add_links</code>,<span>&nbsp;</span><code>add_deps</code>,<span>&nbsp;</span><code>add_packages</code>,<span>&nbsp;</span><code>add_options</code><span>&nbsp;</span>接口，可以配置目標、依賴，包和選項中的鏈接，儘管<span>&nbsp;</span><code>add_links</code><span>&nbsp;</span>本身的鏈接順序可以根據添加順序來調整。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是 links，deps 和 packages 之間的鏈接順序，只能按固定順序生成，無法靈活調整，這對於一些複雜的項目，就有點顯得力不從心了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">而我們在這個版本，徹底解決了這個問題，新增了<span>&nbsp;</span><code>add_linkorders</code><span>&nbsp;</span>接口，可用於配置目標、依賴、包、選項、鏈接組引入的各種鏈接順序。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">更多詳情和背景，請見：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F1452" target="_blank">#1452</a></p><h4>排序鏈接</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">為了更加靈活的調整 target 內部的各種鏈接順序，我們可以通過<span>&nbsp;</span><code>add_linkorders</code><span>&nbsp;</span>這個新接口來實現，例如：</p><div><pre><code><span style="color:#000000">add_links</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><span style="color:#ff00ff">"c"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>,</strong><span style="color:#ff00ff">"e"</span><strong>)</strong><em>-- e -&gt; b -&gt; a</em><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"e"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><span style="color:#ff00ff">"a"</span><strong>)</strong><em>-- e -&gt; d</em><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"e"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">add_links 是配置的初始鏈接順序，然後我們通過 add_linkorders 配置了兩個局部鏈接依賴<span>&nbsp;</span><code>e -&gt; b -&gt; a</code><span>&nbsp;</span>和<span>&nbsp;</span><code>e -&gt; d</code><span>&nbsp;</span>後。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">xmake 內部就會根據這些配置，生成 DAG 圖，通過拓撲排序的方式，生成最終的鏈接順序，提供給鏈接器。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">當然，如果存在循環依賴，產生了環，它也會提供警告信息。</p><h4>排序鏈接和鏈接組</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，對於循環依賴，我們也可以通過<span>&nbsp;</span><code>add_linkgroups</code><span>&nbsp;</span>配置鏈接組的方式也解決。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">並且<span>&nbsp;</span><code>add_linkorders</code><span>&nbsp;</span>也能夠對鏈接組進行排序。</p><div><pre><code><span style="color:#000000">add_links</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><span style="color:#ff00ff">"c"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>,</strong><span style="color:#ff00ff">"e"</span><strong>)</strong><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"c"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>,</strong><strong>{</strong><span style="color:#000000">name</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">group</span><strong>=</strong><strong>true</strong><strong>})</strong><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"e"</span><strong>,</strong><span style="color:#ff00ff">"linkgroup::foo"</span><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果要排序鏈接組，我們需要對每個鏈接組取個名，<code><span>{</span><span>name</span><span><span>&nbsp;</span></span><span>=</span><span><span>&nbsp;</span></span><span>"foo"</span><span>}</span></code><span>&nbsp;</span>，然後就能在<span>&nbsp;</span><code>add_linkorders</code><span>&nbsp;</span>裏面通過<span>&nbsp;</span><code>linkgroup::foo</code><span>&nbsp;</span>去引用配置了。</p><h4>排序鏈接和 frameworks</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以排序鏈接和 macOS/iPhoneOS 的 frameworks。</p><div><pre><code><span style="color:#000000">add_links</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><span style="color:#ff00ff">"c"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>,</strong><span style="color:#ff00ff">"e"</span><strong>)</strong><span style="color:#000000">add_frameworks</span><strong>(</strong><span style="color:#ff00ff">"Foundation"</span><strong>,</strong><span style="color:#ff00ff">"CoreFoundation"</span><strong>)</strong><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"e"</span><strong>,</strong><span style="color:#ff00ff">"framework::CoreFoundation"</span><strong>)</strong></code></pre></div><h4>完整例子</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">相關的完整例子，我們可以看下：</p><div><pre><code><span style="color:#000000">add_rules</span><strong>(</strong><span style="color:#ff00ff">"mode.debug"</span><strong>,</strong><span style="color:#ff00ff">"mode.release"</span><strong>)</strong><span style="color:#000000">add_requires</span><strong>(</strong><span style="color:#ff00ff">"libpng"</span><strong>)</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"bar"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"shared"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/foo.cpp"</span><strong>)</strong><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"m"</span><strong>,</strong><span style="color:#ff00ff">"pthread"</span><strong>,</strong><strong>{</strong><span style="color:#000000">whole</span><strong>=</strong><strong>true</strong><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"foo"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"static"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/foo.cpp"</span><strong>)</strong><span style="color:#000000">add_packages</span><strong>(</strong><span style="color:#ff00ff">"libpng"</span><strong>,</strong><strong>{</strong><span style="color:#000000">public</span><strong>=</strong><strong>true</strong><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"demo"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">add_deps</span><strong>(</strong><span style="color:#ff00ff">"foo"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/main.cpp"</span><strong>)</strong><span style="color:blue">if</span><span style="color:#000000">is_plat</span><strong>(</strong><span style="color:#ff00ff">"linux"</span><strong>,</strong><span style="color:#ff00ff">"macosx"</span><strong>)</strong><span style="color:blue">then</span><span style="color:#000000">add_syslinks</span><strong>(</strong><span style="color:#ff00ff">"pthread"</span><strong>,</strong><span style="color:#ff00ff">"m"</span><strong>,</strong><span style="color:#ff00ff">"dl"</span><strong>)</strong><span style="color:blue">end</span><span style="color:blue">if</span><span style="color:#000000">is_plat</span><strong>(</strong><span style="color:#ff00ff">"macosx"</span><strong>)</strong><span style="color:blue">then</span><span style="color:#000000">add_frameworks</span><strong>(</strong><span style="color:#ff00ff">"Foundation"</span><strong>,</strong><span style="color:#ff00ff">"CoreFoundation"</span><strong>)</strong><span style="color:blue">end</span><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"framework::Foundation"</span><strong>,</strong><span style="color:#ff00ff">"png16"</span><strong>,</strong><span style="color:#ff00ff">"foo"</span><strong>)</strong><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"dl"</span><strong>,</strong><span style="color:#ff00ff">"linkgroup::syslib"</span><strong>)</strong><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"m"</span><strong>,</strong><span style="color:#ff00ff">"pthread"</span><strong>,</strong><strong>{</strong><span style="color:#000000">name</span><strong>=</strong><span style="color:#ff00ff">"syslib"</span><strong>,</strong><span style="color:#000000">group</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">完整工程在：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fblob%2Fmaster%2Ftests%2Fprojects%2Fc%252B%252B%2Flinkorders%2Fxmake.lua" target="_blank">linkorders example</a></p><h3>鏈接組支持</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，這個版本，我們還新增了鏈接組的原生支持，它目前主要用於 linux 平台的編譯，僅支持 gcc/clang 編譯器。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">需要注意的是 gcc/clang 裏面的鏈接組概念主要特指：<code>-Wl,--start-group</code></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">而 Xmake 對齊進行了封裝，做了進一步抽象，並且不僅僅用於處理<span>&nbsp;</span><code>-Wl,--start-group</code>，還可以處理<span>&nbsp;</span><code>-Wl,--whole-archive</code><span>&nbsp;</span>和<span>&nbsp;</span><code>-Wl,-Bstatic</code>。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">下面我們會一一對其進行講解。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">更多詳情見：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F1452" target="_blank">#1452</a></p><h4>–start-group 支持</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><code>-Wl,--start-group</code><span>&nbsp;</span>和<span>&nbsp;</span><code>-Wl,--end-group</code><span>&nbsp;</span>是用於處理複雜庫依賴關係的鏈接器選項，確保鏈接器可以解決符號依賴併成功連接多個庫。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 xmake 中，我們可以通過下面的方式實現：</p><div><pre><code><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它會對應生成<span>&nbsp;</span><code>-Wl,--start-group -la -lb -Wl,--end-group</code><span>&nbsp;</span>鏈接選項。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果 a 和 b 庫之間有符號的循環依賴，也不會報鏈接錯誤，能夠正常鏈接成功。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">對於不支持的平台和編譯，會退化成<span>&nbsp;</span><code>-la -lb</code></p><h4>–whole-archive 支持</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><code>--whole-archive</code><span>&nbsp;</span>是一個鏈接器選項，通常用於處理靜態庫。 它的作用是告訴鏈接器將指定的靜態庫中的所有目標文件都包含到最終可執行文件中，而不僅僅是滿足當前符號依賴的目標文件。 這可以用於確保某些庫的所有代碼都被鏈接，即使它們在當前的符號依賴關係中沒有直接引用。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">更多信息，可以參考 gcc/clang 的文檔。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 xmake 中，我們可以通過下面的方式實現：</p><div><pre><code><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><strong>{</strong><span style="color:#000000">whole</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它會對應生成<span>&nbsp;</span><code>-Wl,--whole-archive -la -lb -Wl,--no-whole-archive</code><span>&nbsp;</span>鏈接選項。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">對於不支持的平台和編譯，會退化成<span>&nbsp;</span><code>-la -lb</code></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，我們可以同時配置 group/whole：</p><div><pre><code><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><strong>{</strong><span style="color:#000000">whole</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">group</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><h4>-Bstatic 支持</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><code>-Bstatic</code><span>&nbsp;</span>也是用於編譯器（如 gcc）的選項，用於指示編譯器在鏈接時只使用靜態庫而不使用共享庫。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">更多信息，可以參考 gcc/clang 的文檔。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 xmake 中，我們可以通過下面的方式實現：</p><div><pre><code><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><strong>{</strong><span style="color:#000000">static</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它會對應生成<span>&nbsp;</span><code>-Wl,-Bstatic -la -lb -Wl,-Bdynamic</code><span>&nbsp;</span>鏈接選項。</p><h3>單元測試支持</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">新版本中，我們還增加了一個內置的測試命令：<code>xmake test</code>，我們只需要在需要測試的 target 上通過 add_tests 配置一些測試用例，就可以自動執行測試。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">即使當前 target 被設置成了<span>&nbsp;</span><code>set_default(false)</code>，在執行測試的時候，xmake 也還是會先自動編譯它們，然後自動運行所有的測試。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們可以先看個整體的例子，大概知道下它是怎麼樣子的。</p><div><pre><code><span style="color:#000000">add_rules</span><strong>(</strong><span style="color:#ff00ff">"mode.debug"</span><strong>,</strong><span style="color:#ff00ff">"mode.release"</span><strong>)</strong><span style="color:blue">for</span><span style="color:#000000">_</span><strong>,</strong><span style="color:#000000">file</span><span style="color:blue">in</span><span style="color:black">ipairs</span><strong>(</strong><span style="color:#000000">os</span><strong>.</strong><span style="color:#000000">files</span><strong>(</strong><span style="color:#ff00ff">"src/test_*.cpp"</span><strong>))</strong><span style="color:blue">do</span><span style="color:blue">local</span><span style="color:#000000">name</span><strong>=</strong><span style="color:#000000">path</span><strong>.</strong><span style="color:#000000">basename</span><strong>(</strong><span style="color:#000000">file</span><strong>)</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#000000">name</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/"</span><strong>..</strong><span style="color:#000000">name</span><strong>..</strong><span style="color:#ff00ff">".cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"default"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"args"</span><strong>,</strong><strong>{</strong><span style="color:#000000">runargs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#ff00ff">"bar"</span><strong>}})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"pass_output"</span><strong>,</strong><strong>{</strong><span style="color:#000000">trim_output</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">runargs</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello foo"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"fail_output"</span><strong>,</strong><strong>{</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"hello2 .*"</span><strong>,</strong><span style="color:#ff00ff">"hello xmake"</span><strong>}})</strong><span style="color:blue">end</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這個例子，自動掃描源碼目錄下的<span>&nbsp;</span><code>test_*.cpp</code><span>&nbsp;</span>源文件，然後每個文件自動創建一個測試目標，它被設置成了<span>&nbsp;</span><code>set_default(false)</code>，也就是正常情況下，默認不會編譯它們。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是，如果執行<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>進行測試，它們就會被自動編譯，然後測試運行，運行效果如下：</p><div><pre><code>ruki-2:test ruki<span style="color:black">$ </span>xmake <span style="color:black">test
</span>running tests ...
<strong>[</strong>  2%]: test_1/args        .................................... passed 7.000s
<strong>[</strong>  5%]: test_1/default     .................................... passed 5.000s
<strong>[</strong>  8%]: test_1/fail_output .................................... passed 5.000s
<strong>[</strong> 11%]: test_1/pass_output .................................... passed 6.000s
<strong>[</strong> 13%]: test_2/args        .................................... passed 7.000s
<strong>[</strong> 16%]: test_2/default     .................................... passed 6.000s
<strong>[</strong> 19%]: test_2/fail_output .................................... passed 6.000s
<strong>[</strong> 22%]: test_2/pass_output .................................... passed 6.000s
<strong>[</strong> 25%]: test_3/args        .................................... passed 7.000s
<strong>[</strong> 27%]: test_3/default     .................................... passed 7.000s
<strong>[</strong> 30%]: test_3/fail_output .................................... passed 6.000s
<strong>[</strong> 33%]: test_3/pass_output .................................... passed 6.000s
<strong>[</strong> 36%]: test_4/args        .................................... passed 6.000s
<strong>[</strong> 38%]: test_4/default     .................................... passed 6.000s
<strong>[</strong> 41%]: test_4/fail_output .................................... passed 5.000s
<strong>[</strong> 44%]: test_4/pass_output .................................... passed 6.000s
<strong>[</strong> 47%]: test_5/args        .................................... passed 5.000s
<strong>[</strong> 50%]: test_5/default     .................................... passed 6.000s
<strong>[</strong> 52%]: test_5/fail_output .................................... failed 6.000s
<strong>[</strong> 55%]: test_5/pass_output .................................... failed 5.000s
<strong>[</strong> 58%]: test_6/args        .................................... passed 7.000s
<strong>[</strong> 61%]: test_6/default     .................................... passed 6.000s
<strong>[</strong> 63%]: test_6/fail_output .................................... passed 6.000s
<strong>[</strong> 66%]: test_6/pass_output .................................... passed 6.000s
<strong>[</strong> 69%]: test_7/args        .................................... failed 6.000s
<strong>[</strong> 72%]: test_7/default     .................................... failed 7.000s
<strong>[</strong> 75%]: test_7/fail_output .................................... failed 6.000s
<strong>[</strong> 77%]: test_7/pass_output .................................... failed 5.000s
<strong>[</strong> 80%]: test_8/args        .................................... passed 7.000s
<strong>[</strong> 83%]: test_8/default     .................................... passed 6.000s
<strong>[</strong> 86%]: test_8/fail_output .................................... passed 6.000s
<strong>[</strong> 88%]: test_8/pass_output .................................... failed 5.000s
<strong>[</strong> 91%]: test_9/args        .................................... passed 6.000s
<strong>[</strong> 94%]: test_9/default     .................................... passed 6.000s
<strong>[</strong> 97%]: test_9/fail_output .................................... passed 6.000s
<strong>[</strong>100%]: test_9/pass_output .................................... passed 6.000s

<span style="color:#8f5902">80% </span>tests passed, 7 tests failed out of 36, spent 0.242s
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><img alt="" src="https://tboox.org/assets/img/manual/xmake-test1.png" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以執行<span>&nbsp;</span><code>xmake test -vD</code><span>&nbsp;</span>查看詳細的測試失敗的錯誤信息：</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><img alt="" src="https://tboox.org/assets/img/manual/xmake-test2.png" referrerpolicy="no-referrer"></p><h4>運行指定測試目標</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以指定運行指定 target 的某個測試：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test </span>targetname/testname
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">或者按模式匹配的方式，運行一個 target 的所有測試，或者一批測試：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test </span>targetname/<span style="color:blue">*</span><span style="color:#8f5902">$ </span>xmake <span style="color:black">test </span>targetname/foo<span style="color:blue">*</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">也可以運行所有 target 的同名測試：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span><span style="color:blue">*</span>/testname
</code></pre></div><h4>並行化運行測試</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">其實，默認就是並行化運行的，但是我們可以通過<span>&nbsp;</span><code>-jN</code><span>&nbsp;</span>調整運行的並行度。</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -jN
</code></pre></div><h4>分組運行測試</h4><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -g <span style="color:#ff00ff">"foo"</span><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -g <span style="color:#ff00ff">"foo*"</span></code></pre></div><h4>添加測試到目標（無參數）</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果沒有配置任何參數，僅僅配置了測試名到<span>&nbsp;</span><code>add_tests</code>，那麼僅僅測試這個目標程序的是否會運行失敗，根據退出代碼來判斷是否通過測試。</p><div><pre><code>target("test")
    add_tests("testname")
</code></pre></div><h4>配置運行參數</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過<span>&nbsp;</span><code><span>{</span><span>runargs</span><span><span>&nbsp;</span></span><span>=</span><span><span>&nbsp;</span></span><span>{</span><span>"arg1"</span><span>,</span><span><span>&nbsp;</span></span><span>"arg2"</span><span>}}</span></code><span>&nbsp;</span>的方式，給<span>&nbsp;</span><code>add_tests</code><span>&nbsp;</span>配置指定測試需要運行的參數。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，一個 target 可以同時配置多個測試用例，每個測試用例可獨立運行，互不衝突。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">runargs</span><strong>=</strong><span style="color:#ff00ff">"arg1"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">runargs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"arg1"</span><strong>,</strong><span style="color:#ff00ff">"arg2"</span><strong>}})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果我們沒有配置 runargs 到<span>&nbsp;</span><code>add_tests</code>，那麼我們也會嘗試從被綁定的 target 中，獲取<span>&nbsp;</span><code>set_runargs</code><span>&nbsp;</span>設置的運行參數。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">set_runargs</span><strong>(</strong><span style="color:#ff00ff">"arg1"</span><strong>,</strong><span style="color:#ff00ff">"arg2"</span><strong>)</strong></code></pre></div><h4>配置運行目錄</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過 rundir 設置測試運行的當前工作目錄，例如：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">rundir</span><strong>=</strong><span style="color:#000000">os</span><strong>.</strong><span style="color:#000000">projectdir</span><strong>()})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果我們沒有配置 rundir 到<span>&nbsp;</span><code>add_tests</code>，那麼我們也會嘗試從被綁定的 target 中，獲取<span>&nbsp;</span><code>set_rundir</code><span>&nbsp;</span>設置的運行目錄。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">set_rundir</span><strong>(</strong><span style="color:#ff00ff">"$(projectdir)"</span><strong>)</strong></code></pre></div><h4>配置運行環境</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過 runenvs 設置一些運行時候的環境變量，例如：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">runenvs</span><strong>=</strong><strong>{</strong><span style="color:#000000">LD_LIBRARY_PATH</span><strong>=</strong><span style="color:#ff00ff">"/lib"</span><strong>}})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果我們沒有配置 runenvs 到<span>&nbsp;</span><code>add_tests</code>，那麼我們也會嘗試從被綁定的 target 中，獲取<span>&nbsp;</span><code>add_runenvs</code><span>&nbsp;</span>設置的運行環境。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">add_runenvs</span><strong>(</strong><span style="color:#ff00ff">"LD_LIBRARY_PATH"</span><strong>,</strong><span style="color:#ff00ff">"/lib"</span><strong>)</strong></code></pre></div><h4>匹配輸出結果</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">默認情況下，<code>xmake test</code><span>&nbsp;</span>會根據測試運行的退出代碼是否為 0，來判斷是否測試通過。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">當然，我們也可以通過配置測試運行的輸出結果是否滿足我們的指定的匹配模式，來判斷是否測試通過。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">主要通過這兩個參數控制：</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#f8f8fd; border-bottom:2px solid #777777; border-collapse:collapse; border-top:2px solid #777777; color:#333333; font-family:&quot;Helvetica Neue&quot;,Helvetica,Arial,&quot;Microsoft YaHei&quot;,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin:8px 0px; orphans:2; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; word-spacing:0px"><tbody><tr><th style="text-align:left">參數</th><th style="text-align:left">説明</th></tr></tbody><tbody><tr><td>pass_outputs</td><td>如果輸出匹配，則測試通過</td></tr><tr><td>fail_outputs</td><td>如果輸出匹配，則測試失敗</td></tr></tbody></table><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">傳入<span>&nbsp;</span><code>pass_outputs</code><span>&nbsp;</span>和<span>&nbsp;</span><code>fail_outputs</code><span>&nbsp;</span>的是一個 lua 匹配模式的列表，但模式稍微做了一些簡化，比如對<span>&nbsp;</span><code>*</code><span>&nbsp;</span>的處理。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果要匹配成功，則測試通過，可以這麼配置：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname1"</span><strong>,</strong><strong>{</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname2"</span><strong>,</strong><strong>{</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello *"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname3"</span><strong>,</strong><strong>{</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"hello"</span><strong>,</strong><span style="color:#ff00ff">"hello *"</span><strong>}})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果要匹配成功，則測試失敗，可以這麼配置：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname1"</span><strong>,</strong><strong>{</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname2"</span><strong>,</strong><strong>{</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello *"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname3"</span><strong>,</strong><strong>{</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"hello"</span><strong>,</strong><span style="color:#ff00ff">"hello *"</span><strong>}})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以同時配置它們：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">由於一些測試輸出的結果，尾部會有一些換行什麼的空白字符，幹擾匹配模式，我們可以再配置<span>&nbsp;</span><code>trim_output = true</code>，先截斷空白字符後，再做匹配。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">trim_output</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們還可以配置<span>&nbsp;</span><code><span>{</span><span>plain</span><span><span>&nbsp;</span></span><span>=</span><span><span>&nbsp;</span></span><span>true</span><span>}</span></code><span>&nbsp;</span>是禁用 lua 模式匹配，僅僅做最基礎的平坦文本匹配。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">plain</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong></code></pre></div><h4>配置測試組</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過<span>&nbsp;</span><code>group = "foo"</code><span>&nbsp;</span>來配置一個測試組，進行分組測試：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname1"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname2"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname3"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><span style="color:#ff00ff">"bar"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname4"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><span style="color:#ff00ff">"bae"</span><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">其中 testname1/testname2 是一個組 foo，另外兩個是在另外一個組。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">然後，我們就可以使用<span>&nbsp;</span><code>xmake test -g groupname</code><span>&nbsp;</span>來進行分組測試了。</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -g <span style="color:#ff00ff">"foo"</span><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -g <span style="color:#ff00ff">"foo*"</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">!&gt; 運行分組，也是支持模式匹配的。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，如果沒有設置<span>&nbsp;</span><code>group</code><span>&nbsp;</span>參數給<span>&nbsp;</span><code>add_tests</code>，我們也可以默認獲取綁定到 target 的組名。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">set_group</span><strong>(</strong><span style="color:#ff00ff">"foo"</span><strong>)</strong></code></pre></div><h4>自定義測試腳本</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們還新增了<span>&nbsp;</span><code>before_test</code>,<span>&nbsp;</span><code>on_test</code><span>&nbsp;</span>和<span>&nbsp;</span><code>after_test</code><span>&nbsp;</span>配置腳本，用户可以在 rule 和 target 域，自定義配置它們實現定製化的測試執行。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">on_test</span><strong>(</strong><span style="color:blue">function</span><strong>(</strong><span style="color:#000000">target</span><strong>,</strong><span style="color:#000000">opt</span><strong>)</strong><span style="color:black">print</span><strong>(</strong><span style="color:#000000">opt</span><strong>.</strong><span style="color:#000000">name</span><strong>,</strong><span style="color:#000000">opt</span><strong>.</strong><span style="color:#000000">runenvs</span><strong>,</strong><span style="color:#000000">opt</span><strong>.</strong><span style="color:#000000">runargs</span><strong>,</strong><span style="color:#000000">opt</span><strong>.</strong><span style="color:#000000">pass_outputs</span><strong>)</strong><em>-- do test</em><em>-- ...</em><em>-- passed</em><span style="color:blue">return</span><strong>true</strong><em>-- failied</em><span style="color:blue">return</span><strong>false</strong><strong>,</strong><span style="color:#000000">errors</span><span style="color:blue">end</span><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">其中，opt 裏面可以獲取到所有傳入<span>&nbsp;</span><code>add_tests</code><span>&nbsp;</span>的參數，我們在 on_test 裏面自定義測試邏輯，然後返回 true 就是測試通過，返回 false 就是測試失敗，然後繼續返回測試失敗的錯誤信息。</p><h4>自動化構建</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">由於測試目標在正常開發構建階段，通常是不需要被構建的，因此我們會設置<span>&nbsp;</span><code>set_default(false)</code>。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是運行<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>進行測試時候，這些測試對應的 target 還是會被自動構建，確保能夠被運行。</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span><strong>[</strong> 25%]: cache compiling.release src/main.cpp
<strong>[</strong> 50%]: linking.release <span style="color:black">test
</span>running tests ...
<strong>[</strong>100%]: <span style="color:black">test</span>/testname .................................... passed 6.000s

<span style="color:#8f5902">100% </span>tests passed, 0 tests failed out of 1, spent 0.006s
</code></pre></div><h4>首次測試失敗就終止</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">默認情況下，<code>xmake test</code><span>&nbsp;</span>會等到所有測試都運行完，不管裏面有多少是沒通過的。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">而有時候，我們想在第一個測試沒通過，就直接中斷測試，那麼我們可以通過下面的配置啓用：</p><div><pre><code><span style="color:#000000">set_policy</span><strong>(</strong><span style="color:#ff00ff">"test.return_zero_on_failure"</span><strong>,</strong><strong>true</strong><strong>)</strong></code></pre></div><h4>測試失敗返回 0</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">默認情況下，只要有一個測試沒通過，等到<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>運行完成，它都會返回非 0 退出代碼，這對於一些 CI 環境非常有用，可以中斷 CI 的其他腳本繼續運行。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">然後觸發信號告訴 CI，我們需要生成測試報告和告警了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">然後，如果我們想要壓制這種行為，可以強制將<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>的退出代碼總是設置成 0。</p><div><pre><code><span style="color:#000000">set_policy</span><strong>(</strong><span style="color:#ff00ff">"test.return_zero_on_failure"</span><strong>,</strong><strong>true</strong><strong>)</strong></code></pre></div><h4>僅僅測試編譯</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">有時候，我們僅僅想要測試代碼是否通過編譯，或者沒有通過編譯，不需要運行它們，那麼可以通過配置<span>&nbsp;</span><code>build_should_pass</code><span>&nbsp;</span>和<span>&nbsp;</span><code>build_should_fail</code><span>&nbsp;</span>來實現。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_10"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/compile.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"compile_fail"</span><strong>,</strong><strong>{</strong><span style="color:#000000">build_should_fail</span><strong>=</strong><strong>true</strong><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_11"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/compile.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"compile_pass"</span><strong>,</strong><strong>{</strong><span style="color:#000000">build_should_pass</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這通常用於一些測試代碼中帶有<span>&nbsp;</span><code>static_assert</code><span>&nbsp;</span>的場景，例如：</p><div><pre><code><span style="color:blue">template</span><strong>&lt;</strong><span style="color:blue">typename</span><span style="color:#000000">T</span><strong>&gt;</strong><span style="color:blue">bool</span><span style="color:#000000">foo</span><strong>(</strong><span style="color:#000000">T</span><span style="color:#000000">val</span><strong>)</strong><strong>{</strong><span style="color:blue">if</span><span style="color:blue">constexpr</span><strong>(</strong><span style="color:#000000">std</span><strong>::</strong><span style="color:#000000">is_same_v</span><strong>&lt;</strong><span style="color:#000000">T</span><strong>,</strong><span style="color:blue">int</span><strong>&gt;</strong><strong>)</strong><strong>{</strong><span style="color:#000000">printf</span><strong>(</strong><span style="color:#ff00ff">"int!</span><span style="color:#ff00ff">\n</span><span style="color:#ff00ff">"</span><strong>);</strong><strong>}</strong><span style="color:blue">else</span><span style="color:blue">if</span><span style="color:blue">constexpr</span><strong>(</strong><span style="color:#000000">std</span><strong>::</strong><span style="color:#000000">is_same_v</span><strong>&lt;</strong><span style="color:#000000">T</span><strong>,</strong><span style="color:blue">float</span><strong>&gt;</strong><strong>)</strong><strong>{</strong><span style="color:#000000">printf</span><strong>(</strong><span style="color:#ff00ff">"float!</span><span style="color:#ff00ff">\n</span><span style="color:#ff00ff">"</span><strong>);</strong><strong>}</strong><span style="color:blue">else</span><strong>{</strong><span style="color:blue">static_assert</span><strong>(</strong><span style="color:black">false</span><strong>,</strong><span style="color:#ff00ff">"unsupported type"</span><strong>);</strong><strong>}</strong><strong>}</strong><span style="color:blue">int</span><span style="color:#000000">main</span><strong>(</strong><span style="color:blue">int</span><strong>,</strong><span style="color:blue">char</span><strong>**</strong><strong>)</strong><strong>{</strong><span style="color:#000000">foo</span><strong>(</strong><span style="color:#ff00ff">"BAD"</span><strong>);</strong><span style="color:blue">return</span><strong>0</strong><strong>;</strong><strong>}</strong></code></pre></div><h4>配置額外的代碼編譯</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們還可以在配置測試用例的時候，對每個測試配置額外需要編譯的代碼，以及一些宏定義，實現內聯測試。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">xmake 會為每個測試單獨編譯一個獨立的可執行程序去運行它，但這並不會影響到 target 在生產環境的編譯結果。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_13"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/test_1.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"stub_1"</span><strong>,</strong><strong>{</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#ff00ff">"tests/stub_1.cpp"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"STUB_1"</span><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_14"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/test_2.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"stub_2"</span><strong>,</strong><strong>{</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#ff00ff">"tests/stub_2.cpp"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"STUB_2"</span><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_15"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/test_1.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"stub_n"</span><strong>,</strong><strong>{</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#ff00ff">"tests/stub_n*.cpp"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"STUB_N"</span><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">以 doctest 為例，我們可以在不修改任何 main.cpp 的情況下，外置單元測試：</p><div><pre><code><span style="color:#000000">add_rules</span><strong>(</strong><span style="color:#ff00ff">"mode.debug"</span><strong>,</strong><span style="color:#ff00ff">"mode.release"</span><strong>)</strong><span style="color:#000000">add_requires</span><strong>(</strong><span style="color:#ff00ff">"doctest"</span><strong>)</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"doctest"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/*.cpp"</span><strong>)</strong><span style="color:blue">for</span><span style="color:#000000">_</span><strong>,</strong><span style="color:#000000">testfile</span><span style="color:blue">in</span><span style="color:black">ipairs</span><strong>(</strong><span style="color:#000000">os</span><strong>.</strong><span style="color:#000000">files</span><strong>(</strong><span style="color:#ff00ff">"tests/*.cpp"</span><strong>))</strong><span style="color:blue">do</span><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#000000">path</span><strong>.</strong><span style="color:#000000">basename</span><strong>(</strong><span style="color:#000000">testfile</span><strong>),</strong><strong>{</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#000000">testfile</span><strong>,</strong><span style="color:#000000">remove_files</span><strong>=</strong><span style="color:#ff00ff">"src/main.cpp"</span><strong>,</strong><span style="color:#000000">languages</span><strong>=</strong><span style="color:#ff00ff">"c++11"</span><strong>,</strong><span style="color:#000000">packages</span><strong>=</strong><span style="color:#ff00ff">"doctest"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN"</span><strong>})</strong><span style="color:blue">end</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">定義 DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN 會引入額外的 main 入口函數，因此我們需要配置 remove_files 去移除已有的 main.cpp 文件。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">運行效果如下：</p><div><pre><code>ruki-2:doctest ruki<span style="color:black">$ </span>xmake <span style="color:black">test
</span>running tests ...
<strong>[</strong> 50%]: doctest/test_1 .................................... failed 0.009s
<strong>[</strong>100%]: doctest/test_2 .................................... passed 0.009s

<span style="color:#8f5902">50% </span>tests passed, 1 tests failed out of 2, spent 0.019s
ruki-2:doctest ruki<span style="color:black">$ </span>xmake <span style="color:black">test</span> -v
running tests ...
<strong>[</strong> 50%]: doctest/test_1 .................................... failed 0.026s
<strong>[</strong>doctest] doctest version is <span style="color:#ff00ff">"2.4.11"</span><strong>[</strong>doctest] run with <span style="color:#ff00ff">"--help"</span><span style="color:blue">for </span>options
<strong>===============================================================================</strong>
tests/test_1.cpp:7:
TEST CASE:  testing the factorial <span style="color:blue">function

</span>tests/test_1.cpp:8: ERROR: CHECK<strong>(</strong> factorial<strong>(</strong>1<strong>)</strong><strong>==</strong> 10 <strong>)</strong> is NOT correct!
  values: CHECK<strong>(</strong> 1 <strong>==</strong> 10 <strong>)</strong><strong>===============================================================================</strong><strong>[</strong>doctest] <span style="color:black">test </span>cases: 1 | 0 passed | 1 failed | 0 skipped
<strong>[</strong>doctest] assertions: 4 | 3 passed | 1 failed |
<strong>[</strong>doctest] Status: FAILURE!

run failed, <span style="color:black">exit </span>code: 1
<strong>[</strong>100%]: doctest/test_2 .................................... passed 0.010s

<span style="color:#8f5902">50% </span>tests passed, 1 tests failed out of 2, spent 0.038s
</code></pre></div><h4>測試動態庫</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">通常，<code>add_tests</code><span>&nbsp;</span>僅用於對可執行程序進行運行測試，運行動態庫需要有一個額外的 main 主入口，因此我們需要額外配置一個可執行程序去加載它，例如：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"doctest_shared"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"shared"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/foo.cpp"</span><strong>)</strong><span style="color:blue">for</span><span style="color:#000000">_</span><strong>,</strong><span style="color:#000000">testfile</span><span style="color:blue">in</span><span style="color:black">ipairs</span><strong>(</strong><span style="color:#000000">os</span><strong>.</strong><span style="color:#000000">files</span><strong>(</strong><span style="color:#ff00ff">"tests/*.cpp"</span><strong>))</strong><span style="color:blue">do</span><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#000000">path</span><strong>.</strong><span style="color:#000000">basename</span><strong>(</strong><span style="color:#000000">testfile</span><strong>),</strong><strong>{</strong><span style="color:#000000">kind</span><strong>=</strong><span style="color:#ff00ff">"binary"</span><strong>,</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#000000">testfile</span><strong>,</strong><span style="color:#000000">languages</span><strong>=</strong><span style="color:#ff00ff">"c++11"</span><strong>,</strong><span style="color:#000000">packages</span><strong>=</strong><span style="color:#ff00ff">"doctest"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN"</span><strong>})</strong><span style="color:blue">end</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">通過<span>&nbsp;</span><code>kind = "binary"</code><span>&nbsp;</span>可以將每個單元測試改為 binary 可執行程序，並通過<span>&nbsp;</span><code>DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN</code><span>&nbsp;</span>引入 main 入口函數。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這樣就能實現動態庫目標中外置可運行的單元測試。</p><h3>新增類型大小檢測</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在先前的版本中，我們可以通過<span>&nbsp;</span><code>check_csnippets</code><span>&nbsp;</span>和<span>&nbsp;</span><code>output = true</code><span>&nbsp;</span>的方式，來實現類型檢測。</p><div><pre><code><span style="color:#000000">check_csnippets</span><strong>(</strong><span style="color:#ff00ff">"INT_SIZE"</span><strong>,</strong><span style="color:#ff00ff">'printf("%d", sizeof(int)); return 0;'</span><strong>,</strong><strong>{</strong><span style="color:#000000">output</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">number</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是這種方式，是通過嘗試運行測試代碼，然後獲取運行輸出結果，提取類型大小信息。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這對於交叉編譯，就不適用了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 2.8.5 版本中，我們新增了<span>&nbsp;</span><code>check_sizeof</code><span>&nbsp;</span>輔助接口，可以通過直接解析測試程序的二進制文件，提取類型大小信息。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">由於不需要運行測試，這種方式不僅可以支持交叉編譯，而且對檢測效率也有極大的提升，使用也更加的簡單。</p><div><pre><code><span style="color:#000000">includes</span><strong>(</strong><span style="color:#ff00ff">"@builtin/check"</span><strong>)</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"static"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"*.cpp"</span><strong>)</strong><span style="color:#000000">check_sizeof</span><strong>(</strong><span style="color:#ff00ff">"LONG_SIZE"</span><strong>,</strong><span style="color:#ff00ff">"long"</span><strong>)</strong><span style="color:#000000">check_sizeof</span><strong>(</strong><span style="color:#ff00ff">"STRING_SIZE"</span><strong>,</strong><span style="color:#ff00ff">"std::string"</span><strong>,</strong><strong>{</strong><span style="color:#000000">includes</span><strong>=</strong><span style="color:#ff00ff">"string"</span><strong>})</strong></code></pre></div><div><pre><code><span style="color:#8f5902">$ </span>xmake f -c
checking <span style="color:blue">for </span>LONG_SIZE ... 8
checking <span style="color:blue">for </span>STRING_SIZE ... 24
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，我也可以通過<span>&nbsp;</span><code>target:check_sizeof</code><span>&nbsp;</span>在腳本域進行檢測。</p><h3>新增 Apple XROS 平台</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">蘋果在 Xcode15 中新增了 visionOS 設備的構建支持，因此我們也在第一時間對其進行了支持，只需要執行：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake f -p applexros
<span style="color:#8f5902">$ </span>xmake
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">就可以完成 visionOS/XROS 平台的構建。</p><h3>支持代碼合併</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">最後，我們還提供了一個小工具模塊，它可以用於快速合併指定 target 裏面的所有 c/c++ 和，頭文件源碼到單個源文件。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">會生成類似 sqlite3.c 的這種單源碼文件，用户可以根據自己的實際需求來決定是否使用這個功能。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">而在做合併的時候，Xmake 會將內部 includes 頭文件全部展開，並生成 DAG，通過拓撲排序引入。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">默認它會處理所有 target 的合併，例如：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake l cli.amalgamate
build/tbox.c generated!
build/tbox.h generated!
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以指定合併需要的目標：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake l cli.amalgamate tbox
build/tbox.c generated!
build/tbox.h generated!
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">也可以在合併每個源文件時候，指定一個自定義的 unique ID 的宏定義，來處理符號衝突問題。</p><div><pre><code><span style="color:#8f5902">$ </span>xmake l cli.amalgamate -u MY_UNIQUEU_ID
build/tbox.c generated!
build/tbox.h generated!
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果多個源文件內部有重名符號，就可以判斷這個<span>&nbsp;</span><code>MY_UNIQUEU_ID</code><span>&nbsp;</span>宏是否被定義，如果定義了，説明是在單文件中，就自己在源碼中處理下重名符號。</p><div><pre><code><em>#ifdef MY_UNIQUEU_ID
</em><em>// do some thing
</em><em>#endif
</em></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以指定輸出位置：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake l cli.amalgamate -o /xxx
/xxx/tbox.c generated!
/xxx/tbox.h generated!
</code></pre></div><h3>新增 windows.manifest.uac 策略</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">通過這個策略，我們可以快速方便的設置並啓用 Windows UAC。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它支持以下幾個 Level：</p><ul><li>invoker: asInvoker</li><li>admin: requireAdministrator</li><li>highest: highestAvailable</li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">例如：</p><div><pre><code><span style="color:#000000">set_policy</span><strong>(</strong><span style="color:#ff00ff">"windows.manifest.uac"</span><strong>,</strong><span style="color:#ff00ff">"admin"</span><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它等價於設置</p><div><pre><code><span style="color:blue">if</span><span style="color:#000000">is_plat</span><strong>(</strong><span style="color:#ff00ff">"windows"</span><strong>)</strong><span style="color:blue">then</span><span style="color:#000000">add_ldflags</span><strong>(</strong><span style="color:#ff00ff">"/manifest:embed"</span><strong>,</strong><strong>{</strong><span style="color:#ff00ff">"/manifestuac:level='requireAdministrator' uiAccess='false'"</span><strong>},</strong><strong>{</strong><span style="color:#000000">force</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">expand</span><strong>=</strong><strong>false</strong><strong>})</strong><span style="color:blue">end</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是更加方便簡潔，並且不需要判斷平台，其他平台自動忽略。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過<span>&nbsp;</span><code>windows.manifest.uac.ui</code><span>&nbsp;</span>策略，設置 Windows UAC 的 uiAccess，如果沒有設置它，默認是 false。</p><div><pre><code><span style="color:#000000">set_policy</span><strong>(</strong><span style="color:#ff00ff">"windows.manifest.uac.ui"</span><strong>,</strong><strong>true</strong><strong>)</strong></code></pre></div><h2>更新日誌</h2><h3>新特性</h3><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F1452" target="_blank">#1452</a>: 支持鏈接順序調整，鏈接組</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F1438" target="_blank">#1438</a>: 支持代碼 amalgamation</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F3381" target="_blank">#3381</a>: 添加<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>支持</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F4276" target="_blank">#4276</a>: 支持自定義域 API</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fpull%2F4286" target="_blank">#4286</a>: 添加 Apple XROS 支持</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F4345" target="_blank">#4345</a>: 支持檢測類型大小 sizeof</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fpull%2F4369" target="_blank">#4369</a>: 添加 windows.manifest.uac 策略</li></ul><h3>改進</h3><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F4284" target="_blank">#4284</a>: 改進內置 includes 模塊</li></ul><h3>Bugs 修復</h3><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F4256" target="_blank">#4256</a>: 為 vsxmake 生成器修復 c++ modules intellisense</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 07 Nov 2023 01:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265506/xmake-v2-8-5</guid>
            <link>https://www.oschina.net/news/265506/xmake-v2-8-5</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Mozilla Firefox 開發將完全轉向 Git，放棄 Mercurial]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Mozilla 負責工作流和發佈管理的高級工程經理&nbsp;Glob&nbsp;在 firefox-dev 郵件列表中<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgroups.google.com%2Fa%2Fmozilla.org%2Fg%2Ffirefox-dev%2Fc%2FQnfydsDj48o%2Fm%2F8WadV0_dBQAJ" target="_blank">表示</a>，Firefox 開發正在從 Mercurial 轉向 GIT，以減輕開發團隊的壓力。</span></p><blockquote><p><span style="color:#000000">長期以來，Firefox Desktop 開發一直同時支持 Mercurial 和 Git 用户。這種雙 SCM 要求給部分已經捉襟見肘的團隊帶來了沉重負擔。我們已經決定將 Firefox 開發轉移到 Git。</span></p><ul><li><span style="color:#000000">我們將繼續使用 Bugzilla、moz-phab、Phabricator 和 Lando。</span></li><li><span style="color:#000000">儘管我們將在 GitHub 上託管版本庫，但我們的貢獻工作流程將保持不變，而且我們目前不會接受拉取請求。</span></li></ul></blockquote><p><span style="color:#000000">目前相關事項仍在規劃中，預計至少六個月後才會開始全面的 Git 過渡。過渡完成後，Mercurial 將從 Firefox 開發工作流程中完全淘汰。</span></p><p><img height="225" src="https://oscimg.oschina.net/oscnet/up-4b4cc1a8fcad1764d254f09eae44065f9c2.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">根據介紹，這項工作將分為兩個部分進行：首先是面向開發人員的工作。項目團隊將把主倉庫從 Mercurial 切換到 Git，同時在開發人員的工作站上移除對 Mercurial 的支持。開發人員將需要在本地使用 Git，並繼續使用 moz-phab 提交補丁以供審核。</span></p><p><span style="color:#000000">然後是後端基礎架構的零散遷移。各個團隊計劃逐步將 Mercurial 上的基礎架構遷移到 Git 上。在這一階段結束時，預計可實現從基礎架構中完全移除對 Mercurial 的支持。</span></p><p><span style="color:#000000">Mercurial 是一款開源的分佈式源代碼控制管理工具，採用 Python 語言實現，易於學習和使用，擴展性強。它可以有效地處理任何規模的項目，並提供簡單直觀的界面。Mercurial 由 Olivia Mackall 於 2005 年創建，作為 BitKeeper 的替代品用於管理 Linux 內核的源代碼，以應對 BitKeeper 免費版的停產。</span></p><p><span style="color:#000000">更多詳細信息可查看</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgroups.google.com%2Fa%2Fmozilla.org%2Fg%2Ffirefox-dev%2Fc%2FQnfydsDj48o%2Fm%2F8WadV0_dBQAJ" target="_blank">郵件列表公告</a><span style="color:#000000">。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 10:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265431/firefox-going-git</guid>
            <link>https://www.oschina.net/news/265431/firefox-going-git</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[DALL·E 3 繪圖來啦，開源 AI 聊天、繪圖軟件 AIdea 現已支持 DALL·E 3]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p style="color:inherit; margin-left:0; margin-right:0">昨晚 OpenAI 的開發者大會後開放了 DALL·E 3 的 API，今天花了一點時間在 AIdea 中增加了對 DALL·E 3 的支持。</p><blockquote><p style="color:inherit; margin-left:0; margin-right:0">簡單來説，AIdea 類似於 POE，它是一款集成了主流大語言模型以及繪圖模型的開源 APP。如果你還不知道它，那麼可以簡單看看這篇文章 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzA3NTU1NDk4Mg%3D%3D%26mid%3D2454663369%26idx%3D1%26sn%3Dfc5ae7e09e5da885fecbe90747900bc9%26chksm%3D88d55900bfa2d016578008ec30550acbab49cf9ed5cd0b454c3ce8d308ff7cc1ab9416637f19%23rd" target="_blank">花了小半年開發了一個 AI 套殼 APP，然而大勢已過，直接開源了</a>。</p><p style="color:inherit; margin-left:0; margin-right:0">AIdea 項目前後端所有代碼均採用 MIT 協議開源。</p></blockquote><img alt="operate-note" src="https://ssl.aicode.cc/ai-server/assets/broadcast/dalle-preview.jpg" referrerpolicy="no-referrer"><p>operate-note</p><img alt="image" src="https://ssl.aicode.cc/ai-server/assets/broadcast/dalle-preview-result.png" referrerpolicy="no-referrer"><p>image</p><p style="color:inherit; margin-left:0; margin-right:0">下載體驗地址</p><p style="color:inherit; margin-left:0; margin-right:0">https://aidea.aicode.cc/</p><blockquote><p style="color:inherit; margin-left:0; margin-right:0">注意：AIdea 項目前後端所有代碼均採用 MIT 協議開源，但是在線體驗服務並不免費（PS. 很多大語言模型每日都有免費使用次數）。</p></blockquote><p style="color:inherit; margin-left:0; margin-right:0">AIdea 是一款集成了主流大語言模型以及繪圖模型的 APP ， 採用 Flutter + Golang 開發，代碼完全開源，支持以下功能：</p><ul><li><span style="color:inherit">OpenAI 的 GPT-3.5 ，GPT-4 大語言模型</span></li><li><span style="color:inherit">Anthropic 的 Claude instant ，Claude 2.0 大語言模型</span></li><li><span style="color:inherit">國產模型：通義千問，文心一言，訊飛星火，商湯日日新，騰訊混元，百川 53B ，360 智腦</span></li><li><span style="color:inherit">開源模型：Llama2 ，ChatGLM2 ，AquilaChat 7B ，Bloomz 7B 等，後續還將開放更多</span></li><li><span style="color:inherit">文生圖、圖生圖、超分辨率、黑白圖片上色等功能，集成 Stable Diffusion 模型，支持 SDXL 1.0</span></li></ul><p style="color:inherit; margin-left:0; margin-right:0">Github 地址：</p><ul><li><span style="color:inherit">客户端（ Flutter ）： https://github.com/mylxsw/aidea</span></li><li><span style="color:inherit">服務端（ Golang ）： https://github.com/mylxsw/aidea-server</span></li></ul></div></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 09:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265412</guid>
            <link>https://www.oschina.net/news/265412</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[馬斯克旗下 AI 公司推出 PromptIDE 工具]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>馬斯克旗下 AI 公司 xAI <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.ai%2Fprompt-ide%2F" target="_blank">宣佈推出 PromptIDE 工具</a></u>，需要使用 X 賬户登錄。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8e71bf70af935eb153aa1cc26a973d0f5c9.png" referrerpolicy="no-referrer"></p><p><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.ai%2Fprompt-ide%2F" target="_blank">https://x.ai/prompt-ide/</a></u></em></p><p>PromptIDE 是一個<strong>用於提示工程和可解釋性研究的集成開發環境</strong>。它通過 SDK 加速提示工程，該 SDK 允許實現複雜的提示技術和豐富的分析功能，從而實現網絡輸出可視化。</p><p>IDE 的核心是一個 Python 代碼編輯器，它可以與新的 SDK 結合實現複雜的提示。在 IDE 中執行提示時，用户會看到一些有用的分析和建議，例如精確標記化等等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-cabd374d49271e12b2b6a54648df587857b.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-162ef024f3eb0fff93e05bc242b6fe28ba8.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f6174ba792122df3fda5a272ff68e00d9e9.png" referrerpolicy="no-referrer"></p><p>xAI 官方表示，他們開發 PromptIDE 是為了向社區的工程師和研究人員<strong>透明地提供 Grok-1 的透明訪問權限</strong>。該 IDE 旨在賦予用户權力，幫助他們快速探索大型語言模型（LLMs）的魅力。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 06:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265374</guid>
            <link>https://www.oschina.net/news/265374</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Kotlin Multiplatform 已穩定，可用於生產環境]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Kotlin Multiplatform (KMP) 是一項由 JetBrains 構建的開源技術，使開發者能夠在跨平台共享代碼的同時保留原生編程的優勢。</p><p>現在，這項技術取得了備受期待的進展，<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.jetbrains.com%2Fzh-hans%2Fkotlin%2F2023%2F11%2Fkotlin-multiplatform-stable%2F" target="_blank">已經穩定</a></u>並完全做好了投入生產環境的準備</strong>。</p><p>根據介紹，Kotlin Multiplatform (KMP) 以靈活性和適應性為設計核心，模糊了跨平台與原生開發之間的界限。它使開發者可以重用盡可能多的代碼，根據需要編寫原生代碼，並將共享的 Kotlin 代碼無縫集成到任何項目中。</p><p>Kotlin Multiplatform 技術的核心由許多部分組成，例如編譯器支持、語言功能、庫 API、IDE、構建工具等。 這些部分覆蓋了最熱門的代碼共享用例，並且在 Kotlin 1.9.20 中得到穩定。&nbsp;</p><p>除了核心之外，KMP 還有一些仍在繼續開發的更高級部分。 expect/actual 類就是此類功能的一個示例（請勿與 expect/actual_函數_混淆，它們在 Kotlin 1.9.20 中已完全穩定）。 此類功能被明確標記為非穩定，Kotlin 會在您使用它們時發出通知。 請注意實驗性警告和相應文檔，以便明智地決定是否要在項目中使用此類功能。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 06:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265360/kotlin-multiplatform-stable</guid>
            <link>https://www.oschina.net/news/265360/kotlin-multiplatform-stable</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
