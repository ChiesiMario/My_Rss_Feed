<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-最新资讯]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-最新资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 01 Nov 2023 08:29:53 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[优惠券 10 几万元，中国首款商用可重构 5G 频射收发芯片上架淘宝]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>近日，国资委淘宝店铺「国资小新」上架了一款售价为 999999 元的硬核商品 ——</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0c0dfda1faab2057d6c1cd71a911022e482.png" referrerpolicy="no-referrer"></p><p>根据商品图介绍，该款芯片名为「破风 8676」，是「中国首款商用可重构 5G 频射收发芯片」，定价 999999 元人民币。这款芯片因独特的用途和「硬核」的定价被网友戏称为「双十一」期间最「硬核」的国货。</p><p>报道称，该芯片由中国移动研究院自主研发。产品介绍信息显示，「破风 8676」可重构 5G 射频收发芯片支持 1.7GHZ~6GHz 频段范围，能够适配全球主流 4/5G 频段、WiFi 及国内车联网频段：支持 2 个射频通道，通道带宽 200MHz；集成 DPD （数字预失真） 、CFR （削峰） 、高阶 FIR （有限长单位冲激响应）滤波等功能。</p><p>公开信息显示，上架这款芯片的店铺「国资小新」由国务院国有资产监督管理委员会下属机构负责运营。该账号店铺内还上架了由中国航发研制的「太行 110」重型燃气轮机、由中国铁建研制的全球最大竖井掘进机、航空工业集团研制直-20 直升机以及中核集团建设的全球首个陆上小型模块化反应堆等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d3dff2bf8551179267c8ac2ee3cc6613cf1.png" referrerpolicy="no-referrer"></p><p>和「破风 8676」一样，店铺将上述产品均定价为 999999 元，并提示消费者该商品「仅展示可加购勿拍」。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 07:41:49 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264470</guid>
            <link>https://www.oschina.net/news/264470</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Layui 2.8.18 发布，阶段性稳定版 🎉]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div>
 经过 8 个预览版的持续迭代，Layui 阶段性稳定版本：&nbsp;2.8.18&nbsp;正式发布。
</div><h3><strong>更新日志</strong></h3><div><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flayui.dev%2Fdocs%2F2%2Fversions.html%232.8.18" target="_blank"><span style="color:#003884">https://layui.dev/docs/2/versions.html#2.8.18</span></a></div><h3><strong>提交记录</strong></h3><div><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1391" target="_blank"><span style="color:#003884">#1391</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1395" target="_blank"><span style="color:#003884">#1395</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1399" target="_blank"><span style="color:#003884">#1399</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1408" target="_blank"><span style="color:#003884">#1408</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1413" target="_blank"><span style="color:#003884">#1413</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1416" target="_blank"><span style="color:#003884">#1416</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1417" target="_blank"><span style="color:#003884">#1417</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1418" target="_blank"><span style="color:#003884">#1418</span></a></li></ul></div><h3><strong>参与贡献 🎉</strong></h3><div><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsentsim" target="_blank"><span style="color:#003884">@sentsim</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FSight-wcg" target="_blank"><span style="color:#003884">@Sight-wcg</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsunxiaobin89" target="_blank"><span style="color:#003884">@sunxiaobin89</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FDiyar-IT" target="_blank"><span style="color:#003884">@Diyar-IT</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmek1986" target="_blank"><span style="color:#003884">@mek1986</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flitaohms" target="_blank"><span style="color:#003884">@litaohms</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwefly2" target="_blank"><span style="color:#003884">@wefly2</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fladudu" target="_blank"><span style="color:#003884">@ladudu</span></a></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 02:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264405/layui-2-8-18-released</guid>
            <link>https://www.oschina.net/news/264405/layui-2-8-18-released</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[深秋，寒露：是时候和 Zadig 说再见了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank"><img alt="" src="https://oscimg.oschina.net/oscnet/up-672c752071cec6bcdf28b3468d5bde60d1a.png" referrerpolicy="no-referrer"></a></p><div><div style="text-align:center"><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank">阅读原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig">Zadig 在 Gitee</a></p><p><strong>推荐阅读：</strong><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490415%26idx%3D1%26sn%3D1914c7fd25aac5d33b98663571bbb744%26chksm%3Dcfb457cff8c3ded9c02809aad88012fa802eac55222eebe70b8c637ca2c86a101045aa81e73a%26scene%3D21%23wechat_redirect" target="_blank">是时候和 Jenkins 说再见了</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank">Zadig vs. Jenkins 详细比对：时代的选择与开发者之选</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247489682%26idx%3D1%26sn%3Df4ac5ceb38547542061477a45d8dc86d%26chksm%3Dcfb45432f8c3dd24b727e0fb6db276b2d63b2751933e63a25b00b9d9fac2dd68efbd2cbd3863%26scene%3D21%23wechat_redirect" target="_blank">平台工程和 AI 时代的新 10 亿开发者</a></p></div><div style="text-align:center">
   2023 年 11 月 1 日 
 </div><div style="text-align:center">
   秋风起，露成霜，正是一年最美时 
 </div><div style="text-align:center">
   Zadig 团队踏入了 
 </div><div style="text-align:center">
   创业的第五个年头 
 </div><div style="text-align:center">
   开源的第 888 天 
 </div><div style="text-align:center">
   然而今天 
 </div><div style="text-align:center">
   我们要向 Zadig 
 </div><div style="text-align:center">
   说再见了 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   深秋外象趋冷 
 </div><div style="text-align:center">
   实则万物蛰伏 
 </div><div style="text-align:center">
   在孕育着新的生机 
 </div><div style="text-align:center">
   今天，我们向 Zadig 1.0 告别 
 </div><div style="text-align:center"><span style="color:#fd2968"><strong>迎来全新的 Zadig 2.0!</strong></span></div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   回顾开源的这两年多时间里 
 </div><div style="text-align:center">
   Zadig 1.0 已完成了 2 万 6 千多次的企业下载 
 </div><div style="text-align:center">
   发布了 21 个开源版本，10 个企业版本 
 </div><div style="text-align:center">
   在 2 千多家企业和团队深度使用 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   我们创作了 157 篇原创技术和产品文章 
 </div><div style="text-align:center">
   制作了 52 个独创的短视频 
 </div><div style="text-align:center">
   与 100 多位国内外商业、技术和产品领域的同仁伙伴建立了深厚的链接 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   今天，Zadig 已不再是婴儿 
 </div><div style="text-align:center">
   是一个坚定自信的少年 
 </div><div style="text-align:center">
   走进数千家企业和团队的日常工作中 
 </div><div style="text-align:center">
   让他们的工作更加高效愉悦 
 </div><div style="text-align:center">
   这段旅程，Zadig 背后的团队和社区一起 
 </div><div style="text-align:center">
   合作共创 
 </div><div style="text-align:center">
   品味挫折 
 </div><div style="text-align:center">
   分享喜悦 
 </div><div style="text-align:center">
   追逐自由 
 </div></div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-fbb18b0ecc053068d166ea1f637149f273f.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-e94bae5f521bce7e3f5326d76218df7912c.png" referrerpolicy="no-referrer"></p><div><div style="text-align:center">
   今天，2023 年 11 月 1 日 
 </div><div style="text-align:center">
   我们团队决定再度迈出一大步 
 </div><div style="text-align:center">
   正式宣布： 
 </div><div style="text-align:center">
   开源 Zadig 与，企业版 ZadigX 产品合并！ 
 </div><div style="text-align:center">
   并全面启用企业版功能，提供一键试用 
 </div><div style="text-align:center">
   与此同时，我们做出了重大的决定 
 </div><div style="text-align:center">
   全部开放服务端源代码 
 </div><div style="text-align:center">
   接下来我们还将发布崭新的文档站 
 </div><div style="text-align:center">
   并推出更加易用的新手在线教程 
 </div></div><span id="OSC_h1_1"></span><h1><span style="color:#fd2968"><em><strong>01</strong></em><strong>为何做出这一选择？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-e6678f7e349d8523888cb8b7d3e0659b69a.png" referrerpolicy="no-referrer"></strong></p><div><div style="text-align:center">
   首先，我们希望通过更开放的方式 
 </div><div style="text-align:center">
   为这个不平凡的时代注入信心 
 </div><div style="text-align:center">
   在过去的三年中，我们共同经历了许多挑战 
 </div><div style="text-align:center">
   包括疫情、经济动荡，资本衰退、互联网红利时代的结束，AI 时代的到来 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   其次，我们希望通过这次开放性尝试，带给每位 IT 从业者更多力量！ 
 </div><div style="text-align:center">
   开源 2 年半以来，社区里的每个人，不论是 80 后、90 后还是 00 后 
 </div><div style="text-align:center">
   都经历了前所未有的技术和经济周期 
 </div><div style="text-align:center">
   似乎没有人准备好，但这些挑战都如期而至： 
 </div><div style="text-align:center">
   互联网大规模的裁员和失业潮影响了我们每个人和每个家庭 
 </div><div style="text-align:center">
   「IT 行业的未来在哪里？ 
 </div><div style="text-align:center">
   IT 人的未来在何方？ 
 </div><div style="text-align:center">
   什么是时代需要的创新？ 
 </div><div style="text-align:center">
   什么是适合中国特色的 IT 创新之路？ 
 </div><div style="text-align:center">
   如何用技术让这个世界更美好？」 
 </div></div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-7643c8b8c38bf97523b3e001c3806795bac.png" referrerpolicy="no-referrer"></p><p>作为 Zadig 的创始人，我会经常思考这些问题。显然并没有标准答案，有一点可以肯定：真正的创新是思想的进步和对他人带来的积极影响。其实，开源代码从来不是核心资产，我们希望用更开放的心态，和社区、用户、客户的小伙伴们更为紧密的配合，找到最佳的姿势帮助到最需要的人，与同行者一起面对每一次成长和变化，直面每一次恐惧和不安。</p><p>同时，通过这次版本发布和源码开放，我们希望能够让更多的开发者看到 Zadig 的企业级全部功能，为希望成为客户的用户提供更为简单的升级方式，从根本上提供更多安全感。通过新版本 Zadig，企业客户可以一键输入试用授权，快速实验 Zadig 专业版能力，企业客户更放心地尝试新技术和新产品，助力各个行业、产业 IT 的数字化升级。</p><p>作为软件交付和研发链路中重要的连接者，我们希望通过这次 Zadig V2.0.0 的开源和版本发布，与同行的基础软件开发者们一起尝试新模式，为建立新的开源商业秩序开一个头。</p><span id="OSC_h1_2"></span><h1><span style="color:#fd2968"><em>02&nbsp;&nbsp;</em><strong>Zadig 产品具体有哪些变化？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-a6a559045246e08f1857b0e8666bab21df8.png" referrerpolicy="no-referrer"></strong></p><p>从源代码层面上，本次产品合并以开源 Zadig v1.18.0（最新版） 为基础，合并了原 ZadigX v1.8.0（即企业版）全部新功能代码，统称为 Zadig，产品版本正式定义为 Zadig v2.0.0，同时服务端代码在 GitHub 上全部开源，产品功能差异通过授权区分基础版和专业版。</p><p>对于已经在大规模使用 Zadig 的小伙伴，如果期待了解和亲自体验专业版功能，可以在平滑升级后免费激活并体验专业版功能长达 30 天，到期后专业版产生的数据不删除，原有基础版功能仍可正常使用。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-d6ad9eba6f9b41f1d391901be2fd3ae39c0.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_3"></span><h1><span style="color:#fd2968"><em>03&nbsp;&nbsp;</em><strong>对现有用户有哪些影响？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-91c5dba9d5f03113d993ebe2fa94c7638cd.png" referrerpolicy="no-referrer"></strong></p><p>对于社区开源用户而言，将在原有开源基础功能上进一步获得更多企业级功能，包括环境管理睡眠进一步做资源成本的削减，同时支持服务级测试管理、自定义工作流也一次性开放了大量企业内置最佳实践模板。同时 Zadig v2.0.0 在过去 V1.x 架构的基础上架构的基础上改进了易用性和性能，优化了安全细节，显著提高了工作流并行和复杂场景的执行效率，效率提升高达 50%，Zadig 的资源运行成本也降低了近 30%。在之后迭代中，用户也将持续获得产品底层能力的可靠性，这些更新将帮助到更多企业，提升开发测试阶段的云原生持续交付能力，为开发者提供更出色的体验。</p><p>对于企业客户，我们用 ZadigX 品牌代表包含企业级功能和专业服务的解决方案，"X"代表为企业客户提供更高质量的服务和保障，根据企业的具体难点和需求，接下来我们会面向企业推出一系列 DevOps 专家培训、DevOps 效能提升、云原生转型、IT 数字化升级等企业级解决方案。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-8c8a7c1737a91a1e0f819e9dcb9a3c82b9c.png" referrerpolicy="no-referrer"></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-5b2c672b70e514e6133d7b885270d5fc71c.png" referrerpolicy="no-referrer"></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank">阅读原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig">Zadig 在 Gitee</a></p><p><strong>推荐阅读</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490415%26idx%3D1%26sn%3D1914c7fd25aac5d33b98663571bbb744%26chksm%3Dcfb457cff8c3ded9c02809aad88012fa802eac55222eebe70b8c637ca2c86a101045aa81e73a%26scene%3D21%23wechat_redirect" target="_blank">是时候和 Jenkins 说再见了</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank">Zadig vs. Jenkins 详细比对：时代的选择与开发者之选</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247489682%26idx%3D1%26sn%3Df4ac5ceb38547542061477a45d8dc86d%26chksm%3Dcfb45432f8c3dd24b727e0fb6db276b2d63b2751933e63a25b00b9d9fac2dd68efbd2cbd3863%26scene%3D21%23wechat_redirect" target="_blank">平台工程和 AI 时代的新 10 亿开发者</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 07:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/koderover/blog/10140233</guid>
            <link>https://my.oschina.net/koderover/blog/10140233</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[阿里云推出 AI 编码助手：通义灵码]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">阿里云推出了一款基于通义大模型的智能编码辅助工具 —— <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftongyi.aliyun.com%2Flingma%2F" target="_blank">通义灵码</a>，提供行级/函数级实时续写、自然语言生成代码、单元测试生成、代码注释生成、代码解释、研发智能问答、异常报错排查等能力，并针对阿里云 SDK/OpenAPI 的使用场景调优，助力开发者高效、流畅的编码。</span></p><p><span style="color:#000000">根据官网介绍，通义灵码兼容 Visual Studio Code、JetBrains IDEs 等主流 IDE；且支持 Java、Python、Go、C/C++、JavaScript、TypeScript、PHP、Ruby、Rust、Scala 等主流编程语言。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>核心场景</strong></span></h4><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代码智能生成</strong></span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000">经过海量优秀开源代码数据训练，可根据当前代码文件及跨文件的上下文，为你生成行级/函数级代码、单元测试、代码注释等。沉浸式编码心流，秒级生成速度，让你更专注在技术设计，高质高效地完成编码工作。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>研发智能问答</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">基于海量研发文档、产品文档、通用研发知识、阿里云的云服务文档和 SDK/OpenAPI 文档等进行问答训练，为你答疑解惑，助你轻松解决研发问题。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>产品优势</strong></span></h4><ul style="margin-left:0; margin-right:0"><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>跨文件感知让代码生成更贴合业务场景：</strong>客户端和模型层同步优化针对代码跨文件上下文感知能力，生成代码更加贴合当前代码库的业务场景。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>阿里云服务使用场景友好：</strong>专门针对阿里云的云服务使用、SDK/OpenAPI 的使用等场景调优，编码时能够更加便捷地使用阿里云服务；在对阿里云使用有疑问时，智能编码助手的回答也将更加有效。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>适配多 IDE 的原生设计，符合开发者使用习惯：</strong>适配 IDE 原生主题、交互模式，让开发者感受到 IDE 原生的视觉和交互体验，更符合开发者使用习惯。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>研发问答、文档/代码搜索能力，打造沉浸式编码：</strong>无需切换工具，IDE 客户端内即可满足开发者编码场景中的技术资料检索、技术难题解答的诉求，打造开发者沉浸式编码体验。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>双模引擎，自由切换：</strong>支持极速本地模型、云端大模型两种代码补全模型，支持一键切换，满足不同网络环境、不同补全强度的场景诉求。</span></p></li></ul><h2 style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>功能介绍</strong></span></h2><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>行级/函数级实时续写</strong></span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000">根据当前语法和跨文件的代码上下文，实时生成行、函数建议代码。</span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000"><img alt="" height="182" src="https://oscimg.oschina.net/oscnet/up-145ecbcb5413f83c4f6512faeb7572d39ba.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>自然语言生成代码</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">通过自然语言描述你想要的功能，可直接在编辑器区生成代码，编码心流不间断。</span></p><p><span style="color:#000000"><img alt="" height="186" src="https://oscimg.oschina.net/oscnet/up-515b87e9afaf2bfb1f9200538f114663d20.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>单元测试生成</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">支持根据 JUnit、Mockito、Spring Test、unit test、pytest 等框架生成单元测试。</span></p><p><span style="color:#000000"><img alt="" height="198" src="https://oscimg.oschina.net/oscnet/up-6512237992e15393d3abbc2c8e3c77d4063.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代码注释生成</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">一键生成方法注释及行间注释，节省你写代码注释的时间，并能够有效提升代码可读性。</span></p><p><span style="color:#000000"><img alt="" height="192" src="https://oscimg.oschina.net/oscnet/up-bd96048c8e3e6d01aa66c1136d8ca7ff355.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代码解释</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">支持 30 多种语言的识别，选中代码后可自动识别编程语言并生成代码解释。跨越语言的边界，让你阅读代码更高效。</span></p><p><span style="color:#000000"><img alt="" height="154" src="https://oscimg.oschina.net/oscnet/up-615f625c27c7e8afe87ad83e1e7df085c76.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>研发领域自由问答</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">遇到编码疑问、技术难题时，一键唤起通义灵码，无需离开 IDE 客户端，即可快速获得答案和解决思路。聚焦研发领域知识的问答，帮助开发者快速解决问题。</span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><img alt="" height="214" src="https://oscimg.oschina.net/oscnet/up-70413ee56236fdc009f429692be9593d05b.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>异常报错智能排查（Java）</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">当运行出现异常报错时，一键启动报错排查的智能答疑，可结合运行代码、异常堆栈等报错上下文，快速给出排查思路或修复建议代码。</span></p><p><span style="color:#000000"><img alt="" height="309" src="https://oscimg.oschina.net/oscnet/up-87d6c9327ffeb245c28f22c1c979fae8172.png" width="500" referrerpolicy="no-referrer"></span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>支持 IDE 及操作系统</strong></span></h4><ul style="margin-left:0; margin-right:0"><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">Windows 7 及以上、macOS、Linux</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">JetBrains IDEs （IntelliJ IDEA、PyCharm、GoLand、WebStorm 等）2020.3 及以上</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">Visual Studio Code 1.75.1 及以上</span></p></li></ul><p><span style="color:#000000">目前，通义灵码已面向所有开发者开放公测，各大 IDE 插件市场均已上线。</span></p><p><span style="color:#000000">更多详情<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftongyi.aliyun.com%2Flingma%2F" target="_blank">可查看官网</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264459</guid>
            <link>https://www.oschina.net/news/264459</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 开源蓝心大模型-7B：70 亿参数、适合中国开发者]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在 2023 vivo 开发者大会上，vivo 宣布开源 70 亿参数级的蓝心大模型-7B，以及对应的微调框架。据称是行业首家开源大模型的手机厂商。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-27161d355f59c839fc4c9b6bb433e37dff3.png" referrerpolicy="no-referrer"></p><p>vivo 介绍道，他们提供<strong>蓝心大模型开发套件 BlueKit</strong>，让开发者不必考虑使用成本，专注于创新产品体验。此外，vivo 还推出蓝心开发者激励计划，<strong>提供一亿元资源支持，包含技术、运营、品牌三大方面。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-93548b2298b63f816adaa7f7c40b07b00f0.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0c711a4b9bd565a2eb78daee566e4475c80.png" referrerpolicy="no-referrer"></p><hr><p>蓝心大模型-7B 是 vivo 自研通用大模型矩阵中的其中一款。</p><p><img height="646" src="https://static.oschina.net/uploads/space/2023/1101/143959_y0Ws_2720166.png" width="1834" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1101/144435_2CXR_2720166.png" referrerpolicy="no-referrer"></p><p>整体如下：</p><ul><li><p>1B：端侧大模型</p></li><li><p>7B：端云两用模型（开源）</p></li><li><p>70B：云端主力模型</p></li><li><p>130B：云端大模型</p></li><li><p>175B：云端大模型</p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264455</guid>
            <link>https://www.oschina.net/news/264455</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Incus 0.2 发布，系统容器和虚拟机管理器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 是一个现代、安全且强大的系统容器和虚拟机管理器，它为在容器或虚拟机内运行和管理完整的 Linux 系统提供了统一的体验。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 以&nbsp;C</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>umulonimbus incus 或 anvil cloud&nbsp;<span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>命名，是 Canonical LXD 的社区分支。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>该分叉是为了回应&nbsp;<a href="https://www.oschina.net/news/248011/lxd-under-canonical">Canonical&nbsp;从 Linux<span>&nbsp;</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><a href="https://www.oschina.net/news/248011/lxd-under-canonical">Containers community&nbsp;</a><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><a href="https://www.oschina.net/news/248011/lxd-under-canonical">接管 LXD 项目</a>的举措。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 0.2 现已发布，</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#222222">此版本整合了 LXD 5.19 中的大部分更改，并引入了一些额外的功能和改进。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span style="background-color:#ffffff; color:#222222"><img alt="" height="333" src="https://static.oschina.net/uploads/space/2023/1101/142856_LLE7_4252687.png" width="500" referrerpolicy="no-referrer"></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span style="background-color:#ffffff; color:#222222">一些亮点更新内容如下：</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><strong><span style="background-color:#ffffff; color:#222222">虚拟机中的 NVME 存储支持</span></strong></p><p><span style="background-color:#ffffff; color:#222222">虚拟机的磁盘类型设备新增了</span><code>io.bus</code><span style="background-color:#ffffff; color:#222222">configuration key。</span></p><p><span style="background-color:#ffffff; color:#222222">默认设置为</span><code>virtio-scsi</code><span style="background-color:#ffffff; color:#222222"><span>&nbsp;</span>，但现在也可以设置为</span><code>nvme</code><span style="background-color:#ffffff; color:#222222">，以便在虚拟机中将磁盘显示为 NVME SSD。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>从 LXD 迁移的集群支持</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>迁移工具<code>lxd-to-incus</code>现在支持集群环境。此外，它还进行了更新以支持 LXD 5.19 作为源版本。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>这意味着任何使用 LXD 4.0 及更高版本（直到 5.19）的人现在都可以通过安装 Incus 并运行<code>lxd-to-incus</code>轻松迁移到 Incus。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>非特权容器的新镜像要求</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>当添加对 NixOS 作为容器镜像的支持时，发现该特定镜像当前无法在特权容器内运行。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>因此添加一个新的镜像要求。可以将<code>requirements.privileged</code>设置为<code>false</code>，以防止该镜像与特权容器一起使用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><pre><code>stgraber@dakara:~$ incus launch images:nixos nixos-priv -c security.privileged=true
Creating nixos-priv
Starting nixos-priv
Error: The image used by this instance is incompatible with privileged containers. Please unset security.privileged on the instance
Try `incus info --show-log local:nixos-priv` for more info
stgraber@dakara:~$</code></pre><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>服务器端自定义卷复制</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 现在支持自定义卷的服务器端副本。这消除了客户端充当中继的需要，从而显着加快了自定义卷的复制速度。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>命令行工具会自动检测对此的支持并在可用时使用它。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>该功能首次在 LXD 中引入。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>静态二进制文件现在可用于 64 位 Arm</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>作为发布和测试的一部分提供的所有静态二进制文件，现在都适用于 Intel 64 位和 Arm 64 位。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdiscuss.linuxcontainers.org%2Ft%2Fincus-0-2-has-been-released%2F18185" target="_blank">查看官方公告</a>。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264451/incus-0-2-released</guid>
            <link>https://www.oschina.net/news/264451/incus-0-2-released</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 发布自研操作系统蓝河 (BlueOS)，系统框架采用 Rust 编写]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 vivo 开发者大会今天正式开始。大会上，vivo 发布了自研操作系统<strong>蓝河 (BlueOS)</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-15a70d97c2f8f3654e7d6f94c8c92df5505.png" referrerpolicy="no-referrer"></p><p>vivo 称「蓝河操作系统」是面向通用人工智能时代的自研智慧操作系统 —— 底层接入了 AI 大模型，支持基于自然交互方式的应用开发。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135537_Q43j_2720166.png" referrerpolicy="no-referrer"></p><p>vivo 还表示，蓝河操作系统<strong>采用 Rust 编写「系统框架」</strong>——从源头避免了内存使用不当引起的安全漏洞。据称是行业首家<strong>。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f21c3eb7d2568b66e3cebdf8f628b9bb78b.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135659_sEFQ_2720166.png" referrerpolicy="no-referrer"></p><p>运行要求方面，在低至 200Mhz 主频 32MB 内存，高至 4GHz 主频 24GB 内存的各种设备上，蓝河都能流畅运行。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/142454_nhO4_2720166.png" referrerpolicy="no-referrer"></p><p>据了解，蓝河操作系统目前不会在 vivo 手机上提供，首款搭载蓝河操作系统的 vivo 设备是 vivo Watch3 智能手表。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b5c944705e833222c61dc1c96c7713648ca.png" referrerpolicy="no-referrer"></p><p>此外，<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1668726803%2FNqydVxKTF%3Frefer_flag%3D1001030103_" target="_blank">据称蓝河操作系统是基于 Linux/RTOS 的自研架构</a></u>，因此不兼容 Android 应用。不过它兼容 hapjs，以获得更好的生态支持。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/152743_iniv_2720166.png" referrerpolicy="no-referrer"></p><blockquote><p>hapjs 项目是由开放原子开源基金会孵化及运营的开源项目，<strong>是快应用标准的开源实现</strong>，是基于智能硬件平台的轻型应用形态，由多智能硬件厂商组成的快应用联盟联合制定标准共同驱动。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1ed767bef366be3bde87f6dbd714fdbd581.png" referrerpolicy="no-referrer"></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264444</guid>
            <link>https://www.oschina.net/news/264444</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[macOS Sonoma 黑屏 bug，影响 Asahi Linux]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Asahi Linux 发布了一篇文档，说明了近期 macOS 黑屏情况。</p><blockquote><p><span style="color:#333333">Asahi Linux 项目致力于将 Linux 操作系统移植到苹果的 Apple Silicon Macs 系列电脑设备上。</span></p><ul><li><a href="https://www.oschina.net/news/125751/asahi-linux-set-up" target="_blank">可移植苹果 M1 的 Asahi Linux 项目正式启</a></li></ul></blockquote><p>Asahi 解释，macOS Sonoma 和 macOS Ventura 13.6 在其升级和启动过程中发布了多个严重的错误。这些错误结合在一起，可以创建出一种情况，即无论使用何种电源按钮按压组合，机器总是启动到黑屏。这使用户陷入困境，唯一的解决方案就是使用 DFU 恢复。</p><p>在某些设置和特定型号下，这种情况可能会发生，即多个 macOS 版本并行安装（一个 Sonoma，一个更早的版本）。由于 Asahi Linux 的行为就像是 macOS 12.3/12.4/13.5（取决于型号和安装时间），所以 macOS Sonoma 和 Asahi Linux 的双启动安装会产生相同的问题。对于 macOS 13.6，这种情况甚至不需要双启动系统，只要作为唯一安装的操作系统就可以触发。</p><p>目前 Asahi Linux 安装程序已经更新，现在它可以在启动时自动进行完整性检查并诊断系统。要运行它，请将此命令粘贴到 macOS 的终端中：</p><p style="text-align:start"><code>curl https://alx.sh | sh</code></p><p style="text-align:start">进入主菜单，用户可以退出安装程序，而不对系统做任何更改。</p><p style="text-align:start">Asahi Linux 具体说明了 macOS 启动失败的原因：</p><ul><li><p>macOS Sonoma 的升级使用先前安装的版本作为系统恢复。这在某种程度上是有道理的，但并未考虑到旧版 RecoveryOS 与新固件之间的向后兼容性问题。如果这种不匹配导致 recoveryOS 无法启动，那么系统恢复将无法使用。</p></li><li><p>对于 14 英寸和 16 英寸的型号：一旦系统固件更新到 macOS Sonoma 版本，如果显示器的刷新率设置为非 ProMotion，则该系统将无法正确地启动旧版本的 macOS 安装程序和 Asahi Linux。这包括当这些系统被设置为默认启动操作系统时的恢复模式，以及至少在下一次操作系统升级之前的系统恢复。</p></li></ul><p>影响设备、系统：</p><ul><li><p>配备 ProMotion 显示屏的 MacBook Pro 型号（14 英寸和 16 英寸）受到黑屏启动错误的影响。</p></li><li><p>macOS Sonoma 14.0+（截至 2023 年 10 月 31 日尚未修复）</p></li><li><p>macOS Ventura 13.6+ (使用 14.0 固件)</p></li><li><p>可能受影响：macOS Monterey 12.7（未经确认）</p></li></ul><p><strong>如果还没升级到 Sonoma，Asahi Linux&nbsp;<span style="background-color:#ffffff; color:#1f2328">建议等到苹果解决这些问题后再进行升级。</span></strong></p><p>更多细节查看 Asahi 发布的说明：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAsahiLinux%2Fdocs%2Fwiki%2FmacOS-Sonoma-Boot-Failures" target="_blank">https://github.com/AsahiLinux/docs/wiki/macOS-Sonoma-Boot-Failures</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 04:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264432/macos-sonoma-boot-failures</guid>
            <link>https://www.oschina.net/news/264432/macos-sonoma-boot-failures</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微信 iOS 版「史诗级」更新：「发送」按钮独立]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>微信 iOS 版昨天发布了 8.0.43 更新，更新日志一如既往地是「修复了一些已知问题」。</p><blockquote><p><img height="780" src="https://static.oschina.net/uploads/space/2023/1101/121221_VGwW_2720166.png" width="1810" referrerpolicy="no-referrer"></p></blockquote><p>不过热心网友发现的一项重要变化冲上了微博热搜：<span style="color:#e67e22"><strong>#微信新增独立发送按钮#</strong></span>。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-12f6e066aebe74a1bd7440aa69ef266c4b9.png" referrerpolicy="no-referrer"></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-877e90cea0d617b8694aa9a040acdc2080e.png" referrerpolicy="no-referrer"></p><p>没错，微信 for iOS 8.0.43 新增了「使用独立的发送按钮」开关。开启后，iOS 自带输入法的「发送」按键变成「换行」按键，而输入框右侧增加了独立的「发送」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-410e4a667b0d00dcd7c363e6c756adad620.png" referrerpolicy="no-referrer"></p><p>对使用 iOS 自带输入法用户来说，这属实是「史诗级」更新。</p><p>毕竟此前在输入文字的时候如果想换行，需要在输入框轻点或者长按呼出换行开关。现在「换行」和「发送」终于都有了独立按键，感谢 Allen Zhang : )</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 04:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264431</guid>
            <link>https://www.oschina.net/news/264431</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gateway API v1.0：GA 版本出炉]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Gateway API v1.0 版本现已发布。公告指出，此版本是该项目的一个重要里程碑。几个关键的 API 已经升级为 GA（generally available，一般可用），同时其他重要功能已添加到实验（Experimental）通道。</span></p><h4><span style="color:#000000"><strong>新增内容</strong></span></h4><p><span style="color:#000000"><strong>升级到 v1</strong></span></p><p><span style="color:#000000">此版本将 Gateway、GatewayClass 和 HTTPRoute 升级为 v1，意味着它们现在是一般可用的。这个 API 版本表示对 API 表面具有高度的信心，并提供向后兼容的保证。需要注意的是，虽然标准（Standard）通道中包含的这些 API 版本现在被认为是稳定的，但这并不意味着它们是完整的。这些 API 将继续通过实验通道接收新的功能，以满足升级的标准。</span></p><p><span style="color:#000000"><strong>Logo</strong></span></p><p><span style="color:#000000">Gateway API 现在有了自己的 Logo！这个 Logo 是通过协作过程设计的，旨在代表这是一组用于在 Kubernetes 中进行南北向和东西向流量路由的 API：</span></p><p><img height="135" src="https://oscimg.oschina.net/oscnet/up-b9aa4cb25f206b6a9cd7b73608e412f035b.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><strong>CEL 验证</strong></span></p><p><span style="color:#000000">过去，Gateway API 作为安装 API 的一部分绑定了验证 webhook。从 v1.0 开始，webhook 的安装是可选的，仅建议在 Kubernetes 1.24 上使用。Gateway API 现在将 CEL ]验证规则作为 CRDs 的一部分进行了包含。这种新形式的验证在 Kubernetes 1.25+中得到支持，因此在大多数安装中不再需要验证 webhook。</span></p><p><span style="color:#000000"><strong>标准通道</strong></span></p><p><span style="color:#000000">此版本的主要重点是确保现有的 beta API 定义明确，并足够稳定，可以升级为 GA。这导致了各种规范的澄清，以及一些改进，以提高与 Gateway API 交互时的整体用户体验。</span></p><p><span style="color:#000000"><strong>实验通道</strong></span></p><p><span style="color:#000000">此版本中包含的大部分更改都限于实验通道，包括 HTTPRoute 超时、从 Gateway 到后端的 TLS 配置、WebSocket 支持、Gateway 基础设施标签等。</span></p><hr><p><span style="color:#000000">接下来，项目团队将继续致力于努力稳定和升级 API 的其他实验性功能。包括支持服务网格]、额外的路由类型（GRPCRoute、TCPRoute、TLSRoute[17]、UDPRoute）以及各种实验性功能。</span></p><p><span style="color:#000000">以及将 ReferenceGrant 移入内置的 Kubernetes API 中，使其可以用于不仅仅是 Gateway API。「在 Gateway API 中，我们使用这个资源来安全地启用跨命名空间引用，而这个概念现在被其他 SIGs 采纳。这个 API 的新版本将归 SIG Auth 所有，并且在迁移到内置的 Kubernetes API 时可能包含至少一些修改。」</span></p><p><span style="color:#000000">更多详情可查看：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubernetes-sigs%2Fgateway-api%2Freleases%2Ftag%2Fv1.0.0" target="_blank">https://github.com/kubernetes-sigs/gateway-api/releases/tag/v1.0.0</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264423/gateway-api-1-0-released</guid>
            <link>https://www.oschina.net/news/264423/gateway-api-1-0-released</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[运营商在光猫内置反诈插件？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>网友发帖称，自己的同事参加某运营商<strong>加 1 元提速 2000m 送 fttr 1+2 活动</strong>后，由于活动要求 45 天内保持在线并且要使用路由模式，这名同事就按照要求使用路由模式。</p><blockquote><p>FTTR (Fiber to The Remote)，是指光纤敷设到远端节点，为光纤接入的基本技术方式。</p></blockquote><p>然后他发现自建的科学上网功能出现不能连接的情况，并且访问&nbsp; xenyth.net 网站时直接跳转到了反诈页面，几分钟之后接到反诈热线打来的电话，询问他有没有访问一个叫做 xenyth.net 的诈骗网站。工作人员告诉他这是一个网购诈骗网站，付款后不会发货，要求不再访问，如有需要可以安排民警上门。</p><p><span style="background-color:#ffffff; color:#000000">后面这名同事搞到超级密码后进入光猫，发现：</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9b10cd4d0019c4015f48be3f0d542493520.png" referrerpolicy="no-referrer"></p><p>最后附上卸载插件方法：</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/113529_5FaL_2720166.png" referrerpolicy="no-referrer"></p><p><em>via&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.v2ex.com%2Ft%2F986550" target="_blank">https://www.v2ex.com/t/986550</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264421</guid>
            <link>https://www.oschina.net/news/264421</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[四维纵横完成超亿元 B 轮融资]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">新一代超融合数据库厂商四维纵横<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fq_l-0lQ_GJxLTEXTjF30ag" target="_blank">宣布</a>完成了上亿元人民币的 B 轮融资，本轮融资由用友、顺义产业基金领投，广州同创基金跟投。该公司表示，</span><span style="background-color:#ffffff">此次募集资金将会主要用于研发核心技术，建设商业生态链等方面。</span></span></p><p><span style="color:#000000"><img height="251" src="https://oscimg.oschina.net/oscnet/up-ecefb2dbc5ddf668afa56fccacfa3960e27.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">四维纵横是一家成立于 2020 年的数据库公司，以超融合数据库 YMatrix 为企业提供集「分析、事务、时序」为一体的企业级数据库产品服务。目前，四维纵横，以 YMatrix 为核心，自研了全栈向量化执行器、分布式数据库灾备、MARS3 存储引擎、MatrixShift 迁移工具、MatrixGate 高性能写入组件、MatrixUI 图形化界面等一系列商业化套件。</span></p><p><span style="color:#000000"><img height="345" src="https://oscimg.oschina.net/oscnet/up-c609ba963a02c51a5f6c10587fc68105704.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">当前，YMatrix 已经被应用到证券、通信、银行、保险、智能制造、车联网等多个行业领域中，服务的客户包括浪潮、中兴、理想汽车、宁德时代、三一重工等多个头部企业。</span></span></p><p><span style="color:#000000">公告指出，在本轮融资之后，四维纵横将会以目前 YMatrix 产品技术能力为根基，以超融合理念为发展方向，继续拓展新的应用领域，将 YMatrix 超融合数据库产品应用于更多的场景中。另外，四维纵横将进一步加快并夯实技术团队的人员建设和技术基础，为全球用户提供更加全面的超融合解决方案。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264414</guid>
            <link>https://www.oschina.net/news/264414</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度上线「文心一言」会员，开通可解锁文心大模型 4.0]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>百度大模型文心一言现已上线会员模式，开通后可解锁文心大模型 4.0。</p><p><strong>目前文心一言基础版功能依旧免费开放使用</strong>，可以满足用户的日常需求，如交互对话、问答等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-523eef7bc90f0772422e76d8d238e5a06f5.png" referrerpolicy="no-referrer"></p><p>据介绍，文心一言会员单月购买价格为 59.9 元，<strong>连续包月价格为 49.9 元</strong>（次月以 49.9 元 / 月自动续费，可随时取消）。此外，百度还推出了文心一言 + 文心一格（白银）的联合会员，价格为 99 元 / 月。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2e89f249c9e05e483bc3e37a5c145a0001d.png" referrerpolicy="no-referrer"></p><p><strong>文心一言会员权益：</strong></p><ul><li><p>模型能力：文心大模型 4.0</p></li><li><p>图片生成：文生图能力全面升级</p></li><li><p>插件权益 （网页端）：高阶插件</p></li><li><p>灵感值 （App 端）：单月赠送 600 灵感值</p></li></ul><p><strong>文心一格会员权益：</strong></p><ul><li><p>极速生成多尺寸高清图像</p></li><li><p>创作海报和艺术字</p></li><li><p>白银会员权益：AI 编辑改图修图</p></li></ul><hr><p><u><a href="https://www.oschina.net/news/262086">文心大模型 4.0 于上个月正式亮相</a></u>，李彦宏表示，<strong>这是迄今为止最强大的文心大模型</strong>，实现了基础模型的全面升级，在理解、生成、逻辑和记忆能力上都有着明显提升，综合水平「与 GPT-4 相比毫不逊色」。</p><p><img alt="up-cb21975862a8f7b014aeea47cbab52da1df.png" src="https://oscimg.oschina.net/oscnet/up-cb21975862a8f7b014aeea47cbab52da1df.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264412</guid>
            <link>https://www.oschina.net/news/264412</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenSign —— 开源 PDF 电子签名解决方案]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenSign 是一个开源文档电子签名解决方案，旨在为 DocuSign、PandaDoc、SignNow、Adobe Sign、Smartwaiver、SignRequest、HelloSign 和 Zoho Sign 等商业平台提供安全、可靠且免费的替代方案。</p><p>特性：</p><ul><li><strong>安全签名</strong>：利用最先进的加密算法来确保文档的安全性和完整性。</li><li><strong>用户友好的界面</strong>：设计时考虑到可用性，使技术和非技术用户都能轻松使用。</li><li><strong>多平台支持</strong>：兼容各种浏览器和设备。</li><li><strong>邀请和协作用户</strong>：将团队中的多人带入签名流程，所有这些都在你自己的基础设施内进行。</li><li><strong>安全</strong>：允许使用「OpenSigDrive」轻松、安全和无缝地组织文档。</li><li><strong>审计跟踪</strong>：保留与文档签名过程相关的所有活动的详细日志，包括 IP 地址和访问时间。</li><li><strong>完成证书</strong>：所有参与者签署文件后立即生成安全完成证书。</li><li><strong>API 支持</strong>：提供强大的 API，用于集成到其他软件和服务中。</li></ul><p><img alt="" height="293" src="https://static.oschina.net/uploads/space/2023/1031/154224_RLJo_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="298" src="https://static.oschina.net/uploads/space/2023/1031/154242_mhWv_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="307" src="https://static.oschina.net/uploads/space/2023/1031/154356_RuMR_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/opensign</guid>
            <link>https://www.oschina.net/p/opensign</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 一站式分布式任务调度系统 Hodor]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-hodorscheduler" class="anchor" href="https://gitee.com/dromara/hodor#hodorscheduler"></a>HodorScheduler</h1><h2><a id="user-content-介绍" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BB%8B%E7%BB%8D"></a>介绍</h2><p>Hodor 是一个专注于<strong>任务调度</strong>以及<strong>任务编排</strong>的<strong>一站式</strong>分布式任务调度系统。</p><p>通过提供任务编程 API 和接口协议， 方便支持用户使用不同的编程语言实现任务执行以及自定义任务类型的扩展，以满足各种业务场景下的任务执行。</p><p>支持多种接入方式，支持 Java SDK 包方式、Java Agent 独立进程方式接入，以及兼容 XXLJob 框架、Spring Task 框架任务无缝接入。</p><p>多语言执行器实现，计划支持 Go 或者 Rust 语言执行器（正在设计与开发中）的接入，满足在资源有限的执行器节点执行，比如物联网场景下面的定时任务执行。</p><p>支持丰富的任务类型，除了支持普通的 Java、脚本任务的执行，也支持了大数据任务 Hadoop、Spark、Flink、Kettle 等主流任务的执行，满足用户的不同场景。</p><h2><a id="user-content-主要特性" class="anchor" href="https://gitee.com/dromara/hodor#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"></a>主要特性</h2><ol><li>支持 Cron、FixedRate、FixedDelay、OnceTime 方式配置定时任务，可以方便地实现各种定时任务需求。</li><li>支持 DAG 方式进行任务编排，使得任务之间的关系更加清晰，同时提高了系统的可扩展性和灵活性。</li><li>支持 Java 任务和大数据任务调度，兼容 XXLJob、SpringTask 调度任务，满足不同场景下的任务调度需求。</li><li>支持可扩展执行器，用户可以根据自己的需求自定义实现任务类型，从而更好地适应不同的业务场景。</li><li>支持任务静态分片、动态分片、广播、WorkFlow 等多种任务执行模式。</li><li>支持任务自动创建与手动创建以及批量创建等方式，任务的暂停、恢复、Kill 等动作，以及实时日志查看等。</li><li>基于 CopySet 算法实现任务副本分配，提高了任务的可靠性和容错性，从而保障了任务的高可用性。</li></ol><p>详细文档请查阅：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor">https://www.yuque.com/tomgs/hodor</a></p><h2><a id="user-content-架构设计" class="anchor" href="https://gitee.com/dromara/hodor#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"></a>架构设计</h2><p><img src="https://gitee.com/dromara/hodor/raw/master/docs/assets/img/hodor%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="hodor 架构设计图" referrerpolicy="no-referrer"></p><h2><a id="user-content-快速开始" class="anchor" href="https://gitee.com/dromara/hodor#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"></a>快速开始</h2><p>项目结构：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">hodor-scheduler</span><span id="LC2" class="line">├─docs                                          # 文档存放位置</span><span id="LC3" class="line">├─hodor-actuator                                # hodor 任务执行器</span><span id="LC4" class="line">│  ├─hodor-actuator-api                         # 执行器扩展接口</span><span id="LC5" class="line">│  ├─hodor-actuator-java                        # jar 包方式任务执行器</span><span id="LC6" class="line">│  ├─hodor-actuator-agent                       # 独立进程方式任务执行器</span><span id="LC7" class="line">│  ├─hodor-actuator-xxljob                      # 支持 xxl-job 执行器</span><span id="LC8" class="line">│  └─hodor-actuator-springtask                  # 支持 spring task 执行器</span><span id="LC9" class="line">├─hodor-admin                                   # hodor 管理控制枱（TODO）</span><span id="LC10" class="line">├─hodor-client                                  # 提供与 hodor server 的交互 sdk</span><span id="LC11" class="line">├─hodor-common                                  # hodor 公共依赖</span><span id="LC12" class="line">├─hodor-core                                    # hodor 核心业务</span><span id="LC13" class="line">├─hodor-examples                                # hodor 测试用例</span><span id="LC14" class="line">├─hodor-cache                                   # hodor 扩展</span><span id="LC15" class="line">│  ├─hodor-cache-local                          # 基于本地内存的缓存</span><span id="LC16" class="line">│  ├─hodor-cache-embedded                       # 基于 embedded 的分布式缓存</span><span id="LC17" class="line">│  └─hodor-cache-redis                          # 基于 redis 的分布式缓存</span><span id="LC18" class="line">├─hodor-model                                   # hodor 公共数据模型</span><span id="LC19" class="line">├─hodor-storage                                 # hodor storage 模块</span><span id="LC20" class="line">├─hodor-register                                # hodor 注册中心</span><span id="LC21" class="line">│  ├─hodor-register-api</span><span id="LC22" class="line">│  ├─hodor-register-embedded                    # 基于 Raft 实现注册中心</span><span id="LC23" class="line">│  └─hodor-register-zookeeper                   # 基于 zk 实现注册中心</span><span id="LC24" class="line">├─hodor-remoting                                # hodor 通信框架</span><span id="LC25" class="line">│  ├─hodor-remoting-api</span><span id="LC26" class="line">│  └─hodor-remoting-netty</span><span id="LC27" class="line">├─hodor-scheduler                               # hodor 调度核心</span><span id="LC28" class="line">│  ├─hodor-scheduler-api</span><span id="LC29" class="line">│  └─hodor-scheduler-quartz</span><span id="LC30" class="line">└─hodor-server                                  # hodor 入口</span><span id="LC31" class="line"></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-本地源码运行方式" class="anchor" href="https://gitee.com/dromara/hodor#%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"></a>本地源码运行方式</h2><ol><li>在 mysql 下执行 docs 目录下面的 hodor_ddl.sql。</li><li>在项目根目录下通过 mvn package -DskipTests=true 命令编译整个项目，因为涉及到一些代码的自动生成。</li><li>进入到 hodor-server，启动 HodorServer 调度器。</li><li>进入到 examples 下面的 hodor-actuator-java-example，启动 java 任务执行器程序</li><li>java 执行器启动完成后会自动将任务注册到调度器里面来</li></ol><h2><a id="user-content-任务使用说明" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"></a>任务使用说明</h2><p>详细参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fiqrsqxh2i2qt5ixi">执行器操作指南</a></p><h3><a id="user-content-java 任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#java%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>java 任务接入 demo</h3><p>详细 demo 代码参考 <em>hodor-examples/hodor-actuator-java-example</em> 模块</p><blockquote><p>普通 java 任务</p></blockquote><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">group</span><span class="o">=</span><span class="s">"testGroup"</span><span class="o">,</span><span class="n">jobName</span><span class="o">=</span><span class="s">"test1"</span><span class="o">,</span><span class="n">cron</span><span class="o">=</span><span class="s">"0/30 * * * * ?"</span><span class="o">)</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="nc">String</span><span class="nf">test1</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC3" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [testGroup#test1] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC4" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC5" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job test1"</span><span class="o">);</span></span><span id="LC6" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"job argument: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getJobParameter</span><span class="o">());</span></span><span id="LC7" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executing......"</span><span class="o">);</span></span><span id="LC8" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executed"</span><span class="o">);</span></span><span id="LC9" class="line"><span class="k">return</span><span class="s">"a=123"</span><span class="o">;</span></span><span id="LC10" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><blockquote><p>动态分片任务</p></blockquote><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 任务动态切分</span></span><span id="LC2" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"splitStage"</span><span class="o">)</span></span><span id="LC3" class="line"><span class="kd">public</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">ShardData</span><span class="o">&gt;</span><span class="nf">split</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC4" class="line"><span class="nc">ShardData</span><span class="n">shardData</span><span class="o">=</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">id</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">params</span><span class="o">(</span><span class="s">"hello"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span></span><span id="LC5" class="line"><span class="nc">ShardData</span><span class="n">shardData1</span><span class="o">=</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">id</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">params</span><span class="o">(</span><span class="s">"world"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span></span><span id="LC6" class="line"><span class="k">return</span><span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">shardData</span><span class="o">,</span><span class="n">shardData1</span><span class="o">);</span></span><span id="LC7" class="line"><span class="o">}</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">// 任务并行执行</span></span><span id="LC10" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"parallelJob"</span><span class="o">)</span></span><span id="LC11" class="line"><span class="kd">public</span><span class="nc">String</span><span class="nf">parallelJob</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC12" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [parallelJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC13" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC14" class="line"><span class="kd">final</span><span class="nc">ShardData</span><span class="n">parentJobData</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobData</span><span class="o">(</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></span><span id="LC15" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job parallelJob, parentJobData: {}"</span><span class="o">,</span><span class="n">parentJobData</span><span class="o">);</span></span><span id="LC16" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job parallelJob, parentJobData: {}"</span><span class="o">,</span><span class="n">parentJobData</span><span class="o">);</span></span><span id="LC17" class="line"><span class="k">return</span><span class="s">"a=123"</span><span class="o">;</span></span><span id="LC18" class="line"><span class="o">}</span></span><span id="LC19" class="line"></span><span id="LC20" class="line"><span class="c1">// 任务汇总执行</span></span><span id="LC21" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"reduceJob2"</span><span class="o">)</span></span><span id="LC22" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">reduceJob</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC23" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC24" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC25" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"job argument: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getJobParameter</span><span class="o">());</span></span><span id="LC26" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executed"</span><span class="o">);</span></span><span id="LC27" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC28" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, results {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobExecuteResults</span><span class="o">()</span></span><span id="LC29" class="line"><span class="o">);</span></span><span id="LC30" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, statues {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobExecuteStatuses</span><span class="o">());</span></span><span id="LC31" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-xxljob 任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#xxljob%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>xxljob 任务接入 demo</h3><p>详细 demo 代码参考 <em>hodor-examples/hodor-actuator-xxljob-example</em> 模块</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="cm">/**</span></span><span id="LC2" class="line"><span class="cm"> * 1、简单任务示例（Bean 模式）</span></span><span id="LC3" class="line"><span class="cm"> */</span></span><span id="LC4" class="line"><span class="nd">@XxlJob</span><span class="o">(</span><span class="s">"demoJobHandler"</span><span class="o">)</span></span><span id="LC5" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">demoJobHandler</span><span class="o">()</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC6" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"XXL-JOB, Hello World."</span><span class="o">);</span></span><span id="LC7" class="line"></span><span id="LC8" class="line"><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"beat at:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span></span><span id="LC10" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC11" class="line"><span class="o">}</span></span><span id="LC12" class="line"><span class="c1">// default success</span></span><span id="LC13" class="line"><span class="o">}</span></span><span id="LC14" class="line"></span><span id="LC15" class="line"><span class="cm">/**</span></span><span id="LC16" class="line"><span class="cm"> * 2、分片广播任务</span></span><span id="LC17" class="line"><span class="cm"> */</span></span><span id="LC18" class="line"><span class="nd">@XxlJob</span><span class="o">(</span><span class="s">"shardingJobHandler"</span><span class="o">)</span></span><span id="LC19" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">shardingJobHandler</span><span class="o">()</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC20" class="line"><span class="c1">// 分片参数</span></span><span id="LC21" class="line"><span class="kt">int</span><span class="n">shardIndex</span><span class="o">=</span><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">getShardIndex</span><span class="o">();</span></span><span id="LC22" class="line"><span class="kt">int</span><span class="n">shardTotal</span><span class="o">=</span><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">getShardTotal</span><span class="o">();</span></span><span id="LC23" class="line"></span><span id="LC24" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"分片参数：当前分片序号 = {}, 总分片数 = {}"</span><span class="o">,</span><span class="n">shardIndex</span><span class="o">,</span><span class="n">shardTotal</span><span class="o">);</span></span><span id="LC25" class="line"></span><span id="LC26" class="line"><span class="c1">// 业务逻辑</span></span><span id="LC27" class="line"><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">shardTotal</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span><span class="o">{</span></span><span id="LC28" class="line"><span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="n">shardIndex</span><span class="o">)</span><span class="o">{</span></span><span id="LC29" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"第 {} 片, 命中分片开始处理"</span><span class="o">,</span><span class="n">i</span><span class="o">);</span></span><span id="LC30" class="line"><span class="o">}</span><span class="k">else</span><span class="o">{</span></span><span id="LC31" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"第 {} 片, 忽略"</span><span class="o">,</span><span class="n">i</span><span class="o">);</span></span><span id="LC32" class="line"><span class="o">}</span></span><span id="LC33" class="line"><span class="o">}</span></span><span id="LC34" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-spring-task 任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#spring-task%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>spring task 任务接入 demo</h3><p>详细 demo 代码参考 <em>hodor-examples/hodor-actuator-springtask-example</em> 模块</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedRate</span><span class="o">=</span><span class="mi">3000</span><span class="o">)</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task1</span><span class="o">()</span><span class="kd">throws</span><span class="nc">InterruptedException</span><span class="o">{</span></span><span id="LC3" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC4" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行 fixedRate 任务的时间："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC5" class="line"><span class="o">}</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedDelay</span><span class="o">=</span><span class="mi">4000</span><span class="o">)</span></span><span id="LC8" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task2</span><span class="o">()</span><span class="kd">throws</span><span class="nc">InterruptedException</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC10" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行 fixedDelay 任务的时间："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC11" class="line"><span class="o">}</span></span><span id="LC12" class="line"></span><span id="LC13" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">cron</span><span class="o">=</span><span class="s">"0/5 * * * * ?"</span><span class="o">)</span></span><span id="LC14" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task3</span><span class="o">()</span><span class="o">{</span></span><span id="LC15" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行 cron 任务的时间："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC16" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-agent-方式任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#agent-%E6%96%B9%E5%BC%8F%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>agent 方式任务接入 demo</h3><p>详细参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fiqrsqxh2i2qt5ixi">执行器操作指南</a> 中的 agent 方式的使用。</p><h2><a id="user-content-hodor 打包部署说明" class="anchor" href="https://gitee.com/dromara/hodor#hodor%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%AF%B4%E6%98%8E"></a>hodor 打包部署说明</h2><p>详细参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fgiukp9y4plqb55ng">安装部署操作指南</a></p><h2><a id="user-content-交流学习" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BA%A4%E6%B5%81%E5%AD%A6%E4%B9%A0"></a>交流学习</h2><p>目前，Hodor 仍处于建设的过程中，团队成员只能抽出空闲时间投入其中，主要精力还是放在日常工作中。
如果有兴趣的同学想要参与 Hodor 的实现或者一起学习，欢迎通过微信联系我们，我们非常欢迎新的成员加入！</p><p>Hodor 的未来发展方向包括以下几个方面：</p><ol><li>前端界面和控制枱开发，为用户提供更加友好、直观的任务管理界面。</li><li>执行器开发工作，包括执行编程框架和大数据任务执行器的优化，以提高系统的性能和稳定性。</li><li>通信协议改造，计划将目前自定义的协议改造为 grpc 的方式，以提高系统的可扩展性和兼容性。</li><li>优化 CopySet 算法的实现，以支持机架感知，更好地分配任务副本。</li><li>开发多语言执行器，主要放在 go 和 rust 语言，以满足用户不同的需求和偏好。</li></ol><p>Wechat：(备注：Hodor)</p><p><img src="https://gitee.com/dromara/hodor/raw/master/docs/assets/img/wechat.png" alt="image-20220529141555032" referrerpolicy="no-referrer"></p>]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/dromara/hodor</guid>
            <link>https://gitee.com/dromara/hodor</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | Dubbo 路由及负载均衡性能优化]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="font-size: 15px;"><section style="text-align: right;margin-top: 10px;margin-bottom: -25px;" powered-by="xiumi.us"><section style="display: inline-block;width: 35px;height: 35px;vertical-align: top;overflow: hidden;border-width: 1px;border-radius: 100%;border-style: solid;border-color: transparent;background-color: rgb(255, 255, 255);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section><section style="text-align: center;font-size: 14px;" powered-by="xiumi.us"><p><span style="color: rgb(0, 82, 255);"><span style="color: rgb(0, 82, 255);letter-spacing: 0.578px;text-align: center;text-wrap: wrap;font-size: 14px;">揭秘 vivo 互联网海量服务的研发之路&nbsp;</span><span style="color: rgb(0, 82, 255);text-align: center;text-wrap: wrap;font-size: 14px;letter-spacing: 0.034em;">报名中👇</span></span></p></section><section style="text-align: center;margin-top: 0.5em;margin-bottom: 0.5em;padding-left: 0.5em;padding-right: 0.5em;" powered-by="xiumi.us"><section style="border-width: 5px;border-style: solid;border-color: rgb(255, 255, 255);display: inline-block;line-height: 0;box-shadow: rgb(102, 102, 102) 0.2em 0.2em 0.5em;width: 70%;height: auto;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D2%26sn%3D949ce368a94c5950749a74fec56b98fb%26chksm%3Debdb8632dcac0f24fbac44050c9605d521f9728517b311f54639e1ab3bc0422ce95391b09636%26scene%3D21%23wechat_redirect" textvalue="你已选中了添加链接的内容" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="1"><span class="js_jump_icon h5_image_link"><img class="rich_pages wxw-img" data-cropselx1="0" data-cropselx2="384" data-cropsely1="0" data-cropsely2="384" data-ratio="0.21944444444444444" data-s="300,640" src="https://oscimg.oschina.net/oscnet/92614968-2ae5-4624-9416-5e3659137ef6.png" data-type="jpeg" data-w="1080" style="vertical-align: middle;width: 578px;height: 127px;" referrerpolicy="no-referrer"></span></a></section><span style="font-size: 14px;letter-spacing: 0.034em;text-align: justify;"></span></section></section><section style="font-size: 15px;line-height: 1.6;"><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">作者：vivo 互联网中间件团队- Wang Xiaochuang</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: left;" powered-by="xiumi.us"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);"><p style="text-wrap: wrap;">本文主要介绍在 vivo 内部针对 Dubbo 路由模块及负载均衡的一些优化手段，主要是异步化+缓存，可减少在 RPC 调用过程中路由及负载均衡的 CPU 消耗，极大提升调用效率。</p></section></section><section style="margin-right: 0%;margin-bottom: -5px;margin-left: 0%;text-align: right;line-height: 1;font-size: 5px;transform: translate3d(5px, 0px, 0px);" powered-by="xiumi.us"><section style="width: 0px;display: inline-block;vertical-align: top;border-bottom: 0.6em solid rgb(160, 160, 160);border-right: 0.6em solid rgb(160, 160, 160);border-top: 0.6em solid transparent !important;border-left: 0.6em solid transparent !important;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>一、概要</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">vivo 内部 Java 技术栈业务使用的是 Apache Dubbo 框架，基于开源社区 2.7.x 版本定制化开发。在海量微服务集群的业务实践中，我们发现 Dubbo 有一些性能瓶颈的问题会极大影响业务逻辑的执行效率，尤其是在集群规模数量较大时 (提供方数量&gt;100)，路由及负载均衡方面有着较大的 CPU 消耗，从采集的火焰图分析高达 30%。为此我们针对 vivo 内部常用路由策略及负载均衡进行相关优化，并取得了较好的效果。接下来主要跟大家分析一下相关问题产生的根源，以及我们采用怎样的方式来解决这些问题。（当前 vivo 内部使用的 Dubbo 的主流版本是基于 2.7.x 进行相关定制化开发。）</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>二、背景知识</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.1 Dubbo 客户端调用流程</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1.&nbsp;相关术语介绍</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.35069075451647186" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bac7b7d2-f9db-4eb0-9f3d-5900e79ab3fe.png" data-type="png" data-w="941" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;主要流程</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">客户端通过本地代理 Proxy 调用 ClusterInvoker，ClusterInvoker 从服务目录 Directory 获取服务列表后经过路由链获取新的服务列表、负载均衡从路由后的服务列表中根据不同的负载均衡策略选取一个远端 Invoker 后再发起远程 RPC 调用。</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.562962962962963" data-s="300,640" src="https://oscimg.oschina.net/oscnet/c2e7d8db-665a-4a4f-b704-246b9544a375.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.2 Dubbo 路由机制</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Dubbo 的路由机制实际是基于简单的责任链模式实现，同时 Router 继承了 Comparable 接口，自定义的路由可以设置不同的优先级进而定制化责任链上 Router 的顺序。基于责任链模式可以支持多种路由策略串行执行如就近路由+标签路由，或条件路由+就近路由等，且路由的配置支持基于接口级的配置也支持基于应用级的配置。常见的路由方式主要有：就近路由，条件路由，标签路由等。具体的执行过程如下图所示：</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.0143112701252237" data-s="300,640" src="https://oscimg.oschina.net/oscnet/de6310ef-9be0-491d-8451-14b01a37e125.png" data-type="png" data-w="559" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 核心类</strong></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">Dubbo 路由的核心类主要有：<strong>RouterChain、RouterFactory 与 Router 。</strong></p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">（1）RouterChain</p><p style="text-wrap: wrap;">RouterChain 是路由链的入口，其核心字段有<br></p></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><strong>invokers（List&lt;invoker&gt; 类型）</strong></p><p>初始服务列表由服务目录 Directory 设置，当前 RouterChain 要过滤的 Invoker 集合<br></p></li><li><p><strong>builtinRouters（List 类型）</strong></p><p>当前 RouterChain 包含的自动激活的 Router 集合<br></p></li><li><p><strong>routers（List 类型）</strong></p><p>包括所有要使用的路由由 builtinRouters 加上通过 addRouters() 方法添加的 Router 对象</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">RouterChain 核心逻辑</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">class</span><span class="code-snippet__title">RouterChain</span>&lt;<span class="code-snippet__title">T</span>&gt; </span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 注册中心最后一次推送的服务列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers = Collections.emptyList();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 所有路由,包括原生 Dubbo 基于注册中心的路由规则如「route://」 urls .</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> volatile <span class="code-snippet__keyword">List</span>&lt;Router&gt; routers = Collections.emptyList();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 初始化自动激活的路由</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span><span class="code-snippet__keyword">List</span>&lt;Router&gt; builtinRouters = Collections.emptyList();</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> RouterChain(URL url) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//通过 ExtensionLoader 加载可自动激活的 RouterFactory</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;RouterFactory&gt; extensionFactories = ExtensionLoader.getExtensionLoader(RouterFactory.class)</span></code><code><span class="code-snippet_outer">                .getActivateExtension(url, ROUTER_KEY);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 由工厂类生成自动激活的路由策略</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Router&gt; routers = extensionFactories.stream()</span></code><code><span class="code-snippet_outer">                .map(factory -&gt; factory.getRouter(url))</span></code><code><span class="code-snippet_outer">                .collect(Collectors.toList());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        initWithRouters(routers);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 添加额外路由</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> void addRouters(<span class="code-snippet__keyword">List</span>&lt;Router&gt; routers) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Router&gt; newRouters = <span class="code-snippet__keyword">new</span> ArrayList&lt;&gt;();</span></code><code><span class="code-snippet_outer">        newRouters.addAll(builtinRouters);</span></code><code><span class="code-snippet_outer">        newRouters.addAll(routers);</span></code><code><span class="code-snippet_outer">        Collections.sort(newRouters, comparator);</span></code><code><span class="code-snippet_outer">        this.routers = newRouters;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; route(URL url, Invocation invocation) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; finalInvokers = invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 遍历全部的 Router 对象，执行路由规则</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (Router router : routers) {</span></code><code><span class="code-snippet_outer">            finalInvokers = router.route(finalInvokers, url, invocation);</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> finalInvokers;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）RouterFactory 为 Router 的工厂类</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">RouterFactory 接口定义</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@SPI</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">RouterFactory</span></span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Adaptive</span>(<span class="code-snippet__string">"protocol"</span>)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__function">Router <span class="code-snippet__title">getRouter</span><span class="code-snippet__params">(URL url)</span></span>;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（3）Router</p><p style="text-wrap: wrap;" powered-by="xiumi.us">Router 是真正的路由实现策略，由 RouterChain 进行调用，同时 Router 继承了 Compareable 接口，可以根据业务逻辑设置不同的优先级。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">Router 主要接口定义</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">Router</span><span class="code-snippet__keyword">extends</span><span class="code-snippet__title">Comparable</span>&lt;<span class="code-snippet__title">Router</span>&gt; </span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     *</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers   带过滤实例列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> url        消费方 url</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invocation 会话信息</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span> routed invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@throws</span> RpcException</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer">    &lt;T&gt; <span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; route(<span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 当注册中心的服务列表发现变化，或有动态配置变更会触发实例信息的变化</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 当时 2.7.x 的 Dubbo 并没有真正使用这个方法，可基于此方法进行路由缓存</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers invoker list</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;      invoker's type</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">default</span> &lt;T&gt; void notify(<span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;同机房优先路由的实现</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="letter-spacing: 0.034em;">为方便大家了解路由的实现，给大家展示一下就近路由的核心代码逻辑</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL consumerUrl, Invocation invocation) throws RpcException {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (!<span class="code-snippet__keyword">this</span>.enabled) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取本地机房信息</span></span></code><code><span class="code-snippet_outer">        String local = getSystemProperty(LOC);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers == <span class="code-snippet__literal">null</span> || invokers.size() == <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">        List&lt;Invoker&lt;T&gt;&gt; result = new ArrayList&lt;Invoker&lt;T&gt;&gt;();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (Invoker invoker: invokers) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取与本地机房一致的 invoker 并加入列表中</span></span></code><code><span class="code-snippet_outer">            String invokerLoc = getProperty(invoker, invocation, LOC);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (local.equals(invokerLoc)) {</span></code><code><span class="code-snippet_outer">                result.add(invoker);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (result.size() &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (fallback){</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 开启服务降级，available.ratio = 当前机房可用服务节点数量 ／ 集群可用服务节点数量</span></span></code><code><span class="code-snippet_outer">                int curAvailableRatio = (int) Math.floor(result.size() * <span class="code-snippet__number">100.0</span>d / invokers.size());</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (curAvailableRatio &lt;= availableRatio) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (force) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.3 Dubbo 负载均衡</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Dubbo 的负载均衡实现比较简单基本都是继承抽象类进行实现，主要作用就是根据具体的策略在路由之后的服务列表中筛选一个实例进行远程 RPC 调用，默认的负载均衡策略是随机。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">整体类图如下所示：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.2824074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/22c30ee5-d60d-45b1-a737-bbf064f7c1cc.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">LoadBalance 接口定义</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@SPI</span>(RandomLoadBalance.NAME)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">LoadBalance</span></span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 从服务列表中筛选一个.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     *</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers   invokers.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> url        refer url</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invocation invocation.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span> selected invoker.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Adaptive</span>(<span class="code-snippet__string">"loadbalance"</span>)</span></code><code><span class="code-snippet_outer">    &lt;T&gt; <span class="code-snippet__function">Invoker&lt;T&gt; <span class="code-snippet__title">select</span><span class="code-snippet__params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span><span class="code-snippet__keyword">throws</span> RpcException</span>;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">随机负载均衡核心代码解析</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 预热过程权重计算</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">static</span><span class="code-snippet__keyword">int</span><span class="code-snippet__title">calculateWarmupWeight</span>(<span class="code-snippet__params"><span class="code-snippet__keyword">int</span> uptime, <span class="code-snippet__keyword">int</span> warmup, <span class="code-snippet__keyword">int</span> weight</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> ww = (<span class="code-snippet__keyword">int</span>) (uptime / ((<span class="code-snippet__keyword">float</span>) warmup / weight));</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> ww &lt; <span class="code-snippet__number">1</span> ? <span class="code-snippet__number">1</span> : (Math.min(ww, weight));</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">int</span><span class="code-snippet__title">getWeight</span>(<span class="code-snippet__params">Invoker&lt;?&gt; invoker, Invocation invocation</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> weight;</span></code><code><span class="code-snippet_outer">       URL url = invoker.getUrl();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 多注册中心场景下的，注册中心权重获取</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">           weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">       } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer">           weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (weight &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取实例启动时间</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">long</span> timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, <span class="code-snippet__number">0L</span>);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (timestamp &gt; <span class="code-snippet__number">0L</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">long</span> uptime = System.currentTimeMillis() - timestamp;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (uptime &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span><span class="code-snippet__number">1</span>;</span></code><code><span class="code-snippet_outer">                   }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取预热时间</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (uptime &gt; <span class="code-snippet__number">0</span> &amp;&amp; uptime &lt; warmup) {</span></code><code><span class="code-snippet_outer">                       weight = calculateWarmupWeight((<span class="code-snippet__keyword">int</span>)uptime, warmup, weight);</span></code><code><span class="code-snippet_outer">                   }</span></code><code><span class="code-snippet_outer">               }</span></code><code><span class="code-snippet_outer">           }</span></code><code><span class="code-snippet_outer">       }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> Math.max(weight, <span class="code-snippet__number">0</span>);</span></code><code><span class="code-snippet_outer">   }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">@Override</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">protected</span> &lt;T&gt; <span class="code-snippet__function">Invoker&lt;T&gt; <span class="code-snippet__title">doSelect</span>(<span class="code-snippet__params">List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Number of invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> length = invokers.size();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Every invoker has the same weight?</span></span></code><code><span class="code-snippet_outer">        boolean sameWeight = <span class="code-snippet__literal">true</span>;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// the weight of every invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span>[] weights = <span class="code-snippet__keyword">new</span><span class="code-snippet__keyword">int</span>[length];</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// the first invoker's weight</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> firstWeight = getWeight(invokers.<span class="code-snippet__keyword">get</span>(<span class="code-snippet__number">0</span>), invocation);</span></code><code><span class="code-snippet_outer">        weights[<span class="code-snippet__number">0</span>] = firstWeight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// The sum of weights</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> totalWeight = firstWeight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = <span class="code-snippet__number">1</span>; i &lt; length; i++) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> weight = getWeight(invokers.<span class="code-snippet__keyword">get</span>(i), invocation);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// save for later use</span></span></code><code><span class="code-snippet_outer">            weights[i] = weight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Sum</span></span></code><code><span class="code-snippet_outer">            totalWeight += weight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) {</span></code><code><span class="code-snippet_outer">                sameWeight = <span class="code-snippet__literal">false</span>;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (totalWeight &gt; <span class="code-snippet__number">0</span> &amp;&amp; !sameWeight) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on totalWeight.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Return a invoker based on the random value.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = <span class="code-snippet__number">0</span>; i &lt; length; i++) {</span></code><code><span class="code-snippet_outer">                offset -= weights[i];</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (offset &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers.<span class="code-snippet__keyword">get</span>(i);</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers.<span class="code-snippet__keyword">get</span>(ThreadLocalRandom.current().nextInt(length));</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>预热解释</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">预热是为了让刚启动的实例流量缓慢增加,因为实例刚启动时各种资源可能还没建立连接，相关代码可能还是处于解释执行，仍未变为 JIT 执行，此时业务逻辑较慢，不应该加载过大的流量，否则有可能造成较多的超时。Dubbo 默认预热时间为 10 分钟，新部署的实例的流量会在预热时间段内层线性增长，最终与其他实例保持一致。Dubbo 预热机制的实现就是通过控制权重来实现。如默认权重 100，预热时间 10 分钟，则第一分钟权重为 10，第二分钟为 20，以此类推。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体预热效果图如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.45765765765765765" data-s="300,640" src="https://oscimg.oschina.net/oscnet/752bc3b5-e121-4de3-b41b-022860b2700e.png" data-type="png" data-w="555" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>三、问题分析</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">使用 Dubbo 的业务方反馈，他们通过火焰图分析发现 Dubbo 的负载均衡模块+路由模块占用 CPU 超过了 30%，框架层面的使用率严重影响了业务逻辑的执行效率急需进行优化。通过火焰图分析，具体占比如下图，其中该机器在业务忙时的 CPU 使用率在 60% 左右，闲时在 30% 左右。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.30970873786407765" data-s="300,640" src="https://oscimg.oschina.net/oscnet/81ae8f99-a18c-4416-8f9a-b6c012a14476.png" data-type="png" data-w="1030" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通过火焰图分析，负载均衡主要的消耗是在 getWeight 方法。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.1388888888888889" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b1d57058-f760-43c5-83bc-166c07ca9d81.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">路由的主要消耗是在 route 方法：</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">同机房优先路由</p><p style="text-wrap: wrap;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.11296296296296296" data-s="300,640" src="https://oscimg.oschina.net/oscnet/fee26d17-6eb3-4103-b12d-cc8975696932.png" data-type="png" data-w="1080" style="font-size: 15px;letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" referrerpolicy="no-referrer"></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">接口级标签路由+应用级标签路由</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.14907407407407408" data-s="300,640" src="https://oscimg.oschina.net/oscnet/11c33b76-0ae1-45fe-aeef-a05793340801.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">这些方法都有一个特点，那就是遍历执行。如负载均衡，针对每一个 invoker 都需要通过 getWeight 方法进行权重的计算；就近路由的 router 方法对于每一个 invoker 都需要通过 url 获取及机房信息进行匹配计算。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">我们分析一下 getWeight 及 router 时间复杂度，发现是 O(n) 的时间复杂度，而且路由是由路由链组成的，每次每个 Router 的 route 方法调用逻辑都会遍历实例列表，那么当实例列表数量过大时，每次匹配的计算的逻辑过大，那么就会造成大量的计算成本，导致占用大量 cpu，同时也导致路由负载均衡效率低下。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">综上所述，罪恶的的根源就是遍历导致的，当服务提供方数量越多，影响越大。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>四、优化方案</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">知道了问题所在，我们来分析一下是否有优化空间。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.1 路由优化</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 优化一：关闭无效路由</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通过火焰图分析，我们发现有部分业务即使完全不使用应用级的标签路由，原生的 TagRouter 也存在遍历逻辑，原因是为了支持静态的标签路由，其实这部分的开销也不少，那对于根本不会使用应用级标签路由的可以手动进行关闭。关闭方式如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">客户端统一关闭<br></p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js"><code><span class="code-snippet_outer">dubbo.consumer.router=-tag</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">服务级别关闭</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">注解方式：</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@DubboReference(parameters = {<span class="code-snippet__meta-string">"router"</span>,<span class="code-snippet__meta-string">"-tag"</span>})</span></span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">xml 方式：</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer">&lt;dubbo:reference id=<span class="code-snippet__string">"demoService"</span> check=<span class="code-snippet__string">"false"</span><span class="code-snippet__keyword">interface</span>=<span class="code-snippet__string">"com.dubbo.study.n.api.DemoService"</span> router=<span class="code-snippet__string">"-tag"</span> /&gt;</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2. 优化二：提前计算路由结果并进行缓存</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">每次路由目前都是进行实时计算，但是在大多数情况下，我们的实例列表是稳定不变的，只有在发布窗口或配置变更窗口内实例列表才会发生变更，那我们是否可以考虑缓存呢。如就近路由，可以以机房为 key 进行机房实例的全量缓存。针对接口级标签路由可以缓存不同标签值指定的实例信息。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">我们知道路由的执行过程是责任链模式，每一个 Router 的实例列表入参实际上是一个 Router 的结果，可参考公式：target = rn(…r3(r2(r1(src))))。那么所有的路由可以基于注册中心推送的原始服务列表进行路由计算并缓存，然后不同的路由结果相互取交集就能得到最终的结果，当实例信息发生变更时，缓存失效并重新计算。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>3. 缓存更新时机</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">当注册中心或者动态配置有变更时，相关通知会给到服务目录 Directory,Directory 收到通知后会重新创建服务列表，并把服务列表同步到路由链 RouterChain，RouterChain 再按顺序通知其链上的 Router,各个 Router 再进行缓存清除并重新进行路由结果的计算及进行缓存。相关时序图如下所示：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.42962962962962964" data-s="300,640" src="https://oscimg.oschina.net/oscnet/e8b71fb8-8926-40de-abe8-147ba10fa2ea.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>4. 具体路由流程</strong></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">进入具体路由方法时，先判断是否存在缓存的路由值，且缓存值的 epoch 必须与上一个路由的 epoch 需一致，此时缓存才生效，然后缓存值与上个 Router 的结果取交集。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">如果不存在缓存或 epoch 不一致则重新进行实时的路由计算。</p><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.7803921568627451" data-s="300,640" src="https://oscimg.oschina.net/oscnet/024bfb79-3f68-4ca5-bf7f-bfd337d6c3d0.jpg" data-type="jpeg" data-w="1020" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us">引入 epoch 的原因主要是保证各个路由策略缓存信息的一致性，保证所有的缓存计算都是基于同一份原始数据。当实例信息发生变更时，epoch 会自动进行更新。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>5. BitMap 引入</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">上文我们说到，不同的路由策略之间的结果是取交集的，然后最终的结果才送入负载均衡流程。那如何在缓存的同时，加快交集的计算呢。答案就是基于位图：BitMap。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">BitMap 的基本原理就是用一个 bit 位来存放某种状态，适用于大规模数据的查找及位运算操作。如在路由场景，先基于全量的推送数据进行计算缓存。如果某个实例被路由选中，则其值为 1，若两个路由的结果要取交集，那直接对 BitMap 进行"&amp;"运行即可。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">全量缓存示意图：</p><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.4935185185185185" data-s="300,640" src="https://oscimg.oschina.net/oscnet/5fc6e016-b880-40ce-9d59-390fe111bfa8.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us">路由交集计算示步骤：</p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">按照路由链依次计算，</p><p style="text-wrap: wrap;">tagRouter-&gt;vivoTag-&gt;vivoNearestRouter</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（1）tagRouter 计算逻辑：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>按照 Invocation 计算出目标的 Tag,假设是 tag1</p></li><li><p>然后从缓存 Cache 根据 key:tag1,取出对应的 targetAddrPool</p></li><li><p>将原始传入的 addrPool</p><p>与 targetAddrPool</p><p>得到结果 resultAddrPool</p></li><li><p>将 resultAddrPool 传入 vivoTagRouter</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）vivoTag 计算逻辑：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>按照 Invocation 计算出目标的 Tag,假设是 tabB</p></li><li><p>然后从缓存 Cache 根据 key:tag1，取出对应的 targetAddrPool</p></li><li><p>将上一次传入的 addrPool</p><p>与 targetAddrPool</p><p>得到结果 resultAddrPooll</p></li><li><p>将 resultAddrPool 传入</p><p>vivoNearestRouter</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">（3）vivoNearestRouter 计算逻辑</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>从环境变量取出当前机房，假设是 bj01</p></li><li><p>然后从缓存 Cache 根据 key:bj01，取出对应的 targetAddrPool</p></li><li><p>将上一次传入的 addrPool</p><p>与 targetAddrPool</p><p>取出 resultAddrPool</p></li><li><p>将上一次传入的 addrPool</p><p>与 targetAddrPool</p><p>得到结果 resultAddrPool</p></li><li><p>将 resultAddrPool 为最终路由结果，传递给 LoadBalance</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6907407407407408" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bfad5e5c-e485-4ab8-8b25-208b5ca92c3d.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>6. 基于缓存的同机房优先路由源码解析</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">缓存刷新</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * Notify router chain of the initial addresses from registry at the first time.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * Notify whenever addresses in registry change.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">public</span><span class="code-snippet__keyword">void</span><span class="code-snippet__title">setInvokers</span>(<span class="code-snippet__params">List&lt;Invoker&lt;T&gt;&gt; invokers</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 创建带 epoch 的 BitList</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">this</span>.invokers = <span class="code-snippet__keyword">new</span> BitList&lt;Invoker&lt;T&gt;&gt;(invokers == <span class="code-snippet__literal">null</span> ? Collections.emptyList() : invokers,createBitListEpoch());</span></code><code><span class="code-snippet_outer">        routers.forEach(router -&gt; router.notify(<span class="code-snippet__keyword">this</span>.invokers));</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">同机房优先路由源码解读</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL consumerUrl, Invocation invocation) throws RpcException {</span></code><code><span class="code-snippet_outer">        …………<span class="code-snippet__comment">//省略非核心代码</span></span></code><code><span class="code-snippet_outer">        BitList&lt;Invoker&lt;T&gt;&gt; bitList = (BitList&lt;Invoker&lt;T&gt;&gt;) invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//获取路由结果</span></span></code><code><span class="code-snippet_outer">        BitList&lt;Invoker&lt;T&gt;&gt; result = getNearestInvokersWithCache(bitList);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (result.size() &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (fallback) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 开启服务降级，available.ratio = 当前机房可用服务节点数量 ／ 集群可用服务节点数量</span></span></code><code><span class="code-snippet_outer">                int curAvailableRatio = (int) Math.floor(result.size() * <span class="code-snippet__number">100.0</span>d / invokers.size());</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (curAvailableRatio &lt;= availableRatio) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (force) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }   </span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 获取缓存列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span></span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> &lt;T&gt; BitList&lt;Invoker&lt;T&gt;&gt; getNearestInvokersWithCache(BitList&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer">        ValueWrapper valueWrapper = getCache(getSystemProperty(LOC));</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 是否存在缓存</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (valueWrapper != <span class="code-snippet__literal">null</span>) {</span></code><code><span class="code-snippet_outer">            BitList&lt;Invoker&lt;T&gt;&gt; invokerBitList = (BitList&lt;Invoker&lt;T&gt;&gt;) valueWrapper.<span class="code-snippet__keyword">get</span>();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 缓存的 epoch 与源列表是否一致</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers.isSameEpoch(invokerBitList)) {</span></code><code><span class="code-snippet_outer">                BitList&lt;Invoker&lt;T&gt;&gt; tmp = invokers.clone();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 结果取交集</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> tmp.and(invokerBitList);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 缓存不存在，实时计算放回</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> getNearestInvokers(invokers);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 新服务列表通知</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Override</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; void notify(List&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer">        clear();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers != <span class="code-snippet__literal">null</span> &amp;&amp; invokers instanceof BitList) {</span></code><code><span class="code-snippet_outer">            BitList&lt;Invoker&lt;T&gt;&gt; bitList = (BitList&lt;Invoker&lt;T&gt;&gt;) invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 设置最后一次更新的服务列表</span></span></code><code><span class="code-snippet_outer">            lastNotify = bitList.clone();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (!CollectionUtils.isEmpty(invokers) &amp;&amp; <span class="code-snippet__keyword">this</span>.enabled) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取机房相同的服务列表并进行缓存</span></span></code><code><span class="code-snippet_outer">                setCache(getSystemProperty(LOC), getNearestInvokers(lastNotify));</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.2 负载均衡优化</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1.&nbsp;优化一</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">针对 getWeight 方法，我们发现有部分业务逻辑较为消耗 cpu,但是在大多数场景下业务方并不会使用到，于是进行优化。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">getWeight 方法优化</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="javascript"><code><span class="code-snippet_outer">优化前：</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//这里主要要用多注册中心场景下，注册中心权重的获取，绝大多数情况下并不会有这个逻辑</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">           weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">       }  </span></code><code><span class="code-snippet_outer">优化后：</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invoker <span class="code-snippet__keyword">instanceof</span> ClusterInvoker &amp;&amp; UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">            weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">   }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;优化二</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">遍历是罪恶的源泉，而实例的数量决定这罪恶的深浅，我们有什么办法减少负载均衡过程中的遍历呢。一是根据 group 及 version 划分不同的集群，但是这需要涉及到业务方代码或配置层面的改动，会带来额外的成本。所以我们放弃了。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">二是没有什么是加一层解决不了的问题，为了尽量减少进入负载均衡的节点数量，考虑新增一个垫底的路由策略，在走完所有的路由策略后，若节点数量&gt;自定义数量后，进行虚拟分组，虚拟分组的策略也可进行自定义，然后随机筛选一组进入负载均衡。此时进入负载均衡的实例数量就会有倍数的下降。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">需要注意的是分组路由必须保证是在路由链的最后一环，否则会导致其他路由计算错误。</p></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.37984496124031" data-s="300,640" src="https://oscimg.oschina.net/oscnet/9ad0f113-9f91-4397-9e60-71b4b03e349f.png" data-type="png" data-w="645" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">分组路由示意</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * </span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers 待分组实例列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> groupNum 分组数量</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span></span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; doGroup(List&lt;Invoker&lt;T&gt;&gt; invokers, <span class="code-snippet__keyword">int</span> groupNum) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> listLength = invokers.size() / groupNum;</span></code><code><span class="code-snippet_outer">        List&lt;Invoker&lt;T&gt;&gt; result = <span class="code-snippet__keyword">new</span> ArrayList&lt;&gt;(listLength);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> random = ThreadLocalRandom.current().nextInt(groupNum);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = random; i &lt; invokers.size(); i = i + groupNum) {</span></code><code><span class="code-snippet_outer">            result.add(invokers.get(i));</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>五、优化效果</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">针对优化前和优化后，我们编写 Demo 工程分别压测了不配置路由/配置就近+标签路由场景。Provider 节点梯度设置 100/500/1000/2000/5000，TPS 在 1000 左右，记录了主机的 cpu 等性能指标，并打印火焰图。发现，配置路由后，采用相同并发，优化后的版本 tps 明显高于优化前版本，且新版本相较于没有配置路由时 tps 显著提高，下游节点数大于 2000 时，tps 提升达到 100% 以上，下游节点数越多，AvgCpu 优化效果越明显，并且路由及负载均衡 CPU 占比明显更低，详细数据可见下表：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.5994694960212201" data-s="300,640" src="https://oscimg.oschina.net/oscnet/1321713f-e488-4248-8ead-3e1db6f52543.png" data-type="png" data-w="754" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.7027777777777777" data-s="300,640" src="https://oscimg.oschina.net/oscnet/be116887-8e9c-4e6f-ba48-b83efffe2464.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">备注：-tag，表示显式禁用原生 Dubbo 应用级标签路由。该路由默认开启。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>六、总结</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">经过我们关闭不必要的路由逻辑、对路由缓存+异步化计算、新增分组路由等优化后，Dubbo 在负载均衡及路由模块整体的性能有了显著的提升，为业务方节省了不少 CPU 资源。在正常业务场景下当提供方数量达到 2000 及以上时，tps 提升可达 100% 以上，消费方平均 CPU 使用率下降约 27%，且提供方数量越多优化效果越明显。但是我们也发现当前的随机负载均衡依然还是会消耗一定的 CPU 资源，且只能保证流量是均衡的。当前我们的应用基本部署在虚拟机及容器上。这两者均存在超卖的状况，且同等配置的宿主机性能存在较大差异等问题。最终会导致部分请求超时、无法最大化利用提供方的资源。我们下一步将会引入 Dubbo 3.2 的自适应负载均衡并进行调优减少其 CPU 使用率波动较大的问题，其次我们自身也扩展了基于 CPU 负载均衡的单一因子算法，最终实现不同性能的机器 CPU 负载趋于均衡，最大程度发挥集群整体的性能。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="color: rgb(65, 95, 255);" powered-by="xiumi.us"><p style="text-wrap: wrap;">参考资料：</p></section><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;" powered-by="xiumi.us"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Fload-balance%2F" textvalue="Dubbo 负载均衡" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 负载均衡</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Ftraffic%2F" textvalue="Dubbo 流量管控" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 流量管控</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU4NzU0MDIzOQ%3D%3D%26mid%3D2247511003%26idx%3D3%26sn%3Defdf3f42790b74226b2ed45b701a6749%26scene%3D21%23wechat_redirect" textvalue="Dubbo 3 StateRouter：下一代微服务高效流量路由" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 3 StateRouter：下一代微服务高效流量路由</span></a></p></li></ol><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;"><section style="text-align: center;color: rgb(45, 66, 87);font-size: 11px;" powered-by="xiumi.us"><p>END</p></section></section><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: left;" powered-by="xiumi.us"><section style="padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;"><span style="display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);" title="" opera-tn-ra-cell="_$.pages:0.layers:0.comps:159.title1"><p>猜你喜欢</p></span></section><section style="border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;"><section style="font-size: 14px;text-align: left;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497343%26idx%3D1%26sn%3D959b66ceb9a8c2fe060b6981b41a807e%26chksm%3Debdb86eddcac0ffb229636ec51ec94433af75c7bc58aaa5ae52b4a2bf6a2d6d2ab11583b3174%26scene%3D21%23wechat_redirect" textvalue="记一次 Redis Cluster Pipeline 导致的死锁问题" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">记一次 Redis Cluster Pipeline 导致的死锁问题</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D1%26sn%3D5795a683e52f70384a13b34aa3daf731%26chksm%3Debdb8632dcac0f2468a461db09d8de6219af346e51436b91e6c946ee8b37e6ae8175b2f5d55e%26scene%3D21%23wechat_redirect" textvalue="深入理解 Netty FastThreadLocal" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">深入理解 Netty FastThreadLocal</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497336%26idx%3D1%26sn%3D777059b19e224f1a4fbb1550ad1de7e8%26chksm%3Debdb86eadcac0ffc78dc019c5685ad137fdddd6572238525d707152c102790f82917a473d52a%26scene%3D21%23wechat_redirect" textvalue="MySQL 到 TiDB：Hive Metastore 横向扩展之路" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">MySQL 到 TiDB：Hive Metastore 横向扩展之路</a></p></li></ul></section></section></section></section><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互联网技术" data-alias="vivoVMIC" data-signature="分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10136865</guid>
            <link>https://my.oschina.net/vivotech/blog/10136865</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌开放 .ing 顶级域名注册]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Google <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.google%2Fproducts%2Fregistry%2Fintroducing-the-ing-top-level-domain%2F" target="_blank">宣布开放 .ing 顶级域名注册</a></u>，即日起用户可通过<strong>支付额外费用（费率随时间推移降低）的方式抢先注册</strong>，抢先体验期 (EAP) 截至 12 月 5 日。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1101/104932_JmaT_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>Google 表示借助该域名企业可以注册一些非常有趣的域名，比如在线设计和绘图平台 Canva 注册的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdesign.ing%2F" target="_blank">design.ing</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdraw.ing%2F" target="_blank">draw.ing</a>、Adobe Acrobat 注册的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fedit.ing%2F" target="_blank">edit.ing</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsign.ing%2F" target="_blank">signing</a>&nbsp;等。</p><p>.ing 域名注册地址：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fget.ing%2F" target="_blank">https://get.ing/</a></u></p><p><img height="1676" src="https://static.oschina.net/uploads/space/2023/1101/105256_D6p3_2720166.png" width="3310" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264406/the-ing-top-level-domain</guid>
            <link>https://www.oschina.net/news/264406/the-ing-top-level-domain</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微软推送 Windows 11 23H2 更新]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#424242">微软正式推出了<span>&nbsp;</span></span>Windows 11<span style="background-color:#ffffff; color:#424242"><span>&nbsp;</span>的「大更新」版本 <strong>Windows 11 23H2</strong>，用户可以从官方网站下载正式的镜像文件，进行全新安装或者升级安装。</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-dc52a4c9559bca2e4c971af4eeee2a191ea.png" referrerpolicy="no-referrer"></p><p>考虑到微软计划在 2024 年发布下一代 Windows（可能是 Windows 12），因此&nbsp;23H2 会成为 Windows 11 的最后一个重大更新。</p><blockquote><p><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.microsoft.com%2Fsoftware-download%2Fwindows11" target="_blank">https://www.microsoft.com/software-download/windows11</a></em><br><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.windows.com%2Fwindowsexperience%2F2023%2F10%2F31%2Fhow-to-get-the-windows-11-2023-update%2F" target="_blank">https://blogs.windows.com/windowsexperience/2023/10/31/how-to-get-the-windows-11-2023-update/</a></em></p></blockquote><p><span style="background-color:#ffffff; color:#424242">此次更新添加了名为 Copilot 的 AI 聊天机器人，以及</span>包含微软此前在 Moment 4 更新中推出的全部新功能，同时还会将内置的聊天应用替换为 Microsoft Teams 免费版。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-89e55171373efda1e01f2a70c140f4a9605.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f4c57381f3a06868203247bdcb41976fe47.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-13ed870d860b818aa514eaf8133f61ae383.png" referrerpolicy="no-referrer"></p><p>和之前的版本 21H2 和 22H2 一样，Windows 11 23H2 将获得两年的支持，每月提供累积更新、修复和新功能。需要提醒的是，Windows 11 21H2 生命周期已经在本月早些时候结束。至于 22H2，微软将在一年后，即 2024 年 10 月 4 日停止支持。</p><hr><p>以下是 Windows 11 23H2 的其他更新：</p><ul><li><strong>虚拟视频编辑器</strong>：内置在 Clipchamp 视频编辑应用中的自动合成功能，利用人工智能技术，使最终视频的合成过程更容易。</li><li><strong>多语言屏幕阅读</strong>：去年，微软在 Windows 的讲述人辅助功能中引入了使用人工智能读取屏幕上文本的自然声音，此次增加了对其他语言的支持。</li><li><strong>降低能耗</strong>：新的节能功能「自适应调光」可以在你不看屏幕时使屏幕变暗，在你再次看屏幕时重新变亮。</li><li><strong>更智能的截图功能</strong>：使用 Windows 11 附带的截图应用，你可以从截图中复制文本，并快速编辑电子邮件或电话号码。</li><li><strong>备份</strong>：现在用户可以备份之前安装在 PC 上的应用程序，以便将来恢复它们。</li><li><strong>用文字作画</strong>：用户可以输入几个单词并选择一个样式，然后画图应用会根据你的描述创建图像。</li><li><strong>更多任务栏自定义</strong>：没有运行的应用也可以显示标签，还可以隐藏时间和日期。</li><li><strong>记事本记忆功能</strong>：记事本会自动保存用户的状态。</li><li><strong>照片</strong>：用户可以在搜索框中输入关键词和对象，找到存储在 Overdrive 中的相关图片。</li><li><strong>即时游戏</strong>：用户可以在微软应用商店中找到休闲游戏，无需先下载并安装它们。</li></ul><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-fb28a2a6e8c4ede4b30e08510ca491aa24d.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b555601fed7548bcd1131d2568dd4606f25.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8be9bc80d3279e9bd4dbce568f25c323595.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-dcffdb984fc2f1427c2f174ad16a740329f.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264399/windows-11-2023-update</guid>
            <link>https://www.oschina.net/news/264399/windows-11-2023-update</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[深圳一公司奖励程序员「黄金键帽」，价值近 2 万元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 10 月 24 日，被众多科技公司和业内人士称为「程序员节」。当天，深圳一公司奖励员工「<strong>黄金键帽</strong>」。</p><blockquote><p><img height="1658" src="https://static.oschina.net/uploads/space/2023/1031/185140_pBn0_2720166.png" width="1176" referrerpolicy="no-referrer"></p></blockquote><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F5558240479%2FNpm9Lffdj%3Fpagetype%3Dprofilefeed" target="_blank">据称</a></u>这款空格键键帽是 40g 黄金，价值近 2 万元。</p><p><img src="https://static.oschina.net/uploads/space/2023/1031/185850_Wq96_2720166.png" referrerpolicy="no-referrer"></p><p><em>△「黄金 C 键」是该公司去年的奖励</em></p><p>获得奖励程序员根据代码行数排名和部门推举共同选出，最具分量的「黄金空格键」奖励给有效代码量最多的程序员。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 10:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264307</guid>
            <link>https://www.oschina.net/news/264307</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[前三季度互联网企业利润总额同比增 18.2%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年前三季度互联网和相关服务业运行情况现已公布。前三季度，互联网业务收入增速小幅提升，利润总额较快增长，研发经费持续下滑。</p><h4 style="margin-left:0px; margin-right:0px"><strong>一，总体运行情况</strong></h4><p><strong>互联网业务收入增速小幅提升。</strong>前三季度，我国规模以上互联网和相关服务企业 1（以下简称互联网企业）完成互联网业务收入 10294 亿元，同比增长 3.4%。</p><p><img height="241" src="https://oscimg.oschina.net/oscnet/up-505b65f84338dd716295e76b74112009b70.png" width="500" referrerpolicy="no-referrer"></p><p><strong>利润总额较快增长。</strong>前三季度，我国规模以上互联网企业营业成本同比增长 7%，增速较上半年回落 0.4 个百分点。实现利润总额 959.3 亿元，同比增长 18.2%。</p><p><img height="239" src="https://oscimg.oschina.net/oscnet/up-54642fdf1ae20d26f1bc9494e46da1f4440.png" width="500" referrerpolicy="no-referrer"></p><p><strong>研发经费持续下滑。</strong>前三季度，我国规模以上互联网企业共投入研发经费 495.9 亿元，同比下降 6.1%。</p><p><img height="246" src="https://oscimg.oschina.net/oscnet/up-d14b35b6a1179d07e10ffc542ff0150925e.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px"><strong>二，分领域运行情况</strong></h4><p style="margin-left:0; margin-right:0"><strong>（一）信息服务领域企业收入小幅回落。</strong>前三季度，以信息服务为主的企业（包括新闻资讯、搜索、社交、游戏、音乐视频等）互联网业务收入同比下降 2.7%。</p><p><strong>（二）生活服务领域企业收入较快增长。</strong>前三季度，以提供生活服务为主的平台企业（包括本地生活、租车约车、旅游出行、金融服务、汽车、房屋住宅等）互联网业务收入同比增长 9.8%。</p><p><strong>（三）网络销售领域企业收入增速持续提升。</strong>前三季度，主要提供网络销售服务的企业（包括大宗商品、农副产品、综合电商、医疗用品、快递等）互联网业务收入同比增长 47.3%。</p><h4 style="margin-left:0px; margin-right:0px"><strong>三，分地区运行情况</strong></h4><p><strong>东部地区互联网业务收入保持平稳增速。</strong>前三季度，东部地区完成互联网业务收入 9613 亿元，同比增长 4.5%，增速较上半年提升 0.7 个百分点，占全国互联网业务收入的比重为 93.4%。中部地区完成互联网业务收入 329.5 亿元，同比下降 9.7%，降幅较上半年扩大 2.2 个百分点。西部地区完成互联网业务收入 325 亿元，同比下降 7.5%，降幅较上半年收窄 3.2 个百分点。东北地区完成互联网业务收入 26.5 亿元，同比下降 33.3%，降幅较上半年收窄 6.4 个百分点。</p><p><img height="239" src="https://oscimg.oschina.net/oscnet/up-7b7896fe852aa2c94820a864e846f80cae2.png" width="500" referrerpolicy="no-referrer"></p><p><strong>长三角地区互联网业务收入实现较快增长。</strong>前三季度，京津冀地区完成互联网业务收入 3948 亿元，同比增长 2.9%，增速较上半年回落 0.3 个百分点，占全国互联网业务收入的比重为 38.4%。长三角地区完成互联网业务收入 4225 亿元，同比增长 13.1%，增速较上半年提升 3.5 个百分点。</p><p><img height="300" src="https://oscimg.oschina.net/oscnet/up-f6cddc5c38e933857b00b43bd049054bd02.png" width="500" referrerpolicy="no-referrer"></p><p><strong>半数地区互联网业务增速实现正增长。</strong>前三季度，互联网业务累计收入居前 5 名的北京（增长 0.7%）、上海（增长 17.7%）、浙江（增长 5.1%）、广东（下降 7.4%）和天津（增长 22.3%）共完成业务收入 9077 亿元，同比增长 5.5%，占全国比重达 88.2%。全国互联网业务增速实现正增长的省（区、市）有 15 个。</p><p><img height="243" src="https://oscimg.oschina.net/oscnet/up-d691bf5c06989113a27d8f6cf4a88d4ab6e.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px"><strong>四，我国移动应用程序（APP）发展情况</strong></h4><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">根据全国 APP 技术检测平台统计，截至 9 月底，我国国内市场上监测到活跃的 APP 数量 2 为 261 万款（包括安卓和苹果商店）。移动应用开发者数量为 84 万，其中安卓开发者为 26 万，苹果开发者为 58 万。9 月份，安卓应用商店在架应用累计下载量 542 亿次。</p><p><span style="color:#888888">附注：</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#888888">1.规模以上互联网和相关服务企业口径由上年互联网和相关服务收入 500 万元以上调整为 2000 万元及以上，文中所有同比增速均按可比口径计算。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#888888">2.活跃的移动应用程序数量是指报告期内我国市场上经过用户主动下载安装的第三方移动应用的总个数，其中安卓应用数的计算方法是根据智能手机记录的已安装移动应用去重后获得。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 10:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264303</guid>
            <link>https://www.oschina.net/news/264303</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
