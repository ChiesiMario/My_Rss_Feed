<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-最新资讯]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-最新资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 01 Nov 2023 06:29:38 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Incus 0.2 发布，系统容器和虚拟机管理器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 是一个现代、安全且强大的系统容器和虚拟机管理器，它为在容器或虚拟机内运行和管理完整的 Linux 系统提供了统一的体验。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 以&nbsp;C</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>umulonimbus incus 或 anvil cloud&nbsp;<span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>命名，是 Canonical LXD 的社区分支。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>该分叉是为了回应&nbsp;<a href="https://www.oschina.net/news/248011/lxd-under-canonical">Canonical&nbsp;从 Linux<span>&nbsp;</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><a href="https://www.oschina.net/news/248011/lxd-under-canonical">Containers community&nbsp;</a><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><a href="https://www.oschina.net/news/248011/lxd-under-canonical">接管 LXD 项目</a>的举措。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 0.2 现已发布，</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#222222">此版本整合了 LXD 5.19 中的大部分更改，并引入了一些额外的功能和改进。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span style="background-color:#ffffff; color:#222222"><img alt="" height="333" src="https://static.oschina.net/uploads/space/2023/1101/142856_LLE7_4252687.png" width="500" referrerpolicy="no-referrer"></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span style="background-color:#ffffff; color:#222222">一些亮点更新内容如下：</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><strong><span style="background-color:#ffffff; color:#222222">虚拟机中的 NVME 存储支持</span></strong></p><p><span style="background-color:#ffffff; color:#222222">虚拟机的磁盘类型设备新增了</span><code>io.bus</code><span style="background-color:#ffffff; color:#222222">configuration key。</span></p><p><span style="background-color:#ffffff; color:#222222">默认设置为</span><code>virtio-scsi</code><span style="background-color:#ffffff; color:#222222"><span>&nbsp;</span>，但现在也可以设置为</span><code>nvme</code><span style="background-color:#ffffff; color:#222222">，以便在虚拟机中将磁盘显示为 NVME SSD。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>从 LXD 迁移的集群支持</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>迁移工具<code>lxd-to-incus</code>现在支持集群环境。此外，它还进行了更新以支持 LXD 5.19 作为源版本。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>这意味着任何使用 LXD 4.0 及更高版本（直到 5.19）的人现在都可以通过安装 Incus 并运行<code>lxd-to-incus</code>轻松迁移到 Incus。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>非特权容器的新镜像要求</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>当添加对 NixOS 作为容器镜像的支持时，发现该特定镜像当前无法在特权容器内运行。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>因此添加一个新的镜像要求。可以将<code>requirements.privileged</code>设置为<code>false</code>，以防止该镜像与特权容器一起使用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><pre><code>stgraber@dakara:~$ incus launch images:nixos nixos-priv -c security.privileged=true
Creating nixos-priv
Starting nixos-priv
Error: The image used by this instance is incompatible with privileged containers. Please unset security.privileged on the instance
Try `incus info --show-log local:nixos-priv` for more info
stgraber@dakara:~$</code></pre><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>服务器端自定义卷复制</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 现在支持自定义卷的服务器端副本。这消除了客户端充当中继的需要，从而显着加快了自定义卷的复制速度。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>命令行工具会自动检测对此的支持并在可用时使用它。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>该功能首次在 LXD 中引入。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>静态二进制文件现在可用于 64 位 Arm</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>作为发布和测试的一部分提供的所有静态二进制文件，现在都适用于 Intel 64 位和 Arm 64 位。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdiscuss.linuxcontainers.org%2Ft%2Fincus-0-2-has-been-released%2F18185" target="_blank">查看官方公告</a>。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 06:14:32 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264451/incus-0-2-released</guid>
            <link>https://www.oschina.net/news/264451/incus-0-2-released</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 发布自研操作系统蓝河 (BlueOS)，系统框架采用 Rust 编写]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 vivo 开发者大会今天正式开始。大会上，vivo 发布了自研操作系统<strong>蓝河 (BlueOS)</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-15a70d97c2f8f3654e7d6f94c8c92df5505.png" referrerpolicy="no-referrer"></p><p>vivo 称「蓝河操作系统」是面向通用人工智能时代的自研智慧操作系统 —— 底层接入了 AI 大模型，支持基于自然交互方式的应用开发。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135537_Q43j_2720166.png" referrerpolicy="no-referrer"></p><p>vivo 还表示，蓝河操作系统<strong>采用 Rust 编写「系统框架」</strong>——从源头避免了内存使用不当引起的安全漏洞。据称是行业首家<strong>。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f21c3eb7d2568b66e3cebdf8f628b9bb78b.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135659_sEFQ_2720166.png" referrerpolicy="no-referrer"></p><p>运行要求方面，在低至 200Mhz 主频 32MB 内存，高至 4GHz 主频 24GB 内存的各种设备上，蓝河都能流畅运行。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/142454_nhO4_2720166.png" referrerpolicy="no-referrer"></p><p>据了解，蓝河操作系统目前不会在 vivo 手机上提供，首款搭载蓝河操作系统的 vivo 设备是 vivo Watch3 智能手表。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b5c944705e833222c61dc1c96c7713648ca.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 06:02:32 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264444</guid>
            <link>https://www.oschina.net/news/264444</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[macOS Sonoma 黑屏 bug，影响 Asahi Linux]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Asahi Linux 发布了一篇文档，说明了近期 macOS 黑屏情况。</p><blockquote><p><span style="color:#333333">Asahi Linux 项目致力于将 Linux 操作系统移植到苹果的 Apple Silicon Macs 系列电脑设备上。</span></p><ul><li><a href="https://www.oschina.net/news/125751/asahi-linux-set-up" target="_blank">可移植苹果 M1 的 Asahi Linux 项目正式启</a></li></ul></blockquote><p>Asahi 解释，macOS Sonoma 和 macOS Ventura 13.6 在其升级和启动过程中发布了多个严重的错误。这些错误结合在一起，可以创建出一种情况，即无论使用何种电源按钮按压组合，机器总是启动到黑屏。这使用户陷入困境，唯一的解决方案就是使用 DFU 恢复。</p><p>在某些设置和特定型号下，这种情况可能会发生，即多个 macOS 版本并行安装（一个 Sonoma，一个更早的版本）。由于 Asahi Linux 的行为就像是 macOS 12.3/12.4/13.5（取决于型号和安装时间），所以 macOS Sonoma 和 Asahi Linux 的双启动安装会产生相同的问题。对于 macOS 13.6，这种情况甚至不需要双启动系统，只要作为唯一安装的操作系统就可以触发。</p><p>目前 Asahi Linux 安装程序已经更新，现在它可以在启动时自动进行完整性检查并诊断系统。要运行它，请将此命令粘贴到 macOS 的终端中：</p><p style="text-align:start"><code>curl https://alx.sh | sh</code></p><p style="text-align:start">进入主菜单，用户可以退出安装程序，而不对系统做任何更改。</p><p style="text-align:start">Asahi Linux 具体说明了 macOS 启动失败的原因：</p><ul><li><p>macOS Sonoma 的升级使用先前安装的版本作为系统恢复。这在某种程度上是有道理的，但并未考虑到旧版 RecoveryOS 与新固件之间的向后兼容性问题。如果这种不匹配导致 recoveryOS 无法启动，那么系统恢复将无法使用。</p></li><li><p>对于 14 英寸和 16 英寸的型号：一旦系统固件更新到 macOS Sonoma 版本，如果显示器的刷新率设置为非 ProMotion，则该系统将无法正确地启动旧版本的 macOS 安装程序和 Asahi Linux。这包括当这些系统被设置为默认启动操作系统时的恢复模式，以及至少在下一次操作系统升级之前的系统恢复。</p></li></ul><p>影响设备、系统：</p><ul><li><p>配备 ProMotion 显示屏的 MacBook Pro 型号（14 英寸和 16 英寸）受到黑屏启动错误的影响。</p></li><li><p>macOS Sonoma 14.0+（截至 2023 年 10 月 31 日尚未修复）</p></li><li><p>macOS Ventura 13.6+ (使用 14.0 固件)</p></li><li><p>可能受影响：macOS Monterey 12.7（未经确认）</p></li></ul><p><strong>如果还没升级到 Sonoma，Asahi Linux&nbsp;<span style="background-color:#ffffff; color:#1f2328">建议等到苹果解决这些问题后再进行升级。</span></strong></p><p>更多细节查看 Asahi 发布的说明：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAsahiLinux%2Fdocs%2Fwiki%2FmacOS-Sonoma-Boot-Failures" target="_blank">https://github.com/AsahiLinux/docs/wiki/macOS-Sonoma-Boot-Failures</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 04:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264432/macos-sonoma-boot-failures</guid>
            <link>https://www.oschina.net/news/264432/macos-sonoma-boot-failures</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微信 iOS 版「史诗级」更新：「发送」按钮独立]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>微信 iOS 版昨天发布了 8.0.43 更新，更新日志一如既往地是「修复了一些已知问题」。</p><blockquote><p><img height="780" src="https://static.oschina.net/uploads/space/2023/1101/121221_VGwW_2720166.png" width="1810" referrerpolicy="no-referrer"></p></blockquote><p>不过热心网友发现的一项重要变化冲上了微博热搜：<span style="color:#e67e22"><strong>#微信新增独立发送按钮#</strong></span>。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-12f6e066aebe74a1bd7440aa69ef266c4b9.png" referrerpolicy="no-referrer"></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-877e90cea0d617b8694aa9a040acdc2080e.png" referrerpolicy="no-referrer"></p><p>没错，微信 for iOS 8.0.43 新增了「使用独立的发送按钮」开关。开启后，iOS 自带输入法的「发送」按键变成「换行」按键，而输入框右侧增加了独立的「发送」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-410e4a667b0d00dcd7c363e6c756adad620.png" referrerpolicy="no-referrer"></p><p>对使用 iOS 自带输入法用户来说，这属实是「史诗级」更新。</p><p>毕竟此前在输入文字的时候如果想换行，需要在输入框轻点或者长按呼出换行开关。现在「换行」和「发送」终于都有了独立按键，感谢 Allen Zhang : )</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 04:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264431</guid>
            <link>https://www.oschina.net/news/264431</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gateway API v1.0：GA 版本出炉]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Gateway API v1.0 版本现已发布。公告指出，此版本是该项目的一个重要里程碑。几个关键的 API 已经升级为 GA（generally available，一般可用），同时其他重要功能已添加到实验（Experimental）通道。</span></p><h4><span style="color:#000000"><strong>新增内容</strong></span></h4><p><span style="color:#000000"><strong>升级到 v1</strong></span></p><p><span style="color:#000000">此版本将 Gateway、GatewayClass 和 HTTPRoute 升级为 v1，意味着它们现在是一般可用的。这个 API 版本表示对 API 表面具有高度的信心，并提供向后兼容的保证。需要注意的是，虽然标准（Standard）通道中包含的这些 API 版本现在被认为是稳定的，但这并不意味着它们是完整的。这些 API 将继续通过实验通道接收新的功能，以满足升级的标准。</span></p><p><span style="color:#000000"><strong>Logo</strong></span></p><p><span style="color:#000000">Gateway API 现在有了自己的 Logo！这个 Logo 是通过协作过程设计的，旨在代表这是一组用于在 Kubernetes 中进行南北向和东西向流量路由的 API：</span></p><p><img height="135" src="https://oscimg.oschina.net/oscnet/up-b9aa4cb25f206b6a9cd7b73608e412f035b.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><strong>CEL 验证</strong></span></p><p><span style="color:#000000">过去，Gateway API 作为安装 API 的一部分绑定了验证 webhook。从 v1.0 开始，webhook 的安装是可选的，仅建议在 Kubernetes 1.24 上使用。Gateway API 现在将 CEL ]验证规则作为 CRDs 的一部分进行了包含。这种新形式的验证在 Kubernetes 1.25+中得到支持，因此在大多数安装中不再需要验证 webhook。</span></p><p><span style="color:#000000"><strong>标准通道</strong></span></p><p><span style="color:#000000">此版本的主要重点是确保现有的 beta API 定义明确，并足够稳定，可以升级为 GA。这导致了各种规范的澄清，以及一些改进，以提高与 Gateway API 交互时的整体用户体验。</span></p><p><span style="color:#000000"><strong>实验通道</strong></span></p><p><span style="color:#000000">此版本中包含的大部分更改都限于实验通道，包括 HTTPRoute 超时、从 Gateway 到后端的 TLS 配置、WebSocket 支持、Gateway 基础设施标签等。</span></p><hr><p><span style="color:#000000">接下来，项目团队将继续致力于努力稳定和升级 API 的其他实验性功能。包括支持服务网格]、额外的路由类型（GRPCRoute、TCPRoute、TLSRoute[17]、UDPRoute）以及各种实验性功能。</span></p><p><span style="color:#000000">以及将 ReferenceGrant 移入内置的 Kubernetes API 中，使其可以用于不仅仅是 Gateway API。「在 Gateway API 中，我们使用这个资源来安全地启用跨命名空间引用，而这个概念现在被其他 SIGs 采纳。这个 API 的新版本将归 SIG Auth 所有，并且在迁移到内置的 Kubernetes API 时可能包含至少一些修改。」</span></p><p><span style="color:#000000">更多详情可查看：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubernetes-sigs%2Fgateway-api%2Freleases%2Ftag%2Fv1.0.0" target="_blank">https://github.com/kubernetes-sigs/gateway-api/releases/tag/v1.0.0</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 03:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264423/gateway-api-1-0-released</guid>
            <link>https://www.oschina.net/news/264423/gateway-api-1-0-released</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[运营商在光猫内置反诈插件？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>网友发帖称，自己的同事参加某运营商<strong>加 1 元提速 2000m 送 fttr 1+2 活动</strong>后，由于活动要求 45 天内保持在线并且要使用路由模式，这名同事就按照要求使用路由模式。</p><blockquote><p>FTTR (Fiber to The Remote)，是指光纤敷设到远端节点，为光纤接入的基本技术方式。</p></blockquote><p>然后他发现自建的科学上网功能出现不能连接的情况，并且访问&nbsp; xenyth.net 网站时直接跳转到了反诈页面，几分钟之后接到反诈热线打来的电话，询问他有没有访问一个叫做 xenyth.net 的诈骗网站。工作人员告诉他这是一个网购诈骗网站，付款后不会发货，要求不再访问，如有需要可以安排民警上门。</p><p><span style="background-color:#ffffff; color:#000000">后面这名同事搞到超级密码后进入光猫，发现：</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9b10cd4d0019c4015f48be3f0d542493520.png" referrerpolicy="no-referrer"></p><p>最后附上卸载插件方法：</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/113529_5FaL_2720166.png" referrerpolicy="no-referrer"></p><p><em>via&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.v2ex.com%2Ft%2F986550" target="_blank">https://www.v2ex.com/t/986550</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 03:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264421</guid>
            <link>https://www.oschina.net/news/264421</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[四维纵横完成超亿元 B 轮融资]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">新一代超融合数据库厂商四维纵横<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fq_l-0lQ_GJxLTEXTjF30ag" target="_blank">宣布</a>完成了上亿元人民币的 B 轮融资，本轮融资由用友、顺义产业基金领投，广州同创基金跟投。该公司表示，</span><span style="background-color:#ffffff">此次募集资金将会主要用于研发核心技术，建设商业生态链等方面。</span></span></p><p><span style="color:#000000"><img height="251" src="https://oscimg.oschina.net/oscnet/up-ecefb2dbc5ddf668afa56fccacfa3960e27.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">四维纵横是一家成立于 2020 年的数据库公司，以超融合数据库 YMatrix 为企业提供集「分析、事务、时序」为一体的企业级数据库产品服务。目前，四维纵横，以 YMatrix 为核心，自研了全栈向量化执行器、分布式数据库灾备、MARS3 存储引擎、MatrixShift 迁移工具、MatrixGate 高性能写入组件、MatrixUI 图形化界面等一系列商业化套件。</span></p><p><span style="color:#000000"><img height="345" src="https://oscimg.oschina.net/oscnet/up-c609ba963a02c51a5f6c10587fc68105704.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">当前，YMatrix 已经被应用到证券、通信、银行、保险、智能制造、车联网等多个行业领域中，服务的客户包括浪潮、中兴、理想汽车、宁德时代、三一重工等多个头部企业。</span></span></p><p><span style="color:#000000">公告指出，在本轮融资之后，四维纵横将会以目前 YMatrix 产品技术能力为根基，以超融合理念为发展方向，继续拓展新的应用领域，将 YMatrix 超融合数据库产品应用于更多的场景中。另外，四维纵横将进一步加快并夯实技术团队的人员建设和技术基础，为全球用户提供更加全面的超融合解决方案。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264414</guid>
            <link>https://www.oschina.net/news/264414</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度上线「文心一言」会员，开通可解锁文心大模型 4.0]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>百度大模型文心一言现已上线会员模式，开通后可解锁文心大模型 4.0。</p><p><strong>目前文心一言基础版功能依旧免费开放使用</strong>，可以满足用户的日常需求，如交互对话、问答等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-523eef7bc90f0772422e76d8d238e5a06f5.png" referrerpolicy="no-referrer"></p><p>据介绍，文心一言会员单月购买价格为 59.9 元，<strong>连续包月价格为 49.9 元</strong>（次月以 49.9 元 / 月自动续费，可随时取消）。此外，百度还推出了文心一言 + 文心一格（白银）的联合会员，价格为 99 元 / 月。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2e89f249c9e05e483bc3e37a5c145a0001d.png" referrerpolicy="no-referrer"></p><p><strong>文心一言会员权益：</strong></p><ul><li><p>模型能力：文心大模型 4.0</p></li><li><p>图片生成：文生图能力全面升级</p></li><li><p>插件权益 （网页端）：高阶插件</p></li><li><p>灵感值 （App 端）：单月赠送 600 灵感值</p></li></ul><p><strong>文心一格会员权益：</strong></p><ul><li><p>极速生成多尺寸高清图像</p></li><li><p>创作海报和艺术字</p></li><li><p>白银会员权益：AI 编辑改图修图</p></li></ul><hr><p><u><a href="https://www.oschina.net/news/262086">文心大模型 4.0 于上个月正式亮相</a></u>，李彦宏表示，<strong>这是迄今为止最强大的文心大模型</strong>，实现了基础模型的全面升级，在理解、生成、逻辑和记忆能力上都有着明显提升，综合水平「与 GPT-4 相比毫不逊色」。</p><p><img alt="up-cb21975862a8f7b014aeea47cbab52da1df.png" src="https://oscimg.oschina.net/oscnet/up-cb21975862a8f7b014aeea47cbab52da1df.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264412</guid>
            <link>https://www.oschina.net/news/264412</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenSign —— 开源 PDF 电子签名解决方案]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenSign 是一个开源文档电子签名解决方案，旨在为 DocuSign、PandaDoc、SignNow、Adobe Sign、Smartwaiver、SignRequest、HelloSign 和 Zoho Sign 等商业平台提供安全、可靠且免费的替代方案。</p><p>特性：</p><ul><li><strong>安全签名</strong>：利用最先进的加密算法来确保文档的安全性和完整性。</li><li><strong>用户友好的界面</strong>：设计时考虑到可用性，使技术和非技术用户都能轻松使用。</li><li><strong>多平台支持</strong>：兼容各种浏览器和设备。</li><li><strong>邀请和协作用户</strong>：将团队中的多人带入签名流程，所有这些都在你自己的基础设施内进行。</li><li><strong>安全</strong>：允许使用「OpenSigDrive」轻松、安全和无缝地组织文档。</li><li><strong>审计跟踪</strong>：保留与文档签名过程相关的所有活动的详细日志，包括 IP 地址和访问时间。</li><li><strong>完成证书</strong>：所有参与者签署文件后立即生成安全完成证书。</li><li><strong>API 支持</strong>：提供强大的 API，用于集成到其他软件和服务中。</li></ul><p><img alt="" height="293" src="https://static.oschina.net/uploads/space/2023/1031/154224_RLJo_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="298" src="https://static.oschina.net/uploads/space/2023/1031/154242_mhWv_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="307" src="https://static.oschina.net/uploads/space/2023/1031/154356_RuMR_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 03:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/opensign</guid>
            <link>https://www.oschina.net/p/opensign</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 一站式分布式任务调度系统 Hodor]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-hodorscheduler" class="anchor" href="https://gitee.com/dromara/hodor#hodorscheduler"></a>HodorScheduler</h1><h2><a id="user-content-介绍" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BB%8B%E7%BB%8D"></a>介绍</h2><p>Hodor 是一个专注于<strong>任务调度</strong>以及<strong>任务编排</strong>的<strong>一站式</strong>分布式任务调度系统。</p><p>通过提供任务编程 API 和接口协议， 方便支持用户使用不同的编程语言实现任务执行以及自定义任务类型的扩展，以满足各种业务场景下的任务执行。</p><p>支持多种接入方式，支持 Java SDK 包方式、Java Agent 独立进程方式接入，以及兼容 XXLJob 框架、Spring Task 框架任务无缝接入。</p><p>多语言执行器实现，计划支持 Go 或者 Rust 语言执行器（正在设计与开发中）的接入，满足在资源有限的执行器节点执行，比如物联网场景下面的定时任务执行。</p><p>支持丰富的任务类型，除了支持普通的 Java、脚本任务的执行，也支持了大数据任务 Hadoop、Spark、Flink、Kettle 等主流任务的执行，满足用户的不同场景。</p><h2><a id="user-content-主要特性" class="anchor" href="https://gitee.com/dromara/hodor#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"></a>主要特性</h2><ol><li>支持 Cron、FixedRate、FixedDelay、OnceTime 方式配置定时任务，可以方便地实现各种定时任务需求。</li><li>支持 DAG 方式进行任务编排，使得任务之间的关系更加清晰，同时提高了系统的可扩展性和灵活性。</li><li>支持 Java 任务和大数据任务调度，兼容 XXLJob、SpringTask 调度任务，满足不同场景下的任务调度需求。</li><li>支持可扩展执行器，用户可以根据自己的需求自定义实现任务类型，从而更好地适应不同的业务场景。</li><li>支持任务静态分片、动态分片、广播、WorkFlow 等多种任务执行模式。</li><li>支持任务自动创建与手动创建以及批量创建等方式，任务的暂停、恢复、Kill 等动作，以及实时日志查看等。</li><li>基于 CopySet 算法实现任务副本分配，提高了任务的可靠性和容错性，从而保障了任务的高可用性。</li></ol><p>详细文档请查阅：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor">https://www.yuque.com/tomgs/hodor</a></p><h2><a id="user-content-架构设计" class="anchor" href="https://gitee.com/dromara/hodor#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"></a>架构设计</h2><p><img src="https://gitee.com/dromara/hodor/raw/master/docs/assets/img/hodor%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="hodor 架构设计图" referrerpolicy="no-referrer"></p><h2><a id="user-content-快速开始" class="anchor" href="https://gitee.com/dromara/hodor#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"></a>快速开始</h2><p>项目结构：</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">hodor-scheduler</span><span id="LC2" class="line">├─docs                                          # 文档存放位置</span><span id="LC3" class="line">├─hodor-actuator                                # hodor 任务执行器</span><span id="LC4" class="line">│  ├─hodor-actuator-api                         # 执行器扩展接口</span><span id="LC5" class="line">│  ├─hodor-actuator-java                        # jar 包方式任务执行器</span><span id="LC6" class="line">│  ├─hodor-actuator-agent                       # 独立进程方式任务执行器</span><span id="LC7" class="line">│  ├─hodor-actuator-xxljob                      # 支持 xxl-job 执行器</span><span id="LC8" class="line">│  └─hodor-actuator-springtask                  # 支持 spring task 执行器</span><span id="LC9" class="line">├─hodor-admin                                   # hodor 管理控制枱（TODO）</span><span id="LC10" class="line">├─hodor-client                                  # 提供与 hodor server 的交互 sdk</span><span id="LC11" class="line">├─hodor-common                                  # hodor 公共依赖</span><span id="LC12" class="line">├─hodor-core                                    # hodor 核心业务</span><span id="LC13" class="line">├─hodor-examples                                # hodor 测试用例</span><span id="LC14" class="line">├─hodor-cache                                   # hodor 扩展</span><span id="LC15" class="line">│  ├─hodor-cache-local                          # 基于本地内存的缓存</span><span id="LC16" class="line">│  ├─hodor-cache-embedded                       # 基于 embedded 的分布式缓存</span><span id="LC17" class="line">│  └─hodor-cache-redis                          # 基于 redis 的分布式缓存</span><span id="LC18" class="line">├─hodor-model                                   # hodor 公共数据模型</span><span id="LC19" class="line">├─hodor-storage                                 # hodor storage 模块</span><span id="LC20" class="line">├─hodor-register                                # hodor 注册中心</span><span id="LC21" class="line">│  ├─hodor-register-api</span><span id="LC22" class="line">│  ├─hodor-register-embedded                    # 基于 Raft 实现注册中心</span><span id="LC23" class="line">│  └─hodor-register-zookeeper                   # 基于 zk 实现注册中心</span><span id="LC24" class="line">├─hodor-remoting                                # hodor 通信框架</span><span id="LC25" class="line">│  ├─hodor-remoting-api</span><span id="LC26" class="line">│  └─hodor-remoting-netty</span><span id="LC27" class="line">├─hodor-scheduler                               # hodor 调度核心</span><span id="LC28" class="line">│  ├─hodor-scheduler-api</span><span id="LC29" class="line">│  └─hodor-scheduler-quartz</span><span id="LC30" class="line">└─hodor-server                                  # hodor 入口</span><span id="LC31" class="line"></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-本地源码运行方式" class="anchor" href="https://gitee.com/dromara/hodor#%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"></a>本地源码运行方式</h2><ol><li>在 mysql 下执行 docs 目录下面的 hodor_ddl.sql。</li><li>在项目根目录下通过 mvn package -DskipTests=true 命令编译整个项目，因为涉及到一些代码的自动生成。</li><li>进入到 hodor-server，启动 HodorServer 调度器。</li><li>进入到 examples 下面的 hodor-actuator-java-example，启动 java 任务执行器程序</li><li>java 执行器启动完成后会自动将任务注册到调度器里面来</li></ol><h2><a id="user-content-任务使用说明" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"></a>任务使用说明</h2><p>详细参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fiqrsqxh2i2qt5ixi">执行器操作指南</a></p><h3><a id="user-content-java 任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#java%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>java 任务接入 demo</h3><p>详细 demo 代码参考 <em>hodor-examples/hodor-actuator-java-example</em> 模块</p><blockquote><p>普通 java 任务</p></blockquote><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">group</span><span class="o">=</span><span class="s">"testGroup"</span><span class="o">,</span><span class="n">jobName</span><span class="o">=</span><span class="s">"test1"</span><span class="o">,</span><span class="n">cron</span><span class="o">=</span><span class="s">"0/30 * * * * ?"</span><span class="o">)</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="nc">String</span><span class="nf">test1</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC3" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [testGroup#test1] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC4" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC5" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job test1"</span><span class="o">);</span></span><span id="LC6" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"job argument: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getJobParameter</span><span class="o">());</span></span><span id="LC7" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executing......"</span><span class="o">);</span></span><span id="LC8" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executed"</span><span class="o">);</span></span><span id="LC9" class="line"><span class="k">return</span><span class="s">"a=123"</span><span class="o">;</span></span><span id="LC10" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><blockquote><p>动态分片任务</p></blockquote><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 任务动态切分</span></span><span id="LC2" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"splitStage"</span><span class="o">)</span></span><span id="LC3" class="line"><span class="kd">public</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">ShardData</span><span class="o">&gt;</span><span class="nf">split</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC4" class="line"><span class="nc">ShardData</span><span class="n">shardData</span><span class="o">=</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">id</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">params</span><span class="o">(</span><span class="s">"hello"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span></span><span id="LC5" class="line"><span class="nc">ShardData</span><span class="n">shardData1</span><span class="o">=</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">id</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">params</span><span class="o">(</span><span class="s">"world"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span></span><span id="LC6" class="line"><span class="k">return</span><span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">shardData</span><span class="o">,</span><span class="n">shardData1</span><span class="o">);</span></span><span id="LC7" class="line"><span class="o">}</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">// 任务并行执行</span></span><span id="LC10" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"parallelJob"</span><span class="o">)</span></span><span id="LC11" class="line"><span class="kd">public</span><span class="nc">String</span><span class="nf">parallelJob</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC12" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [parallelJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC13" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC14" class="line"><span class="kd">final</span><span class="nc">ShardData</span><span class="n">parentJobData</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobData</span><span class="o">(</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></span><span id="LC15" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job parallelJob, parentJobData: {}"</span><span class="o">,</span><span class="n">parentJobData</span><span class="o">);</span></span><span id="LC16" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job parallelJob, parentJobData: {}"</span><span class="o">,</span><span class="n">parentJobData</span><span class="o">);</span></span><span id="LC17" class="line"><span class="k">return</span><span class="s">"a=123"</span><span class="o">;</span></span><span id="LC18" class="line"><span class="o">}</span></span><span id="LC19" class="line"></span><span id="LC20" class="line"><span class="c1">// 任务汇总执行</span></span><span id="LC21" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"reduceJob2"</span><span class="o">)</span></span><span id="LC22" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">reduceJob</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC23" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC24" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC25" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"job argument: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getJobParameter</span><span class="o">());</span></span><span id="LC26" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executed"</span><span class="o">);</span></span><span id="LC27" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC28" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, results {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobExecuteResults</span><span class="o">()</span></span><span id="LC29" class="line"><span class="o">);</span></span><span id="LC30" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, statues {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobExecuteStatuses</span><span class="o">());</span></span><span id="LC31" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-xxljob 任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#xxljob%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>xxljob 任务接入 demo</h3><p>详细 demo 代码参考 <em>hodor-examples/hodor-actuator-xxljob-example</em> 模块</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="cm">/**</span></span><span id="LC2" class="line"><span class="cm"> * 1、简单任务示例（Bean 模式）</span></span><span id="LC3" class="line"><span class="cm"> */</span></span><span id="LC4" class="line"><span class="nd">@XxlJob</span><span class="o">(</span><span class="s">"demoJobHandler"</span><span class="o">)</span></span><span id="LC5" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">demoJobHandler</span><span class="o">()</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC6" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"XXL-JOB, Hello World."</span><span class="o">);</span></span><span id="LC7" class="line"></span><span id="LC8" class="line"><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"beat at:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span></span><span id="LC10" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC11" class="line"><span class="o">}</span></span><span id="LC12" class="line"><span class="c1">// default success</span></span><span id="LC13" class="line"><span class="o">}</span></span><span id="LC14" class="line"></span><span id="LC15" class="line"><span class="cm">/**</span></span><span id="LC16" class="line"><span class="cm"> * 2、分片广播任务</span></span><span id="LC17" class="line"><span class="cm"> */</span></span><span id="LC18" class="line"><span class="nd">@XxlJob</span><span class="o">(</span><span class="s">"shardingJobHandler"</span><span class="o">)</span></span><span id="LC19" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">shardingJobHandler</span><span class="o">()</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC20" class="line"><span class="c1">// 分片参数</span></span><span id="LC21" class="line"><span class="kt">int</span><span class="n">shardIndex</span><span class="o">=</span><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">getShardIndex</span><span class="o">();</span></span><span id="LC22" class="line"><span class="kt">int</span><span class="n">shardTotal</span><span class="o">=</span><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">getShardTotal</span><span class="o">();</span></span><span id="LC23" class="line"></span><span id="LC24" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"分片参数：当前分片序号 = {}, 总分片数 = {}"</span><span class="o">,</span><span class="n">shardIndex</span><span class="o">,</span><span class="n">shardTotal</span><span class="o">);</span></span><span id="LC25" class="line"></span><span id="LC26" class="line"><span class="c1">// 业务逻辑</span></span><span id="LC27" class="line"><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">shardTotal</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span><span class="o">{</span></span><span id="LC28" class="line"><span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="n">shardIndex</span><span class="o">)</span><span class="o">{</span></span><span id="LC29" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"第 {} 片, 命中分片开始处理"</span><span class="o">,</span><span class="n">i</span><span class="o">);</span></span><span id="LC30" class="line"><span class="o">}</span><span class="k">else</span><span class="o">{</span></span><span id="LC31" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"第 {} 片, 忽略"</span><span class="o">,</span><span class="n">i</span><span class="o">);</span></span><span id="LC32" class="line"><span class="o">}</span></span><span id="LC33" class="line"><span class="o">}</span></span><span id="LC34" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-spring-task 任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#spring-task%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>spring task 任务接入 demo</h3><p>详细 demo 代码参考 <em>hodor-examples/hodor-actuator-springtask-example</em> 模块</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedRate</span><span class="o">=</span><span class="mi">3000</span><span class="o">)</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task1</span><span class="o">()</span><span class="kd">throws</span><span class="nc">InterruptedException</span><span class="o">{</span></span><span id="LC3" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC4" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行 fixedRate 任务的时间："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC5" class="line"><span class="o">}</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedDelay</span><span class="o">=</span><span class="mi">4000</span><span class="o">)</span></span><span id="LC8" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task2</span><span class="o">()</span><span class="kd">throws</span><span class="nc">InterruptedException</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC10" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行 fixedDelay 任务的时间："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC11" class="line"><span class="o">}</span></span><span id="LC12" class="line"></span><span id="LC13" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">cron</span><span class="o">=</span><span class="s">"0/5 * * * * ?"</span><span class="o">)</span></span><span id="LC14" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task3</span><span class="o">()</span><span class="o">{</span></span><span id="LC15" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行 cron 任务的时间："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC16" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-agent-方式任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#agent-%E6%96%B9%E5%BC%8F%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>agent 方式任务接入 demo</h3><p>详细参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fiqrsqxh2i2qt5ixi">执行器操作指南</a> 中的 agent 方式的使用。</p><h2><a id="user-content-hodor 打包部署说明" class="anchor" href="https://gitee.com/dromara/hodor#hodor%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%AF%B4%E6%98%8E"></a>hodor 打包部署说明</h2><p>详细参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fgiukp9y4plqb55ng">安装部署操作指南</a></p><h2><a id="user-content-交流学习" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BA%A4%E6%B5%81%E5%AD%A6%E4%B9%A0"></a>交流学习</h2><p>目前，Hodor 仍处于建设的过程中，团队成员只能抽出空闲时间投入其中，主要精力还是放在日常工作中。
如果有兴趣的同学想要参与 Hodor 的实现或者一起学习，欢迎通过微信联系我们，我们非常欢迎新的成员加入！</p><p>Hodor 的未来发展方向包括以下几个方面：</p><ol><li>前端界面和控制枱开发，为用户提供更加友好、直观的任务管理界面。</li><li>执行器开发工作，包括执行编程框架和大数据任务执行器的优化，以提高系统的性能和稳定性。</li><li>通信协议改造，计划将目前自定义的协议改造为 grpc 的方式，以提高系统的可扩展性和兼容性。</li><li>优化 CopySet 算法的实现，以支持机架感知，更好地分配任务副本。</li><li>开发多语言执行器，主要放在 go 和 rust 语言，以满足用户不同的需求和偏好。</li></ol><p>Wechat：(备注：Hodor)</p><p><img src="https://gitee.com/dromara/hodor/raw/master/docs/assets/img/wechat.png" alt="image-20220529141555032" referrerpolicy="no-referrer"></p>]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/dromara/hodor</guid>
            <link>https://gitee.com/dromara/hodor</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | Dubbo 路由及负载均衡性能优化]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="font-size: 15px;"><section style="text-align: right;margin-top: 10px;margin-bottom: -25px;" powered-by="xiumi.us"><section style="display: inline-block;width: 35px;height: 35px;vertical-align: top;overflow: hidden;border-width: 1px;border-radius: 100%;border-style: solid;border-color: transparent;background-color: rgb(255, 255, 255);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section><section style="text-align: center;font-size: 14px;" powered-by="xiumi.us"><p><span style="color: rgb(0, 82, 255);"><span style="color: rgb(0, 82, 255);letter-spacing: 0.578px;text-align: center;text-wrap: wrap;font-size: 14px;">揭秘 vivo 互联网海量服务的研发之路&nbsp;</span><span style="color: rgb(0, 82, 255);text-align: center;text-wrap: wrap;font-size: 14px;letter-spacing: 0.034em;">报名中👇</span></span></p></section><section style="text-align: center;margin-top: 0.5em;margin-bottom: 0.5em;padding-left: 0.5em;padding-right: 0.5em;" powered-by="xiumi.us"><section style="border-width: 5px;border-style: solid;border-color: rgb(255, 255, 255);display: inline-block;line-height: 0;box-shadow: rgb(102, 102, 102) 0.2em 0.2em 0.5em;width: 70%;height: auto;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D2%26sn%3D949ce368a94c5950749a74fec56b98fb%26chksm%3Debdb8632dcac0f24fbac44050c9605d521f9728517b311f54639e1ab3bc0422ce95391b09636%26scene%3D21%23wechat_redirect" textvalue="你已选中了添加链接的内容" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="1"><span class="js_jump_icon h5_image_link"><img class="rich_pages wxw-img" data-cropselx1="0" data-cropselx2="384" data-cropsely1="0" data-cropsely2="384" data-ratio="0.21944444444444444" data-s="300,640" src="https://oscimg.oschina.net/oscnet/92614968-2ae5-4624-9416-5e3659137ef6.png" data-type="jpeg" data-w="1080" style="vertical-align: middle;width: 578px;height: 127px;" referrerpolicy="no-referrer"></span></a></section><span style="font-size: 14px;letter-spacing: 0.034em;text-align: justify;"></span></section></section><section style="font-size: 15px;line-height: 1.6;"><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">作者：vivo 互联网中间件团队- Wang Xiaochuang</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: left;" powered-by="xiumi.us"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);"><p style="text-wrap: wrap;">本文主要介绍在 vivo 内部针对 Dubbo 路由模块及负载均衡的一些优化手段，主要是异步化+缓存，可减少在 RPC 调用过程中路由及负载均衡的 CPU 消耗，极大提升调用效率。</p></section></section><section style="margin-right: 0%;margin-bottom: -5px;margin-left: 0%;text-align: right;line-height: 1;font-size: 5px;transform: translate3d(5px, 0px, 0px);" powered-by="xiumi.us"><section style="width: 0px;display: inline-block;vertical-align: top;border-bottom: 0.6em solid rgb(160, 160, 160);border-right: 0.6em solid rgb(160, 160, 160);border-top: 0.6em solid transparent !important;border-left: 0.6em solid transparent !important;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>一、概要</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">vivo 内部 Java 技术栈业务使用的是 Apache Dubbo 框架，基于开源社区 2.7.x 版本定制化开发。在海量微服务集群的业务实践中，我们发现 Dubbo 有一些性能瓶颈的问题会极大影响业务逻辑的执行效率，尤其是在集群规模数量较大时 (提供方数量&gt;100)，路由及负载均衡方面有着较大的 CPU 消耗，从采集的火焰图分析高达 30%。为此我们针对 vivo 内部常用路由策略及负载均衡进行相关优化，并取得了较好的效果。接下来主要跟大家分析一下相关问题产生的根源，以及我们采用怎样的方式来解决这些问题。（当前 vivo 内部使用的 Dubbo 的主流版本是基于 2.7.x 进行相关定制化开发。）</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>二、背景知识</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.1 Dubbo 客户端调用流程</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1.&nbsp;相关术语介绍</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.35069075451647186" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bac7b7d2-f9db-4eb0-9f3d-5900e79ab3fe.png" data-type="png" data-w="941" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;主要流程</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">客户端通过本地代理 Proxy 调用 ClusterInvoker，ClusterInvoker 从服务目录 Directory 获取服务列表后经过路由链获取新的服务列表、负载均衡从路由后的服务列表中根据不同的负载均衡策略选取一个远端 Invoker 后再发起远程 RPC 调用。</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.562962962962963" data-s="300,640" src="https://oscimg.oschina.net/oscnet/c2e7d8db-665a-4a4f-b704-246b9544a375.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.2 Dubbo 路由机制</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Dubbo 的路由机制实际是基于简单的责任链模式实现，同时 Router 继承了 Comparable 接口，自定义的路由可以设置不同的优先级进而定制化责任链上 Router 的顺序。基于责任链模式可以支持多种路由策略串行执行如就近路由+标签路由，或条件路由+就近路由等，且路由的配置支持基于接口级的配置也支持基于应用级的配置。常见的路由方式主要有：就近路由，条件路由，标签路由等。具体的执行过程如下图所示：</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.0143112701252237" data-s="300,640" src="https://oscimg.oschina.net/oscnet/de6310ef-9be0-491d-8451-14b01a37e125.png" data-type="png" data-w="559" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 核心类</strong></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">Dubbo 路由的核心类主要有：<strong>RouterChain、RouterFactory 与 Router 。</strong></p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">（1）RouterChain</p><p style="text-wrap: wrap;">RouterChain 是路由链的入口，其核心字段有<br></p></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><strong>invokers（List&lt;invoker&gt; 类型）</strong></p><p>初始服务列表由服务目录 Directory 设置，当前 RouterChain 要过滤的 Invoker 集合<br></p></li><li><p><strong>builtinRouters（List 类型）</strong></p><p>当前 RouterChain 包含的自动激活的 Router 集合<br></p></li><li><p><strong>routers（List 类型）</strong></p><p>包括所有要使用的路由由 builtinRouters 加上通过 addRouters() 方法添加的 Router 对象</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">RouterChain 核心逻辑</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">class</span><span class="code-snippet__title">RouterChain</span>&lt;<span class="code-snippet__title">T</span>&gt; </span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 注册中心最后一次推送的服务列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers = Collections.emptyList();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 所有路由,包括原生 Dubbo 基于注册中心的路由规则如「route://」 urls .</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> volatile <span class="code-snippet__keyword">List</span>&lt;Router&gt; routers = Collections.emptyList();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 初始化自动激活的路由</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span><span class="code-snippet__keyword">List</span>&lt;Router&gt; builtinRouters = Collections.emptyList();</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> RouterChain(URL url) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//通过 ExtensionLoader 加载可自动激活的 RouterFactory</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;RouterFactory&gt; extensionFactories = ExtensionLoader.getExtensionLoader(RouterFactory.class)</span></code><code><span class="code-snippet_outer">                .getActivateExtension(url, ROUTER_KEY);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 由工厂类生成自动激活的路由策略</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Router&gt; routers = extensionFactories.stream()</span></code><code><span class="code-snippet_outer">                .map(factory -&gt; factory.getRouter(url))</span></code><code><span class="code-snippet_outer">                .collect(Collectors.toList());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        initWithRouters(routers);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 添加额外路由</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> void addRouters(<span class="code-snippet__keyword">List</span>&lt;Router&gt; routers) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Router&gt; newRouters = <span class="code-snippet__keyword">new</span> ArrayList&lt;&gt;();</span></code><code><span class="code-snippet_outer">        newRouters.addAll(builtinRouters);</span></code><code><span class="code-snippet_outer">        newRouters.addAll(routers);</span></code><code><span class="code-snippet_outer">        Collections.sort(newRouters, comparator);</span></code><code><span class="code-snippet_outer">        this.routers = newRouters;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; route(URL url, Invocation invocation) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; finalInvokers = invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 遍历全部的 Router 对象，执行路由规则</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (Router router : routers) {</span></code><code><span class="code-snippet_outer">            finalInvokers = router.route(finalInvokers, url, invocation);</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> finalInvokers;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）RouterFactory 为 Router 的工厂类</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">RouterFactory 接口定义</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@SPI</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">RouterFactory</span></span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Adaptive</span>(<span class="code-snippet__string">"protocol"</span>)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__function">Router <span class="code-snippet__title">getRouter</span><span class="code-snippet__params">(URL url)</span></span>;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（3）Router</p><p style="text-wrap: wrap;" powered-by="xiumi.us">Router 是真正的路由实现策略，由 RouterChain 进行调用，同时 Router 继承了 Compareable 接口，可以根据业务逻辑设置不同的优先级。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">Router 主要接口定义</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">Router</span><span class="code-snippet__keyword">extends</span><span class="code-snippet__title">Comparable</span>&lt;<span class="code-snippet__title">Router</span>&gt; </span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     *</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers   带过滤实例列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> url        消费方 url</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invocation 会话信息</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span> routed invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@throws</span> RpcException</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer">    &lt;T&gt; <span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; route(<span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 当注册中心的服务列表发现变化，或有动态配置变更会触发实例信息的变化</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 当时 2.7.x 的 Dubbo 并没有真正使用这个方法，可基于此方法进行路由缓存</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers invoker list</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;      invoker's type</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">default</span> &lt;T&gt; void notify(<span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;同机房优先路由的实现</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="letter-spacing: 0.034em;">为方便大家了解路由的实现，给大家展示一下就近路由的核心代码逻辑</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL consumerUrl, Invocation invocation) throws RpcException {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (!<span class="code-snippet__keyword">this</span>.enabled) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取本地机房信息</span></span></code><code><span class="code-snippet_outer">        String local = getSystemProperty(LOC);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers == <span class="code-snippet__literal">null</span> || invokers.size() == <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">        List&lt;Invoker&lt;T&gt;&gt; result = new ArrayList&lt;Invoker&lt;T&gt;&gt;();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (Invoker invoker: invokers) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取与本地机房一致的 invoker 并加入列表中</span></span></code><code><span class="code-snippet_outer">            String invokerLoc = getProperty(invoker, invocation, LOC);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (local.equals(invokerLoc)) {</span></code><code><span class="code-snippet_outer">                result.add(invoker);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (result.size() &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (fallback){</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 开启服务降级，available.ratio = 当前机房可用服务节点数量 ／ 集群可用服务节点数量</span></span></code><code><span class="code-snippet_outer">                int curAvailableRatio = (int) Math.floor(result.size() * <span class="code-snippet__number">100.0</span>d / invokers.size());</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (curAvailableRatio &lt;= availableRatio) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (force) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.3 Dubbo 负载均衡</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Dubbo 的负载均衡实现比较简单基本都是继承抽象类进行实现，主要作用就是根据具体的策略在路由之后的服务列表中筛选一个实例进行远程 RPC 调用，默认的负载均衡策略是随机。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">整体类图如下所示：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.2824074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/22c30ee5-d60d-45b1-a737-bbf064f7c1cc.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">LoadBalance 接口定义</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@SPI</span>(RandomLoadBalance.NAME)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">LoadBalance</span></span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 从服务列表中筛选一个.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     *</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers   invokers.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> url        refer url</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invocation invocation.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span> selected invoker.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Adaptive</span>(<span class="code-snippet__string">"loadbalance"</span>)</span></code><code><span class="code-snippet_outer">    &lt;T&gt; <span class="code-snippet__function">Invoker&lt;T&gt; <span class="code-snippet__title">select</span><span class="code-snippet__params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span><span class="code-snippet__keyword">throws</span> RpcException</span>;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">随机负载均衡核心代码解析</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 预热过程权重计算</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">static</span><span class="code-snippet__keyword">int</span><span class="code-snippet__title">calculateWarmupWeight</span>(<span class="code-snippet__params"><span class="code-snippet__keyword">int</span> uptime, <span class="code-snippet__keyword">int</span> warmup, <span class="code-snippet__keyword">int</span> weight</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> ww = (<span class="code-snippet__keyword">int</span>) (uptime / ((<span class="code-snippet__keyword">float</span>) warmup / weight));</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> ww &lt; <span class="code-snippet__number">1</span> ? <span class="code-snippet__number">1</span> : (Math.min(ww, weight));</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">int</span><span class="code-snippet__title">getWeight</span>(<span class="code-snippet__params">Invoker&lt;?&gt; invoker, Invocation invocation</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> weight;</span></code><code><span class="code-snippet_outer">       URL url = invoker.getUrl();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 多注册中心场景下的，注册中心权重获取</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">           weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">       } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer">           weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (weight &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取实例启动时间</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">long</span> timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, <span class="code-snippet__number">0L</span>);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (timestamp &gt; <span class="code-snippet__number">0L</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">long</span> uptime = System.currentTimeMillis() - timestamp;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (uptime &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span><span class="code-snippet__number">1</span>;</span></code><code><span class="code-snippet_outer">                   }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取预热时间</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (uptime &gt; <span class="code-snippet__number">0</span> &amp;&amp; uptime &lt; warmup) {</span></code><code><span class="code-snippet_outer">                       weight = calculateWarmupWeight((<span class="code-snippet__keyword">int</span>)uptime, warmup, weight);</span></code><code><span class="code-snippet_outer">                   }</span></code><code><span class="code-snippet_outer">               }</span></code><code><span class="code-snippet_outer">           }</span></code><code><span class="code-snippet_outer">       }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> Math.max(weight, <span class="code-snippet__number">0</span>);</span></code><code><span class="code-snippet_outer">   }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">@Override</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">protected</span> &lt;T&gt; <span class="code-snippet__function">Invoker&lt;T&gt; <span class="code-snippet__title">doSelect</span>(<span class="code-snippet__params">List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Number of invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> length = invokers.size();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Every invoker has the same weight?</span></span></code><code><span class="code-snippet_outer">        boolean sameWeight = <span class="code-snippet__literal">true</span>;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// the weight of every invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span>[] weights = <span class="code-snippet__keyword">new</span><span class="code-snippet__keyword">int</span>[length];</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// the first invoker's weight</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> firstWeight = getWeight(invokers.<span class="code-snippet__keyword">get</span>(<span class="code-snippet__number">0</span>), invocation);</span></code><code><span class="code-snippet_outer">        weights[<span class="code-snippet__number">0</span>] = firstWeight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// The sum of weights</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> totalWeight = firstWeight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = <span class="code-snippet__number">1</span>; i &lt; length; i++) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> weight = getWeight(invokers.<span class="code-snippet__keyword">get</span>(i), invocation);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// save for later use</span></span></code><code><span class="code-snippet_outer">            weights[i] = weight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Sum</span></span></code><code><span class="code-snippet_outer">            totalWeight += weight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) {</span></code><code><span class="code-snippet_outer">                sameWeight = <span class="code-snippet__literal">false</span>;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (totalWeight &gt; <span class="code-snippet__number">0</span> &amp;&amp; !sameWeight) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on totalWeight.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Return a invoker based on the random value.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = <span class="code-snippet__number">0</span>; i &lt; length; i++) {</span></code><code><span class="code-snippet_outer">                offset -= weights[i];</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (offset &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers.<span class="code-snippet__keyword">get</span>(i);</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers.<span class="code-snippet__keyword">get</span>(ThreadLocalRandom.current().nextInt(length));</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>预热解释</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">预热是为了让刚启动的实例流量缓慢增加,因为实例刚启动时各种资源可能还没建立连接，相关代码可能还是处于解释执行，仍未变为 JIT 执行，此时业务逻辑较慢，不应该加载过大的流量，否则有可能造成较多的超时。Dubbo 默认预热时间为 10 分钟，新部署的实例的流量会在预热时间段内层线性增长，最终与其他实例保持一致。Dubbo 预热机制的实现就是通过控制权重来实现。如默认权重 100，预热时间 10 分钟，则第一分钟权重为 10，第二分钟为 20，以此类推。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体预热效果图如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.45765765765765765" data-s="300,640" src="https://oscimg.oschina.net/oscnet/752bc3b5-e121-4de3-b41b-022860b2700e.png" data-type="png" data-w="555" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>三、问题分析</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">使用 Dubbo 的业务方反馈，他们通过火焰图分析发现 Dubbo 的负载均衡模块+路由模块占用 CPU 超过了 30%，框架层面的使用率严重影响了业务逻辑的执行效率急需进行优化。通过火焰图分析，具体占比如下图，其中该机器在业务忙时的 CPU 使用率在 60% 左右，闲时在 30% 左右。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.30970873786407765" data-s="300,640" src="https://oscimg.oschina.net/oscnet/81ae8f99-a18c-4416-8f9a-b6c012a14476.png" data-type="png" data-w="1030" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通过火焰图分析，负载均衡主要的消耗是在 getWeight 方法。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.1388888888888889" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b1d57058-f760-43c5-83bc-166c07ca9d81.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">路由的主要消耗是在 route 方法：</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">同机房优先路由</p><p style="text-wrap: wrap;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.11296296296296296" data-s="300,640" src="https://oscimg.oschina.net/oscnet/fee26d17-6eb3-4103-b12d-cc8975696932.png" data-type="png" data-w="1080" style="font-size: 15px;letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" referrerpolicy="no-referrer"></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">接口级标签路由+应用级标签路由</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.14907407407407408" data-s="300,640" src="https://oscimg.oschina.net/oscnet/11c33b76-0ae1-45fe-aeef-a05793340801.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">这些方法都有一个特点，那就是遍历执行。如负载均衡，针对每一个 invoker 都需要通过 getWeight 方法进行权重的计算；就近路由的 router 方法对于每一个 invoker 都需要通过 url 获取及机房信息进行匹配计算。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">我们分析一下 getWeight 及 router 时间复杂度，发现是 O(n) 的时间复杂度，而且路由是由路由链组成的，每次每个 Router 的 route 方法调用逻辑都会遍历实例列表，那么当实例列表数量过大时，每次匹配的计算的逻辑过大，那么就会造成大量的计算成本，导致占用大量 cpu，同时也导致路由负载均衡效率低下。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">综上所述，罪恶的的根源就是遍历导致的，当服务提供方数量越多，影响越大。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>四、优化方案</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">知道了问题所在，我们来分析一下是否有优化空间。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.1 路由优化</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 优化一：关闭无效路由</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通过火焰图分析，我们发现有部分业务即使完全不使用应用级的标签路由，原生的 TagRouter 也存在遍历逻辑，原因是为了支持静态的标签路由，其实这部分的开销也不少，那对于根本不会使用应用级标签路由的可以手动进行关闭。关闭方式如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">客户端统一关闭<br></p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js"><code><span class="code-snippet_outer">dubbo.consumer.router=-tag</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">服务级别关闭</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">注解方式：</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@DubboReference(parameters = {<span class="code-snippet__meta-string">"router"</span>,<span class="code-snippet__meta-string">"-tag"</span>})</span></span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">xml 方式：</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer">&lt;dubbo:reference id=<span class="code-snippet__string">"demoService"</span> check=<span class="code-snippet__string">"false"</span><span class="code-snippet__keyword">interface</span>=<span class="code-snippet__string">"com.dubbo.study.n.api.DemoService"</span> router=<span class="code-snippet__string">"-tag"</span> /&gt;</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2. 优化二：提前计算路由结果并进行缓存</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">每次路由目前都是进行实时计算，但是在大多数情况下，我们的实例列表是稳定不变的，只有在发布窗口或配置变更窗口内实例列表才会发生变更，那我们是否可以考虑缓存呢。如就近路由，可以以机房为 key 进行机房实例的全量缓存。针对接口级标签路由可以缓存不同标签值指定的实例信息。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">我们知道路由的执行过程是责任链模式，每一个 Router 的实例列表入参实际上是一个 Router 的结果，可参考公式：target = rn(…r3(r2(r1(src))))。那么所有的路由可以基于注册中心推送的原始服务列表进行路由计算并缓存，然后不同的路由结果相互取交集就能得到最终的结果，当实例信息发生变更时，缓存失效并重新计算。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>3. 缓存更新时机</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">当注册中心或者动态配置有变更时，相关通知会给到服务目录 Directory,Directory 收到通知后会重新创建服务列表，并把服务列表同步到路由链 RouterChain，RouterChain 再按顺序通知其链上的 Router,各个 Router 再进行缓存清除并重新进行路由结果的计算及进行缓存。相关时序图如下所示：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.42962962962962964" data-s="300,640" src="https://oscimg.oschina.net/oscnet/e8b71fb8-8926-40de-abe8-147ba10fa2ea.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>4. 具体路由流程</strong></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">进入具体路由方法时，先判断是否存在缓存的路由值，且缓存值的 epoch 必须与上一个路由的 epoch 需一致，此时缓存才生效，然后缓存值与上个 Router 的结果取交集。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">如果不存在缓存或 epoch 不一致则重新进行实时的路由计算。</p><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.7803921568627451" data-s="300,640" src="https://oscimg.oschina.net/oscnet/024bfb79-3f68-4ca5-bf7f-bfd337d6c3d0.jpg" data-type="jpeg" data-w="1020" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us">引入 epoch 的原因主要是保证各个路由策略缓存信息的一致性，保证所有的缓存计算都是基于同一份原始数据。当实例信息发生变更时，epoch 会自动进行更新。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>5. BitMap 引入</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">上文我们说到，不同的路由策略之间的结果是取交集的，然后最终的结果才送入负载均衡流程。那如何在缓存的同时，加快交集的计算呢。答案就是基于位图：BitMap。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">BitMap 的基本原理就是用一个 bit 位来存放某种状态，适用于大规模数据的查找及位运算操作。如在路由场景，先基于全量的推送数据进行计算缓存。如果某个实例被路由选中，则其值为 1，若两个路由的结果要取交集，那直接对 BitMap 进行"&amp;"运行即可。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">全量缓存示意图：</p><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.4935185185185185" data-s="300,640" src="https://oscimg.oschina.net/oscnet/5fc6e016-b880-40ce-9d59-390fe111bfa8.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us">路由交集计算示步骤：</p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">按照路由链依次计算，</p><p style="text-wrap: wrap;">tagRouter-&gt;vivoTag-&gt;vivoNearestRouter</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（1）tagRouter 计算逻辑：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>按照 Invocation 计算出目标的 Tag,假设是 tag1</p></li><li><p>然后从缓存 Cache 根据 key:tag1,取出对应的 targetAddrPool</p></li><li><p>将原始传入的 addrPool</p><p>与 targetAddrPool</p><p>得到结果 resultAddrPool</p></li><li><p>将 resultAddrPool 传入 vivoTagRouter</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）vivoTag 计算逻辑：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>按照 Invocation 计算出目标的 Tag,假设是 tabB</p></li><li><p>然后从缓存 Cache 根据 key:tag1，取出对应的 targetAddrPool</p></li><li><p>将上一次传入的 addrPool</p><p>与 targetAddrPool</p><p>得到结果 resultAddrPooll</p></li><li><p>将 resultAddrPool 传入</p><p>vivoNearestRouter</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">（3）vivoNearestRouter 计算逻辑</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>从环境变量取出当前机房，假设是 bj01</p></li><li><p>然后从缓存 Cache 根据 key:bj01，取出对应的 targetAddrPool</p></li><li><p>将上一次传入的 addrPool</p><p>与 targetAddrPool</p><p>取出 resultAddrPool</p></li><li><p>将上一次传入的 addrPool</p><p>与 targetAddrPool</p><p>得到结果 resultAddrPool</p></li><li><p>将 resultAddrPool 为最终路由结果，传递给 LoadBalance</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6907407407407408" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bfad5e5c-e485-4ab8-8b25-208b5ca92c3d.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>6. 基于缓存的同机房优先路由源码解析</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">缓存刷新</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * Notify router chain of the initial addresses from registry at the first time.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * Notify whenever addresses in registry change.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">public</span><span class="code-snippet__keyword">void</span><span class="code-snippet__title">setInvokers</span>(<span class="code-snippet__params">List&lt;Invoker&lt;T&gt;&gt; invokers</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 创建带 epoch 的 BitList</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">this</span>.invokers = <span class="code-snippet__keyword">new</span> BitList&lt;Invoker&lt;T&gt;&gt;(invokers == <span class="code-snippet__literal">null</span> ? Collections.emptyList() : invokers,createBitListEpoch());</span></code><code><span class="code-snippet_outer">        routers.forEach(router -&gt; router.notify(<span class="code-snippet__keyword">this</span>.invokers));</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">同机房优先路由源码解读</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL consumerUrl, Invocation invocation) throws RpcException {</span></code><code><span class="code-snippet_outer">        …………<span class="code-snippet__comment">//省略非核心代码</span></span></code><code><span class="code-snippet_outer">        BitList&lt;Invoker&lt;T&gt;&gt; bitList = (BitList&lt;Invoker&lt;T&gt;&gt;) invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//获取路由结果</span></span></code><code><span class="code-snippet_outer">        BitList&lt;Invoker&lt;T&gt;&gt; result = getNearestInvokersWithCache(bitList);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (result.size() &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (fallback) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 开启服务降级，available.ratio = 当前机房可用服务节点数量 ／ 集群可用服务节点数量</span></span></code><code><span class="code-snippet_outer">                int curAvailableRatio = (int) Math.floor(result.size() * <span class="code-snippet__number">100.0</span>d / invokers.size());</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (curAvailableRatio &lt;= availableRatio) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (force) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }   </span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 获取缓存列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span></span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> &lt;T&gt; BitList&lt;Invoker&lt;T&gt;&gt; getNearestInvokersWithCache(BitList&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer">        ValueWrapper valueWrapper = getCache(getSystemProperty(LOC));</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 是否存在缓存</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (valueWrapper != <span class="code-snippet__literal">null</span>) {</span></code><code><span class="code-snippet_outer">            BitList&lt;Invoker&lt;T&gt;&gt; invokerBitList = (BitList&lt;Invoker&lt;T&gt;&gt;) valueWrapper.<span class="code-snippet__keyword">get</span>();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 缓存的 epoch 与源列表是否一致</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers.isSameEpoch(invokerBitList)) {</span></code><code><span class="code-snippet_outer">                BitList&lt;Invoker&lt;T&gt;&gt; tmp = invokers.clone();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 结果取交集</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> tmp.and(invokerBitList);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 缓存不存在，实时计算放回</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> getNearestInvokers(invokers);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 新服务列表通知</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Override</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; void notify(List&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer">        clear();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers != <span class="code-snippet__literal">null</span> &amp;&amp; invokers instanceof BitList) {</span></code><code><span class="code-snippet_outer">            BitList&lt;Invoker&lt;T&gt;&gt; bitList = (BitList&lt;Invoker&lt;T&gt;&gt;) invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 设置最后一次更新的服务列表</span></span></code><code><span class="code-snippet_outer">            lastNotify = bitList.clone();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (!CollectionUtils.isEmpty(invokers) &amp;&amp; <span class="code-snippet__keyword">this</span>.enabled) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取机房相同的服务列表并进行缓存</span></span></code><code><span class="code-snippet_outer">                setCache(getSystemProperty(LOC), getNearestInvokers(lastNotify));</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.2 负载均衡优化</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1.&nbsp;优化一</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">针对 getWeight 方法，我们发现有部分业务逻辑较为消耗 cpu,但是在大多数场景下业务方并不会使用到，于是进行优化。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">getWeight 方法优化</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="javascript"><code><span class="code-snippet_outer">优化前：</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//这里主要要用多注册中心场景下，注册中心权重的获取，绝大多数情况下并不会有这个逻辑</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">           weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">       }  </span></code><code><span class="code-snippet_outer">优化后：</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invoker <span class="code-snippet__keyword">instanceof</span> ClusterInvoker &amp;&amp; UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">            weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">   }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;优化二</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">遍历是罪恶的源泉，而实例的数量决定这罪恶的深浅，我们有什么办法减少负载均衡过程中的遍历呢。一是根据 group 及 version 划分不同的集群，但是这需要涉及到业务方代码或配置层面的改动，会带来额外的成本。所以我们放弃了。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">二是没有什么是加一层解决不了的问题，为了尽量减少进入负载均衡的节点数量，考虑新增一个垫底的路由策略，在走完所有的路由策略后，若节点数量&gt;自定义数量后，进行虚拟分组，虚拟分组的策略也可进行自定义，然后随机筛选一组进入负载均衡。此时进入负载均衡的实例数量就会有倍数的下降。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">需要注意的是分组路由必须保证是在路由链的最后一环，否则会导致其他路由计算错误。</p></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.37984496124031" data-s="300,640" src="https://oscimg.oschina.net/oscnet/9ad0f113-9f91-4397-9e60-71b4b03e349f.png" data-type="png" data-w="645" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">分组路由示意</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * </span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers 待分组实例列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> groupNum 分组数量</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span></span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; doGroup(List&lt;Invoker&lt;T&gt;&gt; invokers, <span class="code-snippet__keyword">int</span> groupNum) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> listLength = invokers.size() / groupNum;</span></code><code><span class="code-snippet_outer">        List&lt;Invoker&lt;T&gt;&gt; result = <span class="code-snippet__keyword">new</span> ArrayList&lt;&gt;(listLength);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> random = ThreadLocalRandom.current().nextInt(groupNum);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = random; i &lt; invokers.size(); i = i + groupNum) {</span></code><code><span class="code-snippet_outer">            result.add(invokers.get(i));</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>五、优化效果</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">针对优化前和优化后，我们编写 Demo 工程分别压测了不配置路由/配置就近+标签路由场景。Provider 节点梯度设置 100/500/1000/2000/5000，TPS 在 1000 左右，记录了主机的 cpu 等性能指标，并打印火焰图。发现，配置路由后，采用相同并发，优化后的版本 tps 明显高于优化前版本，且新版本相较于没有配置路由时 tps 显著提高，下游节点数大于 2000 时，tps 提升达到 100% 以上，下游节点数越多，AvgCpu 优化效果越明显，并且路由及负载均衡 CPU 占比明显更低，详细数据可见下表：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.5994694960212201" data-s="300,640" src="https://oscimg.oschina.net/oscnet/1321713f-e488-4248-8ead-3e1db6f52543.png" data-type="png" data-w="754" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.7027777777777777" data-s="300,640" src="https://oscimg.oschina.net/oscnet/be116887-8e9c-4e6f-ba48-b83efffe2464.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">备注：-tag，表示显式禁用原生 Dubbo 应用级标签路由。该路由默认开启。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>六、总结</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">经过我们关闭不必要的路由逻辑、对路由缓存+异步化计算、新增分组路由等优化后，Dubbo 在负载均衡及路由模块整体的性能有了显著的提升，为业务方节省了不少 CPU 资源。在正常业务场景下当提供方数量达到 2000 及以上时，tps 提升可达 100% 以上，消费方平均 CPU 使用率下降约 27%，且提供方数量越多优化效果越明显。但是我们也发现当前的随机负载均衡依然还是会消耗一定的 CPU 资源，且只能保证流量是均衡的。当前我们的应用基本部署在虚拟机及容器上。这两者均存在超卖的状况，且同等配置的宿主机性能存在较大差异等问题。最终会导致部分请求超时、无法最大化利用提供方的资源。我们下一步将会引入 Dubbo 3.2 的自适应负载均衡并进行调优减少其 CPU 使用率波动较大的问题，其次我们自身也扩展了基于 CPU 负载均衡的单一因子算法，最终实现不同性能的机器 CPU 负载趋于均衡，最大程度发挥集群整体的性能。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="color: rgb(65, 95, 255);" powered-by="xiumi.us"><p style="text-wrap: wrap;">参考资料：</p></section><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;" powered-by="xiumi.us"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Fload-balance%2F" textvalue="Dubbo 负载均衡" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 负载均衡</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Ftraffic%2F" textvalue="Dubbo 流量管控" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 流量管控</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU4NzU0MDIzOQ%3D%3D%26mid%3D2247511003%26idx%3D3%26sn%3Defdf3f42790b74226b2ed45b701a6749%26scene%3D21%23wechat_redirect" textvalue="Dubbo 3 StateRouter：下一代微服务高效流量路由" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 3 StateRouter：下一代微服务高效流量路由</span></a></p></li></ol><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;"><section style="text-align: center;color: rgb(45, 66, 87);font-size: 11px;" powered-by="xiumi.us"><p>END</p></section></section><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: left;" powered-by="xiumi.us"><section style="padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;"><span style="display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);" title="" opera-tn-ra-cell="_$.pages:0.layers:0.comps:159.title1"><p>猜你喜欢</p></span></section><section style="border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;"><section style="font-size: 14px;text-align: left;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497343%26idx%3D1%26sn%3D959b66ceb9a8c2fe060b6981b41a807e%26chksm%3Debdb86eddcac0ffb229636ec51ec94433af75c7bc58aaa5ae52b4a2bf6a2d6d2ab11583b3174%26scene%3D21%23wechat_redirect" textvalue="记一次 Redis Cluster Pipeline 导致的死锁问题" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">记一次 Redis Cluster Pipeline 导致的死锁问题</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D1%26sn%3D5795a683e52f70384a13b34aa3daf731%26chksm%3Debdb8632dcac0f2468a461db09d8de6219af346e51436b91e6c946ee8b37e6ae8175b2f5d55e%26scene%3D21%23wechat_redirect" textvalue="深入理解 Netty FastThreadLocal" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">深入理解 Netty FastThreadLocal</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497336%26idx%3D1%26sn%3D777059b19e224f1a4fbb1550ad1de7e8%26chksm%3Debdb86eadcac0ffc78dc019c5685ad137fdddd6572238525d707152c102790f82917a473d52a%26scene%3D21%23wechat_redirect" textvalue="MySQL 到 TiDB：Hive Metastore 横向扩展之路" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">MySQL 到 TiDB：Hive Metastore 横向扩展之路</a></p></li></ul></section></section></section></section><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互联网技术" data-alias="vivoVMIC" data-signature="分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 02:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10136865</guid>
            <link>https://my.oschina.net/vivotech/blog/10136865</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌开放 .ing 顶级域名注册]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Google <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.google%2Fproducts%2Fregistry%2Fintroducing-the-ing-top-level-domain%2F" target="_blank">宣布开放 .ing 顶级域名注册</a></u>，即日起用户可通过<strong>支付额外费用（费率随时间推移降低）的方式抢先注册</strong>，抢先体验期 (EAP) 截至 12 月 5 日。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1101/104932_JmaT_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>Google 表示借助该域名企业可以注册一些非常有趣的域名，比如在线设计和绘图平台 Canva 注册的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdesign.ing%2F" target="_blank">design.ing</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdraw.ing%2F" target="_blank">draw.ing</a>、Adobe Acrobat 注册的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fedit.ing%2F" target="_blank">edit.ing</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsign.ing%2F" target="_blank">signing</a>&nbsp;等。</p><p>.ing 域名注册地址：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fget.ing%2F" target="_blank">https://get.ing/</a></u></p><p><img height="1676" src="https://static.oschina.net/uploads/space/2023/1101/105256_D6p3_2720166.png" width="3310" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 02:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264406/the-ing-top-level-domain</guid>
            <link>https://www.oschina.net/news/264406/the-ing-top-level-domain</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Layui 2.8.18 发布，阶段性稳定版 🎉]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div>
 经过 8 个预览版的持续迭代，Layui 阶段性稳定版本：&nbsp;2.8.18&nbsp;正式发布。
</div><h3><strong>更新日志</strong></h3><div><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flayui.dev%2Fdocs%2F2%2Fversions.html%232.8.18" target="_blank"><span style="color:#003884">https://layui.dev/docs/2/versions.html#2.8.18</span></a></div><h3><strong>提交记录</strong></h3><div><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1391" target="_blank"><span style="color:#003884">#1391</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1395" target="_blank"><span style="color:#003884">#1395</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1399" target="_blank"><span style="color:#003884">#1399</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1408" target="_blank"><span style="color:#003884">#1408</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1413" target="_blank"><span style="color:#003884">#1413</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1416" target="_blank"><span style="color:#003884">#1416</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1417" target="_blank"><span style="color:#003884">#1417</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1418" target="_blank"><span style="color:#003884">#1418</span></a></li></ul></div><h3><strong>参与贡献 🎉</strong></h3><div><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsentsim" target="_blank"><span style="color:#003884">@sentsim</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FSight-wcg" target="_blank"><span style="color:#003884">@Sight-wcg</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsunxiaobin89" target="_blank"><span style="color:#003884">@sunxiaobin89</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FDiyar-IT" target="_blank"><span style="color:#003884">@Diyar-IT</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmek1986" target="_blank"><span style="color:#003884">@mek1986</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flitaohms" target="_blank"><span style="color:#003884">@litaohms</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwefly2" target="_blank"><span style="color:#003884">@wefly2</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fladudu" target="_blank"><span style="color:#003884">@ladudu</span></a></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 02:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264405/layui-2-8-18-released</guid>
            <link>https://www.oschina.net/news/264405/layui-2-8-18-released</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微软推送 Windows 11 23H2 更新]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#424242">微软正式推出了<span>&nbsp;</span></span>Windows 11<span style="background-color:#ffffff; color:#424242"><span>&nbsp;</span>的「大更新」版本 <strong>Windows 11 23H2</strong>，用户可以从官方网站下载正式的镜像文件，进行全新安装或者升级安装。</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-dc52a4c9559bca2e4c971af4eeee2a191ea.png" referrerpolicy="no-referrer"></p><p>考虑到微软计划在 2024 年发布下一代 Windows（可能是 Windows 12），因此&nbsp;23H2 会成为 Windows 11 的最后一个重大更新。</p><blockquote><p><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.microsoft.com%2Fsoftware-download%2Fwindows11" target="_blank">https://www.microsoft.com/software-download/windows11</a></em><br><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.windows.com%2Fwindowsexperience%2F2023%2F10%2F31%2Fhow-to-get-the-windows-11-2023-update%2F" target="_blank">https://blogs.windows.com/windowsexperience/2023/10/31/how-to-get-the-windows-11-2023-update/</a></em></p></blockquote><p><span style="background-color:#ffffff; color:#424242">此次更新添加了名为 Copilot 的 AI 聊天机器人，以及</span>包含微软此前在 Moment 4 更新中推出的全部新功能，同时还会将内置的聊天应用替换为 Microsoft Teams 免费版。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-89e55171373efda1e01f2a70c140f4a9605.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f4c57381f3a06868203247bdcb41976fe47.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-13ed870d860b818aa514eaf8133f61ae383.png" referrerpolicy="no-referrer"></p><p>和之前的版本 21H2 和 22H2 一样，Windows 11 23H2 将获得两年的支持，每月提供累积更新、修复和新功能。需要提醒的是，Windows 11 21H2 生命周期已经在本月早些时候结束。至于 22H2，微软将在一年后，即 2024 年 10 月 4 日停止支持。</p><hr><p>以下是 Windows 11 23H2 的其他更新：</p><ul><li><strong>虚拟视频编辑器</strong>：内置在 Clipchamp 视频编辑应用中的自动合成功能，利用人工智能技术，使最终视频的合成过程更容易。</li><li><strong>多语言屏幕阅读</strong>：去年，微软在 Windows 的讲述人辅助功能中引入了使用人工智能读取屏幕上文本的自然声音，此次增加了对其他语言的支持。</li><li><strong>降低能耗</strong>：新的节能功能「自适应调光」可以在你不看屏幕时使屏幕变暗，在你再次看屏幕时重新变亮。</li><li><strong>更智能的截图功能</strong>：使用 Windows 11 附带的截图应用，你可以从截图中复制文本，并快速编辑电子邮件或电话号码。</li><li><strong>备份</strong>：现在用户可以备份之前安装在 PC 上的应用程序，以便将来恢复它们。</li><li><strong>用文字作画</strong>：用户可以输入几个单词并选择一个样式，然后画图应用会根据你的描述创建图像。</li><li><strong>更多任务栏自定义</strong>：没有运行的应用也可以显示标签，还可以隐藏时间和日期。</li><li><strong>记事本记忆功能</strong>：记事本会自动保存用户的状态。</li><li><strong>照片</strong>：用户可以在搜索框中输入关键词和对象，找到存储在 Overdrive 中的相关图片。</li><li><strong>即时游戏</strong>：用户可以在微软应用商店中找到休闲游戏，无需先下载并安装它们。</li></ul><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-fb28a2a6e8c4ede4b30e08510ca491aa24d.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b555601fed7548bcd1131d2568dd4606f25.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8be9bc80d3279e9bd4dbce568f25c323595.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-dcffdb984fc2f1427c2f174ad16a740329f.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 02:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264399/windows-11-2023-update</guid>
            <link>https://www.oschina.net/news/264399/windows-11-2023-update</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[深圳一公司奖励程序员「黄金键帽」，价值近 2 万元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 10 月 24 日，被众多科技公司和业内人士称为「程序员节」。当天，深圳一公司奖励员工「<strong>黄金键帽</strong>」。</p><blockquote><p><img height="1658" src="https://static.oschina.net/uploads/space/2023/1031/185140_pBn0_2720166.png" width="1176" referrerpolicy="no-referrer"></p></blockquote><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F5558240479%2FNpm9Lffdj%3Fpagetype%3Dprofilefeed" target="_blank">据称</a></u>这款空格键键帽是 40g 黄金，价值近 2 万元。</p><p><img src="https://static.oschina.net/uploads/space/2023/1031/185850_Wq96_2720166.png" referrerpolicy="no-referrer"></p><p><em>△「黄金 C 键」是该公司去年的奖励</em></p><p>获得奖励程序员根据代码行数排名和部门推举共同选出，最具分量的「黄金空格键」奖励给有效代码量最多的程序员。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 10:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264307</guid>
            <link>https://www.oschina.net/news/264307</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[前三季度互联网企业利润总额同比增 18.2%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年前三季度互联网和相关服务业运行情况现已公布。前三季度，互联网业务收入增速小幅提升，利润总额较快增长，研发经费持续下滑。</p><h4 style="margin-left:0px; margin-right:0px"><strong>一，总体运行情况</strong></h4><p><strong>互联网业务收入增速小幅提升。</strong>前三季度，我国规模以上互联网和相关服务企业 1（以下简称互联网企业）完成互联网业务收入 10294 亿元，同比增长 3.4%。</p><p><img height="241" src="https://oscimg.oschina.net/oscnet/up-505b65f84338dd716295e76b74112009b70.png" width="500" referrerpolicy="no-referrer"></p><p><strong>利润总额较快增长。</strong>前三季度，我国规模以上互联网企业营业成本同比增长 7%，增速较上半年回落 0.4 个百分点。实现利润总额 959.3 亿元，同比增长 18.2%。</p><p><img height="239" src="https://oscimg.oschina.net/oscnet/up-54642fdf1ae20d26f1bc9494e46da1f4440.png" width="500" referrerpolicy="no-referrer"></p><p><strong>研发经费持续下滑。</strong>前三季度，我国规模以上互联网企业共投入研发经费 495.9 亿元，同比下降 6.1%。</p><p><img height="246" src="https://oscimg.oschina.net/oscnet/up-d14b35b6a1179d07e10ffc542ff0150925e.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px"><strong>二，分领域运行情况</strong></h4><p style="margin-left:0; margin-right:0"><strong>（一）信息服务领域企业收入小幅回落。</strong>前三季度，以信息服务为主的企业（包括新闻资讯、搜索、社交、游戏、音乐视频等）互联网业务收入同比下降 2.7%。</p><p><strong>（二）生活服务领域企业收入较快增长。</strong>前三季度，以提供生活服务为主的平台企业（包括本地生活、租车约车、旅游出行、金融服务、汽车、房屋住宅等）互联网业务收入同比增长 9.8%。</p><p><strong>（三）网络销售领域企业收入增速持续提升。</strong>前三季度，主要提供网络销售服务的企业（包括大宗商品、农副产品、综合电商、医疗用品、快递等）互联网业务收入同比增长 47.3%。</p><h4 style="margin-left:0px; margin-right:0px"><strong>三，分地区运行情况</strong></h4><p><strong>东部地区互联网业务收入保持平稳增速。</strong>前三季度，东部地区完成互联网业务收入 9613 亿元，同比增长 4.5%，增速较上半年提升 0.7 个百分点，占全国互联网业务收入的比重为 93.4%。中部地区完成互联网业务收入 329.5 亿元，同比下降 9.7%，降幅较上半年扩大 2.2 个百分点。西部地区完成互联网业务收入 325 亿元，同比下降 7.5%，降幅较上半年收窄 3.2 个百分点。东北地区完成互联网业务收入 26.5 亿元，同比下降 33.3%，降幅较上半年收窄 6.4 个百分点。</p><p><img height="239" src="https://oscimg.oschina.net/oscnet/up-7b7896fe852aa2c94820a864e846f80cae2.png" width="500" referrerpolicy="no-referrer"></p><p><strong>长三角地区互联网业务收入实现较快增长。</strong>前三季度，京津冀地区完成互联网业务收入 3948 亿元，同比增长 2.9%，增速较上半年回落 0.3 个百分点，占全国互联网业务收入的比重为 38.4%。长三角地区完成互联网业务收入 4225 亿元，同比增长 13.1%，增速较上半年提升 3.5 个百分点。</p><p><img height="300" src="https://oscimg.oschina.net/oscnet/up-f6cddc5c38e933857b00b43bd049054bd02.png" width="500" referrerpolicy="no-referrer"></p><p><strong>半数地区互联网业务增速实现正增长。</strong>前三季度，互联网业务累计收入居前 5 名的北京（增长 0.7%）、上海（增长 17.7%）、浙江（增长 5.1%）、广东（下降 7.4%）和天津（增长 22.3%）共完成业务收入 9077 亿元，同比增长 5.5%，占全国比重达 88.2%。全国互联网业务增速实现正增长的省（区、市）有 15 个。</p><p><img height="243" src="https://oscimg.oschina.net/oscnet/up-d691bf5c06989113a27d8f6cf4a88d4ab6e.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px"><strong>四，我国移动应用程序（APP）发展情况</strong></h4><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">根据全国 APP 技术检测平台统计，截至 9 月底，我国国内市场上监测到活跃的 APP 数量 2 为 261 万款（包括安卓和苹果商店）。移动应用开发者数量为 84 万，其中安卓开发者为 26 万，苹果开发者为 58 万。9 月份，安卓应用商店在架应用累计下载量 542 亿次。</p><p><span style="color:#888888">附注：</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#888888">1.规模以上互联网和相关服务企业口径由上年互联网和相关服务收入 500 万元以上调整为 2000 万元及以上，文中所有同比增速均按可比口径计算。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#888888">2.活跃的移动应用程序数量是指报告期内我国市场上经过用户主动下载安装的第三方移动应用的总个数，其中安卓应用数的计算方法是根据智能手机记录的已安装移动应用去重后获得。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 10:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264303</guid>
            <link>https://www.oschina.net/news/264303</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[阿里云人工智能 + 大数据平台升级发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>大模型和 MaaS 概念的出现，定义了以模型为中心的一整套 AI 开发新范式，而这背后日益增长的巨大算力需求，对 AI 工程底座提出了新的挑战。今天，大模型时代下的人工智能+大数据平台，需要具备计算效率、开发效率、处理效率为一体的高效能力，才能保障服务 AI 时代下的业务创新。10 月 31 日，2023 云栖大会上，阿里云副总裁、阿里云计算平台事业部负责人汪军华宣布<strong>阿里云人工智能+大数据平台升级发布，以服务大模型时代下各行各业的业务创新</strong>。</p><h2>高性能的 AI 基础设施，让计算效率达到极致</h2><p>根据 OpenAI 测算，全球用于头部 AI 模型训练的算力需求以每年 10 倍的速度增长，计算需求处于持续爆发中。汪军华介绍，PAI 灵骏智算集群在网络、存储、调度上做了深度优化，采用 HPN 7.0 新一代 AI 集群网络架构，存储计算分离架构，<strong>支持高达 10 万卡量级的集群可扩展规模，让超大规模集群像 1 台计算机般运转</strong>。</p><p>软硬一体的智算服务 PAI 灵骏，为大规模深度学习训练场景提供稳定和高效的支撑，大模型训练任务线性加速比可达到 96%，大模型训练资源可节省超 50%。在稳定性保障方面，PAI 灵骏智算服务配置了弹性容错训练框架 AIMaster 和 EasyCkpt 模型自动保存与恢复能力，可让千卡规模任务稳定运行 3 周以上。</p><p>面向大模型的推理服务场景，PAI 体系化地整合模型系统联合优化、运行时优化、LLM 领域优化等能力，可将大语言模型推理吞吐提升 3.5 倍，大幅降低推理时延。单卡推理可支持的最大上下文长度达 280K，超长的上下文推理将进一步推动 LLM 涌现。</p><h2>多形态、更灵活的 AI 开发模式，支撑多样化需求</h2><p>随着需求的不断涌现，AI 开发者和 AI 开发需求越发细分。<strong>人工智能平台 PAI 4.0 发布，全面降低大模型 AI 开发门槛，提供完善的需求支撑，提升开发效率</strong>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3b95e15dfa6b87444fc3e282b13714f002c.jpg" alt="" referrerpolicy="no-referrer"></p><p>不论是需要定义模型结构和开发流程的深度学习开发者群体，还是有海量大规模计算任务的群体，亦或是需要高效快速串联起训练推理任务的业务算法群体，都可以通过 PAI 来实现研发，包含各类热门的计算框架、开源模型和开发场景，一站式地完成开发部署。</p><p>PAI 灵积为广大开发者提供了通过云上 API 服务，可以用于应用模型开发和开发好的模型调用，允许开发者将大模型能力迅速集成到自己的业务和应用中，在 PAI-灵积平台上，开发者不仅可以找到通义系列大模型（包括通义千问，通义万相等等），也可以找到来自业界最优秀的头部大模型，包括 ChatGLM，百川，Stable Diffusion 等。</p><p>汪军华宣布，今天这些模型都<strong>通过 PAI 灵积上统一的 API 和 SDK 对广大开发者开放</strong>，开发者只需要几行代码，就能迅速把这些不同类别的大模型的能力，集成到自己的应用中去。</p><h2>高效的数据服务提升大模型效果，大数据和 AI 更深融合</h2><p>在机器学习开发过程中，80% 的研发时间有用于数据准备，数据质量决定着大模型的效果，数据处理分析的重要性更加凸显。大数据作为 AI 基础设施的一部分，阿里云提供了从数据积累、清洗、建模、计算到服务的全套产品化方案，来节省 AI 开发过程中数据准备的时间。</p><p>同时，大数据和 AI 进行了更深度的融合。阿里云自研大数据处理平台 MaxCompute 全面升级 DataFrame 能力，<strong>发布分布式计算框架 MaxFrame，100% 兼容 Pandas 等数据处理接口</strong>，一行代码即可将原生 Pandas 自动转为 MaxFrame 分布式计算，打通数据管理、大规模数据分析、处理到 ML 开发全流程，打破大数据及 AI 开发使用边界，大大提高开发效率。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1b1ceca672616e6e79a2adf7ef338570215.jpg" alt="" referrerpolicy="no-referrer"></p><p>大模型驱动的 AI 时代，AI 场景对数据时效性的要求也越来越高，Flink+Paimon 新一代实时湖仓方案，为用户提供一站式数据入湖、实时加工和探查分析能力，拓展 Flink 在数据湖场景的实时计算能力，同时加速 AI 应用。</p><p>全托管向量检索服务 DashVector 正式发布，基于阿里云自研 8 年的高性能向量检索内核 Proxima，提供具备水平拓展能力的云原生、全托管的向量检索服务。Hologres、OpenSearch、Elasticsearch 分别升级了向量能力，满足不同场景下性能的提升。全新发布 DataWorks Copilot，将大数据平台的一站式统一元数据、统一调度、统一数据集成、统一数据建模与 AI 大模型能力全面结合， 将 AI 与业务充分融合，创造新价值。</p><p>在面向大模型时代整体大数据 AI 产品能力升级后，汪军华宣布<strong>大数据 AI 产品全面完成 Serverless 化</strong>，致力于给客户提供开箱即用、按需付费的高性价比产品。作为大模型时代 AI 的基础设施，阿里云人工智能+大数据平台将坚定、持续的投入研发资源，服务各行各业的业务创新。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 09:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5583868/blog/10140082</guid>
            <link>https://my.oschina.net/u/5583868/blog/10140082</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[飞致云开源社区 10 月动态报告]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#000000; text-align:start"><span><span style="color:#000000">自 2023 年 6 月起，中国领先的开源软件公司 FIT2CLOUD 飞致云以月度为单位发布《飞致云开源社区月度动态报告》，旨在向广大社区用户同步飞致云旗下系列开源软件的发展情况，以及当月主要的产品新版本发布、社区运营成果等相关信息。</span></span></p><p style="color:#000000; text-align:start"><span><strong><span style="color:#00355d">飞致云开源大屏（2023 年 10 月）</span></strong></span></p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-a09815ae51a7ff491a27bae6b2bf1cdf0c7.png" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:start"><span>▲图 1 飞致云开源大屏（2023.10.31 12:00）</span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">2023 年 10 月飞致云开源软件运营数据概览（统计时间为 2023.10.1～2023.10.31）：</span></span></p><p style="color:#000000; text-align:start"><img alt="" height="782" src="https://oscimg.oschina.net/oscnet/up-04d7820369e349de560cad38d0758a8c526.png" width="1388" referrerpolicy="no-referrer"></p><p style="color:#000000"><strong><span style="color:#3370ff">2023 年 10 月产品发布事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 开源建站工具</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 10 日，Halo 开源建站工具正式发布 v2.10.0 版本。在这个版本中，Halo 主要支持了消息通知、内置应用市场等功能，并且完成了其他 30 多项功能优化和问题修复。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 1Panel 开源面板</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 16 日，现代化、开源的 Linux 服务器运维管理面板 1Panel 正式发布 v1.7.0 版本。</p><p style="color:#000000; text-align:start">在这个版本中，1Panel 新增 Node.js 运行环境；新增系统缓存清理功能；应用安装时支持选择远程数据库。此外，我们进行了 40 多项功能更新和问题修复。1Panel 应用商店新增了 2 款应用，并且更新了 25 款应用。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ JumpServer 开源堡垒机</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 23 日，JumpServer 开源堡垒机正式发布 v3.8.0 版本。</p><p style="color:#000000; text-align:start">在这一版本中，JumpServer 在「用户登录」和「资产登录」这两个权限控制功能中，新增「通知」动作。目前其支持的动作包括拒绝、接受、审批以及通知四种动作，方便了管理员针对不同的用户及资产使用需求进行配置。同时，在使用 KoKo 组件连接字符集类型的资产时，JumpServer 支持持久化主题配置，解决了用户需要经常手动修改主题的问题。</p><p style="color:#000000; text-align:start">作业中心方面，用户执行命令时支持自定义执行目录，方便用户在合适的上下文环境中执行命令。另外，在使用 Web GUI 方式连接数据库时，用户可以对查询集进行保存操作，JumpServer 会对查询集以「CSV」格式下载后提供给用户。</p><p style="color:#000000; text-align:start">X-Pack 增强包方面，JumpServer v3.8.0 版本支持纳管 DB2 数据库（IBM 旗下关系型数据库），方便管理员对此类数据库进行纳管，以满足用户在数据库纳管方面的多样化需求。在之前的版本中，JumpServer 支持在页面上简单对接无认证类型的短信网关。在新版本中，JumpServer 支持用户通过编写自定义短信文件的方式，与用户的短信网关环境进行交互，从而实现发送短信验证的功能。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ MeterSphere 开源持续测试平台</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 30 日，MeterSphere 一站式开源持续测试平台正式发布 v2.10.8 LTS 版本。自 2023 年 5 月发布 v2.10 LTS 版本后，MeterSphere 开源项目组坚持发布小版本，持续进行问题的修复更新，并针对部分功能进行优化。</p><p style="color:#000000; text-align:start">本次发布的 MeterSphere v2.10.8 LTS 版本在性能测试模块对压测报告进行功能增强，同时测试执行机新增运行状态和 CPU 监控。</p><p style="color:#000000"><strong><span style="color:#3370ff">其他重要事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ FIT2CLOUD 飞致云九周年</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 21 日，FIT2CLOUD 飞致云度过了九周岁生日。新的一年，飞致云的口号是「只争朝夕，成为三高」。感谢每一位用户、客户、合作伙伴、员工、股东，我们将加速成长，为数字经济时代创造好软件。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 飞致云及其旗下 1Panel 进入 2023 年第三季度最具成长性开源初创榜单</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 26 日，知名风险投资机构 Runa Capital 发布了 2023 年第三季度 ROSS 指数（Runa Open Source Startup Index）。ROSS 指数按季度汇总并公布在代码托管平台 GitHub 上年化增长率（AGR）排名前二十位的开源初创公司和开源项目。</p><p style="color:#000000; text-align:start">在这份名为《Top trending early-stage open-source startups by GitHub star growth in Q3 2023》的榜单中，FIT2CLOUD 飞致云及其旗下的 1Panel 开源面板项目入选。这也是 FIT2CLOUD 飞致云及其旗下开源项目连续第二个季度进入 ROSS 指数相关榜单。</p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-4e76c989b3aaeb4b049167ebe4867d1f213.png" referrerpolicy="no-referrer"></p><p style="color:#000000">▲图 2 《Top trending early-stage open-source startups by GitHub star growth in Q3 2023》榜单</p><p style="color:#000000; text-align:start"><span><strong><span style="color:#00355d">关于飞致云开源大屏</span></strong></span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">飞致云开源大屏（</span></span><em><span><span style="color:#000000">https://bi.fit2cloud.com/link/6CgpMHrT</span></span></em><span><span style="color:#000000">）</span><span style="color:#3e3e3e">是 FIT2CLOUD 飞致云为展示其旗下开源软件的社区运营情况制作的数据仪表板。该大屏使用 DataEase 开源数据可视化分析平台制作，实时呈现飞致云开源社区近 30 日内的动态信息。</span></span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">广大社区用户可以通过该大屏了解飞致云旗下开源项目的 GitHub Star、Fork、Issue、贡献者等指标的数量信息，以及近 30 日内新增的 Star、Fork、下载、Issue、PR 数量等，同时该大屏还展示了飞致云旗下开源项目的 Issue 趋势、Commit 趋势、PR 趋势、Issue 生命周期等。</span></span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">除了展示所有项目的汇总信息外，该大屏还支持用户分类别查看 JumpServer、DataEase、MeterSphere、Halo、1Panel、CloudExplorer Lite 六个开源项目的独立运营数据。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 08:53:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4736111/blog/10140016</guid>
            <link>https://my.oschina.net/u/4736111/blog/10140016</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[从 0 到 1 入门用户画像掌握大数据技术]]>
            </title>
            <description>
                <![CDATA[<h1 class="header article-title"><a href="https://www.oschina.net/question/4855753_2331281">高手问答第 308 期 ——从 0 到 1 入门用户画像掌握大数据技术</a><div class="ui red label horizontal" data-tooltip="置顶">顶</div></h1><div class="extra ui horizontal list meta-wrap"><div class="item"><a href="https://my.oschina.net/u/4855753" class="__user"><span>OSC 哒哒</span></a><span class="org-label org-label--simple primary" data-tooltip="认证官方账号"><i class="oicon oicon-org"></i></span> 发布于，昨天 12:14
                    </div><div class="item">阅读 1K+</div><div class="item collect-btn " data-id="2331281" data-user-id="4855753" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i> 收藏 <span data-collect-count="" data-id="2331281" data-obj-type="2">5</span></div><div class="item comment-count"><a href="https://www.oschina.net/question/4855753_2331281#comments" class="normal"><i class="comment outline icon"></i> 答案 <span data-article-reply-count="">2</span></a></div></div><div class="tags"><a class="ui horizontal label" href="https://www.oschina.net/question/topic/masteronline" target="_blank"><img src="https://static.oschina.net/uploads/logo/masteronline_9WTeU.png" referrerpolicy="no-referrer">高手问答</a></div><div class="content" id="articleContent"><div><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>市面上不少公司都在做用户画像的相关工作，无论是电商行业、金融行业、视频行业等等，都有这样的产品。那到底怎么去定义用户画像呢？</span></span></span></span></span></span></span></span></span></span></span></div><div>
  &nbsp; 
</div><div><strong>OSCHINA 本期高手问答 (10 月 31 日 - 11 月 6 日) 我们请来</strong><strong>了嘉宾&nbsp;</strong><strong><span style="color:#000000"><a href="https://my.oschina.net/u/4294800" rel="nofollow">诸葛子房</a>老师&nbsp;</span></strong><strong>来和大家一起探讨关于从 0 到 1 入门用户画像掌握大数据技术的问题。</strong></div><div>
  &nbsp; 
</div><div><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>可讨论的问题包括但不限于：</span></span></span></span></span></span></span></span></span></span></span></p><ul><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>想入门用户画像需要掌握哪些技术栈？</span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>没有企业的大量用户或者行为数据，普通用户该如何真实地模拟企业级的画像项目？</span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>程序员如何入门大数据？</span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>大数据</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>行业都有哪些职位，以及在公司中发挥的作用如何</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>？</span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>大数据行业未来的发展如何，以 ChatGPT&nbsp;为代表的 AI 浪潮是否会让大数据行业走向</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>没落</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>？</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>有其他相关问题，也欢迎大家积极提问！</span></span></span></span></span></span></span></span></span></span></span></p><hr><h2>嘉宾介绍</h2><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>段小秋，网名：诸葛子房，先后就职于京东和 BAT，在大数据领域有多年工作经验，也是多个 Apache&nbsp;项目的贡献者。蓝桥杯蓝桥云课《用户画像案例精讲》专栏作者，也是开源项目 DataCompare&nbsp;作者。</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>微信</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>：zhugezifang001，欢迎交流沟通。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>个人</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>主页：</span></span></span></span></span></span></span></span><a href="https://gitee.com/ZhuGeZiFang" rel="nofollow"><span><span><span><u><span style="color:#1e6fff"><span><span>https://gitee.com/ZhuGeZiFang</span></span></span></u></span></span></span></a></span></span></span></p><p><img height="639" src="https://oscimg.oschina.net/oscnet/up-5e58f5cf142af8e6ec1a3b8c3dc1cef16ec.png" width="500" referrerpolicy="no-referrer"></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>为了鼓励踊跃提问，会在问答结束后从提问者中抽取&nbsp;5&nbsp;名幸运会员赠予《</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>用户画像案例精讲》专栏电子版！</span></span></span></span></span></span></span></span></span></span></span></p><p><img height="516" src="https://oscimg.oschina.net/oscnet/up-71771b786f7cc1bd0161793b6af70daf066.png" width="310" referrerpolicy="no-referrer"></p><p><img height="574" src="https://oscimg.oschina.net/oscnet/up-c2d9d9ce8dd66a412d3ef791ee45548dc45.png" width="311" referrerpolicy="no-referrer"></p></div><div><div><hr><h4><span><span><span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>用户</span></span></span></span></strong></span></span></span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>画像概念</span></span></span></span></strong></span></span></span></span></span></span></h4><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>用户画像，即：用标签的方式去描述一个人或者一台手机、一台电脑，有些公司称之为」用户画像「，有一些公司称之为」用户特征「，其实是一个意思。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>举个简单的例子：</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>袁小青，性别：女，年龄：22 岁，职业：时尚编辑，爱好：音乐、拍照，居住地：北京，消费情况：年薪 10w，喜欢的 app：抖音</span></span></span></span></span></span></span></span></span></span></span></p><p><img height="310" src="https://oscimg.oschina.net/oscnet/up-d3e2ad6f2150ece5dd0882380562cb797a7.png" width="488" referrerpolicy="no-referrer"></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>因此我们概念中描述的用户画像，其实是用标签的方式对于一个用户、一个账号、一部手机进行描述。</span></span></span></span></span></span></span></span></span></span></span></p><p><img height="368" src="https://oscimg.oschina.net/oscnet/up-adc4c1c21829279233af14e8d74631dfab4.png" width="400" referrerpolicy="no-referrer"></p><h4><span><span><span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>用户画像常见标签</span></span></span></span></strong></span></span></span></span></span></span></h4><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>既然上面讲到了对于用户进行标签化，那究竟要给用户打哪些标签呢？如何对标签进行分类呢？</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>用户</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>画像核心标签以及其分类：</span></span></span></span></span></span></span></span></span></span></span></p><p><img height="589" src="https://oscimg.oschina.net/oscnet/up-9efa6c4c17cb0bd2647c8d303db9def85cc.png" width="868" referrerpolicy="no-referrer"></p><h4><span><span><span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>用户画像的作用</span></span></span></span></strong></span></span></span></span></span></span></h4><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>1. 个性化推荐</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>在使用一些社区产品、电商产品、短视频 app、音乐 app 的时候，经常会遇到推荐的场景，根据不同的人推荐不同的内容或者商品。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>这其实是用户画像其中的一个应用，根据用户查询用户的标签数据，来进行推荐用户感兴趣的内容</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>2. 营销圈选 (短信营销、PUSH 营销)</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>相信不少用户收到过类似的营销短信，或者一些 app&nbsp;弹窗，这个也是用户画像常见的应用场景</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>3. 策略引擎</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>根据用户的标签展示不同页面，比如说：北京地区的用户能才能领取北京的优惠券，以及只有高消费值的用户才有淘宝上奢侈品 Luxury 入口的界面。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>4. 算法模型</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>算法模型的训练，比如说：推荐模型、广告模型，需要用到画像数据来优化推荐模型。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>5. 画像报告</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>不少商业公司会出一些行业报告，比如说下图的小红书、锁屏 app&nbsp;的行业画像报告；还有我们经常看到的一些个人年度榜单。</span></span></span></span></span></span></span></span></span></span></span></p><h4><span><span><span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>大数据技术在用户画像中的实际应用</span></span></span></span></strong></span></span></span></span></span></span></h4><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>由于</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>画像涉及到的一些行为数据，包括用户购物行为、观影行为，一些较为大型一些的公司数据日均都涉及 PB，因此需要处理的数据量非常大。在其中就会用到一些大数据的处理和存储技术，比如说：Hadoop、Spark、Hbase&nbsp;等等。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>同时随着业务发展，一些广告和推荐场景对于实时需求也更加明显，所以实时数据处理领域，Flink、Kafka 等实时相关技术领域也越来越重要了。</span></span></span></span></span></span></span></span></span></span></span></p><hr><div><p><span style="background-color:#ffffff; color:#27ae60">OSChina 高手问答一贯的风格，不欢迎任何与主题无关的讨论和喷子。</span></p><p>下面欢迎大家就<span>用户画像和大数据技术相关</span>问题向&nbsp;<strong><span style="color:#000000"><a href="https://my.oschina.net/u/4294800" rel="nofollow">诸葛子房</a></span></strong><span style="color:#000000">老师</span><strong><span style="color:#000000">&nbsp;</span></strong>提问，直接回帖提问既可。</p></div></div></div></div><div class="poll-wrap"></div><div class="additional-remarks"></div><div class="ui basic center aligned segment action"><div class="ui big buttons"><a class="ui basic button collect-btn hover" data-id="2331281" data-user-id="4855753" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i>收藏 (<span data-collect-count="" data-id="2331281" data-obj-type="2">5</span>)</a><div class="ui basic dropdown share button osc-share dropdown-share" data-tag="share-question"><i class="share icon"></i><span>分享</span><div class="menu"><a class="item" data-platform="weibo" data-value="weibo"><i class="weibo icon"></i>微博</a><a class="item" data-platform="qq" data-value="qq"><i class="qq icon"></i>QQ</a><a class="item" data-platform="wechat" data-value="wechat"><i class="weixin icon"></i>微信</a></div></div></div><div class="ui basic segment"><a class="ban" ban-report="" data-id="2331281" data-obj-type="2" data-url="https://www.oschina.net/question/4855753_2331281"><i class="flag red icon"></i>举报</a></div></div>
            ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 08:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/question/4855753_2331281</guid>
            <link>https://www.oschina.net/question/4855753_2331281</link>
        </item>
        <item>
            <title>
                <![CDATA[周热点 | jQuery 4.0 开发进度已完成 99%；小米澎湃 OS 发布，底层全部重构；Windows CE 彻底退役]]>
            </title>
            <description>
                <![CDATA[回顾一周热门资讯。2023.10.23-2023.10.30]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 08:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649093911&#38;idx=1&#38;sn=38b44f9a65152bbed03e505898027c84&#38;chksm=880c4c04bf7bc5125fe5e1f37886dd58c9c3f9f4b518505968df48e895efa0321de097a67ea3&#38;token=1144339677&#38;lang=zh_CN#rd</guid>
            <link>https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649093911&#38;idx=1&#38;sn=38b44f9a65152bbed03e505898027c84&#38;chksm=880c4c04bf7bc5125fe5e1f37886dd58c9c3f9f4b518505968df48e895efa0321de097a67ea3&#38;token=1144339677&#38;lang=zh_CN#rd</link>
        </item>
    </channel>
</rss>
