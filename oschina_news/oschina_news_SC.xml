<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>开源中国-最新资讯</title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://rsshub.app/oschina/news" rel="self" type="application/rss+xml"></atom:link>
        <description>开源中国-最新资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)</description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>en</language>
        <lastBuildDate>Wed, 27 Mar 2024 16:15:47 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>武汉大学开设「雷军班」：计算机专业、今年招收 15 名本科生</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;3 月 25 日，武汉大学官网对校长张平文调研计算机学院进行了报道，文章提到：「就雷军班和机器人系建设方面，张平文希望学院提高站位、布局未来，发挥雷军校友捐赠的重要作用，凝心聚力早日把计算机学院建成国内知名、世界一流的学术高地。」&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-10c5c2cfd163009c4db026c83070c834fad.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;不少网友好奇，雷军班是个什么情况，跟企业家雷军有什么关系？&lt;/p&gt; 
&lt;p&gt;3 月 27 日，武汉大学计算机学院办公室工作人员回应记者称：「&lt;strong&gt;在今年高考后，雷军班将向全国招 15 名本科生，属于计算机专业，吸纳最优秀的有志向的学生就读，本博贯通培养。&lt;/strong&gt;」&lt;/p&gt; 
&lt;p&gt;工作人员强调：「与其他普通本科班相比，这个班肯定是不一样的。整个培养方面的各个环节都是高配置。」&lt;/p&gt; 
&lt;p&gt;另据武汉大学计算机学院官网 1 月 8 日报道，计算机学院院长杜博曾表示，「雷军校友捐赠除了助力基础学科研究和支持大学生培养，主要资助计算机学科发展和计算机领域科技创新。学院将加强师资力量，传承人才培养优良传统，发扬雷军的创新精神，设立雷军班，把有计算机天赋和有创新、创意、创业的优秀人才招进来。」&lt;/p&gt; 
&lt;p&gt;武汉大学是小米创始人雷军的母校，他在去年 11 月 29 日的武汉大学 130 周年校庆日上宣布，&lt;strong&gt;个人向母校捐赠 13 亿元人民币，刷新武大建校以来单笔最大捐赠额。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ddcdda06e0737310208f9c2696171fdb78b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;当时雷军表示，此次捐赠主要聚焦三个方向：支持数理化文史哲六大学科基础研究、支持计算机领域科技创新、支持大学生培养。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284988</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284988</guid>
            <pubDate>Wed, 27 Mar 2024 08:35:37 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>微软任命新的 Windows 和 Surface 负责人</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;微软任命 Pavan Davuluri 为新任 Windows 和 Surface 主管。去年，在前负责人&amp;nbsp;Panos Panay 跳槽前往亚马逊之后，微软就将 Windows 和 Surface 部门拆分为两个不同的领导团队；由&amp;nbsp;Davuluri 接管了 Surface 相关工作，Windows 方面则由 Mikhail Parakhin 进行领导。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;时至今日，该公司又将 Windows 和 Surface 整合，统一交由都将由 Davuluri 负责。微软体验和设备执行副总裁 Rajesh Jha 在一份内部备忘录中&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2024%2F3%2F25%2F24111931%2Fmicrosoft-windows-surface-pavan-davuluri&quot; target=&quot;_blank&quot;&gt;解释称&lt;/a&gt;，因为 Parakhin 现在正在&quot;探索新的角色&quot;，但他并没有有明确指出是在微软内部还是外部。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Jha 在备忘录中概述了新的 Windows 组织架构。指出 Davuluri 将领导一个合并的 Windows 和设备团队，作为 Experiences + Devices (E+D) 部门的&quot;核心部分&quot;。「这将使我们能够采取整体方法来构建跨 Windows 客户端和云的芯片、系统、体验和设备，以适应这个 AI 时代。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;333&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-90467fe07ce648d6b571892737ebc09c654.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;以下是 Rajesh Jha 的备忘录全文：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;我想分享继上周宣布并创建 Microsoft AI 组织之后 Windows 和 Web Experiences (WWE) 团队的最新动态。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Mikhail Parakhin 决定探索新角色。Satya 和我对 Mikhail 的贡献和领导表示感谢，并感谢他为帮助微软引领新人工智能浪潮所做的一切。他将向 Kevin Scott 汇报工作，同时支持 WWE 的过渡。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;作为此变更的一部分，我们将 Windows Experiences 和 Windows + Devices 团队合并为 Experiences + Devices (E+D) 部门的核心部分。这将使我们能够采取整体方法来构建这个人工智能时代跨越 Windows 客户端和云的芯片、系统、体验和设备。 Pavan Davuluri 将领导这个团队并继续向我汇报。 Shilpa Ranganathan 和 Jeff Johnson 及其团队将直接向 Pavan 汇报。 Windows 团队将继续与 Microsoft AI 团队在 AI、芯片和体验方面密切合作。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Web Experiences 团队将向新的 Microsoft AI 组织中的 Mustafa 汇报工作。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Jordi Ribas 将领导搜索、地图和平台业务，Andrey Proskurin、Fatima Kardar 和 Nick Lee 向他汇报。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Rukmini Iyer 将领导广告部，Paul Viola 和 Weiqing Tu 向她汇报。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Mike Davidson 继续领导设计部门，并将与 Pavan 和团队合作研究如何重新调整 Windows 设计。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Ali Akgun、Kya Sainsbury-Carter、Zhang Qi 和 Rajesh Sundaram 的角色保持不变。他们将与 Jordi、Mike 和 Rukmini 一起加入 Microsoft AI 领导团队，全部向 Mustafa 汇报。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;我们很高兴这个团队能够帮助 Microsoft AI 实现其打造世界一流的消费者 AI 产品的大胆雄心。我非常期待与 Mustafa 及其团队密切合作，将包括 Copilot 在内的 AI 产品广泛应用于我们的 E+D 产品和服务中。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Thanks,&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Rajesh&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284970/microsoft-windows-surface-pavan-davuluri</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284970/microsoft-windows-surface-pavan-davuluri</guid>
            <pubDate>Wed, 27 Mar 2024 07:39:43 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Podman 5.0 正式发布</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Podman 5.0 已正式发布。新版本针对&amp;nbsp;Windows 和 Mac 平台完全重写了代码，并对这两个平台上的虚拟机管理程序支持进行了重大改进。&lt;/p&gt; 
&lt;p&gt;Podman 5.0 的一大亮点是对&lt;code&gt;podman machine&lt;/code&gt;命令的彻底重写。该功能允许用户在 Windows 和 Mac 系统上启动 Linux 虚拟机，使他们能够无缝运行 Linux 容器。&lt;/p&gt; 
&lt;p&gt;重写不仅提高了性能和稳定性，还增强了跨不同 VM 提供商的代码共享，简化了未来的维护和升级。此外，引入了对 Mac 上 Apple 虚拟化程序的支持，显著提升了稳定性、启动时间和文件共享性能。&lt;/p&gt; 
&lt;p&gt;一个值得注意的方便功能是新的&lt;code&gt;podman machine reset&lt;/code&gt;命令，使删除由 Podman 管理的虚拟机比以往更容易。此外，这个版本改进了对&lt;code&gt;containers.conf&lt;/code&gt;配置文件的处理，确保用户的修改得到保留。&lt;/p&gt; 
&lt;p&gt;Podman 5.0 还带来了显著的变化和弃用，以提升用户体验。一个关键更新是将 Pasta 作为无根网络的默认后端，这个决定是由于其出色的性能。&lt;/p&gt; 
&lt;p&gt;在 Podman 4.9 版本中，已经开始将 BoltDB 数据库后端改为 SQLite，现在这个决定已经得到了巩固，为新安装提供了增强的稳定性。&lt;/p&gt; 
&lt;p&gt;Podman 5 的网络变化也值得注意。大多数平台不再支持 CNI 网络，而是使用 Netavark，Podman 自己的网络堆栈，承诺满足或超越 CNI 的能力。&lt;/p&gt; 
&lt;p&gt;另一个重要的改进领域是 Docker 兼容性。Podman 5.0 引入了几项调整，以确保与 Docker 的互操作性更加顺畅，例如修改 podman inspect 的输出，使其与 Docker 的对应版本更加接近。&lt;/p&gt; 
&lt;p&gt;此外，Podman 5.0 不再支持 cgroups v1，为未来在没有 cgroups v2 的系统上运行不再可能铺平了道路，进一步与现代 Linux 发行版对安全性和资源管理的关注保持一致。&lt;/p&gt; 
&lt;p&gt;详情查看 &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.podman.io%2F2024%2F03%2Fpodman-5-0-has-been-released%2F&quot; target=&quot;_blank&quot;&gt;发布公告&lt;/a&gt;&lt;/u&gt;。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284955/podman-5-0-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284955/podman-5-0-released</guid>
            <pubDate>Wed, 27 Mar 2024 06:56:19 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>日本政府称有朝鲜 IT 人员冒充日本人接外包赚外汇</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;日本政府 26 日发布了一份提醒国内 IT 相关企业注意的文件，指出疑似有朝鲜 IT 技术人员冒充日本人，在网上承接 IT 相关业务订单。联合国等表示，为了赚取外汇用于核与导弹开发，朝鲜正在利用技术人员。据称，若把业务发包给此类人员，可能违反《外汇法》等。&lt;/p&gt; 
&lt;p&gt;文件由警察厅、外务省、财务省、经济产业省联名发布。美国和韩国去年 10 月发出了类似提醒，日本则是首次。警察厅干部透露称「在日本也发现了案例，威胁高涨」。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2023/1023/112217_pba9_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;该文件等显示，朝鲜技术人员在为 IT 相关业务发包方和自由技术人员提供中介服务的网站上，或者伪造身份，或者通过住在日本的亲戚等进行注册。据称，他们大多在中国和俄罗斯工作并赚取报酬。&lt;strong&gt;其特点包括不参加视频会议、频繁变更收款账户、使用的日语不地道等&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;在日本，神奈川县警方等 6 日以涉嫌违规领取失业补贴为由，逮捕了广岛县 IT 相关公司社长等人。警方认为其有可能把业务发包给了朝鲜技术人员，正在查明案情。神奈川县警方的调查中还发现，2022 年，另外的朝鲜技术人员以熟人名义承接了兵库县防灾 APP 修改业务等。&lt;/p&gt; 
&lt;p&gt;延伸阅读：&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/news/262984/north-korea-it-workers-remote-work&quot; target=&quot;_blank&quot;&gt;朝鲜 IT 开发者为美国公司从事远程外包工作&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284953</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284953</guid>
            <pubDate>Wed, 27 Mar 2024 06:44:13 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>Linux 6.9 弃用 ext2 文件系统驱动程序</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在即将发布的 6.9 Linux 内核中，ext2 文件系统驱动程序将被标记为已&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Fcommit%2F%3Fid%3Db960e8093e7a57de98724931d17b2fa86ff1105f&quot; target=&quot;_blank&quot;&gt;弃用&lt;/a&gt;。EXT2 第二代扩展文件系统是 Linux 内核所用的文件系统，最开始由 Rémy Card 设计用以代替 ext，于 1993 年 1 月加入 Linux 核心支持之中，至今已有三十多年的历史。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Linux 开发人员 Michael Opdenacker 解释称，ext2 被弃用的主要原因在于，即使文件系统是用 256 字节的 inodes（mkfs.ext2 -I 256）创建的，文件系统驱动程序也会坚持使用 32 位日期。因此，驱动程序不支持超过 2038 年 1 月 19 日 03:14:07 UTC 的 inode 时间戳。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;对于仍在使用 ext2 及其驱动程序，并且系统日期正确设置为截止日期之前最多 30 年的日期的用户，将收到此警告：&lt;/span&gt;&lt;/p&gt; 
&lt;pre style=&quot;margin-left:0; margin-right:0; text-align:start&quot;&gt;# mount -t ext2 /dev/sda1 /mnt
[  441.680685] ext2 filesystem being mounted at /mnt supports timestamps until 2038-01-19 (ox7fffffff)&lt;/pre&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;由于无法正确支持 2038 年 1 月 19 日之后的时间戳。官方建议 ext2 用户升级到使用 ext4 驱动程序来访问其文件系统，ext4 文件系统驱动程序与 ext2 完全兼容。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;416&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-9b1cc7bffe503a4e97379da4df9747b64d9.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;更多详情可查看此&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbootlin.com%2Fblog%2Fext2-filesystem-driver-now-marked-as-deprecated%2F&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284942/ext2-deprecat-linux-6-9</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284942/ext2-deprecat-linux-6-9</guid>
            <pubDate>Wed, 27 Mar 2024 05:50:46 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>开源日报 | AI PC 的价值到底在哪？Windows 格式化对话框的 UI 用了 30 年；丑头像生成器；独立的 Redis Copyleft 分支</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;欢迎阅读 OSCHINA 编辑部出品的开源日报，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#e67e22&quot;&gt;&lt;strong&gt;# 2024.3.26&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日要点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;OpenSource Daily&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284729/inkscape-switches-to-gtk4&quot; target=&quot;_blank&quot;&gt;开源图形编辑器 Inkscape 底层 UI 框架改用 GTK4&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;矢量图形编辑器 Inkscape 开发分支的最新上游代码已迁移至使用 GTK4，这是一次重大升级，同时也改进了架构，并为将来实现 GPU 加速做好了准备。&lt;/p&gt; 
&lt;p&gt;Inkscape 通过其 Mastodon 账户宣布了向 GTK4 过渡的消息。由于各种问题，尤其是在 macOS 和 Windows 上的问题，下一个稳定版本（v1.4）仍将使用 GTK3。&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284749/redict-independent-fork-redis&quot; target=&quot;_blank&quot;&gt;Redict：一个独立的 Redis Copyleft 分支&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;Redict 是由开发者 Drew DeVault 推出的一个 Redis OSS 7.2.4.2 的独立、非商业性的分叉。基于 Redis OSS 的 BSD 3-Clause 源代码，自此之后的所有更改均采用 Lesser GNU General Public license（LGPL-3.0-only）。&lt;/p&gt; 
&lt;p&gt;Redict 旨在作为 Redis OSS 7.2.4 的直接替代品。接下来，Redict 的目的是继续开发 Redis OSS 兼容软件的自由软件发行版，暂时只进行最小程度的破坏性更改。&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日观察&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img height=&quot;1142&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-720920b89166e12e4474df21d15cdb13e1d.png&quot; width=&quot;3290&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- &lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sohu.com%2Fa%2F766955186_166680&quot; target=&quot;_blank&quot;&gt;集微网&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-df160bed3a4a1edeecfaf0ea94367e6ffce.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微博&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1834645454%2FO6OaUrIXM&quot; target=&quot;_blank&quot;&gt;dingtingli&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;今日推荐&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-3dd733b17408eabbeef0376a1b161484ca2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ftxstc55%2Fugly-avatar&quot; target=&quot;_blank&quot;&gt;https://github.com/txstc55/ugly-avatar&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;事件点评&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-bce40dbed054e00f3808407c9d3f805a8b7.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;每日项目榜&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;每日 GitHub 精选&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-4f54b79a6c20ed322ca67c7d78f425b439b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;在线阅读完整日报内容，访问：&lt;/span&gt;&lt;/strong&gt;&lt;br&gt; &lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://report.oschina.net/api/files/jhim80u9qm1ofsw/sq4hlnesqz46pu8/37_ai_pc_windows_ui_30_redis_copyleft_jwb07bWFPR.pdf&quot; target=&quot;_blank&quot;&gt;开源日报第 037 期：AI PC 的价值到底在哪？Windows 格式化对话框的 UI 用了 30 年；丑头像生成器；独立的 Redis Copyleft 分支&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/h4&gt; 
&lt;/blockquote&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;欢迎扫码下载「开源中国 APP」&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;随时在线阅读完整日报内容 ↓&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7871d27245192b8ecfcd21043d309382749.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;889&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-842e51ced6d226559af1af95c8041338cb2.gif&quot; width=&quot;400&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284926</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284926</guid>
            <pubDate>Wed, 27 Mar 2024 03:28:20 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>罗永浩本周日晚将首度直播卖「云」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;阿里云官微宣布，罗永浩将于 3 月 31 日晚首次淘宝直播卖云，选品涵盖云服务器、云存储及企业网盘等热门阿里云产品，重点面向创业者及中小企业群体。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;475&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d2c9f7747404286dff54e6e9df56b4abb39.webp&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此前的 2 月 29 日，阿里云宣布全线降价 20%。根据阿里云官网报价数据显示，降价清单中的云服务器 ECS 最高降 36%、对象存储 OSS 最高降 55%、云数据库 RDS 最高降 40%，都是云上用户使用频率最高的核心产品。此次史上最大规模降价引发了一波中小企业上云热潮。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;最近披露的财报显示，阿里云正通过减少利润率较低的项目制合约类收入，持续提高收入质量。阿里云智能集团资深副总裁、公共云事业部总裁刘伟光此前表示，阿里云期待与行业共同铸造中国云计算产业的规模效应。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284923</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284923</guid>
            <pubDate>Wed, 27 Mar 2024 03:10:20 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>egui 0.27 发布，面向 Web 和原生应用的 Rust GUI 库</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;egui 是易于使用、可移植的即时模式 (immediate mode) GUI 库，采用 Rust 编写，提供了一种简单而直观的方式来创建图形用户界面，并且可运行在 Web 和原生应用中。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-051b7caef2c757433d4cec01c2d77678d2d.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在线体验：&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.egui.rs%2F&quot;&gt;https://www.egui.rs/&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;最新发布的&amp;nbsp;egui 0.27 主要变化：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;重写点击测试逻辑 (hit test logic)&lt;/li&gt; 
 &lt;li&gt;改进菜单&lt;/li&gt; 
 &lt;li&gt;优化阴影效果&lt;br&gt; &lt;br&gt; &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-5a9a8b855f8845b5649f1fa05ed61e55018.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;br&gt; &amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;支持与 UI 在后台进行交互&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Femilk%2Fegui%2Freleases%2Ftag%2F0.27.0&quot; style=&quot;font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Apple Color Emoji&amp;quot;, &amp;quot;Segoe UI Emoji&amp;quot;, &amp;quot;Segoe UI Symbol&amp;quot;, &amp;quot;Segoe UI&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif;&quot; target=&quot;_blank&quot;&gt;详情查看 Release Notes&lt;/a&gt;&lt;span style=&quot;font-family:-apple-system,BlinkMacSystemFont,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;,&amp;quot;Segoe UI&amp;quot;,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;Helvetica Neue&amp;quot;,Helvetica,Arial,sans-serif&quot;&gt;。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284915/egui-0-27-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284915/egui-0-27-released</guid>
            <pubDate>Wed, 27 Mar 2024 02:33:31 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Zstd 1.5.6 发布，Chrome 已支持 Zstandard 编码</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Zstd 1.5.6 已发布。此次发布的部分原因是 Chrome 123 添加了对 Web 流量的 Zstd 编码支持。Chrome 现在支持使用 Zstandard (zstd) 作为内容编码，以加快页面加载速度并节省带宽。&lt;/p&gt; 
&lt;p&gt;虽然 Chrome 支持 Zstd 编码是件好事，但目前 Web 服务器对 Zstd 编码的支持还很有限。Zstd 团队希望 1.5.6 发布后，新版本能得到更多 Web 浏览器的采用，并继续得到其他软件的支持。&lt;/p&gt; 
&lt;p&gt;Zstd 1.5.6 还添加了一个新的稳定参数&quot;ZSTD_c_targetCBlockSize&quot;，以更好地处理 Web 浏览器中的增量更新、细粒度二进制大小选择以及其他各种增强功能。&lt;/p&gt; 
&lt;p&gt;Zstd 1.5.6 现在还能更好地支持 SPARC64、ARM64EC 和 RISC-V 架构，以及 QNX、AIX、Solaris 和 HP-UX 操作系统。&lt;/p&gt; 
&lt;p&gt;详情查看&amp;nbsp;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffacebook%2Fzstd%2Freleases%2Ftag%2Fv1.5.6&quot; target=&quot;_blank&quot;&gt;Release Notes&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284909/zstd-1-5-6-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284909/zstd-1-5-6-released</guid>
            <pubDate>Wed, 27 Mar 2024 02:16:31 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>适用于原生 Arm64 设备的 Chrome 即将发布</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;谷歌与高通公司（Qualcomm）共同&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2024%2F3%2F26%2F24112273%2Fchrome-native-windows-on-arm-qualcomm-snapdragon&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;，将于本周发布针对 Windows on Arm 的 Chrome 浏览器优化版。事实上早在两个月前，就曾有用户在 Chrome 浏览器的 Canary 频道发现过该浏览器的早期版本，现如今谷歌终于正式将其正式推出。高通公司表示，该版本&quot;将从今天开始推出&quot;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;292&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-6bba083617132dcd93860160703973230b4.webp&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;对于使用基于 Arm 处理器的 Windows 机器的 Chrome 浏览器用户来说，该版本的发布将是一件大事，因为他们现在可以使用速度更快的原生浏览器了。相比之下，他们以前只能在模拟状态下运行性能缓慢的 x64 版 Chrome 浏览器。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;高通最新推出的基于 Arm 的 Windows 处理器被称为骁龙 X Elite（Snapdragon X Elite），预计将于今年夏天上市，据称将带来不俗的性能表现。谷歌经过 Arm 优化的 Chrome 浏览器在技术上可以在任何基于 Arm 的 Windows PC 上运行，与处理器制造商无关，但高通公司是目前唯一一家为 Windows 生产基于 Arm 处理器的公司。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;谷歌公司的 Hiroshi Lockheimer 表示：「我们设计的 Chrome 浏览器快速、安全且易于在台式机和移动终端上使用。我们与高通公司的密切合作将有助于确保 Chrome 浏览器用户在当前 Arm 兼容 PC 上浏览网页时获得最佳体验。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;这并不是谷歌第一次发布经过 Arm 优化的 Chrome 浏览器版本，早在 2020 年，谷歌就为苹果基于 Arm 的 Mac 发布了原生版本的浏览器。长期以来，这家搜索巨头还在 ChromeOS 中为 Chromebook 提供基于 Arm 处理器的支持。但是，在以消费者为中心的 Surface 设备有望全面转向 Arm 的这一年，为 Windows 发布基于 Arm 的世界上最流行的 Windows 浏览器原生版本，将极大地推动 Windows on Arm 的发展。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284903/chrome-native-arm-based-windows-pc</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284903/chrome-native-arm-based-windows-pc</guid>
            <pubDate>Wed, 27 Mar 2024 02:03:39 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>Java 8 内存管理原理解析及内存故障排查实践</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                    &lt;div class=&quot;rich_media_content js_underline_content
                       autoTypeSetting24psection
            &quot; id=&quot;js_content&quot;&gt; 
 &lt;section style=&quot;font-size: 15px;line-height: 1.6;&quot;&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;作者：vivo 互联网服务器团队-&amp;nbsp; Zeng Zhibin&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;&quot;&gt; 
    &lt;section style=&quot;text-align: left;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);&quot;&gt; 
      &lt;p style=&quot;text-wrap: wrap;&quot;&gt;介绍 Java8 虚拟机的内存区域划分、内存垃圾回收工作原理解析、虚拟机内存分配配置，介绍各垃圾收集器优缺点及场景应用、实践内存故障场景排查诊断，方便读者面临内存故障时有一个明确的思路和方向。&lt;/p&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
    &lt;section style=&quot;margin-right: 0%;margin-bottom: -5px;margin-left: 0%;text-align: right;line-height: 1;font-size: 5px;transform: translate3d(5px, 0px, 0px);&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;width: 0px;display: inline-block;vertical-align: top;border-bottom: 0.6em solid rgb(160, 160, 160);border-right: 0.6em solid rgb(160, 160, 160);border-top: 0.6em solid transparent !important;border-left: 0.6em solid transparent !important;&quot;&gt; 
      &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;一、背景&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 是一种流行的编程语言，可以在不同的操作系统上运行。它具有跨平台、面向对象、自动内存管理等特点，Java 程序在运行时需要使用内存来存储数据和程序状态。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 的自动内存管理机制是由 JVM 中的垃圾收集器来实现的，垃圾收集器会定期扫描堆内存中的对象，检测并清除不再使用的对象，以释放内存资源。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 的自动内存管理机制带来了许多好处，首先，它可以避免程序员手动管理内存时的错误，例如内存泄漏和悬空指针等问题。其次，它可以提高程序的运行效率，因为程序员不需要频繁地手动分配和释放内存，而是可以将更多时间和精力专注于程序的业务逻辑，最后，它可以提高程序的可靠性和稳定性，因为垃圾收集器可以自动检测和清除不再使用的内存资源，避免内存溢出等问题。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;了解和掌握垃圾收集器原理可以帮助提高程序的性能、稳定性和可维护性。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;font-size: 14px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;名词解释：&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;响应速度&lt;/strong&gt;：响应速度指程序或系统对一个请求的响应有多迅速。比如，用户查询数据响应时间，对响应速度要求很高的系统，较大的停顿时间是不可接受的。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;：吞吐量关注在一个特定时间段内应用系统的最大工作量，例如每小时批处理系统能完成的任务数量，在吞吐量方面优化的系统，较长的 GC 停顿时间也是可以接受的，因为高吞吐量应用更关心的是如何尽可能快地完成整个任务，不考虑快速响应用户请求。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;GC 导致的应用暂停时间影响系统响应速度，GC 处理线程的 CPU 使用率影响系统吞吐量。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;二、Java&amp;nbsp;8&amp;nbsp;的内存管理&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;2.1 JVM（Java 虚拟机）内存划分&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 运行时数据区域划分，Java 虚拟机在执行 Java 程序时，将其所管理的内存划分为不同的数据区域，每个区域都有特定的用途和创建销毁的时间。其中，有些区域在虚拟机进程启动时就存在，而有些区域则是随着用户线程的启动和结束而建立和销毁。这些数据区域包括程序计数器、虚拟机栈、本地方法栈、堆、方法区等，每个区域都有其自身的特点和作用。了解这些数据区域的使用方式和特点，可以更好地理解 Java 虚拟机的内存管理机制和运行原理。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;JVM 的内存区域划分可分为：1.堆内存空间、2.Java 虚拟机栈区域、3.程序计数器、4.本地方法栈、5.元空间区域、6.直接内存。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014615&quot; data-ratio=&quot;0.774074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/1e56b454-4e41-465a-8ba6-8c53e10fc02c.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014616&quot; data-ratio=&quot;0.9365079365079365&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/ec4c9ff4-4b80-46ad-aff9-ce2ce396b38b.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1008&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;堆内存空间&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;：JVM 中占用内存空间最大的是堆，平常对象的创建大部分都是在堆上分配内存的，是垃圾回收的主要目标和方向。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;本地方法栈区域&lt;/strong&gt;：Native Mehod Stack 与 Java 虚拟机栈的作用非常相似，区别是 Java 虚拟机栈为虚拟机执行 Java 方法或者为字节码而服务，本地方法栈是为了 Java 虚拟机栈得到 Native 方法。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;Java 虚拟机栈区域&lt;/strong&gt;：负责 Java 的解释过程、程序的执行过程、入栈和出栈，它是与线程相关的，当启动一个新的线程时，Java 程序就会分配一个 Java 虚拟机栈提供运行；Java 虚拟机栈从方法入栈到具体字节码执行是一个双层栈结构，可以栈里包含栈。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;：记录线程执行位置，线程私有，因为操作系统不停的调度，无法获取到线程被调度之前的位置，程序计数器提供了这样一个线程执行位置。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;元空间区域&lt;/strong&gt;：在原来的老的 Java 7 之前划分中，永久代用来存放类的元数据信息、静态变量以及常量池等。在现在 Java8 后类的元信息存储在元空间中，静态变量和常量池等并入堆中，相当于原来的永久代中的数据，被元空间和堆内存给瓜分了。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;直接内存&lt;/strong&gt;：使用了 Java 的直接内存的 API 的内存，例如缓冲 ByteBuffer，可以控制虚拟机参数调整大小，而本地内存是使用了 native 函数操作的内存，是不受 JVM 管理控制。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;堆内存空间&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;JVM 回收的主要目标是堆内存，对象主要的创建分配内存在堆上进行，堆可以想象成一个对象池子，对象不停创建放入池子中，而 JVM 垃圾回收是不停的回收池子中一些被标记为可回收对象的对象，启动回收线程进行打扫战场，当回收对象的速度赶不上程序的创建时，池子就会立马满，当满了之后从而发生溢出，就是常见的 OOM。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;GC 的速度和堆的内存中存活对象的数量有关，与堆内存所有的对象无关，GC 的速度和堆内存的大小无关，如一个 4GB 大小的堆内存和一个 16GB 的堆内存，只要 2 个堆内存存活对象都是一样多的时候，GC 速度都是基本差不多。每次垃圾回收也不是必须要把垃圾清理干净，重要的是保证不把正在使用的对象给标记清除掉。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;2.2 堆内存管理&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;JVM 中占用内存空间最大的是堆内存，平常对象的创建大部分都是在堆上分配内存的，是 Java 垃圾回收的主要目标和方向、是 Java 内存管理机制的核心组成部分，它可以自动管理 Java 程序的内存分配和释放，Java 垃圾收集器可以自动检测和回收不再使用的内存，以便重新分配给其他需要内存的程序。这种自动内存管理的机制可以提高程序的运行效率和可靠性，防止因内存泄漏等问题导致程序崩溃或性能下降，Java 垃圾收集器使用了不同的垃圾回收算法和垃圾收集器实现，以适应不同的应用场景和需求。Java 垃圾收集器的性能特征和优化技术也是 Java 程序员需要了解和掌握的重要知识。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;因此，了解 Java 垃圾回收的背景、原理和实践经验对于编写高效、可靠的 Java 程序非常重要。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.1 对象如何被判断为可回收&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;JVM 怎么判断堆内存里面的对象是否可回收的，就是当一个对象没有任何引用指向它了，它就是可回收对象，判断的方式有两种算法，一个是引用计数法，一个是可达性分析法。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;可回收对象：&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;424&quot; data-imgfileid=&quot;100014617&quot; data-ratio=&quot;0.7333333333333333&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/891ef4a1-7e31-4cc2-81d3-8e27a1779354.jpg&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;width: 578px;height: 424px;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（1）引用计数法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;给对象中添加一个引用计数器，每当有一个地方引用它时，这个计数器值加一，当引用失效断开时，计数器值就减一，在任何时刻时计数器为 0 的时候，代表这个对象是可以被回收的，没有任何引用使用它了。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014618&quot; data-ratio=&quot;0.6796296296296296&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/bce27aab-824a-4e0d-ab6b-789c5e0799ba.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;引用计数法是有缺点，当对象直接互相依赖引用时，这些对象的计数器都不能为 0，都不能被回收。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（2）可达性分析法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;它使用 tracing（链路追踪）方式寻找存活对象的方法，通过一些列称为「GC Roots」的对象作为初始点，从这些初始点开始向下查找，直到向下查找没有任何链路时，代表这个对象可以被回收，这种算法是目前 Java 唯一且默认使用来判定可回收的算法。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014620&quot; data-ratio=&quot;0.6796296296296296&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/0f23e95f-e8c9-4525-8d62-34b5ac4636b4.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.2 GC Roots 的概念和对象类型&lt;/strong&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ol class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: decimal;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;Java 虚拟机栈中引用的对象，例如各个线程被调用的方法栈用到的参数、局部变量或者临时变量等。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;方法区的静态类属性引用对象或者说 Java 类中的引用类型的静态变量。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;方法区中的常量引用或者运行时常量池中的引用类型变量。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;JVM 内部的内存数据结构的一些引用、同步的监控对象（被修饰同步锁）。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;JNI 中的引用对象。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ol&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;当然，被 GC Roots 追溯到的对象不是一定不会被垃圾回收，具体需要看情况，Java 对象与对象引用存在四种引用级别：分别是强引用、软引用、弱引用、虚引用，默认的对象关系是强引用，只有在和 GCRoots 没有关系时才会被回收；软引用用于维护一些可有可无的对象，当内存足够时不会被回收；弱引用只要发生了垃圾回收就会被清理；虚引用人如其名形同虚设，任何对象都与它无关。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.3 垃圾对象回收算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;当 JVM 定位到了那些对象可回收时，这个时候是通过三个算法标记清除，分别是标记清除算法、复制算法、标记压缩算法。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（1）标记清除算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;首先标记出所有需要回，收的对象，在标记完成后，统一回收掉所有被标记的对象，但是该算法缺点是执行效率低，当大量对象时需要大量标记和清理动作，而且容易产生内存碎片化，当需要一块连续内存时，会因为碎片化无法分配。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014621&quot; data-ratio=&quot;0.2324074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/d964fb76-5184-4844-a6a8-c1e2e8c0d9a0.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（2）标记压缩算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;标记压缩算法跟清除算法很像，只不过它对内存进行了整理， 让存活对象都向内存空间的一端移动，然后将边界的其它对象全部清理，这样能达到内存碎片化问题，不过它比清除算法多了移步动作。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014622&quot; data-ratio=&quot;0.1527777777777778&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/eb4ba1e3-b7b5-42f5-9087-2567b4355f6d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（3）复制算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，将存活对象复制到一块空置的空间里，然后将原来的区域全部清理，缺点是需要额外空间存放存活对象。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014623&quot; data-ratio=&quot;0.3425925925925926&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/a0b97901-6eeb-445a-8dd8-46b6bc0481ce.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.4 分代垃圾回收模型概念和原理&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;堆内存分代模型图&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014624&quot; data-ratio=&quot;0.25277777777777777&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/5f8f3b05-14d8-4730-9825-0dbb1e914d4f.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;当 JVM 进行 GC（垃圾回收）时，JVM 会发起「Stop the world」，所有的业务线程都进行停止，进入 SafePoint 状态，JVM 回收垃圾线程开始进行标记和追溯，如何解决这种停止和如何减少 STW 的时间呢？&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;目前主流垃圾收集器采用分代垃圾回收方式，大部分对象的声明周期都比较短，只有少部分的对象才存活的比较长，分代垃圾回收会在逻辑上把堆内存空间分为两部分，一部分为年轻代，一部分为老年代。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;（1）年轻代空间&lt;/strong&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;年轻代主要是存放新生成的对象，一般占用堆空间的三分之一空间，因为会频繁创建对象，所以年轻代 GC 频率是最高的。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;分为 Eden 空间、Survivor1（from）区、Survivor2（to）区，S1 和 S2 总要有一块空间是空的，为了方便年轻代存活对象来回存放，晋升存活对象年龄。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;三个区的默认比例是 8:1:1，可以通过配置参数调整比例。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;年轻代回收发起 Minor GC（YongGC），当 Eden 内存区域被占满之后就发起 GC，短暂的 STW，基于垃圾收集器。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;（2）老年代空间&lt;/strong&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;是堆内存中最大的空间， ，里面的对象都是比较稳定或者老顽固，GC 频率不会频繁执行。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014625&quot; data-ratio=&quot;0.4685185185185185&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/b655ab3a-9352-4372-b97a-570be86cd06d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;老年代对象：&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ol class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: decimal;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;正常提升&lt;/strong&gt;：由年轻代存活对象年龄到达阈值时，这个对象则会被移动到老年代中。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;分配担保&lt;/strong&gt;：如果年轻代中的空间不足时，此时有新的对象需要分配对象空间，需要依赖其它内存进行分配担保，老年代担保直接创建。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;大对象&lt;/strong&gt;：当创建需要大量连续内存空间的对象时，如长字符串或者数组等，大小超过了阈值时，直接在老年代分配。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;动态年龄对象&lt;/strong&gt;：有的垃圾收集器不需要到达指定年龄大小直接晋升老年代，比如相同年龄的对象的大小总和 &amp;gt; Survivor 空间的 50%， 年龄大于等于该年龄对象直接移动老年代，无需等待正常提升。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ol&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;老年代回收发起 Major GC / FULL GC，当老年代满时会触发 MajorGC，通常至少经历过一次 Minor GC，再紧接着进行 Major GC， Major GC 清理 Tenured 区，用于回收老年代（CMS 才能单独清理）。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;FUll GC：清除整个堆空间，一般来说是针对整个新生代、老生代、元空间的全局范围的清理。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;不管是 Major GC 还是 Full GC， STW 的耗时都是 Ygc 的十倍以上，所以说对象能在年轻代被回收是最优的。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;Full GC 触发条件：&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;老年代空间不足。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;元空间不足扩容导致。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;程序代码执行 System.gc 时可能会执行。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;当程序创建一个大对象时，Eden 区域放不下大对象，老年代内存担保分配，老年代也不足空间时。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;年轻代存留对象晋升老年代时，老年代空间不足时。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.5 Java 对象内存分配过程&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014626&quot; data-ratio=&quot;0.6027777777777777&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/d2937f98-1501-4a47-ab87-fd64453954f6.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&amp;nbsp;对象的分配过程&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ol class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: decimal;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;编译器通过逃逸分析优化手段，确定对象是否在栈上分配还是堆上分配。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;如果在堆上分配，则确定是否大对象，如果是则直接进入老年代空间分配， 不然则走 3。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;对比 tlab， 如果 tlab_top + size &amp;lt;= tlab_end， 则在 tlab 上直接分配，并且增加 tlab_top 值，如果 tlab 不足以空间放当前对象，则重新申请一个 tlab 尝试放入当前对象，如果还是不行则往下走 4。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;分配在 Eden 空间，当 eden 空间不足时发生 YGC， 幸存者区是否年龄晋升、动态年龄、老年代剩余空间不足发生 Full GC 。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;当 YGC 之后仍然不足当前对象放入，则直接分配老年代。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ol&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;TLAB&lt;strong&gt;作用原理&lt;/strong&gt;：Java 在内存新生代 Eden 区域开辟了一小块线程私有区域，这块区域为 TLAB，默认占 Eden 区域大小的 1%， 作用于小对象，因为小对象用完即丢，不存在线程共享，快速消亡 GC，JVM 优先将小对象分配在 TLAB 是线程私有的，所以没有锁的开销，效率高，每次只需要线程在自己的缓冲区分配即可，不需要进行锁同步堆 。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;对象除了基本类型的不一定是在堆内存分配，在 JVM 拥有逃逸分析，能够分析出一个新的对象所拥有的范围，从而决定是否要将这个对象分配到堆上，是 JVM 的默认行为；Java 逃逸分析是一种优化技术，可以通过分析 Java 对象的作用域和生命周期，确定对象的内存分配位置和生命周期，从而减少不必要的内存分配和垃圾回收。可以在栈上分配，可以在栈帧上创建和销毁，分离对象或标量替换，同步消除。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 2px;border-color: transparent;background-color: rgb(255, 255, 255);padding: 1px;&quot;&gt; 
    &lt;section style=&quot;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;display: inline-block;width: 100%;height: 200px;vertical-align: top;overflow-y: auto;&quot;&gt; 
      &lt;section style=&quot;overflow: hidden;&quot;&gt; 
       &lt;section style=&quot;margin-bottom: 120px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
        &lt;section style=&quot;text-align: justify;&quot;&gt; 
         &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
          &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; TaoYiFenxi {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; obj;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; setObj() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        obj = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; getObject() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; obj1 = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; obj1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; test1() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        synchronized (&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
         &lt;/section&gt; 
        &lt;/section&gt; 
       &lt;/section&gt; 
      &lt;/section&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.6 JVM 垃圾收集器特点与原理&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（1）Serial 垃圾收集器、Serial Old 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014627&quot; data-ratio=&quot;0.5712962962962963&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/04a94627-31bb-4e85-a8a8-5ae052deed2b.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Serial 收集器采用复制算法， 作用在年轻代的一款垃圾收集器，串行运行，执行过程中会 STW，是使用单个线程进行垃圾回收，响应速度优先。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Serial Old 收集器采用标记整理算法，作用在老年代的一款收集器，串行运行，执行过程中会暂停所有用户线程，会 STW，使用单个线程进行垃圾回收，响应速度优先。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用场景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;适合内存小几十兆以内，比较适合简单的服务或者单 CPU 服务，避免了线程交互的开销。&lt;br&gt;&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;优点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;小堆内存且单核 CPU 执行效率高。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;堆内存大，多核 CPU 不适合，回收时长非常长。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（2）Parallel Scavenge 垃圾收集器、Parallel Old 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014628&quot; data-ratio=&quot;0.5722222222222222&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/8cf072c7-a51e-4f76-b268-577b9c499ab2.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Parallel Scavenge 垃圾收集器采用了复制算法，作用在年轻代的一款垃圾收集器，是并行的多线程运行，执行过程中会发生 STW，关注与程序吞吐量。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Parallel Old 垃圾收集器采用标记整理算法，作用，作用在老年代的一款垃圾收集器， 是并行的多线程运行，执行过程中会发生 STW，关注与程序吞吐量。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Parallel Scavenge + Parallel Old 组合是 Java8 当中默认使用的一个组合垃圾回收。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;所谓的吞吐量是 CPU 用于运行用户代码时间与 CPU 总消耗时间的比值，也就是说吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集器时间)， 录入程序运行了 100 分钟，垃圾收集器花费时间 1 分钟&lt;span style=&quot;letter-spacing: 0.034em;&quot;&gt;，则吞吐量达到了 99%。&lt;/span&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用场景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;适用于内存在几个 G 之间，适用于后台计算服务或者不需要太多交互的服务，保证吞吐量的服务。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;优点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;可控吞吐量、保证吞吐量，并行收集。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;回收期间 STW，随着堆内存增大，回收暂停时间增大。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（3）Par New 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Par New 垃圾收集器采用了复制算法，作用在年轻代的一款垃圾收集器， 也是并行多线程运行，跟 Parallel 非常相似，是它的增强版本，或者说是 Serial 收集器的多线程版本，是搭配 CMS 垃圾收集器特制的一个收集器。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;使用场景：&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;搭配 CMS 使用&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（4）CMS 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;CMS 是一款多线程+分段操作的一款垃圾收集器。其最大的优点就是将一次完整的回收过程拆分成多个步骤，并且在执行的某些过程中可以使用户线程可以继续运行，分别有初始标记，并发标记，重新标记，并发清理和并发重置。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014629&quot; data-ratio=&quot;0.5064814814814815&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/fa0a6a57-a712-446f-b037-0153ff732161.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;CMS 是一款多线程+分段操作的一款垃圾收集器。其最大的优点就是将一次完整的回收过程拆分成多个步骤，并且在执行的某些过程中可以使用户线程可以继续运行，分别有初始标记，并发标记，重新标记，并发清理和并发重置。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;CMS 分段&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;初始标记阶段&lt;/strong&gt;， 这个阶段会暂停用户线程， 扫描所有的根对象，因为根对象比较少，所以一般 stw 时间都非常短。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;并发标记阶段&lt;/strong&gt;，这个阶段与用户线程一起执行，会一直沿着根往下扫描，不停的识别对象是否为垃圾，标记，采用了三色算法， 在对象头 (Mark World) 标识了一个颜色属性，不同的颜色代表不同阶段，扫描过程中给与对象一个颜色，记录扫描位置，防止 cpu 时间片切换不需要重新扫描。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;重新标记阶段&lt;/strong&gt;， 这个阶段暂停用户线程， 修正一些漏标对象，回扫发生引用变化的对象。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;并发清理阶段&lt;/strong&gt;， 这个阶段与用户线程一起执行，标记清除已经成为垃圾的对象。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;三色标记&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;黑色&lt;/strong&gt;：代表了自己已经被扫描完毕，并且自己的引用对象也已经确定完毕。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;灰色&lt;/strong&gt;：代表自己已经被扫描完毕了， 但是自己的引用还没标记完。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;白色：则代表还没有被扫描过。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;标记过程结束后，所有未被标记的对象都是不可达的，可以被回收。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014630&quot; data-ratio=&quot;0.725925925925926&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/c4354e81-0441-4f2c-839a-825920ac5e2d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;三色标记算法的&lt;strong&gt;问题场景&lt;/strong&gt;：当业务线程做了对象引用变更，会发生 B 对象不会被扫描，当成垃圾回收。&lt;/p&gt; 
  &lt;section style=&quot;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 2px;border-color: transparent;background-color: rgb(255, 255, 255);padding: 1px;&quot;&gt; 
    &lt;section style=&quot;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;display: inline-block;width: 100%;height: 200px;vertical-align: top;overflow-y: auto;&quot;&gt; 
      &lt;section style=&quot;overflow: hidden;&quot;&gt; 
       &lt;section style=&quot;margin-bottom: 120px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
        &lt;section style=&quot;text-align: justify;&quot;&gt; 
         &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
          &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Demo3&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        R r = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; R();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        B b = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; B();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GCroot 遍历 R， R 为黑色， R 下面的 a 引用链还未扫完置灰灰色，R.b 无引用， 切换时间分片&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a.b = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 业务线程发生了引用改变， 原本 r.a.b 的引用置为 null&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a.b = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 线程回来继续上次扫描，发现 r.a.b 无引用，则认为 b 对象无任何引用清除&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.b = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 回收了 b， 业务线程无法使用 b&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;R&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    B b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    B b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;B&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
         &lt;/section&gt; 
        &lt;/section&gt; 
       &lt;/section&gt; 
      &lt;/section&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014631&quot; data-ratio=&quot;0.45185185185185184&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/c965a3e4-1d3c-41bd-8a87-f1e559362200.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;当 GC 线程标记 A 时，CPU 时间片切换，业务线程进行了对象引用改变，这时候时间片回到了 GC 线程，继续扫描对象 A， 发现 A 没有任何引用，则会将 A 赋值黑色扫描完毕，这样 B 则不会被扫描，会标记 B 是垃圾， 在清理阶段将 B 回收掉，错误的回收正常的对象，发生业务异常。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;CMS 基于这种错误标记的解决方案是采取写屏障 + 增量更新 Incremental Update ， 在业务线程发生对象变化时，重新将 R 标识为灰色，重新扫描一遍，Incremental Update 在特殊场景下还是会产生漏标。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014632&quot; data-ratio=&quot;0.8445378151260504&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/4dce9b78-c6ab-4129-b955-11ce7716fe3d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;952&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 2px;border-color: transparent;background-color: rgb(255, 255, 255);padding: 1px;&quot;&gt; 
    &lt;section style=&quot;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;display: inline-block;width: 100%;height: 200px;vertical-align: top;overflow-y: auto;&quot;&gt; 
      &lt;section style=&quot;overflow: hidden;&quot;&gt; 
       &lt;section style=&quot;margin-bottom: 120px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
        &lt;section style=&quot;text-align: justify;&quot;&gt; 
         &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
          &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Demo3&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// Incremental Update 还会产生的问题&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        R r = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; R();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        A a = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        A b = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a1 = a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 线程切换， r 扫完 a1， 但是没有扫完 a2， 还是灰色&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a2 = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 业务线程发生引用切换， r 置灰灰色（本身灰色）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a1 = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 线程继续扫完 a2， R 为黑色， b 对象又漏了~&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;R&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A a1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A a2;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
         &lt;/section&gt; 
        &lt;/section&gt; 
       &lt;/section&gt; 
      &lt;/section&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;当 GC 1 线程正在标记 O， 已经标记完 O 的属性 O.1， 准备标记 O.2 时，业务线程把属性 O,1 = B，这时候将 O 对象再次标记成灰色， GC 1 线程切回，将 O.2 线程标记完成，这时候认为 O 已经全部标记完成，O 标记为黑色， B 对象产生了漏标， CMS 针对 Incremental Update 产生的问题，只能在 remark 阶段，暂停所有线程，将这些发生过引用改变过的，重新扫描一遍。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用场景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;适用于互联网或者 B/S 服务， 响应速度优先，适合 6G 左右。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;优点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;并发收集， 低停顿，回收过程中最耗时的是并发标记和并发清除，它都能与用户线程保持一起工作。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;收集器对 CPU 的资源非常敏感，会占用用户线程部分使用，导致程序会变得缓慢，吞吐量下降。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;无法处理浮动垃圾，在并发清理阶段用户线程还是在运行，这时候产生的新垃圾无法在这次当中处理，只有等待下次才会清理。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;因为 CMS 使用了 Incremental Update，remark 阶段还是会所有暂停，重新扫描发生引用改变的 GC root，效率慢耗时高。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;因为收集器是基于标记清除算法实现的，所以在收集器回收结束后，内存会产生碎片化，当碎片化非常严重的时候，这时候有大对象进入无法分配内存时会触发 FullGC，特殊场景下会使用 Serial 收集器，导致停顿不可控。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（5）G1 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 也是采用三色标记分段式进行回收的算法， 不过它是写屏障 + STAB 快照实现，G1 设定的目标是在延迟可控（低暂停）的情况下获得尽可能高的吞吐量，仍然可以通过并发的方式让 Java 程序继续运行，G1 垃圾收集器在很多方面弥补了 CMS 的不足，比如 CMS 使用的是 mark-sweep 标记清除算法，自然会产生内存碎片 (CMS 只能在 Full GC 时，STW 整理内存碎片)，然而 G1 整体来看是基于标记整理算法实现的收集器，但是从局部来看也是基于复制算法实现的，高效的整理剩余内存，而不需要管理内存碎片它。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 同样有年轻代和老年代的概念，只不过物理空间划分已经不存在，逻辑分区还存在，G1 会把堆切成若干份，每一份当作一个目标，在部分上目标很容易达成，G1 在进行垃圾回收的时候，将会根据最大停顿时间设置值动态选取部分小堆区垃圾回收。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014633&quot; data-ratio=&quot;0.6731481481481482&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/3baad622-5f9e-4052-8a43-43203fcb039b.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 的特点是尽量追求吞吐量，追求响应时间，并发收集，压缩空闲空间不会延长 GC 暂停时间，更容易预测 GC 暂停时间，能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU 对 STW 进行控制 (200ms 以内) 灵活的分区回收，优先回收花费时间少的或者垃圾比例高的 region 新老比例也是动态调整，不需要配置；年龄晋升也是 15，但是可以动态年龄，当幸存者 region 超过了 50 时，会把年龄最大的放入老年代。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 动态 Y 区域设置，G1 每个分区都可能是年轻代或者老年代，但是同一时刻只属于一个代，分代概念还存在，逻辑上分代方便复用以前分代逻辑，在物理上不需要连续，这样能带来额外好处，有的分区内垃圾比较多，有的分区比较少，G1 会优先回收垃圾比较多的分区，这样可以花费少量的时间来回收这些分区垃圾，即收集最多垃圾分区；但是新生代回收不适合这种，新生代达到阈值时发生 YGC，对整个新生代进行回收或者晋升幸存，新生代也分区是方便动态调整分区大小，在进行垃圾回收时，会将存活对象拷贝到另一个可用分区上，这样也能避免一定程度的内存碎片化过程，每个分区的大小都是在 1M- 32M 之间，取决 2 的幂次方。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;Humingous&lt;/strong&gt;：如果一个对象占用的空间超过了分区容量 50% 以上，G1 收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响；为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放巨型对象。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;CardTable&lt;/strong&gt;：记录每一块 card 内存区域是否 dirty，如果在发生 YGC 时，怎么知道那些是存活对象，并且其它代区域有没有引用这部分对象，于是把内存划分了很多 card 区域， 每个区域大小不超过 512b，当该 card 区域里的对象有引用关系，将当前 card 置为「dirty」， 并且使用卡表（CardTable）来记录每一块 card 是否 dirty，在进行 GC 时，不用遍历所有的空间， 只需要遍历卡表中为&quot;dirty&quot;或者说布尔符合条件的 card 区域进行回扫。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014634&quot; data-ratio=&quot;0.6703703703703704&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/317b89d9-596b-458e-ba5d-b9c955eb7575.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;CSet&lt;/strong&gt;：Collection SET 用于记录可被回收分区的集合组， G1 使用不同算法，动态的计算出那些分区是需要被回收的，将其放到 CSet 中，在 CSet 当中存活的数据都会在 GC 过程中拷贝到另一个可用分区，CSet 可以是所有类型分区，它需要额外占用内存，堆空间的 1%。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;RSet&lt;/strong&gt;：RememberedSet 每个 Region 都有一个 Rset，是一个记录了其他 Region 中的对象到本身 Region 的引用，它可以使得垃圾收集器不需要扫描整个堆去找到谁的引用了当前分区对象，是 G1 高效回收的关键点，也是三色算法的一个以来点。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014635&quot; data-ratio=&quot;0.2824074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/a1cb4f90-eef7-4393-9c20-eb6badbc354e.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;RSet 和卡表的区别是什么？&lt;/strong&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;p&gt;卡表记录的是堆内存中 card 有没有变成&quot;dirty&quot;， 但是它本身不知道 dirty 里面哪些是引用了的对象，它是一个大维度的一个记录，RSet 是记录自身 Region 中对象引用了其它 Region 中的那些对象，详细的记录对方引用对象信息，G1 使用了两者的结合，实现了增量式的垃圾回收，并优化跨区引用的最终处理。&lt;/p&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;SATB 算法&lt;/strong&gt;：是一种基于快照的算法，它可以避免在垃圾回收时出现对象漏标或者重复标记的问题，从而提高垃圾回收的准确性和效率，在垃圾回收开始时，对堆中的对象引用进行快照，然后在并发标记阶段中记录下所有被修改过对象引用，保存到 satb_mark_queue 中，最后在重新标记阶段重新扫描这些对象，标记所有被修改的对象，保证了准确性和效率。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;SATB 算法在 remark 阶段不需要暂停遍历整个堆对象，只需要扫描「satb_mark_queue」队列中的记录，避免了这个阶段长耗时，而 cms 的增量算法在这个阶段是需要重新扫描 GC Roots 标记整个堆对象，导致了不可控时间暂停，总的来说 G1 是通过回收领域应用并行化策略，将原来的几块大内存块回收问题，演变成了 N 个小内存块回收，使得回收效率可以高度并行化，停顿时间可控，可以与用户线程并发执行，将一块内存分而治之。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014636&quot; data-ratio=&quot;0.35462962962962963&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/7545f663-b201-495f-9cf2-b522f1c96976.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;G1 默认当分区内存占用阈值达到总内存的 45%，会发生 Mixed gc（混和 GC），YoungGC + 并发回收 Mixed GC 过程：初始标记（stw）、并发标记、最终标记 (重新标记 stw)、筛选回收（stw 并行）。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用场景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;响应速度优先，较高的吞吐量，面向服务端，使用内存 6G 以上。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;优点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;并行与并发收集，分代分区收集，优先垃圾收集，空间整合，可控或者可预测停顿时间。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;收集中产生内存，G1 的每个 region 都需要有一份记忆集和卡表记录跨代指针，这导致记忆集可能占用堆空间 10-20% 甚至更多空间。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;执行过程中额外负载开销加大，写屏障进行维护卡表操作外，还需要原始快照能够减少并发标记和重新标记阶段的消耗，避免最终标记阶段停顿过长，运行过程中会产生由跟踪引用变化带来的额外开销负担，比 CMS 增量算法消耗更多，CMS 的写屏障实现直接是同步操作， 而 G1 是把写屏障和写后屏障中要做的事情放到队列里异步处理。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 对于 Full GC 是没有处理流程， 一旦发生 Full GC G1 的回收执行的是单线程的 Serial 回收器进行回收。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.7 垃圾收集器配置使用&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;机器配置：64 位 4C8G&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;Java 程序使用 CMS 收集器进行内存垃圾回收初始内存划分情况：&lt;/p&gt; 
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-Xms4096M&amp;nbsp;-Xmx4096M&amp;nbsp;-XX:+HeapDumpOnOutOfMemoryError&amp;nbsp;-XX:HeapDumpPath=&lt;span class=&quot;code-snippet__regexp&quot;&gt;/data/&lt;/span&gt;{runuser}/logs/other&amp;nbsp;-XX:+UseConcMarkSweepGC&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014637&quot; data-ratio=&quot;0.5889967637540453&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/9ca62bea-63ea-499e-b9e7-0d0f7a002676.png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;span style=&quot;letter-spacing: 0.034em;&quot;&gt;CMS 跟 parNew 占比情况， 默认下 ParNew 占用整个堆的空间为：机器位数 * CPU 核数 * 13 /10 ， 当前机器配置计算得出 64 * 4 * 13 / 10 = 332M ， 与图上数值差别不大。&lt;/span&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 程序使用 G1 收集器进行内存垃圾回收初始内存划分情况：&lt;/p&gt; 
   &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
    &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-Xms4096M&amp;nbsp;-Xmx4096M&amp;nbsp;-XX:+HeapDumpOnOutOfMemoryError&amp;nbsp;-XX:HeapDumpPath=&lt;span class=&quot;code-snippet__regexp&quot;&gt;/data/&lt;/span&gt;{runuser}/logs/other&amp;nbsp;-XX:+UseG1GC&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
   &lt;/section&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014638&quot; data-ratio=&quot;0.5726495726495726&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/f87fe847-d5a8-4609-b631-234fab58b8c7.png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;G1 新老年代的占比是动态调整， 随着运行时根据实际情况划分空间。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;Java8 默认 ParallerGC 收集器初始内存划分情况：&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014639&quot; data-ratio=&quot;0.5694591728525981&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/b3a135dc-2a00-4a54-acd4-c3600b573ab9.png&quot; data-type=&quot;png&quot; data-w=&quot;943&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;parallel GC 回收器默认堆 old 区与 young 区内存大小比例 2：1， 图上数值差别不大。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;三、内存诊断实践&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;3.1 内存快照生成&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;当发生线上应用告警，告警相关内存故障问题时， 应当如何进行故障排查呢？首先应用在发生内存溢出无法执行时，应 DUMP 当前内存快照，需要在 Java 程序执行启动命令时添加上：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;-XX:+HeapDumpOnOutOfMemoryError&amp;nbsp;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;-XX:HeapDumpPath=${filePath} 参数&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&amp;nbsp;当发生时自动生成一份当前内存快照，方便与开发人员使用快照文件进行问题诊断分析。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;在 Java 应用运行时，想手动生成内存快照，可以使用 JDK 自带几个问题排查工具，可以使用 jmap 工具生成指定 PID 内存快照，不过需要耗费较长的一个时间，会暂停应用程序执行，使用 jcmd 工具可以快速的 DUMP 内存快照，因为在堆转储存文件过程中，jcmd 可以利用虚拟机中的一些优化技术，例如分代堆、增量式垃圾回收等技术，相比传统的 jmap 效率高很多，一般来说在 DUMP 内存前会进行一次&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Full FC，可以指定屏蔽这次 Full GC，保留当前所有内存中的对象。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;除了自带的内存诊断工具， 也可以使用 Arthas 诊断工具，提供了多个命令来帮助诊断内存问题，例如 dashboard（当前 Java 程序内存实时数据面板）、JVM（查看当前 JVM 信息，包括使用的 gc 收集器、内存分区分布情况等信息）、heapdump（当前内存快照类似 jmap 命令的 heap dump）、memory（当前内存分区及占用情况）、monitor（监控模式，可监控内存及查看对象占用情况）profiler（火焰图可以输出多种火焰图，内存分区占用火焰图）等相关内存命令。这些命令可以帮助获取应用程序的内存快照、堆内存使用情况等信息，能快速定位内存问题。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;引用：&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farthas.aliyun.com%2Fdoc%2Fcommands.html&quot; textvalue=&quot;Arthas 命令列表&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Arthas 命令列表&lt;/a&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;3.2 dump 内存快照分析&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;（1）jhat 是 Java 开发工具包自带的一款堆内存分析工具，它可以帮助解决 Java 应用程序的内存问题。Jhat 可以读取 Java 应用程序生成的堆转储文件，并以 HTML 格式展示内存中的对象信息和引用关系，支持 OQL 查询和灵活的过滤和排序功能。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;用例&amp;nbsp;&lt;span style=&quot;background-color: rgb(214, 214, 214);&quot;&gt; jhat E:\diydump\Java_pid2680.hprof&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014640&quot; data-ratio=&quot;0.597&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/ed38fad9-e21f-4c52-b7db-b83e26d1ef28.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;All classes including platform&lt;/strong&gt;：列举应用程序中所有类的信息，并快速定位内存问题。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;Show all members of the rootset&lt;/strong&gt;：显示堆内存中所有根对象的信息，包括系统对象、静态对象、本地对象等。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;Show instance counts for all classes (including platform)&lt;/strong&gt;：显示所有类的实例数量。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;Show heap histogram&lt;/strong&gt;：显示程序堆内存的直方图，可以知道每个类的实例数量和占用内存大小等信息，快速知道内存泄漏原因。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;（2）jvisualvm 也是 Java 开发工具包里自带的一款图形化工具，可以用于监控和诊断 Java 应用程序的性能问题。使用它可以实时查看 Java 应用程序的内存使用情况、CPU 使用情况、线程情况等，并可以进行内存分析、CPU 分析、线程分析等内容。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;以 Java_pid2680.hprof 为例，进行内存分析内存泄漏原因：&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014641&quot; data-ratio=&quot;0.4685185185185185&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/cecd7993-3d90-45ea-9aec-eb5bbc6a811b.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;（3）MAT 是基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java 内存分析工具，能够快速的分析出 dump 文件中各项结果，快速给出内存泄漏原因报告。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;还是以 Java_pid2680.hprof 文件进行分析，比原生的 jhat 方便很多，功能也比原生的更加丰富：&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014642&quot; data-ratio=&quot;0.5074074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/f7caef82-cb1c-4a39-9ee8-103c551796d8.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;MAT 的一些常用功能点介绍（如图所示）：&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;Overview &lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;标签内容有比较多块内容，其中 details 末块介绍总共使用内存大小，类的数量，实例的数量，类的加载器，以及实例的内存直方图；&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;Biggest Objects by Retained Size&lt;/strong&gt;模块，使用了饼状图列出了当前内存中占用最大的几个对象，按照百分比划分，点击不同的饼状块能够看到具体对象及其对象属性等信息；&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;actions&lt;/strong&gt;模块，这里拥有不同的分析功能，Histogram 生成视图列出每个类所对应的对象个数以及占用内存大小，Dominator Tree 生成视图寻找出大对象，每个实例对象的内存占比比重；&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;Reports&lt;/strong&gt;模块是生成报告，其中 Leak Suspects 可以自动分析内存泄漏主要原因报告，可以通过报告准确定位泄漏原因或者可能造成泄漏的原因，并且可以定位到具体累积实例，线程 stack 等信息。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;例子中：leak Suspects 报告给出「0xfe3be480」 非常多内存， Gc root Thread 所引用，在发生 gc 时，不是可回收对象，无法回收内存，导致内存溢出。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014643&quot; data-ratio=&quot;0.4861111111111111&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/df138f30-3373-4dfb-a6d2-95dba48cdf83.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;四、总结&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;本文介绍了 Java 程序中的内存模型，内存模型划分多份内存区域，不同区域的作用介绍及不同区域的线程之间的内存共享范围，可以帮助开发人员更加理解 Java 中内存管理的机制和原理。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;堆是内存模型中最大的一块内存区域，以堆的空间划分详细的介绍了内存分代，部分垃圾收集器即是物理分代和逻辑分代，G1 收集器则物理不分代逻辑保留了以前分代，讲述了不同收集器的原理实现和优缺点，可以根据项目的业务属性，机器配置等因素选择最优的收集器，帮助程序使用最优的收集器可以使得程序的吞吐量和响应速度达到最佳状态。还讲述了不同的参数调优收集器，并且当发生了程序内存溢出崩溃，如何进行内存分析，介绍不同工具的使用，快速定位内存溢出的罪魁祸首，从而在代码层面上根本解决这类问题。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;margin-top: 0.5em;margin-bottom: 0.5em;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;border-top: 1px dotted rgb(90, 98, 114);&quot;&gt; 
      &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;text-align: center;color: rgb(45, 66, 87);font-size: 11px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p&gt;END&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;margin-top: 0.5em;margin-bottom: 0.5em;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;border-top: 1px dotted rgb(90, 98, 114);&quot;&gt; 
      &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: left;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;&quot;&gt; 
    &lt;span style=&quot;display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);&quot; title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:234.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;&quot;&gt; 
    &lt;section style=&quot;font-size: 14px;text-align: left;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;padding-left: 40px;list-style-position: outside;&quot;&gt; 
      &lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247498348%26idx%3D1%26sn%3Da070a524928c6d312a56ead073e14a7c%26chksm%3Debdb8afedcac03e89c1a233dc19e01b468331219eaad321cb6346c0f73a2c06135503e6a83a6%26scene%3D21%23wechat_redirect&quot; textvalue=&quot;vivo 统一接入网关 VUA 转发性能优化实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;vivo 统一接入网关 VUA 转发性能优化实践&lt;/a&gt;&lt;/p&gt;&lt;/li&gt; 
      &lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247498342%26idx%3D1%26sn%3Db314e59b249a74cd76464d16895d8696%26chksm%3Debdb8af4dcac03e2defb1d7339379dadf13f2597f924f5c974e1083c668c971016d199fb1d07%26scene%3D21%23wechat_redirect&quot; textvalue=&quot;Sharding-JDBC 源码解析与 vivo 的定制开发&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Sharding-JDBC 源码解析与 vivo 的定制开发&lt;/a&gt;&lt;/p&gt;&lt;/li&gt; 
      &lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247498320%26idx%3D1%26sn%3Dc0180b1567a8b362c3c23c51528dfb7d%26chksm%3Debdb8ac2dcac03d4a3113cf75191bbf134746649184986b161fc521f4e340e1753ad6afbf744%26scene%3D21%23wechat_redirect&quot; textvalue=&quot;vivo 在离线混部探索与实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;vivo 在离线混部探索与实践&lt;/a&gt;&lt;/p&gt;&lt;/li&gt; 
     &lt;/ul&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
 &lt;/section&gt; 
 &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt; 
  &lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo 互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;&gt;&lt;/mp-common-profile&gt; 
 &lt;/section&gt; 
 &lt;p style=&quot;display: none;&quot;&gt; 
  &lt;mp-style-type data-value=&quot;3&quot;&gt;&lt;/mp-style-type&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color: #858585; font-size: 13px;&quot;&gt;本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。&lt;br&gt;如有侵权，请联系 support@oschina.cn 删除。&lt;br&gt;本文参与「&lt;a href=&quot;https://www.oschina.net/sharing-plan&quot; target=&quot;_blank&quot;&gt;OSC 源创计划&lt;/a&gt;」，欢迎正在阅读的你也加入，一起分享。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://my.oschina.net/vivotech/blog/11048619</link>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/11048619</guid>
            <pubDate>Wed, 27 Mar 2024 01:51:40 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>大数据应用场景落地实践</title>
            <description></description>
            <link>https://www.oschina.net/event/2331846</link>
            <guid isPermaLink="false">https://www.oschina.net/event/2331846</guid>
            <pubDate>Tue, 26 Mar 2024 09:29:17 GMT</pubDate>
        </item>
        <item>
            <title>mybatis-mp - 亮点八：mybatis-xml returnType 的 ORM 映射</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;strong&gt;mybatis-mp - 亮点八:&amp;nbsp; 可对 xml 实体类返回，进行自动映射：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;当你需要写一个很复杂的 sql 时，你可能会选择用 xml 去做例如：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;findUserList&quot; returnType=&quot;User&quot;&amp;gt;

&amp;nbsp; &amp;nbsp; &amp;nbsp; select id,user_name as userName,nick_name as nickName,password from user where xx and xx2 and xx3 ........

&amp;lt;/select&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style=&quot;color:#e74c3c&quot;&gt;如上：你可能需要自己，一个一个 as userName , as nickName 之类的，是不是很麻烦&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;现在好，只要接入 mybatis-mp；这些完全不用写了，如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;findUserList&quot; returnType=&quot;User&quot;&amp;gt;

&amp;nbsp; &amp;nbsp; &amp;nbsp; select id,user_name,nick_name,password from user where xx and xx2 and xx3 ........

&amp;lt;/select&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;自动帮你进行了映射，而且不仅仅支持实体，还支持 VO；省去了很多麻烦步骤！&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284803</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284803</guid>
            <pubDate>Tue, 26 Mar 2024 06:44:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>Ubuntu LTS 支持延长至 12 年</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Canonical &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fubuntu.com%2F%2Fblog%2Fcanonical-expands-long-term-support-to-12-years-starting-with-ubuntu-14-04-lts&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;全面推出 Legacy Support —— 一个 Ubuntu Pro 插件，可将 Ubuntu LTS 版本的安全性和支持范围扩大到 12 年。适用于 Ubuntu 14.04 LTS 及以上版本。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;312&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2a2eb37bed9123652265f19a8da71c4a8b3.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此前，Ubuntu 的 LTS 版本一般将获得 5 年的安全更新、错误修复和精选应用程序更新。Ubuntu Pro 则会在此基础上额外增加 5 年的安全保障，为现代的 LTS 版本提供长达十年的支持。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;通过此次推出的 Legacy Support 插件，Ubuntu Pro 用户将可以在原有的基础上，额外再两年的安全维护和支持。这意味着，Ubuntu 14.04 LTS 及以上版本的 LTS 从发布之日起将可获得长达 12 年的支持期。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Canonical 支持工程全球副总裁 Maximilian Morgan 称，「我们很高兴能为客户提供额外几年的 Ubuntu LTS 版本安全维护和支持......通过 Legacy Support，我们使企业能够满怀信心地引导其运营需求和对开源的投资，确保他们的系统在未来许多年内保持可用、安全和支持。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;这意味着原定于今年 4 月结束支持的 Ubuntu 14.04 LTS &quot;Trusty Tahr&quot; 将推迟至 2026 年 4 月，从而为 IT 人员预留了更多的时间来计划和准备升级到更新的版本。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284787/ubuntu-lts-12-years</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284787/ubuntu-lts-12-years</guid>
            <pubDate>Tue, 26 Mar 2024 06:21:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>苹果和中国百度尚未达成人工智能技术供应协议</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;此前有报道称苹果公司已与百度达成合作，将在该地区使用百度的大模型 AI 功能。但现在又有消息称，双方并未达成这样的协议。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-2550020989aa58a4082d974f67ffa94e71c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.chinastarmarket.cn%2Fdetail%2F1628550&quot; target=&quot;_blank&quot;&gt;https://www.chinastarmarket.cn/detail/1628550&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;《中国日报》指出，这些早先的报道不正确。该刊物称，苹果和百度尚未就人工智能合作达成一致，它是从熟悉苹果公司运作的消息来源获得这一信息的。有关两家公司已达成协议的报道只是媒体的猜测。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-5cf43246dfdeb31ea068b82961ff89dc3e3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.chinadaily.com.cn%2Fa%2F202403%2F26%2FWS6602b2c1a31082fc043bec68.html&quot; target=&quot;_blank&quot;&gt;https://www.chinadaily.com.cn/a/202403/26/WS6602b2c1a31082fc043bec68.html&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;不过无论苹果公司目前签订的任何合同的具体情况如何，至少该公司很可能会与中国公司合作，这样做容易避免潜在的监管问题。&lt;/p&gt; 
&lt;p&gt;百度股价在最初的报道中上涨了 2.55%。百度和苹果公司均未对此发表评论。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284945</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284945</guid>
            <pubDate>Tue, 26 Mar 2024 06:07:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>Rust 1.77.0 发布</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;Rust 1.77.0 稳定版已正式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.rust-lang.org%2F2024%2F03%2F21%2FRust-1.77.0.html&quot; target=&quot;_blank&quot;&gt;发布&lt;/a&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;，主要带来以下变化：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;C-string literals&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;Rust 现在支持 &amp;nbsp;C-string literals&amp;nbsp;(&amp;nbsp;&lt;code&gt;c&quot;abc&quot;&lt;/code&gt;)，它在&lt;code&gt;&amp;amp;&#39;static CStr&lt;/code&gt;类型的内存中扩展为以 nul 字节结束的字符串。这使得编写与需要以 nul 结尾的字符串的外语接口互操作的代码变得更加容易，并且在编译时执行所有相关的错误检查（例如，缺少内部 nul 字节）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h4 style=&quot;text-align:start&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;Support for recursion in &lt;code&gt;async fn&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;由于编译器限制，异步函数以前无法调用自身。在 1.77 中，该限制已被取消；因此只要使用某种间接形式来避免函数状态的无限大，就允许递归调用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;这意味着这样的代码现在可以工作：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre style=&quot;text-align:start&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span style=&quot;color:#b854d4&quot;&gt;async&lt;/span&gt; &lt;span style=&quot;color:#b854d4&quot;&gt;fn&lt;/span&gt; &lt;span style=&quot;color:#6684e1&quot;&gt;fib&lt;/span&gt;(n: &lt;span style=&quot;color:#b65611&quot;&gt;u32&lt;/span&gt;) -&amp;gt; &lt;span style=&quot;color:#b65611&quot;&gt;u32&lt;/span&gt; {
   &lt;span style=&quot;color:#b854d4&quot;&gt;match&lt;/span&gt; n {
       &lt;span style=&quot;color:#b65611&quot;&gt;0&lt;/span&gt; | &lt;span style=&quot;color:#b65611&quot;&gt;1&lt;/span&gt; =&amp;gt; &lt;span style=&quot;color:#b65611&quot;&gt;1&lt;/span&gt;,
       _ =&amp;gt; &lt;span style=&quot;color:#b65611&quot;&gt;Box&lt;/span&gt;::pin(fib(n-&lt;span style=&quot;color:#b65611&quot;&gt;1&lt;/span&gt;)).&lt;span style=&quot;color:#b854d4&quot;&gt;await&lt;/span&gt; + &lt;span style=&quot;color:#b65611&quot;&gt;Box&lt;/span&gt;::pin(fib(n-&lt;span style=&quot;color:#b65611&quot;&gt;2&lt;/span&gt;)).&lt;span style=&quot;color:#b854d4&quot;&gt;await&lt;/span&gt;
   }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;h4 style=&quot;text-align:start&quot;&gt;&lt;strong&gt;offset_of!&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;1.77.0 稳定了 struct fields​​​​​​​ 的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fmem%2Fmacro.offset_of.html&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;offset_of!&lt;/code&gt;&lt;/a&gt;，它提供了对 struct 相关公共字段的字节偏移量的访问。这个宏在需要字段偏移量而又没有类型实例的情况下非常有用。&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;用户现在可以使用&lt;code&gt;offset_of!(StructName, field)&lt;/code&gt;访问公共字段的偏移量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h4 style=&quot;text-align:start&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;默认情况下在发布配置文件中启用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;strip&lt;/h4&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;未在 outputs 中启用&amp;nbsp;debuginfo 的&amp;nbsp;Cargo profiles（例如&lt;code&gt;debug = 0&lt;/code&gt;）将默认启用&lt;code&gt;strip = &quot;debuginfo&quot;&lt;/code&gt;。​​​​​​​&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;之所以需要这样做，主要是因为（预编译）标准库附带有 debuginfo，这意味着即使本地编译没有明确请求 debuginfo，静态链接的结果也会包含标准库中的 debuginfo。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;稳定的 API&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.array.html%23method.each_ref&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;array::each_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.array.html%23method.each_mut&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;array::each_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fcore%2Fnet%2Findex.html&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;core::net&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.f32.html%23method.round_ties_even&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;f32::round_ties_even&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.f64.html%23method.round_ties_even&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;f64::round_ties_even&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fmem%2Fmacro.offset_of.html&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;mem::offset_of!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.first_chunk&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::first_chunk&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.first_chunk_mut&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::first_chunk_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.split_first_chunk&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::split_first_chunk&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.split_first_chunk_mut&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::split_first_chunk_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.last_chunk&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::last_chunk&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.last_chunk_mut&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::last_chunk_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.split_last_chunk&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::split_last_chunk&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.split_last_chunk_mut&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::split_last_chunk_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.chunk_by&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::chunk_by&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.chunk_by_mut&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::chunk_by_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fops%2Fenum.Bound.html%23method.map&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;Bound::map&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Ffs%2Fstruct.File.html%23method.create_new&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;File::create_new&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fsync%2Fstruct.Mutex.html%23method.clear_poison&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;Mutex::clear_poison&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fsync%2Fstruct.RwLock.html%23method.clear_poison&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;RwLock::clear_poison&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Other changes&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;可查看&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frust-lang%2Frust%2Freleases%2Ftag%2F1.77.0&quot; target=&quot;_blank&quot;&gt;Rust&lt;/a&gt;&lt;span style=&quot;color:#000000&quot;&gt;、&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frust-lang%2Fcargo%2Fblob%2Fmaster%2FCHANGELOG.md%23cargo-177-2024-03-21&quot; target=&quot;_blank&quot;&gt;Cargo&lt;/a&gt;&amp;nbsp;和&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frust-lang%2Frust-clippy%2Fblob%2Fmaster%2FCHANGELOG.md%23rust-177&quot; target=&quot;_blank&quot;&gt;Clippy&lt;/a&gt;&amp;nbsp;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;中发生的所有变化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;详情可&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.rust-lang.org%2F2024%2F03%2F21%2FRust-1.77.0.html&quot; target=&quot;_blank&quot;&gt;查看官方公告&lt;/a&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284778/rust-1-77-0-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284778/rust-1-77-0-released</guid>
            <pubDate>Tue, 26 Mar 2024 06:01:32 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Ugly avatar —— 丑头像生成器</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;Ugly avatar 是生成丑头像的在线工具。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-c1df4ccc6fa20c1982e151f5404498a50a0.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

&lt;p&gt;体验地址：&lt;a href=&quot;https://txstc55.github.io/ugly-avatar/&quot;&gt;https://txstc55.github.io/ugly-avatar/&lt;/a&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/ugly-avatar</link>
            <guid isPermaLink="false">https://www.oschina.net/p/ugly-avatar</guid>
            <pubDate>Tue, 26 Mar 2024 04:21:50 GMT</pubDate>
        </item>
        <item>
            <title>Windows 格式化对话框是一个使用了 30 年的「临时解决方案」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;戴夫-普卢默（Dave Plummer）是微软的资深工程师，曾创造了任务管理器、Windows 弹球、原生 ZIP 支持（微软出钱买断该功能后，他用这笔钱购买了一辆红色克尔维特）等传奇，近日他在自己的 X 账户上分享了创建&quot;格式化&quot;对话框的故事——称其是一个使用了长达 30 年的「临时解决方案」。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-5518f52befb96158f97eb7d1b4e287baa1a.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fdavepl1968%2Fstatus%2F1772042158046146792&quot; target=&quot;_blank&quot;&gt;https://twitter.com/davepl1968/status/1772042158046146792&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;故事还要追溯到 1994 年，当时 Dave 和其他软件工程师们正忙于将&quot;海量的代码&quot;从 Windows 95 迁移到 Windows NT 系统上。由于后者引入了许多改动，格式化对话框的界面也亟待重新设计。&lt;/p&gt; 
&lt;p&gt;Dave 拿起纸笔，列出了一些必要的功能，并使用 VC++ 2.0 的资源编辑器快速搭建了一个简单的纵向列表界面。选择垂直布局是为了让用户可以按照大致正确的顺序勾选所有选项。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-94c12885f8f91ab589c030879f7914d81f2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Dave 表示，&lt;strong&gt;这个设计的初衷并不是为了美观，仅仅是为了在「更优雅的界面」到来之前先用着&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;然而让人没想到的是，这个「临时解决方案」一用就是 30 年。即使是最新版本的 Windows 11 预览版，在格式化对话框仍然维持着当年的样式，没有任何升级的迹象。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-db2b723d3944610ef606bc557efc549a365.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Dave 还提到，「30 年前我做的那个星期四上午做出来的临时方案，现在还在使用！」他还感慨：「在开发软件时，可要当心‘临时’这两个字眼儿啊！」&lt;/p&gt; 
&lt;p&gt;此外，Dave 当初还凭直觉决定了 cluster slack 大小的限制，这直接导致了 FAT 卷的格式化最大容量为 32GB。同样，这也是一个当初的临时决定，却意外地变成了至今仍在使用的永久限制。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284757</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284757</guid>
            <pubDate>Tue, 26 Mar 2024 04:01:50 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>开源日报 | AI 手机需要新故事；做了十几年的操作系统和 AI 应用，跨界到机器人领域；VitePress 1.0；苹果曾试图为安卓开发手表</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;欢迎阅读 OSCHINA 编辑部出品的开源日报，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#e67e22&quot;&gt;&lt;strong&gt;# 2024.3.25&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日要点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;OpenSource Daily&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284627/vitepress-1-0-released&quot; target=&quot;_blank&quot;&gt;尤雨溪宣布推出 VitePress 1.0&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;尤雨溪宣布正式发布 VitePress 1.0 版本，并声称其 「基于 Vite 和 Vue 构建，是 VuePress 的精神继承者和现代替代品。」&lt;/p&gt; 
&lt;p&gt;VitePress 是一个静态站点生成器 (SSG)，专为构建快速、以内容为中心的站点而设计。简而言之，VitePress 获取用 Markdown 编写的内容，对其应用主题，并生成可以轻松部署到任何地方的静态 HTML 页面。&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284652/fydeos-18-released&quot; target=&quot;_blank&quot;&gt;FydeOS v18 发布，控制中心重构，虚拟桌面、剪贴板、文件搜索全面升级&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;-虚拟桌面：改进了虚拟桌面功能，通过底部快捷按钮实现工作空间快速切换，以提升任务管理效率。&lt;br&gt; -控制中心重构：采用最新的 Material Design 美学全面优化了控制中心界面和操作逻辑。&lt;br&gt; -剪切板升级：增强剪切板功能，支持快捷键「Windows 键 + V / Command + V」访问历史记录，简化内容管理。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-31e5336fef60aeba4e748aa77d18d5cb244.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日观察&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-2a0ccdb00566a9d3ad038133136b3eee31f.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微信&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIyNDA0MjM4MA%3D%3D%26mid%3D2649518102%26idx%3D1%26sn%3Dea853ae3d1d4c6030b500ae21ab60820%26chksm%3Df00ddcf5c77a55e32cf5a221d62419c93280d09709c43ba15b6aa24c3575cf7390efeb8f3b8f&quot; target=&quot;_blank&quot;&gt;夜半谈&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-1bf927795554e535d08fdbf09793ae8f502.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微博&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F2421203193%2FO69YioUgh&quot; target=&quot;_blank&quot;&gt;生活芯科技&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-b0e3bd1ad453972eab42ea2a8ada18f9ae2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微博&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1815369323%2FO6BYglY0I&quot; target=&quot;_blank&quot;&gt;乔忠良&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;今日推荐&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-3d80e5f9c5a5082466f21b598d417a6e509.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpassbolt%2Fpassbolt_api&quot; target=&quot;_blank&quot;&gt;https://github.com/passbolt/passbolt_api&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;事件点评&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-40301b39e04e7b4b0352352c9a25dc340a5.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;每日项目榜&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;每日 GitHub 精选&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-d0d1da6a4c6c9ec4dceb1e7f059577deb75.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;在线阅读完整日报内容，访问：&lt;/span&gt;&lt;/strong&gt;&lt;br&gt; &lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://report.oschina.net/api/files/jhim80u9qm1ofsw/ojkci7trx2o8oun/36_ai_ai_vite_press_1_0_BYIu9kQwRD.pdf&quot; target=&quot;_blank&quot;&gt;开源日报第 035 期：AI 手机需要新故事；做了十几年的操作系统和 AI 应用，跨界到机器人领域；VitePress 1.0；苹果曾试图为安卓开发手表&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/h4&gt; 
&lt;/blockquote&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;欢迎扫码下载「开源中国 APP」&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;随时在线阅读完整日报内容 ↓&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7871d27245192b8ecfcd21043d309382749.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;889&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-842e51ced6d226559af1af95c8041338cb2.gif&quot; width=&quot;400&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284752</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284752</guid>
            <pubDate>Tue, 26 Mar 2024 03:38:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Redict：Redis 的一个独立的 Copyleft 分支</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Redict 是由开发者 Drew DeVault 推出的一个&amp;nbsp;Redis OSS 7.2.4.2 的独立、非商业性的分叉。基于 Redis OSS 的 BSD 3-Clause 源代码，自此之后的所有更改均采用 Lesser&amp;nbsp;GNU General Public license（LGPL-3.0-only）。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;296&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-c9a0f9b14c09863d0ed266a9efd6915d926.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在许可证的选择上，Drew DeVault 解释称，LGPL 是经过深思熟虑且平衡了多方面的考量之后的选择，是&lt;span style=&quot;color:#000000&quot;&gt;最适合 Redict 的许可证&lt;/span&gt;。最重要的是，这是一个不可撤销的承诺，即 Redict 将永远是免费的。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;「这比 RedisLabs 联合创始人、前首席执行官 Yiftach 在 2018 年做出的承诺要有力得多。通过使用 Copyleft 许可证，Redict 的所有更改都必须使用相同的 LGPL 自由软件许可证发布，从而保证软件的修改版本将是免费的。」&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;此外，他保证 Redict 将不会使用任何形式的贡献者许可协议。Redict 的版权由所有贡献者共同拥有，Redict 许可证的变更将需要取得所有贡献者的同意。从而使得 Redict 未来几乎不可能出现类似 &lt;span style=&quot;color:#000000&quot;&gt;Redis&amp;nbsp;&lt;/span&gt;的许可证变更。&lt;/p&gt; 
&lt;p&gt;Drew DeVault 补充道，没有选择常用的&amp;nbsp;AGPL 或&amp;nbsp;EUPL 许可的原因在于，「我们希望让用户尽可能轻松地遵守 Redict 许可证，而且我们认为没有任何理由阻止云厂商使用 Redict。」&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;选择 LGPL 而不是 GPL，则是为了减少与 Redis 兼容模块或 Lua 插件的集成会受到 GNU GPL 的「病毒式传播」影响的担忧。选择 LGPL 既能保护 Redict 项目的未来，又能在这些问题之间取得最佳平衡。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;到目前为止，项目面向用户的变更包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;可执行文件已重命名为 redict-*，例如 redict-cli。&lt;/li&gt; 
 &lt;li&gt;Lua API 提供了与 Redis OSS API 兼容的「redict」 global，可通过「redis」 global 实现向后兼容。&lt;/li&gt; 
 &lt;li&gt;Module API symbols 已重命名，但是，Redict 保留了与 Redis OSS 模块（最高版本 7.2.4）的 ABI 兼容性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Redict 旨在作为 Redis OSS 7.2.4 的直接替代品。接下来，Redict 的目的是继续开发 Redis OSS 兼容软件的自由软件发行版，暂时只进行最小程度的破坏性更改。目前正在围绕以下变更进行讨论：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;利用这个机会删除一些长期弃用的功能，例如「redis-trib」&lt;/li&gt; 
 &lt;li&gt;消除供应商依赖并转向上游 Lua、jemalloc&lt;/li&gt; 
 &lt;li&gt;减轻与下游的关联性，删除例如 systemd 或 upstart 服务&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;以及计划分叉 Redict 的内部依赖项&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fredis%2Fhiredis&quot; target=&quot;_blank&quot;&gt;Hiredis&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;更多详情可&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fredict.io%2Fposts%2F2024-03-22-redict-is-an-independent-fork%2F&quot; target=&quot;_blank&quot;&gt;查看官方公告&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style=&quot;text-align:start&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/284082/redis-adopts-dual-source-available-licensing&quot; target=&quot;news&quot;&gt;Redis 不再「开源」，未来采用 SSPLv1 和 RSALv2 许可证&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284749/redict-independent-fork-redis</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284749/redict-independent-fork-redis</guid>
            <pubDate>Tue, 26 Mar 2024 03:28:35 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
    </channel>
</rss>