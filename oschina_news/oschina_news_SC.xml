<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-最新资讯]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-最新资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 15 Nov 2023 12:58:22 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[向开源作者提问「项目还活着吗」非常粗鲁且无礼]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>最近几个月，开源 AI 项目的创始人 Max Woolf 经历了一场关于自己的工作的 「存在危机」。</p><p>他表示自己对 AI 的负面抵制情绪日益强烈，以及 AI 行业进展神速，Max 发现自己无法跟上进度，陷入了对开源工作的质疑。在此期间，他暂停了 GitHub 上自己开源项目的开发，其中包括 ChatGPT 的 Python 接口 simpleaichat。</p><p><img src="https://static.oschina.net/uploads/space/2023/1115/190841_hkBi_2720166.png" referrerpolicy="no-referrer"></p><p><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fminimaxir%2Fsimpleaichat" target="_blank">https://github.com/minimaxir/simpleaichat</a></u></em></p><p>简单来说，Max 压力太大，需要休息一段时间。按理来说，他的代码不应该有问题，因为项目本身设计就考虑到了他可能暂停开发的情况。</p><p>然而当 Max 想重操旧业时，却在自己项目的 GitHub 上收到了质疑开发是否已经停止的问题。尽管没有任何证据表明代码出问题，但项目 Stars 数高达 3k 的 simpleaichat 还是收到了 「这个项目被放弃了吗」 的问题。</p><p><img height="302" src="https://static.oschina.net/uploads/space/2023/1115/190713_TFZG_2720166.png" width="1454" referrerpolicy="no-referrer"></p><p>这让 Max 感到既震惊又气愤。他认为，这种质疑开发者的行为是在施加不必要的压力，也显得无礼。</p><p>事实上，开源项目从来没有 「必须持续开发」 的硬性规定。大多数开源许可协议都明确写明软件 「按原样」 提供，不承诺后续维护。但部分社区成员似乎默认开源项目有更新的义务，这让 Max 和其他开源开发者感到困扰。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9f8029289e5c8978243bb08f62b2b0a4dcf.png" referrerpolicy="no-referrer"></p><p>他认为，开源的最大优势是可以随时分叉。如果有开发者认为某项目 「死了」, 大可以复制代码自行维护。但是有些人却以 「分叉」 来威胁原作者，这让原作者不堪重负。</p><p>AI 行业进展迅速，也加重了这一问题。受 ChatGPT 热潮影响，部分 AI 新创通过风险投资大规模运营，让人产生开源 AI 必须 「快速迭代」 的误解。</p><p>Max 表示，这种对开源项目 「活跃度」 的不合理期待，已经成为阻止他继续开源工作的主要障碍。他正在考虑通过创业来全职维护自己的项目，但前景未卜。</p><p>他认为，质疑开源项目是否 「死了」 的问题本身，就可能让开发者产生继续工作的动力。开源社区如果不能保持友善，只会让更多优秀项目消失。</p><p>原文：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fminimaxir.com%2F2023%2F11%2Fopen-source-dead-github%2F" target="_blank">https://minimaxir.com/2023/11/open-source-dead-github/</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 10:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266608/open-source-dead-github</guid>
            <link>https://www.oschina.net/news/266608/open-source-dead-github</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[零一万物对 Yi-34B 训练过程的说明]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>事件背景：</p><ul><li><a href="https://www.oschina.net/news/266377">李开复旗下 AI 公司「零一万物」开源的 Yi 大模型照搬 Llama 架构</a></li><li><a href="https://www.oschina.net/news/266525">「零一万物」 回应 Yi 开源大模型「套壳」 Llama</a></li></ul><hr><p>零一万物今天正式发文回应 Yi 开源大模型引起的争议：</p><blockquote><p>就零一万物的观察和分析，大模型社区在技术架构方面现在是一个处于接近往通用化逐步收拢的阶段，基本上国际主流大模型都是基于<strong>Transformer</strong>的架构，做 attention，activation，normalization，positional embedding 等部分的改动，LLaMA、Chinchilla、Gopher 等模型的架构和 GPT 架构大同小异，全球开源社区基于主流架构的模型变化非常之多，生态呈现欣欣向荣，国内已发布的开源模型也绝大多数采用渐成行业标准的 GPT/LLaMA 的架构。然而，大模型持续发展与寻求突破口的<strong>核心点不仅在于架构，而是在于训练得到的参数</strong>。</p><p>模型训练过程好比做一道菜，架构只是决定了做菜的原材料和大致步骤，这在大多数人的认知中也逐步形成共识。<strong>要训练出好的模型，还需要更好的「原材料」（数据）和对每一个步骤细节的把控（训练方法和具体参数）</strong>。由于大模型技术发展还在非常初期，从技术观点来说，行业共识是与主流模型保持一致的模型结构，更有利于整体的适配与未来的迭代。</p><p>零一万物在训练模型过程中，沿用了 GPT/LLaMA 的基本架构，由于 LLaMA 社区的开源贡献，让零一万物可以快速起步。零一万物<strong>从零开始训练</strong>了 Yi-34B 和 Yi-6B 模型，并根据实际的训练框架重新实现了训练代码，用自建的数据管线构建了高质量配比的训练数据集（从 3PB 原始数据精选到 3T token 高质量数据）。除此以外，在 Infra 部分进行算法、硬件、软件联合端到端优化，实现训练效率倍级提升和极强的容错能力等原创性突破。<strong>这些科学训模的系统性工作，往往比起基本模型结构能起到巨大的作用跟价值。</strong></p><p>零一万物团队在训练前的实验中，尝试了不同的数据配比科学地选取了最优的数据配比方案，投注大部分精力调整训练方法、数据配比、数据工程、细节参数、baby sitting（训练过程监测）技巧等。这一系列超越模型架构之外，研究与工程并进且具有前沿突破性的研发任务，才是真正属于模型训练内核<strong>最为关键、能够形成大模型技术护城河 know-how 积累</strong>。在模型训练同时，零一万物也针对模型结构中的若干关键节点进行了大量的实验和对比验证。举例来说，我们实验了 Group Query Attention（GQA）、Multi-Head Attention（MHA）、Vanilla Attention 并选择了 GQA，实验了 Pre-Norm 和 Post-Norm 在不同网络宽度和深度上的变化，并选择了 Pre-Norm，使用了 RoPE ABF 作为 positional embedding 等。也正是在这些实验与探索过程中，为了执行对比实验的需要，模型对部分推理参数进行了重新命名。</p><p>在零一万物初次开源过程中，我们发现用和开源社区普遍使用的 LLaMA 架构会对开发者更为友好，对于沿用 LLaMA 部分推理代码经实验更名后的疏忽，原始出发点是为了充分测试模型，并非刻意隐瞒来源。<strong>零一万物对此提出说明，并表达诚挚的歉意</strong>，我们正在各开源平台重新提交模型及代码并补充 LLaMA 协议副本的流程中，承诺尽速完成各开源社区的版本更新。</p><p>我们非常感谢社区的反馈，零一万物在开源社区刚刚起步，希望和大家携手共创社区繁荣，在近期发布 Chat Model 之后，我们将择期发布技术报告，Yi Open-source 会尽最大努力虚心学习，持续进步。</p><p><em>开源社区讨论参考：</em><br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">https://huggingface.co/01-ai/Yi-34B/discussions/11#6553145873a5a6f938658491</a></p></blockquote><p>创新工场 CMO 在转发上文的朋友圈中表示：「沿用行业演进渐成通用、生态拥抱的基础架构就成了「套模、山寨」？（就像手机 app 开发者都得益于 iOS、Android 的共通架构）。零一万物会持续从社区中虚心学习，持续进步。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-76f874328ebdab1a891bfc44ea094f539e4.png" referrerpolicy="no-referrer"></p><p>原文：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FaDclX74mPPtjQvco3GYmZQ" target="_blank">https://mp.weixin.qq.com/s/aDclX74mPPtjQvco3GYmZQ</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 09:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266597</guid>
            <link>https://www.oschina.net/news/266597</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[BifroMQ-v2.0.0 发布：支持标准集群模式（StandardCluster）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#3e3e3e">百度天工 AIoT 团队在 2023 年 7 月正式宣布开源高性能分布式 MQTT 物联网消息中间件，并将其全新命名为 BifroMQ。历时三个月，BifroMQ-v2.0.0 版本现已<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FT6CCbbEsdM9mBu_hJVRPGA" target="_blank">发布</a>。</span></p><p><span style="background-color:#ffffff; color:#3e3e3e">新版本首次支持集群模式，官方将其称为标准集群 StandardCluster（简称 StandardCluster）。</span><strong><span style="background-color:#ffffff; color:#3e3e3e">主要有以下特性：</span></strong></p><ul><li style="text-align:justify">集群模式全面支持 MQTT 协议：在集群模式下，每个节点均具备完整的 MQTT 协议功能，提供更高的可用性和扩展性。</li><li style="text-align:justify">新增 HTTP API 支持：除 MQTT 外，本版本新增对 HTTP API 的支持，更加灵活多变。</li><li style="text-align:justify">高性能不减：专注于在大规模负载环境下的高性能 MQTT 协议。</li><li style="text-align:justify">模块化架构进一步优化：适应各种业务需求的分布式集群管理。</li><li style="text-align:justify">强力可扩展性：目标支持大规模多租户的 Serverless 云服务。</li></ul><h4><strong>BifroMQ 的集群架构解析</strong></h4><p><strong>StandardCluster 的整体结构</strong></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">BifroMQ 将逻辑上的 MQTT 功能从负载的角度分解为若干子服务，每个子服务对应一类关键负载：</p><ul><li style="text-align:justify"><span style="color:#3e3e3e">bifromq-mqtt：负责 MQTT 协议连接负载</span></li><li style="text-align:justify"><span style="color:#3e3e3e">bifromq-dist：负责订阅和消息路由分发负载</span></li><li style="text-align:justify"><span style="color:#3e3e3e">bifromq-inbox：负责持久会话中的离线消息队列负载</span></li><li style="text-align:justify"><span style="color:#3e3e3e">bifromq-retain：负责 Retain 消息存取负载</span></li></ul><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">从部署的角度出发，BifroMQ StandardCluster 是将这些独立负载的服务模块"封装"到一个节点服务进程的集群模式，从逻辑上来说，此为 Standalone 运行模式的抽象（BifroMQ Standalone 可以看作是单个节点的 BifroMQ StandardCluster）。与其他支持集群的 MQTT Broker 不同，BifroMQ 内置分布式持久化功能，因此单个 BifroMQ 节点是"有状态的"（Stateful）。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="340" src="https://oscimg.oschina.net/oscnet/up-10103acc9b9400c10279995130df8a8a450.png" width="500" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><strong>消息分发能力的水平扩展</strong></p><p style="margin-left:0; margin-right:0">在 StandardCluster 集群模式下，每个节点进程内的分发负载模块（ 简称 Dist Service ）构成逻辑上的负载子集群（Dist-SubCluster）。Dist Service 将订阅信息存储在内置的持久化引擎中，并通过持久化引擎的分布式功能在节点之间同步路由信息。公告称，在 StandardCluster 模式下，通过增加节点的方式，即可以实现消息分发能力的水平扩展，特别是在 CleanSession 为 True 的情况下。</p><p style="margin-left:0; margin-right:0"><img height="361" src="https://oscimg.oschina.net/oscnet/up-e9a61c9398acd91228e41d3c1715da396bc.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>离线消息队列的持久化、扩展性及高可靠性</strong></p><p style="margin-left:0; margin-right:0">与 Dist Service 模块类似，节点进程内负责 MQTT 持久会话中离线消息队列的 Inbox Service 模块构成了另一个逻辑上的负载子集群（以下简称 Inbox-SubCluster）。Inbox Service 将离线队列消息持久化到内置的存储引擎中，可以极大程度地减少因节点故障导致的数据丢失。在存储方面，Inbox Service 利用内置存储引擎的分片功能，在实现存储规模和处理能力水平扩展的同时，通过静态配置或运行时策略动态增加分片的副本数，可以进一步提高离线消息数据的可靠性，这对某些对数据可靠性要求更高的应用场景尤为重要。</p><p style="margin-left:0; margin-right:0"><img height="427" src="https://oscimg.oschina.net/oscnet/up-e83bad09a192ee073e83448271eeacd3340.png" width="500" referrerpolicy="no-referrer"></p><p><strong>Inbox 服务的基于负载的拆分策略</strong></p><p>如前文所述，在 StandardCluster 部署下，单个节点进程内的 Inbox Service 利用了内置存储引擎的分片功能来实现存储规模和处理能力的水平扩展。然而，分片策略对实际运行效果有着决定性的影响。在 BifroMQ StandardCluster 版本中，已内置开箱即用的基于负载的拆分策略（以下简称 Load-based Splitting）。该策略通过统计最近一段时间内的负载情况来决定对 KV Range 的划分，可以视为一种"后验"拆分策略。当使用场景已经对离线消息负载的分布有提前规划和了解时，提前划分 Range 往往能在负载到来时带来更稳定的性能表现，而对于深度使用 BifroMQ 的用户，可以通过 SPI 机制实现此类"先验"拆分策略。</p><p style="margin-left:0; margin-right:0"><img height="435" src="https://oscimg.oschina.net/oscnet/up-9ebbc30509ae5d8f8471705413c1acf321a.png" width="300" referrerpolicy="no-referrer"></p><p><strong>HTTP API 模块</strong></p><p>BifroMQ StandardCluster 版本同时引入了 HTTP API 功能，每个集群节点均可通过配置开放 API 访问端口。BifroMQ HTTP API 作为无状态的全局接口，旨在支持业务层面的管理控制逻辑集成，访问任何一个节点的 API 都可以实现对整个集群的操作。</p><p><img height="321" src="https://oscimg.oschina.net/oscnet/up-616f9216ef245596cf8317b83796422bcca.png" width="500" referrerpolicy="no-referrer"></p><h4>混合负载对性能的影响</h4><p style="color:#878787; margin-left:0; margin-right:0; text-align:justify"><span style="color:#3e3e3e">在 StandardCluster 部署下，单个节点具备完整的 MQTT 协议功能，承担各种类型的负载。因此，这种模式非常适用于以下两类企业级应用场景：</span></p><ul><li style="text-align:justify"><span style="color:#3e3e3e">业务产生的负载类型相对单一</span></li><li style="text-align:justify"><span style="color:#3e3e3e">业务产生的负载类型多元化，但产生时间相对分散。对于负载形式复杂且在时间维度上有集中产生的情况，官方建议用户通过模拟负载测试来获得单个 BifroMQ StandardCluster 集群下的最佳资源配置和参数设置，或者考虑使用多个 BifroMQ StandardCluster 来承载不同类型的业务负载。</span></li></ul><h4 style="margin-left:0px; margin-right:0px; text-align:justify"><strong><span style="color:#3e3e3e">简单部署和简化运维</span></strong></h4><p><span style="color:#3e3e3e">BifroMQ 集群建立在一套内置的去中心化技术之上（base-cluster），无需依赖外部节点注册和发现服务。因此，构建 BifroMQ StandardCluster 的部署过程非常简单，只需指定任何一个集群中的节点作为种子节点，即可完成新节点的加入。此外，BifroMQ 还内置了集群分裂后的自愈能力，可以极大地简化出现网络分区（Network Partition）等故障时的运维操作。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 08:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266594/bifromq-2-0-0-released</guid>
            <link>https://www.oschina.net/news/266594/bifromq-2-0-0-released</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[CodeFuse 开源 ModelCache 大模型语义缓存]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p style="margin-left:0; margin-right:0"><img alt="" src="https://img.alicdn.com/imgextra/i2/O1CN01Moy0hq1P2Cgi8LERe_!!6000000001782-2-tps-900-383.png" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span>CodeFuse 开源火热进行中！本次开源的是 ModelCache 大模型语义缓存，可大幅降低大模型应用的推理成本，提升用户体验。</span></p><p style="margin-left:0; margin-right:0"><span>CodeFuse-ModelCache 项目地址：</span></p><p style="margin-left:0; margin-right:0"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-ModelCache" target="_blank" rel="nofollow"><span>https://github.com/codefuse-ai/CodeFuse-ModelCache</span></a></p><span id="OSC_h2_1"></span><h2><strong><span style="color:#000000">0 背景</span></strong></h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">在 LLM 技术浪潮席卷全球的背景下，大型模型快速增长的参数规模，对部署所需的推理资源带来了极大的挑战。为了提高大型模型的推理性能和效率，我们尝试从缓存角度解决当前大模型规模化服务部署的困境。类似传统应用，大模型的用户访问同样具有时间和空间的局部性（例如：热门话题相关内容，热门 GitHub repo）。如果有了缓存层，在遇到相似请求时，就无需调用大模型服务，直接从缓存的数据中返回已有的结果给用户，会大幅降低推理成本，提升用户体验。</span></p><span id="OSC_h2_2"></span><h2><span style="color:#333333">1 大模型缓存的意义</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">当前大模型服务面临一下三个挑战：</span></p><ol><li><span style="color:#333333">成本高：大模型参数量千亿级别，单实例就需要多张 A10 卡，规模化部署成本高昂。因此，当前大模型服务基本按照处理的 token 数量计费，导致用户侧使用成本也居高不下。</span></li><li><span style="color:#333333">速度慢：大型模型的推理速度也是一个关键问题。在许多实时应用中，如对话系统、业务助手，响应时间要求非常高，通常在毫秒级别。然而，大型模型的推理速度往往较慢，在秒级，导致无法实时返回结果，用户体验下降。</span></li><li><span style="color:#333333">稳定性无保障：由於单实例部署成本高昂，当前大模型服务接受到大流量请求时，通过限流的方式，防止服务不可用。</span></li></ol><span id="OSC_h2_3"></span><h2><span>2 方案调研</span></h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">我们对开源方案 GPTCache 进行了调研，其是致力于构建用于存储 LLM 响应的语义缓存的项目，该项目提供了语义相似度匹配框架，并提供了相对完善的功能模块和接口。具有以下优点：<span>&nbsp;</span></span></p><ul><li><span style="color:#333333">项目的活跃性，它不断引入新功能，使得我们能够紧跟最新的发展动态。<span>&nbsp;</span></span></li><li><span style="color:#333333">具备开放的功能模块，可以进行调整和优化，这为业务的扩展提供了便利。</span></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#333333">GPTCache 的整体架构如图 1 所示：</span></p><p style="margin-left:0; margin-right:0; text-align:left"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/275821/1699497539548-420014c2-90f5-45dc-929f-15a2e3d32ebf.png" width="642" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:center"><span style="color:#333333">图 1. GPTCache 架构</span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">但是，GPTCache 在落地应用上仍存在诸多不足，包括：</span></p><ol><li><span style="color:#333333">架构上将大模型调用和数据回写对用户进行了黑盒处理，使得大模型产品在流式输出、安全审核、问题排查等方面变的复杂。</span></li><li><span style="color:#333333">默认采用 faiss 和 sqlite 作为存储，不能进行分布式部署，尤其是在关系型数据库方面，SqlAlchemy 框架无法支持蚂蚁的 OceanBase。</span></li><li><span style="color:#333333">数据和资源隔离上，无法处理多模型多版本场景。</span></li><li><span style="color:#333333">不支持多轮会话，尤其是当模型有 system 指令时，无法很好兼容。更多待改进功能会在 3.3 部分会做详细介绍。</span></li></ol><span id="OSC_h2_4"></span><h2><span>3 ModelCache 建设</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">针对上述问题，我们基于 GPTCache 进行了二次开发，构建蚂蚁内部缓存产品 ModelCache，整体架构见图 2，接下来会详细介绍我们的工作，包括：3.1 整体架构；3.2 功能升级。在功能升级部分，会详细介绍 ModelCache 中新增的功能点。</span></p><span id="OSC_h3_5"></span><h3><span>3.1 整体架构</span></h3><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/305114/1699892547016-2e6263cc-8940-4c43-bffb-5bbd06c57998.png" width="941.818161404823" referrerpolicy="no-referrer"></p><p style="margin-left:16em; margin-right:0"><span>图 2. ModelCache 架构及上下游</span></p><span id="OSC_h4_6"></span><h4><span style="color:#000000">3.1.1 技术架构</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在初始架构中，将大模型调用和数据回写对用户进行了黑盒处理。然而，这种架构导致问题排查繁琐，以及流式输出和数据安全审核等方面难以满足企业级要求。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">因此，我们对架构进行了重新调整，ModelCache 采用了轻量化的接入方式，不打扰大模型产品的功能实现。我们设计 ModelCache 为类 redis 结构，提供了开放式的数据查询、数据回写、数据管理等 API，同时解</span><span style="color:#000000">耦</span><span style="color:#333333">了大模型调用，可作为一个独立模块嵌入到大模型产品。通过 ModelCache，产品侧能够更加灵活地管理和使用大模型，提高系统的可维护性和可扩展性。</span></p><span id="OSC_h4_7"></span><h4><span style="color:#000000">3.1.2 核心模块</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在 ModelCache 中，包含了一系列核心模块，包括 adapter、embedding、</span><span style="color:inherit">rank</span><span style="color:#333333">和 data_manager 等，具体功能如下：</span></p><ol><li><span>adapter 模块：其主要功能是处理各种任务的业务逻辑，并且能够将 embedding、</span><span style="color:inherit">rank</span><span>、data_manager 等模块串联起来。</span></li><li><span style="color:inherit">embedding 模块：该模块主要负责将文本转换为语义向量表示，它将用户的查询转换为向量形式，并用于后续的召回或存储操作。</span></li><li><span style="color:inherit">rank 模块：用于对召回的向量进行相似度排序和评估，可根据 L2 距离、余弦相似度或者评估模型，对两个向量进行相似度评分，并进行排序。</span></li><li><span style="color:inherit">data_manager 模块：该模块主要用于管理数据库，包括向量数据库和关系型数据库，它负责数据的存储、查询、更新和删除等操作。</span></li></ol><ol><li><ol><li><span style="color:inherit">向量数据库（Milvus）：</span><span style="color:#333333">Milvus 作为一个高性能、可扩展、多功能的向量数据库，适用于多种需要向量检索的应用场景。</span></li><li><span style="color:#333333">关系型数据库（OceanBase）：我们采用蚂蚁的 OceanBase 数据库，存储用户 query、LLM 相应、模型版本等信息。</span></li></ol></li></ol><span id="OSC_h4_8"></span><h4><span>3.1.3 功能对比</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">功能方面，为了解决 huggingface 网络问题并提升推理速度，增加了 embedding 本地推理能力。鉴于 SqlAlchemy 框架存在一些限制，我们对关系数据库交互模块进行了重写，以更灵活地实现数据库操作。在实践中，大型模型产品需要与多个用户和多个模型对接，因此在 ModelCache 中增加了对多租户的支持，同时也初步兼容了系统指令和多轮会话。更详细的功能对比请参见表 1。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333"><img alt="" src="https://img.alicdn.com/imgextra/i4/O1CN01P0Zr401heMlvow7LH_!!6000000004302-0-tps-716-788.jpg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0; text-align:center"><span>表 1. ModelCache 与 GPTCache 功能点对比</span></p><span id="OSC_h3_9"></span><h3><span>3.2 功能升级</span></h3><p style="margin-left:0; margin-right:0"><span style="color:inherit">为了将 Cache 产品应用于企业级用户，并实现真正的落地效果，我们对其功能进行了大量迭代升级，核心功能如图 3 所示。</span></p><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/2756586/1693799564935-9cb1f565-58a4-4f83-af78-54aaace84668.png" width="657" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:center"><span>图 3. ModelCache 核心功能</span></p><span id="OSC_h4_10"></span><h4><span>3.2.1 数据管理</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">Cache 需要确保过时或不必要的数据不会在缓存中累积，缓存管理是 Cache 中关键的一环，为此，我们实现了两个重要的功能：</span></p><ul><li><span>一键清空能力：</span><span style="color:#333333">ModelCache 中提供了数据移除接口，使用户能够一键清空其缓存。这项功能确保当模型版本或者参数发生变更时，前期版本的数据不会对线上的回答造成干扰。</span></li><li><span>缓存淘汰策略：</span><span style="color:#333333">ModelCache 支持可定制化的缓存淘汰策略，使用户能够根据自身需求来定制缓存。</span></li></ul><span id="OSC_h4_11"></span><h4><span>3.2.2 数据隔离</span></h4><p style="margin-left:0; margin-right:0"><span>在实际应用中，数据隔离是一个重要的功能，为了满足不同场景的需求，ModelCache 实现了多种数据隔离功能，包括：</span></p><ul><li><span>环境隔离： 支持在不同环境中进行数据隔离，包括 DEV、预发和线上环境。这些环境可能存在模型版本和参数上的差异，因此确保了数据在不同环境中的独立性。</span></li><li><span>模型隔离： 支持模型级别的隔离，使用向量数据库表和 OB 表字段实现独立存储。通过这种方式，不同模型之间的数据可以得到有效的隔离，确保数据的安全性和完整性。</span></li></ul><span id="OSC_h4_12"></span><h4><span>3.2.3 数据回流</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">数据回流功能具有知识持久化的能力，能够确保系统重要数据得到有效地保存和持续使用，从而支持系统的长期发展。为此，Cache 中提供了数据回流功能，使得系统中的数据能够得到有效的持久化，这项功能采用异步方式进行，尽可能减少对系统性能的影响。</span></p><span id="OSC_h4_13"></span><h4><span>3.2.4 system 指令及多轮对话支持</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在 ModelCache 中，提供了 system 指令和多轮对话支持，以满足用户的需求。具体如下：</span></p><ul><li><span style="color:#333333">system 指令支持： ModelCache 中支持 system 指令，尤其是后续用户可以自定义 system 指令的情况下，会区分不同 system 指令下对话的语义相似性，保持 Cache 的稳定性，未来，我们还计划将 system 指令与会话进行分离，以进一步提升系统的灵活性和可扩展性。</span></li><li><span style="color:#333333">多轮对话能力： ModelCache 还支持多轮对话，即能够匹配连续对话的语义相似性。</span></li></ul><span id="OSC_h4_14"></span><h4><span>3.2.5 可迁移性</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">ModelCache 具有出色的可迁移性，能够适应不同的场景，OceanBase 可以无缝迁移至 mysql 等产品，Milvus 也是一种可快速部署的数据库服务，所以无论是专有云还是公有云都能够快速应对，并提供高质量的服务。这种可迁移性意味着，ModelCache 可以为用户提供更加灵活和可扩展的部署方案，以满足不同的需求和场景。</span></p><span id="OSC_h4_15"></span><h4><span>3.2.6 Embedding 能力</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在当前的 cache 中，用户可使用中文通用 embedding 模型（text2vec-base-chinese）。我们也支持大模型 embedding 层的嵌入能力，这使得 embedding 能够更好地适应模型本身的语义，但仅使用大模型的 embedding 层，演变成了词袋模型，无法获取各个 token 的权重。为此，我们在训练 SGPT（GPT Sentence Embeddings<span>&nbsp;</span></span><span>for Semantic<span>&nbsp;</span></span><span style="color:#333333">Search），以更好的支持 ModelCache。</span></p><span id="OSC_h2_16"></span><h2>&nbsp;</h2><span id="OSC_h2_17"></span><h2><span>4 效果统计</span></h2><span id="OSC_h4_18"></span><h4><span>4.1 效率统计</span></h4><p style="margin-left:0; margin-right:0"><span>依据蚂蚁内部大模型产品的 GOC 日志信息，统计了缓存命中时长和直接调用模型时长，因为产品端采用了流式输出，时间上会有一定的增加。经过实际系统统计，命中缓存可以将平均耗时降低 10 倍，整体有效提速率可达 14.5%。有效提速率的定义参见下面公式：</span></p><p style="margin-left:0; margin-right:0"><span><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/ba80167f7563caedd5661a48c7813188.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">根据回流数据（排除流式输出的延迟），对缓存的耗时进行了评估，缓存未命中的耗时已经控制在数百毫秒量级，我们仍在持续进行查询耗时的优化。</span></p><span id="OSC_h4_19"></span><h4><span>4.2 embedding 模型的持续优化</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在缓存场景中，我们发现仅仅评估语义相似性是不够的，核心目标应该是判断 query 对应的大型模型输出是否一致（query 的语义相似不等价于大型模型的回复一致）。例如下面的 query，一词之差，但生成的结果是完全不同的</span></p><ul><li><ul><li><span style="color:#333333">query: 从 1 遍历到 1000，找出所有能被 13 和 23 整除的数字，用 Python 实现</span></li><li><span style="color:#333333">query: 从 1 遍历到 1000，找出所有能被 13 和 23 整除的数字，用 Java 实现</span></li></ul></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#333333">我们调研了 SentenceTransformer 领域的诸多模型，但都无法满足缓存场景的需求。因此训练了一个面向企业级应用的 embedding 模型，并希望在此基础上进一步提升语义相似度评估的准确性，以提高缓存的准确率。</span></p><span id="OSC_h2_20"></span><h2><span>5 未来展望</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">未来，我们旨在提供性能更强、精度更高的解决方案，以满足 LLM Cache 场景下的需求。将不断地进行研究和优化，以确保 Cache 系统能够在实际应用中取得最佳的性能和准确性</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">在性能方面，将通过深入优化各个环节，包括算法、数据和计算资源，以实现更快的召回时间，目标是将整体处理时间压缩到 300 毫秒以内，以提供更快捷高效的用户体验。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">在精度方面，将注重语义模型的建设，通过深入研究和改进语义表示技术，致力于提升模型对复杂语义的准确理解能力，从而更精准地匹配用户的 query。此外，还会对相似度评估模块进行优化，以进一步提升召回率。我们将综合考虑多种评估指标，如准确度、召回率和 F1 分数，以确保模型在各个方面都取得显著的提升。</span></p><span id="OSC_h2_21"></span><h2>&nbsp;</h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">想了解更多 CodeFuse 详情，点击进入</span><span style="color:#000000">CodeFuse 官网：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcodefuse.alipay.com%2F" target="_blank" rel="nofollow">https://codefuse.alipay.com</a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 08:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6942768/blog/10143074</guid>
            <link>https://my.oschina.net/u/6942768/blog/10143074</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Seata 进入 Apache 孵化器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#191919">Apache 基金会邮件列表<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fincubator.apache.org%2Fprojects%2Fseata.html" target="_blank">显示</a>，2023 年 10 月 29 日，分布式事务开源项目 Seata 正式通过 Apache 基金会的投票决议，正式成为 Apache 孵化器项目。</span></p><p><span style="background-color:#ffffff; color:#191919">Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</span></p><p><img height="243" src="https://oscimg.oschina.net/oscnet/up-d0f430ca0d175df97cdbcae3599abb935b9.png" width="700" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">2019 年 1 月，阿里巴巴中间件团队发起了开源项目<span>&nbsp;</span><a href="https://www.oschina.net/p/fescar" target="_blank">Fescar</a>（Fast &amp; EaSy Commit And Rollback），和社区一起共建开源分布式事务解决方案。Fescar 的愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong>Fescar 开源后，蚂蚁金服加入 Fescar 社区参与共建，并在 Fescar 0.4.0 版本中贡献了 TCC 模式。</strong></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">为了打造更中立、更开放、生态更加丰富的分布式事务开源社区，经过社区核心成员的投票，大家决定对 Fescar&nbsp;进行品牌升级，并更名为<span>&nbsp;</span><strong>Seata</strong>，意为：<strong>Simple Extensible Autonomous Transaction Architecture</strong>，是一套一站式分布式事务解决方案。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 08:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266588/seata-apache-incubator</guid>
            <link>https://www.oschina.net/news/266588/seata-apache-incubator</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux 内核中 Rust 的最新状态]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">在近日举行的 Linux Plumbers Conference 上，Linux 和 Rust 开发人员 Miguel Ojeda 向 Linux 内核开发人员介绍了有关 Linux 内核中 Rust 的最新情况。简而言之，Rust Linux 正在不断走向成熟，并得到了思科、三星和 Canonical 等开发者和供应商的大力支持。</span></p><p><span style="color:#000000">目前，一些发行版已经张开双臂拥抱 Rust。例如，Ubuntu 已经提供了「构建和测试树外内核模块所需的所有必要工具链和内核要求」。</span></p><p><span style="color:#000000">三大 Linux Rust 工具链也正在形成。一个是 rustc 的 GCC codegen，该工具链无需修改源代码即可编译并启动主线 Rust 和 Linux。</span></p><p><span style="color:#000000">另一个是 GCC Front-End for Rust，它可以由现有的 rustc 前端加载，但受益于 GCC 的优化；不过该项目仍处于 alpha 阶段。还有一个是 Coccinelle for Rust；Coccinelle 是一个用于制作大规模 Linux 内核 C 源代码的工具，而 Coccinelle for Rust 正试图将这一功能引入 Rust 代码库。</span></p><p><span style="color:#000000">一些开发者还在尝试使用 Rust 编写驱动程序。至于一些使 Rust 与 Linux 完全集成所需的日常工作，均可以在&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frust-for-linux.com%2F" target="_blank">Rust for Linux</a> 这一官方网站查询更多详情。</span></p><p><img height="222" src="https://oscimg.oschina.net/oscnet/up-331334d8e76a3e1efb2f883a44a9c3d254b.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">开发了两年之久的原始 rust 代码分支已经退役；代码还在，但已被冻结和归档。今后，rust-next 分支将包含新的 Rust 特性，并在 Linux 内核的下一个合并窗口中提交。而这个分支，顾名思义就是 Linux Next 的一部分。</span></p><p><span style="color:#000000">Rust-fixes 分支则包含 Linux 内核当前周期的 Rust 修复。还有一个用于集成的实验分支 Rust-dev ，是一个"look good enough"的补丁队列。</span></p><p><span style="color:#000000">理所当然的是，前进之路并非一帆风顺。Rust on Linux 的开发人员在过程中发现了一些问题：例如，当两个或多个线程等待另一个线程结束时，死锁在 Rust 中是安全的，因为它们不会导致未定义的行为，但它们在 Linux 内核中却不安全。目前开发人员正在努力解决这个问题。</span></p><p><span style="color:#000000">另一方面，开发人员还在担心如何处理 Rust 版本的问题。因为最新版本的 Rust Linux 兼容一些不稳定的功能，所以他们无法保证较新的 Rust 版本能在 Linux 中运行。Linux Rust 程序员现下正在跟踪最新版本的 Rust 编译器。</span></p><p><span style="color:#000000">与此相关的一个问题是，大众对将 Rust 支持反向移植到的 Linux 的 LTS 版本（特别是 5.15 和 6.1）中越来越感兴趣。但 Linux 通常不允许将 Rust 移植到 LTS Linux 中。因此，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zdnet.com%2Farticle%2Frust-in-linux-where-we-are-and-where-were-going-next%2F" target="_blank">ZDNet</a> 指出，如果你真的非常想要在旧版的 LTS 内核中获得功能齐全的 Rust 支持，那么你就需要以某种方式支付费用。</span></p><p><span style="color:#000000">总的来说，Rust 无疑正在成为 Linux 开发的重要语言。但在这一进程中无疑还有许多挑战需要克服，正如 Ojeda&nbsp;所述，虽然「核心团队随着新成员的加入而成长」，但前进之路上仍有很多工作要完成。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 08:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266584/rust-in-linux</guid>
            <link>https://www.oschina.net/news/266584/rust-in-linux</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Telegram 演示运行于 visionOS 的原生应用]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Telegram 创始人帕维尔-杜罗夫 (Pavel Durov) 今天展示了 Telegram 即将推出的 visionOS 应用程序的简短一瞥，这是我们目前看到的首批第三方 visionOS 应用程序概念之一。</p><p>在 Telegram 上提供的视频中，Telegram 应用采用了半透明设计，与周围区域融为一体，这也是苹果为 visionOS 所采用的设计语言。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-22ca9cb9d4938d2680c3ed6406f83b992af.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1115/150409_gDLb_2720166.png" referrerpolicy="no-referrer"></p><p>该应用的侧边栏列出了用户正在进行的所有可用对话。播放的视频会从界面中跳出，变得更加身临其境，而 emoji 字符则会占据显示屏，并在分享时以独特的方式呈现出动画效果。用户可以使用虚拟键盘或通过 Siri 听写来发送信息。</p><p>与主页界面上的所有 visionOS 图标一样，Telegram 图标在被视觉选中时会以动画的形式弹出，动画可作为应用程序被突出显示的视觉提示。由于 Vision Pro 头显使用眼睛和手势导航，因此手指轻点即可启动应用。</p><p>苹果预计将于 2024 年初推出 Vision Pro，也就是四月份或之前。随着首发日期的临近，我们很快就会看到许多其他第三方应用程序的 VisionOS 体验。</p><p><strong>演示视频可用 Telegram 观看：</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ft.me%2Fdurov%2F239" target="_blank">https://t.me/durov/239</a></p><hr><p>延伸阅读</p><ul><li><a href="https://www.oschina.net/news/244019/visionos-apples-latest-operating-system">苹果宣布最新操作系统：visionOS</a></li><li><a href="https://www.oschina.net/news/251993">Vision Pro 新专利：可模拟生成气味</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 07:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266572/telegram-visionos-app</guid>
            <link>https://www.oschina.net/news/266572/telegram-visionos-app</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[ChatGPT Plus 临时暂停新用户注册，CEO 称服务器扛不住了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenAI 首席执行官 Sam Altman 今日<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fsama%2Fstatus%2F1724626002595471740" target="_blank">发表推文称</a></u>，目前暂时暂停 ChatGPT Plus 新用户注册，原因是<strong>「自 DevDay 大会后，ChatGPT 使用量的激增超出了我们的承受能力，我们希望确保每个人都有良好的体验」</strong>。</p><p><img src="https://static.oschina.net/uploads/space/2023/1115/134613_H0qt_2720166.png" referrerpolicy="no-referrer"></p><blockquote><p>via&nbsp;<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fsama%2Fstatus%2F1724626002595471740" target="_blank">https://twitter.com/sama/status/1724626002595471740</a></u></em></p></blockquote><p><span>上周 ChatGPT 因为流量过高导致服务不稳定，</span><u><a href="https://www.oschina.net/news/265693">而中断了 2 个小时</a></u><span>。半年前，OpenAI 刚上线 ChatGPT Plus 订阅计划时，也是这番操作：</span><em><u><a href="https://www.oschina.net/news/235524/openai-has-temporarily-stopped-selling-the-plus" target="_blank">OpenAI 暂时关闭 ChatGPT Plus 升级</a></u></em><span>。</span></p><p>根据调查机构&nbsp;Writerbuddy.ai&nbsp;公布的一份报告，排名前 50 名的 AI 工具在 10 个月中累计被访问 240 亿次，<strong>而其中 ChatGPT 达到了惊人的 146 亿次，占比超过 60%，平均每月访问 15 亿次</strong>。排名前十的还有 Hugging Face、谷歌 BARD、Novel AI、Capcut、Janitor AI 和 Civit AI 等等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b6328a3f5e61c49394df02d7c0d63287218.png" referrerpolicy="no-referrer"></p><p>OpenAI 于 11 月 7 日举行了其首届开发者大会 DevDay，期间<u><a href="https://www.oschina.net/news/265331/openai-custom-versions-chatgpt"> CEO 重磅推出 GPTs </a></u>——允许开发者和公司定制 ChatGPT，以满足他们的特定需求和服务。</p><p><img height="802" src="https://static.oschina.net/uploads/space/2023/1115/141558_VJJd_2720166.png" width="1452" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#000000">GPTs 是一种新方式，任何人都可以创建 ChatGPT 的定制版本，以便在日常生活、特定任务、工作或家庭中更有帮助，然后与其他人分享该创作。例如，GPTs 可以帮助你学习任何棋盘游戏的规则、帮助你指导孩子的数学或设计贴纸。</span></p><p><em>DevDay 大会回顾</em></p><ul><li><u><em><a href="https://www.oschina.net/news/265330" target="_blank">OpenAI 开发者大会：GPT-4 Turbo、GPTs 商店、128k 上下文窗口、大降价</a></em></u></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 05:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266554</guid>
            <link>https://www.oschina.net/news/266554</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[悬赏十几万元以用 Rust 重写 Prettier]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Facebook 法国前端工程师、React Native 和 Prettier 的联合创始人 Vjeux&nbsp;在 Twitter </span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2FVjeux%2Fstatus%2F1722733472522142022" target="_blank">发帖</a><span style="color:#000000">，寻求有能力的开发者来使用 Rust 重写前端代码格式化工具&nbsp;Prettier，并悬赏 1 万美元。</span></p><blockquote><p><span style="color:#000000">使用 Rust 实现更快、更美观的 printers 引起了广泛关注。但主要问题在于，它们都无法与 prettier 的长尾格式化逻辑相匹配。</span></p><p><span style="color:#000000">如果用 Rust 编写的项目能通过通过 95% 以上的 prettier JavaScript 测试，我将悬赏 1 万美元。</span></p></blockquote><p><img alt="" height="229" src="https://oscimg.oschina.net/oscnet/up-6f7c5921c3486449f168f164f0c04ed72c1.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Vercel 的首席执行官&nbsp;Guillermo Rauch&nbsp;也跟帖<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Frauchg%2Fstatus%2F1723400569392656771" target="_blank">表示</a>，进一步对该悬赏进行加码，将赏金升级到了 2 万美元。</span></p><p><span style="color:#000000">此外，Wasmer 官方也附议了&nbsp;Vjeux 的这一提议，并表示将额外提供 2500 美元的奖励。「我们喜欢这一倡议！如果项目编译到 WASIX 并（通过 CI）发布到 Wasmer，我们将为项目所有者额外奖励 2500 美元。」</span></p><p><span style="color:#000000">Prettier 是一个 「有主见」 的代码格式化工具。它通过解析你的代码并根据自己的规则 re-printing（将最大行长考虑在内），并在必要时对代码进行封装，从而实现一致的风格。简而言之，这个工具能够使输出代码保持风格一致。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 04:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266545/rewriting-prettier-rust</guid>
            <link>https://www.oschina.net/news/266545/rewriting-prettier-rust</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[11.25 源创会杭州站报名开启：从数据到大模型应用]]>
            </title>
            <description>
                <![CDATA[11.25 源创会杭州站报名开启：从数据到大模型应用]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 03:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/action/visit/ad?id=1558</guid>
            <link>https://www.oschina.net/action/visit/ad?id=1558</link>
        </item>
        <item>
            <title>
                <![CDATA[开源多媒体播放器 VLC 发布 3.0.20，为 Windows 添加 AV1 硬件解码]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>开源多媒体播放器 VLC 近日了发布了最新版本 3.0.20。</p><p><img alt="" height="319" src="https://oscimg.oschina.net/oscnet/up-b17d30ec88965ab4d14a96a982f5e49804d.png" width="500" referrerpolicy="no-referrer"></p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.videolan.org%2Fnews.html%23news-2023-11-02" target="_blank">公告写道</a></u>，这是 VLC 3.0 分支的中度更新：它升级了编解码器，修复了 FLAC 的质量问题，并改进了多种格式的播放，包括改进字幕渲染。它还修复了使用逐帧操作时的冻结问题。在 macOS 上，音频布局问题也得到了解决。</p><p>更新日志如下：</p><ul><li>VLC 3.0.20 是 "Vetinari" 系列的第 21 次更新</li><li>改进了多种格式的播放，包括某些字幕的渲染</li><li>升级编解码器</li><li>修复 FLAC 渲染质量问题</li><li>修复使用某些旧版 AMD GPU 显卡驱动程序播放大量文件存在的问题</li><li>在 Windows 上添加 AV1 硬件解码</li><li>升级了大量第三方库</li><li>提升 SMB 与 Windows 11 主机的兼容性</li><li>优化本地化翻译</li><li>修复两个安全问题，详见：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.videolan.org%2Fsecurity%2Fsb-vlc3019.html" target="_blank">1</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.videolan.org%2Fsecurity%2Fsb-vlc3020.html" target="_blank">2</a></li></ul><p>下载地址：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.videolan.org%2Fvlc%2Freleases%2F3.0.20.html" target="_blank">https://www.videolan.org/vlc/releases/3.0.20.html</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 03:25:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266538/vlc-3-0-20</guid>
            <link>https://www.oschina.net/news/266538/vlc-3-0-20</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[李彦宏：百度目前 20% 代码由 AI 完成]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#222222">11 月 15 日，李彦宏在深圳举行的西丽湖论坛上表示，</span><span style="background-color:#ffffff; color:#3b3b3b">百度已经对旗下各产品线进行了 AI 原生化重构，</span><span style="background-color:#ffffff; color:#222222">百度每 100 行代码，20 行就由 AI 完成。</span></p><p><span style="background-color:#ffffff; color:#222222">他表示，大模型是基础底座，类似操作系统不会太多，重复开发大模型是对基础资源的浪费。文心一言有了很大进步，其调用量比国内其他两百家还多。</span></p><p><span style="background-color:#ffffff; color:#222222">目前，文心一言已有 800 万开发者，开发者可以通过插件调用文心一言。</span></p><p><img height="304" src="https://static.oschina.net/uploads/space/2023/1115/111350_ZpLo_4252687.png" width="700" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 03:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266536</guid>
            <link>https://www.oschina.net/news/266536</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[「零一万物」 回应 Yi 开源大模型「套壳」 Llama]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>李开复旗下 AI 公司<span style="background-color:#ffffff; color:#333333">「</span>零一万物<span style="background-color:#ffffff; color:#333333">」&nbsp;</span>(<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2F01.AI" target="_blank">01.AI</a>)&nbsp;<span style="background-color:#ffffff; color:#333333">上周</span><u><a href="https://www.oschina.net/news/265142/01-ai-valued-at-1b-open-source-yi-llm" target="_blank">宣布</a></u><strong>推出&nbsp;Yi-34B 和&nbsp;Yi-6B 两个开源大模型。</strong>其公布的基准测试结果显示虽然模型参数少于其它大模型，但性能更出色。零一万物的估值高达 10 亿美元，已跻身独角兽行列。</p><p>Yi 正式开源数日后，在其<span style="background-color:#ffffff; color:#333333"><span>&nbsp;</span>Hugging Face 主页的讨论区中，有人指出&nbsp;</span>Yi-34B 完全使用了 Meta 开源大模型 Llama 的架构，最明显的变化只是修改了张量 (Tensor) 名称。</p><p><img alt="111349_Novu_2720166.png" src="https://static.oschina.net/uploads/space/2023/1114/111349_Novu_2720166.png" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#333333">来源：</span><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11" target="_blank">https://huggingface.co/01-ai/Yi-34B/discussions/11</a></u></em></p><p>根据公开的信息，Yi 系列开源大模型没有在开源 License 中提及 Llama。上面的帖子内容经过广泛传播后，零一万物的 Yi 系列大模型被质疑是 Llama 的套壳。</p><p>昨天，「零一万物」 正式公开回应了此事。根据该公司开源团队总监<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">&nbsp;</a></u><span style="background-color:#ffffff"><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">Richard Lin 的跟帖回复</a></u>，他们承认了修改 Llama 张量名称的做法不妥，并会按照建议进行修改。</span></p><p>Richard Lin 称此问题是团队的疏忽。因为在大量的训练实验中，<strong>他们对代码进行了多次重命名，以满足实验要求</strong>。但最后没有在发布之前将它们改回来。他为这个失误造成的混乱表示抱歉。</p><p><span style="background-color:#ffffff">与此同时，Richard Lin 邀请这名指出问题的开发者提交包含上述改动的 PR——对 Yi 的张量名称进行重命名以符合 Llama 架构。</span></p><p><img src="https://oscimg.oschina.net/oscnet/up-5607cfe7fee8c2aaf087104396bd1d3d785.png" referrerpolicy="no-referrer"></p><p>最后，<span style="background-color:#ffffff">Richard Lin&nbsp;</span>表示团队会增强对流程的执行，避免此类错误再次发生，他们也将再次检查所有代码，确保其他一切正常。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266525</guid>
            <link>https://www.oschina.net/news/266525</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[EmotiVoice —— 多音色提示控制 TTS 引擎]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong>EmotiVoice（易魔声）</strong>是一个强大的开源 TTS 引擎，支持中英文双语，包含 2000 多种不同的音色，以及特色的<strong>情感合成</strong>功能，支持合成包含快乐、兴奋、悲伤、愤怒等广泛情感的语音。</p><p>EmotiVoice 提供一个易于使用的 Web 界面，还有用于批量生成结果的脚本接口。</p><p>点此查看具体示例：<em><u><a href="https://github.com/netease-youdao/EmotiVoice/blob/main/README.zh.md">https://github.com/netease-youdao/EmotiVoice/blob/main/README.zh.md</a></u></em></p></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/emotivoice</guid>
            <link>https://www.oschina.net/p/emotivoice</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 3D 裸眼风扇屏]]>
            </title>
            <description>
                <![CDATA[<p>项目说明</p><p>本项目是制作一个 3D 裸眼风扇广告机，它是一款裸眼 D 的新型产品，采用晶片、磁铁、发光二极管 (LED) 技能及螺旋桨叶片组合而成,叶片在驱动下随之动弹，继而显现出 D 浮空影像。同时还设计了喇叭，可以实现播放视频、听音乐功能</p><p>视频介绍：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1tN411y7ZS%2F">https://www.bilibili.com/video/BV1tN411y7ZS/</a></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/EE64VlOi1zKg5iufuLVZ46TzYQD5CyY1EIlaoftN.png" alt="输入图片说明" referrerpolicy="no-referrer"></p><p>开源协议</p><p>依据 GPL 3.0 开源协议，可以复制、修改和传播，并且不限制商业使用。</p><p>项目相关功能</p><p>1.图片显示，160x160 的分辨率，上传 jpeg 图片格式，可以显示多张图片</p><p>2.视频播放，不能直接播放 MP4 文件，需要单独解码后才能播放</p><p>3.音乐播放，可以播放音乐 wav 文件。</p><p>4.云端控制，使用手机 APP 进行控制。包括上传图片，开启/停止功能，按钮选择功能</p><p>项目属性</p><p>本项目为首次公开，为本人原创项目。项目未曾在别的比赛中获奖。</p><p>项目进度</p><p>2023 年 2 月 14 日，开始设计</p><p>2023 年 3 月 30 日，完成第一版设计，40x40 分辨率</p><p>2023 年 4 月 4 日，开始设计第二版本提高清晰度，160x160 分辨率</p><p>2023 年 4 月 15 日，开始编写 ESP32 程序，调试电机驱动，LED 显示，音乐播放功能。</p><p>2023 年 5 月 10 日，开始编写手机 APP，实现联网远程控制。</p><p>设计原理</p><p>电路部分</p><p>主控芯片选择 ESP32S3，带有 WiFi 功能，可以实现云端控制。ESP32S3 作为一个双核 240MHZ 处理器，有足够的性能解码 JPEG 图片，mp3 音乐文件。</p><p>电机驱动采用 TMC2209 芯片来驱动一个 28 步进电机，低速时可以静音驱动，带来很好的体验，不会影响音乐播放带来噪音。</p><p>LED 灯采用 WS2812 幻彩灯珠，1615 的小体积封装提高分辨率</p><p>音频驱动采用 MAX98357 芯片，可以驱动一个 3W 的小喇叭。</p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/CFYaQ1z8zbUII5cQohjbOsVbOxdZFypDSe3vojc9.png" alt="输入图片说明" referrerpolicy="no-referrer"></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/RHMgoiHGHXX0bkLdOpdoSmeQOL4TWiKnvqgOOZ2d.png" alt="输入图片说明" referrerpolicy="no-referrer"></p><p>外壳部分</p><p>使用 FreeCAD 软件进行外壳设计。在本次结构设计中有一个难点就是如何给电路板供电，采用电池供电但是续航不久，于是不采用。使用外置电源不用考虑续航问题，但绕线是个问题。于是设计了一个采用轴承导电的机构。其他零件使用 3D 打印出来。</p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/1tbNw9FV6ZrYcSQyd77pQUfiaCVZzsD01rQS1G1d.png" alt="输入图片说明" referrerpolicy="no-referrer"></p><p>软件说明</p><p>ESP32 主控</p><p>ESP32 主控主要是编写 LED 驱动程序，JPEG 图片解码程序，wav 音乐解码播放，已及通 MQTT 订阅来接收云端数据，实现远程控制。如下是一些主要代码</p><p>手机 APP</p><p>手机 App 是使用前端 html 和 JavaScript 写的一个网页，然后对网页打包成安卓应用。实现的功能主要有上传图片，控制 esp32 的各种功能。部分程序如下</p><p>此外为了实现流畅播放视频，我单独使用 python 脚本对视频进行了解码。</p><p>实物展示</p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/BDFCIOQkqrGEZcxuzO4QxZbk8wA5NyMuNJfNLNzm.jpeg" alt="输入图片说明" referrerpolicy="no-referrer"></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/JH1S503sxnVDZRkepAYyLV9BkgoL1VhoYjJtwW90.jpeg" alt="输入图片说明" referrerpolicy="no-referrer"></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/YWbrYCHZBPEeR5dIZoKDOrNhZc62yBtoJYfjzUgY.jpeg" alt="输入图片说明" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>其他</p><p>视频讲解稍后上传</p>]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/qzr123/3-d-bare-eye-fan-screen</guid>
            <link>https://gitee.com/qzr123/3-d-bare-eye-fan-screen</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | MYSQL 事务的底层原理]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><span><span>事务的底层原理</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在事务的实现机制上，MySQL 采用的是 WAL：Write-ahead logging，预写式日志，机制来实现的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在使用 WAL 的系统中，所有的修改都先被写入到日志中，然后再被应用到系统中。通常包含 redo 和 undo 两部分信息。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>为什么需要使用 WAL，然后包含 redo 和 undo 信息呢？举个例子，如果一个系统直接将变更应用到系统状态中，那么在机器掉电重启之后系统需要知道操作是成功了，还是只有部分成功或者是失败了。如果使用了 WAL，那么在重启之后系统可以通过比较日志和系统状态来决定是继续完成操作还是撤销操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>redo log 称为重做日志，每当有操作时，在数据变更之前将操作写入 redo log，这样当发生掉电之类的情况时系统可以在重启后继续操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>undo log 称为撤销日志，当一些变更执行到一半无法完成时，可以根据撤销日志恢复到变更之间的状态。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>MySQL 中用 redo log 来在系统 Crash 重启之类的情况时修复数据，而 undo log 来保证事务的原子性。</span></span></span></p><span id="OSC_h2_2"></span><h2><span><span><span>事务 id</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>一个事务可以是一个只读事务，或者是一个读写事务：可以通过 START TRANSACTION READ ONLY 语句开启一个只读事务。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在只读事务中不可以对普通的表进行增、删、改操作，但可以对用户临时表做增、删、改操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以通过 START TRANSACTION READ WRITE 语句开启一个读写事务，或者使用 BEGIN、START TRANSACTION 语句开启的事务默认也算是读写事务。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在读写事务中可以对表执行增删改查操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>如果某个事务执行过程中对某个表执行了增、删、改操作，那么 InnoDB 存储引擎就会给它分配一个独一无二的事务 id，针对 MySQL 5.7 分配方式如下：</span></strong></span></span></p><ul><li><span><span><span><span>对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个事务 id，否则的话是不分配事务 id 的。</span></span></span></span></li><li><span><span><span><span>对于读写事务来说，只有在它第一次对某个表执行增、删、改操作时才会为这个事务分配一个事务 id，否则的话也是不分配事务 id 的。</span></span></span></span></li><li><span><span><span><span>有的时候虽然开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个事务 id。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>这个事务 id 本质上就是一个数字，它的分配策略和隐藏列 row_id 的分配策略大抵相同，具体策略如下：</span></strong></span></span></p><ul><li><span><span><span><span>服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个事务 id 时，就会把该变量的值当作事务 id 分配给该事务，并且把该变量自增 1。</span></span></span></span></li><li><span><span><span><span>每当这个变量的值为 256 的倍数时，就会将该变量的值刷新到系统表空间的页号为 5 的页面中一个称之为 Max Trx ID 的属性处，这个属性占用 8 个字节的存，储空间。</span></span></span></span></li><li><span><span><span><span>当系统下一次重新启动时，会将上边提到的 Max Trx ID 属性加载到内存中，将该值加上 256 之后赋值给全局变量，因为在上次关机时该全局变量的值可能大于 Max Trx ID 属性值。</span></span></span></span></li><li><span><span><span><span>这样就可以保证整个系统中分配的事务 id 值是一个递增的数字。先被分配 id 的事务得到的是较小的事务 id，后被分配 id 的事务得到的是较大的事务 id。</span></span></span></span></li></ul><span id="OSC_h2_3"></span><h2><span><span><span>mvcc</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>全称 Multi-Version Concurrency Control，即多版本并发控制，主要是为了提高数据库的并发性能。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>同一行数据平时发生读写请求时，会上锁阻塞住。但 MVCC 用更好的方式去处理读写请求，做到在发生读写请求冲突时不用加锁。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这个读是指的快照读，而不是当前读，当前读是一种加锁操作，是悲观锁。</span></span></span></p><span id="OSC_h3_4"></span><h3><span><span><span>MVCC 原理</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在事务并发执行遇到的问题如下：</span></span></span></p><ul><li><span><span><span><span>脏读：如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了脏读；</span></span></span></span></li><li><span><span><span><span>不可重复读：如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了不可重复读；</span></span></span></span></li><li><span><span><span><span>幻读：如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了幻读，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录，幻读只是重点强调了读取到了之前读取没有获取到的记录。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>MySQL 在 REPEATABLE READ 隔离级别下，是可以很大程度避免幻读问题的发生的。</span></strong></span></span></p><span id="OSC_h4_5"></span><h4><span><span><span>版本链</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：</span></span></span></p><ul><li><span><span><span><span>trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务 id 赋值给 trx_id 隐藏列；</span></span></span></span></li><li><span><span><span><span>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo 日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修，改前的信息；</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>演示</span></strong></span></span></p><pre><code><span><span><span style="color:#708090">-- 创建表</span></span><span><span></span></span><span><span style="color:#0077aa">CREATE</span></span><span><span></span></span><span><span style="color:#0077aa">TABLE</span></span><span><span> mvcc_test </span></span><span><span style="color:#999999">(</span></span><span><span>
id </span></span><span><span style="color:#0077aa">INT</span></span><span><span style="color:#999999">,</span></span><span><span>
name </span></span><span><span style="color:#0077aa">VARCHAR</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">100</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">,</span></span><span><span>
domain </span></span><span><span style="color:#0077aa">varchar</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">100</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">PRIMARY</span></span><span><span></span></span><span><span style="color:#0077aa">KEY</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>id</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">Engine</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#0077aa">InnoDB</span></span><span><span></span></span><span><span style="color:#0077aa">CHARSET</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span>utf8</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 添加数据</span></span><span><span></span></span><span><span style="color:#0077aa">INSERT</span></span><span><span></span></span><span><span style="color:#0077aa">INTO</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">VALUES</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'habit'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'演示 mvcc'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>假设插入该记录的事务 id=50，那么该条记录的展示如图：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-497oLuqeLE7xPfzmr.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>假设之后两个事务 id 分别为 70、90 的事务对这条记录进行 UPDATE 操作。</span></span></span></p><div><table cellspacing="0" style="--tw-ring-color:rgba(59,130,246,.5); --tw-ring-inset:var(--tw-empty,/*!*/ /*!*/); --tw-ring-offset-color:#ffffff; --tw-ring-offset-shadow:0 0 #0000; --tw-ring-offset-width:0px; --tw-ring-shadow:0 0 #0000; --tw-shadow:0 0 #0000; border-collapse:collapse; border-color:inherit; border-style:solid; border-width:0px; box-sizing:border-box; margin:0px; outline:none; padding:0px; text-indent:0px; width:auto"><tbody><tr><th style="background-color:var(--w-e-textarea-slight-bg-color); text-align:center"><span><span><span>trx_id=70</span></span></span></th><th style="background-color:var(--w-e-textarea-slight-bg-color); text-align:center"><span><span><span>trx_id=90</span></span></span></th></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>begin</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>begin</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_70_01' where id=1</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_70_02' where id=1</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>commit</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_90_01' where id=1</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_90_02' where id=1</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>commit</span></span></span></td></tr></tbody></table></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>每次对记录进行改动，都会记录一条 undo 日志，每条 undo 日志也都有一个 roll_pointer 属性，可以将这些 undo 日志都连起来，串成一个链表。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-49y0loF49tpKQ7swfq.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>对该记录每次更新后，都会将旧值放到一条 undo 日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务 id。于是可以利用这个记录的版本链来控制并发事务访问相同记录的行为，那么这种机制就被称之为：</span></span></span><span><span><strong><span>多版本并发控制，即 MVCC。</span></strong></span></span></p><span id="OSC_h4_6"></span><h4><span><span><span>ReadView</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于使用 READ UNCOMMITTED 隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于使用 SERIALIZABLE 隔离级别的事务来说，InnoDB 使用加锁的方式来访问记录。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：READ COMMITTED 和 REPEATABLE READ 隔离级别在不可重复读和幻读上的区别是从哪里来的，其实结合前面的知识，这两种隔离级别关键是需要判断一下版本链中的哪个版本是当前事务可见的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>为此，InnoDB 提出了一个 ReadView 的概念，这个 ReadView 中主要包含 4 个比较重要的内容：</span></strong></span></span></p><ul><li><span><span><span><span>m_ids：表示在生成 ReadView 时当前系统中活跃的读写事务的事务 id 列表；</span></span></span></span></li><li><span><span><span><span>min_trx_id：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的事务 id，也就是 m_ids 中的最小值；</span></span></span></span></li><li><span><span><span><span>max_trx_id：表示在生成 ReadView 时系统中应该分配给下一个事务的 id 值，注：max_trx_id 并不是 m_ids 中的最大值，事务 id 是递增分配的。比方说现在有 id 为 1，2，3 这三个事务，之后 id 为 3 的事务提交了。那么一个新的读事务在生成 ReadView 时，m_ids 就包括 1 和 2，min_trx_id 的值就是 1，max_trx_id 的值就是 4；</span></span></span></span></li><li><span><span><span><span>creator_trx_id：表示生成该 ReadView 的事务的事务 id；</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>有了这个 ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</span></span></span></p><ol><li><span><span><span><span>如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问；</span></span></span></span></li><li><span><span><span><span>如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问；</span></span></span></span></li><li><span><span><span><span>如果被访问版本的 trx_id 属性值大于或等于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问；</span></span></span></span></li><li><span><span><span><span>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间 min_trx_id &lt; trx_id &lt; max_trx_id，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问；</span></span></span></span></li><li><span><span><span><span>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录；</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 MySQL 中，READ COMMITTED 和 REPEATABLE READ 隔离级别的一个非常大的区别就是它们生成 ReadView 的时机不同。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>还是以表 mvcc_test 为例，假设现在表 mvcc_test 中只有一条由事务 id 为 50 的事务插入的一条记录，接下来看一下 READ COMMITTED 和 REPEATABLE READ 所谓的生成 ReadView 的时机不同到底不同在哪里。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>READ COMMITTED：</span></strong></span></span><span><span><span> 每次读取数据前都生成一个 ReadView；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比方说现在系统里有两个事务 id 分别为 70、90 的事务在执行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- T 70</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此时表 mvcc_test 中 id 为 1 的记录得到的版本链表如下所示：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-50mpbjn7HMKz7hBhK.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>假设现在有一个使用 READ COMMITTED 隔离级别的事务开始执行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 READ COMMITTED 隔离级别的事务</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值为'habit'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>这个 SELECE1 的执行过程如下：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在执行 SELECT 语句时会先生成一个 ReadView，ReadView 的 m_ids 列表的内容就是[70, 90]，min_trx_id 为 70，max_trx_id 为 91，creator_trx_id 为 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 habit_trx_id_70_02，该版本的 trx_id 值为 70，在 m_ids 列表内，所以不符合可见性要求第 4 条：</span></span></span><span><span><code><strong><span>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间 min_trx_id &lt; trx_id &lt; max_trx_id，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</span></strong></code></span></span><span><span><span>根据 roll_pointer 跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit_trx_id_70_01，该版本的 trx_id 值也为 70，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit，该版本的 trx_id 值为 50，小于 ReadView 中的 min_trx_id 值，所以这个版本是符合要求的第 2 条：</span></span></span><span><span><strong><span>如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</span></strong></span></span><span><span><span>最后返回的版本就是这条列 name 为 habit 的记录。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>之后，把事务 id 为 70 的事务提交一下，然后再到事务 id 为 90 的事务中更新一下表 mvcc_test 中 id 为 1 的记录：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- T 90</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此时表 mvcc 中 id 为 1 的记录的版本链就长这样：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-507DFORnJ7Is10E8bC.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>然后再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 READ COMMITTED 隔离级别的事务</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 均未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值为'habit'</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE2：Transaction 70 提交，Transaction 90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值为'habit_trx_id_70_02'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>这个 SELECE2 的执行过程如下：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在执行 SELECT 语句时又会单独生成一个 ReadView，该 ReadView 的 m_ids 列表的内容就是[90]，min_trx_id 为 90，max_trx_id 为 91，creator_trx_id 为 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 habit_trx_id_90_02，该版本的 trx_id 值为 90，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit_trx_id_90_01，该版本的 trx_id 值为 90，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit_trx_id_70_02，该版本的 trx_id 值为 70，小于 ReadView 中的 min_trx_id 值 90，所以这个版本是符合要求的，最后返回这个版本中列 name 为 habit_trx_id_70_02 的记录。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>以此类推，如果之后事务 id 为 90 的记录也提交了，再次在使用 READ COMMITTED 隔离级别的事务中查询表 mvcc_test 中 id 值为 1 的记录时，得到的结果就是 habit_trx_id_90_02 了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>总结：</span></strong></span></span><span><span><span>使用 READ COMMITTED 隔离级别的事务在每次查询开始时都会生成一个独立的 ReadView。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>REPEATABLE READ：</span></strong></span></span><span><span><span>在第一次读取数据时生成一个 ReadView；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于使用 REPEATABLE READ 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView，之后的查询就不会重复生成了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比方说现在系统里有两个事务 id 分别为 70、90 的事务在执行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- T 70</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此时表 mvcc_test 中 id 为 1 的记录得到的版本链表如下所示：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-51UwvDNOV077PoRbf.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>假设现在有一个使用 REPEATABLE READ 隔离级别的事务开始执行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 REPEATABLE READ 隔离级别的事务</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值为'habit'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>这个 SELECE1 的执行过程如下：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在执行 SELECT 语句时会先生成一个 ReadView，ReadView 的 m_ids 列表的内容就是[70, 90]，min_trx_id 为 70，max_trx_id 为 91，creator_trx_id 为 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 habit_trx_id_70_02，该版本的 trx_id 值为 70，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit_trx_id_70_01，该版本的 trx_id 值也为 70，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit，该版本的 trx_id 值为 50，小于 ReadView 中的 min_trx_id 值，所以这个版本是符合要求的，最后返回的就是这条列 name 为 habit 的记录。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>之后，把事务 id 为 70 的事务提交一下，然后再到事务 id 为 90 的事务中更新一下表 mvcc_test 中 id 为 1 的记录：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 REPEATABLE READ 隔离级别的事务</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此刻，表 mvcc_test 中 id 为 1 的记录的版本链就长这样：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-51h9D8xW10EuQBNz51m.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 REPEATABLE READ 隔离级别的事务</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 均未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值为'habit'</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE2：Transaction 70 提交，Transaction 90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span> &nbsp;</span></span><span><span style="color:#708090">-- 得到的列 name 的值为'habit'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这个 SELECE2 的执行过程如下：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>因为当前事务的隔离级别为 REPEATABLE READ，而之前在执行 SELECE1 时已经生成过 ReadView 了，所以此时直接复用之前的 ReadView，之前的 ReadView 的 m_ids 列表的内容就是[70, 90]，min_trx_id 为 70，max_trx_id 为 91， creator_trx_id 为 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 habit_trx_id_90_02，该版本的 trx_id 值为 90，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit_trx_id_90_01，该版本的 trx_id 值为 90，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit_trx_id_70_02，该版本的 trx_id 值为 70，而 m_ids 列表中是包含值为 70 的事务 id 的，所以该版本也不符合要求，同理下一个列 name 的内容是 habit_trx_id_70_01 的版本也不符合要求。继续跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit，该版本的 trx_id 值为 50，小于 ReadView 中的 min_trx_id 值 70，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 name 为 habit 的记录。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>也就是说两次 SELECT 查询得到的结果是重复的，记录的列 name 值都是 habit，这就是可重复读的含义。如果之后再把事务 id 为 90 的记录提交了，然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这个 id 为 1 的记录，得到的结果还是 habit。</span></span></span></p><span id="OSC_h3_7"></span><h3><span><span><span>MVCC 下的幻读解决和幻读现象</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>REPEATABLE READ 隔离级别下 MVCC 可以解决不可重复读问题，那么幻读呢？MVCC 是怎么解决的？幻读是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录，而这个记录来自另一个事务添加的新记录。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以想想，在 REPEATABLE READ 隔离级别下的事务 T1 先根据某个搜索条件读取到多条记录，然后事务 T2 插入一条符合相应搜索条件的记录并提交，然后事务 T1 再根据相同搜索条件执行查询。结果会是什么？按照 ReadView 中的比较规则中的第 3 条和第 4 条不管事务 T2 比事务 T1 是否先开启，事务 T1 都是看不到 T2 的提交的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>但是，在 REPEATABLE READ 隔离级别下 InnoDB 中的 MVCC 可以很大程度地避免幻读现象，而不是完全禁止幻读。怎么回事呢？来看下面的情况：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-51wOnqygonsF10mmAn.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>首先在事务 T1 中执行：</span></span></span><span><span><code><span>select * from mvcc_test where id = 30;</span></code></span></span><span><span><span> 这个时候是找不到 id = 30 的记录的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在事务 T2 中，执行插入语句：</span></span></span><span><span><code><span>insert into mvcc_test values(30,'luxi','luxi');</span></code></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此时回到事务 T1，执行：</span></span></span></p><pre><code><span><span><span style="color:#0077aa">update</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">set</span></span><span><span> domain</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#669900">'luxi_t1'</span></span><span><span></span></span><span><span style="color:#0077aa">where</span></span><span><span> id</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#990055">30</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">select</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">from</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">where</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">30</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>事务 T1 很明显出现了幻读现象。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 REPEATABLE READ 隔离级别下，T1 第一次执行普通的 SELECT 语句时生成了一个 ReadView，之后 T2 向 mvcc_test 表中新插入一条记录并提交。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>ReadView 并不能阻止 T1 执行 UPDATE 或者 DELETE 语句来改动这个新插入的记录，由于 T2 已经提交，因此改动该记录并不会造成阻塞，但是这样一来，这条新记录的 trx_id 隐藏列的值就变成了 T1 的事务 id。之后 T1 再使用普通的 SELECT 语句去查询这条记录时就可以看到这条记录了，也就可以把这条记录返回给客户端。因为这个特殊现象的存在，可以认为 MVCC 并不能完全禁止幻读。</span></span></span></p><span id="OSC_h3_8"></span><h3><span><span><span>mvcc 总结</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>从上边的描述中可以看出来，所谓的 MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 READ COMMITTD、REPEATABLE READ 这两种隔离级别的事务在执行普通的 SELECT 操作时访问记录的版本链的过程，这样子可以使不同事务的读写、写读操作并发执行，从而提升系统性能。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>READ COMMITTD、REPEATABLE READ 这两个隔离级别的一个很大不同就是：生成 ReadView 的时机不同，READ COMMITTD 在每一次进行普通 SELECT 操作前都会生成一个 ReadView，而 REPEATABLE READ 只在第一次进行普通 SELECT 操作前生成一个 ReadView，之后的查询操作都重复使用这个 ReadView 就好了，从而基本上可以避免幻读现象。</span></span></span></p><span id="OSC_h2_9"></span><h2><span><span><span>InnoDB 的 Buffer Pool</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引，包括：聚簇索引和二级索引，还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只不过是 InnoDB 对文件系统上一个或几个实际文件的抽象，也就是说数据还是存储在磁盘上的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>但是磁盘的速度慢，所以 InnoDB 存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，即使只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘 IO 的开销了。</span></span></span></p><span id="OSC_h3_10"></span><h3><span><span><span>Buffer Pool</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>InnoDB 为了缓存磁盘中的页，在 MySQL 服务器启动的时候就向操作系统申请了一片连续的内存，这块连续内存叫做：Buffer Pool，中文名：缓冲池。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>默认情况下 Buffer Pool 只有 128M 大小。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>查看该值：</span></span></span><span><span><code><span>show variables like 'innodb_buffer_pool_size';</span></code></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以在启动服务器的时候配置 innodb_buffer_pool_size 参数的值，它表示 Buffer Pool 的大小，配置如下：</span></span></span></p><pre><code><span><span><span>[server]
innodb_buffer_pool_size = 268435456</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>其中，268435456 的单位是字节，也就是指定 Buffer Pool 的大小为 256M，Buffer Pool 也不能太小，最小值为 5M，当小于该值时会自动设置成 5M。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>启动 MySQL 服务器的时候，需要完成对 Buffer Pool 的初始化过程，就是先向操作系统申请 Buffer Pool 的内存空间，然后把它划分成若干对控制块和缓，存页。但是此时并没有真实的磁盘页被缓存到 Buffer Pool 中，之后随着程序的运行，会不断的有磁盘上的页被缓存到 Buffer Pool 中。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 Buffer Pool 中会创建多个缓存页，默认的缓存页大小和在磁盘上默认的页大小是一样的，都是 16KB。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>那么怎么知道该页在不在 Buffer Pool 中呢？</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在查找数据的时候，先通过哈希表中查找 key 是否在哈希表中，如果在证明 Buffer Pool 中存在该缓存也信息，如果不存在证明不存该缓存也信息，则通过读取磁盘加载该页信息放到 Buffer Pool 中，哈希表中的 key 是通过表空间号+ 页号作组成的，value 是 Buffer Pool 的缓存页。</span></span></span></p><span id="OSC_h3_11"></span><h3><span><span><span>flush 链表的管理</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果修改了 Buffer Pool 中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为：</span></span></span><span><span><strong><span>脏页</span></strong></span></span><span><span><span>。最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能。所以每次修改缓存页后，并不着急把修改同步到磁盘上，而是在未来的某个时间进行同步。 但是如果不立即同步到磁盘的话，那之后再同步的时候怎么知道 Buffer Pool 中哪些页是脏页，哪些页从来没被修改过呢？总不能把所有的缓存页都同步到磁盘上吧，如果 Buffer Pool 被设置的很大，那一次性同步会非常慢。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>所以，需要再创建一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫 flush 链表。</span></span></span></p><span id="OSC_h3_12"></span><h3><span><span><span>刷新脏页到磁盘</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>从 flush 链表中刷新一部分页面到磁盘，后台线程也会定时从 flush 链表中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为：BUF_FLUSH_LIST。</span></span></span></p><span id="OSC_h2_13"></span><h2><span><span><span>redo 日志</span></span></span></h2><span id="OSC_h3_14"></span><h3><span><span><span>redo 日志的作用</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>InnoDB 存储引擎是以页为单位来管理存储空间的，增删改查操作其实本质上都是在访问页面，包括：读页面、写页面、创建新页面等操作。在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。但是在事务的时候又强调过一个称之为持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果只在内存的 Buffer Pool 中修改了页面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这是所不能忍受的。那么如何保证这个持久性呢？一个很简单的做法就是在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：</span></span></span></p><ol><li><span><span><span><span>刷新一个完整的数据页太浪费了；有时候仅仅修改了某个页面中的一个字节，但是在 InnoDB 中是以页为单位来进行磁盘 IO 的，也就是说在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，一个页面默认是 16KB 大小，只修改一个字节就要刷新 16KB 的数据到磁盘上显然是太浪费了。</span></span></span></span></li><li><span><span><span><span>随机 IO 刷起来比较慢；一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的 Buffer Pool 中的页面刷新到磁盘时，需要进行很多的随机 IO，随机 IO 比顺序 IO 要慢，尤其对于传统的机械硬盘来说。</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好，比方说：某个事务将系统表空间中的第 5 号页面中偏移量为 5000 处的那个字节的值 0 改成 5 只需要记录一下：</span></span></span><span><span><strong><span>将第 5 号表空间的 5 号页面的偏移量为 5000 处的值更新为：5</span></strong></span></span><span><span><span>。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这样在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足持久性的要求。因为在系统崩溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为：</span></span></span><span><span><strong><span>重做日志，即：redo log</span></strong></span></span><span><span><span>。与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的 redo log 刷新到磁盘的好处如下：</span></span></span></p><ol><li><span><span><span><span>redo log 占用的空间非常小存储表空间 ID、页号、偏移量以及需要更新的值所需的存储空间是很小的；</span></span></span></span></li><li><span><span><span><span>redo log 是顺序写入磁盘的在执行事务的过程中，每执行一条语句，就可能产生若干条 redo log，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序 IO；</span></span></span></span></li></ol><span id="OSC_h3_15"></span><h3><span><span><span>redo log 的写入过程</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>InnoDB 为了更好的进行系统崩溃恢复，把一次原子操作生成的 redo log 都放在了大小为 512 字节的块（block）中。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>为了解决磁盘速度过慢的问题而引入了 Buffer Pool。同理，写入 redo log 时也不能直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为 redo log buffer 的连续内存空间，即：redo log 缓冲区，也可以简称：log buffer。这片内存空间被划分成若干个连续的 redo log block，可以通过启动参数 innodb_log_buffer_size 来指定 log buffer 的大小，该启动参数的默认值为：16MB。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>向 log buffer 中写入 redo log 的过程是顺序的，也就是先往前边的 block 中写，当该 block 的空闲空间用完之后再往下一个 block 中写。</span></span></span></p><span id="OSC_h4_16"></span><h4><span><span><span>redo log 刷盘时机</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>log buffer 什么时候会写入到磁盘呢？</span></strong></span></span></p><ul><li><span><span><span><span>log buffer 空间不足时，如果不停的往这个有限大小的 log buffer 里塞入日志，很快它就会被填满。InnoDB 认为如果当前写入 log buffer 的 redo log 量已，经占满了 log buffer 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</span></span></span></span></li><li><span><span><span><span>事务提交时，必须要把修改这些页面对应的 redo log 刷新到磁盘。</span></span></span></span></li><li><span><span><span><span>后台有一个线程，大约每秒都会刷新一次 log buffer 中的 redo log 到磁盘。</span></span></span></span></li><li><span><span><span><span>正常关闭服务器时等等。</span></span></span></span></li></ul><span id="OSC_h2_17"></span><h2><span><span><span>undo 日志</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做。但是偏偏有时候事务执行到一半会出现一些情况，比如：</span></span></span></p><ul><li><span><span><span><span>情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。</span></span></span></span></li><li><span><span><span><span>情况二：程序员可以在事务执行过程中手动输入 ROLLBACK 语句结束当前的事务的执行。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这两种情况都会导致事务执行到一半就结束，但是事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，需要把东西改回原先的样子，这个过程就称之为回滚，即：rollback，这样就可以造成这个事务看起来什么都没做，所以符合原子性要求。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>每当要对一条记录做改动时，都需要把回滚时所需的东西都给记下来。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比方说：</span></span></span></p><ul><li><span><span><span><span>插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉。</span></span></span></span></li><li><span><span><span><span>删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中。</span></span></span></span></li><li><span><span><span><span>修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这些为了回滚而记录的这些东西称之为撤销日志，即：undo log。这里需要注意的一点是，由于查询操作并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的 undo log。</span></span></span></p><span id="OSC_h3_18"></span><h3><span><span><span>undo 日志的格式</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>为了实现事务的原子性，InnoDB 存储引擎在实际进行增、删、改一条记录时，都需要先把对应的 undo 日志记下来。一般每对一条记录做一次改动，就对应着一条 undo 日志，但在某些更新记录的操作中，也可能会对应着 2 条 undo 日志。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>一个事务在执行过程中可能新增、删除、更新若干条记录，也就是说需要记录很多条对应的 undo 日志，这些 undo 日志会被从 0 开始编号，也就是说根据生成的顺序分别被称为第 0 号 undo 日志、第 1 号 undo 日志、...、第 n 号 undo 日志等，这个编号也被称之为 undo no。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这些 undo 日志是被记录到类型为 FIL_PAGE_UNDO_LOG 的页面中。这些页面可以从系统表空间中分配，也可以从一种专门存放 undo 日志的表空间，也就是所谓的 undo tablespace 中分配。</span></span></span></p><blockquote><p>作者：京东物流，张士欣</p><p>来源：京东云开发者社区，自圆其说 Tech 转载请注明来源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10142911</guid>
            <link>https://my.oschina.net/u/4090830/blog/10142911</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[🎁有奖问答 | 从 kkFileView 项目出发，聊聊怎么做开源项目]]>
            </title>
            <description>
                <![CDATA[<h1 class="header article-title"><a href="https://www.oschina.net/question/4700705_2331356">高手问答第 309 期 —— 从 kkFileView 项目出发，聊聊怎么做开源项目</a><div class="ui red label horizontal" data-tooltip="置顶">顶</div></h1><div class="extra ui horizontal list meta-wrap"><div class="item"><a href="https://my.oschina.net/u/4700705" class="__user"><span>小白兔爱吃大灰狼</span></a> 发布于，昨天 17:36
                    </div><div class="item">阅读 558</div><div class="item collect-btn " data-id="2331356" data-user-id="4700705" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i> 收藏 <span data-collect-count="" data-id="2331356" data-obj-type="2">0</span></div><div class="item comment-count"><a href="https://www.oschina.net/question/4700705_2331356#comments" class="normal"><i class="comment outline icon"></i> 答案 <span data-article-reply-count="">3</span></a></div></div><div class="tags"><a class="ui horizontal label" href="https://www.oschina.net/question/topic/masteronline" target="_blank"><img src="https://static.oschina.net/uploads/logo/masteronline_9WTeU.png" referrerpolicy="no-referrer">高手问答</a></div><div class="content" id="articleContent"><p><span><span>开源项目是每一个开发者无法绕过的一个词，无论你是否主动接触开源项目，他就在你身边，和你的工作息息相关。本期嘉宾 KL 博主 6 年前一次偶然的机会接触开源项目后，仿佛打开了代码世界的大门，打通了任督二脉。这里有书本上，你在公司里没有的知识和能量。从开源获取，然后反馈开源，是博主一直践行的开源原则，截止目前，博主开源了数 10+ 的项目，也参与了很多社区的项目，比如 apollo 、skywalking 、seata 等。其中 kkFileView 是博主开源最成功的一个项目，目前 kkFileView 获得过开源中国 GVP 项目，在 Gitee 的所有推荐项目里的 star 排名第 10 ，19281 个 star。kkFileView 一直保持着开源的初心，践行着佛性开源的路子做着开源项目。也因为如下：</span></span></p><ul><li><span><span>好的开源项目一定是架构优良可持续扩展优化的</span></span></li><li><span><span>好的开源项目一定是有需求场景，解决实际问题的</span></span></li><li><span><span>好的开源项目一定是有经济支撑可持续维护迭代的</span></span></li><li><span><span>好的开源项目一定是说明齐全，容易上手的</span></span></li></ul><p><span><span>kkFileView 可以一直健康发展迭代。</span></span></p><blockquote><p><span><span>kkFileView 项目地址：</span><a href="https://gitee.com/kekingcn/file-online-preview" target="_blank" rel="nofollow">https://gitee.com/kekingcn/file-online-preview</a></span></p></blockquote><p><strong><span><span>OSCHINA 本期高手问答（11 月 15 日-11 月 21 日）将以「从 kkFileView 项目聊聊怎么做开源项目」为切入点，聊一聊怎么做好开源项目，可讨论的内容包括带不限于以下：</span></span></strong></p><ul><li><span><span>怎么参与开源项目</span></span></li><li><span><span>怎么上手一个新的开源项目</span></span></li><li><span><span>怎么开源一个自己的开源项目</span></span></li><li><span><span>kkFileView 项目相关话题</span></span></li><li><span><span>怎么从开源项目里学以致用</span></span></li><li><span><span>等等</span></span></li></ul><p><span style="background-color:#ffffff; color:#000000">有其他相关问题，也欢迎大家积极提问！</span></p><h1>嘉宾简介</h1><p><span><span style="color:#000000">陈凯玲，网名：KL，在社区里一直以」KL 博主「自称。先后就职于凯京集团和 TapTap，一直从事 Java 架构、中间件、SRE 等开发工作。是开源项目 kkFileView&nbsp; 作者，也是 Apollo 配置中心社区的 PMC。</span></span></p><ul><li><span><span style="color:#000000">Gitee 主页：</span><a href="https://gitee.com/kailing" target="_blank" rel="nofollow">https://gitee.com/kailing</a></span></li><li><span><span>OSC 主页：</span><a href="https://my.oschina.net/klblog" target="_blank" rel="nofollow">https://my.oschina.net/klblog</a></span></li><li><span><span>个人博客：</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.kailing.pub%2F" target="_blank" rel="nofollow">http://www.kailing.pub/</a></span></li></ul><p><span><img alt="" height="533" src="https://oscimg.oschina.net/oscnet/up-25fffd13ffa4a26b83d8d969dd57c9be8ce.jpg" width="400" referrerpolicy="no-referrer"></span></p><p><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>为了鼓励踊跃提问，我们会在问答结束后从提问者中抽取 5 名幸运会员赠予定制开源魔方一个</span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>！</span></span></span></span></span></span></span></span></p><p><img alt="" height="356" src="https://oscimg.oschina.net/oscnet/up-d8b90a25d803f6b37329dec2c8bae8bdd2c.jpg" width="400" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#27ae60">OSChina 高手问答一贯的风格，不欢迎任何与主题无关的讨论和喷子。</span></p><p>下面欢迎大家就「怎么做好开源项目」<span>相关</span>问题向 <a href="https://my.oschina.net/klblog" rel="nofollow"><strong>KL 博主</strong><strong><span style="color:#000000">&nbsp;</span></strong></a>提问，直接回帖提问既可。</p></div><div class="poll-wrap"></div><div class="additional-remarks"></div><div class="ui basic center aligned segment action"><div class="ui big buttons"><a class="ui basic button collect-btn hover" data-id="2331356" data-user-id="4700705" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i>收藏 (<span data-collect-count="" data-id="2331356" data-obj-type="2">0</span>)</a><div class="ui basic dropdown share button osc-share dropdown-share" data-tag="share-question"><i class="share icon"></i><span>分享</span><div class="menu"><a class="item" data-platform="weibo" data-value="weibo"><i class="weibo icon"></i>微博</a><a class="item" data-platform="qq" data-value="qq"><i class="qq icon"></i>QQ</a><a class="item" data-platform="wechat" data-value="wechat"><i class="weixin icon"></i>微信</a></div></div></div><div class="ui basic segment"><a class="ban" ban-report="" data-id="2331356" data-obj-type="2" data-url="https://www.oschina.net/question/4700705_2331356"><i class="flag red icon"></i>举报</a></div></div>
            ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/question/4700705_2331356</guid>
            <link>https://www.oschina.net/question/4700705_2331356</link>
        </item>
        <item>
            <title>
                <![CDATA[小米澎湃 OS 首个开发版开始推送：底层重构、安装包大小 6GB]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米 13 系列、Redmi K60 系列用户已经陆续收到澎湃 OS 开发版&nbsp;OS1.0.23.11.8.DEV 推送，安装包大小分别为 6.0GB 和 5.9GB。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1e7dfa814e55e981dd76d5f952068e89b6b.png" referrerpolicy="no-referrer"></p><p>更新日志：</p><p><strong>Xiaomi HyperOS</strong></p><ul><li>小米澎湃 OS 打造「人车家全生态」操作系统。</li></ul><p><strong>底层重构</strong></p><ul><li><p>小米澎湃 OS 底层重构，发挥卓越的硬件性能关键；</p></li><li><p>任务识别染色技术，根据任务重要程度动态管控资源分配，更强性能更低功耗；</p></li><li><p>超低功耗渲染框架，提升续航能力并提供更流畅的动画效果；</p></li><li><p><strong>SOC 一体化调频，串联整机硬件资源，更快响应算力需求变化，丢帧更少更流畅；</strong></p></li><li><p>智慧 IO 引擎，焦点 IO 优先执行，避免抢占更流畅；</p></li><li><p>内存管理引擎升级，降低系统内存管理资源消耗，提升整体性能及流畅度，大幅提升可用内存及后台驻留能力焕新存储技术，减少存储碎片化，让手机久用如新；</p></li><li><p>智能选网能力升级，弱网环境网络更流畅；</p></li><li><p>超级近场通信，更高互传速率，更低传输功耗；</p></li><li><p>信号智选引擎，动态调整天线策略，提升信号稳定性。</p></li></ul><p><strong>跨端智联</strong></p><ul><li><p>Xiaomi HyperConnect 跨端互联框架，让设备高效连接，极致协同；</p></li><li><p><strong>全新融合设备中心，所有设备动态实时组网，在控制中心即可查看并操控周围设备；</strong></p></li><li><p>跨设备体验全面升级，支持跨设备调用摄像头、屏幕、通信等多种硬件能力；</p></li><li><p>应用、音视频、剪贴板等数据和服务，支持在多设备间自由流转。</p></li></ul><p><strong>全域安全</strong></p><ul><li><p>面向设备互联的安全隐私架构；</p></li><li><p>设备间通过 TEE 相互校验安全，数据传输硬件级加密；</p></li><li><p>跨端隐私体系，包含互联权限管理、互联行为提醒和互联行为记录。</p></li></ul><p><strong>生命感美学</strong></p><ul><li><p>面向全球化的生命感美学，营造出细腻舒适的视觉和轻盈连贯的动效，多元融合的表达式带来全新的系统美学体验；</p></li><li><p><strong>全新动效语言，带来轻盈连贯的全局动效体验；</strong></p></li><li><p>生命力色彩系统，富有生命气息的自然色，让界面焕然一新；</p></li><li><p>统一的系统字体，为全球而设计；</p></li><li><p>全新天气设计，实时气象引擎创造超现实的视觉体验；</p></li><li><p>全局焦点通知体系，动态展示关键信息变化；</p></li><li><p>全新艺术锁屏，让你的每张照片都变成海报，更有动态玻璃材质，亮屏瞬间精美绝伦；</p></li><li><p>桌面图标设计升级，色彩造型全面焕新；</p></li><li><p>自研多重渲染技术，呈现细腻舒适的自然视效；</p></li><li><p><strong>重构多任务窗口管理，统一交互，高效易用。</strong></p></li></ul><p>此外，小米还提醒用户本次更新为安卓跨版本升级，为降低升级风险，建议提前备份个人数据。本次更新启动加载时间相对较长，<strong>启动后短时间内可能出现微热、微卡等性能、功耗问题</strong>，请耐心等待。部分三方应用由于自身未进行版本适配会影响正常使用，请谨慎升级。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ec01c02cb932dd2ff826fdfebe25a3d342c.png" referrerpolicy="no-referrer"></p><p>澎湃 OS 开发版&nbsp;OS1.0.23.11.8.DEV、OS1.0.23.11.13.DEV&nbsp;版本提前至今日（11 月 14 日）起陆续推送更新，覆盖机型包括小米 14/ Pro 系列、小米 13 / Pro / Ultra 系列、Redmi K60 / Pro 系列。</p><p>此外，原定于 11 月中下旬发布小米澎湃 OS 开发版的小米 MIX Fold 3、MIX Fold 2 目前进展正常，将按原定计划进行推送。</p><p>延伸阅读</p><ul><li><a href="https://www.oschina.net/news/263829" target="news">小米 14 开机动画显示澎湃 OS 基于 Android</a></li><li><a href="https://www.oschina.net/news/263645" target="news">小米澎湃 OS 正式发布，Xiaomi Vela 将开源</a></li><li><a href="https://www.oschina.net/news/263025" target="news">雷军公布小米澎湃 OS 完整系统架构，称底层全部重构</a></li><li><a href="https://www.oschina.net/news/262088" target="news">雷军：小米全新操作系统澎湃 OS 正式版已完成封包</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266511</guid>
            <link>https://www.oschina.net/news/266511</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[.NET 8 正式 GA，最新 LTS 版本]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>.NET 8 <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fannouncing-dotnet-8%2F" target="_blank">已正式 GA</a></u>。</p><p>微软称 .NET 8 提供了数以千计的性能、稳定性和安全性改进，以及平台和工具增强功能，有助于提高开发者的工作效率和创新速度。</p><p>比如 .NET 8 为 Android 和 WASM 引入了<u><a href="https://www.oschina.net/news/258112/dotnet-8-rc1">全新的 AOT 模式</a></u>、改进 System.Text.Json，以及为容器添加 Azure Managed Identity 支持。此外，Linux 上的 .NET 8 独立体积<u><a href="https://www.oschina.net/news/266051">减少 50%</a></u>。</p><blockquote><p><em>延伸阅读：</em><u><em><a href="https://www.oschina.net/news/258091/performance-improvements-in-dot-net-8" target="_blank">.NET 8 性能大幅提升，比 .NET 7 更快</a></em></u></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ff03787397a0c87db779b9a9f69c320f1a5.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-011ebda9040166e191e3e635bc6cbd30a5f.png" referrerpolicy="no-referrer"></p><p>通过此版本，.NET 重塑了构建可按需扩展的智能云原生应用程序和高流量服务的方式。无论是部署到 Linux 还是 Windows，使用容器还是云应用程序模型，.NET 8 都可以支持开发者更轻松地构建这些应用程序。它包括一组经过验证的库，目前 Microsoft 的许多大规模服务都在使用这些库，以帮助应对可观察性、弹性、可扩展性、可管理性等方面的基本挑战。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-4ddd74bf8b72f89c60e1125c5cd19e84eca.png" referrerpolicy="no-referrer"></p><p>.NET 8 还支持将 OpenAI 的 GPT 等大语言模型 (LLM) 直接集成到 .NET 应用程序中。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0af7e466e53f9b88e00546b1ef7ae27371d.png" referrerpolicy="no-referrer"></p><p>开发者可通过 Blazor 使用单个强大的组件模型来处理所有 Web UI 需求，使用 .NET MAUI 将移动应用程序部署到最新版本的 iOS 和 Android。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-48c2bd6fe11d828b1519184c68ccee59222.png" referrerpolicy="no-referrer"></p><p><strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdotnet%2Fcore%2Fblob%2Fmain%2Frelease-notes%2F8.0%2F8.0.0%2F8.0.0.md%3FWT.mc_id%3Ddotnet-35129-website" target="_blank">.NET 8.0.0 Release Notes</a></u>&nbsp;| <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fannouncing-dotnet-8%2F" target="_blank">发布公告</a></u></strong></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 00:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266507/dotnet-8-ga</guid>
            <link>https://www.oschina.net/news/266507/dotnet-8-ga</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[🚀 第一时间适配 .NET8.0，Furion v4.9.1 版本发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>适配 .NET8.0</h2><p><strong>于 2023 年 11 月 15 日，微软正式对外发布了 .NET8.0 正式版。</strong></p><p>Furion 开发团队第一时间进行了升级适配，这一次升级非常顺利，升级过程中<strong>只遇到两个破坏性更改（都是运行时错误）</strong>，所以迅速发布了 v4.9.0，v4.9.0.1，v4.9.1 三个修正版本。</p><p><img height="130" src="https://oscimg.oschina.net/oscnet/up-7fa7ccb98b763beb3d257948361fe1a7c75.png" width="860" referrerpolicy="no-referrer"></p><h2>岁月如梭</h2><p>时间过得真快啊，转眼间 Furion 已经发布了超过 3 年。在这三年间，我们发布了 900 多个版本，修复了 5000 多个问题，合并了 1000 多个请求。经历了各种挑战和困难，但也收获了很多。无论是酸、甜、苦还是咸，我们都一一体验过了。</p><p><strong>继续加油吧。</strong></p><p><img height="1328" src="https://oscimg.oschina.net/oscnet/up-4960bb2a7443d464f06cb55ea0548c908d8.png" width="1718" referrerpolicy="no-referrer"></p><h2>时过境迁</h2><p>当初在发布新版本的定时任务模块时，我写下了下面这段话。时过境迁，再次看到曾经写下的文字，那段充满黑暗和孤独的日子仍然历历在目。</p><p><img height="687" src="https://oscimg.oschina.net/oscnet/up-b048b0a7b5b9efd1030c57d42147cb098c6.png" width="974" referrerpolicy="no-referrer"></p><h2><strong>走向成年</strong></h2><p>这里记录了 Furion 从诞生的一切重要时刻，它就像孩子一样，懵懵懂懂开始走向成年。</p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Ffurion.baiqian.ltd%2Fdocs%2Fcourse" target="_blank">http://furion.baiqian.ltd/docs/course</a></p><p><img height="1328" src="https://oscimg.oschina.net/oscnet/up-f49bd231351d00c7ae9277ce5a5803136c3.png" width="1718" referrerpolicy="no-referrer"></p><p><img height="1328" src="https://oscimg.oschina.net/oscnet/up-557104565bb43862565761ecfe4fd6cc3a4.png" width="1718" referrerpolicy="no-referrer"></p><h2>努力见证</h2><p>三年间，发布了 900 多个版本，每一条版本记录都是努力的见证。</p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Ffurion.baiqian.ltd%2Fdocs%2Fupgrade" target="_blank">http://furion.baiqian.ltd/docs/upgrade</a></p><p><img height="1328" src="https://oscimg.oschina.net/oscnet/up-1b34eca9d627886bbf660635e91105ce950.png" width="1718" referrerpolicy="no-referrer"></p><p><img height="1328" src="https://oscimg.oschina.net/oscnet/up-80f28e24e11c4766e20b720e778da29c14b.png" width="1718" referrerpolicy="no-referrer"></p><h2>项目信息</h2><ul><li>Gitee：<strong><a href="https://gitee.com/dotnetchina/Furion">https://gitee.com/dotnetchina/Furion</a></strong></li><li>Github：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FMonkSoul%2FFurion" target="_blank">https://github.com/MonkSoul/Furion</a></li><li>文档：<strong><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Ffurion.baiqian.ltd%2F" target="_blank">http://furion.baiqian.ltd/</a></strong></li></ul><h2>本期更新</h2><ul><li><p style="margin-left:0; margin-right:0"><strong>新特性</strong></p><ul><li>[新增] 补偿策略模块功能<span>&nbsp;</span>4.9.1<span>&nbsp;</span>⏱️2023.11.15<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/tree/v4/framework/Furion/RescuePolicy">【源码地址】</a><span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/commit/dfc63e7f0ffd2e03653f11a3e49a21646902ddc4">dfc63e7</a></li></ul></li><li><p style="margin-left:0; margin-right:0"><strong>突破性变化</strong></p><ul><li>[升级]<span>&nbsp;</span><strong>框架底层适配<span>&nbsp;</span><code>.NET8.0</code><span>&nbsp;</span>正式版</strong><span>&nbsp;</span>4.9.1<span>&nbsp;</span>⏱️2023.11.15</li><li>[升级]<span>&nbsp;</span><strong>框架脚手架适配<span>&nbsp;</span><code>.NET8.0</code><span>&nbsp;</span>正式版</strong><span>&nbsp;</span>4.9.1<span>&nbsp;</span>⏱️2023.11.15</li></ul></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 16:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266501/furion-4-9-1-released</guid>
            <link>https://www.oschina.net/news/266501/furion-4-9-1-released</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
