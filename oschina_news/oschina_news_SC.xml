<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-最新资讯]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-最新资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 02 Jan 2024 09:40:35 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Bun 1.0.21 版本发布，实现 console.table()，优化大文件上传性能]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Bun 发布了 1.0.21 版本。不仅包含了多项改进和性能优化，还特别在处理大文件上传时引入了一项关键的内存优化技术：写时复制（Copy-on-write）。这次更新修复了 33 个 bug，并处理了 80 个👍反应，体现了对用户反馈的积极响应。新增功能如<code>console.table()</code>，为开发者调试提供了极大的便利。此外，Bun 对<code>Bun.write</code>、<code>Bun.file</code>和<code>bun:sqlite</code>等模块进行了内存优化，提升了整体性能。</p><p>在<code>bun:sqlite</code>错误信息处理方面，此更新使错误信息更加详细，提供了丰富的错误上下文，包括 SQLite 的扩展错误消息和错误码。针对内存管理，<code>bun:sqlite</code>实现了更有效的内存占用管理，显著降低了大量操作的内存需求，并解决了使用 latin1 补充字符可能导致的<code>bun:sqlite</code>崩溃问题。</p><p>特别值得关注的是，Bun 在 1.0.21 版本中对处理大文件上传时的内存优化做出了重大改进。在以往，通过 FormData 上传大文件时，每个文件在内存中都会变成一个 Blob 对象。如果需要将这些数据转换为 ArrayBuffer，传统方法会导致数据被克隆，从而使得内存占用加倍。例如，上传一个 128MB 的文件，转换为 ArrayBuffer 后，内存占用可能增加至 256MB。</p><p style="text-align:center"><img src="https://oscimg.oschina.net/oscnet/up-cb240399f60495c31946dbd86968035e58c.png" referrerpolicy="no-referrer"></p><p>为了解决这一问题，Bun 采用了写时复制技术。这项技术利用虚拟内存的方法，在调用<code>blob.arrayBuffer()</code>时，并不会实际克隆数据。相反，它创建一个新的虚拟内存映射，指向相同的数据，仅在写入时才按 4KB 的块克隆数据。这意味着，在进行例如 100 次 128MB 的 blob 复制操作时，只会使用大约 192MB 的内存，而在早期版本中，这种操作会占用高达 12,993MB 的内存。尽管这种优化带来了一定的开销，因为为每个 blob 创建唯一的内存映射是一项昂贵的操作，但 Bun 只在 blob 大于 8MB（或在<code>--smol</code>模式下为 1MB）时使用这种优化。</p><p>除此之外，Bun 还引入了对 Blob 对象的<code>Bun.CryptoHasher</code>支持，简化了从 FormData 中哈希化文件的上传过程，并增强了<code>bun:test</code>框架的测试功能。Bun 修复了<code>Bun.file()</code>和 Bun.write() 操作中的内存泄漏问题，同时解决了一系列稳定性问题，包括修复了在特定情况下 fetch()、WebSocket 客户端、<code>Bun.listen</code>和<code>Bun.connect</code>的崩溃问题。<code>Bun.serve</code>的流式传输问题、<code>console.log()</code>的输出问题以及<code>expect(error).toStrictEqual()</code>的行为问题也得到了修复。最后，Bun 改进了对重复依赖的处理方式，现在会以警告而非错误的形式提示用户。</p><p>总之，Bun 的这些更新和修复显著提高了其性能和稳定性，同时增强了与现有 JavaScript 生态系统的兼容性。对于开发者而言，这些改进尤其在处理大型文件和复杂应用场景时表现出色，展示了其卓越的性能优化和内存管理能力。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 09:32:19 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273846/bun-1-0-21-released</guid>
            <link>https://www.oschina.net/news/273846/bun-1-0-21-released</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[2024 的开源世界：或有更多企业转向商业许可]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>未来一年，可能会有更多公司将其开源许可证变更为商业许可证、出现新一轮的监管浪潮以及 GenAI 的持续发展。</p></blockquote><p>开源世界在 2023 年伊始就充满了不确定性，科技界大面积裁员、经济动荡不安。生成式 AI 在过去的一年里取得了突飞猛进的发展，而 HashiCorp 许可证的变更则表明，风投公司认为开源模式的前景并不乐观。</p><p>在此背景下，Rust 基金会执行董事兼 CEO Rebecca Rumbul 在接受 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthenewstack.io%2Fopen-source-in-2024-more-volatility-more-risk-more-ai%2F" target="_blank">The New Stack</a> 的采访时，就 2024 年的市场发展发表了一些看法。她认为，目前市场上的乐观情绪已经日渐浓厚。在大幅削减开发人员关系职位之后，出现了一些空缺需要填补；削减职位可能是一种虚假经济。Rumbul 指出，「与开源社区保持良好的关系可以带来巨大的商业回报」。</p><p>不过企业还可以通过一些更直接的方式确保商业回报。譬如今年 8 月，HashiCorp 决定将包括 Terraform 在内的整个产品线转为商业源码许可，这一决定在业界引起了轩然大波；同时也引出了一个获得了 Linux 基金会的支持的 OpenTofu 分叉。</p><p>HashiCorp CEO David McJannet 在其客户会议上曾对整个基金会模式提出质疑，并表示 Linux 基金会对 OpenTofu 的支持是开源创新的悲剧。这最终可能意味着"硅谷将不再有开源公司"。</p><p>Linux 基金会欧洲区总经理 Gabriele Columbro 则评论称，今后可能会出现更多的许可证转换--以及随之而来的分叉：「市场上由风投支持的开源初创公司越多，就越会有一部分公司在某一时刻决定转换许可证，因为这样做对公司最有利。」</p><p>他认为，HashiCorp 完全有权利转换许可。但这一事件可能会鼓励用户更多地考虑开源和项目开放治理之间的区别，从而可能会加强基金会的作用。「当你选择依赖某个开源项目时，你可能会问自己这个问题。它是否只是开源，任何一家专有公司都可以随时打我个猝不及防？」</p><p>Columbro 指出，使用 Terraform 等产品的大公司可能会面临数十万美元的账单，仅仅是为了弄清许可证变更对公司的影响。"我可以想象，摩根大通或谷歌必须花多少钱才能弄清楚他们在 Terraform 上的立场并进行影响评估"。鉴于大企业（特别是在金融领域）对开源的接受程度越来越高，这些计算也变得越来越重要。</p><p>"我认为，我们正处于金融服务和金融科技完全意识到自己是一个以技术为中心的行业的风口浪尖上，因此也会像大型科技公司那样拥抱开源，将其作为数字化转型的核心支柱，同时也是行业结构的核心支柱。"</p><p>Percona 社区负责人 Joe Brockmeier 表示，许多执行团队已经在考虑，是否要冒着更大的风险和弊端转而采用闭源模式。</p><p>但 OpenUK CEO Amanda Brock 认为，这些并不意味着行业不应该重新审视许可和相关问题。现在正是在持有不同观点的不同派别之间进行更开放的对话的时机，让用户、贡献者和社区之间产生更多的了解。</p><p><strong>开源和 GenAI</strong></p><p>AI（尤其是生成式 AI）正在给整个科技界和社会带来巨大冲击，「统一战线可以说比以往任何时候都更加重要」。</p><p>DataStax 开发者关系副总裁 Patrick McFadin 认为，大众对于 GenAI 的隐私问题已经"严重恐慌"，这一情绪将导致对 OpenAI 和超级计算机的反抗。「监管开源几乎是不可能的。一旦事情被公开，你就无法对其进行监管。开源[大语言模型]已经存在，它们正在接受训练，而且它们开始变得比 GPT-4 更好，这使得监管它们变得更加困难。」</p><p>Brock 没有 McFadin 这么末世论，但也同样严肃。「当我们看到人工智能正常化，人们开始更好地理解它是什么并不再被炒作所影响时，我们将更好地讨论开源的含义以及开源如何融入人工智能」。这将导致「与开源社区及其代表的参与，而不仅仅是公司的参与，这是目前全球的一个趋势。」</p><p>她认为，中国参加了在英国布莱切利公园举行的人工智能安全会议是一个非常重要的节点，表明监管对话正在从主权转移到关注跨界合作。这将产生更广泛的影响，促进国际开源技术行业的发展，其中包括强大的本地生态系统和在全球范围内开展合作的熟练劳动力。</p><p><strong>开源监管的前景如何？</strong></p><p>目前，美国和欧盟都已经围绕人工智能制定了立法和监管，但具体的成效还需等到 2024 落地以后才能凸显。欧盟的《网络弹性法案》也将于 2024 年生效，其最近宣布的修订版貌似降低了对开源的限制，不过最终文本尚未公布。</p><p>但要加强科技领域的国际合作还存在很多障碍，美国的制裁已经导致了一些对开源项目的贡献被拒。Rumbul 称，「如果开源只是以美国为中心，或者与美国的外交政策保持一致，那将是非常糟糕的。这不是开源的精神。」</p><p>针对开源在 2024 年的可持续性问题，Rumbul 也同样表达了担忧。「开源社区创造了一些精美的东西，但再精美的东西也会被人从桌子上打下来，摔得粉碎。 」。不过她也认为，虽然"风险"可能比以前更高，但风险并不总是一个坏词，它总是和机遇并存。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 09:26:19 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273844/open-source-in-2024</guid>
            <link>https://www.oschina.net/news/273844/open-source-in-2024</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[MySQL 5.7、魔趣、李跳跳……盘点 2023「停更」的（开源）项目和网站]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年，许多陪伴我们很久的网站和（开源）项目纷纷挥手道别，或退役、或停更、或 EOL、或倒闭……</p><hr><h4><a href="https://www.oschina.net/news/224302/mokee-eol">开源 ROM 魔趣 (Mokee) 创始人宣布项目结束</a></h4><p>国内最大的非营利性开源 ROM 项目魔趣 (Mokee) 在 2023 年 1 月 7 日正式宣布关闭。魔趣下载页面所有固件已备份到 SourceForge。项目作者马丁龙猪发文称，「刷机的时代其实早已落幕，迟迟下不定决心只是希望能让魔趣多存续一些时间，但该来的终究会来。」</p><p><img src="https://oscimg.oschina.net/oscnet/up-a03702d6043769216aed5f1c60b250af639.png" referrerpolicy="no-referrer"></p><p>魔趣开源项目 20121212 ~ 20230107</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/225416/afnetworking-officially-deprecated">网络框架 AFNetworking 停止维护</a></h4><p>在停更近 3 年后，适用于苹果旗下多个操作系统 (iOS、macOS、watchOS 和 tvOS) 的网络框架 AFNetworking 在 2023 年 1 月 17 日正式发布公告宣布弃用，停止维护。原始仓库将作为一个归档库永久保留。</p><p>AFNetworking 建议开发者可以迁移到同样由 Alamofire 软件基金会所开发的 Alamofire —— 一个 100% 使用 Swift 编写的网络框架。</p><p><img src="https://static.oschina.net/uploads/space/2023/0118/153745_fT17_4937141.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/223913/aethersx2-end">开发者遭死亡威胁，项目停止开发</a></h4><p>因遭受过多的骚扰甚至于死亡威胁，AetherSX2 软件的开发者 Tahlreth 于 2023 年 1 月宣布无限期停止该项目的开发。</p><p>「AetherSX2 对我来说一直是一个有趣的爱好，而不是为了盈利。继续开发一个不再有趣的项目是没有任何意义的。」</p><p>AetherSX2 是 Android 平台上最好用的 PlayStation 2 模拟器（没有之一）。用户还可以继续下载和使用 AetherSX2，但该应用程序已经不再有进一步的开发计划。</p><p><img src="https://oscimg.oschina.net/oscnet/up-93a2a42d4210b16856fc57cda8138b21c0e.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/232215/peek-discontinued">问题堆积如山，GIF 录屏工具 Peek 停止开发</a></h4><p>GIF 屏幕录制工具 Peek 的开发者在 2023 年 1 月正式宣布项目停止开发，主要原因在于 Wayland 上运行时所面临的一些技术挑战。而解决问题的唯一途径就是以不同的方式、不同的 UI 完全重写应用程序，但「现在的 Peek 几乎没有什么资源可以重用」。</p><p>开发者表示自己并没有兴趣再开发一个全新的项目，所以做出了放弃该项目的决定。</p><p><img src="https://oscimg.oschina.net/oscnet/up-10c040add5089c3b13095d5f4ee74d1685a.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/230777">aardio 编程语言作者：因妻子患癌，再无精力维护项目</a></h4><p>aardio 编程语言作者发文表示，因妻子患癌，再无精力维护项目。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.aardio.com%2F">aardio</a> 是一门专注于桌面软件开发的编程语言，特点是小、轻、快，体积仅 6.5MB，学习和使用成本极低。aardio 虽然小，但提供了惊人数量的开源标准库、扩展库 —— 这些库基本都是由纯 aardio 代码实现。</p><p>aardio 的所有库基本都是由作者一个人编写，并且 17 年来一直保持非常活跃的更新。</p><p><img src="https://static.oschina.net/uploads/space/2023/0302/174216_nFqa_2720166.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/235303/touca-shutting-down">开源项目 Touca 开发商倒闭</a></h4><p>开源测试工具 Touca 的创始人 Pejman Ghorbanzade 于 2023 年 3 月宣布其公司正式倒闭，不景气的市场大环境是 Touca 倒闭的一个主要原因。</p><p>Pejman Ghorbanzade 于 2021 年创立了 Touca，并于 2022 年 5 在 Apache-2.0 许可下开源。Touca 可以帮助工程团队发现日常代码修改所导致的意外副作用。它将软件的行为和性能与之前的可信版本进行比较，并以近乎实时的方式将差异可视化。</p><p>Touca 公司倒闭后，Touca 这个开源项目还将继续存在，并保持开源，Pejman Ghorbanzade 表示自己会持续维护这个项目，并开始寻找新的机会。</p><p><img src="https://static.oschina.net/uploads/space/2023/0404/083735_MqQM_4937141.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/242988/qt-5-15-lts-support-ends">Qt 5.15 LTS 已结束标准支持</a></h4><p>Qt 5 系列的最后一个次要版本 Qt 5.15 LTS 于 2023 年 5 月 26 日正式结束标准支持。</p><p>Qt 5.15 LTS 是一个长期支持版本，有三年的标准支持期。最后一个补丁版本是 Qt 2023 年 5 月 25 日发布的 5.15.14，适用于具有旧许可证的商业客户的标准支持条款。</p><p><img src="https://static.oschina.net/uploads/space/2023/0530/072839_iyUd_2720166.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/243315/rarbg-shut-down">战争、疫情、通货膨胀，资源网站 RARBG 宣布关闭</a></h4><p>受战争、疫情、通货膨胀等因素影响，资源网站 RARBG 于 2023 年年中宣布关站。</p><p>RARBG 是一个著名的 BitTorrent 网站，提供了许多高质量的电影、电视剧、音乐、游戏和软件等种子资源。它成立于 2008 年，总部位于保加利亚，已经成为了 BitTorrent 社区中备受喜爱的网站之一。</p><p><img src="https://static.oschina.net/uploads/space/2023/0601/090415_Crb3_4937141.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/247891/libjpeg-turbo-fund">资金严重短缺，又一流行开源项目宣布停止功能开发</a></h4><p>libjpeg-turbo 的首席开发人员 DRC 在完成该项目的 3.0.0 版本发布后表示，由于资金短缺，其未来的功能开发或将受到限制，可能永远不会有 libjpeg-turbo 3.1 版本。</p><p>他将继续修复 libjpeg-turbo 中的错误，并在 3.0.x 发行版系列中发布错误修复版本；但不会再有 libjpeg-turbo 3.1 发行版系列，除非该项目可以获得更多的通用资金。</p><p>libjpeg-turbo 是一个 JPEG 图像编解码器，它使用 SIMD 指令（MMX、SSE2、AVX2、Neon、AltiVec）来加速 x86、x86-64、Arm 和 PowerPC 系统上的基线 JPEG 压缩和解压缩，以及 x86、x86-64 和 Arm 系统的渐进式 JPEG 压缩。</p><p><img src="https://oscimg.oschina.net/oscnet/up-5009145e786948703fca4d615949b2aa180.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/255159">自动跳过开屏广告应用「李跳跳」无限期停止更新</a></h4><p>「李跳跳」 作者于 2023 年 8 月在公众号宣布无限期停止更新，原因是收到了某集团律师函，对方称 「李跳跳」 APP 涉嫌不正当竞争，对旗下的浏览器产生影响，并要求四十八小时内全网下架 「李跳跳」。</p><p>「李跳跳」 是一款利用无障碍权限进行跳过 APP 开屏广告的 Android 辅助应用，无需联网，免费使用。除了 「李跳跳」，其他同类开屏广告应用也都在同一时期收到了律师函，比如 「大圣净化」、「一指禅」 和 「叮小跳」。</p><p><img src="https://oscimg.oschina.net/oscnet/up-f76f9db79d31ec9572ff7a63c83b254b314.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/256175/visual-studio-for-mac-retirement">微软官宣：Visual Studio for Mac 退役</a></h4><p>微软于 2023 年 8 月发布了 Visual Studio for Mac 的退役公告。未来，开发团队将专注于增强 Visual Studio 和 VS Code，优化它们以进行跨平台开发。</p><p>自 2024 年 8 月 31 日起，Visual Studio for Mac 将不会再获得任何支持。届时，Visual Studio for Mac 将只能通过 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmy.visualstudio.com" target="_blank">my.visualstudio.com</a>，为已订阅 Visual Studio 的用户提供旧版安装，但不再提供服务或维护。</p><p>Visual Studio for Mac 退役后，微软方面仍会为 Mac 开发者提供替代方案，例如 C# Dev Kit for VS Code 和其他扩展。</p><p><img src="https://static.oschina.net/uploads/space/2023/0831/111644_7KuF_2720166.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/257320/wangeditor-suspend-maintained">开源富文本编辑器 wangEditor 暂停维护</a></h4><p>开源 Web 富文本编辑器 wangEditor 作者王福朋于 2023 年 8 月发布宣布暂停项目维护。主要原因在于作者暂无精力维护 wangEditor ，且 「最近行业形势也不太好，先努力搞钱吧」。</p><p>他也欢迎有人接手 wangEditor 的维护，不过需要通过初步考核：在 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwangeditor-team%2FwangEditor%2Fissues">issues</a> 列表中，回答 10 个 issue。</p><p><img src="https://static.oschina.net/uploads/space/2023/0908/105123_MDIq_2720166.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/256530/microsoft-deprecated-wordpad-in-windows">时隔 28 年，微软计划在 Windows 中淘汰写字板</a></h4><p>微软在 2023 年 9 月宣布计划在未来的 Windows 更新中弃用写字板。对于 .doc 和 .rtf 等富文本文档，该公司建议使用 Microsoft Word 作为替代品；对于 .txt 等纯文本文档，则建议使用 Windows 记事本。</p><p>写字板是一种基本的文本编辑应用程序，允许用户创建和编辑带有格式化文本的文档，幷包含图像和其他文件的链接。自 1995 年 Windows 95 发布以来就附带在 Windows 系统上，为用户提供集成到操作系统中的基本文字处理器和文档编辑器。</p><p><img src="https://oscimg.oschina.net/oscnet/up-9eb98bd9630dd96807298f16da6fd2ec37f.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/224251/linux-4-9-eol">Linux 4.9 正式 EOL ，结束持续 6 年的 LTS 周期</a></h4><p>在长达 6 年多的长期支持后，Linux 4.9 内核系列在 Linux 4.9.337 更新中，结束了生命周期。</p><p>Linux 内核 4.9 于 2016 年 12 月 11 日发布，它带来了对 XFS 文件系统的共，享范围和写时复制支持、用于检测固件引起的延迟的硬件延迟跟踪器、对，来自 Project Ara 的 Greybus 总线的支持、更高效的 BPF 分析器、新的可选 BBR TCP 拥塞控制算法、虚拟映射内核堆栈等特性。</p><p>由于是 LTS 版本，Linux 4.被广泛用于生产环境，比如基于 Linux 4.9 操作，系统驱动的大规模生产设备/硬件。</p><p><img alt="082401_IvCl_5430600.png" src="https://static.oschina.net/uploads/space/2023/0109/082401_IvCl_5430600.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://my.oschina.net/GreatSQL/blog/10117424">MySQL 5.7 于 2023.10.21 正式 EOL</a></h4><p>MySQL 目前已经成为中国用户使用最广泛的开源数据库，其中 5.7 版本用户的比重又是最高的。根据报告中的统计数字，MySQL 5.7 用户占比在国内高达 47%。届时这些用户将会面临选择，如何应对 EOL 事件。</p><p>实际上 2020 年的时候就有一些机构提醒用户，MySQL 5.7 按照生命周期将于 2023 年到达服务期限，当时这件事还在 MySQL 社区和 DBA 圈子里引发过一些关于开源项目安全性的讨论。3 年后，这个狼来了的问题，终于正式要面对我们了。</p><p><img src="https://oscimg.oschina.net/oscnet/up-38ac7bf161ea28943b1db6cc2ac7b40b41d.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/258425">JS 工具库 lodash 关闭所有 issue 和公开 PR</a></h4><p>老牌 JS 工具库 lodash 关闭了所有 issue 并统一打上 "issue bankruptcy" 的 tag，此外还关闭了所有公开 PR，表示无力处理，一关了之。</p><p><img src="https://static.oschina.net/uploads/space/2023/0917/112931_OgKg_2720166.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/265128">承载微软跨平台生态之梦的 UWP，正在消亡</a></h4><p>开发者发现，微软最新的 Windows 11 Canary Build 25987 预览版已经开始提供两个版本的 XAML Shell 服务，新的版本直接基于 Win32 + XAML，曾经被寄予厚望的 UWP 在新版本里已经不见踪影。</p><p><img src="https://static.oschina.net/uploads/space/2023/1106/113836_8gF1_2720166.png" referrerpolicy="no-referrer"></p><hr><p>更多年度重磅事件回顾，<strong>查看<em><u><a href="https://talk.gitee.com/report/china-open-source-2023-annual-report.pdf?fr=shida_news1231">《2023 中国开源开发者报告》</a></u></em></strong>。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 09:25:19 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273843</guid>
            <link>https://www.oschina.net/news/273843</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[守正出奇，穿越周期 - Bytebase 的 2023]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>前情提要：<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI2MDY5OQ%3D%3D%26mid%3D2247501714%26idx%3D1%26sn%3De042aa907bc5eb45bdcad8d4cd56cfd3%26chksm%3Dc25cf9a6f52b70b0ef011150790edb7f6864cc9dbfc94959d358b12506119eefb248d44faa36%26scene%3D21%23wechat_redirect" target="_blank">Bytebase 的 2022｜埋头苦干，孕育希望</a></p></blockquote><h2>产品迭代</h2><ul><li><p>2023 年共发布了 25 个版本。这个数字和 2022 年一样，除开春节和一次全员疫情，做到了两周一次的更新。</p></li><li><p>版本号从 1.11.0 升级到了 2.13.0。其中在 5 月份，我们发布了 Bytebase 2.0 版，明确了做 Database DevOps 的产品主张。 <img src="https://oscimg.oschina.net/oscnet/up-68868615564cc83e1c5c26bc6160165fd16.png" alt="file" referrerpolicy="no-referrer"></p></li><li><p>PR 数超过 10000，成为了 GitHub 上最繁忙的开源项目之一。 <img src="https://oscimg.oschina.net/oscnet/up-f94e6c186bd68ccd2a105ae853db7e9f04e.png" alt="file" referrerpolicy="no-referrer"></p></li><li><p>GitHub Star 数也从 4.7 k 增加到 8.7 k，不仅继续保持同领域内最快的增速，而且还先后超越了国外的 Flyway 和国内的 Yearning，成为了同领域内，全球 Star 最多的开源项目。 <img src="https://oscimg.oschina.net/oscnet/up-2622bb405457359ff36b66daad3d244cc6d.png" alt="file" referrerpolicy="no-referrer"></p></li></ul><h2>企业级，可依赖</h2><p><img src="https://oscimg.oschina.net/oscnet/up-3c1a784de5a150efbfc8e71fe8cd4d2d3da.png" alt="file" referrerpolicy="no-referrer"></p><p>今年 Bytebase 成为了唯一被 CNCF Landscape 和 Platform Engineering (平台工程组织) 同时收录的数据库管理工具。</p><p><img src="https://oscimg.oschina.net/oscnet/up-72f780b2eedaf1328244e667365722b33e3.png" alt="file" referrerpolicy="no-referrer"></p><p>目前 Bytebase 已经支持市面上 17 种主流数据库系统。提供了一套覆盖变更，查询，安全，治理的数据库开发全生命周期的解决方案。</p><p><img src="https://oscimg.oschina.net/oscnet/up-9ebeef3b72d5ba1d510aea61c971e5be01d.png" alt="file" referrerpolicy="no-referrer"></p><p>今年 Bytebase 全面增强了企业级功能，SSO，多因素认证，动态脱敏，批量变更，自定义审批流，审计日志等。并且还通过开放 API 的方式让 Bytebase 能被集成到了企业已有的研发平台中。</p><h2>旧雨新知</h2><p>Bytebase 在 2022 年年中开始商业化，今年则是全面商业化的第一年。我们完成了所有老客户的续约，并且在国内又收获了电信，制造业，造车新势力等行业的标杆。同时我们还把产品卖到了全球，北美，欧洲，东南亚，中东，非洲也都有了我们的客户。</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI2MDY5OQ%3D%3D%26mid%3D2247502348%26idx%3D1%26sn%3D6d1056e2dcc09a35b327ab981a4b4d49%26chksm%3Dc25cf438f52b7d2ee6fb3e56dfa9917abaf470e014d2d04148bb726fcbe0b59295a3bef452cc%26token%3D1617600613%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank">1:1000，新能源车企如何将数据库管理效能发挥到极致</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI2MDY5OQ%3D%3D%26mid%3D2247506285%26idx%3D1%26sn%3D37498d417a3c4b024504e590f89f39a4%26chksm%3Dc25ce759f52b6e4f8d884466b7d155635c031a864df18d3cd6b2d50cfacf2d3670da8a6fae37%26token%3D2062945217%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank">来自电子制造行业视源科技 (CVTE) 的数据库变更管理实践</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI2MDY5OQ%3D%3D%26mid%3D2247505728%26idx%3D1%26sn%3D6fa17fe88d8ba6d8f2635ab05ac3639f%26chksm%3Dc25ce974f52b6062a0d8a03d9669b4b5da3dba081e3f838a9a69b094bee5da0e5b873e40b535%26token%3D1617600613%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank">中东 Shopify 如何使用 Bytebase 构建一站式数据库开发工作流</a></li></ul><h2>良师益友</h2><p>作为一款面向开发者和 DBA 的数据库工具，Bytebase 今年也积极和上下游数据库和开发者工具建立合作关系，先后成为了 PingCAP, Snowflake, GitHub, GitLab 的全球技术合作伙伴。</p><p><img src="https://oscimg.oschina.net/oscnet/up-8689af380e45d36553f6e3e3b79cf3a2c26.png" alt="file" referrerpolicy="no-referrer"></p><p>受邀在 OceanBase 的年度开发者大会进行了专题分享，并且基于一同服务的客户案例，推出了「数据库变更全生命周期管理」的联合解决方案。</p><p><img src="https://oscimg.oschina.net/oscnet/up-87dc34a29f68218802d3b0e281a320767ef.png" alt="file" referrerpolicy="no-referrer"></p><p>此外我们还支持了 RisingWave, StarRocks 这些冉冉升起的数据库新星。</p><h2>守正出奇，穿越周期</h2><p>不可否认，中国的企业服务正在经历低谷，面向 toB 市场的 Bytebase 自然也是受到了冲击。2023 以及即将迎来的 2024，我们依旧会开拓并且专注于「数据库开发」这一个工作流。当年 Bytebase 最早推出的 GitOps 方案现在已经出现在了 Snowflake 的产品中。</p><p><img src="https://oscimg.oschina.net/oscnet/up-4189a487badbc0cf4ea8ebf2dd74463f905.png" alt="file" referrerpolicy="no-referrer"></p><p>今年我们继续在产品上创新，比如第一次在数据库工具里引入了分支工作流 (Branching)。</p><p><img src="https://oscimg.oschina.net/oscnet/up-56b1418f8c2a0f29dbccd0cb17e9358b656.png" alt="file" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-17c7adc49e0b01b7c804bcfbb1f7a204b22.png" alt="file" referrerpolicy="no-referrer"></p><p>总之，Bytebase 既要满足客户的需求，又要交付出一个面向未来的方案。</p><p>最后感谢我们所有的企业客户，社区用户，感谢你们信任一家起步不到三年的初创公司。大家有时也会操心公司的命运 (代码是完全开源的，结构清晰，部署简单，如果公司倒闭了，就可以任意使用/二开)。感谢大家的关心，我们的现金流即将转正，届时等我们的好消息吧。</p><p>好啦，明年再见 👋</p><hr><p>💡 更多资讯，请关注 Bytebase 公号：Bytebase</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 09:23:19 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6148470/blog/10560159</guid>
            <link>https://my.oschina.net/u/6148470/blog/10560159</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[国产数据库管理工具 CloudDM v2.4.1 发布，StarRocks 兼容修复]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><div><p style="margin-left:0; margin-right:0"><span>CloudDM </span><span style="color:#333333">是 </span><span>ClouGence</span><span style="color:#333333"> 公司推出的一款</span><strong><span>一站式多数据源开发管理工具</span></strong><span style="color:#333333">，使用它可以方便地访问和管理 </span><span>MySQL、Oracle、PostgreSQL、阿里云 RDS、Greenplum、TiDB、Redis、StarRocks、Doris、SelectDB、SQL SERVER、ClickHouse、OceanBase 、PolarDB-X 、IBM Db2 等多种不同类型的数据库。通过 CloudDM 丰富的数据源支持可以避免在多个专业工具之间切换，从而提高工作效率。</span></p><p style="margin-left:0; margin-right:0"><span>它是本地化的应用程序，没有后台进程。和 </span><strong><span>DataGrip</span></strong><span>、</span><strong><span>Navicat</span></strong><span> 一样在安装完成后，只需要双击应用程序图标，便可以方便的管理位于本地计算机或远程计算机上的数据库。已经支持 </span><strong><span>Windows</span></strong><span>、</span><strong><span>MacOS</span></strong><span> 和 </span><strong><span>Linux</span></strong><span> 主流操作系统。</span></p></div></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><img src="https://oscimg.oschina.net/oscnet/up-c0a92ca7654a775e970ab24569abe3fe44d.png" referrerpolicy="no-referrer"></p><div><div><div><div><div><h2><span>更新内容</span></h2><ul><li><span style="color:#333333">[优化]</span><ul><li><span>优化 PostgreSql 和 GreenPlum 数据库表编辑内容描述</span></li><li><span>优化 PostgreSql 和 GreenPlum 数据库表编辑生成 SQL，关键字进行大写</span></li></ul></li></ul><ul><li><span style="color:#333333">[修复] </span><ul><li><span style="color:#333333">​​​​​​​</span><span>修复 StarRocks 数据库版本获取错误的问题</span></li><li><span>修复 StarRocks 数据库 Decimal32 等类型不支持的问题</span></li><li><span>修复 SQL SERVER 数据库添加数据源失败的问题</span></li><li><span>修复，设计表选择列组件选中错误的问题</span></li><li><span>修复 SQL 编辑多条 SQL 在一行的时候，无法正确识别光标所在 SQL 的问题</span></li><li><span>修复，编辑器页面修改 Schema，聚焦功能不能正确跳到左边数据源树的对应 Schema 节点的问题</span></li><li><span>修复，在弹窗时，窗体后端 UI 组件没有被遮盖的问题</span></li><li><span>修复，没有新版本仍然会调用更新详情接口的问题</span></li></ul></li></ul></div></div><h2><span>下载与反馈</span></h2><ul><li><span>产品官网：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.clougence.com%2Fclouddm-personal" target="_blank"><span>https://www.clougence.com/clouddm-personal</span></a></li><li><span>问题反馈：</span><a href="https://gitee.com/clougence/clouddm-issue/issues" target="_blank"><span>https://gitee.com/clougence/clouddm-issue/issues</span></a></li><li>Release Node：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.clougence.com%2Fdmp-doc%2Freleaseinfo%2Fdesktop_2_4_1" target="_blank">https://www.clougence.com/dmp-doc/releaseinfo/desktop_2_4_1</a></li><li><span style="color:#333333">微信交流群：访问产品官网，扫描右侧二维码即可加入</span></li></ul></div></div></div></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 09:14:19 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273838/clouddm-2-4-1</guid>
            <link>https://www.oschina.net/news/273838/clouddm-2-4-1</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[米老鼠原始版本进入公有领域 (Public Domain)]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在近一个世纪之后，米老鼠终于摆脱了迪斯尼的版权束缚。</p><p>这个标志性卡通人物的原始版本最早出现在《威利号汽船》(Steamboat Willie) 和无声版《疯狂飞机》(Plane Crazy) 动画电影，<strong>现在已于&nbsp;2024 年 1 月 1 日进入公有领域</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-034cd0975e2f207388bfd20852a4bd6fcd3.png" referrerpolicy="no-referrer"></p><blockquote><p><strong>公有领域 (Public Domain) </strong>是人类的一部分作品与一部分知识的总汇，可以包括文章、艺术品、音乐、科学、发明等等。对于领域内的知识财产，任何个人或团体都不具所有权益（所有权益通常由版权或专利体现）。</p><p>这些知识发明属于公有文化遗产，任何人可以不受限制地使用和加工它们（此处不考虑有关安全、出口等的法律）。创立版权制度的初衷是借由给予创作者一段时期的专有权利作为（经济）刺激以鼓励作者从事创作。当专有权利期间届止，作品便进入公有领域。<strong>公有领域的作品由于没有专属权利人，因此公众有权自由使用它们</strong>。</p><p>许多国家将每年 1 月 1 日定为「<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpublicdomainreview.org%2Fblog%2F2024%2F01%2Fpublic-domain-day-2024%2F" target="_blank"><strong>公有领域日 (Public Domain Day)</strong></a></u>」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-36bc427e8958111f8b21613b93880334f6a.png" referrerpolicy="no-referrer"></p></blockquote><p>进入公有领域的版本是 1928 年上映的动画片《威利号汽船》中刻画的米老鼠，米老鼠有多个版本，后续版本仍然受到了版权保护，仍然掌握在迪士尼手中。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-de4c25d0fcf3d14b5ec5b3b34339bb8e27d.png" referrerpolicy="no-referrer"></p><p>由于米老鼠是迪士尼的商标之一，因此即使版权到期，其他人在使用时不能将其作为商标或 logo，否则会构成侵权。</p><p>米老鼠对于版权法的影响力和意义极为深远。美国将版权保护期限延长到 95 年，一个重要原因是迪士尼等公司的游说，因此该法律被笑称为「米老鼠保护法」。如此长的版权保护期限制了进入公有领域的作品，但另一方面迪士尼其实受益于公有领域作品，而且米老鼠本身的形象也是借鉴了卓别林等早期电影明星的风格。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 07:32:30 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273808/mickey-public-domain</guid>
            <link>https://www.oschina.net/news/273808/mickey-public-domain</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Unity 引擎中国版 ——「团结引擎」开放下载]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>经过四个月的内测与持续的技术迭代与优化，「<strong>团结引擎创世版</strong>」正式开放下载。</p><p>下载链接：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Funity.cn%2Ftuanjie%2Freleases" target="_blank">https://unity.cn/tuanjie/releases</a></u></em></p><p><img src="https://oscimg.oschina.net/oscnet/up-6e2e07e0a9f317c8a90a22afa066c0240dd.jpg" referrerpolicy="no-referrer"></p><p>据介绍，此次发布的团结引擎创世版，带来了完整的一站式微信小游戏解决方案，以及专为汽车智能座舱开发打造的团结引擎车机版，新增了对国产操作系统 OpenHarmony 的支持，并且展示了 beta 版本的虚拟几何体（Virtual Geometry）功能。</p><p><img src="https://oscimg.oschina.net/oscnet/up-fc804fee3a77eb38b4bb885c98dd668eb41.jpg" referrerpolicy="no-referrer"></p><p>在性能分析层面，团结引擎创世版增添了加强版的 Profiler 工具，新增 Frame Debugger 支持，可以深入分析渲染步骤；并在 Profiler 中新增 AssetBundle 的数量和内存统计，覆盖了 NativeHeap、JS 文件系统等，帮助用户全面分析 AssetBundle 的内存占用。</p><p>更多详情访问以下链接：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.unity.cn%2Fcn%2Ftuanjiemanual%2FManual%2Fintro.html" target="_blank">https://docs.unity.cn/cn/tuanjiemanual/Manual/intro.html</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 06:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273793/unity-tuanjie</guid>
            <link>https://www.oschina.net/news/273793/unity-tuanjie</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[@所有人 2023 IT 行业项目管理调查问卷，邀您参与！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span>2023 年，行业飞速发展，在这一年里，新技术、新趋势带来了一波又一波创新浪潮，人工智能、物联网、云计算等技术正也在重塑我们的生活、工作方式。</span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span>作为项目管理工具厂商，禅道深知项目管理过程的困难与不易，也紧跟管理方式的迭代与更新。为共同探索行业趋势，推动项目管理的进步与创新，我们联合多方合作伙伴，发起了 2023 年 IT 行业项目管理调查问卷，现诚挚地邀请您参与填写本问卷。</span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span>我们希望通过这次调查，了解不同公司和个人在项目管理中面临的现状与挑战，为行业提供宝贵的数据、经验，推动行业发展。</span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span>您的参与、转发就是对行业的支持~问卷所填内容仅用于报告分析及礼品发放，不会对外披露或对第三方提供。问卷将于 2024 年 2 月 20 日截止，届时我们将基于问卷数据生成调查报告，与您共享。</span></span></span></span>、</p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span>认真完成问卷填写，即可参与中奖率百分百的抽奖，超多惊喜好礼在等您！</span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><strong><span><span><strong>点击填写问卷：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zentao.net%2Fredirect-index-23598.html" target="_blank">https://www.zentao.net/redirect-index-23598.html</a></strong></span></span></strong></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><img alt="" height="533" src="https://static.oschina.net/uploads/space/2024/0102/141727_mORd_4252687.png" width="300" referrerpolicy="no-referrer"></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><img alt="" height="147" src="https://static.oschina.net/uploads/space/2024/0102/141752_M92b_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 06:18:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273789</guid>
            <link>https://www.oschina.net/news/273789</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Hugging Face 年度回顾：2023，开源大模型之年]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section data-tool="mdnice 编辑器" data-website="https://www.mdnice.com" style="font-size: 16px;color: black;padding-right: 10px;padding-left: 10px;line-height: 1.6;letter-spacing: 0px;word-break: break-word;text-align: left;font-family: Roboto, Oxygen, Ubuntu, Cantarell, PingFangSC-regular, PingFangTC-regular, &quot;Open Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif;"><blockquote data-tool="mdnice 编辑器" style="border-top: none;border-right: none;border-bottom: none;font-size: 0.9em;overflow: auto;color: rgb(106, 115, 125);padding: 10px 10px 10px 20px;margin-bottom: 20px;margin-top: 20px;border-left-color: rgb(255, 177, 27);background: rgb(255, 245, 227);"><p style="font-size: 16px;line-height: 26px;color: rgb(89, 89, 89);">查看本文完整链接，请点击文末阅读原文</p></blockquote><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在 2023 年，大型语言模型（Large Language Models，简称 LLMs）受到了公众的广泛关注，许多人对这些模型的本质及其功能有了基本的了解。是否开源的议题同样引起了广泛的讨论。在 Hugging Face，我们对开源模型抱有极大热情。开源模型的优势在于，它们不仅促进了研究的可复制性，还鼓励社区参与到人工智能模型的开发中来，这样做有助于我们更容易地审视模型中可能存在的偏差和局限性。此外，通过重复利用已有的检查点，我们还能够减少整个领域的碳足迹（这只是，众多优点，中的一部分）。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">让我们一起回顾开源 LLMs 在过去一年的发展历程吧！</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><span style="color: rgb(136, 136, 136);">为了确保本文篇幅适中，我们将不涉及代码模型的相关内容。</span></p><span id="OSC_h2_1"></span><h2 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">🍜 预训练大型语言模型的配方</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">首先，如何获得一个大型语言模型呢？（如果你对此已有所了解，可以跳过这部分内容。）</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">模型的 <strong style="color: black;">架构</strong>（即其代码表示）定义了它的具体实现和数学结构：这包括所有的相关参数，以及这些参数如何与输入数据进行交互。目前，大多数高性能的大型语言模型（LLMs）都是基于 「仅解码器」（decoder-only）的 Transformer 架构的衍生版本，有关原始 Transformer 的详细信息可以参考其，发表的论文。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">训练数据集</strong> 是模型训练过程中（即参数被学习时）所依赖的全部样本和信息的集合，它使模型能够学习到特定的数据模式。这些数据通常包括多样的文本材料，既可以是各种自然语言文本，如法语、英语、汉语等，也可以是各类编程语言代码，比如 Python、C 语言等，或者是任何能够以文本形式表现的结构化信息，例如 Markdown 或 LaTeX 中的表格、公式等。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">分词器</strong> 是定义如何将训练数据集中的文本转化为数字的工具（因为模型是一个数学函数，因此需要数字作为输入）。分词是通过将文本转换为称为 「词元」 的子单元（可以是单词、子词或字符，具体取决于分词方法）来完成的。分词器的词汇量大小决定了其能够将文本分割成的不同词元的种类数目，这个数字通常介于 32,000 到 200,000 之间。数据集的规模常常用它包含的 <strong style="color: black;">词元数量</strong> 来衡量。经过分词后，如今的数据集范围从几千亿词元到几万亿词元不等，这些词元是构成数据集的基本单元。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">训练超参数</strong> 定义了模型训练的方法。这些参数决定了模型应如何调整自身以适应新的数据样本，以及模型参数更新的速度应该是多快。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">一旦确定了这些超参数，接下来需要的就是 1）充足的计算资源来进行模型训练；2）具备专业技能的人员来执行和监督训练过程。训练过程本身包括在训练所用的硬件上初始化模型架构，以及依据前述超参数在训练数据集上应用训练算法。训练的成果是一系列模型权重 —— 这些就是经过学习的 <strong style="color: black;">模型参数</strong>，也正是人们通常所说的开放获取的预训练模型。这些权重可以用于后续的 <strong style="color: black;">推理过程</strong>，即对新的输入数据进行预测，例如生成文本。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">预训练的大型语言模型（LLM）在完成初始训练后，还可以根据具体任务进行定制化或进一步调整。特别是当这些模型的参数被开放共享时，它们可以作为不同用例和应用的基础，经过一种称为 「微调」 的过程进行优化。微调包括在与原始预训练数据集不同的、通常更小且更专业化的数据集上，对模型执行额外的训练步骤，目的是为了针对特定应用场景优化模型性能。尽管微调步骤在计算资源消耗上有一定成本，但这一成本通常远低于从零开始训练一个全新模型所需的财务投入和环境代价。这也是高品质开源预训练模型极具吸引力的一个原因，它们使得即便是计算预算有限的从业者也能够自由地使用和改进这些模型。</p><span id="OSC_h2_2"></span><h2 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">🗝️ 2022 年，从规模竞赛转向数据竞赛</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在 2023 年之前，社区有哪些开源模型可用？</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">直至 2022 年初，机器学习界普遍认为，模型的规模越大（即拥有的参数越多），其性能也越出色。特别是，模型一旦超过某个特定的规模阈值，其能力似乎会实现质的飞跃，这两种现象分别被称为 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">突现能力</code> 和 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">规模定律</code>。2022 年推出的多个预训练开源模型家族大多遵循这种范例。</p><ol data-tool="mdnice 编辑器" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;" class="list-paddingleft-1"><li><p style="margin-top: 5px;line-height: 26px;color: rgb(58, 58, 58);margin-bottom: 16px;"><strong>BLOOM (BigScience Large Open-science Open-access Multilingual Language Model)<br></strong>BLOOM 是由 BigScience 研究团队推出的，一系列模型。BigScience 是一个由 Hugging Face 协调，联合法国的 GENCI 和 IDRIS 组织共同参与的国际合作项目，涵盖了来自 60 个国家、250 个研究机构的 1000 名科研人员。这些模型采用了仅包含解码器的 transformer 架构，并进行了细微调整，比如引入了嵌入后归一化和 ALiBi 位置嵌入技术。在这一系列模型中，最大的一个拥有 1760 亿个参数，它接受了 46 种人类语言和 13 种编程语言的 3500 亿个多语言数据词元的训练。大量的训练数据已经向公众开放，包括数据的来源、策划和处理过程的详细信息。它是目前为止发布的最大的开源多语言模型。</p></li><li><p style="margin-top: 5px;line-height: 26px;color: rgb(58, 58, 58);margin-bottom: 16px;"><strong>OPT (Open Pre-trained Transformer)<br></strong>Meta 发布的 OPT 模型，系列采用了仅包含解码器的 Transformer 架构。这些模型借鉴了 GPT-3 论文中的技术，如特定的权重初始化和预归一化策略，并对注意力机制进行了改进，比如引入了交替的密集型与局部带状注意力层。系列中最大的模型拥有 1750 亿个参数，其训练数据涵盖了来自公共领域的 1800 亿个数据词元，包括书籍、Reddit 社交平台数据、新闻、维基百科以及其他多种互联网来源。这一系列模型在性能上与 GPT-3 不相上下，并且通过编码优化减少了计算资源的消耗。</p></li><li><p style="margin-top: 5px;line-height: 26px;color: rgb(58, 58, 58);margin-bottom: 16px;"><strong>GLM-130B (General Language Model)<br></strong>清华大学联合智谱 AI 共同发布了 GLM-130B 模型。该模型基于完整的 Transformer 架构，并引入了一些创新（如采用 DeepNorm 进行层后归一化、使用旋转式位置嵌入）。GLM-130B 拥有 1300 亿参数，是在包含英文和中文的互联网数据集上训练的，这些数据集包括 The Pile、WuDao 语料库以及其他中文语料库，共计 4000 亿个词元。在性能上，GLM-130B 与 GPT-3 模型不相上下。</p></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);"><strong>较小或更专业的开源大语言模型<br></strong>近期，一些较小型的开源模型也相继发布，这些模型主要服务于科研领域：Meta 推出了 Galactica 系列的大型语言模型（LLM），其中规模最大的模型拥有高达 120B 参数，这些模型是在科学文献中的 1060 亿个词元基础上进行预训练的。EleutherAI 则发布了 GPT-NeoX-20B 模型，这是一个完全开源的仅解码器式 Transformer 模型（包括模型架构、权重和数据），在 5000 亿词元上经过训练，并采用了 RoPE 以及对注意力机制和初始化过程的若干改进，为科学研究提供了一个完整的工具集。 
    </section></li></ol><section style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);margin-top: 16px;">
    这些巨大的模型令人振奋，然而，它们的运行成本也高得惊人！在进行推理计算（即从模型中得出预测结果）时，模型必须被加载到内存中，而一个具有一千亿参数的模型往往需要占用高达 220GB 的内存空间（这个过程我们将在后文中详细阐述），这样的内存需求对于大多数机构和专业人士来说都是难以承担的！ 
  </section><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">然而，2022 年 3 月，DeepMind 发表了一篇，论文，探讨了在固定计算预算条件下，模型参数与数据量的最优配比。简而言之，如果你的模型训练预算有限，应该如何平衡模型大小和数据规模？研究者们发现，在平均计算预算下，对于大型语言模型（LLMs），更高效的策略是维持一个相对较小的模型，并在更广泛的数据集上进行训练。他们开发的模型 Chinchilla（未公开）拥有 700 亿个参数，仅为某些大型模型参数总数的三分之一，却在高达 1.4 万亿个词元的数据集上进行了训练，是其他模型所使用数据量的三到四倍。结果显示，Chinchilla 在性能上不仅媲美甚至超越了其他更大的同类型模型，无论是开源还是非开源的。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">这种范式的变化，尽管可能已在封闭的实验室环境中为人所知，但它却让整个开放的科学界感到措手不及。</p><span id="OSC_h2_3"></span><h2 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">🌊 2023, 开放发布之年</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><span id="OSC_h3_4"></span><h3 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);"><em style="color: black;">小型</em> 大语言模型的崛起</span><span style="display: none;"></span></h3><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">2023 年，仅解码器（decoder-only）式的 Transformer 模型迎来了爆发式增长。几乎每月都有新的预训练模型问世，发展速度之快以至于渐渐演变为每周甚至每日都有新模型的推出。Meta 在 2 月推出了 LLaMA 模型；Eleuther AI 在 4 月带来了 Pythia 模型；MosaicML 在 5 月推出了 MPT 模型；Salesforce 和 TIIUAE 则在 6 月分别发布了 X-GEN 和 Falcon 模型。Meta 紧随其后，在 7 月发布了 LLaMA 的升级版本 LLaMA 2。进入下半年，9 月阿里巴巴发布了 Qwen 模型；Mistral.AI 推出了同名 Mistral 模型；01-ai 在 11 月发布了 Yi 模型；Deci 推出了 DeciLM 模型；而 Upstage 则在 12 月带来了 Phi-2 和 SOLAR 模型。这一系列的模型发布，不仅展示了人工智能领域的快速进步，也预示着技术的不断迭代与革新。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">这些发布包括了：a) 模型权重（在不同程度的开源许可下）；b) 对于较小规模的模型（介于 30 亿至 700 亿参数之间），它们的性能都相当出色，因此立刻被社区采用。这些模型几乎都采用仅解码器的 Transformer 架构，并且进行了各种调整（比如 ALiBi 或 RoPE、RMS 预归一化、SwiGLU），以及对注意力函数的一些改变（如 Flash-Attention、GQA、滑动窗口注意力），并且在不同的代码库实现中进行了优化，以提高训练或推理速度。这些调整很可能在一定程度上影响模型的性能和训练速度；然而，由于所有架构都已经连同权重一起公开发布，剩下的核心差异主要在于训练数据和模型的许可方式。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">Meta AI 发布的 LLaMA 系列是该系列中的首款模型。研究团队的目标是在既定的计算预算内训练不同规模的模型，以求达到最优性能。他们首次明确将训练预算与推理成本（即在满足特定性能目标时，模型推理所需的成本）并重考虑。基于这样的考量，他们选择在更大量的数据和更多的训练步骤上，训练规模较小的模型，以期在较小的模型尺度上获得更高的性能（这是对训练计算效率的一种权衡）。在 LLaMA 系列中，最大的模型拥有 650 亿参数，经过了 1.4 万亿的词元训练，而规模较小的模型 —— 分别具有 60 亿和 130 亿参数 —— 则在 1 万亿词元训练后完成。在大多数基准测试中，130 亿参数的 LLaMA 小型模型的表现超过了 GPT-3，而 650 亿参数的 LLaMA 大模型在发布时则代表了最先进的技术水平。然而，这些模型的权重是以非商业许可的形式发布的，这限制了它们在社区中的应用范围。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">Eleuther AI 是一个开源的非营利实验室，它发布了一系列名为 Pythia 的大型语言模型（LLMs）。这些模型有不同的规模，全部采用公开数据进行训练，目的是为了帮助研究人员理解大型语言模型训练的不同阶段。有关 Pythia 模型的更多信息，可以通过它们在 Hugging Face 上的，系列合集，查看。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">MosaicML 公司在两个月后推出了 MPT 模型，该模型的性能优越，并且支持商业用途，同时公司还公开了其训练的具体细节。MPT 的首个版本是一个 7B 的模型，紧接着在 6 月份，公司发布了一个更大的 30B 版本。这两个模型都是基于 1 万亿个英语和编程语言的词元训练而成，训练数据包括了 C4、CommonCrawl、The Stack、S2ORC 等数据集。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">MPT 模型推出后不久，TIIUAE 团队便发布了 Falcon 系列模型，中的 7B 和 30B 版本。这些模型在 1 至 1.5 万亿个英文和代码词元上进行了训练，训练数据包括来自 RefinedWeb、Project Gutenberg、Reddit、StackOverflow、GitHub、arXiv、Wikipedia 等多个来源。同年晚些时候，TIIUAE 还发布了一款更为庞大的 180B 模型。Falcon 模型的细节、所用数据以及训练过程均在一份技术报告及随后发表的，研究论文，中有详尽的描述。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">先前的模型在公开时通常会公开其数据集，但随后推出的模型很少公布其训练过程中使用的具体信息，这使得重现它们的成果变得困难。尽管如此，这些模型通过发布它们的权重参数，为研究社区提供了一个研究和进一步开发的起点。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">Salesforce 在夏初推出了 X-Gen 模型，这是一款拥有 70 亿参数的模型，训练数据包括了 15 万亿个 「自然语言和代码」 词元，训练过程分为多个步骤，并采用了数据调度系统（并非所有数据同时输入模型）。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">X-Gen 在 Meta 推出的更为引人注目的新的 LLaMA-2 家族的阴影下显得有些黯然失色。LLaMA-2 是 Meta 推出的一个新的模型系列，规模从 7B 到 70B 不等，这些模型是在 2 万亿个 「来自公开来源的词元」 上训练而成的，采用了宽松的社区许可证，并经过了人类偏好的精细调整（RLHF），即所谓的对齐过程。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">随后，新兴初创企业 Mistral 推出了其首款模型 ——Mistral-7B，该模型，是基于互联网公开数据集的大量数据训练而成，具体数据量尚未公布。随着 2023 年末的临近，模型发布活动日益频繁。Mistral 紧接着发布了更为庞大的第二款模型 Mixtral 8x7B。与此同时，Deci.AI 公司也带来了其令人瞩目的首款模型 DeciLM，upstage 公司也不甘落后，推出了规模更大的 SOLAR 模型。这些模型均采用了来源和数量未公开的数据进行训练。在各大排行榜和公开基准测试中，这些模型均展现出稳步的进步。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在 2023 年年底，值得关注的一大事件是中国训练并公开发布了多个性能显著提升的模型。其中，阿里巴巴推出了其双语（英汉）模型 Qwen 系列，其参数规模从 70 亿，至 700 亿不等，经过了 240 亿词元数据的训练。与此同时，01-AI 公司也发布了 Yi 系列模型，其参数规模介于 60 亿至 340 亿之间，训练数据量达到了 300 亿词元。这些模型在公开排行榜（如 Open LLM leaderboard）以及一些极具挑战性的基准测试（例如 Skill-Mix）中的表现，均超过了之前的模型。2023 年底的另一强有力的新竞争者是 DeepSeek AI，他们推出了 「DeepSeek-Coder」，该模型从零开始训练了 200 亿词元数据，其中包含 87% 的代码和 13% 的英汉混合自然语言。</p><span id="OSC_h3_5"></span><h3 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">随处可见的对话模型</span><span style="display: none;"></span></h3><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">2023 年，与前一年相比，几乎所有新发布的预训练模型都配备了预训练版本和对话微调版本，这些版本采纳了多种现有的调整方法。尽管适用于聊天环境的模型调整技术在 2022 年及以前已有所开发，但这些技术在 2023 年得到了广泛应用并迅速兴起，这突显了聊天模型在普罗大众中使用的快速增长，以及通过与模型的互动对其进行的人工评估（即 「氛围检查」 评估）。本文将详细介绍几种著名的训练调整预训练模型以进行聊天的方法，实际上，相关的变体还有很多！</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">基于对话的微调</strong> 是一种特殊形式的监督式微调。在这种方法中，我们使用的标注数据是对话形式的，类似于社交媒体上的多轮对话记录。通过这种方式，可以对模型进行特定的微调。在这个过程中，我们可以采用与模型训练阶段相同的技术。例如，在处理仅解码器 Transformer 模型时，可以训练模型通过自回归方法，即逐一预测接下来的词元。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">指令微调</strong>（Instruction-based Fine-Tuning，IFT）采用相同的方法，但使用指令数据集，该数据集包含一系列类似查询的提示以及答案（如果需要，还可以包含可选的附加输入）。这些数据集教导模型如何遵循指示，并且可以是人类生成的，也可以是大型语言模型生成的。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">利用大规模模型输出的合成数据集（由模型生成的数据集，例如来自 GPT-4 的生成，可以是来自指示或用户与模型之间的交互）是实现指导微调和聊天微调的一种方式。这通常被称为 「蒸馏」，因为它涉及从性能较高的模型中获取知识，以训练或微调较小的模型。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">这两种方法都相对容易执行：你只需找到或创建相应的数据集，然后采用与训练时相同的技术对模型进行调整即可。去年，发布了众多指导性数据集，它们有效提升了模型在对话场景中的表现。想要了解更多关于此主题的信息，可以参阅这篇介绍性博文的，链接。然而，尽管模型的性能有了显著提升，但它们仍未能完全达到人类的预期水平。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">从人类反馈中强化学习</strong>（Reinforcement Learning from Human Feedback，RLHF）是一项旨在使模型输出与人类偏好（基于特定标准）相一致的特定方法。具体操作流程如下：模型根据给定的提示生成多个潜在答案；人类评估者对这些答案进行排序；然后，这些排序结果用于训练一个偏好模型（该模型学习如何给出反映人类对答案偏好程度的评分）；最后，利用偏好模型通过强化学习对语言模型进行进一步的微调。更详细的信息，请参阅这篇，博客文章，原始 RLHF 论文，或者 Anthropic 关于 RLHF 的论文。需要注意的是，这是一种成本较高的方法（注释 / 排名 + 训练新模型 + 微调的整个过程成本很高），主要用于确保模型的输出与安全目标相符。为了降低成本，人们开发了一种低成本的变体方法，即利用高质量的语言模型来对模型输出进行评分，而不是完全依赖人类评价，这种方法称为从 <strong style="color: black;">人工智能反馈中学习的强化学习</strong>（Reinforcement Learning from AI Feedback, RLAIF）。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">直接偏好优化</strong>（Direct Preference Optimization, DPO）是 RLHF 的另一种变体，其核心优势在于无需训练和运用独立的偏好模型。这一方法同样需要人类或人工智能生成的排序数据集，但它通过直接利用这些数据来更新模型，即通过对比模型现有的策略（即预测行为）与理想的策略（即能够预测出最优排序答案的行为）。换言之，模型本身即扮演了对齐和偏好模型的双重角色，这不仅简化了优化流程，而且根据报告，还能够实现与其他方法相媲美的性能水平。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">回到来自（大多数）私企的小型开放权重模型的浪潮，其中很多模型都发布了经过精细调整的对应版本：MPT-7B 还配备了一个指令微调和一个对话版本，Falcon 和 XGen 模型的指令微调版本在年底发布，Llama-2、Qwen 和 Yi 发布了对话版本，DeciLM 则发布了一个指令微调版本。Llama-2 的发布尤其引人注目，因为它在预训练和指令微调模型中都特别注重安全性。</p><span id="OSC_h3_6"></span><h3 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">社区的进展如何？</span><span style="display: none;"></span></h3><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">虽然随着新模型的发布，聊天模型和指令微调模型通常会立即推出，但社区成员和研究人员并没有把这看作是理所应当的。在这些基础模型提供的沃土上，涌现出了一个庞大而活跃的微调爱好者社区。这些微调专家经常会构建新的数据集，并对模型进行细致的微调，以此来展现新发布模型的出色性能。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在 2023 年伊始，一些专为指令交互和对话微调设计的数据集已经被发布。例如，代表人类偏好的数据集包括 OpenAI 的 WebGPT 数据集、Anthropic 的 HH-RLHF 数据集以及 OpenAI 的，摘要，数据集，它们在这一领域是开拓者。指令数据集的例子包括 BigScience 的，公共提示池、Google 的 FLAN 1 和 2（FLAN 数据集）、AllenAI 的，自然指令，数据集、由不同机构的研究人员开发的自动生成指令框架，自我指令、由专家创建的指令基准，超自然指令（有时用作微调数据），以及由特拉维夫大学和 Meta 合作生成的自动指令数据集，非自然指令，等。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">❄️ 冬 2022/2023: 一月，来自中国多个研究机构的研究人员共同发布了，人类 ChatGPT 指令语料库（HC3），其中包含了人类与模型对各种问题的回答。3 月份，发布活动接连不断：斯坦福大学推出了 Alpaca 模型，这是首个遵循指令的 LLaMA 模型（7B），以及相关的数据集，包括用大型语言模型生成的 52K 条指令。非营利开源实验室 LAION 发布了，开放指令通用数据集（OIG），包含 4300 万条指令，这些指令既有通过数据增强创建的，也有编译自其他现有数据源的。同月，位于加州大学伯克利分校的 LMSYS 组织发布了 Vicuna，这也是一个基于 ChatGPT 聊天数据的 LLaMA 精调模型（13B），这些聊天数据是用户与 ChatGPT 之间的对话，由用户自己公开分享在 ShareGPT 上。还发布了 Guanaco 数据集，它是 Alpaca 数据集的扩展版（增加了 50 万条多语言条目），以及相关的 LLaMA-7B 精调模型。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">🌱 春：四月，伯克利人工智能研究实验室（Berkeley AI Research lab，BAIR）发布了 Koala，这是一个经过聊天调优的 LLaMA 模型，它使用了多个先前的数据集（包括 Alpaca、HH-RLHF、WebGPT、ShareGPT），而 DataBricks 则发布了 Dolly 数据集，这是一个由 15K 条人工生成的指令组成的数据集，以及相关的 Pythia 微调模型。五月，清华大学发布了 UltraChat，这是一个包含 1.5M 对话指令的数据集，以及在该数据集上进行微调的 UltraLLaMA 模型。随后，微软发布了 GPT4-LLM 数据集 / 框架，用于生成 GPT4 的指令。六月，微软研究院分享了一种新方法 Orca，通过使用大型模型的推理轨迹（逐步解释其推理过程）来构建指令数据集，该方法很快被社区（尤其是 Alignementlab.ai）复现，他们创建了 Open Orca 数据集，包含数百万条条目，随后用于微调多个模型（如 Llama、Mistral 等）。五月和六月期间，Camel-AI 发布了多个关于不同话题（物理、生物、化学等）的指令或聊天数据集，每个领域都有超过 20K 的示例。同样在六月，发布了 Airoboros 框架，用于使用模型生成的数据微调模型（遵循自我指导方法），以及一系列的，指令数据集。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">🌻 夏：八月，由中国的非营利组织 OpenBMB 发布了 UltraLM（一种基于 LLaMA 的高性能聊天模型微调版本），随后在九月，他们又发布了相关的偏好数据集 UltraFeedback，这是一个包含与 GPT4 对比的输入反馈数据集，并附有注释。在整个夏天，一个名为 NousResearch 的集体发布了多个基于私有和公开指导数据集的微调版本（特别是 Hermes 和 Capybara 系列）。九月，清华大学的一个学生团队发布了 OpenChat，这是一个应用了新的强化学习微调策略的 LLaMA 微调版本。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">🍂 秋：十月，Hugging Face 发布了 Zephyr 模型，这是一个在 UltraChat 和 UltraFeedback 上使用 DPO 和 AIF 技术对 Mistral 模型进行微调的产物。同时，社区成员发布了 OpenHermes 2，这是一个在来自网络或使用 Axolotl 生成的 900K 条目上对 Mistral-7B 模型进行微调的版本。Lmsys 发布了 LMSYS-Chat-1M，包含了与 25 个大型语言模型（LLMs）的真实用户对话。十一月，OpenBuddy 发布了 OpenBuddy-Zephyr，这是一个对 Zephyr 模型进行微调的多轮对话模型。同月，NVIDIA 发布了 HelpSteer 数据集，这是一个对齐微调数据集，提供了提示、相关模型回应以及基于几个标准对这些回答的评分，而微软研究院则发布了 Orca-2 模型，这是一个在新的合成推理数据集上对 Llama 2 模型进行微调的版本。十二月，伯克利大学发布了 Starling 模型，这是一个对 Open-Chat 模型进行 RLAIF 微调的版本，以及相关的数据集 Nectar，包含了 20 万条比较数据。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">正如我们看到的，今年整个领域的发展既依赖于通过使用高质量的预训练大型语言模型（LLMs）创建新数据集，也依赖于社区发布的各种开源模型，这使得该领域进步飞速！如果你现在在模型名称中看到这些名字中的任何一个，你就能够大概了解它的来源了🤗。</p><ul data-tool="mdnice 编辑器" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      还有一些更专业的数据集，例如用于数学问题微调的 MetaMath 和 MathInstruct，以及涉及数学和代码指令的 Evol-Instruct，还有 CodeAlpaca 与 CodeCapybara 等代码指令相关的数据集也已发布。虽然这些数据集同样被用于提升模型在特定任务上的表现，但我们在此不会详细介绍它们。你还可以访问，令人心动的指令数据集，来查看其他相关数据集的集合。 
    </section></li></ul><span id="OSC_h2_7"></span><h2 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">开启定制模型的大门</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><span id="OSC_h3_8"></span><h3 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">模型融合：极致的定制化</span><span style="display: none;"></span></h3><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在开源社区的典范实践中，一个重要的里程碑是模型与数据的融合。随着每一次代码合并或提交，追溯所使用数据的来源变得愈发复杂 —— 许多公开的数据集本身就是其他数据集的汇编。同样，由于卓越性能的模型往往是在相似模型的基础上经过层层微调得来的（可参考 Mistral 的，衍生模型树），模型的发展历史也变得难以梳理。在这篇摘要中，我们尚未有足够的篇幅深入探讨这一引人入胜的技术领域，但在最后，我们将简要介绍一下它的概念。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">然而，「模型融合」 究竟是什么意思呢？</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">模型融合</strong> 是一种将不同模型的权重融合到一个单一模型中的方法，其理想目标是将每个模型的各自优势结合在一个统一的模型中。目前已有一些技术实现了这一目标，这些技术大多在社区论坛中得到扩展和发布，这是一个全球范围内的去中心化研究的典型案例，涵盖了从业者、研究人员到业余爱好者的广泛社区。其中一种最简单的公开方法是平均一组具有共同架构的模型的参数（示例 1，示例 2），但还存在更复杂的参数组合方法，例如确定每个模型中对特定任务最有影响力的参数（加权平均），或者在合并前考虑模型间参数的相互干扰，从而选择保留哪些参数（关联融合）。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">这些技术使任何人都能轻松地生成模型的组合，而且由于大多数现代模型都是基于同一架构的变体，这一过程变得尤为简便。这也是 Open LLM leaderboard 上一些模型名称如 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">llama2-zephyr-orca-ultra</code> 的原因。这个特定的例子很可能是将 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">llama2</code> 和 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">zephyr</code> 模型合并后，再在 orca 和 ultra 数据集上进行微调的结果。通常，更多的细节可以在 Hugging Face 中心的相应模型卡片上找到。</p><span id="OSC_h3_9"></span><h3 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">参数高效微调：触手可及的个性化体验</span><span style="display: none;"></span></h3><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">有时候，你可能需要进行更为细致的个性化调整，但受限于硬件显存大小，无法加载完整模型进行微调。其实，你知道吗？微调时并不必须要用到模型的全部。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">你或许想尝试一种叫做 <strong style="color: black;">参数高效微调</strong>（Parameter-Efficient Fine-Tuning，PEFT）的方法。这项技术首先会冻结你所关注的预训练模型中的参数，然后在其基础上附加一些新的参数层，也就是我们所说的 「适配器」。接下来，你只需对这些专为你的任务设计的轻量级适配器权重进行微调，这些权重远小于原始模型的规模。这样，你仅需分享你的小型适配器权重（以及底层模型）即可！你可以在，这里，探索一系列引人入胜的 PEFT 技术。</p><span id="OSC_h3_10"></span><h3 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">量化：模型普及于各处</span><span style="display: none;"></span></h3><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">我们已经看到，性能出色的模型现在形态各异…… 但即便如此，并不意味着它们对所有人都是触手可及的！一个拥有 300 亿参数的模型仅仅加载到内存中（还未开始使用）就可能需要超过 66GB 的 RAM，而并非社区中的每个人都有能力配备这样的硬件。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">这就是量化技术的用武之地！量化是一种特殊的技术，它通过改变模型参数的精度来减少模型的大小。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">量化是什么意思呢？</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在计算机中，数字是以一定的精度存储的，例如 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">float32</code>、<code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">float16</code>、<code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">int8</code> 等。精度不仅指明了数字类型（是浮点数还是整数），同时也指出了数字存储所占用的内存大小：例如 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">float32</code> 是在计算机上以 32 位存储的浮点数。要了解更深入的解释，请参见这个，链接。因此，数据的精度越高，它所占用的物理内存就越多，这是因为需要更多的位来存储这些数据。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">因此，如果你降低精度，就会减少模型参数在存储上占用的内存，进而减小模型的大小！这也意味着你降低了计算的实际精度，可能会降低模型的性能。然而，我们发现，在较大的模型上，这种性能下降实际上是，非常有限，的。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">回到我们之前的例子中，一个含有 300 亿参数的模型，在使用 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">float16</code> 格式时需要不到 66GB 的内存。如果采用 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">8bit</code>，内存需求将减半至 33GB；若使用 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">4bit</code> 编码，则只需大约 16GB，进一步降低了内存的要求，使得模型更易于部署和使用。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">精度转换有多种方法，涉及不同的 「转换」 策略，每种策略都有其独特的优势和局限。目前流行的转换方法包括 bitsandbytes、GPTQ, 和 AWQ 等。有些开发者，例如 TheBloke，甚至正在将所有流行的模型进行转换，以便更容易地被社区使用。所有这些方法都是相对较新并且仍在不断发展之中，我们期待随着时间的推移，这些技术能够取得更多的进步。</p><span id="OSC_h2_11"></span><h2 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">接下来呢？</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">年尾尚未到来！在这最后时刻，已经迎来了一些惊喜：新的架构是否终将超越简单高效的 Transformer 模型呢？</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">最新发布包括：</p><ul data-tool="mdnice 编辑器" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      混合专家模型： 
    </section></li><ul style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;color: black;list-style-type: square;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
       Mixtral，该模型由 8 个子模型（仅解码器的 Transformer 模型）组成，对于每个输入，一个路由器会选择两个最佳子模型并将它们的输出求和。 
     </section></li></ul><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      几种状态空间模型（通过潜在空间将输入映射到输出的模型，可以根据任务需求表达为 RNN 或 CNN）： 
    </section></li><ul style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;color: black;list-style-type: square;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
       Mamba，增加了选择机制的状态空间模型 
     </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
       Striped Hyena，具有快速卷积核的状态空间模型 
     </section></li></ul></ul><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">目前来说，这些新方法是否会取代 Transformer 模型还为时尚早，但状态空间模型确实非常有前景！</p><span id="OSC_h2_12"></span><h2 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">要点回顾</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><ul data-tool="mdnice 编辑器" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      今年，从大型企业到初创公司，再到研究实验室，各种主体纷纷开放发布模型，这极大地赋能了社区，使其以前所未有的速度开始进行实验和探索。 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      模型公告的开放性呈现出起伏变化，从年初的公开发布（数据集组合、权重、架构）到年末对训练数据守口如瓶，导致无法复现。 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      开源模型出现在包括中国在内许多新的地方，有几个新的参与者将自己定位为语言模型竞争中的强劲竞争者。 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      个性化定制的可能性达到了前所未有的高度，新策略的出现（如强化学习优化的微调、适配器、合并技术），虽然这仅仅是个开始。 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      更小的模型尺寸和量化升级使得大型语言模型对更多人来说变得真正唾手可得！ 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      新的架构也随之出现 —— 它们是否最终会取代 Transformer 架构，仍是一个值得关注的问题。 
    </section></li></ul><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">各位朋友们，就是这样了！</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">希望你喜欢我们今年的回顾，从中学到了一些知识，并且和我一样，对于人工智能进步现在如此依赖开源和社区努力感到无比热情！🤗</p><blockquote data-tool="mdnice 编辑器" style="border-top: none;border-right: none;border-bottom: none;font-size: 0.9em;overflow: auto;color: rgb(106, 115, 125);padding: 10px 10px 10px 20px;margin-bottom: 20px;margin-top: 20px;border-left-color: rgb(255, 177, 27);background: rgb(255, 245, 227);"><p style="font-size: 16px;line-height: 26px;color: rgb(89, 89, 89);"><span style="font-size: 14px;">英文原文:</span><url style="font-size: 14px;color: rgb(136, 136, 136);visibility: visible;display: block;"><span style="font-size: 14px;">https://huggingface.co/blog/2023-in-llms</span></url><span style="font-size: 14px;">原文作者：Clémentine Fourrier<br>译者: Xinyu Yang (杨新宇)，字节跳动算法工程师，工作方向为通过 SFT、RL 提升大模型 Math、Reasoning 能力。</span></p></blockquote></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - Hugging Face（gh_504339124f0f）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 04:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/HuggingFace/blog/10555492</guid>
            <link>https://my.oschina.net/HuggingFace/blog/10555492</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[TinyEngine 服务端正式开源啦]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h1>背景介绍</h1><h2>TinyEngine 低代码引擎介绍</h2><p>随着企业对于低代码开发平台的需求日益增长，急需一个通用的解决方案来满足各种低代码平台的开发需求。正是在这种情况下，低代码引擎应运而生。它是一种通用的开发框架，通过对低代码平台系统常用的功能进行解构，将其划分为多个功能模块，并为每个模块定义了相应的协议和开发范式，使得开发者可以根据自身的业务需求，轻松定制开发出自己的低代码开发平台。</p><p>TinyEngine 提供了低代码底层能力，并集成了人工智能，从而使用户能够高效开发。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a> 具有强大的拖拽功能，无论是图元还是复杂组件，都能在画布上带来流畅的体验。它适用于多场景的低代码平台开发，包括资源编排、流程编排、服务端渲染、模型驱动、移动端、大屏端以及页面编排等低代码平台。</p><p>TinyEngine 官网：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine" target="_blank">https://opentiny.design/tiny-engine</a><br> TinyEngine 源码：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">https://github.com/opentiny/tiny-engine</a> （欢迎 star）</p><p><img src="https://oscimg.oschina.net/oscnet/up-fa7423149eca45391380663a32b595b208f.png" alt="" referrerpolicy="no-referrer"></p><h2>服务端开源介绍</h2><p>2023 年 9 月 21 日，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a> 在<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7280926568854667299" target="_blank">华为全联接大会正式宣布开源</a>，引发了广泛的关注，3 个月时间收获了 960 个 Star，组建了 4 个用户交流社群，成员数 772 名。</p><p>很多企业和个人开发者尝试基于 TinyEngine 搭建自己的低代码平台，为搭建企业 Web 应用提效，在使用过程中，大家也遇到了很多问题，比较常见的包括：如何对接服务端、如何导入第三方组件库、如何使用插槽、如何生成代码、如何开发自定义插件等，为此我们在 10 月 27 日策划了一次<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7298642242116452402" target="_blank">线上直播答疑活动</a>，邀请了团队技术专家为大家答疑解惑。</p><p>其中如何对接服务端是众多开发者非常关注的问题，为了帮助开发者打通低代码平台搭建的前后端整体流程，本次 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a> 低代码引擎服务端配套代码的开源，让开发者能够深入了解 TinyEngine 低代码引擎的前后端运行机制，更能够让更多的小伙伴以更深的层次参与到产品共建，共同探讨并改进系统，推动其不断优化，带来更高的创新潜力，使得更多的人能够从中受益。</p><p>同时服务端的开源为自由定制和扩展提供了可能，开发者可以参考 TinyEngine 的代码，根据自身需求对服务端进行改造创新，从而使得产品更具灵活性，能够满足各种复杂的业务需求，构建一个强大而健壮的 TinyEngine 生态系统。</p><h1>核心特性</h1><p>当今互联网应用的复杂性和用户需求的多样性要求我们搭建一套灵活的、便于扩展的系统架构，以满足不断变化的业务需求。 因此我们引入了微服务的概念，将系统拆分为小而独立的服务单元，使得每个服务单元都可以独立开发、测试和部署。这种架构不仅提高了团队的协作效率，还使得系统更容易扩展和维护。</p><ul><li>TinyEngine 设计器微服务选择了<strong>基于 Node.js 的技术栈</strong>，为前端开发者提供了一致的开发体验，无需学习额外的语言即可全栈开发，降低了开发难度和学习曲线，避免了学习新语言的困扰。更能够从服务端的角度去理解 TinyEngine 设计器的运行原理与设计思想。</li><li>在我们的架构设计中，我们<strong>采用了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.eggjs.org%2Fzh-CN" target="_blank">Egg.js</a> 作为业务接口微服务的框架</strong>。Egg.js 优秀的设计和丰富的插件生态系统，使得我们能够迅速构建可维护、可扩展的微服务，从而确保系统的稳定性和可维护性。</li><li>为了降低服务耦合，我们还单独封装了<strong>提供数据库操作接口的数据中心微服务</strong>，在框架选型上我们选择了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.strapi.io%2F" target="_blank">Strapi</a>，Strapi 是一个开源数据管理框架。不仅提供了强大的数据管理和查询功能，还支持自定义内容类型和灵活的 API 构建，为我们的微服务提供了丰富的数据支持。Strapi 的易用性和可扩展性使得我们能够高效地管理和发布数据，确保前端业务接口始终能够获得及时、准确的数据支持。</li></ul><p>综上所述，我们的技术架构旨在提供高效、可维护、可扩展的系统，充分利用 Node.js 和现代化的开源工具，使我们能够更好地满足不断变化的业务需求。这种架构不仅提高了开发效率，还为未来的扩展和创新提供了坚实的基础。</p><h1>服务端架构</h1><p>根据上面的介绍，开发者可以根据微服务这一特性，轻松扩展并实现自己的 TinyEngine 服务端架构。</p><ul><li>业务接口微服务（webService）：构建业务的引擎， 汇总连接其他微服务为前端提供接口。</li><li>数据中心 (data-center)： 作为数据基座，统一进行数据管理，为其他微服务提供一致性的数据支持。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-f120981dacaac81db69e9a2f113ef113e3b.png" alt="" referrerpolicy="no-referrer"></p><p>根据上述架构特点，我们可以在此基础上，通过核心的 webService (业务接口微服务) 搭配任务队列服务 (RabbitMq、 Kafka、 RocketMq 等等) 连接其他功能微服务， 从而拓展整体系统的功能，例如：</p><ul><li>构建服务：由 webService 收集用户请求触发任务队列执行耗费机器资源的构建设计器、区块、物料的相关服务。</li><li>爬虫服务：单独封装，安装了 puppeteer 服务器的微服务，由 webService 触发去执行一些爬取数据、代理登录等等操作。</li><li>AI 大模型相关服务：连接自己内部 AI 大模型， 进行设计器智能化相关的 AI 代码生成、指令操作等等功能的。</li><li>发布服务：封装自己的 CI/CD 流水线微服务，结合设计器代码产出，使代码生产-构建-部署一条龙式运作。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-4558b19a5a930a638d800a5208bcb821d59.png" alt="" referrerpolicy="no-referrer"></p><h1>硬件配置</h1><h2>本地开发</h2><p>推荐使用 <code>windows</code> 操作系统， 推荐配置如下：</p><ul><li>64 位操作系统</li><li>12 核 CPU</li><li>32G 内存</li></ul><h2>服务容器化部署</h2><p>以下信息为支撑 50 qps 并发量的配置参考， 开发者可根据实际情况进行具体问题具体分析，配置信息仅供参考.</p><p>配置单位：</p><ul><li>U: cpu 核数</li><li>G: 内存单位</li></ul><p>在配置负载均衡的情况下推荐：</p><table><thead><tr><th>服务</th><th>配置</th><th>工作负载数量</th></tr></thead><tbody><tr><td>webService</td><td>1U+3G</td><td>4</td></tr><tr><td>data-center</td><td>1U+2G</td><td>4</td></tr></tbody></table><h1>FAQ</h1><p><strong>1、服务端开源之后，如果不想启动 webservice 和 datacenter 两个后端服务器，是否还能沿用原来 mockServer？</strong><br> 答：可以正常使用 mockServer，启动方式和原先一致，直接在项目里执行 <code>pnpm dev</code> 即可</p><p><strong>2、如果本地启动了 webservice 和 datacenter，那么前端本地工程是否还需要更改配置？如果需要，如何更改配置？</strong><br> 答：需要更改配置，更改流程如下： 启动 <code>tinyengine</code></p><p>修改 <code>packages/design-core/vite.config.js</code> 中 origin 的值为自己本地 webService 项目的地址端口（webService 端口默认为 7011）</p><p>运行如下脚本并启动</p><pre><code class="language-sh">pnpm install  # 第一次启动项目需要
pnpm serve:frontend
</code></pre><p>启动成功后浏览器会自动打开设计器页面</p><p><img src="https://oscimg.oschina.net/oscnet/up-a0f5b0133144d2b27013c73bacbf232675f.png" alt="" referrerpolicy="no-referrer"></p><p>具体搭建流程可参考官网本地化部署文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhelp-center%2Fcourse%2Fbackend%2F51" target="_blank">TinyEngine 服务端开源部署 </a></p><h1>未来规划</h1><p>1，人工智能：计划将低代码平台与 AIGC（人工智能生成内容）技术相结合，为用户提供更加智能、高效的应用开发体验。后续我们考虑将低代码平台的开发流程与 AIGC 技术相结合，通过自然语言处理、机器学习和深度学习等技术，实现应用界面的自动生成、功能模块的智能推荐和代码的自动化生成等功能。</p><p>2，模型驱动：我们将致力于将低代码平台与模型驱动能力相结合，为用户提供更加高效、智能的开发体验。深入研究各种业务模型，包括数据模型、业务流程模型等，以了解其特性和需求。后续，我们将低代码平台的开发流程与模型驱动能力相结合，通过可视化建模工具和自动化技术，实现业务模型的快速构建和部署。通过这一创新性的接入方式，用户将能够更加高效地构建和调整业务模型，降低开发难度和成本。</p><h2><strong>关于 OpenTiny</strong></h2><p><img src="https://oscimg.oschina.net/oscnet/up-1c661a9c0916f9dabf9cf1c4aeba473fb68.png" alt="" referrerpolicy="no-referrer"></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">OpenTiny</a> 是一套企业级 Web 前端开发解决方案，提供跨端、跨框架、跨版本的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue%2Fzh-CN%2Foverview" target="_blank">TinyVue 组件库</a>，包含基于 Angular+TypeScript 的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-ng%2Foverview" target="_blank">TinyNG 组件库</a>，拥有灵活扩展的低代码引擎 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a>，具备主题配置系统<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Fdesigntheme%2Fhome" target="_blank">TinyTheme</a> / 中后台模板<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Fpro%2Fhome" target="_blank"> TinyPro</a>/ <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-cli%2Fhome" target="_blank">TinyCLI </a>命令行等丰富的效率提升工具，可帮助开发者高效开发 Web 应用。</p><hr><p>欢迎加入 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">OpenTiny 开源社区</a>。添加微信小助手：opentiny-official 一起参与交流前端技术～更多视频内容也可关注<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspace.bilibili.com%2F15284299%3Fspm_id_from%3D333.1007.0.0" target="_blank">B 站</a>、抖音、小红书、视频号</p><p>OpenTiny&nbsp;也在持续招募贡献者，欢迎一起共建</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">OpenTiny 官网</a>：<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">https://opentiny.design/</a></strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">OpenTiny 代码仓库</a>：<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">https://github.com/opentiny/</a></strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">TinyVue 源码</a>：<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">https://github.com/opentiny/tiny-vue</a></strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">TinyEngine 源码</a>： <strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">https://github.com/opentiny/tiny-engine</a></strong></p><p>欢迎进入代码仓库 Star🌟<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">TinyEngine</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">TinyVue</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Fng" target="_blank">TinyNG</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-cli" target="_blank">TinyCLI</a>~</p><p>如果你也想要共建，可以进入代码仓库，找到&nbsp;good first issue 标签，一起参与开源贡献~</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 03:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6769809/blog/10555626</guid>
            <link>https://my.oschina.net/u/6769809/blog/10555626</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 年化收入超 16 亿美元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theinformation.com%2Farticles%2Fopenais-annualized-revenue-tops-1-6-billion-as-customers-shrug-off-ceo-drama" target="_blank">The Information</a> 援引知情人士消息称，受益于 ChatGPT 产品的强劲增长，OpenAI 最近的年化收入已经从 10 月中旬的 13 亿美元增至 16 亿美元。</span></p><p><span style="color:#000000">这一增长表明，「即便该公司因为 11 月份的领导层危机为竞争对手提供了抢夺客户的机会，但其仍能保持向企业销售人工智能产品的业务势头。」</span></p><p><img height="307" src="https://oscimg.oschina.net/oscnet/up-bc1feecce3c765f974f328d2a2ace13b9a6.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000">OpenAI 于 2023 年 2 月推出 ChatGPT 服务的付费版本 ChatGPT Plus 后，销售额开始快速增长。此前，该公司主要通过应用程序接口向开发者提供 AI 模型来进行创收。数据显示，该公司 2022 年亏损 5.4 亿美元，营收仅为 2800 万美元。</span></p><p><span style="color:#000000">路透社报道称，OpenAI 最初预计在 2023 年完成 2 亿美元的销售额。但事实证明，ChatGPT Plus 比预期的要更受欢迎：在 8 月份，OpenAI 的营收就突破了 10 亿美元，10 月达到了 13 亿美元。该公司的销售势头预计将持续到 2024 年。OpenAI 的一些高管认为，截至年底，其年化经常性收入将增长近四倍，达到 50 亿美元。</span></p><p><span style="color:#000000">「这种乐观的前景表明，该公司可能不会仅仅依靠现有产品的需求来维持其销售增长。特别是，它可能计划推出新的 AI 服务，从而创造额外的收入来源。」</span></p><p><span style="color:#000000">OpenAI 收入的快速增长也可能有助于其在来年获得投资者更高的估值。日前曾有<a href="https://www.oschina.net/news/272549/openai-valuation-100-billion-funding-round">消息称</a>，OpenAI 正在以 1000 亿美元或以上的估值筹集新一轮融资。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 03:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273759/openais-annualized-revenue-tops-1-6b</guid>
            <link>https://www.oschina.net/news/273759/openais-annualized-revenue-tops-1-6b</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 正式加入 CNCF 云原生计算基金会]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><strong style="outline: 0px;visibility: visible;">vivo 近期完成了新会员的 Onboarding 流程， 已正式加入 CNCF 云原生计算基金会</strong>（<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io" textvalue="https://www.cncf.io" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.cncf.io</a>）。<strong style="letter-spacing: 0.544px;outline: 0px;visibility: visible;"></strong></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><span style="text-align: center;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"><br></span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><span style="text-align: center;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100014267" data-ratio="0.5613346418056918" data-s="300,640" src="https://oscimg.oschina.net/oscnet/d2d6894b-bacd-42d9-b2d8-05a6782d0354.png" data-type="png" data-w="1019" style="letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" referrerpolicy="no-referrer"></span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><span style="text-align: center;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span></p><p><span style="background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">C</span><span style="background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">NCF 云原生计算基金会 （Cloud Native Computing Foundation）是 Linux 基金会的一部分，是开源、供应商中立的云原生计算生态组织，致力于云原生应用推广和普及。我们希望通过加入 CNCF 基金会</span><strong style="font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">，推动云原生技术在 vivo 内部的应用和发展，助力自身业务高效交付；同时进一步加强与全球云原生开源社区的交流沟通和知识分享，共同推动行业云原生技术生态的可持续发展</strong><span style="background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">。</span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;">在正式加入 CNCF 云原生计算基金会之前，vivo 内部研发团队积极探索与实践云原生技术，在多个业务场景下应用云原生项目，助力业务发展。</p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100014268" data-ratio="0.43425925925925923" data-s="300,640" src="https://oscimg.oschina.net/oscnet/695497a4-859d-487c-b98b-7537cebc2053.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"><span style="font-size: var(--articleFontsize);letter-spacing: 0.034em;text-align: justify;"></span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">vivo 在云原生领域的项目采纳现状</span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">截止 2023 年 12 月</span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;text-align: left;"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: right;visibility: visible;"><section style="padding: 10px;outline: 0px;display: inline-block;width: 677px;border-width: 1px;border-style: solid;border-color: transparent;background-color: rgb(239, 239, 239);height: auto;visibility: visible;"><section powered-by="xiumi.us" style="outline: 0px;font-size: 14px;text-align: justify;visibility: visible;"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p><strong style="font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(239, 239, 239);outline: 0px;visibility: visible;">应用方面：</strong><br></p><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;">在云原生领域的应用主要包括基于 Kubernetes 的容器编排、服务发现和负载均衡、容器镜像管理、日志收集和分析等场景。通过使用 Openkruise、Helm、Harbor、Containerd、Dragonfly、Fluentd 等开源项目与工具，vivo 实现了基于容器平台的应用发布和管理，提高了业务交付效率和系统可靠性。</span></p></li></ul><p style="outline: 0px;visibility: visible;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="outline: 0px;visibility: visible;"><strong><span style="font-size: 15px;">容器平台能力建设方面：</span></strong></p><p style="outline: 0px;visibility: visible;"><strong><span style="font-size: 15px;"></span></strong><span style="font-size: 15px;letter-spacing: 0.544px;">主要包括基础设施建设、平台架构设计和运维管理等方面。通过使用 Kubernetes 等容器编排技术，vivo 构建了一套完整的容器平台，包括容器集群运维、容器网络、存储管理、应用发布、安全管理等模块，为企业内部多个业务线提供了稳定、可靠的容</span><span style="font-size: 15px;letter-spacing: 0.544px;">器平台。</span></p></li></ul><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;"><br></span></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p><span style="font-size: 15px;"><strong>敢于探索实践方面：</strong></span></p><p><span style="font-size: 15px;"></span><span style="font-size: 15px;letter-spacing: 0.544px;">vivo 在云原生领域勇于探索和实践，积极参与开源社区和代码贡献，持续探索并推广新技术及其应用场景。</span><span style="font-size: 15px;letter-spacing: 0.544px;">同时有积极参与 CNCF 应用交付 TAG 旗下相关工作组的贡献，推广和传播平台工程相关的白皮书、成熟度模型等相关实践和标准。</span></p></li></ul></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br style="outline: 0px;visibility: visible;"></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;">此外，vivo 持续保持与行业交流及合作，共同探索云原生时代的软件工程之道。2023 年 9 月由 Linux 基金会、云原生计算基金会（CNCF）主办的 <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.lfasiallc.com%2Fkubecon-cloudnativecon-open-source-summit-china%2F" textvalue="KubeCon + CloudNativeCon + Open Source Summit China" linktype="text" imgurl="" tab="outerlink" data-linktype="2">KubeCon + CloudNativeCon + Open Source Summit China</a> 在上海举行，vivo 在平台工程专题做了 2 个主题分享。同时，我们也积极支持并参与 KCD 等区域性 Meetup 活动。</p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100014269" data-ratio="1.0716981132075472" data-s="300,640" src="https://oscimg.oschina.net/oscnet/8a9a6912-227d-44eb-ac54-faf41d593727.jpg" data-type="jpeg" data-w="1060" style="" referrerpolicy="no-referrer"></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;">未来，vivo 将持续探索与实践云原生技术，在 CNCF 云原生基金会积极参与和贡献，并与各成员持续加强交流合作。</p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-wrap: wrap;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);text-align: right;visibility: visible;"><section style="padding: 10px;outline: 0px;display: inline-block;width: 677px;border-width: 1px;border-style: solid;border-color: transparent;background-color: rgb(239, 239, 239);height: auto;visibility: visible;"><section powered-by="xiumi.us" style="outline: 0px;font-size: 14px;text-align: justify;visibility: visible;"><ul class="list-paddingleft-1" style="width: 555.438px;"><li><p><strong style="font-size: 15px;letter-spacing: 0.544px;outline: 0px;visibility: visible;">生产实践方面：</strong><br></p><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;">将继续推进云原生技术在企业中的应用和发展，加强容器化和微服务能力，探索和实践最新的容器化和微服务技术，基于此实践积极向上游提供反馈，最终提高我们自身的业务交付效率和用户体验。</span></p></li></ul><p style="outline: 0px;visibility: visible;"><br></p><ul class="list-paddingleft-1" style="width: 555.438px;"><li><p style="outline: 0px;visibility: visible;"><strong><span style="font-size: 15px;">社区贡献方面：</span></strong></p><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;">以企业中应用云原生技术遇到的实际问题为推动力，加强与 CNCF 组织和其他企业的技术交流与合作，积极参与 CNCF 项目开发和相关工作组的贡献并传播云原生技术<span style="font-size: 15px;letter-spacing: 0.544px;">。</span></span><span style="font-size: 15px;letter-spacing: 0.544px;"></span></p></li></ul></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;text-wrap: wrap;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;visibility: visible;"><section style="padding-bottom: 3px;outline: 0px;display: inline-block;vertical-align: middle;border-bottom: 1px solid rgb(65, 95, 255);border-top-color: rgb(65, 95, 255);border-right-color: rgb(65, 95, 255);border-left-color: rgb(65, 95, 255);visibility: visible;"><section style="outline: 0px;border-bottom: 3px solid rgb(65, 95, 255);border-top-color: rgb(65, 95, 255);border-right-color: rgb(65, 95, 255);border-left-color: rgb(65, 95, 255);font-size: 16px;color: rgb(65, 95, 255);visibility: visible;"><p style="outline: 0px;visibility: visible;">关于 CNCF</p></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br style="outline: 0px;letter-spacing: 0.578px;visibility: visible;"></p><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);line-height: 1.5;visibility: visible;"><p style="outline: 0px;text-align: left;visibility: visible;"><img class="rich_pages wxw-img js_insertlocalimg" data-cropselx1="0" data-cropselx2="200" data-cropsely1="0" data-cropsely2="77" data-imgfileid="100014263" data-ratio="0.16574074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/55ece88a-d979-4dbb-941c-1ed46907bd24.jpg" data-type="png" data-w="1080" style="outline: 0px;visibility: visible !important;width: 465px;height: 77px;" referrerpolicy="no-referrer"></p></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;justify-content: flex-start;display: flex;flex-flow: row;visibility: visible;"><section style="padding-left: 8px;outline: 0px;display: inline-block;width: 578px;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;align-self: flex-start;flex: 0 0 auto;visibility: visible;"><section powered-by="xiumi.us" style="outline: 0px;color: rgba(0, 0, 0, 0.5);text-align: justify;visibility: visible;"><p style="outline: 0px;visibility: visible;">使命：让云原生无处不在</p></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br style="outline: 0px;visibility: visible;"></p><section powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);"><p style="outline: 0px;">CNCF 云原生计算基金会 (Cloud Native Computing Foundation, https://www.cncf.io/）成立于 2015 年 12 月，是非营利性 Linux 基金会（https://www.linuxfoundation.org/）的一部分，其使命是「让云原生技术无处不在」（参考 CNCF 章程 ）。</p><p style="outline: 0px;"><br style="outline: 0px;"></p><p style="outline: 0px;">CNCF 致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术，托管全球技术基础设施的关键组件。通过将最前沿的模式民主化，让这些创新为大众所用。CNCF 汇集了世界顶级的开发者、最终用户和供应商，并举办了最大的开源开发者大会。</p><p style="outline: 0px;"><br></p><p style="outline: 0px;"><span style="letter-spacing: 0.544px;text-align: center;">相关资料：</span></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p>Linux 基金会</p><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linuxfoundation.org%2F" textvalue="https://www.linuxfoundation.org/" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.linuxfoundation.org/</a></p></li><li><p>CNCF 云原生计算基金会</p><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io%2F" textvalue="https://www.cncf.io/" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.cncf.io/</a></p></li><li><p>CNCF 章程</p></li></ul><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcncf%2Ffoundation%2Fblob%2Fmain%2Fcharter.md" textvalue="https://github.com/cncf/foundation/blob/main/charter.md" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://github.com/cncf/foundation/blob/main/charter.md</a></p><p><br></p></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;"><section style="padding: 3px;outline: 0px;display: inline-block;border-bottom: 1px solid rgb(65, 95, 255);color: rgb(65, 95, 255);"><p style="outline: 0px;">关注我们</p></section></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;justify-content: flex-start;display: flex;flex-flow: row;"><section style="padding: 22px;outline: 0px;display: inline-block;width: 677px;vertical-align: top;align-self: flex-start;flex: 0 0 auto;background-color: rgb(247, 247, 247);"><section powered-by="xiumi.us" style="outline: 0px;text-align: justify;"><ul class="list-paddingleft-1" style="padding-left: 40px;outline: 0px;list-style-position: outside;"><li style="outline: 0px;"><p style="outline: 0px;">【移动 OSS】</p><p style="outline: 0px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopensource.vivo.com%2F" textvalue="https://opensource.vivo.com" linktype="text" imgurl="" tab="outerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">https://opensource.vivo.com</a></p></li><li style="outline: 0px;"><p style="outline: 0px;">【互联网 OSS】</p><p style="outline: 0px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvivo" textvalue="https://github.com/vivo&nbsp;" linktype="text" imgurl="" tab="outerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">https://github.com/vivo&nbsp;</a></p></li><li style="outline: 0px;"><p style="outline: 0px;">【<span style="outline: 0px;letter-spacing: 0.578px;">开源频道</span>】@vivo 互联网技术&nbsp;&nbsp;<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26action%3Dgetalbum%26album_id%3D2951473838086422533%23wechat_redirect" textvalue="#开源&nbsp;" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">#开源&nbsp;</a></p></li></ul></section></section></section><p><br></p><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互联网技术" data-alias="vivoVMIC" data-signature="分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 03:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10448921</guid>
            <link>https://my.oschina.net/vivotech/blog/10448921</link>
            <author>
                <![CDATA[vivo 互联网技术]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[飞致云开源社区月度动态报告（2023 年 12 月）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#000000; text-align:start"><span><span style="color:#000000">自 2023 年 6 月起，中国领先的开源软件公司 FIT2CLOUD 飞致云以月度为单位发布《飞致云开源社区月度动态报告》，旨在向广大社区用户同步飞致云旗下系列开源软件的发展情况，以及当月主要的产品新版本发布、社区运营成果等相关信息。</span></span></p><p style="color:#000000; text-align:start"><span><strong><span style="color:#00355d">飞致云开源大屏（2023 年 12 月）</span></strong></span></p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-ce20816fb99437841e5fd716dc8614c9a48.png" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:start"><span>▲图 1 飞致云开源大屏（2023.12.29 12:00）</span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">2023 年 12 月飞致云开源软件运营数据概览（统计时间为 2023.12.1～2023.12.29）</span></span></p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-7f1d375b645d195bf7e8b90007275b91588.png" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:center"><strong><span style="color:#3370ff">2023 年 12 月产品发布事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 开源建站工具</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 1 日，强大易用的开源建站工具 Halo 正式发布 2.11.0 版本。在这一版本中，Halo 新增个人中心功能，将所有和用户自身相关的功能移动到个人中心。同时，Halo 进行了 50 多项功能优化和问题修复。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ DataEase 开源数据可视化分析工具</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 11 日，DataEase 开源数据可视化分析平台正式发布 v2.1.0 版本。</p><p style="color:#000000; text-align:start">这一版本的功能升级包括：新增模板中心，用户可以通过模板中心的模板快速创建仪表板和数据大屏；新增「系统设置」功能模块，该模块包含系统参数、认证设置、嵌入式管理、平台对接四个子模块。在「系统参数」子模块中，用户可以对常用的系统设置项进行管理，「认证设置」子模块支持 CAS（中央认证服务）、LDAP（轻量级目录访问协议）、OIDC（开放 ID 连接）等常用认证协议的对接，在「嵌入式管理」子模块中用户可以创建嵌入式应用，通过嵌入式应用将 DataEase 嵌入到第三方平台中，「平台对接」子模块目前已支持飞书平台的接入，用户可以通过飞书扫码的方式快速登录到 DataEase 平台；数据准备方面，新版 DataEase 支持数据集和数据源的复制功能，方便用户快速创建类似的数据资源。</p><p style="color:#000000; text-align:start">此外，DataEase 开源项目组还对其他一些常用的功能进行了功能优化和问题修复。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 1Panel 开源面板</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 18 日，现代化、开源的 Linux 服务器运维管理面板 1Panel 正式发布 v1.9.0 版本。</p><p style="color:#000000; text-align:start">在这一版本中，1Panel 引入了新的工具箱管理功能，包含 Swap 分区管理、Fail2Ban 管理等功能。此外，1Panel 针对网站证书管理功能进行了全面重构，现在支持添加 ZeroSSL、BuyPass 和 Google Cloud 等 ACME 账户，还新增了 GoDaddy、Name.com、NameCheap、NameSilo 等 DNS 账户。在申请证书时，系统支持多种加密算法，能够创建自签名证书，并且提供证书的上传、下载功能，用户还可以批量删除证书，将证书推送至本地目录。容器配置页面也新增了与 IPv6 相关的配置选项。</p><p style="color:#000000; text-align:start">此外，1Panel 开源项目组还进行了 70 多项功能更新和问题修复。1Panel 应用商店新增了 10 款应用，并且更新了 20 款应用。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ JumpServer 开源堡垒机</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 25 日，JumpServer 开源堡垒机正式发布 v3.10 LTS（Long Term Support）版本。JumpServer 开源项目组将对 v3.10 LTS 版本提供长期支持，定期迭代发布小版本，持续进行问题修复更新并针对部分功能进行优化。欢迎广大用户升级使用 v3.10 LTS 版本。</p><p style="color:#000000; text-align:start">在这一版本中，JumpServer 重构了「标签」功能，支持全局标签管理，赋予了「标签」更为灵活、更为强大的功能。从 JumpServer v3.10.0 版本开始，「标签」不仅能绑定到资产上，还能够绑定到其他资源上，让其他资源通过「标签」功能拥有额外的功能属性。同时，JumpServer 新增 Chat AI 小助手功能，支持对接 ChatGPT，实现了多个用户可以在 JumpServer 浏览器功能界面直接与 ChatGPT 进行对话的能力，极大地提高了用户的使用率及工作效率。</p><p style="color:#000000; text-align:start">另外，「账号收集」功能支持将远程服务器中不存在的账户进行同步删除；「文件管理」功能支持批量传输文件，将批量命令和批量传输文件集中到工作台界面。这样一来，管理员可以让资产功能以更加方便的方式直接暴露给用户使用。</p><p style="color:#000000; text-align:start">X-Pack 增强包方面，JumpServer 支持第三方客户端直连 SQL Server 数据库，支持 Slack 平台的用户认证及消息通知功能。同时，新版本 JumpServer 还支持配置备案信息至登录页面，支持使用 Linux 系统作为远程应用发布机。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ MeterSphere 开源持续测试平台</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 28 日，MeterSphere 开源持续测试平台发布 v2.10.10 LTS 版本。</p><p style="color:#000000; text-align:start">在这一版本中，UI 测试方面，新增文件上传限制、添加关联文件时过滤已存在关联关系的文件；测试跟踪方面，在用例评审时支持左侧模块树功能、表头默认不显示所属模块字段、本地附件转存文件库时排除第三方存储库模块；接口测试方面，去除接口定义路径结尾的空格、接口自动化表头增加所属模块字段。此外，MeterSphere 项目组还进行了 8 项功能优化和 22 项漏洞修复工作。</p><p style="color:#000000; text-align:center"><strong><span style="color:#3370ff">其他重要事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 飞致云与上海吉谛达成战略合作，获得 Gitea 企业版中国大陆地区独家代理权</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 13 日，FIT2CLOUD 飞致云宣布与上海吉谛达成战略合作，FIT2CLOUD 飞致云获得上海吉谛旗下代码托管平台 Gitea 企业版中国大陆地区独家代理权。</p><p style="color:#000000; text-align:start">在 Gitea 社区版的基础之上，Gitea 企业版提供面向企业级应用场景的 X-Pack 增强包及企业级支持服务，有效助力企业快速构建并运营自托管的新一代代码托管平台。</p><p style="color:#000000; text-align:start">Gitea v1.21 版本的企业版软件已经于 2023 年 11 月正式发布，首批开放的 X-Pack 增强包功能包括：企业微信/钉钉/飞书对接集成、供应链安全扫描、数据安全备份、分布式部署架构和国产化信创适配等。</p><p style="color:#000000; text-align:start"><img alt="" height="608" src="https://oscimg.oschina.net/oscnet/up-d57c9939ebd603754752cc23d2f9e9aca95.jpg" width="1080" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:start"><span>▲ 图 2 飞致云与上海吉谛达成战略合作</span></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ FIT2CLOUD 飞致云荣膺「2023 年度 OSCHINA 优秀开源技术团队」奖项</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 8 日，知名开源技术社区 OSCHINA（开源中国）公布了「2023 年度 OSCHINA 优秀开源技术团队」入选名单。凭借在开源软件研发和开源社区运营方面的年度优异表现，FIT2CLOUD 飞致云再次收获「优秀开源技术团队」奖项。这也是继 2021 年和 2022 年之后，FIT2CLOUD 飞致云连续第三年荣膺该项荣誉。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ JumpServer 开源堡垒机 V2 社区版即将停止维护的通知</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 1 日，JumpServer 开源项目组发布重要通知。如《关于 JumpServer 开源堡垒机 V2 版本产品生命周期的相关说明》所示，JumpServer 开源堡垒机 V2 版本（社区版）将于 2023 年 12 月 31 日停止维护支持。</p><p style="color:#000000; text-align:start">出于产品自身迭代和用户需求升级的要求，2023 年 2 月 27 日，JumpServer 开源堡垒机正式发布 v3.0 版本，目前已更新至 v3.10 LTS 版本。JumpServer 开源项目组建议社区版和企业版用户更新至 JumpServe v3.x 版本，以使用更多的新增功能并获取更好的软件使用体验。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 推出 AI 助手插件</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 15 日，Halo AI 助手插件上线。AI 助手插件通过扩展编辑器功能，为 Halo 默认编辑器带来了丰富的 AI 辅助功能。用户可以通过选中文字或者使用/命令的方式快速呼出 AI 对话框。AI 助手插件目前使用 OpenAI 的接口来提供 AI 能力支持，用户可以自定义 OpenAI 接口地址，选择切换不同的模型或者在网络不通的情况下配置代理使用。用户访问 Halo 应用市场，即可下载体验 Halo AI 助手插件。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ DataEase 漏洞通知及修复方案（DE-2023.12.19）</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 19 日，DataEase 项目组发布了编号为「DE-2023.12.19」的漏洞通知及修复方案，请用户尽快将 DataEase 升级至 v1.18.11 及以后的版本。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 1.x 停止维护公告</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 21 日，Halo 开源项目组发布《Halo 1.x 停止维护公告》。为了集中资源和精力去持续改进和维护 Halo 的最新版本，Halo 1.x 版本将于 2023 年 12 月 31 日停止维护。Halo 开源项目组提供了详细的从 1.x 版本迁移到 2.x 版本的升级指南，您可以访问官方文档：《从 Halo 1.x 迁移》<span style="color:#172b4d">（</span>https://docs.halo.run/getting-started/migrate-from-1.x/<span style="color:#172b4d"><span>&nbsp;</span>）</span>来了解详情。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">关于飞致云开源大屏</span></strong></p><p style="color:#000000; text-align:start">飞致云开源大屏（https://bi.fit2cloud.com/link/6CgpMHrT）是 FIT2CLOUD 飞致云为展示其旗下开源软件的社区运营情况制作的数据仪表板。该大屏使用 DataEase 开源数据可视化分析平台制作，实时呈现飞致云开源社区近 30 日内的动态信息。</p><p style="color:#000000; text-align:start">广大社区用户可以通过该大屏了解飞致云旗下开源项目的 GitHub Star、Fork、Issue、贡献者等指标的数量信息，以及近 30 日内新增的 Star、Fork、下载、Issue、PR 数量等，同时该大屏还展示了飞致云旗下开源项目的 Issue 趋势、Commit 趋势、PR 趋势、Issue 生命周期等。</p><p style="color:#000000; text-align:start">除了展示所有项目的汇总信息外，该大屏还支持用户分类别查看 JumpServer、DataEase、MeterSphere、Halo、1Panel、CloudExplorer Lite 六个开源项目的独立运营数据。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4736111/blog/10469745</guid>
            <link>https://my.oschina.net/u/4736111/blog/10469745</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[关于编程模式的总结与思考]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;visibility: visible;" data-mpa-powered-by="yiban.io"><img class="rich_pages wxw-img __bg_gif" data-backh="96" data-backw="578" data-cropselx1="0" data-cropselx2="578" data-cropsely1="0" data-cropsely2="96" data-imgfileid="503041828" data-ratio="0.16666666666666666" src="https://oscimg.oschina.net/oscnet/7f3f91e3-bb2b-4b44-a874-fe03bc749ab0.gif" data-type="gif" data-w="636" style="outline: 0px;letter-spacing: 0.544px;font-size: var(--articleFontsize);border-radius: 8px;text-align: justify;width: 677px;visibility: visible !important;background-size: 16px !important;" referrerpolicy="no-referrer"><br style="outline: 0px;visibility: visible;"></section><section data-mpa-template="t" data-mpa-template-id="502" data-mpa-category="模板" style="outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);visibility: visible;"><section data-mpa-category="模板" data-mid="" style="padding-right: 1px;padding-left: 1px;outline: 0px;width: 677px;display: flex;justify-content: flex-start;align-items: center;flex-direction: column;visibility: visible;"><section data-mid="" style="outline: 0px;letter-spacing: 0.544px;width: 675px;display: grid;grid-template-columns: 26px auto;visibility: visible;"><section data-mid="" style="outline: 0px;width: 26px;height: 14px;display: flex;justify-content: center;align-items: center;align-self: center;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section><section data-mid="" style="padding-left: 7px;outline: 0px;display: flex;justify-content: flex-start;align-items: center;visibility: visible;"><section data-mid="" style="margin-right: 7px;outline: 0px;text-align: left;visibility: visible;"><p data-mid="" style="outline: 0px;width: 0px;font-size: 14px;font-family: PingFangSC-Semibold, &quot;PingFang SC&quot;;font-weight: bold;color: rgb(58, 92, 244);line-height: 20px;visibility: visible;"><br style="outline: 0px;visibility: visible;"></p></section><section data-mid="" style="margin-bottom: 4px;outline: 0px;width: 635px;height: 1px;border-top: 1px solid rgb(58, 92, 244);align-self: flex-end;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section></section></section><section data-mid="" style="padding: 7px 14px 9px 19px;outline: 0px;width: 675px;text-align: left;border-bottom: 1px solid rgb(58, 92, 244);visibility: visible;"><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;letter-spacing: 0.578px;text-align: justify;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;white-space-collapse: preserve;text-size-adjust: inherit;text-align: left;caret-color: rgb(23, 26, 29);letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;color: rgb(0, 0, 0);visibility: visible;font-size: 15px;">淘宝创新业务的<span style="font-size: 15px;letter-spacing: 1px;text-wrap: wrap;">优化迭代是非常高频且迅速的，</span><span style="font-size: 15px;letter-spacing: 1px;text-wrap: wrap;">在这过程中要求技术也必须是快且稳的，而为了适应这种快速变化的节奏，我们在项目开发过程中采用了一些面向拓展以及敏捷开发的设计，</span><span style="font-size: 15px;letter-spacing: 1px;text-wrap: wrap;">本文旨在总结并思考其中一些通用的编程模式。</span></span></p></section></section></section><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;line-height: 1.75em;"><br style="outline: 0px;visibility: visible;"></p><section style="margin-bottom: 0px;outline: 0px;box-sizing: inherit;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgba(25, 26, 31, 0.9);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 16px;text-align: center;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041829" data-ratio="0.3161764705882353" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b90357ce-619d-4abb-a361-96e0ffebccdd.png" data-type="png" data-w="408" style="outline: 0px;color: rgb(34, 34, 34);font-family: system-ui, -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;visibility: visible !important;width: 113px !important;" referrerpolicy="no-referrer"></span></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(34, 34, 34);text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;color: rgb(3, 69, 255);font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;visibility: visible;">前言</span></section><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">静心守护业务是淘宝今年 4 月份启动的创新项目，项目的核心逻辑是通过敲木鱼、冥想、盘手串等疗愈玩法为用户带来内心宁静的同时推动文物的保护与修复，进一步弘扬我们的传统文化。</span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">作为创新项目，业务形态与产品方案的优化迭代是非常高频且迅速的：项目从 4 月底投入开发到 7 月份最终外灰，整体方案经历过大的推倒重建，也经历过多轮小型重构优化，项目上线后也在做持续的迭代优化甚至改版升级。</span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section style="margin-bottom: 0px;outline: 0px;box-sizing: inherit;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgba(25, 26, 31, 0.9);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 16px;text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;font-size: 15px;letter-spacing: 1px;visibility: visible;"><img class="rich_pages wxw-img" data-imgfileid="503041833" data-ratio="0.3056872037914692" data-s="300,640" src="https://oscimg.oschina.net/oscnet/0f807f04-facf-4eba-bf80-54b3dc2b020a.png" data-type="png" data-w="422" style="outline: 0px;color: rgb(34, 34, 34);font-family: system-ui, -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;visibility: visible !important;width: 117px !important;" referrerpolicy="no-referrer"></span></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(34, 34, 34);text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;visibility: visible;color: rgb(0, 17, 255);">模式清单</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><span id="OSC_h4_1"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">基于 Spring 容器与反射的策略模式</span></strong></span></h4><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">策略模式是一种经典的行为设计模式，它的本质是定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换，后续也能根据需要灵活拓展出新的算法。这里推荐的是一种基于 Spring 容器和反射结合的策略模式，这种模式的核心思路是：每个策略模式的实现都是一个 bean，在 Spring 容器启动时基于反射获取每个策略场景的接口类型，并基于该接口类型再获取此类型的所有策略实现 bean 并记录到一个 map（key 为该策略 bean 的唯一标识符，value 为 bean 对象）中，后续可以自定义路由策略来从该 map 中获取 bean 对象并使用相应的策略。</span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h4_2"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">模式解构</span></h4></li></ul><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">模式具体实现方式大致如下面的 UML 类图所描述的：</span></p><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><img class="rich_pages wxw-img" data-backh="258" data-backw="578" data-imgfileid="503041831" data-ratio="0.4462962962962963" src="https://oscimg.oschina.net/oscnet/d8f41f29-554a-49b5-b29f-5130f4805640.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></section><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">其中涉及的各个组件及作用分别为：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>Handler</strong>（<em>interface</em>）：策略的顶层接口，定义的 type 方法表示策略唯一标识的获取方式。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>HandlerFactory</strong>（<em>abstract class</em>）：策略工厂的抽象实现，封装了反射获取 Spring bean 并维护策略与其标识映射的逻辑，但不感知策略的真实类型。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>AbstractHandler</strong>（<em>interface or abstracr class</em>）：各个具体场景下的策略接口定义，该接口定义了具体场景下策略所需要完成的行为。如果各个具体策略实现有可复用的逻辑，可以结合模版方法模式在该接口内定义模版方法，如果模板方法依赖外部 bean 注入，则该接口的类型需要为<em>abstract class</em>，否则为<em>interface</em>即可。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>HandlerImpl</strong>（<em>class</em>）：各个场景下策略接口的具体实现，承载主要的业务逻辑，也可以根据需要横向拓展。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>HandlerFactoryImpl</strong>（<em>class</em>）：策略工厂的具体实现，感知具体场景策略接口的类型，如果有定制的策略路由逻辑也可以在此实现。</span></p></li></ol><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(68, 68, 68);font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(68, 68, 68);font-size: 15px;letter-spacing: 1px;">这种模式的主要优点有：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(68, 68, 68);">策略标识维护自动化</span></strong><span style="color: rgb(68, 68, 68);">：策略实现与标识之间的映射关系完全委托给 Spring 容器进行维护（在</span><em><span style="color: rgb(68, 68, 68);">HandlerFactory</span></em><span style="color: rgb(68, 68, 68);">中封装，每个场景的策略工厂直接继承该类即可，无需重复实现），后续新增策略不用再手动修改关系映射。</span></span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(68, 68, 68);">场景维度维护标识映射</span></strong><span style="color: rgb(68, 68, 68);">：</span><em><span style="color: rgb(68, 68, 68);">HandlerFactory</span></em><span style="color: rgb(68, 68, 68);">中在扫描策略 bean 时是按照</span><em>AbstractHandler</em>的类型来分类维护的，从而避免了不同场景的同名策略发生冲突。</span></p></li><li><section style="margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(68, 68, 68);">策略接口按场景灵活定义</span></strong><span style="color: rgb(68, 68, 68);">：具体场景的策略行为定义在</span><em><span style="color: rgb(68, 68, 68);">AbstractHandler</span></em><span style="color: rgb(68, 68, 68);">中，在这里可以根据真实的业务需求灵活定义行为，甚至也可以结合其他设计模式做进一步抽象处理，在提供灵活拓展的同时减少重复代码。</span></span></section></li></ol><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_3"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">实践案例分析</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">该模式在静心守护项目中的许多功能模块都有使用，下面以称号解锁模块为例来介绍其实际应用。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">我们先简单了解下该模块的业务背景：静心守护的成就体系中有一类是称号，如下图。用户可以通过多种行为去解锁不同类型的称号，比如说通过参与主玩法（敲木鱼、冥想、盘手串），主玩法参与达到一定次数后即可解锁特定类型的称号。当然后续也可能会有其他种类的称号：比如签到类（按照用户签到天数解锁）、捐赠类（按照用户捐赠项目的行为解锁），所以对于称号的解锁操作应该是面向未来可持续拓展的。</span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: center;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041832" data-ratio="2" src="https://oscimg.oschina.net/oscnet/62c7ac5c-2a9c-4a65-b420-4efbd4b250fb.png" data-type="png" data-w="500" referrerpolicy="no-referrer"></span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">基于这样的思考，我选择使用上面的策略模式去实现称号解锁模块。该模块的核心类图组织如下：</span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><img class="rich_pages wxw-img" data-backh="259" data-backw="578" data-imgfileid="503041830" data-ratio="0.44722222222222224" src="https://oscimg.oschina.net/oscnet/5ead0c97-1223-42ec-90dc-be4c054fa964.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">下面是其中部分核心代码的分析解读：</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer">public interface Handler&lt;T&gt; {</span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * handler 类型</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    T type();</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><span style="color: rgb(68, 68, 68);">如上文所说，</span><em><span style="color: rgb(68, 68, 68);">Handler</span></em><span style="color: rgb(68, 68, 68);">是策略的顶层抽象，它只定义了</span><em><span style="color: rgb(68, 68, 68);">type</span></em><span style="color: rgb(68, 68, 68);">方法，该方法用于获取策略的标识，标识的类型支持子接口定义。</span></span></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 15px;color: rgb(68, 68, 68);"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">public abstract class HandlerFactory&lt;T, H extends Handler&lt;T&gt;&gt; implements InitializingBean, ApplicationContextAware {</span></code><code><span class="code-snippet_outer">    private Map&lt;T, H&gt; handlerMap;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    private ApplicationContext appContext;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 根据 type 获得对应的 handler</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param type</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public H getHandler(T type) {</span></code><code><span class="code-snippet_outer">        return handlerMap.get(type);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 根据 type 获得对应的 handler，支持返回默认</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param type</span></code><code><span class="code-snippet_outer">     * @param defaultHandler</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public H getHandlerOrDefault(T type, H defaultHandler) {</span></code><code><span class="code-snippet_outer">        return handlerMap.getOrDefault(type, defaultHandler);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 反射获取泛型参数 handler 类型</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @return handler 类型</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    @SuppressWarnings("unchecked")</span></code><code><span class="code-snippet_outer">    protected Class&lt;H&gt; getHandlerType() {</span></code><code><span class="code-snippet_outer">        Type type = ((ParameterizedType)getClass().getGenericSuperclass()).getActualTypeArguments()[1];</span></code><code><span class="code-snippet_outer">        //策略接口使用了范型参数</span></code><code><span class="code-snippet_outer">        if (type instanceof ParameterizedTypeImpl) {</span></code><code><span class="code-snippet_outer">            return (Class&lt;H&gt;) ((ParameterizedTypeImpl)type).getRawType();</span></code><code><span class="code-snippet_outer">        } else {</span></code><code><span class="code-snippet_outer">            return (Class&lt;H&gt;) type;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public void afterPropertiesSet() {</span></code><code><span class="code-snippet_outer">        // 获取所有 H 类型的 handlers</span></code><code><span class="code-snippet_outer">        Collection&lt;H&gt; handlers = appContext.getBeansOfType(getHandlerType()).values();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        handlerMap = Maps.newHashMapWithExpectedSize(handlers.size());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        for (final H handler : handlers) {</span></code><code><span class="code-snippet_outer">            log.info("HandlerFactory {}, {}", this.getClass().getCanonicalName(), handler.type());</span></code><code><span class="code-snippet_outer">            handlerMap.put(handler.type(), handler);</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">        log.info("handlerMap:{}", JSON.toJSONString(handlerMap));</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public void setApplicationContext(@Nonnull ApplicationContext applicationContext) throws BeansException {</span></code><code><span class="code-snippet_outer">        this.appContext = applicationContext;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><em>HandlerFactory</em>在前面也提到过，是策略工厂的抽象实现，封装了反射获取具体场景策略接口类型，并查找策略 bean 在内存中维护策略与其标识的映射关系，后续可以直接通过标识或者对应的策略实现。这里有二个细节：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">为什么 HandlerFactory 是<em>abstract class</em>？其实可以看到该类并没有任何抽象方法，直接将其定义为<em>class</em>也不会有什么问题。这里将其定义为<em>abstract class</em>主要是起到实例创建的约束作用，因为我们对该类的定义是工厂的抽象实现，只希望针对具体场景来创建实例，针对该工厂本身创建实例其实是没有任何实际意义的。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><em>getHandlerType</em>方法使用了<em>@SuppressWarnings</em>注解并标记了<em>unchecked</em>。这里也确实是存在潜在风险的，因为<em>Type</em>类型转<em>Class</em>类型属于向下类型转换，是存在风险的，可能其实际类型并非<em>Class</em>而是其他类型，那么此处强转就会出错。这里处理了两种最通用的情况：<em>AbstractHandler</em>是带范型的<em>class</em>和最普通的<em>class</em>。</span></p></li></ol><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(68, 68, 68);font-size: 15px;letter-spacing: 1px;"><br></span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class TitleUnlockHandlerFactory</span></code><code><span class="code-snippet_outer">        extends HandlerFactory&lt;String, BaseTitleUnlockHandler&lt;BaseTitleUnlockParams&gt;&gt; {}</span></code></pre></section><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: start;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><ne-text ne-italic="true" style="font-style: italic;"><span style="font-size: 15px;letter-spacing: 1px;">TitleUnlockHandlerFactory</span></ne-text><ne-text><span style="font-size: 15px;letter-spacing: 1px;">是策略工厂的具体实现，由于不需要在此定制策略的路由逻辑，所以只声明了相关的参数类型，而没有对父类的方法做什么覆盖。</span></ne-text><ne-text></ne-text><span style="display: inline;min-width: 1px;vertical-align: baseline;height: 1em;user-select: none;font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: start;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><ne-text><span style="font-size: 15px;letter-spacing: 1px;"><br></span></ne-text></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">public abstract class BaseTitleUnlockHandler&lt;T extends BaseTitleUnlockParams&gt; implements Handler&lt;String&gt; {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private UserTitleTairManager userTitleTairManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private AchievementCountManager achievementCountManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private UserUnreadAchievementTairManager userUnreadAchievementTairManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 解锁称号</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param params</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public @CheckForNull TitleUnlockResult unlockTitles(T params) {</span></code><code><span class="code-snippet_outer">        TitleUnlockResult titleUnlockResult = this.doUnlock(params);</span></code><code><span class="code-snippet_outer">        if (null == titleUnlockResult) {</span></code><code><span class="code-snippet_outer">            return null;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        List&lt;TitleAchievementVO&gt; titleAchievements = titleUnlockResult.getUnlockedTitles();</span></code><code><span class="code-snippet_outer">        if (CollectionUtils.isEmpty(titleAchievements)) {</span></code><code><span class="code-snippet_outer">            titleUnlockResult.setUnlockedTitles(new ArrayList&lt;&gt;());</span></code><code><span class="code-snippet_outer">            return titleUnlockResult;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //基于注入的 bean 和计算出的称号列表进行后置操作，如：更新成就计数、更新用户称号缓存、更新用户未读成就等</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        return titleUnlockResult;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 计算出要解锁的称号</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param param</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    protected abstract TitleUnlockResult doUnlock(T param);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public abstract String type();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: justify;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><ne-text></ne-text></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><em>BaseTitleUnlockHandler</em>定义了称号解锁行为，并且在此确定了策略标识的类型为<em>String</em>。此外，该类是一个<em>abstract class</em>，是因为该类定义了一个模版方法<em>unlockTitles</em>，在该方法里封装了称号解锁所要进行的一些公共操作，比如更新用户的称号计数、用户的称号缓存数据等，这些都依赖于注入的一些外部 bean，而<em>interface</em>不支持非静态成员变量，所以该类通过<em>abstract class</em>来定义。具体的称号解锁行为通过<em>doUnlock</em>定义，这也是该策略的具体实现类需要实现的方法。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">另外也许你还注意到了<em>doUnlock</em>方法的行参是一个范型参数<em>T</em>，因为我们考虑到了不同类型称号解锁所需要的参数可能是不同的，因此在场景抽象接口侧只依赖于称号解锁的公共参数类型，而在策略接口具体实现侧才与该类型策略的具体参数类型进行耦合。</span></section><section style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: start;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><ne-text><span style="font-size: 15px;letter-spacing: 1px;"><br></span></ne-text></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class GameplayTitleUnlockHandler extends BaseTitleUnlockHandler&lt;GameplayTitleUnlockParams&gt; {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private BlessTitleAchievementDiamondConfig blessTitleAchievementDiamondConfig;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private UserTitleTairManager userTitleTairManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected TitleUnlockResult doUnlock(GameplayTitleUnlockParams params) {</span></code><code><span class="code-snippet_outer">        //获取称号元数据</span></code><code><span class="code-snippet_outer">        List&lt;TitleMetadata&gt; titleMetadata = blessTitleAchievementDiamondConfig.getTitleMetadata();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        if (CollectionUtils.isEmpty(titleMetadata)) {</span></code><code><span class="code-snippet_outer">            return null;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        List&lt;TitleAchievementVO&gt; titleAchievements = new ArrayList&lt;&gt;();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        Result&lt;DataEntry&gt; result = userTitleTairManager.queryRawCache(params.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //用户称号数据查询异常</span></code><code><span class="code-snippet_outer">        if (null == result || !result.isSuccess()) {</span></code><code><span class="code-snippet_outer">            return null;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        if (Objects.equals(result.getRc(), ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer">            //解锁新称号</span></code><code><span class="code-snippet_outer">            titleAchievements = unlockNewTitles(params, titleMetadata);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } else if (Objects.equals(result.getRc(), ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer">            //初始化历史称号</span></code><code><span class="code-snippet_outer">            titleAchievements = initHistoricalTitles(params, titleMetadata);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        TitleUnlockResult titleUnlockResult = new TitleUnlockResult();</span></code><code><span class="code-snippet_outer">        titleUnlockResult.setUserTitleCache(result);</span></code><code><span class="code-snippet_outer">        titleUnlockResult.setUnlockedTitles(titleAchievements);</span></code><code><span class="code-snippet_outer">        return titleUnlockResult;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public String type() {</span></code><code><span class="code-snippet_outer">        return TitleType.GAMEPLAY;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ......</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">上面是一个策略的具体实现类的大致示例，可以看到该实现类核心明确了以下信息：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">策略标识：给出了 type 方法的具体实现，返回了一个策略标识的常量</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">策略处理逻辑：此处是玩法类称号解锁的业务逻辑，读者无需关注其细节</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">称号解锁行参：给出了玩法类称号解锁所需的真实参数类型</span></p></li></ol><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><ne-text><br></ne-text></p><span id="OSC_h4_4"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">抽象疲劳度管控体系</span></strong></span></h4><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">在我们的业务需求中经常会遇到涉及疲劳度管控相关的逻辑，比如每日签到允许用户每天完成 1 次、首页项目进展弹窗要求对所有用户只弹 1 次、首页限时回访任务入口则要对用户每天都展示一次，但用户累计完成 3 次后便不再展示......因此我们设计了一套疲劳度管控的模式，以降低后续诸如上述涉及疲劳度管控相关需求的开发成本。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_5"></span><h3 style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">自顶向下的视角</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">这套疲劳度管控体系的类层次大致如下图：</span></section><section style="min-height: 24px;margin-bottom: 8px;"><img class="rich_pages wxw-img" data-backh="360" data-backw="578" data-imgfileid="503041836" data-ratio="0.6222222222222222" src="https://oscimg.oschina.net/oscnet/f99ffd82-3d9e-4965-aa11-20ecbf3845eb.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" width="4011" referrerpolicy="no-referrer"></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">接下来我们自顶向下逐层进行介绍：</span></section><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">FatigueLimiter（<em>interface</em>）：<em>FatigueLimiter</em>是最顶层抽象的疲劳度管控接口，<span style="text-decoration: underline;">它定义了疲劳度管控相关的行为</span>，比如：疲劳度的查询、疲劳度清空、疲劳度增加、是否达到疲劳度限制的判断等。</span></section></li><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">BaseFatigueLdbLimiter（<em>abstract class</em>）：疲劳度数据的存储方案可以是多种多样的，在我们项目中主要利用 ldb 进行疲劳度存储，而<em>BaseFatigueLdbLimiter</em>正是基于 ldb【注：阿里内部自研的一款持久化 k-v 数据库，读者可将其理解为类似 level db 的项目】对疲劳度数据进行管控的抽象实现，它封装了 ldb 相关的操作，并基于 ldb 的数据操作实现了<em>FatigueLimiter</em>的疲劳度管控方法。但它并不感知具体业务的身份和逻辑，因此定义了几个业务相关的方法交给下层去实现，分别是：</span></section></li><ul ne-level="1" class="list-paddingleft-1" style="padding-left: 23px;list-style-position: initial;list-style-image: initial;"><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">scene：标识具体业务的场景，会利用该方法返回值去构造 Ldb 存储的 key</span></section></li><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">buildCustomKey：对 Ldb 存储 key 的定制逻辑</span></section></li><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">getExpireSeconds：对应着 Ldb 存储 kv 失效时间，对应着疲劳度的管控周期</span></section></li></ul><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">Ldb 周期性疲劳度管控的解决方案层（<em>abstract class</em>）：在这一层提供了多种周期的开箱即用的疲劳度管控实现类，如<em>BaseFatigueDailyLimiter</em>提供的是天级别的疲劳度管控能力，<em>BaseFatigueNoCycleLimiter</em>则表示疲劳度永不过期，而<em>BaseFatigueCycleLimiter</em>则支持用户实现 cycle 方法定制疲劳度周期。</span></section></li><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">业务场景层：这一层则是各个业务场景对疲劳度管控的具体实现，实现类只需要实现 scene 方法来声明业务场景的身份标识，随后继承对应的解决方案，即可实现快速的疲劳度管控。比如上面的 DailyWishSign<em>Limiter</em>就对应着本篇开头我们所说的「每日签到允许用户每天完成 1 次」，这就要求为用户的签到行为以天维度构建 key 同时失效时间也为 1 天，因此直接继承解决方案层的<em>BaseFatigueDailyLimiter</em>即可。其代码实现非常简单，如下：</span></section></li></ol><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class DailyWishSignLimiter extends BaseFatigueLdbDailyLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected String scene() {</span></code><code><span class="code-snippet_outer">        return LimiterScene.dailyWish;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_6"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">有一个「异类」</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">也许你注意到了上面的类层次图中有一个「异类」——HomeEnterGuideLimiter。它其实就是我们在上文说的「首页限时回访任务入口则要对用户每天都展示一次，但用户累计完成 3 次后便不再展示」，它的逻辑其实也很简单：因为它有 2 条管控条件，所以需要继承 2 个管控周期的解决方案——天维度和永久维度，最后实际使用的类再聚合了天维度和永久维度的实现类（每个实现类对应 ldb 的一类 key）并实现了顶层的疲劳度管控接口，标识这也是一个疲劳度管理器。它们的代码如下：</span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 首页入口引导限时任务-天级疲劳度管控</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class HomeEnterGuideDailyLimiter extends BaseFatigueLdbDailyLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected String scene() {</span></code><code><span class="code-snippet_outer">        return LimiterScene.homeEnterGuide;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 首页入口引导限时任务-总次数疲劳度管控</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class HomeEnterGuideNoCycleLimiter extends BaseFatigueLdbNoCycleLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected String scene() {</span></code><code><span class="code-snippet_outer">        return LimiterScene.homeEnterGuide;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected int maxSize() {</span></code><code><span class="code-snippet_outer">        return 3;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 首页入口引导限时任务-疲劳度服务</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class HomeEnterGuideLimiter implements FatigueLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private FatigueLimiter homeEnterGuideDailyLimiter;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private FatigueLimiter homeEnterGuideNoCycleLimiter;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public boolean isLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        return homeEnterGuideNoCycleLimiter.isLimit(customKey) || homeEnterGuideDailyLimiter.isLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public Integer incrLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        homeEnterGuideDailyLimiter.incrLimit(customKey);</span></code><code><span class="code-snippet_outer">        return homeEnterGuideNoCycleLimiter.incrLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public boolean isLimit(Integer fatigue) {</span></code><code><span class="code-snippet_outer">        throw new UnsupportedOperationException();</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public Map&lt;String, Integer&gt; batchQueryLimit(List&lt;String&gt; keys) {</span></code><code><span class="code-snippet_outer">        throw new UnsupportedOperationException();</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public void removeLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        homeEnterGuideDailyLimiter.removeLimit(customKey);</span></code><code><span class="code-snippet_outer">        homeEnterGuideNoCycleLimiter.removeLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public Integer queryLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        throw new UnsupportedOperationException();</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 查询首页限时任务的每日疲劳度</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param customKey 用户自定义 key</span></code><code><span class="code-snippet_outer">     * @return 疲劳度计数</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public Integer queryDailyLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        return homeEnterGuideDailyLimiter.queryLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 查询首页限时任务的全周期疲劳度</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param customKey 用户自定义 key</span></code><code><span class="code-snippet_outer">     * @return 疲劳度计数</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public Integer queryNoCycleLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        return homeEnterGuideNoCycleLimiter.queryLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><span id="OSC_h4_7"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">函数式行为参数化</span></strong></span></h4><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"></h4><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">Java 21 在今年 9 月份发布了，而距离 Java 8 发布已经过去 9 年多了，但也许，我是说也许......我们有些同学对 Java 8 还是不太熟悉......</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_8"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">再谈行为参数化</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">最早听到「行为参数化」这个词是在经典的 Java 技术书籍《Java 8 实战》中。在此书中，作者以一个筛选苹果的案例，基于行为参数化的思维一步步优化重构代码，在提升代码抽象能力的同时，保证了代码的简洁性和可读性，而其中的秘密武器就是 Java 8 所引入的 Lambda 表达式和函数式接口。Java 8 发布已经 9 年，对于 Lambda 表达式，大多数同学都已经耳熟能详，但函数式接口也许有同学不知道代表着什么。简单来说，如果一个接口，它只有一个没有被实现的方法，那它就是函数式接口。java.lang.function 包下定义 JDK 提供的一系列函数式接口。如果一个接口是函数式接口，推荐用@FunctionalInterface 注解来显式标明。那函数式接口有什么用呢？如果一个方法的行参里有函数式接口，那么函数式接口对应的参数可以支持传递 Lambda 表达式或者方法引用。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">那何为「行为参数化」？直观地来说就是将行为作为方法/函数的参数来进行传递。在 Java 8 之前，这可以通过匿名类实现，而在 Java 8 以后，可以基于函数式特性来实现行为参数化，即方法参数定义为函数式接口，在具体传参时使用 Lambda 表达式/方法。相比匿名类，后者在简洁性上有极大的提升。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">在我们的日常开发中，如果我们看到两个方法的结构十分相似，只有其中部分行为存在差别，那么就可以考虑采用函数式的行为参数化来重构优化这段代码，将其中存在差异的行为抽象成参数，从而减少重复代码。</span></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_9"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">从实践中来，到代码中去</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">下面给出一个例子。在静心守护项目中，我们基于 ldb 维护了用户未读成就的列表，在用户进入到个人成就页时，会查询未读成就数据，并对未读的成就在成就列表进行置顶以及加红点展示。下面是对用户未读成就列表进行新增和清除的两个方法：</span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 清除未读成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid             用户 ID</span></code><code><span class="code-snippet_outer"> * @param achievementType 需要清除未读成就列表的成就类型</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean clearUnreadAchievements(long uid, Set&lt;String&gt; achievementTypes) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (CollectionUtils.isEmpty(achievementTypes)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    Result&lt;DataEntry&gt; ldbRes = super.rawGet(buildKey(uid), false);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //用户称号数据查询失败</span></code><code><span class="code-snippet_outer">    if (Objects.isNull(ldbRes)) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">        return false;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    boolean success = false;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ResultCode resultCode = ldbRes.getRc();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //不存在用户称号数据则进行初始化</span></code><code><span class="code-snippet_outer">    if (Objects.equals(resultCode, ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer">    UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">        achievementTypes.forEach(type -&gt; clearCertainTypeIds(userUnreadAchievementsCache, type));</span></code><code><span class="code-snippet_outer">        success = putCache(uid, userUnreadAchievementsCache, DEFAULT_VERSION);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    } else if (Objects.equals(resultCode, ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        DataEntry ldbEntry = ldbRes.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //存在新数据则对其进行更新</span></code><code><span class="code-snippet_outer">        if (Objects.nonNull(ldbEntry)) {</span></code><code><span class="code-snippet_outer">            Object data = ldbEntry.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            if (data instanceof String) {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = JSON.parseObject(String.valueOf(data), UserUnreadAchievementsCache.class);</span></code><code><span class="code-snippet_outer">                achievementTypes.forEach(type -&gt; clearCertainTypeIds(userUnreadAchievementsCache, type))</span></code><code><span class="code-snippet_outer">                success = putCache(uid, userUnreadAchievementsCache, ldbEntry.getVersion());</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    //缓存解锁的称号失败</span></code><code><span class="code-snippet_outer">    if (!success) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    return success;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 写入新的未读成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid                  用户 ID</span></code><code><span class="code-snippet_outer"> * @param achievementTypeIdMap 需要新增的成就类型和成就 ID 列表的映射</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean writeUnreadAchievements(long uid, Map&lt;String, List&lt;String&gt;&gt; achievementTypeIdMap) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (MapUtils.isEmpty(achievementTypeIdMap)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    Result&lt;DataEntry&gt; ldbRes = super.rawGet(buildKey(uid), false);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //用户称号数据查询失败</span></code><code><span class="code-snippet_outer">    if (Objects.isNull(ldbRes)) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">        return false;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    boolean success = false;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ResultCode resultCode = ldbRes.getRc();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //不存在用户称号数据则进行初始化</span></code><code><span class="code-snippet_outer">    if (Objects.equals(resultCode, ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer">    UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">        achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(userUnreadAchievementsCache, key, value));</span></code><code><span class="code-snippet_outer">        success = putCache(uid, userUnreadAchievementsCache, DEFAULT_VERSION);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    } else if (Objects.equals(resultCode, ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        DataEntry ldbEntry = ldbRes.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //存在新数据则对其进行更新</span></code><code><span class="code-snippet_outer">        if (Objects.nonNull(ldbEntry)) {</span></code><code><span class="code-snippet_outer">            Object data = ldbEntry.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            if (data instanceof String) {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = JSON.parseObject(String.valueOf(data), UserUnreadAchievementsCache.class);</span></code><code><span class="code-snippet_outer">                achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(oldCache, key, value));</span></code><code><span class="code-snippet_outer">                success = putCache(uid, userUnreadAchievementsCache, ldbEntry.getVersion());</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    //缓存解锁的称号失败</span></code><code><span class="code-snippet_outer">    if (!success) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    return success;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">从结构上看，上面两段代码其实是非常类似的：整个结构都是先判空，然后查询历史的未读成就数据，如果数据未初始化，则进行初始化，如果已经初始化，则对数据进行更新。只不过写入/清除对数据的初始化和更新逻辑并不相同。因此可以将数据初始化和更新抽象为行为参数，将剩余部分提取为公共方法，基于这样的思路重构后的代码如下：</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 创建 or 更新缓存</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid               用户 ID</span></code><code><span class="code-snippet_outer"> * @param initCacheSupplier 缓存初始化策略</span></code><code><span class="code-snippet_outer"> * @param updater           缓存更新策略</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">private boolean upsertCache(long uid, Supplier&lt;UserUnreadAchievementsCache&gt; initCacheSupplier,</span></code><code><span class="code-snippet_outer">                            Function&lt;UserUnreadAchievementsCache, UserUnreadAchievementsCache&gt; updater) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    Result&lt;DataEntry&gt; ldbRes = super.rawGet(buildKey(uid), false);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //用户称号数据查询失败</span></code><code><span class="code-snippet_outer">    if (Objects.isNull(ldbRes)) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">        return false;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    boolean success = false;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ResultCode resultCode = ldbRes.getRc();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //不存在用户称号数据则进行初始化</span></code><code><span class="code-snippet_outer">    if (Objects.equals(resultCode, ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        UserUnreadAchievementsCache userUnreadAchievementsCache = initCacheSupplier.get();</span></code><code><span class="code-snippet_outer">        success = putCache(uid, userUnreadAchievementsCache, DEFAULT_VERSION);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    } else if (Objects.equals(resultCode, ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        DataEntry ldbEntry = ldbRes.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //存在新数据则对其进行更新</span></code><code><span class="code-snippet_outer">        if (Objects.nonNull(ldbEntry)) {</span></code><code><span class="code-snippet_outer">            Object data = ldbEntry.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            if (data instanceof String) {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = JSON.parseObject(String.valueOf(data), UserUnreadAchievementsCache.class);</span></code><code><span class="code-snippet_outer">                userUnreadAchievementsCache = updater.apply(userUnreadAchievementsCache);</span></code><code><span class="code-snippet_outer">                success = putCache(uid, userUnreadAchievementsCache, ldbEntry.getVersion());</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    //缓存解锁的称号失败</span></code><code><span class="code-snippet_outer">    if (!success) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    return success;</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 写入新的未读成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid                  用户 ID</span></code><code><span class="code-snippet_outer"> * @param achievementTypeIdMap 需要新增的成就类型和成就 ID 列表的映射</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean writeUnreadAchievements(long uid, Map&lt;String, List&lt;String&gt;&gt; achievementTypeIdMap) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (MapUtils.isEmpty(achievementTypeIdMap)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    return upsertCache(uid,</span></code><code><span class="code-snippet_outer">            () -&gt; {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">                achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(userUnreadAchievementsCache, key, value));</span></code><code><span class="code-snippet_outer">                return userUnreadAchievementsCache;</span></code><code><span class="code-snippet_outer">            },</span></code><code><span class="code-snippet_outer">            oldCache -&gt; {</span></code><code><span class="code-snippet_outer">                achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(oldCache, key, value));</span></code><code><span class="code-snippet_outer">                return oldCache;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">    );</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 清除未读成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid             用户 ID</span></code><code><span class="code-snippet_outer"> * @param achievementType 需要清除未读成就列表的成就类型</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean clearUnreadAchievements(long uid, Set&lt;String&gt; achievementTypes) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (CollectionUtils.isEmpty(achievementTypes)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    return upsertCache(uid,</span></code><code><span class="code-snippet_outer">            () -&gt; {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">                achievementTypes.forEach(type -&gt; clearCertainTypeIds(userUnreadAchievementsCache, type));</span></code><code><span class="code-snippet_outer">                return userUnreadAchievementsCache;</span></code><code><span class="code-snippet_outer">            },</span></code><code><span class="code-snippet_outer">            oldCache -&gt; {</span></code><code><span class="code-snippet_outer">                achievementTypes.forEach(type -&gt; clearCertainTypeIds(oldCache, type));</span></code><code><span class="code-snippet_outer">                return oldCache;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">    );</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">重构的核心是提取了 upsert 方法，该方法将缓存数据的初始化和更新策略以函数式接口进行定义，从而支持从调用侧进行透传，避免了模板方法的重复编写。这是一个抛砖引玉的例子，在日常开发中，我们可以更多地尝试用函数式编程的思维去思考和重构代码，也许会发现另一个神奇的编程世界。</span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><span id="OSC_h4_10"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">切面编程的一些实践</span></strong></span></h4><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">AOP 想必大家都已经十分熟悉了，在此便不再赘述其基本概念，而是开门见山直接分享一些 AOP 在静心守护项目中的实际应用。</span></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_11"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">服务层异常统一收口</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">静心守护项目采用了在阿里系统中常用的 service-manager-dao 的分层模式，其中 service 层是距离终端最近的一层。为了防止下层预期外的异常抛到终端，我们需要在 service 层对异常进行统一拦截并且记录，同时最好将相关的错误码、请求参数以及 traceId 都一并记下，便于问题排查。这个场景就非常适合使用 AOP。在引入 AOP 之前，我们需要对每个 service 中面向终端的方法都进行异常拦截和监控日志打印的操作。比方说下面这个类，它有 3 个面向终端 mtop【注：阿里内部自研的 API 网关平台】服务的方法（api 具体参数和名称做了模糊化处理），这 3 个方法都采用了同样的 try-catch 结构来进行异常捕捉和监控日志打印，其中存在大量的重复代码，而更糟糕的事，如果后续增加新的方法，这样的重复代码还会不断增加。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">@HSFProvider(serviceInterface = MtopBlessHomeService.class)</span></code><code><span class="code-snippet_outer">public class MtopBlessHomeServiceImpl implements MtopBlessHomeService {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //依赖的 bean 注入</span></code><code><span class="code-snippet_outer">  ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceAVO&gt; entranceA(EntranceARequest request) {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(request.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            //该入口下的业务逻辑</span></code><code><span class="code-snippet_outer">            ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceA", buildMethodParamsStr(request), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceA", buildMethodParamsStr(request), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceBVO&gt; entranceB(EntranceBRequest request) {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(request.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            //该入口下的业务逻辑</span></code><code><span class="code-snippet_outer">            ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceB", buildMethodParamsStr(request), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceB", buildMethodParamsStr(request), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceCVO&gt; entranceC(EntranceCRequest request) {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(query.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            //该入口下的业务逻辑</span></code><code><span class="code-snippet_outer">            ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceC", buildMethodParamsStr(request), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceC", buildMethodParamsStr(request), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }    </span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">看到这样重复的代码结构而只是局部行为的不同，也许我们可以考虑着用上一节的函数式行为参数化进行重构：将重复的代码结构抽取为公共的工具方法，将对 manager 层的调用抽象为行为参数。但在上述场景下，这种做法还是存在一些弊端：</span><ne-clipboard source="https%3A%2F%2Faliyuque.antfin.com%2Flingye.jly%2Fwozrkc%2Fitpnoh733usxcgzk%3FsingleDoc%23r1wtn"></ne-clipboard></section><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">每个服务的方法还是需要显式调用工具类方法</span></p></li><li><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">为了保证监控信息的齐全，还需要在参数里手动透传一些监控相关的信息</span></p></li></ol><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">而 AOP 则不存在这些问题：AOP 基于动态代理实现，在实现上述逻辑时对服务层的代码编写完全透明。此外，AOP 还封装了调用端方法的各种元信息，可以轻松实现各种监控信息的自动化打印。下面是我们提供的 AOP 切面。其中值得注意的点是切点的选择要尽量准确，避免增强了不必要的方法。下面我们选择的切点是 mtop 包下所有 Impl 结尾类的 public 方法。</span></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer">@Aspect</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">public class MtopServiceAspect {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * MtopService 层服务</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    @Pointcut("execution(public com.taobao.mtop.common.MtopResult com.taobao.gaia.veyron.bless.service.mtop.*Impl.*(..))")</span></code><code><span class="code-snippet_outer">    public void mtopService(){}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 对 mtop 服务进行增强</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param pjp 接入点</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     * @throws Throwable</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    @Around("com.taobao.gaia.veyron.bless.aspect.MtopServiceAspect.mtopService()")</span></code><code><span class="code-snippet_outer">    public Object enhanceService(ProceedingJoinPoint pjp) throws Throwable {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(pjp);</span></code><code><span class="code-snippet_outer">            return pjp.proceed();</span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    AspectUtils.extractMethodName(pjp), buildMethodParamsStr(pjp), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    AspectUtils.extractMethodName(pjp), buildMethodParamsStr(pjp), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">存在这样一个切面后，service 层的代码就可以变得非常简洁：只需要纯粹专注于业务逻辑。同样以刚才的 MtopBlessHomeServiceImpl 类为例，在 AOP 改写后的代码里可以去除掉原先异常收口和监控相关的内容，而仅保留业务逻辑部分，代码简洁性大大提升。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">@HSFProvider(serviceInterface = MtopBlessHomeService.class)</span></code><code><span class="code-snippet_outer">public class MtopBlessHomeServiceImpl implements MtopBlessHomeService {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //依赖的 bean 注入</span></code><code><span class="code-snippet_outer">  ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceAVO&gt; entranceA(EntranceARequest request) {</span></code><code><span class="code-snippet_outer">        //业务逻辑</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceBVO&gt; entranceB(EntranceBRequest request) {</span></code><code><span class="code-snippet_outer">        //业务逻辑</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceCVO&gt; entranceC(EntranceCRequest request) {</span></code><code><span class="code-snippet_outer">        //业务逻辑</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_12"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">切点选择的策略</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">除了服务层以外，我们还想对数据访问层进行监控，监控项目中各种数据存储工具的 RT 以及成功率相关指标，并且监控粒度要尽可能地贴近业务维度（整体的数据访问监控直接通过 eagleeye 查看即可），便于具体问题的定位排查。这种面向层级别的逻辑定制，我们很自然而然地想到了 AOP，这也正是它可以大显身手的场景。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">这节核心想要分享的则是切点的选择。静心守护项目的数据存储主要依赖于 Tair【注：阿里内部自研的高性能 K-V 存储系统。根据存储介质和使用场景不同又分为 LDB、MDB、RDB】、Lindorm【注：阿里内部自研的大规模云原生多模数据库服务】和 Mysql，这三种存储工具在代码中的使用各不相同，导致切点的选择策略也大相径庭。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><span id="OSC_h4_13"></span><h4 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">目标对象规律分布</span></h4><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">如果我们要选择增强的对象在项目中分布的非常规律，那么我们往往可以直接利用 Spring AOP 的 PointCut 语法来选择切点。以静心守护项目中的 Mysql 数据访问对象为例：我们使用的 ORM 框架是 mybatis，并且主要的用法是注解模式，所有的 SQL 逻辑都放在一个 DAO 包下，每个业务场景定义一个 DAO 结尾的 Mapper 接口，接口下的每个方法都对应着一种数据访问的方式。因此在切点选择时，我们可以直接选择 DAO 包下以 DAO 结尾的类，并选择其中 public 方法即可准确织入所有满足条件的切点。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Pointcut("execution(public * com.taobao.gaia.serverless.veyron.bless.dao.*DAO.*(..))")</span></code><code><span class="code-snippet_outer">public void charityProjectDataAccess() {</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">这样实现的监控粒度是具体到每个 DAO 对象-方法级别的粒度，监控效果如下：</span></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: center;margin-bottom: 8px;"><img class="rich_pages wxw-img" data-backh="240" data-backw="578" data-imgfileid="503041786" data-ratio="0.41574074074074074" src="https://oscimg.oschina.net/oscnet/353e7a8a-57f3-48a6-938b-7033c6681775.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><span id="OSC_h4_14"></span><h4 style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">一个失效案例</span></h4><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">静心守护项目中对 tair 的使用方式是：通过一个抽象类对 tair 的各种基础操作进行封装（包括参数校验、响应判空、异常处理等），但将具体 tair 实例相关的参数设置行为抽象化，由实现类决定。各个业务场景的 tair 管理类最终会基于抽象类封装的基础操作来对 tair 进行数据访问</span><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">。</span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><br></span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">如下图，AbstractLdbManager 是封装</span></section><section style="min-height: 24px;text-align: center;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041787" data-ratio="0.8398148148148148" src="https://oscimg.oschina.net/oscnet/7d5fa225-7c35-4cf3-97cd-8a6d1de235a5.png" data-type="png" data-w="1080" referrerpolicy="no-referrer"></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">由于各个业务场景的 tair 管理实现类分散在各个业务包下，想要对它们进行统一切入比较困难。因此我们选择对抽象类进行切入。但这样就会遇到一个同类调用导致 AOP 失效的问题：抽象类本身不会有实例对象，因此基于 CGLIB 创建代理对象后，代理对象本质上调用的还是各个业务场景 tair 管理类的对象，而在使用这些对象时，我们不会直接调用 tair 抽象类封装的数据访问方法，而是调用这些业务 tair 管理对象进一步封装的带业务语义的方法，基于这些方法再去调用 tair 抽象类的数据访问方法。这种同类方法间接调用最终就导致了抽象类的方法没有如期被增强。文字描述兴许有些绕，可以参考下面的图：</span></p><p style="min-height: 24px;text-align: center;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041815" data-ratio="0.5935185185185186" src="https://oscimg.oschina.net/oscnet/a7f4daeb-a6c6-430b-9ace-50ffd3b87165.png" data-type="png" data-w="1080" style="letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" width="536" referrerpolicy="no-referrer"></span></p><section style="min-height: 24px;text-align: justify;margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">我们选择的解决方法则是从上面的 MultiClusterTairManager 入手，这个类是 tair 为我们提供的 TairManger 的一种默认实现，我们之前的做法是为该类实例化一个 bean，然后提供给所有业务 Tair 管理类使用，也就是说所有业务 Tair 管理类使用的 TairManager 都是同一个 bean 实例（因为业务流量没那么大，一个 tair 实例暂时绰绰有余）。那么我们可以自己提供一个 TairManager 的实现，基于继承+组合 MultiClusterTairManager 的方式，只对我们项目内用到数据访问操作进行重写，并委托给原先的 MultiClusterTairManager bean 进行处理。这样我们可以在设置 AOP 切点时选择对自己实现的 TairManager 的所有方法做增强，进而避开上面的问题。经过这样改写后，上面的两张图会演变成下面这样：</span></p><section style="min-height: 24px;text-align: center;margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><img class="rich_pages wxw-img" data-imgfileid="503041811" data-ratio="0.5935185185185186" src="https://oscimg.oschina.net/oscnet/a7f4daeb-a6c6-430b-9ace-50ffd3b87165.png" data-type="png" data-w="1080" width="536" referrerpolicy="no-referrer"></section><p style="min-height: 24px;text-align: justify;margin-bottom: 8px;line-height: 1.75em;margin-top: 8px;"><span style="letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041816" data-ratio="0.37407407407407406" src="https://oscimg.oschina.net/oscnet/dcaa95ab-35fe-49ef-8fb6-087473b0f061.png" data-type="png" data-w="1080" referrerpolicy="no-referrer"></span><br></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><span id="OSC_h4_15"></span><h4 style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">基于注解切入</span></h4><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">还有一种场景是我们要增强的方法分布毫无规律，可能都在同一个类中，但方法的名称毫无规律，也无法简单通过 private 或者 public 来区别。针对这样的场景，我们的做法是自定义注解，专门用于标识需要做增强的方法。比如静心守护项目中 lindorm 相关的数据操作就是这样。我们定义注解：</span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="css"><code><span class="code-snippet_outer">@<span class="code-snippet__keyword">Target</span>({<span class="code-snippet__selector-tag">ElementType</span><span class="code-snippet__selector-class">.METHOD</span>})</span></code><code><span class="code-snippet_outer">@<span class="code-snippet__keyword">Retention</span>(<span class="code-snippet__keyword">RetentionPolicy</span>.<span class="code-snippet__keyword">RUNTIME</span>)</span></code><code><span class="code-snippet_outer">@Documented</span></code><code><span class="code-snippet_outer">public @interface VeyronJoinPoint {}</span></code></pre></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">并将该注解标识在需要增强的方法上，随后通过下面的方式描述切点，即可获取到所有需要增强的方法。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="css"><code><span class="code-snippet_outer">@<span class="code-snippet__keyword">Pointcut</span>("@<span class="code-snippet__keyword">annotation</span>(<span class="code-snippet__keyword">com</span>.<span class="code-snippet__keyword">taobao</span>.<span class="code-snippet__keyword">gaia</span>.<span class="code-snippet__keyword">serverless</span>.<span class="code-snippet__keyword">veyron</span>.<span class="code-snippet__keyword">aspect</span>.<span class="code-snippet__keyword">VeyronJoinPoint</span>)")</span></code><code><span class="code-snippet_outer">public void lindormDataAccess() {}</span></code></pre></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">上面的方法也有进一步改良的空间：在注解内增加属性来描述具体的业务场景，不同的切面根据业务场景来对捕获的方法进行过滤，只留下当前业务场景所需要的方法。不然按照现有的做法，如果新的切面也要基于注解来寻找切点，那只能定义新的注解，否则会与原先注解产生冲突。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;visibility: visible;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><img class="rich_pages wxw-img" data-imgfileid="503041834" data-ratio="0.3056872037914692" data-s="300,640" data-type="png" data-w="422" src="https://oscimg.oschina.net/oscnet/18f51c34-a896-48a4-b5c4-e2bfd339953f.png" style="outline: 0px;letter-spacing: 0.544px;font-size: 14px;visibility: visible !important;width: 117px !important;" referrerpolicy="no-referrer"></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;visibility: visible;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;color: rgb(0, 17, 255);">总结</span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">业务需求千变万化，对应的解法也见仁见智。在研发过程中对各种变化中不变的部分进行总结，从中提取出自己的模式与方法论进行整理沉淀，会让我们以后跑的更快。也正应了学生时期，老师常说的那句话：「我们要把厚厚的书本读薄才能装进脑子里。」</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">最后，如果大家有好的实践模式推荐或者建议，欢迎在评论区分享交流～</span></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><p style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><img class="rich_pages wxw-img" data-imgfileid="503041835" data-ratio="0.328125" data-s="300,640" data-type="png" data-w="256" src="https://oscimg.oschina.net/oscnet/5749e182-ccf0-448e-af95-1df19ffdd6a8.png" style="outline: 0px;letter-spacing: 0.544px;font-size: 16px;visibility: visible !important;width: 122px !important;" referrerpolicy="no-referrer"></p><p style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(100, 99, 99);font-size: 15px;text-align: center;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 1px;font-size: 18px;color: rgb(0, 17, 255);">团队介绍</span></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">我们是淘天业务技术用户消息与社交团队，负责淘宝消息、客服、Push、分享、我淘、关系、社交互动等业务，涵盖淘宝 APP 中两个一级 Tab，第三个消息 tab 和第五个我的淘宝 tab，这里有一流的产品技术，为消费者提供更好的消息与社交服务；丰富的业务场景，为淘系业务增加助力；几十万 QPS 的高并发流量，可以与淘系各位技术大牛合作，思想激荡碰撞，共同提升，包含以下方向：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">在淘宝 IM 基础上构建以用户实时意图感知、统一投放引擎为核心的全域触达体系，通过跨场景的触达方案，赋能淘系搜索、互动、用增等业务增长，每日触达亿级用户。</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">社交域基础平台服务，我的淘宝、淘友、互动等业务，服务上亿淘宝用户。</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">淘宝消息 tab、千牛商家消息，通过建立平台，消费者，商家之间的链接，提升手淘 DAU，助力商家更好的服务消费者，拥有亿级电商 IM 消息即时通讯产品，可以深入掌握分布式高可靠设计理念和架构方法论。</span></p></li></ol><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">招聘持续火热🔥进行中，如果有兴趣可将简历发至 lingye.jly@taobao.com，期待您的加入！</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section data-role="outer" label="Powered by 135editor.com" style="margin-bottom: 0px;outline: 0px;letter-spacing: 0.544px;visibility: visible;"><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;word-break: break-all;color: rgb(0, 0, 0);font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;text-align: center;line-height: 1.75em;"><span style="outline: 0px;color: rgb(0, 17, 255);"><strong style="outline: 0px;">¤</strong></span><span style="outline: 0px;"><strong style="outline: 0px;">&nbsp;拓展阅读&nbsp;</strong></span><span style="outline: 0px;color: rgb(0, 17, 255);"><strong style="outline: 0px;">¤</strong></span></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;word-break: break-all;color: rgb(0, 0, 0);font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;text-align: center;line-height: 1.75em;"><br style="outline: 0px;"></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;min-height: 24px;clear: both;visibility: visible;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D2565944923443904512%23wechat_redirect" textvalue="3DXR 技术" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">3DXR 技术</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1533906991218294785%23wechat_redirect" textvalue="终端技术" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">终端技术</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1592015847500414978%23wechat_redirect" textvalue="音视频技术" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">音视频技术</a></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;visibility: visible;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1539610690070642689%23wechat_redirect" textvalue="服务端技术" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">服务端技术</a><span style="outline: 0px;letter-spacing: 0.544px;">&nbsp;|&nbsp;</span><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D2565883875634397185%23wechat_redirect" textvalue="技术质量" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">技术质量</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1522425612282494977%23wechat_redirect" textvalue="数据算法" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">数据算法</a></section><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;visibility: visible;"><br style="outline: 0px;"></p><section class="mp_profile_iframe_wrp" style="margin-bottom: 24px;outline: 0px;"><mp-common-profile class="custom_select_card mp_profile_iframe js_wx_tap_highlight" data-pluginname="mpprofile" data-id="MzAxNDEwNjk5OQ==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/33P2FdAnju8t5nZGhAatCrc4e2iaDfAaoInribRKxc7MOqdTGygfcLqSDxhj0trCHVEh94Sjl7zuWYzwouYtJ0VQ/300?wx_fmt=png&amp;wxfrom=19" data-nickname="大淘宝技术" data-alias="AlibabaMTT" data-signature="大淘宝技术官方账号" data-from="2" data-index="0" data-origin_num="685" data-isban="0" data-weuitheme="light" data-biz_account_status="0" data-is_biz_ban="0"></mp-common-profile><span style="outline: 0px;color: rgb(0, 0, 0);font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 1px;"></span></section></section><section style="line-height: 1.75em;"><section style="display: none;line-height: 1.75em;"><br></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - 大淘宝技术（AlibabaMTT）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 02:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4662964/blog/10555462</guid>
            <link>https://my.oschina.net/u/4662964/blog/10555462</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Fish Shell 3.7 发布，功能强大的命令行 Shell]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Fish Shell 3.7 已正式<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffish-shell%2Ffish-shell%2Freleases%2Ftag%2F3.7.0" target="_blank">发布</a></u>，其开发团队称<u><a href="https://www.oschina.net/news/226616/fish-shell-be-rewritten-rust">采用 Rust 重写</a></u>的工作仍在进行中，因此该版本仍然基于 C++ 编写——不过也将是采用 C++ 编写的最后分支版本。</p><blockquote><p><em><strong>Fish 3.7.0 和 3.7 系列的未来子版本均采用 C++</strong>。</em></p></blockquote><p>fish 是适用于 Linux、macOS 的命令行 Shell，其名字取于 "the<strong>f</strong>riendly<strong>i</strong>nteractive<strong>sh</strong>ell" 的简称，最大特点就是方便易用、功能强大、智能并且用户友好。很多其他 Shell 需要配置才有的功能，fish 默认提供，不需要任何配置。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8ac37b9a595ea6b4d16839034fa3b00e68f.png" referrerpolicy="no-referrer"></p><p>主要变化：</p><ul><li>支持将 Fish 配置为等待指定的时间来完成多键序列，而不是无限期地等待</li><li>改进&nbsp;history pager</li><li>改进命令自动补全和通配符性能</li><li>改进交互</li><li>……</li></ul><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffish-shell%2Ffish-shell%2Freleases%2Ftag%2F3.7.0" target="_blank">详情查看 Release Notes</a></u>。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 02:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273753/fish-shell-3-7-0-released</guid>
            <link>https://www.oschina.net/news/273753/fish-shell-3-7-0-released</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[最新桌面浏览器市场份额排名：Edge 重回第二、Safari 跌破 10%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>知名流量监测机构 Statcounter 公布了 2023 年&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgs.statcounter.com%2Fbrowser-market-share%2Fdesktop%2Fworldwide" target="_blank">12 月份全球桌面浏览器市场份额</a>：</p><p><img src="https://static.oschina.net/uploads/space/2024/0102/101516_FTqQ_2720166.png" referrerpolicy="no-referrer"></p><p>主要数据如下：</p><ul><li><strong>Chrome：65.29%</strong></li><li><strong>Edge：<span>11.89%</span></strong></li><li><strong>Safari：<span>8.92%</span></strong></li><li>Firefox：7.61%</li><li>Opera：3.8%</li><li>360 Safe：0.71%</li><li>……</li></ul><p><img height="720" src="https://oscimg.oschina.net/oscnet/up-da555d51c704e0a59cad47fb01d30a6da9f.png" width="1280" referrerpolicy="no-referrer"></p><p>2023 年 5 月，Safari <u><a href="https://www.oschina.net/news/240186/statcounter-safari-edge">以微弱优势超过 Edge </a></u>成为全球市场份额排名第二的桌面浏览器。此后几个月也一直稳坐第二，然而没想到 Edge 在 2023 年最后一个月来了一波大反杀——要知道 11 月 Safari 的市场份额仍有 13%，比 Edge 的 11% 高出两个点。</p><p><img src="https://oscimg.oschina.net/oscnet/up-729990e5f76ed08ac6344603617f319861c.png" referrerpolicy="no-referrer"></p><p>然而在 12 月，Safari 的市场份额急剧下降，直接跌破 10%——只剩&nbsp;<span>8.92%。</span>目前尚无信息显示 Safari 市场份额暴跌的背后原因。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 02:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273741/statcounter-edge-202312</guid>
            <link>https://www.oschina.net/news/273741/statcounter-edge-202312</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[openKylin 1.0 成功适配 Inte l 最新 x86 平台 Raptor Lake 系列]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify">2023 年 12 月 25 日，openKylin 1.0 成功适配 Intel（英特尔）最新 x86 平台 Raptor Lake 系列，与国际 OSV 同步。</p><div><p style="text-align:center"><img alt="" height="410" src="https://oscimg.oschina.net/oscnet/up-fcdea1508a9a5937b9f83fbef89e66a1b9e.png" width="940" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">Intel 中国公司在 2023 年 11 月加入 openKylin 社区之后，成立了 Intel SIG 并与 openKylin 社区开展合作，经过 Intel SIG 团队成员的努力，目前 openKylin 1.0 操作系统已成功适配第 13/14 代 Intel 客户端平台，Raptor Lake 系列，以及 ADL-N（12 代 refresh）。具体机型如下所示：</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">1.支持 Intel 最新 13/14 代 CPU 型号；</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">2.支持 Intel ADL-N, RPL-S,RPL-P, RPL-U, RPL-HX 等最新平台；</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">3.支持相关 OEM 惠普，联想等基于 Intel13 代机的相关机型。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">测试期间，openKylin 1.0 操作系统在以上 Intel 开发机平台上整体运行稳定，功能、性能及兼容性方面表现良好。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">Raptor Lake 是 Intel 基于混合架构的第 13 代和第 14 代 Intel 酷睿处理器的代号，采用 Raptor Cove 性能核心和 Gracemont 效率核心。与 Alder Lake 一样，Raptor Lake 也是使用 Intel 的 Intel 7 工艺制造的。Raptor Lake 具有多达 24 个核心（8 个性能核心加 16 个效率核心）和 32 个线程，并且与 Alder Lake 系统（LGA 1700、BGA1744、BGA1964）兼容。与前几代一样，Raptor Lake 处理器也需要配套的芯片组。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">目前，Intel SIG 共完成 6.1 Kernel 合并 Intel 最新平台支持补丁 110 多个, 包括最新图形，声音，蓝牙，无线，电源管理，网络，串口，多媒体等硬件的支持。同时 linux-firmware 合并 Intel 最新平台支持补丁 170 多个，包括 Intel 最新显卡，无线网卡，蓝牙，声音等的硬件固件支持。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">未来，Intel 将持续与 openKylin 社区开展深入合作，推动 openKylin 操作系统适配更多的 Intel 最新平台，并不断优化和完善其应用体验，共同推动 openKylin 开源操作系统的普及和国产开源生态的打造，助力 openKylin 开源生态布局进一步完善。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 01:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273735</guid>
            <link>https://www.oschina.net/news/273735</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Vue 3.4 「灌篮高手」发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Vue 3.4 已正式发布，代号"🏀 Slam Dunk"（灌篮高手）。</p><h4><strong>新版本主要变化</strong></h4><ul><li><strong>重写模板解析器</strong>，速度提升了 2 倍</li><li><strong>重构响应性系统 (Reactivity System</strong><strong style="font-family:-apple-system,BlinkMacSystemFont,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;,&quot;Segoe UI&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif">)</strong><span style="font-family:-apple-system,BlinkMacSystemFont,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;,&quot;Segoe UI&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif">，让 effect 的触发更准确高效</span></li><li><strong>优化 API</strong>，比如<code>defineModel</code>进入稳定阶段，以及绑定 props 时的同名简写</li></ul><hr><h4><strong>更新亮点</strong></h4><ul><li><strong><span style="background-color:#e67e22">解析器速度提升 2 倍，优化 SFC 构建性能</span></strong></li></ul><p><strong>Vue 3.4 完全重写了模板解析器</strong>。在旧版本，Vue 使用递归下降解析器，该解析器依赖了大量正则表达式和前向搜索。</p><p>新的解析器使用基于<code>htmlparser2</code>的状态机 tokenizer（分词器），它仅迭代整个模板字符串一次。结果是对于所有尺寸的模板而言，解析器始终优化 2 倍。得益于 Vue 广泛的测试用例和 ecosystem-ci，它也 100% 向后兼容 Vue 终端用户。</p><p>在将新的解析器与系统的其他部分集成时，开发团队还发现了进一步优化整体 SFC 编译性能的机会。基准测试显示，在生成源码映射的同时，编译 Vue SFC 的脚本和模板部分的时候，性能优化了约 44%，因此 Vue 3.4 应该会优化大多数使用 Vue SFC 的项目构建。</p><p>但是请注意，Vue SFC 编译只是现实项目中整个构建过程的一部分。与单独的基准测试相比，端到端构建时间的最终收益可能要小得多。</p><p>在 Vue 核心库之外，新的解析器还将优化 Volar/vue-tsc，以及需要解析 Vue SFC 或模板的社区插件的性能，比如 Vue Macros。</p><ul><li><strong><span style="background-color:#e67e22">更高效的响应性系统 (Reactivity System)</span></strong></li></ul><p>3.4 对响应性系统进行了重大重构，目标是提高计算属性的重新计算效率。</p><p>比如下面的场景：</p><pre><code class="language-javascript">const count = ref(0)
const isEven = computed(() =&gt; count.value % 2 === 0)

watchEffect(() =&gt; console.log(isEven.value)) // logs true

count.value = 2 // logs true again</code></pre><p>在 3.4 之前的版本，每当&nbsp;<code>count.value</code>&nbsp;变更时，即使计算结果不变，也会触发&nbsp;<code>watchEffect</code>&nbsp;的回调。通过 3.4 优化，现在仅当计算结果实际发生变更时才会触发回调。</p><ul><li><strong><code><span style="background-color:#e67e22">v-bind</span></code><span style="background-color:#e67e22">&nbsp;同名简写</span></strong></li></ul><p>下面用例：</p><pre><code class="language-javascript">&lt;img&nbsp;:id="id"&nbsp;:src="src"&nbsp;:alt="alt"&nbsp;/&gt;</code></pre><p>可简写为：</p><pre><code class="language-javascript">&lt;img&nbsp;:id&nbsp;:src&nbsp;:alt&nbsp;/&gt;</code></pre><p>Vue 团队表示，最初他们担心这种用法会与布尔属性混淆。但在重新审视该功能后，考虑到其动态特性，他们认为<code>v-bind</code>的行为比原生属性更像 JavaScript 是有意义的。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.vuejs.org%2Fposts%2Fvue-3-4" target="_blank">详情查看发布公告</a></u>。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 14:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273703/vue-3-4</guid>
            <link>https://www.oschina.net/news/273703/vue-3-4</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenChat 1.0 beta，开源 IM 服务器搭配 SDK 以及 APP 软件平台！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>龙年元旦，祝大家龙年快乐，技术更上一层！2024 赚大钱！</p><p>在这里我也为大家准备了一个新年礼物 OpenChat 的源码，希望有自主 IM 研发需求的朋友可以尝试体验。</p><p>整个 IM 服务器我们分为 Gate / Msg / Logic 三个服务，下面是三个服务的解释：</p><ol><li>Gate：顾名思义是网关服务，可以启用多个网关，比如北京、上海、深圳我们都放一个网关，来提升用户访问的响应问题。</li><li>Msg：消息服务器，Msg 服务可以根据需求无限扩展，来提服务的并发能力。</li><li>Logic：这个是逻辑服务器，所有用户关系、群、红包等功能都会在这个服务内完成，主要是操作消息队列和数据库。</li></ol><p>值得一提的是 OpenChat 配套了完整的 SDK 封装，SDK 封装使用了 C++11 语法，兼容了 iOS / Android / Windows / macOS / Linux / FreeBSD 等主流平台。</p><p>因为这个开源软件目前没有 UI 设计人员参与，Demo 界面参照了微信的常规布局，演示在下方。</p><p>苹果 iPhone iOS 版本演示二维码：</p><p><img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-f63906cd3a53f9519e876991edf5b1ca6ac.png" width="400" referrerpolicy="no-referrer"></p><p>安卓 Android 版本演示二维码：</p><p><img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-cba62748e9efe7969b3eeea3b98259b5aad.png" width="400" referrerpolicy="no-referrer"></p><p>开源项目希望大家能喜欢，有建议可以加 D 语言交流 QQ 群：<span style="background-color:#303030; color:rgba(255, 255, 255, 0.6)">184183224</span></p><p>开源作者 QQ 和微信：<span style="background-color:#303030; color:rgba(255, 255, 255, 0.6)">101011100</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 07:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273657/openchat-1-0-beta</guid>
            <link>https://www.oschina.net/news/273657/openchat-1-0-beta</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[基于 mybatis 的 orm：mybatis-mp 1.3.0 发布-超丰富的 api！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">mybatis-mp 包含丰富的 api：</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">1：基于注解，映射数据库；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">2：支持多表 join 和返回；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">3：api 采用 lambda 和 stream 流式设计；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">4：内置分页以及超强的 sql 优化功能；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">5：稳定且性能极优；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">6：轻量级封装 mybatis，几乎没有侵入；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">7：api 丰富，支持数据库函数、多表、乐观锁、多租户、逻辑删除、默认值（可动态值） 等众多功能；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">8：零学习成本，和写 sql 一样方便。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">9：支持复杂的返回关系映射：例如一对一 ，一对多，多对多；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">10：支持自定义 sql 模板，再也不用担心框架支持不足；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">11：内置代码生成器，通过配置，可定制自身规范；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">12：全新的框架，全新的设计理念，新的就是好！</p><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 06:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273646/mybatis-mp-1-3-0-released</guid>
            <link>https://www.oschina.net/news/273646/mybatis-mp-1-3-0-released</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
