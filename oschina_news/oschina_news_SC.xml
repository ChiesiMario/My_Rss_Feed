<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-最新资讯]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-最新资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Sun, 17 Dec 2023 14:36:40 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Chrome 测试限制跨站点跟踪功能，以逐步淘汰第三方 Cookie]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">谷歌 Chrome 浏览器正在测试 Tracking Protection，一项可限制<span style="background-color:#ffffff">跨站点跟踪的新功能</span>。</span></p><p><span style="color:#000000">这项新功能是谷歌"</span><span style="background-color:#ffffff; color:#202124">Privacy Sandbox</span><span style="color:#000000">"计划的一部分，该计划旨在以负责任的方式在 2024 年下半年逐步淘汰第三方 cookie，其中包括为网站创建新的工具来实现基本功能，并给予开发人员适应的时间。</span></p><p><span style="color:#000000">Tracking Protection&nbsp;<span style="background-color:#ffffff">的引入将首先从一小部分 Chrome 用户开始，公告透露，</span>他们将于 2024 年 1 月 4 日开始测试 Tracking Protection 功能，面向全球 1% 的 Chrome 浏览器用户推出。</span></p><p><span style="color:#000000">近三十年来，第三方 cookie 一直是网络的基本组成部分。它们可用于跟踪网站活动，但网站同时也在使用它们来支持一系列在线体验，例如帮助用户登录或展示相关广告。</span></p><blockquote><p><span style="color:#000000">「通过 Privacy Sandbox，我们正在采取负责任的方式逐步淘汰 Chrome 中的第三方 Cookie。我们为网站构建了新工具，支持关键用例，并为开发人员提供了过渡时间。我们将从一小部分 Chrome 用户开始引入 Tracking Protection，以便开发者可以测试他们对没有第三方 Cookie 的网络的准备情况。」</span></p></blockquote><p>参与&nbsp;<span style="color:#000000">Tracking Protection 功能试用的用户将随机抽取。被选中的用户在</span><span style="background-color:#ffffff; color:#202124">打开 Chrome 浏览器时，会收到相关通知。启用该功能后，用户在浏览网页时，默认情况下第三方 cookie 将受到限制，从而限制在不同网站上跟踪的能力。</span></p><p><span style="background-color:#ffffff; color:#202124"><img alt="" height="344" src="https://oscimg.oschina.net/oscnet/up-57f1c84f1b3c261331013a59a537fd1aae8.webp" width="500" referrerpolicy="no-referrer"></span></p><p><span style="background-color:#ffffff; color:#202124">如果某个网站在没有第三方 cookie 的情况下无法运行，而 Chrome 浏览器又发现用户遇到了该问题（比如进行了多次页面刷新），就会在地址栏右侧的眼睛图标上提示用户暂时重新启用该网站的第三方 cookie。</span></p><p><span style="background-color:#ffffff; color:#202124"><img alt="" height="300" src="https://oscimg.oschina.net/oscnet/up-7dfa96f75c4d4ba43aa7ade9fd6ab653d77.gif" width="300" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">此前，谷歌方面已经发布一系列 Privacy Sandbox 更新。 譬如 8 月推出了 Project Flight，该项目包含一系列示例应用程序，共同展示了 Privacy Sandbox API 在真实用户体验中的实际应用。</span></p><p><span style="color:#000000">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.google%2Fproducts%2Fchrome%2Fprivacy-sandbox-tracking-protection%2F" target="_blank">查看官方博客</a>。</span></p><p><strong><span style="color:#000000">相关阅读：</span></strong></p><ul><li><a href="https://www.oschina.net/news/204434/google-delays-third-party-cookies" target="_blank">2022、2023 再到 2024，谷歌再次推迟 Cookies 淘汰时间</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Sun, 17 Dec 2023 04:18:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271417/google-chrome-tracking-protection</guid>
            <link>https://www.oschina.net/news/271417/google-chrome-tracking-protection</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[ONF 解散，将所有业务转移到 Linux 基金会]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Open Networking Foundation (ONF) <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linuxfoundation.org%2Fpress%2Fonf-merges-market-leading-portfolio-of-networking-projects-into-linux-foundation" target="_blank">宣布</a>，其涵盖接入、边缘和云解决方案的领先开源网络项目组合将毕业成为 Linux 基金会下的独立项目。「此举为三个主要项目领域（Broadband，Aether 和 P4）创造了独立的、由社区领导的治理，并为项目的广泛协作和采用奠定了基础。」</p><p><img alt="" height="281" src="https://oscimg.oschina.net/oscnet/up-7377a8aba31c8b7c4d29de527f9310b8382.webp" width="500" referrerpolicy="no-referrer"></p><p>由于此次合并，ONF 将解散，将所有业务转移到 Linux 基金会。Linux 基金会将创建三个新的项目指导基金，以支持技术项目的工作，包括：</p><ul><li>LF Broadband Directed Fund - 支持一系列改变宽带网络和被动光纤网络（Passive Optical Network，PON）行业的项目。该组合包括用于构建开放宽带网络的 SEBA 参考设计和用于虚拟化多厂商 PON 系统的 VOLTHA 开源项目。这些项目已在德国电信、Jio、Türk Telekom 等世界各地部署。</li><li>Aether Directed Fund - 支持一系列 5G 移动网络项目，包括 Aether（私有 5G 和边缘计算）、SD-Core（开放 5G 移动核心）和 SD-RAN（开放 RAN）。电信、商业和研究部署依赖于这些项目，并且刚刚获得了 200 万美元的美国政府研究拨款，以推动 5G 网络的节能和可持续性。</li><li>P4 Directed Fund - 支持一系列工作，实现网络数据平面的可编程性，包括 P4 体系结构、语言、API、应用和平台。其中包括可编程网络 Fabric 的开源编译器和堆栈实现（SD-Fabric、Stratum），在从云到数据中心和运营商边缘网络（如 Comcast、Google、SKT、腾讯和巴西的空中交通管制系统）的各种部署中。</li></ul><p>公告称，ONF 与 LF 的合并反映了项目治理的变化，但保留了基于社区合作的技术项目的演进过程，以适应市场需求的变化。</p><p>ONF 现有的技术指导团队<span style="color:#000000">将继续指导技术工作</span>。但成立了新的管理委员会，以领导每个新指导基金，使社区完全拥有项目的方向和 ONF 为指导基金提供的约 500 万美元资金的应用权。这些资金将用于有选择地为项目提供工程人员的支持。</p><p>&nbsp;详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linuxfoundation.org%2Fpress%2Fonf-merges-market-leading-portfolio-of-networking-projects-into-linux-foundation" target="_blank">查看官方公告</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 17 Dec 2023 03:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271412/onf-linux-foundation</guid>
            <link>https://www.oschina.net/news/271412/onf-linux-foundation</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[HTTPie Desktop —— 跨平台 API 测试客户端]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>HTTPie for Web &amp; Desktop，跨平台 API 测试客户端，轻松测试 REST、GraphQL 和 HTTP API。目前已发布了适用于 Mac、Windows 和 Linux 的 HTTPie for Desktop 版本。初次安装后，应用程序会持续自动更新。</p><p><strong>特点：</strong></p><ul style="margin-left:0; margin-right:0"><li><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:rgb(209 209 207/var(--tw-text-opacity))"><span><span><span><span>与 API 轻松交互</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:rgb(209 209 207/var(--tw-text-opacity))"><span><span><span><span>利用人工智能辅助工作的力量</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:rgb(209 209 207/var(--tw-text-opacity))"><span><span><span><span>在空间、集合和选项卡中组织您的工作</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:rgb(209 209 207/var(--tw-text-opacity))"><span><span><span><span>使用变量和环境参数化请求</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:rgb(209 209 207/var(--tw-text-opacity))"><span><span><span><span>通过自动保存和实时同步跨设备工作</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:rgb(209 209 207/var(--tw-text-opacity))"><span><span><span><span>构建并预览请求而不发送请求</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:rgb(209 209 207/var(--tw-text-opacity))"><span><span><span><span>无需帐户即可离线使用该应用程序</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li></ul><p><img alt="" height="307" src="https://static.oschina.net/uploads/space/2023/1009/155957_SR87_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Sun, 17 Dec 2023 03:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/httpie-desktop</guid>
            <link>https://www.oschina.net/p/httpie-desktop</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 基于 eBPF 的 Linux 审计观测工具 safeguard]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-safeguard-linux-security-audit-control-and-behavior-analysis-tools-based-on-krsiebpflsm" class="anchor" href="https://gitee.com/openeuler/safeguard#safeguard-linux-security-audit-control-and-behavior-analysis-tools-based-on-krsiebpflsm"></a>safeguard: Linux security audit, control, and behavior analysis tools based on KRSI(eBPF+LSM)</h1><p>针对操作系统、内核安全，safeguard 是一个基于 eBPF 的 Linux 审计观测工具，可以实现安全操作的拦截及审计记录。项目采用 libbpfgo 库，使用 go 语言实现顶层控制</p><h1><a id="user-content-特性" class="anchor" href="https://gitee.com/openeuler/safeguard#%E7%89%B9%E6%80%A7"></a>特性</h1><ul><li>审计：日志记录配置范围内的行为</li><li>控制：针对文件，进程，网络的安全访问控制</li><li>行为分析：收集信息，进行资源，热点，异常等分析</li><li>主机管理：从安全角度自动化构建细粒度资产信息</li><li>风险管理：精准发现内部风险，快速定位问题并有效解决安全风险</li><li>入侵检测：提供多锚点的检测能力，能够实时、准确的感知入侵事件，发现失陷主机，并提供对入侵事件的响应手段。</li></ul><p><img src="https://gitee.com/openeuler/safeguard/raw/master/docs/architecture.png" alt="architecture" referrerpolicy="no-referrer"></p><h1><a id="user-content-编译" class="anchor" href="https://gitee.com/openeuler/safeguard#%E7%BC%96%E8%AF%91"></a>编译</h1><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nv">$ </span>git clone <span class="nt">--recursive</span> https://gitee.com/openeuler/safeguard.git <span class="o">&amp;&amp;</span><span class="nb">cd </span>safeguard</span><span id="LC2" class="line"><span class="c"># $ vagrant up &amp;&amp; vagrant reload</span></span><span id="LC3" class="line"><span class="c"># $ vagrant ssh</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="nv">$ </span>make libbpf-static</span><span id="LC6" class="line"><span class="nv">$ </span>make build</span><span id="LC7" class="line"></span><span id="LC8" class="line"><span class="nv">$ </span><span class="nb">sudo</span> ./build/safeguard <span class="nt">--config</span> config/safeguard.yml <span class="c">#|grep BLOCK</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h1><a id="user-content-项目功能部分位于开发阶段" class="anchor" href="https://gitee.com/openeuler/safeguard#%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E9%83%A8%E5%88%86%E4%BD%8D%E4%BA%8E%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5"></a>项目功能 (部分位于开发阶段)</h1><h3><a id="user-content-审计控制" class="anchor" href="https://gitee.com/openeuler/safeguard#%E5%AE%A1%E8%AE%A1%E6%8E%A7%E5%88%B6"></a>审计控制</h3><p>文件：</p><ul><li>追踪文件系统的活动，包括文件的打开、关闭、读写、删除等。</li><li>修改文件系统的行为，例如拦截某些文件操作，或者实现自定义的<strong>安全策略</strong>。
安全策略：
<ol><li>拦截或重定向某些文件操作，使用 eBPF 来拦截对敏感文件的读写操作，或者重定向对某些文件的访问到其他位置。</li><li>实现自定义的访问控制，使用 eBPF 来检查对文件的访问者的身份、权限、环境等信息，然后根据一些规则来允许或拒绝访问。</li><li>实现自定义的审计和监控，使用 eBPF 来记录对某些文件的操作的详细信息，如操作者、时间、内容等，并将这些信息输出到日志。</li></ol></li></ul><p>进程：</p><ul><li>追踪进程的生命周期，例如进程的创建、终止、调度、上下文切换等。</li><li>修改进程的行为，例如注入或修改某些系统调用，或者实现自定义的调度策略。</li></ul><p>网络：</p><ul><li>追踪网络的活动，例如网络包的发送、接收、转发、丢弃等。</li><li>修改网络的行为，例如过滤或重写某些网络包，或者实现自定义的路由策略。</li></ul><h3><a id="user-content-行为分析" class="anchor" href="https://gitee.com/openeuler/safeguard#%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90"></a>行为分析</h3><ul><li><p>收集并分析文件系统的性能、热点、异常等。（选择合适的 eBPF 程序类型和挂载点，例如，使用 kprobes 或 tracepoints 来追踪文件系统相关的内核函数或事件，如 vfs_read, vfs_write, ext4_sync_file 等。）</p></li><li><p>收集信息来分析进程的资源消耗、状态变化、依赖关系等（do_fork, do_exit, schedule 等）。</p></li><li><p>收集信息，分析网络的流量、延迟、丢包率、拥塞等（使用 tc 或 xdp 来追踪网络包的发送、接收、转发、丢弃等事件）。</p></li></ul><h3><a id="user-content-主机管理" class="anchor" href="https://gitee.com/openeuler/safeguard#%E4%B8%BB%E6%9C%BA%E7%AE%A1%E7%90%86"></a>主机管理</h3><p>从安全角度自动化构建细粒度资产信息，支持对业务层资产精准识别和动态感知，让保护对象清晰可见。</p><ul><li>账号展示</li><li>端口列表</li><li>进程列表</li></ul><h3><a id="user-content-风险管理" class="anchor" href="https://gitee.com/openeuler/safeguard#%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86"></a>风险管理</h3><p>精准发现内部风险，快速定位问题并有效解决安全风险，提供详细的资产信息、风险信息以供分析和响应。</p><ul><li>漏洞检测</li><li>安全补丁</li><li>弱密码</li><li>系统风险</li><li>账号风险</li></ul><h3><a id="user-content-入侵检测" class="anchor" href="https://gitee.com/openeuler/safeguard#%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B"></a>入侵检测</h3><p>提供多锚点的检测能力，能够实时、准确的感知入侵事件，发现失陷主机，并提供对入侵事件的响应手段。</p><ul><li>暴力破解</li><li>异常登录</li><li>反弹 shell</li><li>本地提权</li><li>后门检测，Web 后门</li></ul><h1><a id="user-content-开发路线" class="anchor" href="https://gitee.com/openeuler/safeguard#%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF"></a>开发路线</h1><table><thead><tr><th></th><th></th><th align="center">23.12（22.03 LTS SP3）</th><th align="center">24.03 LTS</th><th align="center">24.09 创新版本</th><th align="center">24.09（24.03 LTS SP1）</th><th align="center">已实现</th></tr></thead><tbody><tr><td>控制-主机规则设置</td><td>文件操作拦截</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td></tr><tr><td></td><td>进程拦截（采用 path hook）</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td></td><td>网络拦截</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td></tr><tr><td>主机管理</td><td>账号</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td></td><td>端口</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td></td><td>进程</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>风险管理</td><td>漏洞检测</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr><tr><td></td><td>安全补丁</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr><tr><td></td><td>弱密码</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr><tr><td></td><td>系统风险</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr><tr><td></td><td>账号风险</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr><tr><td>入侵检测</td><td>暴力破解</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td></td><td>异常登录</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td></td><td>反弹 shell</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr><tr><td></td><td>本地提权</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td></td><td>后门检测，Web 后门</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr><tr><td>安全日志</td><td>审计日志：文件 hook 拦截方式由路径更改为 inode</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td></tr><tr><td></td><td>登录日志</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td></td><td>账户变更日志</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1><a id="user-content-license" class="anchor" href="https://gitee.com/openeuler/safeguard#license"></a>LICENSE</h1><p>safeguard's userspace program is licensed under Apache License 2.0 License.<br>
eBPF programs inside <a href="https://gitee.com/openeuler/safeguard/blob/master/pkg/bpf">pkg/bpf directory</a> are licensed under <a href="https://gitee.com/openeuler/safeguard/blob/master/pkg/bpf/LICENSE.md">GNU General Public License version 2</a>.</p>]]>
            </description>
            <pubDate>Sun, 17 Dec 2023 03:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/openeuler/safeguard</guid>
            <link>https://gitee.com/openeuler/safeguard</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | PWA 离线方案研究报告]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>本文并不是介绍如何将一个网页配置成离线应用并支持安装下载的。研究 PWA 的目的仅仅是为了保证用户的资源可以直接从本地加载，来忽略全国或者全球网络质量对页面加载速度造成影响。当然，如果页面上所需的资源，除了资源文件外并不需要任何的网络请求，那它除了不支持</span></span></span><span><span><strong><span>安装到桌面</span></strong></span></span><span><span><span>，已经算是一个离线应用了。</span></span></span></p><span id="OSC_h1_1"></span><h1><span><span><span>什么是 PWA</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>PWA（Progressive Web App）是一种结合了网页和原生应用程序功能的新型应用程序开发方法。PWA 通过使用现代 Web 技术，例如 Service Worker 和 Web App Manifest，为用户提供了类似原生应用的体验。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><strong><span><span><span>从用户角度来看，PWA 具有以下特点：</span></span></span></strong></p><div><span>1.</span><span><span><span><span>可离线访问：PWA 可以在离线状态下加载和使用，使用户能够在没有网络连接的情况下继续浏览应用；</span></span></span></span></div><div><span>2.</span><span><span><span><span>可安装：用户可以将 PWA 添加到主屏幕，就像安装原生应用一样，方便快捷地访问；</span></span></span></span></div><div><span>3.</span><span><span><span><span>推送通知：PWA 支持推送通知功能，可以向用户发送实时更新和提醒；</span></span></span></span></div><div><span>4.</span><span><span><span><span>响应式布局：PWA 可以适应不同设备和屏幕大小，提供一致的用户体验。</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><strong><span><span><span>从开发者角度来看，PWA 具有以下优势：</span></span></span></strong></p><div><span>1.</span><span><span><span><span>跨平台开发：PWA 可以在多个平台上运行，无需单独开发不同的应用程序；</span></span></span></span></div><div><span>2.</span><span><span><span><span>更新便捷：PWA 的更新可以通过服务器端更新 Service Worker 来实现，用户无需手动更新应用；</span></span></span></span></div><div><span>3.</span><span><span><span><span>可发现性：PWA 可以通过搜索引擎进行索引，增加应用的可发现性；</span></span></span></span></div><div><span>4.</span><span><span><span><span>安全性：PWA 使用 HTTPS 协议传输数据，提供更高的安全性。</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>总之，PWA 是一种具有离线访问、可安装、推送通知和响应式布局等特点的新型应用开发方法，为用户提供更好的体验，为开发者带来更高的效率。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>我们从 PWA 的各种能力中，聚焦下其</span></span></span><span><span><strong><span>可离线访问</span></strong></span></span><span><span><span>的能力。</span></span></span></p><span id="OSC_h1_2"></span><h1><span><span><span>Service Worker</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>离线加载本质上是页面所需的各种</span></span></span><span><span><code><span>js</span></code></span></span><span><span><span>、</span></span></span><span><span><code><span>css</span></code></span></span><span><span><span>以及页面本身的</span></span></span><span><span><code><span>html</span></code></span></span><span><span><span>，都可以缓存到本地，不再从网络上请求。这个能力是通过</span></span></span><span><span><code><span>Service Worker</span></code></span></span><span><span><span>来实现的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Service Worker 是一种在浏览器背后运行的脚本，用于处理网络请求和缓存数据。它可以拦截和处理网页请求，使得网页能够在离线状态下加载和运行。Service Worker 可以缓存资源，包括 HTML、CSS、JavaScript 和图像等，从而提供更快的加载速度和离线访问能力。它还可以实现推送通知和后台同步等功能，为 Web 应用带来更强大的功能和用户体验。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>某些情况下，Service Worker 和浏览器插件的 background 很相似，但在功能和使用方式上有一些区别：</span></span></span></p><ul><li><span><span><span><strong><span>功能差异：</span></strong></span></span><span><span><span> Service Worker 主要用于处理网络请求和缓存数据，可以拦截和处理网页请求，实现离线访问和资源缓存等功能。而浏览器插件的 background 主要用于扩展浏览器功能，例如修改页面、拦截请求、操作 DOM 等。</span></span></span></span></li><li><span><span><span><strong><span>运行环境：</span></strong></span></span><span><span><span> Service Worker 运行在浏览器的后台，独立于网页运行。它可以在网页关闭后继续运行，并且可以在多个页面之间共享状态。而浏览器插件的 background 也在后台运行，但是它的生命周期与浏览器窗口相关，关闭浏览器窗口后插件也会被终止。</span></span></span></span></li><li><span><span><span><strong><span>权限限制：</span></strong></span></span><span><span><span> 由于安全考虑，Service Worker 受到一定的限制，无法直接访问 DOM，只能通过 postMessage() 方法与网页进行通信。而浏览器插件的 background 可以直接操作 DOM，对页面有更高的控制权。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>总的来说，Service Worker 更适合用于处理网络请求和缓存数据，提供离线访问和推送通知等功能；而浏览器插件的 background 则更适合用于扩展浏览器功能，操作页面 DOM，拦截请求等。</span></span></span></p><span id="OSC_h1_3"></span><h1><span><span><span>注册</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>注册一个 Service Worker 其实是非常简单的，下面举个简单的例子</span></span></span></p><pre><code><span><span><span style="color:#708090">&lt;!-- index.html --&gt;</span></span><span><span></span></span><span><span style="color:#708090">&lt;!DOCTYPE html&gt;</span></span><span><span></span></span><span><span style="color:#990055">&lt;html&gt;</span></span><span><span></span></span><span><span style="color:#990055">&lt;head&gt;</span></span><span><span></span></span><span><span style="color:#990055">&lt;title&gt;</span></span><span><span>Service Worker 示例</span></span><span><span style="color:#990055">&lt;/title&gt;</span></span><span><span></span></span><span><span style="color:#990055">&lt;/head&gt;</span></span><span><span></span></span><span><span style="color:#990055">&lt;body&gt;</span></span><span><span></span></span><span><span style="color:#990055">&lt;script&gt;</span></span><span><span>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('/service-worker.js')
          .then(function(registration) {
            console.log('Service Worker 注册成功:', registration.scope);
          })
          .catch(function(error) {
            console.log('Service Worker 注册失败:', error);
          });
      });
    }
  </span></span><span><span style="color:#990055">&lt;/script&gt;</span></span><span><span></span></span><span><span style="color:#990055">&lt;/body&gt;</span></span><span><span></span></span><span><span style="color:#990055">&lt;/html&gt;</span></span><span><span></span></span></span></code></pre><pre><code><span><span><span style="color:#708090">// service-worker.js</span></span><span><span></span></span><span><span style="color:#708090">// 定义需要预缓存的文件列表</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> filesToCache </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#999999">[</span></span><span><span></span></span><span><span style="color:#669900">'/'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'/index.html'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'/styles.css'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'/script.js'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'/image.jpg'</span></span><span><span></span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 安装 Service Worker 时进行预缓存</span></span><span><span>
self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addEventListener</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'install'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  event</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">waitUntil</span></span><span><span style="color:#999999">(</span></span><span><span>
    caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">open</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'my-cache'</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span style="color:#999999">(</span></span><span><span>cache</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> cache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addAll</span></span><span><span style="color:#999999">(</span></span><span><span>filesToCache</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 激活 Service Worker</span></span><span><span>
self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addEventListener</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'activate'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  event</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">waitUntil</span></span><span><span style="color:#999999">(</span></span><span><span>
    caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">keys</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span style="color:#999999">(</span></span><span><span>cacheNames</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> Promise</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">all</span></span><span><span style="color:#999999">(</span></span><span><span>
        cacheNames</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">filter</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span style="color:#999999">(</span></span><span><span>cacheName</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> cacheName </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!==</span></span><span><span></span></span><span><span style="color:#669900">'my-cache'</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">map</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span style="color:#999999">(</span></span><span><span>cacheName</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">delete</span></span><span><span style="color:#999999">(</span></span><span><span>cacheName</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 拦截 fetch 事件并从缓存中返回响应</span></span><span><span>
self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addEventListener</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'fetch'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  event</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">respondWith</span></span><span><span style="color:#999999">(</span></span><span><span>
    caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">match</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">.</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> response </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">||</span></span><span><span></span></span><span><span style="color:#dd4a68">fetch</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">.</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>上述示例中，注册 Service Worker 的逻辑包含在 HTML 文件的</span></span></span><span><span><code><span>&lt;script&gt;</span></code></span></span><span><span><span>标签中。当浏览器加载页面时，会检查是否支持 Service Worker，如果支持，则注册 Service Worker 文件</span></span></span><span><span><code><span>/service-worker.js</span></code></span></span><span><span><span>。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Service Worker 文件中，首先定义了需要预缓存的文件列表</span></span></span><span><span><code><span>filesToCache</span></code></span></span><span><span><span>。在</span></span></span><span><span><code><span>install</span></code></span></span><span><span><span>事件中，将这些文件添加到缓存中。在</span></span></span><span><span><code><span>activate</span></code></span></span><span><span><span>事件中，删除旧缓存。在</span></span></span><span><span><code><span>fetch</span></code></span></span><span><span><span>事件中，拦截请求并从缓存中返回响应。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Service Worker 文件</span></span></span><span><span><code><span>service-worker.js</span></code></span></span><span><span><span>需要放置在页面的主域名下。在调用</span></span></span><span><span><code><span>navigator.serviceWorker.register('/service-worker.js')</span></code></span></span><span><span><span>时，可以在第二个参数中设置</span></span></span><span><span><code><span>scope</span></code></span></span><span><span><span>，用来确定 Service Worker 的影响范围，默认是 sw 文件所在 path 的作用域。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>需要注意的是，如果 sw 文件被放置在</span></span></span><span><span><code><span>/a</span></code></span></span><span><span><span>目录下，是不能设置作用域为</span></span></span><span><span><code><span>/</span></code></span></span><span><span><span>的。因为文件本身路径的级别小于根路径。</span></span></span></p><span id="OSC_h1_4"></span><h1><span><span><span>使用</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>当我们按照上面的示例，配置好了</span></span></span><span><span><code><span>html</span></code></span></span><span><span><span>及对应的</span></span></span><span><span><code><span>sw.js</span></code></span></span><span><span><span>后，启动服务并刷新页面，应该就能看到控制枱打印出了</span></span></span><span><span><code><span>Service Worker 注册成功</span></code></span></span><span><span><span>的日志。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果在 chrome 浏览器中，可以打开控制枱，切换到应用 Tab，就能看到我们刚注册好的应用了。 </span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-12-02-17-022Ah2qfo8NupBJK8.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>此时在浏览器的缓存空间中，也能发现我们开辟的缓存</span></span></span><span><span><code><span>my-cache</span></code></span></span><span><span><span>，内部存储着我们指定的预缓存文件</span></span></span><span><span><code><span>index.html</span></code></span></span><span><span><span>。由于我的项目只有根页面，所以只有一个条目。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-12-02-17-02z9Numw0dw0WYJTS.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>此时如果页面所需的所有文件都被缓存了，即使将浏览器设置成断网模式，刷新页面也是能打开的。本文的目的并不是创建离线应用，下面我们讲讲上面方式会面临的问题。</span></span></span></p><span id="OSC_h3_5"></span><h3><span><span><span>如何确定预缓存范围</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果我们的项目只有一个仓库，可以使用一些</span></span></span><span><span><code><span>webpack</span></code></span></span><span><span><span>插件，可以直接帮我们生成</span></span></span><span><span><code><span>sw</span></code></span></span><span><span><span>文件。每次重新构建都会生成新的文件，这样就不用担心多存或者少存文件了。同时，在下一章节的删除旧缓存中，每次更新版本号就好了。</span></span></span></p><blockquote><span><span><span>﻿</span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ftools%2Fworkbox" target="_blank" rel="nofollow"><span><span><span>Workbox</span></span></span></a><span><span><span>是一个用于创建离线优先的网络应用程序的 JavaScript 库。它提供了一套工具和功能，帮助开发人员创建可靠的离线体验，并使网页应用程序能够在网络连接不稳定或断开的情况下正常工作。Workbox 可以用于缓存和提供离线资源，实现离线页面导航，处理后台同步和推送通知等功能。它能够简化离线应用程序的开发过程，并提供强大的缓存管理和资源加载能力。</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于有统一配置后台的微前端项目，这个问题有些棘手。</span></span></span></p><div><span>1.</span><span><span><span><span>由于有后台管理，更新某个模块的文件很常见，但并不想每次都更新</span></span></span><span><span><code><span>sw.js</span></code></span></span><span><span><span>。</span></span></span></span></div><div><span>2.</span><span><span><span><span>由于资源的不确定性，无法在</span></span></span><span><span><code><span>precache</span></code></span></span><span><span><span>中列举出所有的资源列表，即使列举出了，可能用户永远也不会用到某个文件，造成缓存浪费或溢出。</span></span></span></span></div><div><span>3.</span><span><span><span><span>出于第 1、2 条缘由，更新</span></span></span><span><span><code><span>sw</span></code></span></span><span><span><span>文件后，无法确定如何删除旧缓存。</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于这个问题，首先确定的是，先在</span></span></span><span><span><code><span>precache</span></code></span></span><span><span><span>中列举出所有的基础底座的资源文件，并单独占用一个</span></span></span><span><span><code><span>cacheName</span></code></span></span><span><span><span>。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于剩下的不确定性的业务文件，可以使用动态缓存的方式，这个会在后面具体讲解，也是本文要研究的重点。</span></span></span></p><span id="OSC_h3_6"></span><h3><span><span><span>资源更新</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>由于刷新页面后，所有资源都从缓存中获取，此时修改</span></span></span><span><span><code><span>html</span></code></span></span><span><span><span>后，再刷新浏览器，页面并没有更新。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这个问题其实不用太担心，虽然我们的资源都被缓存了，但是</span></span></span><span><span><code><span>sw.js</span></code></span></span><span><span><span>本身是不会被缓存的。即使我们在下一次更新中，删除了页面上注册 Service Worker 的代码，已经注册的 Service Worker 也会一直激活，直到我们主动的删除它。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于一般的 SPA 项目，上线后资源一般是不变的，如果我们希望更新页面，只需要更新</span></span></span><span><span><code><span>sw.js</span></code></span></span><span><span><span>就好。当注册的 Service Worker 文件发生变化时，浏览器会自动下载新的 Service Worker 文件，并在下一次访问页面时激活新的 Service Worker。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>更新文件需要注意几个问题：</span></span></span></p><div><span>1.</span><span><span><span><strong><span>删除旧缓存：</span></strong></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>示例代码中，在</span></span></span><span><span><code><span>activate</span></code></span></span><span><span><span>阶段，我们执行了删除缓存的逻辑。真实环境中，一般会将</span></span></span><span><span><code><span>cacheName</span></code></span></span><span><span><span>带上版本号，每次更新</span></span></span><span><span><code><span>sw</span></code></span></span><span><span><span>都更新下版本号。这样每次都会将旧缓存删掉，并重新开辟新版本的缓存。各浏览器对于缓存超出后的处理是不同的，例如</span></span></span><span><span><code><span>chrome</span></code></span></span><span><span><span>就是缓存逐出策略。及时的清理缓存，可以防止出现一些奇怪的问题。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">const</span></span><span><span> version </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'v1'</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> preCacheName </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'pre-cache-'</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> version</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 将后文调用的 ’my-cache‘的位置替换为 preCacheName</span></span><span><span></span></span></span></code></pre><div><span>2.</span><span><span><span><strong><span>Service Worker 更新不及时：</span></strong></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>同一个域下，只能有一个 Service Worker 被激活，只有所有该域下的页面都关闭了，下一个注册的 Service Worker 才能被激活并取代上一个。对于某些用户来说，这个时间太长了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>因此，我们需要在</span></span></span><span><span><code><span>install</span></code></span></span><span><span><span>事件中，等待</span></span></span><span><span><code><span>precache</span></code></span></span><span><span><span>环节结束后，调用</span></span></span><span><span><code><span>self.skipWaiting();</span></code></span></span><span><span><span>来立即激活新的 Service Worker，但并不会立即接管控制所有客户端（即浏览器标签页）。这意味着旧的 Service Worker 仍然会处理当前打开的页面，直到这些页面被关闭或重新加载。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>为了确保新的 Service Worker 可以立即接管所有客户端，在</span></span></span><span><span><code><span>activate</span></code></span></span><span><span><span>事件中调用</span></span></span><span><span><code><span>clients.claim()</span></code></span></span><span><span><span>方法。这个方法会在新的 Service Worker 激活后，立即接管所有已打开的页面，而不需要等待这些页面重新加载。这样可以确保新的 Service Worker 能够立即生效，提供更新的功能和服务。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>更改完后的代码如下，这样修改后，</span></span></span><span><span><code><span>skipWaiting()</span></code></span></span><span><span><span>和</span></span></span><span><span><code><span>clients.claim()</span></code></span></span><span><span><span>方法会在异步操作完成后被调用，确保新的 Service Worker 在安装完成后立即激活并接管所有客户端。</span></span></span></p><pre><code><span><span><span style="color:#708090">// 安装 Service Worker 时进行预缓存</span></span><span><span>
self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addEventListener</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'install'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  event</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">waitUntil</span></span><span><span style="color:#999999">(</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">async</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">await</span></span><span><span> caches
        </span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">open</span></span><span><span style="color:#999999">(</span></span><span><span>preCacheName</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>cache</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> cache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addAll</span></span><span><span style="color:#999999">(</span></span><span><span>filesToCache</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
          self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">skipWaiting</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 激活 Service Worker</span></span><span><span>
self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addEventListener</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'activate'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  event</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">waitUntil</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">async</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">await</span></span><span><span></span></span><span><span style="color:#dd4a68">clearOutdateResources</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>
    self</span></span><span><span style="color:#999999">.</span></span><span><span>clients</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">claim</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>现在，更新下</span></span></span><span><span><code><span>index.html</span></code></span></span><span><span><span>，然后将上述</span></span></span><span><span><code><span>sw.js</span></code></span></span><span><span><span>的更新保存，接着刷新两次页面 (不要着急，给注册和加载资源一些时间，可以在控制枱中观察下 Service Worker 的活跃状态以及缓存的变化)。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-12-02-17-060ft9bqjUqI5nj5X.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>可以在某个时刻，发现同时存在两个 Service Worker，一个处于激活状态，是我们正在使用的，另一个处于待激活状态，因为正在进行</span></span></span><span><span><code><span>install</span></code></span></span><span><span><span>。此时缓存空间也会同时存在两个版本的缓存，等新的 Service Worker 激活后，就会删除旧缓存。然后就只存在一个最新的 Service Worker 了，同时缓存也只剩一个了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>现在每次用户打开新的页面，</span></span></span></p><ul><li><span><span><span><span>优先从缓存中获取资源</span></span></span></span></li><li><span><span><span><span>如果发现</span></span></span><span><span><code><span>sw</span></code></span></span><span><span><span>文件被更新，安装新的文件</span></span></span></span></li><li><span><span><span><span>文件内会下载新的资源，同时删除旧缓存，并且接管所有页面</span></span></span></span></li><li><span><span><span><span>用户下一次打开新页面或刷新当前页面，就会展示最新的内容</span></span></span></span></li></ul><span id="OSC_h1_7"></span><h1><span><span><span>能力扩展</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>基础操作搞定了。但是上面我们还欠了点技术债，即如果不确定到底有哪些资源，怎么动态的做出缓存。不要着急，现在先进行下扩展阅读。</span></span></span></p><span id="OSC_h3_8"></span><h3><span><span><span>缓存的几种策略</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>当谈到 Service Worker 缓存策略时，有以下几种常见的策略：</span></span></span></p><ul><li><span><span><span><span>Cache First（优先缓存）：首先尝试从缓存中获取响应，如果缓存中存在该资源，则直接返回；如果没有缓存或缓存过期，则向网络发送请求。</span></span></span></span></li><li><span><span><span><span>Network First（优先网络）：首先尝试从网络获取响应，如果网络请求成功，则返回网络响应；如果网络请求失败，则从缓存中获取响应，即使缓存过期也会返回缓存的响应。</span></span></span></span></li><li><span><span><span><span>Cache Only（仅缓存）：只从缓存中获取响应，不向网络发送请求。适用于完全离线可访问的资源。</span></span></span></span></li><li><span><span><span><span>Network Only（仅网络）：只从网络获取响应，不使用缓存。适用于需要实时数据的场景。</span></span></span></span></li><li><span><span><span><span>Stale-While-Revalidate（同时更新和使用缓存）：首先尝试从缓存中获取响应，如果缓存过期，则向网络发送请求获取最新响应，并更新缓存。同时返回缓存的响应，以便快速展示内容。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>上文中我们使用的，就是缓存优先模式。对于不怎么更新或者只有一个仓库的应用来说，使用</span></span></span><span><span><code><span>sw.js</span></code></span></span><span><span><span>文件的更新来说已经足够了。毕竟代码写的越多，bug 就越多。同比，更新的越频繁，系统就越不稳定。</span></span></span></p><span id="OSC_h3_9"></span><h3><span><span><span>Stale-While-Revalidate</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>其他策略如果有兴趣，可以自行搜索，现在我们来讲下动态缓存是怎么实现的。毕竟对于微服务来说，不更新</span></span></span><span><span><code><span>sw</span></code></span></span><span><span><span>是最好的，如果能忘了它就更好了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>上文中我们介绍了</span></span></span><span><span><code><span>Cache First</span></code></span></span><span><span><span>，重新附下代码</span></span></span></p><pre><code><span><span><span style="color:#708090">// 拦截 fetch 事件并从缓存中返回响应</span></span><span><span>
self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addEventListener</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'fetch'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  event</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">respondWith</span></span><span><span style="color:#999999">(</span></span><span><span>
    caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">match</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">.</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> response </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">||</span></span><span><span></span></span><span><span style="color:#dd4a68">fetch</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">.</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>新增一个</span></span></span><span><span><code><span>mock.js</span></code></span></span><span><span><span>，脚本会向 body 中新增一个字符串。将</span></span></span><span><span><code><span>js</span></code></span></span><span><span><span>文件使用</span></span></span><span><span><code><span>script</span></code></span></span><span><span><span>的方式加载。</span></span></span></p><pre><code><span><span><span style="color:#708090">// mock.js</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> div </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> document</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">createElement</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'div'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>
div</span></span><span><span style="color:#999999">.</span></span><span><span>innerText </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'Hello World'</span></span><span><span style="color:#999999">;</span></span><span><span>
document</span></span><span><span style="color:#999999">.</span></span><span><span>body</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">appendChild</span></span><span><span style="color:#999999">(</span></span><span><span>div</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// index.html</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&lt;</span></span><span><span>script src</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#669900">"./mock.js"</span></span><span><span> type</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#669900">"text/javascript"</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&gt;</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&lt;</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">/</span></span><span><span>script</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&gt;</span></span><span><span></span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>同时调整下</span></span></span><span><span><code><span>sw</span></code></span></span><span><span><span>的拦截逻辑。</span></span></span></p><pre><code><span><span><span style="color:#708090">// 新增 runtime 缓存</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> runtimeCacheName </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'runtime-cache-'</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> version</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 符合条件也是缓存优先，但是每次都重新发起网络请求更新缓存</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span></span></span><span><span>isStaleWhileRevalidate</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> url </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> request</span></span><span><span style="color:#999999">.</span></span><span><span>url</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> index </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#999999">[</span></span><span><span style="color:#669900">'http://127.0.0.1:5500/mock.js'</span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">indexOf</span></span><span><span style="color:#999999">(</span></span><span><span>url</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> index </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!==</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-</span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">;</span></span><span><span>

self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addEventListener</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'fetch'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  event</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">respondWith</span></span><span><span style="color:#999999">(</span></span><span><span></span></span><span><span style="color:#708090">// 尝试从缓存中获取响应</span></span><span><span>
    caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">match</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">.</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> fetchPromise </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">fetch</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">.</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>networkResponse</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// 符合匹配条件才克隆响应并将其添加到缓存中</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">isStaleWhileRevalidate</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">.</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> responseToCache </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">clone</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>
          caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">open</span></span><span><span style="color:#999999">(</span></span><span><span>runtimeCacheName</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>cache</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
            cache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">put</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">.</span></span><span><span>request</span></span><span><span style="color:#999999">,</span></span><span><span> responseToCache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">clone</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 返回缓存的响应，然后更新缓存中的响应</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> response </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">||</span></span><span><span> fetchPromise</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>现在每次用户打开新的页面，</span></span></span></p><ul><li><span><span><span><span>优先从缓存中获取资源，同时发起一个网络请求</span></span></span></span></li><li><span><span><span><span>有缓存则直接返回缓存，没有则返回一个</span></span></span><span><span><code><span>fetchPromise</span></code></span></span></span></li><li><span><span><span><code><span>fetchPromise</span></code></span></span><span><span><span>内部更新符合缓存条件的请求</span></span></span></span></li><li><span><span><span><span>用户下一次打开新页面或刷新当前页面，就会展示最新的内容</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>通过修改</span></span></span><span><span><code><span>isStaleWhileRevalidate</span></code></span></span><span><span><span>中 url 的匹配条件，就能够控制是否更新缓存。在上面的示例中，我们可以将</span></span></span><span><span><code><span>index.html</span></code></span></span><span><span><span>从</span></span></span><span><span><code><span>precache</span></code></span></span><span><span><span>列表中移除，放入</span></span></span><span><span><code><span>runtime</span></code></span></span><span><span><span>中，或者专门处理下</span></span></span><span><span><code><span>index.html</span></code></span></span><span><span><span>的放置规则，去更新</span></span></span><span><span><code><span>precache</span></code></span></span><span><span><span>中的缓存。最好不要出现多个缓存桶中存在同一个</span></span></span><span><span><code><span>request</span></code></span></span><span><span><span>的缓存，那样就不知道走的到底是哪个缓存了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>一般来说，微前端的应用，资源文件都有个固定的存放位置，文件本身通过在文件名上增加</span></span></span><span><span><code><span>hash</span></code></span></span><span><span><span>或版本号来进行区分。我们在</span></span></span><span><span><code><span>isStaleWhileRevalidate</span></code></span></span><span><span><span>函数中匹配存放资源位置的路径，这样用户在第二次打开页面时，就可以直接使用缓存了。如果是内嵌页面，可以与平台沟通，是否可以在应用冷起的时候，偷偷访问一个资源页面，提前进行预加载，这样就能在首次打开的时候也享受本地缓存了。</span></span></span></p><span id="OSC_h3_10"></span><h3><span><span><span>缓存过期</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>即使我们缓存了一些资源文件，例如 Iconfont、字体库等只会更新自身内容，但不会变化名称的文件。仅使用</span></span></span><span><span><code><span>Stale-While-Revalidate</span></code></span></span><span><span><span>其实也是可以的。用户会在第二次打开页面时看到最新的内容。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>但为了提高一些体验，例如，用户半年没打开页面了，突然在今天打开了一下，展示历史的内容就不太合适了，这时候可以增加一个缓存过期的策略。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果我们使用的是</span></span></span><span><span><code><span>Workbox</span></code></span></span><span><span><span>，通过使用</span></span></span><span><span><code><span>ExpirationPlugin</span></code></span></span><span><span><span>来实现的。</span></span></span><span><span><code><span>ExpirationPlugin</span></code></span></span><span><span><span>是</span></span></span><span><span><code><span>Workbox</span></code></span></span><span><span><span>中的一个缓存插件，它允许为缓存条目设置过期时间。示例如下所示</span></span></span></p><pre><code><span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span> registerRoute </span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">from</span></span><span><span></span></span><span><span style="color:#669900">'workbox-routing'</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span> CacheFirst</span></span><span><span style="color:#999999">,</span></span><span><span> StaleWhileRevalidate </span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">from</span></span><span><span></span></span><span><span style="color:#669900">'workbox-strategies'</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span> ExpirationPlugin </span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">from</span></span><span><span></span></span><span><span style="color:#669900">'workbox-expiration'</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 设置缓存的有效期为一小时</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> cacheExpiration </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  maxAgeSeconds</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span></span></span><span><span style="color:#990055">60</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#990055">60</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#708090">// 一小时</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 使用 CacheFirst 策略，并应用 ExpirationPlugin</span></span><span><span></span></span><span><span style="color:#dd4a68">registerRoute</span></span><span><span style="color:#999999">(</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>{ request }</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span> request</span></span><span><span style="color:#999999">.</span></span><span><span>destination </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">===</span></span><span><span></span></span><span><span style="color:#669900">'image'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">CacheFirst</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">{</span></span><span><span>
    cacheName</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span></span></span><span><span style="color:#669900">'image-cache'</span></span><span><span style="color:#999999">,</span></span><span><span>
    plugins</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span></span></span><span><span style="color:#999999">[</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">ExpirationPlugin</span></span><span><span style="color:#999999">(</span></span><span><span>cacheExpiration</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 使用 StaleWhileRevalidate 策略，并应用 ExpirationPlugin</span></span><span><span></span></span><span><span style="color:#dd4a68">registerRoute</span></span><span><span style="color:#999999">(</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>{ request }</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span> request</span></span><span><span style="color:#999999">.</span></span><span><span>destination </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">===</span></span><span><span></span></span><span><span style="color:#669900">'script'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">StaleWhileRevalidate</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">{</span></span><span><span>
    cacheName</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span></span></span><span><span style="color:#669900">'script-cache'</span></span><span><span style="color:#999999">,</span></span><span><span>
    plugins</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span></span></span><span><span style="color:#999999">[</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">ExpirationPlugin</span></span><span><span style="color:#999999">(</span></span><span><span>cacheExpiration</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>或者我们可以实现一下自己的缓存过期策略。首先是增加缓存过期时间。在原本的更新缓存的基础上，设置自己的</span></span></span><span><span><code><span>cache-control</span></code></span></span><span><span><span>，然后再放入缓存中。示例中直接删除了原本的</span></span></span><span><span><code><span>cache-control</span></code></span></span><span><span><span>，真正使用中，需要判断下，比如</span></span></span><span><span><code><span>no-cache</span></code></span></span><span><span><span>类型的资源，就不要使用缓存了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>每次命中缓存时，都会判断下是否过期，如果过期，则直接返回从网络中获取的最新的请求，并更新缓存。</span></span></span></p><pre><code><span><span><span>self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addEventListener</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'fetch'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  event</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">respondWith</span></span><span><span style="color:#999999">(</span></span><span><span></span></span><span><span style="color:#708090">// 尝试从缓存中获取响应</span></span><span><span>
    caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">match</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">.</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> fetchPromise </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">fetch</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">.</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>networkResponse</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">isStaleWhileRevalidate</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">.</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// 检查响应的状态码是否为成功</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>networkResponse</span></span><span><span style="color:#999999">.</span></span><span><span>status </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">===</span></span><span><span></span></span><span><span style="color:#990055">200</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// 克隆响应并将其添加到缓存中</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> clonedResponse </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">clone</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 在存储到缓存之前，设置正确的缓存头部</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> headers </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Headers</span></span><span><span style="color:#999999">(</span></span><span><span>networkResponse</span></span><span><span style="color:#999999">.</span></span><span><span>headers</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>
            headers</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">delete</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'cache-control'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>
            headers</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">append</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'cache-control'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'public, max-age=3600'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 设置缓存有效期为 1 小时</span></span><span><span></span></span><span><span style="color:#708090">// 创建新的响应对象并存储到缓存中</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> cachedResponse </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Response</span></span><span><span style="color:#999999">(</span></span><span><span>clonedResponse</span></span><span><span style="color:#999999">.</span></span><span><span>body</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
              status</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">.</span></span><span><span>status</span></span><span><span style="color:#999999">,</span></span><span><span>
              statusText</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">.</span></span><span><span>statusText</span></span><span><span style="color:#999999">,</span></span><span><span>
              headers</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span> headers</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>

            caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">open</span></span><span><span style="color:#999999">(</span></span><span><span>runtimeCacheName</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span>cache</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
              cache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">put</span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">.</span></span><span><span>request</span></span><span><span style="color:#999999">,</span></span><span><span> cachedResponse</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 检查缓存的响应是否存在且未过期</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>response </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&amp;&amp;</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!</span></span><span><span style="color:#dd4a68">isExpired</span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> response</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 返回缓存的响应</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> fetchPromise</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#dd4a68">isExpired</span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// 从响应的 headers 中获取缓存的有效期信息</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> cacheControl </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> response</span></span><span><span style="color:#999999">.</span></span><span><span>headers</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">get</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'cache-control'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>cacheControl</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> maxAgeMatch </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> cacheControl</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">match</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#ee9900">/max-age=(\d+)/</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>maxAgeMatch</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> maxAgeSeconds </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">parseInt</span></span><span><span style="color:#999999">(</span></span><span><span>maxAgeMatch</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#990055">10</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> requestTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> Date</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">parse</span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">.</span></span><span><span>headers</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">get</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'date'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> expirationTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> requestTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> maxAgeSeconds </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#990055">1000</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 检查当前时间是否超过了缓存的有效期</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>Date</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">now</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&lt;</span></span><span><span> expirationTime</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#990055">false</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 未过期</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#990055">true</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 已过期</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span></span></code></pre><blockquote><span><span><span>从 Service Worker 发起的请求，可能会被浏览器自身的内存缓存或硬盘缓存捕获，然后直接返回。</span></span></span></blockquote><span id="OSC_h3_11"></span><h3><span><span><span>精确清理缓存</span></span></span></h3><blockquote><span><span><span>下面的内容，默认为微前端应用。</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>随着微前端应用的更新，会逐渐出现失效的资源文件一直出现在缓存中，时间长了可能会导致缓存溢出。</span></span></span></p><span id="OSC_h4_12"></span><h4><span><span><span>定时更新</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如以半年为期限，定期更新</span></span></span><span><span><code><span>sw</span></code></span></span><span><span><span>文件的版本号，每次更新都会一刀切的将上一个版本中的</span></span></span><span><span><strong><span>动态缓存</span></strong></span></span><span><span><span>干掉，此操作会导致下次加载变慢，因为会重新通过网络请求的方式加载来创建缓存。但如果更新频率控制得当，并且资源拆分合理，用户感知不会很大。</span></span></span></p><span id="OSC_h4_13"></span><h4><span><span><span>处理不常用缓存</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>上文中的缓存过期策略，并不适用于此处。因为微服务中资源文件中，只要文件名不变，内容就应该不变。我们只是期望删除超过一定时间没有使用的条目，防止缓存溢出。这里也使用</span></span></span><span><span><code><span>Stale-While-Revalidate</span></code></span></span><span><span><span>的原因是为了帮助我们识别长期不使用的</span></span></span><span><span><code><span>js</span></code></span></span><span><span><span>文件，方便删除。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>本来可以使用</span></span></span><span><span><code><span>self.registration.periodicSync.register</span></code></span></span><span><span><span>来创建一个周期性任务，但是由于兼容性问题，放弃了。需要的可自行研究，附上</span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FPeriodicSyncManager" target="_blank" rel="nofollow"><span><span><span>网址</span></span></span></a><span><span><span>。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这里我们换一个条件。每当有网络请求被触发时，启动一个延迟 20s 的</span></span></span><span><span><code><span>debounce</span></code></span></span><span><span><span>函数，来处理缓存问题。先把之前的清除旧版本缓存的函数改名成</span></span></span><span><span><code><span>clearOldResources</span></code></span></span><span><span><span>。然后设定缓存过期时间为 10s，刷新两次页面来触发网路请求，20s 之后，</span></span></span><span><span><code><span>runtime</span></code></span></span><span><span><span>缓存中的</span></span></span><span><span><code><span>mock.js</span></code></span></span><span><span><span>就会被删除了。真实场景下，延迟函数和缓存过期都不会这么短，可以设置成 5min 和 3 个月。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#dd4a68">debounce</span></span><span><span style="color:#999999">(</span></span><span><span>func, delay</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">let</span></span><span><span> timerId</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>...args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">clearTimeout</span></span><span><span style="color:#999999">(</span></span><span><span>timerId</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>

    timerId </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">setTimeout</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">func</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">apply</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">,</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">,</span></span><span><span> delay</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> clearOutdateResources </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">debounce</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  cache
    </span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">open</span></span><span><span style="color:#999999">(</span></span><span><span>runtimeCacheName</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">keys</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>requests</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
      requests</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">forEach</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
        cache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">match</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// response 为匹配到的 Response 对象</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">isExpiredWithTime</span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#990055">10</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
            cache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">delete</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#dd4a68">isExpiredWithTime</span></span><span><span style="color:#999999">(</span></span><span><span>response, time</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> requestTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> Date</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">parse</span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">.</span></span><span><span>headers</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">get</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'date'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!</span></span><span><span>requestTime</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#990055">false</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> expirationTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> requestTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> time </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#990055">1000</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 检查当前时间是否超过了缓存的有效期</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>Date</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">now</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&lt;</span></span><span><span> expirationTime</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#990055">false</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 未过期</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#990055">true</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 已过期</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>重新总结下微前端应用下的缓存配置：</span></span></span></p><div><span>1.</span><span><span><span><span>使用版本号，并初始化</span></span></span><span><span><code><span>preCache</span></code></span></span><span><span><span>和</span></span></span><span><span><code><span>runtimeCache</span></code></span></span></span></div><div><span style="color:var(--vscode-textPreformat-foreground)">2.</span><span><span><span><code><span>preCache</span></code></span></span><span><span><span>中预缓存基座数据，使用</span></span></span><span><span><code><span>Cache First</span></code></span></span><span><span><span>策略，</span></span></span><span><span><code><span>sw</span></code></span></span><span><span><span>不更新则基座数据不更新</span></span></span></span></div><div><span style="color:var(--vscode-textPreformat-foreground)">3.</span><span><span><span><code><span>runtimeCache</span></code></span></span><span><span><span>使用</span></span></span><span><span><code><span>Stale-While-Revalidate</span></code></span></span><span><span><span>策略负责动态缓存业务资源的数据，每次访问页面都动态更新一次</span></span></span></span></div><div><span>4.</span><span><span><span><span>使用</span></span></span><span><span><code><span>debounce</span></code></span></span><span><span><span>函数，每次访问页面都会延迟清除过期的缓存</span></span></span></span></div><div><span>5.</span><span><span><span><span>如果需要更新</span></span></span><span><span><code><span>preCache</span></code></span></span><span><span><span>中的基座数据，则需要升级版本号并重新安装</span></span></span><span><span><code><span>sw</span></code></span></span><span><span><span>文件。新服务激活后会删除上一个版本的数据</span></span></span></span></div><div><span style="color:var(--vscode-textPreformat-foreground)">6.</span><span><span><span><code><span>runtimeCache</span></code></span></span><span><span><span>和</span></span></span><span><span><code><span>preCache</span></code></span></span><span><span><span>不能同时存储一个资源，否则可能导致混乱。</span></span></span></span></div><span id="OSC_h1_14"></span><h1><span><span><span>最终示例</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下面是最终的</span></span></span><span><span><code><span>sw.js</span></code></span></span><span><span><span>，我删除掉了缓存过期的逻辑，如有需要请自行从上文代码中获取。顺便我增加了一点点丧心病狂的错误处理逻辑。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>理论上，</span></span></span><span><span><code><span>index.html</span></code></span></span><span><span><span>应该放入预缓存的列表里，但我懒得写在</span></span></span><span><span><code><span>Stale-While-Revalidate</span></code></span></span><span><span><span>里分别更新</span></span></span><span><span><code><span>preCache</span></code></span></span><span><span><span>和</span></span></span><span><span><code><span>runtimeCache</span></code></span></span><span><span><span>了，相信看完上面内容的你，一定可以自己实现对应逻辑。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果你用了下面的文件，每次刷新完页面的 20s 后，runtime 的缓存就会被清空，因为我们过期时间只设置了 10s。而每次发起请求后的 20s 后就会进行过期判断。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在真实的验证过程中，有部分</span></span></span></p><pre><code><span><span><span style="color:#0077aa">const</span></span><span><span> version </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'v1'</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> preCacheName </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'pre-cache-'</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> version</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> runtimeCacheName </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'runtime-cache'</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// runtime 不进行整体清除</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> filesToCache </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 这里将 index.html 放到动态缓存里了，为了搭自动更新的便车。这个小项目也没别的需要预缓存的了</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> maxAgeSeconds </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">10</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 缓存过期时间，单位 s</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> debounceClearTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">20</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 延迟清理缓存时间，单位 s</span></span><span><span></span></span><span><span style="color:#708090">// 符合条件也是缓存优先，但是每次都重新发起网络请求更新缓存</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span></span></span><span><span>isStaleWhileRevalidate</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> url </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> request</span></span><span><span style="color:#999999">.</span></span><span><span>url</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> index </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#999999">[</span></span><span><span>`${self.location.origin}/mock.js`</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span>`${self.location.origin}/index.html`</span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">indexOf</span></span><span><span style="color:#999999">(</span></span><span><span>url</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> index </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!==</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-</span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">/*********************上面是配置代码***************************** */</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span></span></span><span><span>addResourcesToCache</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">async</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">open</span></span><span><span style="color:#999999">(</span></span><span><span>preCacheName</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span>cache</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> cache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addAll</span></span><span><span style="color:#999999">(</span></span><span><span>filesToCache</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 安装 Service Worker 时进行预缓存</span></span><span><span>
self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addEventListener</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'install'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  event</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">waitUntil</span></span><span><span style="color:#999999">(</span></span><span><span></span></span><span><span style="color:#dd4a68">addResourcesToCache</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
      self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">skipWaiting</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 删除上个版本的数据</span></span><span><span></span></span><span><span style="color:#0077aa">async</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#dd4a68">clearOldResources</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">keys</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>cacheNames</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> Promise</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">all</span></span><span><span style="color:#999999">(</span></span><span><span>
      cacheNames
        </span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">filter</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>cacheName</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!</span></span><span><span style="color:#999999">[</span></span><span><span>preCacheName</span></span><span><span style="color:#999999">,</span></span><span><span> runtimeCacheName</span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">includes</span></span><span><span style="color:#999999">(</span></span><span><span>cacheName</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">map</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>cacheName</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">delete</span></span><span><span style="color:#999999">(</span></span><span><span>cacheName</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#708090">// 激活 Service Worker</span></span><span><span>
self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addEventListener</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'activate'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  event</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">waitUntil</span></span><span><span style="color:#999999">(</span></span><span><span></span></span><span><span style="color:#dd4a68">clearOldResources</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">finally</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
      self</span></span><span><span style="color:#999999">.</span></span><span><span>clients</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">claim</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#dd4a68">clearOutdateResources</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 缓存优先</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span></span></span><span><span>isCacheFirst</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> url </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> request</span></span><span><span style="color:#999999">.</span></span><span><span>url</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> index </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> filesToCache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">findIndex</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span>u</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span> url</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">includes</span></span><span><span style="color:#999999">(</span></span><span><span>u</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> index </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!==</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-</span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#dd4a68">addToCache</span></span><span><span style="color:#999999">(</span></span><span><span>cacheName, request, response</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">try</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
    caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">open</span></span><span><span style="color:#999999">(</span></span><span><span>cacheName</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span>cache</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
      cache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">put</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">,</span></span><span><span> response</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">catch</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>error</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
    console</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">error</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'add to cache error =&gt;'</span></span><span><span style="color:#999999">,</span></span><span><span> error</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">async</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#dd4a68">cacheFirst</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">try</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> caches
      </span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">match</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> response</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#dd4a68">fetch</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// 检查是否成功获取到响应</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!</span></span><span><span>response </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">||</span></span><span><span> response</span></span><span><span style="color:#999999">.</span></span><span><span>status </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!==</span></span><span><span></span></span><span><span style="color:#990055">200</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> response</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 返回原始响应</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> clonedResponse </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> response</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">clone</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#dd4a68">addToCache</span></span><span><span style="color:#999999">(</span></span><span><span>runtimeCacheName</span></span><span><span style="color:#999999">,</span></span><span><span> request</span></span><span><span style="color:#999999">,</span></span><span><span> clonedResponse</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> response</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">catch</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
        console</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">error</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'match in cacheFirst error'</span></span><span><span style="color:#999999">,</span></span><span><span> error</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#dd4a68">fetch</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">catch</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>error</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
    console</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">error</span></span><span><span style="color:#999999">(</span></span><span><span>error</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#dd4a68">fetch</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#708090">// 缓存优先，同步更新</span></span><span><span></span></span><span><span style="color:#0077aa">async</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#dd4a68">handleFetch</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">try</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">clearOutdateResources</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 尝试从缓存中获取响应</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">match</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> fetchPromise </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">fetch</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>networkResponse</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// 检查响应的状态码是否为成功</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!</span></span><span><span>networkResponse </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">||</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">.</span></span><span><span>status </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!==</span></span><span><span></span></span><span><span style="color:#990055">200</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#708090">// 克隆响应并将其添加到缓存中</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> clonedResponse </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">clone</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#dd4a68">addToCache</span></span><span><span style="color:#999999">(</span></span><span><span>runtimeCacheName</span></span><span><span style="color:#999999">,</span></span><span><span> request</span></span><span><span style="color:#999999">,</span></span><span><span> clonedResponse</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 返回缓存的响应，然后更新缓存中的响应</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> response </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">||</span></span><span><span> fetchPromise</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">catch</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>error</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
    console</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">error</span></span><span><span style="color:#999999">(</span></span><span><span>error</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#dd4a68">fetch</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span>

self</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">addEventListener</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'fetch'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>event</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span> request </span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> event</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">isCacheFirst</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
    event</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">respondWith</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">cacheFirst</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">isStaleWhileRevalidate</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
    event</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">respondWith</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">handleFetch</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#dd4a68">debounce</span></span><span><span style="color:#999999">(</span></span><span><span>func, delay</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">let</span></span><span><span> timerId</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>...args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">clearTimeout</span></span><span><span style="color:#999999">(</span></span><span><span>timerId</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>

    timerId </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">setTimeout</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">func</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">apply</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">,</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">,</span></span><span><span> delay</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> clearOutdateResources </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">debounce</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">try</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
    caches</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">open</span></span><span><span style="color:#999999">(</span></span><span><span>runtimeCacheName</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span>cache</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
      cache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">keys</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>requests</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
        requests</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">forEach</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
          cache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">match</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> isExpired </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">isExpiredWithTime</span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">,</span></span><span><span> maxAgeSeconds</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>isExpired</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
              cache</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">delete</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">catch</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>error</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
    console</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">error</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'clearOutdateResources error =&gt; '</span></span><span><span style="color:#999999">,</span></span><span><span> error</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">,</span></span><span><span> debounceClearTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#990055">1000</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#dd4a68">isExpiredWithTime</span></span><span><span style="color:#999999">(</span></span><span><span>response, time</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> requestTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> Date</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">parse</span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">.</span></span><span><span>headers</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">get</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'date'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!</span></span><span><span>requestTime</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#990055">false</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> expirationTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> requestTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> time </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#990055">1000</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 检查当前时间是否超过了缓存的有效期</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>Date</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">now</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&lt;</span></span><span><span> expirationTime</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#990055">false</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 未过期</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#990055">true</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 已过期</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span></span></code></pre><span id="OSC_h3_15"></span><h3><span><span><strong><span>注意</span></strong></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在真实的验证过程中，有部分资源获取不到</span></span></span><span><span><code><span>date</span></code></span></span><span><span><span>这个数据，因此为了保险，我们还是在存入缓存时，自己补充一个存入时间</span></span></span></p><pre><code><span><span><span></span></span><span><span style="color:#708090">// 克隆响应并将其添加到缓存中</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> clonedResponse </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">clone</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 在存储到缓存之前，设置正确的缓存头部</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> headers </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Headers</span></span><span><span style="color:#999999">(</span></span><span><span>networkResponse</span></span><span><span style="color:#999999">.</span></span><span><span>headers</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>

headers</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">append</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'sw-save-date'</span></span><span><span style="color:#999999">,</span></span><span><span> Date</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">now</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 创建新的响应对象并存储到缓存中</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> cachedResponse </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Response</span></span><span><span style="color:#999999">(</span></span><span><span>clonedResponse</span></span><span><span style="color:#999999">.</span></span><span><span>body</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
  status</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">.</span></span><span><span>status</span></span><span><span style="color:#999999">,</span></span><span><span>
  statusText</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span> networkResponse</span></span><span><span style="color:#999999">.</span></span><span><span>statusText</span></span><span><span style="color:#999999">,</span></span><span><span>
  headers</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span> headers</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在判断过期时，取我们自己写入的</span></span></span><span><span><code><span>key</span></code></span></span><span><span><span>即可。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#dd4a68">isExpiredWithTime</span></span><span><span style="color:#999999">(</span></span><span><span>response, time</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> requestTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">Number</span></span><span><span style="color:#999999">(</span></span><span><span>response</span></span><span><span style="color:#999999">.</span></span><span><span>headers</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">get</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'sw-save-date'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!</span></span><span><span>requestTime</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#990055">false</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">var</span></span><span><span> expirationTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> requestTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> time </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#990055">1000</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 检查当前时间是否超过了缓存的有效期</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>Date</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">now</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&lt;</span></span><span><span> expirationTime</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#990055">false</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 未过期</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#990055">true</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 已过期</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h3_16"></span><h3><span><span><span>不可见响应</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>还记得上面为了安全考虑，在存入缓存时，对响应的状态做了判断，非 200 的都不缓存。然后就又发现异常场景了。</span></span></span></p><pre><code><span><span><span></span></span><span><span style="color:#708090">// 检查是否成功获取到响应</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!</span></span><span><span>response </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">||</span></span><span><span> response</span></span><span><span style="color:#999999">.</span></span><span><span>status </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!==</span></span><span><span></span></span><span><span style="color:#990055">200</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> response</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 返回原始响应</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><code><span>opaque</span></code></span></span><span><span><span> 响应通常指的是跨源请求（CORS）中的一种情况，在该情况下，浏览器出于安全考虑，不允许访问服务端返回的响应内容。</span></span></span><span><span><code><span>opaque</span></code></span></span><span><span><span> 响应通常发生在服务工作者（Service Workers）进行的跨源请求中，且没有 CORS 头部的情况下。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><code><span>opaque</span></code></span></span><span><span><span> 响应的特征是：</span></span></span></p><ul><li><span><span><span><span>响应的内容无法被 JavaScript 访问。</span></span></span></span></li><li><span><span><span><span>响应的大小无法确定，因此 Chrome 开发者工具中会显示为 (opaque)。</span></span></span></span></li><li><span><span><span><span>响应的状态码通常是 0，即使实际上服务器可能返回了不同的状态码。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>因此我们需要做一些补充动作。不单是补充</span></span></span><span><span><code><span>cors</span></code></span></span><span><span><span>模式，还得同步设置下</span></span></span><span><span><code><span>credentials</span></code></span></span><span><span><span>。</span></span></span></p><pre><code><span><span><span></span></span><span><span style="color:#0077aa">const</span></span><span><span> newRequest </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span>
  request</span></span><span><span style="color:#999999">.</span></span><span><span>url </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">===</span></span><span><span></span></span><span><span style="color:#669900">'index.html'</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">?</span></span><span><span> request
    </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Request</span></span><span><span style="color:#999999">(</span></span><span><span>request</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span> mode</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span></span></span><span><span style="color:#669900">'cors'</span></span><span><span style="color:#999999">,</span></span><span><span> credentials</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span></span></span><span><span style="color:#669900">'omit'</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 Service Workers 发起网络请求时，如果页面本身需要认证，那就像上面代码那样，对页面请求做个判断。</span></span></span><span><span><code><span>request.url === 'index.html'</span></code></span></span><span><span><span>是我写的示例，真实请求中，需要拼出完整的 url 路径。而对于资源文件，走非认证的</span></span></span><span><span><code><span>cors</span></code></span></span><span><span><span>请求即可。将请求的</span></span></span><span><span><code><span>request</span></code></span></span><span><span><span>改为我们变更后的</span></span></span><span><span><code><span>newRequest</span></code></span></span><span><span><span>，请求资源就可以正常的被缓存了。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">var</span></span><span><span> fetchPromise </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">fetch</span></span><span><span style="color:#999999">(</span></span><span><span>newRequest</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">function</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>networkResponse</span></span><span><span style="color:#999999">)</span></span></span></code></pre><span id="OSC_h1_17"></span><h1><span><span><span>销毁</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>离线缓存用得好升职加薪，用不好就删库跑路。除了上面的一点点的防错逻辑，整体的降级方案一定要有。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>看到这里，应该已经忘了 Service Worker 是如何被注册上的吧。没事，我们看个新的脚本。在原本的基础上，我们加了个变量</span></span></span><span><span><code><span>SW_FALLBACK</span></code></span></span><span><span><span>，如果离线缓存出问题了，赶紧到管理后台，把对应的值改成</span></span></span><span><span><code><span>true</span></code></span></span><span><span><span>。让用户多刷新两次就好了。只要不是彻底的崩溃导致</span></span></span><span><span><code><span>html</span></code></span></span><span><span><span>无法更新，这个方案就没问题。</span></span></span></p><pre><code><span><span><span style="color:#708090">// 如果有问题，将此值改成 true</span></span><span><span></span></span><span><span style="color:#990055">SW_FALLBACK</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">false</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'serviceWorker'</span></span><span><span></span></span><span><span style="color:#0077aa">in</span></span><span><span> navigator</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">!</span></span><span><span style="color:#990055">SW_FALLBACK</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
    navigator</span></span><span><span style="color:#999999">.</span></span><span><span>serviceWorker
      </span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">register</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'/eemf-service-worker.js'</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span>registration</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
        console</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">log</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'Service Worker 注册成功！'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">catch</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span>error</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
        console</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">log</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'Service Worker 注册失败：'</span></span><span><span style="color:#999999">,</span></span><span><span> error</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">else</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
    navigator</span></span><span><span style="color:#999999">.</span></span><span><span>serviceWorker</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">getRegistration</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">'/'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">then</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span>reg</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
      reg </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&amp;&amp;</span></span><span><span> reg</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">unregister</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span style="color:#999999">(</span></span><span><span>reg</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">{</span></span><span><span>
        window</span></span><span><span style="color:#999999">.</span></span><span><span>location</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">reload</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于没有管理后台配置</span></span></span><span><span><code><span>html</span></code></span></span><span><span><span>的项目，可以将上面的脚本移动到</span></span></span><span><span><code><span>sw-register.js</span></code></span></span><span><span><span>的脚本中，在</span></span></span><span><span><code><span>html</span></code></span></span><span><span><span>以</span></span></span><span><span><code><span>script</span></code></span></span><span><span><span>的形式加载该脚本，并将该文件缓存设置为</span></span></span><span><span><code><span>no-cache</span></code></span></span><span><span><span>，也不要在</span></span></span><span><span><code><span>sw</span></code></span></span><span><span><span>中缓存该文件。这样出问题后，覆写下该文件即可。</span></span></span></p><span id="OSC_h1_18"></span><h1><span><span><span>总结</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>所有要说的，在上面都说完了。PWA 的离线方案，是一种很好的解决方案，但是也有其局限性。本项目所用的 demo 已经上传到了</span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsuilang%2FPWA-demo" target="_blank" rel="nofollow"><span><span><span>github</span></span></span></a><span><span><span>，可自行查看。</span></span></span></p><span id="OSC_h1_19"></span><h1><span><span><span>参考文档</span></span></span></h1><ul><li><span><span><span><span>﻿</span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FService_Worker_API" target="_blank" rel="nofollow"><span><span><span>Service Worker</span></span></span></a><span><span><span>﻿</span></span></span></span></li><li><span><span><span><span>﻿</span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fworkbox%2Fservice-worker-overview%2F" target="_blank" rel="nofollow"><span><span><span>Service worker overview</span></span></span></a><span><span><span>﻿</span></span></span></span></li><li><span><span><span><span>﻿</span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ftools%2Fworkbox" target="_blank" rel="nofollow"><span><span><span>Workbox</span></span></span></a><span><span><span>﻿</span></span></span></span></li><li><span><span><span><span>GPT 问答</span></span></span></span></li></ul><blockquote><p>作者：CHO 张鹏程</p><p>来源：京东云开发者社区，转载请注明来源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Sun, 17 Dec 2023 03:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10320663</guid>
            <link>https://my.oschina.net/u/4090830/blog/10320663</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[商汤科技创始人汤晓鸥离世，享年 55 岁]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>12 月 16 日，腾讯新闻报道称，商汤科技董事长、人工智能科学家汤晓鸥于 12 月 15 日在睡梦中不幸离世，享年 55 岁。</p><p>汤晓鸥主要从事计算机视觉相关领域的研究，包括多媒体、计算机视觉、模式识别及视频处理，是全球人脸识别技术的「开拓者」和「探路者」。</p><blockquote><p><img height="1272" src="https://static.oschina.net/uploads/space/2023/1216/153402_su2B_2720166.png" width="1442" referrerpolicy="no-referrer"></p><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fview.inews.qq.com%2Fa%2F20231216A051VT00" target="_blank"><span style="background-color:rgba(0, 0, 0, 0); color:inherit">https://</span>view.inews.qq.com/a/20231216A051<span style="background-color:rgba(0, 0, 0, 0); color:inherit">VT00</span></a></u></em></p></blockquote><p>最早的网传消息：</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1216/153606_97lp_2720166.png" referrerpolicy="no-referrer"></p><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1644054135%2FNxokl6vOQ%3Fpagetype%3Dprofilefeed" target="_blank">https://weibo.com/1644054135/Nxokl6vOQ</a></u></em></p></blockquote><p>公开信息显示，汤晓鸥 1968 年出生于辽宁鞍山，香港中文大学信息工程学系教授、工程学院杰出学人。汤晓鸥于 1990 年从中国科学技术大学毕业；1991 年获得美国罗切斯特大学硕士学位；1996 年获得麻省理工学院博士学位，之后进入香港中文大学工作；2001 年创立了香港中文大学多媒体实验室；2005 年至 2007 年在微软亚洲研究院工作，担任视觉计算组主任；2008 年在深圳先进技术研究院多媒体集成技术研究室工作，担任主任和研究员。</p><p><img height="457" src="https://oscimg.oschina.net/oscnet/up-a417892a92b7c38cf49b69a36526d033f48.png" width="300" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#333333">汤晓鸥指导的博士生何恺明是深度残差网络 (ResNets) 的主要开发者。深度残差网络</span>使神经网络能够达到前所未有的深度，获得以前难以实现的能力，促成了多个突破性的成果——包括 AlphaGo、AlphaFold 和 ChatGPT，为人工智能做出了基础性贡献。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 16 Dec 2023 07:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271336</guid>
            <link>https://www.oschina.net/news/271336</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 设立 1000 万美元基金，支持超人类 AI 风险研究]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">OpenAI <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Fblog%2Fsuperalignment-fast-grants" target="_blank">宣布</a>与 Eric Schmidt 合作，启动了一项 1000 万美元的新资助计划，以支持技术研究，确保超人类人工智能（superhuman AI）系统的一致性和安全性。</span></p><p><span style="color:#000000">「<span style="background-color:#ffffff">我们相信超级智能可能在未来十年内到来。这些人工智能系统将拥有巨大的能力 —— 它们可能带来巨大的好处，但也可能带来巨大的风险。</span>」</span></p><p><img height="249" src="https://oscimg.oschina.net/oscnet/up-76bbf42b019b3dacb6d1b9184ea8dcc692a.png" width="700" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">该公司表示，当前确保 AI 系统安全的手段主要是依赖于人工监督的对齐技术（例如 RLHF）。但超</span>人类&nbsp;AI&nbsp;<span style="background-color:#ffffff">系统将能够执行人类无法完全理解的复杂且富有创造性的行为。例如，如果一个超人模型生成一百万行极其复杂的代码，人类将无法可靠地评估这些代码执行起来是安全还是危险，现有的技术可能不再够用。&nbsp;</span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">「这就引出了一个根本性的挑战：人类如何引导和信任比自己聪明得多的人工智能系统？这是世界上尚未解决的最重要的技术问题之一。但我们认为，只要齐心协力，这个问题是可以解决的。现存<span style="background-color:#ffffff">许多有希望的方法和令人兴奋的方向，以及许多唾手可得的成果。</span>」</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">作为其 Superalignment 项目的一部分，OpenAI 推出的这一资助计划旨在：</span></p><ul><li style="text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">向学术实验室、非营利组织和个人研究人员捐赠 10 万至 200 万美元</span></span></li><li style="text-align:start"><span style="color:#000000">并<span style="background-color:#ffffff">为研究生推出为期一年的 15 万美元奖学金（一半将用于研究经费，另一半将作为津贴）</span></span></li></ul><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">根据 OpenAI 的说法，申请这一资助资金的研究人员不要求有对齐工作的经验，他们已准备好为尚未在这方面做过任何工作的研究人员提供支持。</span></span><span><span><span><span style="color:#585858"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fairtable.com%2FappnIXmOlWAJBzrJp%2FpaghnoKL6EHiKmKbf%2Fform" target="_blank"><span><span><span>申请</span></span></span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="color:#000000"><span style="background-color:#ffffff">将持续开放至 2 月 18 日，申请人将在申请截止日期后四个星期内收到回复。&nbsp;</span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fairtable.com%2FappnIXmOlWAJBzrJp%2FpaghnoKL6EHiKmKbf%2Fform" target="_blank">申请表单</a></strong></p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 16 Dec 2023 03:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271307/openai-superalignment-grant-fund</guid>
            <link>https://www.oschina.net/news/271307/openai-superalignment-grant-fund</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[今年我国语言大模型市场增长率将超 100%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#222222">据央视新闻报道，工业和信息化部赛迪研究院数据显示，2023 年我国语言大模型市场规模实现较快提升，应用场景不断丰富，增长率有望突破 100%。</span></p><p><span style="background-color:#ffffff; color:#222222">工业和信息化部赛迪研究院数据显示，目前，我国已有超过 19 个语言大模型研发厂商，其中，15 家厂商的模型产品已经通过备案，预计今年我国语言大模型市场规模将达到 132.3 亿元，增长率将达到 110%。</span></p><p><span style="background-color:#ffffff; color:#222222">语言大模型能够模仿人类的对话和决策能力，是率先实现技术突破和应用落地的大模型，是当下人工智能的主赛道，在金融、医疗、教育、工业、游戏、法律等多个行业应用广泛。专家预测，到 2027 年，我国语言大模型市场规模有望达到 600 亿元。</span></p><p><img height="273" src="https://oscimg.oschina.net/oscnet/up-256c6498333f3d9198b73f867a58b33c90d.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 16 Dec 2023 03:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271303</guid>
            <link>https://www.oschina.net/news/271303</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Prompt flow —— 构建高质量的 LLM 应用程序]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><strong>Prompt flow&nbsp;</strong>是一套开发工具，旨在简化基于 LLM 的人工智能应用程序的端到端开发周期，从构思、原型设计、测试、评估到生产部署和监控。它使即时工程变得更加容易，并使你能够构建具有生产质量的 LLM 应用程序。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>通过该项目，你将能够：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>创建将 LLM、提示、Python 代码和其他工具链接在一起的可执行工作流程。</li><li>轻松调试和迭代你的流程，尤其是与 LLM 的交互。</li><li>使用更大的数据集评估流程的质量和性能。</li><li>将测试和评估集成到你的 CI/CD 系统中，以确保流程的质量。</li><li>将你的流程部署到你选择的服务平台或轻松集成到应用程序的代码库中。</li><li>（可选，官方强烈推荐）利用 Azure AI 中 Prompt flow 的云版本与团队协作。
<p>&nbsp;</p></li></ul></div>
                                                                ]]>
            </description>
            <pubDate>Sat, 16 Dec 2023 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/promptflow</guid>
            <link>https://www.oschina.net/p/promptflow</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 分布式块存储系统 fastblock]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-fastblock 简介" class="anchor" href="https://gitee.com/openeuler/fastblock#fastblock%E7%AE%80%E4%BB%8B"></a>fastblock 简介</h1><p>目前使用的分布式块存储系统 (ceph) 存在的问题已经不能适应对性能、延迟、成本和稳定性的需求，主要体现在:</p><ul><li>CPU 经济性: 目前需要消耗大量的 CPU，CPU 在 nvme ssd 集群中成为瓶颈</li><li>可用性差: 采用主从强同步复制策略, 集群抖动时有 IO 会被 hang 住</li><li>单卷性能不足: 对接 qemu 时性能更差，做压测时需要多个卷才能跑满整个集群的性能</li><li>单卷延迟过大: 不能充分利用 nvme 设备的低延迟特性，rbd 块设备通常延迟都在毫秒级别</li><li>并发总性能不足: iops 和吞吐相对硬件能够提供的水平相差较大</li></ul><p>fastblock 是为解决性能和延迟问题而生的，它的特点是:</p><ul><li>使用 spdk 编程框架编写，利用用户态 nvme 驱动、无锁队列等特性降低 IO 路径延迟</li><li>引入 RDMA 网卡进行零拷贝、内核旁路、无需 CPU 干预的网络通信</li><li>使用 multi-raft 进行数据复制，保证数据可靠性</li><li>简单、可靠、易定制的集群元数据管理</li></ul><h1><a id="user-content-fastblock 设计及架构" class="anchor" href="https://gitee.com/openeuler/fastblock#fastblock%E8%AE%BE%E8%AE%A1%E5%8F%8A%E6%9E%B6%E6%9E%84"></a>fastblock 设计及架构</h1><p>fastblock 的架构跟 ceph 非常类似，且 monitor、osd、pg 等众多概念都跟 ceph 一样以便于快速理解，架构如下图所示:<br><img src="https://gitee.com/openeuler/fastblock/raw/master/docs/architecture.png" alt="arch" referrerpolicy="no-referrer">
其中:</p><ul><li>Compute 表示计算服务</li><li>Monitor cluster 负责维护集群元数据（包括 osdMap、pgMap、pool 信息和 image 信息），以及 pool 和 pg 的管理。</li><li>storage cluster 对应存储集群，每个存储集群包含多个 Storage Node，每个 Storage Node 上运行多个 osd(Object Storage Daemon)。</li><li>Control rpc 用于传输元数据，使用 tcp socket；Data rpc 用于在客户端和 osd 之间传输数据请求；raft rpc 用于在 osd 之间传输 raft 论文中定义的 RPC 消息。其中 Data rpc 和 raft rpc 使用 protobuf 和 RDMA。</li><li>Monitor Client 是 monitor 客户端模块，用于跟 monitor 通信。</li><li>Command Dispatcher 是消息处理模块，用于接收处理客户端的数据请求。</li><li>raft Protocol Processer 用于处理 raft RPC 消息、选举、成员变更等 raft 协议规定的内容。</li><li>raft Log Manager 负责管理和持久化 raft Log，持久化 raft Log 使用了 spdk blob。</li><li>Data State Machine 存储用户数据，使用了 spdk blobstore。</li><li>raft Log Entry Cache 用于缓存 raft Log，提高性能。</li><li>KV System 则提供 kv api，持久化时使用了 spdk blob。</li></ul><h1><a id="user-content-fastblock 组件及交互逻辑" class="anchor" href="https://gitee.com/openeuler/fastblock#fastblock%E7%BB%84%E4%BB%B6%E5%8F%8A%E4%BA%A4%E4%BA%92%E9%80%BB%E8%BE%91"></a>fastblock 组件及交互逻辑</h1><h2><a id="user-content-monitor" class="anchor" href="https://gitee.com/openeuler/fastblock#monitor"></a>monitor</h2><p>monitor 服务负责维护存储节点状态和节点加入删除、存储卷的元数据、维护集群的拓扑结构、响应用户创建 pool 等操作、根据当前的拓扑结构在 osd 上均匀创建 raft group 等。monitor 作为集群管理工具，并不需要存储数据，也不需要追求极致性能，所以使用 golang 进行实现, monitor 使用 etcd 进行多副本存储。<br>
monitor 集群是一致性的重要保证，因为客户端、osd 看到的都是相同的视图。对于所有客户端的 io 操作都只能看到 pg 这一层，而 osd 和客户端都会在启动时开启一个定时器定时去向 monitor 获取 osdmap 和 pgmap 信息，所以所有的 osd 和客户端都能够看到相同的 pg 状态变化并作出相同的相应，针对特定 pg 的写入操作也不会写到错误的地方。<br>
详情可参考<a href="https://gitee.com/openeuler/fastblock/blob/master/monitor/README.md" title="monitor 简介">monitor 简介</a></p><h2><a id="user-content-osd-rpc 子系统" class="anchor" href="https://gitee.com/openeuler/fastblock#osd-rpc%E5%AD%90%E7%B3%BB%E7%BB%9F"></a>osd rpc 子系统</h2><p>rpc 子系统是连接各模块的重要系统，出于异构网络的要求，rpc 子系统的实现了两种方式，即基于 socket（Control rpc）的和基于 rdma（Data Rpc 和 Raft Rpc）的，基于 socket 的就是经典的 linux socket 应用场景，而基于 rdma 的 rpc 则是使用异步 rdma(即 rdma write) 语义实现的。<br><img src="https://gitee.com/openeuler/fastblock/raw/master/docs/rpc_subsystem.png" alt="rpc 子系统" referrerpolicy="no-referrer">
上图是 fastblock 中各个模块之间的联系，由图中可以看出使用了三种类型的 rpc，分别为 Control Rpc、Data Rpc 和 Raft Rpc:
Control rpc： 用于在客户端与 monitor 之间，osd 与 monitor 之间传递 osdmap、pgmap 和 image 信息等数据，这些数据量不大，频率不高，因此可以使用基于 socket 的实现;
Data rpc：用于在客户端与 osd 之间传输对象数据操作和结果，这些数据量比较大，频率会很高，因此需要基于 rdma 的方法;
Raft rpc： 用于在 osd 之间传输 raft rpc 协议内容，里面会保护对象数据，这些数据量比较大，频率会很高，因此需要基于 rdma 的方法。
Data rpc 和 Raft rpc 使用 protobuf 的 RPC 框架，网络交互部分代码使用 RDMA,rpc 传输数据的序列号都使用 protobuf。</p><h2><a id="user-content-osd-raft 子系统" class="anchor" href="https://gitee.com/openeuler/fastblock#osd-raft%E5%AD%90%E7%B3%BB%E7%BB%9F"></a>osd raft 子系统</h2><p>raft 通过选举一个领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目（log entries），把日志条目复制到其他服务器上，并告诉其他的服务器什么时候可以安全地将日志条目应用到他们的状态机中。 raft 在已经有很多开源实现，我们参考<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fwillemt%2Fraft" title="raft 的 C 语言实现">willemt</a>的 C 语言 raft 实现，并额外实现了 multi-raft，这个模块主要包括了:</p><ul><li>raft groups 的管理，包括 raft 的创建、修改和删除;</li><li>raft 选举以及选举超时处理;</li><li>raft log 处理，包括 log 缓存、log 落盘和 log 复制到 follower 节点;</li><li>数据 state machine 处理，既数据落盘;</li><li>raft 快照管理和 raft log recovery;</li><li>raft 成员变更管理 (暂未实现);</li><li>raft 心跳合并。</li></ul><p>实现 multi-group raft,意味着有多个 raft 并存，每个 raft 的 leader 需要给它的 follower 发送心跳包，因此就会有多个心跳包，如果 raft 过多就会导致心跳包过多，占用大量的带宽和 cpu 资源。解决方法也很简单，每个 osd 可能属于多个 raft，因此可以对相同 leader、相同 flower 的 raft 进行心跳的合并，这样就可以减少心跳包数量。如下图所示，有两个 pg（raft）分别为 pg1 和 pg2，pg1 和 pg2 中都包含 osd1、osd2 和 osd3，osd1 是 leader，osd1 需要给 osd2 和 osd3 分别发送 heartbeat (pg1)，pg2 中 osd1 需要给 osd2 和 osd3 分别发送 heartbeat (pg2)。心跳合并后，只需要 osd1 给 osd2 和 osd3 分别发送 heartbeat (pg1, pg2)。
<img src="https://gitee.com/openeuler/fastblock/raw/master/docs/heartbeat_merge.png" alt="心跳合并" referrerpolicy="no-referrer"></p><h2><a id="user-content-osd-kv 子系统" class="anchor" href="https://gitee.com/openeuler/fastblock#osd-kv%E5%AD%90%E7%B3%BB%E7%BB%9F"></a>osd kv 子系统</h2><p>kv 子系统用于存储 raft 的元数据、存储系统本身的数据，由于数据量不大，就自己设计了一套。因为数据量不大，内存中的 hash map 就可以存储所有数据，提供 put、remove 和 get 接口，每隔 10ms 把 hash map 中修改的数据写到磁盘中。</p><h2><a id="user-content-osd-localstore 子系统" class="anchor" href="https://gitee.com/openeuler/fastblock#osd-localstore%E5%AD%90%E7%B3%BB%E7%BB%9F"></a>osd localstore 子系统</h2><p>本地存储基于 spdk blobstrore 进行存储，包含 3 个存储功能模块：</p><ul><li>disk_log: 存储 raft log，一个 pg(对应一个 raft 组) 对应一个 spdk blob。</li><li>object_store: 存储对象数据，一个对象对应一个 spdk blob。</li><li>kv_store: 每个 cpu 核拥有一个 spdk blob。保存当前 cpu 核上的需要保存的所有 kv 数据，包括 raft 的元数据、存储系统本身的数据。
如下图所示，假设我们运行了两个 raft，localstore 为这两个 raft 提供了 log、object 和 kv 这 3 部分存储功能。
<img src="https://gitee.com/openeuler/fastblock/raw/master/docs/osd_localstore.png" alt="本地存储引擎" referrerpolicy="no-referrer"></li></ul><h2><a id="user-content-客户端" class="anchor" href="https://gitee.com/openeuler/fastblock#%E5%AE%A2%E6%88%B7%E7%AB%AF"></a>客户端</h2><p>客户端用于创建、修改和删除 image，把用户对 image 的数据操作转换为对 object（osd 处理的基本数据单元）的操作，然后封装为 Data Rpc 消息发送给 pg 的 leader osd，并接收处理 leader osd 返回的响应，结果返回给用户。 客户端有多种模式：使用 spdk vhost 提供给虚拟机使用；使用 NBD 提供给裸金属使用；使用 CSI 提供给虚拟机使用。这三种模式最终都会调用 libfastblock 库进行 image 到 object 的转换，并和 osd 通信。 下面主要介绍使用 spdk vhost 提供给虚拟机使用的模式:<br>
调用 spdk 库创建一个 vhost app，spdk 资源初始化后，需要开启一个定时器去向 monitor 获取 osdmap、pgmap 和 image 信息。
使用 spdk 的 rpc.py 脚本向 vhost app 发送创建 bdev（bdev_fastblock_create）的请求，vhost app 收到请求后创建 image，把 image 信息发送给 monitor，创建 bdev 设备，然后注册此设备的操作接口（此接口会调用 libfastblock 库）。
使用 spdk 的 rpc.py 脚本向 vhost app 发送创建 bdev 的 vhost-blk controller（vhost_create_blk_controller）的请求，vhost app 收到请求后打开 bdev 设备，注册一个 vhost 驱动去处理 vhost 消息（创建一个可供客户端 (如 qemu) 连接的 socket，并遵循 vhost 协议实现连接服务，这是 DPDK 中已实现的功能）。
libfastblock 把用户对 image 的数据操作转换为对 object（osd 处理的基本数据单元）的操作，然后封装为 Data Rpc 消息发送给 pg 的 leader osd，并接收处理 leader osd 返回的响应。</p><h1><a id="user-content-代码结构及编译" class="anchor" href="https://gitee.com/openeuler/fastblock#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E5%8F%8A%E7%BC%96%E8%AF%91"></a>代码结构及编译</h1><p>fastblock 代码主要位于 src、monitor 和 spdk 目录中:</p><ul><li>src 目录主要包含 raft 实现、rdma 通信、底层存储引擎、块层 API 封装等功能, 详情见<a href="https://gitee.com/openeuler/fastblock/blob/master/src/README.md" title="src 代码简介">src 目录简介</a></li><li>monitor 目录则包含了集群元数据存储管理、monitor 选举、pg 分配、clustermap 分发等功能, 详情见<a href="https://gitee.com/openeuler/fastblock/blob/master/monitor/README.md" title="monitor 代码简介">monitor 目录简介</a></li><li>spdk 目录是通过复用 spdk 的 rdma 通信模块以支撑低延迟的 rpc 通信, 详情见<a href="https://gitee.com/openeuler/fastblock/blob/master/spdk/README.md" title="spdk 目录简介">spdk 目录简介</a>
编译之前需要先安装依赖，目前已进行了 ubuntu 21.10 和 openEuler 22.03 版本的验证，其他操作系统可酌情更改.</li></ul><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">./install-deps.sh</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>首次编译时，需要获取 spdk 和 abseil-cpp 等依赖，可通过运行以下命令分别编译 Release 版本的 montior 和 osd:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">./build.sh -t Release -c monitor</span><span id="LC2" class="line">./build.sh -t Release -c osd</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>编译完成后，<code>fastblock-mon</code>和<code>fastblock-client</code>二进制位于<code>mon/</code>目录下，而<code>fastblock-osd</code>和<code>fastblock-vhost</code>二进制位于<code>build/src/osd/</code>目录和<code>build/src/bdev</code>目录下。
后续 osd、vhost 有代码改动，则可仅在<code>build/</code>目录下编译，而 monitor 有改动则可仅在<code>mon/</code>目录下<code>make</code>即可。</p><h1><a id="user-content-部署及性能测试" class="anchor" href="https://gitee.com/openeuler/fastblock#%E9%83%A8%E7%BD%B2%E5%8F%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"></a>部署及性能测试</h1><p>参考<a href="https://gitee.com/openeuler/fastblock/blob/master/docs/performance_test_1012.md" title="性能测试报告">部署及测试报告</a>, 在我们的测试环境中，在每个 osd 仅适用一个核的情况下，获得了 4k 随机写单线程 100us 以下的延迟以及并发 41 万 iops 的性能。</p><h1><a id="user-content-future-works" class="anchor" href="https://gitee.com/openeuler/fastblock#future-works"></a>future works</h1><ul><li>实现卷快照、快照组等功能</li><li>实现卷 QoS</li><li>osd 和 client 多核性能优化</li><li>实现本地存储引擎的可恢复性，以及本地存储引擎优化</li><li>添加测试系统，进行单元测试、集成测试，特别是 raft 层和本地存储引擎的故障测试</li><li>接入 CI 系统</li><li>实现可定制的 monitor 的 pg 分配插件</li><li>实现 raft 成员变更及与 monitor 的 pg 分配整体联调</li><li>优化 osd client 的 rdma 连接管理</li><li>重写 rdma 传输层以替换 spdk nvmf 版的 rdma 传输层</li><li>支持 DPU 卸载 vhost</li><li>监控数据导出及集群运行时数据展示</li><li>部署工具开发及系统配置文件简化</li><li>支持卷加解密功能</li><li>支持卷共享</li></ul>]]>
            </description>
            <pubDate>Sat, 16 Dec 2023 02:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/openeuler/fastblock</guid>
            <link>https://gitee.com/openeuler/fastblock</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 如何做到人均告警减少 90%？B 站新一代告警平台的设计与实践]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h1>一分钟精华速览</h1><p>B 站的业务规模和用户群体不断扩大，对于服务的稳定性和可用性的要求也日益增高。这就需要 B 站的监控告警系统能够及时、准确地发现和定位问题，以便尽快解决，维护好用户的使用体验。</p><p>本文是对 B 站在告警监控系统上的一次重要迭代和优化的详细记录。文章详细阐述了 B 站对告警平台设计思路和优化迭代，以及在实现过程中遇到的问题和解决方法。特别是对于告警定位的精准性和定位效率的提升，文章给出了新的设计方案和实践方法。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1c59a16c99cd6269dbb40c664c5cf2055c4.png" alt="file" referrerpolicy="no-referrer"></p><h1>作者介绍</h1><p><img src="https://oscimg.oschina.net/oscnet/up-a440bfaf0e2d837fc556f9759e77fe1f9e6.png" alt="file" referrerpolicy="no-referrer"></p><p>哔哩哔哩资深开发工程师——王程田</p><p>TakinTalks 稳定性社区专家团成员，哔哩哔哩资深开发工程师。2020 年加入 B 站先后负责事件平台，链路追踪，AIOps 及告警平台方向技术演进 &amp;平台迭代。完成了新一代告警平台落地，达成了 99 分位一分钟内的异常端到端发现，实现了人均告警从每周 1000+条/人到 70+条/人告警治理上的突破。</p><p>温馨提醒：本文约 6000 字，预计花费 8 分钟阅读。</p><p>TakinTalks 稳定性社区后台回复 「交流」 进入读者交流群；回复「1130」获取课件；</p><h1>背景</h1><p>在 B 站的多元化业务中，告警平台起着至关重要的作用。无论是视频播放、弹幕发送、用户评论、直播间管理，还是后台的内容审核、数据统计等，都离不开系统的稳定运行。告警平台可以实时监控这些业务系统的运行状态，一旦出现异常，就会及时发出告警示，使运维人员能够迅速定位问题，及时进行处理。</p><p>然而，维护这些业务的稳定运行并非易事。从告警发生的前、中、后三个阶段，即生产端、传输端和消费端来看，B 站的告警平台设计都面临着不小的挑战和复杂性。 <img src="https://oscimg.oschina.net/oscnet/up-1dd0249404eb178d97848101b0fd3492b8f.png" alt="file" referrerpolicy="no-referrer"></p><p>考虑到这些业务需求和复杂度，我们着手对 B 站新一代告警平台进行了全面升级，结果达成了人均告警减少 90%，根因分析准确率高达 87.9% 的突破。在本文中，我将概述新一代告警平台的设计理念，并重点分享该平台在告警降噪和告警智能化分析方面的实施策略。</p><h1>一、告警平台做了哪些重点设计？</h1><h2>1.1 业务核心诉求</h2><p>在告警平台的设计和迭代过程中，我们不断收到各类业务需求。总体上，这些需求的核心都集中在「以质量为中心，及时发现并处理异常，确保业务稳定性」。具体来说，需求场景可划分为风险场景和故障场景。在风险场景中，需要提前感知并有效应对潜在问题；而在故障场景中，需要迅速发现线上问题，及时响应，以实现快速恢复。</p><p>在满足这些业务需求的过程中，我们提炼出三个核心诉求和目标：</p><p>有效性：我们期望所有收到的告警都是有效的，即每次接收到告警时，都确实存在异常，而且这条告警对当前的接收者是具有意义的。</p><p>及时性：对于高优先级的异常，我们希望能在第一时间触达并被用户感知，以便他们能够及时采取行动进行处理。</p><p>覆盖性与跟进：我们期望实现告警的全面覆盖和跟进。从用户的角度来看，他们希望所有自己负责的业务或应用的场景都能被告警覆盖，同时，他们也希望能了解不同场景的告警覆盖情况。当规则产生异常后，用户需要有一个便捷的方式去快速处理并跟进解决问题。</p><h2>1.2 告警平台详细设计</h2><h3>1.2.1 闭环模型</h3><p>在告警平台的详细设计中，我们基于前述的目标和业务需求，构建了一个闭环模型。这个模型旨在保证各关联方的积极参与，从而推动目标的持续改善。特别的，告警定义和告警治理是模型中的两个关键环节，因为它们决定了告警降噪和召回效果的优劣。 <img src="https://oscimg.oschina.net/oscnet/up-412a40c1cfbb39cb0c17812de113d3f3d26.png" alt="file" referrerpolicy="no-referrer"></p><p>接下来将详细介绍 B 站告警定义、检测、通道侧功能的设计。重点是告警处理、根因分析以及告警治理侧的实践内容。</p><h3>1.2.2 告警接入</h3><p>在告警接入环节，主要区分了三个场景，这些场景的设计可以覆盖业务对于告警接入的大部分需求。</p><p>1）面向平台的场景</p><p>我们为平台覆盖的告警场景提供告警规则和模板的开放接口能力，支持多租户规则集成。不同租户可以基于预定义的模板进行配置，可以在业务申请或者注册资源时，快速完成告警的定义和覆盖，整个过程成本低，便捷性高。</p><p>2）面向自定义场景</p><p>我们为业务直接开放告警规则定义，包括规则的触发条件配置、表达式及通知策略的配置。</p><p>3）面向第三方事件</p><p>我们开放事件集成能力，用户可以通过注册事件完成准入，主动触发方式发送到告警平台，告警平台完成后续闭环的处理。</p><h3>1.2.3 告警计算</h3><p>我们设计了一个分布式的告警计算引擎，实现了多级的调度。基于线上全量生效的规则，进行全局调度，将告警的场景、可用区调度到不同的可用区和计算集群下。在同一个计算集群下，进行本地调度，将任务调度到不同的计算节点，实现负载均衡。计算节点会周期性地检测数据判断告警是否触发，触发后将投递到告警通道。 <img src="https://oscimg.oschina.net/oscnet/up-6dd8eb1e13f1625434405ab2a73c51430a1.png" alt="file" referrerpolicy="no-referrer"></p><h3>1.2.4 告警通道</h3><p>主要做降噪、渲染、分发，以实现准确的投递和快速的触达。对于引擎侧产生的告警事件，在通道会生成告警消息，然后先经过降噪模块，依次完成通知窗口拦截、通知频率拦截、接警拦截、静默拦截、抑制拦截、告警聚合等。接下来，经过告警渲染分发模块，完成渲染接收人、渲染通知通道、渲染通知模板，最终触达到用户并更新告警的投递状态。 <img src="https://oscimg.oschina.net/oscnet/up-9ceb09b7a6a29d8ed6874d76ba957d1e1c1.png" alt="file" referrerpolicy="no-referrer"></p><h1>二、告警治理有哪些实践心得？</h1><p>下面我将主要阐述 B 站在告警治理的实践过程中，如何推行告警治理策略，降低告警噪声，以及提高告警的有效性。</p><h2>2.1 告警治理背景</h2><p>过去一段时间里，B 站的告警通知泛滥问题，对技术团队和平台来说，这已经成为一个多年的困扰，也是一个较大的痛点。一方面，随着稳定性问题的出现以及新平台的接入，告警规则和配置不断增加；另一方面，又缺乏有效的告警治理和运营分析机制。这导致告警数量越来越多，很多用户也不会去主动治理告警，反而选择设定免打扰。最后，真实的风险和异常往往被淹没在众多告警中，无法第一时间被感知到。</p><p>用一句话来概括，就是「太多的告警就相当于没有告警」。</p><h2>2.2 问题分析</h2><p>我们认为，这主要由以下四部分原因导致：</p><p>告警定义不合理：很多规则缺乏有效的维护，大量的规则在触发后，并不代表有异常发生，业务也不会去处理。此外，有些告警的粒度太细，导致同一异常触发后产生大量的告警，放大了整个通知的影响。</p><p>通知人数放大：由于历史组织架构的变更或临时排查问题，定位权限相耦合，导致服务树长期缺乏治理，造成告警通知人数的大幅度放大，经常发给一些无关的人员。</p><p>缺少分析治理工具：虽然大家都知道告警太多了，需要治理，但是却没有头绪，也没有合适的平台能力帮助他们分析告警主要集中的部分，从而进行有针对性的治理。</p><p>缺乏有效的运营机制：大家对治理告警的动力不足，同时也缺乏有效的机制和规范约束。在历史上可能经过一些短期治理后，告警又出现反弹，治理效果就不复存在。</p><h2>2.3 告警治理的三个阶段</h2><p>在分析了告警泛滥的原因后，我们开始了告警治理，这个过程主要分为三个阶段。 <img src="https://oscimg.oschina.net/oscnet/up-88282d9da6f4baae2fd9486d47eae1f9705.png" alt="file" referrerpolicy="no-referrer"></p><p>第一阶段：目标设定</p><p>经过多轮的会议和讨论，我们确定了告警数的指标，将原先每周超过 1000 条的告警数量降低到每周 80 条。这个目标在初始阶段看起来几乎是不可能完成的。然而，我们认为这 80 条告警是一个业务人员能够逐条响应处理的合理范围。于是，我们坚持以这个目标去执行，并尽力去达成。</p><p>第二阶段：数据分析</p><p>我们将告警数据集成到数据仓库中，提供了多维度的分析视图，为告警治理提供了数据支持。通过计算公式来确定影响因子，公式基于告警通知数量，即：告警通知数量=告警数<em>每次触发通知的人数</em>降噪系数。这个公式帮助我们明确了治理的方向和重点。</p><p>第三阶段：治理动作</p><p>在这个阶段，我们开始执行一系列治理动作。</p><p>首先，优化了告警项，与 SRE 和平台同事一起评估了默认告警项的合理性，对无效的告警项进行了关闭处理。对于一些不合理的告警项，我们评估并优化了其表达式和默认阈值等条件，以降低告警噪声并提高告警的有效性。</p><p>其次，为了解决通知人数放大的问题，优化了告警接收人的设置。我们深度参与并推动了服务树研发和负责人角色的校准，并推出了值班，升级等能力，以缩小告警的通知范围，有效地降低了通知人数放大的噪声。</p><p>最后，丰富了通道的告警降噪策略，支持了规则组的微调拦截能力，以及多维度下的告警汇总和聚合能力，从而更高效降低了告警噪声。</p><h2>2.4 告警治理过程经验总结</h2><p>在进行了一系列的告警治理行动后，我们对治理过程进行了总结和思考。主要从以下三个方面进行分享：</p><p>1）异常召回是底线</p><p>在整个治理过程中，集中处理的主要是无效的噪声告警，然而，绝不能忽视真实且有效的告警。在治理中，我们始终坚守一个原则，即不能牺牲异常的召回率。因此，我们将注意力集中在那些持续触发、重复触发以及异常放大等不合理的规则上，以及 Top 级别的规则上，并对这些问题进行专项治理。</p><p>2）运营推进不可少</p><p>实际上，治理过程就是一个运营推进的过程。在这个过程中，创建了数十个群组，制定了无数的治理、推进和跟进文档，以确保整个密集且强制性的告警治理工作的落实。同时，也与各个场景平台以及 SRE 进行了紧密合作，共同推动了告警治理工作。</p><p>3）分层分级抓重点是方向</p><p>我们借鉴了毛剑老师的理念，强调分层分级，抓住重点，尤其是保证业务可用性的核心告警。对于事件类的告警，建议记录并可查询，以避免淹没其他重要的告警通知。对于一些不适合直接通知业务侧的依赖告警，建议通过关联的方式来呈现，这样可以有效地降低告警的噪声。</p><h2>2.5 告警治理效果</h2><p>近半年地推式的告警治理，告警数据得到显著改善：</p><p>中位数告警 1000 次/周减少到 74 次/周，减少到原来的 7.4%；</p><p>整体告警通知数从治理前 300w+减少到 22w+，减少到原来的 7%；</p><p>人均告警通知数从 1600+减少到 140，减少到原来的 8.8%； <img src="https://oscimg.oschina.net/oscnet/up-4aaba5026a5563dc1f202fb6d8ec6184710.png" alt="file" referrerpolicy="no-referrer"></p><h2>2.6 建立长效治理机制</h2><p>为了确保告警治理所取得的成果能够持续稳定，我们构建了一套长效治理机制，具体包含以下三个方面：</p><p>1）便捷治理分析工具</p><p>包含了一个告警治理分析大盘，它被集成在告警平台上。这个大盘支持从业务、个人和公司等多个视角，通过多个维度对告警的分布和趋势进行分析。此外，我们还利用了一些治理工具，为快速治理提供了必要的能力。</p><p>2）数据报表订阅</p><p>我们与 SRE 各个组件平台达成了共识，制定了共同的目标，并生成了各类数据报表的订阅。持续跟进这些报表，以防止告警的恶化，并持续进行告警治理。 <img src="https://oscimg.oschina.net/oscnet/up-c3811ee980a3d066894a0537c26b3846b35.png" alt="file" referrerpolicy="no-referrer"></p><p>3）接入管控</p><p>针对新接入的规则和平台场景，增加了一些告警数据接入的人工校验，以及平台侧的校验和噪声监控。对于一些不合理的规则，我们会建议对应的接入方进行优化，以保持告警治理成果。</p><h1>三、告警根因分析是如何设计和应用的？</h1><p>结合当下业界广泛运用的前沿技术，例如异常检测、智能降噪、智能合并策略以及根因分析等，我将重点分享 B 站在根因分析方面的实践和实战经验。</p><h2>3.1 根因分析背景</h2><p>随着 SLO 体系的日益完善，更多的业务被接入到 SLO 体系中。这使得我们有了明确的异常定义和触发对象，能够更精确地实施根因分析。</p><p>此外，B 站已经设定了 「1-5-10」 的目标。目前，已经通过优化告警计算采集和通道，实现了 99 分位端到端一分钟内的问题发现。然而，对于 5 分钟的定位，仍存在一些瓶颈。定位过程过于依赖人工经验，存在一定的不确定性。人工专家经验因人而异，同时受场景影响，导致定位效率也不一致。另外，由于平台能力的建设和交互，以及一些极端情况下的响应延时，如凌晨故障或者出差等场景，都会影响定位效率。</p><p>最后，用户需求的积累也在不断增加。随着业务和基础设施的增长，人们越来越关注告警定位的效率，并积累了大量定位告警的经验。因此，对于根因分析的需求日益迫切，同时，根因分析的实施条件也逐渐成熟。</p><h2>3.2 根因分析设计</h2><h3>3.2.1 根因分析设计 1.0 版</h3><p>首先，我们采用了以 SLO 告警为基础的设计方案，对微服务架构下的黄金指标进行定位能力的设计，这就是 1.0 版根因分析设计。整个设计方案主要包含三个阶段。 <img src="https://oscimg.oschina.net/oscnet/up-9bd92ad17719b87e37ee6ac443eaf813c83.png" alt="file" referrerpolicy="no-referrer"></p><p>首阶段，我们监听 SLO 的告警触发，关联错误的范围和数据，然后基于这些数据分析日志指标，挖掘出异常的维度。例如，错误可能集中在特定集群的某个实例下，或者某个上游请求的某个接口。</p><p>第二阶段，我们根据这些错误维度，对应用侧的链路调用进行关联，找出异常期间的异常链路。通过聚合分析，能区分出耗时和错误的场景，通过关键路径分析和剪枝下钻的方式，定位到异常链路下的异常节点。</p><p>最后一阶段，将定位到的异常节点映射到知识图谱中，通过数据图谱关联到相关的数据库、缓存、消息队列、容器、机器、交换机、机柜、机房等信息。然后，结合异常、告警、变更等信息，通过关联分析模型进行打分推荐，最终推荐出可能的 Top 根因排序。</p><p>尽管这个 1.0 版的根因分析设计在某些场景下的准确率可以接受，但是它仍然存在一些瓶颈。</p><p><img src="https://oscimg.oschina.net/oscnet/up-54c493835c8d5726c828410f1bc25b115b6.png" alt="file" referrerpolicy="no-referrer"></p><h3>3.2.2 根因分析设计 2.0 版</h3><p>在设计 2.0 版的根因分析时，我们进行了全面的调研，深入了解了业界资深的 SRE 和业务同事们在定位问题时的过程。</p><p>总结下来，这个过程主要是：在告警触发后，根据专家的经验，关联到具体的异常事件；然后再根据这些经验，分析这个异常可能由哪些原因导致，并找出这些原因的相关指标和日志等观测数据；最后，通过观察这些数据，判断出导致异常的根源。</p><p>在设计 2.0 版的过程中，我们力求将这个过程普遍化，并构建一个异常知识图谱，将专家的经验沉淀下来。同时，也开放了根因分析的集成和知识目录的功能，提供通用的根因分析能力。</p><p><img src="https://oscimg.oschina.net/oscnet/up-e5caf92711bcb72bd249bb36169653cf1be.png" alt="file" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-f219736ec60c443fe1e4c5ee319640d9a75.png" alt="file" referrerpolicy="no-referrer"></p><p>根因分析的实现主要围绕知识的定义。这里的知识主要是基于异常节点定义。每个异常都会定义在具体的某个实体节点下，例如某个应用或某个数据库的集群实例。每个异常都会关联到具体的数据节点，比如日志、指标、告警等，通过这些数据我们可以检测和判断异常的发生。同时，异常之间也存在传导关系，一个异常可能由哪些异常导致，这些异常之间的传导链路和关联关系是怎样的。这就是我们在知识工程中定义的整个知识结构。</p><p>这种基于知识图谱的根因分析方式，很好地解决了 1.0 版中遇到的问题。使我们能够更深入地理解异常发生的原因，更准确地定位到问题的根源。通过将专家的经验进行系统化的沉淀，不仅提高了问题定位的效率，也使得知识的传承和积累成为可能。</p><h3>3.2.3 AIOps 算法支持</h3><p>根因分析的能力建设，离不开 AIOps 算法的支撑。目前，我们已经构建了一个全面的算法体系，设计了指标、日志、事件、链路等多个场景。同时，也根据不同类型的数据，支持了时序预测、异常检测、指标分类以及日志聚类、多维下钻，和事件聚类、链路分析等多个场景的算法能力。 <img src="https://oscimg.oschina.net/oscnet/up-59882e82b01a1f6dfdd569508b48de9e812.png" alt="file" referrerpolicy="no-referrer"></p><h3>3.2.4 关联分析模型升级</h3><p>在关联分析的过程中，我们将异常图通过特征构建、模型加载，基于模型推理预测并打分，最终推荐出异常的根因和传导路径。特征设计包括：时间依赖特征、图关系/距离特征、因果特征、路径相似特征、事件类别特征。</p><p>模型构建方面，在初期主要是基于冷启动的方式，预定义了一些异常之间的传播系数。随着样本标注数据的增多，开始进行模型的训练，并基于模型进行推理和推荐。此外，我们也支持 GBDT 模型，以进一步提升关联分析能力。</p><p><img src="https://oscimg.oschina.net/oscnet/up-d6b0445d907edbb174e1774270aaad5e9fe.png" alt="file" referrerpolicy="no-referrer"></p><h2>3.3 难点和重点</h2><p>在根因分析的过程中，我们面临着一些难点和重点。难点主要在于，如何有效评价推荐的根因，以及如何获取用户的准确率和评价数据。这对于评估不同版本，以及根因分析的准确率和有效性，以及帮助模型进行迭代至关重要。为了解决这个难题，我们进行了以下四部分工作：</p><p><img src="https://oscimg.oschina.net/oscnet/up-5420196edcfd8b93bbbd8b23c00f71ee132.png" alt="file" referrerpolicy="no-referrer"></p><p>在整个过程中，一个重点是围绕专家经验的收集和构建。我们会与不同业务和 SRE 同学深度沟通，梳理相关的异常知识和专家经验，完成这部分知识的定义。</p><p>对于组件方面，我们会与相关同学持续完善这部分知识的定义和构建能力。针对一些特殊场景，也会提供外部专家经验的集成方案，提供根因分析的集成能力和接口，让外部的根因也可以通过分析能力完成，实现人工告警的推荐、展示和评价。</p><h2>3.4 案例分析</h2><h3>3.4.1 上游流量突增导致服务限流，可用率下降</h3><p>在这种情况下，可以基于告警关联到具体服务的 SLO 异常，并且下钻得到具体的异常接口和错误。同时，通过异常关联分析可以检测到上游的流量突增，明确具体哪一个入口的流量突增。有了这些信息，业务侧可以对上游的服务进行一些限流的配置并进行修复。</p><p><img src="https://oscimg.oschina.net/oscnet/up-447ee94180d00bc126ef72c16b89a733600.png" alt="file" referrerpolicy="no-referrer"></p><h3>3.4.2 下游变更导致服务异常影响网关接口可用率</h3><p>可以通过根因分析关联到具体的链路，并关联到具体下游的异常和变更。最终，可以推荐出 AI 服务的变更是影响网关接口的主要原因。业务同学可以快速找到对应的变更人，然后进行排查和回滚等止损操作。</p><p><img src="https://oscimg.oschina.net/oscnet/up-d0179cd8afb98967fa016c6b5edc192f2ce.png" alt="file" referrerpolicy="no-referrer"></p><h3>3.4.3 下游 Redis 请求异常影响服务接口</h3><p>可以通过内部分析以及异常关联到具体的服务，并构建起异常的传导路径。同时，可以推荐出具体的异常请求耗时和日志。此外，业务侧也可以与相关组件的同学一起进行更深入的定位。</p><p><img src="https://oscimg.oschina.net/oscnet/up-5ffa4fd875968133050d7a1cdeac23233f3.png" alt="file" referrerpolicy="no-referrer"></p><h2>3.5 效果评估</h2><p>根因分析已经落地，并取得了一些成效——</p><p>根因分析次数：20652/天</p><p>准确率：87.9%</p><p>召回率：77.5%</p><p>分析耗时 95 分位：10s</p><p>平均分析耗时：4s 内（这意味着，在告警发出后，平均仅需 4 秒钟就可以推荐出根因，业务人员打开告警卡片就可以直接看到对应的异常根因。）</p><p><img src="https://oscimg.oschina.net/oscnet/up-c32a5ed1c13a8e5e899857ff7a6633ab6ae.png" alt="file" referrerpolicy="no-referrer"></p><h1>四、总结与展望</h1><p>设计告警平台时，需要考虑到多种多样的业务需求和不同的应用场景。理解这些需求的本质，然后基于这个本质来构建平台的能力以及关键功能模型，并设计出闭环逻辑，以此来设计出更贴近业务需求的告警平台。其次，告警治理过程是必不可少的。无论告警的数量多少，只有通过完善的告警治理机制，才能使整个系统的闭环优化规则的定义，持续提升告警的有效性，发挥告警的价值。最后，告警与人工智能的结合是未来的发展趋势。通过深度结合的一些能力，可以提升故障发现的准确率，减少定位和恢复止损的时间，为质量管理和系统稳定性提供保障。（全文完）</p><h1>Q&amp;A：</h1><p>1、这个告警治理是否主要靠人力筛选减少规则？</p><p>2、业务侧的告警关联降噪可以举个例子吗？是在监控侧关联还是在告警侧关联？业务告警可以和基础告警关联吗？</p><p>3、告警后有进一步的自动分析场景吗？</p><p>4、监控告警通知的发送状态和效果怎么管理？怎么处理通知失败或异常的情况？</p><p>5、在告警合并方面，高优告警怎么不被淹没？同时保证低优告警的质量巡检？</p><p>6、怎么优化根因分析的效率和准确性，来支持实时分析和批量处理呢？根因分析过程中，大量的数据和日志信息怎么管理和存储？有哪些最佳实践和经验可以分享？</p><p>以上问题答案，欢迎点击「<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.shulie.io%2F%3Fp%3D7721" target="_blank">阅读全文</a>」，观看完整版解答！</p><p>声明：本文由公众号「TakinTalks 稳定性社区」联合社区专家共同原创撰写，如需转载，请后台回复「转载」获得授权。</p><blockquote><p>本文由博客一文多发平台 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenwrite.cn%3Ffrom%3Darticle_bottom" target="_blank">OpenWrite</a> 发布！</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Sat, 16 Dec 2023 02:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/5129714/blog/10321815</guid>
            <link>https://my.oschina.net/5129714/blog/10321815</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Oxlint 正式面市，JavaScript 开发者的新选择？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 12 月 12 日，JavaScript 和 TypeScript 开发者们迎来了一个新工具的诞生——Oxlint。这个被设计用来快速捕捉错误或无用代码的 JavaScript linter，以其显著的性能优势和易用性宣告了自己的市场入场。据报道，Oxlint 能够在仅需几秒钟的时间内完成原本 ESLint 需要 75 分钟才能完成的任务，这对于那些在持续集成环境中追求高效的大型项目来说，无疑是一种极具吸引力的改变。</p><p>然而，在技术社区，特别是在 HackerNews 上，对于 Oxlint 的讨论并非全然积极。一部分人担忧，尽管 Oxlint 在速度上有显著提升，但这种优势对于日常的开发工作可能并不那么重要。毕竟，ESLint 的执行速度问题在多数情况下并不明显，它只在大规模运行 lint 任务时才可能成为瓶颈。此外，Oxlint 的出现意味着可能需要重新实现 ESLint 的许多规则，这不仅降低了与现有生态的兼容性，也给未来的规则和语法更新带来了同步维护的压力。</p><p>另一方面，对于大型项目，优化 ESLint 的配置，比如仅扫描修改过的文件，可能就足以解决速度问题，而无需转向全新的工具。这引发了一个更深层次的问题：开发和维护一个全新的工具是否真的值得，特别是对于商业项目而言，这种成本与收益的权衡需要更加审慎。</p><p>而且，不可忽视的是，Oxlint 在初期可能无法与 ESLint 的规则集完全兼容，功能上可能不如 ESLint 丰富。这对于那些依赖 ESLint 深厚生态的项目来说，可能是一个不小的挑战。此外，关于 Oxlint 的性能提升，有观点认为应该深入分析 ESLint 存在的性能瓶颈，并进行针对性优化，而不是简单地通过更换工具来解决问题。</p><p>在这样的背景下，Oxlint 的出现无疑给 JavaScript 和 TypeScript 的开发者们提供了一个新的选择。它的高效性和易用性对于一些特定场景下的需求来说，可能是一个不错的解决方案。但同时，它也带来了一系列的考量，包括对现有生态的兼容性、功能的完备性，以及长期维护的可持续性等。</p><p>那么，面对这样一个新兴工具，开发者们又该如何选择？是否应该追求速度和效率，还是应该更加重视生态的完整性和成熟度？Oxlint 是否能够在未来的技术演进中找到自己的定位，或者说，它能否引领一种新的开发工具趋势？这些问题，可能还需要时间和更多的实践来回答。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 16 Dec 2023 01:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271287</guid>
            <link>https://www.oschina.net/news/271287</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[稚晖君创业公司再融资，金额超 6 亿元，投前估值 35 亿元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F36kr.com%2Fp%2F2560285742488705" target="_blank">据报道</a>，稚晖君创业公司智元机器人近日完成新一轮 A3 融资。</p><p>本轮融资由蓝驰创投、中科创星、鼎晖投资、长飞基金、C 资本、高瓴创投、立景创新、三花控股集团、基石资本、临港新片区基金和银杏谷资本投资。 据了解，本轮投前估值为 35 亿元，融资金额超 6 亿元人民币。</p><p>目前，该公司正在进行新一轮融资，投前 70 亿元估值。截止发稿，官方并未给到回复。</p><p>智元机器人因创始人「稚晖君」彭志辉而出名，公司希望对标特斯拉的擎天柱，产品方向为人形机器人。今年 8 月，智元推出了<em><u><a href="https://www.oschina.net/news/254290">远征 A1 人形机器人</a></u></em>，并发布了其自研的 PowerFlow 关节电机，反关节的设计和灵巧手 SkillHand。</p><p><img src="https://static.oschina.net/uploads/space/2023/0818/134556_I0Zb_2720166.jpg" referrerpolicy="no-referrer"></p><p>智元机器人在 8 月发布会时表示，他们已经和多家头部制造业服务企业对接，并面向 3C 电子、汽车装备等不同场景，训练了很多如拧螺丝的动作，公司预计 2024 年产品会推向商业化落地。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 15 Dec 2023 08:41:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271228</guid>
            <link>https://www.oschina.net/news/271228</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[MariaDB 拆分 SkySQL，作为独立公司成立]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">MariaDB<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmariadb.com%2Fnewsroom%2Fpress-releases%2Fmariadb-finalizes-spinoff-of-skysql%2F" target="_blank"> 宣布</a>已将其 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fskysql.com%2F" target="_blank">SkySQL</a> 业务拆分为一家独立的云数据库公司，以负责构建和支持 SkySQL 产品。</span></p><p><span style="color:#000000">「我们相信，此次分拆将促进依赖 SkySQL 的客户顺利过渡。我们很高兴 SkySQL 产品将在一家新公司的领导下继续发展，同时让我们能够集中精力开发核心的 MariaDB 企业服务器产品。」</span></p><p><span style="color:#000000">未来，新公司 SkySQL Inc. 将承担 SkySQL 数据库即服务 (DBaaS) 的开发、销售和支持工作。MariaDB 将持有 SkySQL 的股权，以强调两家公司之间的长期合作关系。</span></p><p><span style="color:#000000">SkySQL DBaaS 产品是 MariaDB 数据库的云托管和生产级版本。SkySQL 表示，通过作为一个独立实体推出，它将能够加快向平台提供新功能的步伐。其主要优先事项之一是在 Microsoft Azure 上启动该服务。目前，客户可以通过 Amazon Web Services 和 Google Cloud 进行访问。</span></p><p><span style="color:#000000"><img alt="" height="294" src="https://oscimg.oschina.net/oscnet/up-a1e38eab7fc4e80eb5d8322843767666f63.webp" width="300" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">MariaDB 于 2020 年推出了 SkySQL，称它是流行的 MariaDB 数据库的云原生版本，是 MySQL 数据库的替代品。由于 SkySQL 是基于 Kubernetes 构建，因此它可以与任何类型的云基础设施相融合。</span></p><p><span style="color:#000000">SkySQL 的云原生特性意味着客户可以更轻松地管理其数据库部署。与 Oracle 等其他公司的数据库产品相比，它的许可和管理也更容易。此外，SkySQL 是首批支持行、列式以及组合行和列式存储的 DBaaS 服务之一，这是一种可以在同一个数据集上在一个位置处理事务和分析的技术。</span></p><p><span style="color:#000000">由于采用了 MariaDB 专有的 MaxScale 和 Xpand 技术，SkySQL 还声称比其他类型的数据库具有更高的可用性和更大的可扩展性。</span></p><p><span style="color:#000000">作为一个独立的实体，SkySQL 的领导团队包括：首席执行官 Nithin Rao、联合创始人 Jags Ramnarayan（首席技术官）和 Saravana Krishnamurthy (CPO)。曾在 MariaDB 中负责开发和运营 SkySQL 的核心技术团队也已加入该公司。</span></p><p><span style="color:#000000">Rao <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsiliconangle.com%2F2023%2F12%2F14%2Fmariadb-spins-skysql-independent-database-service-company%2F" target="_blank">表示</a>，通过分拆 SkySQL，新公司将确保 SkySQL 继续成为那些希望在云中获得最佳 MariaDB 体验的客户的「不二之选」。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 15 Dec 2023 07:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271211/mariadb-spins-skysql-independent-company</guid>
            <link>https://www.oschina.net/news/271211/mariadb-spins-skysql-independent-company</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[FolkMQ 「多中心」集群部署方案]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#24292e; text-align:start">FolkMQ 是一个新起的内存型消息中间件。</p><h3>简介</h3><ul><li>采用 「多路复用」 + "内存运行" + "快照持久化" + "Broker 集群模式"（可选）+</li><li>基于<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsocketd.noear.org%2F" target="_blank">Socket.D 网络应用协议</a><span>&nbsp;</span>开发。全新设计，自主架构！</li></ul><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#24292e; display:block; font-family:-apple-system,&quot;system-ui&quot;,&quot;Segoe UI&quot;,Helvetica,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:960px; word-spacing:0px"><tbody><tr><th>角色</th><th>功能</th></tr></tbody><tbody><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">生产端</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">发布消息（Qos0、Qos1）、发布定时消息（Qos0、Qos1）、发布重试</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">消费端</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">订阅、取消订阅</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">消费端</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">消费-ACK（自动、手动）</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">服务端</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">发布-Confirm、订阅-Confirm、取消订阅-Confirm、派发-Retry、派发-Delayed</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">服务端</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">内存运行、快照持久化（自动、停机、手动）</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">服务端</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">集群热扩展</td></tr></tbody></table><h3>特点</h3><ul><li>高吞吐量、低延迟（单机版，180K TPS）</li><li>扩展性（集群可」热扩展「服务节点）</li><li>持久性、可靠性</li><li>高可用（只要有」一个「同类节点在即可）</li></ul><h3>多中心集群部署演示：</h3><p><iframe frameborder="0" height="400" scrolling="no" src="https://player.bilibili.com/player.html?aid=409798174&amp;bvid=BV1vG411a7Q7&amp;cid=1367060964&amp;p=1" style="box-sizing: border-box; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; color: rgb(36, 41, 46); font-family: -apple-system, &quot;system-ui&quot;, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; text-align: start; background-color: rgb(255, 255, 255);" width="700" referrerpolicy="no-referrer"></iframe></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 15 Dec 2023 04:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271182</guid>
            <link>https://www.oschina.net/news/271182</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 「泄露」 GPT-4.5，价格是 GPT-4 的 6 倍]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenAI 官网的产品价格订阅页面似乎意外地「泄露」了 GPT-4.5。按照页面的信息，GPT-4.5 的价格是目前 GPT-4 的 6 倍。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-31d1ece739917eff1f166c5dbe37cdaf3cd.png" referrerpolicy="no-referrer"></p><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reddit.com%2Fr%2FOpenAI%2Fcomments%2F18i5n29%2Fanyone_hear_of_gpt45_drop_today%2F" target="_blank">https://www.reddit.com/r/OpenAI/comments/18i5n29/anyone_hear_of_gpt45_drop_today/</a></u></em></p></blockquote><p>根据描述，最先进的模型带来了<strong>跨语言、音频、视觉、视频和 3D 的多模态功能，以及复杂的推理和跨模态理解</strong>，以及 3 个新型号：</p><ul><li>GPT-4.5</li><li>GPT-4.5-64k</li><li>GPT-4.5-audio-and-speech</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Fri, 15 Dec 2023 03:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271170/openai-leak-gpt45</guid>
            <link>https://www.oschina.net/news/271170/openai-leak-gpt45</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[夸克浏览器 PC 版开启内测]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff"><span style="color:#555555">夸克浏览器今天正式开启 PC 版本的内测，安装包大小 165 MB，基于 Chromium&nbsp;112 内核版本打造，目前内测版本功能相对简单，主打夸克小工具和夸克网盘。</span></span></p><p><span style="background-color:#ffffff"><span style="color:#555555"><img alt="" height="313" src="https://oscimg.oschina.net/oscnet/up-7d2b1e9f052bd1f16e693666b844526c384.png" width="500" referrerpolicy="no-referrer"></span></span></p><p><span style="color:#555555"><img alt="" height="313" src="https://oscimg.oschina.net/oscnet/up-c1abc7d9868a44f006af303db9fc34bc1f2.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="background-color:#ffffff"><span style="color:#555555"><img alt="" height="319" src="https://oscimg.oschina.net/oscnet/up-1a021e823d1e28e62da4d57b8883ec880ef.png" width="300" referrerpolicy="no-referrer"></span></span></p><p><span style="background-color:#ffffff"><span style="color:#555555">安装完成，需要使用夸克浏览器手机版扫码登录，登录后的界面</span></span></p><p><span style="background-color:#ffffff"><span style="color:#555555"><img alt="" height="338" src="https://oscimg.oschina.net/oscnet/up-118ef3c22895713a51398d5edfc8ff9bde0.png" width="500" referrerpolicy="no-referrer"></span></span></p><p><span style="background-color:#ffffff"><span style="color:#555555">文件工具中心</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 15 Dec 2023 03:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271168</guid>
            <link>https://www.oschina.net/news/271168</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[游戏引擎 Godot 4.2.1 发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Godot 4.2.1 现已发布，</span><span style="background-color:#ffffff; color:#000000">共有 42 位贡献者提交了约 74 项改进。</span><span style="color:#000000">这是&nbsp;</span><a href="https://www.oschina.net/news/268993/godot-4-2-arrives-in-style-stable" target="news">Godot 4.2</a>&nbsp;的<span style="color:#000000">第一个维护版本，它解决了其中一些问题，同时完全保持兼容性。</span></p><p><span style="color:#000000"><img alt="" height="281" src="https://oscimg.oschina.net/oscnet/up-472537cd914c94a5ea23c76df0066b4f9cf.webp" width="500" referrerpolicy="no-referrer"></span></p><p style="text-align:start"><span style="color:#000000">此版本中的一些最重要的修复是：</span></p><ul><li><p><span><span><span>对于 macOS 上的 GL 兼容性渲染器，项目团队从 Metal ANGLE 后端切换回原生 OpenGL 驱动程序。他们原本希望 ANGLE 的 Metal 后端能够使兼容性渲染器面向未来（因为 Apple 已弃用其原生 OpenGL 支持），并修复 macOS 上 OpenGL 驱动程序的一些已知驱动程序错误。但事实证明，ANGLE 的 Metal 后端带来的问题比它解决的问题还要多，因此他们回滚了默认后端的更改 (<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgodotengine%2Fgodot%2Fpull%2F85785" target="_blank">GH-85785</a>)。</span></span></span></p></li><li><p><span><span><span>还是在 macOS 上，新的 iOS 一键部署功能需要安装 Xcode，并在编辑器启动时使用&nbsp;<code class="language-plaintext">xcode-select</code>&nbsp;进行检查。这可能会触发一个安装对话框，使 Godot 显示为冻结状态，而不向用户明确说明问题。项目团队改为使用&nbsp;<code class="language-plaintext">mdfind</code>&nbsp;检查 Xcode 是否已安装，以解决此问题 (<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgodotengine%2Fgodot%2Fpull%2F85774" target="_blank">GH-85774</a>)。</span></span></span></p></li><li><p><span><span><span>Android 上的 Vulkan 渲染器的一些 Bug 已得到解决，这些&nbsp;Bug 可能会导致崩溃或网格损坏 (<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgodotengine%2Fgodot%2Fpull%2F84852" target="_blank">GH-84852</a>)。这也可能解决了某些 Android 设备上的 garbled tilemap 渲染问题，但还需确认。</span></span></span></p></li><li><p><span><span><span>许多使用 4.1 版 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgodot-jolt%2Fgodot-jolt%2F" target="_blank">Godot Jolt</a>&nbsp;插件的用户在将他们的项目升级到 4.2 版时都遇到了编辑器崩溃的问题，这是因为旧版本的 Godot Jolt 存在一个错误，导致它与 Godot 4.2 不兼容。鉴于这个问题似乎非常普遍，项目团队决定专门为 Godot Jolt 添加一个 hack，以防止加载已知与 Godot 4.2 不兼容的旧版本 (<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgodotengine%2Fgodot%2Fpull%2F85779" target="_blank">GH-85779</a>）。在成功加载禁用了 Godot Jolt 的项目后，应删除已安装的旧版本，并重新安装与 Godot 4.2 兼容的最新版本。</span></span></span></p></li><li><p><span><span><span>还修复了处理 TileMap occluders 时出现的回归问题 (<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgodotengine%2Fgodot%2Fpull%2F85893" target="_blank">GH-85893</a>)。</span></span></span></p></li><li><p><span><span><span>最近的 Emscripten 版本更改了默认堆栈大小，这导致在使用某些 API 时，Godot 4.2 中的 Web 导出出现问题。添加了所需的 linker flags 来恢复旧版 Emscripten 的行为，确保 Godot 在由最新 Emscripten 版本编译后可以成功运行 (<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgodotengine%2Fgodot%2Fpull%2F86036" target="_blank">GH-86036</a>)。</span></span></span></p></li></ul><p>更多详情可查看官方<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgodotengine.org%2Farticle%2Fmaintenance-release-godot-4-2-1%2F" target="_blank">公告</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 15 Dec 2023 03:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271165/godot-4-2-1-released</guid>
            <link>https://www.oschina.net/news/271165/godot-4-2-1-released</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Bytebase 2.12.0 - 改进自动补全和布局导航]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>🚀 新功能</h2><ul><li>支持 MySQL 高级自动补全。</li><li>支持从 UI 上导入分类分级配置。 <img src="https://oscimg.oschina.net/oscnet/up-0268af7aad60dafccd3d2d9f573a25e45b2.png" alt="file" referrerpolicy="no-referrer"></li></ul><h2>🔔 重大变更</h2><ul><li>作废已有企业版试用证书。之后可以通过提交申请获取新的试用证书。</li></ul><h2>🎄 改进</h2><ul><li><p>改进整体布局和导航。</p></li><li><p>支持在 SQL 编辑器里显示以及查询 PostgreSQL 数据库分区表。</p></li><li><p>优化对数据库/实例/慢查询的过滤体验。 <img src="https://oscimg.oschina.net/oscnet/up-0e38c7ab958fb392f60f9f749b38a5a5e48.png" alt="file" referrerpolicy="no-referrer"></p></li><li><p>Schema 编辑器性能优化。</p></li><li><p>支持 TiDB 7.5。</p></li><li><p>提升 MySQL SQL 审核，的兼容性。</p></li></ul><h2>🐞 Bug 修复</h2><ul><li>修复了当结果太大无法查询 MongoDB 的问题。</li><li>修复了在 SQL Editor 中无法查询 PostgreSQL 视图的问题。</li></ul><h2>🎠 社区</h2><ul><li>感谢 @jinrenjie 提交 fix(smtp): fix host name error in smtp authentication #9674</li></ul><h2>📕 安装及升级</h2><p>参考<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbytebase%2Fbytebase%23installation" target="_blank">升级指南</a>。如果从之前版本升级，获取新版本后，重新启动升级即可。</p><hr><p>💡 更多资讯，请关注 Bytebase 公号：Bytebase</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 15 Dec 2023 03:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6148470/blog/10321743</guid>
            <link>https://my.oschina.net/u/6148470/blog/10321743</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[互联网大厂月薪分布：字节跳动超 5% 员工月薪高于 5 万]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>某统计机构公开了一份国内互联网大厂的月薪分布。从统计来看，贝壳、阿里、滴滴、拼多多、快手和腾讯有超过 60% 的员工，月薪都在 3-5 万区间。而拼多多和字节跳动，还有 5% 以上的员工月薪超过了 5 万。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6dee49384f61d67489bea92afa25362f142.png" referrerpolicy="no-referrer"></p><p>大家熟悉的华为，有 51% 的员工月薪在 3-5 万区间（3.4% 员工月薪超过 5 万），而小米这个数字为 47.5%。</p><p>事实上，不少互联网公司内部都有等级评定，而像华为、阿里、腾讯内部，级别高的员工甚至年薪+分红都轻松过百万。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 15 Dec 2023 03:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/271163</guid>
            <link>https://www.oschina.net/news/271163</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
