<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-最新资讯]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-最新资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 30 Nov 2023 02:29:51 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[幻方量化旗下 DeepSeek 发布 67B 开源大模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">知名私募巨头幻方量化<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZj7gPGqJ8UTTxp1umfWjKQ" target="_blank">宣布</a>，其探索 AGI（通用人工智能）的新组织「深度求索（DeepSeek）」继 11 月初发布 Coder 代码模型之后，正式发布通用大语言模型：DeepSeek LLM 67B。模型已完全开源，同时服务已经全面开放内测。</span></p><p><span style="color:#000000">目前 DeepSeek 已同时开源 7B 和 67B 的两种规模模型，均含基础模型（base）和指令微调模型（chat）。无需申请，免费商用。同时，项目团队还将训练中途的 9 个模型 checkpoints 开放下载。</span></p><p><span style="color:#000000">相比开源的同级别模型 LLaMA2 70B，DeepSeek LLM 67B 在近 20 个中英文的公开评测榜单上表现更佳。尤其突出的是推理、数学、编程等能力（如：HumanEval、MATH、CEval、CMMLU）。</span></p><p><img height="412" src="https://oscimg.oschina.net/oscnet/up-90b96f11cad1cebc1a6f8ed065af941752e.png" width="500" referrerpolicy="no-referrer"></p><p><img height="418" src="https://oscimg.oschina.net/oscnet/up-b18e003f54e25e5fcb9112b2733d0c1afc3.png" width="500" referrerpolicy="no-referrer">&nbsp;</p><p><img height="418" src="https://oscimg.oschina.net/oscnet/up-ae3911e345f12b177ff22551b6f2adfd615.png" width="500" referrerpolicy="no-referrer"></p><p><img height="432" src="https://oscimg.oschina.net/oscnet/up-fb75c7324ae7131702fad2abdc8a6f96af6.png" width="500" referrerpolicy="no-referrer"></p><p><img height="288" src="https://oscimg.oschina.net/oscnet/up-2f23eeacbc701e424120f6c2507412d23de.png" width="500" referrerpolicy="no-referrer"></p><p><img height="418" src="https://oscimg.oschina.net/oscnet/up-4e497e6c1d9e0cb35dfd6f064c7ad2f7ea0.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:25:47 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268792</guid>
            <link>https://www.oschina.net/news/268792</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[助力 AI 开发，openKylin AI 框架安装助手正式发布！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0; margin-right:0; text-align:justify"><span>当前，以大模型为代表的人工智能技术迅猛发展，成为全球技术焦点，越来越多的开发者投入到人工智能技术的学习和应用中。AI 框架是 AI 算法模型设计、训练和验证的一套标准接口、特性库和工具包，集成了算法的封装、数据的调用以及计算资源的使用，同时面向开发者提供了开发界面和高效的执行平台，是现阶段 AI 算法开发的必备工具。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span>目前在操作系统上安装 AI 框架并不是件容易的事情，需要安装合适的显卡驱动、加速工具、依赖软件以及配置系统环境等。每一个环节出问题都会导致 AI 框架安装失败。</span><strong><span>为了让 AI 开发者能够更快的投入到算法设计和 AI 开发当中，openKylin 社区 AI4OS SIG 组开发了 AI 框架安装助手</span></strong><strong><span>，助力 AI 开发者实现一键安装 AI 框架</span></strong><span>。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span>AI 框架安装助手采用前后端分离架构：前端负责检测系统硬件，自动推荐安装方式，提供安装选择，获取安装选项，显示安装信息及进度；后端执行具体任务并向前端及时反馈信息。该架构提高了开发效率、可维护性和可扩展性，同时也提供了更好的用户体验。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><strong><span>openKylin AI 框架安装助手具有以下特点：</span></strong></p><ol><li><span style="color:#0052ff"><strong>智能推荐</strong></span>，用户只需选择需要安装的 AI 框架，应用根据系统硬件智能推荐最佳安装方式，同时支持用户选择。</li><li><span style="color:#0052ff"><strong>一键自动</strong></span>，软件自动安装最适合的硬件驱动，加速工具，依赖软件，并且配置好系统环境。免去了繁复的安装过程和系统环境配置。</li><li><span style="color:#0052ff"><strong>无需值守</strong></span>，由于网络等原因造成的安装失败，能自动恢复继续安装。</li><li><span style="color:#0052ff"><strong>过程可见</strong></span><span>，软件显示安装的各个步骤，以及各个步骤的进度等信息。</span></li><li><span style="color:#0052ff"><strong>节省资源</strong></span><span>，支持资源断点继续下载，过程断点继续安装。</span></li><li><span style="color:#0052ff"><strong><span>支持</span>热更新</strong></span><span>，确保能及时更新 AI 框架版本以及安装方式，同时能以最快的速度解决软件可能存在的 BUG。</span></li><li><span style="color:#0052ff"><strong>界面友好</strong></span><span>，采用简洁、直观的 AI 框架选项，并提供良好的安装过程反馈。</span></li></ol><p style="text-align:center"><img alt="" height="1800" src="https://oscimg.oschina.net/oscnet/up-e6dc32eede425550f426b66a8c26400aaee.png" width="2880" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>目前，openKylin AI 框架安装助手已上架至软件商店。后续，AI4OS SIG 也将持续开发，优化 openKylin AI 框架安装助手交互界面、支持更多主流 AI 框架及其套件等等，紧跟人工智能技术发展的潮流，更好地助力 AI 开发者！</span></p><p><span>AI4OS SIG 致力于为 openKylin 社区适配主流的 AI 框架，同时将人工智能（AI）与操作系统（OS）相结合，以实现 openKylin 操作系统的智能化和性能优化，欢迎感兴趣的小伙伴加入！</span></p><ul><li><p style="margin-left:0; margin-right:0; text-align:justify"><span>项目地址：</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#0052ff">https://gitee.com/openkylin/ai-frame-installer</span></p></li><li><p><span>AI4OS SIG 主页：</span></p><p><span style="color:#0052ff">https://gitee.com/openkylin/community/tree/master/sig/AI4OS</span></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:19:47 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268789</guid>
            <link>https://www.oschina.net/news/268789</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 正式宣布 Sam Altman 回归担任 CEO]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenAI 今天<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Fblog%2Fsam-altman-returns-as-ceo-openai-has-a-new-initial-board">正式宣布</a></u>，Sam Altman 回归 OpenAI 担任 CEO 一职。与此同时，Mira Murati 仍将继续担任 CTO 一职，Greg Brockman 也将继续担任 OpenAI 总裁。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a1347c1ff57c70bc945b594b050d3a5203b.png" referrerpolicy="no-referrer"></p><p>此外，OpenAI 成立全新董事会，董事会主席由 Bret Taylor 担任。其他的董事会成员还包括 Larry Summers 以及 Adam D'Angelo。</p><p>Ilya Sutskever 、Tasha McCauley 以及 Helen Toner 将退出董事会。不过 Sam Altman 表示，<strong>正在讨论如何让 Ilya Sutskever 继续在 OpenAI 工作</strong>。</p><p>OpenAI 还让微软以「<strong>无投票权观察员</strong>」的身份加入董事会，他们将有更多机会了解公司的内部运作，但在重大决策中没有正式投票权。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:18:47 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268788/altman-returns-as-ceo-openai-has-a-new-initial-board</guid>
            <link>https://www.oschina.net/news/268788/altman-returns-as-ceo-openai-has-a-new-initial-board</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[MobSlide —— 将智能手机变成演示文稿遥控器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>MobSlide 是一个可将你的将智能手机变成演示文稿遥控器的工具。</p><p><img alt="" height="225" src="https://static.oschina.net/uploads/space/2023/1122/142007_UPpG_4252687.png" width="300" referrerpolicy="no-referrer">&nbsp;<img alt="" height="225" src="https://static.oschina.net/uploads/space/2023/1122/142018_XS3R_4252687.png" width="300" referrerpolicy="no-referrer"></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>适用于 MacOS 和 Windows。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Tauri for Linux 不支持 webrtc，因此目前不支持 Linux</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>用法</strong></p><p><span style="background-color:#ffffff; color:#1f2328">使用智能手机扫描二维码并打开链接。</span></p><p><img alt="" height="225" src="https://static.oschina.net/uploads/space/2023/1122/141937_4l9Z_4252687.png" width="300" referrerpolicy="no-referrer"></p><p><strong>特性：</strong></p><ul><li>扫描二维码。无需安装</li><li>轻量级应用程序<code>~2.5M</code></li><li>简约而有效的设计</li></ul></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:17:47 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/mobslide</guid>
            <link>https://www.oschina.net/p/mobslide</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 内存型消息中间件 FolkMQ]]>
            </title>
            <description>
                <![CDATA[<h1 align="center"><a id="user-content---folkmq" class="anchor" href="https://gitee.com/noear/folkmq#--folkmq"></a>
  FolkMQ
</h1><p align="center"><strong>一个内存型消息中间件（支持快照持久化、Broker 集群）</strong></p><p align="center"><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fsearch.maven.org%2Fartifact%2Forg.noear%2Ffolkmq"><img src="https://img.shields.io/maven-central/v/org.noear/folkmq.svg?label=Maven%20Central" alt="Maven" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.apache.org%2Flicenses%2FLICENSE-2.0.txt"><img src="https://img.shields.io/:license-Apache2-blue.svg" alt="Apache 2" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjavase-jdk8-downloads.html"><img src="https://img.shields.io/badge/JDK-8-green.svg" alt="jdk-8" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk11-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-11-green.svg" alt="jdk-11" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk17-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-17-green.svg" alt="jdk-17" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk21-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-21-green.svg" alt="jdk-21" referrerpolicy="no-referrer"></a><br><a target="_blank" href="https://gitee.com/noear/folkmq/stargazers"><img src="https://gitee.com/noear/folkmq/badge/star.svg" alt="gitee star" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fnoear%2Ffolkmq%2Fstargazers"><img src="https://img.shields.io/github/stars/noear/folkmq.svg?logo=github" alt="github star" referrerpolicy="no-referrer"></a></p><br><p align="center"><a href="https://gitee.com/link?target=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3DkjB5JNiC"><img src="https://img.shields.io/badge/QQ%E4%BA%A4%E6%B5%81%E7%BE%A4-870505482-orange" referrerpolicy="no-referrer"></a></p><hr><h2><a id="user-content-简介" class="anchor" href="https://gitee.com/noear/folkmq#%E7%AE%80%E4%BB%8B"></a>简介</h2><ul><li>采用，类似 Redis 的策略（内存运行 + 快照持久化）</li><li>功能，订阅、取消订阅、发布消息、发布定时消息、ACK，自动重试、延时策略、Qos0、Qos1</li><li>集群，采用 Socket.D Broker 集群模式</li><li>支持，使用 ws,udp 通讯（或许，也可用于物联网）</li></ul><h2><a id="user-content-特点" class="anchor" href="https://gitee.com/noear/folkmq#%E7%89%B9%E7%82%B9"></a>特点</h2><ul><li>快、是真的快（大约 100_000 TPS）。有点像 Redis 之于 MySql。</li></ul><img src="https://gitee.com/noear/folkmq/raw/main/DEV-TEST.png" width="600" referrerpolicy="no-referrer"><p>//使用 MacBook pro 2020 + JDK8 本机测试，单客户端发与收（跑分难免有波动，我是选了好看点的）</p><ul><li>简单的管理后台</li></ul><img src="https://gitee.com/noear/folkmq/raw/main/DEV-PREVIEW.png" width="600" referrerpolicy="no-referrer"><h3><a id="user-content-加入到社区交流群" class="anchor" href="https://gitee.com/noear/folkmq#%E5%8A%A0%E5%85%A5%E5%88%B0%E7%A4%BE%E5%8C%BA%E4%BA%A4%E6%B5%81%E7%BE%A4"></a>加入到社区交流群</h3><table><thead><tr><th>QQ 交流群：316697724</th><th>微信交流群（申请时输入：FolkMQ）</th></tr></thead><tbody><tr><td></td><td><img src="https://gitee.com/noear/folkmq/raw/main/group_wx.png" width="120" referrerpolicy="no-referrer"></td></tr></tbody></table><h2><a id="user-content-开发过程视频记录" class="anchor" href="https://gitee.com/noear/folkmq#%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%A7%86%E9%A2%91%E8%AE%B0%E5%BD%95"></a>开发过程视频记录</h2><ul><li>开发过程视频：<a href="https://gitee.com/noear/folkmq/blob/main/DEV-RECORD.md">《DEV-RECORD.md》</a></li><li>成果展示：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1mc411D7pY%2F">《[FolkMQ] 一个新的内存型消息队列（快，特别的快）》</a></li><li>快速入门：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1Yj411L7fB%2F">《FolkMQ - Helloworld 入门》</a></li></ul><h2><a id="user-content-服务端容器镜像" class="anchor" href="https://gitee.com/noear/folkmq#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F"></a>服务端容器镜像</h2><table><thead><tr><th>镜像</th><th>说明</th></tr></thead><tbody><tr><td>noearorg/folkmq-server:1.0.10</td><td>服务端（主端口：8602，消息端口：18602）</td></tr><tr><td>noearorg/folkmq-broker:1.0.10</td><td>服务端（主端口：8602，消息端口：18602）</td></tr></tbody></table><p>当使用 broker 集群时，把 folkmq-server 端口改成：8601</p><ul><li>可选配置</li></ul><table><thead><tr><th>属性或环境变量</th><th>默认值</th><th></th></tr></thead><tbody><tr><td><code>server.port</code></td><td>8602</td><td>主端口 (http，管理用)</td></tr><tr><td></td><td>18602</td><td>消息端口 (tcp)，等于主端口+10000</td></tr><tr><td><code>folkmq.admin</code></td><td>admin</td><td>管理密码</td></tr></tbody></table><ul><li>添加消息访问账号：</li></ul><p>添属性或环境变量，例： <code>folkmq.access.ak1=sk1</code>，<code>folkmq.access.ak2=sk2</code></p><h2><a id="user-content-helloworld" class="anchor" href="https://gitee.com/noear/folkmq#helloworld"></a>Helloworld</h2><h3><a id="user-content-1 启动服务-更多部署参考部署说明" class="anchor" href="https://gitee.com/noear/folkmq#1%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1-%E6%9B%B4%E5%A4%9A%E9%83%A8%E7%BD%B2%E5%8F%82%E8%80%83%E9%83%A8%E7%BD%B2%E8%AF%B4%E6%98%8E"></a>1、启动服务 (更多部署参考：<a href="https://gitee.com/noear/folkmq/blob/main/deploy">部署说明</a>)</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker run -p 18602:18602 -p 8602:8602 noearorg/folkmq-server:1.0.10 </span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-2 编写客户端代码" class="anchor" href="https://gitee.com/noear/folkmq#2%E7%BC%96%E5%86%99%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"></a>2、编写客户端代码</h3><ul><li>maven import</li></ul><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;dependencies&gt;</span></span><span id="LC2" class="line"><span class="c">&lt;!-- 可选包：java-tcp（90kb 左右）, smartsocket（260Kb 左右）, netty（2.5Mb 左右） --&gt;</span></span><span id="LC3" class="line"><span class="nt">&lt;dependency&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;groupId&gt;</span>org.noear<span class="nt">&lt;/groupId&gt;</span></span><span id="LC5" class="line"><span class="nt">&lt;artifactId&gt;</span>folkmq-transport-java-tcp<span class="nt">&lt;/artifactId&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;version&gt;</span>1.0.10<span class="nt">&lt;/version&gt;</span></span><span id="LC7" class="line"><span class="nt">&lt;/dependency&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;/dependencies&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><ul><li>client(consumer + producer) use</li></ul><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">public</span><span class="kd">class</span><span class="nc">ClientDemo1</span><span class="o">{</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kd">static</span><span class="kt">void</span><span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span><span class="n">args</span><span class="o">)</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC3" class="line"><span class="c1">//客户端（鉴权为可选。服务端，不添加则不鉴权）</span></span><span id="LC4" class="line"><span class="nc">MqClient</span><span class="n">client</span><span class="o">=</span><span class="nc">FolkMQ</span><span class="o">.</span><span class="na">createClient</span><span class="o">(</span><span class="s">"folkmq://127.0.0.1:18602?ak=folkmq&amp;sk=YapLHTx19RlsEE16"</span><span class="o">)</span></span><span id="LC5" class="line"><span class="o">.</span><span class="na">connect</span><span class="o">();</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="c1">//订阅（consumer = ip or cluster name）</span></span><span id="LC8" class="line"><span class="n">client</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="s">"demo"</span><span class="o">,</span><span class="s">"demoapp"</span><span class="o">,</span><span class="n">message</span><span class="o">-&gt;</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">);</span></span><span id="LC10" class="line"><span class="o">});</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">//发布</span></span><span id="LC13" class="line"><span class="n">client</span><span class="o">.</span><span class="na">publish</span><span class="o">(</span><span class="s">"demo"</span><span class="o">,</span><span class="s">"helloworld!"</span><span class="o">).</span><span class="na">get</span><span class="o">();</span></span><span id="LC14" class="line"><span class="o">}</span></span><span id="LC15" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-自动重试与延时策略" class="anchor" href="https://gitee.com/noear/folkmq#%E8%87%AA%E5%8A%A8%E9%87%8D%E8%AF%95%E4%B8%8E%E5%BB%B6%E6%97%B6%E7%AD%96%E7%95%A5"></a>自动重试与延时策略</h2><table><thead><tr><th>派发次数</th><th>自动延时</th><th></th></tr></thead><tbody><tr><td>0</td><td>0s</td><td>相当于马上发</td></tr><tr><td>1</td><td>5s</td><td></td></tr><tr><td>2</td><td>30s</td><td></td></tr><tr><td>3</td><td>3m</td><td></td></tr><tr><td>4</td><td>9m</td><td></td></tr><tr><td>5</td><td>15m</td><td></td></tr><tr><td>6</td><td>30m</td><td></td></tr><tr><td>7</td><td>1h</td><td></td></tr><tr><td>n..</td><td>2h</td><td>第 8 次之后都是 2 小时</td></tr></tbody></table><h2><a id="user-content-客户端接口字典" class="anchor" href="https://gitee.com/noear/folkmq#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%8F%A3%E5%AD%97%E5%85%B8"></a>客户端接口字典</h2><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">//消息客户端接口</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kd">interface</span><span class="nc">MqClient</span><span class="o">{</span></span><span id="LC3" class="line"><span class="c1">//连接</span></span><span id="LC4" class="line"><span class="nc">MqClient</span><span class="nf">connect</span><span class="o">()</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC5" class="line"></span><span id="LC6" class="line"><span class="c1">//断开连接</span></span><span id="LC7" class="line"><span class="kt">void</span><span class="nf">disconnect</span><span class="o">()</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">//客户端配置</span></span><span id="LC10" class="line"><span class="nc">MqClient</span><span class="nf">config</span><span class="o">(</span><span class="nc">ClientConfigHandler</span><span class="n">configHandler</span><span class="o">);</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">//自动回执</span></span><span id="LC13" class="line"><span class="nc">MqClient</span><span class="nf">autoAcknowledge</span><span class="o">(</span><span class="kt">boolean</span><span class="n">auto</span><span class="o">);</span></span><span id="LC14" class="line"></span><span id="LC15" class="line"><span class="c1">//订阅主题</span></span><span id="LC16" class="line"><span class="kt">void</span><span class="nf">subscribe</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">consumer</span><span class="o">,</span><span class="nc">MqConsumeHandler</span><span class="n">consumerHandler</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC17" class="line"></span><span id="LC18" class="line"><span class="c1">//取消订阅主题</span></span><span id="LC19" class="line"><span class="kt">void</span><span class="nf">unsubscribe</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">consumer</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC20" class="line"></span><span id="LC21" class="line"><span class="c1">//发布消息</span></span><span id="LC22" class="line"><span class="k">default</span><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">{</span></span><span id="LC23" class="line"><span class="k">return</span><span class="nf">publish</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span><span class="n">content</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span></span><span id="LC24" class="line"><span class="o">}</span></span><span id="LC25" class="line"></span><span id="LC26" class="line"><span class="c1">//发布消息</span></span><span id="LC27" class="line"><span class="k">default</span><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">,</span><span class="kt">int</span><span class="n">qos</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">{</span></span><span id="LC28" class="line"><span class="k">return</span><span class="nf">publish</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span><span class="n">content</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="n">qos</span><span class="o">);</span></span><span id="LC29" class="line"><span class="o">}</span></span><span id="LC30" class="line"></span><span id="LC31" class="line"><span class="c1">//发布消息</span></span><span id="LC32" class="line"><span class="k">default</span><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">,</span><span class="nc">Date</span><span class="n">scheduled</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">{</span></span><span id="LC33" class="line"><span class="k">return</span><span class="nf">publish</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span><span class="n">content</span><span class="o">,</span><span class="n">scheduled</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span></span><span id="LC34" class="line"><span class="o">}</span></span><span id="LC35" class="line"></span><span id="LC36" class="line"><span class="c1">//发布消息</span></span><span id="LC37" class="line"><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">,</span><span class="nc">Date</span><span class="n">scheduled</span><span class="o">,</span><span class="kt">int</span><span class="n">qos</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC38" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div>]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:12:47 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/noear/folkmq</guid>
            <link>https://gitee.com/noear/folkmq</link>
        </item>
        <item>
            <title>
                <![CDATA[关于 deepin V23 的发热、续航问题，我们做了电源配置优化]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>之前一些用户反馈，在使用 deepin （深度）操作系统过程中遇到了 CPU 功耗过高导致的设备发热、续航较差情况，而在这些负载场景下，CPU 的占用往往不高。为了解决这个痛点，deepin 团队特别成立专项计划，对于 deepin 的电源进行专项优化。</p><p>在对电源进行专项优化之前，首先对 deepin （深度）操作系统进行了深入调查和分析，以了解其在负载场景下的实际运行情况。</p><p>经过对 CPU 使用率和功耗的监测，我们发现了一个令人惊讶的事实：尽管在高负载场景下 CPU 的占用率不高，但其功耗却持续升高，最终导致设备发热并影响续航。也就是说，我们前期做的省电优化工作，不仅无效，还起了反作用。那么到底该如何解决这一问题呢？</p><p>在刚刚结束的 DDUC 2023 上，deepin（深度）社区用户 fslong 从社区参与共创的角度，分享了帮助 deepin 团队一起完成优化工作的故事。那么，本文就让我们从 deepin 团队研发工程师的角度来回顾解决这一问题的历程吧！</p><h2><strong>&nbsp;找到问题的根源&nbsp;</strong></h2><p><strong>1.内核</strong><br> 最开始发现问题的地方在内核。有用户将 deepin 的内核和 Ubuntu 的内核进行对比后发现，虽然二者性能相差无几，但是在发热和续航上，较 Ubuntu 落后较多。有用户在 deepin （深度）操作系统上使用 Ubuntu 和其他开源 Linux 发行版的配置文件分别编译内核，发现 deepin 的主要问题在于发热控制上。deepin 团队的测试伙伴高度重视这一社区反馈，对该问题进行复现，佐证了这一现象。</p><p>于是，我们立即联系了内核研发的伙伴，并邀请部分对内核配置有一定研究的社区用户共同参与，合力排查后发现，deepin V23 中提供的 HWE 内核存在部分 debug 和无用的内核选项被开启的情况，并且部分节电功能实际未能获得启用，这些都在一定程度上导致了 deepin V23 的续航表现不佳。</p><p><strong>2. 系统</strong><br> 系统层面，重新审视了 dde-daemon 提供的电源调度模块，并且对比内核文档提供的文件接口，分析用户使用的电源模式，发现其中存在可以优化的空间。这是本文着重讲解的内容之一。</p><h2><strong>一些前置知识&nbsp;</strong></h2><h3><strong>1.ACPI</strong></h3><p>ACPI（Advanced Configuration and Power Interface）是一种计算机硬件和操作系统之间交换能源相关信息的接口规范。它定义了计算机硬件的能源相关信息，如电源供应器状态、设备功耗、设备功率因数等。ACPI 是操作系统控制计算机硬件能源管理的标准，同时也是硬件厂商和操作系统之间通信的标准。<br> 在 deepin （深度）操作系统中，ACPI 负责处理计算机硬件的能源管理，与电源管理模块进行交互，以实现对计算机硬件的能源管理。</p><p>在分析系统层面的问题时，需要了解 ACPI 和电源管理模块的作用和功能，以及它们是如何协同工作的。本文将会详细讲解 ACPI 的工作原理以及 deepin （深度）操作系统中的电源调度模块工作模式，并提出可行优化建议。</p><p>ACPI 的工作原理是：当计算机硬件发生电源变化时，ACPI 会收集硬件信息，并向操作系统发送电源请求。操作系统收到电源请求后，会根据用户配置自动调整各个硬件的电源策略。</p><p>deepin （深度）操作系统的电源模块则是帮助用户生成配置来调整 ACPI 的行为。所以在这一方面，我们能做的就是向 ACPI 提供合理的电源策略，在保证性能的同时，降低设备温度并提升续航表现。</p><h3><strong>2.平台电源配置</strong></h3><p>相关内核文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.kernel.org%2Fuserspace-api%2Fsysfs-platform_profile.html" target="_blank">https://docs.kernel.org/userspace-api/sysfs-platform_profile.html</a></p><p>UEFI ACPI 文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fuefi.org%2Fhtmlspecs%2FACPI_Spec_6_4_html%2Findex.html" target="_blank">https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/index.html</a></p><p>平台电源配置是电源管理模块的重要组成部分，用于管理计算机平台硬件（指所有支持 ACPI 的设备）的电源状态。CPU 也属于 ACPI 设备的一部分，不过 CPU 是计算机的核心发热大户，对于其使用平台电源管理可能粒度较粗，所以 APCI 引入了一些 CPU 独有的性能管理方式，在下一小节将详细说明。</p><p>平台电源配置提供了三种可选模式：performance（性能模式），balance（平衡模式），low-power（节能模式）。一般情况下，用户使用平衡模式就可以。在台式机和 mini 主机类（对于功耗和发热没有任何要求）设备上默认提供性能模式，在笔记本等移动设备上默认提供平衡模式。默认不提供节能模式，因为某些 ACPI 设备在节能模式工作过程中可能出现「睡死现象」，所以为了避免此问题，默认不提供 low-power 节电模式。</p><h3><strong>3.CPU 电源配置</strong></h3><p>传统电源模式（SCalling）内核文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.kernel.org%2Fdoc%2Fhtml%2Fv6.1%2Fadmin-guide%2Fpm%2Fcpufreq.html" target="_blank">https://www.kernel.org/doc/html/v6.1/admin-guide/pm/cpufreq.html</a></p><p>Intel PState 内核文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.kernel.org%2Fdoc%2Fhtml%2Fv6.1%2Fadmin-guide%2Fpm%2Fintel_pstate.html" target="_blank">https://www.kernel.org/doc/html/v6.1/admin-guide/pm/intel_pstate.html</a></p><p>AMD PState 内核文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.kernel.org%2Fadmin-guide%2Fpm%2Famd-pstate.html" target="_blank">https://docs.kernel.org/admin-guide/pm/amd-pstate.html</a></p><p>如果有时间，可以自行研读上述电源文档，就很容易理解 CPU 电源配置相关内容。作者在这里的讲述将忽略大量技术细节和实现方式，仅表述如何调整 CPU 的电源模式。</p><p>在 /sys/devices/system/cpu/cpufreq 目录下有许多文件名为 policy&lt;x&gt;（x 代表核心编号），这些文件对应着电脑上的 CPU 核心，而 CPU 的电源调度细节就在这些文件夹里。在 policy&lt;x&gt; 目录下有一个文件`scaling_driver`，使用 cat 或其他方式访问它，得到的结果就是当前使用的调度器：</p><ul><li>intel_cpufreq / acpi_cpufreq : 使用 scaling freq 调度；</li><li>intel_pastate : 使用 Intel PState 调度；</li><li>amd-pstate : 使用 AMD PState 调度。</li></ul><p><strong>&nbsp;scalling freq 调度</strong></p><p>这是最传统的 CPU 调度方式，可以在 policy 文件夹下的 scaling_available_governors 获取可选电源模式：</p><p style="text-align:center"><img height="742" src="https://oscimg.oschina.net/oscnet/up-30d23181f6f0f60ab32af9f63d163238aa5.png" width="765" referrerpolicy="no-referrer"></p><p>其实这些平衡模式的作用都是是一样的：平衡性能和续航，不过使用的算法可能不同。</p><p><strong>Intel PState</strong></p><p>这是 Intel 近几代 CPU 独享的 moment，内核开启 Intel PState 后（deepin V23 内核默认开启），在 policy 文件夹下多了几个文件：</p><p>我们只需要关注：</p><ul><li>energy_performance_available_perference : 可用的 PState 电源调度；</li><li>energy_performance_perference：当前选定的 PState 电源调度，可以更改此文件内容来更改电源调度。</li></ul><p>在 Intel PState 中出现了两个新的调度方案：</p><ul><li>balance_performance : 平衡偏性能，平时工作频率不高，在负载增大时能快速响应；</li><li>balance_power : 平衡偏节能，电源策略较为保守，在部分电脑上还有 default 方案，此方案就是经过 PState 优化过的 balance 策略。具体 PState 使用的黑魔法以及主动模式和被动模式的调度策略，可以参照内核文档进行分析。</li></ul><p><strong>AMD PState</strong></p><p>这是 AMD ZEN2 以上用户，以及支持 kernel 6.4.x 用户独享的 moment。其实 AMD 在 6.1 内核已经做了 PState 的支持，不过是被动模式。</p><ul><li>（Actvie Mode）主动模式</li></ul><p>Active Mode 仅在内核版本大于 6.4 以上，且内核选项打开 AMD PState 时可用。可能需要在 grub 内加入启动参数以打开此功能：amd_pstate=active，也可以修改文件实现 Active Mode 的电源策略和 Intel PStatewi 类似。</p><ul><li>（Passive Mode）被动模式</li></ul><p>Passtive Mode 仅在内核大于 6.1 以上，且内核选项打开 AMD PState 时可用。可能需要在 grub 加入启动参数开启此功能：amd_pstate=passive，也可修改文件实现。</p><p>Passive Mode 提供两种电源模式，在/sys/device/system/cpu/cpufreq/scaling_governor 文件进行调整：</p><p>（1）performance 使用 platform_profile 进行配置，调度积极性较高；<br> （2）scheutils 在/sys/device/system/cpu/cpufreq/schedutil/rate_limit_us 文件中调整调度粒度（两次调度的间隔时间）和 ACPI 的 scheutils 类 &nbsp;/sys/device/system/cpu/cpufreq/scaling_governor 。</p><ul><li>（Guided Mode）引导模式</li></ul><p>Guided Mode 仅在内核大于 6.1 以上，且内核选项打开 AMD PState 时可用。可能需要在 grub 加入启动参数开启此功能：amd_pstate=guided，也可修改文件实现。这就类似汽车的自动挡，驱动程序请求最低和最大性能级别，平台自动选择此范围内适合当前工作负荷的性能级别。</p><h3><strong>4.GPU 电源管理部分</strong></h3><p><strong>&nbsp;AMD GPU</strong></p><p>如果是 AMD GPU 则需要更改两个文件（使用 tee 命令进行写入）：</p><ul><li>/sys/class/drm/card0/device/power_dpm_state（这是一个遗留接口，目的是向后兼容）；</li><li>performance 高性能模式；</li><li>balance 平衡模式；</li><li>battery 节能模式；</li><li>/sys/class/drm/card0/device/power_dpm_force_performance_level 。</li></ul><p>以下设置来自 AMD 官方驱动文档：</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdri.freedesktop.org%2Fdocs%2Fdrm%2Fgpu%2Famdgpu.html%23power-dpm-force-performance-level" target="_blank">https://dri.freedesktop.org/docs/drm/gpu/amdgpu.html#power-dpm-force-performance-level</a></p><pre><code>power_dpm_force_performance_level:</code></pre><p>AMD GPU 驱动程序提供了一个 sysfs API，用于调整某些与功率相关的参数。文件 power-dpm-force-performance-level 将用于执行此操作。它接受以下参数：</p><ul><li>auto：当选择 auto 时，设备将尝试针对驱动中的当前条件动态选择最佳功率曲线；</li><li>low：当选择低时，GPU 被强制到最低功率状态；</li><li>high：当选择高时，GPU 被强制到最高功率状态；</li><li>manual：当选择手动时，用户可以通过 sysfs pp_dpm_mclk、pp_dpm_sclk 和 pp_dpm_pcie 文件手动调整每个时钟域启用的电源状态，并通过 pp_power_profile_mode sysfs 文件调整电源状态转换方式；</li><li>profile_standard 固定时钟级别分析模式。此模式将时钟设置为固定级别，该级别因 ASIC 而异。这对于分析特定工作负载很有用（不常用）；</li><li>profile_min_sclk 最小 SCLK 分析模式。此模式将 SCLK 强制设置为最低级别。这对于分析最小功耗的场景很有用（不常用）；</li><li>profile_min_mclk 最小 MCLK 分析模式。此模式将 MCLK 强制设置为最低级别。这对于分析最小功耗的场景很有用（不常用）；</li><li>profile_peak 峰值分析模式。此模式将所有时钟（MCLK、SCLK、PCIe）设置为最高级别。这对于分析最大性能的场景很有用（不常用）。</li></ul><p><strong>测试：</strong></p><ul><li>Low 模式的跑分</li></ul><p style="text-align:center"><img height="527" src="https://oscimg.oschina.net/oscnet/up-a7c7db000560426ab1a9b7c748e27c0a1b7.png" width="905" referrerpolicy="no-referrer"></p><ul><li>Auto 模式的跑分</li></ul><p style="text-align:center"><img height="368" src="https://oscimg.oschina.net/oscnet/up-5bb4cd6ed50bbcdc27d0be3b221b6393b32.png" width="715" referrerpolicy="no-referrer"></p><ul><li><p>High 模式的跑分</p></li></ul><p><img height="482" src="https://oscimg.oschina.net/oscnet/up-34be1d83b01eab80986cba3af73de7fbe2d.png" width="885" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><strong>Intel GPU</strong></p><p>Intel GPU 使用的 i915 驱动，并不希望你对其做出调整，因为其驱动自带的电源策略已经足够聪明。不过你也可以通过 Intel 提供的 intel-gpu-tools 进行调整和获取信息。</p><pre><code>sudo apt install intel-gpu-tools &nbsp; </code></pre><p>然后使用</p><pre><code>sudo intel_gpu_frequency</code></pre><p>来获取当前频率（当前使用的是 Intel A750）。</p><p style="text-align:center"><img height="133" src="https://oscimg.oschina.net/oscnet/up-8f915468117bd14d8fe8cefa8f8035b08d6.png" width="594" referrerpolicy="no-referrer"></p><p>可以看到 Intel 的显卡驱动是在 600 MHz 到 2400 MHz 之间动态调整（如上图）。</p><p>测试笔记本下 Intel 核显跑分如下：</p><p style="text-align:center"><img height="490" src="https://oscimg.oschina.net/oscnet/up-97908337d81f9e30651c110d9dddbf88129.png" width="732" referrerpolicy="no-referrer"></p><p><strong>NVIDIA</strong></p><p>由于 NVIDIA 驱动不开源，所以在系统层面无法对其做控制。</p><h2><strong>应用级别的省电&nbsp;</strong></h2><p>应用级别的省电，应该就是在保证用户使用流畅度的情前提下节省性能。之前也有用户提出过，是否能参照某手机厂商的不公平调度算法来实现优化，毕竟安卓系统的底层也是 Linux，理论上实现难度不大。</p><p>Cgroups，全称 Control Groups，是 Linux 内核提供的一种资源管理机制，用于对进程分组并对其资源进行限制和隔离。Cgroups 可以用于限制进程的 CPU、内存、磁盘、网络等资源，也可以用于限制进程的优先级和 IO 权限。利用其提供的能力，很容易实现类似不公平调度算法（新的 AM 天然支持 Cgroups 的操作），但是还有一些顾虑：</p><ul><li>不同于手机操作系统，计算机操作系统是多任务并行的，在多数窗口管理器下，我们并没有一个明显的前台应用，此时使用不公平调度可能存在隐患；</li><li>容易引发人机对抗。在我的观念里面，计算机是为人服务的，那么用户的意志必定是第一优先级，所以我们不应改变用户的行为，如果使用不平衡调度和用户预期不一致，会极大降低用户体验；</li><li>使用前后台区分应用，可能导致开销和收益比下降，性价比不高。Linux 桌面不像安卓设备有明显前后台，用户频繁切换应用的操作将导致调度器频繁切换调度，使得开销过大。最佳的解决方案是：提供能力，但不提供方案。可以提供基于 Cgroups 方式修改应用组的优先级，然后让用户自己选择什么应用优先级更高，什么应用优先级低，以实现调度（比如在 dock 上右键选择优先级）或提供一套配置以供用户自由选择。</li></ul><p>如果一个电脑需要使用不平衡调度来保证使用流畅性，可能这并不是一个操作系统能解决的问题，而更应该考虑硬件是否需要更换，以保证多任务使用的流畅性。</p><h4><strong>附录——常用的调试测试工具</strong></h4><p>1. S-tui</p><p>可以看到 CPU 频率变化，配合 stress 可以对 CPU 进行压力测试。</p><p style="text-align:center"><img height="553" src="https://oscimg.oschina.net/oscnet/up-9035dd7df12eda9d831c879f89d1e2f3230.png" width="1025" referrerpolicy="no-referrer"></p><p>2. intel-gpu-tools</p><p>可以使用 intel_gpu_frequency 来获取和调整 i965 的驱动频率。</p><p>3. GLMark2</p><p>GPU 跑分软件。</p><p>4. stress-ng</p><p>CPU 压力测试软件。</p><p>5. PowerTOP</p><p>电源测试软件，可以看到电源的功耗和使用情况。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:08:47 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268783</guid>
            <link>https://www.oschina.net/news/268783</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | Promise 规范与原理解析]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><span><span>摘要</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Promise 对象用于清晰的处理异步任务的完成，返回最终的结果值，本次分享主要介绍 Promise 的基本属性以及 Promise 内部的基础实现，能够帮我们更明确使用场景、更快速定位问题。</span></span></span></p><span id="OSC_h1_2"></span><h1><span><span><span>Promise 出现的原因</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>首先我们先来看一段代码：异步请求的层层嵌套</span></span></span></p><pre><code><span><span><span>function fn1(params) {
  const xmlHttp = new XMLHttpRequest();
  xmlHttp.onreadystatechange = function(){
    if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
      const fn1Data = {name: 'fn1'}
      console.log(fn1Data, 'fn1Data');
      // 请求 2
      (function fn2() {
        xmlHttp.onreadystatechange = function(){
        if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
          const fn2Data = {name: `${fn1Data.name}-fn2`}
          console.log(fn2Data, 'fn2Data');
          // 请求 3
          (function fn2() {
            xmlHttp.onreadystatechange = function(){
            if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
              const fn3Data = {name: `${fn2Data.name}-fn3`}
              console.log(fn3Data, 'fn3Data');
            }
          }
          xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
          xmlHttp.send();
          })()
        }
      }
      xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
      xmlHttp.send();
      })()
    }
  }
  xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
  xmlHttp.send();
}

fn1()

</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>或者我们可以将上面的代码优化为下面这样</span></span></span></p><pre><code><span><span><span>function fn1(params) {
  console.log(`我是 fn1，我在函数${params}中执行！！！`);
}
  
function fn2(params) {
  try {
    const xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function(){
      if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
        console.log(`我是 fn2，我在函数${params}中执行！！！结果是：`,params.data);
        fn1('fn2')
      }
    }
    xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
    xmlHttp.send();
  } catch (error) {
    console.error(error);
  }
}
  
function fn3() {
  try {
    const xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function(){
      if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
          console.log('fn3 请求已完成');
          fn2('fn3')
      }
    }
    xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
    xmlHttp.send();
    console.log('我是 f3 函数呀');
  } catch (error) {
    console.error(error);
  }
}
  
fn3()

</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>由上面的两种写法的请求可见，在 promise 之前，为了进行多个异步请求并且依赖上一个异步请求的结果时，我们必须进行层层嵌套，大多数情况下，我们又对异步结果进行数据处理，这样使得我们的代码非常难看，并且难以维护，这就形成了回调地狱，由此 Promise 开始出现了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>回调地狱缺点</span></span></span></p><ul><li><span><span><span><span>代码臃肿</span></span></span></span></li><li><span><span><span><span>可读性差</span></span></span></span></li><li><span><span><span><span>耦合性高</span></span></span></span></li><li><span><span><span><span>不好进行异常处理</span></span></span></span></li></ul><span id="OSC_h1_3"></span><h1><span><span><span>Promise 的基本概念</span></span></span></h1><span id="OSC_h3_4"></span><h3><span><span><span>含义</span></span></span></h3><ol><li><span><span><span><span>ES6 将其写进了语言标准里统一了用法，是一个构造函数，用来生成 Promise 实例</span></span></span></span></li><li><span><span><span><span>参数为一个执行器函数 (执行器函数是立即执行的),该函数有两个函数作为参数，第一个参数是成功时的回调,第二个参数是失败时的回调</span></span></span></span></li><li><span><span><span><span>函数的方法有 resolve(可以处理成功和失败)、reject(只处理失败)、all 等方法</span></span></span></span></li><li><span><span><span><span>then、catch、finally 方法为 Promise 实例上的方法</span></span></span></span></li></ol><span id="OSC_h3_5"></span><h3><span><span><span>状态</span></span></span></h3><ol><li><span><span><span><span>pending --- 等待状态</span></span></span></span></li><li><span><span><span><span>Fulfilled --- 执行状态 （resolve 回调函数，then）</span></span></span></span></li><li><span><span><span><span>Rejected --- 拒绝状态 (reject 回调函数，catch)</span></span></span></span></li><li><span><span><span><span>状态一旦改变就不会再变，状态只可能是两种改变，从 pending-&gt;Fulfilled，pending-&gt;Rejected</span></span></span></span></li><li><span><span><span><span>有两个关键的属性：PromiseState --- 状态改变，PromiseResult --- 结果数据改变</span></span></span></span></li></ol><pre><code><span><span><span>const p1 = Promise.resolve(64)
const p2 = Promise.reject('我错了')
const p3 = Promise.then()
const p4 = Promise.catch()

// 状态改变 PromiseState 结果改变 PromiseResult
console.log(new Promise(()=&gt;{}), 'Promise');  // PromiseState='pending' PromiseResult=    
console.log(p1,'p1');  // PromiseState='Fulfilled' PromiseResult=64
console.log(p2,'p2');  // PromiseState="Rejected" PromiseResult='我错了'
console.log(p3, 'p3'); // then 为实例上的方法，报错
console.log(p4, 'p4');  // catch 为实例上的方法，报错
</span></span></span></code></pre><div><img alt="" height="457" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-14-14-59d8dPWcg59hoiOwx59.png" width="705" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h3_6"></span><h3><span><span><span>特点</span></span></span></h3><div><span>1.</span><span><span><span><span>错误信息清晰定位：可以在外层捕获异常信息（网络错误、语法错误都可以捕获），有「冒泡」性质，会一直向后传递，直到被捕获，所以在最后写一个 catch 就可以了</span></span></span></span></div><div><span>2.</span><span><span><span><span>链式调用：每一个 then 和 catch 都会返回一个新的 Promise，把结果传递到下一个 then/catch 中，因此可以进行链式调用 --- 代码简洁清晰</span></span></span></span></div><span id="OSC_h3_7"></span><h3><span><span><span>结果由什么决定</span></span></span></h3><span id="OSC_h4_8"></span><h4><span><span><span>resolve</span></span></span></h4><ol><li><span><span><span><span>如果传递的参数是非 Promise 类型的对象，则返回的结果是成功状态的 Promise 对象，进入下一个 then 里面</span></span></span></span></li><li><span><span><span><span>如果传递的参数是 Promise 类型的对象，则返回的结果由返回的 Promise 决定，如果返回的是 resolve 则是成功的状态，进入下一个 then 里，如果返回的是 reject 则是失败的状态，进入下一个 catch 里</span></span></span></span></li></ol><span id="OSC_h4_9"></span><h4><span><span><span>reject</span></span></span></h4><ol><li><span><span><span><span>如果传递的参数是非 Promise 类型的对象，则返回的结果是拒绝状态的 Promise 对象，进入下一个 catch 里面或者是下一个 then 的第二个参数 reject 回调里面</span></span></span></span></li><li><span><span><span><span>如果传递的参数是 Promise 类型的对象，则返回的结果由返回的 Promise 决定，如果返回的是 resolve 则是成功的状态，进入下一个 then 里，如果返回的是 reject 则是拒绝的状态，进入下一个 catch 里面或者是下一个 then 的第二个参数 reject 回调里面</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这在我们自己封装的 API 里面也有体现：为什么 code 为 1 时都是 then 接收，其他都是 catch 接收，就是因为在 then 里面也就是 resolve 函数中对 code 码进行了判断，如果是 1 则返回 Promise.resolve()，进入 then 里处理，如果是非 1 则返回 Promise.reject()，进入 catch 里处理。</span></span></span></p><span id="OSC_h3_10"></span><h3><span><span><span>流程图</span></span></span></h3><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-14-14-59rKXgoFvRLU89IXE.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h3_11"></span><h3><span><span><span>简单使用</span></span></span></h3><pre><code><span><span><span>// 模拟一个 promise 的 get 请求
let count = 0
function customGet(url){
    count += 1
    return new Promise((resolve, reject)=&gt;{
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.open("GET",url, true);
        xmlHttp.onload = ()=&gt;{
          console.log(xmlHttp, 'xmlHttp---onload');
          if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
            console.log('customGet 请求成功了');
            // 返回非 Promise，结果为成功状态
            resolve({data:`第${count}次请求获取数据成功`})

            // 返回 Promise，结果由 Promise 决定
            // resolve(Promise.reject('resolve 中返回 reject'))
          } else {
            reject('customGet 请求错误了')
          }
        }

        // Promise 状态改变就不会再变
        // onreadystatechange 方法会被执行四次
        // 当地次进来的时候，readyState 不等于 4，执行 else 逻辑，执行 reject，状态变为 Rejected，所以即使再执行 if，状态之后不会再改变
        // xmlHttp.onreadystatechange = function(){
        //   console.log(xmlHttp,'xmlHttp---onreadystatechange')
        //   if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
        //     console.log('customGet 请求成功了');
        //     resolve({data:`第${count}次请求获取数据成功`})
        //   } else {
        //     reject('customGet 请求错误了')
        //   }
        // }
        xmlHttp.send();
      })
 }

// 使用 Promise，并且进行链式调用
customGet('https://v0.yiketianqi.com/api/cityall?appid=&amp;appsecret=').then((res)=&gt;{
   console.log(res.data);
   return '第一次请求处理后的数据'
}).then((data)=&gt;{
   console.log(data)
   // console.log(data.toFixed());
   return customGet('https://v0.yiketianqi.com/api/cityall?appid=&amp;appsecret=')
}).then((res)=&gt;{
   console.log(res.data);
}).catch((err)=&gt;{
    // 以类似'冒泡'的性质再外层捕获所有的错误
   console.error(err, '这是 catch 里的错误信息');
})

</span></span></span></code></pre><span id="OSC_h3_12"></span><h3><span><span><span>手写实现简单的 Promise</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>通过上面的回顾，我们已经了解了 Promise 的关键属性和特点，下面我们一起来实现一个简单的 Promise 吧</span></span></span></p><pre><code><span><span><span>  // 1、封装一个 Promise 构造函数，有一个函数参数
  function Promise(executor){
    // 7、添加对象属性 PromiseState PromiseResult
    this.PromiseState = 'pending'
    this.PromiseResult = null

    // 14、创建一个保存成功失败回调函数的属性
    this.callback = null

    // 8、this 指向问题
    const that = this

    // 4、executor 有两个函数参数（resolve，reject）
    function resolve(data){
      // 10、Promise 状态只能修改一次（同时记得处理 reject 中的状态）
      if(that.PromiseState !== 'pending') return

      // console.log(this, 'this');
      // 5、修改对象的状态 PromiseState
      that.PromiseState = 'Fulfilled'

      // 6、修改对象的结果 PromiseResult
      that.PromiseResult = data

      // 15、异步执行 then 里的回调函数
      if(that.callback?.onResolve){
        that.callback.onResolve(that.PromiseResult)
      }
    }
    function reject(data){
      console.log(that.PromiseState, 'that.PromiseState');
      if(that.PromiseState !== 'pending') return

      // 9、处理失败函数状态
      that.PromiseState = 'Rejected'
      that.PromiseResult = data
      console.log(that.PromiseResult, 'that.PromiseResult');
      console.log(that.PromiseState, 'that.PromiseState');

      // 16、异步执行 then 里的回调函数
      if(that.callback?.onReject){
        that.callback.onReject(that.PromiseResult)
      }
    }
    // 3、执行器函数是同步调用的，并且有两个函数参数
    executor(resolve,reject)
  }
  // 2、函数的实例上有方法 then
  Promise.prototype.then = function(onResolve,onReject){
    // 20、处理 onReject 没有的情况
    if(typeof onReject !== 'function'){
      onReject = reason =&gt; {
        throw reason
      }
    }
    // 21、处理 onResolve 没有的情况
    if(typeof onResolve !== 'function'){
      onResolve = value =&gt; value
    }
    // 17、每一个 then 方法都返回一个新的 Promise，并且把上一个 then 返回的结果传递出去
    return new Promise((nextResolve,nextReject)=&gt;{
      // 11、处理成功或失败
      if(this.PromiseState === 'Fulfilled'){
        // 12、将结果传递给函数
        // onResolve(this.PromiseResult)

        // 18、拿到上一次执行完后返回的结果,判断是不是 Promise
        const result = onResolve(this.PromiseResult)
        if(result instanceof Promise){
          result.then((v)=&gt;{
            nextResolve(v)
          },(r)=&gt;{
            nextReject(r)
          })
        } else {
          nextResolve(result)
        }
      }
      // 当你一步步写下来的时候有没有怀疑过为什么不用 else
       if(this.PromiseState === 'Rejected'){
            // 第 12 步同时处理此逻辑
            // onReject(this.PromiseResult)

            // 22、处理 catch 异常穿透捕获错误
            try {
              const result = onReject(this.PromiseResult)
              if(result instanceof Promise){
                result.then((v)=&gt;{
                  nextResolve(v)
                }).catch((r)=&gt;{
                  nextReject(r)
                })
              } else {
                nextReject(result)
              }
            } catch (error) {
              nextReject(this.PromiseResult)
            }
         }
  
      // 13、异步任务时处理成功或失败,想办法等异步任务执行完成后才去执行这两个函数
      if(this.PromiseState === 'pending'){
        this.callback = {
          onResolve,
          onReject
        }
        console.log(this.callback, 'this.callback');
      }
    })
  }
  // 19、函数实例上有方法 catch
  Promise.prototype.catch = function(onReject) {
    return this.then(null,onReject)
  }

  // 使用自定义封装的 Promise
  const customP = new Promise((resolve,reject)=&gt;{
    // 模拟异步执行请求
    // const xmlHttp = new XMLHttpRequest();
    // xmlHttp.open("GET",'https://v0.yiketianqi.com/api/cityall?appid=&amp;appsecret=', true);
    // xmlHttp.onload = ()=&gt;{
    //   if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
    //     resolve('success')
    //   } else {
    //     reject('error')
    //   }
    // }
    // xmlHttp.send();

    // 同步执行
    resolve('success')
    // reject('error')
  })

  console.log(customP, 'customP');
  customP.then((res)=&gt;{
    console.log(res, 'resolve 回调');
    return '第一次回调'
    // return new Promise((resolve,reject)=&gt;{
    //   reject('错错错')
    // })
  },(err)=&gt;{
    console.error(err, 'reject 回调');
    return '2121'
  }).then(()=&gt;{
    console.log('then 里面输出');
  }).then().catch((err)=&gt;{
    console.error(err, 'catch 里的错误');
  })

</span></span></span></code></pre><span id="OSC_h4_13"></span><h4><span><span><span>针对 resolve 中返回 Promise 对象时的内部执行顺序</span></span></span></h4><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-14-15-00IiDMseqfyk0DroM.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_14"></span><h1><span><span><span>总结</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>以上就是我们常用的 Promise 基础实现，在实现过程中对比了 Promise 和函数嵌套处理异步请求的优缺点，Promise 仍存在缺点，但是的确方便很多，同时更清晰的理解到错误处理如何进行异常穿透的，也能帮助我们更规范的使用 Promise 以及快速定位问题所在。</span></span></span></p><blockquote><p>作者：京东物流&nbsp;孙琦</p><p>来源：京东云开发者社区，自猿其说 Tech 转载请注明来源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:08:47 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10150936</guid>
            <link>https://my.oschina.net/u/4090830/blog/10150936</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Go 语言微服务框架重磅升级：dubbo-go v3.2.0 -alpha 版本预览]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:justify">随着 Dubbo3 在云原生微服务方向的快速发展，Dubbo 的 go 语言实现迎来了 Dubbo3 版本以来最全面、最大幅度的一次升级，这次升级是全方位的，涉及 API、协议、流量管控、可观测能力等。总的来说，新版本的 dubbo-go：</p><ul><li><strong>全面升级 Triple 协议，</strong>兼容 gRPC、标准 HTTP 客户端，提供简单明了的 API 用于编写 RPC server 与 client，解决组件间的基本通信问题。</li><li><strong>针对微服务场景，提供了完善的服务治理能力，</strong>这包括配置管理、可观测性、流量管控规则、生态集成与适配等的全面升级。</li></ul><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-c4c6b5317adb83a4b234eb8fcd15d8c9_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h3_1"></span><h3>全新升级的 Triple 协议</h3><p style="text-align:justify">基于 dubbo-go 实现的 Triple 协议，你可以轻松编写浏览器、gRPC 兼容的 RPC 服务，并让这些服务同时运行在 HTTP/1 和 HTTP/2 上。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-8146beb5d33000f7180c25928e62fba0_720w.webp" referrerpolicy="no-referrer"></p><p>如上图所示，你可以使用 "http+json" 的标准形式访问 dubbo-go 发布的后端 triple 服务，基于这一特性， 我们可以在 dubbo 客户端在浏览器页面、移动设备上访问后端服务，使用标准 cURL 工具访问服务，也可以让比如 Spring 体系的应用轻松的调通 Dubbo 服务。</p><p style="text-align:justify">由于 Triple 协议完全兼容 gRPC 协议，Dubbo 后端服务有可以直接调通标准的 gRPC 服务，它们之间可以无缝的互通，不论是 unary 还是 streaming 通信模式。</p><span id="OSC_h4_2"></span><h4>发布一个 triple rpc 服务</h4><p style="text-align:justify">为了体验升级后的 triple 协议，我们接下来会尝试启动一个 dubbo-go server，并发布一个基于 triple 协议的服务。</p><p style="text-align:justify">创建一个新的 server 并启动 server，它将在指定的端口监听 triple 协议请求。</p><pre><code>func main() {
  srv, err := server.NewServer(
    server.WithServerProtocol(
      protocol.WithTriple(),
      protocol.WithPort(50051),
    ),
  )
  if err != nil {
    panic(err)
  }
  if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
  }
  if err := srv.Serve(); err != nil {
    panic(err)
  }
}</code></pre><span id="OSC_h4_3"></span><h4>cURL 访问服务</h4><p style="text-align:justify">Triple 服务启动完成之后，最简单方式是使用 HTTP/1.1 POST 访问服务，参数则作以标准 JSON 格式作为 HTTP 负载传递。如下是使用 cURL 命令的访问示例：</p><pre><code>curl \
    --header "Content-Type: application/json" \
    --data '{"name": "Dubbo"}' \
    http://localhost:50051/greet.GreetService/Greet</code></pre><p style="text-align:justify">Triple 协议的一项重大升级是支持标准 http 工具直接访问，通过 cURL 可以极大的降低 dubbo-go 服务的测试验证、前端接入成本。</p><span id="OSC_h3_4"></span><h3>简单明了的 API</h3><p style="text-align:justify">Dubbo Go SDK 支持使用 IDL 或编程语言特有的方式定义服务，并提供一套轻量的 API 来发布或调用这些服务。在上一节的示例中，我们已经看到了部分 dubbo-go API 的使用方式，接下来，让我们更仔细全面的看一下新版本的 API 设计。</p><span id="OSC_h4_5"></span><h4>RPC Server 与 Client</h4><p style="text-align:justify">对于一些 RPC 通信的场景，开发者只需要使用 dubbo-go 编写一个最简单的 RPC server 或者 RPC client，这在新版本 dubbo-go 中只需要几行代码即可完成。</p><p style="text-align:justify">通常，我们会使用 Protocol Buffer (IDL) 来定义一个 Dubbo 服务。</p><pre><code>syntax = "proto3";
package greet;

message GreetRequest {
  string name = 1;
}

message GreetResponse {
  string greeting = 1;
}

service GreetService {
  rpc Greet(GreetRequest) returns (GreetResponse) {}
}</code></pre><p style="text-align:justify">使用 Protocol Buffers Compiler 从 IDL 生成 stub 代码（篇幅关系，我们不在此展示，具体请参见官网 dubbo-go 快速开始）。接下来，我们实现 greettriple.GreeterClient 接口并提供自定义服务实现。</p><pre><code>type GreeterServer struct {
}

func (s *GreeterServer) SayHello(ctx context.Context, in *greet.HelloRequest) (*greet.User, error) {
  return &amp;greet.User{Name: "Hello " + in.Name, Id: "12345", Age: 21}, nil
}</code></pre><p style="text-align:justify">以下是一个简单的 RPC server 示例，执行协议信息，并注册服务到 server 中：</p><pre><code>func main() {
  srv, err := server.NewServer(
    server.WithServer_Protocol(
      protocol.WithTriple(),
      protocol.WithPort(50052),
    ),
  )
  if err != nil {
    panic(err)
  }
  if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
  }
  if err := srv.Serve(); err != nil {
    panic(err)
  }
}</code></pre><p style="text-align:justify">如前面 Triple 协议一节所述，你可以使用 cURL 直接测试以上 server 服务运行正常。与此同时，对应的 RPC client 示例如下：</p><pre><code>func main() {
  // for the most brief RPC case
  cli, err := client.NewClient(
    client.WithURL("tri://127.0.0.1:50052"),
  )
  if err != nil {
    panic(err)
  }
  svc, err := greettriple.NewGreetService(cli)
  if err != nil {
    panic(err)
  }

  common.TestClient(svc)
}</code></pre><span id="OSC_h4_6"></span><h4>微服务开发</h4><p style="text-align:justify">如果你正在开发微服务应用，那么除了 RPC 通信之外，你通常还需要为应用配置一些服务治理能力，比如 retistry 注册中心、配置中心、可观测能力等。</p><p style="text-align:justify">以下展示了如何使用 dubbo-go 开发一个微服务应用。</p><p style="text-align:justify">首先，创建一个代表微服务的应用 Server，将服务注册给它，添加注册中心等服务治理配置。</p><pre><code>func main() {
  // configure global configurations and common modules
  ins, err := dubbo.NewInstance(
    dubbo.WithName("dubbo_test"),
    dubbo.WithRegistry(
      registry.WithZookeeper(),
      registry.WithAddress("127.0.0.1:2181"),
    ),
    dubbo.WithProtocol(
      protocol.WithTriple(),
      protocol.WithPort(50052),
    ),
  )
    // create a server with registry and protocol set above
  srv, err := ins.NewServer()
  if err != nil {
    panic(err)
  }
    // register a service to server
  if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
  }
    // start the server
  if err := srv.Serve(); err != nil {
    panic(err)
  }
}</code></pre><p style="text-align:justify">其中，Instance 是我们在新版本中引入的全局配置，你可以将所有微服务全局配置在这里进行初始化。这里，我们设置了微服务通信协议 protocol 和注册中心 registry，如以下代码片段所示：</p><pre><code>ins, err := dubbo.NewInstance(
    dubbo.WithName("dubbo_test"),
    dubbo.WithRegistry(
        registry.WithZookeeper(),
        registry.WithAddress("127.0.0.1:2181"),
    ),
    dubbo.WithProtocol(
        protocol.WithTriple(),
        protocol.WithPort(50052),
    ),
)</code></pre><p style="text-align:justify">接下来的操作就非常简单明了了，我们创建一个 server，将服务注册给它并启动，如下所示。如果有更多的服务，则可以依次注册到 server 后再启动。</p><pre><code>// create a server with registry and protocol set above
srv, err := ins.NewServer()
// register a service to server
if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
}
// start the server
if err := srv.Serve(); err != nil {
    panic(err)
}</code></pre><p style="text-align:justify">以上就是一个微服务应用的基本开发过程，如果你的微服务应用要调用一些远程 Dubbo 服务，那么你只需要参照以下方式创建一个 client 就行了。</p><p style="text-align:justify">下面的代码示例创建了一个 client，紧接着生成了一个 GreetService 远程服务代理，之后，就可以像调用本地方法一样调用远端 Dubbo 服务了。client 将基于注册中心实现 server 实例的自动发现并自动为流量应用负载均衡策略。</p><pre><code>func main() {
  // configure global configurations and common modules
  ins, err := dubbo.NewInstance(
    dubbo.WithName("dubbo_test"),
    dubbo.WithRegistry(
      registry.WithZookeeper(),
      registry.WithAddress("127.0.0.1:2181"),
    ),
  )
  
  // configure the params that only client layer cares
  cli, err := ins.NewClient()
  if err != nil {
    panic(err)
  }

  svc, err := greettriple.NewGreetService(cli)
  if err != nil {
    panic(err)
  }

  resp, err := svc.Greet(context.Background(), &amp;greet.GreetRequest{Name: "triple"})
  if err != nil {
    return err
  }
  logger.Infof("TRIPLE unary call resp: %s", resp.Greeting)
}</code></pre><span id="OSC_h3_7"></span><h3>企业级服务治理能力</h3><span id="OSC_h4_8"></span><h4>动态配置</h4><p style="text-align:justify">除了 API 模式之外，Dubbo-go 支持基于配置文件驱动的编码方式，这对于一些更大规模的微服务开发场景非常适用。在这种模式下，我们将 registry、protocol 等组件配置，甚至包括服务声明等都放在 dubbogo.yml 文件中，框架会在启动过程中完成配置文件加载。</p><p style="text-align:justify">以下是一个基于 dubbogo.yml 的微服务应用的开发示例：</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-7420aaf1df69816f650d9fafc20a94e5_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">其中，server.go 定义如下：</p><pre><code>func main() {
  greettriple.SetProviderService(&amp;GreeterServiceImpl{})
  if err := dubbo.Load(); err != nil {
    panic(err)
  }
}</code></pre><p style="text-align:justify">dubbogo.yml 示例内容如下：</p><pre><code>dubbo:
  application: # 应用信息，服务启动后会将相关信息注册到注册中心，可被客户端从 url 中识别
    name: myApp
  registries:
    nacos:
      protocol: nacos # 注册中心选择 nacos 
      address: 127.0.0.1:8848 # nacos ip
      group: DEFAULT_GROUP # nacos group, 默认 DEFAULT_GROUP
      namespace: 9fb00abb-278d-42fc-96bf-e0151601e4a1 # nacos namespaceID, should be created before. 默认 public
      username: abc
      password: abc
  protocols:
    dubbo:
      name: tri
      port: 20000
  provider:
    services:
      UserProviderWithCustomGroupAndVersion: # 接口三元组：接口名、版本号、分组。client 和 server 需要保持一致。
        interface: org.apache.dubbo.UserProvider.Test # 接口名必填
        version: myInterfaceVersion # 默认为空
        group: myInterfaceGroup # 默认为空</code></pre><p style="text-align:justify">可以看到相比于之前的 API 编码方式，这里的 server.go 只有两行代码，dubbo.Load() 会完成所有配置的自动组装并启动相关组件，我们只需要在启动应用时指定 export DUBBO_GO_CONFIG_PATH=$ABSOLUTE_PATH/conf/dubbogo.yml 即可。</p><span id="OSC_h4_9"></span><h4>可观测性</h4><p style="text-align:justify">自 3.2.0 版本开始，dubbo-go 重点升级了内置 metrics 指标采集能力，提供 RPC 调用（RT、QPS、调用量、请求成功数、请求失败数、并发请求数等）、注册中心、元数据中心、配置中心交互统计等丰富的内置采集埋点，支持多维度的指标聚合。</p><p style="text-align:justify">dubbo-go 内置 metrics 指标导出到 Prometheus + Grafana 体系的能力，以下是 dubbo-go v3.2.0 示例在 Grafana 的监控效果图，具体示例我们将与随后发布在 dubbo-go-samples/metrics。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-b4ec54c1891c2d1f09b91227746c751e_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_10"></span><h4>流量管控</h4><p style="text-align:justify">Dubbo 提供了丰富的流量管控策略：</p><ul><li><strong>地址发现与负载均衡，</strong>地址发现支持服务实例动态上下线，负载均衡确保流量均匀的分布到每个实例上。</li><li><strong>基于路由规则的流量管控，</strong>路由规则对每次请求进行条件匹配，并将符合条件的请求路由到特定的地址子集。</li></ul><p style="text-align:justify">服务发现保证调用方看到最新的提供方实例地址，服务发现机制依赖注册中心 (Zookeeper、Nacos、Istio 等) 实现。在消费端，Dubbo 提供了多种负载均衡策略，如随机负载均衡策略、一致性哈希负载、基于权重的轮询、最小活跃度优先、P2C 等。</p><p style="text-align:justify">Dubbo 的流量管控规则可以基于应用、服务、方法、参数等粒度精准的控制流量走向，根据请求的目标服务、方法以及请求体中的其他附加参数进行匹配，符合匹配条件的流量会进一步的按照特定规则转发到一个地址子集。以下是 dubbo-go 流量管控规则可以实现的一些具体管控场景示例：</p><ul><li>基于权重的比例流量分发</li><li>灰度验证</li><li>金丝雀发布</li><li>按请求参数的路由</li><li>同区域优先</li><li>超时时间调整</li><li>重试</li><li>限流降级</li></ul><p style="text-align:justify">以下是一个基于 dubbo-go 实现的全链路灰度示例：</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-d3af29d517bd1d38914a8b7df29c0384_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">以下是一个基于 dubbo-go 实现的按比例流量转发示例：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-4688342e32359c6fa7e25ef3bc3c22b6_720w.webp" referrerpolicy="no-referrer"></p><p>关于 dubbo-go 流量管控，我们以一个商城系统提供了一个完整的 demo 示例，感兴趣的读者可以参考详细信息：</p><ul><li>流量管控规则详情<strong>[1]</strong></li><li>流量管控商场示例解读<strong>[2]</strong></li></ul><span id="OSC_h4_11"></span><h4>生态</h4><p style="text-align:justify">dubbo-go 总体上遵循框架内核+插件的的设计理念，左侧的框架内核定义了 dubbo-go 作为微服务框架的一些核心概念，右侧的插件部分则提供了核心概念扩展实现。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-c4c6b5317adb83a4b234eb8fcd15d8c9_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">框架内核，可分为 4 个层次，从上到下依次为：</p><ul><li><strong>API 层</strong></li></ul><p style="text-align:justify">dubbo-go 同时支持基于 IDL、interface/struct 的服务契约定义，兼顾跨语言与易用性诉求；支持基于纯 yaml 文件的微服务配置模式；提供了同步、异步、单次 (unary)、流式 (streaming) 等 RPC 通信与编码模型。</p><ul><li><strong>服务治理层</strong></li></ul><p style="text-align:justify">dubbo-go 内置了多维度的服务治理能力抽象，确保满足微服务开发与集群治理的核心诉求，这包括地址发现（Service Discovery）、负载均衡（Load Balancing）、可观测指标（Metrics）、流量管控（Traffic Management）、全链路追踪（Tracing）等。</p><ul><li><strong>RPC 协议层</strong></li></ul><p style="text-align:justify">dubbo-go 实现的最核心的 RPC 协议是 - triple 协议，triple 可同时工作在 http1/2 之上 (支持 CURL 直接访问)，兼容 gRPC；从设计上，dubbo-go 还提供了多协议发布服务的支持，你可以在一个进程内同时发布 triple、dubbo2、rest、jsonRPC 等多种不同通信协议的服务。</p><ul><li><strong>传输层</strong></li></ul><p style="text-align:justify">支持 HTTP1/2、TCP 传输层，兼顾性能与通用性，同时支持多种序列化方式。</p><p style="text-align:justify">插件体系极大的丰富了 dubbo-go 功能与生态，社区内置提供了大量的内置扩展实现，同时，开发者可以非常容易的根据需求增加扩展实现。以下是一些典型的插件定义：</p><ul><li><strong>Protocol</strong></li></ul><p style="text-align:justify">dubbo-go 基于 protocol 插件内置提供了 triple、dubbo2、rest 等协议支持，通过扩展 protocol 可以为 dubbo-go 扩展更多协议。</p><ul><li><strong>Service Discovery</strong></li></ul><p style="text-align:justify">支持 Nacos、Zookeeper、Polaris 等主流注册中心集成。</p><ul><li><strong>Traffic Management</strong></li></ul><p style="text-align:justify">dubbo-go 支持 Dubbo 体系定义的流量规则，可以实现在运行期动态的调整服务行为如超时时间、重试次数、限流参数等，通过控制流量分布可以实现 A/B 测试、金丝雀发布、多版本按比例流量分配、条件匹配路由、黑白名单等。</p><ul><li><strong>Metrics</strong></li></ul><p style="text-align:justify">提供 RPC 调用（RT、QPS、调用量、请求成功数、请求失败数、并发请求数等）、注册中心、元数据中心、配置中心交互统计等丰富的内置采集埋点，支持多维度的指标聚合。</p><ul><li><strong>Logging</strong></li></ul><p style="text-align:justify">提供通用的日志采集接口定义，内置 Zap、Logrus 支持</p><ul><li><strong>Tracing</strong></li></ul><p style="text-align:justify">提供分布式链路追踪能力，通过此插件扩展可接入 Zipkin、Jaeger、Skywalking 等链路追踪系统。</p><span id="OSC_h3_12"></span><h3>总结</h3><p style="text-align:justify">dubbo-go 3.2.0 的首个 alpha 版本将于 11 月底发布，本文是发版前的抢先预览，感兴趣的读者也可以访问源码尝鲜：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fapache%2Fdubbo-go%2Ftree%2Ffeature-triple%2Fprotocol%2Ftriple%2Finternal%253Fspm%253Da2c6h.13046898.publish-article.3.79d66ffahA9acR" target="_blank">https://github.com/apache/dubbo-go/tree/feature-triple/protocol/triple/internal</a></em></u></p><p style="text-align:justify">接下来，我们将持续推进 3.2.0 版本迭代并计划与 2 月份发布正式稳定版本，详细 Roadmap 请关注项目仓库：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fapache%2Fdubbo-go%253Fspm%253Da2c6h.13046898.publish-article.4.79d66ffahA9acR" target="_blank">https://github.com/apache/dubbo-go</a></em></u></p><p style="text-align:justify"><strong>相关链接：</strong></p><p style="text-align:justify">[1] 流量管控规则详情</p><p style="text-align:justify"><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Ftraffic%2F%253Fspm%253Da2c6h.13046898.publish-article.5.79d66ffahA9acR" target="_blank">https://cn.dubbo.apache.org/zh-cn/overview/core-features/traffic/</a></em></u></p><p style="text-align:justify">[2] 流量管控商场示例解读</p><p style="text-align:justify"><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Ftasks%2Ftraffic-management%2F%253Fspm%253Da2c6h.13046898.publish-article.6.79d66ffahA9acR" target="_blank">https://cn.dubbo.apache.org/zh-cn/overview/tasks/traffic-management/</a></em></u></p><p style="text-align:justify"><em>作者：王宇轩， Apache Dubbo Committer</em></p><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1380725%3Futm_content%3Dg_1000384715" target="_blank">原文链接</a></strong></p><p style="text-align:justify"><strong>本文为阿里云原创内容，未经允许不得转载。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 09:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10314426</guid>
            <link>https://my.oschina.net/yunqi/blog/10314426</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[国内首个农业开源鸿蒙操作系统]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0px; margin-right:0px; text-align:start">11 月 29 日，在全球首个以供应链为主题的国家级展会——中国国际供应链促进博览会上，中信农业科技股份有限公司（简称「中信农业」）联合深圳开鸿数字产业发展有限公司（简称「深开鸿」）、华为技术有限公司（简称「华为」）正式对外发布了<strong>国内首个自主可控的农业开源鸿蒙操作系统。</strong></p><p style="margin-left:0px; margin-right:0px; text-align:start">据介绍，农业开源鸿蒙是致力于维护农业数据安全，打造自主可控的农业操作系统。</p><p><img src="https://static.oschina.net/uploads/space/2023/1129/170904_6My8_2720166.png" referrerpolicy="no-referrer"></p><p>下图是农业开源鸿蒙操作系统的演示：</p><p><img height="906" src="https://static.oschina.net/uploads/space/2023/1129/171101_l9cl_2720166.png" width="2232" referrerpolicy="no-referrer"></p><p><img height="928" src="https://static.oschina.net/uploads/space/2023/1129/171017_86bC_2720166.png" width="2226" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-116c65e954d843c9b90f6fb5ba8f83258c5.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-c8e4bc96284803ab6547db6797684372387.png" referrerpolicy="no-referrer"></p><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fj4EIO_8RPUdwqLJBhsozAQ" target="_blank">https://mp.weixin.qq.com/s/j4EIO_8RPUdwqLJBhsozAQ</a></u></em></p><p>深开鸿 CEO 王成录博士介绍道，农业开源鸿蒙操作系统是基于 KaihongOS 的新一代面向数字农业领域的万物智联操作系统，为大小不一、类型多样设备的互联和协同提供统一的数字底座，让所有农业设备都用统一的操作系统，讲同一种语言，而且全栈关键核心技术均为国产自主研发，从底层操作系统源头上保证了数据的安全可靠。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 28 Nov 2023 09:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268706</guid>
            <link>https://www.oschina.net/news/268706</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微软开源 Azure RTOS，更名为 Eclipse ThreadX]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">微软<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcommunity.microsoft.com%2Ft5%2Finternet-of-things-blog%2Fmicrosoft-contributes-azure-rtos-to-open-source%2Fba-p%2F3986318" target="_blank">宣布</a>将 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fazure-rtos" target="_blank">Azure RTOS</a> 托管至&nbsp;<span style="background-color:#ffffff">Eclipse 基金会，并更名为&nbsp;Eclipse ThreadX。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Azure RTOS 是一个带有 ThreadX 实时操作系统（RTOS）的嵌入式开发套件。ThreadX 是一个普及性很高的小型 RTOS，</span>可为资源受限的设备提供可靠、超快的性能；<span style="background-color:#ffffff">目前已部署在全球超过 120 亿台设备上。除了作为 RTOS 内核的 Azure RTOS ThreadX 之外，Azure RTOS 还提供了一组系统组件来加速构建嵌入式系统和物联网应用程序。</span></span></p><p><span style="color:#000000">在基金会管理下，<span style="background-color:#ffffff">Eclipse ThreadX 项目计划将于 2024 年第一季度在 MIT 协议下开源提供。「</span><span style="background-color:#ffffff">ThreadX 将成为世界上第一个开源实时操作系统。</span><span style="background-color:#ffffff">」</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff"><img alt="" height="374" src="https://oscimg.oschina.net/oscnet/up-70e9a7d446ccf867ef9551516c458a9610d.png" width="700" referrerpolicy="no-referrer"></span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">公告称，Eclipse ThreadX 为实时应用提供了一个供应商中立、开放源代码、安全认证的操作系统。它是第一个也是唯一一个具有这种独特混合属性的实时操作系统，可满足广泛的需求，使行业采用者、开发人员和最终用户都能从中受益。</span><span style="background-color:#ffffff">主要优点包括：</span></span></p><ul><li><span style="color:#000000">不间断访问：更广泛、持续地访问 ThreadX 技术</span></li><li><span style="color:#000000">加速创新：通过社区参与提供更快的更新和改进</span></li><li><span style="color:#000000">开放且可预测：透明的开发流程以增强社区协作</span></li><li><span style="color:#000000">更广泛的覆盖范围：对于各种应用来说更易于访问和通用</span></li></ul><p><span style="color:#000000">「这一变革性合作为嵌入式 RTOS 技术的空前发展铺平了道路，并将在新成立的 </span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fprojects.eclipse.org%2Fproposals%2Feclipse-threadx" target="_blank">Eclipse ThreadX Project</a>&nbsp;<span style="color:#000000"><span style="background-color:#ffffff">和</span></span>&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fprojects.eclipse.org%2Finterest-groups%2Fthreadx-interest-group" target="_blank">Eclipse ThreadX Interest Group</a><span style="color:#4c4d4e">&nbsp;</span><span style="color:#000000">的框架内展开。<span style="background-color:#ffffff">与我们一起塑造嵌入式系统的未来并利用开源的力量促进创新！</span>」&nbsp;</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Eclipse 基金会<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Feclipse-foundation.blog%2F2023%2F11%2F21%2Fintroducing-eclipse-threadx%2F" target="_blank">认为</a>，</span></span><span style="background-color:#ffffff"><span style="color:#222222">ThreadX 将凭借其全面的属性，迅速扩大在航空航天、汽车、物联网、医疗、交通、自动化和消费可穿戴设备等广泛用例中的采用。「Eclipse ThreadX 为行业带来了改变游戏规则的机会。」</span></span></p><p><strong><span style="background-color:#ffffff"><span style="color:#222222">项目官网：</span></span></strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthreadx.io%2F" target="_blank">https://threadx.io/</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 28 Nov 2023 09:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268705/microsoft-azure-rtos-eclipse-threadx</guid>
            <link>https://www.oschina.net/news/268705/microsoft-azure-rtos-eclipse-threadx</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[1 - 10 月我国电子信息制造业生产持续回升]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 1-10 月份电子信息制造业运行情况已<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F-NlHIDx-kRamtsv2EoBppQ" target="_blank">公布</a>。1-10&nbsp;<span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">月份，我国电子信息制造业生产持续回升，出口降幅收窄，效益持续改善，投资稳定增长，地区间营收分化明显。</span></p><p style="margin-left:0; margin-right:0"><strong>一、生产持续回升</strong></p><p style="margin-left:0; margin-right:0">1—10 月份，规模以上电子信息制造业增加值同比增长 1.7%，增速较前三季度提高 0.3 个百分点；<span>增速分别比同期工业、高技术制造业低 2.4 个和 0.2 个百分点。10 月份，规模以上电子信息制造业增加值同比增长 4.8%，较同期工业高 0.2 个百分点。</span></p><p><img height="284" src="https://oscimg.oschina.net/oscnet/up-c7e8347b11afa929069846f119706440564.png" width="500" referrerpolicy="no-referrer"></p><p>1—10 月份，主要产品中，手机产量 12.5 亿台，同比增长 1.6%，其中智能手机产量 9.06 亿台，同比下降 4.8%；微型计算机设备产量 2.81 亿台，同比下降 20.8%；集成电路产量 2765 亿块，同比增长 0.9%；光电子器件产量 11753 亿只，同比增长 9.3%。</p><p style="margin-left:0; margin-right:0"><strong>二、出口降幅收窄</strong></p><p>1—10 月份，规模以上电子信息制造业出口交货值同比下降 6.9%，降幅较前三季度收窄 1.2 个百分点，比同期工业降幅深 2.7 个百分点。10 月份，规模以上电子信息制造业出口交货值与去年同期持平。</p><p><img height="278" src="https://oscimg.oschina.net/oscnet/up-8fddcd7d4c558e2d88e81617b79a9576a58.png" width="500" referrerpolicy="no-referrer"></p><p>据海关统计，1—10 月份，我国出口笔记本电脑 11774 万台，同比下降 18%；出口手机 6.42 亿台，同比下降 6.5%；出口集成电路 2218 亿个，同比下降 4.1%。</p><p style="margin-left:0; margin-right:0"><strong>三、效益持续改善</strong></p><p style="margin-left:0px; margin-right:0px; text-align:justify">1—10 月份，规模以上电子信息制造业实现营业收入 12.1 万亿元，同比下降 2.9%，较前三季度降幅收窄 0.5 个百分点；营业成本 10.5 万亿元，同比下降 2.6%；实现利润总额 4826 亿元，同比下降 18.2%，较前三季度降幅收窄 0.4 个百分点；营业收入利润率为 4%，较前三季度持平。</p><p><img height="280" src="https://oscimg.oschina.net/oscnet/up-8fb3765349827aa46ce821c7b2ef59dfc32.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>四、投资稳定增长</strong></p><p style="margin-left:0; margin-right:0">1—10 月份，电子信息制造业固定资产投资同比增长 9.6%，比同期工业投资增速高 0.7 个百分点，但比高技术制造业投资增速低 1.7 个百分点。</p><p><img height="274" src="https://oscimg.oschina.net/oscnet/up-ed620009a27ece0de52f59079cdf61d17da.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>五、地区间营收分化明显</strong></p><p>1—10 月份，规模以上电子信息制造业东部地区实现营业收入 82003 亿元，同比下降 3%，较前三季度降幅收窄 0.8 个百分点；中部地区实现营业收入 19834 亿元，同比下降 3.9%，较前三季度降幅收窄 1.3 个百分点；西部地区实现营业收入 17982 亿元，同比下降 1.9%，较前三季度降幅加深 1.8 个百分点；东北地区实现营业收入 823 亿元，同比增加 9%，较前三季度回落 0.5 个百分点。四个地区电子信息制造业营业收入占全国比重分别为 68.0%、16.4%、14.9% 和 0.7%。</p><p><img height="310" src="https://oscimg.oschina.net/oscnet/up-b0043b1d7c4585093e396d4d7d5f544fe2a.png" width="500" referrerpolicy="no-referrer"></p><p>1—10 月份，规模以上电子信息制造业京津冀地区实现营业收入 5995 亿元、同比下降 6.3%，较前三季度降幅持平，营收占全国比重 5%；长三角地区实现营业收入 33990 亿元、同比下降 3.8%，较前三季度降幅收窄 1.1 个百分点，营收占全国比重 28.2%。</p><p><span style="color:#888888">（注：1.文中统计数据除注明外，其余均为国家统计局数据或据此测算。2.文中「电子信息制造业」与国民经济行业分类中的「计算机、通信和其他电子设备制造业」为同一口径。）</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 28 Nov 2023 08:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268691</guid>
            <link>https://www.oschina.net/news/268691</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[滴滴向所有用户补偿 10 元无门槛打车通用券]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>滴滴出行今日就 11 月 27 日夜间发生的系统故障进行了说明，并再一次道歉。同时，滴滴还为所有用户派发了一张「致歉补偿券」，无门槛使用，立减 10 元。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f2fd281711327e482dba21d9ff535b24145.png" referrerpolicy="no-referrer"></p></blockquote><p>扫码领取：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-28207da7bde2ec3598e23358e58cbbeaafd.png" referrerpolicy="no-referrer"></p><p>滴滴表示，目前滴滴 App 的所有服务已经全部恢复。初步确定，这起事故的起因是底层系统软件发生故障，并非网传的「遭受攻击」，后续将深入开展技术风险隐患排查和升级工作，全面保障服务稳定性。</p><hr><p><strong>事件回顾</strong></p><ul><li><a href="https://www.oschina.net/news/268635" target="news">滴滴史上最严重服务故障，罪魁祸首是底层软件 or 「降本增笑」？</a></li><li><a href="https://www.oschina.net/news/268480" target="news">滴滴昨晚系统服务故障，技术团队连夜修复</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 28 Nov 2023 07:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268677</guid>
            <link>https://www.oschina.net/news/268677</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[AWS 推出 AI 聊天机器人 Amazon Q]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">AWS 正式加入聊天机器人赛道，宣布推出一款名为 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Faws.amazon.com%2Fcn%2Fblogs%2Faws%2Famazon-q-brings-generative-ai-powered-assistance-to-it-pros-and-developers-preview%2F" target="_blank">Amazon Q</a> 的生成式 AI 助手；可以帮助用户完成工作中的各种任务，如聊天、生成内容和采取行动。</span></p><p><span style="color:#000000">根据介绍，Amazon Q 主要面向企业提供，旨在帮助员工完成日常任务，例如总结文档、填写内部文件以及回答有关公司政策的问题。其可供企业使用多种功能，包括开发应用程序、转换代码、生成商业智能、充当业务应用程序的生成式 AI 助手以及帮助客户通过 Amazon Connect 产品的服务代理。</span></p><p><span style="color:#000000"><img alt="" height="260" src="https://oscimg.oschina.net/oscnet/up-1f94a6a3ef5eecb740529e810e21d309130.png" width="700" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">AWS 首席执行官 Adam Selipsky 介绍称，Amazon Q 可以利用来自各种应用程序的业务数据，包括办公软件 Microsoft 365、企业协作软件 Slack、客户服务软件 Salesforce、网络储存应用 Dropbox 和 Amazon S3。目前开箱即用地支持 40 多种应用程序和服务。</span></p><p><span style="color:#000000">他还强调了安全和隐私的重要性，并表示 Amazon Q 尊重用户现有的身份、角色和权限，不会使用用户的内容来训练其底层模型。</span></p><p><span style="color:#000000">Selipsky 表示，AWS 已将许多功能融入 Amazon Q 中以帮助开发人员，其中包括允许程序员在构建应用程序时提出问题的自然语言对话功能。与此同时，该公司还在将 Amazon Q 集成到 Visual Studio Code 和 IntelliJ IDEA 等 IDE 中。</span></p><p><span style="color:#000000">Amazon Q 目前处于预览阶段，部分功能免费对外提供。亚马逊计划未来将面向企业用户收取每人每月 20 美元的费用，为开发人员和 IT 人员提供功能的版本则将收取每人每月 25 美元。</span></p><p><span style="color:#000000">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Faws.amazon.com%2Fcn%2Fblogs%2Faws%2Famazon-q-brings-generative-ai-powered-assistance-to-it-pros-and-developers-preview%2F" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 28 Nov 2023 06:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268675/amazon-q</guid>
            <link>https://www.oschina.net/news/268675/amazon-q</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[AI 生成图片著作权侵权第一案宣判：被告构成侵权，赔偿 500 元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>11 月 29 日消息，近日，北京互联网法院针对<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrdzctOfPu9zQaKO4ZVDCwQ" target="_blank">人工智能生成图片（AI 绘画图片）著作权侵权纠纷</a></u>作出一审判决，据悉该案为 AI 生成图片相关领域著作权第一案。</p><p>法院最终判决，<strong>被告构成侵权，需向原告公开道歉，并赔偿 500 元</strong>。</p><p>据悉，原告李某使用 AI 生成涉案图片后发布于小红书平台；被告系百家号博主，发布文章配图使用了原告该 AI 生成的图片，原告遂起诉。</p><p>北互审理认为涉案人工智能生成图片（AI 绘画图片）具备「独创性」要件，体现了人的独创性智力投入，应当被认定为作品，受到著作权法保护等。</p><p><img alt="1701225443968.png" src="https://static.oschina.net/uploads/img/202311/29143541_fABc.png" referrerpolicy="no-referrer"></p><p><img alt="图片" src="https://static.oschina.net/uploads/img/202311/29143541_3GlB.png" referrerpolicy="no-referrer"></p><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FWu3-GuFvMJvJKJobqqq7vQ" target="_blank">https://mp.weixin.qq.com/s/Wu3-GuFvMJvJKJobqqq7vQ</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 28 Nov 2023 06:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268672</guid>
            <link>https://www.oschina.net/news/268672</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[恭喜 Devlive DataCap 新晋一位 Committer]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>非常感谢所有对 DataCap 项目的支持和贡献，我们迎来了新的一位来自互联网行业的大数据资深运维工程师，感谢他对 DataCap 的支持以及代码的贡献。</p></blockquote><h3>关于 DataCap</h3><hr><p>DataCap 是数据转换、集成和可视化的集成软件。支持多种数据源，文件类型，大数据相关数据库，关系型数据库，NoSQL 数据库等。通过软件可以实现管理多种数据源，对该源下的数据进行各种操作转换，制作数据图表，监控数据源等各种功能。</p><h3>DataCap 喜迎一位 Committer 成员</h3><hr><table><tbody><tr><th>名字</th><th>职业</th><th>GitHub ID</th></tr></tbody><tbody><tr><td>陈文明</td><td>大数据资深运维工程师</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fchenwenming-zj" target="_blank">chenwenming-zj</a></td></tr></tbody></table><h4>个人描述</h4><hr><p>有多年大数据组件维护经验，对 Hadoop 集群有丰富的经验，同时对 Apache Kafka 以及各个大数据组件有一定的经验。</p><ol><li>优化过亿 Blocks 的 NameNode，优化解决集群小文件问题，减少 NameNode RPC 压力</li><li>迁移并运维过 PB 级别的 Hadoop 集群</li><li>维护管理万级别 Topic 的 Kafka 集群，自动化脚本实现分区均衡迁移，Reassignment 限速等</li></ol><h4>对 DataCap 的认识</h4><hr><p>在做公司 Clickhouse 迁移时，从 GitHub 中搜索，发现 datacap 项目，结合公司内部业务，经过一段时间运行后发现缺失，服务功能缺失 JVM 动态加载功能，因为我对 Shell 比较熟悉且做过 JVM 优化工作，特意在源码中支持了服务启动读取 JVM 配置功能。</p><h4>代码提交之路</h4><hr><ol><li>在 datacap 上提交了相关代码 (commit 57473faf4f45616a96962b7f84b9b5b81ecfbc42(HEAD-&gt;dev_get_jvm, origin/dev_get_jvm)</li></ol><h4>得到的收获</h4><hr><ol><li>作为大数据运维,很少参与工程项目，非常荣幸能在 datacap 上贡献自己微薄的代码</li><li>这次参与也体会到团队协助的力量，希望 datacap 做的越来越好</li></ol><h4>对新人的建议</h4><hr><ol><li>上线前整理 checklist</li><li>一定要写好注释，方便以后维护，要写好注释，可以写某个方法是做什么的，主要步骤是什么</li><li>测试！一定要多测试，先上测试环境，再上线</li><li>新参与项目时，可以多参考官方文档</li></ol><h4>如何参与 DataCap</h4><hr><ul><li>参考官网 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdatacap.devlive.org%2Fdeveloper_guide%2Fenv.html" target="_blank">开发者文档</a></li><li>通过 Issues 列表参与 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdevlive-community%2Fdatacap%2Fissues" target="_blank">GitHub</a>&nbsp;&amp;&nbsp; <a href="https://gitee.com/devlive-community/datacap/issues">Gitee</a></li><li>加入我们的微信群&amp;钉钉群（在代码仓库中可以看到二维码）</li><li>微信公众号后台留言（搜索微信公公众号 <code>devlive-sf</code> 关注，标记 DataCap 项目给我们留言即可）</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 28 Nov 2023 04:27:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268646</guid>
            <link>https://www.oschina.net/news/268646</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[两名玩家利用 DNF 漏洞获利近 1 亿元人民币，已被公诉]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>日前，南京市玄武区人民检察院依法对 2 名涉嫌非法获取计算机信息系统数据罪被告人提起公诉。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-22fa6166d578719921e446311de49657bc3.png" referrerpolicy="no-referrer"></p><p>2022 年 8 月以来，被告人唐某利用深圳市腾讯计算机系统有限公司运营的网络游戏《地下城与勇士》个人揹包和仓库程序的漏洞，使用被告人蔡某某提供的脚本，利用游戏漏洞非法复制出「矛盾的结晶体」「扭曲的次元结晶」 「无瑕的金绿柱石」 等八种游戏道具，将所复制的游戏道具放在多个游戏公会仓库内，再进行出售。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-078b174cef4e6dae71ce7917a7f3ddb43e1.png" referrerpolicy="no-referrer"></p><p>2022 年 8 月起，被告人唐某先后向王某某、王某、周某出售非法获取的游戏道具，获利人民币 9163 万余元。被告人蔡某某将被告人唐某复制的游戏道具出售给王某某，获利人民币 182 万余元。</p><p><img src="https://oscimg.oschina.net/oscnet/up-855b94f09d04a42b9687726b3241276edaa.jpg" referrerpolicy="no-referrer"></p><hr><p>DNF 昨日在官网回应了此事：</p><blockquote><p><img height="1284" src="https://oscimg.oschina.net/oscnet/up-d04269bfc1d55a0b8914d959668a5eccc08.png" width="1506" referrerpolicy="no-referrer"></p></blockquote><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdnf.qq.com%2Fwebplat%2Finfo%2Fnews_version3%2F119%2F495%2F498%2Fm21449%2F202311%2F944229.shtml" target="_blank">https://dnf.qq.com/webplat/info/news_version3/119/495/498/m21449/202311/944229.shtml</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 28 Nov 2023 03:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268643</guid>
            <link>https://www.oschina.net/news/268643</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Jenkins 任务如何迁移到 Zadig 工作流]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-645523f745c4b7ebf67fbdd388751cbe2ff.png" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">我们在「</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491115%26idx%3D1%26sn%3D83e593f77e1aec4d59cee72cca711927%26chksm%3Dcfb4528bf8c3db9de4d0adbe3c0cb15600d35e647c869867dc2e99a599cd7f58ca6208bb4443%26scene%3D21%23wechat_redirect" target="_blank">不想放弃 Jenkins？这么做也能云原生</a><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">」一文中详细描述了如何在保留 Jenkins 的前提下，通过 Zadig 快速提升效率和工程师幸福度。然而，尽管这样做可以取得一些显著的成果，却未能实质解决运维人员对系统维护的繁重负担。实际情况中，Jenkins 的管理和维护存在诸如插件兼容性、内存泄漏、用户权限管理、脚本维护等多方面的问题，导致运维人员仍需花费大量时间进行系统维护。因此，是否可以完全弃用 Jenkins，并将现有任务全部迁移到 Zadig 上执行呢？</span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)"><strong>答案是肯定的</strong></span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">。Zadig 不仅具备 Jenkins 的全部功能，而且能够实现软件开发过程中复杂流程的自动化。</span></p><span id="OSC_h1_1"></span><h1><strong>一、Zadig 工作流到底有何独特之处？</strong></h1><p style="margin-left:0; margin-right:0">Zadig 工作流引擎起初基于 Kubernetes 原生能力搭建，借助 Kubernertes 的资源动态分配能力，实现多任务的并发执行，相比 Jenkins 至少可以节省<span>&nbsp;</span><span><strong>50%</strong></span><span>&nbsp;</span>的资源，并可以提高至少<span>&nbsp;</span><strong><span>40%</span></strong><span>&nbsp;</span>的任务执行效率。</p><p style="margin-left:0; margin-right:0">Zadig 工作流的设计更贴合实际业务场景，支持编排产品交付过程中涉及到的任何系统和工具，如：项目管理系统、代码托管平台、测试平台、部署工具、配置管理工具、数据管理工具、审批系统、企业自建系统等等。Zadig 工作流除了具备 CI 工作流的基本能力（比如克隆代码、执行 shell 脚本、触发器、通知、缓存等等）外，支持以下更多能力：</p><ul><li><p style="margin-left:0; margin-right:0"><span>支持多服务共享构建、构建模板、利用 Serverless 资源构建</span></p></li><li><p style="margin-left:0; margin-right:0">支持多服务的并发构建、并发部署、并发测试</p></li><li><p style="margin-left:0; margin-right:0">支持项目管理中的任务状态变更、配置变更、数据变更</p></li><li><p style="margin-left:0; margin-right:0">支持蓝绿发布、金丝雀发布、分批次灰度发布、MSE 全链路和 Istio 全链路发布</p></li><li><p style="margin-left:0; margin-right:0">支持发布过程审批</p></li><li><p style="margin-left:0; margin-right:0">在执行时支持根据实际的分支策略，自由选择<span>&nbsp;</span><span style="background-color:rgba(0, 0, 0, 0.19)">Branch</span><span style="background-color:#ffffff">、</span><span style="background-color:rgba(0, 0, 0, 0.19)">PR/MR</span>、<span style="background-color:rgba(0, 0, 0, 0.19)">Branch+PR/MR</span>、<span style="background-color:rgba(0, 0, 0, 0.19)">Tag</span>、<span style="background-color:rgba(0, 0, 0, 0.19)">Commit</span><span>&nbsp;</span>方式进行构建</p></li><li><p style="margin-left:0; margin-right:0"><span>......</span></p></li></ul><span id="OSC_h3_2"></span><h3><span style="color:#fd2968">工作流实现方式的细节差异</span></h3><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,&quot;system-ui&quot;,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:657px; word-spacing:0px"><tbody><tr><td style="background-color:#ff7faa; border-color:#3e3e3e #f0f9ff #3e3e3e #3e3e3e; border-image:initial; border-style:none solid none none; border-width:0px 1px 0px 0px"><p style="margin-left:0; margin-right:0"><span style="color:#ffffff"><strong>工作流关键环节</strong></span></p></td><td style="background-color:#ff7faa; border-color:#3e3e3e #f0f9ff #3e3e3e #3e3e3e; border-image:initial; border-style:none solid none none; border-width:0px 1px 0px 0px"><p style="margin-left:0; margin-right:0"><span style="color:#ffffff"><strong>Jenkins</strong></span></p></td><td style="background-color:#ff7faa; border-color:#3e3e3e #f0f9ff #3e3e3e #3e3e3e; border-image:initial; border-style:none solid none none; border-width:0px 1px 0px 0px"><p style="margin-left:0; margin-right:0"><span style="color:#ffffff"><strong>Zadig</strong></span></p></td></tr><tr><td style="background-color:rgba(255, 242, 243, 0.46); border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699"><strong>执行环境</strong></span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">手工制作环境</span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">可扩展云原生环境及依赖包</span></p></td></tr><tr><td style="background-color:rgba(255, 242, 243, 0.46); border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699"><strong>代码信息</strong></span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">分散配置代码源</span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">统一管理多种代码来源</span></p></td></tr><tr><td style="background-color:rgba(255, 242, 243, 0.46); border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699"><strong>执行脚本与变量</strong></span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">分散编写脚本</span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">统一配置脚本规范</span></p></td></tr><tr><td style="background-color:rgba(255, 242, 243, 0.46); border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699"><strong>定时触发</strong></span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">定时触发</span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">多种可定制触发策略</span></p></td></tr><tr><td style="background-color:rgba(255, 242, 243, 0.46); border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699"><strong>代码变更触发</strong></span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">插件代码触发</span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">海量多种触发策略</span></p></td></tr><tr><td style="background-color:rgba(255, 242, 243, 0.46); border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699"><strong>工作流间的串接</strong></span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">根据工作流状态触发</span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">服务化灵活编排调度</span></p></td></tr><tr><td style="background-color:rgba(255, 242, 243, 0.46); border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699"><strong>多任务并发执行</strong></span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">编写脚本控制并发</span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">云原生任务 GUI 配置并发</span></p></td></tr><tr><td style="background-color:rgba(255, 242, 243, 0.46); border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699"><strong>任务并发数量控制</strong></span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">资源节点控制并发</span></p></td><td style="border-color:#3e3e3e #7aafe7 #7aafe7 #3e3e3e; border-image:initial; border-style:solid; border-width:0px; vertical-align:top"><p style="margin-left:0; margin-right:0"><span style="color:#ff6699">统一管理并发调度策略</span></p></td></tr></tbody></table><p>&nbsp;</p><span id="OSC_h1_3"></span><h1><strong><span style="color:#ff2968">二、如何将 Jenkins 上的配置</span></strong><strong><span style="color:#ff2968">迁移到 Zadig 上</span></strong></h1><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">下面详细介绍如何将已经在 Jenkins 上的相应配置迁移到 Zadig 上，按照不同的阶段拆解迁移的过程。</span></p><span id="OSC_h3_4"></span><h3><span style="color:#fd2968"><strong>比较一：执行环境</strong></span></h3><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">对于工作流任务依赖的环境，在 Jenkins 上需在对应节点上手工制作，而在 Zadig 上支持管理任务运行时基础环境和依赖的软件包，方便平台运维统一管控业务构建、测试等过程使用的基础资源，保障资源的安全及合规。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">Jenkins 任务的执行环境通过在配置中选择运行节点来指定，任务执行过程中用到的软件包需要在对应节点上安装和管理。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img alt="" src="https://oscimg.oschina.net/oscnet/up-b03a84b1b4a2458670650dacef1c171c016.png" referrerpolicy="no-referrer"></p><p>&nbsp;<span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">Zadig 任务的执行环境通过在配置中选择操作系统和依赖软件包来指定。</span></p><p><img height="1414" src="https://oscimg.oschina.net/oscnet/up-66a8378c904b5f89d3ee1eb8d897bdb75a2.png" width="2904" referrerpolicy="no-referrer"></p><p><img height="1414" src="https://oscimg.oschina.net/oscnet/up-2683317702faa1d26a984502cad7be11112.png" width="2904" referrerpolicy="no-referrer"></p><p><img height="1414" src="https://oscimg.oschina.net/oscnet/up-2acc8d6572e9822324abf804ba7b27b1fcf.png" width="2904" referrerpolicy="no-referrer"></p><span id="OSC_h3_5"></span><h3><span style="color:#fd2968"><strong>比较二：代码信息</strong></span></h3><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">对企业内部使用的代码源，在 Jenkins 上将其分散在不同的任务中进行管理，而在 Zadig 上由管理员统一集成，以确保代码源的安全性。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">下面以 GitLab 为例，比对 Jenkins 和 Zadig 上代码信息的配置。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">Jenkins 通过配置「源码管理」来实现构建代码源的定义。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1414" src="https://oscimg.oschina.net/oscnet/up-febe241da9a1686ed0b8f46d3f0f7b21095.png" width="2904" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">Zadig 支持 GitLab、GitHub、Gerrit、Gitee 、其他通用 Git 代码源等代码托管平台的集成，完成集成后可列出代码库中有权限的代码仓库信息，包括 Branch、PR/MR、Tag 等等，对于开发者更加直观、体验更友好。</p><p style="margin-left:0; margin-right:0"><strong><span>·<span>&nbsp;</span></span></strong>步骤 1：集成代码源。具体过程参考<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.koderover.com%2Fzadig%2Fsettings%2Fcodehost%2Fgitlab%2F" target="_blank"><span style="color:#0080ff">GitLab 代码源集成</span></a><span>&nbsp;</span>[1]</p><p style="margin-left:0; margin-right:0"><img height="1414" src="https://oscimg.oschina.net/oscnet/up-999d1878b4bf86f8d9eea338e6e44eed49c.png" width="2904" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong><span>·<span>&nbsp;</span></span></strong><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">步骤 2：任务中配置代码信息。Zadig 构建、测试、代码扫描及通用任务均支持拉取代码信息。</span></p><p style="margin-left:0; margin-right:0"><img height="1414" src="https://oscimg.oschina.net/oscnet/up-d823c5f1fe7a383959d3e9661142357980c.png" width="2904" referrerpolicy="no-referrer"></p><span id="OSC_h3_6"></span><h3><span style="color:#fd2968"><strong>比较三：执行脚本及变量</strong></span></h3><p style="margin-left:0; margin-right:0">对于服务执行脚本和变量的定义，在 Jenkins 上分散在各个任务中进行管理，而在 Zadig 上可以通过构建模版来标准化服务的构建过程，降低运维管理的负担。</p><p style="margin-left:0; margin-right:0">下面以一个多服务的代码仓库的构建并推送镜像为例，比较 Jenkins 脚本编写和 Zadig 脚本编写的差异。</p><p style="margin-left:0; margin-right:0">Jenkins 执行脚本及变量如下图所示，脚本中主要进行服务构建、镜像构建以及镜像推送过程。其中 $SERVICE、$VERSION、$PWD 变量需要在配置中定义。</p><p style="margin-left:0; margin-right:0"><img height="1414" src="https://oscimg.oschina.net/oscnet/up-38c673bada87035ad70e58c24f0e028dd21.png" width="2904" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="1414" src="https://oscimg.oschina.net/oscnet/up-ae40af20e6b1b72caaf08dd2bc574e43e05.png" width="2904" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">Zadig 执行脚本及变量如下图所示，Zadig 构建内置 $SERVICE、$IMAGE 变量，脚本更加简洁。</span></p><p style="margin-left:0; margin-right:0"><img height="1414" src="https://oscimg.oschina.net/oscnet/up-29b021813c3330edbc16205166a2a0f7d25.png" width="2904" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="1414" src="https://oscimg.oschina.net/oscnet/up-c151777d9c835d19a639bed96ea643e76c6.png" width="2904" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">两者之间的差异：</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">1. Zadig 任务执行过程中根据工作流配置的镜像仓库自动完成<span style="background-color:rgba(0, 0, 0, 0.19)"><span>&nbsp;</span>docker login<span>&nbsp;</span></span>操作，所以无需在脚本中声明。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">2. 在 Zadig 中镜像命名规则支持统一配置和管理，具体可参考<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.koderover.com%2Fzadig%2Fproject%2Fservice%2Fk8s%2F%23%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE" target="_blank"><span style="color:#0080ff">文档</span></a><span>&nbsp;</span>[2]，所以无需在脚本中定义<span style="background-color:rgba(0, 0, 0, 0.19)"><span>&nbsp;</span>IMAGE<span>&nbsp;</span></span>变量的生成规则。</p><span id="OSC_h3_7"></span><h3>&nbsp;</h3><span id="OSC_h3_8"></span><h3><span style="color:#fd2968"><strong>比较四：定时触发</strong></span></h3><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">工作流任务的定时执行场景比较常见，Jenkins 针对工作流任务的默认参数可以配置定时触发，而 Zadig 上除了可以指定触发时间周期外，还支持配置任务的执行变量，更加灵活。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">Jenkins 触发器支持配置 Cron 表达式来定时触发任务。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1428" src="https://oscimg.oschina.net/oscnet/up-916400c25cec910faaf5caa14f50bb82bb0.png" width="2904" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">Zadig 定时器支持多种触发方式，包括定时循环、间隔循环和 Cron 表达式，以满足各种定时触发的需求。此外，相较于 Jenkins 使用默认参数执行，Zadig 定时器允许配置不同的工作流执行变量，提供更灵活的定制选项。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1428" src="https://oscimg.oschina.net/oscnet/up-5a857454ef740f8ecc70b00f4ebc517306b.png" width="2904" referrerpolicy="no-referrer"></p><span id="OSC_h3_9"></span><h3>&nbsp;</h3><span id="OSC_h3_10"></span><h3><span style="color:#fd2968"><strong>比较五：代码变更触发</strong></span></h3><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">开发者提交代码自动触发工作流执行是持续集成和持续部署（CI/CD）中常见的实践。在 Jenkins 中，为实现这一需求，需要依赖插件。相比之下，Zadig 则内建 Git 触发器功能，无需额外插件，通过灵活的配置满足各种触发场景，从而提升整体效率。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">Jenkins 可以通过安装插件实现代码变更触发任务的执行。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1428" src="https://oscimg.oschina.net/oscnet/up-8969ed3234ff36d444ddfcb159cb3ac0191.png" width="2904" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">Zadig Git 触发器支持代码变更触发，通过定义代码信息、触发事件、代码文件目录以及工作流执行变量，来配置触发规则。这使得在代码库发生变更时，可以灵活而精准地触发相应的工作流，以满足各种复杂的自动化流程的执行。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1444" src="https://oscimg.oschina.net/oscnet/up-0b6f382446af82a670dc25d831d63126c0a.png" width="2904" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">除了上述两种触发器，Zadig 还支持多种其他触发器，包括「JIRA 触发器」、「飞书项目触发器」和「通用触发器」等，使用详情参考</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.koderover.com%2Fzadig%2Fproject%2Fworkflow-trigger%2F" target="_blank"><span style="background-color:#ffffff; color:#0080ff">文档</span></a><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)"><span>&nbsp;</span>[3]。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><span id="OSC_h3_11"></span><h3><span style="color:#fd2968"><strong>比较六：工作流之间的串接编排</strong></span></h3><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">企业内部对于一些服务化的任务，例如安全扫描服务，需要进行统一管理并在多个工作流中使用。通常，这些任务由安全部门或平台团队进行统一管理，然后在各个业务工作流中进行调用。为了降低实施和后续维护的负担，一般选择采用多工作流串接的方式，以实现更高效的任务调度和管理。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">Jenkins 通过配置「构建其他工程」来触发其他任务。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1432" src="https://oscimg.oschina.net/oscnet/up-6af1ce2aae3f7eeb01d1a3f2b037c0589c9.png" width="2936" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">Zadig 的工作流本身采用了服务化的设计，使得测试、代码扫描等配置可以实现集中化的管理，然后轻松挂接到各个工作流中使用。这种设计使得配置和管理变得更加高效，同时在不同的工作流中灵活地应用这些服务，提高了整体工作流的可维护性和可扩展性。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1432" src="https://oscimg.oschina.net/oscnet/up-5dd0db5d0c2484d09a8fe71af3c8ab26fd2.png" width="2936" referrerpolicy="no-referrer"></p><span id="OSC_h3_12"></span><h3>&nbsp;</h3><span id="OSC_h3_13"></span><h3><span style="color:#fd2968"><strong>比较七：多任务并发执行</strong></span></h3><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">多任务并发执行在复杂的软件开发流程、持续集成和部署中尤为关键。这能够显著减少工程师的等待时间，提高整体研发效率，从而加速项目进程，更灵活地应对不断变化的需求。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">Jenkins 流水线支持不同的 "stage" 并发执行，详细配置请参考以下结构。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="582" src="https://oscimg.oschina.net/oscnet/up-3be3980e313fc5d5e0caa6dfb825822a50a.png" width="822" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">Zadig 工作流仅需在「阶段」上打开「并发执行」的开关，即可实现阶段内多个任务的并发执行。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1432" src="https://oscimg.oschina.net/oscnet/up-df878ddc393fe89803cc5ccd6adb4fbc5c8.png" width="2936" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1432" src="https://oscimg.oschina.net/oscnet/up-19fbbbb66f8dfb1f131220b679faf5efc10.png" width="2936" referrerpolicy="no-referrer"></p><span id="OSC_h3_14"></span><h3>&nbsp;</h3><span id="OSC_h3_15"></span><h3><span style="color:#fd2968"><strong>比较八：任务并发数量控制</strong></span></h3><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">Jenkins 和 Zadig 均支持同一工作流的多个任务并发执行。Jenkins 通过资源节点来控制并发数量，而 Zadig 则统一管理并发调度策略，具有灵活控制任务优先级能力。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">Jenkins 通过在节点上配置「任务执行数量」来控制多个任务的并发，单个 Jenkins 任务的并发可以在任务配置中指定。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1418" src="https://oscimg.oschina.net/oscnet/up-16aee0879ad6a67f8bb0a2a8f6d9e645af0.png" width="2904" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1414" src="https://oscimg.oschina.net/oscnet/up-2a9a5bef154eeb56b5410d206a91d0bbb51.png" width="2904" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">Zadig 通过在任务配置中修改「任务并发数量设置」实现并发数控制，其中「工作流任务并发数量」控制同时执行的工作流任务数，「单任务服务并发数」控制同一个工作流任务中服务的并发数量。除此之外，面对低优先级任务占用全局并发数量的场景，可以通过配置工作流的「执行并发数」来解决。Zadig 具有更自由的任务并发数控制，能够灵活应对企业内部复杂的任务并发场景。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1418" src="https://oscimg.oschina.net/oscnet/up-4acde3574c2e0b7e1f4d8fad7f01f629f9f.png" width="2904" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="1418" src="https://oscimg.oschina.net/oscnet/up-e7872ba2b6aec2838c8c1ad71c7ccdc7f78.png" width="2904" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">除以上能力外，Jenkins 通过插件来扩展更多的能力，而 Zadig 可以通过开发「自定义任务」，和企业自建系统打通，来满足企业复杂流程，具体开发过程参考</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.koderover.com%2Fzadig%2Fsettings%2Fcustom-task%2F" target="_blank"><span style="background-color:#ffffff; color:#0080ff">文档</span></a><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)"><span>&nbsp;</span>[4]。</span></p><span id="OSC_h4_16"></span><h4><strong>参考链接</strong></h4><p style="margin-left:0; margin-right:0; text-align:left"><span>[1]&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.koderover.com%2Fzadig%2Fsettings%2Fcodehost%2Fgitlab%2F" target="_blank"><span style="color:#0080ff">https://docs.koderover.com/zadig/settings/codehost/gitlab/</span></a></p><p style="margin-left:0; margin-right:0; text-align:left"><span>[2]&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.koderover.com%2Fzadig%2Fproject%2Fservice%2Fk8s%2F%23%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE" target="_blank"><span style="color:#0080ff">https://docs.koderover.com/zadig/project/service/k8s/#策略配置</span></a></p><p style="margin-left:0; margin-right:0; text-align:left">[3]&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.koderover.com%2Fzadig%2Fproject%2Fworkflow-trigger%2F" target="_blank"><span style="color:#0080ff">https://docs.koderover.com/zadig/project/workflow-trigger/</span></a></p><p style="margin-left:0; margin-right:0; text-align:left">[4]&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.koderover.com%2Fzadig%2Fsettings%2Fcustom-task%2F" target="_blank"><span style="color:#0080ff">https://docs.koderover.com/zadig/settings/custom-task/</span></a></p><p style="margin-left:0px; margin-right:0px; text-align:center">&nbsp;</p><p style="margin-left:0px; margin-right:0px; text-align:center"><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">立即体验 Zadig V2.0 新架构，开启高效交付之旅！🚀&nbsp;</span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><strong><span style="color:#ff2968">Zadig 开放，链接，专业</span></strong></p><p style="margin-left:0px; margin-right:0px; text-align:center"><strong><span style="color:#ff2968"><img alt="" src="https://oscimg.oschina.net/oscnet/up-b3270466a68bf98a90c5d08b91cd0ebc98c.png" referrerpolicy="no-referrer"></span></strong></p><p style="margin-left:0px; margin-right:0px; text-align:center">&nbsp;</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center">&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig">Zadig 在 Gitee</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><strong>推荐阅读：</strong></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490415%26idx%3D1%26sn%3D1914c7fd25aac5d33b98663571bbb744%26chksm%3Dcfb457cff8c3ded9c02809aad88012fa802eac55222eebe70b8c637ca2c86a101045aa81e73a%26scene%3D21%23wechat_redirect" target="_blank">是时候和 Jenkins 说再见了</a>&nbsp;</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491115%26idx%3D1%26sn%3D83e593f77e1aec4d59cee72cca711927%26chksm%3Dcfb4528bf8c3db9de4d0adbe3c0cb15600d35e647c869867dc2e99a599cd7f58ca6208bb4443%26scene%3D21%23wechat_redirect" target="_blank">不想放弃 Jenkins？这么做也能云原生</a>&nbsp;</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491064%26idx%3D1%26sn%3D4bbe7bfe944feaa8b44a08e6156e04e2%26chksm%3Dcfb45158f8c3d84e40d44d2dd9228a844b9bcdeea1fe32a7b0ae41b9af982c11319a38f6675e%26scene%3D21%23wechat_redirect" target="_blank">Zadig 推出环境睡眠，平均节省一半测试资源</a>&nbsp;</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center">&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank">Zadig vs. Jenkins 详细比对：时代的选择与开发者之选</a>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 28 Nov 2023 03:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/koderover/blog/10314033</guid>
            <link>https://my.oschina.net/koderover/blog/10314033</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Java 8 仍被广泛使用，占比 50%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">JetBrains&nbsp;最新发布的 2023 年度开发者生态系统调查报告指出，在面向 Java 开发者的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.jetbrains.com%2Flp%2Fdevecosystem-2023%2Fjava%2F" target="_blank">调查</a>中，</span>更多的开发人员选择在生产中使用 Java 17，而不是 Java 11。Docker 逐渐成为打包 Web 应用程序的首选，且 Spring 和 Spring Boot 的使用率遥遥领先。</span></p><p><span style="color:#000000">具体而言，开发者最常使用的&nbsp;Java 版本是&nbsp;Java 8，占比高达&nbsp;50%；其次分别是&nbsp;Java 17 (45%)、Java 11(38%) 以及&nbsp;Java 20 (11%)。</span></p><p><span style="color:#000000">「很遗憾看到这么多人仍在使用 Java 8（及更旧的版本）。我想知道是什么阻碍了他们升级到更新的版本并获得强大的新语言功能，以及我们如何帮助他们将代码迁移到更新的 Java 版本。」</span></p><p><img height="356" src="https://oscimg.oschina.net/oscnet/up-d79d8c2307c0972948764928b7719266a39.png" width="300" referrerpolicy="no-referrer"></p><p>其他一些发现包括：</p><ul><li><span style="color:#000000">58% 的受访者表示，他们打包 Web 应用程序的方式是&nbsp;Docker，还有 56% 使用的是<span style="background-color:#ffffff">嵌入式服务器。</span></span></li><li>最常用的是单元测试框架是&nbsp;JUnit，以 84% 的占比稳居首位。</li><li><span style="color:#000000">Web 框架方面，72</span>% 开发者正在使用&nbsp;Spring Boot。</li><li>Java EE 8 / Jakarta EE 8 使用率为 33%，Jakarta EE 10 以 10% 的使用率超过了 Jakarta EE 9 的 7%。</li><li>Java 开发中使用最多的&nbsp;IDE/编辑器是 IntelliJ IDEA，占比 78%。</li><li><span style="background-color:#ffffff; color:#19191c">JavaScript、SQL、Python 和 HTML / CSS 是那些使用 Java 作为主要语言之一的人中最常用的语言和技术。</span></li></ul><p><img height="184" src="https://oscimg.oschina.net/oscnet/up-7a087c1c4d8482dffc48bd3f1d157872f49.png" width="500" referrerpolicy="no-referrer"></p><p>更多详情可查看<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.jetbrains.com%2Flp%2Fdevecosystem-2023%2Fjava%2F" target="_blank">此处</a></strong>。</p><p><strong>相关阅读：</strong></p><ul><li style="text-align:start"><a href="https://www.oschina.net/news/267606/jetbrains-devecosystem-2023" target="_blank">JetBrains 报告：Scala/Go/Kotlin 薪酬最高，Objective-C 日薄西山</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 28 Nov 2023 03:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268636/devecosystem-2023-java8</guid>
            <link>https://www.oschina.net/news/268636/devecosystem-2023-java8</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[滴滴史上最严重服务故障，罪魁祸首是底层软件 or 「降本增笑」？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 11 月 27 日晚间，<u><a href="https://www.oschina.net/news/268480">滴滴因系统故障导致 App 服务异常</a></u>，不显示定位且无法打车。11 月 27 日晚，滴滴出行进行了回复：非常抱歉，由于系统故障。</p><p>2023 年 11 月 28 日早间，滴滴出行消息称，网约车等服务已恢复，骑车等在陆续修复中。11 月 28 日，在滴滴发出公告的同时，记者在上海、深圳等地使用滴滴呼叫网约车，发现网约车功能并未恢复使用，网络加载异常，仍无法打车。11 月 28 日，滴滴向记者回应称，网约车服务已恢复，司机乘客权益陆续恢复补发。</p><p><strong>11 月 29 日，滴滴再次发文致歉，称初步确定事故起因是底层系统软件发生故障</strong>。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-de730d329966eb2d4a658c5008f11be82a7.png" referrerpolicy="no-referrer"></p><p>来源：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F2838754010%2FNuMAAaUEl" target="_blank">https://weibo.com/2838754010/NuMAAaUEl</a></em></u></p></blockquote><p>在滴滴官方发布这份公告之前，已经有资深 IT 技术人士分析：「从表现上看，打车、共享单车全挂，不同的业务板块之间应该是有隔离的，说明问题出在更加底层的基础设施。攻击者一般只能访问到应用层，基础设施访问不到。要么是被攻击者打穿，要么是自己系统操作不慎挂了。即便是前者，也算是一种系统缺陷，才会被打穿。」</p><p>360 安全专家认为，滴滴闪崩背后的技术原因可能有六种：</p><p>第一，系统更新升级过程中出现了编程错误、逻辑错误或未处理的异常情况：一般情况下，互联网厂商发布更新都会在晚上，与滴滴发生故障的时间也能对应，当然业务升级维护是放量更新，但现在滴滴全平台、全业务都故障了，说明肯定是他「家里」的问题。</p><p>第二，服务器故障：比如滴滴的核心机房，可能恒温恒湿环境出了问题，导致服务器过热、CPU 烧了，或者核心机房所在地发生了自然灾害如地震、洪水、海啸等，这种情况下，硬件需要重新更换，里面的服务软件也需要重新配置，恢复周期相对较长，但这个可能性比较小。</p><p>第三，第三方服务故障：滴滴的后台架构可能使用了第三方服务或者组件。如果第三方出了问题，也可能会影响滴滴的正常运行。但出于安全性考虑，滴滴可能不会将核心业务托管给第三方，不过这个可能性也较小。</p><p>第四，DDOS 攻击：黑客采用分布式拒绝服务的方式，抢占了大量的服务器资源，导致用户无法访问，但这个不太可能，因为 DDos 不会导致数据出错，而且滴滴从体量上来说，有足够的成本和能力去对抗。</p><p>第五，其他网络攻击：某些黑灰产团伙可能会通过拖库盗取数据，然后在暗网上售卖，在这个过程中不排除会有误操作，破坏了数据库。</p><p>第六，勒索病毒：网络攻击黑客对滴滴的底层数据、业务代码进行了加密。据披露现象，用户的账单和打车数据都算错了，存在一定可能是滴滴为了避免更大损失主动暂停了业务。近期勒索攻击事件屡屡发生，月初，某金融机构就是因为遭遇勒索病毒攻击造成了业务停摆。</p><p>不过也有网络安全公司专家认为，如果是来自外部的黑客攻击，公司一般会在第一时间进行声明。他猜测更集中于滴滴发生了内部重大业务调整，或有新业务接入原系统，但没有做好预案，导致关联业务或关联系统出现重大故障，这是大公司系统故障最常见的原因。</p><p>因此对于滴滴此次大规模的长时间故障，有行业人士认为，<strong>降本增效可能也是原因之一</strong>。</p><p>该人士认为，<strong>互联网公司核心业务频繁宕机，且长时间宕机，是降本增效的附属品之一。系统投资少了，维护资源少了，程序员更换频繁了，BUG 就多</strong>。</p><p>他举例称，一般在业务上行阶段都有冗余，为了迎接随时爆发的订单，上行阶段要维持负载的上限不能过大，比如平时 70%，这样遇到一个小爆发不用担心会出问题，足以应对小高峰；但是下行期的逻辑就不同了，负载很高的时候抗一抗就行了，虽然后面遇到小高峰可能会难受，但是随着时间的推移总体负载会下降。</p><hr><p>最后来看一下网传的消息，有同行说滴滴这次严重故障是升级 k8s 版本导致，当时 SRE 工程师定位了三个小时都没定位到问题。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-a181b0f3434ee33fc8d1903a1fdf9a188bc.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1129/113103_VOdZ_2720166.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9c6757d79e017225bd7d61ecc642362132f.png" referrerpolicy="no-referrer"><span>&nbsp;</span></p></blockquote><p>从滴滴公开的技术分享来看，滴滴弹性云在上个月升级了 k8s 版本：从 k8s 1.12 升级到 1.20。</p><ul><li>K8s 1.12<span>&nbsp;</span>发布于 2018 年：<em><u><a href="https://www.oschina.net/news/100393/kubernetes-1-12-0-released" target="_blank">Kubernetes 1.12 正式发布，新增 VMSS 支持</a></u></em></li><li>K8s 1.20 发布于 2020 年：<em><u><a href="https://www.oschina.net/news/123008/kubernetes-1-20-released" target="_blank">Kubernetes 1.20 发布：妙啊</a></u></em></li></ul><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-d0aafb8fd2141c9aaf3394b4081fcda9aef.png" referrerpolicy="no-referrer"><br><br><strong><em>来源：</em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FnMSIsS72fSXGqJO9Vy_Pfw" target="_blank"><u><em>滴滴弹性云基于 K8S 的调度实践</em></u></a></strong></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 28 Nov 2023 03:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268635</guid>
            <link>https://www.oschina.net/news/268635</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[周鸿祎：「360 无法卸载」是彻底的谣言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>俞敏洪在公众号更新了与周鸿祎的采访对话。对话中双方聊到了大众对 360 的误解，<strong>周鸿祎表示，360 不能卸载是一个彻底的谣言。</strong></p><blockquote><p><img height="1206" src="https://static.oschina.net/uploads/space/2023/1129/110144_gNAL_2720166.png" width="1480" referrerpolicy="no-referrer"></p><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fpd2R8Y5Q6HtYODNfRvcbnA" target="_blank">https://mp.weixin.qq.com/s/pd2R8Y5Q6HtYODNfRvcbnA</a></u></em></p></blockquote><p>周鸿祎称，因为 360 提供了完整的卸载过程。有的小朋友总是试图用一个 Windows 的删除想把 360 的目录删掉，这样其实是删不掉的，所以大家就会有一个错误的印象，好像 360 删不掉。</p><p>但是你想，360 在电脑上是起保护作用的，最恨 360 的是什么？是各种黑产、黑客，现在无论是国外的网军做攻击，还是国内的勒索软件做攻击，因为 360 装的太广，所以他们很重要的一个任务就是想办法让 360 失效，要不然 360 一报警他们就出问题了，<strong>所以你随便用一个 Windows 做一个拖拽，把它移垃圾箱里肯定是不行的</strong>。</p><p>甚至<strong>现在很多国外的攻击软件试图调动 360 自己删自己的过程，因为 360 提供了自己卸载自己的能力，所以在用户卸载的时候，我们要区别是用户真的在卸载，还是被攻击了模拟用户在卸载</strong>，因为很多软件可以模拟用户的操作。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-75c92d5bced77262bd78834927c10f9975c.png" referrerpolicy="no-referrer"></p><p>我们为了做自我保护，可能有一个比较烦琐的提示过程，就是这样以讹传讹，好像就变成了 360 不能卸载，这是一个彻底的谣言。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 28 Nov 2023 02:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268632</guid>
            <link>https://www.oschina.net/news/268632</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
