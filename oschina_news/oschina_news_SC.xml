<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-最新资讯]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-最新资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 23 Nov 2023 22:53:06 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Rust Web 框架 Rocket 发布 v0.5：支持异步、SSE、WebSockets 等]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>历经四年多，四个 RC 版本、一千次 commit、一千多个 issue、讨论和 PR 之后，<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frocket.rs%2Fv0.5%2Fnews%2F2023-11-17-version-0.5%2F" target="_blank">Rocket v0.5 正式发布了</a></u></strong>。</p><blockquote><p>Rocket 是支持异步的后端 Rust Web 框架，专注于可用性、安全性、可扩展性和性能。它使编写安全的 Web 应用程序变得简单，而不会牺牲生产力或性能。</p></blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-749db50b650e7b26e57cb9b7f418e05b004.png" referrerpolicy="no-referrer"></p><p>Rocket v0.5 部分重要新功能包括：</p><ol><li><p><strong>支持稳定的 Rust 编译器</strong>：Rocket v0.5 基于 Rust 稳定版本进行编译和构建，开发者现在可以使用稳定发布通道中的<code>rustc</code>编译和构建 Rocket 应用程序，不再需要使用<code>#![feature(..)]</code>crate<strong>&nbsp;</strong>属性。<br> &nbsp;</p><pre><code>#[macro_use] extern crate rocket;

#[get("/&lt;name&gt;/&lt;age&gt;")]
fn hello(name: &amp;str, age: u8) -&gt; String {
    format!("Hello, {} year old named {}!", age, name)
}

#[launch]
fn rocket() -&gt; _ {
    rocket::build().mount("/hello", routes![hello])
}</code></pre><p>&nbsp;</p></li><li><p><strong>支持异步 I/O</strong>：Rocket v0.5 重新构建了核心请求处理部分，利用了 Rust 中最新的异步网络功能。Rocket 现在可以自动在机器上的所有可用核心上多路复用请求处理，使路由处理程序可以声明为异步并使用 await 语法。<br> &nbsp;</p><pre><code>use rocket::tokio;
use rocket::data::{Data, ToByteUnit};

#[post("/debug", data = "&lt;data&gt;")]
async fn debug(data: Data&lt;'_&gt;) -&gt; std::io::Result&lt;()&gt; {
    // Stream at most 512KiB all of the body data to stdout.
    data.open(512.kibibytes())
        .stream_to(tokio::io::stdout())
        .await?;

    Ok(())
}</code></pre><p>&nbsp;</p></li><li><p><strong>支持 Sentinels</strong>：Rocket v0.5 引入了 Sentinels，这是 Rocket 框架独有的功能。Sentinels 提供了一种自动的最后防线，可以在出现无效条件时中止应用程序的启动。Sentinels 可以在 Rocket 之外实现，并且应该尽可能地使用它们。<br> &nbsp;</p><pre><code>use rocket::{Rocket, Ignite, Sentinel};

impl Sentinel for MyResponder {
    fn abort(r: &amp;Rocket&lt;Ignite&gt;) -&gt; bool {
        r.state::&lt;T&gt;().is_none() || !r.catchers().any(|c| c.code == Some(400))
    }
}</code></pre><p>&nbsp;</p></li><li><p><strong>支持流和 SSE</strong>：Rocket v0.5 引入了实时的、类型化的异步流。Rocket 的新异步流部分包含了更多详细信息，我们鼓励所有感兴趣的人查看新的实时、多房间聊天示例。</p></li><li><p><strong>支持 WebSockets</strong>：Rocket v0.5 通过新的升级 API 引入了对 HTTP 连接升级的支持。这个 API 允许响应器在现有的 HTTP 连接中控制与客户端的原始 I/O，从而允许将 HTTP 连接升级到任何协议，包括 WebSockets。</p></li><li><p><strong>全面的表单功能支持</strong>：Rocket v0.5 完全改进了表单支持，支持多部分上传、任意嵌套的集合、即时验证等。Rocket 的新表单协议允许应用程序表达任何结构，任意嵌套和集合，无需任何自定义代码。</p></li></ol><p>除了上述功能之外，Rocket v0.5 还引入了其他 40 多个新功能和重大改进，包括安全和隐私头、优雅的关闭、灵活的配置系统、类型系统强制的数据限制等。</p><p>Rocket v0.5 的发布是一个重要的里程碑，为 Rust 开发者提供了一个强大而易用的 Web 框架。我们鼓励所有用户升级到 Rocket v0.5，并<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frwf2%2FRocket%2Fblob%2Fv0.5.0%2FCHANGELOG.md" target="_blank">查看完整的 CHANGELOG</a></u>以了解所有新功能和改进。</p><p>请注意，Rocket v0.4 仍然会得到支持和安全更新，直到 Rocket v0.6 发布为止。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 11:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267838/rocketrs-0-5-released</guid>
            <link>https://www.oschina.net/news/267838/rocketrs-0-5-released</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Git 2.43 值得关注的新特性]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Git 发布了最新版本 2.43，新增了许多改进和新功能。</p><p>以下是 Git 2.43 的部分亮点：</p><ol><li><p><strong><code>git repack</code>的新功能</strong>：在 Git 2.43 中，git repack 学会了一些新技巧。git repack 用于重新组织仓库中的 pack 文件。在这个版本中，git repack 支持使用多个 cruft pack，并且可以通过对象过滤器将仓库的内容拆分为多个部分。</p></li><li><p><strong>多 cruft pack</strong>：在过去，Git 将无法访问的对象存储在单个 cruft pack 中。但是，这样做会导致在每次重新打包操作时都需要重写整个 cruft pack，从而浪费大量的 I/O 时间。在 Git 2.43 中，引入了对多个 cruft pack 的本地支持，可以将无法访问的对象拆分为多个 pack，从而提高性能。</p></li><li><p><strong>使用对象过滤器拆分仓库</strong>：Git 的「partial clone」机制允许在包含有限对象子集的仓库中进行交互。在 Git 2.43 中，git repack 学会了使用对象过滤器规范重新打包仓库，并可以选择将过滤后的对象移动到其他位置。这使得可以根据需要轻松地过滤和移除不需要的对象。</p></li><li><p><strong>针对 revert 多次回滚的改进</strong>：在过去的 Git 版本中，当多次回滚时，每次回滚都会在提交消息中添加"Revert"，导致提交消息变得冗长。在 Git 2.43 中，Git 意识到进行多次回滚时，会生成更简洁的提交消息。</p></li></ol><p>详情查看&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.blog%2F2023-11-20-highlights-from-git-2-43%2F" target="_blank">https://github.blog/2023-11-20-highlights-from-git-2-43/</a></u></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 10:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267835/git-2-43-highlights</guid>
            <link>https://www.oschina.net/news/267835/git-2-43-highlights</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[云安全之盾：ZStack 云主机安全防护解决方案全方位保护云环境]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0.0001pt; margin-right:0px"><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#000000">随着云计算的蓬勃发展，网络威胁愈发复杂，涵盖了从勒索病毒到 APT 攻击的各种威胁类型。在这一风云变幻的网络安全环境下，云主机安全不再仅仅是一个选项，它是信息系统安全的核心要素。</span></span></span><span><span><span style="color:#000000">云轴科技</span></span></span><span><span><span style="color:#000000">ZStack&nbsp;云主机安全</span></span></span><span><span><span style="color:#000000">防护</span></span></span><span><span><span style="color:#000000">解决方案是为了满足这一需求而生的，与 ZStack</span></span></span><span><span><span style="color:#000000">&nbsp;Cloud</span></span></span><span><span><span style="color:#000000">云</span></span></span><span><span><span style="color:#000000">平台</span></span></span><span><span><span style="color:#000000">全面</span></span></span><span><span><span style="color:#000000">兼容、杀毒性能卓越、具备全面的安全特性，同时支持多部署模式和多操作系统。该方案不仅仅是一个安全防护措施，更是一种安全保障的完整体系，保护</span></span></span><span><span><span style="color:#000000">企业级客户</span></span></span><span><span><span style="color:#000000">的数据和应用安全。<img alt="" height="597" src="https://oscimg.oschina.net/oscnet/up-f056bf758422a99c12e7e04c28f227e5b3a.png" width="1031" referrerpolicy="no-referrer"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0.0001pt; margin-right:0px"><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#000000">在云计算环境下，云主机承载着关键数据和核心业务系统，一旦遭受攻击，最重要的部分可能会被盗取或破坏。而传统的杀毒模式资源占用过多，影响生产系统的性能。因此，一个与底层云计算平台兼容、功能全面且同时具备稳定性和高性能的云主机安全解决方案至关重要。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><strong><span><span><span style="color:#000000">ZStack&nbsp;云主机安全防护解决方案</span></span></span></strong><strong><span><span><span style="color:#000000">亮点</span></span></span></strong></li><li><span><span><span style="color:#000000">云主机安全</span></span></span><span><span><span style="color:#000000">防护解决方案</span></span></span><span><span><span style="color:#000000">与</span></span></span><span><span><span style="color:#000000">ZStack Cloud</span></span></span><span><span><span style="color:#000000">云</span></span></span><span><span><span style="color:#000000">平台深度融合，确保云计算环境的稳定运行。</span></span></span></li><li><span><span><span style="color:#000000">支持无代理模式，通过虚拟化层直接进行病毒查杀，降低性能损耗。</span></span></span></li><li><span><span><span style="color:#000000">支持 0day 漏洞在线补丁修复，保证业务连续性。</span></span></span></li><li><span><span><span style="color:#000000">具备全生命周期的安全能力，包括事前预防、事中防御和事后溯源。</span></span></span></li><li><span><span><span style="color:#000000">多部署模式支持，兼容多类型操作系统，灵活方案选择，降低管理成本。</span></span></span></li></ul><p><span><span><span style="color:#000000"><img alt="" height="573" src="https://oscimg.oschina.net/oscnet/up-e5916906c1b1392e81c3895d25fe7c3a429.png" width="1255" referrerpolicy="no-referrer"></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:start"><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#000000">ZStack 云主机安全</span></span></span><span><span><span style="color:#000000">防护</span></span></span><span><span><span style="color:#000000">解决方案适用于不停机补丁修复、云主机无代理杀毒、宿主机加固防护以及云主机安全综合防护等多个应用场景。能够降低黑客攻击带来的损失，提高运维效率，构建闭环安全系统，为</span></span></span><span><span><span style="color:#000000">云主机提供全面保护。为数据中心云平台提供事前防御措施，事中威胁处理和事后攻击溯源能力，应对网络威胁升级带来的安全挑战。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:start"><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#000000">ZStack 将继续改进和创新，以提供更完整的产品和解决方案，支撑和</span></span></span><span><span><span style="color:#000000">保护客户的数据</span></span></span><span><span><span style="color:#000000">和业务，迎接未来的业务和安全挑战</span></span></span><span><span><span style="color:#000000">。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 10:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267832</guid>
            <link>https://www.oschina.net/news/267832</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux 内核放弃支持过时的图形驱动基础设施]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Linux 内核正在准备删除支持旧的和过时的图形驱动程序的基础设施。</p><p>早在 Linux 6.3 内核中就已经移除了许多旧版的 DRM 驱动程序，现在的补丁进一步删除了支持这些旧的用户空间模式设置图形/显示驱动程序的基础设施。</p><p>在 Linux 6.3 内核中，ATI Rage 128、3Dfx、S3 Savage、Intel 810、SiS、VIA 和 Matrox MGA DRM 驱动程序被淘汰。这是为了清除 DRI1 时代过时 GPU 驱动程序的努力的一部分。</p><p>现在，SUSE 工程师 Thomas Zimmermann 计划进一步删除用户空间模式设置的基础设施。他认为，由于 Linux 6.6 是今年的长期支持版本（LTS）内核。现在是一个很好的时机来删除这个基础设施。如果有人仍在使用这些旧的驱动程序或类似的驱动程序，他们可以继续使用 Linux 6.6 LTS。</p><p>Zimmermann<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Fdri-devel%2F20231122122449.11588-1-tzimmermann%40suse.de%2F" target="_blank">在 dri-devel 上写道</a></u>：</p><blockquote><p>旧的用户空间模式设置驱动程序已经在 Linux v6.3 中被删除。没有人抱怨或要求它们的恢复。现在是时候从 DRM 核心中删除这些驱动程序的基础设施了。</p><p>最近的 Linux v6.6 已被指定为长期支持版本，因此任何剩余的用户还有几年时间来购买新的显卡。通过简单的 drm 仍然支持这些旧设备。将适当的驱动程序与内核模式设置合并也是一个选择。</p><p>补丁 1 到 7 修复了在删除驱动程序过程中被遗忘的一些微不足道的问题。</p><p>补丁 8 和 9 删除了旧的 ioctl 接口。其中一个操作与其他操作不同，因此它有自己的补丁。</p><p>补丁 10 到 12 从 DRM 中删除了旧的源代码。随着这些代码的消失，补丁 13 中的 AGP 代码也可以简化。以前有一个用于用户空间模式设置的设备文件/dev/agpgart，现在已经过时了。</p><p>这 14 个补丁在直接渲染管理器子系统中消除了另外 8000 行旧代码。如果没有提出异议，这个旧的用户空间模式设置基础设施的删除可能会在新的一年的 Linux 6.8 内核周期中发生。</p></blockquote><p>这项工作主要是为了清除过时的 GPU 驱动程序，并为用户提供更好的性能和稳定性。对于依赖旧版驱动程序的用户，他们可以继续使用 Linux 6.6 LTS，直到他们准备好升级到支持新的图形驱动程序的版本。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 10:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267831/linux-drop-old-ums-drm-infra</guid>
            <link>https://www.oschina.net/news/267831/linux-drop-old-ums-drm-infra</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Ubuntu 在新 AMD Zen 4 Threadripper 上的性能比 Windows 11 高约 20%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Freview%2Fthreadripper-7995wx-windows-linux" target="_blank">根据 Phoronix 的报道</a></u>，对于最新的 AMD Zen 4 Threadripper 处理器，运行 Ubuntu 会比 Windows 11 获得更好的性能，前者较后者大约提升了 20% 的性能。这项测试是在一台配置了 HP Z6 G5 A 工作站的 96 核 AMD Ryzen Threadripper PRO 7995WX 处理器上进行的。</p><p><img src="https://oscimg.oschina.net/oscnet/up-c4adb3609ed3dba446e73d67cbfe76cf0a3.png" referrerpolicy="no-referrer"></p><p>测试结果显示，Linux 在处理高核心数处理器时的性能优势比 Windows 更明显。这主要归功于 Linux 内核调度程序在处理大核心数处理器时的优秀表现。此外，Linux 在处理这类高端台式机和工作站上的性能方面也比 Windows 更出色。</p><p>测试中，HP Z6 G5 A 工作站分别运行了预装的 Windows 11 Pro 和 Ubuntu 23.10 操作系统。在运行了一系列适用于高端台式机和工作站的基准测试后，结果显示 Ubuntu Linux 在大部分测试中都表现出更好的性能。这表明 Ubuntu Linux 在处理高核心数处理器时能够更好地利用硬件资源，从而提供更高的性能。</p><p>需要注意的是，这项测试是在特定硬件配置下进行的，因此结果可能会因为不同的硬件配置而有所不同。此外，这项测试只涉及到 Ubuntu 23.10 操作系统，其他 Linux 发行版的性能可能会有所不同。</p><p>总的来说，根据这项测试结果，如果你在使用 AMD Zen 4 Threadripper 处理器的高端台式机或工作站，选择 Ubuntu Linux 作为操作系统可能会获得更好的性能。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 10:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267827</guid>
            <link>https://www.oschina.net/news/267827</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌将于 2024 年 6 月开始禁用 Manifest V2]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">谷歌<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.chrome.com%2Fblog%2Fresuming-the-transition-to-mv3%2F" target="_blank">宣布</a>恢复&nbsp;<span style="background-color:#ffffff">Manifest V2 的</span><span style="background-color:#ffffff">弃用时间表，以继续向 Manifest V3 迈进从而提供更高的安全性和隐私保障。</span>计划最早将于 2024 年 6 月开始在 Chrome 127 及更高版本的 pre-stable 版（开发版、金丝雀版和测试版）中禁用 Manifest V2 扩展。</span></p><p><span style="color:#000000">生效后，Manifest V2 扩展程序将在浏览器中被自动禁用，并且无法再从 Chrome 网上商城安装 Manifest V2 扩展程序。与此同时，Manifest V2 扩展程序将失去 Chrome 网上商城中的精选徽章（如果目前有的话）。</span></p><p><img height="311" src="https://static.oschina.net/uploads/space/2023/1123/174712_jZM4_4252687.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">此前谷歌曾宣布 Chrome 浏览器将在 2023 年 1 月停止支持 Manifest V2 扩展，并且也不再支持更新。但后续却因为 Bug 太多，导致</span></span><a href="https://www.oschina.net/news/221452/google-delays-chrome-manifest-v3">多次推迟发布</a><span style="background-color:#ffffff; color:#333333"><span>&nbsp;</span></span><span style="color:#000000"><span style="background-color:#ffffff">Manifest V3 版本，延长&nbsp;Manifest V2 的使用日期，</span>并于去年 12 月宣布暂停了 Manifest V2 的弃用计划。</span></p><p><span style="color:#000000">在这将近一年的时间里，项目团队表示已根据反馈对 Manifest V3 进行了一系列修改，解决了开发人员反馈的问题并为迁移提供了更好的解决方案。</span></p><p><span style="color:#000000">该公司计划逐步推出这一变更，同时收集用户反馈并收集数据，以确保 Chrome 浏览器用户充分了解详情并寻找到可替代的扩展。预计变更从 pre-stable 版推广到 Chrome 稳定版至少需要一个月的时间，具体时间可能会根据收集到的数据而有所不同。</span></p><p><span style="color:#000000">对于那些使用 ExtensionManifestV2Availability 策略来确保 Manifest V2 扩展在其组织中持续运行的企业，将有额外一年的时间（直到 2025 年 6 月）来迁移其组织中的 Manifest V2 扩展。在此之前，启用了该策略的浏览器不会受到停用的影响。</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">对于仍在发布 Manifest V2 扩展的开发者，谷歌方面强烈建议他们在 2024 年 6 月之前完成向 Manifest V3 的迁移，并提供了一份</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%2Fmigrating%2F" target="_blank">迁移指南</a>。</p><p><span style="color:#000000">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.chrome.com%2Fblog%2Fresuming-the-transition-to-mv3%2F" target="_blank">查看官方公告</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 09:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267820/google-resuming-the-transition-to-mv3</guid>
            <link>https://www.oschina.net/news/267820/google-resuming-the-transition-to-mv3</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[快来查收 KCL 社区开源快讯 | 云原生模型、语言和工具链更新速递!]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img height="258" src="https://oscimg.oschina.net/oscnet/up-10a425f008580d122921fd1db5cbadc672c.jpg" width="520" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:left"><strong>双周同步开源进展</strong></p><p style="color:#000000; text-align:left"><strong>欢迎加入 KCL 社区进行互动～</strong></p><p style="color:#000000; text-align:left">KCL 是一个&nbsp;CNCF 基金会托管的基于约束的记录及函数语言，期望通过成熟的编程语言技术和实践来改进对大量繁杂配置比如云原生 Kubernetes 配置场景的编写，致力于构建围绕配置的更好的模块化、扩展性和稳定性，更简单的逻辑编写，以及更简单的自动化和生态工具集成。</p><p style="color:#000000; text-align:left">本栏目将会双周更新 KCL 语言社区最新动态，包括功能、官网更新和最新的社区动态等，帮助大家更好地了解 KCL 社区！</p><p style="color:#000000; text-align:left"><em><strong>KCL 官网：<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fkcl-lang.io%2F" target="_blank">https://kcl-lang.io</a></strong></em></p><h2>内容概述</h2><p style="color:#000000; text-align:left">感谢所有贡献者过去两周 (2023 11.09 - 11.23) 的杰出工作，以下是重点内容概述</p><p style="color:#000000; text-align:left"><strong>📦 模型更新</strong></p><ul><li>KCL 模型数量新增至<span>&nbsp;</span><strong>200 个</strong>，主要新增与<span>&nbsp;</span><code>Pod</code>,<span>&nbsp;</span><code>RBAC</code><span>&nbsp;</span>相关的校验模型及 Kubernetes 1.14-1.28 版本的模型参考文档</li><li>可以在<span>&nbsp;</span><code>Artifact Hub</code><span>&nbsp;</span>中搜索浏览到所有模型的文档及使用方式:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fartifacthub.io%2Fpackages%2Fsearch%3Forg%3Dkcl%26sort%3Drelevance%26page%3D1" target="_blank">https://artifacthub.io/packages/search?org=kcl&amp;sort=relevance&amp;page=1</a></em></li></ul><p style="color:#000000; text-align:left"><strong>💬 语言更新</strong></p><ul><li><strong>体验改进</strong><ul><li>优化配置代码块的语法缩进检查，不再强制报错</li><li>支持通过文件路径通配符作为编译入口</li></ul></li><li><strong>错误修复</strong><ul><li>修复部分场景字典类型的类型推导错误</li><li>修复 Schema 参数数量的检查</li></ul></li></ul><p style="color:#000000; text-align:left"><strong>🔧 工具链更新</strong></p><ul><li><strong>测试工具发布</strong><ul><li>支持使用 KCL 函数编写单元测试并使用工具执行测试</li><li>支持使用正则表达式过滤待测试用例</li><li>支持单元测试快速失败功能</li></ul></li><li><strong>导入工具更新</strong><ul><li>修复 patterns 到正则匹配表达式的生成:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-openapi%2Fpull%2F70" target="_blank">https://github.com/kcl-lang/kcl-openapi/pull/70</a></em></li><li>修复 minItems/maxItems 到字段长度校验规则的生成:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-openapi%2Fpull%2F69" target="_blank">https://github.com/kcl-lang/kcl-openapi/pull/69</a></em></li><li>修复 0 或空字符串为默认值的生成:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-openapi%2Fpull%2F69" target="_blank">https://github.com/kcl-lang/kcl-openapi/pull/69</a></em></li><li>修复 Kubernetes CRD 到 KCL Package 转换中包名的生成为：<code>${apiVersion}_${kind}</code>:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-openapi%2Fpull%2F68" target="_blank">https://github.com/kcl-lang/kcl-openapi/pull/68</a></em></li></ul></li><li><strong>包管理工具更新</strong><ul><li>新增 update 命令用于自动更新本地依赖:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkpm%2Fpull%2F212" target="_blank">https://github.com/kcl-lang/kpm/pull/212</a></em></li></ul></li></ul><p style="color:#000000; text-align:left"><strong>💻 IDE 更新</strong></p><ul><li><strong>体验改进</strong><ul><li>支持包管理工具引入的外部包依赖 import 语句补全</li></ul></li><li><strong>错误修复</strong><ul><li>修复函数参数未定义类型错误显示位置</li></ul></li></ul><p style="color:#000000; text-align:left"><strong>🏄 API 更新</strong></p><ul><li>新增 KCL 单元测试 API:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fpull%2F904" target="_blank">https://github.com/kcl-lang/kcl/pull/904</a></em></li><li>新增 KCL 符号重命名 API:<span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fpull%2F890" target="_blank">https://github.com/kcl-lang/kcl/pull/890</a></em></li></ul><p style="color:#000000; text-align:left"><strong>🔥 架构升级</strong></p><ul><li>KCL 设计并重构了新的语义模型以及支持最近符号查找和符号语义信息查询 API</li><li>IDE 补全，跳转和悬停等功能实现迁移至新语义模型，显著降低 IDE 功能开发难度和代码量</li></ul><p style="color:#000000; text-align:left"><strong>🚀 性能提升</strong></p><ul><li>KCL 编译器支持语法增量解析以及语义增量检查，大部分场景提升 KCL 编译构建和 IDE 插件使用性能<span>&nbsp;</span><strong>5-10 倍</strong></li></ul><h2>特别鸣谢</h2><p style="color:#000000; text-align:left">以下排名不分先后</p><ul><li>感谢 @cr7258 对 KCL 模型库以及 KCL 文档的贡献 🙌 
  <ul><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-lang.io%2Fpull%2F203" target="_blank">https://github.com/kcl-lang/kcl-lang.io/pull/203</a></em></li><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-lang.io%2Fpull%2F209" target="_blank">https://github.com/kcl-lang/kcl-lang.io/pull/209</a></em></li><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-lang.io%2Fpull%2F210" target="_blank">https://github.com/kcl-lang/kcl-lang.io/pull/210</a></em></li><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-lang.io%2Fpull%2F211" target="_blank">https://github.com/kcl-lang/kcl-lang.io/pull/211</a></em></li><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fmodules%2Fpull%2F67" target="_blank">https://github.com/kcl-lang/modules/pull/67</a></em></li></ul></li><li>感谢 @XiaoK29 为 KCL IDE 的悬停和引用查找功能代码架构重构以及 KCL 文档的贡献 🙌 
  <ul><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fpull%2F887" target="_blank">https://github.com/kcl-lang/kcl/pull/887</a></em></li><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fpull%2F899" target="_blank">https://github.com/kcl-lang/kcl/pull/899</a></em></li><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl-lang.io%2Fpull%2F205" target="_blank">https://github.com/kcl-lang/kcl-lang.io/pull/205</a></em></li></ul></li><li>感谢 @MeenuyD, @negz 对&nbsp;<strong>Crossplane KCL Composition Functions</strong>&nbsp;集成的讨论与支持 🙌 
  <ul><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fissues%2F885" target="_blank">https://github.com/kcl-lang/kcl/issues/885</a></em></li></ul></li><li>感谢 @kolloch 对&nbsp;<strong>Bazel KCL</strong>&nbsp;构建规则脚本的宝贵反馈 🙌 
  <ul><li><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Frules_kcl%2Fpull%2F2" target="_blank">https://github.com/kcl-lang/rules_kcl/pull/2</a></em></li></ul></li><li>感谢 @陆云, @Even Solberg, @Prahalad Ramji @Matt Gowie, @ddh 和 @mouuii 在使用推广 KCL 过程中的交流与宝贵反馈 🙌</li></ul><h2>精选更新</h2><h3>在 Artifact Hub 上检索 KCL 代码包及云原生模型</h3><ul><li>通过 k8s 模型编写或者校验 Kubernetes 配置</li></ul><p style="color:#000000; text-align:left">&nbsp;</p><p><img height="413" src="https://oscimg.oschina.net/oscnet/up-be579d3f163ed2a9ef989f516169d64f9b1.png" width="1080" referrerpolicy="no-referrer"></p><ul><li>通过 Open Application Model (OAM) 开放应用模型配合 KubeVela 控制器进行应用发布与运维</li></ul><p style="color:#000000; text-align:left">&nbsp;</p><p><img height="770" src="https://oscimg.oschina.net/oscnet/up-8a2737b64f74b1d5a27733ce7a5a084a195.png" width="1080" referrerpolicy="no-referrer"></p><ul><li>查找 KCL 代码库如&nbsp;<code>jsonpatch</code>&nbsp;进行配置操作</li></ul><p><img height="718" src="https://oscimg.oschina.net/oscnet/up-15703cf81898b8126bed226fd3e1c45141a.png" width="1080" referrerpolicy="no-referrer"></p><ul><li>通过引入 KusionStack Modules 模型生态并配合 KusionStack 增强客户端的应用交付体验：<em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FKusionStack%2Fcatalog" target="_blank">https://github.com/KusionStack/catalog</a></em></li></ul><p><img height="697" src="https://oscimg.oschina.net/oscnet/up-16ff10fe152afe1ca5321397a39a1b5b41d.png" width="1080" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:left">想了解更多？🤔️ 后续我们会通过一系列文章讲解各个模型更具体使用场景以及工作流程，敬请期待! 此外，200+ 模型的源代码位于&nbsp;<em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fmodules" target="_blank">https://github.com/kcl-lang/modules</a></em>，欢迎社区的小伙伴进行共建。❤️</p><h2>其他资源</h2><p style="color:#000000; text-align:left">❤️ 感谢所有 KCL 用户和社区小伙伴在社区中提出的宝贵反馈与建议。预计&nbsp;11 月底我们会正式发布 KCL v0.7 新版本，敬请期待!</p><p style="color:#000000; text-align:left">更多其他资源请参考：</p><ul><li><p>KCL 网站<span>&nbsp;</span><em>:</em><span>&nbsp;</span><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fkcl-lang.io%2F" target="_blank">https://kcl-lang.io/</a></em></p></li><li><p>KusionStack 网站:&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fkusionstack.io%2F" target="_blank">https://kusionstack.io/</a></p></li><li><p>KCL 2023 路线规划:<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fkcl-lang.io%2Fdocs%2Fcommunity%2Frelease-policy%2Froadmap" target="_blank">https://kcl-lang.io/docs/community/release-policy/roadmap</a></p></li><li><p>KCL v0.7.0 Milestone:<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fmilestone%2F7" target="_blank">https://github.com/kcl-lang/kcl/milestone/7</a></p></li><li><p>KCL v0.8.0 Milestone:<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fmilestone%2F8" target="_blank">https://github.com/kcl-lang/kcl/milestone/8</a></p></li><li><p>KCL Github Issues:<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fkcl%2Fissues" target="_blank">https://github.com/kcl-lang/kcl/issues</a></p></li><li><p>KCL Github Discussion:<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Forgs%2Fkcl-lang%2Fdiscussions" target="_blank">https://github.com/orgs/kcl-lang/discussions</a></p></li><li><p>👉&nbsp;戳链接加入 KCL 社区:<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang%2Fcommunity" target="_blank">https://github.com/kcl-lang/community</a></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 09:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267815</guid>
            <link>https://www.oschina.net/news/267815</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[feilong 4.0.3 发布了，让 Java 开发更简便的工具库]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#1f2328; text-align:start">feilong 4.0.3 发布了，让 Java 开发更简便的工具库</p><ol><li>让你从大量重复的底层代码中脱身,提高开发效率;</li><li>让你的代码<code>更简炼</code>，<code>易写</code>、<code>易读</code>、<code>易于维护</code>;</li></ol><p style="color:#1f2328; text-align:start">文档地址:<span>&nbsp;</span><a href="http://feilong-core.mydoc.io/">http://feilong-core.mydoc.io/</a></p><p style="color:#1f2328; text-align:start">maven 依赖配置:</p><div><pre>&lt;<span style="color:var(--color-prettylights-syntax-entity-tag)">dependency</span>&gt;
     &lt;<span style="color:var(--color-prettylights-syntax-entity-tag)">groupId</span>&gt;com.github.ifeilong&lt;/<span style="color:var(--color-prettylights-syntax-entity-tag)">groupId</span>&gt;
     &lt;<span style="color:var(--color-prettylights-syntax-entity-tag)">artifactId</span>&gt;feilong&lt;/<span style="color:var(--color-prettylights-syntax-entity-tag)">artifactId</span>&gt;
     &lt;<span style="color:var(--color-prettylights-syntax-entity-tag)">version</span>&gt;4.0.3&lt;/<span style="color:var(--color-prettylights-syntax-entity-tag)">version</span>&gt;
&lt;/<span style="color:var(--color-prettylights-syntax-entity-tag)">dependency</span>&gt;</pre><div>
  &nbsp;
 </div></div><p style="color:#1f2328; text-align:start">Gradle 依赖配置:</p><div><pre><span style="color:var(--color-prettylights-syntax-storage-modifier-import)">com</span>.<span style="color:var(--color-prettylights-syntax-storage-modifier-import)">github</span>.<span style="color:var(--color-prettylights-syntax-storage-modifier-import)">ifeilong</span>:<span>feilong</span>:<span style="color:var(--color-prettylights-syntax-constant)">4.0</span><span style="color:var(--color-prettylights-syntax-constant)">.3</span></pre><div>
  &nbsp;
 </div></div><p style="color:#1f2328; text-align:start">本次升级共有<span>&nbsp;</span><code>12</code><span>&nbsp;</span>处变更, 具体参见<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fmilestone%2F37%3Fclosed%3D1" target="_blank">4.0.3 milestone</a></p><h2>🐛<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Abug%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">bug</a></h2><p style="color:#1f2328; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F626" target="_blank">#626</a><span>&nbsp;</span>log 动态参数，最后一个 e 没有生效 [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Afeilong-net-bot%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">feilong-net-bot</a>]</p><h2>🍑<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Afeilong-core%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">feilong-core</a></h2><p style="color:#1f2328; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F624" target="_blank">#624</a><span>&nbsp;</span>✨ 新建 com.feilong.core.lang.ThreadUtil.execute(List, Map&lt;String, ?&gt;, PartitionPerHandler) [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]</p><p style="color:#1f2328; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F635" target="_blank">#635</a><span>&nbsp;</span>PartitionEachSizeThreadConfigBuilder 新增 javadoc [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Ajavadoc%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">javadoc</a>]<br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F636" target="_blank">#636</a><span>&nbsp;</span>✨ 新建 com.feilong.core.lang.ThreadUtil.execute(List, PartitionPerHandler) [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]<br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F630" target="_blank">#630</a><span>&nbsp;</span>✨ 新建 com.feilong.core.net.URLUtil.transformHttpsToHttp(String) [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]<br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F631" target="_blank">#631</a><span>&nbsp;</span>✨ 新建 com.feilong.core.net.URLUtil.transformProtocol(String, String, String) [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]<br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F627" target="_blank">#627</a><span>&nbsp;</span>✨ 新建 com.feilong.core.net.URLUtil.transformHttpToHttps(String) [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]<br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F632" target="_blank">#632</a><span>&nbsp;</span>标识 PartitionEachSizeBuilder<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FFunctionalInterface" target="_blank">@FunctionalInterface</a><br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F633" target="_blank">#633</a><span>&nbsp;</span>标识 PartitionPerHandler<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FFunctionalInterface" target="_blank">@FunctionalInterface</a><br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F634" target="_blank">#634</a><span>&nbsp;</span>标识 PartitionRunnableBuilder<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FFunctionalInterface" target="_blank">@FunctionalInterface</a></p><h2>🍷<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Afeilong-net%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">feilong-net</a></h2><p style="color:#1f2328; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F629" target="_blank">#629</a><span>&nbsp;</span>✨ RequestByteArrayBody 支持字符串格式的 MimeType [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]</p><h2><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Afeilong-net-bot%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">feilong-net-bot</a></h2><p style="color:#1f2328; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%2F625" target="_blank">#625</a><span>&nbsp;</span>✨ 新建个带签名类似于短信 [<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fifeilong%2Ffeilong%2Fissues%3Fq%3Dis%253Aissue%2Blabel%253Aenhancement%2Bmilestone%253A4.0.3%2Bis%253Aclosed" target="_blank">enhancement</a>]</p><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 08:27:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267802/feilong-4-0-3</guid>
            <link>https://www.oschina.net/news/267802/feilong-4-0-3</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Fortran 2023 发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Fortran 2023 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.iso.org%2Fstandard%2F82170.html" target="_blank">已发布</a>。Fortran 2023 是 Fortran 语言的最新版本，它在性能、易用性和并行编程方面都有显著的改进。如果您正在编写一个需要对大型数值数组进行快速计算的程序或库，Fortran 2023 是您的最佳选择。</p><p>Fortran 2023 根据 ISO/IEC 1539-1:2023 标准发布。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/1123/163021_T3nW_2720166.png" referrerpolicy="no-referrer"></p><p>Fortran 2023 是 Fortran 编程语言的最新版本。它是一种高性能并行编程语言，专为科学和工程计算而设计。Fortran 2023 具有许多强大的特性，使得它成为处理大规模数值数组的快速计算的理想工具。</p><ol><li><p>高性能：Fortran 2023 针对科学和工程计算应用进行了优化，具有成熟且经过实战验证的编译器和库，可以编写接近底层的高效二进制代码。</p></li><li><p>静态和强类型：Fortran 是一种静态和强类型的语言，这使得编译器能够在早期捕捉到许多编程错误。这也使得编译器能够生成高效的二进制代码。</p></li><li><p>易学易用：Fortran 是一种相对简单的语言，学习和使用起来非常容易。通过将大多数数学和算术操作表达为方程式，可以轻松地处理大型数组。</p></li><li><p>多功能：Fortran 允许您以最适合问题的方式编写代码：命令式、过程式、面向数组、面向对象或函数式。</p></li><li><p>本地并行：Fortran 是一种本地并行编程语言，具有直观的类似数组的语法，用于在 CPU 之间传递数据。您可以在单个 CPU 上、共享内存多核系统上或分布式内存的 HPC 或基于云的系统上运行几乎相同的代码。Coarrays、teams、events 和集体子程序允许您表达最适合当前问题的不同并行编程模式。</p></li></ol><p>有关语法变更的摘要，查看：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffortran.bcs.org%2F2022%2FAGM22_Reid.pdf" target="_blank">https://fortran.bcs.org/2022/AGM22_Reid.pdf</a></u>。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/1123/162951_mnjD_2720166.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 08:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267801/fortran-2023</guid>
            <link>https://www.oschina.net/news/267801/fortran-2023</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[TQUIC - 高性能轻量级跨平台 QUIC 协议库]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#1f2328; text-align:start">TQUIC 是 IETF QUIC 协议的实现。它是一个高性能、轻量级、跨平台的 QUIC 库。</p><h4 style="text-align:start"><strong>特性及优点</strong></h4><ul><li><p><strong>高性能</strong>：TQUIC 是为高性能和低延迟而设计的。相关细节可以参考<a href="https://tquic.net/zh/docs/further_readings/benchmark">基准测试结果</a>。</p></li><li><p><strong>可插拔拥塞控制</strong>：TQUIC 支持多种拥塞控制算法，包括 CUBIC，BBR，BBRv3，COPA。</p></li><li><p><strong>多路径传输</strong>：TQUIC 支持多路径，一个连接可同时使用多个路径提高性能及可靠性。</p></li><li><p><strong>易用性</strong>：TQUIC 提供易用的接口，支持灵活的配置参数，提供丰富的可观测性。</p></li><li><p><strong>跨平台</strong>：TQUIC 可运行在 Rust 语言支持的各种平台，同时提供了 Rust/C/C++语言接口。</p></li><li><p><strong>基于 Rust</strong>：TQUIC 基于用内存安全语言编写，可避免缓冲区溢出漏洞和其他内存相关错误的影响。</p></li><li><p><strong>高质量</strong>：TQUIC 包括充分的自动化测试，包括单元测试、模糊测试、集成测试、性能基准测试、互操作性测试等。</p></li><li><p><strong>协议一致性</strong>：TQUIC 已通过基于 Ivy 的形式化规范验证。同时通过了 IETF 互操作性测试。</p></li><li><p><strong>丰富的功能</strong>：TQUIC 支持所有 QUIC、HTTP/3 规范中的重大功能。</p></li></ul><h4><strong>架构</strong></h4><p><img height="383" src="https://static.oschina.net/uploads/space/2023/1108/104746_mwuM_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 07:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/tquic</guid>
            <link>https://www.oschina.net/p/tquic</link>
        </item>
        <item>
            <title>
                <![CDATA[程序员篡改 ETC 余额，一年私吞 260 余万元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>上海网警公众号今日报道了一起程序员的违法犯罪案件。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrSUrzlxsrEHgzp0dqhXH1A" target="_blank">据介绍</a></u>，2023 年 9 月上海警方接到某科技公司员工张女士报案称，其公司发现计算机系统被他人篡改数据，导致公司账户钱款损失。</p><p>民警对公司后台电子数据出现的异常账户进行提取，搜证中发现，<strong>操作者很有可能是管理网站后台系统的员工，监守自盗的可能性较大</strong>。</p><p>民警随即展开工作，最终嫌疑人曹某迫于压力主动投案自首。</p><p><img height="810" src="https://static.oschina.net/uploads/space/2023/1123/140254_7G6Y_2720166.png" width="1080" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1123/140427_D2nm_2720166.png" referrerpolicy="no-referrer"></p><p>曹某是该公司的软件工程师，他坦白称，<strong>去年 8 月发现公司网站后台的漏洞，用母亲和朋友身份证注册了两个 ETC 账户。</strong></p><p><strong>一年内两个账户分别从公司提取来了 230 余万元和 36 万元，总计 260 余万元。</strong>目前其因涉嫌盗窃罪已被依法刑事拘留，案件正在进一步审理中。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 06:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267760</guid>
            <link>https://www.oschina.net/news/267760</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[9 月国内手机市场出货量 3327.7 万部，5G 手机占比 86.3%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>中国信通院<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FhtODPwuYMGpG0LLkXScHqw" target="_blank">发布</a>了 2023 年 9 月国内手机市场运行分析报告，具体情况如下：</p><h4 style="margin-left:0px; margin-right:0px"><strong>一、国内手机市场总体情况</strong></h4><p style="margin-left:0; margin-right:0">2023 年 9 月，国内市场手机出货量 3327.7 万部，同比增长 59.0%，其中，5G 手机 2871.7 万部，同比增长 90.1%，占同期手机出货量的 86.3%。</p><p style="margin-left:0; margin-right:0">2023 年 1-9 月，国内市场手机总体出货量累计 2.0 亿部，同比增长 2.2%，其中，5G 手机出货量 1.62 亿部，同比增长 5.5%，占同期手机出货量的 80.7%。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="288" src="https://oscimg.oschina.net/oscnet/up-69c95e09317725c4f7ffc7ef79b2f4738ff.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>图 1&nbsp; 国内手机市场出货量及 5G 手机占比</strong></p><p style="margin-left:0; margin-right:0">2023 年 9 月，国内手机上市新机型 42 款，同比增长 23.5%，其中 5G 手机 20 款，同比增长 33.3%，占同期手机上市新机型数量的 47.6%。</p><p style="margin-left:0; margin-right:0">2023 年 1-9 月，上市新机型累计 335 款，同比增长 9.8%，其中 5G 手机 153 款，同比下降 1.9%，占同期手机上市新机型数量的 45.7%。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="294" src="https://oscimg.oschina.net/oscnet/up-c560fe8a7f746252f0eb067442a16f4a434.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>图 2&nbsp; 国内手机上市新机型数量及 5G 手机占比</strong></p><h4 style="margin-left:0px; margin-right:0px"><strong>二、国内手机市场国内外品牌构成</strong></h4><p style="margin-left:0; margin-right:0">2023 年 9 月，国产品牌手机出货量 2494.6 万部，同比增长 36.1%，占同期手机出货量的 75.0%；上市新机型 41 款，同比增长 36.7%，占同期手机上市新机型数量的 97.6%。</p><p style="margin-left:0; margin-right:0">2023 年 1-9 月，国产品牌手机出货量累计 1.63 亿部，同比下降 3.9%，占同期手机出货量的 81.4%；上市新机型累计 307 款，同比增长 10.4%，占同期手机上市新机型数量的 91.6%。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="229" src="https://oscimg.oschina.net/oscnet/up-f96594c4ab35fa2f58a6f38fc849910fae5.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>图 3&nbsp; 国产品牌手机出货量及占比</strong></p><h4 style="margin-left:0px; margin-right:0px"><strong>三、国内智能手机发展情况</strong></h4><p style="margin-left:0; margin-right:0">2023 年 9 月，智能手机出货量 3193.4 万部，同比增长 60.9%，占同期手机出货量的 96.0%。2023 年 1-9 月，智能手机出货量 1.92 亿部，同比增长 0.3%，占同期手机出货量的 95.6%。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="260" src="https://oscimg.oschina.net/oscnet/up-914d590bdbd5b0ede95fa2c8e1f6e33b3f8.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>图 4&nbsp; 国内智能手机出货量及占比</strong></p><p style="margin-left:0; margin-right:0">2023 年 9 月，智能手机上市新机型 32 款，同比增长 14.3%，占同期手机上市新机型数量的 76.2%。2023 年 1-9 月，智能手机上市新机型累计 279 款，同比增长 8.6%，占同期上市新机型数量的 83.3%。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 03:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267742</guid>
            <link>https://www.oschina.net/news/267742</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[长安汽车基于 Apache Doris 的车联网数据分析平台建设实践]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>导读：随着消费者更安全、更舒适、更便捷的驾驶体验需求不断增长，汽车智能化已成必然趋势。长安汽车智能化研究院作为长安汽车集团有限责任公司旗下的研发机构，专注于汽车智能化技术的创新与研究。为满足各业务部门的数据分析需求，长安汽车基于 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fdoris" target="_blank">Apache Doris</a> 升级了车联网数据分析平台，支撑单日百亿级别数据实时处理，并实现十亿级别数据查询秒级响应，为长安汽车在提升用户用车体验、实时预警车辆故障、保证车辆安全驾驶等方面带来显著成果，为其在智能化方向的技术创新提供了有力支持。</p><p>作者｜长安汽车智能化研究院</p></blockquote><p>智能化是汽车工业进程中的一场革命，它旨在利用大数据、人工智能、云计算、物联网等前沿数字技术，对汽车设备和系统的运行状态进行全方位的感知、分析、决策和控制，从而提高汽车的安全性、舒适性、便捷性和节能性。</p><p>长安汽车智能化研究院作为长安汽车集团有限责任公司旗下的研发机构，专注于汽车智能化技术的创新与研究，其愿景是通过持续创新和技术突破，实现汽车智能驾驶、智能网联和智能交通的全面发展，为消费者提供更安全、更便捷、更智能的出行体验，并致力于成为中国汽车智能化领域的领军企业。</p><p>实现汽车智能化的关键之一，是需要建立稳定、高效的数据平台，以承载和利用海量的车联网数据。作为智能化发展的重要支撑，长安汽车智能化研究院肩负着整个长安汽车集团车联网数据的汇聚、处理和应用工作。为满足各业务部门提出的数据支持需求，目前已经构建了车联网数据分析平台，并在业务指标分析、质量管理系统、智慧能耗、智能诊断、智慧运营等多个重点领域实现数据应用。</p><p>本文将详细介绍长安汽车车联网数据分析平台的演进历程及实践经验，<strong>分享长安汽车基于 Apache Doris 支撑单日百亿级别数据实时处理、实现十亿级别数据查询秒级响应的实践经验</strong>。此外，<strong>Apache Doris 的引入还为长安汽车在用户用车体验提升、驾驶安全保障等方面带来显著收益，为长安汽车从机电化到智能化转型发展提供有力支持</strong>。</p><h1>汽车智能化所面临的挑战</h1><p>近些年来，长安汽车取得了令人瞩目的销量增长成绩。1-8 月，长安汽车自主乘用车累计销量超百万辆、保持持续上升的发展势头，以深蓝、阿维塔、启源为代表的新能源系列品牌力和产品竞争力不断提升，自主新能源车累计销量约为 25.6 万辆、同比增长 102.44%，成为销量增长新动能。</p><p>在汽车销量快速攀升的背后，车联网数据更是呈现爆发式增长的态势，其中最为核心的即车辆 CAN 总线数据。CAN 即 Controller Area Network，通过 CAN 总线可以对车辆上的各类电子控制系统进行统一通信，在实际车辆运行过程中 ，CAN 总线数据是车辆安全性、可靠性和高性能的重要保证：</p><ul><li>车辆系统监测和控制：CAN 总线数据可用于监测和控制系统中的各种设备和组件。传感器通过 CAN 总线发送其测量值，如温度、压力、位置等，以便其他设备或控制器实时监测和采取相应的措施。同时，控制器可以通过 CAN 总线向执行器发送控制指令，如调节阀门、驱动电机等，以实现对系统的控制。</li><li>车辆信息实时反馈：CAN 总线数据可用于提供实时反馈信息。例如在车辆控制系统中，传感器通过 CAN 总线传输车速、转向角度、制动状态等数据，控制器可以根据这些数据进行实时决策和调整，以确保车辆的安全性和性能。</li><li>数据共享和协调：CAN 总线数据允许不同设备之间进行数据共享和协调。通过 CAN 总线，不同的控制器和设备可以交换信息，共享状态和控制命令，有利于提高系统的整体性能和效率。</li><li>网络管理和故障诊断：CAN 总线数据用于网络管理和故障诊断。通过 CAN 总线，可以进行设备的自动识别、配置和监控，以便进行网络管理和故障排查，提高系统的可靠性和可维护性。</li></ul><p><strong>随着网联车销量不断增长，车辆每天将产生千亿级别的 CAN 数据，清洗处理后的数据也在 50 亿级别</strong>，面对如此庞大且持续膨胀的数据规模，如何从海量数据中快速提取挖掘有价值的信息，为研发、生产、销售等部门提供数据支持，成为当前亟需解决的问题。</p><p>而想要提供良好的数据支持及服务，首先需要应对以下几大挑战：</p><ul><li><strong>大规模数据实时写入及处理</strong>：为实现智能化，汽车的车门、座椅、刹车灯设备被设置了大量的传感器，每个传感器收集一种或者多种信号数据，数据被汇聚后进一步加工处理。目前长安汽车需要支持至少 400 万辆车的链接，车联网数据每秒吞吐量已达百万级 TPS ，每日新增数据规模高达数十 TB ，且还在持续增长中。如何对数据进行实时写入成为了长安汽车首要面临的挑战。</li><li><strong>准确及时的实时数据分析需求</strong>：车联网场景下数据分析通常要求实时性，快速获取分析结果是实时监控、故障诊断、预警和实时决策等服务的重要保障。例如在智能诊断中，车企需要近实时地收集相关信号数据，并快速定位故障原因。通过分析车辆传感器数据、行驶记录等，可以提前发现潜在故障，进行预防性维护，提高车辆的可靠性和安全性。</li><li><strong>更加低廉的数据存储和计算成本</strong>：面对快速增长的的数据以及日益强烈的全量写入和计算需求，导致数据存储和计算成本不断攀升。这就要求数据平台具备低成本存储和计算的能力，以降低使用成本；同时需具备弹性伸缩能力，以便用户在业务高峰期快速扩容，提升海量数据计算场景的分析效率。</li></ul><p>为给用户提供更优质的驾车体验、为业务部门提供更准确高效的数据支持，长安汽车开始对大数据平台的建设进行探索和实践。</p><h1>Hive 离线数据仓库难以支撑超大规模实时数据服务</h1><p><img src="https://cdn.selectdb.com/static/Hive_17776ddfed.jpg" alt="长安汽车车联网-Hive 离线数仓.jpg" referrerpolicy="no-referrer"></p><p>长安汽车最早以 Hive 为核心构建了数据平台架构，所处理数据包括车辆 CAN 总线数据和埋点数据，这些数据通过 4G 网络从车端传送至长安云端网关，然后由网关将数据写入 Kafka。考虑到数据量级和存储空间的限制，早期架构中的数据处理流程是将 Kafka 采集到的数据直接通过 Flink 进行处理，并通过 ETL 将结果存储到 Hive 中。下游应用使用 Spark SQL 进行逐层离线计算，并通过 Sqoop 将汇总数据导出到 MySQL 中。最终由 Hive 和 MySQL 分别为应用层提供数据服务。</p><p>尽管该架构在早期基本满足了数据处理需求，但随着车辆销量不断增长，当需要面对每天千亿级别的数据处理分析工作时，架构的问题逐步暴露出来：</p><ul><li><strong>数据时效性无法保证</strong>：Hive 的导入速度较慢，尤其在处理大规模数据时，导入时间明显增加；同时部分业务依赖 T+1 离线任务，无法满足实时数据处理需求；此外， Hive 只支持分区覆盖，不支持主键级别的数据更新，无法满足特殊场景的数据更新需求。</li><li><strong>数据查询分析延迟较高</strong>：对于 10 亿级别以上大规模表查询，Hive 查询性能较慢。通过 SparkSQL 进行数仓分层运算时，启动和任务执行时间较长，对查询响应也会产生影响。此外，数据看板、BI 展示应用无法直接从 Hive 中查询，需要将 Hive 中数据导出到 MySQL 中，由 MySQL 提供服务，受限于 Hive 导数性能，当数据量较大时，导出到 MySQL 耗时大幅增加，进而导致查询响应时间变长。此外，通过 Java 后端查询 MySQL 时，数据量过大也会影响数据的响应时间。</li></ul><p>追根究底，产生这些问题的根本原因在于早期架构无法满足超大规模实时数据场景下的数据需求，这迫使长安汽车必须进行平台升级改造。</p><h1>技术调研与选型</h1><p>长安汽车经过深入调研，决定引入开源实时数据仓库 Apache Doris ，在导入性能、实时查询等方面具有显著优势：</p><ul><li><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.selectdb.com%2Fblog%2F106" target="_blank">丰富的数据导入方式</a></strong>：Doris 提供了丰富的内置导入方式，如 Broker Load 和 Stream Load 等，可以满足实时和离线场景中数据导入需求。</li><li><strong>支持实时查询分析</strong>：Doris 大表 Join 能力突出，提供了多种分布式 Join 方式，使 Join SQL 编写具备高度灵活性，极大提升数据分析的效率。此外，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.selectdb.com%2Fblog%2F56" target="_blank">Doris 支持单节点上万 QPS 的超高并发</a>，可解决早期架构由于前端并发量过大导致查询失败的问题。</li><li><strong>较低的使用成本</strong>：Doris 兼容 MySQL 协议，开发人员可以更高效便捷的使用 MySQL 编写和执行查询语句，有效提高开发效率。基于 Doris 极简的架构，不仅让部署运维更加简单，也让扩缩容操作变的更加方便弹性。同时，Doris 拥有良好的上下游生态，可为用户提供灵活高效的数据管理和分析体验。这些优势和特性都极大的降低了 Doris 的使用成本。</li></ul><p>除此以外，<strong>开源社区的活跃度也是我们考虑的重要因素之一</strong> 。Apache Doris 吸引了大量的开发者及用户参与社区，共同贡献代码和改进 Doris，这对质量和稳定性的提高起关键作用。同时，Doris 社区为用户提供了全面的文档资料和技术支持，任何问题都可以快速得到解答和帮助。Apache Doris 的活跃程度使我们在使用时更加放心，解决了技术方面的后顾之忧。</p><h1>基于 Apache Doris 车联网数据分析平台</h1><p><img src="https://cdn.selectdb.com/static/_50f5a17a88.jpg" alt="长安汽车车联网-车联网数据分析平台.jpg" referrerpolicy="no-referrer"></p><p>在新的车联网数据分析平台中，通过 Flink 结合 Doris 的 Stream Load 功能，可直接将 Kafka 数据实时写入 Doris，同时，利用 Doris Broker Load 功能可以将 Hive 中数据导入到 Doris 中进行分析计算。在这个架构中，Apache Doris 承担了实时数据部分的计算和处理，还作为结果端直接输出数据给上游业务平台调用。</p><p>这一升级在系统上缩短了数据处理的路径，保证了大规模数据导入的时效性。此外，Apache Doris 的引入为上游应用层提供统一数据服务支持，这对于查询分析效率的提升至关重要。具体收益如下：</p><ul><li>便捷进行数据写入和迁移：Doris 支持丰富的数据导入形式，可轻松从不同的数据源中导入数据。其次，Doris 支持通过 insert into select 快速导入数据，无需进行繁重的数据迁移配置以及引入外部同步组件。</li><li>统一数据服务，秒级查询响应：通过 Doris Multi-Catalog 功能，数据分析师可直接从 Doris 上查询数据，实现秒级别查询响应。其次，Doris Join 能力优异，对于超过 1000 万的结果表查询也可实现秒级返回结果。</li><li>降低存储和计算成本：在早期架构中，使用 Flink 实时写入数据并进行压缩时需要消耗大量的计算资源。而引入 Apache Doris 后，借助 Doris ZSTD 压缩算法（3-5 倍压缩率提升），可有效降低计算和存储所需的资源，还可以将压缩处理流程放到 Doris 内部进行，无需消耗 Flink 计算资源。</li></ul><h1>从 T+1 到 T+0，实时数据提升智能驾驶体验</h1><p>CAN 总线数据在车辆分析中扮演着关键的角色，通过 CAN 总线可以读取车辆的各种状态信息，例如车速、转速、水温等。这些数据对于分析车辆的行驶数据具有重要的价值，为整车研发单位提供宝贵的参考信息。</p><p>在早期架构中，车辆 CAN 数据是按照 CAN ID 作为维度进行上传的，而在实际使用中，通常需要将不同 CAN ID 的信号按照时间对齐形成一个宽表。过去的数仓架构解决方案会先将 Kafka 中的数据写入到 Hive，此时不同 CAN ID 的数据被存储在不同的行中，需要使用 SparkSQL T+1 将数据转换为几个不同业务域的宽表。然而，这种计算方式耗时较长，SQL 语句难以维护，且数据的实时性较差。</p><p>在引入 Apache Doris 之后，我们在 Doris 中基于 Aggregate 聚合模型建立了业务域的宽表，将车辆和时间等作为主键，其他的信号字段都用<code>REPLACE_IF_NOT_NULL</code>定义。具体如下：</p><p><img src="https://cdn.selectdb.com/static/_c3afa33c84.jpg" alt="长安汽车车联网-实时数据.jpg" referrerpolicy="no-referrer"></p><p>首先，可以使用 Flink 来消费 Kafka 中按 CAN ID 维度的数据，在 Flink 中根据业务域宽表的配置对数据进行分流，将同一个 CAN ID 上的信号分配到相应的业务域宽表中。当同一个车辆在同一时间内不同 CAN ID 的数据到达同一个业务域宽表时，可以将这些数据填充到同一行中的不同 CAN ID 的信号数据字段中，实现宽表的构建（如上图 Doris 的表示例）。</p><p>在这种方式中，主要通过 Flink 对数据进行分流，将数据发送到不同的 Doris 业务域宽表中（每个宽表约有 200 个字段）。宽表的生成逻辑被放在了 Doris 中，而不是在 Flink 中进行宽表对齐的操作。这样设计的原因是不同 CAN ID 的数据上传存在一定的时间差，时间窗口过大时，使用 Flink 根据车辆和时间进行聚合可能会导致资源开销过高。</p><p><strong>通过以上方案，可以将数据的新鲜度从 T+1 提高到 T+0 。同时，对于包含约 10 亿行数据的宽表，可以达到秒级的查询效率，即在进行单车查询时，可以快速地获取查询结果。</strong></p><h1>10 亿级别 DTC 故障码实时查询，保障车辆驾驶安全</h1><p>DTC 属于 CAN 数据中的故障报文，因此对其进行单独的业务数据存储。每天的 DTC 数据量级可以达到 10 亿条，为了让业务端便捷高效的使用这些数据，快速进行故障诊断，提升车辆安全性，需要将 DTC 故障码明细数据与一张 MySQL 业务配置表进行关联。</p><p>在早期架构中，开发人员每天都需要将海量 DTC 数据先写入到 Kafka 中，然后通过 Flink 进行实时处理，并将结果存储到 Hive 中。而这种处理方式存在一些问题：</p><ul><li>面对 10 亿级数据量的表，难以将其导入 MySQL 进行实时查询。如果直接查询 Hive，则查询反馈时间会非常长，难以满足业务需求。</li><li>由于无法直接关联 MySQL 的配置表，不得不定时将配置表导入 Hive 数仓。这样做虽然能够满足数据处理的需求，但却丢失了 DTC 配置的实时性。</li></ul><p><img src="https://cdn.selectdb.com/static/_98e4700c50.jpg" alt="长安汽车车联网-实时查询.jpg" referrerpolicy="no-referrer"></p><p>在引入 Apache Doris 后，采用上图所示处理方式成功解决了早期架构存在的问题。首先将 Hive 的 DTC 明细数据通过 HDFS 文件导入的方式导入到 Doris 中，然后创建对应的 MySQL Catalog 连接，最后使用后端 Java 通过 MyBatis 连接 Doris 数据库，并使用 SQL 通过 Catalog 连接 MySQL 的 DTC 配置表进行 Join 操作，可直接实时查询返回结果。</p><p>通过 Apache Doris 成功完成了 10 亿级别数据的实时查询，并且可以对关联的 MySQL 配置表进行直接关联查询，成功实现了<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.selectdb.com%2Fblog%2F31" target="_blank">配置的实时更新</a>。</p><h1>总结与规划</h1><p><strong>凭借 Apache Doris 卓越的性能，目前在长安汽车已经部署数十台机器，支撑了近十条业务线，每天处理数据规模达到百亿级别。</strong> Apache Doris 的引入为长安汽车在提升用户用车体验、实时预警车辆故障、保证车辆安全驾驶等方面带来显著成果，为其在智能化方向的技术创新提供了有力支持。</p><p>未来，长安汽车将进一步将 Apache Doris 应用在标签和指标业务，实现以下需求：</p><ul><li>自动识别冷热数据：将热数据存储在 Apache Doris 中，冷数据存储在 Hive 中，通过这种方式实现更高效的数据访问和管理。</li><li>扩大业务范围：对现有的 Doris 业务 SQL 代码进行优化，利用 Doris 的某些特性和功能，将适合这些特性的业务迁移到 Doris 中，从而提高数据处理和查询的效率。</li><li>共建社区：积极尝试使用 Doris 最新版本及新功能，在与社区保持同步的同时，不断探索和应用新的技术，反哺社区、为社区发展做出贡献。</li></ul><p>最后，衷心感谢 Apache Doris 社区和<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.selectdb.com%2F" target="_blank">飞轮科技技术团队</a>的积极支持，期待未来与大家继续深入合作，推动长安汽车智能化发展，为用户提供更好的驾车体验！</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 03:29:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5735652/blog/10143334</guid>
            <link>https://my.oschina.net/u/5735652/blog/10143334</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[博通宣布成功收购 VMware]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">博通（Broadcom）宣布已经获得<span style="background-color:#ffffff">收购所需的所有必要监管批准，成功</span>完成了对云计算公司 VMware 的收购。</span></p><p><span style="color:#000000">中国方面于 2023 年 11 月 21 日批准了该收购，不过附带了额外的限制性条件。声明明确指出，VMWare 的服务器软件应与本地硬件保持兼容，收购不得对客户购买和使用博通的硬件产品（包括存储适配器）施加限制。</span></p><p><span style="color:#000000"><img height="266" src="https://oscimg.oschina.net/oscnet/up-304e8a97c668a6833abc83fd09a46010735.png" width="700" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">收购完成后，该公司将致力于开发解决方案，帮助客户优化其私有云、混合云和多云环境，并从任何地方运行应用程序和服务。公告表示，博通未来的工作重点将聚焦在帮助企业客户创建并现代化其私有云和混合云环境。</span></p><p><span style="color:#000000">该公司计划投资 VMware Cloud Foundation，<span style="background-color:#ffffff">这是一个作为私有云和混合云基础的软件堆栈。</span>作为收购的一部分，VMware 将在 VMware Cloud Foundation 之上提供一系列服务。</span></p><p><span style="color:#000000">博通针对 VMware Tanzu 的计划是通过加速跨各种云环境的应用程序开发、交付和管理来增强客户的业务敏捷性。该解决方案适用于 VMware Cloud Foundation 和主要的超大规模提供商，为 Spring 等应用程序开发框架提供优化。Tanzu 提高了开发人员的工作效率，同时使平台团队能够执行标准、维护安全性和跟踪性能。</span></p><p><span style="color:#000000">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.broadcom.com%2Fblog%2Fbroadcom-announces-successful-acquisition-of-vmware" target="_blank">查看官方公告</a>。</span></p><p><strong><span style="color:#000000">相关阅读：</span></strong></p><ul><li><a href="https://www.oschina.net/news/197527/broadcom-vmware-61-billion" target="_blank">博通拟以 610 亿美元收购 VMware</a></li><li><a href="https://www.oschina.net/news/249166/eu-approves-broadcom-vmware-acquisition" target="news">博通 610 亿美元收购 VMware 已获欧盟委员会批准</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 03:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267737/broadcom-successful-acquisition-of-vmware</guid>
            <link>https://www.oschina.net/news/267737/broadcom-successful-acquisition-of-vmware</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[PHP 8.3 GA]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>PHP 8.3 <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.php.net%2Freleases%2F8.3%2Fzh.php" target="_blank">已正式发布</a></u>。主要变化包括：</p><ul><li>类常量显式类型 (Typed class constants)</li><li>只读属性深拷贝</li><li>新增<code>#[\Override]</code>属性</li><li>新增<code>json_validate()</code>函数</li><li>添加<code>Randomizer::getBytesFromString()</code>方法</li><li>添加<code>Randomizer::getFloat()</code>和<code>Randomizer::nextFloat()</code>方法</li><li>以及更好的性能、更好的语法、改进类型安全</li></ul><p><img height="1114" src="https://static.oschina.net/uploads/space/2023/1123/110607_AwYL_2720166.png" width="2552" referrerpolicy="no-referrer"></p><p>下面介绍部分语法的变化。</p><ul><li><strong>类型化类常量</strong></li></ul><p>PHP &lt; 8.3</p><pre><code class="language-php">interface I {
    // We may naively assume that the PHP constant is always a string.
    const PHP = 'PHP 8.2';
}

class Foo implements I {
    // But implementing classes may define it as an array.
    const PHP = [];
}</code></pre><p>PHP 8.3</p><pre><code class="language-php">interface I {
    const string PHP = 'PHP 8.3';
}

class Foo implements I {
    const string PHP = [];
}

// Fatal error: Cannot use array as value for class constant
// Foo::PHP of type string</code></pre><ul><li><strong>动态获取类常量</strong></li></ul><p>PHP &lt; 8.3</p><pre><code class="language-php">class Foo {
    const PHP = 'PHP 8.2';
}

$searchableConstant = 'PHP';

var_dump(constant(Foo::class . "::{$searchableConstant}"));</code></pre><p>PHP 8.3</p><pre><code class="language-php">class Foo {
    const PHP = 'PHP 8.3';
}

$searchableConstant = 'PHP';

var_dump(Foo::{$searchableConstant});</code></pre><ul><li><strong>只读属性深拷贝</strong></li></ul><p><code>readonly</code>属性现在可以在魔术方法<code>__clone</code>中被修改一次，以此实现只读属性的深拷贝。</p><p>PHP &lt; 8.3</p><pre><code class="language-php">class PHP {
    public string $version = '8.2';
}

readonly class Foo {
    public function __construct(
        public PHP $php
    ) {}

    public function __clone(): void {
        $this-&gt;php = clone $this-&gt;php;
    }
}

$instance = new Foo(new PHP());
$cloned = clone $instance;

// Fatal error: Cannot modify readonly property Foo::$php</code></pre><p>PHP 8.3</p><pre><code class="language-php">class PHP {
    public string $version = '8.2';
}

readonly class Foo {
    public function __construct(
        public PHP $php
    ) {}

    public function __clone(): void {
        $this-&gt;php = clone $this-&gt;php;
    }
}

$instance = new Foo(new PHP());
$cloned = clone $instance;

$cloned-&gt;php-&gt;version = '8.3';</code></pre><ul><li><strong>新增<code>#[\Override]</code>属性</strong></li></ul><p>通过给方法添加<code>#[\Override]</code>属性，PHP 将确保在父类或实现的接口中存在同名的方法。<br> 添加该属性表示明确说明复盖父方法是有意为之，并且简化了重构过程，因为删除被覆盖的父方法将被检测出来。</p><p>PHP &lt; 8.3</p><pre><code class="language-php">use PHPUnit\Framework\TestCase;

final class MyTest extends TestCase {
    protected $logFile;

    protected function setUp(): void {
        $this-&gt;logFile = fopen('/tmp/logfile', 'w');
    }

    protected function taerDown(): void {
        fclose($this-&gt;logFile);
        unlink('/tmp/logfile');
    }
}

// The log file will never be removed, because the
// method name was mistyped (taerDown vs tearDown).</code></pre><p>PHP 8.3</p><pre><code class="language-php">use PHPUnit\Framework\TestCase;

final class MyTest extends TestCase {
    protected $logFile;

    protected function setUp(): void {
        $this-&gt;logFile = fopen('/tmp/logfile', 'w');
    }

    #[\Override]
    protected function taerDown(): void {
        fclose($this-&gt;logFile);
        unlink('/tmp/logfile');
    }
}

// Fatal error: MyTest::taerDown() has #[\Override] attribute,
// but no matching parent method exists</code></pre><ul><li><strong>新增<code>json_validate()</code>函数</strong></li></ul><p><code>json_validate()</code>可以检查一个字符串是否为语法正确的 JSON，比<code>json_decode()</code>更有效。</p><p>PHP &lt; 8.3</p><pre><code class="language-php">function json_validate(string $string): bool {
    json_decode($string);

    return json_last_error() === JSON_ERROR_NONE;
}

var_dump(json_validate('{ "test": { "foo": "bar" } }')); // true</code></pre><p>PHP 8.3</p><pre><code class="language-php">var_dump(json_validate('{ "test": { "foo": "bar" } }')); // true</code></pre><hr><p>此外，PHP 8.0 的生命周期即将结束。早在 2022 年 11 月 26 日，PHP 8.0 结束了积极支持，而安全支持也将在 PHP 8.3 正式发布三天后——2023 年 11 月 26 日停止。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267734/php-8-3-ga</guid>
            <link>https://www.oschina.net/news/267734/php-8-3-ga</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Node.js v20.10.0 (LTS)]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Node.js v20.10.0 已正式发布，代号 'Iron'。根据发布时间表，由于上月&nbsp;Node.js 21 已正式发布，因此&nbsp;Node.js 20 就变成了长期支持版本 (LTS)。</p><p><strong>新版本主要变化</strong></p><ul><li><strong>引入新的<code>--experimental-default-type</code>flag，用于改变 Node.js 的默认 module</strong><br> 通过设置 <strong><code>--experimental-default-type=module</code></strong>，可以将原本隐式的 CommonJS 模块解释为 ES 模块。</li><li><strong>引入新的<code>--experimental-detect-module</code>flag</strong>，用于检测 JavaScript 中不明确的 ESM 语法<br> 该 flag 用来自动检测 ES 模块的语法。对于「模棱两可」的文件，Node.js 会解析文件以检测是否包含 ES 模块语法，如果检测到，则将其作为 ES 模块运行，否则将其作为 CommonJS 模块运行。</li><li><strong>为文件系统函数引入新的&nbsp;<code>flush</code>&nbsp;选项</strong><br> 在写入文件时，可能会出现数据不立即刷新到永久存储的情况。为了解决这个问题，fs.writeFile 系列函数新增了 flush 选项，可以在成功写入操作结束时强制刷新数据。</li><li><strong>新增实验性的 WebSocket 客户端</strong><br> 使用&nbsp;<strong><code>--experimental-websocket</code></strong>&nbsp;flag，可以添加一个全局的 WebSocket 对象，符合 WHATWG 的标准。</li><li>修复 vm.Script 的 V8 编译缓存支持</li></ul><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnodejs.org%2Fen%2Fblog%2Frelease%2Fv20.10.0" target="_blank">详情查看发布公告</a></u>。</p><p>延伸阅读：<u><em><a href="https://www.oschina.net/news/262268/nodejs-v21-release-released" target="news">Node.js 21 正式发布</a></em></u></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 23 Nov 2023 02:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267730/nodejs-v20-10-0-lts</guid>
            <link>https://www.oschina.net/news/267730/nodejs-v20-10-0-lts</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux 6.8 将更新 Zstd 代码以获得更好的压缩性能]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FZstd-1.5.5-Patches-Linux-Kernel" target="_blank">根据 Phoronix 的报道</a></u>，Linux 6.8 内核计划在明年升级其 Zstd 代码，以提供更好的压缩性能。</p><p>在 Linux 6.2 中，内核的 Zstd 压缩/解压缩代码已经根据 Zstd 1.5 的最新状态进行了更新。而在 Linux 6.8 内核中，计划升级到 Zstd 1.5.5 版本，这将提供更好的压缩性能。</p><p>这次 Zstd 升级对 Linux 内核的动力之一是英特尔希望在 Linux 内核中使用更新的 Zstd 版本，因为它公开了 Zstd 的外部匹配提供程序 API，从而允许 QuickAssist 技术（QAT）加速 LZ 匹配查找阶段。这对于那些拥有 QAT 硬件或将 QAT 加速集成到 Xeon Sapphire Rapids 和即将推出的 Emerald Rapids 处理器的用户来说是个好消息。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b673c0555866551114bd2e08b4c9c512046.png" referrerpolicy="no-referrer"></p><p>除了满足英特尔的需求之外，内核中更新的 Zstd 代码经过测试，发现在写入+压缩时间上可以减少约 6%。然而，读取+解压缩时间略有增加。Zstd 1.5.5 本身是在今年 4 月发布的，其中包含了一些性能改进、修复和其他变更。</p><p>目前可以在邮件列表的补丁中找到适用于 Linux 内核的 Zstd 1.5.5 版本，内核维护者计划在 Linux 6.8 合并窗口提交这项工作。</p><p>这次 Zstd 代码的升级将为 Linux 内核带来更好的压缩性能，这对于文件系统驱动程序的透明文件系统压缩/解压缩、将各种内核资源压缩为 Zstd 格式等方面都是有益的。</p><p>详情查看&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Flkml%2F20231121010318.524570-1-nickrterrell%40gmail.com%2FT%2F%23m693429838032e235560212b8339b315dcaa02460" target="_blank">https://lore.kernel.org/lkml/</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 10:22:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267826/zstd-1-5-5-patches-linux-kernel</guid>
            <link>https://www.oschina.net/news/267826/zstd-1-5-5-patches-linux-kernel</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 如何做好架构设计，架构设计有章可循吗？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><em><span>设计一个系统的过程，就是建造一座大厦的过程，架构设计的质量直接决定了大厦的质量。</span></em></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在我们进行系统的架构设计时，总是会遇到一系列的问题，比如一个大型系统的架构应该如何起步，从哪里开始设计？系统是否应该划分成多个模块，应该怎么划分模块才更加的合理？亦或是觉得产品提出的需求非常不合理，完全影响我们正常的架构设计！对于非功能性的需求，我们是否可以得过且过，不去重视？</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>这些问题，让我们在刚开始架构设计时手足无措，但是随着我们完成一个又一个的系统架构设计以后，发现架构设计是有章法可循的，只要我们学习这些章法和套路，并且在工作过程中不断的积累与沉淀，就会行成一个完整的架构设计方法论，面对新的大型系统架构设计，也会一步一步有节奏进行，最终完成整体的架构设计。</span></span></span></p><span id="OSC_h1_1"></span><h1><span><span><span style="background-color:#b7eb8f">架构设计的原则</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>架构设计需要遵循一些原则：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span style="color:black">1、架构设计需要方法体系</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>架构设计并不是一个」单一的方法「，直接拿来进行架构设计，而是多个各具特色的方法，组成的「方法体系」，并且这个体系随着新技术的发展还会不断进化。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span style="color:black">2、架构设计是质疑驱动</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>架构设计是质疑驱动的过程，在」需求驱动「的基础上，我们需要不断的质疑我们架构设计的中间成果，进一步通过「质疑」，引入更多的「质量属性」及更多「功能场景」。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span style="color:black">3、多阶段下的多视图</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>架构设计，是多阶段还是多视图？架构设计首先是「多阶段的」，我们将架构设计划分成多个阶段，在每个阶段中才会考虑」视图「这个维度。</span></span></span></p><span id="OSC_h3_2"></span><h3><span><span><em><span>架构设计的三个阶段</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>阶段一、 预备阶段</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>预备阶段的目标：全面理解需求，把握需求特点，确定架构设计驱动力。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在预备阶段，我们需要全面的梳理与理解需求，不放过任何一个需求细节。同时分析需求产生的各项质量属性与系统约束，同时兼顾这些约束进行架构设计，才能不遗漏重大的架构属性。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>阶段二、 概念架构</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>概念架构，必须考虑包括</span></span></span><span><span><strong><span>功能</span></strong></span></span><span><span><strong><span>，</span></strong></span></span><span><span><strong><span>质量</span></strong></span></span><span><span><strong><span>，</span></strong></span></span><span><span><strong><span>约束</span></strong></span></span><span><span><span>在内的所有方面的需求。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>阶段三、 细化架构</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在细化架构阶段，我们从五个不同的角度出发，设计五个视图，完成整个系统全方位的设计。</span></span></span></p><span id="OSC_h3_3"></span><h3><span><span><em><span>架构设计的一个贯穿环节</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><strong><span>对非功能需求的考虑</span></strong></span></span><span><span><span style="color:black">：</span></span></span><span><span><span>非功能需求无法一蹴而就，因为在设计的过程当中，会有新的需求不断的被发现，即使设计完成，在开发阶段，都会有影响非功能需求的约束出现，所以在整个阶段，都应该注意非功能需求。</span></span></span></p><span id="OSC_h1_4"></span><h1><span><span><span style="background-color:#b7eb8f">预备架构阶段分析</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><em><span>预备架构的最重要的目标，是建立需求大局观，把握需求特点，确定架构设计驱动力。通过对需求的详细分析，有一个宏观的需求感知，同时还要兼顾系统的质量要求和约束对系统设计造成的制约条件。</span></em></span></span></p><span id="OSC_h3_5"></span><h3><span><span><em><span>需求结构化</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>需求是有结构的，而不是零散的需求点，只有将分析后的需求结构化，才能宏观的感知整个需求。可以借助 ADMEMS 二维矩阵，将架构影响因素，梳理脉络。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如以下矩阵分析，将需求划分为多个维度，横向上从」广义功能「」，质量「」，约束「三个方面分析，广义功能是指需求需要满足的基本功能，及产品或业务人员的直接要求。质量维度则是系统设计时需要考虑的高并发，高可用，可拓展等技术设计维护，保证系统在满足基本需求的同时，同时对后续系统进化发展以及极端场景（例如：用户量激增，秒杀）等的满足。约束则是系统设计时的一些制约，例如上线日期，上线环境，开发人员技能水平等。纵向上划分为」业务级需求「」，用户级需求「」，开发级需求「三个维护」，业务级需求「是指产品或业务人员提出的基本要求」，用户级需求「则是从系统的使用用户角度出发，发现的例如用户电脑操作水平，用户使用习惯等潜在需求，而」开发级需求「，则是从研发人员角度出发，发现的例如可拓展，可测试，技术环境等不同维度的需求。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>通过将需求结构化，我们可以全面的分析整体的需求，对需求进行整体的理解，同时也可以从不同的角度发现系统制约条件，在系统设计的最开始阶段就着手设计，防止遗漏重大约束导致架构设计失败。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-21F216gXpb11EiRfhbt.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h3_6"></span><h3><span><span><em><span>分析约束影响</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>约束分析的几个方面：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 来自产品或运营人员的约束性需求</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>系统的非功能需求，例如：上线时间，预算，工期要求等</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>业务领域相关的限制，例如业务规则或业务限制，相关法律，专利等。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 来自</span></span></span><span><span><strong><span>用户</span></strong></span></span><span><span><span>的约束性需求</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>系统的用户，同样会产生约束性需求，比如用户的计算机水平，年龄段，使用偏好，国家等。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如用户计算机水平整体较弱的话，在开发交互方式时就不应太过复杂，同时要兼顾系统的鲁棒性，防止系统被用户搞挂。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>用户使用产品时的外部环境同样可能产生约束条件，比如访问环境是内网或是外网，则决定了系统提供访问链接不同的网络权限。访问环境信号强度若，则系统的性能要求则更高。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、 来自</span></span></span><span><span><strong><span>开发或运维人员</span></strong></span></span><span><span><span>的约束性需求</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>开发团队的技术水平，磨合程度，同样制约着系统的开发，如果开发人员均是高级研发人员且对当前技术栈有深入的了解，则开发进度就会更快，如果是新团队，且需要对技术栈进行学习才可以介入开发，则在工期或系统风险层面需要额外考虑。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>4、 业界</span></span></span><span><span><strong><span>当前技术环境</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>当前技术环境中间件的成熟程度，编程语言及流行度，优缺点等，都会对架构设计产生约束条件。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>约束的分类：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 直接约束</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如：系统运行于 linux 平台。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 转换为功能需求的约束</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于这种约束，可以直接转换为功能需求</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如：供应商拥有自己的一套城市信息表 -&gt; 引出的功能需求：需要进行城市转换</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如：供应商服务器性能差，tps 最大 10 -&gt; 引出的功能需求：需要进行限流请求</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、 转换为质量属性需求的约束</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如：系统使用者计算机水平不高</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>转换为质量属性：易用性（否则不会用），鲁棒性（系统被搞瘫）</span></span></span></p><span id="OSC_h3_7"></span><h3><span><span><em><span>确定关键质量</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><em><span>系统的关键质量是需要进行取舍的，需要确认业务人员更注重那方面或在满足需求的基础上，确定哪些是必须的，哪些是可以适当忽略的。</span></em></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>我们需要首先确定架构重点支持哪些质量属性，然后对于相互矛盾的质量属性，进行权衡折中。例如当满足性能这个质量属性时，同时就会因为引入新的方案或组件，导致可维护性，可测试性降低；提高可拓展性时，就会对系统的性能和安全性产生影响等等，我们需要做的，就是在各个关键质量中进行取舍。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-22LELMr9d22zFXatK50.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span></p><span id="OSC_h3_8"></span><h3><span><span><em><span>确定关键功能</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>确定关键功能的 4 个方面</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 核心功能</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 必做功能</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、 高风险功能</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>4、 独特功能</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>其他常见系统不存在的功能</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><strong><span>注意衍生需求：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>从需求转入设计时，因方案制定过程的复杂，会产生大量的衍生需求，衍生需求是原始需求的数倍。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><em><span>举例：</span></em></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>原始需求：定时拉取供应商数据。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>衍生需求：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 由于供应商数量较多，需要引入分布式定时任务，集群并发拉取</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 由于供应商数据量大，需要分库分表设计</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、需要快速搜索，引入存储引擎组件等等</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-24DBopViOOSWkb7SO.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span>这些衍生需求我们必须要考虑，虽然业务需求没有体现，但缺失架构设计的关键影响因素。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>架构驱动力对比：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>业务需求驱动架构：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-25pbrXAR24YnLHpXB21.png" width="284" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span>重大需求驱动架构：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-2511lKgKmtlkleQWxu.png" width="284" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span>由此可以看出，通过重大需求驱动的架构，更能考虑到更关键的部分，设计的架构更能满足需求的要求，架构设计成功的概率会更高。</span></span></span></p><span id="OSC_h1_9"></span><h1><span><span><span style="background-color:#b7eb8f">概念架构阶段分析</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><em><span>概念架构阶段，对系统进行适当的分解，而不陷入细节</span></em></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>概念架构的过程是，先根据关键功能进行初步设计，然后对设计的系统进行高层分割，接下来考虑非功能性需求（关键质量和约束），然后修改自己的初步设计，循环往复，在不断的质疑和优化过程中，完善架构设计。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-26T7A52xvPwdCSGT7q.png" width="474" referrerpolicy="no-referrer"></div><p>&nbsp;</p><span id="OSC_h3_10"></span><h3><span><span><em><span>初步设计</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>初步设计的目标是发现职责，无需展开细节设计。基于关键功能，进行初步设计，</span></span></span><span><span><strong><span>基于主流程，关键流程，黄金流程等进行流转图设计，从而发现职责。</span></strong></span></span></p><span id="OSC_h3_11"></span><h3><span><span><em><span>高层分割</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>切分复杂系统，为多个二级系统。或者直接切分为具体子系统。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>高层分割的两种方式：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 系统切分</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>切分的考虑点，包括系统功能、部署环境、语言、系统规模等</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>例如一个大型系统，切分为订单，商品，供应链等系统。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 系统内切分</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>根据系统的职责、调用关系、通用性等，进行系统内部切分。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>最常见的就是分层，例如一个系统，切分为网关层，服务层，搜索模块，man 端等。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>分层的角度</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 逻辑分层</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>逻辑分层重视职责的划分，职责直接常常是上层使用下层的关系，上层和下层，可以是分布在不同的机器，也可以分布在同一台机器。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 物理分层</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>分布在不同机器上的软件单元。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、 通用性分层</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>通用性不同的，划分为不同的层，一般通用性越大，所处的层次越靠下。</span></span></span></p><span id="OSC_h3_12"></span><h3><span><span><em><span>考虑非功能需求</span></em></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>具体方法是：采用</span></span></span><span><span><strong><span>目标-场景-决策表</span></strong></span></span><span><span><span>，见下图：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>架构设计是质疑驱动的，例如，质疑系统的可用性，考虑系统可能宕机，则引入集群部署设计，考虑下游接口可能超时或出现异常，则引入接口降级的设计等。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-30khnlGt6Qe939QO21.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span>考虑场景的 5 个要素</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 影响来源，来自系统内部还是系统外部</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 如何影响的</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、 受影响的对象</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>4、 有什么问题或有什么价值</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>5、 所处的环境为何</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>对场景的权衡因素：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>价值，代价，开发难度，出现几率。对于某些场景，经过全面的权衡和思考，可以不支持，并不是所有的场景都要支持，否则可能存在过度设计。</span></span></span></p><span id="OSC_h1_13"></span><h1><span><span><span style="background-color:#b7eb8f">细化架构阶段分析</span></span></span></h1><span id="OSC_h3_14"></span><h3><span><span><span style="color:black">逻辑视图</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>逻辑视图是对系统的不同部分</span></span></span><span><span><strong><span>职责</span></strong></span></span><span><span><span>的划分，根据职责不同，可以将系统进行细粒度的拆分，划分为多个子系统。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span style="background-color:#87e8de">分层的细化</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>根据系统设计的需要，可以将系统的分层进行细化，例如展示层 -&gt; 业务层 -&gt; 数据层，可以细化为：展示层 -&gt; 控制层 -&gt; 接口层 -&gt; 接口实现层 -&gt; 数据层。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-32iq0B11mN3f32twUqC.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span style="background-color:#87e8de">分区的引入</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>分区的概念是业务流程相关的，分区的依据是：</span></span></span><span><span><strong><span>职责</span></strong></span></span><span><span><span>，比如结算流程可以作为一个分区，下单流程可以作为一个分区。将系统划分为多个分区，一方面可以支持并行开发，另一方面也将系统划分为多个子域，有利于业务概念和业务流程的收敛。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-33tPJdWeJMDcvCT5c.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span style="background-color:#87e8de">机制的提取</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>机制是指系统可以抽象的公共部分，例如公共工具，公共组件，公共流程等，提取这些公共部分，对于架构设计是至关重要的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>划分子系统的原则：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1、 职责不同的单元，划分为不同的子系统</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2、 通用性不同的单元，划分为不同的子系统</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3、 需要不同开发技能的单元，划分为不同的子系统兼顾工作量，进一步切分太大的系统</span></span></span></p><span id="OSC_h3_15"></span><h3><span><span><span style="color:black">开发视图</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>开发架构视图的任务，是将「逻辑职责」映射为「程序单元」，例如：要自主编写的「源程序」，可重用的库，框架等；同时进行开发技术选型，例如：开发语言，开发工具等，然后也需要确立程序单元间的关系，project 划分，目录结构，编译依赖关系等。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-37jm117lDma8m21KTOo.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span></span></span></span></p><span id="OSC_h3_16"></span><h3><span><span><span>运行视图</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>运行架构设计的工作内容，是确定引入哪些控制流：进程，线程等；确定每条控制流的任务，同时还要处理相关问题，例如控制流的创建，销毁，通信机制等，控制流之间的同步关系，是否有资源争用，是否需要加锁等也需要考虑。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-37xeumJqiBEAkn0Su.png" width="284" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h3_17"></span><h3><span><span><span>物理视图</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>物理架构设计的 3 项任务</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1. 硬件的选择与物理拓扑</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2. 软件到硬件的映射关系</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3. 方案的优化</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>思维要点：「开销」和「争用」是核心，应避免争用，降低开销。</span></span></span></p><span id="OSC_h3_18"></span><h3><span><span><span>数据视图</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>数据视图是系统的数据存储设计，根据对系统的分析，确定一种或多种数据策略，常见的数据分布策略如下 6 种：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>1、独立的 Schema</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>不同系统应用，使用不同的数据 schema，数据完全独立，一般界限清晰的不同系统可以采用这种方式。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-38IAcR6ctu568BXqUB.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span style="color:black">2</span></span></span><span><span><span style="color:black">、集中</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span style="color:black">不同的系统应用，使用同一个数据库，一般具有关联属性的应用可以采用这种方式，比如一个系统分为服务端和管理端，但都属于一个系统，则可以使用同一个数据库。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-39lOCEP39j21zaVHggv.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span style="color:black">3</span></span></span><span><span><span style="color:black">、分区</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>水平分区</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>水平分区即我们常见的分表方案，当一个 schema 无法满足我们的数据量要求时，可以划分为多个分区，每个分区存储一部分数据。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-396Zrt9eYBraZnGV0.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span style="color:black">垂直分区</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span style="color:black">垂直分区是分区策略的另外一个维度，当我们单库无法承载巨大的数据量时，也可以根据数据的类别，进行垂直分区。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-40EKfhbfQ13Rmif3x.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>4、复制</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span style="color:black">多个数据库保存相同的数据，根据制定的更新策略保证不同库之间的数据同步，</span></span></span><span><span><span>我们常用的读写库分离，即为此方案，主库提供写能力，从库提供读能力，其中从库的数据是根据主库数据同步而来。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-40LnrTouVj21EUvpx0.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span>5、子集</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>根据一些特殊的场景要求，需要保存原数据的部分数据，例如 application1 保存全量订单，application2 只需要部分出票成功的订单，进行后续分析操作，则可以使用子集的策略进行数据视图设计。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-40Moxg9UObMUth8l9.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span><span><span><span>6、重组</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span style="color:black">通过多个不同的 application 作为数据来源，异构至其他 application，用于数据的分析或后续流程使用。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2022-11-21-15-41RIaqyVykQOqcxwX.png" width="474" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span></p><span id="OSC_h1_19"></span><h1><span><span><span>总结</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>架构设计的三个阶段：预备架构阶段；概念架构阶段；细化架构阶段</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>架构设计的四个要素：需求结构化；分析约束的影响；确定关键质量；确定关键功能</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>概念架构的三个步骤：基于关键功能初步设计；系统高层分割；分析非功能需求</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>细化架构的五个视图：逻辑视图；开发视图；运行视图；物理视图；数据视图</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>一个贯穿环节：非功能需求的考虑</span></span></span></p><span id="OSC_h3_20"></span><h3><span><span><span>参考资料</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1.《一线架构设计指南》</span></span></span></p><blockquote><p>作者：京东零售&nbsp;冯晓涛</p><p>来源：京东云开发者社区，转载请注明来源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 07:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10149764</guid>
            <link>https://my.oschina.net/u/4090830/blog/10149764</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[特斯拉「完全开源」初代 Roadster 设计和工程]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">埃隆·马斯克 (Elon Musk)<span>&nbsp;在社交平台发文<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Felonmusk%2Fstatus%2F1727392569238159491" target="_blank">宣布</a>，已将</span></span><span style="background-color:#ffffff; color:#222222">特斯拉 (Tesla) 初代 Roadster 跑车的设计和工程细节「完全开源」，并发布了所有人都可以访问的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fservice.tesla.com%2Froadster" target="_blank">研发文件</a>。</span></p><blockquote><p><span style="color:#000000">「我们拥有的一切，现在你也拥有。」</span></p></blockquote><p><img height="312" src="https://oscimg.oschina.net/oscnet/up-34c1eef102f415f2e8a40190a16e4475a65.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">所披露的研发文件下方声明指出：</span></span></p><blockquote><div><span style="color:#000000">此处提供的信息是为了向 Roadster 爱好者提供的，是在 Roadster 的研发设计阶段创建的。它不是制造商的参考资料或维修保养材料，可能无法准确反映实际生产的车型或销售的部件。如果您使用这些信息，您有责任确保遵守所有法律和安全协议，因为无论您是否使用此处提供的信息，我们都不对非特斯拉人员所做的任何工作提供任何保证。您还需了解，如果您根据此信息制造或设计零件或创建新的维修或程序，我们将不对它们负责，并且它们不是正品 Tesla 零件或配件或 Tesla 批准的程序。</span>&nbsp;
 </div></blockquote><p><span style="color:#000000"><span style="background-color:#ffffff">开源 Roadster 蓝图和技术细节的决定，被<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fteslanorth.com%2F2023%2F11%2F22%2Ftesla-opens-up-original-roadster-design-and-engineering-to-public%2F" target="_blank">视为</a>特斯拉促进电动汽车行业创新与合作的战略步骤。此举允许世界各地的个人、公司和研究人员访问、研究特斯拉首款电动跑车所采用的技术，并在此基础上进行开发。「这标志着特斯拉对其专有技术的态度发生了重大转变。」</span></span></p><p><span style="color:#000000">特斯拉初代 <span style="background-color:#ffffff">Roadster&nbsp;</span>于 2008 年推出，是电动汽车行业的里程碑式车型。它是第一辆在高速公路上合法使用锂离子电池的纯电动汽车，也是<span style="background-color:#ffffff">第一款</span>每次充电行驶里程超过 200 英里的电动汽车。</span></p><p><span style="color:#000000">但是特斯拉<span style="background-color:#ffffff">初代 Roadster 当时只生产了 2000 多辆，且已经有十多年没有进行量产。特斯拉</span><span style="background-color:#ffffff">新一代的 Roadster&nbsp;曾在 </span><span style="background-color:#ffffff">2017 年 11 月的</span><span style="background-color:#ffffff">一场活动中亮相，但在经历了多次推迟之后，至今仍未正式推出。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 06:56:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267767/roadster-open-source</guid>
            <link>https://www.oschina.net/news/267767/roadster-open-source</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[俄罗斯操作系统 ALT Linux 支持龙芯处理器 (LoongArch)]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>根据俄媒 CNews 的<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnews.ru%2Fnews%2Ftop%2F2023-11-16_rossiyane_vpervye_nauchili" target="_blank">报道</a></u>，ALT Linux 操作系统已经正式添加对龙芯处理器的适配，支持龙芯 3A5000、龙芯 3A6000 等 CPU。得益于龙芯 CPU 出口限制已经被解除，<strong>俄罗斯相关部门可以采购这些 CPU 来替代 AMD 和英特尔的产品</strong>。</p><p><img src="https://static.oschina.net/uploads/space/2023/1123/113827_V5RM_2720166.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b019b0af83f74abe941843b40680ea69e8a.png" referrerpolicy="no-referrer"></p><p>ALT Linux 由俄罗斯公司 Basalt SPO 开发，其桌面环境基于 KDE Plasma 及 Xfce 构建，设计风格和 Windows 类似。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6090cfdcee56fe3b264b7d1c10ce5b543eb.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-5842fd873798b6510a44b29f117b94c0961.png" referrerpolicy="no-referrer"></p><p>报道称，Basalt SPO 的开发团队非常高效，只花了 9 个月时间，就将 ALT Linux 移植到了龙芯 LoongArch 架构。</p><p>Basalt SPO 表示，目前支持龙芯的 ALT Linux 已开始提供不稳定的测试分支，<strong>预计稳定的 11.0 正式版将在明年第一季度发布，采用 Xfce 桌面环境</strong>。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 22 Nov 2023 03:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/267741/russia-alt-os-linux-loongson-loongarch</guid>
            <link>https://www.oschina.net/news/267741/russia-alt-os-linux-loongson-loongarch</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
