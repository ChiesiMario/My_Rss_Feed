<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-最新资讯]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-最新资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 02 Jan 2024 05:37:36 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Fish Shell 3.7 发布，功能强大的命令行 Shell]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Fish Shell 3.7 已正式<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffish-shell%2Ffish-shell%2Freleases%2Ftag%2F3.7.0" target="_blank">发布</a></u>，其开发团队称<u><a href="https://www.oschina.net/news/226616/fish-shell-be-rewritten-rust">采用 Rust 重写</a></u>的工作仍在进行中，因此该版本仍然基于 C++ 编写——不过也将是采用 C++ 编写的最后分支版本。</p><blockquote><p><em><strong>Fish 3.7.0 和 3.7 系列的未来子版本均采用 C++</strong>。</em></p></blockquote><p>fish 是适用于 Linux、macOS 的命令行 Shell，其名字取于 "the<strong>f</strong>riendly<strong>i</strong>nteractive<strong>sh</strong>ell" 的简称，最大特点就是方便易用、功能强大、智能并且用户友好。很多其他 Shell 需要配置才有的功能，fish 默认提供，不需要任何配置。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8ac37b9a595ea6b4d16839034fa3b00e68f.png" referrerpolicy="no-referrer"></p><p>主要变化：</p><ul><li>支持将 Fish 配置为等待指定的时间来完成多键序列，而不是无限期地等待</li><li>改进&nbsp;history pager</li><li>改进命令自动补全和通配符性能</li><li>改进交互</li><li>……</li></ul><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffish-shell%2Ffish-shell%2Freleases%2Ftag%2F3.7.0" target="_blank">详情查看 Release Notes</a></u>。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 02:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273753/fish-shell-3-7-0-released</guid>
            <link>https://www.oschina.net/news/273753/fish-shell-3-7-0-released</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Vue 3.4 「灌篮高手」发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Vue 3.4 已正式发布，代号"🏀 Slam Dunk"（灌篮高手）。</p><h4><strong>新版本主要变化</strong></h4><ul><li><strong>重写模板解析器</strong>，速度提升了 2 倍</li><li><strong>重构响应性系统 (Reactivity System</strong><strong style="font-family:-apple-system,BlinkMacSystemFont,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;,&quot;Segoe UI&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif">)</strong><span style="font-family:-apple-system,BlinkMacSystemFont,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;,&quot;Segoe UI&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif">，让 effect 的触发更准确高效</span></li><li><strong>优化 API</strong>，比如<code>defineModel</code>进入稳定阶段，以及绑定 props 时的同名简写</li></ul><hr><h4><strong>更新亮点</strong></h4><ul><li><strong><span style="background-color:#e67e22">解析器速度提升 2 倍，优化 SFC 构建性能</span></strong></li></ul><p><strong>Vue 3.4 完全重写了模板解析器</strong>。在旧版本，Vue 使用递归下降解析器，该解析器依赖了大量正则表达式和前向搜索。</p><p>新的解析器使用基于<code>htmlparser2</code>的状态机 tokenizer（分词器），它仅迭代整个模板字符串一次。结果是对于所有尺寸的模板而言，解析器始终优化 2 倍。得益于 Vue 广泛的测试用例和 ecosystem-ci，它也 100% 向后兼容 Vue 终端用户。</p><p>在将新的解析器与系统的其他部分集成时，开发团队还发现了进一步优化整体 SFC 编译性能的机会。基准测试显示，在生成源码映射的同时，编译 Vue SFC 的脚本和模板部分的时候，性能优化了约 44%，因此 Vue 3.4 应该会优化大多数使用 Vue SFC 的项目构建。</p><p>但是请注意，Vue SFC 编译只是现实项目中整个构建过程的一部分。与单独的基准测试相比，端到端构建时间的最终收益可能要小得多。</p><p>在 Vue 核心库之外，新的解析器还将优化 Volar/vue-tsc，以及需要解析 Vue SFC 或模板的社区插件的性能，比如 Vue Macros。</p><ul><li><strong><span style="background-color:#e67e22">更高效的响应性系统 (Reactivity System)</span></strong></li></ul><p>3.4 对响应性系统进行了重大重构，目标是提高计算属性的重新计算效率。</p><p>比如下面的场景：</p><pre><code class="language-javascript">const count = ref(0)
const isEven = computed(() =&gt; count.value % 2 === 0)

watchEffect(() =&gt; console.log(isEven.value)) // logs true

count.value = 2 // logs true again</code></pre><p>在 3.4 之前的版本，每当&nbsp;<code>count.value</code>&nbsp;变更时，即使计算结果不变，也会触发&nbsp;<code>watchEffect</code>&nbsp;的回调。通过 3.4 优化，现在仅当计算结果实际发生变更时才会触发回调。</p><ul><li><strong><code><span style="background-color:#e67e22">v-bind</span></code><span style="background-color:#e67e22">&nbsp;同名简写</span></strong></li></ul><p>下面用例：</p><pre><code class="language-javascript">&lt;img&nbsp;:id="id"&nbsp;:src="src"&nbsp;:alt="alt"&nbsp;/&gt;</code></pre><p>可简写为：</p><pre><code class="language-javascript">&lt;img&nbsp;:id&nbsp;:src&nbsp;:alt&nbsp;/&gt;</code></pre><p>Vue 团队表示，最初他们担心这种用法会与布尔属性混淆。但在重新审视该功能后，考虑到其动态特性，他们认为<code>v-bind</code>的行为比原生属性更像 JavaScript 是有意义的。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.vuejs.org%2Fposts%2Fvue-3-4" target="_blank">详情查看发布公告</a></u>。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 14:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273703/vue-3-4</guid>
            <link>https://www.oschina.net/news/273703/vue-3-4</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenChat 1.0 beta，开源 IM 服务器搭配 SDK 以及 APP 软件平台！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>龙年元旦，祝大家龙年快乐，技术更上一层！2024 赚大钱！</p><p>在这里我也为大家准备了一个新年礼物 OpenChat 的源码，希望有自主 IM 研发需求的朋友可以尝试体验。</p><p>整个 IM 服务器我们分为 Gate / Msg / Logic 三个服务，下面是三个服务的解释：</p><ol><li>Gate：顾名思义是网关服务，可以启用多个网关，比如北京、上海、深圳我们都放一个网关，来提升用户访问的响应问题。</li><li>Msg：消息服务器，Msg 服务可以根据需求无限扩展，来提服务的并发能力。</li><li>Logic：这个是逻辑服务器，所有用户关系、群、红包等功能都会在这个服务内完成，主要是操作消息队列和数据库。</li></ol><p>值得一提的是 OpenChat 配套了完整的 SDK 封装，SDK 封装使用了 C++11 语法，兼容了 iOS / Android / Windows / macOS / Linux / FreeBSD 等主流平台。</p><p>因为这个开源软件目前没有 UI 设计人员参与，Demo 界面参照了微信的常规布局，演示在下方。</p><p>苹果 iPhone iOS 版本演示二维码：</p><p><img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-f63906cd3a53f9519e876991edf5b1ca6ac.png" width="400" referrerpolicy="no-referrer"></p><p>安卓 Android 版本演示二维码：</p><p><img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-cba62748e9efe7969b3eeea3b98259b5aad.png" width="400" referrerpolicy="no-referrer"></p><p>开源项目希望大家能喜欢，有建议可以加 D 语言交流 QQ 群：<span style="background-color:#303030; color:rgba(255, 255, 255, 0.6)">184183224</span></p><p>开源作者 QQ 和微信：<span style="background-color:#303030; color:rgba(255, 255, 255, 0.6)">101011100</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 07:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273657/openchat-1-0-beta</guid>
            <link>https://www.oschina.net/news/273657/openchat-1-0-beta</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[基于 mybatis 的 orm：mybatis-mp 1.3.0 发布-超丰富的 api！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">mybatis-mp 包含丰富的 api：</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">1：基于注解，映射数据库；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">2：支持多表 join 和返回；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">3：api 采用 lambda 和 stream 流式设计；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">4：内置分页以及超强的 sql 优化功能；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">5：稳定且性能极优；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">6：轻量级封装 mybatis，几乎没有侵入；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">7：api 丰富，支持数据库函数、多表、乐观锁、多租户、逻辑删除、默认值（可动态值） 等众多功能；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">8：零学习成本，和写 sql 一样方便。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">9：支持复杂的返回关系映射：例如一对一 ，一对多，多对多；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">10：支持自定义 sql 模板，再也不用担心框架支持不足；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">11：内置代码生成器，通过配置，可定制自身规范；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">12：全新的框架，全新的设计理念，新的就是好！</p><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 06:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273646/mybatis-mp-1-3-0-released</guid>
            <link>https://www.oschina.net/news/273646/mybatis-mp-1-3-0-released</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Hugging Face 年度回顾：2023，开源大模型之年]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section data-tool="mdnice 编辑器" data-website="https://www.mdnice.com" style="font-size: 16px;color: black;padding-right: 10px;padding-left: 10px;line-height: 1.6;letter-spacing: 0px;word-break: break-word;text-align: left;font-family: Roboto, Oxygen, Ubuntu, Cantarell, PingFangSC-regular, PingFangTC-regular, &quot;Open Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif;"><blockquote data-tool="mdnice 编辑器" style="border-top: none;border-right: none;border-bottom: none;font-size: 0.9em;overflow: auto;color: rgb(106, 115, 125);padding: 10px 10px 10px 20px;margin-bottom: 20px;margin-top: 20px;border-left-color: rgb(255, 177, 27);background: rgb(255, 245, 227);"><p style="font-size: 16px;line-height: 26px;color: rgb(89, 89, 89);">查看本文完整链接，请点击文末阅读原文</p></blockquote><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在 2023 年，大型语言模型（Large Language Models，简称 LLMs）受到了公众的广泛关注，许多人对这些模型的本质及其功能有了基本的了解。是否开源的议题同样引起了广泛的讨论。在 Hugging Face，我们对开源模型抱有极大热情。开源模型的优势在于，它们不仅促进了研究的可复制性，还鼓励社区参与到人工智能模型的开发中来，这样做有助于我们更容易地审视模型中可能存在的偏差和局限性。此外，通过重复利用已有的检查点，我们还能够减少整个领域的碳足迹（这只是，众多优点，中的一部分）。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">让我们一起回顾开源 LLMs 在过去一年的发展历程吧！</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><span style="color: rgb(136, 136, 136);">为了确保本文篇幅适中，我们将不涉及代码模型的相关内容。</span></p><span id="OSC_h2_1"></span><h2 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">🍜 预训练大型语言模型的配方</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">首先，如何获得一个大型语言模型呢？（如果你对此已有所了解，可以跳过这部分内容。）</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">模型的 <strong style="color: black;">架构</strong>（即其代码表示）定义了它的具体实现和数学结构：这包括所有的相关参数，以及这些参数如何与输入数据进行交互。目前，大多数高性能的大型语言模型（LLMs）都是基于 「仅解码器」（decoder-only）的 Transformer 架构的衍生版本，有关原始 Transformer 的详细信息可以参考其，发表的论文。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">训练数据集</strong> 是模型训练过程中（即参数被学习时）所依赖的全部样本和信息的集合，它使模型能够学习到特定的数据模式。这些数据通常包括多样的文本材料，既可以是各种自然语言文本，如法语、英语、汉语等，也可以是各类编程语言代码，比如 Python、C 语言等，或者是任何能够以文本形式表现的结构化信息，例如 Markdown 或 LaTeX 中的表格、公式等。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">分词器</strong> 是定义如何将训练数据集中的文本转化为数字的工具（因为模型是一个数学函数，因此需要数字作为输入）。分词是通过将文本转换为称为 「词元」 的子单元（可以是单词、子词或字符，具体取决于分词方法）来完成的。分词器的词汇量大小决定了其能够将文本分割成的不同词元的种类数目，这个数字通常介于 32,000 到 200,000 之间。数据集的规模常常用它包含的 <strong style="color: black;">词元数量</strong> 来衡量。经过分词后，如今的数据集范围从几千亿词元到几万亿词元不等，这些词元是构成数据集的基本单元。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">训练超参数</strong> 定义了模型训练的方法。这些参数决定了模型应如何调整自身以适应新的数据样本，以及模型参数更新的速度应该是多快。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">一旦确定了这些超参数，接下来需要的就是 1）充足的计算资源来进行模型训练；2）具备专业技能的人员来执行和监督训练过程。训练过程本身包括在训练所用的硬件上初始化模型架构，以及依据前述超参数在训练数据集上应用训练算法。训练的成果是一系列模型权重 —— 这些就是经过学习的 <strong style="color: black;">模型参数</strong>，也正是人们通常所说的开放获取的预训练模型。这些权重可以用于后续的 <strong style="color: black;">推理过程</strong>，即对新的输入数据进行预测，例如生成文本。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">预训练的大型语言模型（LLM）在完成初始训练后，还可以根据具体任务进行定制化或进一步调整。特别是当这些模型的参数被开放共享时，它们可以作为不同用例和应用的基础，经过一种称为 「微调」 的过程进行优化。微调包括在与原始预训练数据集不同的、通常更小且更专业化的数据集上，对模型执行额外的训练步骤，目的是为了针对特定应用场景优化模型性能。尽管微调步骤在计算资源消耗上有一定成本，但这一成本通常远低于从零开始训练一个全新模型所需的财务投入和环境代价。这也是高品质开源预训练模型极具吸引力的一个原因，它们使得即便是计算预算有限的从业者也能够自由地使用和改进这些模型。</p><span id="OSC_h2_2"></span><h2 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">🗝️ 2022 年，从规模竞赛转向数据竞赛</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在 2023 年之前，社区有哪些开源模型可用？</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">直至 2022 年初，机器学习界普遍认为，模型的规模越大（即拥有的参数越多），其性能也越出色。特别是，模型一旦超过某个特定的规模阈值，其能力似乎会实现质的飞跃，这两种现象分别被称为 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">突现能力</code> 和 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">规模定律</code>。2022 年推出的多个预训练开源模型家族大多遵循这种范例。</p><ol data-tool="mdnice 编辑器" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;" class="list-paddingleft-1"><li><p style="margin-top: 5px;line-height: 26px;color: rgb(58, 58, 58);margin-bottom: 16px;"><strong>BLOOM (BigScience Large Open-science Open-access Multilingual Language Model)<br></strong>BLOOM 是由 BigScience 研究团队推出的，一系列模型。BigScience 是一个由 Hugging Face 协调，联合法国的 GENCI 和 IDRIS 组织共同参与的国际合作项目，涵盖了来自 60 个国家、250 个研究机构的 1000 名科研人员。这些模型采用了仅包含解码器的 transformer 架构，并进行了细微调整，比如引入了嵌入后归一化和 ALiBi 位置嵌入技术。在这一系列模型中，最大的一个拥有 1760 亿个参数，它接受了 46 种人类语言和 13 种编程语言的 3500 亿个多语言数据词元的训练。大量的训练数据已经向公众开放，包括数据的来源、策划和处理过程的详细信息。它是目前为止发布的最大的开源多语言模型。</p></li><li><p style="margin-top: 5px;line-height: 26px;color: rgb(58, 58, 58);margin-bottom: 16px;"><strong>OPT (Open Pre-trained Transformer)<br></strong>Meta 发布的 OPT 模型，系列采用了仅包含解码器的 Transformer 架构。这些模型借鉴了 GPT-3 论文中的技术，如特定的权重初始化和预归一化策略，并对注意力机制进行了改进，比如引入了交替的密集型与局部带状注意力层。系列中最大的模型拥有 1750 亿个参数，其训练数据涵盖了来自公共领域的 1800 亿个数据词元，包括书籍、Reddit 社交平台数据、新闻、维基百科以及其他多种互联网来源。这一系列模型在性能上与 GPT-3 不相上下，并且通过编码优化减少了计算资源的消耗。</p></li><li><p style="margin-top: 5px;line-height: 26px;color: rgb(58, 58, 58);margin-bottom: 16px;"><strong>GLM-130B (General Language Model)<br></strong>清华大学联合智谱 AI 共同发布了 GLM-130B 模型。该模型基于完整的 Transformer 架构，并引入了一些创新（如采用 DeepNorm 进行层后归一化、使用旋转式位置嵌入）。GLM-130B 拥有 1300 亿参数，是在包含英文和中文的互联网数据集上训练的，这些数据集包括 The Pile、WuDao 语料库以及其他中文语料库，共计 4000 亿个词元。在性能上，GLM-130B 与 GPT-3 模型不相上下。</p></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);"><strong>较小或更专业的开源大语言模型<br></strong>近期，一些较小型的开源模型也相继发布，这些模型主要服务于科研领域：Meta 推出了 Galactica 系列的大型语言模型（LLM），其中规模最大的模型拥有高达 120B 参数，这些模型是在科学文献中的 1060 亿个词元基础上进行预训练的。EleutherAI 则发布了 GPT-NeoX-20B 模型，这是一个完全开源的仅解码器式 Transformer 模型（包括模型架构、权重和数据），在 5000 亿词元上经过训练，并采用了 RoPE 以及对注意力机制和初始化过程的若干改进，为科学研究提供了一个完整的工具集。 
    </section></li></ol><section style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);margin-top: 16px;">
    这些巨大的模型令人振奋，然而，它们的运行成本也高得惊人！在进行推理计算（即从模型中得出预测结果）时，模型必须被加载到内存中，而一个具有一千亿参数的模型往往需要占用高达 220GB 的内存空间（这个过程我们将在后文中详细阐述），这样的内存需求对于大多数机构和专业人士来说都是难以承担的！ 
  </section><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">然而，2022 年 3 月，DeepMind 发表了一篇，论文，探讨了在固定计算预算条件下，模型参数与数据量的最优配比。简而言之，如果你的模型训练预算有限，应该如何平衡模型大小和数据规模？研究者们发现，在平均计算预算下，对于大型语言模型（LLMs），更高效的策略是维持一个相对较小的模型，并在更广泛的数据集上进行训练。他们开发的模型 Chinchilla（未公开）拥有 700 亿个参数，仅为某些大型模型参数总数的三分之一，却在高达 1.4 万亿个词元的数据集上进行了训练，是其他模型所使用数据量的三到四倍。结果显示，Chinchilla 在性能上不仅媲美甚至超越了其他更大的同类型模型，无论是开源还是非开源的。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">这种范式的变化，尽管可能已在封闭的实验室环境中为人所知，但它却让整个开放的科学界感到措手不及。</p><span id="OSC_h2_3"></span><h2 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">🌊 2023, 开放发布之年</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><span id="OSC_h3_4"></span><h3 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);"><em style="color: black;">小型</em> 大语言模型的崛起</span><span style="display: none;"></span></h3><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">2023 年，仅解码器（decoder-only）式的 Transformer 模型迎来了爆发式增长。几乎每月都有新的预训练模型问世，发展速度之快以至于渐渐演变为每周甚至每日都有新模型的推出。Meta 在 2 月推出了 LLaMA 模型；Eleuther AI 在 4 月带来了 Pythia 模型；MosaicML 在 5 月推出了 MPT 模型；Salesforce 和 TIIUAE 则在 6 月分别发布了 X-GEN 和 Falcon 模型。Meta 紧随其后，在 7 月发布了 LLaMA 的升级版本 LLaMA 2。进入下半年，9 月阿里巴巴发布了 Qwen 模型；Mistral.AI 推出了同名 Mistral 模型；01-ai 在 11 月发布了 Yi 模型；Deci 推出了 DeciLM 模型；而 Upstage 则在 12 月带来了 Phi-2 和 SOLAR 模型。这一系列的模型发布，不仅展示了人工智能领域的快速进步，也预示着技术的不断迭代与革新。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">这些发布包括了：a) 模型权重（在不同程度的开源许可下）；b) 对于较小规模的模型（介于 30 亿至 700 亿参数之间），它们的性能都相当出色，因此立刻被社区采用。这些模型几乎都采用仅解码器的 Transformer 架构，并且进行了各种调整（比如 ALiBi 或 RoPE、RMS 预归一化、SwiGLU），以及对注意力函数的一些改变（如 Flash-Attention、GQA、滑动窗口注意力），并且在不同的代码库实现中进行了优化，以提高训练或推理速度。这些调整很可能在一定程度上影响模型的性能和训练速度；然而，由于所有架构都已经连同权重一起公开发布，剩下的核心差异主要在于训练数据和模型的许可方式。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">Meta AI 发布的 LLaMA 系列是该系列中的首款模型。研究团队的目标是在既定的计算预算内训练不同规模的模型，以求达到最优性能。他们首次明确将训练预算与推理成本（即在满足特定性能目标时，模型推理所需的成本）并重考虑。基于这样的考量，他们选择在更大量的数据和更多的训练步骤上，训练规模较小的模型，以期在较小的模型尺度上获得更高的性能（这是对训练计算效率的一种权衡）。在 LLaMA 系列中，最大的模型拥有 650 亿参数，经过了 1.4 万亿的词元训练，而规模较小的模型 —— 分别具有 60 亿和 130 亿参数 —— 则在 1 万亿词元训练后完成。在大多数基准测试中，130 亿参数的 LLaMA 小型模型的表现超过了 GPT-3，而 650 亿参数的 LLaMA 大模型在发布时则代表了最先进的技术水平。然而，这些模型的权重是以非商业许可的形式发布的，这限制了它们在社区中的应用范围。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">Eleuther AI 是一个开源的非营利实验室，它发布了一系列名为 Pythia 的大型语言模型（LLMs）。这些模型有不同的规模，全部采用公开数据进行训练，目的是为了帮助研究人员理解大型语言模型训练的不同阶段。有关 Pythia 模型的更多信息，可以通过它们在 Hugging Face 上的，系列合集，查看。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">MosaicML 公司在两个月后推出了 MPT 模型，该模型的性能优越，并且支持商业用途，同时公司还公开了其训练的具体细节。MPT 的首个版本是一个 7B 的模型，紧接着在 6 月份，公司发布了一个更大的 30B 版本。这两个模型都是基于 1 万亿个英语和编程语言的词元训练而成，训练数据包括了 C4、CommonCrawl、The Stack、S2ORC 等数据集。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">MPT 模型推出后不久，TIIUAE 团队便发布了 Falcon 系列模型，中的 7B 和 30B 版本。这些模型在 1 至 1.5 万亿个英文和代码词元上进行了训练，训练数据包括来自 RefinedWeb、Project Gutenberg、Reddit、StackOverflow、GitHub、arXiv、Wikipedia 等多个来源。同年晚些时候，TIIUAE 还发布了一款更为庞大的 180B 模型。Falcon 模型的细节、所用数据以及训练过程均在一份技术报告及随后发表的，研究论文，中有详尽的描述。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">先前的模型在公开时通常会公开其数据集，但随后推出的模型很少公布其训练过程中使用的具体信息，这使得重现它们的成果变得困难。尽管如此，这些模型通过发布它们的权重参数，为研究社区提供了一个研究和进一步开发的起点。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">Salesforce 在夏初推出了 X-Gen 模型，这是一款拥有 70 亿参数的模型，训练数据包括了 15 万亿个 「自然语言和代码」 词元，训练过程分为多个步骤，并采用了数据调度系统（并非所有数据同时输入模型）。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">X-Gen 在 Meta 推出的更为引人注目的新的 LLaMA-2 家族的阴影下显得有些黯然失色。LLaMA-2 是 Meta 推出的一个新的模型系列，规模从 7B 到 70B 不等，这些模型是在 2 万亿个 「来自公开来源的词元」 上训练而成的，采用了宽松的社区许可证，并经过了人类偏好的精细调整（RLHF），即所谓的对齐过程。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">随后，新兴初创企业 Mistral 推出了其首款模型 ——Mistral-7B，该模型，是基于互联网公开数据集的大量数据训练而成，具体数据量尚未公布。随着 2023 年末的临近，模型发布活动日益频繁。Mistral 紧接着发布了更为庞大的第二款模型 Mixtral 8x7B。与此同时，Deci.AI 公司也带来了其令人瞩目的首款模型 DeciLM，upstage 公司也不甘落后，推出了规模更大的 SOLAR 模型。这些模型均采用了来源和数量未公开的数据进行训练。在各大排行榜和公开基准测试中，这些模型均展现出稳步的进步。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在 2023 年年底，值得关注的一大事件是中国训练并公开发布了多个性能显著提升的模型。其中，阿里巴巴推出了其双语（英汉）模型 Qwen 系列，其参数规模从 70 亿，至 700 亿不等，经过了 240 亿词元数据的训练。与此同时，01-AI 公司也发布了 Yi 系列模型，其参数规模介于 60 亿至 340 亿之间，训练数据量达到了 300 亿词元。这些模型在公开排行榜（如 Open LLM leaderboard）以及一些极具挑战性的基准测试（例如 Skill-Mix）中的表现，均超过了之前的模型。2023 年底的另一强有力的新竞争者是 DeepSeek AI，他们推出了 「DeepSeek-Coder」，该模型从零开始训练了 200 亿词元数据，其中包含 87% 的代码和 13% 的英汉混合自然语言。</p><span id="OSC_h3_5"></span><h3 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">随处可见的对话模型</span><span style="display: none;"></span></h3><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">2023 年，与前一年相比，几乎所有新发布的预训练模型都配备了预训练版本和对话微调版本，这些版本采纳了多种现有的调整方法。尽管适用于聊天环境的模型调整技术在 2022 年及以前已有所开发，但这些技术在 2023 年得到了广泛应用并迅速兴起，这突显了聊天模型在普罗大众中使用的快速增长，以及通过与模型的互动对其进行的人工评估（即 「氛围检查」 评估）。本文将详细介绍几种著名的训练调整预训练模型以进行聊天的方法，实际上，相关的变体还有很多！</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">基于对话的微调</strong> 是一种特殊形式的监督式微调。在这种方法中，我们使用的标注数据是对话形式的，类似于社交媒体上的多轮对话记录。通过这种方式，可以对模型进行特定的微调。在这个过程中，我们可以采用与模型训练阶段相同的技术。例如，在处理仅解码器 Transformer 模型时，可以训练模型通过自回归方法，即逐一预测接下来的词元。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">指令微调</strong>（Instruction-based Fine-Tuning，IFT）采用相同的方法，但使用指令数据集，该数据集包含一系列类似查询的提示以及答案（如果需要，还可以包含可选的附加输入）。这些数据集教导模型如何遵循指示，并且可以是人类生成的，也可以是大型语言模型生成的。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">利用大规模模型输出的合成数据集（由模型生成的数据集，例如来自 GPT-4 的生成，可以是来自指示或用户与模型之间的交互）是实现指导微调和聊天微调的一种方式。这通常被称为 「蒸馏」，因为它涉及从性能较高的模型中获取知识，以训练或微调较小的模型。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">这两种方法都相对容易执行：你只需找到或创建相应的数据集，然后采用与训练时相同的技术对模型进行调整即可。去年，发布了众多指导性数据集，它们有效提升了模型在对话场景中的表现。想要了解更多关于此主题的信息，可以参阅这篇介绍性博文的，链接。然而，尽管模型的性能有了显著提升，但它们仍未能完全达到人类的预期水平。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">从人类反馈中强化学习</strong>（Reinforcement Learning from Human Feedback，RLHF）是一项旨在使模型输出与人类偏好（基于特定标准）相一致的特定方法。具体操作流程如下：模型根据给定的提示生成多个潜在答案；人类评估者对这些答案进行排序；然后，这些排序结果用于训练一个偏好模型（该模型学习如何给出反映人类对答案偏好程度的评分）；最后，利用偏好模型通过强化学习对语言模型进行进一步的微调。更详细的信息，请参阅这篇，博客文章，原始 RLHF 论文，或者 Anthropic 关于 RLHF 的论文。需要注意的是，这是一种成本较高的方法（注释 / 排名 + 训练新模型 + 微调的整个过程成本很高），主要用于确保模型的输出与安全目标相符。为了降低成本，人们开发了一种低成本的变体方法，即利用高质量的语言模型来对模型输出进行评分，而不是完全依赖人类评价，这种方法称为从 <strong style="color: black;">人工智能反馈中学习的强化学习</strong>（Reinforcement Learning from AI Feedback, RLAIF）。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">直接偏好优化</strong>（Direct Preference Optimization, DPO）是 RLHF 的另一种变体，其核心优势在于无需训练和运用独立的偏好模型。这一方法同样需要人类或人工智能生成的排序数据集，但它通过直接利用这些数据来更新模型，即通过对比模型现有的策略（即预测行为）与理想的策略（即能够预测出最优排序答案的行为）。换言之，模型本身即扮演了对齐和偏好模型的双重角色，这不仅简化了优化流程，而且根据报告，还能够实现与其他方法相媲美的性能水平。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">回到来自（大多数）私企的小型开放权重模型的浪潮，其中很多模型都发布了经过精细调整的对应版本：MPT-7B 还配备了一个指令微调和一个对话版本，Falcon 和 XGen 模型的指令微调版本在年底发布，Llama-2、Qwen 和 Yi 发布了对话版本，DeciLM 则发布了一个指令微调版本。Llama-2 的发布尤其引人注目，因为它在预训练和指令微调模型中都特别注重安全性。</p><span id="OSC_h3_6"></span><h3 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">社区的进展如何？</span><span style="display: none;"></span></h3><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">虽然随着新模型的发布，聊天模型和指令微调模型通常会立即推出，但社区成员和研究人员并没有把这看作是理所应当的。在这些基础模型提供的沃土上，涌现出了一个庞大而活跃的微调爱好者社区。这些微调专家经常会构建新的数据集，并对模型进行细致的微调，以此来展现新发布模型的出色性能。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在 2023 年伊始，一些专为指令交互和对话微调设计的数据集已经被发布。例如，代表人类偏好的数据集包括 OpenAI 的 WebGPT 数据集、Anthropic 的 HH-RLHF 数据集以及 OpenAI 的，摘要，数据集，它们在这一领域是开拓者。指令数据集的例子包括 BigScience 的，公共提示池、Google 的 FLAN 1 和 2（FLAN 数据集）、AllenAI 的，自然指令，数据集、由不同机构的研究人员开发的自动生成指令框架，自我指令、由专家创建的指令基准，超自然指令（有时用作微调数据），以及由特拉维夫大学和 Meta 合作生成的自动指令数据集，非自然指令，等。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">❄️ 冬 2022/2023: 一月，来自中国多个研究机构的研究人员共同发布了，人类 ChatGPT 指令语料库（HC3），其中包含了人类与模型对各种问题的回答。3 月份，发布活动接连不断：斯坦福大学推出了 Alpaca 模型，这是首个遵循指令的 LLaMA 模型（7B），以及相关的数据集，包括用大型语言模型生成的 52K 条指令。非营利开源实验室 LAION 发布了，开放指令通用数据集（OIG），包含 4300 万条指令，这些指令既有通过数据增强创建的，也有编译自其他现有数据源的。同月，位于加州大学伯克利分校的 LMSYS 组织发布了 Vicuna，这也是一个基于 ChatGPT 聊天数据的 LLaMA 精调模型（13B），这些聊天数据是用户与 ChatGPT 之间的对话，由用户自己公开分享在 ShareGPT 上。还发布了 Guanaco 数据集，它是 Alpaca 数据集的扩展版（增加了 50 万条多语言条目），以及相关的 LLaMA-7B 精调模型。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">🌱 春：四月，伯克利人工智能研究实验室（Berkeley AI Research lab，BAIR）发布了 Koala，这是一个经过聊天调优的 LLaMA 模型，它使用了多个先前的数据集（包括 Alpaca、HH-RLHF、WebGPT、ShareGPT），而 DataBricks 则发布了 Dolly 数据集，这是一个由 15K 条人工生成的指令组成的数据集，以及相关的 Pythia 微调模型。五月，清华大学发布了 UltraChat，这是一个包含 1.5M 对话指令的数据集，以及在该数据集上进行微调的 UltraLLaMA 模型。随后，微软发布了 GPT4-LLM 数据集 / 框架，用于生成 GPT4 的指令。六月，微软研究院分享了一种新方法 Orca，通过使用大型模型的推理轨迹（逐步解释其推理过程）来构建指令数据集，该方法很快被社区（尤其是 Alignementlab.ai）复现，他们创建了 Open Orca 数据集，包含数百万条条目，随后用于微调多个模型（如 Llama、Mistral 等）。五月和六月期间，Camel-AI 发布了多个关于不同话题（物理、生物、化学等）的指令或聊天数据集，每个领域都有超过 20K 的示例。同样在六月，发布了 Airoboros 框架，用于使用模型生成的数据微调模型（遵循自我指导方法），以及一系列的，指令数据集。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">🌻 夏：八月，由中国的非营利组织 OpenBMB 发布了 UltraLM（一种基于 LLaMA 的高性能聊天模型微调版本），随后在九月，他们又发布了相关的偏好数据集 UltraFeedback，这是一个包含与 GPT4 对比的输入反馈数据集，并附有注释。在整个夏天，一个名为 NousResearch 的集体发布了多个基于私有和公开指导数据集的微调版本（特别是 Hermes 和 Capybara 系列）。九月，清华大学的一个学生团队发布了 OpenChat，这是一个应用了新的强化学习微调策略的 LLaMA 微调版本。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">🍂 秋：十月，Hugging Face 发布了 Zephyr 模型，这是一个在 UltraChat 和 UltraFeedback 上使用 DPO 和 AIF 技术对 Mistral 模型进行微调的产物。同时，社区成员发布了 OpenHermes 2，这是一个在来自网络或使用 Axolotl 生成的 900K 条目上对 Mistral-7B 模型进行微调的版本。Lmsys 发布了 LMSYS-Chat-1M，包含了与 25 个大型语言模型（LLMs）的真实用户对话。十一月，OpenBuddy 发布了 OpenBuddy-Zephyr，这是一个对 Zephyr 模型进行微调的多轮对话模型。同月，NVIDIA 发布了 HelpSteer 数据集，这是一个对齐微调数据集，提供了提示、相关模型回应以及基于几个标准对这些回答的评分，而微软研究院则发布了 Orca-2 模型，这是一个在新的合成推理数据集上对 Llama 2 模型进行微调的版本。十二月，伯克利大学发布了 Starling 模型，这是一个对 Open-Chat 模型进行 RLAIF 微调的版本，以及相关的数据集 Nectar，包含了 20 万条比较数据。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">正如我们看到的，今年整个领域的发展既依赖于通过使用高质量的预训练大型语言模型（LLMs）创建新数据集，也依赖于社区发布的各种开源模型，这使得该领域进步飞速！如果你现在在模型名称中看到这些名字中的任何一个，你就能够大概了解它的来源了🤗。</p><ul data-tool="mdnice 编辑器" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      还有一些更专业的数据集，例如用于数学问题微调的 MetaMath 和 MathInstruct，以及涉及数学和代码指令的 Evol-Instruct，还有 CodeAlpaca 与 CodeCapybara 等代码指令相关的数据集也已发布。虽然这些数据集同样被用于提升模型在特定任务上的表现，但我们在此不会详细介绍它们。你还可以访问，令人心动的指令数据集，来查看其他相关数据集的集合。 
    </section></li></ul><span id="OSC_h2_7"></span><h2 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">开启定制模型的大门</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><span id="OSC_h3_8"></span><h3 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">模型融合：极致的定制化</span><span style="display: none;"></span></h3><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在开源社区的典范实践中，一个重要的里程碑是模型与数据的融合。随着每一次代码合并或提交，追溯所使用数据的来源变得愈发复杂 —— 许多公开的数据集本身就是其他数据集的汇编。同样，由于卓越性能的模型往往是在相似模型的基础上经过层层微调得来的（可参考 Mistral 的，衍生模型树），模型的发展历史也变得难以梳理。在这篇摘要中，我们尚未有足够的篇幅深入探讨这一引人入胜的技术领域，但在最后，我们将简要介绍一下它的概念。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">然而，「模型融合」 究竟是什么意思呢？</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">模型融合</strong> 是一种将不同模型的权重融合到一个单一模型中的方法，其理想目标是将每个模型的各自优势结合在一个统一的模型中。目前已有一些技术实现了这一目标，这些技术大多在社区论坛中得到扩展和发布，这是一个全球范围内的去中心化研究的典型案例，涵盖了从业者、研究人员到业余爱好者的广泛社区。其中一种最简单的公开方法是平均一组具有共同架构的模型的参数（示例 1，示例 2），但还存在更复杂的参数组合方法，例如确定每个模型中对特定任务最有影响力的参数（加权平均），或者在合并前考虑模型间参数的相互干扰，从而选择保留哪些参数（关联融合）。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">这些技术使任何人都能轻松地生成模型的组合，而且由于大多数现代模型都是基于同一架构的变体，这一过程变得尤为简便。这也是 Open LLM leaderboard 上一些模型名称如 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">llama2-zephyr-orca-ultra</code> 的原因。这个特定的例子很可能是将 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">llama2</code> 和 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">zephyr</code> 模型合并后，再在 orca 和 ultra 数据集上进行微调的结果。通常，更多的细节可以在 Hugging Face 中心的相应模型卡片上找到。</p><span id="OSC_h3_9"></span><h3 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">参数高效微调：触手可及的个性化体验</span><span style="display: none;"></span></h3><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">有时候，你可能需要进行更为细致的个性化调整，但受限于硬件显存大小，无法加载完整模型进行微调。其实，你知道吗？微调时并不必须要用到模型的全部。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">你或许想尝试一种叫做 <strong style="color: black;">参数高效微调</strong>（Parameter-Efficient Fine-Tuning，PEFT）的方法。这项技术首先会冻结你所关注的预训练模型中的参数，然后在其基础上附加一些新的参数层，也就是我们所说的 「适配器」。接下来，你只需对这些专为你的任务设计的轻量级适配器权重进行微调，这些权重远小于原始模型的规模。这样，你仅需分享你的小型适配器权重（以及底层模型）即可！你可以在，这里，探索一系列引人入胜的 PEFT 技术。</p><span id="OSC_h3_10"></span><h3 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">量化：模型普及于各处</span><span style="display: none;"></span></h3><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">我们已经看到，性能出色的模型现在形态各异…… 但即便如此，并不意味着它们对所有人都是触手可及的！一个拥有 300 亿参数的模型仅仅加载到内存中（还未开始使用）就可能需要超过 66GB 的 RAM，而并非社区中的每个人都有能力配备这样的硬件。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">这就是量化技术的用武之地！量化是一种特殊的技术，它通过改变模型参数的精度来减少模型的大小。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">量化是什么意思呢？</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在计算机中，数字是以一定的精度存储的，例如 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">float32</code>、<code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">float16</code>、<code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">int8</code> 等。精度不仅指明了数字类型（是浮点数还是整数），同时也指出了数字存储所占用的内存大小：例如 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">float32</code> 是在计算机上以 32 位存储的浮点数。要了解更深入的解释，请参见这个，链接。因此，数据的精度越高，它所占用的物理内存就越多，这是因为需要更多的位来存储这些数据。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">因此，如果你降低精度，就会减少模型参数在存储上占用的内存，进而减小模型的大小！这也意味着你降低了计算的实际精度，可能会降低模型的性能。然而，我们发现，在较大的模型上，这种性能下降实际上是，非常有限，的。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">回到我们之前的例子中，一个含有 300 亿参数的模型，在使用 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">float16</code> 格式时需要不到 66GB 的内存。如果采用 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">8bit</code>，内存需求将减半至 33GB；若使用 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">4bit</code> 编码，则只需大约 16GB，进一步降低了内存的要求，使得模型更易于部署和使用。</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">精度转换有多种方法，涉及不同的 「转换」 策略，每种策略都有其独特的优势和局限。目前流行的转换方法包括 bitsandbytes、GPTQ, 和 AWQ 等。有些开发者，例如 TheBloke，甚至正在将所有流行的模型进行转换，以便更容易地被社区使用。所有这些方法都是相对较新并且仍在不断发展之中，我们期待随着时间的推移，这些技术能够取得更多的进步。</p><span id="OSC_h2_11"></span><h2 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">接下来呢？</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">年尾尚未到来！在这最后时刻，已经迎来了一些惊喜：新的架构是否终将超越简单高效的 Transformer 模型呢？</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">最新发布包括：</p><ul data-tool="mdnice 编辑器" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      混合专家模型： 
    </section></li><ul style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;color: black;list-style-type: square;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
       Mixtral，该模型由 8 个子模型（仅解码器的 Transformer 模型）组成，对于每个输入，一个路由器会选择两个最佳子模型并将它们的输出求和。 
     </section></li></ul><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      几种状态空间模型（通过潜在空间将输入映射到输出的模型，可以根据任务需求表达为 RNN 或 CNN）： 
    </section></li><ul style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;color: black;list-style-type: square;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
       Mamba，增加了选择机制的状态空间模型 
     </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
       Striped Hyena，具有快速卷积核的状态空间模型 
     </section></li></ul></ul><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">目前来说，这些新方法是否会取代 Transformer 模型还为时尚早，但状态空间模型确实非常有前景！</p><span id="OSC_h2_12"></span><h2 data-tool="mdnice 编辑器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">要点回顾</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><ul data-tool="mdnice 编辑器" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      今年，从大型企业到初创公司，再到研究实验室，各种主体纷纷开放发布模型，这极大地赋能了社区，使其以前所未有的速度开始进行实验和探索。 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      模型公告的开放性呈现出起伏变化，从年初的公开发布（数据集组合、权重、架构）到年末对训练数据守口如瓶，导致无法复现。 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      开源模型出现在包括中国在内许多新的地方，有几个新的参与者将自己定位为语言模型竞争中的强劲竞争者。 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      个性化定制的可能性达到了前所未有的高度，新策略的出现（如强化学习优化的微调、适配器、合并技术），虽然这仅仅是个开始。 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      更小的模型尺寸和量化升级使得大型语言模型对更多人来说变得真正唾手可得！ 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      新的架构也随之出现 —— 它们是否最终会取代 Transformer 架构，仍是一个值得关注的问题。 
    </section></li></ul><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">各位朋友们，就是这样了！</p><p data-tool="mdnice 编辑器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">希望你喜欢我们今年的回顾，从中学到了一些知识，并且和我一样，对于人工智能进步现在如此依赖开源和社区努力感到无比热情！🤗</p><blockquote data-tool="mdnice 编辑器" style="border-top: none;border-right: none;border-bottom: none;font-size: 0.9em;overflow: auto;color: rgb(106, 115, 125);padding: 10px 10px 10px 20px;margin-bottom: 20px;margin-top: 20px;border-left-color: rgb(255, 177, 27);background: rgb(255, 245, 227);"><p style="font-size: 16px;line-height: 26px;color: rgb(89, 89, 89);"><span style="font-size: 14px;">英文原文:</span><url style="font-size: 14px;color: rgb(136, 136, 136);visibility: visible;display: block;"><span style="font-size: 14px;">https://huggingface.co/blog/2023-in-llms</span></url><span style="font-size: 14px;">原文作者：Clémentine Fourrier<br>译者: Xinyu Yang (杨新宇)，字节跳动算法工程师，工作方向为通过 SFT、RL 提升大模型 Math、Reasoning 能力。</span></p></blockquote></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - Hugging Face（gh_504339124f0f）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 04:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/HuggingFace/blog/10555492</guid>
            <link>https://my.oschina.net/HuggingFace/blog/10555492</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[TinyEngine 服务端正式开源啦]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h1>背景介绍</h1><h2>TinyEngine 低代码引擎介绍</h2><p>随着企业对于低代码开发平台的需求日益增长，急需一个通用的解决方案来满足各种低代码平台的开发需求。正是在这种情况下，低代码引擎应运而生。它是一种通用的开发框架，通过对低代码平台系统常用的功能进行解构，将其划分为多个功能模块，并为每个模块定义了相应的协议和开发范式，使得开发者可以根据自身的业务需求，轻松定制开发出自己的低代码开发平台。</p><p>TinyEngine 提供了低代码底层能力，并集成了人工智能，从而使用户能够高效开发。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a> 具有强大的拖拽功能，无论是图元还是复杂组件，都能在画布上带来流畅的体验。它适用于多场景的低代码平台开发，包括资源编排、流程编排、服务端渲染、模型驱动、移动端、大屏端以及页面编排等低代码平台。</p><p>TinyEngine 官网：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine" target="_blank">https://opentiny.design/tiny-engine</a><br> TinyEngine 源码：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">https://github.com/opentiny/tiny-engine</a> （欢迎 star）</p><p><img src="https://oscimg.oschina.net/oscnet/up-fa7423149eca45391380663a32b595b208f.png" alt="" referrerpolicy="no-referrer"></p><h2>服务端开源介绍</h2><p>2023 年 9 月 21 日，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a> 在<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7280926568854667299" target="_blank">华为全联接大会正式宣布开源</a>，引发了广泛的关注，3 个月时间收获了 960 个 Star，组建了 4 个用户交流社群，成员数 772 名。</p><p>很多企业和个人开发者尝试基于 TinyEngine 搭建自己的低代码平台，为搭建企业 Web 应用提效，在使用过程中，大家也遇到了很多问题，比较常见的包括：如何对接服务端、如何导入第三方组件库、如何使用插槽、如何生成代码、如何开发自定义插件等，为此我们在 10 月 27 日策划了一次<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7298642242116452402" target="_blank">线上直播答疑活动</a>，邀请了团队技术专家为大家答疑解惑。</p><p>其中如何对接服务端是众多开发者非常关注的问题，为了帮助开发者打通低代码平台搭建的前后端整体流程，本次 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a> 低代码引擎服务端配套代码的开源，让开发者能够深入了解 TinyEngine 低代码引擎的前后端运行机制，更能够让更多的小伙伴以更深的层次参与到产品共建，共同探讨并改进系统，推动其不断优化，带来更高的创新潜力，使得更多的人能够从中受益。</p><p>同时服务端的开源为自由定制和扩展提供了可能，开发者可以参考 TinyEngine 的代码，根据自身需求对服务端进行改造创新，从而使得产品更具灵活性，能够满足各种复杂的业务需求，构建一个强大而健壮的 TinyEngine 生态系统。</p><h1>核心特性</h1><p>当今互联网应用的复杂性和用户需求的多样性要求我们搭建一套灵活的、便于扩展的系统架构，以满足不断变化的业务需求。 因此我们引入了微服务的概念，将系统拆分为小而独立的服务单元，使得每个服务单元都可以独立开发、测试和部署。这种架构不仅提高了团队的协作效率，还使得系统更容易扩展和维护。</p><ul><li>TinyEngine 设计器微服务选择了<strong>基于 Node.js 的技术栈</strong>，为前端开发者提供了一致的开发体验，无需学习额外的语言即可全栈开发，降低了开发难度和学习曲线，避免了学习新语言的困扰。更能够从服务端的角度去理解 TinyEngine 设计器的运行原理与设计思想。</li><li>在我们的架构设计中，我们<strong>采用了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.eggjs.org%2Fzh-CN" target="_blank">Egg.js</a> 作为业务接口微服务的框架</strong>。Egg.js 优秀的设计和丰富的插件生态系统，使得我们能够迅速构建可维护、可扩展的微服务，从而确保系统的稳定性和可维护性。</li><li>为了降低服务耦合，我们还单独封装了<strong>提供数据库操作接口的数据中心微服务</strong>，在框架选型上我们选择了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.strapi.io%2F" target="_blank">Strapi</a>，Strapi 是一个开源数据管理框架。不仅提供了强大的数据管理和查询功能，还支持自定义内容类型和灵活的 API 构建，为我们的微服务提供了丰富的数据支持。Strapi 的易用性和可扩展性使得我们能够高效地管理和发布数据，确保前端业务接口始终能够获得及时、准确的数据支持。</li></ul><p>综上所述，我们的技术架构旨在提供高效、可维护、可扩展的系统，充分利用 Node.js 和现代化的开源工具，使我们能够更好地满足不断变化的业务需求。这种架构不仅提高了开发效率，还为未来的扩展和创新提供了坚实的基础。</p><h1>服务端架构</h1><p>根据上面的介绍，开发者可以根据微服务这一特性，轻松扩展并实现自己的 TinyEngine 服务端架构。</p><ul><li>业务接口微服务（webService）：构建业务的引擎， 汇总连接其他微服务为前端提供接口。</li><li>数据中心 (data-center)： 作为数据基座，统一进行数据管理，为其他微服务提供一致性的数据支持。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-f120981dacaac81db69e9a2f113ef113e3b.png" alt="" referrerpolicy="no-referrer"></p><p>根据上述架构特点，我们可以在此基础上，通过核心的 webService (业务接口微服务) 搭配任务队列服务 (RabbitMq、 Kafka、 RocketMq 等等) 连接其他功能微服务， 从而拓展整体系统的功能，例如：</p><ul><li>构建服务：由 webService 收集用户请求触发任务队列执行耗费机器资源的构建设计器、区块、物料的相关服务。</li><li>爬虫服务：单独封装，安装了 puppeteer 服务器的微服务，由 webService 触发去执行一些爬取数据、代理登录等等操作。</li><li>AI 大模型相关服务：连接自己内部 AI 大模型， 进行设计器智能化相关的 AI 代码生成、指令操作等等功能的。</li><li>发布服务：封装自己的 CI/CD 流水线微服务，结合设计器代码产出，使代码生产-构建-部署一条龙式运作。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-4558b19a5a930a638d800a5208bcb821d59.png" alt="" referrerpolicy="no-referrer"></p><h1>硬件配置</h1><h2>本地开发</h2><p>推荐使用 <code>windows</code> 操作系统， 推荐配置如下：</p><ul><li>64 位操作系统</li><li>12 核 CPU</li><li>32G 内存</li></ul><h2>服务容器化部署</h2><p>以下信息为支撑 50 qps 并发量的配置参考， 开发者可根据实际情况进行具体问题具体分析，配置信息仅供参考.</p><p>配置单位：</p><ul><li>U: cpu 核数</li><li>G: 内存单位</li></ul><p>在配置负载均衡的情况下推荐：</p><table><thead><tr><th>服务</th><th>配置</th><th>工作负载数量</th></tr></thead><tbody><tr><td>webService</td><td>1U+3G</td><td>4</td></tr><tr><td>data-center</td><td>1U+2G</td><td>4</td></tr></tbody></table><h1>FAQ</h1><p><strong>1、服务端开源之后，如果不想启动 webservice 和 datacenter 两个后端服务器，是否还能沿用原来 mockServer？</strong><br> 答：可以正常使用 mockServer，启动方式和原先一致，直接在项目里执行 <code>pnpm dev</code> 即可</p><p><strong>2、如果本地启动了 webservice 和 datacenter，那么前端本地工程是否还需要更改配置？如果需要，如何更改配置？</strong><br> 答：需要更改配置，更改流程如下： 启动 <code>tinyengine</code></p><p>修改 <code>packages/design-core/vite.config.js</code> 中 origin 的值为自己本地 webService 项目的地址端口（webService 端口默认为 7011）</p><p>运行如下脚本并启动</p><pre><code class="language-sh">pnpm install  # 第一次启动项目需要
pnpm serve:frontend
</code></pre><p>启动成功后浏览器会自动打开设计器页面</p><p><img src="https://oscimg.oschina.net/oscnet/up-a0f5b0133144d2b27013c73bacbf232675f.png" alt="" referrerpolicy="no-referrer"></p><p>具体搭建流程可参考官网本地化部署文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhelp-center%2Fcourse%2Fbackend%2F51" target="_blank">TinyEngine 服务端开源部署 </a></p><h1>未来规划</h1><p>1，人工智能：计划将低代码平台与 AIGC（人工智能生成内容）技术相结合，为用户提供更加智能、高效的应用开发体验。后续我们考虑将低代码平台的开发流程与 AIGC 技术相结合，通过自然语言处理、机器学习和深度学习等技术，实现应用界面的自动生成、功能模块的智能推荐和代码的自动化生成等功能。</p><p>2，模型驱动：我们将致力于将低代码平台与模型驱动能力相结合，为用户提供更加高效、智能的开发体验。深入研究各种业务模型，包括数据模型、业务流程模型等，以了解其特性和需求。后续，我们将低代码平台的开发流程与模型驱动能力相结合，通过可视化建模工具和自动化技术，实现业务模型的快速构建和部署。通过这一创新性的接入方式，用户将能够更加高效地构建和调整业务模型，降低开发难度和成本。</p><h2><strong>关于 OpenTiny</strong></h2><p><img src="https://oscimg.oschina.net/oscnet/up-1c661a9c0916f9dabf9cf1c4aeba473fb68.png" alt="" referrerpolicy="no-referrer"></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">OpenTiny</a> 是一套企业级 Web 前端开发解决方案，提供跨端、跨框架、跨版本的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue%2Fzh-CN%2Foverview" target="_blank">TinyVue 组件库</a>，包含基于 Angular+TypeScript 的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-ng%2Foverview" target="_blank">TinyNG 组件库</a>，拥有灵活扩展的低代码引擎 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a>，具备主题配置系统<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Fdesigntheme%2Fhome" target="_blank">TinyTheme</a> / 中后台模板<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Fpro%2Fhome" target="_blank"> TinyPro</a>/ <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-cli%2Fhome" target="_blank">TinyCLI </a>命令行等丰富的效率提升工具，可帮助开发者高效开发 Web 应用。</p><hr><p>欢迎加入 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">OpenTiny 开源社区</a>。添加微信小助手：opentiny-official 一起参与交流前端技术～更多视频内容也可关注<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspace.bilibili.com%2F15284299%3Fspm_id_from%3D333.1007.0.0" target="_blank">B 站</a>、抖音、小红书、视频号</p><p>OpenTiny&nbsp;也在持续招募贡献者，欢迎一起共建</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">OpenTiny 官网</a>：<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">https://opentiny.design/</a></strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">OpenTiny 代码仓库</a>：<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">https://github.com/opentiny/</a></strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">TinyVue 源码</a>：<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">https://github.com/opentiny/tiny-vue</a></strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">TinyEngine 源码</a>： <strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">https://github.com/opentiny/tiny-engine</a></strong></p><p>欢迎进入代码仓库 Star🌟<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">TinyEngine</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">TinyVue</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Fng" target="_blank">TinyNG</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-cli" target="_blank">TinyCLI</a>~</p><p>如果你也想要共建，可以进入代码仓库，找到&nbsp;good first issue 标签，一起参与开源贡献~</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 03:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6769809/blog/10555626</guid>
            <link>https://my.oschina.net/u/6769809/blog/10555626</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 年化收入超 16 亿美元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theinformation.com%2Farticles%2Fopenais-annualized-revenue-tops-1-6-billion-as-customers-shrug-off-ceo-drama" target="_blank">The Information</a> 援引知情人士消息称，受益于 ChatGPT 产品的强劲增长，OpenAI 最近的年化收入已经从 10 月中旬的 13 亿美元增至 16 亿美元。</span></p><p><span style="color:#000000">这一增长表明，「即便该公司因为 11 月份的领导层危机为竞争对手提供了抢夺客户的机会，但其仍能保持向企业销售人工智能产品的业务势头。」</span></p><p><img height="307" src="https://oscimg.oschina.net/oscnet/up-bc1feecce3c765f974f328d2a2ace13b9a6.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000">OpenAI 于 2023 年 2 月推出 ChatGPT 服务的付费版本 ChatGPT Plus 后，销售额开始快速增长。此前，该公司主要通过应用程序接口向开发者提供 AI 模型来进行创收。数据显示，该公司 2022 年亏损 5.4 亿美元，营收仅为 2800 万美元。</span></p><p><span style="color:#000000">路透社报道称，OpenAI 最初预计在 2023 年完成 2 亿美元的销售额。但事实证明，ChatGPT Plus 比预期的要更受欢迎：在 8 月份，OpenAI 的营收就突破了 10 亿美元，10 月达到了 13 亿美元。该公司的销售势头预计将持续到 2024 年。OpenAI 的一些高管认为，截至年底，其年化经常性收入将增长近四倍，达到 50 亿美元。</span></p><p><span style="color:#000000">「这种乐观的前景表明，该公司可能不会仅仅依靠现有产品的需求来维持其销售增长。特别是，它可能计划推出新的 AI 服务，从而创造额外的收入来源。」</span></p><p><span style="color:#000000">OpenAI 收入的快速增长也可能有助于其在来年获得投资者更高的估值。日前曾有<a href="https://www.oschina.net/news/272549/openai-valuation-100-billion-funding-round">消息称</a>，OpenAI 正在以 1000 亿美元或以上的估值筹集新一轮融资。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 03:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273759/openais-annualized-revenue-tops-1-6b</guid>
            <link>https://www.oschina.net/news/273759/openais-annualized-revenue-tops-1-6b</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 正式加入 CNCF 云原生计算基金会]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><strong style="outline: 0px;visibility: visible;">vivo 近期完成了新会员的 Onboarding 流程， 已正式加入 CNCF 云原生计算基金会</strong>（<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io" textvalue="https://www.cncf.io" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.cncf.io</a>）。<strong style="letter-spacing: 0.544px;outline: 0px;visibility: visible;"></strong></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><span style="text-align: center;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"><br></span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><span style="text-align: center;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100014267" data-ratio="0.5613346418056918" data-s="300,640" src="https://oscimg.oschina.net/oscnet/d2d6894b-bacd-42d9-b2d8-05a6782d0354.png" data-type="png" data-w="1019" style="letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" referrerpolicy="no-referrer"></span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><span style="text-align: center;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span></p><p><span style="background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">C</span><span style="background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">NCF 云原生计算基金会 （Cloud Native Computing Foundation）是 Linux 基金会的一部分，是开源、供应商中立的云原生计算生态组织，致力于云原生应用推广和普及。我们希望通过加入 CNCF 基金会</span><strong style="font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">，推动云原生技术在 vivo 内部的应用和发展，助力自身业务高效交付；同时进一步加强与全球云原生开源社区的交流沟通和知识分享，共同推动行业云原生技术生态的可持续发展</strong><span style="background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">。</span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;">在正式加入 CNCF 云原生计算基金会之前，vivo 内部研发团队积极探索与实践云原生技术，在多个业务场景下应用云原生项目，助力业务发展。</p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100014268" data-ratio="0.43425925925925923" data-s="300,640" src="https://oscimg.oschina.net/oscnet/695497a4-859d-487c-b98b-7537cebc2053.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"><span style="font-size: var(--articleFontsize);letter-spacing: 0.034em;text-align: justify;"></span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">vivo 在云原生领域的项目采纳现状</span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">截止 2023 年 12 月</span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;text-align: left;"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: right;visibility: visible;"><section style="padding: 10px;outline: 0px;display: inline-block;width: 677px;border-width: 1px;border-style: solid;border-color: transparent;background-color: rgb(239, 239, 239);height: auto;visibility: visible;"><section powered-by="xiumi.us" style="outline: 0px;font-size: 14px;text-align: justify;visibility: visible;"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p><strong style="font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(239, 239, 239);outline: 0px;visibility: visible;">应用方面：</strong><br></p><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;">在云原生领域的应用主要包括基于 Kubernetes 的容器编排、服务发现和负载均衡、容器镜像管理、日志收集和分析等场景。通过使用 Openkruise、Helm、Harbor、Containerd、Dragonfly、Fluentd 等开源项目与工具，vivo 实现了基于容器平台的应用发布和管理，提高了业务交付效率和系统可靠性。</span></p></li></ul><p style="outline: 0px;visibility: visible;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="outline: 0px;visibility: visible;"><strong><span style="font-size: 15px;">容器平台能力建设方面：</span></strong></p><p style="outline: 0px;visibility: visible;"><strong><span style="font-size: 15px;"></span></strong><span style="font-size: 15px;letter-spacing: 0.544px;">主要包括基础设施建设、平台架构设计和运维管理等方面。通过使用 Kubernetes 等容器编排技术，vivo 构建了一套完整的容器平台，包括容器集群运维、容器网络、存储管理、应用发布、安全管理等模块，为企业内部多个业务线提供了稳定、可靠的容</span><span style="font-size: 15px;letter-spacing: 0.544px;">器平台。</span></p></li></ul><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;"><br></span></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p><span style="font-size: 15px;"><strong>敢于探索实践方面：</strong></span></p><p><span style="font-size: 15px;"></span><span style="font-size: 15px;letter-spacing: 0.544px;">vivo 在云原生领域勇于探索和实践，积极参与开源社区和代码贡献，持续探索并推广新技术及其应用场景。</span><span style="font-size: 15px;letter-spacing: 0.544px;">同时有积极参与 CNCF 应用交付 TAG 旗下相关工作组的贡献，推广和传播平台工程相关的白皮书、成熟度模型等相关实践和标准。</span></p></li></ul></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br style="outline: 0px;visibility: visible;"></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;">此外，vivo 持续保持与行业交流及合作，共同探索云原生时代的软件工程之道。2023 年 9 月由 Linux 基金会、云原生计算基金会（CNCF）主办的 <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.lfasiallc.com%2Fkubecon-cloudnativecon-open-source-summit-china%2F" textvalue="KubeCon + CloudNativeCon + Open Source Summit China" linktype="text" imgurl="" tab="outerlink" data-linktype="2">KubeCon + CloudNativeCon + Open Source Summit China</a> 在上海举行，vivo 在平台工程专题做了 2 个主题分享。同时，我们也积极支持并参与 KCD 等区域性 Meetup 活动。</p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100014269" data-ratio="1.0716981132075472" data-s="300,640" src="https://oscimg.oschina.net/oscnet/8a9a6912-227d-44eb-ac54-faf41d593727.jpg" data-type="jpeg" data-w="1060" style="" referrerpolicy="no-referrer"></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;">未来，vivo 将持续探索与实践云原生技术，在 CNCF 云原生基金会积极参与和贡献，并与各成员持续加强交流合作。</p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-wrap: wrap;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);text-align: right;visibility: visible;"><section style="padding: 10px;outline: 0px;display: inline-block;width: 677px;border-width: 1px;border-style: solid;border-color: transparent;background-color: rgb(239, 239, 239);height: auto;visibility: visible;"><section powered-by="xiumi.us" style="outline: 0px;font-size: 14px;text-align: justify;visibility: visible;"><ul class="list-paddingleft-1" style="width: 555.438px;"><li><p><strong style="font-size: 15px;letter-spacing: 0.544px;outline: 0px;visibility: visible;">生产实践方面：</strong><br></p><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;">将继续推进云原生技术在企业中的应用和发展，加强容器化和微服务能力，探索和实践最新的容器化和微服务技术，基于此实践积极向上游提供反馈，最终提高我们自身的业务交付效率和用户体验。</span></p></li></ul><p style="outline: 0px;visibility: visible;"><br></p><ul class="list-paddingleft-1" style="width: 555.438px;"><li><p style="outline: 0px;visibility: visible;"><strong><span style="font-size: 15px;">社区贡献方面：</span></strong></p><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;">以企业中应用云原生技术遇到的实际问题为推动力，加强与 CNCF 组织和其他企业的技术交流与合作，积极参与 CNCF 项目开发和相关工作组的贡献并传播云原生技术<span style="font-size: 15px;letter-spacing: 0.544px;">。</span></span><span style="font-size: 15px;letter-spacing: 0.544px;"></span></p></li></ul></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;text-wrap: wrap;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;visibility: visible;"><section style="padding-bottom: 3px;outline: 0px;display: inline-block;vertical-align: middle;border-bottom: 1px solid rgb(65, 95, 255);border-top-color: rgb(65, 95, 255);border-right-color: rgb(65, 95, 255);border-left-color: rgb(65, 95, 255);visibility: visible;"><section style="outline: 0px;border-bottom: 3px solid rgb(65, 95, 255);border-top-color: rgb(65, 95, 255);border-right-color: rgb(65, 95, 255);border-left-color: rgb(65, 95, 255);font-size: 16px;color: rgb(65, 95, 255);visibility: visible;"><p style="outline: 0px;visibility: visible;">关于 CNCF</p></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br style="outline: 0px;letter-spacing: 0.578px;visibility: visible;"></p><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);line-height: 1.5;visibility: visible;"><p style="outline: 0px;text-align: left;visibility: visible;"><img class="rich_pages wxw-img js_insertlocalimg" data-cropselx1="0" data-cropselx2="200" data-cropsely1="0" data-cropsely2="77" data-imgfileid="100014263" data-ratio="0.16574074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/55ece88a-d979-4dbb-941c-1ed46907bd24.jpg" data-type="png" data-w="1080" style="outline: 0px;visibility: visible !important;width: 465px;height: 77px;" referrerpolicy="no-referrer"></p></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;justify-content: flex-start;display: flex;flex-flow: row;visibility: visible;"><section style="padding-left: 8px;outline: 0px;display: inline-block;width: 578px;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;align-self: flex-start;flex: 0 0 auto;visibility: visible;"><section powered-by="xiumi.us" style="outline: 0px;color: rgba(0, 0, 0, 0.5);text-align: justify;visibility: visible;"><p style="outline: 0px;visibility: visible;">使命：让云原生无处不在</p></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br style="outline: 0px;visibility: visible;"></p><section powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);"><p style="outline: 0px;">CNCF 云原生计算基金会 (Cloud Native Computing Foundation, https://www.cncf.io/）成立于 2015 年 12 月，是非营利性 Linux 基金会（https://www.linuxfoundation.org/）的一部分，其使命是「让云原生技术无处不在」（参考 CNCF 章程 ）。</p><p style="outline: 0px;"><br style="outline: 0px;"></p><p style="outline: 0px;">CNCF 致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术，托管全球技术基础设施的关键组件。通过将最前沿的模式民主化，让这些创新为大众所用。CNCF 汇集了世界顶级的开发者、最终用户和供应商，并举办了最大的开源开发者大会。</p><p style="outline: 0px;"><br></p><p style="outline: 0px;"><span style="letter-spacing: 0.544px;text-align: center;">相关资料：</span></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p>Linux 基金会</p><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linuxfoundation.org%2F" textvalue="https://www.linuxfoundation.org/" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.linuxfoundation.org/</a></p></li><li><p>CNCF 云原生计算基金会</p><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io%2F" textvalue="https://www.cncf.io/" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.cncf.io/</a></p></li><li><p>CNCF 章程</p></li></ul><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcncf%2Ffoundation%2Fblob%2Fmain%2Fcharter.md" textvalue="https://github.com/cncf/foundation/blob/main/charter.md" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://github.com/cncf/foundation/blob/main/charter.md</a></p><p><br></p></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;"><section style="padding: 3px;outline: 0px;display: inline-block;border-bottom: 1px solid rgb(65, 95, 255);color: rgb(65, 95, 255);"><p style="outline: 0px;">关注我们</p></section></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;justify-content: flex-start;display: flex;flex-flow: row;"><section style="padding: 22px;outline: 0px;display: inline-block;width: 677px;vertical-align: top;align-self: flex-start;flex: 0 0 auto;background-color: rgb(247, 247, 247);"><section powered-by="xiumi.us" style="outline: 0px;text-align: justify;"><ul class="list-paddingleft-1" style="padding-left: 40px;outline: 0px;list-style-position: outside;"><li style="outline: 0px;"><p style="outline: 0px;">【移动 OSS】</p><p style="outline: 0px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopensource.vivo.com%2F" textvalue="https://opensource.vivo.com" linktype="text" imgurl="" tab="outerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">https://opensource.vivo.com</a></p></li><li style="outline: 0px;"><p style="outline: 0px;">【互联网 OSS】</p><p style="outline: 0px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvivo" textvalue="https://github.com/vivo&nbsp;" linktype="text" imgurl="" tab="outerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">https://github.com/vivo&nbsp;</a></p></li><li style="outline: 0px;"><p style="outline: 0px;">【<span style="outline: 0px;letter-spacing: 0.578px;">开源频道</span>】@vivo 互联网技术&nbsp;&nbsp;<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26action%3Dgetalbum%26album_id%3D2951473838086422533%23wechat_redirect" textvalue="#开源&nbsp;" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">#开源&nbsp;</a></p></li></ul></section></section></section><p><br></p><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互联网技术" data-alias="vivoVMIC" data-signature="分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 03:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10448921</guid>
            <link>https://my.oschina.net/vivotech/blog/10448921</link>
            <author>
                <![CDATA[vivo 互联网技术]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[飞致云开源社区月度动态报告（2023 年 12 月）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#000000; text-align:start"><span><span style="color:#000000">自 2023 年 6 月起，中国领先的开源软件公司 FIT2CLOUD 飞致云以月度为单位发布《飞致云开源社区月度动态报告》，旨在向广大社区用户同步飞致云旗下系列开源软件的发展情况，以及当月主要的产品新版本发布、社区运营成果等相关信息。</span></span></p><p style="color:#000000; text-align:start"><span><strong><span style="color:#00355d">飞致云开源大屏（2023 年 12 月）</span></strong></span></p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-ce20816fb99437841e5fd716dc8614c9a48.png" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:start"><span>▲图 1 飞致云开源大屏（2023.12.29 12:00）</span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">2023 年 12 月飞致云开源软件运营数据概览（统计时间为 2023.12.1～2023.12.29）</span></span></p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-7f1d375b645d195bf7e8b90007275b91588.png" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:center"><strong><span style="color:#3370ff">2023 年 12 月产品发布事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 开源建站工具</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 1 日，强大易用的开源建站工具 Halo 正式发布 2.11.0 版本。在这一版本中，Halo 新增个人中心功能，将所有和用户自身相关的功能移动到个人中心。同时，Halo 进行了 50 多项功能优化和问题修复。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ DataEase 开源数据可视化分析工具</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 11 日，DataEase 开源数据可视化分析平台正式发布 v2.1.0 版本。</p><p style="color:#000000; text-align:start">这一版本的功能升级包括：新增模板中心，用户可以通过模板中心的模板快速创建仪表板和数据大屏；新增「系统设置」功能模块，该模块包含系统参数、认证设置、嵌入式管理、平台对接四个子模块。在「系统参数」子模块中，用户可以对常用的系统设置项进行管理，「认证设置」子模块支持 CAS（中央认证服务）、LDAP（轻量级目录访问协议）、OIDC（开放 ID 连接）等常用认证协议的对接，在「嵌入式管理」子模块中用户可以创建嵌入式应用，通过嵌入式应用将 DataEase 嵌入到第三方平台中，「平台对接」子模块目前已支持飞书平台的接入，用户可以通过飞书扫码的方式快速登录到 DataEase 平台；数据准备方面，新版 DataEase 支持数据集和数据源的复制功能，方便用户快速创建类似的数据资源。</p><p style="color:#000000; text-align:start">此外，DataEase 开源项目组还对其他一些常用的功能进行了功能优化和问题修复。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 1Panel 开源面板</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 18 日，现代化、开源的 Linux 服务器运维管理面板 1Panel 正式发布 v1.9.0 版本。</p><p style="color:#000000; text-align:start">在这一版本中，1Panel 引入了新的工具箱管理功能，包含 Swap 分区管理、Fail2Ban 管理等功能。此外，1Panel 针对网站证书管理功能进行了全面重构，现在支持添加 ZeroSSL、BuyPass 和 Google Cloud 等 ACME 账户，还新增了 GoDaddy、Name.com、NameCheap、NameSilo 等 DNS 账户。在申请证书时，系统支持多种加密算法，能够创建自签名证书，并且提供证书的上传、下载功能，用户还可以批量删除证书，将证书推送至本地目录。容器配置页面也新增了与 IPv6 相关的配置选项。</p><p style="color:#000000; text-align:start">此外，1Panel 开源项目组还进行了 70 多项功能更新和问题修复。1Panel 应用商店新增了 10 款应用，并且更新了 20 款应用。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ JumpServer 开源堡垒机</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 25 日，JumpServer 开源堡垒机正式发布 v3.10 LTS（Long Term Support）版本。JumpServer 开源项目组将对 v3.10 LTS 版本提供长期支持，定期迭代发布小版本，持续进行问题修复更新并针对部分功能进行优化。欢迎广大用户升级使用 v3.10 LTS 版本。</p><p style="color:#000000; text-align:start">在这一版本中，JumpServer 重构了「标签」功能，支持全局标签管理，赋予了「标签」更为灵活、更为强大的功能。从 JumpServer v3.10.0 版本开始，「标签」不仅能绑定到资产上，还能够绑定到其他资源上，让其他资源通过「标签」功能拥有额外的功能属性。同时，JumpServer 新增 Chat AI 小助手功能，支持对接 ChatGPT，实现了多个用户可以在 JumpServer 浏览器功能界面直接与 ChatGPT 进行对话的能力，极大地提高了用户的使用率及工作效率。</p><p style="color:#000000; text-align:start">另外，「账号收集」功能支持将远程服务器中不存在的账户进行同步删除；「文件管理」功能支持批量传输文件，将批量命令和批量传输文件集中到工作台界面。这样一来，管理员可以让资产功能以更加方便的方式直接暴露给用户使用。</p><p style="color:#000000; text-align:start">X-Pack 增强包方面，JumpServer 支持第三方客户端直连 SQL Server 数据库，支持 Slack 平台的用户认证及消息通知功能。同时，新版本 JumpServer 还支持配置备案信息至登录页面，支持使用 Linux 系统作为远程应用发布机。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ MeterSphere 开源持续测试平台</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 28 日，MeterSphere 开源持续测试平台发布 v2.10.10 LTS 版本。</p><p style="color:#000000; text-align:start">在这一版本中，UI 测试方面，新增文件上传限制、添加关联文件时过滤已存在关联关系的文件；测试跟踪方面，在用例评审时支持左侧模块树功能、表头默认不显示所属模块字段、本地附件转存文件库时排除第三方存储库模块；接口测试方面，去除接口定义路径结尾的空格、接口自动化表头增加所属模块字段。此外，MeterSphere 项目组还进行了 8 项功能优化和 22 项漏洞修复工作。</p><p style="color:#000000; text-align:center"><strong><span style="color:#3370ff">其他重要事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 飞致云与上海吉谛达成战略合作，获得 Gitea 企业版中国大陆地区独家代理权</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 13 日，FIT2CLOUD 飞致云宣布与上海吉谛达成战略合作，FIT2CLOUD 飞致云获得上海吉谛旗下代码托管平台 Gitea 企业版中国大陆地区独家代理权。</p><p style="color:#000000; text-align:start">在 Gitea 社区版的基础之上，Gitea 企业版提供面向企业级应用场景的 X-Pack 增强包及企业级支持服务，有效助力企业快速构建并运营自托管的新一代代码托管平台。</p><p style="color:#000000; text-align:start">Gitea v1.21 版本的企业版软件已经于 2023 年 11 月正式发布，首批开放的 X-Pack 增强包功能包括：企业微信/钉钉/飞书对接集成、供应链安全扫描、数据安全备份、分布式部署架构和国产化信创适配等。</p><p style="color:#000000; text-align:start"><img alt="" height="608" src="https://oscimg.oschina.net/oscnet/up-d57c9939ebd603754752cc23d2f9e9aca95.jpg" width="1080" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:start"><span>▲ 图 2 飞致云与上海吉谛达成战略合作</span></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ FIT2CLOUD 飞致云荣膺「2023 年度 OSCHINA 优秀开源技术团队」奖项</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 8 日，知名开源技术社区 OSCHINA（开源中国）公布了「2023 年度 OSCHINA 优秀开源技术团队」入选名单。凭借在开源软件研发和开源社区运营方面的年度优异表现，FIT2CLOUD 飞致云再次收获「优秀开源技术团队」奖项。这也是继 2021 年和 2022 年之后，FIT2CLOUD 飞致云连续第三年荣膺该项荣誉。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ JumpServer 开源堡垒机 V2 社区版即将停止维护的通知</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 1 日，JumpServer 开源项目组发布重要通知。如《关于 JumpServer 开源堡垒机 V2 版本产品生命周期的相关说明》所示，JumpServer 开源堡垒机 V2 版本（社区版）将于 2023 年 12 月 31 日停止维护支持。</p><p style="color:#000000; text-align:start">出于产品自身迭代和用户需求升级的要求，2023 年 2 月 27 日，JumpServer 开源堡垒机正式发布 v3.0 版本，目前已更新至 v3.10 LTS 版本。JumpServer 开源项目组建议社区版和企业版用户更新至 JumpServe v3.x 版本，以使用更多的新增功能并获取更好的软件使用体验。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 推出 AI 助手插件</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 15 日，Halo AI 助手插件上线。AI 助手插件通过扩展编辑器功能，为 Halo 默认编辑器带来了丰富的 AI 辅助功能。用户可以通过选中文字或者使用/命令的方式快速呼出 AI 对话框。AI 助手插件目前使用 OpenAI 的接口来提供 AI 能力支持，用户可以自定义 OpenAI 接口地址，选择切换不同的模型或者在网络不通的情况下配置代理使用。用户访问 Halo 应用市场，即可下载体验 Halo AI 助手插件。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ DataEase 漏洞通知及修复方案（DE-2023.12.19）</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 19 日，DataEase 项目组发布了编号为「DE-2023.12.19」的漏洞通知及修复方案，请用户尽快将 DataEase 升级至 v1.18.11 及以后的版本。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 1.x 停止维护公告</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 21 日，Halo 开源项目组发布《Halo 1.x 停止维护公告》。为了集中资源和精力去持续改进和维护 Halo 的最新版本，Halo 1.x 版本将于 2023 年 12 月 31 日停止维护。Halo 开源项目组提供了详细的从 1.x 版本迁移到 2.x 版本的升级指南，您可以访问官方文档：《从 Halo 1.x 迁移》<span style="color:#172b4d">（</span>https://docs.halo.run/getting-started/migrate-from-1.x/<span style="color:#172b4d"><span>&nbsp;</span>）</span>来了解详情。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">关于飞致云开源大屏</span></strong></p><p style="color:#000000; text-align:start">飞致云开源大屏（https://bi.fit2cloud.com/link/6CgpMHrT）是 FIT2CLOUD 飞致云为展示其旗下开源软件的社区运营情况制作的数据仪表板。该大屏使用 DataEase 开源数据可视化分析平台制作，实时呈现飞致云开源社区近 30 日内的动态信息。</p><p style="color:#000000; text-align:start">广大社区用户可以通过该大屏了解飞致云旗下开源项目的 GitHub Star、Fork、Issue、贡献者等指标的数量信息，以及近 30 日内新增的 Star、Fork、下载、Issue、PR 数量等，同时该大屏还展示了飞致云旗下开源项目的 Issue 趋势、Commit 趋势、PR 趋势、Issue 生命周期等。</p><p style="color:#000000; text-align:start">除了展示所有项目的汇总信息外，该大屏还支持用户分类别查看 JumpServer、DataEase、MeterSphere、Halo、1Panel、CloudExplorer Lite 六个开源项目的独立运营数据。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4736111/blog/10469745</guid>
            <link>https://my.oschina.net/u/4736111/blog/10469745</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[关于编程模式的总结与思考]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;visibility: visible;" data-mpa-powered-by="yiban.io"><img class="rich_pages wxw-img __bg_gif" data-backh="96" data-backw="578" data-cropselx1="0" data-cropselx2="578" data-cropsely1="0" data-cropsely2="96" data-imgfileid="503041828" data-ratio="0.16666666666666666" src="https://oscimg.oschina.net/oscnet/7f3f91e3-bb2b-4b44-a874-fe03bc749ab0.gif" data-type="gif" data-w="636" style="outline: 0px;letter-spacing: 0.544px;font-size: var(--articleFontsize);border-radius: 8px;text-align: justify;width: 677px;visibility: visible !important;background-size: 16px !important;" referrerpolicy="no-referrer"><br style="outline: 0px;visibility: visible;"></section><section data-mpa-template="t" data-mpa-template-id="502" data-mpa-category="模板" style="outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);visibility: visible;"><section data-mpa-category="模板" data-mid="" style="padding-right: 1px;padding-left: 1px;outline: 0px;width: 677px;display: flex;justify-content: flex-start;align-items: center;flex-direction: column;visibility: visible;"><section data-mid="" style="outline: 0px;letter-spacing: 0.544px;width: 675px;display: grid;grid-template-columns: 26px auto;visibility: visible;"><section data-mid="" style="outline: 0px;width: 26px;height: 14px;display: flex;justify-content: center;align-items: center;align-self: center;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section><section data-mid="" style="padding-left: 7px;outline: 0px;display: flex;justify-content: flex-start;align-items: center;visibility: visible;"><section data-mid="" style="margin-right: 7px;outline: 0px;text-align: left;visibility: visible;"><p data-mid="" style="outline: 0px;width: 0px;font-size: 14px;font-family: PingFangSC-Semibold, &quot;PingFang SC&quot;;font-weight: bold;color: rgb(58, 92, 244);line-height: 20px;visibility: visible;"><br style="outline: 0px;visibility: visible;"></p></section><section data-mid="" style="margin-bottom: 4px;outline: 0px;width: 635px;height: 1px;border-top: 1px solid rgb(58, 92, 244);align-self: flex-end;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section></section></section><section data-mid="" style="padding: 7px 14px 9px 19px;outline: 0px;width: 675px;text-align: left;border-bottom: 1px solid rgb(58, 92, 244);visibility: visible;"><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;letter-spacing: 0.578px;text-align: justify;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;white-space-collapse: preserve;text-size-adjust: inherit;text-align: left;caret-color: rgb(23, 26, 29);letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;color: rgb(0, 0, 0);visibility: visible;font-size: 15px;">淘宝创新业务的<span style="font-size: 15px;letter-spacing: 1px;text-wrap: wrap;">优化迭代是非常高频且迅速的，</span><span style="font-size: 15px;letter-spacing: 1px;text-wrap: wrap;">在这过程中要求技术也必须是快且稳的，而为了适应这种快速变化的节奏，我们在项目开发过程中采用了一些面向拓展以及敏捷开发的设计，</span><span style="font-size: 15px;letter-spacing: 1px;text-wrap: wrap;">本文旨在总结并思考其中一些通用的编程模式。</span></span></p></section></section></section><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;line-height: 1.75em;"><br style="outline: 0px;visibility: visible;"></p><section style="margin-bottom: 0px;outline: 0px;box-sizing: inherit;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgba(25, 26, 31, 0.9);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 16px;text-align: center;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041829" data-ratio="0.3161764705882353" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b90357ce-619d-4abb-a361-96e0ffebccdd.png" data-type="png" data-w="408" style="outline: 0px;color: rgb(34, 34, 34);font-family: system-ui, -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;visibility: visible !important;width: 113px !important;" referrerpolicy="no-referrer"></span></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(34, 34, 34);text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;color: rgb(3, 69, 255);font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;visibility: visible;">前言</span></section><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">静心守护业务是淘宝今年 4 月份启动的创新项目，项目的核心逻辑是通过敲木鱼、冥想、盘手串等疗愈玩法为用户带来内心宁静的同时推动文物的保护与修复，进一步弘扬我们的传统文化。</span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">作为创新项目，业务形态与产品方案的优化迭代是非常高频且迅速的：项目从 4 月底投入开发到 7 月份最终外灰，整体方案经历过大的推倒重建，也经历过多轮小型重构优化，项目上线后也在做持续的迭代优化甚至改版升级。</span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section style="margin-bottom: 0px;outline: 0px;box-sizing: inherit;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgba(25, 26, 31, 0.9);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 16px;text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;font-size: 15px;letter-spacing: 1px;visibility: visible;"><img class="rich_pages wxw-img" data-imgfileid="503041833" data-ratio="0.3056872037914692" data-s="300,640" src="https://oscimg.oschina.net/oscnet/0f807f04-facf-4eba-bf80-54b3dc2b020a.png" data-type="png" data-w="422" style="outline: 0px;color: rgb(34, 34, 34);font-family: system-ui, -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;visibility: visible !important;width: 117px !important;" referrerpolicy="no-referrer"></span></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(34, 34, 34);text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;visibility: visible;color: rgb(0, 17, 255);">模式清单</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><span id="OSC_h4_1"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">基于 Spring 容器与反射的策略模式</span></strong></span></h4><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">策略模式是一种经典的行为设计模式，它的本质是定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换，后续也能根据需要灵活拓展出新的算法。这里推荐的是一种基于 Spring 容器和反射结合的策略模式，这种模式的核心思路是：每个策略模式的实现都是一个 bean，在 Spring 容器启动时基于反射获取每个策略场景的接口类型，并基于该接口类型再获取此类型的所有策略实现 bean 并记录到一个 map（key 为该策略 bean 的唯一标识符，value 为 bean 对象）中，后续可以自定义路由策略来从该 map 中获取 bean 对象并使用相应的策略。</span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h4_2"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">模式解构</span></h4></li></ul><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">模式具体实现方式大致如下面的 UML 类图所描述的：</span></p><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><img class="rich_pages wxw-img" data-backh="258" data-backw="578" data-imgfileid="503041831" data-ratio="0.4462962962962963" src="https://oscimg.oschina.net/oscnet/d8f41f29-554a-49b5-b29f-5130f4805640.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></section><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">其中涉及的各个组件及作用分别为：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>Handler</strong>（<em>interface</em>）：策略的顶层接口，定义的 type 方法表示策略唯一标识的获取方式。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>HandlerFactory</strong>（<em>abstract class</em>）：策略工厂的抽象实现，封装了反射获取 Spring bean 并维护策略与其标识映射的逻辑，但不感知策略的真实类型。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>AbstractHandler</strong>（<em>interface or abstracr class</em>）：各个具体场景下的策略接口定义，该接口定义了具体场景下策略所需要完成的行为。如果各个具体策略实现有可复用的逻辑，可以结合模版方法模式在该接口内定义模版方法，如果模板方法依赖外部 bean 注入，则该接口的类型需要为<em>abstract class</em>，否则为<em>interface</em>即可。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>HandlerImpl</strong>（<em>class</em>）：各个场景下策略接口的具体实现，承载主要的业务逻辑，也可以根据需要横向拓展。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>HandlerFactoryImpl</strong>（<em>class</em>）：策略工厂的具体实现，感知具体场景策略接口的类型，如果有定制的策略路由逻辑也可以在此实现。</span></p></li></ol><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(68, 68, 68);font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(68, 68, 68);font-size: 15px;letter-spacing: 1px;">这种模式的主要优点有：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(68, 68, 68);">策略标识维护自动化</span></strong><span style="color: rgb(68, 68, 68);">：策略实现与标识之间的映射关系完全委托给 Spring 容器进行维护（在</span><em><span style="color: rgb(68, 68, 68);">HandlerFactory</span></em><span style="color: rgb(68, 68, 68);">中封装，每个场景的策略工厂直接继承该类即可，无需重复实现），后续新增策略不用再手动修改关系映射。</span></span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(68, 68, 68);">场景维度维护标识映射</span></strong><span style="color: rgb(68, 68, 68);">：</span><em><span style="color: rgb(68, 68, 68);">HandlerFactory</span></em><span style="color: rgb(68, 68, 68);">中在扫描策略 bean 时是按照</span><em>AbstractHandler</em>的类型来分类维护的，从而避免了不同场景的同名策略发生冲突。</span></p></li><li><section style="margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(68, 68, 68);">策略接口按场景灵活定义</span></strong><span style="color: rgb(68, 68, 68);">：具体场景的策略行为定义在</span><em><span style="color: rgb(68, 68, 68);">AbstractHandler</span></em><span style="color: rgb(68, 68, 68);">中，在这里可以根据真实的业务需求灵活定义行为，甚至也可以结合其他设计模式做进一步抽象处理，在提供灵活拓展的同时减少重复代码。</span></span></section></li></ol><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_3"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">实践案例分析</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">该模式在静心守护项目中的许多功能模块都有使用，下面以称号解锁模块为例来介绍其实际应用。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">我们先简单了解下该模块的业务背景：静心守护的成就体系中有一类是称号，如下图。用户可以通过多种行为去解锁不同类型的称号，比如说通过参与主玩法（敲木鱼、冥想、盘手串），主玩法参与达到一定次数后即可解锁特定类型的称号。当然后续也可能会有其他种类的称号：比如签到类（按照用户签到天数解锁）、捐赠类（按照用户捐赠项目的行为解锁），所以对于称号的解锁操作应该是面向未来可持续拓展的。</span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: center;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041832" data-ratio="2" src="https://oscimg.oschina.net/oscnet/62c7ac5c-2a9c-4a65-b420-4efbd4b250fb.png" data-type="png" data-w="500" referrerpolicy="no-referrer"></span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">基于这样的思考，我选择使用上面的策略模式去实现称号解锁模块。该模块的核心类图组织如下：</span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><img class="rich_pages wxw-img" data-backh="259" data-backw="578" data-imgfileid="503041830" data-ratio="0.44722222222222224" src="https://oscimg.oschina.net/oscnet/5ead0c97-1223-42ec-90dc-be4c054fa964.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">下面是其中部分核心代码的分析解读：</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer">public interface Handler&lt;T&gt; {</span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * handler 类型</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    T type();</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><span style="color: rgb(68, 68, 68);">如上文所说，</span><em><span style="color: rgb(68, 68, 68);">Handler</span></em><span style="color: rgb(68, 68, 68);">是策略的顶层抽象，它只定义了</span><em><span style="color: rgb(68, 68, 68);">type</span></em><span style="color: rgb(68, 68, 68);">方法，该方法用于获取策略的标识，标识的类型支持子接口定义。</span></span></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 15px;color: rgb(68, 68, 68);"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">public abstract class HandlerFactory&lt;T, H extends Handler&lt;T&gt;&gt; implements InitializingBean, ApplicationContextAware {</span></code><code><span class="code-snippet_outer">    private Map&lt;T, H&gt; handlerMap;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    private ApplicationContext appContext;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 根据 type 获得对应的 handler</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param type</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public H getHandler(T type) {</span></code><code><span class="code-snippet_outer">        return handlerMap.get(type);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 根据 type 获得对应的 handler，支持返回默认</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param type</span></code><code><span class="code-snippet_outer">     * @param defaultHandler</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public H getHandlerOrDefault(T type, H defaultHandler) {</span></code><code><span class="code-snippet_outer">        return handlerMap.getOrDefault(type, defaultHandler);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 反射获取泛型参数 handler 类型</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @return handler 类型</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    @SuppressWarnings("unchecked")</span></code><code><span class="code-snippet_outer">    protected Class&lt;H&gt; getHandlerType() {</span></code><code><span class="code-snippet_outer">        Type type = ((ParameterizedType)getClass().getGenericSuperclass()).getActualTypeArguments()[1];</span></code><code><span class="code-snippet_outer">        //策略接口使用了范型参数</span></code><code><span class="code-snippet_outer">        if (type instanceof ParameterizedTypeImpl) {</span></code><code><span class="code-snippet_outer">            return (Class&lt;H&gt;) ((ParameterizedTypeImpl)type).getRawType();</span></code><code><span class="code-snippet_outer">        } else {</span></code><code><span class="code-snippet_outer">            return (Class&lt;H&gt;) type;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public void afterPropertiesSet() {</span></code><code><span class="code-snippet_outer">        // 获取所有 H 类型的 handlers</span></code><code><span class="code-snippet_outer">        Collection&lt;H&gt; handlers = appContext.getBeansOfType(getHandlerType()).values();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        handlerMap = Maps.newHashMapWithExpectedSize(handlers.size());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        for (final H handler : handlers) {</span></code><code><span class="code-snippet_outer">            log.info("HandlerFactory {}, {}", this.getClass().getCanonicalName(), handler.type());</span></code><code><span class="code-snippet_outer">            handlerMap.put(handler.type(), handler);</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">        log.info("handlerMap:{}", JSON.toJSONString(handlerMap));</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public void setApplicationContext(@Nonnull ApplicationContext applicationContext) throws BeansException {</span></code><code><span class="code-snippet_outer">        this.appContext = applicationContext;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><em>HandlerFactory</em>在前面也提到过，是策略工厂的抽象实现，封装了反射获取具体场景策略接口类型，并查找策略 bean 在内存中维护策略与其标识的映射关系，后续可以直接通过标识或者对应的策略实现。这里有二个细节：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">为什么 HandlerFactory 是<em>abstract class</em>？其实可以看到该类并没有任何抽象方法，直接将其定义为<em>class</em>也不会有什么问题。这里将其定义为<em>abstract class</em>主要是起到实例创建的约束作用，因为我们对该类的定义是工厂的抽象实现，只希望针对具体场景来创建实例，针对该工厂本身创建实例其实是没有任何实际意义的。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><em>getHandlerType</em>方法使用了<em>@SuppressWarnings</em>注解并标记了<em>unchecked</em>。这里也确实是存在潜在风险的，因为<em>Type</em>类型转<em>Class</em>类型属于向下类型转换，是存在风险的，可能其实际类型并非<em>Class</em>而是其他类型，那么此处强转就会出错。这里处理了两种最通用的情况：<em>AbstractHandler</em>是带范型的<em>class</em>和最普通的<em>class</em>。</span></p></li></ol><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(68, 68, 68);font-size: 15px;letter-spacing: 1px;"><br></span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class TitleUnlockHandlerFactory</span></code><code><span class="code-snippet_outer">        extends HandlerFactory&lt;String, BaseTitleUnlockHandler&lt;BaseTitleUnlockParams&gt;&gt; {}</span></code></pre></section><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: start;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><ne-text ne-italic="true" style="font-style: italic;"><span style="font-size: 15px;letter-spacing: 1px;">TitleUnlockHandlerFactory</span></ne-text><ne-text><span style="font-size: 15px;letter-spacing: 1px;">是策略工厂的具体实现，由于不需要在此定制策略的路由逻辑，所以只声明了相关的参数类型，而没有对父类的方法做什么覆盖。</span></ne-text><ne-text></ne-text><span style="display: inline;min-width: 1px;vertical-align: baseline;height: 1em;user-select: none;font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: start;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><ne-text><span style="font-size: 15px;letter-spacing: 1px;"><br></span></ne-text></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">public abstract class BaseTitleUnlockHandler&lt;T extends BaseTitleUnlockParams&gt; implements Handler&lt;String&gt; {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private UserTitleTairManager userTitleTairManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private AchievementCountManager achievementCountManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private UserUnreadAchievementTairManager userUnreadAchievementTairManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 解锁称号</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param params</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public @CheckForNull TitleUnlockResult unlockTitles(T params) {</span></code><code><span class="code-snippet_outer">        TitleUnlockResult titleUnlockResult = this.doUnlock(params);</span></code><code><span class="code-snippet_outer">        if (null == titleUnlockResult) {</span></code><code><span class="code-snippet_outer">            return null;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        List&lt;TitleAchievementVO&gt; titleAchievements = titleUnlockResult.getUnlockedTitles();</span></code><code><span class="code-snippet_outer">        if (CollectionUtils.isEmpty(titleAchievements)) {</span></code><code><span class="code-snippet_outer">            titleUnlockResult.setUnlockedTitles(new ArrayList&lt;&gt;());</span></code><code><span class="code-snippet_outer">            return titleUnlockResult;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //基于注入的 bean 和计算出的称号列表进行后置操作，如：更新成就计数、更新用户称号缓存、更新用户未读成就等</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        return titleUnlockResult;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 计算出要解锁的称号</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param param</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    protected abstract TitleUnlockResult doUnlock(T param);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public abstract String type();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: justify;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><ne-text></ne-text></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><em>BaseTitleUnlockHandler</em>定义了称号解锁行为，并且在此确定了策略标识的类型为<em>String</em>。此外，该类是一个<em>abstract class</em>，是因为该类定义了一个模版方法<em>unlockTitles</em>，在该方法里封装了称号解锁所要进行的一些公共操作，比如更新用户的称号计数、用户的称号缓存数据等，这些都依赖于注入的一些外部 bean，而<em>interface</em>不支持非静态成员变量，所以该类通过<em>abstract class</em>来定义。具体的称号解锁行为通过<em>doUnlock</em>定义，这也是该策略的具体实现类需要实现的方法。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">另外也许你还注意到了<em>doUnlock</em>方法的行参是一个范型参数<em>T</em>，因为我们考虑到了不同类型称号解锁所需要的参数可能是不同的，因此在场景抽象接口侧只依赖于称号解锁的公共参数类型，而在策略接口具体实现侧才与该类型策略的具体参数类型进行耦合。</span></section><section style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: start;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><ne-text><span style="font-size: 15px;letter-spacing: 1px;"><br></span></ne-text></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class GameplayTitleUnlockHandler extends BaseTitleUnlockHandler&lt;GameplayTitleUnlockParams&gt; {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private BlessTitleAchievementDiamondConfig blessTitleAchievementDiamondConfig;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private UserTitleTairManager userTitleTairManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected TitleUnlockResult doUnlock(GameplayTitleUnlockParams params) {</span></code><code><span class="code-snippet_outer">        //获取称号元数据</span></code><code><span class="code-snippet_outer">        List&lt;TitleMetadata&gt; titleMetadata = blessTitleAchievementDiamondConfig.getTitleMetadata();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        if (CollectionUtils.isEmpty(titleMetadata)) {</span></code><code><span class="code-snippet_outer">            return null;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        List&lt;TitleAchievementVO&gt; titleAchievements = new ArrayList&lt;&gt;();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        Result&lt;DataEntry&gt; result = userTitleTairManager.queryRawCache(params.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //用户称号数据查询异常</span></code><code><span class="code-snippet_outer">        if (null == result || !result.isSuccess()) {</span></code><code><span class="code-snippet_outer">            return null;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        if (Objects.equals(result.getRc(), ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer">            //解锁新称号</span></code><code><span class="code-snippet_outer">            titleAchievements = unlockNewTitles(params, titleMetadata);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } else if (Objects.equals(result.getRc(), ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer">            //初始化历史称号</span></code><code><span class="code-snippet_outer">            titleAchievements = initHistoricalTitles(params, titleMetadata);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        TitleUnlockResult titleUnlockResult = new TitleUnlockResult();</span></code><code><span class="code-snippet_outer">        titleUnlockResult.setUserTitleCache(result);</span></code><code><span class="code-snippet_outer">        titleUnlockResult.setUnlockedTitles(titleAchievements);</span></code><code><span class="code-snippet_outer">        return titleUnlockResult;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public String type() {</span></code><code><span class="code-snippet_outer">        return TitleType.GAMEPLAY;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ......</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">上面是一个策略的具体实现类的大致示例，可以看到该实现类核心明确了以下信息：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">策略标识：给出了 type 方法的具体实现，返回了一个策略标识的常量</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">策略处理逻辑：此处是玩法类称号解锁的业务逻辑，读者无需关注其细节</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">称号解锁行参：给出了玩法类称号解锁所需的真实参数类型</span></p></li></ol><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><ne-text><br></ne-text></p><span id="OSC_h4_4"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">抽象疲劳度管控体系</span></strong></span></h4><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">在我们的业务需求中经常会遇到涉及疲劳度管控相关的逻辑，比如每日签到允许用户每天完成 1 次、首页项目进展弹窗要求对所有用户只弹 1 次、首页限时回访任务入口则要对用户每天都展示一次，但用户累计完成 3 次后便不再展示......因此我们设计了一套疲劳度管控的模式，以降低后续诸如上述涉及疲劳度管控相关需求的开发成本。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_5"></span><h3 style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">自顶向下的视角</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">这套疲劳度管控体系的类层次大致如下图：</span></section><section style="min-height: 24px;margin-bottom: 8px;"><img class="rich_pages wxw-img" data-backh="360" data-backw="578" data-imgfileid="503041836" data-ratio="0.6222222222222222" src="https://oscimg.oschina.net/oscnet/f99ffd82-3d9e-4965-aa11-20ecbf3845eb.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" width="4011" referrerpolicy="no-referrer"></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">接下来我们自顶向下逐层进行介绍：</span></section><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">FatigueLimiter（<em>interface</em>）：<em>FatigueLimiter</em>是最顶层抽象的疲劳度管控接口，<span style="text-decoration: underline;">它定义了疲劳度管控相关的行为</span>，比如：疲劳度的查询、疲劳度清空、疲劳度增加、是否达到疲劳度限制的判断等。</span></section></li><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">BaseFatigueLdbLimiter（<em>abstract class</em>）：疲劳度数据的存储方案可以是多种多样的，在我们项目中主要利用 ldb 进行疲劳度存储，而<em>BaseFatigueLdbLimiter</em>正是基于 ldb【注：阿里内部自研的一款持久化 k-v 数据库，读者可将其理解为类似 level db 的项目】对疲劳度数据进行管控的抽象实现，它封装了 ldb 相关的操作，并基于 ldb 的数据操作实现了<em>FatigueLimiter</em>的疲劳度管控方法。但它并不感知具体业务的身份和逻辑，因此定义了几个业务相关的方法交给下层去实现，分别是：</span></section></li><ul ne-level="1" class="list-paddingleft-1" style="padding-left: 23px;list-style-position: initial;list-style-image: initial;"><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">scene：标识具体业务的场景，会利用该方法返回值去构造 Ldb 存储的 key</span></section></li><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">buildCustomKey：对 Ldb 存储 key 的定制逻辑</span></section></li><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">getExpireSeconds：对应着 Ldb 存储 kv 失效时间，对应着疲劳度的管控周期</span></section></li></ul><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">Ldb 周期性疲劳度管控的解决方案层（<em>abstract class</em>）：在这一层提供了多种周期的开箱即用的疲劳度管控实现类，如<em>BaseFatigueDailyLimiter</em>提供的是天级别的疲劳度管控能力，<em>BaseFatigueNoCycleLimiter</em>则表示疲劳度永不过期，而<em>BaseFatigueCycleLimiter</em>则支持用户实现 cycle 方法定制疲劳度周期。</span></section></li><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">业务场景层：这一层则是各个业务场景对疲劳度管控的具体实现，实现类只需要实现 scene 方法来声明业务场景的身份标识，随后继承对应的解决方案，即可实现快速的疲劳度管控。比如上面的 DailyWishSign<em>Limiter</em>就对应着本篇开头我们所说的「每日签到允许用户每天完成 1 次」，这就要求为用户的签到行为以天维度构建 key 同时失效时间也为 1 天，因此直接继承解决方案层的<em>BaseFatigueDailyLimiter</em>即可。其代码实现非常简单，如下：</span></section></li></ol><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class DailyWishSignLimiter extends BaseFatigueLdbDailyLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected String scene() {</span></code><code><span class="code-snippet_outer">        return LimiterScene.dailyWish;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_6"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">有一个「异类」</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">也许你注意到了上面的类层次图中有一个「异类」——HomeEnterGuideLimiter。它其实就是我们在上文说的「首页限时回访任务入口则要对用户每天都展示一次，但用户累计完成 3 次后便不再展示」，它的逻辑其实也很简单：因为它有 2 条管控条件，所以需要继承 2 个管控周期的解决方案——天维度和永久维度，最后实际使用的类再聚合了天维度和永久维度的实现类（每个实现类对应 ldb 的一类 key）并实现了顶层的疲劳度管控接口，标识这也是一个疲劳度管理器。它们的代码如下：</span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 首页入口引导限时任务-天级疲劳度管控</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class HomeEnterGuideDailyLimiter extends BaseFatigueLdbDailyLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected String scene() {</span></code><code><span class="code-snippet_outer">        return LimiterScene.homeEnterGuide;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 首页入口引导限时任务-总次数疲劳度管控</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class HomeEnterGuideNoCycleLimiter extends BaseFatigueLdbNoCycleLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected String scene() {</span></code><code><span class="code-snippet_outer">        return LimiterScene.homeEnterGuide;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected int maxSize() {</span></code><code><span class="code-snippet_outer">        return 3;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 首页入口引导限时任务-疲劳度服务</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class HomeEnterGuideLimiter implements FatigueLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private FatigueLimiter homeEnterGuideDailyLimiter;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private FatigueLimiter homeEnterGuideNoCycleLimiter;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public boolean isLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        return homeEnterGuideNoCycleLimiter.isLimit(customKey) || homeEnterGuideDailyLimiter.isLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public Integer incrLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        homeEnterGuideDailyLimiter.incrLimit(customKey);</span></code><code><span class="code-snippet_outer">        return homeEnterGuideNoCycleLimiter.incrLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public boolean isLimit(Integer fatigue) {</span></code><code><span class="code-snippet_outer">        throw new UnsupportedOperationException();</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public Map&lt;String, Integer&gt; batchQueryLimit(List&lt;String&gt; keys) {</span></code><code><span class="code-snippet_outer">        throw new UnsupportedOperationException();</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public void removeLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        homeEnterGuideDailyLimiter.removeLimit(customKey);</span></code><code><span class="code-snippet_outer">        homeEnterGuideNoCycleLimiter.removeLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public Integer queryLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        throw new UnsupportedOperationException();</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 查询首页限时任务的每日疲劳度</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param customKey 用户自定义 key</span></code><code><span class="code-snippet_outer">     * @return 疲劳度计数</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public Integer queryDailyLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        return homeEnterGuideDailyLimiter.queryLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 查询首页限时任务的全周期疲劳度</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param customKey 用户自定义 key</span></code><code><span class="code-snippet_outer">     * @return 疲劳度计数</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public Integer queryNoCycleLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        return homeEnterGuideNoCycleLimiter.queryLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><span id="OSC_h4_7"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">函数式行为参数化</span></strong></span></h4><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"></h4><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">Java 21 在今年 9 月份发布了，而距离 Java 8 发布已经过去 9 年多了，但也许，我是说也许......我们有些同学对 Java 8 还是不太熟悉......</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_8"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">再谈行为参数化</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">最早听到「行为参数化」这个词是在经典的 Java 技术书籍《Java 8 实战》中。在此书中，作者以一个筛选苹果的案例，基于行为参数化的思维一步步优化重构代码，在提升代码抽象能力的同时，保证了代码的简洁性和可读性，而其中的秘密武器就是 Java 8 所引入的 Lambda 表达式和函数式接口。Java 8 发布已经 9 年，对于 Lambda 表达式，大多数同学都已经耳熟能详，但函数式接口也许有同学不知道代表着什么。简单来说，如果一个接口，它只有一个没有被实现的方法，那它就是函数式接口。java.lang.function 包下定义 JDK 提供的一系列函数式接口。如果一个接口是函数式接口，推荐用@FunctionalInterface 注解来显式标明。那函数式接口有什么用呢？如果一个方法的行参里有函数式接口，那么函数式接口对应的参数可以支持传递 Lambda 表达式或者方法引用。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">那何为「行为参数化」？直观地来说就是将行为作为方法/函数的参数来进行传递。在 Java 8 之前，这可以通过匿名类实现，而在 Java 8 以后，可以基于函数式特性来实现行为参数化，即方法参数定义为函数式接口，在具体传参时使用 Lambda 表达式/方法。相比匿名类，后者在简洁性上有极大的提升。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">在我们的日常开发中，如果我们看到两个方法的结构十分相似，只有其中部分行为存在差别，那么就可以考虑采用函数式的行为参数化来重构优化这段代码，将其中存在差异的行为抽象成参数，从而减少重复代码。</span></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_9"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">从实践中来，到代码中去</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">下面给出一个例子。在静心守护项目中，我们基于 ldb 维护了用户未读成就的列表，在用户进入到个人成就页时，会查询未读成就数据，并对未读的成就在成就列表进行置顶以及加红点展示。下面是对用户未读成就列表进行新增和清除的两个方法：</span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 清除未读成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid             用户 ID</span></code><code><span class="code-snippet_outer"> * @param achievementType 需要清除未读成就列表的成就类型</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean clearUnreadAchievements(long uid, Set&lt;String&gt; achievementTypes) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (CollectionUtils.isEmpty(achievementTypes)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    Result&lt;DataEntry&gt; ldbRes = super.rawGet(buildKey(uid), false);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //用户称号数据查询失败</span></code><code><span class="code-snippet_outer">    if (Objects.isNull(ldbRes)) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">        return false;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    boolean success = false;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ResultCode resultCode = ldbRes.getRc();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //不存在用户称号数据则进行初始化</span></code><code><span class="code-snippet_outer">    if (Objects.equals(resultCode, ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer">    UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">        achievementTypes.forEach(type -&gt; clearCertainTypeIds(userUnreadAchievementsCache, type));</span></code><code><span class="code-snippet_outer">        success = putCache(uid, userUnreadAchievementsCache, DEFAULT_VERSION);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    } else if (Objects.equals(resultCode, ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        DataEntry ldbEntry = ldbRes.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //存在新数据则对其进行更新</span></code><code><span class="code-snippet_outer">        if (Objects.nonNull(ldbEntry)) {</span></code><code><span class="code-snippet_outer">            Object data = ldbEntry.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            if (data instanceof String) {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = JSON.parseObject(String.valueOf(data), UserUnreadAchievementsCache.class);</span></code><code><span class="code-snippet_outer">                achievementTypes.forEach(type -&gt; clearCertainTypeIds(userUnreadAchievementsCache, type))</span></code><code><span class="code-snippet_outer">                success = putCache(uid, userUnreadAchievementsCache, ldbEntry.getVersion());</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    //缓存解锁的称号失败</span></code><code><span class="code-snippet_outer">    if (!success) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    return success;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 写入新的未读成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid                  用户 ID</span></code><code><span class="code-snippet_outer"> * @param achievementTypeIdMap 需要新增的成就类型和成就 ID 列表的映射</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean writeUnreadAchievements(long uid, Map&lt;String, List&lt;String&gt;&gt; achievementTypeIdMap) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (MapUtils.isEmpty(achievementTypeIdMap)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    Result&lt;DataEntry&gt; ldbRes = super.rawGet(buildKey(uid), false);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //用户称号数据查询失败</span></code><code><span class="code-snippet_outer">    if (Objects.isNull(ldbRes)) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">        return false;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    boolean success = false;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ResultCode resultCode = ldbRes.getRc();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //不存在用户称号数据则进行初始化</span></code><code><span class="code-snippet_outer">    if (Objects.equals(resultCode, ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer">    UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">        achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(userUnreadAchievementsCache, key, value));</span></code><code><span class="code-snippet_outer">        success = putCache(uid, userUnreadAchievementsCache, DEFAULT_VERSION);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    } else if (Objects.equals(resultCode, ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        DataEntry ldbEntry = ldbRes.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //存在新数据则对其进行更新</span></code><code><span class="code-snippet_outer">        if (Objects.nonNull(ldbEntry)) {</span></code><code><span class="code-snippet_outer">            Object data = ldbEntry.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            if (data instanceof String) {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = JSON.parseObject(String.valueOf(data), UserUnreadAchievementsCache.class);</span></code><code><span class="code-snippet_outer">                achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(oldCache, key, value));</span></code><code><span class="code-snippet_outer">                success = putCache(uid, userUnreadAchievementsCache, ldbEntry.getVersion());</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    //缓存解锁的称号失败</span></code><code><span class="code-snippet_outer">    if (!success) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    return success;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">从结构上看，上面两段代码其实是非常类似的：整个结构都是先判空，然后查询历史的未读成就数据，如果数据未初始化，则进行初始化，如果已经初始化，则对数据进行更新。只不过写入/清除对数据的初始化和更新逻辑并不相同。因此可以将数据初始化和更新抽象为行为参数，将剩余部分提取为公共方法，基于这样的思路重构后的代码如下：</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 创建 or 更新缓存</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid               用户 ID</span></code><code><span class="code-snippet_outer"> * @param initCacheSupplier 缓存初始化策略</span></code><code><span class="code-snippet_outer"> * @param updater           缓存更新策略</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">private boolean upsertCache(long uid, Supplier&lt;UserUnreadAchievementsCache&gt; initCacheSupplier,</span></code><code><span class="code-snippet_outer">                            Function&lt;UserUnreadAchievementsCache, UserUnreadAchievementsCache&gt; updater) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    Result&lt;DataEntry&gt; ldbRes = super.rawGet(buildKey(uid), false);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //用户称号数据查询失败</span></code><code><span class="code-snippet_outer">    if (Objects.isNull(ldbRes)) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">        return false;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    boolean success = false;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ResultCode resultCode = ldbRes.getRc();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //不存在用户称号数据则进行初始化</span></code><code><span class="code-snippet_outer">    if (Objects.equals(resultCode, ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        UserUnreadAchievementsCache userUnreadAchievementsCache = initCacheSupplier.get();</span></code><code><span class="code-snippet_outer">        success = putCache(uid, userUnreadAchievementsCache, DEFAULT_VERSION);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    } else if (Objects.equals(resultCode, ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        DataEntry ldbEntry = ldbRes.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //存在新数据则对其进行更新</span></code><code><span class="code-snippet_outer">        if (Objects.nonNull(ldbEntry)) {</span></code><code><span class="code-snippet_outer">            Object data = ldbEntry.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            if (data instanceof String) {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = JSON.parseObject(String.valueOf(data), UserUnreadAchievementsCache.class);</span></code><code><span class="code-snippet_outer">                userUnreadAchievementsCache = updater.apply(userUnreadAchievementsCache);</span></code><code><span class="code-snippet_outer">                success = putCache(uid, userUnreadAchievementsCache, ldbEntry.getVersion());</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    //缓存解锁的称号失败</span></code><code><span class="code-snippet_outer">    if (!success) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    return success;</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 写入新的未读成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid                  用户 ID</span></code><code><span class="code-snippet_outer"> * @param achievementTypeIdMap 需要新增的成就类型和成就 ID 列表的映射</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean writeUnreadAchievements(long uid, Map&lt;String, List&lt;String&gt;&gt; achievementTypeIdMap) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (MapUtils.isEmpty(achievementTypeIdMap)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    return upsertCache(uid,</span></code><code><span class="code-snippet_outer">            () -&gt; {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">                achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(userUnreadAchievementsCache, key, value));</span></code><code><span class="code-snippet_outer">                return userUnreadAchievementsCache;</span></code><code><span class="code-snippet_outer">            },</span></code><code><span class="code-snippet_outer">            oldCache -&gt; {</span></code><code><span class="code-snippet_outer">                achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(oldCache, key, value));</span></code><code><span class="code-snippet_outer">                return oldCache;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">    );</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 清除未读成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid             用户 ID</span></code><code><span class="code-snippet_outer"> * @param achievementType 需要清除未读成就列表的成就类型</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean clearUnreadAchievements(long uid, Set&lt;String&gt; achievementTypes) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (CollectionUtils.isEmpty(achievementTypes)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    return upsertCache(uid,</span></code><code><span class="code-snippet_outer">            () -&gt; {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">                achievementTypes.forEach(type -&gt; clearCertainTypeIds(userUnreadAchievementsCache, type));</span></code><code><span class="code-snippet_outer">                return userUnreadAchievementsCache;</span></code><code><span class="code-snippet_outer">            },</span></code><code><span class="code-snippet_outer">            oldCache -&gt; {</span></code><code><span class="code-snippet_outer">                achievementTypes.forEach(type -&gt; clearCertainTypeIds(oldCache, type));</span></code><code><span class="code-snippet_outer">                return oldCache;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">    );</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">重构的核心是提取了 upsert 方法，该方法将缓存数据的初始化和更新策略以函数式接口进行定义，从而支持从调用侧进行透传，避免了模板方法的重复编写。这是一个抛砖引玉的例子，在日常开发中，我们可以更多地尝试用函数式编程的思维去思考和重构代码，也许会发现另一个神奇的编程世界。</span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><span id="OSC_h4_10"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">切面编程的一些实践</span></strong></span></h4><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">AOP 想必大家都已经十分熟悉了，在此便不再赘述其基本概念，而是开门见山直接分享一些 AOP 在静心守护项目中的实际应用。</span></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_11"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">服务层异常统一收口</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">静心守护项目采用了在阿里系统中常用的 service-manager-dao 的分层模式，其中 service 层是距离终端最近的一层。为了防止下层预期外的异常抛到终端，我们需要在 service 层对异常进行统一拦截并且记录，同时最好将相关的错误码、请求参数以及 traceId 都一并记下，便于问题排查。这个场景就非常适合使用 AOP。在引入 AOP 之前，我们需要对每个 service 中面向终端的方法都进行异常拦截和监控日志打印的操作。比方说下面这个类，它有 3 个面向终端 mtop【注：阿里内部自研的 API 网关平台】服务的方法（api 具体参数和名称做了模糊化处理），这 3 个方法都采用了同样的 try-catch 结构来进行异常捕捉和监控日志打印，其中存在大量的重复代码，而更糟糕的事，如果后续增加新的方法，这样的重复代码还会不断增加。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">@HSFProvider(serviceInterface = MtopBlessHomeService.class)</span></code><code><span class="code-snippet_outer">public class MtopBlessHomeServiceImpl implements MtopBlessHomeService {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //依赖的 bean 注入</span></code><code><span class="code-snippet_outer">  ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceAVO&gt; entranceA(EntranceARequest request) {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(request.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            //该入口下的业务逻辑</span></code><code><span class="code-snippet_outer">            ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceA", buildMethodParamsStr(request), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceA", buildMethodParamsStr(request), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceBVO&gt; entranceB(EntranceBRequest request) {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(request.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            //该入口下的业务逻辑</span></code><code><span class="code-snippet_outer">            ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceB", buildMethodParamsStr(request), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceB", buildMethodParamsStr(request), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceCVO&gt; entranceC(EntranceCRequest request) {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(query.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            //该入口下的业务逻辑</span></code><code><span class="code-snippet_outer">            ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceC", buildMethodParamsStr(request), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceC", buildMethodParamsStr(request), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }    </span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">看到这样重复的代码结构而只是局部行为的不同，也许我们可以考虑着用上一节的函数式行为参数化进行重构：将重复的代码结构抽取为公共的工具方法，将对 manager 层的调用抽象为行为参数。但在上述场景下，这种做法还是存在一些弊端：</span><ne-clipboard source="https%3A%2F%2Faliyuque.antfin.com%2Flingye.jly%2Fwozrkc%2Fitpnoh733usxcgzk%3FsingleDoc%23r1wtn"></ne-clipboard></section><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">每个服务的方法还是需要显式调用工具类方法</span></p></li><li><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">为了保证监控信息的齐全，还需要在参数里手动透传一些监控相关的信息</span></p></li></ol><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">而 AOP 则不存在这些问题：AOP 基于动态代理实现，在实现上述逻辑时对服务层的代码编写完全透明。此外，AOP 还封装了调用端方法的各种元信息，可以轻松实现各种监控信息的自动化打印。下面是我们提供的 AOP 切面。其中值得注意的点是切点的选择要尽量准确，避免增强了不必要的方法。下面我们选择的切点是 mtop 包下所有 Impl 结尾类的 public 方法。</span></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer">@Aspect</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">public class MtopServiceAspect {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * MtopService 层服务</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    @Pointcut("execution(public com.taobao.mtop.common.MtopResult com.taobao.gaia.veyron.bless.service.mtop.*Impl.*(..))")</span></code><code><span class="code-snippet_outer">    public void mtopService(){}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 对 mtop 服务进行增强</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param pjp 接入点</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     * @throws Throwable</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    @Around("com.taobao.gaia.veyron.bless.aspect.MtopServiceAspect.mtopService()")</span></code><code><span class="code-snippet_outer">    public Object enhanceService(ProceedingJoinPoint pjp) throws Throwable {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(pjp);</span></code><code><span class="code-snippet_outer">            return pjp.proceed();</span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    AspectUtils.extractMethodName(pjp), buildMethodParamsStr(pjp), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    AspectUtils.extractMethodName(pjp), buildMethodParamsStr(pjp), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">存在这样一个切面后，service 层的代码就可以变得非常简洁：只需要纯粹专注于业务逻辑。同样以刚才的 MtopBlessHomeServiceImpl 类为例，在 AOP 改写后的代码里可以去除掉原先异常收口和监控相关的内容，而仅保留业务逻辑部分，代码简洁性大大提升。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">@HSFProvider(serviceInterface = MtopBlessHomeService.class)</span></code><code><span class="code-snippet_outer">public class MtopBlessHomeServiceImpl implements MtopBlessHomeService {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //依赖的 bean 注入</span></code><code><span class="code-snippet_outer">  ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceAVO&gt; entranceA(EntranceARequest request) {</span></code><code><span class="code-snippet_outer">        //业务逻辑</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceBVO&gt; entranceB(EntranceBRequest request) {</span></code><code><span class="code-snippet_outer">        //业务逻辑</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceCVO&gt; entranceC(EntranceCRequest request) {</span></code><code><span class="code-snippet_outer">        //业务逻辑</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_12"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">切点选择的策略</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">除了服务层以外，我们还想对数据访问层进行监控，监控项目中各种数据存储工具的 RT 以及成功率相关指标，并且监控粒度要尽可能地贴近业务维度（整体的数据访问监控直接通过 eagleeye 查看即可），便于具体问题的定位排查。这种面向层级别的逻辑定制，我们很自然而然地想到了 AOP，这也正是它可以大显身手的场景。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">这节核心想要分享的则是切点的选择。静心守护项目的数据存储主要依赖于 Tair【注：阿里内部自研的高性能 K-V 存储系统。根据存储介质和使用场景不同又分为 LDB、MDB、RDB】、Lindorm【注：阿里内部自研的大规模云原生多模数据库服务】和 Mysql，这三种存储工具在代码中的使用各不相同，导致切点的选择策略也大相径庭。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><span id="OSC_h4_13"></span><h4 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">目标对象规律分布</span></h4><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">如果我们要选择增强的对象在项目中分布的非常规律，那么我们往往可以直接利用 Spring AOP 的 PointCut 语法来选择切点。以静心守护项目中的 Mysql 数据访问对象为例：我们使用的 ORM 框架是 mybatis，并且主要的用法是注解模式，所有的 SQL 逻辑都放在一个 DAO 包下，每个业务场景定义一个 DAO 结尾的 Mapper 接口，接口下的每个方法都对应着一种数据访问的方式。因此在切点选择时，我们可以直接选择 DAO 包下以 DAO 结尾的类，并选择其中 public 方法即可准确织入所有满足条件的切点。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Pointcut("execution(public * com.taobao.gaia.serverless.veyron.bless.dao.*DAO.*(..))")</span></code><code><span class="code-snippet_outer">public void charityProjectDataAccess() {</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">这样实现的监控粒度是具体到每个 DAO 对象-方法级别的粒度，监控效果如下：</span></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: center;margin-bottom: 8px;"><img class="rich_pages wxw-img" data-backh="240" data-backw="578" data-imgfileid="503041786" data-ratio="0.41574074074074074" src="https://oscimg.oschina.net/oscnet/353e7a8a-57f3-48a6-938b-7033c6681775.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><span id="OSC_h4_14"></span><h4 style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">一个失效案例</span></h4><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">静心守护项目中对 tair 的使用方式是：通过一个抽象类对 tair 的各种基础操作进行封装（包括参数校验、响应判空、异常处理等），但将具体 tair 实例相关的参数设置行为抽象化，由实现类决定。各个业务场景的 tair 管理类最终会基于抽象类封装的基础操作来对 tair 进行数据访问</span><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">。</span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><br></span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">如下图，AbstractLdbManager 是封装</span></section><section style="min-height: 24px;text-align: center;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041787" data-ratio="0.8398148148148148" src="https://oscimg.oschina.net/oscnet/7d5fa225-7c35-4cf3-97cd-8a6d1de235a5.png" data-type="png" data-w="1080" referrerpolicy="no-referrer"></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">由于各个业务场景的 tair 管理实现类分散在各个业务包下，想要对它们进行统一切入比较困难。因此我们选择对抽象类进行切入。但这样就会遇到一个同类调用导致 AOP 失效的问题：抽象类本身不会有实例对象，因此基于 CGLIB 创建代理对象后，代理对象本质上调用的还是各个业务场景 tair 管理类的对象，而在使用这些对象时，我们不会直接调用 tair 抽象类封装的数据访问方法，而是调用这些业务 tair 管理对象进一步封装的带业务语义的方法，基于这些方法再去调用 tair 抽象类的数据访问方法。这种同类方法间接调用最终就导致了抽象类的方法没有如期被增强。文字描述兴许有些绕，可以参考下面的图：</span></p><p style="min-height: 24px;text-align: center;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041815" data-ratio="0.5935185185185186" src="https://oscimg.oschina.net/oscnet/a7f4daeb-a6c6-430b-9ace-50ffd3b87165.png" data-type="png" data-w="1080" style="letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" width="536" referrerpolicy="no-referrer"></span></p><section style="min-height: 24px;text-align: justify;margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">我们选择的解决方法则是从上面的 MultiClusterTairManager 入手，这个类是 tair 为我们提供的 TairManger 的一种默认实现，我们之前的做法是为该类实例化一个 bean，然后提供给所有业务 Tair 管理类使用，也就是说所有业务 Tair 管理类使用的 TairManager 都是同一个 bean 实例（因为业务流量没那么大，一个 tair 实例暂时绰绰有余）。那么我们可以自己提供一个 TairManager 的实现，基于继承+组合 MultiClusterTairManager 的方式，只对我们项目内用到数据访问操作进行重写，并委托给原先的 MultiClusterTairManager bean 进行处理。这样我们可以在设置 AOP 切点时选择对自己实现的 TairManager 的所有方法做增强，进而避开上面的问题。经过这样改写后，上面的两张图会演变成下面这样：</span></p><section style="min-height: 24px;text-align: center;margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><img class="rich_pages wxw-img" data-imgfileid="503041811" data-ratio="0.5935185185185186" src="https://oscimg.oschina.net/oscnet/a7f4daeb-a6c6-430b-9ace-50ffd3b87165.png" data-type="png" data-w="1080" width="536" referrerpolicy="no-referrer"></section><p style="min-height: 24px;text-align: justify;margin-bottom: 8px;line-height: 1.75em;margin-top: 8px;"><span style="letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041816" data-ratio="0.37407407407407406" src="https://oscimg.oschina.net/oscnet/dcaa95ab-35fe-49ef-8fb6-087473b0f061.png" data-type="png" data-w="1080" referrerpolicy="no-referrer"></span><br></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><span id="OSC_h4_15"></span><h4 style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">基于注解切入</span></h4><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">还有一种场景是我们要增强的方法分布毫无规律，可能都在同一个类中，但方法的名称毫无规律，也无法简单通过 private 或者 public 来区别。针对这样的场景，我们的做法是自定义注解，专门用于标识需要做增强的方法。比如静心守护项目中 lindorm 相关的数据操作就是这样。我们定义注解：</span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="css"><code><span class="code-snippet_outer">@<span class="code-snippet__keyword">Target</span>({<span class="code-snippet__selector-tag">ElementType</span><span class="code-snippet__selector-class">.METHOD</span>})</span></code><code><span class="code-snippet_outer">@<span class="code-snippet__keyword">Retention</span>(<span class="code-snippet__keyword">RetentionPolicy</span>.<span class="code-snippet__keyword">RUNTIME</span>)</span></code><code><span class="code-snippet_outer">@Documented</span></code><code><span class="code-snippet_outer">public @interface VeyronJoinPoint {}</span></code></pre></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">并将该注解标识在需要增强的方法上，随后通过下面的方式描述切点，即可获取到所有需要增强的方法。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="css"><code><span class="code-snippet_outer">@<span class="code-snippet__keyword">Pointcut</span>("@<span class="code-snippet__keyword">annotation</span>(<span class="code-snippet__keyword">com</span>.<span class="code-snippet__keyword">taobao</span>.<span class="code-snippet__keyword">gaia</span>.<span class="code-snippet__keyword">serverless</span>.<span class="code-snippet__keyword">veyron</span>.<span class="code-snippet__keyword">aspect</span>.<span class="code-snippet__keyword">VeyronJoinPoint</span>)")</span></code><code><span class="code-snippet_outer">public void lindormDataAccess() {}</span></code></pre></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">上面的方法也有进一步改良的空间：在注解内增加属性来描述具体的业务场景，不同的切面根据业务场景来对捕获的方法进行过滤，只留下当前业务场景所需要的方法。不然按照现有的做法，如果新的切面也要基于注解来寻找切点，那只能定义新的注解，否则会与原先注解产生冲突。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;visibility: visible;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><img class="rich_pages wxw-img" data-imgfileid="503041834" data-ratio="0.3056872037914692" data-s="300,640" data-type="png" data-w="422" src="https://oscimg.oschina.net/oscnet/18f51c34-a896-48a4-b5c4-e2bfd339953f.png" style="outline: 0px;letter-spacing: 0.544px;font-size: 14px;visibility: visible !important;width: 117px !important;" referrerpolicy="no-referrer"></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;visibility: visible;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;color: rgb(0, 17, 255);">总结</span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">业务需求千变万化，对应的解法也见仁见智。在研发过程中对各种变化中不变的部分进行总结，从中提取出自己的模式与方法论进行整理沉淀，会让我们以后跑的更快。也正应了学生时期，老师常说的那句话：「我们要把厚厚的书本读薄才能装进脑子里。」</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">最后，如果大家有好的实践模式推荐或者建议，欢迎在评论区分享交流～</span></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><p style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><img class="rich_pages wxw-img" data-imgfileid="503041835" data-ratio="0.328125" data-s="300,640" data-type="png" data-w="256" src="https://oscimg.oschina.net/oscnet/5749e182-ccf0-448e-af95-1df19ffdd6a8.png" style="outline: 0px;letter-spacing: 0.544px;font-size: 16px;visibility: visible !important;width: 122px !important;" referrerpolicy="no-referrer"></p><p style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(100, 99, 99);font-size: 15px;text-align: center;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 1px;font-size: 18px;color: rgb(0, 17, 255);">团队介绍</span></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">我们是淘天业务技术用户消息与社交团队，负责淘宝消息、客服、Push、分享、我淘、关系、社交互动等业务，涵盖淘宝 APP 中两个一级 Tab，第三个消息 tab 和第五个我的淘宝 tab，这里有一流的产品技术，为消费者提供更好的消息与社交服务；丰富的业务场景，为淘系业务增加助力；几十万 QPS 的高并发流量，可以与淘系各位技术大牛合作，思想激荡碰撞，共同提升，包含以下方向：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">在淘宝 IM 基础上构建以用户实时意图感知、统一投放引擎为核心的全域触达体系，通过跨场景的触达方案，赋能淘系搜索、互动、用增等业务增长，每日触达亿级用户。</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">社交域基础平台服务，我的淘宝、淘友、互动等业务，服务上亿淘宝用户。</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">淘宝消息 tab、千牛商家消息，通过建立平台，消费者，商家之间的链接，提升手淘 DAU，助力商家更好的服务消费者，拥有亿级电商 IM 消息即时通讯产品，可以深入掌握分布式高可靠设计理念和架构方法论。</span></p></li></ol><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">招聘持续火热🔥进行中，如果有兴趣可将简历发至 lingye.jly@taobao.com，期待您的加入！</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section data-role="outer" label="Powered by 135editor.com" style="margin-bottom: 0px;outline: 0px;letter-spacing: 0.544px;visibility: visible;"><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;word-break: break-all;color: rgb(0, 0, 0);font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;text-align: center;line-height: 1.75em;"><span style="outline: 0px;color: rgb(0, 17, 255);"><strong style="outline: 0px;">¤</strong></span><span style="outline: 0px;"><strong style="outline: 0px;">&nbsp;拓展阅读&nbsp;</strong></span><span style="outline: 0px;color: rgb(0, 17, 255);"><strong style="outline: 0px;">¤</strong></span></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;word-break: break-all;color: rgb(0, 0, 0);font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;text-align: center;line-height: 1.75em;"><br style="outline: 0px;"></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;min-height: 24px;clear: both;visibility: visible;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D2565944923443904512%23wechat_redirect" textvalue="3DXR 技术" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">3DXR 技术</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1533906991218294785%23wechat_redirect" textvalue="终端技术" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">终端技术</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1592015847500414978%23wechat_redirect" textvalue="音视频技术" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">音视频技术</a></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;visibility: visible;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1539610690070642689%23wechat_redirect" textvalue="服务端技术" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">服务端技术</a><span style="outline: 0px;letter-spacing: 0.544px;">&nbsp;|&nbsp;</span><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D2565883875634397185%23wechat_redirect" textvalue="技术质量" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">技术质量</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1522425612282494977%23wechat_redirect" textvalue="数据算法" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">数据算法</a></section><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;visibility: visible;"><br style="outline: 0px;"></p><section class="mp_profile_iframe_wrp" style="margin-bottom: 24px;outline: 0px;"><mp-common-profile class="custom_select_card mp_profile_iframe js_wx_tap_highlight" data-pluginname="mpprofile" data-id="MzAxNDEwNjk5OQ==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/33P2FdAnju8t5nZGhAatCrc4e2iaDfAaoInribRKxc7MOqdTGygfcLqSDxhj0trCHVEh94Sjl7zuWYzwouYtJ0VQ/300?wx_fmt=png&amp;wxfrom=19" data-nickname="大淘宝技术" data-alias="AlibabaMTT" data-signature="大淘宝技术官方账号" data-from="2" data-index="0" data-origin_num="685" data-isban="0" data-weuitheme="light" data-biz_account_status="0" data-is_biz_ban="0"></mp-common-profile><span style="outline: 0px;color: rgb(0, 0, 0);font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 1px;"></span></section></section><section style="line-height: 1.75em;"><section style="display: none;line-height: 1.75em;"><br></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - 大淘宝技术（AlibabaMTT）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 02:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4662964/blog/10555462</guid>
            <link>https://my.oschina.net/u/4662964/blog/10555462</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[最新桌面浏览器市场份额排名：Edge 重回第二、Safari 跌破 10%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>知名流量监测机构 Statcounter 公布了 2023 年&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgs.statcounter.com%2Fbrowser-market-share%2Fdesktop%2Fworldwide" target="_blank">12 月份全球桌面浏览器市场份额</a>：</p><p><img src="https://static.oschina.net/uploads/space/2024/0102/101516_FTqQ_2720166.png" referrerpolicy="no-referrer"></p><p>主要数据如下：</p><ul><li><strong>Chrome：65.29%</strong></li><li><strong>Edge：<span>11.89%</span></strong></li><li><strong>Safari：<span>8.92%</span></strong></li><li>Firefox：7.61%</li><li>Opera：3.8%</li><li>360 Safe：0.71%</li><li>……</li></ul><p><img height="720" src="https://oscimg.oschina.net/oscnet/up-da555d51c704e0a59cad47fb01d30a6da9f.png" width="1280" referrerpolicy="no-referrer"></p><p>2023 年 5 月，Safari <u><a href="https://www.oschina.net/news/240186/statcounter-safari-edge">以微弱优势超过 Edge </a></u>成为全球市场份额排名第二的桌面浏览器。此后几个月也一直稳坐第二，然而没想到 Edge 在 2023 年最后一个月来了一波大反杀——要知道 11 月 Safari 的市场份额仍有 13%，比 Edge 的 11% 高出两个点。</p><p><img src="https://oscimg.oschina.net/oscnet/up-729990e5f76ed08ac6344603617f319861c.png" referrerpolicy="no-referrer"></p><p>然而在 12 月，Safari 的市场份额急剧下降，直接跌破 10%——只剩&nbsp;<span>8.92%。</span>目前尚无信息显示 Safari 市场份额暴跌的背后原因。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 02:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273741/statcounter-edge-202312</guid>
            <link>https://www.oschina.net/news/273741/statcounter-edge-202312</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[openKylin 1.0 成功适配 Inte l 最新 x86 平台 Raptor Lake 系列]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify">2023 年 12 月 25 日，openKylin 1.0 成功适配 Intel（英特尔）最新 x86 平台 Raptor Lake 系列，与国际 OSV 同步。</p><div><p style="text-align:center"><img alt="" height="410" src="https://oscimg.oschina.net/oscnet/up-fcdea1508a9a5937b9f83fbef89e66a1b9e.png" width="940" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">Intel 中国公司在 2023 年 11 月加入 openKylin 社区之后，成立了 Intel SIG 并与 openKylin 社区开展合作，经过 Intel SIG 团队成员的努力，目前 openKylin 1.0 操作系统已成功适配第 13/14 代 Intel 客户端平台，Raptor Lake 系列，以及 ADL-N（12 代 refresh）。具体机型如下所示：</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">1.支持 Intel 最新 13/14 代 CPU 型号；</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">2.支持 Intel ADL-N, RPL-S,RPL-P, RPL-U, RPL-HX 等最新平台；</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">3.支持相关 OEM 惠普，联想等基于 Intel13 代机的相关机型。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">测试期间，openKylin 1.0 操作系统在以上 Intel 开发机平台上整体运行稳定，功能、性能及兼容性方面表现良好。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">Raptor Lake 是 Intel 基于混合架构的第 13 代和第 14 代 Intel 酷睿处理器的代号，采用 Raptor Cove 性能核心和 Gracemont 效率核心。与 Alder Lake 一样，Raptor Lake 也是使用 Intel 的 Intel 7 工艺制造的。Raptor Lake 具有多达 24 个核心（8 个性能核心加 16 个效率核心）和 32 个线程，并且与 Alder Lake 系统（LGA 1700、BGA1744、BGA1964）兼容。与前几代一样，Raptor Lake 处理器也需要配套的芯片组。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">目前，Intel SIG 共完成 6.1 Kernel 合并 Intel 最新平台支持补丁 110 多个, 包括最新图形，声音，蓝牙，无线，电源管理，网络，串口，多媒体等硬件的支持。同时 linux-firmware 合并 Intel 最新平台支持补丁 170 多个，包括 Intel 最新显卡，无线网卡，蓝牙，声音等的硬件固件支持。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">未来，Intel 将持续与 openKylin 社区开展深入合作，推动 openKylin 操作系统适配更多的 Intel 最新平台，并不断优化和完善其应用体验，共同推动 openKylin 开源操作系统的普及和国产开源生态的打造，助力 openKylin 开源生态布局进一步完善。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 01:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273735</guid>
            <link>https://www.oschina.net/news/273735</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[袋鼠数据库工具 v4.0.0 已发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>重点特性介绍：增加了界面主题支持</h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">上一个版本发布后，群里的小伙伴们讨论很热烈，有提出新功能想法的，也有期望袋鼠变得【更美】一些的；新功能的想法，我都有及时记录在项目的 Issue 列表中；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">对于【更美】的想法，我却觉得有点棘手：因为爱美之心人皆有之，非常正常的需求，可在变美的这个议题上，袋鼠界面已经经历过三次重大迭代，已经是脱胎换骨了，各位对比看就可以看出端倪了：<span>&nbsp;</span><img alt="袋鼠界面对比图" src="https://oscimg.oschina.net/oscnet/up-3facdd761fca23f71268db1ee0589dd7d95.png" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">在这个基础上再变美，感觉超出我的能力范围，经过谨慎的思量之后，决定开放袋鼠的界面定制能力，为爱美又有专业能力的同学提供一个平台：支持界面定制和二次出售，详细请参考链接：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FXTJF5Xz1kEnTK_rF2f9CtQ" target="_blank">袋鼠数据库工具开放美容能力</a>；</p><h2>新特性预告</h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">袋鼠使用轻量级的 FreeTDS 库来支持 SQLServer，已经完成了 SQL Server 的技术支持验证，特性适配完善中，敬请关注；</p><h2>新特性或修复的缺陷列表</h2><ul><li>增加界面定制 (theme) 支持</li><li>改进单元格图片显示体验</li><li>更新工作空间边栏面板行为</li><li>更新中文语言支持 (zh-CN/zh-TW/zh-SG/zh-HK)</li><li>修复: 无法创建代码块片段的问题</li></ul><h2>下载与安装</h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.datatable.online%2Fzh%2Fdownload%2Fv4.0.0.240101.html" target="_blank">袋鼠数据库管理工具 2024（4.0）</a></p><h2>新版本功能快照</h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.datatable.online%2Fzh%2F" target="_blank"><img alt="图标定制效果预览" src="https://oscimg.oschina.net/oscnet/up-1f02d1b402f68c50b5dc8d614f042c86978.png" referrerpolicy="no-referrer"></a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.datatable.online%2Fzh%2F" target="_blank"><img alt="界面主题简单效果预览" src="https://oscimg.oschina.net/oscnet/up-911fc72301d82494af73b669233c9e31bc3.png" referrerpolicy="no-referrer"></a></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 00:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273614</guid>
            <link>https://www.oschina.net/news/273614</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[盘点 2023 十大宕机事故「冥场面」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>名场面？冥场面！</p><p>速来围观 2023 十大宕机事故「冥场面」——</p><hr><h1><a href="https://www.oschina.net/news/231236" target="_blank">哔哩哔哩（B 站）崩了两次</a></h1><p>2023 年 3 月 5 日晚 20:20 左右，许多网友表示在使用 B 站时，手机和电脑端都无法访问视频详情页，且手机端无法查看收藏夹与历史记录。还有网友表示，首页能够正常加载，但全部是繁体字。</p><p><img src="https://oscimg.oschina.net/oscnet/up-affa896050135c6a15c206de322a4e28acc.png" referrerpolicy="no-referrer"></p><p><u><a href="https://www.oschina.net/news/252405">8 月 4 日晚间</a></u>，距离上次事故 5 个月后，又有许多网友反馈 B 站图片（视频封面）无法加载、视频无法打开、视频一直在缓冲。</p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/236219" target="_blank">腾讯「3.29」一级事故</a></h1><p>2023 年 3 月 29 日凌晨，腾讯旗下的微信和 QQ 等业务曾出现崩溃状况，包括微信语音对话、朋友圈、微信支付，以及 QQ 文件传输、QQ 空间和 QQ 邮箱在内的多个功能无法使用。</p><p>直到 29 日早间，腾讯微信团队才回应表示，经工程师抢修，系统正在逐步恢复。</p><p><img src="https://oscimg.oschina.net/oscnet/up-127213d84c63650497a340914182c4a89f9.png" referrerpolicy="no-referrer"></p><p>本次事故由广州电信机房冷却系统故障导致，腾讯将它定义为公司一级事故，并对大量相关领导做出了处罚。</p><p>4 月 12 日，工业和信息化部信息通信管理局<u><a href="https://www.oschina.net/news/236943">听取腾讯公司关于 「3・29」 微信业务异常情况汇报</a></u>，要求腾讯公司进一步健全安全生产管理制度、落实网络运行保障措施，坚决避免发生重大安全生产事故，切实提升公众业务安全稳定运行水平。</p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/244039" target="_blank">唯品会 329 事故处罚结果：基础平台部负责人被免职</a></h1><p>今年 3 月 29 日，「唯品会崩了」 登上热搜，由于崩溃时间太长，影响了很多消费者无法正常下单。唯品会官方对此回应称，因系统短时故障，主站 「加购」 等功能或出现异常。</p><p>6 月 5 日，唯品会发布 「关于 329 机房宕机故障处理的公告」。公告称，3 月 29 日（00:14-12:01）南沙 IDC 冷冻系统故障，导致机房设备温度快速升高宕机，造成线上商城停止服务。此次事故影响时间持续 12 个小时，导致唯品会业绩损失超亿元，影响客户达 800 万，唯品会将此次故障判定为 P0 级故障。据了解，P0 属于最高级别事故，比如崩溃、页面无法访问、主流程不通、主功能未实现，或在影响面上影响很大（即使 Bug 本身不严重）。</p><p>公告指出，唯品会决定对此次事件严肃处理，对应部门的直接管理者承担此次事故责任，基础平台部负责人予以免职作相应处理。</p><p><img src="https://oscimg.oschina.net/oscnet/up-168b9a6041c9b94335f6c23063ef7f9ce95.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/244118/microsoft-azure-outage-brazil" target="_blank">微软 Azure 故障，17 个生产级数据库被删</a></h1><p>5 月 24 日，微软 Azure DevOps 在巴西南部地区的一处 scale-unit 发生故障，导致宕机约 10.5 个小时。后续微软首席软件工程经理 Eric Mattingly 出面针对此次故障事件道歉，并<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstatus.dev.azure.com%2F_event%2F392143683%2Fpost-mortem">透露了</a>导致中断的原因：即，一个简单的拼写错误致使 17 个生产级数据库被删除。</p><p><img alt="up-d28b235003ee1390973397efd32e59d2ee1.png" src="https://oscimg.oschina.net/oscnet/up-d28b235003ee1390973397efd32e59d2ee1.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/244330" target="_blank">中国电信出现大规模无服务问题</a></h1><p>2023 年 6 月 8 日下午，中国电信的网络和通信服务出现无信号等失灵现象，绝大部分反馈的用户都在广东区域，疑似广东省内故障。</p><p>此后中国电信客服回应表示，电信基站全省（广东电信）故障，暂时不能拨打电话，请耐心等待，现在紧急加急处理中，不便之处，敬请谅解。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3ccdb0730d3b6ee9d3faf43d5d2a31c7d6e.png" referrerpolicy="no-referrer"></p><p>历时 4 个小时左右，广东省内电信网络全面恢复。</p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/263266" target="_blank">语雀 10.23 重大服务故障，持续 7 小时</a></h1><p>2023 年 10 月 23 日语雀出现重大服务故障，且持续 7 个多小时才完全恢复。语雀团队后续公布了故障原因及处理过程：</p><p>10 月 23 日下午，服务语雀的数据存储运维团队在进行升级操作时，由于新的运维升级工具 bug，导致华东地区生产环境存储服务器被误下线。受其影响，语雀数据服务发生严重故障，造成大面积的服务中断。</p><p><img src="https://oscimg.oschina.net/oscnet/up-d0d73c9d391b9afb17b5d8a1fdfe8babfa4.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/266694" target="_blank">阿里云 11.12 重大服务故障，全线产品受影响</a></h1><p>2023 年 11 月 12 日下午，阿里云出现严重故障，全线产品受影响。</p><p>后续官方确认故障原因与某个底层服务组件有关。在历时约 5 个小时后，阿里云宣布受影响云产品均已恢复，因故障影响部分云产品的数据（如监控、账单等）可能存在延迟推送情况，不影响业务运行。</p><p><img src="https://oscimg.oschina.net/oscnet/up-12e038da50562b9fb7806fac53534a272ac.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/268480" target="_blank">滴滴 11.27 系统服务故障，技术团队连夜修复</a></h1><p>2023 年 11 月 27 日晚间，滴滴因系统故障导致 App 服务异常，不显示定位且无法打车。11 月 27 日晚，滴滴出行进行了回复：非常抱歉，由于系统故障，今天晚间滴滴 App 服务出现异常，经技术同学紧急修复，目前正陆续恢复中。</p><p>2023 年 11 月 28 日早间，滴滴出行消息称，网约车等服务已恢复，骑车等在陆续修复中。11 月 28 日，在滴滴发出公告的同时，记者在上海、深圳等地使用滴滴呼叫网约车，发现网约车功能并未恢复使用，网络加载异常，仍无法打车。11 月 28 日，滴滴向记者回应称，网约车服务已恢复，司机乘客权益陆续恢复补发。</p><p><strong>11 月 29 日，滴滴再次发文致歉，称初步确定事故起因是底层系统软件发生故障</strong>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-de730d329966eb2d4a658c5008f11be82a7.png" referrerpolicy="no-referrer"></p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1129/113103_VOdZ_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/231624/a-single-engineer-brought-down-twitter" target="_blank">推特严重宕机，马斯克暴怒</a></h1><p>2023 年 2 月，马斯克因其关于超级碗的推文曝光度不如美国总统拜登，而深夜紧急召集约 80 人解决算法问题。</p><p>3 月份，因一名工程师修改配置导致推特出现严重的宕机故障，马斯克扬言要将代码全部进行重构。</p><p><img src="https://static.oschina.net/uploads/space/2023/0308/083022_yiJO_2720166.png" referrerpolicy="no-referrer"></p><p>7 月份，用户反馈平台再次出现问题，无法发布新推文，收到 「超出限制」 的错误提示。马斯克则回应称，Twitter 正在努力应对 「极端程度的数据抓取」 和 「系统操纵」，这些新的限制是遏制这些紧迫问题的重要措施。</p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/265693" target="_blank">ChatGPT 服务中断近 2 小时，CEO 奥特曼道歉：流量远超预期</a></h1><p>北京时间 11 月 8 日晚 22 点左右，OpenAI 旗下 ChatGPT 以及相关 API 出现中断故障，导致面向用户和开发者的服务近 2 小时无法正常使用。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstatus.openai.com%2F">随后 OpenAl 更新事故报告称</a></u>，已确定了一个导致 API 和 ChatGPT 错误率高的问题，正在努力修复。</p><p><img src="https://oscimg.oschina.net/oscnet/up-9dfae5273c9fd8f249f7e5bbc7592211806.png" referrerpolicy="no-referrer"></p><p>与此同时，OpenAI CEO 山姆・奥特曼<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fsama%2Fstatus%2F1722315204242149788">公开致歉称</a></u>，本周发布的新功能遇到远超预期的使用量。公司原计划在周一为所有订阅者启用 GPTs 服务，但目前还无法实现。由于负载的原因，短期内可能会出现服务不稳定的情况，对此情况向用户道歉。</p><p>&nbsp;</p><p><em>延伸阅读：<u><a href="https://www.oschina.net/news/270052">网信办发布《网络安全事件报告管理办法（征求意见稿）》</a></u></em></p><hr><p>更多年度重磅事件回顾，查看<strong><u><a href="https://talk.gitee.com/report/china-open-source-2023-annual-report.pdf?fr=shida_news1231" target="_blank">《2023 中国开源开发者报告》</a></u></strong>。</p><p><img height="4950" src="https://oscimg.oschina.net/oscnet/up-742bb3d98bf476a2aa6120928bae7b2ee33.png" width="3497" referrerpolicy="no-referrer"><img height="4950" src="https://oscimg.oschina.net/oscnet/up-e2e5b4d5020eec787e184044fd4f42d8c7b.png" width="3497" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 04:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273501</guid>
            <link>https://www.oschina.net/news/273501</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[回顾 30 年前的 IDE：只有 TUI、背景颜色亮瞎眼……]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>当谈到 30 年前的集成开发环境 (IDE)，纯文本模式大行其道。在 20 世纪 80 年代末/90 年代初，DOS 操作系统上的 IDE 都是<strong>基于文本用户界面 (TUI)</strong>。这些 IDE 虽然没有图形界面，但却提供了一些令人印象深刻的功能，让程序员们能够进行编码、编译和调试他们的程序。</p><p>比如 MS-DOS 自带的编辑器 EDIT.COM。这是一个全屏 TUI 编辑器，提供了菜单栏、对话框、状态栏等功能。虽然不太适合编码，但它展示了当时的技术水平。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-5028193deeef003d71722a0e0206c7cba5a.png" referrerpolicy="no-referrer"></p><p>另一个经典的 IDE 是 Borland Turbo 系列，比如 Turbo C++。这些 IDE 提供了语法高亮、编译器集成、调试器、项目管理等功能，甚至还有完整的参考手册。这些功能在当时来说非常先进，让程序员们能够在没有互联网的情况下完成整个开发过程。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-88e0ddd9805e24b5d3fab4b5e6479936743.png" referrerpolicy="no-referrer"></p><p><em>（语法高亮）</em></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0b6a07d4eff9299bbe1994abb4e8e822709.png" referrerpolicy="no-referrer"></p><p><em>（集成编译器和诊断）</em></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0d05a776e3a60a221c7cbec17db45f81932.png" referrerpolicy="no-referrer"></p><p><em>（集成项目和构建系统管理）</em></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-93863267f7c7ff62eff8100b50b2e2bd32e.png" referrerpolicy="no-referrer"></p><p><em>（包含断点、堆栈跟踪等功能的调试器）</em></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-bf6c8d95bd4f5f049c98cbaf4a30987ad5d.png" referrerpolicy="no-referrer"></p><p><em>（完整的使用手册）</em></p><p>有人表示，Bordland 在当时出品的 IDE 确实十分惊艳，但在使用 Bordland Turbo C++ 一段时间后，眼睛都要被亮瞎了……</p><p>与此同时，Linux 上的 IDE 并不如 DOS 上的 IDE 那么成熟。虽然也有一些文本模式的程序，比如 Vim 和 Emacs，但它们并不像 Borland Turbo 系列那样提供完整的集成开发环境。这导致了在当时许多程序员还是更倾向于使用 DOS 上的 IDE 进行开发。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-affdf2cf4e49f6240d455b0ad65df6324d2.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 03:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273632/the-ides-we-had-30-years-ago</guid>
            <link>https://www.oschina.net/news/273632/the-ides-we-had-30-years-ago</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[恶意软件滥用 Google OAuth 端点「恢复」cookie、劫持帐户]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">多个信息窃取恶意软件系列正在滥用名为「MultiLogin」的未记录的 Google OAuth 端点来恢复过期的身份验证 cookie 并登录用户帐户（即使账户密码已被重置）。</span></p><p style="color:#404040; margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">科技网站&nbsp;<span style="background-color:#ffffff"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bleepingcomputer.com%2Fnews%2Fsecurity%2Fmalware-abuses-google-oauth-endpoint-to-revive-cookies-hijack-accounts%2F" target="_blank">BleepingComputer</a> 指出，他们在今年 11 月底曾报道了两名黑客：Lumma 和 Rhadamanthys，两人声称可以恢复在攻击中窃取的过期谷歌验证 cookie。</span></span><span style="color:#000000"><span style="background-color:#ffffff">即使合法所有者已经注销、重置密码或会话过期，这些 cookie 仍可让网络犯罪分子在未经授权的情况下访问谷歌账户。但在这一个多月来，BleepingComputer&nbsp;曾多次联系谷歌，询问相关说法的真实性以及他们计划如何缓解这一问题，却从未收到过回复。</span></span></p><p><span style="color:#000000">CloudSEK 研究人员日前发布的一份报告则进一步揭示了这种零日漏洞利用的工作原理，并描绘了有关其利用规模的可怕景象。10 月 20 日，一个名为 PRISMA 的威胁行为者首次披露了这一漏洞称，他们发现了一种恢复过期谷歌验证 cookie 的方法。</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>对漏洞进行逆向工程后，CloudSEK 发现它使用了一个名为「MultiLogin」的未记录的 Google OAuth 端点，该端点旨在通过接受帐户 ID 和 auth-login&nbsp;tokens 向量来同步不同 Google 服务之间的帐户。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>「此请求用于在多个 Google 网站（例如 YouTube）的 Google 身份验证 cookie 中设置浏览器中的 Chrome 帐户。」&nbsp; &nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>「这个请求是 Gaia Auth API 的一部分，只要 cookie 中的帐户与浏览器中的帐户不一致就会触发。」</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>CloudSEK 表示，滥用该终端的信息窃取恶意软件会提取登录到谷歌账户的 Chrome 配置文件的 tokens 和账户 ID。这些被盗信息包含两个关键数据：service (GAIA ID) 和 encrypted_token。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>加密令牌使用存储在 Chrome 浏览器"Local State"文件中的加密密钥进行解密。同样的加密密钥也用于解密浏览器中保存的密码。利用窃取的 token：GAIA 与多重登录端点配对，威胁行为者可以重新生成过期的 Google Service cookies，并保持对受损账户的持久访问。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><img height="263" src="https://oscimg.oschina.net/oscnet/up-0d39112d34ae544e0bc2bc03fa265fea829.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#404040">CloudSek 研究员 Pavan Karthick 表示，他们对该漏洞进行了逆向工程，并能够使用它来重新生成过期的 Google 身份验证 cookie，如下所示：</span></p><p><img height="253" src="https://oscimg.oschina.net/oscnet/up-b05c5e78446b2fe30d3c88ba80361617dc5.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#404040">Karthick 解释称，如果用户重置其 Google 密码，身份验证 cookie 只能重新生成一次。否则，它可以多次重新生成，从而提供对帐户的持久访问。</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Lumma stealer 于 11 月 14 日首次利用了该漏洞，</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Radamanthys 是第一个在 11 月 17 日效仿的人；</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>此后还有 12 月 1 日的 Stealc、12 月 11 日的 Medusa、12 月 12 日的 RisePro 和 12 月 26 日的 Whitesnake。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>因此，目前至少有 6 个信息窃取者声称能够使用此 API 端点重新生成 Google cookie。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>此后，</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#070707">Lumma 还发布了该漏洞的更新版本：转而使用 SOCKS 代理来逃避 Google 的滥用检测措施，并在恶意软件和 MultiLogin 端点之间实现加密通信；以抵消谷歌的缓解措。</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">BleepingComputer 认为，这实际上也表明，谷歌方面是知道这一漏洞的存在的。但该公司</span>尚未确认 MultiLogin 端点被滥用的这一事件，因此目前该漏洞利用的状态及其缓解措施仍不清楚。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 03:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273500/malware-abuses-google-oauth-endpoint-cookies</guid>
            <link>https://www.oschina.net/news/273500/malware-abuses-google-oauth-endpoint-cookies</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[1-11 月我国规上互联网企业完成业务收入 15668 亿元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="background-color:#ffffff; color:#000000"><span style="background-color:#ffffff">工信部最新</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fgxsj%2Ftjfx%2Fhlw%2Fart%2F2023%2Fart_e133fb8083b84cc5993dfe7ae5eb32d0.html" target="_blank">发布</a><span style="background-color:#ffffff; color:#000000"><span style="background-color:#ffffff">的&nbsp;2023 年 1-11 月份互联网和相关服务业运行情况指出，</span></span><span style="color:#070707">1-11 月份，互联网业务收入增速持续提升，利润总额增势放缓，研发经费持续下滑。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:justify"><strong><span>一、总体情况</span></strong></h4><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>互联网业务收入</span></strong><strong><span>增速持续提升</span></strong><strong><span>。</span></strong></span><span>1－11</span><span>月份</span><span><span>，我国规模以上互联网和相关服务企业</span><span><span>1</span></span><span>（以下简称互联网企业）完成互联网业务收入</span></span><span>15668 亿元，同比增长 6.1%</span><span>。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><img height="249" src="https://oscimg.oschina.net/oscnet/up-207c3b83268b47a98ecb744cb5cdb7b82fb.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>利润</span></strong><strong><span>总额</span></strong><strong><span>增势放缓</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，我国规模以上互联网企业营业成本同比增长</span></span><span>9.7%，增速较</span><span>1</span><span>－10 月份回落 0.1</span><span><span>个百分点。实现利润总额</span></span><span>1189 亿元，同比增长 2.5</span><span>%。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><img height="252" src="https://oscimg.oschina.net/oscnet/up-593de36ec44bc8dd102524f5b7a772b98b3.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>研发经费</span></strong><strong><span>持续下滑</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，我国规模以上互联网企业共投入研发经费</span></span><span>822.7 亿元，同比下降 4.5</span><span>%。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><img height="249" src="https://oscimg.oschina.net/oscnet/up-6fa68b7451c0f67c4ed961f6c2559e4f35a.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px; text-align:justify"><strong><span>二、分领域情况</span></strong></h4><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>（一）信息服务领域企业</span></strong><strong><span>收入实现正增长</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，以信息服务为主的企业（包括新闻资讯、搜索、社交、游戏、音乐视频等）互联网业务收入同比</span></span><span>增长 0.4</span><span>%。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>（二）生活服务领域企业收入</span></strong><strong><span>保持快速增长</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，以提供生活服务为主的平台企业（包括本地生活、租车约车、旅游出行、金融服务、汽车、房屋住宅等）互联网业务收入同比增长</span></span><span>22.1%。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>（三）网络销售领域企业收入</span></strong><strong><span>增速有所回落</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，主要提供网络销售服务的企业（包括大宗商品、农副产品、综合电商、医疗用品、快递等）互联网业务收入同比增长</span></span><span>23.7%。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:justify"><strong><span>三、分地区情况</span></strong></h4><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>中</span></strong><strong><span>部地区互联网业务收入增</span></strong><strong><span>速持续提升</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，东部地区完成互联网业务收入</span></span><span>14016 亿元，同比增长 6.5</span><span>%，增速与 1</span><span>－10 月份持平</span><span><span>，高于全国增速</span></span><span>0.4 个百分点，占全国互联网业务收入的比重为 89.5%。中部地区完成互联网业务收入</span><span><span>701</span></span><span>亿元，同比增长 10.5%，</span><span>增速</span><span>较 1－10 月份提升 4</span><span><span>个百分点，</span></span><span>高于全国增速 4.4 个百分点。西部地区完成互联网业务收入 915.9 亿元，同比下降 1.6</span><span>%，降幅较 1</span><span>－10 月份扩大 0.2</span><span><span>个百分点。东北地区完成互联网业务收入</span></span><span>35.3 亿元，同比下降 25.9</span><span>%，降幅较 1</span><span>－10 月份收窄 3.2</span><span><span>个百分点。</span></span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><img height="246" src="https://oscimg.oschina.net/oscnet/up-f13b705f77044296551c3a3d3f3473ce1a2.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>长三角</span></strong><strong><span>地区互联网业务收入</span></strong><strong><span>增速领先</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，</span></span><span>京津冀地区完成互联网业务收入 6000 亿元，同比增长 5.6%，增速较</span><span>1</span><span>－10 月份提升 0.6 个百分点，占全国互联网业务收入的比重为 38.3%。</span><span>长三角</span><span>地区完成互联网业务收入 5242 亿元，同比增长 12.8%，增速较</span><span>1</span><span>－10 月份回落 0.4</span><span><span>个百分点，占全国互联网业务收入的比重为</span></span><span>37.5%。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><img height="307" src="https://oscimg.oschina.net/oscnet/up-ba7cb957eefa1894ad7636e89bb0f561fa4.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>半数</span></strong><strong><span>地区互联网业务</span></strong><strong><span>增速实现正增长</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span>，互联网业务累计收入居前</span><span>5 名的</span><span>北京</span><span>（增长 3.2</span><span>%）、上海</span><span>（增长 17.4</span><span>%）、浙江</span><span>（增长 4.8%）、</span><span>广东</span><span>（下降 6.6%）和天津（增长</span><span><span>19.1</span></span><span>%）共完成业务收入</span><span>13075</span><span>亿元，同比增长 6.6</span><span>%，占全国比重达</span><span>83.</span><span><span>5</span></span><span>%。全国互联网业务增速实现正增长的省（区、市）有 16 个。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><img height="242" src="https://oscimg.oschina.net/oscnet/up-196ef056da869e93a9d75c6e816c15b64ef.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#070707; margin-left:2px; margin-right:0; text-align:justify"><span><strong><span>附注：</span></strong>1.规模以上互联网和相关服务企业口径由上年互联网和相</span><span style="color:#070707">关服务收入 500 万元以上调整为 2000 万元及以上，文中所有同比增速均按可比口径计算。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 03:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273491</guid>
            <link>https://www.oschina.net/news/273491</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Shiori —— Go 编写的书签管理器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Shiori 是一个用 Go 语言编写的简单书签管理器。旨在作为 Pocket&nbsp;的简单克隆。你可以将其用作命令行应用程序或 Web 应用程序。该应用程序作为单个二进制文件分发，这意味着它可以轻松安装和使用。</p><p><img height="244" src="https://static.oschina.net/uploads/space/2023/0816/150851_4oPv_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><strong>特性：</strong></p><ul><li>基本书签管理，即添加、编辑、删除和搜索。</li><li>从 Netscape 书签文件导入和导出书签。</li><li>从 Pocket 导入书签。</li><li>简单干净的命令行界面。</li><li>简单而漂亮的网络界面，适合那些不想使用命令行应用程序的人。</li><li>由于其单一二进制格式，因此可移植。</li><li>支持 sqlite3、PostgreSQL 和 MySQL 作为其数据库。</li><li>如果可能，默认情况下<code>shiori</code>将解析可读内容并创建网页的离线存档。</li><li>[BETA]对 Firefox 和 Chrome 的<a href="https://github.com/go-shiori/shiori-web-ext">网络扩展支持。</a></li></ul><p><img height="406" src="https://static.oschina.net/uploads/space/2023/0816/151010_pUOz_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 02:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/shiori</guid>
            <link>https://www.oschina.net/p/shiori</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 领先的开源数据库自治运维平台 openGauss-DBMind]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-dbmind" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#dbmind"></a>DBMind</h1><p><a href="https://gitee.com/opengauss/openGauss-DBMind#dbmind-%E4%B8%AD%E6%96%87">中文</a> | <a href="https://gitee.com/opengauss/openGauss-DBMind#dbmind-engish">English</a></p><p>Maintainer: <a href="mailto:ai@opengauss.org">openGauss AI-SIG</a></p><h1><a id="user-content-dbmind-中文" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#dbmind-%E4%B8%AD%E6%96%87"></a>DBMind-中文</h1><p>DBMind 作为 openGauss 数据库的一部分，为 openGauss 数据库提供了自动驾驶能力，是一款领先的开源数据库自治运维平台。通过 DBMind, 您可以很容易地发现数据库的问题，同时可以实现秒级的数据库问题根因分析。</p><p>DBMind 的特点：</p><ul><li>DBMind 采用了先进的插件化的架构形式，支持海量插件扩展；</li><li>支持多种运行模式，具备命令行交互式运行、服务式运行；</li><li>面向云原生进行设计，支持 Prometheus，并提供多种丰富的 exporter 插件；</li><li>提供丰富的对接模式，可以很容易地与现有管理系统进行对接，支持 RESTful API、Python SDK、命令行、Prometheus 协议等模式；</li><li>支持端到端全流程的数据库自治运维能力，包括慢 SQL 根因分析、workload 索引推荐、多指标关联挖掘、故障自修复、异常检测与根因分析等功能；</li></ul><p>DBMind 支持的主要能力：</p><ul><li>索引推荐</li><li>异常检测与分析</li><li>多指标关联分析</li><li>慢 SQL 根因分析</li><li>时序预测</li><li>参数调优与推荐</li><li>SQL 改写与优化</li><li>故障自动修复</li></ul><p><img src="https://gitee.com/opengauss/openGauss-DBMind/raw/master/docs/dbmind.png" alt="DBMind 架构图" referrerpolicy="no-referrer"></p><h2><a id="user-content-开始使用 dbmind" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8dbmind"></a>开始使用 DBMind</h2><h3><a id="user-content-下载并安装 dbmind" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85dbmind"></a>下载并安装 DBMind</h3><p>DBMind 基于 Python 语言实现，在使用 DBMind 时，需要运行环境具备 Python 虚拟机，同时安装好所需的第三方依赖。</p><h4><a id="user-content-方式一直接下载代码部署" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E6%96%B9%E5%BC%8F%E4%B8%80%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%A0%81%E9%83%A8%E7%BD%B2"></a>方式一：直接下载代码部署</h4><p>DBMind 主要使用 Python 语言进行编写，因此，可以在下载获取 DBMind 的源代码后，使用操作系统上安装的 Python 虚拟机直接运行，不过该过程中的第三方依赖需要用户手动安装。</p><p>用户可以通过 <code>git clone</code> 命令从 Gitee 或者 Github 上下载代码，例如：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">git clone --depth 1 https://gitee.com/opengauss/openGauss-DBMind.git</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>也可以通过 Gitee 或者 Github 提供的 zip 包下载路径进行下载，而后解压缩该 zip 包即可。</p><p>下载 DBMind 后，会产生一个名为 <code>openGauss-DBMind</code> 的目录， 将该目录的路径添加到环境变量<code>PATH</code>中，即可调用该目录中的可执行文件。例如可以执行下述命令完成：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">chmod +x openGauss-DBMind/gs_dbmind</span><span id="LC2" class="line"></span><span id="LC3" class="line">echo PATH=`pwd`/openGauss-DBMind:'$PATH' &gt;&gt; ~/.bashrc</span><span id="LC4" class="line">echo 'export PATH' &gt;&gt; ~/.bashrc</span><span id="LC5" class="line"></span><span id="LC6" class="line">source ~/.bashrc</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-方式二使用安装包进行部署" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E6%96%B9%E5%BC%8F%E4%BA%8C%E4%BD%BF%E7%94%A8%E5%AE%89%E8%A3%85%E5%8C%85%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2"></a>方式二：使用安装包进行部署</h4><p>DBMind 会定期在 openGauss-DBMind 项目的 release 页面发布 DBMind 的安装包，可以通过下载该 DBMind 安装包进行安装部署。该安装包会自动将 DBMind 解压到指定目录，并配置好环境变量。</p><p>安装包和校验码的下载地址为：</p><table><thead><tr><th>Name</th><th>Download</th><th>Remarks</th></tr></thead><tbody><tr><td>DBMind X86</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fopengauss.obs.cn-south-1.myhuaweicloud.com%2Flatest%2Fdbmind%2Fx86%2Fdbmind-installer-x86_64-python3.11.sh.tar.gz">dbmind-installer-x86_64-python3.11.sh.tar.gz</a></td><td>X86 架构下 DBMind 安装包</td></tr><tr><td>DBMind X86 SHA256</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fopengauss.obs.cn-south-1.myhuaweicloud.com%2Flatest%2Fdbmind%2Fx86%2Fdbmind-installer-x86_64-python3.11.sh.tar.gz.sha256">dbmind-installer-x86_64-python3.11.sh.tar.gz.sha256</a></td><td>DBMind X86 安装包 SHA256 校验文件</td></tr><tr><td>DBMind ARM</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fopengauss.obs.cn-south-1.myhuaweicloud.com%2Flatest%2Fdbmind%2Farm%2Fdbmind-installer-aarch64-python3.11.sh.tar.gz">dbmind-installer-aarch64-python3.11.sh.tar.gz</a></td><td>ARM 架构下 DBMind 安装包</td></tr><tr><td>DBMind ARM SHA256</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fopengauss.obs.cn-south-1.myhuaweicloud.com%2Flatest%2Fdbmind%2Farm%2Fdbmind-installer-aarch64-python3.11.sh.tar.gz.sha256">dbmind-installer-aarch64-python3.11.sh.tar.gz.sha256</a></td><td>DBMind ARM 安装包 SHA256 校验文件</td></tr></tbody></table><p>安装包使用：</p><p>  解压：tar zxvf dbmind-installer-x86_64-python3.11.sh.tar.gz</p><p>  DBMind 安装: sh dbmind-installer-x86_64-python3.11.sh</p><h4><a id="user-content-关于 python 运行环境" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%85%B3%E4%BA%8Epython%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"></a>关于 Python 运行环境</h4><p>需要至少为 Python3.7 的版本。虽然在 DBMind 的实现中对 Python3.7 以下的环境尽可能地进行了兼容，但是这些低版本的 Python 环境疏于测试，可能会引发意料之外的异常。同时，在 DBMind 启动时，也会尝试校验 Python 版本，如果 Python 版本不符合要求，则默认不会继续执行后续的动作。</p><p><em>DBMind 的 Python 版本由根目录下的 constant 文件中的变量做约束</em></p><p>如果您的环境需要安装多个版本的 Python 运行时，并且它们可能会引起冲突，那么我们建议您将 DBMind 所需的 Python 运行环境安装到 DBMind 根目录下的 <code>python</code> 目录中，DBMind 会优先选择使用在其根目录下 <code>python</code> 目录中的环境。即 <code>gs_dbmind</code> 命令会首先在<code>python/bin</code> 目录下寻找 <code>python3</code> 命令执行后续的 Python 功能。</p><h4><a id="user-content-关于第三方依赖" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%85%B3%E4%BA%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96"></a>关于第三方依赖</h4><p>DBMind 所使用的第三方依赖通过 DBMind 根目录下的 <code>requirements-xxx.txt</code> 文件指定。对于 x86 架构（amd64）以及 ARM 架构（aarch64），使用了不同的文件名进行标识。这是因为 ARM 平台对于某些第三方依赖并不友好，必须指定特定的版本才可以安装。</p><p>可以使用 pip 工具对第三方依赖进行安装。与前文所述的情况类似，如果您当前的操作系统不得不安装多个 Python 运行环境，那么，DBMind 也支持对第三方依赖进行优先选择。即可以将第三方依赖库存储到 DBMind 根目录下的 <code>3rd</code> 目录中。 在通过 <code>gs_dbmind</code> 命令使用 DBMind 功能时，会优先选择该目录下的 <code>3rd</code> 目录中的第三方依赖库进行加载。</p><p>以 x86 环境为例，可以使用下述<code>pip</code>命令安装 DBMind 的第三方依赖库：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">python3 -m pip install -r requirements-x86.txt</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如果希望指定下载的第三方依赖库地址，则可以通过 <code>--target</code> 或 <code>-t</code> 选项进行指定，例如</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">python3 -m pip install -r requirements-x86.txt -t 3rd</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-使用 dbmind" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E4%BD%BF%E7%94%A8dbmind"></a>使用 DBMind</h3><h4><a id="user-content-部署 prometheus" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E9%83%A8%E7%BD%B2prometheus"></a>部署 Prometheus</h4><p>可以通过 <a href="https://gitee.com/link?target=https%3A%2F%2Fprometheus.io%2F">Prometheus</a> 官方网站获取下载方式，下载并部署 Prometheus，以便汇集对 openGauss 实例的监控结果。</p><h4><a id="user-content-部署 node-exporter" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E9%83%A8%E7%BD%B2node-exporter"></a>部署 Node Exporter</h4><p>下载并启动 <a href="https://gitee.com/link?target=https%3A%2F%2Fprometheus.io%2Fdownload%2F%23node_exporter">Prometheus node exporter</a>.</p><p>Node exporter 可以用于监控 Linux 系统，因此每个 Linux 环境（或容器内）只需要部署一个实例即可。</p><h3><a id="user-content-启动-dbmind-组件" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%90%AF%E5%8A%A8-dbmind-%E7%BB%84%E4%BB%B6"></a>启动 DBMind 组件</h3><p>如果希望将 DBMind 作为后台服务运行，则下面的 DBMind 组件是必须安装的，否则获取不到数据库的监控信息。为了获得更高的安全机制，DBMind 提供的 exporter 默认是使用 Https 协议的，如果您觉得您的场景中不需要使用 Https 协议，则可以通过 <code>--disable-https</code> 选项禁用。</p><h4><a id="user-content-opengauss-exporter" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#opengauss-exporter"></a>openGauss Exporter</h4><p>openGauss exporter 从 openGauss 数据库中读取系统表（或系统视图）的数据，并通过 Prometheus 存储起来。由于 openGauss exporter 需要读取监控数据库的系统表信息，因此至少应该具备 <strong>monadmin</strong> 权限。例如，可以通过下述 SQL 语句为名为 <code>dbmind_monitor</code> 用户赋予权限：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">ALTER USER dbmind_monitor monadmin;</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>使用 <code>gs_dbmind component opengauss_exporter ...</code> 命令即可启动该 openGauss exporter 组件。例如，可以通过下述命令监控某个数据库，通过 <code>--url</code> 参数指定被监控的数据库实例地址：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component opengauss_exporter --url postgresql://username:password@host:port/database --web.listen-address 0.0.0.0 --web.listen-port 9187 --log.level warn --disable-https ...</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p><code>--url</code> 表示的是数据库的 DSN 地址，其格式可以<a href="https://gitee.com/opengauss/openGauss-DBMind#dsn%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E">参考此处</a>。</p><p>可以通过下述命令检查 openGauss exporter 是否已经启动：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">curl -vv http://localhost:9187/metrics</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-reprocessing-exporter" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#reprocessing-exporter"></a>Reprocessing Exporter</h4><p>reprocessing exporter 是一个用于二次加工处理数据的 exporter. 由于 node exporter、openGauss exporter 保存到 Prometheus 中的数据是即时的监控信息，而只通过这些信息是无法反应某些指标的瞬时增量信息的，例如 TPS、iops 信息等。因此，reprocessing exporter 可以用来计算增量信息或者聚合结果等。</p><p>由于 reprocessing 是从 Prometheus 中获取指标数据，进行二次加工处理后再返回给 Prometheus. 因此，它与 Prometheus 是一一对应的，即如果只有一个 Prometheus 服务，则只需要一个 reprocessing exporter 即可。例如，可以通过下述命令启动 reprocessing exporter:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component reprocessing_exporter 127.0.0.1 9090 --web.listen-address 0.0.0.0 --web.listen-port 9189</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如果您的 Prometheus 使用了<code>basic authorization</code>方式进行登录校验，则需要额外指定 <code>--prometheus-auth-user</code> 以及 <code>--prometheus-auth-password</code> 选项的值。</p><h3><a id="user-content-配置以及启动" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%90%AF%E5%8A%A8"></a>配置以及启动</h3><p>DBMind 后台服务是常驻内存的。因此，您需要首先配置一个配置文件目录，在该目录中保存多个 DBMind 的配置文件。可以通过 <code>gs_dbmind service</code> 命令来进行配置文件目录的生成以及服务的启动。该命令的使用说明为：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ gs_dbmind service --help</span><span id="LC2" class="line">usage:  service [-h] -c DIRECTORY [--only-run {...}] [--interactive | --initialize] {setup,start,stop}</span><span id="LC3" class="line"></span><span id="LC4" class="line">positional arguments:</span><span id="LC5" class="line">  {setup,start,stop}    perform an action for service</span><span id="LC6" class="line"></span><span id="LC7" class="line">optional arguments:</span><span id="LC8" class="line">  -h, --help            show this help message and exit</span><span id="LC9" class="line">  -c DIRECTORY, --conf DIRECTORY</span><span id="LC10" class="line">                        set the directory of configuration files</span><span id="LC11" class="line">  --only-run {slow_query_diagnosis,forecast}</span><span id="LC12" class="line">                        explicitly set a certain task running in the backend</span><span id="LC13" class="line">  --interactive         configure and initialize with interactive mode</span><span id="LC14" class="line">  --initialize          initialize and check configurations after configuring.</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>下面，分别介绍配置文件目录生成，以及服务的启停操作。</p><h4><a id="user-content-配置 dbmind" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E9%85%8D%E7%BD%AEdbmind"></a>配置 DBMind</h4><p>DBMind 提供两种方式进行配置文件的生成。一种是交互式的，通过 <code>--interactive</code> 选项指定；另一种则需要用户自己手动来修改，这也是默认方式。</p><p><strong>交互式配置方式</strong></p><p>下面是一些使用示例，这里我们用 <code>CONF_DIRECTORY</code> 标识我们的配置文件目录：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service setup -c CONF_DIRECTORY --interactive</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>通过上述命令，用户可以在交互式界面中，根据提示信息输入需要监控的 openGauss 实例信息和参数。</p><p><strong>手动配置方式</strong></p><p>下面的命令演示了如何通过手动方式进行 DBMind 配置：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service setup -c CONF_DIRECTORY</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>在执行完上述命令后，会生成一个名为 <code>CONF_DIRECTORY</code> 的目录，这个目录里面包含有很多的配置文件。不过，用户需要配置 <code>CONF_DIRECTORY/dbmind.conf</code> 文件即可。当用户配置完该文件后，则需要执行一下下述命令，DBMind 会根据用户刚刚配置的信息初始化 DBMind 系统：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service setup -c CONF_DIRECTORY --initialize</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-启动与停止 dbmind 服务" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%81%9C%E6%AD%A2dbmind%E6%9C%8D%E5%8A%A1"></a>启动与停止 DBMind 服务</h4><p>当用户配置完 DBMind 数据库后，则可以直接通过下述命令启动 DBMind 后台服务：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service start -c CONF_DIRECTORY</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>通过下述命令关闭 DBMind 服务：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service stop -c CONF_DIRECTORY</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-dbmind 的组件" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#dbmind%E7%9A%84%E7%BB%84%E4%BB%B6"></a>DBMind 的组件</h3><p>如前文所述，DBMind 基于一种插件化设计，这个组件（component）即为 DBMind 提供的插件（plugin）。通过插件式设计，DBMind 可以任意进行功能扩展。如果想要使用某个组件的功能，则需要执行<code>component</code>子命令。例如某个名为<code>xtuner</code>的组件可以进行数据的参数调优，那么可以执行下述命令来使用<code>xtuner</code>的功能。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component xtuner --help</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-使用 docker 运行 dbmind" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E4%BD%BF%E7%94%A8docker%E8%BF%90%E8%A1%8Cdbmind"></a>使用 Docker 运行 DBMind</h3><p>DBMind 支持 Docker, 同时也会在 Docker Hub 上定期发布 openGauss-DBMind 的 docker 镜像，镜像的地址是：</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Fhub.docker.com%2Fr%2Fdbmind%2Fopengauss_dbmind">https://hub.docker.com/r/dbmind/opengauss_dbmind</a></p><p>可以通过下述命令拉取该镜像：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker pull dbmind/opengauss_dbmind</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-创建 docker 镜像" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%88%9B%E5%BB%BAdocker%E9%95%9C%E5%83%8F"></a>创建 Docker 镜像</h4><p>在某些情况下，您可能希望手动创建 DBMind 的 docker 镜像，例如想要创建基于最新代码的镜像时。那么，可以通过 DBMind 代码根目录下的 Dockerfile 文件创建。例如在 DBMind 的根目录中执行下述命令，即可创建名为 <code>opengauss_dbmind</code> 的镜像：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker build -t opengauss_dbmind .</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-docker-镜像的使用" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#docker-%E9%95%9C%E5%83%8F%E7%9A%84%E4%BD%BF%E7%94%A8"></a>Docker 镜像的使用</h4><p>DBMind 的 docker 镜像的默认执行文件是 <code>docker_run.py</code>，该启动脚本可以在容器中启动 DBMind 所需的大多数依赖服务，包括 Prometheus, openGauss exporter, reprocessing exporter. 但是，却无法在该镜像容器内运行 node exporter 来监控远端服务器上的信息。</p><p>用户可以通过下述环境变量，将需要监控的 openGauss 服务信息传递给 DBMind 的 docker 镜像：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">OPENGAUSS_DSNS: 需要监控的 openGauss 数据库实例的 DSN 信息，多个 DSN 信息用逗号 (,) 隔开</span><span id="LC2" class="line">NODE_EXPORTERS: openGauss 数据库实例所在机器的 node exporter 地址，多个地址用逗号 (,) 隔开</span><span id="LC3" class="line">METADATABASE: 可选，将 DBMind 的离线计算结果存储起来的位置，用 DSN 形式标识数据库的连接信息；若为空，则默认使用 SQLite 进行存储</span><span id="LC4" class="line">SCRAPE_INTERVAL: 可选，指标信息的采集间隔，单位是秒；默认为 15 秒</span><span id="LC5" class="line">MASTER_USER: 可选，具有管理员权限的数据库用户名，可以用来执行某些数据库变更动作或者查询当前数据库的即时状态信息；若为空，则采用 OPENGAUSS_DSNS 中提供的用户</span><span id="LC6" class="line">MASTER_USER_PWD: 可选，上述 MASTER_USER 对应的用户密码</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>注：DSN 的配置格式可以参考<a href="https://gitee.com/opengauss/openGauss-DBMind#dsn%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E">常见问题</a>中的说明。</p><p>使用<code>docker run</code>的<code>-v</code>参数可以将路径进行映射，docker 容器内的日志统一写到 <code>/log</code> 目录中，持久化的数据统一存放在 <code>/data</code> 目录中。使用 <code>-p</code> 参数可以将容器内的端口号进行映射，Prometheus 的容器内端口是 9090, DBMind 的 web 服务则使用 8080 端口。下面是个启动 docker 服务的例子：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker run -it \</span><span id="LC2" class="line">    -e OPENGAUSS_DSNS="dbname=postgres user=dbmind_monitor password=DBMind@123 port=6789 host=192.168.1.100, dbname=postgres user=dbmind_monitor password=DBMind@123 port=6789 host=192.168.1.101, dbname=postgres user=dbmind_monitor password=DBMind@123 port=6789 host=192.168.1.102" \</span><span id="LC3" class="line">    -e NODE_EXPORTERS="http://192.168.1.100:9100,http://192.168.1.101:9100,http://192.168.1.102:9100" \</span><span id="LC4" class="line">    -e METADATABASE='postgresql://dbmind_metadb:DBMind%40123@192.168.1.100:6789/dbmind_metadb' \</span><span id="LC5" class="line">    -e MASTER_USER='dbmind_sys' \</span><span id="LC6" class="line">    -e MASTER_USER_PWD='DBMind@123' \</span><span id="LC7" class="line">    -e SCRAPE_INTERVAL=30 \</span><span id="LC8" class="line">    -p 38080:8080 -p 39090:9090 \</span><span id="LC9" class="line">    -v `pwd`/data:/data -v `pwd`/log:/log \</span><span id="LC10" class="line">    dbmind/opengauss_dbmind </span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>上面的例子是一主二备节点的部署形态，他们的 IP 地址分别是<code>192.168.1.100</code>、<code>192.168.1.101</code>以及<code>192.168.1.102</code>，数据库的端口号都是 6789. 上面我们使用了三个用户，为了方便演示，它们的密码都设置为<code>DBMind@123</code>。其中<code>dbmind_monitor</code>负责从 openGauss 数据库中抓取指标监控，需要具备 <code>monitor admin</code>权限；<code>dbmind_sys</code> 至少需要具备 <code>monitor admin</code>权限，以便可以获取数据库的即时状态，如果具备<code>sysadmin</code>权限，则可以完成一些数据库变更动作，如慢 SQL 查杀；<code>dbmind_metadb</code> 只是负责数据保存，具备指定数据库的使用权限即可；同时，这里也进行了端口和目录的映射。</p><p>如果希望使用命令行的形式运行 DBMind，则可以直接在该 docker 镜像内调用 <code>gs_dbmind</code> 命令即可，Python 运行时和第三方依赖等都已经打包在 docker 镜像中了，无需再次安装。例如，希望使用 DBMind 的参数调优组件提供的功能，则可以执行下述命令：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker run -it dbmind/opengauss_dbmind \</span><span id="LC2" class="line">   gs_dbmind component xtuner recommend \</span><span id="LC3" class="line">   --database tpcds \</span><span id="LC4" class="line">   --db-host 192.168.1.100 \</span><span id="LC5" class="line">   --host-user omm \</span><span id="LC6" class="line">   --db-user tpcds \</span><span id="LC7" class="line">   --db-port 16000</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>注：在使用<code>docker run</code> 命令运行 <code>gs_dbmind</code> 时，需要指定 <code>-it</code> 参数，以便创建一个 tty.</p><h2><a id="user-content-常见问题" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"></a>常见问题</h2><h3><a id="user-content-dsn 的格式说明" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#dsn%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E"></a>DSN 的格式说明</h3><p>DSN 是 Database Source Name 的缩写，这里支持两种格式，一种是 K-V 格式，如<code>dbname=postgres user=username password=password_value port=6789 host=127.0.0.1</code>；另一种是 URL 形式，例如<code>postgresql://username:password_value@127.0.0.1:6789/postgres</code>；对于采用 URL 格式的 DSN，由于<code>@</code>等特殊字符用来分割 URL 串中各个部分的内容，故需要 URL 编码（URL encode）。例如某个用户<code>dbmind</code>的密码为<code>DBMind@123</code>，则 URL 形式的 DSN 可以是<code>postgresql://dbmind:DBMind%40123@127.0.0.1:6789</code>，即将<code>@</code>字符编码为<code>%40</code>. 类似地，需要编码的字符还包括其他可能引起歧义的字符，如<code>/</code>, <code>\</code>, <code>?</code>, <code>&amp;</code>.</p><h2><a id="user-content-相关资料" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99"></a>相关资料</h2><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fdocs.opengauss.org%2Fzh%2Fdocs%2Flatest%2Fdocs%2FDeveloperguide%2FAI4DB-%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E8%2587%25AA%25E6%25B2%25BB%25E8%25BF%2590%25E7%25BB%25B4.html">openGauss 在线手册</a></li><li><a href="https://gitee.com/opengauss/openGauss-DBMind/wikis">DBMind wiki</a></li><li><a href="mailto:ai@opengauss.org">openGauss AI-SIG</a></li></ul><hr><h1><a id="user-content-dbmind-engish" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#dbmind-engish"></a>DBMind-Engish</h1><p>DBMind is a part of openGauss, which empowers openGauss to carry the autonomous operations and maintenance capabilities. DBMind is leading and open-source. Through DBMind, users can easily discover database problems and the root causes of the problems in seconds.</p><p><img src="https://gitee.com/opengauss/openGauss-DBMind/raw/master/docs/dbmind.png" alt="DBMind overview" referrerpolicy="no-referrer"></p><h2><a id="user-content-getting-started" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#getting-started"></a>Getting Started</h2><h3><a id="user-content-prerequisites" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#prerequisites"></a>Prerequisites</h3><p>In order to run DBMind, the following components should be configured and running.</p><h4><a id="user-content-python-runtime" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#python-runtime"></a>Python Runtime</h4><p>At least Python 3.7.</p><h4><a id="user-content-third-party-dependencies" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#third-party-dependencies"></a>Third-party Dependencies</h4><p>Use <code>pip3 install</code> to install the python dependencies.
Type the <code>pip3 install</code> command with dependencies according to the environment you are running:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">pip install -r requirements-aarch64.txt | requirements-x86.txt</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-prometheus-up-and-running" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#prometheus-up-and-running"></a>Prometheus up and Running</h4><p>Download and run the <a href="https://gitee.com/link?target=https%3A%2F%2Fprometheus.io%2F">Prometheus</a> time-series database.</p><h4><a id="user-content-node-exporter" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#node-exporter"></a>Node Exporter</h4><p>Download and run the <a href="https://gitee.com/link?target=https%3A%2F%2Fprometheus.io%2Fdownload%2F%23node_exporter">Prometheus node exporter</a>. Node-exporter is to monitor the Linux system. Hence, one Linux environment only needs to deploy one node-exporter.</p><h3><a id="user-content-dbmind-components" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#dbmind-components"></a>DBMind Components</h3><p>The following DBMind components are required:</p><p><strong>Note: If you want to get higher security, you should use the HTTPS scheme.</strong></p><h4><a id="user-content-opengauss-exporter-1" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#opengauss-exporter-1"></a>openGauss Exporter</h4><p>The openGauss-exporter reads data from the database and places it on the Prometheus time-series database.
OpenGauss-exporter is to monitor only one database instance. So if your deployment environment has not only one instance, you should start multiple openGauss-exporters to correspond to monitor multiple database instances.
It needs database access with a user having the role of at least <strong>monadmin</strong> (monitoring administrator) granted to run it. For example, you can grant monadmin privilege to role dbmind as below:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">ALTER USER dbmind monadmin;</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>Use the following command with the parameters below:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component opengauss_exporter ...</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>You can get detailed explanations of this component through passing <code>--help</code>:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component opengauss_exporter --help</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>For example, the following command starts it:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component opengauss_exporter --url postgresql://username:password@host:port/database --web.listen-address 0.0.0.0 --web.listen-port 9187 --log.level warn --disable-https ...</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>To test that the exporter is up, type the following command on its host (or use change the localhost to the server address):</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">curl -vv http://localhost:9187/metrics</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-reprocessing-exporter-1" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#reprocessing-exporter-1"></a>Reprocessing Exporter</h4><p>Reprocessing-exporter is a re-processing module for metrics stored in the Prometheus server. It helps Prometheus to reprocess the metric data then dump the new data into Prometheus. Therefore, only one needs to be started in a deployment environment.
To run it use the command below:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component reprocessing_exporter ...</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>Users can see usage by using <code>--help</code> too.</p><p>See this example for running the exporter in a single machine development environment:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component reprocessing_exporter 127.0.0.1 9090 --web.listen-address 0.0.0.0 --web.listen-port 9189</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>Use the following command to check that the service is up:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">curl http://127.0.0.1:9189/metrics</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-configure-start-and-stop-the-dbmind-service" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#configure-start-and-stop-the-dbmind-service"></a>Configure, Start and Stop the DBMind Service</h3><p>DBMind service is a memory-resident backend service. Therefore, users should configure it first then start or stop the service by using the configuration.</p><p>Service usages:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ gs_dbmind service --help</span><span id="LC2" class="line">usage:  service [-h] -c DIRECTORY [--only-run {slow_query_diagnosis,forecast,anomaly_detection,alarm_log_diagnosis,index_recommendation,knob_recommendation}] [--dry-run] [-f]</span><span id="LC3" class="line">                [--interactive | --initialize]</span><span id="LC4" class="line">                {setup,start,stop,restart}</span><span id="LC5" class="line"></span><span id="LC6" class="line">positional arguments:</span><span id="LC7" class="line">  {setup,start,stop,restart}</span><span id="LC8" class="line">                        perform an action for service</span><span id="LC9" class="line"></span><span id="LC10" class="line">optional arguments:</span><span id="LC11" class="line">  -h, --help            show this help message and exit</span><span id="LC12" class="line">  -c DIRECTORY, --conf DIRECTORY</span><span id="LC13" class="line">                        set the directory of configuration files</span><span id="LC14" class="line">  --only-run {slow_query_diagnosis,forecast,anomaly_detection,alarm_log_diagnosis,index_recommendation,knob_recommendation}</span><span id="LC15" class="line">                        explicitly set a certain task running in the backend</span><span id="LC16" class="line">  --dry-run             run the backend task(s) once. the task to run can be specified by the --only-run argument</span><span id="LC17" class="line">  -f, --force           force to stop the process and cancel all in-progress tasks</span><span id="LC18" class="line">  --interactive         configure and initialize with interactive mode</span><span id="LC19" class="line">  --initialize          initialize and check configurations after configuring.</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-configure" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#configure"></a>Configure</h4><p>DBMind offers two methods to configure. The one is an interactive mode by using <code>--interactive</code> argument, the other is a modification by hands.</p><p>See this example for configuring in the interactive mode:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service setup -c CONF_DIRECTORY --interactive</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>Then users can type parameters into the shell terminal.</p><p>See the following example for configuring by hands:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service setup -c CONF_DIRECTORY</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>After executing the above command, the directory <code>CONF_DIRECTORY</code> will generate too many configuration files. Therefore, users should modify these parameters in the <code>CONF_DIRECTORY/dbmind.conf</code>. While users finish configuring, this command needs to be run to initialize DBMind according to the <code>CONF_DIRECTORY/dbmind.conf</code>.</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service setup -c CONF_DIRECTORY --initialize</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-start-or-stop-the-dbmind-service" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#start-or-stop-the-dbmind-service"></a>Start or Stop the DBMind Service</h4><p>After configuring, specify your CONF_DIRECTORY, users can start or stop the service directly.</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service start/stop -c CONF_DIRECTORY</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-component" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#component"></a>Component</h3><p>If users want to use a specific component offline. They can use the sub-command <code>component</code>:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component xxx ...</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p><code>xxx</code> is the name of a component. Users can also get the component list by using the <code>--help</code> argument.</p><p>For example, use the following component to tune the knobs of a database:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component xtuner --help</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h1><a id="user-content-license" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#license"></a>LICENSE</h1><p>Mulan PSL v2</p><h1><a id="user-content-reference" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#reference"></a>Reference</h1><ol><li><a href="https://gitee.com/link?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPercent-encoding">https://en.wikipedia.org/wiki/Percent-encoding</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fdba.stackexchange.com%2Fquestions%2F243219%2Fin-postgresql-url-i-cant-use-a-password-containing-special-characters">https://dba.stackexchange.com/questions/243219/in-postgresql-url-i-cant-use-a-password-containing-special-characters</a></li></ol>]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 02:37:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/opengauss/openGauss-DBMind</guid>
            <link>https://gitee.com/opengauss/openGauss-DBMind</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 反向 Debug 了解一下？揭秘 Java DEBUG 的基本原理]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Debug 的时候，都遇到过手速太快，直接跳过了自己想调试的方法、代码的时候吧……</p><p>一旦跳过，可能就得重新执行一遍，准备数据、重新启动可能几分钟就过去了。</p><p><img alt="Untitled.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-08oleiHOrAlh8kTie.png" referrerpolicy="no-referrer"></p><p>好在 IDE 们都很强大，还给你后悔的机会，可以直接删除某个 Stack Frame，直接返回到之前的状态，确切的说是返回到之前的某个 Stack Frame，从而实现让程序「逆向运行」。</p><p><img alt="Untitled 1.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-08tZjMjyHSbNdpAu8.png" referrerpolicy="no-referrer"></p><p>这个 Reset Frame 的能力，可不只是返回上一步，上 N 步也是可以的；选中你期望的那个帧，直接 Reset Frame/Drop Frame，可以直接回到调用栈上的某个栈帧，时间反转！</p><p>可惜这玩意也不是那么万能，毕竟是通过 stack pop 这种操作实现，实际上只是给调用栈栈顶的 N 个 frame pop 出来而已，还谈不上是真正的「反向 DEBUG」。</p><p>相比之下， GDB 的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sourceware.org%2Fgdb%2Fnews%2Freversible.html" rel="nofollow" target="_blank">Reverse Debugging</a>就比较强大，真正的 「反向」 DEBUG，逆向运行，实现回放。</p><p>所以吧在运行过程中，已经修改的数据，比如引用传递的方法参数、变量，一旦修改肯定回退不了，不然真的成时光机了。</p><p>这些乱七八糟的调试功能，都是基于 Java 内置的 Debug 体系来实现的。</p><span id="OSC_h1_1"></span><h1>JAVA DEBUG 体系</h1><p>Java 提供了一个完整的 Debug 体系<strong>JPDA</strong>(Java Platform Debugger Architecture)，这个 JPDA 架构体系由 3 部分组成：</p><ol><li><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Ftechnotes%2Fguides%2Fjvmti%2Findex.html" rel="nofollow" target="_blank">JVM TI</a>- Java VM Tool Interface</p></li><li><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Ftechnotes%2Fguides%2Fjpda%2Fjdwp-spec.html" rel="nofollow" target="_blank">JDWP</a>- Java Debug Wire Protocol</p></li><li><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Fjdk%2Fapi%2Fjpda%2Fjdi%2Findex.html" rel="nofollow" target="_blank">JDI</a>- Java Debug Interface</p></li></ol><p>如果结合 IDE 来看，那么一个完整的 Debug 功能看起来就是这个样子：</p><p><img alt="Untitled 2.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-08129VuqLlh19HeCExh.png" referrerpolicy="no-referrer"></p><p>解释一下这个体系：</p><p>JVM TI 是一个 JVM 提供的一个调试接口，提供了一系列控制 JVM 行为的功能，比如分析、调试、监控、线程分析等等。也就是说，这个接口定义了一系列调试分析功能，而 JVM 实现了这个接口，从而提供调试能力。</p><p>不过吧，这个接口毕竟是 C++的，调用起来确实不方便，所以 Java 还提供了 JDI 这么个 Java 接口。</p><p>JDI 接口使用 JDWP 这个私有的应用层协议，通过 TCP 和目标 VM 的 JVMTI 接口进行交互。</p><p>也可以把简单这个 JDWP 协议理解为 JSF/Dubbo 协议；相当于 IDE 里通过 JDI 这个 SDK，使用 JDWP 协议调用远程 JVMTI 的 RPC 接口，来传输调试时的各种断点、查看操作。</p><p>可能有人会问，搞什么套壳！要什么 JDWP，我直接 JVMTI 调试不是更香，链路越短性能越高！</p><p>当然可以，比如 Arthas 里的部分功能，就直接使用了 JVMTI 接口，要什么 JDI！直接 JVMTI 干就完了。</p><p>开个玩笑，Arthas 毕竟不是 Debug 工具，人家根本就不用 JDI 接口。而且 JVMTI 的能力也不只是断点，它的功能非常多：</p><p><img alt="Untitled 3.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-0819od43PdyVrEOjtTP.png" referrerpolicy="no-referrer"></p><p>左边的功能类，提供了各种乱七八糟的功能，比如我们常用的添加一个断点：</p><pre><code>jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

</code></pre><p>右边的事件类，可以简单的理解为回调；还是拿断点举例，如果我用上面的 SetBreakpoint 添加了一个断点，那么当执行到该位置时，就会触发这个事件:</p><pre><code>void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

</code></pre><p>JVMTI 的功能非常之多，而 JDI 只是实现了部分 JVMTI 的方法，所以某些专业的 Profiler 工具，可能会直接使用 JVMTI，从而实现更丰富的诊断分析功能。</p><span id="OSC_h1_2"></span><h1>远程调试与本地调试</h1><p>不知道大家有没有留意过本地 Debug 启动时的日志：</p><p><img alt="Untitled 4.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-08UAIUfwqu8mWHWTH.png" referrerpolicy="no-referrer"></p><p>第一行是隐藏了后半段的启动命令，展开后是这个样子：</p><pre><code>/path/to/java -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:53631,suspend=y,server=n -javaagent:/path/to/jetbrains/debugger-agent.jar ...

</code></pre><p>第二行是一个 Connected 日志，意思是使用 socket 连接到远程 VM 的 53631 端口</p><p>上一段说到，IDE 通过 JDI 接口，使用 JDWP 协议和目标 VM 的 JVMTI 交互。这里的 53631 端口，就是目标 JVM 暴露出的 JVM TI 的 server 端口。</p><p>而第一行里，IDEA 自动给我们加上了<code>-agentlib:jdwp=transport=dt_socket,address=127.0.0.1:53631</code>这么一段，这个参数的意思就是，让 jvm 以 53631 暴露 jdwp 协议</p><p>小知识，这个 agentlib 可不只是为 jvmti 提供的。它还可以让 JVM 加载其他的 native lib 包，直接「外挂」到你的 jvm 上，下面是「外挂」的参数格式：</p><p><img alt="Untitled 5.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-08Vy0912rKBUuOBMye.png" referrerpolicy="no-referrer"></p><p>所以吧，上面的描述其实不太严谨，更专业的说法是：</p><p>让 JVM 加载 JDWP 这个 agent 库，参数为<code>transport=dt_socket,address=127.0.0.1:53631</code>，这个 jdwp agent 库以 53631 端口提供了 jdwp 协议的 server。只不过这个 jdwp 是 jvm 内部的库，不需要额外的 so/dylib/dll 文件。</p><p>如有需要，你完全可以弄个 「datupiao」 的 agentlib，「外挂」到这个 jvm 上，然后在这个 lib 里调用 JVMTI 接口，然后暴露个端口提供服务和远程交互，实现自己的 jdwp！</p><p>可能某些老板们注意到了，本地调试还要 127.0.0.1 走 tcp 交互一遍，那远程调试呢？</p><p>基于上面的解释，本地调试和远程调试真的没啥区别！或者说，在目前 IDEA/Eclipse 的实现下，不存在本地调试，都是远程！只不过一个是 127.0.0.1，一个是远程的 IP 而已。</p><p>在本地调试时，IDEA 会自动给我们的 JVM 增加<code>agent</code>参数，随机指定一个端口，然后通过 JDI 接口连接，代码大概长这样（JDI 的 SDK 在 JDK_HOME/lib/tools.jar ）：</p><pre><code>Map&lt;String, Connector.Argument&gt; env = connector.defaultArguments();
env.get("hostname").setValue(hostname);
env.get("port").setValue(port);

VirtualMachine vm = connector.attach(env);

</code></pre><p>瞅瞅， VirtualMachine 里的就这点方法，能力上比 JVMTI 还是差远了</p><pre><code>List&lt;ReferenceType&gt; classesByName(String className);

List&lt;ReferenceType&gt; allClasses();

void redefineClasses(Map&lt;? extends ReferenceType, byte[]&gt; classToBytes);

List&lt;ThreadReference&gt; allThreads();

void suspend();

void resume();

List&lt;ThreadGroupReference&gt; topLevelThreadGroups();

EventQueue eventQueue();

EventRequestManager eventRequestManager();

VoidValue mirrorOfVoid();

Process process();

</code></pre><p>再回来看看 IDEA 中独立的远程调试，配置好之后，红框里的信息会提示你 ，远程的 JVM 需增加这一段启动参数，而且支持多个版本 JDK 的格式，CV 大法就能直接用。</p><p><img alt="Untitled 6.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-09aZdTrWaGxcoBVtI.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_3"></span><h1>-agentlib 和 -javaagent</h1><p>有些细心的同学可能发现了，IDEA 默认的启动脚本里，同时配置了 -agentlib 和 -javaagent。</p><pre><code>-javaagent:/path/to/jetbrains/debugger-agent.jar 

</code></pre><p>这个 debugger-agent 吧，其实也没干啥事，只是对 JDK 内置的一些线程做了些增强，辅助 IDEA 的 debug 功能，支持一些异步的调试。</p><p><img alt="Untitled 7.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-09uMEzNf19FBA12z11N.png" referrerpolicy="no-referrer"></p><p>agentlib、javaagent 这俩兄弟，定位其实很像，都是加载自定义的代码。</p><p>不过区别在于，agentlib 是加载 native lib，需要 c/cpp 去写，相当于外挂自己的代码在 jvm 上，可以为所欲为，比如在 agentlib 里调用上面说的 JVMTI 。</p><p>而 javaagent 是用 java 写的，可以直接用上层的 Instrumentation API，做一些类的增强转换之类，这也是大多数 APM Agent、Profiler Agent 实现的基本原理。</p><span id="OSC_h1_4"></span><h1>Arthas 的玩法</h1><p>Arthas 的核心入口，其实还是 javaagent，支持静态加载和动态加载两种玩法。</p><p>静态没啥好说的，启动脚本里增加一个<code>-javaagent:/tmp/test/arthas-agent.jar</code>，然后为所欲为。</p><p>动态的叫 attach，使用 Java 提供的<code>VirtualMachine</code>就可以实现运行时添加 -javaagent，效果一样：</p><pre><code>VirtualMachine virtualMachine = VirtualMachine.attach(virtualMachineDescriptor);
virtualMachine.loadAgent(agentPath, agentArgs);

</code></pre><p>这个 Agent 在 JVM 里启动了一个 TCP server，用于收发 Arthas Client 的各种 trace、watch 、Dashboard 等指令，然后通过 Instrumentation 增强 Class 插入代码、或者直接调用某些 Java API，实现各种功能。</p><p>注意到了吗？Arthas 可以直接下载一个 jar 包，java -jar 就能连上。</p><p>其实吧，它这个直接启动的 jar 包，是一个 boot 包，启动之后把乱七八糟的 jar 都下载下来。接着动态 attach 的方式，连接到本机指定进程号的 JVM，然后再为所欲为。</p><p>在 3.5 版本之后，Arthas 还新增了一个<strong><strong>vmtool</strong></strong>命令，这个命令可以直接获取内存中的指定对象实例。</p><pre><code>$ vmtool --action getInstances --className java.lang.String --limit 10
@String[][
    @String[com/taobao/arthas/core/shell/session/Session],
    @String[com.taobao.arthas.core.shell.session.Session],
    @String[com/taobao/arthas/core/shell/session/Session],
    @String[com/taobao/arthas/core/shell/session/Session],
    @String[com/taobao/arthas/core/shell/session/Session.class],
    @String[com/taobao/arthas/core/shell/session/Session.class],
    @String[com/taobao/arthas/core/shell/session/Session.class],
    @String[com/],
    @String[java/util/concurrent/ConcurrentHashMap$ValueIterator],
    @String[java/util/concurrent/locks/LockSupport],
]

</code></pre><p>直接获取内存对象，这玩意只靠 Instrumentation API 可做不到。Arthas 搞了个骚操作，直接 JNI 调用自定义 lib，用过 cpp 直接调用了 JVMTI 的 API，融合了 Instrumentation 和 JVMTI 的能力，这下是真的为所欲为了！</p><pre><code>#include &lt;stdio.h&gt;
#include &lt;jni.h&gt;
#include &lt;jni_md.h&gt;
#include &lt;jvmti.h&gt;
#include "arthas_VmTool.h" // under target/native/javah/

static jvmtiEnv *jvmti;

...

extern "C"
JNIEXPORT jobjectArray JNICALL
Java_arthas_VmTool_getInstances0(JNIEnv *env, jclass thisClass, jclass klass, jint limit) {
    jlong tag = getTag();
    limitCounter.init(limit);
    jvmtiError error = jvmti-&gt;IterateOverInstancesOfClass(klass, JVMTI_HEAP_OBJECT_EITHER,
                                               HeapObjectCallback, &amp;tag);
    if (error) {
        printf("ERROR: JVMTI IterateOverInstancesOfClass failed!%u\n", error);
        return NULL;
    }

    jint count = 0;
    jobject *instances;
    error = jvmti-&gt;GetObjectsWithTags(1, &amp;tag, &amp;count, &amp;instances, NULL);
    if (error) {
        printf("ERROR: JVMTI GetObjectsWithTags failed!%u\n", error);
        return NULL;
    }

    jobjectArray array = env-&gt;NewObjectArray(count, klass, NULL);
    //添加元素到数组
    for (int i = 0; i &lt; count; i++) {
        env-&gt;SetObjectArrayElement(array, i, instances[i]);
    }
    jvmti-&gt;Deallocate(reinterpret_cast&lt;unsigned char *&gt;(instances));
    return array;
}

</code></pre><span id="OSC_h1_5"></span><h1>总结</h1><ol><li><p>Debug 基于 JDPA 体系</p><ol><li><p>IDE 直接接入 JDPA 体系中的 JDI 接口完成</p></li><li><p>JDI 通过 JDWP 协议，调用远程 VM 的 JVMTI 接口</p></li><li><p>JDWP 是通过 agentlib 加载的，agentlib 算是一个 native 的静态「外挂」接口</p></li></ol></li><li><p>javaagent 是 JAVA 层面的「外挂」接口，用过 Instrumentation API（Java）实现各种功能，主要用于 APM、Profiler 工具</p></li><li><p>如果你想，在 javaagent 里调用功能更丰富的 JVMTI 也不是不行。</p></li></ol><blockquote><p>作者：京东保险，蒋信</p><p>来源：京东云开发者社区，转载请注明来源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 02:32:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10388524</guid>
            <link>https://my.oschina.net/u/4090830/blog/10388524</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
    </channel>
</rss>
