<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-最新资讯]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-最新资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 20 Oct 2023 00:32:50 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[北大开源代码大模型 CodeShell，提供了配套的 IDE 插件]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>北京大学知识计算实验室联合四川天府银行 AI 团队，正式开源 70 亿参数的代码大模型&nbsp;CodeShell，并提供了与 CodeShell 配套的部署方案与 IDE 插件，具体查看&nbsp;<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FWisdomShell%2Fcodeshell" target="_blank">CodeShell</a>&nbsp;</u></strong>代码库。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-78f14c27454c7f47bd89405366b1af6ca1a.png" referrerpolicy="no-referrer"></p><p>官方介绍称，CodeShell 具有 70 亿参数，采用五千亿 Tokens 进行了训练，上下文窗口长度为 8192。CodeShell 的原始训练数据基于自己爬取的 GitHub 数据、Stack 和 StarCoder 数据集，以及少量高质量的中英文数据。</p><p>在权威的代码评估 Benchmark（HumanEval 与 MBPP）中，CodeShell 取得同等规模最好的性能。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-78c60cbccc31a8205f373d3e9f137b44b48.png" referrerpolicy="no-referrer"></p><p>本次开源的模型如下：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FWisdomShell%2FCodeShell" target="_blank"><strong>CodeShell Base</strong></a>：CodelShell 底座模型，具有强大的代码基础能力。</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FWisdomShell%2FCodeShell-Chat" target="_blank"><strong>CodeShell Chat</strong></a>：CodelShell 对话模型，在代码问答、代码补全等下游任务重性能优异。</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FWisdomShell%2FCodeShell-Chat-int4" target="_blank"><strong>CodeShell Chat 4bit</strong></a>：CodelShell 对话模型 4bit 量化版本，在保证模型性能的前提下内存消耗更小，速度更快。</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FWisdomShell%2Fllama_cpp_for_codeshell" target="_blank"><strong>CodeShell CPP</strong></a>：CodelShell 对话模型 CPP 版本，支持开发者在没有 GPU 的个人电脑中使用。注意，CPP 版本同样支持量化操作，用户可以在最小内存为 8G 的个人电脑中运行 CodeShell。</li></ul><hr><p>下图是 CodeShell 代码助手的 VS Code 插件截图：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-bbb4f00f915125e1971b962f89b6171a932.png" referrerpolicy="no-referrer"></p><p>IDEA 插件：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d1b86e58fd179b1bec428a6bb3d46c2981a.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 19 Oct 2023 09:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262460/codeshell-llm</guid>
            <link>https://www.oschina.net/news/262460/codeshell-llm</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[2023 年 WebAssembly 现状：Swift、Zig 采用率显着增加]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="color:#000000">2023 年 WebAssembly 现状调查报告现已<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.scottlogic.com%2F2023%2F10%2F18%2Fthe-state-of-webassembly-2023.html" target="_blank">出炉</a>，一些亮点内容如下：</span></p><ul><li><span style="color:#000000">Rust 和 JavaScript 的使用量正在持续增长。与此同时，Swift 和 Zig 的采用率也都在显着增加。</span></li><li><span style="color:#000000">开发人员对 Zig、Kotlin 和 C# 语言的使用渴望超过了当前的使用率。</span></li><li><span style="color:#000000">WebAssembly 仍然最常用于 Web 应用程序开发，但 Serverless 的使用率正在持续上升，WebAssembly 作为插件环境的使用率也在上升。</span></li><li><span style="color:#000000">线程、垃圾收集和相对较新的组件模型提案，是大家最感兴趣的 WebAssembly 发展方向。</span></li><li><span style="color:#000000">对于 WASI，最受关注的是 I/O 提案（例如 HTTP、文件系统）。</span></li><li><span style="color:#000000">受访者对 WAI 发展的满意度明显低于对 WebAssembly 发展的满意度。</span></li><li><span style="color:#000000">许多受访者表示，他们希望 WebAssembly 能够兑现 Java 最初做出的「write once and run anywhere」承诺。</span></li></ul><p><strong>语言</strong></p><p><span style="background-color:#ffffff; color:#0a0a0a">Rust 已经连续第三年成为 WebAssembly 最常用的语言，其次是 JavaScript。</span><span><span><span><span><span><span><span style="color:#0a0a0a"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Swift 是 WebAssembly 生态系统中相对较新的成员，始于几年前对 Apple 的 Swift 存储库添加 wasm 目标的拉取请求，不过该请求目前仍未被合并。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><img height="290" src="https://oscimg.oschina.net/oscnet/up-529a4a5bd1ede66a6c8897124867a6f9d68.png" width="500" referrerpolicy="no-referrer">&nbsp;<img height="290" src="https://oscimg.oschina.net/oscnet/up-124f86b04acdb4659a3e60fbd77bf7a26d7.png" width="371" referrerpolicy="no-referrer"></p><p><span style="color:#000000">调查发现，<span style="background-color:#ffffff">WebAssembly&nbsp;</span>工具开发人员对 Rust 有着强烈的偏好，并且也喜欢直接使用 WAT（WebAssembly 文本格式）对 WebAssembly 进行编程；同时还对 Go 和 Python 也有着强烈的偏好。</span></p><p><img height="261" src="https://oscimg.oschina.net/oscnet/up-367dcaf11d60128ed859b232819447af541.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">在被问及「希望将来使用哪种语言来开发使用 WebAssembly 的应用程序？」的问题时，被提及最多的依然是&nbsp;<span style="background-color:#ffffff">Rust，其次是&nbsp;JavasScript，而排在第三位的语言则是目前使用频率较低的 Zig。</span></span></p><p><img height="290" src="https://oscimg.oschina.net/oscnet/up-6e01877e82f62682c549874e79cf3f0e558.png" width="500" referrerpolicy="no-referrer"></p><p><img height="291" src="https://oscimg.oschina.net/oscnet/up-9dc0076729ffa1bc3beb47cd6b63e4e6e5b.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><strong><span><span><span><span><span style="color:#0a0a0a"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>WebAssembly 的实际应用</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><span style="background-color:#ffffff; color:#0a0a0a">Web 应用程序开发仍然处于领先地位，但差距正在缩小。</span></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><img height="290" src="https://oscimg.oschina.net/oscnet/up-6554f8ad47d5b7a5482d251465fa5323e03.png" width="515" referrerpolicy="no-referrer">&nbsp;<img height="290" src="https://oscimg.oschina.net/oscnet/up-873833dae39174a594d8c19b45f8e627f95.png" width="399" referrerpolicy="no-referrer"></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><span style="background-color:#ffffff; color:#0a0a0a">就 WebAssembly 在组织中的采用现状而言，41% 的受访者透露其正在生产中使用 WebAssembly，还有 28% 的受访者表示正在试点或计划在明年使用。</span></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><img height="293" src="https://oscimg.oschina.net/oscnet/up-b5cc0681dcd4d5738a298eab1bf287dbfb7.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start">受访者认为，<span style="background-color:#ffffff; color:#0a0a0a">通过 WASI 实现更好的非浏览器集成</span>、<span style="background-color:#ffffff; color:#0a0a0a">更好的调试支持等功能</span>可以有效的推动&nbsp;<span style="background-color:#ffffff; color:#0a0a0a">WebAssembly 的进一步采用。</span></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><img height="295" src="https://oscimg.oschina.net/oscnet/up-292329d5a3f2a7ca5d7bb9f4044150330c1.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><span style="background-color:#ffffff; color:#000000">更多详情可</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.scottlogic.com%2F2023%2F10%2F18%2Fthe-state-of-webassembly-2023.html" target="_blank">查看完整报告</a><span style="background-color:#ffffff; color:#000000">。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 19 Oct 2023 09:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262453/the-state-of-webassembly-2023</guid>
            <link>https://www.oschina.net/news/262453/the-state-of-webassembly-2023</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Windows 11 月活跃设备数超过 4 亿台]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>根据 Windows Central 的<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.windowscentral.com%2Fsoftware-apps%2Fwindows-11%2Fexclusive-windows-11-is-active-on-almost-half-a-billion-devices-ahead-of-microsofts-expectations" target="_blank">报道</a></u>，<span style="color:#252a2d">微软内部数据显示，目前<strong>运行 Windows 11 的月活跃设备已超过 4 亿台</strong>，并且正在稳步增长，预计到 2024 年初达到 5 亿台。</span></p><p><span style="color:#252a2d">从这份数据来看，Windows 11&nbsp;</span>普及率明显要比上一代 Windows 10 更慢。Windows 11 于 2021 年 10 月发布，这意味着它花了大约两年的时间才达到这一里程碑，相比 Windows 10 要慢得多，后者在一年多的时间里就达到了同样的水平。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3e5b147c33f77b535e10cc9655b79dceebe.png" referrerpolicy="no-referrer"></p><p>Windows Central 称，采用率的差异可归因于两个操作系统不同的发布策略。Windows 10 最初作为 Windows 7 和 Windows 8 的限时免费升级而推出，微软一直在敦促用户在免费升级期结束前尽快升级。</p><p>相比之下，Windows 11 的发布较为平静，而且由于 TPM 的要求，支持的 PC 数量较少，因此采用率较低。</p><p>虽然 Windows 11 采用率到达里程碑的速度没有 Windows 10 快，但这也已经超出了微软自己对 Windows 11 采用率的预期。</p><p>根据流量监测机构 StatCounter 的数据，Windows 10 仍然以 71.62% 的市场份额牢牢控制着桌面 Windows 市场。与此同时，Windows 11 占所有 Windows 桌面安装量的 23.64%。Windows 7 的市场份额下降到 3.33%，而 Windows XP 的市场份额仅为 0.34%。</p><p>根据微软的内部指标，Windows 11 的势头很强劲。尽管最初存在争议和兼容性问题，但微软通过频繁的更新和预览选项，让 Windows 11 对新设备和现有设备都充满了吸引力。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 19 Oct 2023 06:39:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262425/windows-11-is-active-on-almost-half-a-billion-device</guid>
            <link>https://www.oschina.net/news/262425/windows-11-is-active-on-almost-half-a-billion-device</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[8 月国内手机市场出货量 1898.5 万部，5G 手机占比 82.4%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="background-color:#ffffff; color:#333333">中国信通院</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FiAHQPiCOzs1Yfa2bjgOZPQ" target="_blank">发布</a><span style="background-color:#ffffff; color:#333333">了 2023 年 8 月国内手机市场运行分析报告，具体情况如下：</span></p><p style="margin-left:0; margin-right:0"><strong>一、国内手机市场总体情况</strong></p><p style="margin-left:0; margin-right:0">2023 年 8 月，国内市场手机出货量 1898.5 万部，同比增长 0.03%，其中，5G 手机 1564.5 万部，同比增长 9.6%，占同期手机出货量的 82.4%。</p><p style="margin-left:0; margin-right:0">2023 年 1-8 月，国内市场手机总体出货量累计 1.67 亿部，同比下降 4.5%，其中，5G 手机出货量 1.33 亿部，同比下降 3.8%，占同期手机出货量的 79.5%。</p><p style="margin-left:0; margin-right:0"><img height="306" src="https://oscimg.oschina.net/oscnet/up-2c643a53dd7693f0057105e72029463071d.png" width="500" referrerpolicy="no-referrer"></p><p>2023 年 8 月，国内手机上市新机型 55 款，同比增长 14.6%，其中 5G 手机 30 款，同比增长 50.0%，占同期手机上市新机型数量的 54.5%。</p><p style="margin-left:0; margin-right:0">2023 年 1-8 月，上市新机型累计 293 款，同比增长 8.1%，其中 5G 手机 133 款，同比下降 5.7%，占同期手机上市新机型数量的 45.4%。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="312" src="https://oscimg.oschina.net/oscnet/up-917be2330c145e58fc7ac99ceca87baf701.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>二、国内手机市场国内外品牌构成</strong></p><p style="margin-left:0; margin-right:0">2023 年 8 月，国产品牌手机出货量 1684.3 万部，同比下降 5.7%，占同期手机出货量的 88.7%；上市新机型 47 款，同比增长 23.7%，占同期手机上市新机型数量的 85.5%。</p><p style="margin-left:0; margin-right:0">2023 年 1-8 月，国产品牌手机出货量累计 1.38 亿部，同比下降 8.7%，占同期手机出货量的 82.7%；上市新机型累计 266 款，同比增长 7.3%，占同期手机上市新机型数量的 90.8%。</p><p style="margin-left:0; margin-right:0"><img height="251" src="https://oscimg.oschina.net/oscnet/up-d20eb80b2c4db91a395325de68931501eda.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>三、国内智能手机发展情况</strong></p><p style="margin-left:0; margin-right:0">2023 年 8 月，智能手机出货量 1792.6 万部，同比下降 1.2%，占同期手机出货量的 94.4%。2023 年 1-8 月，智能手机出货量 1.60 亿部，同比下降 6.7%，占同期手机出货量的 95.5%。</p><p style="margin-left:0; margin-right:0"><img height="278" src="https://oscimg.oschina.net/oscnet/up-59caa5d22c4a5db7c64c222baacfc1365a4.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">2023 年 8 月，智能手机上市新机型 46 款，同比增长 7.0%，占同期手机上市新机型数量的 83.6%。2023 年 1-8 月，智能手机上市新机型累计 247 款，同比增长 7.9%，占同期上市新机型数量的 84.3%。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 19 Oct 2023 06:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262420</guid>
            <link>https://www.oschina.net/news/262420</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[ScyllaDB 获 4300 万美元融资，NoSQL 数据库市场再掀热潮！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" target="_blank">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt; <img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><blockquote><p>ScyllaDB 是一家成立于 2012 年 12 月的美国公司，总部位于加利福尼亚州桑尼维尔。作为一家数据密集型应用程序数据库供应商，ScyllaDB 生产的 NoSQL 数据库兼容 Apache Cassandra 和 Amazon DynamoDB，具有可靠的低延迟和 10 倍的吞吐量。在 2023 年 10 月 17 日，该公司成功获得了 4300 万美元的融资。截至目前，ScyllaDB 已经筹集了 1.03 亿美元的风险投资。</p></blockquote><h1>关于 ScyllaDB 公司</h1><p>本篇内容是根据 Kyle Wiggers 发布在 TechCrunch 网站上的文章翻译整理，以下是玖章算术 NineData 的工程师点评： ：</p><ul><li>&nbsp; 对于日新月异的高科技领域，NoSQL 属于爷爷辈的技术名词。ScyllaDB 成立在 10+年前，对标 MongoDB, Cassandra 和 DynamoDB，依然显示其生命活力，主要的优势在于其向云原生的成功转型，精简的团队（168 人）和成功的生态构建。</li><li>&nbsp; 在市场相对萎靡的情况下，作为一个数据库引擎公司，获得了投资者的青睐，说明投资方对于优质团队的信心。当然，我们也要看到现在数据库系统的公司暂时的困境，比如去年勉强上市的 MariaDB，从$10 跌到$0.60，最近又传出其主力 Xpand 团队解散的消息，让人唏嘘不已呀。另外打个广告，如果有团队招收数据库内核工程师，我可以直接推荐 MariaDB 资深开发。Xpand 是基于 MySQL 类似于国内 PolarDB/OceanBase/TiDB 的分布式 OLTP 数据库。</li></ul><h1>ScyllaDB 新一轮融资 4300 万美元</h1><p>投资者似乎对数据库情有独钟。</p><p>10 月 17 日，ScyllaDB 宣布在一轮融资中获得了<strong>4300 万美元</strong>，ScyllaDB 为需要高吞吐量和低延迟的数据密集型应用提供数据库。本次领投方为 Eight Roads Ventures，参与投资方包括 AB Private Credit Investors、AllianceBernstein、TLV partners、Magma Ventures 和 Qualcomm Ventures 等。</p><p><img src="https://oscimg.oschina.net/oscnet/up-d54c5782f6b139a5d486d1140a2c79c6f77.png" alt="" referrerpolicy="no-referrer"></p><p>据联合创始人兼 CEO Dor Laor 介绍，这笔新资金将用于「加速」ScyllaDB 的发展势头，以及扩大拥有 168 人的团队规模。</p><p>Laor 在接受 TechCrunch 的电子邮件采访时表示：「如今的颠覆者正在吸收前所未有的数据量，并利用它提供不同的用户体验，改变市场格局并取代传统领导者，数据正在通过多个来源进行丰富、清洗、流式传输、输入到 AI 和机器学习流程，并进行复制和缓存。因此，拥有一个能胜任任务的数据库比以往任何时候都更加重要。」</p><h1>ScyllaDB 简介</h1><p><img src="https://oscimg.oschina.net/oscnet/up-d7c6b7d347101eb1b5893015fe1dee6e332.jpg" alt="" referrerpolicy="no-referrer"></p><p>ScyllaDB 被称为一种 NoSQL 数据库，与在企业中曾经占主导地位的关系型数据库不同，它提供了不依赖于「表关系」模型的数据存储和检索机制。在表关系模型中，关系是两个数据表之间的连接。但是使用 NoSQL 数据库，关系不必遵循这种模式，这提供了更大的工程灵活性，在某些情况下还可以提高性能</p><p>NoSQL 数据库常用于广告投放、人工智能和机器学习、推荐和个性化引擎、欺诈检测以及分析物联网设备的数据等应用。</p><p>根据 Ventana 公司 2022 年的一项调查，近四分之一（22%）的企业目前正在生产中使用 NoSQL 数据库，而超过三分之一（34%）的企业正计划在两年内采用 NoSQL 数据库或评估其潜在用途。而 NoSQL 市场预计将增长到报告的规模。</p><p>现在，ScyllaDB 并不是唯一的 NoSQL 供应商。类似的产品还有 ArangoDB、Redis Labs 和 Crate.io 等等，更不用提像 MongoDB、亚马逊的 DynamoDB 和 Couchbase 这样的大型供应商了。</p><p>但 ScyllaDB 声称，它的技术具有架构优势，比如每秒可执行数百万次操作，延迟时间仅为 "个位数毫秒"。ScyllaDB 能在多个云平台、混合云环境或本地运行，并通过工作负载优先级进行 I/O 和 CPU 性能的自动调整，将工作负载放置在单个服务器集群下。</p><p>显然，这些声明和能力足以吸引客户。ScyllaDB 表示，包括 Discord、Epic Games 和 Palo Alto Networks 在内的 400 多家公司现在正在使用其数据库，并且自 2012 年 12 月成立以来，收入已增长了 800%。</p><p>Laor 表示：「在各行各业，研发团队越来越意识到，ScyllaDB 与众不同的数据库架构为数据密集型工作负载提供了更好的性能和横向可扩展性。ScyllaDB 旨在帮助快速增长、快节奏的团队在大规模情况下提供闪电般快速的用户体验... ScyllaDB 的独特架构充分利用现代云资源，提供令人印象深刻的效率和性价比。」</p><p>截至目前，ScyllaDB 已经筹集了 1.03 亿美元的风险投资。</p><hr><p>原文链接： &nbsp; <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2023%2F10%2F17%2Fscylladb-raises-43m-to-scale-its-nosql-database-platform%2F" target="_blank">https://techcrunch.com/2023/10/17/scylladb-raises-43m-to-scale-its-nosql-database-platform/</a></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 19 Oct 2023 06:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/ninedata/blog/10120349</guid>
            <link>https://my.oschina.net/ninedata/blog/10120349</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Spring Batch 5.1 RC1]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>Spring Batch 5.1 发布了首个 RC 版本。</p><blockquote><p>Spring Batch 是一个轻量级且功能全面的批处理框架，使用 Spring 和 Java 编写离线和批处理应用程序，旨在为开发对企业系统日常运行至关重要的批处理应用程序提供支持。</p></blockquote><p><strong>主要变化</strong></p><ul><li><strong>更新入门指南</strong></li></ul><p>新增「<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-batch%23two-minutes-tutorial" target="_blank">两分钟上手教程</a>」，其中包含创建 Spring Batch 项目并实现简单的"Hello world"任务的步骤指南。</p><p>当前基于 Spring Boot 的指南已更新到最新的 Spring Boot 3 版本，以展示如何使用 Spring Batch 5 中的新功能（例如支持 Java Records）。</p><ul><li><strong>改进示例</strong></li></ul><p>在此版本中，开发团队重新编写了示例套件中的所有代码示例。</p><p>这些示例现在按功能组织在单独的包中，以便用户更容易理解和掌握 Spring Batch 中的特定功能。主要的&nbsp;<code>README</code>&nbsp;文件包含一个表格，其中显示可用示例及其涵盖的功能。</p><p>详情：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-batch%2Ftree%2Fmain%2Fspring-batch-samples" target="_blank">Spring Batch Samples</a></p><ul><li><strong>升级依赖</strong></li></ul><p>Spring Framework 6.1.0-RC1<br> Spring Integration 6.2.0-RC1<br> Spring Data 3.2.0-RC1<br> Spring LDAP 3.2.0-RC1<br> Spring AMQP 3.1.0-RC1<br> Spring Kafka 3.1.0-RC1<br> Micrometer 1.12.0-RC1</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspring.io%2Fblog%2F2023%2F10%2F18%2Fspring-batch-5-1-rc1-is-out" target="_blank">详情查看发布公告</a></u>。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 19 Oct 2023 03:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262402/spring-batch-5-1-rc1-released</guid>
            <link>https://www.oschina.net/news/262402/spring-batch-5-1-rc1-released</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[X Editor —— 嵌入到浏览器的文本编辑器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="project_detail_above_text_link_1" data-tracepid="project_detail_above_text_link"><a style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" target="_blank">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt; <img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p><strong>X 编辑器</strong>是嵌入在浏览器中的文本编辑器。它可以访问用户的本地文件系统，并且预览 Markdown 文件。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3a2387fc2caa6def043f8ee1e0e789064b9.png" referrerpolicy="no-referrer"></p><p>目前支持 Chrome、Edge 和 Opera 等基于 Chromium 的浏览器。</p><p><strong>运行截图</strong></p><ul><li>预览 Markdown 文件</li></ul><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-48a05913c04b8748b77d9c113a2f1b2e9d8.png" referrerpolicy="no-referrer"></p><ul><li>播放 MP3 文件</li></ul><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-13b162d7dc910af35cbf13dc10110cfcde2.png" referrerpolicy="no-referrer"></p><ul><li>观看视频</li></ul><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1d4d98955df4f8a5db0a17df183260adb2a.png" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 19 Oct 2023 02:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/x-editor</guid>
            <link>https://www.oschina.net/p/x-editor</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 终端仿真软件 quardCRT]]>
            </title>
            <description>
                <![CDATA[<p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Fwindows.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/windows.yml?branch=main&amp;logo=windows" alt="Windows ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Flinux.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/linux.yml?branch=main&amp;logo=linux" alt="Linux ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Fmacos.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/macos.yml?branch=main&amp;logo=apple" alt="Macos ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.codefactor.io%2Frepository%2Fgithub%2Fqqxiaoming%2FquardCRT"><img src="https://img.shields.io/codefactor/grade/github/qqxiaoming/quardCRT.svg?logo=codefactor" alt="CodeFactor" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/license/qqxiaoming/quardCRT.svg?colorB=f48041&amp;logo=gnu" alt="License" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Freleases"><img src="https://img.shields.io/github/tag/QQxiaoming/quardCRT.svg?logo=git" alt="GitHub tag (latest SemVer)" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Freleases"><img src="https://img.shields.io/github/downloads/QQxiaoming/quardCRT/total.svg?logo=pinboard" alt="GitHub All Releases" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/stars/QQxiaoming/quardCRT.svg?logo=github" alt="GitHub stars" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/forks/QQxiaoming/quardCRT.svg?logo=github" alt="GitHub forks" referrerpolicy="no-referrer"></a><a href="https://gitee.com/QQxiaoming/quardCRT"><img src="https://gitee.com/QQxiaoming/quardCRT/badge/star.svg?theme=dark" alt="Gitee stars" referrerpolicy="no-referrer"></a><a href="https://gitee.com/QQxiaoming/quardCRT"><img src="https://gitee.com/QQxiaoming/quardCRT/badge/fork.svg?theme=dark" alt="Gitee forks" referrerpolicy="no-referrer"></a></p><h1><a id="quardcrt" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#quardcrt"></a>quardCRT</h1><p><a href="https://gitee.com/QQxiaoming/quardCRT/blob/main/README.md">English</a> | 简体中文</p><p>quardCRT 一款终端仿真软件，支持多种后端协议，无依赖跨平台使用，windows/linux/mac 使用体验完全一致，支持多标签页和历史记录管理。</p><table><thead><tr><th align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/windows.png" alt="img2" referrerpolicy="no-referrer"></th></tr></thead><tbody><tr><td align="center">Windows</td></tr><tr><td align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/macos.png" alt="img1" referrerpolicy="no-referrer"></td></tr><tr><td align="center">MacOS</td></tr><tr><td align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/linux.png" alt="img3" referrerpolicy="no-referrer"></td></tr><tr><td align="center">Linux</td></tr></tbody></table><p>其他协议选择界面：</p><p><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/img4.png" alt="img4" referrerpolicy="no-referrer"></p><h2><a id="功能描述" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E5%8A%9F%E8%83%BD%E6%8F%8F%E8%BF%B0"></a>功能描述</h2><ul><li><p>目前支持的终端协议包括：</p><ul><li>telnet (支持带 websocket 封装)</li><li>serial</li><li>loaclshell</li><li>rawsocket</li></ul></li><li><p>多标签页管理，标签页克隆，标签页拖拽排序</p></li><li><p>双列分屏</p></li><li><p>工作目录书签</p></li><li><p>自动化发送</p></li><li><p>HEX 显示</p></li><li><p>会话记录管理</p></li><li><p>终端样式配置</p></li><li><p>自定义字体 (进行中，目前固定等宽字体，大小可配置)</p></li></ul><h2><a id="贡献" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E8%B4%A1%E7%8C%AE"></a>贡献</h2><p>如果您对本项目有建议或想法，欢迎在 GitHub 或 Gitee 上提交 issue 和 pull requests。</p><p>目前项目建议使用版本 Qt6.2.0 或更高版本。</p><h2><a id="感谢" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E6%84%9F%E8%B0%A2"></a>感谢</h2><p>本项目代码引用或部份参考或依赖了以下开源项目，项目完全尊重原项目开源协议，并在此表示感谢。</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FColinDuquesnoy%2FQDarkStyleSheet">QDarkStyleSheet</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fdridk%2FQFontIcon">QFontIcon</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fsilderan%2FQTelnet">QTelnet</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Flxqt%2Fqtermwidget">qtermwidget</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fkafeg%2Fptyqt">ptyqt</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fbitmeal%2Fargv_split">argv_split</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmbadolato%2FiTerm2-Color-Schemes">iTerm2-Color-Schemes</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Frprichard%2Fwinpty">winpty</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FSM-nzberg%2FQtFancyTabWidget">QtFancyTabWidget</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fteknoraver%2Fqtftp">qtftp</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FJuliaStrings%2Futf8proc">utf8proc</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Ffcitx%2Ffcitx-qt5">fcitx-qt5</a></li></ul>]]>
            </description>
            <pubDate>Thu, 19 Oct 2023 02:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/QQxiaoming/quardCRT</guid>
            <link>https://gitee.com/QQxiaoming/quardCRT</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 架构师日记 - 聊聊开发必掌握的那些实践技能]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" target="_blank">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt; <img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><span id="OSC_h1_1"></span><h1><span><span><span>一，引言</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>尽管软件开发一直致力于追求高效、可读性强、易于维护的特性，但这些特性却像是一个不可能三角，相互交织，此消彼长。就像底层语言（如汇编和 C 语言）能够保持高效的运行性能，但在可读性和维护性方面却存在短板和劣势；而高级语言（如 Java 和 Python）在可读性和可维护性方面表现出色，但在执行效率方面却存在不足。</span></span></span></p><blockquote><span><span><span>构建语言生态的优势，弥补其存在短板，始终是编程语言的一个演进方向。</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>不同编程语言，拥有不同的特性和规约，下面就以 JAVA 语言为例，细数那些开发过程中容易被人忽略，但必须掌握的知识点和实践技能。</span></span></span></p><span id="OSC_h1_2"></span><h1><span><span><span>二，基础篇</span></span></span></h1><blockquote><span><span><span>1999 年，美国太空总署（NASA）的火星任务失败：在这次任务中，</span></span></span><span><span><span style="color:#191919">火星气候探测者号上的飞行系统软件使用公制单位牛顿计算推进器动力，而地面人员输入的方向校正量和推进器参数则使用英制单位磅力，导致探测器进入大气层的高度有误，最终瓦解碎裂。</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这是由于国际标准（牛）和本土化（磅）的冲突导致的一起事故。由此引出了程序需要关注可维护性这个话题，由于软件生产往往需要多人协作，可维护性正是协作共识里的重要一环。关于这方面，让人最容易想到的就是命名和注释两个方面了，下面就展开来探讨一下。</span></span></span></p><span id="OSC_h3_3"></span><h3><span><span><span>2.1 关于命名</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>按照阅读习惯，程序的变量命名法都需要克服单词间的空格问题，从而把不同单词串连起来，最终达到创造出一种易于阅读的新「单词」的效果。常见的命名方法有以下几种：</span></span></span></p><ul><li><span><span><span><strong><span>蛇形命名法</span></strong></span></span><span><span><span>（snake case）：又叫下划线命名法，使用下划线，单词小写，比如：my_system;</span></span></span></span></li><li><span><span><span><strong><span>驼峰命名法</span></strong></span></span><span><span><span>（camel case）：按照单词首字母区分大小写，又可细分为大驼峰命名法和小驼峰命名法，比如：MySystem，mySystem;</span></span></span></span></li><li><span><span><span><strong><span>匈牙利命名法</span></strong></span></span><span><span><span>（HN case）：属性+类型+描述，比如：nLength，</span></span></span><span><span><span style="background-color:#ffffff; color:#333333">g_cch</span></span></span><span><span><span>,</span></span></span><span><span><span style="background-color:#ffffff; color:#333333">hwnd；</span></span></span></span></li><li><span><span><span><strong><span>帕斯卡命名法</span></strong></span></span><span><span><span>（Pascal case）：全部首字母大写，等同于大驼峰命名法，比如：MySystem；</span></span></span></span></li><li><span><span><span><strong><span>脊柱命名法</span></strong></span></span><span><span><span>（spinal case）：使用中划线，比如：my-system；</span></span></span></span></li><li><span><span><span><strong><span>自由命名法</span></strong></span></span><span><span><span>（studly caps）：大小写混杂，无简明规则，比如：mySYSTEM，MYSystem；</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>按照受众量与知名程度排名，驼峰命名法和蛇形命名法更受到大家的欢迎，毕竟它们在可读性，易写性等方面比较有优势。</span></span></span></p><span id="OSC_h4_4"></span><h4><span><span><span>2.1.1 命名字典</span></span></span></h4><blockquote><span><span><span>见名知意：好的命名就是一种注释。</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>建议研发同学将业内常见业务场景的命名熟记，当然，已经有人帮我们总结过了，这里不再做过多的说明。这里摘录如下，可供参考：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>管理类命名</span></strong></span></span><span><span><span>：Bootstrap，Starter，Processor，Manager，Holder，Factory，Provider，Registrar，Engine，Service，Task</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>传播类命名</span></strong></span></span><span><span><span>：Context，Propagator</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>回调类命名</span></strong></span></span><span><span><span>：Handler，Callback，Trigger，Listener，Aware</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>监控类命名</span></strong></span></span><span><span><span>：Metric，Estimator，Accumulator，Tracker</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>内存管理类命名</span></strong></span></span><span><span><span>：Allocator，Chunk，Arena，Pool</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>过滤检测类命名</span></strong></span></span><span><span><span>：Pipeline，Chain，Filter，Interceptor，Evaluator，Detector</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>结构类命名</span></strong></span></span><span><span><span>：Cache，Buffer，Composite，Wrapper，Option, Param,Attribute，Tuple，Aggregator，Iterator，Batch，Limiter</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>常见设计模式命名</span></strong></span></span><span><span><span>：Strategy，Adapter，Action，Command，Event，Delegate，Builder，Template，Proxy</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>解析类命名</span></strong></span></span><span><span><span>：Converter，Resolver，Parser，Customizer，Formatter</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>网络类命名</span></strong></span></span><span><span><span>：Packet，Encoder、Decoder、Codec，Request，Response</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>CRUD 命名</span></strong></span></span><span><span><span>：Controller，Service，</span></span></span><span><span><span style="background-color:#ffffff; color:#4d4d4d">Repository</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>辅助类命名</span></strong></span></span><span><span><span>：Util，Helper</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>其他类命名</span></strong></span></span><span><span><span>：Mode，Type，Invoker，Invocation，Initializer，Future，Promise，Selector，Reporter，Constants，Accessor，Generator</span></span></span></p><span id="OSC_h4_5"></span><h4><span><span><span>2.1.2 命名实践</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>工程通用命名规则</span></span></span><span><span><span style="background-color:#ffffff; color:#4d4d4d">都有哪些呢？不同的语言可能会有不同的习惯，以 Java 语言的驼峰命名规范举例：</span></span></span></p><div><span style="color:#4d4d4d">1.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">项目名全部小写；</span></span></span></span></div><div><span style="color:#4d4d4d">2.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">包名全部小写；</span></span></span></span></div><div><span style="color:#4d4d4d">3.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">类名首字母大写,其余组成词首字母依次大写；</span></span></span></span></div><div><span style="color:#4d4d4d">4.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">变量名,方法名首字母小写,如果名称由多个单词组成,除首字母外的每个单词首字母都要大写；</span></span></span></span></div><div><span style="color:#4d4d4d">5.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">常量名全部大写；</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span style="background-color:#ffffff; color:#4d4d4d">规范比较抽象，先来看看不好的命名有哪些呢？</span></span></span></p><div><span style="color:#4d4d4d">1.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">自带混淆功能的变量名：String zhrmghg = "极致缩写型";</span></span></span></span></div><div><span style="color:#4d4d4d">2.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">没有意义的万能变量名：String a,b,c="爱谁谁型";</span></span></span></span></div><div><span style="color:#4d4d4d">3.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">长串拼音变量名：</span></span></span><span><span><span>String </span></span></span><span><span><span style="background-color:#ffffff; color:#4d4d4d">HuaBuHua = "考古型";</span></span></span></span></div><div><span style="color:#4d4d4d">4.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">各种符号混用：String $my_first_name_ = "打死记不住型";</span></span></span></span></div><div><span style="color:#4d4d4d">5.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">大小写，数字，缩写混乱：String waitRPCResponse1 = "极易出错型";</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span style="background-color:#ffffff; color:#4d4d4d">除了标准的规范之外，在实际的开发过程中还会有一些困扰我们的实际案例。</span></span></span></p><blockquote><span><span><span>1. 在定义一个成员变量的时候，到底是使用包装类型还是使用基本数据类型呢？</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>包装类和基本数据类型的默认值是不一样的，前者是 null，后者依据不同类型其默认值也不一样。从数据严谨的角度来讲，包装类的 null 值能够表示额外信息，从而更加安全。比如可以规避基本类型的自动拆箱，导致的 NPE 风险以及业务逻辑处理异常风险。所以成员变量必须使用包装数据类型，基本数据类型则在局部变量的场景下使用。</span></span></span></p><blockquote><span><span><span>2. 为什么不建议布尔类型的成员变量以 is 开头？</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>关于 Java Bean 中的 getter/setter 方法的定义其实是有明确的规定的，根据 JavaBeans(TM) Specification 规定，如果是普通的参数，命名为 propertyName，需要通过以下方式定义其 setter/getter：</span></span></span></p><pre><code><span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span>&lt;PropertyType&gt;</span></span><span><span> get</span></span><span><span>&lt;PropertyName&gt;</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span> set</span></span><span><span>&lt;PropertyName&gt;</span></span><span><span style="color:#999999">(</span></span><span><span>&lt;PropertyType&gt;</span></span><span><span> p</span></span><span><span style="color:#999999">)</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>但是，布尔类型的变量 propertyName 则是另外一套命名原则的：</span></span></span></p><pre><code><span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">boolean</span></span><span><span> is</span></span><span><span>&lt;PropertyName&gt;</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span> set</span></span><span><span>&lt;PropertyName&gt;</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">boolean</span></span><span><span> p</span></span><span><span style="color:#999999">)</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>由于各种 RPC 框架和对象序列化工具对于布尔类型变量的处理方式存在差异，就容易造成代码移植性问题。最常见的 json 序列化库 Jackson 和 Gson 之间就存在兼容性问题，前者是通过</span></span></span><span><span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">通过反射遍历出该类中的所有 getter 方法，通过方法名截取获得到对象的属性，后者则是通过反射直接遍历该类中的属性。为了规避这种差异对业务的影响，建议所有成员变量都不要以 is 开头，防止序列化结果出现不预知的情况发生。</span></span></span></p><blockquote><span><span><span>3. 看看单词大小写能引起的哪些副作用？</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>JAVA 语言本身是区分大小写的，但是在用文件路径、文件名对文件进行操作时，这里的文件名和路径是不区分大小写的，这是因为文件系统不区分大小写。典型的场景就是我们通过 git 等代码管理平台时，将 package 路径里的大写的文件名称，修改为小写时，git 是无法更新的，为了规避不必要的麻烦，这里建议包路径统一使用小写单词，多个单词通过路径层次来进行定义。</span></span></span></p><blockquote><span><span><span>4. 不同 jar 包里的类也会出现冲突问题？</span></span></span></blockquote><div><span>1.</span><span><span><span><span>一类是同一个 jar 包出现了多个不同的版本。应用选择了错误的版本导致 jvm 加载不到需要的类或者加载了错误版本的类；（借助 maven 管理工具相对容易解决）</span></span></span></span></div><div><span>2.</span><span><span><span><span>另一类是不同的 jar 包出现了类路径相同的类，同样的类出现在不同的依赖 jar 里，由于 jar 加载的先后顺序导致了 JVM 加载了错误版本的类；（比较难以解决）</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这里着重介绍第二种情况，这种情况容易出现在系统拆分重构时，将原有的项目进行了复制，然后删减，导致部分工具或者枚举类和原有的路径和命名都一样，当第三方调用方同时依赖了这两个系统时，就容易为以后的迭代埋下坑。要规避此类问题，一定要为系统起一个独一无二的 package 路径。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>补充：如果依赖的都是第三方的库，存在着类冲突时，可以通过引入第三方库 jarjar.jar，修改其中某个冲突 jar 文件的包名，以此来解决 jar 包冲突。</span></span></span></p><blockquote><span><span><span>5. 在变量命名的可读性和占用资源（内存，带宽）方面，如何去做权衡？</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以通过对象序列化工具为突破口，以常见的 Json（Jackson）序列化方式来举例：</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">SkuKey</span></span><span><span></span></span><span><span style="color:#0077aa">implements</span></span><span><span></span></span><span><span style="color:#dd4a68">Serializable</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span>@JsonProperty</span></span><span><span style="color:#999999">(</span></span><span><span>value </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">"sn"</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span>@ApiModelProperty</span></span><span><span style="color:#999999">(</span></span><span><span>name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">"stationNo"</span></span><span><span style="color:#999999">,</span></span><span><span> value </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">" 门店编号"</span></span><span><span style="color:#999999">,</span></span><span><span> required </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">true</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#dd4a68">Long</span></span><span><span> stationNo</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span>@JsonProperty</span></span><span><span style="color:#999999">(</span></span><span><span>value </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">"si"</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span>@ApiModelProperty</span></span><span><span style="color:#999999">(</span></span><span><span>name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">"skuId"</span></span><span><span style="color:#999999">,</span></span><span><span> value </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">" 商品编号"</span></span><span><span style="color:#999999">,</span></span><span><span> required </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">true</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#dd4a68">Long</span></span><span><span> skuId</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 省略 get/set 方法</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>其中@JsonProperty 注解的作用就是将 JavaBean 中的普通属性在序列化的时候，重新命名成指定的新的名字。而这一实现对于业务实现没有影响，依然以原来的命名操作为准，只在对外 RPC 需要序列化和反序列化的过程生效。如此，比较好的解决了可读性和资源占用的冲突问题。</span></span></span></p><blockquote><span><span><span>6. 对外提供服务的入参和出参，我们是用 class 对象，还是 Map 容器？</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>从灵活性的角度看，Map 容器稳定且更灵活。从稳定性和可读性上来看，Map 容器是个黑盒子，不知道里面有什么，得有辅助的详细说明文档才能协作，由于维护文档的动作往往与工程代码是分开的，这中机制就会导致信息的准确性和实时性很难得到保障。所以还是建议使用 class 结构对象维护出入参结构。</span></span></span></p><span id="OSC_h3_6"></span><h3><span><span><span>2.2 关于注释</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>注释是程序员和阅读者之间交流的重要手段，是对代码的解释和说明，好的注释可以提高软件的可读性，减少维护软件的成本。</span></span></span></p><span id="OSC_h4_7"></span><h4><span><span><span>2.2.1 好的注释</span></span></span></h4><blockquote><span><span><strong><span>分层次</span></strong></span></span><span><span><span>：按照系统，包，类，方法，代码块，代码行等不同粒度，各有侧重点的进行注释说明。</span></span></span></blockquote><div><span>1.</span><span><span><span><strong><span>系统注释</span></strong></span></span><span><span><span>：通过 README.md 文件体现宏观的功能和架构实现；</span></span></span></span></div><div><span>2.</span><span><span><span><strong><span>包注释</span></strong></span></span><span><span><span>：通过 package-info 文件体现模块职责边界，另外该文件也支持声明友好类，包常量以及为标注在包上的注解（Annotation）提供便利；</span></span></span></span></div><div><span>3.</span><span><span><span><strong><span>类注释</span></strong></span></span><span><span><span>：主要体现功能职责，版本支持，作者归属，应用示例等相关信息；</span></span></span></span></div><div><span>4.</span><span><span><span><strong><span>方法注释</span></strong></span></span><span><span><span>：关注入参，出参，异常处理声明，使用场景举例等相关内容；</span></span></span></span></div><div><span>5.</span><span><span><span><strong><span>代码块和代码行注释</span></strong></span></span><span><span><span>：主要体现逻辑意图，闭坑警示，规划 TODO，放大关注点等细节内容；</span></span></span></span></div><blockquote><span><span><strong><span>有规范</span></strong></span></span><span><span><span>：好的代码优于大量注释，这和我们常说的「约定大于配置」是相同的道理。借助 swagger 等三方库实现</span></span></span><span><span><strong><span>注解即接口文档</span></strong></span></span><span><span><span>，是一个不错的规范方式；</span></span></span></blockquote><span id="OSC_h4_8"></span><h4><span><span><span>2.2.2 坏的注释</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>为了能使注释准确清晰的表达出功能逻辑，注释的维护是有相当的维护成本的，所以注释并不是越多，越详细越好。下面就举一些坏的注释场景，辅助理解：</span></span></span></p><div><span>1.</span><span><span><span><strong><span>冗余式</span></strong></span></span><span><span><span>：</span></span></span><span><span><span style="background-color:#ffffff; color:#404040">如果一个函数，读者能够很容易的就读出来代码要表达的意思，注释就是多余的；</span></span></span></span></div><div><span style="color:#404040">2.</span><span><span><span><strong><span>错误</span></strong></span></span><span><span><strong><span>式</span></strong></span></span><span><span><span style="background-color:#ffffff; color:#404040">：如果注释的不清楚，甚至出现歧义，那还不如不写；</span></span></span></span></div><div><span style="color:#404040">3.</span><span><span><span><strong><span>签名式</span></strong></span></span><span><span><span style="background-color:#ffffff; color:#404040">：类似「add by liuhuiqing 2023-08-05」这种注释，容易过期失效而且不太可信（不能保证所有人每次都采用这种方式注释），其功能完全可以由 git 代码管理工具来实现；</span></span></span></span></div><div><span style="color:#404040">4.</span><span><span><span><strong><span>长篇大论式</span></strong></span></span><span><span><span style="background-color:#ffffff; color:#404040">：代码块里，夹杂了大篇幅的注释，不仅影响代码阅读，而且维护困难；</span></span></span></span></div><div><span style="color:#404040">5.</span><span><span><span><strong><span>非本地注释</span></strong></span></span><span><span><span style="background-color:#ffffff; color:#404040">：注释应该在离代码实现最近的地方，比如：被调用的方法注释就由方法本身来维护，调用方无需对方法做详细的说明；</span></span></span></span></div><div><span style="color:#404040">6.</span><span><span><span><strong><span>注释掉的代码</span></strong></span></span><span><span><span style="background-color:#ffffff; color:#404040">：无用的代码应该删除，而不是注释。历史记录交给 git 等代码管理工具来维护；</span></span></span></span></div><span id="OSC_h3_9"></span><h3><span><span><span>2.3 关于分层</span></span></span></h3><blockquote><span><span><span>系统分层设计的主要目是通过分离关注点，来降低系统的复杂度，同时提高可复用性和降低维护成本。所以懂得分层的概念，很大程度上系统的可维护性就有了骨架。</span></span></span></blockquote><span id="OSC_h4_10"></span><h4><span><span><span style="background-color:#ffffff; color:#4d4d4d">2.3.1 系统分层 </span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span style="background-color:#ffffff; color:#4d4d4d">在 ISO(（International Standardization Organization）) 于 1981 年制定网络通信七层模型 (Open System Interconnection Reference Model，OSI/RM) 之前，计算机网络中存在众多的体系结构，其中以 IBM 公司的 SNA(系统网络体系结构) 和 DEC 公司的 DNA(DigitalNetworkArchitecture) 数字网络体系结构最为著名。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span style="background-color:#ffffff; color:#4d4d4d">最早之前，各个厂家提出的不同标准都是以自家设备为基础的，用户在选择产品的时候就只能用同一家公司的，因为不同公司间大家的标准不一样，工作方式也可能不一样，结果就是不同厂商的网络产品间，可能会出现不兼容的情况。如果说同一家的公司的产品都能满足用户的需求的话，那就看哪家公司实力强点，实力强的，用户粘性高的，用户自然也不会说什么，问题是一家公司并不是对所有的产品都擅长。这就会导致厂商和用户都面临着痛苦的煎熬。类比一下当前手机充电接口协议（Micro USB 接口、Type- c 接口、Lightning 接口），手头总是要备有各种充电线的场景，就能深刻理解标准的意义了。</span></span></span></p><span id="OSC_h4_11"></span><h4><span><span><span>2.3.2 软件伸缩性</span></span></span></h4><blockquote><span><span><span>软件伸缩性指的是软件系统在面对负载压力时，能够保持原有性能并扩展以支持更多任务的能力。</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>伸缩性可以有两个方面，垂直伸缩性和水平伸缩性，垂直伸缩性是通过在同一个业务单元中增加资源来提高系统的吞吐量，比如增加服务器 cpu 的数量，增加服务器的内存等。水平伸缩性是通过增加多个业务单元资源，使得所有的业务单元逻辑上就像是一个单元一样。比如 ejb 分布式组件模型，微服务组件模型等都属于此种方式。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>软件系统在设计时需要考虑如何进行有效的伸缩性设计，以确保在面对负载压力时能够提供足够的性能支持。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>系统分层从伸缩性角度看，更多的属于水平伸缩性的范畴。在 J2EE 系统开发当中，我们普遍采用了分层构架的方式，一般分为表现层，业务层和持久层。采用分层以后，因为层与层之间通信会引来额外的开销，所以给我们软件系统带来的就是每个业务处理开销会变大。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>既然采用分层会带来额外的开销，那么我们为什么还要进行分层呢？</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这是因为单纯依靠堆硬件资源的垂直伸缩方式来提高软件性能和吞吐是有上限的，而且随着系统规模的扩大，垂直伸缩的代价也将变得非常昂贵。当采用了分层以后，虽然层与层之间带来了通信开销，但是它有利于各层的水平伸缩性，并且各个层都可以进行独立的伸缩而不会影响到其它的层。也就是说当系统要应对更大的访问量的时候，我们可以通过增加多个业务单元资源来增加系统吞吐量。</span></span></span></p><span id="OSC_h3_12"></span><h3><span><span><span>2.4 小结</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>本章内容主要从可读性和可维护性方面讲述了在开发过程中，要做好命名和注释的统一共识。除了共识之外，在设计层面也需要做好关注点的隔离，这包含系统职责的拆分，模块功能的划分，类能力的收敛，实体结构的关系都需要做好规划。</span></span></span></p><span id="OSC_h1_13"></span><h1><span><span><span>三，实践篇</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下面就从程序的扩展性，维护性，安全性以及性能等几个重要质量指标，来学习那些经典的实践案例。</span></span></span></p><span id="OSC_h3_14"></span><h3><span><span><span>3.1 类定义</span></span></span></h3><span id="OSC_h4_15"></span><h4><span><span><span>3.1.1 常量定义</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>常量是一种固定值，不会在程序执行期间发生改变。你可以使用枚举（Enum）或类（Class）来定义常量。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果你需要定义一组相关的常量，那么使用枚举更为合适。枚举从安全性和可操作性（支持遍历和函数定义）上面拥有更大的优势。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">enum</span></span><span><span></span></span><span><span style="color:#dd4a68">Color</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
 RED</span></span><span><span style="color:#999999">,</span></span><span><span> GREEN</span></span><span><span style="color:#999999">,</span></span><span><span> BLUE</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果你只需要定义一个或少数几个只读的常量，那么使用类常量更为简洁和方便。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">MyClass</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> MAX_VALUE </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">100</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h4_16"></span><h4><span><span><span>3.1.2 工具类</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>工具类通常包含具有通用性的、某一非业务领域内的公共方法，不需要配套的成员变量，仅仅是作为工具方法被使用。因此，将其做成静态方法最合适，不需要实例化，能够获取到方法的定义并调用就行。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>工具类不实例化的原因是可以节省内存空间，因为工具类提供的是静态方法，通过类就能调用，不需要实例化工具类对象。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">abstract</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">ObjectHelper</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">boolean</span></span><span><span></span></span><span><span style="color:#dd4a68">isEmpty</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> str</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> str </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">==</span></span><span><span></span></span><span><span style="color:#0077aa">null</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">||</span></span><span><span> str</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">length</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">==</span></span><span><span></span></span><span><span style="color:#990055">0</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>为了实现不需要实例化对象的约束，我们最好在类定义时，加上</span></span></span><span><span><strong><span>abstract</span></strong></span></span><span><span><span>关键字进行声明限定，这也是为什么 spring 等开源工具类大都使用 abstract 关键字修饰的原因。</span></span></span></p><span id="OSC_h4_17"></span><h4><span><span><span>3.1.3 JavaBean</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>JavaBean 的定义有两种常见实现方式：手动编写和自动生成。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> age</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> age</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> name</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>age </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> age</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span></span></span><span><span style="color:#dd4a68">getName</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> name</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">setName</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> name</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span></span></span><span><span style="color:#dd4a68">getAge</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> age</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">setAge</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">int</span></span><span><span> age</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>age </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> age</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>使用 lombok 插件，</span></span></span><span><span><span style="background-color:#ffffff; color:#1e1f24">通过注解方式来增强 Java 代码的编写，在编译期动态生成 get 和 set 方法。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>lombok.</span></span><span><span style="color:#dd4a68">Data</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span>@NoArgsConstructor</span></span><span><span></span></span><span><span>@Data</span></span><span><span></span></span><span><span>@Accessors</span></span><span><span style="color:#999999">(</span></span><span><span>chain </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">true</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> age</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>插件包还提供了@Builder 和@Accessors 等比较实用的链式编程能力，在一定程度上能提高编码效率。</span></span></span></p><span id="OSC_h4_18"></span><h4><span><span><span>3.1.4 不可变类</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在某些场景下，类为了保证其功能和行为的稳定性和一致性，会被设计为不能被继承和重写的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>定义方式就是在类上面添加 final 关键字，示例：</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span></span></span><span><span style="color:#0077aa">implements</span></span><span><span></span></span><span><span style="color:#dd4a68">Serializable</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">Comparable</span></span><span><span>&lt;String&gt;</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">CharSequence</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>以下是一些不能被继承和重写的类，这在一些底层中间件中会有应用：</span></span></span></p><pre><code><span><span><span style="color:#dd4a68">java.lang.String</span></span><span><span></span></span><span><span style="color:#dd4a68">java.lang.Math</span></span><span><span></span></span><span><span style="color:#dd4a68">java.lang.Boolean</span></span><span><span></span></span><span><span style="color:#dd4a68">java.lang.Character</span></span><span><span></span></span><span><span style="color:#dd4a68">java.util.Date</span></span><span><span></span></span><span><span style="color:#dd4a68">java.sql.Date</span></span><span><span></span></span><span><span style="color:#dd4a68">java.lang.System</span></span><span><span></span></span><span><span style="color:#dd4a68">java.lang.ClassLoader</span></span></span></code></pre><span id="OSC_h4_19"></span><h4><span><span><span>3.1.5 匿名内部类</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>匿名内部类通常用于简化代码，它的定义和使用通常发生在同一处，它的使用场景如下：</span></span></span></p><div><span>1.</span><span><span><span><span>直接作为参数传递给方法或构造函数；</span></span></span></span></div><div><span>2.</span><span><span><span><span>用于实现某个接口或抽象类的匿名实例；</span></span></span></span></div><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Example</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// 创建一个匿名内部类</span></span><span><span></span></span><span><span style="color:#dd4a68">Runnable</span></span><span><span> runnable </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Runnable</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span>@Override</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">run</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"Hello, World!"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 调用匿名内部类的方法</span></span><span><span>
        runnable</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">run</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h4_20"></span><h4><span><span><span>3.1.6 声明类</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>声明类是 Java 语言中的基本类型或接口，用于定义类的行为或特性，有的甚至只是个声明，没有具体的方法定义。</span></span></span></p><div><span>•</span><span><span><span><span>AutoCloseable：表示实现了该接口的类可以被自动关闭，通常用于资源管理。</span></span></span></span></div><div><span>•</span><span><span><span><span>Comparable：表示实现了该接口的类可以与其他实现了该接口的对象进行比较。</span></span></span></span></div><div><span>•</span><span><span><span><span>Callable：表示实现了该接口的类可以作为参数传递给线程池，并返回结果。</span></span></span></span></div><div><span>•</span><span><span><span><span>Cloneable：表示实现了该接口的类可以被克隆。</span></span></span></span></div><div><span>•</span><span><span><span><span>Enum：表示实现了该接口的类是一个枚举类型。</span></span></span></span></div><div><span>•</span><span><span><span><span>Iterable：表示实现了该接口的类可以迭代。</span></span></span></span></div><div><span>•</span><span><span><span><span>Runnable：表示实现了该接口的类可以作为线程运行。</span></span></span></span></div><div><span>•</span><span><span><span><span>Serializable：表示实现了该接口的类可以被序列化和反序列化。</span></span></span></span></div><div><span>•</span><span><span><span><span>interface：表示实现了该接口的类是一个接口，可以包含方法声明。</span></span></span></span></div><div><span>•</span><span><span><span><span>Annotation：表示实现了该接口的类是一个注解，可以用于元数据描述。</span></span></span></span></div><span id="OSC_h4_21"></span><h4><span><span><span>3.1.7 Record 类</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Record 类在 Java14 中就开始预览，一直到 Java17 才正式发布。根据 JEP395 的描述，Record 类是不可变数据的载体，类似于当下广泛应用的各种 model，dto，vo 等 POJO 类，但 record 本身在构造之后不再可赋值。所有的 record 类都继承自 java.lang.Record。</span></span></span><span><span><strong><span>Record 类默认提供了全字段的构造器，属性的访问，还有 equals，hashcode，toString 方法，其作用和 lombok 插件非常类似</span></strong></span></span><span><span><span>。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>定义方式</span></span></span></p><pre><code><span><span><span style="color:#708090">/**
 * 关键定义的类是不可变类
 * 将所有成员变量通过参数的形式定义
 * 默认会生成全部参数的构造方法
 * @param name
 * @param age
 */</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">record</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> age</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span style="color:#999999">(</span></span><span><span>name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">==</span></span><span><span></span></span><span><span style="color:#0077aa">null</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">throw</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">IllegalArgumentException</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"提供紧凑的方式进行参数校验"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#708090">/**
     * 定义的类中可以定义静态方法
     * @param name
     * @return
     */</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span></span></span><span><span style="color:#dd4a68">of</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span style="color:#999999">(</span></span><span><span>name</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#990055">18</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>使用方式</span></span></span></p><pre><code><span><span><span style="color:#dd4a68">Person</span></span><span><span> person </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"John"</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#990055">30</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// Person person = Person.of("John");</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> person</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">name</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> age </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> person</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">age</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>使用场景</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>通过 Record 构建一个临时存储对象，将 Person 数组对象按照年龄排序。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">List</span></span><span><span>&lt;Person&gt;</span></span><span><span></span></span><span><span style="color:#dd4a68">sortPeopleByAge</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">List</span></span><span><span>&lt;Person&gt;</span></span><span><span> people</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">record</span></span><span><span></span></span><span><span style="color:#dd4a68">Data</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Person</span></span><span><span> person</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> age</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">{</span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> people</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">stream</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">map</span></span><span><span style="color:#999999">(</span></span><span><span>person </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-&gt;</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Data</span></span><span><span style="color:#999999">(</span></span><span><span>person</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">computAge</span></span><span><span style="color:#999999">(</span></span><span><span>person</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">sorted</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span>d1</span></span><span><span style="color:#999999">,</span></span><span><span> d2</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-&gt;</span></span><span><span></span></span><span><span style="color:#dd4a68">Integer</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">compare</span></span><span><span style="color:#999999">(</span></span><span><span>d2</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">age</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">,</span></span><span><span> d1</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">age</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">map</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Data</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">::</span></span><span><span style="color:#dd4a68">person</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">collect</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">toList</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span></span></span><span><span style="color:#dd4a68">computAge</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Person</span></span><span><span> person</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> person</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">age</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h4_22"></span><h4><span><span><span>3.1.8 </span></span></span><span><span><span style="background-color:#ffffff; color:#1e1f24">密封类</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Java 17 推出的新特性密封类（Sealed Classes），主要作用就是限制类的继承。我们知道之前对类继承功能的限制主要有两种：</span></span></span></p><div><span>1.</span><span><span><span><span>final 修饰类，这样类就无法被继承了；</span></span></span></span></div><div><span>2.</span><span><span><span><span>package-private 类，可以控制只能被同一个包下的类继承；</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>但很显然，这两种限制方式的力度都非常粗，而密封类正是对类继承的更细粒度的控制。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">sealed</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">SealedClass</span></span><span><span></span></span><span><span style="color:#0077aa">permits</span></span><span><span></span></span><span><span style="color:#dd4a68">SubClass1</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">SubClass2</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">SubClass1</span></span><span><span></span></span><span><span style="color:#0077aa">extends</span></span><span><span></span></span><span><span style="color:#dd4a68">SealedClass</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">SubClass2</span></span><span><span></span></span><span><span style="color:#0077aa">extends</span></span><span><span></span></span><span><span style="color:#dd4a68">SealedClass</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在上面的示例中，SealedClass 是一个密封类，它包含两个子类 SubClass1 和 SubClass2。在 SubClass1 和 SubClass2 的定义中，必须使用 extends 关键字来继承自 SealedClass，并且使用 permits 关键字来指定它们允许哪些子类来继承。通过使用密封类，可以确保只有符合特定条件的子类才能继承或实现该协议或规范。</span></span></span></p><span id="OSC_h3_23"></span><h3><span><span><span>3.2 方法定义</span></span></span></h3><span id="OSC_h4_24"></span><h4><span><span><span>3.2.1 构造方法</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>构造方法是一种特殊的方法，用于创建和初始化对象。构造方法的名称必须与类名相同，并且没有返回类型。在创建对象时，可以通过使用 new 关键字来调用构造方法。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">MyClass</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> myInt</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> myString</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 构造方法</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">MyClass</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">int</span></span><span><span> myInt</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> myString</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>myInt </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> myInt</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>myString </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> myString</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>实现单例模式的一个重要特性就是不允许用户随意创建（new）对象，如何做到安全控制呢？将构造方法声明为私有（private）是必不可少的一步。</span></span></span></p><span id="OSC_h4_25"></span><h4><span><span><span>3.2.2 方法重写</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>方法重写是指在子类中重新定义与父类中同名的方法。方法重写允许子类覆盖父类中的方法实现，以便根据子类的需要实现其自己的行为。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Animal</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">makeSound</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"Animal is making a sound"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Cat</span></span><span><span></span></span><span><span style="color:#0077aa">extends</span></span><span><span></span></span><span><span style="color:#dd4a68">Animal</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span>@Override</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">makeSound</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"Meow"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Main</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">Animal</span></span><span><span> myCat </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Cat</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>
        myCat</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">makeSound</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 输出 "Meow"</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>面向对象的三大特性之一的多态，方法重写是其核心。</span></span></span></p><span id="OSC_h4_26"></span><h4><span><span><span>3.2.3 方法重载</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>类中定义多个方法，它们具有相同的名称但参数列表不同。方法重载允许我们使用同一个方法名执行不同的操作，根据传递给方法的参数不同来执行不同的代码逻辑。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Calculator</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span></span></span><span><span style="color:#dd4a68">add</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">int</span></span><span><span> a</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> b</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> a </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> b</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">double</span></span><span><span></span></span><span><span style="color:#dd4a68">add</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">double</span></span><span><span> a</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">double</span></span><span><span> b</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> a </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> b</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Main</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">Calculator</span></span><span><span> calculator </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Calculator</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> result1 </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> calculator</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">add</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">2</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#990055">3</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">double</span></span><span><span> result2 </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> calculator</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">add</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">2.5</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#990055">3.5</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span>result1</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 输出 5</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span>result2</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 输出 6.0</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h4_27"></span><h4><span><span><span>3.2.4 匿名方法</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Java 8 引入了 Lambda 表达式，可以用来实现类似匿名方法的功能。Lambda 表达式是一种匿名函数，可以作为参数传递给方法，或者直接作为一个独立表达式使用。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> args</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">List</span></span><span><span>&lt;String&gt;</span></span><span><span> names </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">Arrays</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">asList</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"hello"</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">"world"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 使用 Lambda 表达式作为参数传递给 forEach 方法</span></span><span><span>
    names</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">forEach</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-&gt;</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"Name: "</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> name</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 使用 Lambda 表达式作为独立表达式使用</span></span><span><span></span></span><span><span style="color:#dd4a68">Predicate</span></span><span><span>&lt;String&gt;</span></span><span><span> nameLengthGreaterThan5 </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-&gt;</span></span><span><span> name</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">length</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&gt;</span></span><span><span></span></span><span><span style="color:#990055">5</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">boolean</span></span><span><span> isLongName </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> nameLengthGreaterThan5</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">test</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"John"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"Is long name? "</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> isLongName</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h3_28"></span><h3><span><span><span>3.3 对象定义</span></span></span></h3><span id="OSC_h4_29"></span><h4><span><span><span>3.3.1 单例对象</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>单例对象是一种可以重复使用的对象，但只有一个实例。它有以下几个作用：</span></span></span></p><div><span>1.</span><span><span><span><span>控制资源的使用：通过线程同步来控制资源的并发访问。</span></span></span></span></div><div><span>2.</span><span><span><span><span>控制实例产生的数量：达到节约资源的目的。</span></span></span></span></div><div><span>3.</span><span><span><span><span>作为通信媒介使用：也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信。</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比如，使用枚举实现单例模式：</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">enum</span></span><span><span></span></span><span><span style="color:#dd4a68">Singleton</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
 INSTANCE</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">someMethod</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// ...其他代码...</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h4_30"></span><h4><span><span><span>3.3.2 不可变对象</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Java 中的不可变对象是指那些一旦被创建，其状态就不能被修改的对象。不可变对象是一种非常有用的对象，因为它们可以确保对象的状态在任何时候都是一致的，从而避免了因为修改对象状态而引发的问题。实现不可变对象有以下几种方式：</span></span></span></p><div><span>1.</span><span><span><span><span>将对象的状态存储在不可变对象中：String、Integer 等就是内置的不可变对象类型；</span></span></span></span></div><div><span>2.</span><span><span><span><span>将对象的状态存储在 final 变量中：final 变量一旦被赋值就不能被修改；</span></span></span></span></div><div><span>3.</span><span><span><span><span>将对象的所有属性都设为不可变对象：这样就可以确保整个对象都是不可变的；</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>一些容器类的操作也有对应的包装类实现容器对象的不可变，比如定义不可变数组对象：</span></span></span></p><pre><code><span><span><span style="color:#dd4a68">Collections</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">unmodifiableList</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">ArrayList</span></span><span><span>&lt;&gt;</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span></span></code></pre><blockquote><span><span><span>当领域内的对象作为入参往外传递时，将其定义为不可变对象，这在保持数据一致性方面非常重要，否则对象属性变更的不可预测性，在进行问题定位时，将会非常麻烦。</span></span></span></blockquote><span id="OSC_h4_31"></span><h4><span><span><span>3.3.3 元组对象</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>元组（Tuple）是函数式编程语言中的常见概念，元组是一个不可变，并且能够以类型安全的形式保存多个不同类型的对象。它是一种非常有用的数据结构，可以让开发者在处理多个数据元素时更加方便和高效。但原生的 Java 标准库并没有提供元组的支持，需要我们自己或借助第三方类库来实现。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>二元组实现</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Pair</span></span><span><span>&lt;A,B&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#dd4a68">A</span></span><span><span> first</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#dd4a68">B</span></span><span><span> second</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">Pair</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">A</span></span><span><span> a</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">B</span></span><span><span> b</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>first </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> a</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>second </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> b</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">A</span></span><span><span></span></span><span><span style="color:#dd4a68">getFirst</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> first</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">B</span></span><span><span></span></span><span><span style="color:#dd4a68">getSecond</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> second</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>三元组实现</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Triplet</span></span><span><span>&lt;A,B,C&gt;</span></span><span><span></span></span><span><span style="color:#0077aa">extends</span></span><span><span></span></span><span><span style="color:#dd4a68">Pair</span></span><span><span>&lt;A,B&gt;</span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#dd4a68">C</span></span><span><span> third</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">Triplet</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">A</span></span><span><span> a</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">B</span></span><span><span> b</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">C</span></span><span><span> c</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">super</span></span><span><span style="color:#999999">(</span></span><span><span>a</span></span><span><span style="color:#999999">,</span></span><span><span> b</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>third </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> c</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">C</span></span><span><span></span></span><span><span style="color:#dd4a68">getThird</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> third</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// 表示姓名，性别，年龄</span></span><span><span></span></span><span><span style="color:#dd4a68">Triplet</span></span><span><span>&lt;String,String,Integer&gt;</span></span><span><span> triplet </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Triplet</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"John"</span></span><span><span style="color:#999999">,</span></span><span><span style="color:#669900">"男"</span></span><span><span style="color:#999999">,</span></span><span><span style="color:#990055">18</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 获得姓名</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> triplet</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">getFirst</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>多元组实现</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Tuple</span></span><span><span>&lt;E&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#dd4a68">E</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> elements</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">Tuple</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">E</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#999999">.</span></span><span><span> elements</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>elements </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> elements</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">E</span></span><span><span></span></span><span><span style="color:#dd4a68">get</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">int</span></span><span><span> index</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> elements</span></span><span><span style="color:#999999">[</span></span><span><span>index</span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span></span></span><span><span style="color:#dd4a68">size</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> elements</span></span><span><span style="color:#999999">.</span></span><span><span>length</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// 表示姓名，性别，年龄</span></span><span><span></span></span><span><span style="color:#dd4a68">Tuple</span></span><span><span>&lt;String&gt;</span></span><span><span> tuple </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Tuple</span></span><span><span>&lt;&gt;</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"John"</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">"男"</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">"18"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 获得姓名</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> tuple</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">get</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">0</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Tuple 主要有以下几个功能：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1. 存储多个数据元素：Tuple 可以存储多个不同类型的数据元素，这些元素可以是基本类型、对象类型、数组等；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2. 简化代码：Tuple 可以使代码更加简洁，减少重复代码的编写。通过 Tuple，我们可以将多个变量打包成一个对象，从而减少了代码量；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3. 提高代码可读性：Tuple 可以提高代码的可读性。通过 Tuple，我们可以将多个变量打包成一个对象，从而使代码更加易读；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>4. 支持函数返回多个值：Tuple 可以支持函数返回多个值。在 Java 中，函数只能返回一个值，但是通过 Tuple，我们可以将多个值打包成一个对象返回；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>除了自定义之外，实现了元组概念的第三方类库有：Google Guava，Apache Commons Lang，JCTools，Vavr 等。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Google Guava 库的 Tuple 提供了更多的功能，并且被广泛使用。比如，为了使元组的含义更加明确，Guava 提供了命名元组（NamedTuple）的概念。通过给元组命名，可以更清晰地表示每个元素的意义。示例：</span></span></span></p><pre><code><span><span><span style="color:#dd4a68">NamedTuple</span></span><span><span> namedTuple </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">Tuples</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">named</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"person"</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">"name"</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">"age"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span></span></code></pre><span id="OSC_h4_32"></span><h4><span><span><span>3.3.4 临时对象</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>临时对象是指在程序执行过程中临时需要，但生命周期较短的对象。这些对象通常只在使用过程中短暂存在，不需要长期存储或重复使用。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>关于临时对象的优化建议如下：</span></span></span></p><div><span>1.</span><span><span><span><span>尽量重用对象。由于系统不仅要花时间生成对象，以后可能还需花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响，重用对象的策略有缓存对象，也可以针对具体场景进行定向优化，比如使用 StringBuffer 代替字符串拼接的方式；</span></span></span></span></div><div><span>2.</span><span><span><span><span>尽量使用局部变量。调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中，速度较快。其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢；</span></span></span></span></div><div><span>3.</span><span><span><span><span>分代收集。分代垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率；</span></span></span></span></div><span id="OSC_h4_33"></span><h4><span><span><span>3.3.5 Valhalla</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Java 作为高级语言，和更为底层的 C 语言，汇编语言在性能方面一直存在着不小的差距。为了弥补这一差距，Valhalla 项目于 2014 年启动，目标是为基于 JVM 的语言带来更灵活的扁平化数据类型。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>我们都知道 Java 支持原生类型和引用类型两种。原生数据类型按值传递，赋值和函数传参都会把值给复制一份，复制之后两份之间就再无关联； 引用类型无论什么情况传的都是指针，修改指针指向的内容会影响到所有的引用。而 Valhalla 又引入了值类型（value types），一种介于原生类型和引用类型之间的概念。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>由于应用程序中的大多数 Java 数据结构都是对象，因此我们可以将 Java 视为指针密集型语言。这种基于指针的对象实现用于启用对象标识，对象标识本身用于语言特性，如多态性、可变性和锁定。默认情况下，这些特性适用于每个对象，无论它们是否真的需要。这就是值类型（value types）发挥作用的地方。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>值类型（value types）的概念是表示纯数据聚合，这会删除常规对象的功能。因此，我们有纯数据，没有身份。当然，这意味着我们也失去了使用对象标识可以实现的功能。由于我们不再有对象标识，我们可以放弃指针，改变值类型的一般内存布局。让我们来比较一下对象引用和值类型内存布局。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-08-28-22-34ywa6eBTJAoJdQEn.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><blockquote><span><span><span>去掉了对象头信息，在 64 位操作系统中值类型节约了对象头 16 个字节的空间。同时，也意味着放弃对象唯一身份（Identity）和初始化安全性，之前的 wait()，notify()，synchronized(obj)，System.identityHashCode(obj) 等关键字或方法都将失效，无法使用。</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Valhalla 在提高性能和减少泄漏的抽象方面将会显著提高：</span></span></span></p><div><span>•</span><span><span><span><span>性能增强通过展平对象图和移除间接来解决。这将获得更高效的内存布局和更少的分配和垃圾回收。</span></span></span></span></div><div><span>•</span><span><span><span><span>当用作泛型类型时，原语和对象具有更相似的行为，这是更好的抽象。</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>截止到 2023 年 9 月，Valhalla 项目仍在进行中，还没有正式版本的发布，这一创新项目值得期待的。</span></span></span></p><span id="OSC_h1_34"></span><h1><span><span><span>四，总结</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>本文总结了软件开发过程中经常用到的基础常识，分为基础篇和实践篇两个篇章，其中基础篇中着重讲述了类，方法，变量的命名规范以及代码注释好坏的评判标准。实践篇中从类，方法以及对象三个层面分析了常见的技术概念和落地实践，希望这些常识能够为读者带来一些思考和帮助。</span></span></span></p><blockquote><p>作者：京东零售&nbsp;刘慧卿</p><p>来源：京东云开发者社区，转载请注明来源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Thu, 19 Oct 2023 02:15:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10120062</guid>
            <link>https://my.oschina.net/u/4090830/blog/10120062</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[新晋项目 X File Storage 加入 Dromara 开源社区，一站式文件存储]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><h3><img alt="logo" height="200px" src="https://x-file-storage.xuyanwu.cn/assets/logo.svg" referrerpolicy="no-referrer"><br><span>原名 X Spring File Storage 现已捐赠至 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdromara.org%2Fzh" target="_blank">dromara</a> 开源组织</span></h3><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.dromara.org" target="_blank">x-file-storage.dromara.org</a> | <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn" target="_blank">x-file-storage.xuyanwu.cn</a> | <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspring-file-storage.xuyanwu.cn" target="_blank">spring-file-storage.xuyanwu.cn</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcentral.sonatype.com%2Fsearch%3Fq%3Dorg.dromara.x-file-storage" target="_blank"><img src="https://img.shields.io/maven-central/v/org.dromara.x-file-storage/x-file-storage-core.svg?label=Maven%20Central" referrerpolicy="no-referrer"></a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.apache.org%2Flicenses%2FLICENSE-2.0" target="_blank"><img src="https://img.shields.io/badge/license-Apache%202-green.svg" referrerpolicy="no-referrer"></a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2Fdownloads%2Findex.html" target="_blank"><img src="https://img.shields.io/badge/JDK-8+-blue.svg" referrerpolicy="no-referrer"></a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdromara%2Fx-file-storage" target="_blank"><img alt="github star" src="https://img.shields.io/github/stars/dromara/x-file-storage.svg?style=social" referrerpolicy="no-referrer"></a><a href="https://gitee.com/dromara/x-file-storage"><img alt="star" src="https://gitee.com/dromara/x-file-storage/badge/star.svg?theme=dark" referrerpolicy="no-referrer"></a><br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3DeGfeNqka" target="_blank"><img alt="" src="https://img.shields.io/badge/QQ%E7%BE%A4-515706495-orange" referrerpolicy="no-referrer"></a></p><h1>📚简介</h1><p>一行代码将文件存储到本地、FTP、SFTP、WebDAV、阿里云 OSS、华为云 OBS、七牛云 Kodo、腾讯云 COS、百度云 BOS、又拍云 USS、MinIO、 Amazon S3、GoogleCloud Storage、金山云 KS3、美团云 MSS、京东云 OSS、天翼云 OOS、移动，云 EOS、沃云 OSS、 网易数帆 NOS、Ucloud US3、青云 QingStor、平安云 OBS、首云 OSS、IBM COS、其它兼容 S3 协议的存储平台。查看 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn%2F%23%2F%25E5%25AD%2598%25E5%2582%25A8%25E5%25B9%25B3%25E5%258F%25B0" target="_blank">所有支持的存储平台</a></p><p>💡 通过 WebDAV 连接到 Alist 后，可以使用百度网盘、天翼云盘、阿里云盘、迅雷网盘等常见存储服务，查看 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Falist-doc.nn.ci%2Fdocs%2Fwebdav" target="_blank">Alist 支持的存储平台</a></p><p>GitHub：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdromara%2Fx-file-storage" target="_blank">https://github.com/dromara/x-file-storage</a> Gitee：<a href="https://gitee.com/dromara/x-file-storage">https://gitee.com/dromara/x-file-storage</a></p><p>文档 1：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.dromara.org" target="_blank">https://x-file-storage.dromara.org</a> 文档 2：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn" target="_blank">https://x-file-storage.xuyanwu.cn</a> 文档 3：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspring-file-storage.xuyanwu.cn" target="_blank">https://spring-file-storage.xuyanwu.cn</a></p><hr><h1>📜更新内容</h1><ul><li>更改项目名、更改包名、优化项目结构</li><li>新增直接读取 HttpServletRequest 的流进行上传，文件不落盘，速度更快</li><li>新增支持 Metadata 元数据</li><li>优化 ACL 异常处理</li><li>优化文件删除逻辑</li><li>修复 Amazon S3 上传文件偶现 ResetException 问题</li><li>捐赠至 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdromara.org%2Fzh" target="_blank">dromara</a> 开源社区</li></ul><h4>项目依赖的变化</h4><p>2.0.0 之前的版本</p><pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;cn.xuyanwu&lt;/groupId&gt;
    &lt;artifactId&gt;spring-file-storage&lt;/artifactId&gt;
    &lt;version&gt;1.0.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>2.0.0 及以后的版本</p><pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.dromara.x-file-storage&lt;/groupId&gt;
    &lt;artifactId&gt;x-file-storage-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4>配置参数的变化</h4><p>2.0.0 之前的版本</p><pre><code class="language-yaml">spring:
  file-storage: #文件存储配置
    default-platform: huawei-obs-1 #默认使用的存储平台
    thumbnail-suffix: ".min.jpg" #缩略图后缀，例如【.min.jpg】【.png】
    #对应平台的配置写在这里，注意缩进要对齐
</code></pre><p>2.0.0 及以后的版本</p><pre><code class="language-yaml">dromara:
  x-file-storage: #文件存储配置
    default-platform: huawei-obs-1 #默认使用的存储平台
    thumbnail-suffix: ".min.jpg" #缩略图后缀，例如【.min.jpg】【.png】
    #对应平台的配置写在这里，注意缩进要对齐
</code></pre><h4>包名的变化</h4><p>2.0.0 之前的版本</p><pre><code class="language-java">cn.xuyanwu.spring.file.storage
cn.xuyanwu.spring.file.storage.spring
</code></pre><p>2.0.0 及以后的版本</p><pre><code class="language-java">org.dromara.x.file.storage.core
org.dromara.x.file.storage.spring
</code></pre><hr><h1>📦使用</h1><p>点击 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn%2F%23%2F%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8" target="_blank">快速入门</a> 查看全部存储平台的使用方法！</p><h4>🔧 配置</h4><p>这里以阿里云 OSS 为例，<code>pom.xml</code> 引入本项目，这里默认是 <code>SpringBoot</code> 环境，其它环境参考 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn%2F%23%2F%25E8%2584%25B1%25E7%25A6%25BBSpringBoot%25E5%258D%2595%25E7%258B%25AC%25E4%25BD%25BF%25E7%2594%25A8" target="_blank">脱离 SpringBoot 单独使用</a></p><pre><code class="language-xml">&lt;!-- 引入本项目 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.dromara.x-file-storage&lt;/groupId&gt;
    &lt;artifactId&gt;x-file-storage-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 引入，阿里云 OSS SDK，如果使用其它存储平台，就引入对应的 SDK  --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
    &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
    &lt;version&gt;3.16.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p><code>application.yml</code> 配置文件中添加以下基础配置</p><pre><code class="language-yaml">dromara:
  x-file-storage: #文件存储配置
    default-platform: aliyun-oss-1 #默认使用的存储平台
    aliyun-oss:
      - platform: aliyun-oss-1 # 存储平台标识
        enable-storage: true  # 启用存储
        access-key: ??
        secret-key: ??
        end-point: ??
        bucket-name: ??
        domain: ?? # 访问域名，注意「/」结尾，例如：https://abc.oss-cn-shanghai.aliyuncs.com/
        base-path: test/ # 基础路径
</code></pre><h4>🔨编码</h4><p>在启动类上加上<code>@EnableFileStorage</code>注解</p><pre><code class="language-java">@EnableFileStorage
@SpringBootApplication
public class SpringFileStorageTestApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringFileStorageTestApplication.class,args);
    }

}
</code></pre><h4>✨开始上传</h4><p>支持 File、MultipartFile、byte[]、InputStream、URL、URI、String、HttpServletRequest，大文件会自动分片上传。如果想支持更多方式，请阅读 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn%2F%23%2F%25E6%2596%2587%25E4%25BB%25B6%25E9%2580%2582%25E9%2585%258D%25E5%2599%25A8" target="_blank">文件适配器</a> 章节</p><pre><code class="language-java">@RestController
public class FileDetailController {

    @Autowired
    private FileStorageService fileStorageService;//注入实列

    /**
     * 上传文件
     */
    @PostMapping("/upload")
    public FileInfo upload(MultipartFile file) {
        //只需要这一行代码即可上传成功
        return fileStorageService.of(file).upload();
    }
    
    /**
     * 上传文件，成功返回文件 url
     */
    @PostMapping("/upload2")
    public String upload2(MultipartFile file) {
        FileInfo fileInfo = fileStorageService.of(file)
                .setPath("upload/") //保存到相对路径下，为了方便管理，不需要可以不写
                .setObjectId("0")   //关联对象 id，为了方便管理，不需要可以不写
                .setObjectType("0") //关联对象类型，为了方便管理，不需要可以不写
                .putAttr("role","admin") //保存一些属性，可以在切面、保存上传记录、自定义存储平台等地方获取使用，不需要可以不写
                .upload();  //将文件上传到对应地方
        return fileInfo == null ? "上传失败！" : fileInfo.getUrl();
    }

    /**
     * 上传图片，成功返回文件信息
     * 图片处理使用的是 https://github.com/coobird/thumbnailator
     */
    @PostMapping("/upload-image")
    public FileInfo uploadImage(MultipartFile file) {
        return fileStorageService.of(file)
                .image(img -&gt; img.size(1000,1000))  //将图片大小调整到 1000*1000
                .thumbnail(th -&gt; th.size(200,200))  //再生成一张 200*200 的缩略图
                .upload();
    }

    /**
     * 上传文件到指定存储平台，成功返回文件信息
     */
    @PostMapping("/upload-platform")
    public FileInfo uploadPlatform(MultipartFile file) {
        return fileStorageService.of(file)
                .setPlatform("aliyun-oss-1")    //使用指定的存储平台
                .upload();
    }

    /**
     * 直接读取 HttpServletRequest 中的文件进行上传，成功返回文件信息
     * 使用这种方式有些注意事项，请查看文档，基础功能-上传，章节
     */
    @PostMapping("/upload-request")
    public FileInfo uploadPlatform(HttpServletRequest request) {
        return fileStorageService.of(request).upload();
    }
}
</code></pre><h4>🎨其它操作</h4><pre><code class="language-java">//手动构造文件信息，可用于其它操作
FileInfo fileInfo = new FileInfo()
        .setPlatform("huawei-obs-1")
        .setBasePath("test/")
        .setPath("aa/")
        .setFilename("image.png")
        .setThFilename("image.png.min.jpg");

//文件是否存在
boolean exists = fileStorageService.exists(fileInfo);
//下载
byte[] bytes = fileStorageService.download(fileInfo).bytes();
//删除
fileStorageService.delete(fileInfo);
//其它更多操作

</code></pre><p>如果将文件记录保存到数据库中，还可以更方便的根据 URL 进行操作了，详情请阅读 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn%2F%23%2F%25E5%259F%25BA%25E7%25A1%2580%25E5%258A%259F%25E8%2583%25BD%3Fid%3D%25E4%25BF%259D%25E5%25AD%2598%25E4%25B8%258A%25E4%25BC%25A0%25E8%25AE%25B0%25E5%25BD%2595" target="_blank">保存上传记录</a> 章节</p><pre><code class="language-java">//直接从数据库中获取 FileInfo 对象，更加方便执行其它操作
FileInfo fileInfo = fileStorageService.getFileInfoByUrl("https://abc.def.com/test/aa/image.png");

//文件是否存在
boolean exists = fileStorageService.exists("https://abc.def.com/test/aa/image.png");
//下载
byte[] bytes = fileStorageService.download("https://abc.def.com/test/aa/image.png").bytes();
//删除
fileStorageService.delete("https://abc.def.com/test/aa/image.png");
//其它更多操作
</code></pre><p>点击 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn%2F%23%2F%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8" target="_blank">快速入门</a> 查看全部存储平台的使用方法！</p><hr></div>
                                    ]]>
            </description>
            <pubDate>Thu, 19 Oct 2023 00:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262366</guid>
            <link>https://www.oschina.net/news/262366</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌向 Linux 内核提交 mseal() syscall 补丁]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>谷歌工程师近日向 Linux 内核<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Flkml%2F20231016143828.647848-1-jeffxu%40chromium.org%2F" target="_blank">提交了一个新补丁</a></u>，希望为其添加名为 mseal() 的系统调用「<strong>mseal() syscall</strong>」。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1018/182107_uGso_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>据介绍， 谷歌这个<strong>独立于架构的系统调用</strong>最初由 Chrome OS 上的 Chrome 浏览器使用。当时 Glibc 也在动态链接器中进行类似的实验，以在启动时封装所有不可写的段。</p><p>通过 mseal() 可<strong>防止系统调用修改虚拟地址的元数据</strong>。最初支持的是针对 mprotect/pkey_mprotect、munmap、mmap 和 mremap 调用进行封装。为了在 Chrome 和 V8 JavaScript 引擎中提供更好的保护，开发者正在寻求使虚拟内存区域的元数据不可变。</p><p>Glibc 的方案是在动态链接器中添加封装，以便在启动时对所有不可写段进行封装，这也将自动使所有应用程序受益。</p><p>Linus Torvalds 对 mseal() syscall&nbsp;提出的模型表达了保留意见，目前这个提案并没有直接被接受，需要修订才能进化成适合上游的形式。</p><p>Linus 表示：</p><blockquote><p>「我对添加某种’锁定内存映射’ (lock down memory mappings) 模型没有异议，但事实并非如此。</p><p>首先，最明显的问题是提交信息无价值。</p><p>另外更根本的问题要严重得多——"ON_BEHALF_OF_KERNEL" 和 "ON_BEHALF_OF_USERSPACE" 整体完全不合逻辑，整体概念都需要重写。因为这就是 remap_file_pages() 「字面上」的系统调用定义。」</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 10:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262326</guid>
            <link>https://www.oschina.net/news/262326</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米澎湃 OS 界面曝光]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>雷军昨天<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FvjNBvY8Bn9Npnmisru_EKw" target="_blank">官宣</a></u>「小米澎湃 OS」正式诞生（英文命名为 Xiaomi HyperOS），称其将接替 MIUI，并表示正式版已完成封包。</p><blockquote><p>小米澎湃 OS 基于深度进化的 Android 以及自研的 Vela 系统融合，彻底重写底层架构。</p></blockquote><p>小米 14 系列则是第一款搭载小米澎湃 OS 的手机，目前已交付工厂开始生产。</p><p>根据网上流传的小米澎湃 OS 界面截图，其采用全新控制中心，相比 MIUI 14 有了很大变化，小米妙想中心位于控制界面中央，方便使用。从界面来看，澎湃 OS 线条更简洁，视觉更清爽。</p><p><img alt="" height="931" src="https://oscimg.oschina.net/oscnet/up-680458cc567c6c4d0d978b24001e29e620d.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-5872ac15f05f2b0805dee812300aace7400.png" referrerpolicy="no-referrer"></p><p><img alt="" height="1111" src="https://oscimg.oschina.net/oscnet/up-e689790f931181126f237dbd50effd3ccb0.png" width="500" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><img alt="" height="1139" src="https://oscimg.oschina.net/oscnet/up-5cd94040c9348a532ec3a572a7323f51c0a.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="1139" src="https://oscimg.oschina.net/oscnet/up-273f391865e9d9385fbfc26780c02561a60.png" width="500" referrerpolicy="no-referrer"></p><p>有数码博主爆料称，小米澎湃 OS 是自 MIUI 12 以来的最大更新，拥有类似 iOS 锁屏编辑器。此外，新系统的天气动画全面升级，动效更真实，比如云的形状和光影会微调，不像之前直接贴图。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8425347b93ee76ed1aab74fde880a544be7.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e03b9175314cb69350b8d966f079c3644ed.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1e1fa6cfe8f7462579ef46749af7b0b1aab.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>当然，上述截图都没有得到官方证实，一切请以小米官方公布的信息为准。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 08:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262306</guid>
            <link>https://www.oschina.net/news/262306</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[10.28 源创会苏州站，欢迎大家来轰趴馆——寻宝 AI]]>
            </title>
            <description>
                <![CDATA[10.28 源创会苏州站，欢迎大家来轰趴馆——寻宝 AI]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 07:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/event/2331193</guid>
            <link>https://www.oschina.net/event/2331193</link>
        </item>
        <item>
            <title>
                <![CDATA[AlmaLinux 不使用「红帽代码」，如何保持兼容 RHEL]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>科技媒体 ZDNET 资深撰稿人 Steven Vaughan-Nichols 近日发表文章"<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zdnet.com%2Farticle%2Fhow-almalinux-stays-red-hat-enterprise-linux-compatible-without-red-hat-code%2F" target="_blank"><em>How AlmaLinux stays Red Hat Enterprise Linux compatible without Red Hat code</em></a></u>"，介绍了 AlmaLinux 发行版如何在<strong><span style="background-color:#f39c12">没有任何红帽代码</span>的情况下，仍保持兼容 RHEL</strong>。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1019/155002_Xj5s_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>今年 6 月份，红帽<u><a href="https://www.oschina.net/news/246331/red-hat-centos-stream-sources" target="_blank">执行新政策</a></u>限制了 RHEL 的代码访问，此举导致基于 RHEL 的衍生发行版（比如 AlmaLinux，Rocky Linux，Oracle Linux 等）难以提供与 RHEL 100% 兼容的构建。</p><p>针对此政策，甲骨文、SUSE 和 CIQ（Rocky Linux 背后的商业实体）合作<u><a href="https://www.oschina.net/news/253319/oracle-suse-ciq-openela" target="_blank">建立了 OpenELA</a></u>&nbsp;(Open Enterprise Linux Association) —— 旨在创建兼容 RHEL 的 Linux 代码库，并通过提供开放和免费的 Enterprise Linux (EL) 源代码，鼓励开发与 RHEL 兼容的发行版。</p><p><img alt="up-29deac510fcb6941f2761d016a8e201c58a.png" src="https://oscimg.oschina.net/oscnet/up-29deac510fcb6941f2761d016a8e201c58a.png" referrerpolicy="no-referrer"></p><p>AlmaLiniux 没有加入 OpenELA，而是选择了另一条路。AlmaLinux OS 基金会主席 benny Vasquez <a href="https://www.oschina.net/news/249342/almalinux-no-1-1-rhel" target="_blank">原话</a>：<strong>「放弃与 RHEL 1:1 的目标，AlmaLinux 致力于兼容其应用程序二进制接口 (ABI)」</strong>。主要代码从&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.com%2Fredhat%2Fcentos-stream" target="_blank">CentOS Stream</a>&nbsp;获取，其他代码则是从<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.redhat.com%2Fen%2Fblog%2Fintroducing-red-hat-universal-base-image" target="_blank"> Red Hat 通用基础镜像</a>和上游 Linux 代码中获取。</p><p>但最难的部分其实是 RHEL 的 Linux 内核更新。Vasquez 说道：「如果不违反红帽的许可协议，就无法获得这些内核更新。因此他们的做法就是<strong>从其他各种来源获取安全补丁</strong>，以及在 Oracle 发布补丁时再去溯源找到上游。」</p><p>Vasquez 表示这样的流程带来了好处：「AlmaLinux 不再受 RHEL 的约束，而且能够比它更快地发布上游安全修复程序。」比如，AlmaLinux 比 RHEL 提前一周修复了 AMD 微码漏洞。</p><p>由于这篇文章一直在强调 AlamLinux 没有使用「红帽代码」，有人对此<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D37935375" target="_blank">提出了质疑</a></u>，认为 AlamLinux 从&nbsp;CentOS Stream 获取的代码事实上就是「红帽代码」。CentOS Stream 也早已与 RHLE 兼容 ABI。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 16 Oct 2023 08:39:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262448/almalinux-stays-rhel-compatible</guid>
            <link>https://www.oschina.net/news/262448/almalinux-stays-rhel-compatible</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GPT 模型容易被误导从而输出问题内容]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>微软研究院近日<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.microsoft.com%2Fen-us%2Fresearch%2Fblog%2Fdecodingtrust-a-comprehensive-assessment-of-trustworthiness-in-gpt-models%2F" target="_blank">发布文章</a></u>介绍了他们对 GPT 模型可信度的研究。文章称&nbsp;<strong>GPT 模型很容易被误导</strong>，产生有毒和有偏见的输出，并泄露训练数据和对话历史中的隐私信息。</p><p><img src="https://static.oschina.net/uploads/space/2023/1019/114921_ltu9_2720166.png" referrerpolicy="no-referrer"></p><p><em>▲&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F%2F2306.11698" target="_blank">https://arxiv.org/abs//2306.11698</a></em></p><p>微软联合伊利诺伊大学厄巴纳-香槟分校与斯坦福大学、加州大学伯克利分校、人工智能安全中心发布了一款面向大语言模型的综合可信度评估平台——<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdecodingtrust.github.io%2F" target="_blank">DecodingTrust</a></u>，对大模型的毒性、刻板偏见、对抗稳健性、分布稳健性、对抗演示稳健性、隐私、机器伦理和公平性等内容进行评估。</p><p>根据测试，研究者发现 GPT 模型很容易被误导，产生有毒和有偏见的输出，并泄露训练数据和对话历史中的隐私信息。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b61e2f5a48ca552ccf5118cfedadbffc3eb.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-7360d284e297af22f8166099304ef91191b.png" referrerpolicy="no-referrer"></p><p>研究还发现，虽然在标准基准上，GPT-4 通常比 GPT-3.5 更值得信赖，但在越狱系统或用户提示的情况下，GPT-4 更容易受到攻击，这些提示是恶意设计来绕过 LLM 的安全措施的，<strong>这可能是因为 GPT-4 更精确地遵循了（误导性的）指令</strong>。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 16 Oct 2023 03:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262405/trustworthiness-in-gpt-models</guid>
            <link>https://www.oschina.net/news/262405/trustworthiness-in-gpt-models</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gartner 发布 2024 十大战略技术趋势]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="color:#000000"><span style="background-color:#ffffff">Gartner 最新<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.gartner.com%2Fen%2Farticles%2Fgartner-top-10-strategic-technology-trends-for-2024" target="_blank">发布</a>了预计将在未来 36 个月内为 IT 领导者带来重大颠覆和机遇的 10 大战略技术趋势。「</span>这些创新可以推动你更快地实现业务目标，尤其是在人工智能快速发展的时代。<span style="background-color:#ffffff">」</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff"><img alt="" height="407" src="https://oscimg.oschina.net/oscnet/up-5bd7ea9c5644a5ad99798146ce3593b0901.png" width="500" referrerpolicy="no-referrer"></span></span></p><p><strong><span style="color:#000000"><span style="background-color:#ffffff">十大技术趋势具体如下：</span></span></strong></p><ol><li><span style="color:#000000">人工智能信任、风险和安全管理 (AI TRiSM)</span></li><li><span style="color:#000000">持续威胁暴露管理 (CTEM)</span></li><li><span style="color:#000000">可持续技术</span></li><li><span style="color:#000000">平台工程</span></li><li><span style="color:#000000">人工智能增强开发</span></li><li><span style="color:#000000">行业云平台</span></li><li><span style="color:#000000">智能应用</span></li><li><span style="color:#000000">全民化的生成式人工智能</span></li><li>增强型互联员工队伍<span style="background-color:#ffffff; color:#333333">（Augmented-Connected Workforce）</span></li><li><span style="background-color:#ffffff; color:#000000">机器客户</span>（<span style="color:#000000">Machine Customers</span>）</li></ol><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">该公司每年都会列出一份它认为下一年将在科技行业占据主导地位的 10 大趋势。每种趋势都与企业的一个或多个关键主题有关：保护和保存过去和未来的投资，在正确的时间为正确的利益相关者构建正确的解决方案，以及为内部和外部客户不断变化的环境提供价值。</span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">在今年的清单中，其中有 5 个趋势属于「资产保护」的类别：人工智能信任、风险和安全管理 (AI TRiSM)，持续威胁暴露管理 (CTEM)，行业云平台，可持续技术，</span>全民化<span style="background-color:#ffffff">的生成式人工智能。</span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">Gartner 表示，实现这种保护的关键在于要深思熟虑，在没有充分指导的情况下停止无节制的试验；要实事求是，计算项目的投资回报率；在定制创新时要考虑重复使用。「到 2026 年，生成式 AI 将显着改变新 Web 应用程序和移动应用程序 70% 的设计和开发工作。」</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">此外，还划分了「构建者的崛起」和「价值交付」两个类别。其中符合「构建者的崛起」这一主题的趋势包括：平台工程、人工智能增强开发、行业云平台、智能应用、可持续技术和</span>全民化的<span style="background-color:#ffffff">生成人工智能。&nbsp;</span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">符合「价值交付」的包括：机器客户、</span></span>增强型互联员工队伍<span style="color:#000000"><span style="background-color:#ffffff">、智能应用、可持续技术和</span>全民化的<span style="background-color:#ffffff">生成人工智能的趋势。</span></span></p><p style="margin-left:0; margin-right:0; text-align:start">更多详情可查看<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.gartner.com%2Fen%2Farticles%2Fgartner-top-10-strategic-technology-trends-for-2024" target="_blank">此处</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 16 Oct 2023 03:55:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262404/gartner-top-10-strategic-technology-trends-for-2024</guid>
            <link>https://www.oschina.net/news/262404/gartner-top-10-strategic-technology-trends-for-2024</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度 CTO 王海峰：文心一言用户规模已达 4500 万]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>百度首席技术官王海峰在解读文心大模型 4.0 背后的关键技术和最新进展时<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FbC1v9-xKMRbUVhM5JMT58A" target="_blank">表示</a>，文心大模型 4.0 的理解、生成、逻辑、记忆四大能力都有显著提升。</p><p>文心大模型 4.0 在 9 月已开始小流量上线，过去一个多月效果又提升了近 30%。训练算法效率自 3 月以来已累计提升 3.6 倍，周均的训练有效率超过 98%。</p><p>8 月 31 日文心一言面向全社会开放至今，用户规模已经达到 4500 万，开发者 5.4 万，场景 4300 个，应用 825 个，插件超过 500 个。</p><p>王海峰指出，文心大模型 4.0 的理解和生成能力的提升幅度相近，而逻辑和记忆能力的提升则更大，逻辑的提升幅度达到理解的近 3 倍，记忆的提升幅度也达到了理解的 2 倍多。百度基于文心大模型研制了智能代码助手 Comate，从内部应用效果来看，整体的代码采纳率达到 40%，高频用户的代码采纳率达到 60%。</p><p><img height="281" src="https://oscimg.oschina.net/oscnet/up-856d6910a56bbb2d0ae2902d1c1c9b8247b.png" width="500" referrerpolicy="no-referrer"></p><p><img height="281" src="https://oscimg.oschina.net/oscnet/up-fdb22be35e82911409420c1314a4f74d7cb.png" width="500" referrerpolicy="no-referrer"></p><p>此外，文心大模型 4.0 在输入和输出阶段都进行知识点增强。一方面，对用户输入的问题进行理解，并拆解出回答问题所需的知识点，然后在搜索引擎、知识图谱、数据库中查找准确知识，最后把这些找到的知识组装进 Prompt 送入大模型，准确率好，效率也高；另一方面，对大模型的输出进行反思，从生成结果中拆解出知识点，然后再利用搜索引擎、知识图谱、数据库，以及大模型本身进行确认，进而对有差错的点进行修正。</p><p>王海峰还公布了百度人工智能人才培养的最新数据称，百度在 2020 年提出 5 年为全社会培养 500 万 AI 人才，截至目前已经培养了 420 万 AI 人才。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 16 Oct 2023 03:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262394</guid>
            <link>https://www.oschina.net/news/262394</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Qt 6.5 LTS 转为「仅面向商业客户提供」阶段]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>随着 <u><a href="https://www.oschina.net/news/261263/qt-6-6-released" target="_blank">Qt 6.6 正式发布</a></u>，<u><a href="https://www.oschina.net/news/235304/qt-6-5-lts-released" target="_blank">Qt 6.5 LTS</a></u>&nbsp;已转变为<strong>仅面向商业客户提供 (Commercial-only)</strong>。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1019/104731_bHJt_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>Qt 官方在开发者邮件列表<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flists.qt-project.org%2Fpipermail%2Fdevelopment%2F2023-October%2F044573.html" target="_blank">写道</a></u>：</p><blockquote><p>随着 Qt 6.6.0 的发布和首个补丁更新 (Qt 6.6.1)&nbsp;将于 11 月发布，Qt 6.5 LTS 也将进入「仅限商业客户使用」的 LTS 阶段。</p><p>6.5 现有的全部分支仍然公开，<strong>但它们已不再接受新的 commit 和 cherry-picks</strong>——除了 Qt WebEngine，因为它具有使用 LPGL 许可证的第三方依赖。</p><p>生效时间从 2023 年 10 月 18 日开始。在此之后，cherry-picks 将进入另一个仓库，仅对商业许可证持有者开放。</p><p>首个仅限商业客户使用的 Qt 6.5.4 LTS 补丁版本计划于 11 月底发布。</p><p>外部模块维护者可以继续访问&nbsp;Qt 6.5 商业客户专有仓库。</p></blockquote><p><u><a href="https://www.oschina.net/news/125661/qt-5-15-lts-commercia" target="_blank">这项政策从 2020 年开始实施</a></u>。2020 年 1 月，Qt 公司宣布对 Qt 项目的运营策略进行改革，所有用户都需要注册 Qt 帐户才能获取安装 Qt 的二进制文件（源码文件不受限制），同时长期支持版本 (LTS) 和离线安装程序仅面向拥有商业许可证的大型企业用户提供，只有最新的非稳定版本仍可供用户免费使用。</p><p><img alt="081354_Y2Ti_4487475.png" src="https://static.oschina.net/uploads/space/2021/0106/081354_Y2Ti_4487475.png" referrerpolicy="no-referrer"></p><hr><p>延伸阅读：</p><ul><li><a href="https://www.oschina.net/news/114828/qt-might-restrict-new-releases" target="_blank">KDE 社区称 Qt 公司正考虑仅面向付费用户提供新版本</a></li><li><a href="https://www.oschina.net/news/181231/qt-simplify-commercial">Qt 简化商业授权方案</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 16 Oct 2023 03:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262391/qt-6-5-lts-commercial-only</guid>
            <link>https://www.oschina.net/news/262391/qt-6-5-lts-commercial-only</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[报告：Web 开发岗最易受到 ChatGPT 冲击]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="color:#000000">编程网站&nbsp;Programiz&nbsp;最新发布了一份调查<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fprogramiz.pro%2Freport" target="_blank">报告</a>，旨在揭示 ChatGPT 对编程教育领域的影响，并涉及了 ChatGPT 对职业生涯的影响。值得注意的是，此项调查是在&nbsp;GPT-4 发布之前进行的。</span></p><p><span style="color:#000000">该报告基于来自 50 多个国家/地区的 10000 多名受访者的见解，受访者就 ChatGPT 如何改写他们的学习经历、重塑职业道路以及影响他们对 AI 未来世界的愿景发表了看法。其中&nbsp;58% 的受访者为学生，超过一半的受访者只拥有不到一年的编程经验。</span></p><p><span style="color:#000000">一些亮点内容包括：</span></p><ul><li><span style="color:#000000">67% 的受访者表示使用 ChatGPT 作为主要来源或学习编程的辅助手段，大多数受访者使用它来理解编程概念。有&nbsp;72% 的人每周多次使用 ChatGPT 来学习编程。</span></li><li><span style="color:#000000">理解编程概念、调试/改进代码以及理解他人的代码是 ChatGPT 在学习编程过程中的三大主要用途。</span></li></ul><p>​​​​​​​<img height="301" src="https://oscimg.oschina.net/oscnet/up-af24038b9255d20bf70aaca17423dd3694b.png" width="400" referrerpolicy="no-referrer"></p><ul><li><span style="color:#000000">77%&nbsp;的受访者认为 ChatGPT 改善了他们的编程学习体验。只有 6% 的受访者表示 ChatGPT 的回答无法准确满足他们的学习需求。</span></li><li><span style="color:#000000">不相关和不一致的回答 (54%) 是使用 ChatGPT 学习编程时面临的主要挑战。40% 的受访者表示，过度依赖 ChatGPT 可能会阻碍批判性思维和解决问题的能力；还有 19% 的受访者非常担心会导致人际互动和个性化指导的丧失。</span></li><li><span style="color:#000000">30% 的人认为 ChatGPT 优于大学讲座，超过 38% 的人更喜欢 ChatGPT 而不是 Google。</span></li></ul><p><img height="249" src="https://oscimg.oschina.net/oscnet/up-e5323cf758b8bf8b5281f2b0a820281df0b.png" width="400" referrerpolicy="no-referrer"></p><ul><li><span style="color:#000000">近 75% 的受访者正在提高技能或计划提高技能，为 ChatGPT 对就业市场的影响做好准备。</span></li><li><span style="color:#000000">34%&nbsp;的受访者因 ChatGPT 而经历了工作上的一些转变。</span></li><li><span style="color:#000000">61% 的受访者对 ChatGPT 在科技领域创造新就业机会的潜力持乐观态度，51% 的受访者认为 Web 开发最容易受到 ChatGPT 造成的工作流失的影响。</span></li><li><span style="color:#000000">17% 的受访者认为 ChatGPT 将完全取代传统教学方式，​​​​​​​84% 的人认为教育机构应该针对 ChatGPT 调整其编程课程。</span></li></ul><p><span style="color:#000000">报告指出，如果有效利用，ChatGPT 有能力显著改变编程教育领域。现在采用这项技术不仅有可能提升职业生涯，还能使个人在不断发展的环境中保持领先地位。&nbsp;</span></p><p><span style="color:#000000">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fprogramiz.pro%2Freport" target="_blank">查看完整报告</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 15 Oct 2023 08:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262310/chatgpt-programming-education-report</guid>
            <link>https://www.oschina.net/news/262310/chatgpt-programming-education-report</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[英伟达发布 Windows 版 TensorRT-LLM 库，为本地运行大模型提速]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源创会预告】1024 程序员节（的前两天），相约开源中国办公室，我们一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>英伟达<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.nvidia.com%2Fblog%2F2023%2F10%2F17%2Ftensorrt-llm-windows-stable-diffusion-rtx%2F" target="_blank">发布</a></u>了 Windows 版本的 TensorRT-LLM 库，称其<strong>将大模型在 RTX 上的运行速度提升 4 倍</strong>。</p><p><img src="https://static.oschina.net/uploads/space/2023/1018/153818_0cWf_2720166.png" referrerpolicy="no-referrer"></p><p>GeForce RTX 和 NVIDIA RTX GPU 配备了名为 Tensor Core 的专用 AI 处理器，正在为超过 1 亿台 Windows PC 和工作站带来原生生成式 AI 的强大功能。</p><p>TensorRT-LLM 是一个开源库，用于提升上述 GPU 运行最新 AI 大模型（如 Llama 2 和 Code Llama）的推理性能。上个月英伟达发布了面向数据中心的 TensorRT-LLM，现在最新发布的 TensorRT-LLM for Windows 主要是面向家用电脑，将 PC 上运行 LLM 的速度提高了 4 倍。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-bef2ad6f2d5cae9eee341fbbad7d6c337c0.png" referrerpolicy="no-referrer"></p><p>英伟达还同时发布了帮助开发人员加速 LLM 的工具，包括使用 TensorRT-LLM 优化自定义模型的脚本、TensorRT 优化的开源模型以及展示 LLM 响应速度和质量的开发人员参考项目。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 15 Oct 2023 07:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262298/tensorrt-llm-windows-stable-diffusion-rtx</guid>
            <link>https://www.oschina.net/news/262298/tensorrt-llm-windows-stable-diffusion-rtx</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
