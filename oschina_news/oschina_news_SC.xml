<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-最新资讯]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-最新资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Sun, 05 Nov 2023 18:47:34 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[OpenELA 公开发布 Enterprise Linux 源代码]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#000000">Open Enterprise Linux Association (OpenELA)</span><span style="color:#000000"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenela.org%2Fnews%2F2023.11.02-governance_and_code_availability%2F" target="_blank">宣布</a>公开发布 Enterprise Linux (EL) 源代码并成立技术指导委员会。</span></p><blockquote><p><span style="color:#000000">「OpenELA 很高兴地宣布，现在所有人都可以获取构建衍生&nbsp;Enterprise Linux 操作系统所需的全部源代码包。初步侧重点在于 EL8 和 EL9，EL7 的软件包也即将推出。该项目致力于确保向社区无限期提供 EL 源代码。」</span></p></blockquote><p><img alt="" height="381" src="https://oscimg.oschina.net/oscnet/up-08878f094d1e8bcafadeca1ea19e8f93ccc.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">OpenELA 是在今年 8 月份，由甲骨文、SUSE 和 CIQ (Rocky Linux 背后的商业实体) 联合组建的一个开源企业 Linux 发行版开发商的行业协会；旨在通过提供开放和免费的 Enterprise Linux 源代码，鼓励<span style="background-color:#ffffff">与 Red Hat Enterprise Linux (RHEL) 兼容的发行版的开发和协作</span>。</span><span style="background-color:#ffffff; color:#000000">OpenELA 的形成源于红帽</span><a href="https://www.oschina.net/news/246331/red-hat-centos-stream-sources">对 RHEL 源代码可用性的更改</a><span style="background-color:#ffffff; color:#000000">。</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Oracle、SUSE 和 CIQ&nbsp;方面都表达了对这一进展的喜悦之情。CIQ 首席执行官兼 Rocky Linux 创始人 Gregory Kurtzer 发言称：</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">「几十年来，各组织都在 CentOS 上进行标准化，因为它是免费的，遵循 Enterprise Linux 标准，并且得到许多供应商的大力支持。CentOS 停产后，不仅在生态系统中留下了一个巨大的漏洞，而且也清楚地表明了社区需要团结起来才能做得更好。OpenELA 正是这样的一个社区答案，它将确保所有专业 IT 部门和企业用例拥有一个协作和稳定的未来。」</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">AlmaLinux 尚未加入该协会。AlmaLinux 操作系统基金会主席 benny Vasquez 评论表示，「</span></span><span style="background-color:#ffffff; color:#000000">我总是很乐于看到一个新的非营利组织站稳脚跟并开始</span><span style="color:#000000"><span style="background-color:#ffffff">运作。不过我们目前还不会使用他们发布的代码，因为我们已经建立了自己的工作流程，不需要使用这些代码。」</span></span></p><p><span style="color:#000000">OpenELA&nbsp;已经<span style="background-color:#ffffff">完成了在美国特拉华州的非营利性非股份公司的注册，正在向美国国税局申请 501(c)(6) 免税资格。该公司表示，将为有兴趣支持开源企业 Linux 发行版开发目标和利益的利益相关者提供一个论坛。「创始公司认为，法律实体是对开源工作产生积极影响的基础性工具，可以统一开源工作的价值观，并确保与开源社区的适当接触。」</span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>相关阅读：</strong></span></p><ul><li style="text-align:start"><a href="https://www.oschina.net/news/253319/oracle-suse-ciq-openela" target="_blank">SUSE、甲骨文和 CIQ 组建 OpenELA：企业 Linux 源代码的社区存储库</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 04:22:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264995/openela-enterprise-linux-source</guid>
            <link>https://www.oschina.net/news/264995/openela-enterprise-linux-source</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenHarmony 4.0 正式发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">OpenHarmony 4.0 版本现已<a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/release-notes/OpenHarmony-v4.0-release.md">发布</a>，</span>开发套件同步升级到 API 10。相比 3.2 Release 版本，新增 4000 多个 ArkTS API，应用开发能力更加丰富；HDF 新增 200 多个 HDI 接口，硬件适配更加便捷；持续优化图形框架和方舟编译器（ArkCompiler），用户交互体验得到进一步提升；ArkUI 组件定制化能力和组件动效能力也得到进一步增强；分布式硬件支持的范围扩大到音频和输入领域；分布式数据为开发者数据分享带来了全新的统一数据管理框架。</span></p><p><span style="color:#000000">另外，该版本在媒体、安全和隐私保护等方面也得到了进一步增强。</span></p><h2>特性说明</h2><h3>应用框架</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">Stage 模型完善了以下特性：</p><ul><li><p style="margin-left:0; margin-right:0">新增 Extension 能力最小化管理，支持各类 Extension 满足业务场景需要。</p></li><li><p style="margin-left:0; margin-right:0">新增 UIExtension 机制，用于实现有界面的 Extension，UIExtension 的界面可以通过 UIExtension 组件的方式嵌入到调用方应用的窗口上显示。</p><ul><li><p style="margin-left:0; margin-right:0">支持统一的 UIExtension 模板，定义基础的生命周期和上下文能力。</p></li><li><p style="margin-left:0; margin-right:0">支持原生默认的 Extension 界面展示，方便开发者快速实现 Extension 功能，同时也提供界面定制能力。</p></li><li><p style="margin-left:0; margin-right:0">提供连接和断连 ExtensionAbility 的能力。</p></li><li><p style="margin-left:0; margin-right:0">支持对 UIExtensionAbility 页面设置背景色。</p></li><li><p style="margin-left:0; margin-right:0">支持对 UIExtensionAbility 页面隐私属性，设置了隐私的页面不能被录屏或截屏。</p></li><li><p style="margin-left:0; margin-right:0">支持通过 UIExtensionAbility 连接 Service。</p></li></ul></li><li><p style="margin-left:0; margin-right:0">提供自定义操作业务的 ActionExtension、分享业务的 ShareExtension、备份恢复业务的 BackupExtension、驱动业务的 DriverExtension、打印业务的 PrintExtension。</p></li><li><p style="margin-left:0; margin-right:0">ArkTS 卡片能力增强，支持静态卡片配置、静态图展示，有效降低卡片内存资源占用，支持通过数据代理的方式刷新内容，有效降低卡片功耗。</p></li><li><p style="margin-left:0; margin-right:0">支持元服务的分享，应用开发者可以使用 UIAbility 组件提供的 UIAbility.onShare() 生命周期方法，设置要分享的数据。用户可以通过分享框把元服务和卡片分享到另外一台终端设备。</p></li><li><p style="margin-left:0; margin-right:0">跨端迁移能力增强，支持调用接口来动态打开和关闭迁移能力。应用可动态选择迁移成功后是否迁移页面栈，以及源端是否退出。</p></li></ul><h3>应用包管理</h3><ul><li><p style="margin-left:0; margin-right:0">支持应用安装包免解压特性，优化系统启动性能和应用安装性能。</p></li><li><p style="margin-left:0; margin-right:0">支持应用、元服务数据共享，在应用安装时，解析证书文件中的 data-group-ids 列表，建立映射关系，创建数据共享路径，实现应用与元服务数据共享。</p></li><li><p style="margin-left:0; margin-right:0">支持应用安装时设置分发类型和附加信息，提供 ArkTS 接口实现应用分发类型和附加信息的设置和查询。</p></li><li><p style="margin-left:0; margin-right:0">支持根据文件扩展名查询打开文件的应用列表，实现通过文件扩展名打开文件。</p></li><li><p style="margin-left:0; margin-right:0">支持企业应用，提供企业 MDM 应用和企业 normal 应用的安装，以及对企业应用的管理和吊销。</p></li><li><p style="margin-left:0; margin-right:0">支持 overlay 能力，针对不同产品的显示风格，开发者可以在不重新编译打包情况下，新增资源文件 overlay 包，实现应用界面风格变换。</p></li><li><p style="margin-left:0; margin-right:0">拆包工具支持多语言，应用市场可查询包中的多语言信息，支持在不同的语言环境下分发应用。</p></li><li><p style="margin-left:0; margin-right:0">支持 so 文件不解压使用，即不解压 so 文件到单独目录，运行期直接从包中读取加载 so 文件，提升安装速度和减少占用的 ROM 空间。</p></li></ul><h3>ArkUI</h3><ul><li><p style="margin-left:0; margin-right:0"><strong>基础组件增加或增强：</strong></p><ul><li>新增 UIExtension 组件，用于将一个应用通过 UIExtensionAblity 的方式，嵌入显示到另一个应用内。</li><li>绘制组件 Rect/Circle/Ellipse/Line/Polyline/Polygon/Path/Rect/Shape 支持偏移、裁剪、遮罩等通用属性，增强绘制组件基础功能。</li><li>自定义弹框支持蒙层颜色及弹出动画自定义，如允许设置弹出动画效果的相关参数，增强弹框的开发者自定义功能。</li><li>bindContextMenu/bindMenu 支持自定义位置，允许设置菜单的位置，增强菜单基础功能。</li><li>ColumnSplit 分隔线支持可拖动，增强组件基础功能。</li><li>Refresh 组件支持自定义下拉刷新能力，允许设置下拉刷新时的显示内容，增强组件基础能力。</li><li>支持文本组件中返回输入字符串的宽高，用于字符串折叠显示时，鼠标悬浮可弹出字符串完整提示框，增强文本组件基础功能。</li><li>Xcomponent 组件支持 Texture 模式绘制。</li><li>Popup 组件支持自定义位置。</li><li>ArkTS/JS 卡片支持 UI 渲染完成的回调，方便获取渲染完成的状态并进行下一步处理。</li><li>Image/Text 组件支持设置隐私遮罩的属性。</li><li>基础组件特性增强，提升终端用户的体验，包括弹框支持通过键盘 ESC 键逐层退出、ListItem 支持长距离左滑删除手势、ContextMenu 支持分段显示能力等。</li><li>Grid 组件支持设置布局信息。</li><li>Menu 组件支持设置圆角。</li><li>半模态组件支持设置高度自适应。</li></ul></li><li><p style="margin-left:0; margin-right:0"><strong>动画效果增加或增强：</strong></p><ul><li>支持组件属性变化的过渡动效，如组件的尺寸、背景色、透明度等属性发生变化时通过过渡动效衔接变化前后的状态，提升组件属性变化时的动画体验。</li><li>支持给组件设置球面高阶属性、下边缘像素扩展、取色模糊、G2 圆角、阴影、渐变等高阶图形属性，丰富高阶动画效果。</li><li>布局属性、背景图片大小位置属性、显隐属性支持隐式动效。</li><li>List 新增支持 scrollToIndex 动效、Tasb 模糊动效、Popup 出现/消失动效。</li><li>支持自定义动画，满足多种多样的动画诉求。</li></ul></li><li><p style="margin-left:0; margin-right:0">开发效率增强：支持命名路由的能力，借助此能力可针对不同页面设置差异化的切换动效；轻量级 ArkUI 框架支持定义全局数据对象，可进行应用内页面间的数据共享。</p></li><li><p style="margin-left:0; margin-right:0">框架能力增强，包括：全局 API 支持 Stage 模型多实例场景，支持 Rosen 渲染后端等。</p></li><li><p style="margin-left:0; margin-right:0">对富文本的交互能力增强：新增支持手势长按选中文本、支持鼠标拖动选中文本、支持设置文本可编辑（通过通用属性设置富文本框是否使能编辑）、支持对输入事件的监听。</p></li><li><p style="margin-left:0; margin-right:0">弹窗功能增强，新增错误、信息和询问三种消息弹窗接口，完善警告弹窗三按钮场景和交互优化。</p></li></ul><h3>ArkCompiler</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>高级语言调试调优：</strong></p><ul><li><p style="margin-left:0; margin-right:0">热重载性能优化，支持多 hap 等场景。</p></li><li><p style="margin-left:0; margin-right:0">支持多实例调优。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>高级语言并发增强：</strong></p><ul><li><p style="margin-left:0; margin-right:0">TaskPool 支持任务中断和取消，支持定义任务组（TaskGroup），支持对任务的状态和调度信息进行打点，支持超长等待的任务进行识别和恢复。</p></li><li><p style="margin-left:0; margin-right:0">TaskPool 支持优先级设置及自动扩缩容算法。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>高级语言优化编译：</strong></p><ul><li><p style="margin-left:0; margin-right:0">正式定义 ArkTS 语法规则并新增 ArkTS 语法检查，在使用 DevEco Studio 进行代码编译时会对不符合 ArkTS 语法规则的代码进行告警。语法检查的规则详见<a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/application-dev/quick-start/typescript-to-arkts-migration-guide.md">从 TypeScript 到 ArkTS 的迁移指导</a>。</p></li><li><p style="margin-left:0; margin-right:0">AOT 优化编译支持端侧闲时编译，增强编译优化进一步提升性能。</p></li><li><p style="margin-left:0; margin-right:0">PGO 支持采集运行期的类型和函数热点信息，支持 AOT 优化编译 JS 代码，提升动态 JS 代码的运行性能。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>高级语言运行时其它功能：</strong></p><ul><li><p style="margin-left:0; margin-right:0">支持动态 import 加载 NAPI 库。</p></li><li><p style="margin-left:0; margin-right:0">NAPI buffer、object、arraybuffer、object type 接口功能补齐。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>编译工具链更新：</strong></p><ul><li><p style="margin-left:0; margin-right:0">clang/llvm 工具链升级到 15.0.4 版本。</p></li><li><p style="margin-left:0; margin-right:0">libc 版本升级到 1.2.3 版本，libc 库接口性能优化。</p></li><li><p style="margin-left:0; margin-right:0">sigaction 函数提供 sigchain 功能。</p></li></ul><h3>分布式数据管理</h3><ul><li><p style="margin-left:0; margin-right:0">DataShare 客户端提供按 URI 前缀订阅 DataShareExtension 数据变化的能力，被订阅的 URI 前缀下任何 DataShareExtension 数据发生变化都会通知 DataShare 客户端。</p></li><li><p style="margin-left:0; margin-right:0">新增统一数据管理框架（Unified Data Management Framework, UDMF），支持数据标准化模型、设备内数据拖拽、UDMF 数据存储适配、权限管理、生命周期管理。UDMF 框架下支持应用的跨设备拖拽，在此过程中允许对分布式目录中的文件临时授权。</p></li><li><p style="margin-left:0; margin-right:0">提供 RDBstore NDK 接口 ：包含增/删/改/查/事务、数据加密、数据分级保护、备份/恢复能力。</p></li><li><p style="margin-left:0; margin-right:0">Key-Value 和分布式数据对象支持根据数据量自动选择数据同步的通道。系统会根据数据量大小自动选择蓝牙通道或基于 Wi-Fi 的 P2P 通道进行数据的同步。</p></li><li><p style="margin-left:0; margin-right:0">支持系统应用通过数据管理服务代理静默访问其他系统应用的 DataShareExtension 数据，即不拉起 DataShareExtension 所在的应用即可访问应用 DataShareExtension 的数据。</p></li></ul><h3>分布式软总线</h3><ul><li><p style="margin-left:0; margin-right:0">支持对基于软总线连接的 link 信息进行管理。</p></li><li><p style="margin-left:0; margin-right:0">支持会话级的传输能力协商，可通过协商确定设备间传输的能力。</p></li></ul><h3>分布式硬件</h3><ul><li><p style="margin-left:0; margin-right:0">分布式音频支持扬声器（speaker），麦克风（mic）的资源池化管理，可以在 native 系统服务中跨设备使用远端设备的扬声器和麦克风，并支持控制远端设备的扬声器音量。</p></li><li><p style="margin-left:0; margin-right:0">分布式输入支持键盘，鼠标，触摸板的资源池化管理，可以在系统应用中触发跨设备的键盘、鼠标和触摸板的使用。</p></li></ul><h3>文件管理</h3><ul><li><p style="margin-left:0; margin-right:0">支持文件分类视图管理能力，图库等应用以相册方式管理媒体文件（图片、视频无需关注具体存储位置），相册内添加、移除文件等功能不涉及具体的 File IO 行为。支持三方应用通过 PhotoAccessHelper 接口获取相册列表，访问相册内图片、视频等文件。</p></li><li><p style="margin-left:0; margin-right:0">提供增强的 FileIO 访问能力，支持 randomAccessFile、moveDir、copyDir 能力。</p></li><li><p style="margin-left:0; margin-right:0">提供基于 URI 的文件临时授权访问及取消授权能力，支持文件的跨应用本地授权或跨设备授权。</p></li><li><p style="margin-left:0; margin-right:0">支持公共图片文件在设备端和云端进行同步（设备登录的帐号需开通云端服务），支持通过 picker 选择云端的图片。</p></li><li><p style="margin-left:0; margin-right:0">支持应用定制备份恢复的目录。</p></li><li><p style="margin-left:0; margin-right:0">支持应用监听沙箱内的文件变化。</p></li></ul><h3>图形显示及窗口</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>图形</strong></p><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">稳定流畅：</p><ul><li><p style="margin-left:0; margin-right:0">对统一渲染模式进行了性能优化，包含基于共享内存的 IPC 性能优化、基于遮挡剔除和缓存等技术的渲染性能优化、基于硬件合成器能力的能效提升等。</p></li><li><p style="margin-left:0; margin-right:0">图形处理依赖的渲染库升级至 Skia 0310 新版本，提升了渲染性能。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">极致动效：</p><ul><li><p style="margin-left:0; margin-right:0">支持组件自绘制内容的属性动画。支持组件设置出现和消失的转场动画。</p></li><li><p style="margin-left:0; margin-right:0">支持取色能力，支持渐变模糊，支持边缘像素扩展，支持渐亮效果，支持多种模糊材质能力。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">图片能力增强：</p><ul><li><p style="margin-left:0; margin-right:0">图片编解码能力增强：支持 SVG 格式图片解码，ico 格式图片解码，GIF 增量解码，jpeg_IDCT 缩放解码，png 图片编码，图片 exif 信息拓展。</p></li><li><p style="margin-left:0; margin-right:0">图片接口能力增强：支持 Pixelmap JS 侧的序列化反序列化，提供 ImageReceiver 和图片解码 NDK 接口。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>窗口</strong></p><ul><li><p style="margin-left:0; margin-right:0">支持监听窗口的获焦状态，可以监听单个窗口的获焦、失焦和显示隐藏状态。</p></li><li><p style="margin-left:0; margin-right:0">支持应用将子窗口 z 轴顺序调整到当前应用窗口中的顶层。</p></li><li><p style="margin-left:0; margin-right:0">支持查询屏幕的显示模式（镜像、扩展），提供停止镜像和停止扩展 API。</p></li><li><p style="margin-left:0; margin-right:0">优化了 display 模块的参数值获取方式，从原先软件方式优化为从硬件直接获取真实值。</p></li><li><p style="margin-left:0; margin-right:0">支持通过窗口设置将屏幕亮度恢复默认值。</p></li><li><p style="margin-left:0; margin-right:0">重构沉浸式实现方式，优化应用打开、退出、跳转下的动画效果。</p></li></ul><h3>媒体</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>音频</strong></p><ul><li><p style="margin-left:0; margin-right:0">支持通过 Native 接口（OHAudio）进行音频播放和录制。对于音频录制和播放的时延比较敏感的场景，使用 Native 接口可实现更低的时延。</p></li><li><p style="margin-left:0; margin-right:0">支持查询或监听当前优先级最高的播放设备。</p></li><li><p style="margin-left:0; margin-right:0">支持闹钟音量的独立调整。</p></li><li><p style="margin-left:0; margin-right:0">支持通过物理按键设置静音。</p></li><li><p style="margin-left:0; margin-right:0">支持音频焦点：应用播放音频时无需手动申请焦点，系统会在后台自动申请焦点，并自动执行焦点策略（如暂停、淡出、淡出恢复等）；应用仅需要注册焦点事件监听函数，以接收焦点事件并更新状态，如暂停时停止进度条。支持短音播放。</p></li><li><p style="margin-left:0; margin-right:0">支持音效模式：应用可查询音频输出的音效模式，切换或关闭音效模式。</p></li><li><p style="margin-left:0; margin-right:0">支持系统内录音能力：可根据音频场景属性筛选，录制系统内播放的音频数据，支持对录音设备进行查询。</p></li><li><p style="margin-left:0; margin-right:0">音频设备能力增强：支持获取音频设备显示名，播放对象详细信息内可获取当前播放输出归属的设备名。支持对蓝牙连接的多个可用于音频播放的设备进行查询并选择音频播放的设备。支持标准 USB 协议的音频外设。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>播控框架</strong></p><ul><li><p style="margin-left:0; margin-right:0">支持媒体提供方和控制方之间传递自定义媒体信息，应用可扩展媒体内容展示方式，如媒体控制方可要求媒体提供方按特殊形式显示歌曲歌词。</p></li><li><p style="margin-left:0; margin-right:0">支持媒体播放列表的框架能力，媒体提供方提供播放列表内容，媒体控制方获取播放列表内容并可以选择任一媒体内容进行播放。</p></li><li><p style="margin-left:0; margin-right:0">支持播放历史记录的框架能力，媒体会话框架提供查询历史播放应用的列表，列表项按播放先后顺序排序（包含当前播放的和已退出的应用）。</p></li><li><p style="margin-left:0; margin-right:0">提供自定义媒体事件的传输通道，如歌词内容的传输通道，媒体提供方提供歌词内容，媒体控制方获取歌词内容。</p></li><li><p style="margin-left:0; margin-right:0">提供自定义的媒体控制命令的传输通道，媒体控制方可以利用该自定义命令传输通道向媒体提供方发送自定义控制命令，如媒体控制方要求媒体提供方显示弹幕信息。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>媒体播放</strong></p><ul><li><p style="margin-left:0; margin-right:0">支持基于 HLS 协议的网络直播功能以及基于 datasource 的流式播放功能。</p></li><li><p style="margin-left:0; margin-right:0">支持基于 HDI 的 H.265 视频硬解播放能力。</p></li><li><p style="margin-left:0; margin-right:0">支持播放音频属性设置，用户在使用播放器的时候可以选择输出声音的类型。</p></li><li><p style="margin-left:0; margin-right:0">支持视频自带的旋转播放功能。</p></li><li><p style="margin-left:0; margin-right:0">支持音效参数配置，可以在音频框架支持音效的能力基础上进一步配置音效。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>相机</strong></p><ul><li><p style="margin-left:0; margin-right:0">支持前置预览镜像能力，默认情况下，前置预览画面呈镜像状态。</p></li><li><p style="margin-left:0; margin-right:0">支持分布式摄像头查询该摄像头的主设备属性，包括设备名称和设备类型。</p></li><li><p style="margin-left:0; margin-right:0">支持更精细化的分辨率查询，可以按照预览、拍照、录像用途查询支持的尺寸、格式和帧率信息。</p></li><li><p style="margin-left:0; margin-right:0">相机框架提供横向归一化座标系[0, 0, 1, 1]，所有与座标相关的操作都基于这套座标系完成。</p></li><li><p style="margin-left:0; margin-right:0">不同相机应用使用同一个摄像头场景下，相机框架具备优先级管控和互斥策略。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>音视频编解码</strong></p><ul><li><p style="margin-left:0; margin-right:0">支持获取系统的音视频编解码，可以调用本模块的 Native API 接口，查询系统编解码能力的支持情况。</p></li><li><p style="margin-left:0; margin-right:0">支持音视频封装，可以调用本模块的 Native API 接口，完成音视频封装，即将音频、视频等编码后的媒体数据，按一定的格式存储到文件里。</p></li><li><p style="margin-left:0; margin-right:0">支持音视频解封装，可以调用本模块的 Native API 接口，完成音视频解封装，即从比特流数据中取出音频、视频等媒体帧数据。</p></li></ul><h3>事件通知</h3><ul><li><p style="margin-left:0; margin-right:0">支持应用设置静态事件订阅的开关。</p></li><li><p style="margin-left:0; margin-right:0">支持系统应用删除已发布的粘性事件。</p></li><li><p style="margin-left:0; margin-right:0">支持应用设置代表通知数量的数字角标。</p></li><li><p style="margin-left:0; margin-right:0">支持将通知设置为不可移除。</p></li><li><p style="margin-left:0; margin-right:0">支持选定通知并批量删除通知。</p></li><li><p style="margin-left:0; margin-right:0">应用内事件处理模块支持取消已按条件指定订阅的回调。</p></li></ul><h3>通信与连接</h3><ul><li><p style="margin-left:0; margin-right:0">支持 NFC eSE 卡模拟能力。</p></li><li><p style="margin-left:0; margin-right:0">支持 Wi-Fi 连接 AP 时使用随机 MAC。</p></li><li><p style="margin-left:0; margin-right:0">支持 Wi-Fi 通过静态 IP 连接 AP。</p></li></ul><h3>系统服务管理</h3><ul><li><p style="margin-left:0; margin-right:0">支持系统服务按需启动机制，例如外部调用、事件触发，同时支持在设备空闲时自动退出系统服务。</p></li><li><p style="margin-left:0; margin-right:0">系统服务配置格式优化，使用 JSON 格式替代 XML 格式。</p></li></ul><h3>电源</h3><ul><li><p style="margin-left:0; margin-right:0">增强系统电量等级查询及上报能力，支持电量等级的裁剪和定制。</p></li><li><p style="margin-left:0; margin-right:0">支持有线和无线充电类型上报，充电类型包括普通充电、快速充电和超级快速充电。</p></li><li><p style="margin-left:0; margin-right:0">增强运行锁的管控机制，明确系统电源状态和等级。</p></li><li><p style="margin-left:0; margin-right:0">提供唤醒源设置能力，支持通过电源键、鼠标、键盘、触控板、屏幕、手写笔、皮套等方式唤醒设备。</p></li><li><p style="margin-left:0; margin-right:0">提供休眠源设置能力，支持通过电源键、皮套、及超时自动休眠等方式设置设备休眠。</p></li><li><p style="margin-left:0; margin-right:0">提供电源管理、电池管理、显示亮度管理、耗电统计及热管理的开发指南。</p></li><li><p style="margin-left:0; margin-right:0">新增系统接口，支持设置系统立即进入睡眠状态。</p></li></ul><h3>多模输入</h3><ul><li><p style="margin-left:0; margin-right:0">支持将键盘输入设备的原始事件映射为归一化交互的意图事件。</p></li><li><p style="margin-left:0; margin-right:0">支持用户根据个人习惯设置触控板功能的个性化配置：</p><ul><li>支持两种触发模式映射鼠标左键功能：按压、轻点。</li><li>支持两种触发模式映射鼠标右键功能：点按左/右下角、双指点按或轻点。</li><li>跟踪速度：支持 10 档速度调节。</li><li>支持两种交互模式映射鼠标滚轮功能：内容随手指移动方向、内容随手指反向移动。</li></ul></li></ul><h3>主题框架</h3><ul><li><p style="margin-left:0; margin-right:0">锁屏管理服务：支持锁屏事件回调机制、支持静态/动态壁纸、支持查询锁屏时的业务状态。</p></li><li><p style="margin-left:0; margin-right:0">壁纸管理服务：支持自定义壁纸、支持锁屏/解锁操作、支持重置壁纸。</p></li></ul><h3>上传下载</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">新增接口，使用统一配置参数与接口完成上传下载业务任务创建执行，完善业务流程。</p><ul><li><p style="margin-left:0; margin-right:0">支持任务信息持久化记录，查询方式灵活多样，任务信息更加全面，支持按过滤条件查询任务信息。</p></li><li><p style="margin-left:0; margin-right:0">增强安全隐私保护，增加系统管理接口权限。</p></li><li><p style="margin-left:0; margin-right:0">支持文件覆盖下载、分片上传下载、自定义 token 任务创建。</p></li><li><p style="margin-left:0; margin-right:0">支持服务按需启停，应用调用相关接口时启动，任务空闲时自动退出。</p></li></ul><h3>时间时区</h3><ul><li><p style="margin-left:0; margin-right:0">获取系统时间、系统启动时间提供同步接口。获取到的时间更精准，且提供较好的开发者体验。</p></li><li><p style="margin-left:0; margin-right:0">获取日期接口废弃，由 ArkTS 公共库 new Date() 接口替代。</p></li></ul><h3>输入法</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">新增同步接口，用于获取编辑框信息。</p><h3>网络管理</h3><ul><li><p style="margin-left:0; margin-right:0">提供 IPv6 基础能力，包括 DNS 解析、应用通过 http/https/socket 联网，蜂窝/Wi-Fi/有线网络下均可支持 IPv4/IPv6 双栈接入。</p></li><li><p style="margin-left:0; margin-right:0">新增同步接口，针对@ohos.net.connection 模块的高频接口，在原有异步接口基础上新增了对应的同步接口。</p></li></ul><h3>打印</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">提供打印服务功能，应用可以通过 print 接口触发打印业务。打印服务提供了系统默认的打印预览界面和任务管理界面，可以管理网络打印机设备连接。</p><h3>安全</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>加解密算法库框架</strong></p><ul><li><p style="margin-left:0; margin-right:0">提供 DSA 数字签名算法能力。</p></li><li><p style="margin-left:0; margin-right:0">提供 DSA、ECC、RSA 密钥解析和密钥参数的获取能力。</p></li><li><p style="margin-left:0; margin-right:0">提供安全随机数生成算法类型的获取能力。</p></li><li><p style="margin-left:0; margin-right:0">提供 SM4 密钥的随机生成与转换，以及加密解密能力。</p></li><li><p style="margin-left:0; margin-right:0">提供 SM3 密钥的 HMAC 和 HASH 的能力。</p></li><li><p style="margin-left:0; margin-right:0">提供 SM2 密钥的随机生成与转换、签名及验签、以及加密解密能力。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>密钥管理</strong></p><ul><li><p style="margin-left:0; margin-right:0">基于 GID 派生芯片级密钥的能力。</p></li><li><p style="margin-left:0; margin-right:0">支持国密密钥的安全导入。</p></li><li><p style="margin-left:0; margin-right:0">支持二次身份认证的细粒度访问控制。</p></li><li><p style="margin-left:0; margin-right:0">密钥管理签名支持签名 NO HASH 模式。</p></li><li><p style="margin-left:0; margin-right:0">密钥管理算法支持运算时指定密钥参数。</p></li><li><p style="margin-left:0; margin-right:0">支持 HUKS 密钥加密保护。</p></li><li><p style="margin-left:0; margin-right:0">支持 KeyAttestation 公钥证书中增加对密钥所属业务身份字段。</p></li><li><p style="margin-left:0; margin-right:0">支持标准 HDI 南向接口。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>设备互信认证</strong></p><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">支持在以下两种场景的设备间互信认证流程中生成假名，支持识别及标识设备的假名化名称。</p><ul><li><p style="margin-left:0; margin-right:0">对同帐号登录的多个设备进行互信认证。</p></li><li><p style="margin-left:0; margin-right:0">对非同帐号的点对点互联的两个设备进行互信认证。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>安全基础能力</strong></p><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">支持小型设备查询其它设备的设备安全等级信息。</p><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>证书管理</strong></p><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">支持外部指定 RSA 密钥签名摘要及填充签名和验签能力。</p><h3>程序访问控制</h3><ul><li><p style="margin-left:0; margin-right:0">支持拉起应用粒度的权限管理界面。</p></li><li><p style="margin-left:0; margin-right:0">支持对系统应用的所属身份进行校验。</p></li><li><p style="margin-left:0; margin-right:0">优化权限管理的菜单呈现，拆分媒体和文件的权限组，相应权限的授权粒度更加精细化。</p></li></ul><h3>帐号</h3><ul><li><p style="margin-left:0; margin-right:0">支持帐号授权能力扩展和三方应用使用帐号授权能力。</p></li><li><p style="margin-left:0; margin-right:0">支持域帐号插件管理、域帐号管理、域帐号认证能力。</p></li></ul><h3>用户 IAM</h3><ul><li><p style="margin-left:0; margin-right:0">提供统一身份认证控件，完善用户身份认证能力，方便系统开发者调用身份认证能力并且生态体验统一。</p></li><li><p style="margin-left:0; margin-right:0">统一身份认证控件提供了系统默认的用户身份认证界面，选择使用带控件的接口 getUserAuthInstance, AuthParam 指定认证参数，WidgetParam 指定控件显示参数。为确保用户在系统上有统一的身份认证体验，建议开发者使用 API version 10 提供的新用户身份认证接口。</p></li></ul><h3>WebView</h3><ul><li><p style="margin-left:0; margin-right:0">W3C 能力补充完善：补充 Web camere 能力，以及 bindContextMenu、Select、date 类型 input 等 H5 标签能力。</p></li><li><p style="margin-left:0; margin-right:0">支持多渲染进程的进程拆分。</p></li><li><p style="margin-left:0; margin-right:0">支持文字、图片基础拖拽能力。</p></li><li><p style="margin-left:0; margin-right:0">支持 WebRTC 的视频会议能力（不含摄像头共享）。</p></li><li><p style="margin-left:0; margin-right:0">支持渲染进程独立 SELinux 标签，增强安全基础能力。</p></li><li><p style="margin-left:0; margin-right:0">支持识别 Web 组件渲染进程、显示线程和场景信息，并通知系统资源调度进行 CPU 管控。</p></li></ul><h3>内核</h3><ul><li><p style="margin-left:0; margin-right:0">支持 HCK 内核接口框架。</p></li><li><p style="margin-left:0; margin-right:0">支持 Linux 内核 config 多级分层配置。</p></li><li><p style="margin-left:0; margin-right:0">代码执行权限管控能力增强，新增了以下能力：</p><ul><li>支持安全内存机制。</li><li>支持不同场景的代码执行权限管控策略。</li><li>支持代码执行权限管控的全生命周期管理能力。</li><li>支持解析可执行文件获取代码段信息。</li><li>支持代码页的完整性保护能力。</li></ul></li></ul><h3>驱动</h3><ul><li><p style="margin-left:0; margin-right:0">扩展设备驱动框架提供以下能力：</p><ul><li>扩展设备驱动框架基于「驱动扩展 Ability（DriverExtensionAbility）」的能力，构建应用态扩展驱动包的开发、部署、安装、更新、卸载、运行能力，开放全流程生命周期管理能力。</li><li>支持三方设备厂商开发的非标准协议的可插拔 USB 设备扩展驱动包，正常安装到 OpenHarmony 系统。插入 USB 设备后，能正常识别 USB 设备并与扩展驱动包匹配。</li><li>支持三方应用通过扩展外部设备管理框架查询并绑定 USB 设备扩展驱动包，完成对扩展驱动包定制功能的操作。</li></ul></li><li><p style="margin-left:0; margin-right:0">相机驱动提供以下能力：</p><ul><li>提供 USB 相机热插拔识别能力，支持开机启动检查识别和启动后热插拔识别。</li><li>支持 USB 相机的预览、拍照、录像能力，提供相机格式、分辨率查询和配置能力。</li></ul></li><li><p style="margin-left:0; margin-right:0">编解码驱动提供 JPEG 图片硬件解码加速能力，包括获取硬件解码信息，初始化/去初始化，解码，申请/释放 buffer，提升用户浏览图片流畅度体验。</p></li><li><p style="margin-left:0; margin-right:0">传感器驱动提供温湿度传感器设备驱动能力，支持小型设备温湿度器件查询，器件使能/去使能，数据查询能力，丰富智能设备传感器能力。</p></li></ul><h3>泛 Sensor</h3><ul><li><p style="margin-left:0; margin-right:0">支持对设备所支持的预置振动效果进行查询，可通过 EffectId 查询某个振动效果在设备上是否被支持。</p></li><li><p style="margin-left:0; margin-right:0">新增振动全停接口，无需传入对应的振动模式，可直接停止当前任意模式所设置的振动。</p></li><li><p style="margin-left:0; margin-right:0">新增播放振动配置文件接口，支持从文件播放自定义触觉的控制模式，播放执行结果依赖设备的振感器件能力。</p></li></ul><h3>测试</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>测试框架 arkxtest</strong></p><ul><li><p style="margin-left:0; margin-right:0">支持自动化脚本测试套嵌套定义能力，提升开发者脚本设计灵活性。</p></li><li><p style="margin-left:0; margin-right:0">支持对象级断言能力，提升测试脚本断言能力。</p></li><li><p style="margin-left:0; margin-right:0">支持模拟中文输入、模拟鼠标操作、区域截图的能力。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>自测试执行框架 developer_test</strong></p><ul><li><p style="margin-left:0; margin-right:0">支持测试任务管理能力，开发者通过任务 ID 执行历史任务，提升开发者自测试效率。</p></li><li><p style="margin-left:0; margin-right:0">支持精准测试能力，支持子系统、部件、测试套、测试用例级测试用例筛选执行能力，提升开发者自测试效率。</p></li><li><p style="margin-left:0; margin-right:0">支持对接执行 hats 用例，丰富执行用例范围。</p></li><li><p style="margin-left:0; margin-right:0">支持稳定性测试能力，支持测试用例乱序执行。</p></li><li><p style="margin-left:0; margin-right:0">支持覆盖率统计能力，支持开发者本地一键式生成代码覆盖率数据。</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>稳定性测试工具 wukong</strong></p><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">支持旋转事件注入，增强注入能力。</p><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>性能调试开发工具 SmartPerf Host</strong></p><ul><li><p style="margin-left:0; margin-right:0">支持 Frame timeline 抓取和展示能力，开发者可以抓取和展示卡顿丢帧检测的数据。</p></li><li><p style="margin-left:0; margin-right:0">支持 Scheduling analysis 抓取和展示能力，开发者可以抓取和展示 CPU 调度分析，线程调度分析相关数据。</p></li><li><p style="margin-left:0; margin-right:0">支持调用栈可视化和不同库函数调用占比展示能力，开发者可以抓取并通过饼图的方式展示调用栈及不同库函数的占比</p></li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>性能数据采集 SmartPerf Device</strong></p><ul><li><p style="margin-left:0; margin-right:0">支持应用冷热启、页面内切换、滑动帧率测试能力，开发者可以测试应用冷热启动时延、页面切换时延、滑动帧率测试能力。</p></li><li><p style="margin-left:0; margin-right:0">支持端侧测试数据对接云端看板能力，开发者可以将端侧测试报告上传云端查看或下载云端数据到本地。</p></li></ul><h2>配套关系</h2><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"><strong>表 1</strong><span>&nbsp;</span>版本软件和工具配套关系</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#40485b; display:block; font-family:-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,Helvetica,Arial,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;,&quot;Liberation Sans&quot;,&quot;PingFang SC&quot;,&quot;Microsoft YaHei&quot;,&quot;Hiragino Sans GB&quot;,&quot;Wenquanyi Micro Hei&quot;,&quot;WenQuanYi Zen Hei&quot;,&quot;ST Heiti&quot;,SimHei,SimSun,&quot;WenQuanYi Zen Hei Sharp&quot;,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:left; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:942px; word-break:initial; word-spacing:0px"><tbody><tr><th>软件</th><th>版本</th><th>备注</th></tr></tbody><tbody><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">OpenHarmony</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">4.0 Release</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">NA</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">Public SDK</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">Ohos_sdk_public 4.0.10.13 (API Version 10 Release)</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">面向应用开发者提供，不包含需要使用系统权限的系统接口。通过 DevEco Studio 默认获取的 SDK 为 Public SDK。</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">HUAWEI DevEco Studio（可选）</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">4.0 Release</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">OpenHarmony 应用开发推荐使用。获取方式：<br><a href="https://gitee.com/link?target=https%3A%2F%2Fcontentcenter-vali-drcn.dbankcdn.cn%2Fpvt_2%2FDeveloperAlliance_package_901_9%2F9a%2Fv3%2FHBD3TfhiT_GFqeX44Qcwtg%2Fdevecostudio-windows-4.0.0.600.zip%3FHW-CC-KV%3DV1%26HW-CC-Date%3D20231027T004333Z%26HW-CC-Expire%3D315360000%26HW-CC-Sign%3D279824A013505EFC063997614DC1B6AB1C3A2EE5AC48CEF15DDB3E1F79DA435A">Windows(64-bit)</a><br> SHA256 校验码：2c88cf43e1ef6ba722aac31eccc8ef92f07a9b72e43a9c1df127017828a22137<br><a href="https://gitee.com/link?target=https%3A%2F%2Fcontentcenter-vali-drcn.dbankcdn.cn%2Fpvt_2%2FDeveloperAlliance_package_901_9%2Fe0%2Fv3%2Fy3Qc4UHsTn6i1M7yr3hVYg%2Fdevecostudio-mac-4.0.0.600.zip%3FHW-CC-KV%3DV1%26HW-CC-Date%3D20231027T004531Z%26HW-CC-Expire%3D315360000%26HW-CC-Sign%3D07F14E7173D87ABF73777BA0CF7ADF1C1264A7D94909976471AC420C1932E8A6">Mac(X86)</a><br> SHA256 校验码：25e491458eec50b4abddf5bed6aa85893801d70afbce02958f17bd904619405a<br><a href="https://gitee.com/link?target=https%3A%2F%2Fcontentcenter-vali-drcn.dbankcdn.cn%2Fpvt_2%2FDeveloperAlliance_package_901_9%2F94%2Fv3%2Fb0yynFMFSGGvbe--AQQR9w%2Fdevecostudio-mac-arm-4.0.0.600.zip%3FHW-CC-KV%3DV1%26HW-CC-Date%3D20231027T004429Z%26HW-CC-Expire%3D315360000%26HW-CC-Sign%3D451E5B5C6B6E721A6C35E96FD67791D50ADEC56E987D87CD61E9E5152F8D6626">Mac(ARM)</a><br> SHA256 校验码：284cb01f7b819e0da1d4fcacbbbbe8017ba220b5e3b9b1d5e4cc59ea30456acc</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">HUAWEI DevEco Device Tool（可选）</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">4.0 Release</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">OpenHarmony 智能设备集成开发环境推荐使用。<br><a href="https://gitee.com/link?target=https%3A%2F%2Fdevice.harmonyos.com%2Fcn%2Fdevelop%2Fide%23download">请点击这里获取</a>。</td></tr></tbody></table></div>
                                    ]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 03:22:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264989/openharmony-4-0-released</guid>
            <link>https://www.oschina.net/news/264989/openharmony-4-0-released</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[WinterJS —— Rust 编写的 Service Worker]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>WinterJS 是用 Rust 编写的 JavaScript Service Worker。</p><p>WinterJS 使用 SpiderMonkey 运行时执行 JavaScript（与 Firefox 使用的运行时相同），并遵循 WinterCG 规范，目的是最大限度地兼容 Cloudflare Workers、Deno Deploy 和 Vercel 等其他服务（因此命名为 WinterJS）。</p><p>WinterJS 除了速度极快，还能通过 WASIX&nbsp;<strong>编译成 WebAssembly</strong>，因此完全支持在 Wasmer 上运行。</p></div>
                                                                ]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/winterjs</guid>
            <link>https://www.oschina.net/p/winterjs</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 基于连接的可扩展消息传输协议 SocketD]]>
            </title>
            <description>
                <![CDATA[<h1 align="center"><a id="user-content---socketd" class="anchor" href="https://gitee.com/noear/socketd#--socketd"></a>
  SocketD
</h1><p align="center"><strong>基于连接的可扩展消息传输协议</strong></p><p align="center"><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fsearch.maven.org%2Fartifact%2Forg.noear%2Fsocketd"><img src="https://img.shields.io/maven-central/v/org.noear/socketd.svg?label=Maven%20Central" alt="Maven" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.apache.org%2Flicenses%2FLICENSE-2.0.txt"><img src="https://img.shields.io/:license-Apache2-blue.svg" alt="Apache 2" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjavase-jdk8-downloads.html"><img src="https://img.shields.io/badge/JDK-8-green.svg" alt="jdk-8" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk11-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-11-green.svg" alt="jdk-11" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk17-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-17-green.svg" alt="jdk-17" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk21-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-21-green.svg" alt="jdk-21" referrerpolicy="no-referrer"></a><br><a target="_blank" href="https://gitee.com/noear/socketd/stargazers"><img src="https://gitee.com/noear/socketd/badge/star.svg" alt="gitee star" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fnoear%2Fsocketd%2Fstargazers"><img src="https://img.shields.io/github/stars/noear/socketd.svg?logo=github" alt="github star" referrerpolicy="no-referrer"></a></p><br><p align="center"><a href="https://gitee.com/link?target=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3DkjB5JNiC"><img src="https://img.shields.io/badge/QQ%E4%BA%A4%E6%B5%81%E7%BE%A4-870505482-orange" referrerpolicy="no-referrer"></a></p><hr><p>SocketD 是一个基于连接的、可扩展的、消息驱动的传输协议。具有异步，背压流控，双向通讯，多路复用，断线重连，支持签权，基于主题消息等特性。</p><ul><li>具有语言无关性的二进制通信协议（支持 tcp, ws, udp）</li><li>异步非阻塞消息驱动通信</li><li>可以进行流量控制、自动连接恢复</li><li>支持双向通信（如：单链接双向 RPC 接口调用）</li><li>更加适合分布式通信场景</li><li>支持 ssl，支持国密 ssl</li><li>消息有由元信息和数据组成，通过元信息实现可扩展性</li><li>自动分片（数据超出 16Mb，会自动分片、自动重组）</li><li>接口简单</li></ul><h3><a id="user-content-快速入门与学习" class="anchor" href="https://gitee.com/noear/socketd#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0"></a>快速入门与学习</h3><p>目前已完成 java 部分，学习可见：<a href="https://gitee.com/noear/socketd/blob/main/_docs">《快速入门》</a></p><h3><a id="user-content-适用场景" class="anchor" href="https://gitee.com/noear/socketd#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"></a>适用场景</h3><p>可用于 MSG、RPC、IM、MQ，等一些的场景开发，可替代 http, websocket, grpc 等一些协议。比如移动设备与服务器的连接，比如一些微服务场景等等。</p><h3><a id="user-content-简单的协议格式" class="anchor" href="https://gitee.com/noear/socketd#%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F"></a>简单的协议格式</h3><ul><li>codec</li></ul><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">[len:int][flag:int][sid:str(&lt;64)][\n][topic:str(&lt;512)][\n][metaString:str(&lt;4k)][\n][data:bts(&lt;16m)]</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><ul><li>flag</li></ul><table><thead><tr><th>Flag</th><th>Server</th><th>Client</th><th>备注</th></tr></thead><tbody><tr><td>Unknown</td><td>::close()</td><td>::close()</td><td></td></tr><tr><td>Connect</td><td>/</td><td>c(Connect)-&gt;s</td><td></td></tr><tr><td>Connack</td><td>s(Connack),s::c.onOpen()-&gt;c</td><td>s(Connack)-&gt;c::onOpen()</td><td></td></tr><tr><td>Ping</td><td>/</td><td>c(Ping)-&gt;s</td><td></td></tr><tr><td>Pong</td><td>s(Pong)-&gt;c</td><td>/</td><td></td></tr><tr><td>Close</td><td>s(Close)-&gt;c</td><td>c(Close)-&gt;s</td><td>用于特殊场景（如：T 人）</td></tr><tr><td>Message</td><td>s(Message)-&gt;c</td><td>c(Message)-&gt;s</td><td></td></tr><tr><td>Request</td><td>s(Request)-&gt;c(Reply)-&gt;s</td><td>c(Request)-&gt;s(Reply)-&gt;c</td><td></td></tr><tr><td>Subscribe</td><td>s(Subscribe)-&gt;c(Reply?..)-&gt;s</td><td>c(Subscribe)-&gt;s(Reply?..)-&gt;c</td><td></td></tr><tr><td>Reply</td><td>s(Reply)-&gt;c</td><td>c(Reply)-&gt;s</td><td></td></tr><tr><td>ReplyEnd</td><td>s(ReplyEnd)-&gt;c</td><td>c(ReplyEnd)-&gt;s</td><td>结束答复</td></tr></tbody></table>]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 02:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/noear/socketd</guid>
            <link>https://gitee.com/noear/socketd</link>
        </item>
        <item>
            <title>
                <![CDATA[Protocol Buffers 25.0 发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#333333">Protocol Buffers 25.0 已经发布。Protocol Buffers（protobuf）是&nbsp;Google 开源的语言无关、平台无关的可扩展机制，用于序列化结构化数据。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="background-color:#ffffff; color:#333333">具体更新内容包括：</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Announcements</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><ul style="list-style-type:disc; margin-left:0; margin-right:0"><li><p style="margin-left:0; margin-right:0"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fprotobuf.dev%2Fnews%2F" target="_blank">Protobuf News</a>&nbsp;可能包括针对即将发生的更改的附加公告或预先公告。</p></li></ul><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>Compiler</strong></p><ul><li>实现 proto2/proto3 的版本 (&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F3813b6622f6490b969c16e1b1ba7dcbd8f4e3209" target="_blank">3813b66</a>&nbsp;)</li><li>将 Protobuf 编译器版本字符串定义为宏，并分离出后缀字符串定义。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F3c59585bc116bee70f5f00a10005ea1403aef062" target="_blank">3c59585</a>）</li><li>将 utf8_validation 功能添加回全局功能集中。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F153028d7f3029e066bb2287012e14417ca83d55c" target="_blank">153028d</a>）</li><li>设置版本更新程序以准备 poison pills 并将版本信息嵌入到 C++、Python 和 Java gencode 中。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F4322e00e5b4c2f36016f0eee614e0e823a693ed4" target="_blank">4322e00</a>）</li><li>合并 protobuf 和 upb Bazel 存储库 (&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F7286ffceb2f0a4489672a90c823e00425ab8ab5c" target="_blank">7286ffc</a>&nbsp;)</li><li>Editions：向 protoc 引入用于生成版本功能集默认值的功能。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F4019e254322b2312cc7431b45ae71bb8e3dfa035" target="_blank">4019e25</a>）</li><li>为 ExtensionIdentifier 创建 reflection helper。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F4d5ab7324ef4d79eda69c8ed5bcb35f35e6db6f1" target="_blank">4d5ab73</a>）</li><li>Editions：为 C++ 生成器提供指定其特性的 API。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2Fe897bcf3ff8004b7446bbe43a1fc28f9a92a11d4" target="_blank">e897bcf</a>）</li><li>发布带有声明验证的扩展声明。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2Fe72b0e181b236ff23c03a9f9f97f58e6989f25c9" target="_blank">e72b0e1</a>）</li><li>Editions：将 string_field_validation 移植到 C++ 特性&nbsp;(&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F1f9583069f0e2b11790ea36cc760ee371106f232" target="_blank">1f95830</a>&nbsp;)</li><li>Protoc：解析器拒绝显式使用 map_entry 选项 (&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fpull%2F13479" target="_blank">#13479</a>&nbsp;) (&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F8f5929230d5c5d117b84953463ef0da6d29ad36d" target="_blank">8f59292</a>&nbsp;)</li><li>放弃对 Bazel 5 的支持。(&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2Fa80daa2a2caaaac9ebe9ae6bb1b639c2771c5c55" target="_blank">a80daa2</a>&nbsp;)</li><li>允许代码生成器指定它们是否支持版本。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F2176a145ba210c286177032037e736bf97158f7d" target="_blank">2176a14</a>）</li></ul><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>C++</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><ul><li>在<code>InternalOutOfLineDeleteMessageLite()</code>上设置<code>PROTOBUF_EXPORT</code>(&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fpull%2F14434" target="_blank">#14434</a>&nbsp;) (&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2Fdb89a51e4557c40abc8845b13277a83cdf917382" target="_blank">db89a51</a>&nbsp;)</li><li>更新过时的&nbsp;checked-in&nbsp;文件 (&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fpull%2F14431" target="_blank">#14431</a>&nbsp;) (&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2Fada0be86608dc10b3c2c46e7e2a0951015abbcc3" target="_blank">ada0be8</a>&nbsp;)</li><li>将 PROTOBUF_NOINLINE 应用于某些需要它的函数的声明。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F6e848b00c95556d4f4fc7a1a512cd31a33de75d6" target="_blank">6e848b0</a>）</li><li>使 JSON UTF-8 边界检查包含最大可能的 UTF-8 字符。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2Fe80b8ec620d71cdeca000dce835e5a167a8dc370" target="_blank">e80b8ec</a>）</li><li>减少<code>Map::size_type</code>到 32 位。Protobuf 容器不能超过 (&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F95d2b2ed5039c1b1606a5f8c9d9cb362a2a33c95" target="_blank">95d2b2e</a>&nbsp;)</li><li>将 Protobuf 编译器版本字符串定义为宏，并分离出后缀字符串定义。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F3c59585bc116bee70f5f00a10005ea1403aef062" target="_blank">3c59585</a>）</li><li>在生成的 oneof 访问器上添加<code>ABSL_ATTRIBUTE_LIFETIME_BOUND</code>属性。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2Fe33e0d2ba569c8a7d6d74b5a8b39d804ec2a0169" target="_blank">e33e0d2</a>）</li><li>将 utf8_validation 功能添加回全局功能集中。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F153028d7f3029e066bb2287012e14417ca83d55c" target="_blank">153028d</a>）</li><li>设置版本更新程序以准备 poison pills 并将版本信息嵌入到 C++、Python 和 Java gencode 中。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F4322e00e5b4c2f36016f0eee614e0e823a693ed4" target="_blank">4322e00</a>）</li><li>将 prefetching 添加到 arena allocations 中。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2Ffbdeb5af0b0f89dec79efc371ba75f838ffad2e8" target="_blank">fbdeb5a</a>）</li><li>合并 protobuf 和 upb Bazel 存储库 (&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F7286ffceb2f0a4489672a90c823e00425ab8ab5c" target="_blank">7286ffc</a>&nbsp;)</li><li>在生成的重复和 map&nbsp;字段访问器上添加<code>ABSL_ATTRIBUTE_LIFETIME_BOUND</code>属性。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F9a0a3cf0cd8b4ac5c8a06db89f76c5d754f850d0" target="_blank">9a0a3cf</a>）</li><li>gcc 7.5 上的 ICE 解决方法是不让一个重载使用调用另一个重载。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F0522054f3ee5e32c9df15af7c11f046e91e77998" target="_blank">0522054</a>）</li><li>为 ExtensionIdentifier 创建 reflection helper。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F4d5ab7324ef4d79eda69c8ed5bcb35f35e6db6f1" target="_blank">4d5ab73</a>）</li><li>修复了 32 位 MSVC。(&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F66cf6b1d9c22333a20d83ee02472e2e7162a8da6" target="_blank">66cf6b1</a>&nbsp;)</li><li>删除&nbsp;protoc&nbsp;中禁用表驱动解析器的选项。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F6d03f9b19bd7aa10d541f6c1a11ac71f2851eece" target="_blank">6d03f9b</a>）</li><li>......</li></ul><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Java</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><ul><li>实现 proto2/proto3 的版本 (&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F3813b6622f6490b969c16e1b1ba7dcbd8f4e3209" target="_blank">3813b66</a>&nbsp;)</li><li>从 Java gencode 字段访问器表中删除合成 oneof。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F9ad2268544a345d9ed449e766999388b895d18a3" target="_blank">9ad2268</a>）</li><li>Timestamps.parse：添加对时区偏移中无效小时/分钟的错误处理。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F8f8513835c0c4ebe206a5ead04a1bd0c8c7d1dbf" target="_blank">8f85138</a>）</li><li>将 Protobuf 编译器版本字符串定义为宏，并分离出后缀字符串定义。（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Fcommit%2F3c59585bc116bee70f5f00a10005ea1403aef062" target="_blank">3c59585</a>）</li><li>在生成的 oneof 访问器上添加<code>ABSL_ATTRIBUTE_LIFETIME_BOUND</code>属性。<span style="background-color:#ffffff; color:#1f2328"><span>&nbsp;</span>(ht...</span></li></ul><p>更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf%2Freleases" target="_blank">查看更新说明</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 02:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264978/protobuf-25-0-released</guid>
            <link>https://www.oschina.net/news/264978/protobuf-25-0-released</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Hyprland —— 动态平铺式 Wayland 合成器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Hyprland 是一款基于 wlroots 的动态平铺式 Wayland 合成器。</p><p>它提供最新的 Wayland 功能，可高度自定义，拥有所有美观的外观、最强大的插件、简易的 IPC，以及比其他基于 wlr 的合成器更多的 QoL 功能等等...</p><p><strong>特性：</strong></p><ul><li>所有令人赏心悦目的内容：渐变边框、模糊、动画、阴影等等</li><li>大量定制</li><li>比其他基于 wlr 的合成器提供更多的生活质量内容</li><li>自定义贝塞尔曲线以获得最佳动画</li><li>强大的插件支持</li><li>撕裂支持以获得更好的游戏性能</li><li>易于扩展和可读的代码库</li><li>快速、积极的开发</li><li>不害怕提供尖端功能</li><li>保存后立即重新加载配置</li><li>完全动态的工作空间</li><li>两个内置布局以及更多可用作插件的布局</li><li>紧随<code>wlroots-git</code></li><li>全局按键绑定传递给你选择的应用程序</li><li>平铺/伪平铺/浮动/全屏窗口</li><li>特殊工作区（便签本）</li><li>窗口组（选项卡模式）</li><li>强大的窗口/监视器/图层规则</li><li>基于套接字的 IPC</li><li>原生 IME 和输入面板支持</li></ul><p>&nbsp;<img height="282" src="https://static.oschina.net/uploads/space/2023/1030/172906_LCd1_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img height="281" src="https://static.oschina.net/uploads/space/2023/1030/172925_yXI2_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img height="313" src="https://static.oschina.net/uploads/space/2023/1030/172946_yrzI_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Sat, 04 Nov 2023 02:53:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/hyprland</guid>
            <link>https://www.oschina.net/p/hyprland</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 将 Web 动画渲染为视频的框架 WebVideoCreator]]>
            </title>
            <description>
                <![CDATA[<p><a href="https://gitee.com/vblog/web-video-creator/blob/master/README.md">简体中文</a> | <a href="https://gitee.com/vblog/web-video-creator/blob/master/README.en-US.md">English</a></p><p align="center"><img width="650px" src="https://gitee.com/vblog/web-video-creator/raw/master/assets/web-video-creator.png" referrerpolicy="no-referrer"></p><h1><a id="user-content-简介" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E7%AE%80%E4%BB%8B"></a>简介</h1><p>WebVideoCreator（简称 WVC）是一个将 Web 动画渲染为视频的框架，基于 Node.js + Puppeteer + Chrome + FFmpeg 实现，它执行确定性的渲染，准确的以目标帧率捕获任何可在 HTML5 播放动画（CSS3 动画/SVG 动画/Lottie 动画/GIF 动画/APNG 动画/WEBP 动画）以及任何基于时间轴使用<a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FrequestAnimationFrame">RAF</a>驱动的动画（<a href="https://gitee.com/link?target=https%3A%2F%2Fanimejs.com%2F">anime.js</a>是一个不错的选择 :D），当然您也可以调皮的使用 setInterval 或者 setTimeout 来控制动画，支持嵌入 mp4 和透明 webm 视频，还支持转场合成、音频合成与字体加载等功能。让我们<a href="https://gitee.com/vblog/web-video-creator#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">快速开始</a>。</p><p>WVC 为您酷炫的动画页面创造了一个虚拟时间环境（也许可以想象成是一个《楚门的世界》），它的主要职责是将一个 <a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/renderer-env.md#%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E6%B8%B2%E6%9F%93%E7%8E%AF%E5%A2%83">不确定性渲染的环境</a> 转化到 <a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/renderer-env.md#%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E6%B8%B2%E6%9F%93%E7%8E%AF%E5%A2%83">确定性渲染的环境</a>。</p><p>这一切的前提由 Chrome 提供的<a href="https://gitee.com/link?target=https%3A%2F%2Fgoo.gle%2Fchrome-headless-rendering">确定性渲染模式</a>和无头实验 API 支持：<a href="https://gitee.com/link?target=https%3A%2F%2Fchromedevtools.github.io%2Fdevtools-protocol%2Ftot%2FHeadlessExperimental%2F%23method-beginFrame">HeadlessExperimental.beginFrame</a></p><p>答疑交流 QQ 群：752693580</p><br><h1><a id="user-content-特性" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E7%89%B9%E6%80%A7"></a>特性</h1><ul><li>基于 Node.js 开发，使用非常简单，易于扩展和开发。</li><li>视频处理速度非常快，最快 5 分钟视频可在 1 分钟内完成渲染。</li><li>支持单幕和多幕视频渲染合成，多幕视频可应用<a href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5%E8%BD%AC%E5%9C%BA%E6%95%88%E6%9E%9C">转场效果</a>。</li><li>支持分块视频合成，可以将分块分发到多个设备上渲染回传再合成为多幕视频，大幅降低长视频渲染耗时。</li><li>支持并行多个视频渲染合成任务，充分利用系统资源。</li><li>API 支持进行<a href="https://gitee.com/vblog/web-video-creator#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88">分布式渲染</a>封装，只需对 WVC 进行一些封装即可将大量视频分块分发到多个设备渲染并最终取回合并输出</li><li>支持使用 GPU 加速渲染和合成，可以显著的降低视频渲染耗时。</li><li>支持在 Windows 和 Linux 平台部署运行。</li></ul><br><h1><a id="user-content-视频 demo" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E8%A7%86%E9%A2%91demo"></a>视频 DEMO</h1><p>我们还缺少动画设计师，不过还是从开放的平台中使用 WVC 捕获渲染了一些优秀的动画 Demo。</p><p>在这里查看所有 DEMO：<strong><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FVinlic%2FWebVideoCreator%2Fwiki%2FRendering-Example">渲染示例页面</a></strong></p><img src="https://gitee.com/vblog/web-video-creator/raw/master/assets/demo.gif" referrerpolicy="no-referrer"><br><h1><a id="user-content-支持的动画库" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%94%AF%E6%8C%81%E7%9A%84%E5%8A%A8%E7%94%BB%E5%BA%93"></a>支持的动画库</h1><p>理论上所有的 Web 动画/图形库都能够在 WVC 环境正常运行，以下仅列出我已验证可用的库：</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Fanimejs.com%2F">Anime.js</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fgreensock.com%2F">GSAP</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fd3js.org%2F">D3.js</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fthreejs.org%2F">Three.js</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fecharts.apache.org%2F">Echart</a> / <a href="https://gitee.com/link?target=http%3A%2F%2Fairbnb.io%2Flottie%2F%23%2Fweb">Lottie-Web</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fpixijs.download%2Frelease%2Fdocs%2Findex.html">PixiJS</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fanimate.style%2F">Animate.css</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fmojs.github.io%2F">Mo.js</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Ftweenjs.github.io%2Ftween.js%2F">Tween.js</a></p><p>需要注意的是，如果您手动使用<a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FrequestAnimationFrame">RAF</a>驱动动画，请确保从回调中接收 timestamp 参数设置动画的进度到该时间点，否则可能出现帧率不同步。</p><br><h1><a id="user-content-快速开始" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"></a>快速开始</h1><h2><a id="user-content-安装" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%AE%89%E8%A3%85"></a>安装</h2><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c"># 从 NPM 安装 WebVideoCreator</span></span><span id="LC2" class="line">npm i web-video-creator</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如遇到 ffmpeg-static 下载失败，请先设置环境变量：<code>FFMPEG_BINARIES_URL=https://cdn.npmmirror.com/binaries/ffmpeg-static</code></p><h2><a id="user-content-创建本地服务器" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"></a>创建本地服务器</h2><p>WVC 需要从 Web 页面中捕获动画，您可以在本地创建一个临时的 Web 服务器来提供静态页面服务，方便接下来的测试，使用 live-server 是最简单的方式之一，如果您已经有静态页面可跳过这个步骤。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c"># 从 NPM 全局安装 live-server</span></span><span id="LC2" class="line">npm i <span class="nt">-g</span> live-server</span><span id="LC3" class="line"><span class="c"># 启用 Web 服务</span></span><span id="LC4" class="line">live-server</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>创建一个测试页面到 Web 服务根路径，以下 html 内容展示一个自动旋转的三角形 svg 动画。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="cp">&lt;!DOCTYPE html&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;html&gt;</span></span><span id="LC3" class="line"><span class="nt">&lt;head&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;meta</span><span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">/&gt;</span></span><span id="LC5" class="line"><span class="nt">&lt;title&gt;</span>测试页面<span class="nt">&lt;/title&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;/head&gt;</span></span><span id="LC7" class="line"><span class="nt">&lt;body&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;svg</span><span class="na">width=</span><span class="s">"120"</span><span class="na">height=</span><span class="s">"120"</span><span class="na">viewBox=</span><span class="s">"0 0 120 120"</span><span class="na">
                xmlns=</span><span class="s">"http://www.w3.org/2000/svg"</span><span class="na">version=</span><span class="s">"1.1"</span></span><span id="LC9" class="line"><span class="na">
                xmlns:xlink=</span><span class="s">"http://www.w3.org/1999/xlink"</span><span class="nt">&gt;</span></span><span id="LC10" class="line"><span class="nt">&lt;polygon</span><span class="na">points=</span><span class="s">"60,30 90,90 30,90"</span><span class="nt">&gt;</span></span><span id="LC11" class="line"><span class="nt">&lt;animateTransform</span><span class="na">attributeName=</span><span class="s">"transform"</span><span class="na">attributeType=</span><span class="s">"XML"</span><span class="na">type=</span><span class="s">"rotate"</span><span class="na">from=</span><span class="s">"0 60 70"</span><span class="na">to=</span><span class="s">"360 60 70"</span></span><span id="LC12" class="line"><span class="na">dur=</span><span class="s">"10s"</span><span class="na">repeatCount=</span><span class="s">"indefinite"</span><span class="nt">/&gt;</span></span><span id="LC13" class="line"><span class="nt">&lt;/polygon&gt;</span></span><span id="LC14" class="line"><span class="nt">&lt;/svg&gt;</span></span><span id="LC15" class="line"><span class="nt">&lt;/body&gt;</span></span><span id="LC16" class="line"><span class="nt">&lt;/html&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-渲染单幕视频" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%B8%B2%E6%9F%93%E5%8D%95%E5%B9%95%E8%A7%86%E9%A2%91"></a>渲染单幕视频</h2><img src="https://gitee.com/vblog/web-video-creator/raw/master/assets/single-video.gif" referrerpolicy="no-referrer"><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">import</span><span class="nx">WebVideoCreator</span><span class="p">,</span><span class="p">{</span><span class="nx">VIDEO_ENCODER</span><span class="p">,</span><span class="nx">logger</span><span class="p">}</span><span class="k">from</span><span class="dl">"</span><span class="s2">web-video-creator</span><span class="dl">"</span><span class="p">;</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="kd">const</span><span class="nx">wvc</span><span class="o">=</span><span class="k">new</span><span class="nx">WebVideoCreator</span><span class="p">();</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="c1">// 配置 WVC</span></span><span id="LC6" class="line"><span class="nx">wvc</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span></span><span id="LC7" class="line"><span class="c1">// 根据您的硬件设备选择适合的编码器，这里采用的是 Nvidia 显卡的 h264_nvenc 编码器</span></span><span id="LC8" class="line"><span class="c1">// 编码器选择可参考 docs/video-encoder.md</span></span><span id="LC9" class="line"><span class="na">mp4Encoder</span><span class="p">:</span><span class="nx">VIDEO_ENCODER</span><span class="p">.</span><span class="nx">NVIDIA</span><span class="p">.</span><span class="nx">H264</span></span><span id="LC10" class="line"><span class="p">});</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">// 创建单幕视频</span></span><span id="LC13" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC14" class="line"><span class="c1">// 需要渲染的页面地址</span></span><span id="LC15" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/test.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC16" class="line"><span class="c1">// 视频宽度</span></span><span id="LC17" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC18" class="line"><span class="c1">// 视频高度</span></span><span id="LC19" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC20" class="line"><span class="c1">// 视频帧率</span></span><span id="LC21" class="line"><span class="na">fps</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span></span><span id="LC22" class="line"><span class="c1">// 视频时长</span></span><span id="LC23" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC24" class="line"><span class="c1">// 视频输出路径</span></span><span id="LC25" class="line"><span class="na">outputPath</span><span class="p">:</span><span class="dl">"</span><span class="s2">./test.mp4</span><span class="dl">"</span><span class="p">,</span></span><span id="LC26" class="line"><span class="c1">// 是否在 cli 显示进度条，默认是不显示</span></span><span id="LC27" class="line"><span class="na">showProgress</span><span class="p">:</span><span class="kc">true</span></span><span id="LC28" class="line"><span class="p">});</span></span><span id="LC29" class="line"></span><span id="LC30" class="line"><span class="c1">// 监听合成完成事件</span></span><span id="LC31" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">once</span><span class="p">(</span><span class="dl">"</span><span class="s2">completed</span><span class="dl">"</span><span class="p">,</span><span class="nx">result</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC32" class="line"><span class="nx">logger</span><span class="p">.</span><span class="nx">success</span><span class="p">(</span><span class="s2">`Render Completed!!!\nvideo duration: </span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">duration</span><span class="o">/</span><span class="mi">1000</span><span class="p">)}</span><span class="s2">s\ntakes: </span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">takes</span><span class="o">/</span><span class="mi">1000</span><span class="p">)}</span><span class="s2">s\nRTF: </span><span class="p">${</span><span class="nx">result</span><span class="p">.</span><span class="nx">rtf</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span></span><span id="LC33" class="line"><span class="p">});</span></span><span id="LC34" class="line"></span><span id="LC35" class="line"><span class="c1">// 启动合成</span></span><span id="LC36" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-渲染多幕视频" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%B8%B2%E6%9F%93%E5%A4%9A%E5%B9%95%E8%A7%86%E9%A2%91"></a>渲染多幕视频</h2><img src="https://gitee.com/vblog/web-video-creator/raw/master/assets/multi-video.gif" referrerpolicy="no-referrer"><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">import</span><span class="nx">WebVideoCreator</span><span class="p">,</span><span class="p">{</span><span class="nx">VIDEO_ENCODER</span><span class="p">,</span><span class="nx">TRANSITION</span><span class="p">,</span><span class="nx">logger</span><span class="p">}</span><span class="k">from</span><span class="dl">"</span><span class="s2">web-video-creator</span><span class="dl">"</span><span class="p">;</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="kd">const</span><span class="nx">wvc</span><span class="o">=</span><span class="k">new</span><span class="nx">WebVideoCreator</span><span class="p">();</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="c1">// 配置 WVC</span></span><span id="LC6" class="line"><span class="nx">wvc</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span></span><span id="LC7" class="line"><span class="c1">// 根据您的硬件设备选择适合的编码器，这里采用的是 Nvidia 显卡的 h264_nvenc 编码器</span></span><span id="LC8" class="line"><span class="c1">// 编码器选择可参考 docs/video-encoder.md</span></span><span id="LC9" class="line"><span class="na">mp4Encoder</span><span class="p">:</span><span class="nx">VIDEO_ENCODER</span><span class="p">.</span><span class="nx">NVIDIA</span><span class="p">.</span><span class="nx">H264</span></span><span id="LC10" class="line"><span class="p">});</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">// 创建多幕视频</span></span><span id="LC13" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createMultiVideo</span><span class="p">({</span></span><span id="LC14" class="line"><span class="c1">// 视频宽度</span></span><span id="LC15" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC16" class="line"><span class="c1">// 视频高度</span></span><span id="LC17" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC18" class="line"><span class="c1">// 视频帧率</span></span><span id="LC19" class="line"><span class="na">fps</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span></span><span id="LC20" class="line"><span class="c1">// 视频段参数</span></span><span id="LC21" class="line"><span class="na">chunks</span><span class="p">:</span><span class="p">[</span></span><span id="LC22" class="line"><span class="p">{</span></span><span id="LC23" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/scene-1.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC24" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC25" class="line"><span class="c1">// 在第一和第二幕之间插入转场</span></span><span id="LC26" class="line"><span class="na">transition</span><span class="p">:</span><span class="nx">TRANSITION</span><span class="p">.</span><span class="nx">CIRCLE_CROP</span></span><span id="LC27" class="line"><span class="p">},</span></span><span id="LC28" class="line"><span class="p">{</span></span><span id="LC29" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/scene-2.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC30" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span></span><span id="LC31" class="line"><span class="p">}</span></span><span id="LC32" class="line"><span class="p">],</span></span><span id="LC33" class="line"><span class="c1">// 视频输出路径</span></span><span id="LC34" class="line"><span class="na">outputPath</span><span class="p">:</span><span class="dl">"</span><span class="s2">./test.mp4</span><span class="dl">"</span><span class="p">,</span></span><span id="LC35" class="line"><span class="c1">// 是否在 cli 显示进度条，默认是不显示</span></span><span id="LC36" class="line"><span class="na">showProgress</span><span class="p">:</span><span class="kc">true</span></span><span id="LC37" class="line"><span class="p">});</span></span><span id="LC38" class="line"></span><span id="LC39" class="line"><span class="c1">// 监听合成完成事件</span></span><span id="LC40" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">once</span><span class="p">(</span><span class="dl">"</span><span class="s2">completed</span><span class="dl">"</span><span class="p">,</span><span class="nx">result</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC41" class="line"><span class="nx">logger</span><span class="p">.</span><span class="nx">success</span><span class="p">(</span><span class="s2">`Render Completed!!!\nvideo duration: </span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">duration</span><span class="o">/</span><span class="mi">1000</span><span class="p">)}</span><span class="s2">s\ntakes: </span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">takes</span><span class="o">/</span><span class="mi">1000</span><span class="p">)}</span><span class="s2">s\nRTF: </span><span class="p">${</span><span class="nx">result</span><span class="p">.</span><span class="nx">rtf</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span></span><span id="LC42" class="line"><span class="p">});</span></span><span id="LC43" class="line"></span><span id="LC44" class="line"><span class="c1">// 启动合成</span></span><span id="LC45" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-渲染分块视频合并为多幕视频" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%B8%B2%E6%9F%93%E5%88%86%E5%9D%97%E8%A7%86%E9%A2%91%E5%90%88%E5%B9%B6%E4%B8%BA%E5%A4%9A%E5%B9%95%E8%A7%86%E9%A2%91"></a>渲染分块视频合并为多幕视频</h2><img src="https://gitee.com/vblog/web-video-creator/raw/master/assets/chunk-video.gif" referrerpolicy="no-referrer"><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">import</span><span class="nx">WebVideoCreator</span><span class="p">,</span><span class="p">{</span><span class="nx">VIDEO_ENCODER</span><span class="p">,</span><span class="nx">TRANSITION</span><span class="p">,</span><span class="nx">logger</span><span class="p">}</span><span class="k">from</span><span class="dl">"</span><span class="s2">web-video-creator</span><span class="dl">"</span><span class="p">;</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="kd">const</span><span class="nx">wvc</span><span class="o">=</span><span class="k">new</span><span class="nx">WebVideoCreator</span><span class="p">();</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="c1">// 配置 WVC</span></span><span id="LC6" class="line"><span class="nx">wvc</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span></span><span id="LC7" class="line"><span class="c1">// 根据您的硬件设备选择适合的编码器，这里采用的是 Nvidia 显卡的 h264_nvenc 编码器</span></span><span id="LC8" class="line"><span class="c1">// 编码器选择可参考 docs/video-encoder.md</span></span><span id="LC9" class="line"><span class="na">mp4Encoder</span><span class="p">:</span><span class="nx">VIDEO_ENCODER</span><span class="p">.</span><span class="nx">NVIDIA</span><span class="p">.</span><span class="nx">H264</span></span><span id="LC10" class="line"><span class="p">});</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">// 创建分块视频 1</span></span><span id="LC13" class="line"><span class="kd">const</span><span class="nx">chunk1</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createChunkVideo</span><span class="p">({</span></span><span id="LC14" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/scene-1.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC15" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC16" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC17" class="line"><span class="na">fps</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span></span><span id="LC18" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC19" class="line"><span class="na">showProgress</span><span class="p">:</span><span class="kc">true</span></span><span id="LC20" class="line"><span class="p">});</span></span><span id="LC21" class="line"></span><span id="LC22" class="line"><span class="c1">// 创建分块视频 2</span></span><span id="LC23" class="line"><span class="kd">const</span><span class="nx">chunk2</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createChunkVideo</span><span class="p">({</span></span><span id="LC24" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/scene-2.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC25" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC26" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC27" class="line"><span class="na">fps</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span></span><span id="LC28" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC29" class="line"><span class="na">showProgress</span><span class="p">:</span><span class="kc">true</span></span><span id="LC30" class="line"><span class="p">});</span></span><span id="LC31" class="line"></span><span id="LC32" class="line"><span class="c1">// 等待分块们渲染完成</span></span><span id="LC33" class="line"><span class="k">await</span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">chunk1</span><span class="p">.</span><span class="nx">startAndWait</span><span class="p">(),</span><span class="nx">chunk2</span><span class="p">.</span><span class="nx">startAndWait</span><span class="p">()]);</span></span><span id="LC34" class="line"></span><span id="LC35" class="line"><span class="c1">// 设置 chunk1 和 chunk2 之间的转场效果为淡入淡出</span></span><span id="LC36" class="line"><span class="nx">chunk1</span><span class="p">.</span><span class="nx">setTransition</span><span class="p">({</span><span class="na">id</span><span class="p">:</span><span class="nx">TRANSITION</span><span class="p">.</span><span class="nx">FADE</span><span class="p">,</span><span class="na">duration</span><span class="p">:</span><span class="mi">500</span><span class="p">});</span></span><span id="LC37" class="line"><span class="c1">// 不设置时长可以直接提供效果 ID</span></span><span id="LC38" class="line"><span class="c1">// chunk1.setTransition(TRANSITION.FADE);</span></span><span id="LC39" class="line"></span><span id="LC40" class="line"><span class="c1">// 创建多幕视频</span></span><span id="LC41" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createMultiVideo</span><span class="p">({</span></span><span id="LC42" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC43" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC44" class="line"><span class="na">fps</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span></span><span id="LC45" class="line"><span class="c1">// 视频段</span></span><span id="LC46" class="line"><span class="na">chunks</span><span class="p">:</span><span class="p">[</span></span><span id="LC47" class="line"><span class="nx">chunk1</span><span class="p">,</span></span><span id="LC48" class="line"><span class="nx">chunk2</span></span><span id="LC49" class="line"><span class="p">],</span></span><span id="LC50" class="line"><span class="c1">// 视频输出路径</span></span><span id="LC51" class="line"><span class="na">outputPath</span><span class="p">:</span><span class="dl">"</span><span class="s2">./test.mp4</span><span class="dl">"</span><span class="p">,</span></span><span id="LC52" class="line"><span class="c1">// 是否在 cli 显示进度条</span></span><span id="LC53" class="line"><span class="na">showProgress</span><span class="p">:</span><span class="kc">true</span></span><span id="LC54" class="line"><span class="p">});</span></span><span id="LC55" class="line"></span><span id="LC56" class="line"><span class="c1">// 监听合成完成事件</span></span><span id="LC57" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">once</span><span class="p">(</span><span class="dl">"</span><span class="s2">completed</span><span class="dl">"</span><span class="p">,</span><span class="nx">result</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC58" class="line"><span class="nx">logger</span><span class="p">.</span><span class="nx">success</span><span class="p">(</span><span class="s2">`Render Completed!!!\nvideo duration: </span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">duration</span><span class="o">/</span><span class="mi">1000</span><span class="p">)}</span><span class="s2">s\ntakes: </span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">takes</span><span class="o">/</span><span class="mi">1000</span><span class="p">)}</span><span class="s2">s\nRTF: </span><span class="p">${</span><span class="nx">result</span><span class="p">.</span><span class="nx">rtf</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span></span><span id="LC59" class="line"><span class="p">});</span></span><span id="LC60" class="line"></span><span id="LC61" class="line"><span class="c1">// 启动合成</span></span><span id="LC62" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-全局配置" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE"></a>全局配置</h2><p>您可以全局配置 WVC 调整一些通用参数。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">import</span><span class="nx">WebVideoCreator</span><span class="p">,</span><span class="p">{</span><span class="nx">VIDEO_ENCODER</span><span class="p">,</span><span class="nx">AUDIO_ENCODER</span><span class="p">}</span><span class="k">from</span><span class="dl">"</span><span class="s2">web-video-creator</span><span class="dl">"</span><span class="p">;</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="kd">const</span><span class="nx">wvc</span><span class="o">=</span><span class="k">new</span><span class="nx">WebVideoCreator</span><span class="p">();</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="nx">wvc</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span></span><span id="LC6" class="line"><span class="c1">// 开启后将输出一些 WVC 的调试日志</span></span><span id="LC7" class="line"><span class="na">debug</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC8" class="line"><span class="c1">// 开启后将输出浏览器的运行日志</span></span><span id="LC9" class="line"><span class="na">browserDebug</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC10" class="line"><span class="c1">// 开启后将输出每一条执行的 FFmpeg 命令</span></span><span id="LC11" class="line"><span class="na">ffmpegDebug</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC12" class="line"><span class="c1">// ffmpeg 可执行文件路径，设置后将禁用内部的 ffmpeg-static，建议您默认使用内部的 FFmpeg 以确保功能完整性</span></span><span id="LC13" class="line"><span class="na">ffmpegExecutablePath</span><span class="p">:</span><span class="dl">"</span><span class="s2">...</span><span class="dl">"</span><span class="p">,</span></span><span id="LC14" class="line"><span class="c1">// ffprobe 可执行文件路径，设置后将禁用内部的 ffprobe-static，建议您默认使用内部的 ffprobe 以确保功能完整性</span></span><span id="LC15" class="line"><span class="na">ffprobeExecutablePath</span><span class="p">:</span><span class="dl">"</span><span class="s2">...</span><span class="dl">"</span><span class="p">,</span></span><span id="LC16" class="line"><span class="c1">// 浏览器 GPU 加速开关，建议开启提高渲染性能，如果您没有 GPU 设备或遭遇了诡异的渲染问题则可以关闭它</span></span><span id="LC17" class="line"><span class="na">browserUseGPU</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC18" class="line"><span class="c1">// 浏览器是否使用 Angle 作为渲染后端，建议开启增强渲染跨平台兼容性和性能</span></span><span id="LC19" class="line"><span class="na">browserUseAngle</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC20" class="line"><span class="c1">// 是否禁用浏览器使用共享内存，当/dev/shm 分区较小时建议开启此选项</span></span><span id="LC21" class="line"><span class="na">browserDisableDevShm</span><span class="p">:</span><span class="kc">false</span><span class="p">,</span></span><span id="LC22" class="line"><span class="c1">// 浏览器可执行文件路径，设置后将禁用内部的浏览器，建议您默认使用内部的浏览器以确保功能完整性</span></span><span id="LC23" class="line"><span class="na">browserExecutablePath</span><span class="p">:</span><span class="dl">"</span><span class="s2">...</span><span class="dl">"</span><span class="p">,</span></span><span id="LC24" class="line"><span class="c1">// 是否允许不安全的上下文，默认禁用，开启后能够导航到不安全的 URL，但由于不安全上下文限制，将无法在页面中使用动态图像和内嵌视频</span></span><span id="LC25" class="line"><span class="na">allowUnsafeContext</span><span class="p">:</span><span class="kc">false</span><span class="p">,</span></span><span id="LC26" class="line"><span class="c1">// 兼容渲染模式，不建议启用，启用后将禁用 HeadlessExperimental.beginFrame API 调用改为普通的 Page.screenshot</span></span><span id="LC27" class="line"><span class="c1">// 这会导致渲染性能下降，且部分动画可能帧率无法同步，当你遭遇 TargetCloseError: Protocol error (HeadlessExperimental.beginFrame): Target closed 错误的时候可以尝试开启它</span></span><span id="LC28" class="line"><span class="na">compatibleRenderingMode</span><span class="p">:</span><span class="kc">false</span><span class="p">,</span></span><span id="LC29" class="line"><span class="c1">// 资源池最小浏览器实例数量</span></span><span id="LC30" class="line"><span class="na">numBrowserMin</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span></span><span id="LC31" class="line"><span class="c1">// 资源池最大浏览器实例数量</span></span><span id="LC32" class="line"><span class="na">numBrowserMax</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span></span><span id="LC33" class="line"><span class="c1">// 每个浏览器实例最小页面实例数量</span></span><span id="LC34" class="line"><span class="na">numPageMin</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span></span><span id="LC35" class="line"><span class="c1">// 每个浏览器实例最大页面实例数量</span></span><span id="LC36" class="line"><span class="na">numPageMax</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span></span><span id="LC37" class="line"><span class="c1">// 访问页面时的用户 UA</span></span><span id="LC38" class="line"><span class="na">userAgent</span><span class="p">:</span><span class="kc">null</span><span class="p">,</span></span><span id="LC39" class="line"><span class="c1">// 捕获帧图质量（0-100），仅 jpeg 有效</span></span><span id="LC40" class="line"><span class="na">frameQuality</span><span class="p">:</span><span class="mi">80</span><span class="p">,</span></span><span id="LC41" class="line"><span class="c1">// 帧图格式（jpeg/png），建议使用 jpeg，png 捕获较为耗时</span></span><span id="LC42" class="line"><span class="na">frameFormat</span><span class="p">:</span><span class="dl">"</span><span class="s2">jpeg</span><span class="dl">"</span><span class="p">,</span></span><span id="LC43" class="line"><span class="c1">// BeginFrame 捕获图像超时时间</span></span><span id="LC44" class="line"><span class="na">beginFrameTimeout</span><span class="p">:</span><span class="mi">5000</span><span class="p">,</span></span><span id="LC45" class="line"><span class="c1">// MP4 格式的视频编码器，默认使用 libx264 软编码器，建议根据您的硬件选用合适的硬编码器加速合成，编码器选择可参考 docs/video-encoder.md</span></span><span id="LC46" class="line"><span class="na">mp4Encoder</span><span class="p">:</span><span class="nx">VIDEO_ENCODER</span><span class="p">.</span><span class="nx">CPU</span><span class="p">.</span><span class="nx">H264</span><span class="p">,</span></span><span id="LC47" class="line"><span class="c1">// WEBM 格式的视频编码器，默认使用 libvpx 软编码器，建议根据您的硬件选用合适的硬编码器加速合成</span></span><span id="LC48" class="line"><span class="na">webmEncoder</span><span class="p">:</span><span class="nx">VIDEO_ENCODER</span><span class="p">.</span><span class="nx">CPU</span><span class="p">.</span><span class="nx">VP8</span><span class="p">,</span></span><span id="LC49" class="line"><span class="c1">// 音频编码器，建议采用默认的 aac 编码器</span></span><span id="LC50" class="line"><span class="na">audioEncoder</span><span class="p">:</span><span class="nx">AUDIO_ENCODER</span><span class="p">.</span><span class="nx">AAC</span></span><span id="LC51" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-插入音频" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5%E9%9F%B3%E9%A2%91"></a>插入音频</h2><p>只需在需要渲染的 html 中添加 <code>&lt;audio&gt;</code> 元素，您还可以设置循环，WVC 会自动为视频合入循环音轨。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;audio</span><span class="na">src=</span><span class="s">"bgm.mp3"</span><span class="na">loop</span><span class="nt">&gt;&lt;/audio&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>还可以设置一些其它属性控制音频的行为，这些属性并不总是需要成对出现，您可以根据自己的需求定制。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c">&lt;!-- 控制音频音量为原来的一半 --&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;audio</span><span class="na">src=</span><span class="s">"bgm.mp3"</span><span class="na">volume=</span><span class="s">"0.5"</span><span class="nt">&gt;&lt;/audio&gt;</span></span><span id="LC3" class="line"><span class="c">&lt;!-- 控制音频在 3 秒后开始播放并在 10 秒处停止播放 --&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;audio</span><span class="na">src=</span><span class="s">"bgm.mp3"</span><span class="na">startTime=</span><span class="s">"3000"</span><span class="na">endTime=</span><span class="s">"10000"</span><span class="nt">&gt;&lt;/audio&gt;</span></span><span id="LC5" class="line"><span class="c">&lt;!-- 截取音频第 5 秒到第 15 秒的片段并循环播放它 --&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;audio</span><span class="na">src=</span><span class="s">"bgm.mp3"</span><span class="na">seekStart=</span><span class="s">"5000"</span><span class="na">seekEnd=</span><span class="s">"15000"</span><span class="na">loop</span><span class="nt">&gt;&lt;/audio&gt;</span></span><span id="LC7" class="line"><span class="c">&lt;!-- 控制音频 300 毫秒淡入且 500 毫秒淡出 --&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;audio</span><span class="na">src=</span><span class="s">"bgm.mp3"</span><span class="na">fadeInDuration=</span><span class="s">"300"</span><span class="na">fadeOutDuration=</span><span class="s">"500"</span><span class="nt">&gt;&lt;/audio&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>在代码中添加和移除 <code>&lt;audio&gt;</code> 元素来实现音频出入场也是被允许的，WVC 将检测到它们。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">audio</span><span class="o">=</span><span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">audio</span><span class="dl">"</span><span class="p">);</span></span><span id="LC2" class="line"><span class="nx">audio</span><span class="p">.</span><span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">bgm.mp3</span><span class="dl">"</span><span class="p">;</span></span><span id="LC3" class="line"><span class="c1">// 音频在视频第 3 秒入场</span></span><span id="LC4" class="line"><span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">audio</span><span class="p">),</span><span class="mi">3000</span><span class="p">);</span></span><span id="LC5" class="line"><span class="c1">// 音频在视频第 8 秒出场</span></span><span id="LC6" class="line"><span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="nx">audio</span><span class="p">.</span><span class="nx">remove</span><span class="p">(),</span><span class="mi">8000</span><span class="p">);</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>或者在页面中调用 <a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/capture-ctx.md#capturecontextaddaudiooptions-object">captureCtx.addAudio</a> 添加音频到视频中。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 添加单个音频</span></span><span id="LC2" class="line"><span class="nx">captureCtx</span><span class="p">.</span><span class="nx">addAudio</span><span class="p">({</span></span><span id="LC3" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">bgm.mp3</span><span class="dl">"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="na">startTime</span><span class="p">:</span><span class="mi">500</span><span class="p">,</span></span><span id="LC5" class="line"><span class="na">loop</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC6" class="line"><span class="c1">// 80% 的音量</span></span><span id="LC7" class="line"><span class="na">volume</span><span class="p">:</span><span class="mi">80</span></span><span id="LC8" class="line"><span class="p">});</span></span><span id="LC9" class="line"><span class="c1">// 添加多个音频</span></span><span id="LC10" class="line"><span class="nx">captureCtx</span><span class="p">.</span><span class="nx">addAudios</span><span class="p">([...]);</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>也可以在 WVC 中直接使用 <a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/api-reference-high-level.md#singlevideoaddaudiooptions-object">addAudio</a> 将本地或远程的音频添加到视频中。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span><span class="p">...</span><span class="p">});</span></span><span id="LC2" class="line"><span class="c1">// 添加单个音频</span></span><span id="LC3" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">addAudio</span><span class="p">({</span></span><span id="LC4" class="line"><span class="c1">// url: "http://.../bgm.mp3"</span></span><span id="LC5" class="line"><span class="na">path</span><span class="p">:</span><span class="dl">"</span><span class="s2">bgm.mp3</span><span class="dl">"</span><span class="p">,</span></span><span id="LC6" class="line"><span class="na">startTime</span><span class="p">:</span><span class="mi">500</span><span class="p">,</span></span><span id="LC7" class="line"><span class="na">loop</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC8" class="line"><span class="c1">// 80% 的音量</span></span><span id="LC9" class="line"><span class="na">volume</span><span class="p">:</span><span class="mi">80</span></span><span id="LC10" class="line"><span class="p">});</span></span><span id="LC11" class="line"><span class="c1">// 添加多个音频</span></span><span id="LC12" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">addAudios</span><span class="p">([...]);</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>这样的操作同样适用于 MultiVideo 和 ChunkVideo 。</p><h2><a id="user-content-插入视频" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91"></a>插入视频</h2><p>目前支持 <code>mp4</code> 和 <code>webm</code> 格式的视频，只需在需要渲染的 html 中添加 <code>&lt;video&gt;</code> 元素，您可以设置循环和静音，如果您的 src 不包含 <code>.mp4</code> 后缀名可能无法被识别，请添加 <code>capture</code> 属性标识为需要捕获的元素。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"background.mp4"</span><span class="na">loop</span><span class="na">muted</span><span class="nt">&gt;&lt;/video&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如果希望插入透明通道的视频请见：<a href="https://gitee.com/vblog/web-video-creator#%E9%80%8F%E6%98%8E%E9%80%9A%E9%81%93%E8%A7%86%E9%A2%91">透明通道视频</a>，对视频帧率同步或透明视频绘制感兴趣可以参考：<a href="https://gitee.com/vblog/web-video-creator#%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0">技术实现</a>。</p><p>和音频一样，它也支持设置一些属性控制视频的行为，这些属性并不总是需要成对出现，您可以根据自己的需求定制。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c">&lt;!-- 控制音频音量为原来的 70% --&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"test.mp4"</span><span class="na">volume=</span><span class="s">"0.7"</span><span class="nt">&gt;&lt;/video&gt;</span></span><span id="LC3" class="line"><span class="c">&lt;!-- 控制视频在 3 秒后开始播放并在 10 秒处停止播放 --&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"test.mp4"</span><span class="na">startTime=</span><span class="s">"3000"</span><span class="na">endTime=</span><span class="s">"10000"</span><span class="nt">&gt;&lt;/video&gt;</span></span><span id="LC5" class="line"><span class="c">&lt;!-- 截取视频第 5 秒到第 15 秒的片段并循环播放它 --&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"test.mp4"</span><span class="na">seekStart=</span><span class="s">"5000"</span><span class="na">seekEnd=</span><span class="s">"15000"</span><span class="na">loop</span><span class="nt">&gt;&lt;/video&gt;</span></span><span id="LC7" class="line"><span class="c">&lt;!-- 控制视频的音频在 300 毫秒淡入且 500 毫秒淡出 --&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"test.mp4"</span><span class="na">fadeInDuration=</span><span class="s">"300"</span><span class="na">fadeOutDuration=</span><span class="s">"500"</span><span class="nt">&gt;&lt;/video&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>在代码中添加和移除 <code>&lt;video&gt;</code> 元素来实现视频出入场也是被允许的，WVC 将检测到它们。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">video</span><span class="dl">"</span><span class="p">);</span></span><span id="LC2" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">test.mp4</span><span class="dl">"</span><span class="p">;</span></span><span id="LC3" class="line"><span class="c1">// 视频在第 3 秒入场</span></span><span id="LC4" class="line"><span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">video</span><span class="p">),</span><span class="mi">3000</span><span class="p">);</span></span><span id="LC5" class="line"><span class="c1">// 视频在第 8 秒出场</span></span><span id="LC6" class="line"><span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="nx">video</span><span class="p">.</span><span class="nx">remove</span><span class="p">(),</span><span class="mi">8000</span><span class="p">);</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-透明通道视频" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E9%80%8F%E6%98%8E%E9%80%9A%E9%81%93%E8%A7%86%E9%A2%91"></a>透明通道视频</h3><p>透明视频非常适合用于将 vtuber 数字人合成到视频画面中，结合精美的动画可以获得非常好的观看体验，合成效果请参考 <strong><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FVinlic%2FWebVideoCreator%2Fwiki%2FRendering-Example">渲染示例页面</a></strong> 最后一个 Demo。</p><p>透明通道视频格式需为 <code>webm</code> ，在内部它会被重新编码为两个 mp4 容器的视频，分别是原色底视频和蒙版视频后在浏览器 canvas 中使用进行 <code>globalCompositeOperation</code> 进行图像混合并绘制。</p><p>对于使用者是无感的，像下面代码演示中那样，只需需要渲染的 html 中添加 <code>&lt;video&gt;</code> 元素，并设置 src 为 webm 格式视频地址即可。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"vtuber.webm"</span><span class="nt">&gt;&lt;/video&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>webm 编解码通常比较耗时，如果您可以直接获得原始 mp4 视频和蒙版 mp4 视频是更好的方案，只需增加设置 maskSrc 即可。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"vtuber.mp4"</span><span class="na">maskSrc=</span><span class="s">"vtuber_mask.mp4"</span><span class="nt">&gt;&lt;/video&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-插入动态图像" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5%E5%8A%A8%E6%80%81%E5%9B%BE%E5%83%8F"></a>插入动态图像</h2><p>动态图像指的是 <code>gif</code> / <code>apng</code> / <code>webp</code> 格式的序列帧动画，他们可以在浏览器中自然播放，帧率通常是不可控的，但 WVC 代理了它们的绘制，img 元素被替换为 canvas 并通过 ImageDecoder 解码绘制每一帧，让序列帧动画按照虚拟时间同步绘制。</p><p>以下这些动图都能够正常绘制，您也可以照常给他们设置样式。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"test.gif"</span><span class="nt">/&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"test.apng"</span><span class="nt">/&gt;</span></span><span id="LC3" class="line"><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"test.webp"</span><span class="nt">/&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-插入 lottie 动画" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5lottie%E5%8A%A8%E7%94%BB"></a>插入 Lottie 动画</h2><p>WVC 已经内置 <a href="https://gitee.com/link?target=http%3A%2F%2Fairbnb.io%2Flottie%2F%23%2Fweb">lottie-web</a> 动画库，如果您的页面有自己实现的 lottie 动效则可以忽略本内容，因为它们也能够正常工作。</p><p>只需要插入一个 <code>&lt;lottie&gt;</code> 元素并设置 src 即可。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;lottie</span><span class="na">src=</span><span class="s">"example.json"</span><span class="nt">&gt;&lt;/lottie&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-应用字体" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%BA%94%E7%94%A8%E5%AD%97%E4%BD%93"></a>应用字体</h2><p>WVC 能够检测样式表中的 <code>@font-face</code> 声明并等待字体加载完成再开始渲染。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;style&gt;</span></span><span id="LC2" class="line"><span class="k">@font-face</span><span class="p">{</span></span><span id="LC3" class="line"><span class="nl">font-family</span><span class="p">:</span><span class="s1">"FontTest"</span><span class="p">;</span></span><span id="LC4" class="line"><span class="nl">src</span><span class="p">:</span><span class="sx">url("font.ttf")</span><span class="n">format</span><span class="p">(</span><span class="s1">"truetype"</span><span class="p">);</span></span><span id="LC5" class="line"><span class="p">}</span></span><span id="LC6" class="line"><span class="nt">&lt;/style&gt;</span></span><span id="LC7" class="line"><span class="nt">&lt;p</span><span class="na">style=</span><span class="s">'font-family: "FontTest"'</span><span class="nt">&gt;</span>Hello World<span class="nt">&lt;/p&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>或者，可以通过代码注册本地或远程的字体。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span><span class="p">...</span><span class="p">});</span></span><span id="LC2" class="line"><span class="c1">// 注册单个字体</span></span><span id="LC3" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">registerFont</span><span class="p">({</span></span><span id="LC4" class="line"><span class="c1">// url: "http://.../font.ttf"</span></span><span id="LC5" class="line"><span class="na">path</span><span class="p">:</span><span class="dl">"</span><span class="s2">font.ttf</span><span class="dl">"</span><span class="p">,</span></span><span id="LC6" class="line"><span class="na">family</span><span class="p">:</span><span class="dl">"</span><span class="s2">FontTest</span><span class="dl">"</span><span class="p">,</span></span><span id="LC7" class="line"><span class="na">format</span><span class="p">:</span><span class="dl">"</span><span class="s2">truetype</span><span class="dl">"</span></span><span id="LC8" class="line"><span class="p">});</span></span><span id="LC9" class="line"><span class="c1">// 注册多个字体</span></span><span id="LC10" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">registerFonts</span><span class="p">([...]);</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>您需要确保字体能够正常加载，否则可能无法启动渲染。</p><h2><a id="user-content-插入转场效果" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5%E8%BD%AC%E5%9C%BA%E6%95%88%E6%9E%9C"></a>插入转场效果</h2><p>WVC 支持使用 FFmpeg 所支持的 <a href="https://gitee.com/link?target=https%3A%2F%2Ftrac.ffmpeg.org%2Fwiki%2FXfade">Xfade</a> 滤镜来合成转场效果，可参考<a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/transition.md">转场列表</a>、</p><p>每个分块视频参数都能够设置转场效果和持续时长。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">import</span><span class="nx">WebVideoCreator</span><span class="p">,</span><span class="p">{</span><span class="nx">TRANSITION</span><span class="p">}</span><span class="k">from</span><span class="dl">"</span><span class="s2">web-video-creator</span><span class="dl">"</span><span class="p">;</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="p">...</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createMultiVideo</span><span class="p">({</span></span><span id="LC6" class="line"><span class="p">...</span></span><span id="LC7" class="line"><span class="c1">// 视频段参数</span></span><span id="LC8" class="line"><span class="na">chunks</span><span class="p">:</span><span class="p">[</span></span><span id="LC9" class="line"><span class="p">{</span></span><span id="LC10" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/scene-1.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC11" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC12" class="line"><span class="c1">// 在第一和第二幕之间插入淡入淡出转场</span></span><span id="LC13" class="line"><span class="na">transition</span><span class="p">:</span><span class="p">{</span></span><span id="LC14" class="line"><span class="na">id</span><span class="p">:</span><span class="nx">TRANSITION</span><span class="p">.</span><span class="nx">FADE</span><span class="p">,</span></span><span id="LC15" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">500</span></span><span id="LC16" class="line"><span class="p">},</span></span><span id="LC17" class="line"><span class="c1">// 如果不需要设置时长也可以直接设置转场 ID</span></span><span id="LC18" class="line"><span class="c1">// transition: TRANSITION.FADE</span></span><span id="LC19" class="line"><span class="p">},</span></span><span id="LC20" class="line"><span class="p">{</span></span><span id="LC21" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/scene-2.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC22" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span></span><span id="LC23" class="line"><span class="p">}</span></span><span id="LC24" class="line"><span class="p">],</span></span><span id="LC25" class="line"><span class="p">...</span></span><span id="LC26" class="line"><span class="p">});</span></span><span id="LC27" class="line"></span><span id="LC28" class="line"><span class="p">...</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>需要注意的是，应用转场会导致视频总时长缩短，转场效果实际上是两段视频的部分重叠，两段 5 秒的视频插入转场，会合成时长为 9 秒的视频。</p><p>Lottie 动画也很适合作为转场效果，您可以在一段视频的尾部播放一半时长的全屏 Lottie 动画，然后在下一段视频开头播放另一半时长的全屏 Lottie 动画实现更动感的转场效果。</p><h2><a id="user-content-延迟启动渲染" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%BB%B6%E8%BF%9F%E5%90%AF%E5%8A%A8%E6%B8%B2%E6%9F%93"></a>延迟启动渲染</h2><p>WVC 默认页面导航完成后立即启动渲染，如果希望在渲染之前进行一些工作，可以在选项中禁用自动启动渲染，禁用后请记得在您的页面中调用 <a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/capture-ctx.md#capturecontextstart">captureCtx.start()</a>，否则将永远阻塞。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/test.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC3" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC4" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC5" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC6" class="line"><span class="c1">// 禁用自动启动渲染</span></span><span id="LC7" class="line"><span class="na">autostartRender</span><span class="p">:</span><span class="kc">false</span></span><span id="LC8" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>页面代码中，在您觉得合适的时机调用启动。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;script&gt;</span></span><span id="LC2" class="line"><span class="c1">// 数据加载完成后启动渲染</span></span><span id="LC3" class="line"><span class="nx">loadData</span><span class="p">()</span></span><span id="LC4" class="line"><span class="p">.</span><span class="nx">then</span><span class="p">(()</span><span class="o">=&gt;</span><span class="nx">captureCtx</span><span class="p">.</span><span class="nx">start</span><span class="p">())</span></span><span id="LC5" class="line"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="o">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">));</span></span><span id="LC6" class="line"><span class="nt">&lt;/script&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-启动渲染前操作页面" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%90%AF%E5%8A%A8%E6%B8%B2%E6%9F%93%E5%89%8D%E6%93%8D%E4%BD%9C%E9%A1%B5%E9%9D%A2"></a>启动渲染前操作页面</h2><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/test.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC3" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC4" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC5" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC6" class="line"><span class="na">pagePrepareFn</span><span class="p">:</span><span class="k">async</span><span class="nx">page</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC7" class="line"><span class="c1">// 获取 puppeteer Page 对象</span></span><span id="LC8" class="line"><span class="kd">const</span><span class="nx">_page</span><span class="o">=</span><span class="nx">page</span><span class="p">.</span><span class="nx">target</span><span class="p">;</span></span><span id="LC9" class="line"><span class="c1">// 点击按钮</span></span><span id="LC10" class="line"><span class="k">await</span><span class="nx">_page</span><span class="p">.</span><span class="nx">tap</span><span class="p">(</span><span class="dl">"</span><span class="s2">#play-button</span><span class="dl">"</span><span class="p">);</span></span><span id="LC11" class="line"><span class="p">}</span></span><span id="LC12" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-页面控制枱输出" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E9%A1%B5%E9%9D%A2%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA"></a>页面控制枱输出</h2><p>如果想看到页面的日志，可在视频选项中开启 consoleLog。开启 videoPreprocessLog 将输出内嵌视频预处理日志。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 输出页面控制枱打印的日志</span></span><span id="LC4" class="line"><span class="na">consoleLog</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC5" class="line"><span class="c1">// 输出内嵌视频预处理日志</span></span><span id="LC6" class="line"><span class="na">videoPreprocessLog</span><span class="p">:</span><span class="kc">true</span></span><span id="LC7" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-截取封面图" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%88%AA%E5%8F%96%E5%B0%81%E9%9D%A2%E5%9B%BE"></a>截取封面图</h2><p>合成视频后可以截取某一帧图像并保存，可以作为视频封面图。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 是否截取图像</span></span><span id="LC4" class="line"><span class="na">coverCapture</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC5" class="line"><span class="c1">// 图像截取时间点（毫秒），默认是视频时长的 20% 位置）</span></span><span id="LC6" class="line"><span class="na">coverCaptureTime</span><span class="p">:</span><span class="mi">1000</span><span class="p">,</span></span><span id="LC7" class="line"><span class="c1">// 图像保存格式（jpg/png/bmp），默认 jpg</span></span><span id="LC8" class="line"><span class="na">coverCaptureFormat</span><span class="p">:</span><span class="dl">"</span><span class="s2">jpg</span><span class="dl">"</span></span><span id="LC9" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-插入封面图" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5%E5%B0%81%E9%9D%A2%E5%9B%BE"></a>插入封面图</h2><p>WVC 支持往视频的首帧插入图像，当视频未被播放时将展示首帧图像。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 设置附加的封面图地址，支持 jpg/png/bmp</span></span><span id="LC4" class="line"><span class="na">attachCoverPath</span><span class="p">:</span><span class="dl">"</span><span class="s2">./cover.jpg</span><span class="dl">"</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-调整视频音量" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E8%B0%83%E6%95%B4%E8%A7%86%E9%A2%91%E9%9F%B3%E9%87%8F"></a>调整视频音量</h2><p>您可以控制输出视频的总音量。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 设置视频音量为原来的 80%</span></span><span id="LC4" class="line"><span class="na">volume</span><span class="p">:</span><span class="mi">80</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-控制输出视频质量" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8E%A7%E5%88%B6%E8%BE%93%E5%87%BA%E8%A7%86%E9%A2%91%E8%B4%A8%E9%87%8F"></a>控制输出视频质量</h2><p>WVC 支持通过 <code>videoQuality</code> 或 <code>videoBitrate</code> 控制视频图像质量。</p><p>videoQuality 是通过图像总像素量简单计算码率，以下 WVC 内计算视频码率方法。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">pixels</span><span class="o">=</span><span class="nx">width</span><span class="o">*</span><span class="nx">height</span><span class="p">;</span></span><span id="LC2" class="line"><span class="kd">const</span><span class="nx">videoBitrate</span><span class="o">=</span><span class="p">(</span><span class="mi">2560</span><span class="o">/</span><span class="mi">921600</span><span class="o">*</span><span class="nx">pixels</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nx">videoQuality</span><span class="o">/</span><span class="mi">100</span><span class="p">);</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>可以在视频选项中提供 videoQuality（0-100）</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 设置视频质量为 80%</span></span><span id="LC4" class="line"><span class="na">videoQuality</span><span class="p">:</span><span class="mi">80</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如果您认为码率不合适，可以单独设置 videoBitrate。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 设置视频码率为 8Mbps</span></span><span id="LC4" class="line"><span class="na">videoBitrate</span><span class="p">:</span><span class="dl">"</span><span class="s2">8192k</span><span class="dl">"</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>另外还可以调整帧图质量，当使用 jpeg 作为帧图格式时可以调整 frameQuality，详见 <a href="https://gitee.com/vblog/web-video-creator#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE">全局配置</a>。</p><p>音频质量则可以通过设置音频码率 audioBitrate 调整。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 设置音频码率为 320Kbps</span></span><span id="LC4" class="line"><span class="na">audioBitrate</span><span class="p">:</span><span class="dl">"</span><span class="s2">320k</span><span class="dl">"</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-修改像素格式" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E4%BF%AE%E6%94%B9%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F"></a>修改像素格式</h2><p>WVC 目前支持输出 <code>yuv420p</code> / <code>yuv444p</code> / <code>rgb24</code> 像素格式的视频，默认采用兼容性更好的 yuv420p ，如果您发现输出的视频与页面的颜色有较大的差异，可以切换为 rgb24 改善这个问题。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 设置像素格式为 rgb24</span></span><span id="LC4" class="line"><span class="na">pixelFormat</span><span class="p">:</span><span class="dl">"</span><span class="s2">rgb24</span><span class="dl">"</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><br><h1><a id="user-content-视频编码器选择" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%99%A8%E9%80%89%E6%8B%A9"></a>视频编码器选择</h1><p>浏览器渲染输出帧图流输入 FFmpeg 时需要通过视频编码器将图像数据按指定帧率编码为视频数据并存储于指定格式容器中，视频编码是一项较为消耗资源的操作，选用硬编码器可以加速这个过程并降低 CPU 的负载。</p><p>WVC 支持的视频编码器请参考：<a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/video-encoder.md">视频编码器说明</a></p><br><h1><a id="user-content-进度监听" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E8%BF%9B%E5%BA%A6%E7%9B%91%E5%90%AC"></a>进度监听</h1><p>您可以通过视频实例的 <code>progress</code> 事件监听渲染合成进度。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span><span class="p">...</span><span class="p">});</span></span><span id="LC2" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">progress</span><span class="dl">"</span><span class="p">,</span><span class="p">(</span><span class="nx">progress</span><span class="p">,</span><span class="nx">synthesizedFrameCount</span><span class="p">,</span><span class="nx">totalFrameCount</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC3" class="line"><span class="c1">// 输出，进度 / 已合成帧数 / 总帧数</span></span><span id="LC4" class="line"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">progress</span><span class="p">,</span><span class="nx">synthesizedFrameCount</span><span class="p">,</span><span class="nx">totalFrameCount</span><span class="p">);</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>这同样适用于 <code>MultiVideo</code> / <code>ChunkVideo</code> 以及低级别 API 的合成器。</p><br><h1><a id="user-content-异常处理" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"></a>异常处理</h1><h2><a id="user-content-抛出错误" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF"></a>抛出错误</h2><p>您可以在页面中主动抛出错误来中断渲染。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;script&gt;</span></span><span id="LC2" class="line"><span class="nx">____throwError</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="dl">"</span><span class="s2">Abort</span><span class="dl">"</span><span class="p">);</span></span><span id="LC3" class="line"><span class="nt">&lt;/script&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-监听页面崩溃" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E5%B4%A9%E6%BA%83"></a>监听页面崩溃</h2><p>如果您的页面存在大量密集计算或者占用过多的运行内存，页面将可能崩溃，从而导致渲染中断。</p><p>如果使用高级别 API，页面崩溃时通过视频实例的 <code>error</code> 事件通知。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span><span class="p">...</span><span class="p">});</span></span><span id="LC2" class="line"><span class="c1">// 错误时输出 Page crashed:...</span></span><span id="LC3" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">,</span><span class="nx">err</span><span class="o">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">));</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>使用低级别 API 时，页面崩溃时通过 Page 实例的 <code>crashed</code> 事件通知</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 错误时输出崩溃错误</span></span><span id="LC2" class="line"><span class="nx">page</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">crashed</span><span class="dl">"</span><span class="p">,</span><span class="nx">err</span><span class="o">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">));</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-监听其它错误" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E7%9B%91%E5%90%AC%E5%85%B6%E5%AE%83%E9%94%99%E8%AF%AF"></a>监听其它错误</h2><p>如果使用高级别 API，页面崩溃时通过视频实例的 <code>error</code> 事件通知。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span><span class="p">...</span><span class="p">});</span></span><span id="LC2" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">,</span><span class="nx">err</span><span class="o">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">));</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>使用低级别 API 时，页面崩溃时通过 Page 实例的 <code>error</code> 事件通知</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nx">page</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">,</span><span class="nx">err</span><span class="o">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">));</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><br><h1><a id="user-content-分布式渲染方案" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88"></a>分布式渲染方案</h1><p>如果您有多台设备可以为这些设备部署 WVC，它提供了 <code>MultiVideo</code> 和 <code>ChunkVideo</code>，您可以将动画页面分为很多个分段，如 0-10 秒、10-20 秒...，将它们的参数分发到不同设备的 WVC 上，在这些设备上创建 ChunkVideo 实例并执行并行渲染为多个视频 <code>ts</code> 分段，将他们回传到核心节点上，并最终输入 MultiVideo 进行合并以及转场、音轨合成输出。<strong>这个分发以及回传流程 WVC 还未实现，但它并不难，您可以根据自己的场景进行封装并欢迎为 WVC 贡献<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FVinlic%2FWebVideoCreator%2Fpulls">PR</a>！</strong></p><br><h1><a id="user-content-api 参考" class="anchor" href="https://gitee.com/vblog/web-video-creator#api%E5%8F%82%E8%80%83"></a>API 参考</h1><h2><a id="user-content-高级别 api" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E9%AB%98%E7%BA%A7%E5%88%ABapi"></a>高级别 API</h2><p>大部分时候，建议使用高级别 API，因为它足够的简单，但可能不够灵活。</p><p><a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/api-reference-high-level.md">API Reference High Level</a></p><h2><a id="user-content-低级别 api" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E4%BD%8E%E7%BA%A7%E5%88%ABapi"></a>低级别 API</h2><p><a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/api-reference-low-level.md">API Reference Low Level</a></p><br><h1><a id="user-content-性能提示" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%80%A7%E8%83%BD%E6%8F%90%E7%A4%BA"></a>性能提示</h1><p>性能通常受动画和媒体的复杂程度影响，您可以将长时间动画分为多个分段动画播放，比如为每个页面地址带一个 seek 参数，加载页面后 seek 到指定时间点开始播放，然后作为多幕视频进行渲染合成，可以显著的降低长视频的渲染耗时。</p><ul><li>并行更多的视频块渲染，如果希望榨干系统资源，在确保系统内存充足的情况下并行数选定为 CPU 的线程数</li><li>CPU 主频对于基准速度影响较大，通常消费级 CPU 主频很高，可以获得更佳的性能。</li><li>建议使用 GPU 加速渲染和合成，如果您设备有 GPU 但没有被使用，请检查配置项或报告问题。</li><li>采用 SSD（固态硬盘）可以提升并行渲染时的硬盘缓存写入性能从而降低渲染耗时。</li><li>选择正确的视频硬编码器很重要，默认采用的是软编码器（mp4 是 libx264，webm 是 libvpx），如果您有核显或者独显请记得配置他们支持的硬编码器。</li><li>有些耗时可能来自于网络文件传输，建议将静态文件服务部署于同一台服务器或从局域网访问文件服务器。</li><li>降低输出视频分辨率和帧率是降低耗时最有效的方法。</li></ul><hr><p>目前手上没有更好的测试设备，我将以我的个人主机的性能参数作为参考：</p><p>系统：Windows10（在 Linux 系统中性能表现更好）</p><p>CPU: AMD Ryzen 7 3700X（主频 3.6-4.4GHz 8 核 16 线程）</p><p>GPU: Nvidia GeForce GTX 1660 SUPER（6GB 显存，支持 NVENC）</p><p>RAM: 16GB（DDR4 2400MHz）</p><p>视频类型：SVG 动画+GIF+Lottie 动画播放</p><p>视频分辨率：1280x720</p><p>视频帧率：30</p><p>视频时长：300s（5 分钟）</p><p>渲染耗时：61s（1 分钟）</p><p>实时率：4.844</p><p>并行渲染数：16</p><hr><br><h1><a id="user-content-局限性" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%B1%80%E9%99%90%E6%80%A7"></a>局限性</h1><ul><li>受制于浏览器的<a href="https://gitee.com/link?target=https%3A%2F%2Fw3c.github.io%2Fwebappsec-secure-contexts%2F">安全上下文限制</a>，只能访问 localhost / 127.0.0.1 或者使用 HTTPS 协议且证书有效的域，从安全角度考虑建议使用本机静态服务器（live-server 是一个不错的选择）。</li><li>在 Mac 系统中使用无头实验 API 在会发生崩溃，需要改为兼容渲染模式才能运行，但兼容渲染模式存在诸多问题，不建议在 Mac 系统使用，详见<a href="https://gitee.com/vblog/web-video-creator#%E5%85%BC%E5%AE%B9%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F">兼容渲染模式</a></li><li>WebVideoCreator 是纯 ESM 包，无法使用 CommonJS 风格引入，如果依然希望使用 require 引入，请参考：<a href="https://gitee.com/link?target=https%3A%2F%2Fgist.github.com%2Fsindresorhus%2Fa39789f98801d908bbc7ff3ecc99d99c">https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c</a></li></ul><br><h1><a id="user-content-技术实现" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"></a>技术实现</h1><p>正在编写中...</p>]]>
            </description>
            <pubDate>Sat, 04 Nov 2023 02:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/vblog/web-video-creator</guid>
            <link>https://gitee.com/vblog/web-video-creator</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | vivo 网络端口安全建设技术实践]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="letter-spacing: 0.578px;text-wrap: wrap;font-size: 15px;"><section powered-by="xiumi.us" style="text-align: center;font-size: 14px;"><p><span style="color: rgb(0, 82, 255);"><span style="letter-spacing: 0.578px;">揭秘 vivo 互联网海量服务的研发之路&nbsp;</span><span style="letter-spacing: 0.034em;">报名中👇</span></span></p></section><section powered-by="xiumi.us" style="margin-top: 0.5em;margin-bottom: 0.5em;padding-right: 0.5em;padding-left: 0.5em;text-align: center;"><section style="border-width: 5px;border-style: solid;border-color: rgb(255, 255, 255);display: inline-block;line-height: 0;box-shadow: rgb(102, 102, 102) 0.2em 0.2em 0.5em;width: 394.094px;height: auto;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdev.vivo.com.cn%2Fvdc%2F2023%2Findex.html%23%2F" textvalue="‍‍" linktype="text" imgurl="" tab="outerlink" data-linktype="1"><span class="js_jump_icon h5_image_link"><img class="rich_pages wxw-img" data-cropselx1="0" data-cropselx2="384" data-cropsely1="0" data-cropsely2="384" data-ratio="0.21944444444444444" data-s="300,640" src="https://oscimg.oschina.net/oscnet/67276678-97b5-4d79-8ae3-651f665ab878.png" data-type="jpeg" data-w="1080" style="height: 127px;vertical-align: middle;width: 578px;" referrerpolicy="no-referrer"></span></a></section></section></section><section style="font-size: 15px;line-height: 1.6;"><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">作者：vivo 互联网安全团队 - Peng Qiankun</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: left;" powered-by="xiumi.us"><section style="font-size: 14px;text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);"><p style="text-wrap: wrap;">随着互联网业务的快速发展，网络攻击的频率和威胁性也在不断增加，端口是应用通信中的门户，它是数据进出应用的必经之路，因此端口安全也逐渐成为了企业内网的重要防线之一，然而网络端口因其数量庞大、端口开放和关闭的影响评估难度大，业务影响程度高、以及异常识别技术复杂度高等特点给网络端口安全治理带来了一定挑战，如何对端口风险进行有效治理几乎是每个企业安全团队在攻击面管理工作中持续探索的重点项。</p></section></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>一、网络端口简介</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">在网络空间中，标记一个服务资源实体最基本的两个要素就是 IP 和逻辑端口，二者构建服务资源实体的唯一标志符。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. &nbsp;常见的端口分布划分：</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（1）知名端口 (Well-Known Ports)</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">知名端口即众所周知的端口号，范围从 0 到 1023，这些端口号一般固定分配给一些服务。比如 21 端口分配给 FTP 服务，25 端口分配给 SMTP(简单邮件传输协议) 服务，80 端口分配给 HTTP 服务，135 端口分配给 RPC(远程过程调用) 服务等等。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）动态端口 (Dynamic Ports)</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">动态端口的范围从 1024 到 65535，这些端口号一般不固定分配给某个服务，也就是说许多服务都可以使用这些端口。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。比如 1024 端口就是分配给第一个向系统发出申请的程序。在关闭程序进程后，就会释放所占用的端口号。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;&nbsp;另外，端口还会按照协议类型划分</strong></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">（1）TCP 端口</p><p style="text-wrap: wrap;">&nbsp;</p><p style="text-wrap: wrap;">即传输控制协议端口，需要在客户端和服务器之间建立连接，这样可以提供可靠的数据传输。常见的包括 FTP 服务的 21 端口，Telnet 服务的 23 端口，SMTP 服务的 25 端口，以及 HTTP 服务的 80 端口等等。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">（2）&nbsp;UDP 端口</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">即用户数据包协议端口，无需在客户端和服务器之间建立连接，安全性得不到保障。常见的有 DNS 服务的 53 端口，SNMP(简单网络管理协议) 服务的 161 端口，QQ 使用的 8000 和 4000 端口等等。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>3.&nbsp;&nbsp;常用的网络端口映射表</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6138917262512769" data-s="300,640" src="https://oscimg.oschina.net/oscnet/affd180b-4e93-4677-a843-2a267a05b99a.png" data-type="png" data-w="979" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp;图 1 常用网络端口映射表</span></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">PS：更多详细端口规范可查阅：</p><p style="text-wrap: wrap;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.iana.org%2Fassignments%2Fservice-names-port-numbers%2Fservice-names-port-numbers.xhtml" textvalue="http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml" linktype="text" imgurl="" tab="outerlink" data-linktype="2">http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml</a></p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>二、端口利用方式</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.1 基于传输层的资源耗尽攻击（DDoS）</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">该攻击是非常有效的利用小流量冲击大带宽的攻击手段，也是十分常见的攻击方式。其本质还是利用 TCP 协议的链接建立（三次握手）及链接关闭（四次挥手）阶段机制漏洞进行攻击，链接资源耗尽攻击方式主要分为以下几个类别：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（1）&nbsp;SYN flood</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">SYN flood 是基于 TCP 协议产生的，它利用三次握手机制，制造多个半连接，消耗服务器的连接数。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.44166666666666665" data-s="300,640" src="https://oscimg.oschina.net/oscnet/8c97a12b-6829-4190-9266-30e097022e4a.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">图 2&nbsp;SYN flood 示意图</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">攻击者伪造源 IP 地址向服务器发送大量的 SYN 报文，请求建立三次握手。由于发送源 IP 是伪造的，所以服务器回应了 SYN-ACK 报文后，源 IP 并不会再继续回应 ACK 报文进行确认。这样服务器就会维持一个庞大的等待列表，不停地重试发送 SYN-ACK 报文，同时占用着大量的资源无法释放。这就导致，被攻击的服务器被恶意半连接占满，不再接受新的 SYN 请求，而合法用户无法完成三次握手建立 TCP 连接。另外，随着对抗技术的持续演进，攻击者通过肉鸡或 Ddos 服务发起大规模分布式真实 IP 集中进行资源耗尽攻击，此类攻击成功率更高。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（2）SYN-ACK Flood</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通信双方通过三次握手建立一个 TCP 连接的过程中，SYN-ACK 报文出现在第二次握手中，是用来确认第一次握手的。一方收到 SYN-ACK 报文后，首先会判断该报文是不是属于三次握手范畴之内的报文。如果都没有进行第一次握手就直接收到了第二次握手的报文，那么就会向对方发送 RST 报文，告知对方其发来报文有误，不能建立连接。SYN-ACK Flood 攻击正是利用了这一点，攻击者利用工具或者操纵僵尸主机，向目标服务器发送大量的 SYN-ACK 报文，这些报文都属于凭空出现的第二次握手报文，服务器忙于回复 RST 报文，导致资源耗尽，无法响应正常的请求。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（3）ACK Flood</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">在 TCP 三次握手的过程中，ACK 报文出现在第三次握手中，用来确认第二次握手中的 SYN-ACK 报文。ACK Flood 攻击指的是攻击者利用工具或者操纵僵尸主机，向目标服务器发送大量的 ACK 报文，服务器忙于回复这些凭空出现的第三次握手报文，导致资源耗尽，无法响应正常的请求。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（4）FIN/RST Flood</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">TCP 交互过程中还存在 FIN 和 RST 报文，FIN 报文用来关闭 TCP 连接，RST 报文用来断开 TCP 连接。这两种报文也可能会被攻击者利用来发起 DDoS 攻击，导致目标服务器资源耗尽，无法响应正常的请求。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（5）TCP connection Flood</strong></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">TCP 是面向连接的协议，通信双方必须保持连接状态，并且通过确认、重传、滑动窗口等机制，保证数据传输的可靠性和稳定性。攻击者利用 TCP 协议的上述特点，在 TCP 连接上做文章，利用 TCP 连接来消耗被攻击目标的系统资源。例如，攻击者与被攻击目标完成三次握手后，立刻发送 FIN 或 RST 报文，释放本端连接，同时快速发起新的连接，以此来消耗被攻击目标的系统资源，或者攻击者与被攻击目标完成三次握手后，发送很少的报文来维持连接状态，通过这种异常的 TCP 连接来消耗被攻击目标的系统资源。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.2 基于应用层的资源耗尽攻击（cc）</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">CC 攻击的原理就是攻击者控制某些主机不停地发大量数据包给对方服务器造成服务器资源耗尽，一直到宕机崩溃。CC 主要是用来消耗服务器资源的，每个人都有这样的体验：当一个网页访问的人数特别多的时候，打开网页就慢了，CC 就是模拟多个用户 (多少线程就是多少用户) 不停地进行访问那些需要大量数据操作 (就是需要大量 CPU 时间) 的页面，造成服务器资源的浪费，CPU 长时间处于 100%，永远都有处理不完的连接直至就网络拥塞，正常的访问被中止。以下介绍一些 cc 攻击的常用变种。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（1）基于 HTTP-header 慢速 cc 攻击</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Web 应用在处理 HTTP 请求之前都要先接收完所有的 HTTP 头部，因为 HTTP 头部中包含了一些 Web 应用可能用到的重要的信息。攻击者利用这点，发起一个 HTTP 请求，一直不停的发送 HTTP 头部，消耗服务器的连接和内存资源。抓包数据可见，攻击客户端与服务器建立 TCP 连接后，每 30 秒才向服务器发送一个 HTTP 头部，而 Web 服务器再没接收到 2 个连续的\r\n 时，会认为客户端没有发送完头部，而持续的等等客户端发送数据。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（2）基于 HTTP-body 慢速 cc 攻击</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">攻击者发送一个 HTTP POST 请求，该请求的 Content-Length 头部值很大，使得 Web 服务器或代理认为客户端要发送很大的数据。服务器会保持连接准备接收数据，但攻击客户端每次只发送很少量的数据，使该连接一直保持存活，消耗服务器的连接和内存资源。抓包数据可见，攻击客户端与服务器建立 TCP 连接后，发送了完整的 HTTP 头部，POST 方法带有较大的 Content-Length，然后每 10s 发送一次随机的参数。服务器因为没有接收到相应 Content-Length 的 body，而持续的等待客户端发送数据。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（3）基于 HTTP-read 慢速 cc 攻击</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">客户端与服务器建立连接并发送了一个 HTTP 请求，客户端发送完整的请求给服务器端，然后一直保持这个连接，以很低的速度读取 Response，比如很长一段时间客户端不读取任何数据，通过发送 Zero Window 到服务器，让服务器误以为客户端很忙，直到连接快超时前才读取一个字节，以消耗服务器的连接和内存资源。抓包数据可见，客户端把数据发给服务器后，服务器发送响应时，收到了客户端的 ZeroWindow 提示（表示自己没有缓冲区用于接收数据），服务器不得不持续的向客户端发出 ZeroWindowProbe 包，询问客户端是否可以接收数据。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">剖析其原理，本质上还是对任何一个开放了 HTTP 访问的服务器 HTTP 服务器，先建立了一个连接，指定一个比较大的 content-length，然后以非常低的速度发包，比如 1-10s 发一个字节，然后维持住这个连接不断开。如果客户端持续建立这样的连接，那么服务器上可用的连接将一点一点被占满，从而导致拒绝服务。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.3&nbsp;基于端口发起的渗透测试</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">IP 和端口作为应用暴露在公网的唯一入口，攻击者通常发起渗透测试的起点便是通过扫描目标 IP 上的开放端口来发现系统的漏洞、薄弱点或安全隐患。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">往往服务器系统本身或引入的应用服务就具备一定的脆弱性，攻击者获取到目标服务器的端口列表后会逐一去比对自己的武器库进行漏洞利用尝试。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以下是整理的常见端口利用清单及攻击利用方式：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.787962962962963" data-s="300,640" src="https://oscimg.oschina.net/oscnet/ffff7d43-b2d6-4387-8509-ca5522e4afd4.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">图 3 常见的端口利用清单</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>三、基于端口利用的案例</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;"><strong>Equifax 数据泄露案落幕：七亿赔款，索赔期限延长四年</strong></p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6046511627906976" data-s="300,640" src="https://oscimg.oschina.net/oscnet/67512766-7039-4567-9399-288fd0ae5076.jpg" data-type="jpeg" data-w="860" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;letter-spacing: 0.034em;color: rgb(136, 136, 136);">图 4 EQUIFAX （图片来源：<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fglobalnews.ca%2F" textvalue="globalnews.ca" linktype="text" imgurl="" tab="outerlink" data-linktype="2">globalnews.ca</a>）<br></span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">2017 年 9 月，Equifax 系统遭到黑客攻击，导致超过 1.45 亿美国消费者的个人信息，以及 1520 万英国居民的记录和 8000 名加拿大用户的数据遭到泄露，其中包括姓名、地址、出生日期、身份证号、护照、驾照、信用卡等信息。事件曝光后，Equifax 股票暴跌 30%，相当于蒸发掉 50 亿美元市值，成为史上罕见大型数据泄露事件之一。2018 年 12 月，美国国会众议院的政府改革暨监督委员会发布报告指出，因 Equifax 公司组织架构的缺陷，导致公司部门间的沟通失效，从而致使大量的关键系统补丁没有被及时开发，其中包括一个超 19 个月未做更新的漏洞。最终，黑客对 Equifax 进行了长达 76 天的攻击，先后 265 次从公司获取未被加密的数据。该事件最初是由于 Equifax 未修补针对 Apache Struts 的漏洞而导致的，攻击者利用该漏洞访问了 Equifax 的数据库，这个漏洞是通过开放的 80 端口进行攻击的。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;"><strong>爱尔兰国家医疗保健局数据泄露事件</strong></p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6926829268292682" data-s="300,640" src="https://oscimg.oschina.net/oscnet/e6de8c64-5e42-4524-9573-34df37515805.jpg" data-type="jpeg" data-w="615" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">图 5 爱尔兰衞生部&nbsp;</span></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">（图片来源：<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sohu.com%2Fa%2F480716983_121123851" textvalue="https://www.sohu.com/a/480716983_121123851" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.sohu.com/a/480716983_121123851</a>）</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">爱尔兰国家医疗保健局（HSE）是负责为爱尔兰居民提供医疗保健的机构。在 2021 年 5 月，该机构发生了一起数据泄露事件，影响到数百万个患者的个人信息。该事件起因于攻击者通过暴露的 VPN 服务端口进行攻击，成功登录了 HSE 的 IT 系统。接着，攻击者开始利用系统漏洞，并最终获取了 HSE 服务器的管理员权限。攻击者随后将一个 WastedLocker 勒索软件的恶意代码安装在服务器上，并要求赎金以释放数据。在攻击过程中，攻击者还利用了 HSE 的 Exchange 电子邮件系统，以及 HSE 员工用于管理患者信息的软件系统。这些系统中的漏洞使得攻击者能够访问和窃取大量患者的个人信息，包括姓名、出生日期、地址、电话号码、诊断信息和病历等。据称，该事件涉及到的患者数量达到了数百万。HSE 在发现事件后，立即关闭了受影响的系统，并采取措施保护患者数据的安全。HSE 还与执法部门和网络安全专家合作，以追查攻击者的身份和追回数据。截至目前，尚未有人或组织宣称对此次攻击负责。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>四、端口风险防护及治理实践</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.1&nbsp;端口风险防护</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">无论是 Flood 还是 cc 防护，一般都是借助一些安全设备及安全设备提供的策略定制能力，流量级的可以依靠运营商提供的抗 D 服务，如云盾、云堤，流量清洗服务等，面向应用层的攻击可以借助防火墙，WAF，NIDS 等安全设备/节点提供的能力。无论是借助厂商还是自身建设抗 D 能力，<strong>都需要摸清企业所面临的资源耗尽风险，一方面理清基础架构的脆弱点，治理脆弱点；另一方面需要熟悉攻击利用原理，制定针对性策略来进行异常检测及攻击缓解。</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">这里简述一些对抗思路，例如上文提到 SYN Flood 攻击，其本质上是利用 TCP 建立链接的机制漏洞，只要持续发送建立链接请求，服务端就会进行响应同时在连接池里记录一条链接，那么依据该原理，防护思路就很明确了：</p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;"><strong>1. 对发起源进行主动认证</strong></p><p style="text-wrap: wrap;"><strong><br></strong></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.5030549898167007" data-s="300,640" src="https://oscimg.oschina.net/oscnet/4f91784c-a5bc-44b3-874a-575b58e44aa2.png" data-type="png" data-w="982" style="font-size: 15px;letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="color: rgb(136, 136, 136);font-size: 14px;">图 6 主动认证示意图</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>当连续一段时间内去往目标服务器的 SYN 报文超过告警阈值后，抗 DDoS 设备启动源认证机制。源认证机制启动后，抗 DDoS 设备将会代替服务器向客户端响应带有正确确认序号的 SYN-ACK 报文；</p></li><li><p>如果这个源是虚假源，是一个不存在的地址或者是存在的地址但却没有发送过 SYN 报文，不会做出任何响应；</p></li><li><p>如果这个源是真实客户端，则会向服务器发送 ACK 报文，对收到的 SYN-ACK 报文进行确认。抗 DDoS 设备收到 ACK 报文后，将该客户端的源 IP 地址加入白名单。同时，抗 DDoS 设备会向客户端发送 RST 报文，要求重新建立连接；</p></li><li><p>后续这个客户端发出的 SYN 报文命中白名单直接通过。</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;首包丢弃</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.0574074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/afd85ac0-8ab8-4f3c-874c-b655dcb18041.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="color: rgb(136, 136, 136);font-size: 14px;">图 7 首包丢弃示意图</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">TCP 的可靠性保证除了面向连接（三次/四次握手）之外，还体现在超时与重传机制。TCP 协议规范要求发送端每发送一个报文，就启动一个定时器并等待确认信息；如果在定时器超时前还没有收到确认，就会重传报文。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">首包丢弃功能就是利用了 TCP 的超时重传机制，Anti-DDoS 系统对收到的第一个 SYN 报文直接丢弃，然后观察客户端是否重传。如果客户端重传了 SYN 报文，再对重传的 SYN 报文进行源认证，即反弹 SYN-ACK 报文，这样就可以大大减少反弹报文的数量。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>混合使用，效果更佳</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">实际部署时，一般将首包丢弃和源认证结合使用。防御 SYN Flood 攻击时，先通过首包丢弃功能来过滤掉一些攻击报文，当重传的 SYN 报文超过告警阈值后，再启动源认证。这样就能够减少反弹的 SYN-ACK 报文的数量，缓解网络拥塞情况。对于虚假源攻击，尤其是对于不断变换源 IP 和源端口的虚假源攻击，可以达到最佳防御效果。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>针对连接耗尽场景，其防御思路可以总结为以下内容：</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">针对此攻击会耗尽服务器的 TCP 连接资源的特点，对目的 IP 地址的新建连接速率和并发连接数分布进行统计，当新建连接速率或并发连接数大于阈值时，则触发对源 IP 地址的相应检查，当检查发现异常时，将异常源 IP 地址加入黑名单，切断其 TCP 流量。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>源 IP 地址新建连接速率检查：启动源 IP 地址新建连接速率检查后，如果某个源 IP 地址在检查周期内发起的 TCP 新建连接数大于阈值，则将该源 IP 地址判定为攻击源。</p><p><br></p></li><li><p>源 IP 地址并发连接数检查：启动源 IP 地址并发连接数检查后，如果某个源 IP 地址的 TCP 并发连接数大于阈值，则将该源 IP 地址判定为攻击源。</p><p><br></p></li><li><p>慢速连接速率检查：启动慢速连接速率检查后，统计同一源 IP 地址对同一目的 IP 地址的连接次数，在各统计时间间隔内，如果连续多次连接数相同并超过阈值，则判定为 TCP 慢速连接攻击。</p><p><br></p></li><li><p>异常会话检查：如果在检查周期内，某个源 IP 地址发起的 TCP 异常会话的连接数大于阈值时，则将该源 IP 地址判定为攻击源。</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">判定 TCP 异常会话依据如下：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>【空连接检查】：如果在检查周期内，在某条 TCP 连接上通过的报文数小于阈值，则判定该连接为异常连接。</p></li><li><p>【重传会话检查】：当某条 TCP 连接上重传报文数量大于阈值时，则判定该连接为异常连接。</p></li><li><p>【慢启动连接检查】：当某条 TCP 连接上通过的报文窗口小于阈值时，则判定该连接为异常连接。</p></li><li><p>当异常会话数超过一定数量时，将此源加入黑名单。异常会话数量可配置。</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>同样的，应用层 CC 攻击，按照相对应的原理进行内容检查，这也是一般 WAF 或 NIDS 设备提供的基础能力，这里就不再累述。</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.2&nbsp;端口风险治理实践</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">上段内容有提到的防护思路，理解协议的脆弱性原理再依据攻击者的视角进行防护措施的定制，则会有比较清晰的防护思路和防护效果，因此在端口安全治理实践上，我们通过建立常态化端口发现机制以及常态化的漏洞扫描机制，将网络端口及端口漏洞风险进行持续统一治理，同时建立基于流量的异常识别能力丰富基于行为的异常端口检测能力，再辅以脆弱性管理以及端口生命周期管理（规范与流程）来形成整个端口安全治理体系。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 建立常态化的端口发现机制</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">使用网络发现工具进行异常端口识别，设计思路是首先通过 vscheduler 中间件触发扫描（支持两种模式：一网段配置表全表网段扫描、二是：指定网段扫描。），调用扫描工具（以 nmap 为例）进行扫描，通过增加两个异步线程去读取缓冲区内容以解决缓冲区拥塞问题，通过异步线程进行缓冲区内容读取以及清理的同时通过错误缓冲区内容判断是否扫描失败。扫描结果输出 xml 后通过 dom4j 进行解析，再进行分批保存，避免大事务以及减少 jvm 内存占用。最后把文件删除，释放存储空间。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.34629629629629627" data-s="300,640" src="https://oscimg.oschina.net/oscnet/70667ba7-7a93-43b8-9c41-cca278403648.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">图 8 端口扫描架构图</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;建立常态化漏洞扫描机制</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">结合漏洞扫描工具及端口扫描工具构建自动化漏洞扫描平台，漏扫平台架构设计思路如下图：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6351851851851852" data-s="300,640" src="https://oscimg.oschina.net/oscnet/090f99ff-bff8-4792-9c61-7362919ce184.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="color: rgb(136, 136, 136);font-size: 14px;">图 9 漏扫平台架构图</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">该系统架构的核心功能点包括：资产收集、Web 漏洞扫描、依赖包扫描、端口扫描，辅助功能包括：扫描任务管理、风险管理等。</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>【资产收集】：</p></li><li><p>扫描的目标是公司的网络资产，没有资产无法进行扫描，资产不全面扫描的效果也会打折扣，所以平台采集了多种途径进行资产的采集，力求做到无遗漏，持续丰富采集的手段。</p></li><li><p>【Web 漏洞扫描】：</p><p>用于发现暴露在公网的站点、URL 等 Web 资源是否存在漏洞。<br></p></li><li><p>【依赖包扫描】：</p><p>用于发现线上业务是否使用了高危的 Java 依赖包。</p></li><li><p>【端口扫描】：</p><p>用于发现公司服务器是否对公网开放了高危端口。</p></li><li><p>【扫描任务管理】：</p><p>无论是依赖包扫描、端口扫描，都是通过创建扫描任务的形式来发起的，扫描任务分为立即扫描任务和定时扫描任务两种类型，用户可以创建立即扫描任务来一次性执行扫描，也可以创建定时任务来周期性执行扫描。</p></li><li><p>【风险管理】：</p><p>对于扫描出来的 Web、依赖包和端口风险，系统能够对其处理状态进行管理，以便安全工程师对风险状态进行跟踪和处理。</p></li><li><p>【工单管理】：</p><p>对于扫描出来的 Web、依赖包和端口风险，运营人员可对其创建工单，工单会对接到漏洞管理系统，通过漏洞管理系统的工单体系来对跟踪风险的处理进程。</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">常用的漏扫工具：</p><section style="font-size: 15px;line-height: 1.5;"><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>【Nmap】：</p><p>Nmap 是一款常用的网络发现和安全审计工具，支持多种扫描技术和扫描选项，可以快速扫描本地或远程计算机上的开放端口和服务。</p></li><li><p>【Masscan】：</p><p>Masscan 是一款高速的端口扫描工具，可以在短时间内扫描数百万个端口，支持 TCP 和 UDP 扫描，适用于大规模网络扫描。</p></li><li><p>【Zenmap】：</p><p>Zenmap 是 Nmap 的图形用户界面（GUI）版本，可以方便地进行扫描选项配置和结果分析。</p></li><li><p>【Angry IP Scanner】：</p><p>Angry IP Scanner 是一款轻量级的端口扫描工具，支持多线程扫描和快速扫描本地网络和远程主机。</p></li><li><p>【SuperScan】：</p><p>SuperScan 是一款 Windows 平台上的端口扫描工具，支持 TCP 和 UDP 扫描、多线程扫描、服务版本识别等功能。</p></li><li><p>【Unicornscan】：</p><p>Unicornscan 是一款高速的网络扫描工具，支持 TCP、UDP、ICMP 等多种扫描方式和扫描选项。</p></li><li><p>【Netcat】：</p><p>Netcat 是一款多功能的网络工具，其中包括端口扫描功能，支持 TCP 和 UDP 扫描，可以快速扫描本地或远程计算机上的开放端口和服务。</p></li></ul></section></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>3.&nbsp;建立基于流量的异常识别能力</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（1）流量基线学习</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">流量基线一般对五元组进行配置学习，通过对比应用流量基线，发现孤立的端口流量，对比端口开放库以发现异常开放的端口，另外，可以同步建设告警能力与处置能力，在发现异常的第一时间切断风险源头。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.5585106382978723" data-s="300,640" src="https://oscimg.oschina.net/oscnet/7a8242ee-8c70-4d47-8f96-d25e0bc636ca.png" data-type="png" data-w="752" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">图 10 基线学习</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">流量基线学习的核心表：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>【策略快照表】：</p><p>从离线同步过来的每个小时的服务维度的多种策略计算结果</p></li><li><p>【学习配置表】：</p><p>用于存放学习配置，包括各种策略的加解锁条件（偏离阈值+次数）、偏离告警条件（偏离阈值+次数，可以预留出来，告警下迭代做）</p></li><li><p>【当前策略集】：</p><p>服务维度自定义的的策略集</p></li><li><p>【策略状态表】：</p><p>记录各个服务节点的锁状态，偏离情况，策略生效时间等</p></li><li><p>【策略目标集】：</p><p>部分策略拥有自己的目标机器/服务结算逻辑，该表用于存放目标范围，用于定时清理不在目标集的策略</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）异常检测</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通过对上节提到的流量基线结果的数据分析来识别网络个体或群体的异常行为，一方面建立行为偏离预警机制，另一方面需要引入一些统计分析模型帮助建立阈值点，在偏离预警机制这块我们做了一些架构实践，其逻辑简单描述如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6716981132075471" data-s="300,640" src="https://oscimg.oschina.net/oscnet/94966a61-a614-46b5-8441-05525442a106.jpg" data-type="jpeg" data-w="795" style="" referrerpolicy="no-referrer"></p><p><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">行为偏离比对逻辑：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.42362002567394097" data-s="300,640" src="https://oscimg.oschina.net/oscnet/89ad5fbd-82ed-46d0-9ebc-a7dcfd769801.png" data-type="png" data-w="779" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">总结四个关键点分别为：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><strong>配置文件</strong>，用于描述对应服务的流量特征</p></li><li><p><strong>上锁</strong>，参数或配置文件在满足预设规则条件下或人工干预下停止动态学习行为</p></li><li><p><strong>解锁</strong>，参数或配置文件在满足预设规则条件下或人工干预下重新开始动态学习行为</p></li><li><p><strong>偏离</strong>，指同一服务下某一时间切片的配置文件与已上锁的配置文件的参数值对比，发生超过阈值的变化</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">此外便是阈值的设定问题，通过引入统计模型的使用来帮助我们制定阈值，常用的入侵检测统计模型有以下几类：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><strong>操作模型</strong>：该模型假设异常可通过测量结果与一些固定指标相比较得到，固定指标可以根据经验值或一段时间内的统计平均得到，举例来说，在短时间内多次针对某一端口尝试建立连接失败，则可能是针对端口的拒绝服务</p></li><li><p><strong>方差</strong>：这也是常用的模型，通过计算参数的方差，设定置信区间，当测量值超过置信区间的范围时表明可能存在异常</p></li><li><p><strong>多元模型</strong>：操作模型的扩展，通过同时分析多个参数实现异常检测</p></li><li><p><strong>马尔柯夫过程模型</strong>：将每种类型的事件定义为系统状态，用状态转移矩阵来表示状态的变化，当一个事件发生时，如果状态矩阵中该转移的概率较小则可能是异常事件</p></li><li><p><strong>时间序列分析</strong>：将流量切片特征提取出来按照时间排成序列，如果一个新的请求或一个新的请求集合在该时间发生的概率较低，则该事件可能是异常</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">在异常识别这块通常也会引入基于图的数据分析方法，针对网络个体和网络群体进行流量行为分析来发现异常行为，但应用起来相对较为复杂，也需要较高学习与实践成本，这块更多在 NIDS 的应用范畴，在此模块不再赘述。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">需要提醒的是以上这种方法还是存在一些局限，如爬虫类服务，商业广告类服务因为其服务的特殊性，以上机制比较难进行准确的基线生成，虽说无法解决 100% 的问题，但也能 cover 住大部分的服务类型，同样的，在这个领域还需要持续探索来提升服务类型的覆盖率以及异常检测精度。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>4. 健全脆弱性管理能力实现风险追踪与闭环</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">端口暴露的最核心问题就是脆弱性利用，因此健全基础架构的脆弱性管理能力是阻断外部威胁，有效控制风险的重要手段，我们通过建立统一的脆弱性管理平台来建立业务关系流，脆弱性库，资产三者的关联关系，针对脆弱性做到持续发现，持续修复并将脆弱性作为安全告警关联分析中的重要评价维度。脆弱性管理系统因其安全管理战略特殊性，此处只能简单介绍给读者一些建设思路：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>脆弱性管理系统核心功能模块结构</strong><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.1944444444444444" data-s="300,640" src="https://oscimg.oschina.net/oscnet/1927c6cb-f74d-4bff-ac4b-21a4364a1376.png" data-type="png" data-w="936" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">另外脆弱性关联分析 AVC 是脆弱性管理系统的核心功能，读者可以从以下评价维度进行建设实践：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.47129629629629627" data-s="300,640" src="https://oscimg.oschina.net/oscnet/4effb9d9-df3a-4e35-9085-79d4b7e1ee29.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>5.&nbsp;完善端口生命周期管理（规范与流程）</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（1）制定端口管理规范</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">规范原则</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><strong>最小权限原则</strong>：端口开放遵循最小权限原则，只允许开放运行 http 和 https 的 80/443 端口，其他对外开放的端口必须有合理的业务理由，并且应该只开放业务需要的最小端口集合，由端口使用者提出工作联络单进行申请经审批同意后方可开放。</p></li><li><p><strong>可审计原则</strong>：所有端口开放都必须有可追溯的对应申请依据、安全性评估依据、审批依据，不允许私自开放端口。</p></li><li><p><strong>闭环原则</strong>：端口开放应实施闭环管理，在业务不再需要时，应及时关闭端口。</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">对端口进行明确定义</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.325" data-s="300,640" src="https://oscimg.oschina.net/oscnet/8fa433a8-b65b-4250-93e5-b09f8e6d64d1.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">图 11 端口定义示例</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">规范内容可包含端口申请规范，端口使用规范，端口关闭规范以及明确的处罚规定。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（2）端口生命周期管理</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">实现从端口申请到端口关闭全流程管理</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><p style="text-wrap: wrap;">应用申请 → 端口记录→ 开墙（映射）→ 安全节点纳管 → 流量反馈 → 主动关闭 → 端口映射记录清除→ 安全节点卸载→ 端口资源池回收</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（3）持续评估</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">结合异常端口发现机制和端口开放库以及相关流程建立起持续端口风险评估机制，用以保障规范以及风险处置有效性的落地。</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>五、总结</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">端口作为应用对外暴露的主要入口，是应用暴露在公网上的标识，因此端口安全建设是企业信息安全防护体系中的重要一环，安全团队需要详细了解其内部网络中使用的所有端口，以及开放和关闭的端口数量和情况，在理解协议的脆弱性原理基础上制定合适的安全策略和措施。同时再安全策略和措施制定的过程中，通过对各类端口扫描工具的使用，安全团队可以快速获取目标网络中的端口开放情况。然后根据扫描结果，采取合适的安全策略和措施，禁止不必要端口的开放或者采取过滤、加密等方式对端口进行保护。在技术实践上，建设常态化端口发现机制以及常态化的漏洞扫描机制，将网络端口及端口漏洞风险进行持续统一治理，同时建立基于流量的异常识别能力丰富基于行为的异常端口检测能力，再辅以脆弱性管理以及端口生命周期管理（规范与流程）来形成整个端口安全治理体系。另外值得强调的是，全员网络安全意识的水位决定整体安全态势的下限，个人行为和错误配置通常是网络漏洞的一大原因，因此安全管理团队需要持续加强内部员工的网络安全教育和培训，提高其网络安全意识和知识水平，建立全员参与的安全意识文化。总的来说，可以通过规范，流程，技术和人员意识培训来构建全面的网络端口风险治理体系。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="color: rgb(65, 95, 255);" powered-by="xiumi.us"><p style="text-wrap: wrap;">参考文献：</p></section><section powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><span style="font-size: 14px;">《网络端口安全治理的研究与实践》（姜云飞，高国权，张全超，2019）</span></p></li><li><p><span style="font-size: 14px;">《基于漏洞扫描的网络端口安全治理研究》（黄珂，杨明，张鹏飞，2017）</span></p></li><li><p><span style="font-size: 14px;">《基于流量监测的网络端口安全治理技术研究》（胡彩玲，申伟，周婷婷，2016）</span></p></li><li><p><span style="font-size: 14px;">《网络端口安全治理技术研究》（程显霞，郑晓宁，2014）</span></p></li><li><p><span style="font-size: 14px;">《网络端口安全治理策略研究》（朱绍军，李彦霞，陈琳琳，2013）</span></p></li><li><p><span style="font-size: 14px;">vivo 互联网端口开放管理规范</span></p></li><li><p><span style="font-size: 14px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.csdn.net%2FJackMaF%2Farticle%2Fdetails%2F123676195" textvalue="什么是网络端口？" linktype="text" imgurl="" tab="outerlink" data-linktype="2">什么是网络端口？</a></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2FShepherdzhao%2Fp%2F15219310.html" textvalue="【漏洞分析】DDOS 攻防分析（四）——TCP 篇" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">【漏洞分析】DDOS 攻防分析（四）——TCP 篇</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fkenshinobiy%2Fp%2F10215913.html" textvalue="CC 攻击原理及防范方法和如何防范 CC 攻击&nbsp;" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">CC 攻击原理及防范方法和如何防范 CC 攻击&nbsp;</span></a><span style="font-size: 14px;"></span></p></li><li><p><span style="font-size: 14px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.csdn.net%2Fweixin_50464560%2Farticle%2Fdetails%2F118962399" textvalue="常用的端口攻击" linktype="text" imgurl="" tab="outerlink" data-linktype="2">常用的端口攻击</a></span></p></li><li><p><span style="font-size: 14px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fforum.huawei.com%2Fenterprise%2Fzh%2Fthread%2F580895552575520769" textvalue="TCP 连接耗尽攻击与防御原理" linktype="text" imgurl="" tab="outerlink" data-linktype="2">TCP 连接耗尽攻击与防御原理</a></span></p></li><li><p><span style="font-size: 14px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.freebuf.com%2Farticles%2Fnetwork%2F258061.html" textvalue="DDOS 之 TCP 连接耗尽攻击与防御" linktype="text" imgurl="" tab="outerlink" data-linktype="2">DDOS 之 TCP 连接耗尽攻击与防御</a></span></p></li></ol><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;"><section style="text-align: center;color: rgb(45, 66, 87);font-size: 11px;" powered-by="xiumi.us"><p>END</p></section></section><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: left;" powered-by="xiumi.us"><section style="padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;"><span style="display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);" title="" opera-tn-ra-cell="_$.pages:0.layers:0.comps:224.title1"><p>猜你喜欢</p></span></section><section style="border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;"><section style="font-size: 14px;text-align: left;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497432%26idx%3D1%26sn%3Df372c83043de8da859cec802976e371a%26chksm%3Debdb864adcac0f5cf753444f2c9198b08d6b0831e66e4b5b6405a1eaa32e53b8747aa9dc1217%26scene%3D21%23wechat_redirect" textvalue="Dubbo 路由及负载均衡性能优化" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">Dubbo 路由及负载均衡性能优化</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D1%26sn%3D5795a683e52f70384a13b34aa3daf731%26chksm%3Debdb8632dcac0f2468a461db09d8de6219af346e51436b91e6c946ee8b37e6ae8175b2f5d55e%26scene%3D21%23wechat_redirect" textvalue="深入理解 Netty FastThreadLocal" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">深入理解 Netty FastThreadLocal</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497343%26idx%3D1%26sn%3D959b66ceb9a8c2fe060b6981b41a807e%26chksm%3Debdb86eddcac0ffb229636ec51ec94433af75c7bc58aaa5ae52b4a2bf6a2d6d2ab11583b3174%26scene%3D21%23wechat_redirect" textvalue="记一次 Redis Cluster Pipeline 导致的死锁问题" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">记一次 Redis Cluster Pipeline 导致的死锁问题</a><br></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互联网技术" data-alias="vivoVMIC" data-signature="分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 04 Nov 2023 02:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10140381</guid>
            <link>https://my.oschina.net/vivotech/blog/10140381</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[TypeScript 5.3 RC 发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>TypeScript 5.3 RC 版本现已发布。可以通过 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.nuget.org%2Fpackages%2FMicrosoft.TypeScript.MSBuild" target="_blank">NuGet</a> 获取，或通过 npm 使用以下命令获取：</p><pre><code>npm install -D typescript@rc
</code></pre><p><strong>TypeScript 5.3 中的新特性包括：</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23import-attributes" target="_blank">Import Attributes</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23stable-support-resolution-mode-in-import-types" target="_blank">在 Import Types 中稳定支持<code>resolution-mode</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23resolution-mode-supported-in-all-module-modes" target="_blank"><code>resolution-mode</code>在所有模块模式均受支持</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23switch-true-narrowing" target="_blank"><code>switch (true)</code>Narrowing</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23narrowing-on-comparisons-to-booleans" target="_blank">Narrowing On Comparisons to Booleans</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23instanceof-narrowing-through-symbolhasinstance" target="_blank"><code>instanceof</code><span>&nbsp;</span>Narrowing Through<span>&nbsp;</span><code>Symbol.hasInstance</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23checks-for-super-property-accesses-on-instance-fields" target="_blank">检查对实例字段的 super 属性访问</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23interactive-inlay-hints-for-types" target="_blank">针对类型的交互式嵌套提示 (Interactive Inlay Hints)</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23settings-to-prefer-type-auto-imports" target="_blank">Prefer<code>type</code>Auto-Imports 的设置</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23optimizations-by-skipping-jsdoc-parsing" target="_blank">通过跳过 JSDoc 解析进行优化</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23optimizations-by-comparing-non-normalized-intersections" target="_blank">通过 Comparing Non-Normalized Intersections 进行优化</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23consolidation-between-tsserverlibraryjs-and-typescriptjs" target="_blank">合并<code>tsserverlibrary.js</code>和<code>typescript.js</code></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23breaking-changes-and-correctness-improvements" target="_blank">Breaking Changes 和 Correctness Improvements</a></li></ul><p><strong>自&nbsp;Beta&nbsp;<span><span><span><span><span style="color:#333333"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>版以来的新变化有：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:left">Beta&nbsp;<span><span><span><span><span style="color:#333333"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>版<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23resolution-mode-supported-in-all-module-modes" target="_blank">允许<code>resolution-mode</code>跨模块分辨率设置使用</a>，但并未对此进行记录。自 </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>Beta&nbsp;<span><span><span><span><span style="color:#333333"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>版发布以来，项目团队添加了<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23settings-to-prefer-type-auto-imports" target="_blank">一个选项，在可能的情况下首选</a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F%23settings-to-prefer-type-auto-imports" target="_blank"><code>type</code>-only auto-imports</a><span><span><span><span><span style="color:#333333"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-import-attributes" target="_blank">import attributes</a></u></strong></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">import attributes 的一个用例是向运行时提供有关模块预期格式的信息。</p><pre style="margin-left:0; margin-right:0; text-align:left"><code class="language-javascript"><span style="color:#6a737d">// We only want this to be interpreted as JSON,</span><span style="color:#6a737d">// not a runnable/malicious JavaScript file with a `.json` extension.</span><span style="color:#d73a49">import</span> obj <span style="color:#d73a49">from</span><span style="color:#032f62">"./something.json"</span><span style="color:#d73a49">with</span> { <span style="color:#d73a49">type</span>: <span style="color:#032f62">"json"</span> };</code></pre><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">TypeScript 不会检查这些属性的内容，因为它们是特定于主机的，因此不会对它们进行检查，只是让浏览器和运行时处理它们（可能会出错）。</p><pre style="margin-left:0; margin-right:0; text-align:left"><code class="language-javascript"><span style="color:#6a737d">// TypeScript is fine with this.</span><span style="color:#6a737d">// But your browser? Probably not.</span><span style="color:#d73a49">import</span> * <span style="color:#d73a49">as</span> foo <span style="color:#d73a49">from</span><span style="color:#032f62">"./foo.js"</span><span style="color:#d73a49">with</span> { <span style="color:#d73a49">type</span>: <span style="color:#032f62">"fluffy bunny"</span> };</code></pre><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">动态 import () 调用也可以通过第二个参数使用 import 属性。</p><pre style="margin-left:0; margin-right:0; text-align:left"><code class="language-javascript"><span style="color:#d73a49">const</span> obj = <span style="color:#d73a49">await</span><span style="color:#d73a49">import</span>(<span style="color:#032f62">"./something.json"</span>, {
    <span style="color:#d73a49">with</span>: { <span style="color:#d73a49">type</span>: <span style="color:#032f62">"json"</span> }
});</code></pre><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">第二个参数的预期类型由一个名为<span>&nbsp;</span><code>ImportCallOptions</code><span>&nbsp;</span>的类型定义，默认情况下，该类型只期望调用一个属性<span>&nbsp;</span><code>with</code>。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">请注意，导入属性是从早期的 "导入断言"（import assertions）提案演变而来的，该提案已在 TypeScript 4.5 中实现。最明显的区别是使用了<span>&nbsp;</span><code>with</code><span>&nbsp;</span>关键字而非<span>&nbsp;</span><code>assert</code><span>&nbsp;</span>关键字。但不太明显的区别是，运行时现在可以自由使用属性来指导导入路径的解析和解释，而导入断言只能在加载模块后断言某些特性。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">随着时间的推移，TypeScript 将淘汰旧的导入断言语法，转而使用建议的导入属性语法。使用 assert 的现有代码应迁移到 with 关键字。需要导入属性的新代码应只使用<span>&nbsp;</span><code>with</code><span>&nbsp;</span>关键字。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong><code>switch (true)</code>Narrowing</strong></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">TypeScript 5.3 可以根据<span>&nbsp;</span><code>switch (true)</code><span>&nbsp;</span>中每个<span>&nbsp;</span><code>case</code><span>&nbsp;</span>子句的条件执行 narrowing。</p><pre style="margin-left:0; margin-right:0; text-align:left"><code class="language-javascript"><span><span style="color:#d73a49">function</span><span style="color:#6f42c1">f</span>(<span>x: unknown</span>) </span>{
    <span style="color:#d73a49">switch</span> (<span style="color:#005cc5">true</span>) {
        <span style="color:#d73a49">case</span><span style="color:#d73a49">typeof</span> x === <span style="color:#032f62">"string"</span>:
            <span style="color:#6a737d">// 'x' is a 'string' here</span><span>console</span>.log(x.toUpperCase());
            <span style="color:#6a737d">// falls through...</span><span style="color:#d73a49">case</span><span>Array</span>.isArray(x):
            <span style="color:#6a737d">// 'x' is a 'string | any[]' here.</span><span>console</span>.log(x.length);
            <span style="color:#6a737d">// falls through...</span><span style="color:#d73a49">default</span>:
          <span style="color:#6a737d">// 'x' is 'unknown' here.</span><span style="color:#6a737d">// ...</span>
    }
}</code></pre><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Ftypescript%2Fannouncing-typescript-5-3-rc%2F" target="_blank">查看发布公告</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 04 Nov 2023 02:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264869/typescript-5-3-rc</guid>
            <link>https://www.oschina.net/news/264869/typescript-5-3-rc</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[游戏引擎 Godot 4.1.3 发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Godot 4.1.3 现已<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgodotengine.org%2Farticle%2Fmaintenance-release-godot-4-1-3%2F" target="_blank">发布</a>，共有 76 位贡献者提出了 128 项 pull-request（或 133 次 commits）。Godot 是一个非营利性的开源游戏引擎，由数百名贡献者利用业余时间开发，也有少数兼职或全职开发人员受雇于 Godot 社区的捐助。</span></p><p><span style="color:#000000"><img alt="" height="281" src="https://oscimg.oschina.net/oscnet/up-e95b46d9d794618d76ef3887eeade7270b9.webp" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">v4.1.3 是&nbsp;Godot 4.1 的第三个维护版本，包含了许多针对渲染系统的修复，解决了所有渲染后端、光照贴图和体素全局照明系统以及 GPU 粒子中的问题。编辑器 UI 和引擎 GUI 系统中的各种问题已得到解决，输入团队改进了控制器支持并解决了 Android 平台特有的几个问题。</span></p><p><span style="color:#000000">此外还添加了一个重要的修复程序，以改进对 Android 14 的支持，并修复了其他目标平台上的各种错误。以及纠正了一些文档错误，并且为<code class="language-plaintext">RenderingDevice</code>class 提供了新的文档。</span></p><p>截至目前，与之前的 Godot 4.1.x 版本没有已知的不兼容性。官方鼓励所有用户升级到 4.1.3。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgodotengine.org%2Fdownload%2F" target="_blank"><strong>立即下载 Godot 4.1.3</strong></a>或尝试<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Feditor.godotengine.org%2F4.1.3.stable%2F" target="_blank">在线版本的 Godot 编辑器</a>。</p><p>更多详情可查看官方公告。</p><p><strong>相关阅读：</strong></p><ul><li><a href="https://www.oschina.net/news/258085/godot-developer-fund" target="_blank">游戏引擎项目 Godot 成立开发基金</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Sat, 04 Nov 2023 02:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264867/godot-4-1-3-released</guid>
            <link>https://www.oschina.net/news/264867/godot-4-1-3-released</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[TUI 库开发商 Charm 融资 600 万，打造下一代命令行]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>TUI 库开发商 Charm <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcharm.sh%2Fblog%2Fthe-next-generation%2F" target="_blank">宣布融资 600 万美金</a></u>。Charm 专注于命令行工具开发，目标是让命令行变得充满魅力、功能强大、有趣和现代化。</p><p><img src="https://static.oschina.net/uploads/space/2023/1103/190910_uqZD_2720166.png" referrerpolicy="no-referrer"></p><p>从 Charm 的 GitHub 开源主页看到，其最欢迎的项目均采用 Go 语言开发。</p><p>简单列举几个：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcharmbracelet%2Fbubbletea%23bubble-tea" target="_blank">Bubble Tea</a>：功能强大的轻量级 TUI 框架</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcharmbracelet%2Fgum%23gum" target="_blank">Gum</a>：界面优雅的 Shell 脚本工具</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcharmbracelet%2Fvhs%23vhs" target="_blank">VHS</a>：CLI 录制工具</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcharmbracelet%2Fglow%23glow" target="_blank">Glow</a>：命令行界面 Markdown 渲染工具</li></ul><p><img height="1242" src="https://static.oschina.net/uploads/space/2023/1103/192626_xjM1_2720166.png" width="3114" referrerpolicy="no-referrer"></p><p><em>△&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcharmbracelet" target="_blank">https://github.com/charmbracelet</a></u></em></p><p>Charm 公司认为，在过去的 30 多年里，命令行一直是无处不在的计算平台，部分原因归功于<strong>它是专注于做好一件事的简单工具</strong>，并且能够轻松地将这些工具组合成独特的解决方案，以及有大量的现有命令行程序库可供使用。这些特性与当代互联网及其孤立的数据、缺乏可组合性以及大型、不透明的解决方案形成了鲜明对比，后者往往包含大量的跟踪、广告和其他「黑暗面」。</p><p>在他们看来，命令行是网络和封闭移动平台的健康替代品。当前更新的时机也已经成熟，重点是打造以用户为中心的设计和加密的自托管网络服务。他们希望为下一个 30 年打造命令行平台。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 11:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264838</guid>
            <link>https://www.oschina.net/news/264838</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[数据库国产化，是一门圈钱的生意吗？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>最近两天，技术圈掀起了一场关于数据库国产化的大讨论，国产数据库到底是真自研还是来套壳圈钱的？</p><p><span style="background-color:#ffffff; color:#333333">开源 PG 发行版&nbsp;</span>Pigsty 创始人冯若航在微信公众号「非法加冯」发布的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fvh1JE_BdaLetWtt5vvPDDw" target="_blank">《数据库真被卡脖子了吗？》</a>一文认为，<strong>很多「国产数据库」就是烂泥扶不上墙的残次品。<span style="background-color:#ffffff; color:#3f3f3f">把开源免费的软件包装一下，用 Oracle 的价格卖给你！</span></strong></p><p>「真正自研的数据库出现两极分化：极少数真正有创新贡献与使用价值的产品爱惜羽毛，不会刻意标榜「国产」。而剩下的大多数往往多是闭门造车、技术落后的土法数据库，或者开源古早分叉、负向阉割出来的劣质轮子。国产数据库并非没有踏实做事的好公司，只是「国产」这个标签被大量钻入数据库领域的平庸低劣产品污染。</p><p>「更让人扼腕的是劣币驱逐良币。本已稀缺的数据库研发人力经过这样的挥霍，反而会真正卡死国内数据库产业的脖子。特别是核心的 OLTP/关系型数据库领域因为开源的存在，已经不缺足够好用的内核了。能把 PostgreSQL / MySQL 用好并提供服务支持，远比自欺欺人的大炼内核要有价值的多。」</p><p>冯若航认为，业界已经不缺足够完美的数据库内核了 —— 比如 PostgreSQL，功能完备且开源免费（BSD-Like）。无数」国产数据库「基于 PG 换皮套壳魔改而成。如果说谁在数据库内核上被卡了脖子，那肯定是吃饱了撑着给噎着的。</p><p>但数据库国产化又是必要的，正如微信公众号「白鳝的洞穴」发布的文章<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F1btCxNVkBOirr_O05P__YA" target="_blank">《数据库国产化是在套壳圈钱吗》</a>所言：「<strong>一旦<span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">上了老美的黑名单，你想买 Oracle 人家也不卖了。」</span></strong></p><p><strong>文章还认为，利用国产数据库去圈钱真的有点脑洞太大了。</strong></p><p>「想要圈钱的人，没必要去搞数据库，有大量的可以更好圈钱的项目可以去折腾。我所见到的国产数据库的朋友，大多数还是有些情怀的。就像十年前我见到南大通用当时的董事长崔维力的时候他所说的想干点点天元的事情的时候的感受一样，只有有点情怀的人才会去干这种十分长线的、不知道啥时候能挣着钱的买卖。</p><p>」我认识的朋友中不乏一些在数据库领域中很成功的人，自从入圈自研数据库后，虽然也看到他们几个亿几个亿的融资，不过算下来，这些人干的基本上都是过路财神的活，融来的钱很快就填到无底洞似的研发与营销中了。虽然如此，国产数据库企业的技术人员待遇并不高，除了几家财大气粗，能够长期大投入的企业外，大多数国产数据库企业的研发骨干和管理高层并没有像有些人所想象的那样赚得盆满钵满。圈钱之说其实是不成立的，我看到的反而，是有不少国产数据库的从业人员十年清贫，依然痴心不改。这种人哪怕我们不去尊重，也没必要去诋毁他们。」</p><p>去 IOE 已经说了很多年了，真要操作起来，不光是嘴上喊喊口号的事。薛晓刚在其公众号」四海内皆兄弟「发文<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Feetz1aAfa_oogr9keAjJbg" target="_blank">《替换数据库的代价与真假国产》</a>认为，<strong>从开发、运维以及成本的角度来看，放弃 Oracle，替换成国产数据库并不容易。</strong></p><p>」国产也有好的，可能只占少数吧。这些集中在 2016 年以前从事这个行业的，那可能是真的做。就是这个不被看好的时候就做的是还可以的，最起码不是骗人的。至于做的好坏另说啊。总之不是在有了政策之后才冒出来的抢钱就行。但凡是大家一窝蜂的去做的，基本就是乱来了。</p><p>」<span style="background-color:#ffffff; color:#000000">日常我看到不少手机用苹果的，笔记本用 MAC 的，开着特斯拉或者用 IPad 的，对我说要替换某某国产数据库</span>。这些人可能不参与开发，不参与运维，不参与采购，属于站着说话不腰疼的。这些成本谁出？出了问题你上不？不少人连锁是什么都搞不清楚就来说数据库选型这不是外行指挥内行吗？「</p><p><strong>关于数据库国产化替代，你觉得有必要吗？至于国产化的路子，应该重新开发数据库内核，还是基于现有开源数据库搞国产化？数据库自研与否，其实并不难分辨，为什么还会出现那么多圈钱的企业？在评论区留下你的看法吧~</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 11:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/3859945/blog/10140824</guid>
            <link>https://my.oschina.net/u/3859945/blog/10140824</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[KubeEdge-Ianvs v0.2 发布：终身学习支持非结构化场景]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>本文分享自华为云社区《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%2F414430%3Futm_source%3Doschina%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent" target="_blank" rel="nofollow">KubeEdge-Ianvs v0.2 发布：终身学习支持非结构化场景</a>》，作者： 云容器大未来。</p><p>在边缘计算的浪潮中，AI 是边缘云乃至分布式云中最重要的应用。随着边缘设备的广泛使用和性能提升，将人工智能相关的部分任务部署到边缘设备已经成为必然趋势。KubeEdge-Ianvs 子项目，作为业界首个分布式协同 AI 基准测试平台，基于 KubeEdge-Sedna 为算法及服务开发者提供全场景可扩展的分布式协同 AI 基准测试，以研发、衡量和优化分布式协同 AI 系统。</p><p>然而在边缘设备中部署静态的 AI 模型往往不足以应对复杂多变的真实世界环境，因此终身学习能力对于边缘 AI 模型来说变得越来越重要。为了方便边缘 AI 算法研究者开发及测试终身学习算法在真实世界环境中的效果，KubeEdge-Ianvs 在新版本的更新中发布了支持终身学习范式的相关算法的研发与测试功能。</p><p>本篇文章为大家阐释相关<strong>背景</strong>和<strong>Ianvs 终身学习架构</strong>，并<strong>以 Ianvs 云机器人终身学习测试</strong>为例对 Ianvs 终身学习的特性进行介绍。欢迎关注 Ianvs 项目，持续获得第一手独家公开数据集与完善基准测试配套。</p><p>开源项目 GitHub 地址：https://github.com/kubeedge/ianvs</p><span id="OSC_h1_1"></span><h1>一、背景</h1><span id="OSC_h2_2"></span><h2>1.1 终身学习能力对边缘模型越来越重要</h2><p>边缘设备所处的环境通常是不稳定的，环境变化会导致数据分布的大幅变化，即数据漂移。数据漂移会显著降低模型准确性。为了解决数据漂移问题，边缘设备需要具备动态更新模型的能力，以适应环境变化。下图展示了一个典型的终身学习算法流程框架。在该框架中，终身学习任务被定义为：已处理 N 个任务，将陆续处理 M 个任务。如何维护知识库并利用其中的模型处理这些任务是关键。</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/28/28a09244308b8b649ede40334d8c9c5d.png" referrerpolicy="no-referrer"></p><p>终身学习的流程分为四步，首先根据之前已处理的 N 个任务初始化云端的知识库中的已知任务处理模型；然后在遇到新的任务时，从云端知识库中选取合适的模型部署到边缘端处理任务，如果新任务是已知的任务则更新原来的模型，如果遇到了未知任务则重新训练新的模型用于处理该任务；在边缘端处理好该任务后，对云端知识库进行更新；最后遇到新任务时重复前两步操作。通过以上流程可以确保边缘部署的模型具备终身学习的能力，从而可以应对数据漂移等问题带来的影响。</p><span id="OSC_h2_3"></span><h2>1.2 业界缺少合适的终身学习测试工具</h2><p>目前终身学习算法相关测试工具发展较慢，目前比较成熟的测试工具只有 ContinualAI 推出的 Avalanche。Avalanche 支持的特性如下：</p><p>&nbsp;</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/92/92b1cb696aac2abe74896dc16aeefc09.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>Avalanche 支持的特性非常丰富，但是对于终身学习算法开发者来说 Avalanche 还存在一些局限性：</p><p>&nbsp;</p><ul><li><strong>未能覆盖终身学习全生命周期算法</strong>：支持的场景主要局限于增量学习等场景，而终身学习中任务定义、分配以及未知任务识别等流程无法体现在该 benchmark 中。</li><li><strong>缺乏配套真实世界数据集</strong>：配套的数据集主要包括 Split-MNIST、Cifar10 等学术界常用的玩具测试集，缺乏适用的真实世界数据集及配套算法。</li><li><strong>研发算法难以落地</strong>：Avalanche 更多面向终身学习算法的测试实验，并没有考虑未来将算法落地部署的需求。</li></ul><p>&nbsp;</p><div><p>因此目前业界亟需一个更好的终身学习测试 benchmarking 工具，Ianvs 发布的非结构化终身学习新特性可以很好的解决上述问题。</p><span id="OSC_h1_4"></span><h1>二、lanvs 终身学习架构</h1><span id="OSC_h2_5"></span><h2>2.1 Ianvs 终身学习优势</h2><p>终身学习近年来得到了越来越多的关注，越来越多的边缘智能从业者认识到了终身学习的重要性。但是终身学习相比其他 AI 算法来说有着更高的研究门槛，经过我们的调研发现终身学习研发存在<strong>模型训练流程复杂、算法效果难以衡量</strong>和<strong>算法落地应用困难</strong>三大挑战。</p><p><strong>第一个挑战是终身学习模型训练流程较为复杂</strong>，比如对于一个刚入门终身学习的同学来说，可能对终身学习算法流程中的未知任务识别模块比较感兴趣，但是要想完整实现终身学习还需要填补任务定义、任务分配等模块，而这对于刚入门的同学不太友好，想复现别人的工作还需要去额外完成其他终身学习模块。</p><p>针对这一挑战，KubeEdge-Ianvs 中对终身学习全生命周期的各个模块都进行了设计，包括并不限于任务定义、任务分配、未知任务识别和未知任务处理等多个终身学习核心算法模块，各个模块之间是解耦合的，用户可以只研究自己感兴趣的模块，其他模块采用默认配置即可跑通终身学习实验。</p><p><strong>第二个挑战是终身学习算法效果衡量困难</strong>，不同论文中的终身学习算法由于其测试流程不一样难以比较其工作的优劣。同时大部分论文的工作都是在 MNIST、CIFAR10 这些非真实数据集上进行的实验，由于缺乏在真实世界数据集上的测试，算法在现实世界中的实际应用效果往往要大打折扣。</p><p>针对这一挑战，KubeEdge-Ianvs 中对终身学习的测试流程进行了统一，提供 BWT、FWT 等公认的终身学习系统指标，方便衡量算法效果。同时 KubeEdge-Ianvs 开源了 Cloud-Robotics 等真实世界终身学习数据集，并配套了对应的运行样例，用户可以直接开箱使用该真实世界数据集测试自己提出的算法的效果。</p><p><strong>第三个挑战是终身学习算法落地较为困难</strong>，算法研发与实际部署之间存在一定鸿沟。用户训练好的模型需要进一步封装才能实际在生产环境上使用。</p><p>针对这一挑战，KubeEdge-Ianvs 在开发时就考虑到了和其姊妹项目 KubeEdge-Sedna 开源服务平台是配套兼容关系，因此在 KubeEdge-Ianvs 上研发的终身学习算法可以直接迁移到 KubeEdge-Sedna 平台上实现落地部署，解决了从研发到落地最后一公里的问题。</p><p>总而言之，Ianvs 终身学习优势包括：</p><ul><li><p><strong>覆盖终身学习全生命周期</strong>，包括任务定义、任务分配、未知任务识别和未知任务处理等多个模块，各个模块是解耦合的；</p></li><li><p><strong>统一化的测试流程</strong>，系统内置权威的终身学习测试指标，并且支持测试结果的可视化；并提供真实世界数据集用于终身学习测试，能更好测试终身学习算法在真实环境的效果；</p></li><li><p><strong>和</strong><span>&nbsp;</span><strong>KubeEdge-Sedna 终身学习相兼容</strong>，研发算法可以快捷迁移到 Sedna 上实现落地部署。</p></li></ul><span id="OSC_h2_6"></span><h2>2.2 Ianvs 终身学习新特性</h2><p>Ianvs 在去年发布的 0.1.0 版本中已具备支持单任务学习范式和增量学习范式的算法研发与测试，在新版的 Ianvs 中增加了支持对终身学习范式的相关算法的研发与测试的功能，同时也为终身学习算法测试提供了新的开源数据集。主要新特性如下：</p><span id="OSC_h3_7"></span><h3>特性一：覆盖终身学习全生命周期</h3><p>Ianvs 终身学习具体架构如下图所示，主要包括任务定义、任务分配、未知任务识别和未知任务处理等模块，覆盖终身学习全生命周期。</p><p>&nbsp;</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/60/6050b9d43e911475220f06f46c31a403.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>对于已处理任务，Ianvs 通过任务定义模块，将已知任务抽象成若干个模型存储进云端知识库中。在遇到新任务时，Ianvs 首先通过未知任务识别模块判断推理样本属于未知任务还是已知任务。若是已知任务，则从云端知识库中调度对应模型部署在边侧处理该任务，同时基于已知任务样本对模型进行增量更新。若是未知任务，则 Ianvs 通过未知任务处理模块处理该任务，利用外部系统标注并重新训练新的模型用于处理该任务。处理完成后，新的任务模型或是更新后的已知任务模型再重新整合至云端知识库中。</p><p>为了方便初学者使用 Ianvs，在 Ianvs 仓库中的 examples/robot/ 文件夹下提供了一个可以直接运行的样例 https://github.com/kubeedge/ianvs/examples/robot/ ， 详细的教程在第三节。</p><span id="OSC_h3_8"></span><h3>特性二：统一化的测试流程和真实世界数据集</h3><p>Ianvs 对终身学习测试流程进行了统一，主要参考了 NIPS2017 的论文 「Gradient Episodic Memory for Continual Learning」，复现了其中提出的 BWT 和 FWT 指标，用于评价终身学习算法的抗遗忘能力和未知任务泛化能力。</p><p>Ianvs 还开源了 Cloud-Robotics 等真实世界数据集，并提供了配套的可以开箱即用的实验代码，帮助用户快速上手 Ianvs 终身学习。</p><p>数据集官网链接：https://kubeedge-ianvs.github.io/</p><p><img src="https://static001.geekbang.org/infoq/1e/1e8f57b13470035bc9206eb90fe80ec0.png" referrerpolicy="no-referrer"></p><span id="OSC_h3_9"></span><h3>特性三：支持快捷落地部署</h3><p>如下图所示，Ianvs 中终身学习算法实现的组件与 Sedna 上终身学习算法实现的组件是相兼容的，因此在 Ianvs 上研发测试的算法可以无障碍迁移部署到 Sedna 上，方便相关从业人员实地部署算法。</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/91/913df4ee6292b224808ec6b3e7e3032f.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_10"></span><h1>三、lanvs 终身学习快速教，程</h1><p>在这章中我们通过运行 Ianvs 终身学习的 cloud-robotics 样例向大家讲解 Ianvs 终身学习的基本流程。Ianvs 安装流程以及终身学习更详细的介绍可以参考：Ianvs-lifelong-learning-tutorial</p><p>相关链接：https://ianvs.readthedocs.io/en/latest/</p><p>1）首先我们需要配置好 Cloud-Robotics 的数据集，先创建数据集的文件夹，注意如果你把数据集放到别的位置，本教程中的部分路径配置也要一并修改。</p><blockquote><p>mkdir /data</p><p>&nbsp;</p><p>cd /data</p><p>&nbsp;</p><p>mkdir datasets</p><p>&nbsp;</p><p>cd datasets</p></blockquote><p>Cloud-Robotics 数据集可以根据该数据集专属网站的指示操作获得，链接：https://kubeedge-ianvs.github.io/download.html</p><p>2）下载完成后解压数据集：unzip cloud-robotics.zip</p><p>3）配置好数据集后，我们可以准备运行示例代码了。Cloud-Robotics 示例运行的代码放在 /ianvs/project/ianvs/examples/robot/lifelong_learning_bench/ 下，我们首先要配置 python 路径（这里如果 Ianvs 安装位置不一样的话需要更改路径）：</p><blockquote><p>export PYTHONPATH=$PYTHONPATH:/ianvs/project/ianvs/examples/robot/lifelong_learning_bench/testalgorithms/rfnet/RFNet</p></blockquote><p>4）然后我们检查一下 yaml 文件的信息：</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/4d/4dafcc020a4950e7bd1c6505e75cf829.png" referrerpolicy="no-referrer"></p><p>5）上图 benchmarkjob.yaml 中 workplace 是存放模型训练输出的路径，可以改成你需要的路径。</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/ae/aebaf7029f5459ef0e0e4458cff0d8b8.png" referrerpolicy="no-referrer"></p><p>6）上图 testenv-robot.yaml 中 train_url 和 test_url 是数据集索引的路径，如果你的数据集存放位置和教程不一样，则需要修改 train_url 和 test_url 的路径。</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/da/da7c61c3e5bd4110f1bb82f3110c86d8.png" referrerpolicy="no-referrer"></p><p>7）在上图 rfnet_algorithm.yaml 中可以根据你的需求添加测试的<strong>终身学习算法</strong>，比如任务定义、任务分配等算法。本样例中提供了一个简单的示例。</p><p>8）其他的配置文件暂时没有需要调整的。接下来我们就可以运行示例代码了：</p><pre>cd /ianvs/project/ianvs
ianvs -f examples/robot/lifelong_learning_bench/benchmarkingjob.yaml</pre><p><img alt="图片" src="https://static001.geekbang.org/infoq/90/9089fecf78972336f37aaf91c5c30e8a.png" referrerpolicy="no-referrer"></p><p>在模型终身学习任务结束后你可以看到以下内容，包括 BWT、FWT 等终身学习系统衡量指标：</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/6a/6a86722ddf7ffdf6e21531931fd3c9e6.png" referrerpolicy="no-referrer"></p><p>9）出现以上显示结果，则成功跑通了一个 Ianvs 终身学习样例！</p><p>如果读者对于本次版本发布的更多细节感兴趣，欢迎查阅 Ianvs v0.2 Release Note：https://github.com/kubeedge/ianvs/releases/tag/v0.2.0</p><p>后续 KubeEdge SIG AI 将发布系列文章，陆续具体介绍终身学习全面升级的特性，欢迎各位读者继续关注社区动态。</p><span id="OSC_h3_11"></span><h3>相关链接</h3><p><strong>[1]</strong><span>&nbsp;</span>开源项目 GitHub 地址：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubeedge%2Fianvs" rel="nofollow" target="_blank">https://github.com/kubeedge/ianvs</a></u></p><p><strong>[2]<span>&nbsp;</span></strong>数据集官网链接：<u>https://kubeedge-ianvs.github.io/</u></p><p><strong>[3]<span>&nbsp;</span></strong>Ianvs 安装流程以及终身学习更详细的介绍链接：<u>https://ianvs.readthedocs.io/en/latest/</u></p><p><strong>[4]<span>&nbsp;</span></strong>Cloud-Robotics 数据集：<u><strong>https://kubeedge-ianvs.github.io/download.html</strong></u></p><p><strong>[5]<span>&nbsp;</span></strong>Ianvs v0.2 Release Note：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubeedge%2Fianvs%2Freleases%2Ftag%2Fv0.2.0" rel="nofollow" target="_blank">https://github.com/kubeedge/ianvs/releases/tag/v0.2.0</a></u></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%3Futm_source%3Doschina%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent" rel="nofollow" target="_blank"><strong>点击关注，第一时间了解华为云新鲜技术~</strong></a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 09:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4526289/blog/10140642</guid>
            <link>https://my.oschina.net/u/4526289/blog/10140642</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米 HyperOS 内置 32 位 App 转译器，性能比原生支持更好]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米手机系统软件部总监张国全介绍了 Xiaomi HyperOS 对第三方应用进行兼容的开发工作。</p><p>据介绍，小米 14&nbsp; 搭载的 CPU 虽然仅支持 64 位架构，但 HyperOS 通过内置 32 位转译内核的方式让用户在新设备上无缝运行 32 位应用。</p><p>相比小米 13 通过 CPU 小核原生运行 32 位应用，<strong>小米 14 凭借译码器可以在大核上运行 32 位应用</strong>，所以即便 CPU 不支持 32 位但依然实现了 32 位应用的兼容支持，而且性能反而更好。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-543d609013f751cb4c431b863bcca7c25bb.png" referrerpolicy="no-referrer"></p><p>此外，小米工程师分析了每年不兼容的三方应用，发现有一大类三方应用修改的内容都比较相似、在应用适配新系统前会出现种闪退和无法使用的问题，因此自研了一套 <strong>CompatEngine 引擎</strong>，可以不依赖三方应用开发者主动做兼容适配第三方应用，经验证目前超过 90% 未适配应用均可正常使用。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 09:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264814</guid>
            <link>https://www.oschina.net/news/264814</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Chrome 支持运行 Kotlin、Java 等 GC 编程语言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>谷歌 Chrome 开发者博客<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.chrome.com%2Fblog%2Fwasmgc%2F" target="_blank">官宣</a></u></strong>：Chrome 已默认启用 <strong>WebAssembly 垃圾回收 (WasmGC) </strong>功能&nbsp;—— 能够<strong>将具有 GC 的编程语言编译为 WebAssembly (Wasm)</strong>。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1103/165225_wBLu_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>下面是示例代码</p><ul><li><strong>Kotlin Wasm</strong></li></ul><pre><code class="language-java">import kotlinx.browser.document
import kotlinx.dom.appendText
import org.w3c.dom.HTMLDivElement

fun main() {
    (document.getElementById("warning") as HTMLDivElement).style.display = "none"
    document.body?.appendText("Hello, ${greet()}!")
}

fun greet() = "world"</code></pre><p>据介绍，<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FWebAssembly%2Fgc%2Fblob%2Fmain%2Fproposals%2Fgc%2FOverview.md" target="_blank">WasmGC </a></u>是 WebAssembly 社区群组发布的一项提案。当前的 Wasm 最小可行化实现只能处理线性内存中的 number 类型数据，即整数和浮点数。随着引用类型 (<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FWebAssembly%2Freference-types%2Fblob%2Fmaster%2Fproposals%2Freference-types%2FOverview.md" target="_blank">reference types</a>) 提案的发布，Wasm 还可以保留外部引用。</p><p>WasmGC 现在添加了结构体和数组堆类型，因此<strong>支持非线性内存分配</strong>。每个 WasmGC 对象都有固定的类型和结构，这使得虚拟机可以轻松生成有效的代码来访问其字段，而不会像 JavaScript 等动态语言那样存在去优化的风险。</p><p>因此，<strong>该提案通过结构和数组堆类型为 WebAssembly 增加了对高级托管语言的有效支持</strong>，使得针对 Wasm 的语言编译器能够与主机 VM 中的垃圾回收器集成。简单来说，通过 WasmGC，将编程语言移植到 Wasm 意味着编程语言的垃圾回收器不再需要成为移植的一部分，而是可以<strong>直接使用现有的垃圾回收器</strong>。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 09:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264807/wasmgc-chrome</guid>
            <link>https://www.oschina.net/news/264807/wasmgc-chrome</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[查询平均提速 700%，奇安信基于 Apache Doris 升级日志安全分析系统]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong>本文导读</strong>：数智时代的到来使网络安全成为了不可忽视的重要领域。奇安信作为一家领先的网络安全解决方案领军者，致力于为企业提供先进全面的网络安全保护，其日志分析系统在网络安全中发挥着关键作用，通过对运行日志数据的深入分析，能够对漏洞和异常行为生成关键见解，帮助企业建立有效的防御策略。本文将深入探讨奇安信在网络安全与日志分析解决方案的关键优势，了解基于 Apache Doris 构建的全新一体化日志存储分析平台如何实时监测和分析日志事件，加强对可疑活动的追踪与应对，提升系统安全性与快速响应能力。（作者｜奇安信，服务端技术专家，舒鹏）</p><p>奇安信是中国企业级网络安全市场的领军者，专注于为政府和企业用户提供新一代网络安全产品和服务。目前核心产品天擎终端安全系统在国内已有 4000 万政企用户部署、全国部署服务器超过 100 万台、服务超 40 万大型机构。作为网络安全国家队，奇安信立志为国家构建安全的网络空间，在终端安全、云安全、威胁情报、态势感知等领域的技术研发持续领先。</p><p>随着现代企业数字化转型的不断深化，大数据、物联网、5G 等创新技术的广泛应用加速了企业的数字化转型步伐，这使得原先的网络边界被打破，多源多样的终端设备成为了新的安全边界。</p><p>网络安全系统的防御性能与日志分析密不可分，当网络设备、操作系统以及应用程序在运行时，会产生大量的运行日志，其中蕴涵了丰富的数据价值。最大化地利用运行日志数据能够有效检测内部系统的安全风险、还原攻击路径、回溯攻击入口等，可以进一步提升系统安全性、保障企业网络安全，因此日志分析系统在其中发挥着不可或缺的作用。</p><p>本文将介绍奇安信在网络安全场景中，基于 Apache Doris 进行架构升级迭代并建设全新一体化日志存储分析平台的实践经验。</p><h1>早期架构痛点与需求</h1><p>安全日志平台的架构如下图所示，原始的设备、系统日志首先经过业务处理环节，包括归一化和扩充维度等操作。这些处理步骤旨在将来自不同设备和系统日志转化为半结构化 JSON 格式的安全日志，并将其写入 Kafka 消息队列中。</p><p>最新的日志会被写入实时数仓，安全分析师可以通过分析平台对实时数仓中的最新数据进行交互式查询，从而进行攻击研判和追踪溯源等安全分析工作。另外，离线数仓用于保存历史数据，以支持长周期数据挖掘的离线分析。</p><p><img src="https://cdn.selectdb.com/static/Wechat_IMG_494_f5c46bcc5d.jpg" alt="WechatIMG494.jpg" referrerpolicy="no-referrer"></p><p>在以上日志数据平台中，日志数据的写入速度与查询分析效率对上层业务人员进行实时安全事件监控和分析至关重要，这也是当前我们所面对的最主要痛点。</p><p>一方面，每天所生产的安全日志数据达到千亿级，写入压力很大。最初我们选择使用某 Apache Doris 的 Fork 版本来存储日志数据，但在实际应用中，随着每天新增日志量的不断增长，入库速度逐渐降低、集群写入压力过大、高峰期数据积压严重，对集群稳定性造成很大影响，并且数据压力较高时、查询效率也达不到有效果的保证。随后我们对集群进行多次扩容，从 3 节点逐步扩容到 13 节点，尽管机器成本已经大幅超过预期、但写入效率并没有发生本质的改善。</p><p>另一方面，业务人员在进行安全日志分析时，经常需要对文本字段（如 URL，payload 等）进行关键字匹配。在原系统中只能通过 SQL LIKE 进行全量扫描和暴力匹配，整体查询性能不佳，千亿级数量的数据表查询耗时接近分钟级甚至达到数百秒，即便按照时间区间过滤大量数据后、查询耗时仍在数秒到数十秒。一旦遇到并发查询性能还会进一步恶化，很难满足日常安全分析的需求。</p><p>除写入和查询效率以外，运维监控也是我们的痛点之一，该厂商提供的可视化运维系统需要商业 License 授权，对于开源社区用户不友好，集群维护处于原始手动状态。</p><h1>架构选型与升级的思考</h1><p>为了解决过去版本的痛点、满足更高效实时的日志分析诉求，我们亟需对早期系统升级改造。同时面向安全日志分析场景，我们也对新日志分析平台的架构提出了更高的要求：</p><ul><li><p><strong>写入性能</strong>：系统一方面需要支持海量病毒查杀事件等数据实时写入与存储，以满足分析时效性的要求，另一方面需要基于日志数据 Schema Free 特点支持丰富数据类型的写入与变更。</p></li><li><p><strong>查询性能</strong>：由于日志查询分析会涉及对文本类型、JSON 数据进行全文检索、日期或普通数值的范围查询，系统需要对字符串提供模糊查询的能力，还需要支持能够灵活创建且类型丰富的索引，以加速筛选过滤海量数据，提升查询效率。</p></li><li><p><strong>存储成本</strong>：设备每天产生大量的日志数据，为了挖掘这些有价值的日志信息，业务人员还需要从数据中进行筛选和分析，并对异常日志回溯追踪，这使得日志存储的规模很大、存储周期相对较长，因此高性价比的存储成本也是系统构建的目标之一。</p></li><li><p><strong>运维成本</strong>：系统自身的运维简易程度以及是否具备合适的管控工具都能帮助我们进一步提效。</p></li></ul><p>在持续关注业界 OLAP 数据库的过程中，我们发现 Apache Doris 最近一年的发展非常迅猛，最新的 2.0 版本也把日志存储和检索分析作为新的发力点，推出了倒排索引、NGram BloomFilter 索引等特性，对关键词检索、LIKE 文本匹配的性能有大幅提升，与我们文本检索慢的痛点需求非常契合，因此开启了新架构的升级之旅。</p><h1>架构升级之旅</h1><p>上文中提到，在整体架构选型过程中我们主要关注的地方包括写入性能、查询性能、数据存储成本以及运维成本等方面。在架构升级过程中，我们选择了 Apache Doris 当时最新发布的 2.0 版本，具体升级收益如下。</p><h3>01 写入性能提升超 200%</h3><p>为了评估 Apache Doris 写入的极限性能，我们初期使用与线上系统相同配置的 3 台服务器，从 Kafka 接入线上真实写入流量，测试期间当 CPU 写入效率跑满至 100% 时写入吞吐达到了 108 万条/s、1.15 GB/s，写入数据的可见性延迟保持在秒级。</p><p>而线上运行的原系统集群规模达 13 台，在同样的数据写入情况下，CPU 利用率 30% 左右、写入吞吐仅 30 万条/s，并且存在高峰期 CPU Load 高、系统响应慢的问题。</p><p>根据测试结果，我们预估架构<strong>替换为 Apache Doris 后保持同样 30% 的 CPU 占用，只需要 3 台服务器即可满足写入需求，机器资源成本至少节约 70%</strong>。值得注意的是，在测试中对 Apache Doris 表中一半字段开启了倒排索引，如果不开启倒排索引的话，写入性能在之前基础上还能够再提升 50% 左右。</p><h3>02 存储成本降低近 40%</h3><p>在看到写入性能的大幅提升后，Apache Doris 存储空间占用也给我们带来了惊喜。<strong>在开启倒排索引的前提下，存储空间比原系统不具备倒排索引还要略低，压缩比从 1 : 4.3 提高至 1 : 5.7。</strong></p><p>通过对比 Apache Doris 在磁盘上存储的文件大小，同一份数据的索引文件 (.idx) 与数据文件 (.dat) 大小相差无几。换言而之，增加索引后 Doris 数据膨胀率大约在 1 倍左右，与许多数据库和检索引擎 3-5 倍的膨胀率相比，Doris 的数据存储空间占用相对较低。经过研究发现，Apache Doris 采用了列式存储和 ZSTD 压缩算法来优化存储空间占用。Doris 将原始数据和倒排索引都以列的形式存储，使同一列的数据被存储在相邻位置，从而实现了更高的压缩率。</p><p>ZSTD 是一个优秀的新型压缩算法，使用了智能优化算法，相较于常见的 GZIP 算法， ZSTD 具有更高的压缩率和更快的解压速度，尤其在处理日志场景时表现非常出色。</p><h3>03 查询性能平均提升 690%</h3><p>对于业务最关注的查询性能，我们从线上查询日志进行去重后分析出 79 条 SQL，在同一天总数据（1000 亿条）、同样规模的集群（10 BE 节点）上对比测试 Apache Doris 与原系统的查询耗时。</p><p><strong>我们发现，与原系统相比，所有的查询语句均有明显提升，整体查询性能提升近 7 倍，有 26 条 SQL 查询语句性能提升 10 倍以上</strong>，其中 8 条 SQL 查询提升 10-20 倍、14 条 SQL 查询提升 20-50 倍、还有 4 条 SQL 查询提升 50 倍以上。最大差异的一条 SQL 查询语句为 Q43，在原系统中执行时间接近一分钟，在 Apache Doris 中仅需不到 1 秒，其性能差异高达到 88 倍。</p><p><img src="https://cdn.selectdb.com/static/Wechat_IMG_495_6ac4f35ed5.jpg" alt="WechatIMG495.jpg" referrerpolicy="no-referrer"></p><p>针对性能提升幅度高的查询，我们进行了对比分析并发现了其中几个共同点：</p><p><strong>倒排索引对关键词查找的加速：Q23、Q24、Q30、Q31、Q42、Q43、Q50 等</strong></p><pre><code>1 -- 例如 q43 提升 88.2 倍
2 
3 SELECT count() from table2 
4 WHERE ( event\_time &gt;= 1693065600000 and event\_time &lt; 1693152000000) 
5 &nbsp; AND (rule\_hit\_big MATCH 'xxxx');
</code></pre><p>这种基于倒排索引进行关键词检索的技术，相较于基本的暴力扫描后进行文本匹配具有显著的优势，一方面极大地减少了需要读取的数据量；另一方面，在查询过程中无需进行文本匹配操作，因此查询效率往往提升一个数量级甚至更高。</p><p><img src="https://cdn.selectdb.com/static/Wechat_IMG_496_12be3ae384.jpg" alt="WechatIMG496.jpg" referrerpolicy="no-referrer"></p><p><strong>NGram BloomFilter 索引对 LIKE 的加速：Q75、Q76、Q77、Q78 等</strong></p><pre><code>1 -- 例如 q75 提升 44.4 倍
2 
3 SELECT * FROM table1
4 WHERE  ent_id = 'xxxxx' 
5 &nbsp;  AND event_date = '2023-08-27' 
6 &nbsp;  AND file_level = 70 
7 &nbsp;  AND rule\_group\_id LIKE 'adid:%' 
8 ORDER BY event_time LIMIT 100；
</code></pre><p>对于要查找的非一个完整关键词的场景，LIKE 仍然是有用的查询方式，Apache Doris 的 NGram BloomFilter 索引能对常规的 LIKE 进行加速。</p><p>NGram BloomFilter 索引与普通 BloomFilter 索引不同，它不是将整个文本放入 BloomFilter ，而是将文本分成连续的子串，每个子串长度为 n ，并将他们放入 NGram BloomFilter 中。对于 <code>cola LIKE '%pattern%'</code> 的查询，将<code>'pattern'</code>按照同样的方式分成长度为 n 的子串，判断每个子串在 BloomFilter 中是否存在，如果有一个子串不存在，则说明 BloomFilter 对应的数据块中没有跟<code>'pattern'</code>匹配的数据块，因此通过跳过数据块扫描的步骤，达到加速查询的效果。</p><p><strong>满足条件的最新 TopN 条日志明细查询优化：Q19-Q29 等</strong></p><pre><code>1 -- 例如 q22，提升 50.3 倍
2 
3 SELECT * FROM table1
4 where event\_date = '2023-08-27' and file\_level = 70 
5 &nbsp; and ent\_id = 'nnnnnnn' and file\_name = 'xxx.exe'
6 order by event_time limit 100;
</code></pre><p>这种<code>SELECT * FROM t WHERE xxx ORDER BY xx LIMIT n</code> 的查询，在查找满足某种条件的最新 n 条日志时使用频率非常高，Apache Doris 针对这种 SQL 查询模式进行了专门的优化，根据查询的中间状态确定排序字段的动态范围，并利用自动动态谓词下推的方式，避免读全部数据进行排序取 TopN，从而减少需要读取的数据量（有时甚至可以减少一个数量级），进而提升了查询效率。</p><h3><strong>04 可视化运维管控和可视化查询 WebUI，最大化减少运维和探索分析成本</strong></h3><p>为了提高日常集群维护的效率，我们使用了飞轮科技免费开放的可视化集群管理工具 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.selectdb.com%2Fblog%2F102" target="_blank">Cluster Manager for Apache Doris</a> （以下简称 Doris Manager ）。Doris Manager 提供的功能可以满足日常运维中集群监控、巡检、修改配置、扩缩容、升级等操作，降低登陆机器手动操作的麻烦和误操作风险。</p><p><img src="https://cdn.selectdb.com/static/Wechat_IMG_497_a752c765ea.jpg" alt="WechatIMG497.jpg" referrerpolicy="no-referrer"></p><p>除了管控 Apache Doris 集群之后，Doris Manager 还集成了类似 Kibana 的可视化日志探索分析 WebUI，对于习惯 ELK 日志分析的用户非常友好，支持关键词检索、趋势图展示、趋势图拖拽日期范围、明细日志平铺和折叠展示、字段值过滤等交互方便的探索式分析，跟日志场景探索下钻的分析需求很契合。</p><p><img src="https://cdn.selectdb.com/static/Wechat_IMG_498_2e65f945f0.jpg" alt="WechatIMG498.jpg" referrerpolicy="no-referrer"></p><h1><strong>总结与规划</strong></h1><p>在跟随 Apache Doris 2.0-alpha，2.0-beta，2.0 正式版本发布的节奏，我们根据业务场景进行了详细的评测，也为社区反馈了不少优化建议，得到社区的积极响应和解决。系统经历试运行一个月之后，我们将 2.0.1 版本正式用于生产环境，替换了原系统集群，完成架构升级改造，实现了写入性能、查询性能、存储成本、运维成本等多方面收益：</p><ul><li><p><strong>写入性能提升 3 倍以上</strong>：目前，奇安信的日志分析平台每日平均有数千亿的新增安全日志数据，通过 Doris 的 Routine Load 能够将数据实时稳定写入库，保障数据低延迟高吞吐写入。</p></li><li><p><strong>查询性能平均提升 7 倍</strong>：查询响应时间大幅减少，与之前的查询效率相比达到平均 7 倍提升，其中业务特别关注的全文检索速度达到 20 倍以上的提升，助力日志分析与网络安全运营效率。</p></li><li><p><strong>高效便捷的可视化管理</strong>：Cluster Manager for Apache Doris 工具提供了可视化集群监控告警平台，满足日常集群监控等一系列操作，同时 WebUI 多种功能为分析人员提供了操作简单、使用便捷的交互式分析。总而言之，Doris 的易用性、灵活性大幅降低了开发、运维、分析人员的学习与使用成本。</p></li></ul><p>后续我们还将在日志分析场景下探索更多 Apache Doris 的能力。我们将扩大 JSON 数据类型的相关应用，加强系统对于半结构化数据深度分析的能力。同时，我们也<strong>非常期待 Apache Doris 2.1 版本中新增的 Variant 可变数据类型，支持存储任意结构的 JSON 数据，支持字段个数与类型的变化，让业务人员灵活定义特殊字符，以更好地实现半结构数据 Schema Free 的分析需求</strong>。</p><p>非常感谢 SelectDB 团队一直以来对我们的技术支持，助力奇安信走向「体系化防御、数字化运营」的网络日志安全管理，帮助客户准确识别、保护和监管网络设备与各类系统，确保业务人员在任何时候都能够安全、可信、稳定地访问数据与业务。</p><p>最后，我们也将持续参与到 Apache Doris 社区建设中，将相关成果贡献回馈社区，希望 Apache Doris 飞速发展，越来越好！</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 08:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5735652/blog/10140250</guid>
            <link>https://my.oschina.net/u/5735652/blog/10140250</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[昆仑万维「天工」大模型正式向全社会开放]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 11 月 3 日，昆仑万维「天工」大模型宣布通过《生成式人工智能服务管理暂行办法》备案，面向全社会开放服务！</p><p>用户在应用商店下载「天工 APP」或登陆「天工官网」（<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.tiangong.cn" target="_blank">www.tiangong.cn</a>）均可直接注册使用。</p><p>官方介绍称，「天工」是国内首个对标 ChatGPT 的双千亿级大语言模型，也是一个 AI 搜索引擎，一个对话式 AI 助手。「天工」拥有强大的自然语言处理和智能交互能力，能够实现个性化 AI 搜索、智能问答、聊天互动、文本生成、编写代码、语言翻译等多种应用场景，并且具有丰富的知识储备，涵盖科学、技术、文化、艺术、历史等领域。</p><p><img height="232" src="https://oscimg.oschina.net/oscnet/up-4220721cc203df8b9704c1aa7e7fb303f00.png" width="500" referrerpolicy="no-referrer"></p><p>2022 年 12 月 15 日，昆仑万维在北京举行 AIGC 技术发布会，发布自研 AIGC 全系列算法与模型，覆盖了图像、音乐、文本、编程等多模态的 AI 内容生成能力。</p><p>2023 年 4 月 17 日，昆仑万维正式发布自研千亿级大语言模型「天工」，同时宣布启动邀请测试。「天工」用过通过自然语言与用户进行问答式交互，AI 生成能力可满足文案创作、知识问答、代码编程、逻辑推演、数理推算等多元化需求。</p><p>2023 年 5 月 19 日，北京市经济和信息化局公布第一批《北京市通用人工智能产业创新伙伴计划成员名单》。昆仑万维成为第一批模型伙伴和投资伙伴。</p><p>2023 年 8 月 23 日，昆仑万维推出国内第一款 AI 搜索产品——「天工 AI 搜索」，并开启内测申请。「天工 AI 搜索」深度融合 AI 大模型能力，通过人性化、智能化的方式全面提升用户的搜索体验，为用户提供快速、可靠的交互式搜索服务，并集成 AI 对话、AI 写作等常用功能，帮助用户提升工作效率，全面重塑中文搜索体验。</p><p>2023 年 9 月，昆仑万维多模态大模型 Skywork-MM 在腾讯优图实验室联合厦门大学开展的多模态大语言模型测评 MME 中，综合得分排名第一。该评测首次对全球范围内 MLLM 模型进行了全面定量评测并公布了 16 个排行榜，包含感知、认知两个总榜单以及 14 个子榜单。Skywork-MM 模型位列综合榜单第一，其中，感知榜单排名第一、认知榜单排名第二。</p><p>2023 年 9 月 16 日，在权威推理榜单 Benchmark GSM8K 测试中，昆仑万维「天工」大模型以 80% 的正确率脱颖而出，大幅领先 GPT-3.5（57.1%）和 LLaMA2-70B（56.8%）。</p><p>2023 年 9 月 17 日，昆仑万维通过信通院「可信 AI」评估，并被评选为人工智能实验室副组长单位。经中国信通院评估，昆仑万维天工大模型符合 AIIA/PG 0071-2023、AIIA/PG 0072-2023 评估标准，模型开发、以及模型能力均达到了「4+级」。</p><p>10 月 30 日，昆仑万维开源百亿级大语言模型「天工」Skywork-13B 系列，并配套开源了 600GB、150B Tokens 的超大高质量开源中文数据集。「天工」Skywork-13B 系列目前包括 130 亿参数的两大模型，Skywork-13B-Base 模型、Skywork-13B-Math 模型，它们在 CEVAL、GSM8K 等多个权威评测与基准测试上都展现了同等规模模型的最佳效果，其中文能力尤为出色，在中文科技、金融、政务等领域表现均高于其他开源模型。同时，昆仑万维「天工」Skywork-13B 系列大模型全面开放商用——开发者无需申请，即可商用。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 03:06:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264987</guid>
            <link>https://www.oschina.net/news/264987</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 复用性风控：软件复用成本的量化管理]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:justify">复用性（Reusability）是软件工程中一个被频频使用的术语，它一般作为产品的卖点被宣传，或者出现在技术设计文档之中。大部分看到这个概念的的受众只是将其作为一个积极的软件非功能属性去理解，但却忽略了其背后隐藏的风险。本文从另一个角度出发，去分析「复用性」这一概念背后的风险及成因，借助笔者在业务安全和基础安全的一点经验，提出了一个在软件研发流程中，管理「复用性成本风险」的风险管理模型。从模型出发，我们可以认识到实现复用时面临的各项挑战、开发认知谬误、复用成本的形式化定义方法等，希望这些输入能为读者在后续的技术决策和软件研发流程提供些许帮助。</p><p style="text-align:justify">本文主要分为三个部分：第一部分介绍复用性的定义以及不合理复用引入的主要技术债，第二部分分析复用性失效的原因；第三部分为复用性软件资产的构建方和使用方提供一个形式化的度量工具，该工具将奠定后续风险管理模型评估阶段定量分析的基础；第四部分提出一个用于管理「复用性风险」的模型，覆盖软件研发生命周期的全流程，通过事前评估、事中缓释和事后迭代三个环节最大程度地降低由于软件复用带来的软件开发和维护成本。</p><span id="OSC_h3_1"></span><h3>一、复用性的理想与现实</h3><span id="OSC_h4_2"></span><h4><strong>1.1 复用定义：从代码到系统</strong></h4><p style="text-align:justify">软件复用是解决软件质量和生产力问题的一种方法，它指的是在软件开发过程中重复使用相同或相似的软件元素。通过合理利用软件复用技术，我们可以提高开发效率，并且降低开发过程中的错误率。同时，软件复用还可以促进团队协作和知识共享，使得开发者们能够更好地利用彼此的经验和资源。因此，在当今快节奏的开发环境中，软件复用已经成为提高生产力和质量的关键策略之一。在过去几十年的时间里，很多编程语言的成功（Python、Java 等）和开源文化的蓬勃发展，都与复用密不可分。软件复用可以在不同粒度上进行，包括代码和设计拷贝、源代码复用、设计和软件体系结构复用以及领域特定的软件体系结构复用等。早期的软件复用主要集中在代码级别，例如共享方法、抽象类、库、微服务和 Docker 镜像等。随着时间推移，其外延拓展至领域知识、开发经验、设计文档、需求分析和测试用例及数据等在不同阶段所产生的各种软件产品。<strong>在本文中，除非特别说明，复用性主要指的就是聚焦代码的复用，下文中的「组件复用」，不仅限于通常我们认知中的公共库，还包括代码方法、公共类、软件框架、可集成系统等软件开发中的可复用元素。</strong></p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-963651fba23c39dc34c4a58a1a6eaacb_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_3"></span><h4><strong>1.2 复用风险：复杂度和成本</strong></h4><p style="text-align:justify">诚然，通过组件的复用可以提高软件开发效率和质量，但复用不是银弹，复用也会有一些副作用：</p><p style="text-align:justify">1.兼容性/安全性/性能；</p><p style="text-align:justify">2.增加了系统间的依赖；</p><p style="text-align:justify">3.增加了开发和维护成本。</p><p style="text-align:justify"><strong>首先，兼容性/安全性/性能</strong>等这几类问题，是针对可复用组件的使用方来说的，一般来说，在决策是否复用之前就可以评估，其指标和过程也比较清晰，这里就不具体展开了。</p><p style="text-align:justify"><strong>其次，复用会增加系统依赖。</strong>依赖关系是软件的基本组成部分，无法消除，但软件设计的目标之一是尽可能消除依赖关系，并使依赖关系尽可能简单和明显。当我们引入外部组件进行复用时，软件组件之间的依赖关系会导致组件变更范围的扩大以及组件认知负荷的增加，前者是针对组件维护方而言的，即看似简单的变更需要在许多不同的地方修改代码，<strong>随着消费者数量的增长，在不同需求之间进行平衡变得越来越困难；</strong>后者是对于组件使用方而言的，即开发人员需要了解大量组件领域知识才能实现有效的组件复用。比如，需要了解待使用接口中若干入参的设计意图、是否存在隐式依赖传递从而导致依赖冲突等。依赖的增加会为系统引入更多的复杂性，而我们知道，构建软件系统的核心挑战就是管理复杂性，复用组件只会在一定程度上转移复杂性，但并不能消除复杂性。因此，我们需要在「复用组件降低成本」和「复用组件引入依赖（复杂性）」之间取得平衡。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-3612b21399b66c7600b9f27155d86f92_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>最后，复用会增加各项成本。</strong>包括开发的成本、变更的成本、集成的成本、领域知识迁移的成本。对于一个面向复用设计的组件来说，实现正确抽象和通用框架的设计和开发成本，比一次性的解决方案高得多，对于组件的后续维护者来说，这样的可复用框架和库通常也会带来陡峭的学习曲线（因为文档一般是缺失的），组件会逐渐走向腐化，最后不得不推倒重来。此外，对于可复用组件的使用方来说，其理解和集成组件的成本通常也是被忽略的，一些强推的业务层的「伪复用框架」给前台集成的同学带来了巨大的集成、学习和维护成本。</p><p style="text-align:justify">上述复用带来问题，有一些是可以规避的，如兼容性、性能、容量等的匹配度，有一些是无法避免的，如设计通用化组件的开发成本、不合理的抽象导致的代码腐化、不合理的复用导致的维护成本等。事实上，无论我们在技术上做多么精妙的设计，技术的创新永远滞后于系统的腐化速度。</p><p style="text-align:justify">为了最大程度的降低复用带来的风险，本文提出一套从类比于安全风险管理的「复用性风险」应对模型，从事前评估、事中缓释、事后迭代三个阶段出发，最大程度地降低我们在开发可复用组件、使用可复用组件中遇到的各类风险。需要说明的是，<strong>上面以及后面指的「复用性风险」，定义为「由于不合理的复用决策，导致依赖和复杂度膨胀过快，从而导致软件维护成本过高」的问题，</strong>除了成本风险外，由于复用组件的不合理使用或存在的缺陷而导致的兼容性、安全性、性能等方面的风险，其风险更为显著和易于治理，因此不是本文论述的重点。此外，复用开发过程中的开发目标偏移、迭代和发布计划的延期、人员短缺等风险，限于篇幅也不在这里展开。</p><p style="text-align:justify">第二部分首先会介绍导致「复用提升软件开发效率」这一原则失效的几类主要原因，第三部分会重点介绍用于评估复用性的若干工具，有了对复用性本质的认识后，再第四部分我们会简要介绍复用性风险管理模型。</p><span id="OSC_h3_4"></span><h3>二、复用性风险根因分析</h3><span id="OSC_h4_5"></span><h4><strong>2.1 现实挑战：正确和错误的抽象</strong></h4><p style="text-align:justify">我们复用组件的一个初衷，除了是为了提升研发效率之外，也是希望可复用组件可以将领域的复杂性隔离在一个我们永远看不到的地方，从而整体降低组件使用方的系统复杂度。因此，一个可复用的组件，无论其规模大小，其设计过程就是对某个领域高度抽象的过程。在设计组件时，向上面对当前或潜在的需求，需要我们做一定的前向通用设计，向下尽可能屏蔽掉组件的实现细节，抽象的结果直接决定了后续该组件可复用性程度的高低（可复用性的度量将在下一个章节详述）。但遗憾的是，良好的抽象能力对于大部分开发者来说是一个稀缺的产物，它需要对问题进行清晰的定义、简化和分解，同时识别和利用通用模式，将子问题的解法组合起来形成一个整体解决方案，依赖对设计模式、开源的库和框架、数据结构和算法以及大量生产项目的长期实践和思考。</p><p style="text-align:justify">在日常的代码中，我们不乏抽象，但大部分都是不合理的抽象。错误的抽象造成的危害甚于不抽象，比如常见的一个现象：对设计模式的适用范围知之甚少，仅仅为了炫技而滥用设计模式，导致代码的可读性和可维护性下降。</p><p style="text-align:justify">除了对抽象能力的要求外，很多时候需求紧迫度、开发资源、责任心以及组件所在领域职责的变更等因素，都会导致可复用组件从出生就带着「高成本」的原罪，其后续的使用成本和维护成本会急剧上升，这里就不一一展开了。</p><span id="OSC_h4_6"></span><h4><strong>2.2 认知谬误：复用不是设计目标</strong></h4><p style="text-align:justify">一个对于复用性的认知谬误就是，把「不重复」等效为「复用」，这两个概念之间有相似之处，但还是有一些微妙的差别。「不重复」即我们所熟知的 DRY 原则（Don’t Repeat Yourself），其目标是通过减少重复建设从而避免承担副本不一致的维护成本，而 Reusability 是从所有代码中找到重复的部分，然后在复杂度可控的前提下，努力抽象出可复用的东西。一堆不重复的代码，并不代表存在可复用的组件。</p><p style="text-align:justify"><strong>复用只是实现不重复目标的一种手段，「不重复」才是我们设计软件系统时的目标，单纯追逐「复用性」很多时候会出现一些本末倒置的现象。</strong>如出现了一些接入成本非常高的自动测试框架、业务中台框架，一味追逐「（我）一次开发，（你）随处使用」，殊不知在使用方需要消耗大量的精力去内化框架设计者的设计初衷，面对十几个接入参数或配置文件一筹莫展。</p><p style="text-align:justify">举个例子，偶尔会看到我们在业务层代码中，部分同学会把简单的新增和修改逻辑抽象为一个方法，美其名曰「提供给接入层复用」，如下面的 insertOrUpdate 方法中，初看是复用了领域对象转换和用户对象是否存在的代码，符合 DRY 原则，但实际上却是混用了两个不同的业务语义，会给后续的维护带来较高的成本，如变更用户信息时，需要做更个性化的用户属性处理，这时候调整领域对象转换处的代码，将会影响新增逻辑。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-3c8e7289db213680d7aa473520b964c9_720w.webp" referrerpolicy="no-referrer"></p><p>更合理的实现是，将明显不同语义的代码进行拆分，虽然看上去存在一定程度上的代码重复，但其设计会更利于后续的功能迭代，也更符合代码的「单一职责」设计原则。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-5f8500b6ba012049c89989be0edced10_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_7"></span><h4><strong>2.3 决策偏差：复用的决策权在哪</strong></h4><p style="text-align:justify">代码的复用更多的时候是软件开发者自发完成的，但我们无法忽视的一点是，如何集成、是否复用、如何复用、是否是同一个功能、使用什么粒度的复用，很多时候是由业务架构决定的，「康威定律」还是无法回避的。</p><p style="text-align:justify">比如，在一个新的场景里，产品要求把「PPT 上与其名字相同的一个功能」进行复用，以快速上线，虽然他们除了名字相同，其产品形态、业务流程、环境依赖等都不一样。最终强行「复用」的结果就是代码逻辑里出现了大量的分支判断，底层技术架构变得臃肿。由于对于领域的理解不同，出现这种情况在所难免。虽然很多时候软件复用的决策权并不在开发者这里，但出于技术情怀也好，责任心也罢，开发者有义务去做这种纠偏，最大程度地消除这种差异性。但需要认识到技术的作用在这里并不是决定性的，卓越的技术是复用成功的必要非充分条件。</p><span id="OSC_h4_8"></span><h4><strong>2.4 工具缺失：如何计算复用成本</strong></h4><p style="text-align:justify">复用性度量，主要分为两个部分：</p><p style="text-align:justify">1.复用度：决定一个组件复用性高低水平的因素有哪些？</p><p style="text-align:justify">2.复用成本：组件集成方、组件所在的组织，决定实行复用策略后的 ROI 如何计算？</p><p style="text-align:justify">通过复用度和复用成本两个指标，我们可以进行一定程度上的复用性定量分析，做出更为长远的技术决策。比如，可以了解到一个复用性高的组件，其特征有哪些？引入一个新的第三方组件时，除了基础的功能性组件外，我还需要考虑哪些？相较于使用已经存在的组件，是否考虑重新造一个轮子？「复用」和「造轮子」间成本有多大？关于复用性的度量工具，第三部分将重点论述。</p><span id="OSC_h3_9"></span><h3>三、复用性的形式化度量</h3><span id="OSC_h4_10"></span><h4><strong>3.1 组件度量：可复用水平的评估</strong></h4><p style="text-align:justify">我们在设计一段代码/一个类/一个模块等可复用的组件时，一些可衡量的软件指标共同决定了组件的可复用性水平的高低。这些指标包括：可靠性（Reliability）、可读性（Understandability）、可维护性（Maintainability）、通用性（Generality）与可迁移性（Portability），如下图所示。每一个指标可由各类代码度量属性决定，如组件的可迁移性由「组件的独立性」和「耦合性」两个属性决定，大部分的度量属性都是可以通过形式化定义并计算出来。不同指标的决定因子及度量值（括号中）如下：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-ae30c926a96772aa3e71efcc921e9e0e_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">1.<strong>可靠性：</strong>性能（响应时间）、容错程度（恢复时间）；</p><p style="text-align:justify">2.<strong>通用性：</strong>类泛化水平（子类实例个数或接口实现类个数）；</p><p style="text-align:justify">3.<strong>可读性：</strong>内聚性（类之间耦合度）、复杂度（圈复杂度）、规模（代码行数）、文档水平（数量+完整度）；</p><p style="text-align:justify">4.<strong>可维护性：</strong>易于修改、单测和回归测试（测试覆盖度）、组件的独立性（依赖数）、耦合性（类间耦合度）；</p><p style="text-align:justify">5.<strong>可迁移性：</strong>组件的独立性（依赖数）、耦合性（类间耦合度）。</p><p style="text-align:justify">为了度量整个组件的的可复用性，有必要定义一个可复用性计算模型。该模型基于上图所示的复用性属性模型。主要的可复用性属性、影响这些属性的因素以及度量这些因素的量度之间的关系显示在这个模型中。理论上，软件组件的可复用性 (用&nbsp;<em>Reusability</em>&nbsp;表示) 可以用表达式来计算：</p><p style="text-align:justify"><em>Reusability = w1*M + w2*R + w3*P + w4*U + w5*G</em></p><p style="text-align:justify">其中&nbsp;<em>w1 ~ w5</em>&nbsp;为不同指标的权重值，指标&nbsp;<em>M（Maintainability）、R（Reliability）、P（Portability）、U（Understandability）、G（Generality）</em>&nbsp;值进行归一化（0 ... 1）后，乘以每个指标不同的权重值，通过计算得到最终的组件的可复用度。</p><p style="text-align:justify">在上面的分析过程中，存在部分度量无法进行定量分析的情况，但不同因子组合计算还是有意义的，我们可以拿这些指标去评估我们目前的系统，存在的问题的严重程度。当下次别人问我们为什么要复用组件 A 而不是组件 B 时，我们可以给出更令人信服的理由，而不仅仅是「我觉得」、「A 比 B 好很多」等论述。</p><span id="OSC_h4_11"></span><h4><strong>3.2 组织度量：复用的投入产出比</strong></h4><p style="text-align:justify">对组件的复用性有了一个感性认知后，更加一步地，让我们从经济的角度去思考复用性背后的成本问题。首先，我们先定义几个变量&nbsp;<strong>RL、NUC、RCR、RCWR</strong>。</p><ul><li><strong>RL（Reuse Level）</strong>：可复用组件在应用中的比例，即 RL=复用的组件中代码行数/应用总的代码行数；</li><li><strong>NUC（Not Use Cost）</strong>：应用开发过程中完全不使用可复用组件的成本，注意不包括后续的维护成本；</li><li><strong>RCR（Relative Cost of Reuse）</strong>：复用既有的组件与重新造一个相似的轮子，这两者之间工作量的比值，一般在 0.03~0.4 之间，经验值为 20%，即这意味着复用所花费的成本大约是编写新组件所投入的 20%；</li><li><strong>RCWR（Relative Cost of Writing for Reuse）</strong>：开发可复用的组件与开发一次性使用的模块，这两者之间工作量的比值，一般在 1.0~2.2 之间，经验值为 1.5，即这意味着编写可复用软件需要大约 50% 的额外成本。</li></ul><p style="text-align:justify">对于集成方而言，可以计算因复用节省的成本（DCA，Development Cost Avoidance）以及复用后的成本节省比占比（ DCAR，Development Cost Avoidance Ratio）：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-ac493599b0c28acc0e45e8e36f988186_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">举例，如果复用度 RL = 40%， RCR = 0.2，则软件集成方节约成本占比 = 0.64，即节省了 64% 的成本。同时我们可以得到一个简单的结论，对于组件的集成方来说，如果想要提升成本占比，则需要：<strong>可复用组件在项目中的复用度越高越好，同时可复用组件的 RCR 应较低。</strong>这意味着可复用组件拓展性、可读性需要保持在一个较高的水平，这样集成方在集成时的二次开发和适配成本会较低，这个结论也是契合我们研发时的直觉的。</p><p style="text-align:justify">对于组织而言，假如某可复用组件的 N 个场景被使用了，则组织复用收益 OROI 可计算如下：</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-6d2fc9255a7e8362245fea5bbc0424ab_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">举例：如果复用度 RL = 40%，RCR = 0.2，RCWR = 1.5，复用次数为 5 次，则，组织收益 OROI = 167%，这意味着开发一个可复用的组件，同时在多个场景进行复用，是有超额回报的。但是不是只要复用了就会有收益呢？另 OROI = (N*(1-RCR) - RCWR)/RCWR &gt; 0 可以得到 N &gt; RCWR/(1-RCR)，带入上面预设的 RCR = 0.2，RCWR = 1.5 这两个值，得到 N &gt; 2，这意味着需要两个或两个以上的场景复用了此组件，我们此次研发活动才会取得正向的收益。与此同时，我们可以从上面的公式得到以下几个关于提升组织复用 ROI 的结论：<strong>可复用组件在项目中复用度越高越好，开发可复用组件时，RCWR 和 RCR 越低越好。</strong>RCWR 低意味着不要去过度设计，组件的泛化性需要在领域内得到一定的控制，RCR 低意味着可复用组件可读性好、拓展性高，集成时的成本不高。</p><p style="text-align:justify">马丁·福勒（Martin Fowler）在《重构》一书提出了一条代码重构经验法则「Rule of Three 」，即我们可以复制和粘贴一次代码，但是当复制相同的代码三次时，应将其提取到新过程中进行抽象以便于复用，法则里面的最小重复次数 3，其值亦符合上述 N &gt; RCWR/(1-RCR) 的结论。</p><span id="OSC_h4_12"></span><h4><strong>3.3 重复度量：复用和复制的边界</strong></h4><p style="text-align:justify">回到我们第二节中所提到的问题：为什么说 DRY 原则不等价于复用？假设以下场景：1. 项目中设计了全局的字符串常量类，所有的公共常量都放在此处，其他模块中的类都引用此常量，这是一个好的实践吗，是不是定义模块内的常量类或类中的常量字段会更好？2. 我需要进行字符串判重逻辑，是自己重写一个字符串工具类，还是直接使用如 commons-lang 或 guava 包中的代码呢？上面的场景都没有绝对的答案，但就我目前看到的情况来看，在很多开发者的编码习惯中，因为过度去追逐「复用性」，出现了一些没有必要的依赖负担，如使用全局常量类，出现没必要的类加载，第三方包的随意使用，造成应用包膨胀或者集成时的包冲突问题。<strong>有时候，复制一些类似的代码比尝试泛化再实例要好得多，过度使用抽象只会模糊真正关键的问题。</strong></p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-0ce4791fa1d8b3d3c325d20da80465f7_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">那什么时候可以复制，什么时候不建议呢？除了 2.2 中提到的语义不一致时的适度复制（就不是复用），当我们真实使用的代码占可复用组件整体代码逻辑的比例较低时（譬如只使用了 commons-lang 包中的 StringUitls 类），可以考虑重写一份，进行适度的复制粘贴，实现该处逻辑和集成方「自治」。对应前面的结论，这种情况下意味着 RL 较低，同时&nbsp;<strong>RCR 较高，比如 RL = 0.01，RCR = 0.8，则，软件集成方节约成本占比只有 RL*(1-RCR) = 0.2%</strong>，这一点收益同后续可能潜在的风险（包膨胀和包冲突）相比，复制可能是一个更好的选择。</p><span id="OSC_h3_13"></span><h3>四、复用性风险管理模型</h3><p style="text-align:justify">有了前面两个部分的铺垫，我们再回头去审视因为复用引入的成本风险，应该采取哪些措施能使得风险最小化呢？在业务风控和数据安全等泛信息安全的业务中，我们对风险管理的抽象，都会强调事前、事中、事后的风险控制流程。相似地，我们可以在代码研发过程中，<strong>通过建立事前评估、事中缓释及事后迭代的复用性风险管控手段</strong>，降低风险发生的可能性及其造成的影响，并根据业务架构和技术架构的发展趋势采取规避、降低和转移风险的措施，将风险控制到团队可承受的水平之内，最大程度地避免或延缓因为复用导致的维护成本高、系统快速腐化等问题。</p><p style="text-align:justify">事前评估、事中缓释、事后迭代形成的全生命周期复用性风险管理模型如下图所示：</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-68fe36560c29dea37111fa27bd2310e9_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_14"></span><h4><strong>4.1 事前评估：成本与启发式决策</strong></h4><p style="text-align:justify">风控的事前阶段（评估+分析），一般基于某些黑样本出发，挖掘出适用于后续风险对抗阶段的某些风险行为特征或模型，并基于历史样本计算出准确率和召回率。在复用性风险的事前阶段，我们也可以通过定性和定量的评估手段，尽早发现各种复用时的「坏味道」，立即予以纠正或防范，把风险消灭在萌芽状态，避免因为错误的复用引入过多技术债。评估的流程主要分为：可复用组件评估、复用成本和收益的度量、启发式决策这三个阶段，具体地：</p><p style="text-align:justify">1.如果待复用的组件是已存在的，则可以计算或估算出已复用组件的可复用水平，考量的指标即上面提到的可靠性、可读性、可维护性、通用性和可迁移性，不同场景的指标权重不一，可以结合具体场景进行判断；</p><p style="text-align:justify">2.如果待复用的组件是需要新建的，则可以计算出后续集成节约的人力成本，以及中长期的时间里组织通过复用组件获取的整体收益，通过结合复用成本、复用收益、当前组织人力现状、后续业务进行最终的决策；</p><p style="text-align:justify">3.如果步骤 1 和 2 都得不到一个最终的结论，下面还有一些启发式的经验帮助我们决定是否真的需要复用。</p><p style="text-align:justify"><strong>可能需要复用的场景</strong>（抽象组件或复用既有组件）：</p><p style="text-align:justify">1.待复用的业务逻辑非常专业，如 Json 序列化、加解密；</p><p style="text-align:justify">2.相同或相似业务语义的代码已经存在多（3）处，需要重构；</p><p style="text-align:justify">3.待选的可复用组件文档非常全面，易于接入、拓展、替换或移除；</p><p style="text-align:justify">4.业务逻辑变更频繁，每次变更需要同时变更多个系统或模块以保持同步；</p><p style="text-align:justify">5.需要即时共享且对不一致性容忍度较低的一些业务逻辑单元，如表的元信息。</p><p style="text-align:justify"><strong>可能无需复用的场景</strong>（那就再造一个轮子吧）：</p><p style="text-align:justify">1.没有文档，或文档质量较差；</p><p style="text-align:justify">2.重复造一个不太难，同时维护成本较低；</p><p style="text-align:justify">3.只使用了可复用组件所有功能里的很少一点逻辑；</p><p style="text-align:justify">4.要花费大量的时间去了解可复用组件的设计思路；</p><p style="text-align:justify">5.可复用组件在拓展新功能时，需要投入大量的精力去协同推进；</p><p style="text-align:justify">6.可复用组件集成时的适配或拓展代码，比单独重写该组件的代码还要多；</p><p style="text-align:justify">7.可复用的组件是整个应用的核心，且后续业务发展迅速有较多的定制需求；</p><p style="text-align:justify">8.可复用组件的产品文档或系统设计中承诺了太多的功能（饼），过于「雄心勃勃」；</p><p style="text-align:justify">9.最后一点：如果决策时觉得可用可不用，那大概率也是不需要复用的，相信自己的第一判断。</p><p style="text-align:justify">通过成本和收益估算，以及若干启发式的决策经验，大多数的场景我们都可以评估得到一个清晰的是否复用的答案。软件复用可能会在短期内提高生产力，但它可能会产生长期后果，所以这一步需要慎之又慎。</p><span id="OSC_h4_15"></span><h4><strong>4.2 事中缓释：HCLC&amp;测试&amp;文档</strong></h4><p style="text-align:justify">事中缓释阶段是控制复用性风险的核心环节，它主要聚焦在可复用组件的开发阶段，通过一系列的关键步骤将复用风险在开发或正式使用前尽可能地降低，主要包括下面几个要点：</p><ul><li>高内聚低耦合</li><li>单元测试和回归测试</li><li>完整且有效的文档化</li></ul><p style="text-align:justify"><strong>高内聚低耦合（HCLC）。</strong>这是一个老生常谈的事情了，内聚和耦合会影响可复用水平中的多个指标，如是否内聚会影响可读性和可迁移性，耦合会影响可维护性、可迁移性和可读性。软件工程中已经有很多设计原则或模式供我们选择了，如在代码开发阶段，优先组合、依赖倒置、里式替换、接口隔离、单一职责、开放封闭、23 种设计模式等，在架构设计阶段，也有若干的架构设计模式或方法论，如分层、CQRS、异步事件驱动、领域驱动设计等。</p><p style="text-align:justify"><strong>完整且有效的文档。</strong>「好的代码是自解释性的」，这句话不完全对。首先，无论是我们的架构设计抑或是代码设计，很多东西是无法在代码中体系出来的，如对于领域抽象的取舍、决策的思考过程等，即便是我们的的接口、成员变量、实现，其命名和设计过程已经到了一个非常高的水平，代码中「隐藏信息」还是会损失，而注释可以尽可能去弥补这部分损失。其次，需要认识到：人类的感知与沟通速度是很慢且低效的，需要通过文档去填补双方沟通时的这一道鸿沟。当然，这里讨论的是一般情况，依托「无文档化」构建核心「竞争力」的行为模式不应归入此类。最后，一个正常的组织，人员是会流失的，大部分人最终都会离开这个组织，可复用组件的关键设计者如果不在组织里了，这种知识性的损失将是永久性的，文档（注释、设计）起到了一个备份领域知识的作用。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-865f007635a00f99fa6fbed28bc1075e_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>单元测试和回归测试。</strong>复用理论之所以成立，出发点是我们希望使用已经存在的、成熟的软件资产来提升研发效率，同时降低系统缺陷，一套全面的自动化回归测试，不仅有利于集成方，也会让后续和此可复用组件相关的每一个人受益。如果我们开发的可复用组件没有自动化的回归测试，那这样的组件是不合格的，是不应该发布公共仓库的。缺少自动化测试或核心流程自动化测试覆盖度较低的组件，对于集成方和组件后续的维护者来说是一场灾难，它给系统引入的巨大的技术债甚于完全没有配套文档的可复用组件。</p><span id="OSC_h4_16"></span><h4><strong>4.3 事后迭代：捕捉领域变化&amp;组织</strong></h4><p style="text-align:justify">在开发可复用组件时，如果一开始就大刀阔斧地投入研发资源，最终可能会创建与直接需求无关的软件资产，并由于设计、开发和测试时间的增加而产生重大的进度风险，相反，通过多次迭代改进可复用组件来降低这些风险，<strong>一个良好的组件、框架和软件架构需要时间来设计、实现、优化、验证、应用、维护和增强。</strong>与此同时，第一阶段的开发和集成结束后，在迭代的过程中进行持续性的风险管理，可以使得可复用组件的风险保持在一个较低的水位，尽可能地延长组件的生命力，需要做的主要事项包括：持续捕捉领域变化以及相应的组织支持。</p><p style="text-align:justify"><strong>捕捉领域变化。</strong>上面提到了，代码中有部分内隐的知识，事实上，<strong>一个可复用的组件就是开发者对于某个领域思考的结果</strong>，无论它是以类文件、模块还是系统的方式呈现。而领域都是会变化的，变化包括：领域的边界会拓展、领域内部分实体内涵会变化、不同领域之间的边界会重叠或者融合等。领域变化后，如果在这其中的可复用组件没有进行适当的调整，就会出现技术和业务配速失效的问题。可复用组件在封装了领域知识的同时，也一定程度上屏蔽了复杂度，当组件不足以承担起领域的实体或功能出现偏差时，就会出现「复杂度泄漏」的问题。</p><p style="text-align:justify">捕捉域变化的两个关键动作：统一领域上下文以及关注上游需求池。统一领域上下文重要性不言而喻，<strong>很多时候各方意见出现偏差的根本原因是大家没有形成统一沟通的语言，无法简单、准确且清晰地描述各自的诉求。</strong>我在进行某风险域架构治理时，做的第一件事情就是拉上了业产研三方，统一大家对「规则」和「策略」两个概念的内涵和边界的认知。其次，开发人员和架构师需紧密关注需求池，从需求本身出发，区分领域中可变性和通用性的关键来源。识别出问题域中的所有变化是不现实的，我们可以关注一些关键问题，如面对一个新的需求，可以考虑：</p><p style="text-align:justify">1.我们讨论的概念是否一致？</p><p style="text-align:justify">2.该需求涉及哪些领域实体？</p><p style="text-align:justify">3.该需求是否需要有我们新增实体？</p><p style="text-align:justify">4.新增实体是否会与既有实体产生二义性？</p><p style="text-align:justify">5.之前是否存在类似的需求？有什么不同？</p><p style="text-align:justify">6.新增的需求是否可以和既有的逻辑进行隔离？</p><p style="text-align:justify">7.......</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-b4a6ff6154f2348778fd424cd86b6cfc_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">是否有一种指导原则，可以让我们在跟踪这些域变化的时候，进行更合理的设计与取舍呢？熵增原理告诉我们：一个孤立的热力学系统的熵不减。对于系统的可逆过程熵不变，不可逆过程熵增加。因此，类比软件工程领域，在组件的事后迭代阶段，<strong>一个尽可能消除代码设计/软件架构中熵增的设计原则：在既有组件中新增的功能点需要存在逆向的删除机制</strong>，这样就可以尽可能让可复用组件跳出逐渐混乱无法维护的宿命。功能可逆的具体操作具体可以表现为：SPI 机制（Service Provider Interface ）、面向接口的编程、通过模块隔离随机的或一次性的需求等。</p><p style="text-align:justify"><strong>组织和配套的文化。首先，组织是业务架构的投射</strong>，当复用组件内的领域实体和组织负责的领域实体出现偏差时，就会出现因错位产生的技术债，结果无非是两种：一种是之前的可复用组件直接被抛弃，任由其自生自灭；另一种缺少破釜沉舟进行重构勇气与担当，既然不是我负责的，那就改一改重新用，原先统一均衡的结构会快速打破。<strong>其次，可复用组件和框架的好坏取决于构建和使用它们的人</strong>，我们需要能评估风险和机遇的管理者，需要能识别领域本质复杂度和偶然复杂度、同时能很好掌握设计模式和架构模式的架构师，以及，在开发原则、模式和实践上经验丰富的开发人员，组件是否可复用、可以复用多久，很大程度上是具备良好设计和经验丰富的开发人员的副产品。<strong>再者，在事后迭代阶段，我们需要专门的团队或负责人为此可复用资产负责</strong>，不断监控平台代码库的健康，跟踪和修复错误，坚持正确抽象，不断完善文档。当然上述只是理想情况，更多的时候，这样的人或团队是不存在的，或者即便存在，相应的组织激励也是缺失的，在一个没有复用的文化土壤中，组件腐化只是时间问题。最后，有了正确的组织和优秀的人，长期的<strong>信心、热情、激励以及管理层的支持与响应</strong>，也都是成功的复用必不可少的条件。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-2228938440622697c56b0d0ace934f73_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h3_17"></span><h3>五、关于复用的一点感想</h3><p style="text-align:justify">本文想重点去表达的几个观点：不要过度去追逐「复用」、可复用的水平以及复用投入产出比是可量化的、可复用资产是内隐的领域知识、适度的重复也是可接受的、文档可以弥补领域知识的损失、架构演进中新增功能需可逆。</p><p style="text-align:justify">撰写此篇文章的初衷，一方面源于近几年来在指导新同学时，发现出现较多的「伪复用」现象，例如为了减少代码，将共享的方法签名放在接口中，形成「过程式接口」，另一方面，自己也写过一些「为了复用」而设计的组件或模块，从中间件到业务组件大概有十几个了。但最近逐渐开始意识到，很多时候为了后续的可迁移性，一些架构或代码层的的前向防御性设计作用并不大，过度抽象反而是给使用方造成了一些理解上的困难。到底哪些真的需要复用，哪些可以妥协，梳理完这篇文章后，坚定了一部分想法（例如全程文档化），也给一些既有观念做了纠偏。</p><p style="text-align:justify">上面也一直在传递一个观点，好的软件资产是一个优秀团队的副产品。当把复用的目光从软件聚焦到人，我们自己身上，哪些是可以复用的，哪些又是平台或组织赋予我们的？去除掉那些光怪陆离的虚幻部分，不可变的部分又有哪些？授权后的高价值专利算一种，其有效期为二十年。思考过程中沉淀可能算另一种，它们或多或少且阶段性地概述了当时的所思所想，无论内容是否全面、正确，也涂抹上了时光的颜色，这也是这篇文章产生的另一个动机。</p><p style="text-align:justify">作者｜齐光</p><blockquote><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fclick.aliyun.com%2Fm%2F1000373503%2F" target="_blank"><span style="color:#ff9900">点击立即免费试用云产品，开启云上实践之旅！</span></a></strong></blockquote><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1364680%3Futm_content%3Dg_1000382902" target="_blank">原文链接</a></strong></p><p style="text-align:justify"><strong>本文为阿里云原创内容，未经允许不得转载</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 02:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10140476</guid>
            <link>https://my.oschina.net/yunqi/blog/10140476</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌放弃 Web Environment Integrity API 提案]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">谷歌<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid-developers.googleblog.com%2F2023%2F11%2Fincreasing-trust-for-embedded-media.html" target="_blank">宣布</a>放弃其备受争议的&nbsp;<span style="background-color:#ffffff">Web Environment Integrity API 提案，转而开发&nbsp;</span><span style="background-color:#ffffff">Android WebView Media Integrity API。</span></span></p><p><span style="color:#000000">今年 5 月份，谷歌在开发者邮件列表中宣布了其&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FRupertBenWiser%2FWeb-Environment-Integrity%2Fblob%2Fmain%2Fexplainer.md%23goals" target="_blank">Web Environment Integrity API</a><span style="color:#000000">，旨在作为一种限制在线欺诈和滥用的方法，同时不会引发跨站点跟踪或浏览器指纹识别等隐私问题。但却遭受了公众的强烈反对，认为其更类似于一种网站的数字版权管理（DRM）功能，担心谷歌借此限制网络自由。</span></p><p><span style="color:#000000">因此在收到众多反馈后，谷歌表示其&nbsp;<span style="background-color:#ffffff">Chrome 团队不再考虑&nbsp;Web Environment Integrity API；并将重点转向范围更窄的解决方案 Android WebView Media Integrity API，仅针对应用程序中嵌入的 WebView。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">根据介绍，这个新的 API 只扩展了具有 Google 移动服务 (GMS) 的 Android 设备上的现有功能，并且没有计划提供超出嵌入式媒体（例如流媒体视频和音频）或 Android WebView 之外的功能。</span></span></p><p><span style="color:#000000"><img height="248" src="https://oscimg.oschina.net/oscnet/up-79bb6dbdddd857c0a5caad36bd7b735e59e.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Android WebView API 允许应用程序开发人员显示嵌入媒体的网页，并增强对 UI 的控制和高级配置选项，以允许在应用程序中无缝集成。这为移动应用开发带来了很大的灵活性，但同时也为欺诈和滥用提供了途径；因为它允许应用程序开发人员访问网页内容，拦截或修改用户与网页的交互。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">新的 Android WebView Media Integrity API 旨在使嵌入式媒体提供商能够访问定制的完整性响应，其中包含设备和应用程序的完整性判定，以便他们能够确保他们的流媒体在安全、可信的环境中运行，无论嵌入式应用程序是从哪个应用程序商店安装的。</span></span></p><p><span style="color:#000000">谷歌方面计划<span style="background-color:#ffffff">在明年初，与选定的嵌入式媒体供应商一起试点实验性 Android WebView Media Integrity API。</span></span></p><p><span style="color:#000000">详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid-developers.googleblog.com%2F2023%2F11%2Fincreasing-trust-for-embedded-media.html" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 04:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264883/google-abandons-web-environment-integrity-api</guid>
            <link>https://www.oschina.net/news/264883/google-abandons-web-environment-integrity-api</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[贵阳银行回应证实弃用易鲸捷]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#333333">知名打假人王海发文<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.toutiao.com%2Farticle%2F7297260518304219682%2F" target="_blank">表示</a>，</span><span style="background-color:#ffffff; color:#000000">11 月 2 日下午，贵阳银行董事长张正海在 2023 年第三季度业绩说明会上，回应证实了媒体报道的「贵阳银行弃用了贵州易鲸捷假国产数据库」。</span></p><p><span style="background-color:#ffffff; color:#000000">在与投资者互动和交流中，面对投资人提出的「易鲸捷在贵阳银行建设的数据库进展到什么程度？」的问题时。贵阳银行董事长张正海回答称，「贵阳银行新核心业务系统目前已经完成的开发测试工作，系统进入上线准备阶段，预计于 2023 年 11 月 3 日 17:00 至 11 月 6 日 8:00 进行系统的上线工作。」</span></p><p><img height="199" src="https://oscimg.oschina.net/oscnet/up-54c947b770fd5c4889d4ea002bca25562ad.png" width="700" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">自 2020 年 10 月贵阳银行耗资 4.26 亿元以单一来源方式采购贵州易鲸捷国产数据库应用项目以来，这是贵阳银行第一次在与投资者互动和交流中，针对「易鲸捷数据建设到什么程度」的回答中未提及「贵州易鲸捷」和「国产数据库应用项目」，而是将 11 月 3 日「贵阳银行系统升级」明确改为「上线新核心业务系统」，也拒绝回答关于「易鲸捷数据库项目是否失败？4.27 亿是否存在利益输送」的提问。</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">互动和交流的前一天，已有媒体公开报道称，贵阳银行系统升级，即为贵阳银行酝酿三年的核心业务系统替代工程正式启动，甲骨文将替代贵州易鲸捷承担起改行核心交易业务中的数据库任务，双方合作事宜将另行商议，贵州易鲸捷通过贴牌假冒国产数据库这一丑闻震惊业内，成为舆论热点。</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">此前 10 月 23 日，贵阳银行发布在 11 月 3 日 17：00 至 11 月 6 日 8：00 进行系统升级暂停服务的公告，以系统升级降低舆论对弃用 4.26 亿元天价国产数据的关注。</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000"><img alt="" height="533" src="https://oscimg.oschina.net/oscnet/up-1fd874a630e4c716e5830945c23e9031a97.png" width="300" referrerpolicy="no-referrer"></span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 03:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264876</guid>
            <link>https://www.oschina.net/news/264876</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
