<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 16 Nov 2023 19:12:10 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[微軟推出全新「Windows App」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">微軟在&nbsp;Ignite 2023 上宣佈推出一款適用於 iOS、iPadOS、Web 和 Windows 的全新「Windows App」，目前正以預覽版形式提供。</span></p><p><span style="color:#000000">用戶可以通過該 APP 連接 Windows 365、Azure 虛擬桌面、Microsoft Dev Box 或個人遠程桌面 PC。在手機或 iPad 上，用戶無需下載或安裝任何內容即可啓動 Windows 環境。</span></p><p><span style="color:#000000"><img alt="" height="309" src="https://oscimg.oschina.net/oscnet/up-6de517b3878e038efe903ec950a3f14d987.webp" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">新的 Windows APP 帶來了多項新功能：如支持多顯示器、自定義顯示分辨率、動態顯示縮放、網絡攝像頭、音頻和打印機的設備重定向等。用戶可以固定最喜歡的應用程序，以便快速訪問，還可以在不同賬戶之間輕鬆切換。</span></p><p><span style="color:#000000">雖然微軟官方表示該應用程序僅上架 iOS、Windows、macOS 以及網頁端，但提供的屏幕截圖顯示 Android&nbsp;平板上也能運行該應用。或許 Android 版本將會在不久的未來推出。</span></p><p><span style="color:#000000">不過，該 Windows APP 僅面向微軟企業用戶提供，個人賬戶無法訪問相關服務。但有跡象表明，微軟計劃通過 Windows 365 為普通消費者提供雲 PC。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 09:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266787/microsoft-windows-app-launched-run-cloud-pc</guid>
            <link>https://www.oschina.net/news/266787/microsoft-windows-app-launched-run-cloud-pc</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[ClickHouse 聯合創始人、前 Google 副總裁 Yury 到訪杭州玖章算術公司，雙方建立生態合作]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span><span style="color:#000000">10 月 31 日，ClickHouse 聯合創始人 Yury 到訪未來科技城，與玖章算術創始人葉正盛和國際總經理 Ni Demai 展開溝通與推進合作。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-3abad57e89ff8fcc5278d96ff167a2bf87d.jpg" width="1707" referrerpolicy="no-referrer"></p><p style="color:#999999; margin-left:0; margin-right:0; text-align:center">圖片備註：Ni Demai(左),Yury(中),葉正盛 (右)</p></div><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">ClickHouse 是深受開發者青睞的實時分析型數據庫，成立 2 年就發展成為基礎軟件領域的獨角獸，玖章算術核心產品 NineData 則是中國數據庫工具領域的佼佼者。通過本次溝通，</span><span style="color:#f04142">ClickHouse 將繼續增加其在生態能力上的投入，引入玖章算術成為 ClickHouse 全球正式合作伙伴</span><span style="color:#000000">，NineData 將提供數據複製、SQL 開發等能力，幫助開發者更加便捷、穩定地使用 ClickHouse。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">ClickHouse 中國區負責人王楠（Tracy）、玖章算術首席產品經理蔡冬者參與了本次會議，雙方深度交流了 NineData 幫助 ClikHouse 完成數據複製的實踐場景，將在 ClickHouse 中國社區發展深度合作。</span></span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="1659" src="https://oscimg.oschina.net/oscnet/up-29fbbc98347ec5e04fcc19c903bdcbea0d0.jpg" width="2091" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">Yury 作為 ClickHouse 的聯合創始人、產品和工程總裁，是前谷歌、Netflix 的副總裁。<span style="color:#f04142">本次代表 ClickHouse 與玖章算術 CEO 葉正盛進行溝通，旨在加強兩家公司之間的合作，增強 ClickHouse 的生態能力建設，幫助開發者更好地使用 ClickHouse。</span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="1080" src="https://oscimg.oschina.net/oscnet/up-d6908642b538092775611c1383c849b5928.jpg" width="2301" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">葉正盛是玖章算術創始人，在數據庫生態工具產品裏有 20 年經驗，是國內把數據庫生態工具體系做成專業產品的第一人。後續，</span><span style="color:#f04142">NineData 將快速支持 ClickHouse 最新版本，適配 ClickHouse Cloud，同時會更大力度投入中國 ClickHouse 社區建設。</span></span></p><div><p style="text-align:center"><img alt="" height="1080" src="https://oscimg.oschina.net/oscnet/up-e0d4a2d815c5fc2bf9daf62ae54c45c901c.jpg" width="2301" referrerpolicy="no-referrer"></p><p style="color:#999999; margin-left:0; margin-right:0; text-align:center">玖章算術創始人葉正盛（中）</p></div><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">NineData 提供企業級 SQL 開發能力，包括數據庫堡壘機、生產變更服務，以及細粒度權限管控、審計、敏感數據脫敏處理等功能。並集成了大模型 AI 技術，提供智能 SQL 編寫、SQL 優化和數據庫專業知識問答，能夠幫助客戶提高 DBA 與技術團隊及 ISV 夥伴的合作效率。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">NineData 的數據複製能力可應用於多種場景，包括在線數據庫到數據倉庫實時同步、數據庫國產化替換、數據上雲、數據容災等，支持 1000 公里數據實時同步，複製性能超過 10 萬 TPS，領先於市場主流產品。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">NineData 的創始團隊由阿里雲、華為、IBM 等公司資深數據庫專家組成。NineData 支持 MySQL、Oracle、PostgreSQL、ClickHouse、Redis、MongoDB、Doris 等 60 種主流數據源。</span></span></p><div><p style="text-align:center"><img alt="" height="1332" src="https://oscimg.oschina.net/oscnet/up-7e72cd287ff75493e4b1730da64f74e22f5.png" width="2878" referrerpolicy="no-referrer"></p><p style="color:#999999; margin-left:0; margin-right:0; text-align:center">NineData 支持 60 種主流數據源</p></div><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">目前，NineData 已經為上萬開發者提供服務，在中國移動、沃爾沃、綠城集團等大型企業上線，與華為雲、阿里雲、騰訊雲、百度雲、移動雲、AWS、Apache Doris、SelectDB 等平台建立了緊密合作關係。NineData 的目標是讓企業各個數據源之間的數據自由流動，讓數據管理與研發流程更安全、更高效。</span></span></p><p style="margin-left:0px; margin-right:0px"><span><strong><span style="color:#000000">結束語：</span></strong><span style="color:#000000"><span>&nbsp;</span>ClickHouse 與玖章算術 NineData 的合作將促進其生態系統的發展，NineData 將更好地支持 ClickHouse 數據庫複製、SQL 開發等。這一合作將為中國的 ClickHouse 社區帶來更多支持和創新，進一步推動社區發展，幫助開發者更好的使用 ClickHouse，發掘數據價值，推進企業業務發展。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 09:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266785</guid>
            <link>https://www.oschina.net/news/266785</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GitHub 報告：TypeScript 取代 Java 成為第三受歡迎語言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">GitHub 發佈了 2023 年度&nbsp;Octoverse 開源狀態報告。主要研究了圍繞 AI、雲和 Git 的開源活動如何改變開發人員體驗，以及如何在開發者和企業中產生越來越大的影響。</span></p><p><span style="color:#000000">報告發現了三大趨勢：</span></p><ul><li><span style="color:#000000"><strong>開發人員正在大量使用生成式 AI 進行構建。</strong>越來越多的開發人員嘗試使用 OpenAI 和其他 AI 公司的基礎模型，開源生成式 AI 項目甚至在 2023 年進入了按貢獻者數量排名的十大最受歡迎的開源項目。幾乎所有開發人員 (92%) 都在使用或嘗試藉助 AI 編碼工具。</span></li><li><span style="color:#000000"><strong>開發人員正在大規模運行雲原生應用程序。</strong>使用基於 Git 的基礎設施即代碼 (IaC) 工作流的聲明式語言越來越多，雲部署的標準化程度更高，開發人員使用 Dockerfile 和容器、IaC 以及其他雲原生技術的速度也急劇加快。</span></li><li><span style="color:#000000"><strong>2023 年 first-time 開源貢獻者數量最多。</strong>其中，有商業支持的開源項目依舊最受貢獻者歡迎。但生成式 AI 項目在今年進入了 first-time 貢獻者最受歡迎的的十大項目之列。GitHub 上的私人項目顯着增長，同比增長 38%，佔 GitHub 上所有活動的 80% 以上。</span></li></ul><p><span style="color:#000000"><strong>全球開發者社區</strong>繼續增長。美國擁有 2020 萬開發者，開發者人數在去年增長了 21%，仍然是全球最大的開發者社區。亞太地區、非洲、南美洲和歐洲的開發者社區規模逐年擴大，其中印度、巴西和日本處於領先地位。</span></p><p><span style="color:#000000">預計到 2027 年，印度將取代美國成為 GitHub 上最大的開發者社區。新加坡今年是亞太地區開發者人數增長最快的國家，並且是開發者佔總人口的比例最高的第地區（全球範圍內）。報告指出，由於日本在技術和初創企業方面的進一步投資，明年日本的開發者將有持續增長。</span></p><p><img alt="" height="281" src="https://oscimg.oschina.net/oscnet/up-ac720a0e760e91cc5b2eb3fbe5912621880.webp" width="500" referrerpolicy="no-referrer"></p><p><img height="356" src="https://oscimg.oschina.net/oscnet/up-80f62228356fcbdefb478e041a0eac39e37.png" width="400" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><strong>生成式 AI </strong>在 2023 年經歷了爆發式增長，僅半年內湧現出的生成式 AI 項目數量就已達到了 2022 年全年的兩倍之多。開發人員也開始更多地嘗試使用 AI 模型。前幾年，開發人員常使用 tensorflow/tensorflow、pytorch/pytorch 等機器學習庫構建項目；現在則更多嘗試使用 AI 模型和 LLM（如 ChatGPT API）。</span></p><p><img height="270" src="https://oscimg.oschina.net/oscnet/up-7496f60e2ee0f94240f5faf6341e5262a5b.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">報告分析了 GitHub 上排名前 20 位的開源生成式 AI 項目，發現其中一些頂級項目都是由個人所有。生成式 AI 項目中的個人貢獻者正在全球範圍內大幅飆升，同比增長幅度達到了 148%，而生成式 AI 項目總數也同比增長 248%。</span></p><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">美國、印度和日本在開發者社區中處於領先地位，</span><span style="background-color:#ffffff; color:#24292f">香港特別行政區</span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">、英國和巴西緊隨其後。</span></p><p><img height="257" src="https://oscimg.oschina.net/oscnet/up-24b4f2b8554174e97591f4e9b11183c4b8e.png" width="500" referrerpolicy="no-referrer"></p><p><strong style="color:rgba(0, 0, 0, 0.9)">最流行的編程語言</strong></p><p><img height="144" src="https://oscimg.oschina.net/oscnet/up-3a0a14c95ce1e310f742e6ce36ad9af9795.png" width="500" referrerpolicy="no-referrer"></p><p>報告指出，<span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">自 2019 年雲原生開發大規模增長以來，IaC 在開源領域持續增長。2023 年，Shell 和 Hashicorp 配置語言（HCL）再次成為開源項目中的頂級語言，</span><span style="background-color:#ffffff; color:#24292f">HCL 採用率同比增長 36%；「表明運維和 IaC 工作在開源領域越來越受到重視」。</span></p><p><img height="263" src="https://oscimg.oschina.net/oscnet/up-72dde2bf24c363d79ba454d8df65c964a2b.png" width="500" referrerpolicy="no-referrer"></p><ul style="list-style-type:disc; margin-left:0; margin-right:0"><li><span style="color:#000000">JavaScript 仍然是 GitHub 上最常用的語言，其次是 Python。</span></li><li><span style="color:#000000">TypeScript 越來越受歡迎，<span style="background-color:#ffffff">首次取代 Java 成為 GitHub 上 OSS 項目中第三大最受歡迎的語言，其用戶羣增長了 37%。</span></span></li><li><span style="color:#000000">用於數據分析和操作的流行語言和框架明顯增加。T-SQL 和 TeX 等古老的語言在 2023 年均有所增長，凸顯了數據科學家、數學家和分析師越來越多地使用開源平台和工具。「<span style="background-color:#ffffff">編程語言不再僅僅侷限於傳統軟件開發領域</span>」。</span></li><li><span style="color:#000000"><span style="background-color:#ffffff">在 GitHub 上一些較新的項目中，Kotlin、Rust、Go 和 Lua 的採用出現了較大的增長。「Rust 和 Lua 都以內存安全和高效著稱，而且都可用於系統和嵌入式系統編程，這也是它們增長的原因。而 Go 最近的增長則是由 Kubernetes 和 Prometheus 等雲原生項目的推動。」</span></span></li></ul><p><img height="262" src="https://oscimg.oschina.net/oscnet/up-58e41eb95e2505a64d2a2a8a7b46fdf4ee6.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">其他一些發現還包括：</span></span></p><ul><li><span style="color:#000000"><span style="background-color:#ffffff">與 2022 年相比，2023 年開源代碼開發人員合併的針對易受攻擊軟件包的自動 Dependabot 拉取請求增加了 60%</span></span></li><li><span style="color:#000000"><span style="background-color:#ffffff">2023 年，</span><span style="background-color:#ffffff">開發者</span><span style="background-color:#ffffff">為 GitHub 上的開源項目做出了 3.01 億次貢獻，這些項目既有像 Mastodon 這樣的熱門項目，也有像 Stable Diffusion 和 LangChain 這樣的生成式 AI 項目。</span></span></li><li><span style="color:#000000"><span style="background-color:#ffffff">2023 年有 430 萬個存儲庫使用了 Docker。Linux 發行版 NixOS/nixpkgs 在過去兩年中一直位居開源項目貢獻者榜首。</span></span></li></ul><p><span style="background-color:#ffffff; color:#333333">更多詳情可</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.blog%2F2023-11-08-the-state-of-open-source-and-ai%2F" target="_blank">查看完整報告</a><span style="background-color:#ffffff; color:#333333">。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 07:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266757/2023-state-of-the-octoverse</guid>
            <link>https://www.oschina.net/news/266757/2023-state-of-the-octoverse</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[李開復再回應爭議：受益於開源也貢獻開源]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>針對旗下「零一萬物」 開源的 Yi 大模型近日被質疑照搬 Llama 架構，只對兩個張量（Tensor）名稱做了修改的風波，李開復在朋友圈<span style="color:#030303">轉發了「</span><a href="https://www.oschina.net/news/266597" target="news">零一萬物對 Yi-34B 訓練過程的説明</a><span style="color:#030303">」文章，並配文</span>迴應稱：</p><blockquote><p><span style="color:#030303">零一萬物 Yi-34B 模型訓練的説明也迴應這兩天大家對於模型架構的探討。全球大模型架構一路從 GPT2--&gt;Gopher--&gt;Chinchilla--&gt;Llama2-&gt;Yi，行業逐漸形成大模型的通用標準（就像做一個手機 app 開發者不會去自創 iOS、Android 以外的全新基礎架構）。01.AI 起步受益於開源，也貢獻開源，從社區中虛心學習，我們會持續進步。</span></p></blockquote><p><img height="290" src="https://static.oschina.net/uploads/space/2023/1116/141708_SLoh_4252687.png" width="300" referrerpolicy="no-referrer"></p><p><strong>相關閲讀：</strong></p><ul><li><a href="https://www.oschina.net/news/266377">李開復旗下 AI 公司 「零一萬物」 開源的 Yi 大模型照搬 Llama 架構</a></li><li><a href="https://www.oschina.net/news/266525">「零一萬物」 迴應 Yi 開源大模型 「套殼」 Llama</a></li><li><p style="margin-left:0px; margin-right:0px; text-align:start"><a href="https://www.oschina.net/news/266597" target="_blank">零一萬物對 Yi-34B 訓練過程的説明</a></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 06:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266727</guid>
            <link>https://www.oschina.net/news/266727</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[.NET 8.0 中有哪些新的變化？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong>1 性能提升</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fperformance-improvements-in-aspnet-core-8%2F" target="_blank">.NET 8 在整個</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fdotnet-8-performance-improvements-in-dotnet-maui%2F" target="_blank">堆棧</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fthis-arm64-performance-in-dotnet-8%2F" target="_blank">中</a>帶來了數千項性能<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fperformance-improvements-in-net-8%2F" target="_blank">改進</a> 。默認情況下會啓用一種名為動態配置文件引導優化 (PGO) 的新代碼生成器，它可以根據實際使用情況優化代碼，並且可以將應用程序的性能提高高達 20%。現在支持的 AVX-512 指令集能夠對 512 位數據向量執行並行操作，這意味着可以在更短的時間內處理更多的數據。原始類型（數字及其他類型）現在實現了新的可格式化和可解析接口，這使它們能夠直接格式化和解析為 UTF-8，而無需任何轉碼開銷。 <img src="https://img-blog.csdnimg.cn/img_convert/b91071a2632a5da242e53238fb844e52.png" alt="" referrerpolicy="no-referrer"></p><p><strong>2.NET Aspire</strong></p><p>.NET Aspire 是一個用於使用 .NET 構建彈性、可觀察和可配置的雲原生應用程序的堆棧。它包括一組針對雲原生而增強的精選組件，默認情況下包括遙測、彈性、配置和運行狀況檢查。結合複雜而簡單的本地開發人員體驗，.NET Aspire 可以在第 1 天和第 100 天輕鬆發現、獲取和配置雲原生應用程序的基本依賴項。</p><p>點擊這裏查看.NET Aspire 的預覽版本。 <img src="https://img-blog.csdnimg.cn/img_convert/ba664a021af354f1fc46c013578b8946.png" alt="" referrerpolicy="no-referrer"></p><p><strong>3.NET 8 容器增強功能 – 更安全、更緊湊、更高效</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fsecuring-containers-with-rootless%2F" target="_blank">使用 .NET 比以往更輕鬆、更安全地使用容器</a>打包應用程序。每個 .NET 映像都包含一個非 root 用戶，從而通過單行配置啓用更安全的容器。.NET SDK 工具無需 Dockerfile 即可發佈容器映像，並且默認情況下是非 root 的。由於 .NET 基礎映像更小，因此可以更快地部署容器化應用程序 - 包括我們映像的新實驗變體，這些變體可為本機 AOT 提供真正最小的應用程序大小。選擇使用新的 Chiseled Ubuntu 映像變體進行更多安全強化，以進一步減少攻擊面。使用 Dockerfile 或 SDK 工具，為任何架構構建應用程序和容器映像。 <img src="https://img-blog.csdnimg.cn/img_convert/16b65a6962356cd1e24f164cf66ead3c.png" alt="" referrerpolicy="no-referrer"></p><p><strong>4 原生 AoT – 邁向更高密度可持續計算的旅程</strong></p><p>無需等待 JIT（即時）編譯器在運行時編譯代碼。無需部署 JIT 編譯器和 IL 代碼。AOT 應用程序僅部署應用程序所需的代碼。應用程序現在可以在不允許使用 JIT 編譯器的受限環境中運行。 <img src="https://img-blog.csdnimg.cn/img_convert/5037b084ad2c4e26f6696f6c7b74712a.png" alt="" referrerpolicy="no-referrer"></p><p><strong>5 人工智能 – 將 AI 融入您的 .NET 應用程序</strong></p><p>生成式人工智能和大型語言模型正在改變人工智能領域，使開發人員能夠在其應用程序中創建獨特的人工智能體驗。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgist.github.com%2FLadyNaggaga%2F5b0a708f2b945f5c8ca8ade4974665ff" target="_blank">.NET 8 可以</a>通過 .NET SDK 中一流的開箱即用 AI 功能以及與多種工具的無縫集成來輕鬆利用 AI。</p><p>.NET 8 為該，庫帶來了多項增強功能，以提高其與生成式 AI 工作負載的兼容性，例如集成 Tensor Primitives。隨着人工智能應用程序的興起，新的工具和 SDK 出現了。我們與眾多內部和外部合作伙伴合作，例如 Azure OpenAI、Azure Cognitive Search、Milvus、Qdrant 和 Microsoft Teams，以確保 .NET 開發人員可以通過各自的 SDK 輕鬆訪問各種 AI 模型、服務和平台。此外，開源語義內核 SDK 簡化了這些 AI 組件與新的和現有應用程序的集成，以幫助您提供創新的用戶體驗。System.Numerics</p><p>現在提供各種示例和參考模板，展示模式和實踐，以便開發人員輕鬆入門：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdotnet%2FeShop" target="_blank">客戶聊天機器人</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAzure-Samples%2Fazure-search-openai-demo-csharp" target="_blank">檢索增強生成</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fdemystifying-retrieval-augmented-generation-with-dotnet%2F" target="_blank">使用 Azure AI 服務開發應用程序</a><img src="https://img-blog.csdnimg.cn/img_convert/892b90ec5d84e0bf792f8dba707dce58.png" alt="" referrerpolicy="no-referrer"></li></ul><p><strong>6Blazor – 使用 .NET 構建全棧 Web 應用程序</strong></p><p>.NET 8 中的 Blazor 可以同時使用服務器和客戶端來處理您的所有 Web UI 需求。這是全棧 Web UI！通過專注於優化頁面加載時間、可擴展性和提升用戶體驗的多項新增強功能，開發人員現在可以在同一應用程序中使用 Blazor Server 和 Blazor WebAssembly，在運行時自動將用戶從服務器轉移到客戶端。得益於新的基於「Jiterpreter」的運行時和新的內置組件，您的 .NET 代碼在 WebAssembly 上的運行速度顯着加快。作為增強.NET 8 中整體身份驗證、授權和身份管理的一部分，Blazor 現在支持生成完整的基於 Blazor 的身份 UI。 <img src="https://img-blog.csdnimg.cn/img_convert/f0563b1ef218bb7b09130df55e5de700.png" alt="" referrerpolicy="no-referrer"></p><p><strong>7.NET MAUI – 提升性能、可靠性和開發人員體驗</strong></p><p>.NET MAUI 提供單一項目系統和單一代碼庫來構建 WinUI、Mac Catalyst、iOS 和 Android 應用程序。本機 AOT（實驗性）現在支持針對類似 iOS 的平台。適用於 .NET MAUI 的新 Visual Studio Code 擴展為您提供了開發跨平台 .NET 移動和桌面應用程序所需的工具。現在支持 Xcode 15 和 Android API 34，允許您瞄準最新版本的 iOS 和 Android。在性能、控件和 UI 元素以及特定於平台的行為方面進行了大量的質量改進，例如桌面交互添加了更好的點擊處理、鍵盤偵聽器等。 <img src="https://img-blog.csdnimg.cn/img_convert/130807a5e11b784d65aa556290afda0d.png" alt="" referrerpolicy="no-referrer"></p><p><strong>8 C# 12 功能 – 簡化語法以提高開發人員的工作效率</strong></p><p>C# 12 讓您的編碼體驗更加高效和愉快。現在，您可以使用簡單而優雅的語法在任何類和結構中創建主構造函數。不再需要樣板代碼來初始化您的字段和屬性。使用簡潔且富有表現力的語法創建數組、跨度和其他集合類型時會感到高興。對 lambda 表達式中的參數使用新的默認值。不再需要重載或空檢查來處理可選參數。您甚至可以使用 usingalias 指令為任何類型添加別名，而不僅僅是命名類型！</p><p><strong>8.1 集合表達式</strong></p><p>在 C# 12 之前，創建集合需要針對不同場景使用不同的語法。初始化所需的與 or 不同的語法。以下是創建集合的幾種方法：List&lt;int&gt;int[]Span&lt;int&gt;</p><pre><code class="language-C#">int[] x1 = new int[] { 1, 2, 3, 4 };
int[] x2 = Array.Empty&lt;int&gt;();
WriteByteArray(new[] { (byte)1, (byte)2, (byte)3 });
List&lt;int&gt; x4 = new() { 1, 2, 3, 4 };
Span&lt;DateTime&gt; dates = stackalloc DateTime[] { GetDate(0), GetDate(1) };
WriteByteSpan(stackalloc[] { (byte)1, (byte)2, (byte)3 });
</code></pre><p><strong>8.2 任何類或結構上的主構造函數</strong></p><p>C# 12 擴展了主構造函數以適用於所有類和結構，而不僅僅是記錄。主構造函數允許在聲明類時定義構造函數參數：</p><pre><code class="language-C#">public class BankAccount(string accountID, string owner)
{
    public string AccountID { get; } = accountID;
    public string Owner { get; } = owner;

    public override string ToString() =&gt; $"Account ID: {AccountID}, Owner: {Owner}";
}
</code></pre><p>主構造函數參數最常見的用途是：</p><ul><li>作為 base() 構造函數調用的參數。</li><li>初始化成員字段或屬性。</li><li>在實例成員中引用構造函數參數。</li><li>刪除依賴注入中的樣板。</li></ul><p><strong>8.3 別名任意類型</strong></p><p>別名類型是從代碼中刪除複雜類型簽名的便捷方法。using 從 C# 12 開始，其他類型在別名指令中有效。例如，這些別名在早期版本的 C# 中無效：</p><pre><code class="language-C#">using intArray = int[]; // Array types.
using Point = (int x, int y);  // Tuple type
using unsafe ArrayPtr = int*;  // Pointer type (requires "unsafe")
</code></pre><p><strong>8.4 默認 lambda 參數</strong></p><p>從 C# 12 開始，您可以在 lambda 表達式中聲明默認參數：</p><pre><code class="language-C#">var IncrementBy = (int source, int increment = 1) =&gt; source + increment;

Console.WriteLine(IncrementBy(5)); // 6
Console.WriteLine(IncrementBy(5, 2)); // 7
</code></pre><p><strong>8.5 內聯數組</strong></p><p>運行時團隊和其他庫作者使用內聯數組來提高應用的性能。 內聯數組使開發人員能夠創建固定大小的 struct 類型數組。 具有內聯緩衝區的結構應提供類似於不安全的固定大小緩衝區的性能特徵。 你可能不會聲明自己的內聯數組，但當它們從運行時 API 作為 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.span-1" target="_blank">System.Span&lt;T&gt;</a> 或 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.readonlyspan-1" target="_blank">System.ReadOnlySpan&lt;T&gt;</a> 對象公開時，你將透明地使用這些數組。</p><pre><code class="language-C#">[System.Runtime.CompilerServices.InlineArray(10)]
public struct Buffer
{
    private int _element0;
}
</code></pre><p>它們的用法與任何其他數組類似：</p><pre><code class="language-C#">var buffer = new Buffer();
for (int i = 0; i &lt; 10; i++)
{
    buffer[i] = i;
}

foreach (var i in buffer)
{
    Console.WriteLine(i);
}
</code></pre><p>區別在於編譯器可以利用有關內聯數組的已知信息。 你可能會像使用任何其他數組一樣使用內聯數組。 有關如何聲明內聯數組的詳細信息，請參閲有關 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fcsharp%2Flanguage-reference%2Fbuiltin-types%2Fstruct%23inline-arrays" target="_blank">struct</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fcsharp%2Flanguage-reference%2Fbuiltin-types%2Fstruct%23inline-arrays" target="_blank">類型</a>的語言參考。</p><p><strong>9.反射改進</strong></p><p>.NET 5 中引入了函數指針，但當時未添加對反射的相應支持。 對函數指針使用 typeof 或反射時（例如分別使用 typeof(delegate*&lt;void&gt;()) 或 FieldInfo.FieldType），返回了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.intptr" target="_blank">IntPtr</a>。 從 .NET 8 開始，將改為返回 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.type" target="_blank">System.Type</a> 對象。 此類型提供對函數指針元數據的訪問，包括調用約定、返回類型和參數。</p><p>新功能目前僅在 CoreCLR 運行時和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.reflection.metadataloadcontext" target="_blank">MetadataLoadContext</a> 中實現。已將新的 API 添加到 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.type" target="_blank">System.Type</a>（例如 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.type.isfunctionpointer%23system-type-isfunctionpointer" target="_blank">IsFunctionPointer</a>）以及 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.reflection.propertyinfo" target="_blank">System.Reflection.PropertyInfo</a>、System.Reflection.FieldInfo 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.reflection.parameterinfo" target="_blank">System.Reflection.ParameterInfo</a>。 以下代碼演示如何使用一些新 API 進行反射。</p><pre><code class="language-C#">// Sample class that contains a function pointer field.
public unsafe class UClass
{
    public delegate* unmanaged[Cdecl, SuppressGCTransition]&lt;in int, void&gt; _fp;
}

// ...

FieldInfo fieldInfo = typeof(UClass).GetField(nameof(UClass._fp));

// Obtain the function pointer type from a field.
Type fpType = fieldInfo.FieldType;

// New methods to determine if a type is a function pointer.
Console.WriteLine($"IsFunctionPointer: {fpType.IsFunctionPointer}");
Console.WriteLine($"IsUnmanagedFunctionPointer: {fpType.IsUnmanagedFunctionPointer}");

// New methods to obtain the return and parameter types.
Console.WriteLine($"Return type: {fpType.GetFunctionPointerReturnType()}");

foreach (Type parameterType in fpType.GetFunctionPointerParameterTypes())
{
    Console.WriteLine($"Parameter type: {parameterType}");
}

// Access to custom modifiers and calling conventions requires a "modified type".
Type modifiedType = fieldInfo.GetModifiedFieldType();

// A modified type forwards most members to its underlying type.
Type normalType = modifiedType.UnderlyingSystemType;

// New method to obtain the calling conventions.
foreach (Type callConv in modifiedType.GetFunctionPointerCallingConventions())
{
    Console.WriteLine($"Calling convention: {callConv}");
}

// New method to obtain the custom modifiers.
foreach (Type modreq in modifiedType.GetFunctionPointerParameterTypes()[0].GetRequiredCustomModifiers())
{
    Console.WriteLine($"Required modifier for first parameter: {modreq}");
}
</code></pre><p>輸出：</p><pre><code class="language-C#">IsFunctionPointer: True
IsUnmanagedFunctionPointer: True
Return type: System.Void
Parameter type: System.Int32&amp;
Calling convention: System.Runtime.CompilerServices.CallConvSuppressGCTransition
Calling convention: System.Runtime.CompilerServices.CallConvCdecl
Required modifier for first parameter: System.Runtime.InteropServices.InAttribute
</code></pre><p><strong>10.配置綁定源生成器</strong></p><p>.NET 8 引入了一個源生成器，用於在 ASP.NET Core 中提供 AOT 和適合剪裁的配置。 該生成器是現有的基於反射的實現的替代方法。</p><p>源生成器探測 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fmicrosoft.extensions.options.configureoptions-1.configure%23microsoft-extensions-options-configureoptions-1-configure%28-0%29" target="_blank">Configure(TOptions)</a>、Bind 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fmicrosoft.extensions.configuration.configurationbinder.get" target="_blank">Get</a> 調用來從中檢索類型信息。 在項目中啓用生成器後，編譯器將隱式選擇生成的方法，而非預先存在的基於反射的框架實現。</p><p>無需更改源代碼即可使用生成器。 AOT Web 應用中默認啓用該生成器。 對於其他項目類型，源生成器默認關閉，但你可通過在項目文件中將 EnableConfigurationBindingGenerator 屬性設置為 true 來選擇使用它：</p><pre><code class="language-XML">&lt;PropertyGroup&gt;
    &lt;EnableConfigurationBindingGenerator&gt;true&lt;/EnableConfigurationBindingGenerator&gt;
&lt;/PropertyGroup&gt;
</code></pre><p>以下代碼演示了調用綁定器的示例：</p><pre><code class="language-C#">using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

WebApplicationBuilder builder = WebApplication.CreateBuilder(args);
IConfigurationSection section = builder.Configuration.GetSection("MyOptions");

// !! Configure call - to be replaced with source-gen'd implementation
builder.Services.Configure&lt;MyOptions&gt;(section);

// !! Get call - to be replaced with source-gen'd implementation
MyOptions options0 = section.Get&lt;MyOptions&gt;();

// !! Bind call - to be replaced with source-gen'd implementation
MyOptions options1 = new MyOptions();
section.Bind(options1);

WebApplication app = builder.Build();
app.MapGet("/", () =&gt; "Hello World!");
app.Run();

public class MyOptions
{
    public int A { get; set; }
    public string S { get; set; }
    public byte[] Data { get; set; }
    public Dictionary&lt;string, string&gt; Values { get; set; }
    public List&lt;MyClass&gt; Values2 { get; set; }
}

public class MyClass
{
    public int SomethingElse { get; set; }
}
</code></pre><p><strong>11.針對 Android 應用的 AOT 編譯</strong></p><p>為了減小應用大小，面向 Android 的 .NET 和 .NET MAUI 應用在發佈模式下構建時使用分析的預先 (AOT) 編譯模式。 與常規 AOT 編譯相比，分析的 AOT 編譯所影響的方法更少。 .NET 8 引入了 &lt;AndroidStripILAfterAOT&gt; 屬性，你可使用它進一步對 Android 應用進行 AOT 編譯，從而更進一步減少應用大小。</p><pre><code class="language-XML">&lt;PropertyGroup&gt;
  &lt;AndroidStripILAfterAOT&gt;true&lt;/AndroidStripILAfterAOT&gt;
&lt;/PropertyGroup&gt;
</code></pre><p>默認情況下，將 AndroidStripILAfterAOT 設置為 true 會替代默認的 AndroidEnableProfiledAot 設置，從而允許剪裁已 AOT 編譯的（幾乎）所有方法。 還可通過將兩個屬性都顯式設置為 true 來結合使用分析的 AOT 和 IL 條帶化：</p><pre><code class="language-XML">&lt;PropertyGroup&gt;
  &lt;AndroidStripILAfterAOT&gt;true&lt;/AndroidStripILAfterAOT&gt;
  &lt;AndroidEnableProfiledAot&gt;true&lt;/AndroidEnableProfiledAot&gt;
&lt;/PropertyGroup&gt;
</code></pre><p><strong>12.代碼分析</strong></p><p>.NET 8 包括幾個新的代碼分析器和修復程序，可幫助驗證是否正確且高效地使用 .NET 庫 API。 下表總結了新的分析器。</p><table><thead><tr><th>規則 ID</th><th>類別</th><th>説明</th></tr></thead><tbody><tr><td>CA1856</td><td>性能</td><td>未在參數上正確應用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.diagnostics.codeanalysis.constantexpectedattribute" target="_blank">ConstantExpectedAttribute</a> 屬性時觸發。</td></tr><tr><td>CA1857</td><td>性能</td><td>當參數使用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.diagnostics.codeanalysis.constantexpectedattribute" target="_blank">ConstantExpectedAttribute</a> 添加批註但提供的參數不是常量時觸發。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1858" target="_blank">CA1858</a></td><td>性能</td><td>若要確定字符串是否以給定前綴開頭，最好調用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.string.startswith" target="_blank">String.StartsWith</a>，而不是調用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.string.indexof" target="_blank">String.IndexOf</a>，然後將結果與零進行比較。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1859" target="_blank">CA1859</a></td><td>性能</td><td>此規則建議儘可能將特定局部變量、字段、屬性、方法參數和方法返回類型從接口或抽象類型升級到具體類型。 使用具體類型可生成更高質量的代碼。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1860" target="_blank">CA1860</a></td><td>性能</td><td>若要確定集合類型是否具有任何元素，最好使用 Length、Count 或 IsEmpty，而不是調用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.linq.enumerable.any" target="_blank">Enumerable.Any</a>。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1861" target="_blank">CA1861</a></td><td>性能</td><td>重複調用時，不會重複使用作為參數傳遞的常量數組，這意味着每次都會創建一個新數組。 若要提高性能，請考慮將數組提取到靜態只讀字段。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1865-ca1867" target="_blank">CA1865-CA1867</a></td><td>性能</td><td>對於單字符串，char 重載的性能更好。</td></tr><tr><td>CA2021</td><td>可靠性</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.linq.enumerable.cast%23system-linq-enumerable-cast-1%28system-collections-ienumerable%29" target="_blank">Enumerable.Cast(IEnumerable)</a> 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.linq.enumerable.oftype%23system-linq-enumerable-oftype-1%28system-collections-ienumerable%29" target="_blank">Enumerable.OfType(IEnumerable)</a> 需要兼容的類型才能正常運行。 泛型類型不支持擴大轉換和用戶定義的轉換。</td></tr><tr><td>CA1510-CA1513</td><td>可維護性</td><td>在構造新的異常實例方面，引發幫助程序比 if 塊更簡單、更高效。 這四個分析器是為以下例外情況創建的：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.argumentnullexception" target="_blank">ArgumentNullException</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.argumentexception" target="_blank">ArgumentException</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.argumentoutofrangeexception" target="_blank">ArgumentOutOfRangeException</a> 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.objectdisposedexception" target="_blank">ObjectDisposedException</a>。</td></tr></tbody></table><p><strong>13.Core .NET 庫</strong></p><p><strong>13.1 時間抽象</strong></p><p>新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.timeprovider" target="_blank">TimeProvider</a> 類和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.itimer" target="_blank">ITimer</a> 接口添加了時間抽象功能，讓你可以在測試方案中模擬時間。 此外，還可以使用時間抽象，通過 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.tasks.task.delay" target="_blank">Task.Delay</a> 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.tasks.task.waitasync" target="_blank">Task.WaitAsync</a> 來模擬依賴於時間進度的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.tasks.task" target="_blank">Task</a> 操作。 時間抽象支持以下基本時間操作：</p><ul><li>檢索本地和 UTC 時間</li><li>獲取用於測量性能的時間戳</li><li>創建計時器</li></ul><p>以下代碼片段演示了一些使用情況示例。</p><pre><code class="language-C#">// Get system time.
DateTimeOffset utcNow = TimeProvider.System.GetUtcNow();
DateTimeOffset localNow = TimeProvider.System.GetLocalNow();

// Create a time provider that works with a
// time zone that's different than the local time zone.
private class ZonedTimeProvider : TimeProvider
{
    private TimeZoneInfo _zoneInfo;

    public ZonedTimeProvider(TimeZoneInfo zoneInfo) : base()
    {
        _zoneInfo = zoneInfo ?? TimeZoneInfo.Local;
    }

    public override TimeZoneInfo LocalTimeZone =&gt; _zoneInfo;

    public static TimeProvider FromLocalTimeZone(TimeZoneInfo zoneInfo) =&gt;
        new ZonedTimeProvider(zoneInfo);
}

// Create a timer using a time provider.
ITimer timer = timeProvider.CreateTimer(callBack, state, delay, Timeout.InfiniteTimeSpan);

// Measure a period using the system time provider.
long providerTimestamp1 = TimeProvider.System.GetTimestamp();
long providerTimestamp2 = TimeProvider.System.GetTimestamp();

var period = GetElapsedTime(providerTimestamp1, providerTimestamp2);
</code></pre><p><strong>13.2UTF8 改進</strong></p><p>如果要啓用將類型的類似字符串的表示形式寫出到目標範圍，請在類型上實現新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.iutf8spanformattable" target="_blank">IUtf8SpanFormattable</a> 接口。 此新接口與 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.ispanformattable" target="_blank">ISpanFormattable</a> 密切相關，但面向 UTF8 和 Span&lt;byte&gt;，而不是 UTF16 和 Span&lt;char&gt;。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.iutf8spanformattable" target="_blank">IUtf8SpanFormattable</a> 已在所有基元類型（以及其他）上實現，無論是面向 string、Span&lt;char&gt; 還是 Span&lt;byte&gt;，其共享邏輯完全一致。 它完全支持所有格式（包括新的「B」二進制説明符）和所有區域性。 這意味着現在可以從 Byte、Complex、Char、DateOnly、DateTime、DateTimeOffset、Decimal、Double、Guid、Half、IPAddress、IPNetwork、Int16、Int32、Int64、Int128、IntPtr、NFloat、SByte、Single、Rune、TimeOnly、TimeSpan、UInt16、UInt32、UInt64、UInt128、UIntPtr 和 Version 直接格式化為 UTF8。</p><p>新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.text.unicode.utf8.trywrite" target="_blank">Utf8.TryWrite</a> 方法向現有 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.memoryextensions.trywrite" target="_blank">MemoryExtensions.TryWrite</a> 方法（基於 UTF16）提供基於 UTF8 的對應方法。 可以使用內插字符串語法將複雜表達式直接格式化為 UTF8 字節範圍，例如：</p><pre><code class="language-C#">static bool FormatHexVersion(
    short major,
    short minor,
    short build,
    short revision,
    Span&lt;byte&gt; utf8Bytes,
    out int bytesWritten) =&gt;
    Utf8.TryWrite(
        utf8Bytes,
        CultureInfo.InvariantCulture,
        $"{major:X4}.{minor:X4}.{build:X4}.{revision:X4}",
        out bytesWritten);
</code></pre><p><strong>13.3 加密</strong></p><p>.NET 8 添加了對 SHA-3 哈希基元的支持。 （目前，具有 OpenSSL 1.1.1 或更高版本和 Windows 11 Build 25324 或更高版本的 Linux 支持 SHA-3。）可在其中使用 SHA-2 的 API 現在提供對 SHA-3 的補充。 對於哈希，這包括 SHA3_256、SHA3_384 和 SHA3_512；對於 HMAC，這包括 HMACSHA3_256、HMACSHA3_384 和 HMACSHA3_512；對於其中可配置算法的哈希，這包括 HashAlgorithmName.SHA3_256、HashAlgorithmName.SHA3_384 和 HashAlgorithmName.SHA3_512；對於 RSA OAEP 加密，這包括 RSAEncryptionPadding.OaepSHA3_256、RSAEncryptionPadding.OaepSHA3_384 和 RSAEncryptionPadding.OaepSHA3_512。</p><p>以下示例演示如何使用 API（包括 SHA3_256.IsSupported 屬性）來確定平台是否支持 SHA-3。</p><pre><code class="language-C#">// Hashing example
if (SHA3_256.IsSupported)
{
    byte[] hash = SHA3_256.HashData(dataToHash);
}
else
{
    // ...
}

// Signing example
if (SHA3_256.IsSupported)
{
     using ECDsa ec = ECDsa.Create(ECCurve.NamedCurves.nistP256);
     byte[] signature = ec.SignData(dataToBeSigned, HashAlgorithmName.SHA3_256);
}
else
{
    // ...
}
</code></pre><p><strong>13.4 基於流的 ZipFile 方法</strong></p><p>.NET 8 包含 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.io.compression.zipfile.createfromdirectory" target="_blank">ZipFile.CreateFromDirectory</a> 的新重載，通過它可以收集目錄中包含的所有文件並壓縮這些文件，然後將生成的 zip 文件存儲到提供的流中。 同樣，通過新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.io.compression.zipfile.extracttodirectory" target="_blank">ZipFile.ExtractToDirectory</a> 重載，可提供包含壓縮文件的流，並將其內容提取到文件系統中。 下面是新的重載：</p><pre><code class="language-C#">namespace System.IO.Compression;

public static partial class ZipFile
{
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination);
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, CompressionLevel compressionLevel, bool includeBaseDirectory);
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, CompressionLevel compressionLevel, bool includeBaseDirectory, Encoding? entryNameEncoding);

    public static void ExtractToDirectory(Stream source, string destinationDirectoryName) { }
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, bool overwriteFiles) { }
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, Encoding? entryNameEncoding) { }
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, Encoding? entryNameEncoding, bool overwriteFiles) { }
}
</code></pre><p>參考資料：</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fcore%2Fwhats-new%2Fdotnet-8%23networking" target="_blank">https://learn.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-8#networking</a></p><p><strong>擴展鏈接：</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fblogs%2Fexcel-io-spreadjs-blazor" target="_blank">如何使用 Blazor 框架在前端瀏覽器中導入/導出 Excel XLSX</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fblogs%2Fcreate-flow-chart-dotnet" target="_blank">如何在.NET 電子表格應用程序中創建流程圖</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fblogs%2Fsjs-realtime-data-refresh-part1" target="_blank">如何將實時數據顯示在前端電子表格中</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 06:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/powertoolsteam/blog/10143465</guid>
            <link>https://my.oschina.net/powertoolsteam/blog/10143465</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米推出 Xiaomi Vela 快應用開發工具：Aiot-IDE]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米在今天舉辦的《2023&nbsp;小米 IoT 生態夥伴大會》上<a href="https://www.oschina.net/news/266688/xiaomi-vela-opensource">宣佈</a>全面開源&nbsp;Xiaomi Vela。</p><p><img alt="" height="667" src="https://oscimg.oschina.net/oscnet/up-2e4d78299513d8dd8e48dd44f9f1c80cbea.png" width="500" referrerpolicy="no-referrer"></p><blockquote><p>Xiaomi Vela 是小米基於開源實時操作系統&nbsp;<strong><a href="https://www.oschina.net/p/nuttx">NuttX</a></strong>&nbsp;打造的物聯網嵌入式軟件平台，Vela 在各種物聯網硬件平台上提供統一的軟件服務，支持豐富的組件和易用的框架，打通碎片化的物聯網應用場景。</p></blockquote><p>隨 Xiaomi Vela 一同發佈的還有 Aiot-IDE，官方稱這是用於開發<strong> Xiaomi Vela 快應用</strong>的工具。據介紹，在小米智能穿戴 (Wearable) 設備上進行應用開發，此類應用統稱為 <strong>Xiaomi Vela 快應用</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8c26527175a6a981cbd609b6b5fa67209b5.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-642ef5598b7a4dfdf8d448948a0b32a4fbc.png" referrerpolicy="no-referrer"></p><p>官方稱 Aiot-IDE 基於 VS Code 進行開發，此外快應用的開發也類似網頁開發。感興趣可以下載安裝體驗：</p><ul><li><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fiot.mi.com%2Fvela%2Fquickapp%2Fzh%2Fcontent%2Fguide%2Fstart%2Fuse-ide.html" target="_blank">Aiot-IDE 下載地址</a></u>（該&nbsp;IDE 只支持在<code>Ubuntu 20.04</code>下進行 vela 項目的開發）</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 06:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266723</guid>
            <link>https://www.oschina.net/news/266723</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[開源中國將在年末推出大模型託管平台，大量人才招募中]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">Gitee 正在招募大量人才，歡迎加入。</span></span></p><p><img alt="" height="1348" src="https://static.oschina.net/uploads/space/2023/1116/151453_9FSP_3820517.jpg" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">開源中國於 2023 年 6 月完成了&nbsp;</span><strong><span style="background-color:#ffffff">7.75 億元&nbsp;</span></strong></span><span style="color:#000000">B+ 輪戰略融資</span><span style="color:#000000">，公司創始團隊重新成為實際控制人，經此股份重組企業成為完全中立平台。目前，開源中國員工共計 300 餘人，其中研發團隊佔比 85% 以上。</span></p><p><span style="color:#000000"><strong><span style="background-color:#ffffff">開源中國將在年末推出大模型託管平台</span></strong><span style="background-color:#ffffff">，在 AI 時代為廣大開發者和企業提供更高質量的服務。從軟件應用到 AI 時代，開源中國將堅持幫助國內開發者和企業共同發展，創造健康的生態環境。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Gitee 是開源中國旗下，國內第一大企業級研發效能平台和全球第二大開源代碼託管平台。經過 10 年發展，Gitee 已經擁有超過 1100 萬開發者，託管超過 2500 萬個代碼倉庫，服務 26 萬家企業（含 1200 家中大型私有化部署企業）和 2000 多所高校，為他們提供優質的 DevOps 產品服務。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 03:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266707/gitee-hiring</guid>
            <link>https://www.oschina.net/news/266707/gitee-hiring</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[金山辦公 WPS AI 開啓公測]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>金山辦公<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FcSKhX3tqmZgdw7EfTid_TA" target="_blank">宣佈</a>旗下只能辦公助手 WPS AI 開啓公測，即日起面向全體用戶陸續開放體驗。WPS AI 是一款生成式人工智能應用，具備了大語言模型能力。它提供起草、改寫、總結、潤色等功能，可以提高辦公創作效率。</p><p>用戶可前往 <strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fai.wps.cn%2F" target="_blank">WPS AI 官網</a></strong>申請權益，並下載最新版 WPS PC 客戶端限時體驗文字/智能文檔、表格/智能表格、PPT 演示組件的 AI 能力，安卓、iOS 和 Mac 端預計將於 11 月底陸續開放。</p><p><img alt="" height="376" src="https://oscimg.oschina.net/oscnet/up-9b4717aaa45d58081e02785ba28fc5dda23.png" width="300" referrerpolicy="no-referrer"></p><p><img alt="" height="354" src="https://oscimg.oschina.net/oscnet/up-fa29542a7d817329492fdc62024e16f7025.png" width="300" referrerpolicy="no-referrer"></p><p><img alt="" height="379" src="https://oscimg.oschina.net/oscnet/up-f98e75322933cd6c5d3e5239be36401148e.png" width="300" referrerpolicy="no-referrer"></p><p>更多詳細功能介紹可查看 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhome.wps.cn%2Ftopic%2F10254" target="_blank">WPS AI 能力介紹（11 月最新版）</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 03:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266706</guid>
            <link>https://www.oschina.net/news/266706</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微軟將 Bing Chat 更名為 Copilot in Bing]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">在 Ignite 2023 大會上，微軟宣佈將今年早些時候在 Bing 上推出的 AI 聊天機器人 Bing Chat 更名為 Copilot in Bing。與此同時，Bing Chat 的高端企業版（之前稱為 Bing Chat Enterprise）也已更名為 Copilot。</span></p><p><span style="color:#000000">目前該公司現在約有十幾種產品共享 Copilot 品牌，微軟方面表示，此次改名並不是為了造成混淆。其通信總監 Caitlin Roulston 解釋稱，「將 Bing Chat Enterprise 更名為 Copilot 反映了我們為消費者和商業客戶打造統一的 Copilot 體驗的願景。」</span></p><p><span style="color:#000000">科技媒體 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2023%2F11%2F15%2Fbing-chat-is-now-copilot%2F" target="_blank">TechCrunch</a> 認為，雖然 Roulston 的言論有一定的道理。但也不排除是因為 Bing Chat 並沒有給 Bing 帶來多大的推動，所以微軟希望將這項技術與推出它的搜索引擎剝離開來的原因。StatCounter 8 月份的一份報告指出，在 Bing Chat 推出六個月後，Bing 未能從 Google 手中奪取任何市場份額；不過微軟方面對這一調查結果提出異議。</span></p><p><img height="279" src="https://oscimg.oschina.net/oscnet/up-3a23b972d5c87805c49dd110d3b0bb06145.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">除了改名之外，從 12 月 1 日起，使用企業賬戶（準確地説，是 Microsoft Entra ID）登錄 Bing 的用戶在 Bing 中使用 Copilot 時，將享受"商業數據保護"的好處。Roulston 稱，這意味着用戶的數據不會被保存、不會被用於訓練人工智能模型，且微軟也無法訪問這些數據。</span></p><p><span style="color:#000000">「Copilot 將於 12 月 1 日更新商業條款和條件，以反映它是微軟的通用產品。作為其中的一部分，它將繼承微軟在線服務的通用許可條款……隨着時間的推移，微軟將免費向更多的 Entra ID 用戶提供具有商業數據保護功能的 Copilot。」</span></p><p><span style="color:#000000">除了 Copilot.Microsoft.com 和 Bing 之外，現在還可以在 Windows 中訪問 Copilot，並在 Microsoft 的一系列企業訂閲計劃（Microsoft 365 E、E5、Business Premium 和 Business Standard）中提供，無需額外付費。Copilot 將從 12 月 1 日起包含在 Microsoft 365 F3 中。對於所有其他客戶，它將以每月 5 美元的價格提供服務。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 03:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266700/bing-chat-rename-copilot</guid>
            <link>https://www.oschina.net/news/266700/bing-chat-rename-copilot</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[阿里雲 11.12 故障原因曝光：訪問密鑰服務 (Access Key) 異常]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>針對阿里雲 11.12 的重大服務故障， 該公司發給客戶的一份「官方故障報告」昨天在網上被廣泛流傳。</span></p><blockquote><p><span>事件回顧：</span><u><a href="https://www.oschina.net/news/266144">阿里雲嚴重故障，全線產品受影響（已恢復）</a></u></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-12e038da50562b9fb7806fac53534a272ac.png" referrerpolicy="no-referrer"></p><hr><p style="margin-left:0; margin-right:0"><strong><span>影響範圍</span></strong></p><p><span style="color:#021eaa"><strong><span style="color:#021eaa">1、OSS、OTS、SLS、MNS 等產品的部分服務受到影響，大部分產品如 ECS、RDS、網絡等運行不受影響。</span></strong></span></p><p><span style="color:#0052ff"><strong><span>2、雲產品控制枱、管控 API 等功能受到影響。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span>時間</span></strong></p><p><span style="color:#0052ff"><strong><span>2023 年 11 月 12 日 17:39～19.20，</span></strong></span><span style="color:#021eaa"><strong><span>故障時間為 1 小時 41 分。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span style="color:rgba(0, 0, 0, 0.9)">問題概況</span></strong></p><p><span style="color:#0052ff"><strong><span>2023 年 11 月 12 日 17:39 起，阿里云云產品控制枱訪問及管控 API 調用出現異常、部分雲產品服務訪問異常，工程師排查故障原因與訪問密鑰服務 (AK) 異常有關。工程師修訂白名單版本後，採取分批重啓 AK 服務的措施，於 18:35 開始陸續恢復，19:20 絕大部分 Region 產品控制枱和管控 API 恢復。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span style="color:rgba(0, 0, 0, 0.9)">處理過程</span></strong></p><p><span>17:39：阿里云云產品控制枱訪問及管控 API 調用出現異常。</span></p><p><span>17:50：工程師確認故障是 AK 服務異常導致，影響雲產品控制枱、管控 API 調<span>用異常，以及依賴 AK 服務的雲產品服務運行異常。</span></span></p><p><span>18:01：工程師定位到根因。</span></p><p><span>18:07：開始執行恢復措施，包括修訂白名單版本、重啓 AK 服務。</span></p><p><span>18:35：杭州等 Region 開始恢復正常。</span></p><p><span>19:20：絕大部分 Region 的雲產品控制枱和管控 API 調用恢復正常。</span></p><p style="margin-left:0; margin-right:0"><strong><span>原因</span></strong></p><p><span style="color:#021eaa"><strong><span>訪問密鑰服務 (AK）在讀取白名單數據時出現讀取異常，因處理讀取異常的代碼存在邏輯缺陷，生成了一份不完整白名單，導致不在此白名單中的有效請求失敗，影響雲產品控制枱及管控 API 服務出現異常，同時部分依賴 AK 服務的產品因不完整的白名單出現部分服務運行異常。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span>改進措施</span></strong></p><p><span>1、增加 AK 服務白名單生成結果的校驗及告警攔截能力。</span></p><p><span>2、增加 AK 服務白名單更新的灰度驗證邏輯，提前發現異常。</span></p><p><span>3、增加 AK 服務白名單的快速恢復能力。</span></p><p><span>4、加強雲產品側的聯動恢復能力。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 03:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266694</guid>
            <link>https://www.oschina.net/news/266694</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米官宣 Xiaomi Vela 全面開源，底層內核為 NuttX]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米澎湃 OS 剛剛在微博<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F1786860821%2FNsNK2mfse%3Fpagetype%3Dprofilefeed" target="_blank">宣佈</a></u>，Xiaomi Vela 採用 Apache 2.0 License 面向全球軟硬件開發者正式開源。</p><blockquote><p><img height="1352" src="https://static.oschina.net/uploads/space/2023/1116/102959_ekSh_2720166.png" width="2000" referrerpolicy="no-referrer"></p></blockquote><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fiot.mi.com%2Fvela" target="_blank">根據官網的介紹</a></u>，Xiaomi Vela 是小米基於開源實時操作系統<strong><u><a href="https://www.oschina.net/p/nuttx">NuttX</a></u></strong>打造的物聯網嵌入式軟件平台，Vela 在各種物聯網硬件平台上提供統一的軟件服務，支持豐富的組件和易用的框架，打通碎片化的物聯網應用場景。‘Vela’ 一詞源自拉丁語中船帆的含義，也是南方星空中最亮的星座之一。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2e4d78299513d8dd8e48dd44f9f1c80cbea.png" referrerpolicy="no-referrer"></p><p><strong>Xiaomi Vela 主要特性</strong></p><ul><li>高效性能：Vela 基於 NuttX 內核，具有高實時性、低功耗、低延遲等特點，適用於各種資源受限的嵌入式設備。</li><li>豐富組件：Vela 提供了多種常用的組件，如網絡、音頻、視頻、圖形、安全等，方便開發者快速構建應用。</li><li>易用框架：Vela 提供了一套統一的應用框架，支持 Lua、JavaScript 等腳本語言開發應用，並提供了豐富的 API 和文檔。</li><li>萬物互聯：Vela 支持多種通信協議和標準，如 WiFi、BLE、Zigbee、MQTT 等，並提供了小米妙享技術，實現設備之間的無縫連接和協同。</li></ul><p><strong>Xiaomi Vela 系統架構如下</strong></p><p><img src="https://oscimg.oschina.net/oscnet/up-9bc7edd16b77b3d0ef73407769d0dc0b404.png" referrerpolicy="no-referrer"></p><ul><li><strong>底層 NuttX 內核</strong>：提供最基本的任務調度、跨進程間通信、文件系統等基礎 OS 功能，同時也提供簡潔高效的設備驅動、輕量級的 TCP/IP 協議棧和電源管理等組件。</li><li><strong>應用框架</strong>：分為上下兩層，下層是為擴展系統服務而提供的通用應用框架，上層是針對不同的物聯網應用而開發的定製應用框架，例如多媒體應用框架和傳感應用框架，提供 Cloud SDK 可以方便開發者更快速的接入小米雲服務。</li><li><strong>開發者工具</strong>：除了常見的 Logger 和 Debugger 工具，Xiaomi Vela 還提供 Emulator 工具來幫助開發者提升調試效率，使用 Emulator，開發者可以利用 PC 端豐富的調試工具和調試信息，降低嵌入式系統開發和調試的難度。</li></ul><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fiot.mi.com%2Fvela%2Fdetail.html" target="_blank">點此查看更多細節</a></u>。</p><hr><p>延伸閲讀</p><ul><li><a href="https://www.oschina.net/news/263025" target="_blank">雷軍公佈小米澎湃 OS 完整系統架構，稱底層全部重構</a></li><li><a href="https://www.oschina.net/news/263645" target="_blank">小米澎湃 OS 正式發佈，Xiaomi Vela 將開源</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266688/xiaomi-vela-opensource</guid>
            <link>https://www.oschina.net/news/266688/xiaomi-vela-opensource</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Socket.D —— 基於語義消息流的網絡協議]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">Socket.D&nbsp;是一個基於連接的、可擴展的、消息驅動的傳輸協議。具有異步，自動分片，背壓流控，雙向通訊，多路複用，斷線重連，支持籤權，基於主題消息等特性。</p><ul><li>具有語言無關性的二進制通信協議（支持 tcp, ws, udp）</li><li>異步非阻塞消息驅動通信</li><li>可以進行流量控制、自動連接恢復</li><li>支持雙向通信（如：單鏈接雙向 RPC 接口調用）</li><li>更加適合分佈式通信場景</li><li>支持 ssl，支持國密 ssl</li><li>消息有由元信息和數據組成，通過元信息實現可擴展性</li><li>接口簡單</li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">開發時，主要交互只有 2 接口對象（更多可見：<a href="https://gitee.com/noear/socketd/blob/main/API.md">API.md</a><span>&nbsp;</span>）：</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#40485b; display:block; font-family:-apple-system,&quot;system-ui&quot;,&quot;Segoe UI&quot;,Helvetica,Arial,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;,&quot;Liberation Sans&quot;,&quot;PingFang SC&quot;,&quot;Microsoft YaHei&quot;,&quot;Hiragino Sans GB&quot;,&quot;Wenquanyi Micro Hei&quot;,&quot;WenQuanYi Zen Hei&quot;,&quot;ST Heiti&quot;,SimHei,SimSun,&quot;WenQuanYi Zen Hei Sharp&quot;,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:left; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:835px; word-break:initial; word-spacing:0px"><thead><tr><th>接口</th><th>描述</th><th>説明</th></tr></thead><tbody><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">listener</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">監聽器</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">（可雙向互聽）</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">會話</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">（可雙向互發）</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::send</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">發送</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::sendAndRequest</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">發送並請求</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">要求一次答覆</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::sendAndSubscribe</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">發送並訂閲</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答覆結束之前，不限答覆次數</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::reply</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答覆</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::replyEnd</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答覆結束</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr></tbody></table><h3 style="margin-left:0; margin-right:0; text-align:left">適用場景：</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">可用於 MSG、RPC、IM、MQ，等一些的場景開發，可替代 http, websocket, grpc 等一些協議。比如移動設備與服務器的連接，比如一些微服務場景等等。</p></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/socketd</guid>
            <link>https://www.oschina.net/p/socketd</link>
        </item>
        <item>
            <title>
                <![CDATA[ChatGPT 代碼解釋器存在巨大安全漏洞]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenAI 近日為 ChatGPT 推出了全新的代碼解釋器（Code Interpreter）工具，可以幫助程序員調試、完善代碼編程工作。該工具可以利用 AI 來編寫 Python 代碼，所編寫的代碼甚至可以在沙盒中運行。</p><p>不過根據 Johann Rehberger 網絡安全專家、Tom's Hardware 等多家國外媒體<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tomshardware.com%2Fnews%2Fchatgpt-code-interpreter-security-hole" target="_blank">報道</a></u>，由於該代碼解釋器工具可以處理任何電子表格文件，並能以圖表的形式分析和呈現數據，<strong>黑客可以欺騙 ChatGPT 聊天機器人，讓其執行來自第三方 URL 的指令</strong>。</p><p>Tom's Hardware 媒體復現了相關漏洞，創建虛假的環境變量文件，利用 ChatGPT 的功能處理此數據，然後將其發送到外部惡意站點。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1ca35470cf685c96d916ec4c8a97265c843.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-df3cfd0173073986a718e72cfaab32eb096.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-787cc41d51a67b812ef60dda6ed6532d570.png" referrerpolicy="no-referrer"></p><p>ChatGPT 可以響應 Linux 命令，可以訪問相關信息和文件，黑客通過這種方式，可以在用戶沒有防備的情況下，訪問相關的敏感數據。</p><p>目前需要訂閲 ChatGPT Plus，才能訪問該代碼解釋工具，但這個漏洞引發了網絡安全專家的擔憂。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266683/chatgpt-code-interpreter-security-hole</guid>
            <link>https://www.oschina.net/news/266683/chatgpt-code-interpreter-security-hole</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 基於 Kotlin 的 AndroidX 仿微信圖片選擇器 MXImagePicker]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-imagepicker" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#imagepicker"></a>ImagePicker</h1><h2><a id="user-content-介紹" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E4%BB%8B%E7%BB%8D"></a>介紹</h2><h2><a id="user-content-基於 kotlinandroidx 的仿微信圖片選擇器" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E5%9F%BA%E4%BA%8Ekotlinandroidx%E7%9A%84%E4%BB%BF%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9%E5%99%A8"></a>基於 Kotlin，AndroidX 的仿微信圖片選擇器
<a href="https://gitee.com/link?target=https%3A%2F%2Fjitpack.io%2F%23com.gitee.zhangmengxiong%2FMXImagePicker"><img src="https://jitpack.io/v/com.gitee.zhangmengxiong/MXImagePicker.svg" alt="" referrerpolicy="no-referrer"></a></h2><p>Gradle 引用</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="n">implementation</span><span class="s1">'com.gitee.zhangmengxiong:MXImagePicker:1.6.3'</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p><img src="https://gitee.com/zhangmengxiong/MXImagePicker/raw/master/imgs/screenshot1.png" alt="Image text" referrerpolicy="no-referrer"><img src="https://gitee.com/zhangmengxiong/MXImagePicker/raw/master/imgs/screenshot2.png" alt="Image text" referrerpolicy="no-referrer"><img src="https://gitee.com/zhangmengxiong/MXImagePicker/raw/master/imgs/screenshot3.png" alt="Image text" referrerpolicy="no-referrer"></p><h2><a id="user-content-使用方法" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"></a>使用方法</h2><h4><a id="user-content-第一步項目增加 androidx 庫和 glide 圖片加載庫圖片縮放庫" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E7%AC%AC%E4%B8%80%E6%AD%A5%E9%A1%B9%E7%9B%AE%E5%A2%9E%E5%8A%A0androidx%E5%BA%93%E5%92%8Cglide%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE%E5%BA%93"></a>第一步：項目增加 Androidx 庫和 Glide 圖片加載庫、圖片縮放庫</h4><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="n">implementation</span><span class="s2">"androidx.appcompat:appcompat:x.x.x"</span></span><span id="LC2" class="line"><span class="n">implementation</span><span class="s2">"androidx.recyclerview:recyclerview:x.x.x"</span></span><span id="LC3" class="line"><span class="n">implementation</span><span class="s2">"com.github.bumptech.glide:glide:x.x.x"</span></span><span id="LC4" class="line"><span class="n">implementation</span><span class="s2">"androidx.constraintlayout:constraintlayout:2.0.4"</span></span><span id="LC5" class="line"><span class="n">implementation</span><span class="s2">"com.github.chrisbanes:PhotoView:2.3.0"</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-第二步使用前需要修改 androidmanifestxml 配置添加相冊存儲權限" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%BD%BF%E7%94%A8%E5%89%8D%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9androidmanifestxml%E9%85%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C%E5%AD%98%E5%82%A8%E6%9D%83%E9%99%90"></a>第二步：使用前需要修改‘AndroidManifest.xml’配置：添加相冊、存儲權限</h4><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 如果 Android 版本 &lt; 33 需要以下權限：</span></span><span id="LC2" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">CAMERA</span></span><span id="LC3" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">READ_EXTERNAL_STORAGE</span></span><span id="LC4" class="line"><span class="c1">// 如果 Android 版本 &gt;= 33 需要以下權限：</span></span><span id="LC5" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">CAMERA</span></span><span id="LC6" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">READ_MEDIA_IMAGES</span></span><span id="LC7" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">READ_MEDIA_VIDEO</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">// targetSdkVersion &gt;= 29 的應用需要在 application 節點添加以下屬性</span></span><span id="LC10" class="line"><span class="n">android</span><span class="p">:</span><span class="n">requestLegacyExternalStorage</span><span class="p">=</span><span class="s">"true"</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>注意：<code>沒有權限進入選擇頁面會報錯！</code></p><h4><a id="user-content-第三步啓動選擇頁面" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E7%AC%AC%E4%B8%89%E6%AD%A5%E5%90%AF%E5%8A%A8%E9%80%89%E6%8B%A9%E9%A1%B5%E9%9D%A2"></a>第三步：啓動選擇頁面</h4><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">val</span><span class="py">intent</span><span class="p">=</span><span class="nc">MXPickerBuilder</span><span class="p">().</span><span class="nf">setMaxSize</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nf">createIntent</span><span class="p">(</span><span class="k">this</span><span class="p">)</span></span><span id="LC2" class="line"><span class="nf">startActivityForResult</span><span class="p">(</span><span class="n">intent</span><span class="p">,</span><span class="mh">0x22</span><span class="p">)</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-預加載説明" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E9%A2%84%E5%8A%A0%E8%BD%BD%E8%AF%B4%E6%98%8E"></a>預加載説明</h5><p>預加載可以提前搜索本機圖片/視頻資源，減少首次進入選擇頁面時空白時間</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nc">MXImagePicker</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">application</span><span class="p">)</span></span><span id="LC2" class="line"><span class="nc">MXScanBiz</span><span class="p">.</span><span class="nf">scanAll</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="n">lifecycleScope</span><span class="p">)</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-mxpickerbuilder 參數説明" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#mxpickerbuilder%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"></a>MXPickerBuilder 參數説明</h5><ol><li><code>setMaxSize(size: Int)</code> 設置最大選擇文件個數</li><li><code>setType(type: PickerType)</code> 設置類型
<ul><li>PickerType.Image = 圖片</li><li>PickerType.Video = 視頻</li><li>PickerType.ImageAndVideo = 圖片 + 視頻，混合選擇</li></ul></li><li><code>setCameraEnable(enable: Boolean)</code> 設置是否啓動拍攝功能，默認=true</li><li><code>setMaxVideoLength(length: Int)</code> 當類型=Video 時，可以選擇視頻最大時長限制，單位：秒，默認=-1 無限制</li><li><code>setMaxListSize(size: Int)</code> 最長列表加載長度，防止圖片過多時產生 OOM -1=不限制，默認限制長度=1000 條</li></ol><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 在圖片選擇器 Activity 創建時會回調這個方法，一般會通過這個來改變導航欄、狀態欄的 Theme,demo 中搭配`ImmersionBar`來實現沉浸式效果</span></span><span id="LC2" class="line"><span class="nc">MXImagePicker</span><span class="p">.</span><span class="nf">registerActivityCallback</span><span class="p">{</span><span class="n">activity</span><span class="p">-&gt;</span></span><span id="LC3" class="line"><span class="nc">ImmersionBar</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="n">activity</span><span class="p">)</span></span><span id="LC4" class="line"><span class="p">.</span><span class="nf">autoDarkModeEnable</span><span class="p">(</span><span class="k">true</span><span class="p">)</span></span><span id="LC5" class="line"><span class="p">.</span><span class="nf">statusBarColorInt</span><span class="p">(</span><span class="n">activity</span><span class="p">.</span><span class="n">resources</span><span class="p">.</span><span class="nf">getColor</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">picker_color_background</span><span class="p">))</span></span><span id="LC6" class="line"><span class="p">.</span><span class="nf">fitsSystemWindows</span><span class="p">(</span><span class="k">true</span><span class="p">)</span></span><span id="LC7" class="line"><span class="p">.</span><span class="nf">navigationBarColor</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">picker_color_background</span><span class="p">)</span></span><span id="LC8" class="line"><span class="p">.</span><span class="nf">init</span><span class="p">()</span></span><span id="LC9" class="line"><span class="p">}</span></span><span id="LC10" class="line"></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-頁面顏色設置" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E9%A1%B5%E9%9D%A2%E9%A2%9C%E8%89%B2%E8%AE%BE%E7%BD%AE"></a>頁面顏色設置</h5><p>將下面顏色值放如主項目的資源 xml 中，可以修改頁面對應的顏色顯示</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c">&lt;!--  頁面背景色  --&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;color</span><span class="na">name=</span><span class="s">"mx_picker_color_background"</span><span class="nt">&gt;</span>#333333<span class="nt">&lt;/color&gt;</span></span><span id="LC3" class="line"></span><span id="LC4" class="line"><span class="c">&lt;!--  字體、icon 顏色  --&gt;</span></span><span id="LC5" class="line"><span class="nt">&lt;color</span><span class="na">name=</span><span class="s">"mx_picker_color_important"</span><span class="nt">&gt;</span>#F1F1F1<span class="nt">&lt;/color&gt;</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="c">&lt;!--  選中狀態顏色  --&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;color</span><span class="na">name=</span><span class="s">"mx_picker_color_select"</span><span class="nt">&gt;</span>#03CE65<span class="nt">&lt;/color&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-多語言設置" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E7%BD%AE"></a>多語言設置</h5><p>將下面字符串定義放入對應的語言目錄中，可以修改頁面對應的文字提示</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_select"</span><span class="nt">&gt;</span>選擇<span class="nt">&lt;/string&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_all"</span><span class="nt">&gt;</span>全部<span class="nt">&lt;/string&gt;</span></span><span id="LC3" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_image_limit_tip"</span><span class="nt">&gt;</span>您最多隻能選擇 %s 張圖片！<span class="nt">&lt;/string&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_video_limit_tip"</span><span class="nt">&gt;</span>您最多隻能選擇 %s 個視頻！<span class="nt">&lt;/string&gt;</span></span><span id="LC5" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_video_limit_length_tip"</span><span class="nt">&gt;</span>只能選擇 %s 秒以內的視頻<span class="nt">&lt;/string&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_need_permission_storage_camera"</span><span class="nt">&gt;</span>需要寫入存儲、相機權限<span class="nt">&lt;/string&gt;</span></span><span id="LC7" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_need_permission_storage"</span><span class="nt">&gt;</span>需要讀取存儲權限<span class="nt">&lt;/string&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_open_failed"</span><span class="nt">&gt;</span>打開失敗！<span class="nt">&lt;/string&gt;</span></span><span id="LC9" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_preview"</span><span class="nt">&gt;</span>預覽<span class="nt">&lt;/string&gt;</span></span><span id="LC10" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_not_compress"</span><span class="nt">&gt;</span>原圖<span class="nt">&lt;/string&gt;</span></span><span id="LC11" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_take_pic"</span><span class="nt">&gt;</span>拍攝圖片<span class="nt">&lt;/string&gt;</span></span><span id="LC12" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_take_video"</span><span class="nt">&gt;</span>拍攝視頻<span class="nt">&lt;/string&gt;</span></span><span id="LC13" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_show_list"</span><span class="nt">&gt;</span>圖片查看<span class="nt">&lt;/string&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>dimens.xml 資源</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c">&lt;!--  頂部導航欄高度  --&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;dimen</span><span class="na">name=</span><span class="s">"mx_picker_bar_height"</span><span class="nt">&gt;</span>50dp<span class="nt">&lt;/dimen&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-自定義圖片加載器默認使用 glide" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%99%A8%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8glide"></a>自定義圖片加載器（默認使用 Glide）</h5><p>通過繼承實現接口<code>IImageLoader</code> ,並註冊到服務<code>MXImagePicker</code>即可</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 數據對象</span></span><span id="LC2" class="line"><span class="kd">data class</span><span class="nc">MXItem</span><span class="p">(</span><span class="kd">val</span><span class="py">path</span><span class="p">:</span><span class="nc">String</span><span class="p">,</span><span class="kd">val</span><span class="py">time</span><span class="p">:</span><span class="nc">Long</span><span class="p">,</span><span class="kd">val</span><span class="py">type</span><span class="p">:</span><span class="nc">MXPickerType</span><span class="p">,</span><span class="kd">val</span><span class="py">duration</span><span class="p">:</span><span class="nc">Int</span><span class="p">=</span><span class="mi">0</span><span class="p">)</span></span><span id="LC3" class="line"></span><span id="LC4" class="line"><span class="c1">// 全局註冊加載器，可以卸載 Application 裏面，不影響啓動速度</span></span><span id="LC5" class="line"><span class="nc">MXImagePicker</span><span class="p">.</span><span class="nf">registerImageLoader</span><span class="p">{</span><span class="n">activity</span><span class="p">,</span><span class="n">item</span><span class="p">,</span><span class="n">imageView</span><span class="p">-&gt;</span></span><span id="LC6" class="line"><span class="k">if</span><span class="p">(</span><span class="nc">File</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">path</span><span class="p">).</span><span class="nf">exists</span><span class="p">())</span><span class="p">{</span></span><span id="LC7" class="line"><span class="nc">Glide</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="n">activity</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="nc">File</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">path</span><span class="p">))</span></span><span id="LC8" class="line"><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">mx_icon_picker_image_place_holder</span><span class="p">).</span><span class="nf">into</span><span class="p">(</span><span class="n">imageView</span><span class="p">)</span></span><span id="LC9" class="line"><span class="p">}</span><span class="k">else</span><span class="k">if</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">startsWith</span><span class="p">(</span><span class="s">"http"</span><span class="p">))</span><span class="p">{</span></span><span id="LC10" class="line"><span class="nc">Glide</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="n">activity</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">path</span><span class="p">)</span></span><span id="LC11" class="line"><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">mx_icon_picker_image_place_holder</span><span class="p">).</span><span class="nf">into</span><span class="p">(</span><span class="n">imageView</span><span class="p">)</span></span><span id="LC12" class="line"><span class="p">}</span><span class="k">else</span><span class="p">{</span></span><span id="LC13" class="line"><span class="nc">Glide</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="n">activity</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">uri</span><span class="p">)</span></span><span id="LC14" class="line"><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">mx_icon_picker_image_place_holder</span><span class="p">).</span><span class="nf">into</span><span class="p">(</span><span class="n">imageView</span><span class="p">)</span></span><span id="LC15" class="line"><span class="p">}</span></span><span id="LC16" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-第四步獲取返回結果" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E7%AC%AC%E5%9B%9B%E6%AD%A5%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"></a>第四步：獲取返回結果</h4><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">override</span><span class="k">fun</span><span class="nf">onActivityResult</span><span class="p">(</span><span class="n">requestCode</span><span class="p">:</span><span class="nc">Int</span><span class="p">,</span><span class="n">resultCode</span><span class="p">:</span><span class="nc">Int</span><span class="p">,</span><span class="n">data</span><span class="p">:</span><span class="nc">Intent</span><span class="p">?)</span><span class="p">{</span></span><span id="LC2" class="line"><span class="k">super</span><span class="p">.</span><span class="nf">onActivityResult</span><span class="p">(</span><span class="n">requestCode</span><span class="p">,</span><span class="n">resultCode</span><span class="p">,</span><span class="n">data</span><span class="p">)</span></span><span id="LC3" class="line"><span class="k">if</span><span class="p">(</span><span class="n">resultCode</span><span class="p">==</span><span class="nc">RESULT_OK</span><span class="p">&amp;&amp;</span><span class="n">requestCode</span><span class="p">==</span><span class="mh">0x22</span><span class="p">)</span><span class="p">{</span></span><span id="LC4" class="line"><span class="kd">val</span><span class="py">paths</span><span class="p">=</span><span class="nc">MXPickerBuilder</span><span class="p">.</span><span class="nf">getPickerResult</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">?:</span><span class="k">return</span><span class="c1">//返回 List&lt;String&gt;類型數據</span></span><span id="LC5" class="line"><span class="nf">println</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span></span><span id="LC6" class="line"><span class="p">}</span></span><span id="LC7" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-調取攝像頭單獨拍攝照片" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E8%B0%83%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4%E5%8D%95%E7%8B%AC%E6%8B%8D%E6%91%84%E7%85%A7%E7%89%87"></a>調取攝像頭單獨拍攝照片</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">val</span><span class="py">builder</span><span class="p">=</span><span class="nc">MXCaptureBuilder</span><span class="p">().</span><span class="nf">setType</span><span class="p">(</span><span class="nc">MXPickerType</span><span class="p">.</span><span class="nc">Image</span><span class="p">)</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="nf">startActivityForResult</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="nf">createIntent</span><span class="p">(</span><span class="k">this</span><span class="p">),</span><span class="mh">0x11</span><span class="p">)</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="c1">// 在 onActivityResult 獲取結果</span></span><span id="LC6" class="line"><span class="kd">val</span><span class="py">file</span><span class="p">=</span><span class="n">builder</span><span class="p">.</span><span class="nf">getCaptureFile</span><span class="p">()</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-調取攝像頭單獨拍攝視頻" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E8%B0%83%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4%E5%8D%95%E7%8B%AC%E6%8B%8D%E6%91%84%E8%A7%86%E9%A2%91"></a>調取攝像頭單獨拍攝視頻</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">val</span><span class="py">builder</span><span class="p">=</span><span class="nc">MXCaptureBuilder</span><span class="p">().</span><span class="nf">setType</span><span class="p">(</span><span class="nc">MXPickerType</span><span class="p">.</span><span class="nc">Video</span><span class="p">).</span><span class="nf">setMaxVideoLength</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span></span><span id="LC2" class="line"><span class="nf">startActivityForResult</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="nf">createIntent</span><span class="p">(</span><span class="k">this</span><span class="p">),</span><span class="mh">0x11</span><span class="p">)</span></span><span id="LC3" class="line"></span><span id="LC4" class="line"><span class="c1">// 在 onActivityResult 獲取結果</span></span><span id="LC5" class="line"><span class="kd">val</span><span class="py">file</span><span class="p">=</span><span class="n">builder</span><span class="p">.</span><span class="nf">getCaptureFile</span><span class="p">()</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-圖片查看器" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8"></a>圖片查看器</h3><p><img src="https://gitee.com/zhangmengxiong/MXImagePicker/raw/master/imgs/screenshot3.png" alt="Image text" referrerpolicy="no-referrer"></p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nc">MXImgShowActivity</span><span class="p">.</span><span class="k">open</span><span class="p">(</span></span><span id="LC2" class="line"><span class="k">this</span><span class="p">,</span><span class="nf">arrayListOf</span><span class="p">(</span></span><span id="LC3" class="line"><span class="s">"http://videos.jzvd.org/v/餃子主動.jpg"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="s">"http://videos.jzvd.org/v/餃子運動.jpg"</span></span><span id="LC5" class="line"><span class="p">),</span><span class="s">"圖片詳情"</span></span><span id="LC6" class="line"><span class="p">)</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-單張圖片壓縮" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E5%8D%95%E5%BC%A0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9"></a>單張圖片壓縮</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">val</span><span class="py">file</span><span class="p">=</span><span class="nc">File</span><span class="p">(</span><span class="s">".../xx.png"</span><span class="p">)</span></span><span id="LC2" class="line"><span class="kd">val</span><span class="py">scaleImg</span><span class="p">=</span><span class="nc">MXImageCompress</span><span class="p">.</span><span class="nf">from</span><span class="p">(</span><span class="n">context</span><span class="p">)</span></span><span id="LC3" class="line"><span class="p">.</span><span class="nf">setCacheDir</span><span class="p">(</span><span class="n">applicationContext</span><span class="p">.</span><span class="n">cacheDir</span><span class="p">)</span><span class="c1">// 緩存目錄</span></span><span id="LC4" class="line"><span class="p">.</span><span class="nf">setSupportAlpha</span><span class="p">(</span><span class="k">true</span><span class="p">)</span><span class="c1">// 支持透明通道 (’.png‘格式) 默認=’.jpg‘格式</span></span><span id="LC5" class="line"><span class="p">.</span><span class="nf">setTargetFileSize</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="c1">// 設置壓縮文件大小目標值，單位：Kb 默認=0 自然壓縮</span></span><span id="LC6" class="line"><span class="p">.</span><span class="nf">setTargetPixel</span><span class="p">(</span><span class="mi">2400</span><span class="p">)</span><span class="c1">// 設置壓縮文件寬或高目標值，單位：像素</span></span><span id="LC7" class="line"><span class="p">.</span><span class="nf">compress</span><span class="p">(</span><span class="n">file</span><span class="p">)</span></span><span id="LC8" class="line"></span></pre><div class="markdown-code-block-copy-btn"></div></div></div>]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/zhangmengxiong/MXImagePicker</guid>
            <link>https://gitee.com/zhangmengxiong/MXImagePicker</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 百度搜索智能化算力調控分配方法]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img src="https://oscimg.oschina.net/oscnet/up-24c7ae180da549d2d3ab12f4b6a9d4899ff.png" alt="" referrerpolicy="no-referrer"></p><p>作者 | 泰來</p><blockquote><p>導讀</p><p>隨着近年深度學習技術的發展，搜索算法複雜度不斷上升，算力供給需求出現了爆發式的增長。伴隨着 AI 技術逐步走到深水區，算法紅利在逐步消失，邊際效應日益顯著，算力效能的提升尤為重要，同時隨着宏觀經濟影響，大規模的算力需求供給也遭遇到了瓶頸。同時隨着流量、時間或系統故障時帶來的容量變化，總算力約束也在時刻改變，週期性的出現波峯、波谷，以及會因為流量突增、網絡抖動等原因導致系統出現穩定性問題。</p><p>在此背景下，需要一種更加智能化、個性化的算力調控分配方法，不斷提高系統的自適應性，使得在給定資源上限的情況下，最大化資源投入的性價，同時在故障時刻發生時自適應的調整算力分配，降低系統負載。</p></blockquote><blockquote><p><em>全文 4328 字，預計閲讀時間 11 分鐘。</em></p></blockquote><h1><strong>01 問題與挑戰</strong></h1><p>互聯網行業十餘年的蓬勃發展及硬件性能的持續攀升，使得 Ranking 相關算法進入到了深度學習時代，模型、技術創新層出不窮。但隨着技術逐步進入到深水區，在同樣的算力需求下對效果的增長邊際已經非常明顯。</p><p>同時伴隨當前宏觀經濟影響，大規模算力的需求供給也持續遭遇瓶頸，如何在有限的算力資源內不斷創造出更大的效果價值是一項非常有挑戰性的工作。</p><p><img src="https://oscimg.oschina.net/oscnet/up-630522985830d91e7f1357f55777b530f87.png" alt="圖片" referrerpolicy="no-referrer"></p><p>為此我們不斷探索根據流量價值及系統狀態自適應的進行算力分配，使得總體投入產出比不斷提升。</p><p><img src="https://oscimg.oschina.net/oscnet/up-a64376c135fecc2ffcb80b1ecc848497a0b.png" alt="圖片" referrerpolicy="no-referrer"></p><h1><strong>02 整體思路</strong></h1><p>目前搜索系統流轉過程中調控手段彼此相互之間是獨立的，調控的算子的輸入輸出沒有全局視角，調控算子彼此割裂、聯動和管理是比較困難的，且調控手段大多基於靜態閾值配置。但我們認為系統中請求經過每層的調控算子是有狀態的，理想的級聯繫統中每種調控算子應該是全局可見的，需要從全局的視角更好的審視業務系統，站在更高的維度去看算力調控分配這項工作。</p><p>我們在微觀和宏觀兩方案開展了相關調控工作：</p><p><strong>1.微觀</strong>：忽略系統容量狀態，在當前時刻下根據流量產生的價值來動態的分配算力，使得在給定算力總約束下獲得全局最優。</p><p><img src="https://oscimg.oschina.net/oscnet/up-98985f8b2a15f8558c83df58a4ebe18715d.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong>2.宏觀</strong>：隨着流量、時間或系統故障時帶來的容量變化，總算力約束在不斷改變，需要在給定的資源及響應時間限制下，計算出在當前限制條件下的最優分配方式。動態的調整系統核心階段的計算強度，合理調控峯值算力。並基於搜索系統的實時狀態反饋，自動的調節系統的安全狀態。使搜索系統能夠在速度、資源、效果、穩定性等多個維度上進行自適應的調控。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1e6e541b843bafcd142fbd5bd3d69ef3dba.png" alt="圖片" referrerpolicy="no-referrer"></p><h2><strong>2.1 問題建模</strong></h2><p><strong>變量説明：</strong></p><p>第 i 條流量\(r_i\)。</p><p>流量 i 在階段 j 的具體信息，例如隊列長度，模型選型等，可以用表示，其中的 alpha beta gamma 都可以根據經驗進行設定並用實驗來驗證。</p><p>\(Q_(i,j) = [α*queue_length, β*cpu_usage, γ*gpu_uasage]\)</p><p>流量在第 j 階段的折扣因子\(Y_i\)。</p><p>第 i 條流量的價值\(O_i=Y(r_i,Q_(i,1),Q_(i,2),…,Q_(i,N) )\)</p><p><img src="https://oscimg.oschina.net/oscnet/up-7c9ce2b9226f138fc1dd8bbc65e9ea1234b.png" alt="圖片" referrerpolicy="no-referrer"></p><p>目標：通過調控流量在各個階段的信息例如隊列長度、模型選型等，從而調節折扣因子，最終實現流量價值最大化，假設 M 條流量經過 N 個階段表達如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-de28539ee4bac5fbd6df6f7e3f1317cb2fd.png" alt="圖片" referrerpolicy="no-referrer"></p><p>C1 成本約束，對於任意一個階段，都必須小於等於其成本；</p><p>C2 時間約束，對於任意一個請求流量，在 N 個階段的耗時綜合都必須小於等於規定的耗時；</p><p>C3 輔助約束，對於任意一個請求任意一個階段都必須有大於等於 0 的值。</p><p>對於一個實時的搜索系統來説，在線進行上述的優化並不太實際也會帶來比較多的困難。為了簡化分析和提高系統的魯棒性，我們將上述 N 個階段拆封成 N 個子問題，這樣方便對各個階段進行監控和可靠的幹預，提高系統的魯棒性，例如當系統出現巨大的變化時，可以隨時動態調整各個階段的參數。簡化問題求解，將 C1、C2 約束進行一定的拆分。</p><p><img src="https://oscimg.oschina.net/oscnet/up-f6430b5dc5daf55c8c881024c8212a8e1b4.png" alt="圖片" referrerpolicy="no-referrer"></p><p>具體來説，對於階段 j，流量的價值最大化，我們可以看作是上述的一個子問題。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6946e0b198d88545b3f7e182609a5ae6124.png" alt="圖片" referrerpolicy="no-referrer"></p><p>假設\(Y_j （r_i,Q_(i,j)）\) 是單調遞增的，但其對\(Q_(i,j)\) 的導數是單調遞減的，也就是其價值會隨着配置資源的增加而越來越緩慢的增加。</p><h2><strong>2.2 示例説明</strong></h2><p><strong>示例：用相關性精排階段的彈性候選集進行舉例</strong></p><p>假設將流量 i 細化成第 i 條 Query，j 階段則為具體篩選階段，增加一個維度 k 表示 URL 級別的參數和特徵信息。在正排候選集篩選階段 k 信息表示為多個特徵的分數信息，authority_feature【權威性特徵】、click_feature【點擊特徵】...correlation_feature【相關性特徵】。</p><p>則在正排候選集篩選階段請求 i 的第 k 條 url 的信息可以表示為：</p><p><img src="https://oscimg.oschina.net/oscnet/up-0d31f093be129945380d88fc27f864dce80.png" alt="圖片" referrerpolicy="no-referrer"></p><p>流量 i 在彈性候選集下的折扣因子，可以看作是 1 - 刪掉 URL 數量在原本可出現在最終排序的 Top40 的概率，假如候選集合中完全沒有刪除的 URL 則無折扣損失，若是候選集合中刪除了 URL，但對最終 Top40 的召回無影響，也可以看作是對總價值無折扣影響。</p><p><img src="https://oscimg.oschina.net/oscnet/up-c740c592761c36f2c38a784c92ba5018ff8.png" alt="圖片" referrerpolicy="no-referrer"></p><p>具體來説，針對第 i 條 query 的 k 條 url 的具體信息，我們採用多個維度的特徵進行考量。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1d1ec5ab10bfc446a85c856a1d408835f4c.png" alt="圖片" referrerpolicy="no-referrer"></p><p>其中</p><p><img src="https://oscimg.oschina.net/oscnet/up-c45ba9cae44e13b3fb3f8f399a3e20c6626.png" alt="圖片" referrerpolicy="no-referrer"></p><p>如果是 0 表示丟棄，1 表示留下第 k 條 url，希臘字母表示的是採取的閾值標準，例如評分位於後 x%。如果一個 url 的所有特徵貢獻度排名都處於分佈的末尾，則會將該 url 從候選集中剔除。</p><p><img src="https://oscimg.oschina.net/oscnet/up-50089654880969967f46124956cfddd37f6.png" alt="圖片" referrerpolicy="no-referrer"></p><h1><strong>03 關鍵技術</strong></h1><p>過去傳統的調控方式下，既不知道上游階段做過哪些調控動作，也不知道在自己的階段上做的調控動作，下游是如何反饋的，只能追求自己的局部最優。而我們認為在搜索這種分層的級聯繫統下，越往下流轉看到的特徵和信號越多，調控動作應該隨着流轉過程發生狀態轉變，不應該是靜態的。我們創新的採用彈性級聯調控框架將調控手段進行組合，追求全局的最優解，從全鏈路上提升算力投入產出的性價比。</p><p><img src="https://oscimg.oschina.net/oscnet/up-58fe63995a5a07653dc25586db731a312e6.png" alt="圖片" referrerpolicy="no-referrer"></p><p>具體做法，我們構建的彈性級聯框架包含四個部分：</p><p><strong>1、調控算子集合</strong>，將調控動作按照 Query 級別、URL 級別、Feature 級別進行劃分，調控算子擁有相同基類，接口規範統一；</p><p><strong>2、計算中心</strong>，負責實時計算各種調控動作所需的各類信號、以及流量價值的判斷、容量信號的獲取等；</p><p><strong>3、參數集合</strong>，經過計算中心產出的特徵和信號，固化超參數，使得模塊內超參數全局可見，跨模塊之間按照規定協議統一進行交互；</p><p><strong>4、調控決策器</strong>，主要負責根據參數集合，確定各個階段的調控檔位設置並調用算子集合裏的算子進行執行，每個調控階段包含控制流（Control Level）和反饋流（FeedbackLevel），控制流能結合當前階段看到的特徵和信號給出它下游其他階段的調控檔位，反饋流是當前階段參考其他階段給出的調控檔位建議和當前階段看到的特徵和信號確定實際執行的調控檔位。通過這種方式，每個調控階段既能看到到其他階段實際執行的調控狀態，同時也能根據它們對當前階段的指導建議進行綜合判斷，最終在全鏈路上獲取全局最優解。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3d45fec8e8b0e24a58b2e608cce248a3628.png" alt="圖片" referrerpolicy="no-referrer"></p><p>如上圖左側可以看到整個彈性級聯框架的組成部分，右側是舉例正排階段的彈性候選集的實際計算過程，將各種維度的特徵通過計算中心生成價值參數，用於調控決策器進行決策，然後給出實際的正排計算集合。我們不僅建立控制反饋流級聯自適應調控系統，而且還提供了一個全局視角的彈性算力分配控制中心。彈性算力系統主要通過對集羣各種維度指標的獲取、策略分析及週期性執行最適合當前機器負載狀態的策略組合參數來實現其核心彈性算力分配決策。</p><p>根據當前搜索系統，當前智能彈性調參把系統定義和描述為下面 4 種狀態：系統異常狀態，負載峯值狀態，彈性過渡狀態，負載低谷狀態，根據不同的系統狀態，執行當前狀態的策略集合，從而使資源使用率及業務收益效果最優。具體方案見下圖：</p><p><img src="https://oscimg.oschina.net/oscnet/up-34531ef341d0092f4c8826b061a4c72cb68.png" alt="圖片" referrerpolicy="no-referrer"></p><p>主要包含流程如下：</p><p><strong>信息採集</strong>：自動化的週期性採集業務日誌（流量 pv，流量分類，流量質量）和機器狀態（CPU/MEM 使用率）等信息。對於這些信息進行深入挖掘分析，主要從以下幾個時間維度進行採集：</p><p>1、峯值時間段模塊狀態信號；</p><p>2、前 n 個採集週期模塊狀態信號；</p><p>3、前一天同時刻前 n 個採集週期模塊狀態信號；</p><p>4、前一週同時刻前 n 個採集週期模塊狀態信號。</p><p>系統狀態預估:&nbsp;對各種維度信息採集，之後通過人工規則，在線策略，離線預估等手段評估系統當前狀態，把目前系統劃分為系統異常狀態，系統負載峯值狀態，系統負載低谷狀態，系統負載過渡狀態。下面是系統狀態定義規則，及狀態轉移圖：</p><p><strong>系統異常狀態</strong>：系統發生故障，例如系統可用性 SLA，CPU 負載率，結果空值率等不符合預期。</p><p><strong>系統負載峯值狀態</strong>：系統請求數，CPU 負載率等系統容量指標大於指定閾值。</p><p><strong>系統負載低谷狀態</strong>：系統請求數，CPU 負載率等系統容量指標小於指定閾值。</p><p><strong>系統負載過渡狀態</strong>：負載峯值和低谷之間的過渡狀態。</p><p><img src="https://oscimg.oschina.net/oscnet/up-8a94ecc0c3d4bfc093470cc02d2f1a4dff4.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong>檔位判斷</strong>：根據系統狀態抽象成便於系統決策的系統檔位，及每個檔位內需要關注的系統問題。</p><p><strong>1、異常檔位</strong>：如何快速服務降級，保證保證系統質量。</p><p><strong>2、峯值檔位</strong>：需要關注系統的穩定性和響應時間，以確保系統在高負載下依然能夠穩定運行。</p><p><strong>3、低谷檔位</strong>：可以考慮優化系統資源的分配，提升資源的投入產出比。在探測到系統出現異常故障狀態時。</p><p><strong>4、過渡檔位</strong>：一種中間狀態，它的主要作用是在系統從低負載狀態過渡到高負載狀態，或從高負載狀態過渡到低負載狀態時，提供一個緩衝階段，以避免系統狀態的突然跳變。過渡檔位不進行策略的調整，而是保持系統在一個相對穩定的狀態。這樣做的目的是為了避免頻繁的策略調整帶來的系統震動，保證系統的穩定性。</p><p><strong>方案決策執行：</strong></p><p>降級檔位主要應對系統異常或重大風險，其對應的策略包括關閉被動觸發流量，以及降低召回集合，降低複雜模型計算等策，通過這種方式降低系統的負載，保證核心業務的正常運行。低谷檔位對應的是彈性策略集，這些策略主要目的是在低谷期加強複雜策略的計算，提升搜索效果。而在峯值檔位，我們主要採用削峯策略，包括減少被動觸發流量，以確保系統在高負載下依然能夠穩定運行。</p><p><strong>示例：視頻搜索彈性擴觸發：</strong></p><p>在系統資源容量低谷階段，根據指標採集數據計算當前系統容量資源冗餘情況，基於冗餘資源進行擴觸發比例計算，通過彈性算力決策模塊下發觸發信號，利用閒時資源擴大流量的觸發面。</p><h1><strong>04 總結與展望</strong></h1><p>通過基於彈性級聯框架的調控方式，提升了分層系統的效益比，對於每個用戶請求實施精細化、差異化的調控組合，在算力效能提升上取得了不錯的成績。</p><p>算力分配是架構研究的核心問題之一，未來會在以下兩個方面持續開展系統性工作：</p><p>1、結合 AI 大模型的推理能力在調控組合上可以做到更加精細化，在算力效能的提升上會帶來更大的挖掘空間；</p><p>2、通過自適應的宏觀調控給系統穩定性帶來了柔性降級能力，後續會在這個方向上持續深耕，不斷提升系統自動化的處置能力。</p><p>——END——</p><p><strong>推薦閲讀</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247573568%26idx%3D1%26sn%3D393c3af07b86b342aba082cb42ae6594%26chksm%3Dc03f903cf748192a906d259791b7a49b4a34742a656379482051df9c8c0411af15290af1b2b6%26scene%3D21%23wechat_redirect" target="_blank">UBC SDK 日誌級別重複率優化實踐</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247573374%26idx%3D1%26sn%3D9d9d6dd9fa1476416facc30344724b0f%26chksm%3Dc03fef02f7486614370c5f861cf8139e7f37c35e856eda45b4cf1c7269ae82fbe315e1750254%26scene%3D21%23wechat_redirect" target="_blank">百度搜索深度學習模型業務及優化實踐</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247573218%26idx%3D1%26sn%3De5082b7c4b4c14ed9365c18ac74bc8b2%26chksm%3Dc03fee9ef7486788a9ddac5e35cd9c4e1c7bd001b533ca57b9835af04560f09a0ae95ef058c7%26scene%3D21%23wechat_redirect" target="_blank">文生圖大型實踐：揭祕百度搜索 AIGC 繪畫工具的背後故事！</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247572968%26idx%3D1%26sn%3D6895f4d29410e3a2fc2a9884df0a078a%26chksm%3Dc03fed94f7486482f93bbdbce036341e82f50a4822eb3d91ffbd76ca018d47fe35a9f77bdd99%26scene%3D21%23wechat_redirect" target="_blank">大模型在代碼缺陷檢測領域的應用實踐</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247572835%26idx%3D1%26sn%3D7d08b04901206d41bf39c8b07087b391%26chksm%3Dc03fed1ff74864095e11f2f4eb75b15c4abbef06649c719201f782f1f3a653cd22e9fd7f5dac%26scene%3D21%23wechat_redirect" target="_blank">通過 Python 腳本支持 OC 代碼重構實踐（二）：數據項提供模塊接入數據通路的代碼生成</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:16:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/10143329</guid>
            <link>https://my.oschina.net/u/4939618/blog/10143329</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[向開源作者提問「項目還活着嗎」非常粗魯且無禮]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>最近幾個月，開源 AI 項目的創始人 Max Woolf 經歷了一場關於自己的工作的 「存在危機」。</p><p>他表示自己對 AI 的負面抵制情緒日益強烈，以及 AI 行業進展神速，Max 發現自己無法跟上進度，陷入了對開源工作的質疑。在此期間，他暫停了 GitHub 上自己開源項目的開發，其中包括 ChatGPT 的 Python 接口 simpleaichat。</p><p><img src="https://static.oschina.net/uploads/space/2023/1115/190841_hkBi_2720166.png" referrerpolicy="no-referrer"></p><p><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fminimaxir%2Fsimpleaichat" target="_blank">https://github.com/minimaxir/simpleaichat</a></u></em></p><p>簡單來説，Max 壓力太大，需要休息一段時間。按理來説，他的代碼不應該有問題，因為項目本身設計就考慮到了他可能暫停開發的情況。</p><p>然而當 Max 想重操舊業時，卻在自己項目的 GitHub 上收到了質疑開發是否已經停止的問題。儘管沒有任何證據表明代碼出問題，但項目 Stars 數高達 3k 的 simpleaichat 還是收到了 「這個項目被放棄了嗎」 的問題。</p><p><img height="302" src="https://static.oschina.net/uploads/space/2023/1115/190713_TFZG_2720166.png" width="1454" referrerpolicy="no-referrer"></p><p>這讓 Max 感到既震驚又氣憤。他認為，這種質疑開發者的行為是在施加不必要的壓力，也顯得無禮。</p><p>事實上，開源項目從來沒有 「必須持續開發」 的硬性規定。大多數開源許可協議都明確寫明軟件 「按原樣」 提供，不承諾後續維護。但部分社區成員似乎默認開源項目有更新的義務，這讓 Max 和其他開源開發者感到困擾。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9f8029289e5c8978243bb08f62b2b0a4dcf.png" referrerpolicy="no-referrer"></p><p>他認為，開源的最大優勢是可以隨時分叉。如果有開發者認為某項目 「死了」, 大可以複製代碼自行維護。但是有些人卻以 「分叉」 來威脅原作者，這讓原作者不堪重負。</p><p>AI 行業進展迅速，也加重了這一問題。受 ChatGPT 熱潮影響，部分 AI 新創通過風險投資大規模運營，讓人產生開源 AI 必須 「快速迭代」 的誤解。</p><p>Max 表示，這種對開源項目 「活躍度」 的不合理期待，已經成為阻止他繼續開源工作的主要障礙。他正在考慮通過創業來全職維護自己的項目，但前景未卜。</p><p>他認為，質疑開源項目是否 「死了」 的問題本身，不可能讓開發者產生繼續工作的動力。開源社區如果不能保持友善，只會讓更多優秀項目消失。</p><p>原文：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fminimaxir.com%2F2023%2F11%2Fopen-source-dead-github%2F" target="_blank">https://minimaxir.com/2023/11/open-source-dead-github/</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 10:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266608/open-source-dead-github</guid>
            <link>https://www.oschina.net/news/266608/open-source-dead-github</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[零一萬物對 Yi-34B 訓練過程的説明]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>事件背景：</p><ul><li><a href="https://www.oschina.net/news/266377">李開復旗下 AI 公司「零一萬物」開源的 Yi 大模型照搬 Llama 架構</a></li><li><a href="https://www.oschina.net/news/266525">「零一萬物」 迴應 Yi 開源大模型「套殼」 Llama</a></li></ul><hr><p>零一萬物今天正式發文迴應 Yi 開源大模型引起的爭議：</p><blockquote><p>就零一萬物的觀察和分析，大模型社區在技術架構方面現在是一個處於接近往通用化逐步收攏的階段，基本上國際主流大模型都是基於<strong>Transformer</strong>的架構，做 attention，activation，normalization，positional embedding 等部分的改動，LLaMA、Chinchilla、Gopher 等模型的架構和 GPT 架構大同小異，全球開源社區基於主流架構的模型變化非常之多，生態呈現欣欣向榮，國內已發佈的開源模型也絕大多數採用漸成行業標準的 GPT/LLaMA 的架構。然而，大模型持續發展與尋求突破口的<strong>核心點不僅在於架構，而是在於訓練得到的參數</strong>。</p><p>模型訓練過程好比做一道菜，架構只是決定了做菜的原材料和大致步驟，這在大多數人的認知中也逐步形成共識。<strong>要訓練出好的模型，還需要更好的「原材料」（數據）和對每一個步驟細節的把控（訓練方法和具體參數）</strong>。由於大模型技術發展還在非常初期，從技術觀點來説，行業共識是與主流模型保持一致的模型結構，更有利於整體的適配與未來的迭代。</p><p>零一萬物在訓練模型過程中，沿用了 GPT/LLaMA 的基本架構，由於 LLaMA 社區的開源貢獻，讓零一萬物可以快速起步。零一萬物<strong>從零開始訓練</strong>了 Yi-34B 和 Yi-6B 模型，並根據實際的訓練框架重新實現了訓練代碼，用自建的數據管線構建了高質量配比的訓練數據集（從 3PB 原始數據精選到 3T token 高質量數據）。除此以外，在 Infra 部分進行算法、硬件、軟件聯合端到端優化，實現訓練效率倍級提升和極強的容錯能力等原創性突破。<strong>這些科學訓模的系統性工作，往往比起基本模型結構能起到巨大的作用跟價值。</strong></p><p>零一萬物團隊在訓練前的實驗中，嘗試了不同的數據配比科學地選取了最優的數據配比方案，投注大部分精力調整訓練方法、數據配比、數據工程、細節參數、baby sitting（訓練過程監測）技巧等。這一系列超越模型架構之外，研究與工程並進且具有前沿突破性的研發任務，才是真正屬於模型訓練內核<strong>最為關鍵、能夠形成大模型技術護城河 know-how 積累</strong>。在模型訓練同時，零一萬物也針對模型結構中的若干關鍵節點進行了大量的實驗和對比驗證。舉例來説，我們實驗了 Group Query Attention（GQA）、Multi-Head Attention（MHA）、Vanilla Attention 並選擇了 GQA，實驗了 Pre-Norm 和 Post-Norm 在不同網絡寬度和深度上的變化，並選擇了 Pre-Norm，使用了 RoPE ABF 作為 positional embedding 等。也正是在這些實驗與探索過程中，為了執行對比實驗的需要，模型對部分推理參數進行了重新命名。</p><p>在零一萬物初次開源過程中，我們發現用和開源社區普遍使用的 LLaMA 架構會對開發者更為友好，對於沿用 LLaMA 部分推理代碼經實驗更名後的疏忽，原始出發點是為了充分測試模型，並非刻意隱瞞來源。<strong>零一萬物對此提出説明，並表達誠摯的歉意</strong>，我們正在各開源平台重新提交模型及代碼並補充 LLaMA 協議副本的流程中，承諾儘速完成各開源社區的版本更新。</p><p>我們非常感謝社區的反饋，零一萬物在開源社區剛剛起步，希望和大家攜手共創社區繁榮，在近期發佈 Chat Model 之後，我們將擇期發佈技術報告，Yi Open-source 會盡最大努力虛心學習，持續進步。</p><p><em>開源社區討論參考：</em><br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">https://huggingface.co/01-ai/Yi-34B/discussions/11#6553145873a5a6f938658491</a></p></blockquote><p>創新工場 CMO 在轉發上文的朋友圈中表示：「沿用行業演進漸成通用、生態擁抱的基礎架構就成了「套模、山寨」？（就像手機 app 開發者都得益於 iOS、Android 的共通架構）。零一萬物會持續從社區中虛心學習，持續進步。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-76f874328ebdab1a891bfc44ea094f539e4.png" referrerpolicy="no-referrer"></p><p>原文：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FaDclX74mPPtjQvco3GYmZQ" target="_blank">https://mp.weixin.qq.com/s/aDclX74mPPtjQvco3GYmZQ</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 09:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266597</guid>
            <link>https://www.oschina.net/news/266597</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[CodeFuse 開源 ModelCache 大模型語義緩存]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p style="margin-left:0; margin-right:0"><img alt="" src="https://img.alicdn.com/imgextra/i2/O1CN01Moy0hq1P2Cgi8LERe_!!6000000001782-2-tps-900-383.png" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span>CodeFuse 開源火熱進行中！本次開源的是 ModelCache 大模型語義緩存，可大幅降低大模型應用的推理成本，提升用戶體驗。</span></p><p style="margin-left:0; margin-right:0"><span>CodeFuse-ModelCache 項目地址：</span></p><p style="margin-left:0; margin-right:0"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-ModelCache" target="_blank" rel="nofollow"><span>https://github.com/codefuse-ai/CodeFuse-ModelCache</span></a></p><span id="OSC_h2_1"></span><h2><strong><span style="color:#000000">0 背景</span></strong></h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">在 LLM 技術浪潮席捲全球的背景下，大型模型快速增長的參數規模，對部署所需的推理資源帶來了極大的挑戰。為了提高大型模型的推理性能和效率，我們嘗試從緩存角度解決當前大模型規模化服務部署的困境。類似傳統應用，大模型的用戶訪問同樣具有時間和空間的局部性（例如：熱門話題相關內容，熱門 GitHub repo）。如果有了緩存層，在遇到相似請求時，就無需調用大模型服務，直接從緩存的數據中返回已有的結果給用戶，會大幅降低推理成本，提升用戶體驗。</span></p><span id="OSC_h2_2"></span><h2><span style="color:#333333">1 大模型緩存的意義</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">當前大模型服務面臨一下三個挑戰：</span></p><ol><li><span style="color:#333333">成本高：大模型參數量千億級別，單實例就需要多張 A10 卡，規模化部署成本高昂。因此，當前大模型服務基本按照處理的 token 數量計費，導致用戶側使用成本也居高不下。</span></li><li><span style="color:#333333">速度慢：大型模型的推理速度也是一個關鍵問題。在許多實時應用中，如對話系統、業務助手，響應時間要求非常高，通常在毫秒級別。然而，大型模型的推理速度往往較慢，在秒級，導致無法實時返回結果，用戶體驗下降。</span></li><li><span style="color:#333333">穩定性無保障：由於單實例部署成本高昂，當前大模型服務接受到大流量請求時，通過限流的方式，防止服務不可用。</span></li></ol><span id="OSC_h2_3"></span><h2><span>2 方案調研</span></h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">我們對開源方案 GPTCache 進行了調研，其是致力於構建用於存儲 LLM 響應的語義緩存的項目，該項目提供了語義相似度匹配框架，並提供了相對完善的功能模塊和接口。具有以下優點：<span>&nbsp;</span></span></p><ul><li><span style="color:#333333">項目的活躍性，它不斷引入新功能，使得我們能夠緊跟最新的發展動態。<span>&nbsp;</span></span></li><li><span style="color:#333333">具備開放的功能模塊，可以進行調整和優化，這為業務的擴展提供了便利。</span></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#333333">GPTCache 的整體架構如圖 1 所示：</span></p><p style="margin-left:0; margin-right:0; text-align:left"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/275821/1699497539548-420014c2-90f5-45dc-929f-15a2e3d32ebf.png" width="642" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:center"><span style="color:#333333">圖 1. GPTCache 架構</span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">但是，GPTCache 在落地應用上仍存在諸多不足，包括：</span></p><ol><li><span style="color:#333333">架構上將大模型調用和數據回寫對用戶進行了黑盒處理，使得大模型產品在流式輸出、安全審核、問題排查等方面變的複雜。</span></li><li><span style="color:#333333">默認採用 faiss 和 sqlite 作為存儲，不能進行分佈式部署，尤其是在關係型數據庫方面，SqlAlchemy 框架無法支持螞蟻的 OceanBase。</span></li><li><span style="color:#333333">數據和資源隔離上，無法處理多模型多版本場景。</span></li><li><span style="color:#333333">不支持多輪會話，尤其是當模型有 system 指令時，無法很好兼容。更多待改進功能會在 3.3 部分會做詳細介紹。</span></li></ol><span id="OSC_h2_4"></span><h2><span>3 ModelCache 建設</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">針對上述問題，我們基於 GPTCache 進行了二次開發，構建螞蟻內部緩存產品 ModelCache，整體架構見圖 2，接下來會詳細介紹我們的工作，包括：3.1 整體架構；3.2 功能升級。在功能升級部分，會詳細介紹 ModelCache 中新增的功能點。</span></p><span id="OSC_h3_5"></span><h3><span>3.1 整體架構</span></h3><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/305114/1699892547016-2e6263cc-8940-4c43-bffb-5bbd06c57998.png" width="941.818161404823" referrerpolicy="no-referrer"></p><p style="margin-left:16em; margin-right:0"><span>圖 2. ModelCache 架構及上下游</span></p><span id="OSC_h4_6"></span><h4><span style="color:#000000">3.1.1 技術架構</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在初始架構中，將大模型調用和數據回寫對用戶進行了黑盒處理。然而，這種架構導致問題排查繁瑣，以及流式輸出和數據安全審核等方面難以滿足企業級要求。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">因此，我們對架構進行了重新調整，ModelCache 採用了輕量化的接入方式，不打擾大模型產品的功能實現。我們設計 ModelCache 為類 redis 結構，提供了開放式的數據查詢、數據回寫、數據管理等 API，同時解</span><span style="color:#000000">耦</span><span style="color:#333333">了大模型調用，可作為一個獨立模塊嵌入到大模型產品。通過 ModelCache，產品側能夠更加靈活地管理和使用大模型，提高系統的可維護性和可擴展性。</span></p><span id="OSC_h4_7"></span><h4><span style="color:#000000">3.1.2 核心模塊</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在 ModelCache 中，包含了一系列核心模塊，包括 adapter、embedding、</span><span style="color:inherit">rank</span><span style="color:#333333">和 data_manager 等，具體功能如下：</span></p><ol><li><span>adapter 模塊：其主要功能是處理各種任務的業務邏輯，並且能夠將 embedding、</span><span style="color:inherit">rank</span><span>、data_manager 等模塊串聯起來。</span></li><li><span style="color:inherit">embedding 模塊：該模塊主要負責將文本轉換為語義向量表示，它將用戶的查詢轉換為向量形式，並用於後續的召回或存儲操作。</span></li><li><span style="color:inherit">rank 模塊：用於對召回的向量進行相似度排序和評估，可根據 L2 距離、餘弦相似度或者評估模型，對兩個向量進行相似度評分，並進行排序。</span></li><li><span style="color:inherit">data_manager 模塊：該模塊主要用於管理數據庫，包括向量數據庫和關係型數據庫，它負責數據的存儲、查詢、更新和刪除等操作。</span></li></ol><ol><li><ol><li><span style="color:inherit">向量數據庫（Milvus）：</span><span style="color:#333333">Milvus 作為一個高性能、可擴展、多功能的向量數據庫，適用於多種需要向量檢索的應用場景。</span></li><li><span style="color:#333333">關係型數據庫（OceanBase）：我們採用螞蟻的 OceanBase 數據庫，存儲用戶 query、LLM 相應、模型版本等信息。</span></li></ol></li></ol><span id="OSC_h4_8"></span><h4><span>3.1.3 功能對比</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">功能方面，為瞭解決 huggingface 網絡問題並提升推理速度，增加了 embedding 本地推理能力。鑑於 SqlAlchemy 框架存在一些限制，我們對關係數據庫交互模塊進行了重寫，以更靈活地實現數據庫操作。在實踐中，大型模型產品需要與多個用戶和多個模型對接，因此在 ModelCache 中增加了對多租戶的支持，同時也初步兼容了系統指令和多輪會話。更詳細的功能對比請參見表 1。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333"><img alt="" src="https://img.alicdn.com/imgextra/i4/O1CN01P0Zr401heMlvow7LH_!!6000000004302-0-tps-716-788.jpg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0; text-align:center"><span>表 1. ModelCache 與 GPTCache 功能點對比</span></p><span id="OSC_h3_9"></span><h3><span>3.2 功能升級</span></h3><p style="margin-left:0; margin-right:0"><span style="color:inherit">為了將 Cache 產品應用於企業級用戶，並實現真正的落地效果，我們對其功能進行了大量迭代升級，核心功能如圖 3 所示。</span></p><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/2756586/1693799564935-9cb1f565-58a4-4f83-af78-54aaace84668.png" width="657" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:center"><span>圖 3. ModelCache 核心功能</span></p><span id="OSC_h4_10"></span><h4><span>3.2.1 數據管理</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">Cache 需要確保過時或不必要的數據不會在緩存中累積，緩存管理是 Cache 中關鍵的一環，為此，我們實現了兩個重要的功能：</span></p><ul><li><span>一鍵清空能力：</span><span style="color:#333333">ModelCache 中提供了數據移除接口，使用戶能夠一鍵清空其緩存。這項功能確保當模型版本或者參數發生變更時，前期版本的數據不會對線上的回答造成幹擾。</span></li><li><span>緩存淘汰策略：</span><span style="color:#333333">ModelCache 支持可定製化的緩存淘汰策略，使用戶能夠根據自身需求來定製緩存。</span></li></ul><span id="OSC_h4_11"></span><h4><span>3.2.2 數據隔離</span></h4><p style="margin-left:0; margin-right:0"><span>在實際應用中，數據隔離是一個重要的功能，為了滿足不同場景的需求，ModelCache 實現了多種數據隔離功能，包括：</span></p><ul><li><span>環境隔離： 支持在不同環境中進行數據隔離，包括 DEV、預發和線上環境。這些環境可能存在模型版本和參數上的差異，因此確保了數據在不同環境中的獨立性。</span></li><li><span>模型隔離： 支持模型級別的隔離，使用向量數據庫表和 OB 表字段實現獨立存儲。通過這種方式，不同模型之間的數據可以得到有效的隔離，確保數據的安全性和完整性。</span></li></ul><span id="OSC_h4_12"></span><h4><span>3.2.3 數據迴流</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">數據迴流功能具有知識持久化的能力，能夠確保系統重要數據得到有效地保存和持續使用，從而支持系統的長期發展。為此，Cache 中提供了數據迴流功能，使得系統中的數據能夠得到有效的持久化，這項功能採用異步方式進行，儘可能減少對系統性能的影響。</span></p><span id="OSC_h4_13"></span><h4><span>3.2.4 system 指令及多輪對話支持</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在 ModelCache 中，提供了 system 指令和多輪對話支持，以滿足用戶的需求。具體如下：</span></p><ul><li><span style="color:#333333">system 指令支持： ModelCache 中支持 system 指令，尤其是後續用戶可以自定義 system 指令的情況下，會區分不同 system 指令下對話的語義相似性，保持 Cache 的穩定性，未來，我們還計劃將 system 指令與會話進行分離，以進一步提升系統的靈活性和可擴展性。</span></li><li><span style="color:#333333">多輪對話能力： ModelCache 還支持多輪對話，即能夠匹配連續對話的語義相似性。</span></li></ul><span id="OSC_h4_14"></span><h4><span>3.2.5 可遷移性</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">ModelCache 具有出色的可遷移性，能夠適應不同的場景，OceanBase 可以無縫遷移至 mysql 等產品，Milvus 也是一種可快速部署的數據庫服務，所以無論是專有云還是公有云都能夠快速應對，並提供高質量的服務。這種可遷移性意味着，ModelCache 可以為用戶提供更加靈活和可擴展的部署方案，以滿足不同的需求和場景。</span></p><span id="OSC_h4_15"></span><h4><span>3.2.6 Embedding 能力</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在當前的 cache 中，用戶可使用中文通用 embedding 模型（text2vec-base-chinese）。我們也支持大模型 embedding 層的嵌入能力，這使得 embedding 能夠更好地適應模型本身的語義，但僅使用大模型的 embedding 層，演變成了詞袋模型，無法獲取各個 token 的權重。為此，我們在訓練 SGPT（GPT Sentence Embeddings<span>&nbsp;</span></span><span>for Semantic<span>&nbsp;</span></span><span style="color:#333333">Search），以更好的支持 ModelCache。</span></p><span id="OSC_h2_16"></span><h2>&nbsp;</h2><span id="OSC_h2_17"></span><h2><span>4 效果統計</span></h2><span id="OSC_h4_18"></span><h4><span>4.1 效率統計</span></h4><p style="margin-left:0; margin-right:0"><span>依據螞蟻內部大模型產品的 GOC 日誌信息，統計了緩存命中時長和直接調用模型時長，因為產品端採用了流式輸出，時間上會有一定的增加。經過實際系統統計，命中緩存可以將平均耗時降低 10 倍，整體有效提速率可達 14.5%。有效提速率的定義參見下面公式：</span></p><p style="margin-left:0; margin-right:0"><span><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/ba80167f7563caedd5661a48c7813188.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">根據迴流數據（排除流式輸出的延遲），對緩存的耗時進行了評估，緩存未命中的耗時已經控制在數百毫秒量級，我們仍在持續進行查詢耗時的優化。</span></p><span id="OSC_h4_19"></span><h4><span>4.2 embedding 模型的持續優化</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在緩存場景中，我們發現僅僅評估語義相似性是不夠的，核心目標應該是判斷 query 對應的大型模型輸出是否一致（query 的語義相似不等價於大型模型的回覆一致）。例如下面的 query，一詞之差，但生成的結果是完全不同的</span></p><ul><li><ul><li><span style="color:#333333">query: 從 1 遍歷到 1000，找出所有能被 13 和 23 整除的數字，用 Python 實現</span></li><li><span style="color:#333333">query: 從 1 遍歷到 1000，找出所有能被 13 和 23 整除的數字，用 Java 實現</span></li></ul></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#333333">我們調研了 SentenceTransformer 領域的諸多模型，但都無法滿足緩存場景的需求。因此訓練了一個面向企業級應用的 embedding 模型，並希望在此基礎上進一步提升語義相似度評估的準確性，以提高緩存的準確率。</span></p><span id="OSC_h2_20"></span><h2><span>5 未來展望</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">未來，我們旨在提供性能更強、精度更高的解決方案，以滿足 LLM Cache 場景下的需求。將不斷地進行研究和優化，以確保 Cache 系統能夠在實際應用中取得最佳的性能和準確性</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">在性能方面，將通過深入優化各個環節，包括算法、數據和計算資源，以實現更快的召回時間，目標是將整體處理時間壓縮到 300 毫秒以內，以提供更快捷高效的用戶體驗。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">在精度方面，將注重語義模型的建設，通過深入研究和改進語義表示技術，致力於提升模型對複雜語義的準確理解能力，從而更精準地匹配用戶的 query。此外，還會對相似度評估模塊進行優化，以進一步提升召回率。我們將綜合考慮多種評估指標，如準確度、召回率和 F1 分數，以確保模型在各個方面都取得顯著的提升。</span></p><span id="OSC_h2_21"></span><h2>&nbsp;</h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">想了解更多 CodeFuse 詳情，點擊進入</span><span style="color:#000000">CodeFuse 官網：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcodefuse.alipay.com%2F" target="_blank" rel="nofollow">https://codefuse.alipay.com</a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 08:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6942768/blog/10143074</guid>
            <link>https://my.oschina.net/u/6942768/blog/10143074</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[BifroMQ-v2.0.0 版本重磅發佈：支持標準集羣模式（StandardCluster）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0px; margin-right:0px">2023 年 7 月，百度天工 AIoT 團隊正式開源高性能分佈式 MQTT 物聯網消息中間件，並將其全新命名為 BifroMQ。自 BifroMQ 首個版本發佈以來，獲得海量社區的廣泛關注，其中，BifroMQ 的集羣能力一直備受期待。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">通過近三個月的不懈努力，如今正式推出 BifroMQ-v2.0.0 版本，新版本首次支持集羣模式，我們將其稱為標準集羣 StandardCluster（以下簡稱 StandardCluster）。新版本主要有以下特性：</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">🌍 集羣模式全面支持 MQTT 協議：在集羣模式下，每個節點均具備完整的 MQTT 協議功能，提供更高的可用性和擴展性。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">🌍&nbsp;新增 HTTP API 支持：除 MQTT 外，本版本新增對 HTTP API 的支持，更加靈活多變。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">🚀 高性能不減：專注於在大規模負載環境下的高性能 MQTT 協議。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">🛠️ 模塊化架構進一步優化：適應各種業務需求的分佈式集羣管理。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">📊 強力可擴展性：目標支持大規模多租戶的 Serverless 雲服務。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">詳情介紹，繼續閲讀</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span><strong>BifroMQ 的集羣架構解析</strong></span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3498db"><strong>▌StandardCluster 的整體結構</strong></span></p><p style="margin-left:0; margin-right:0">在過往介紹 BifroMQ 整體架構的文章（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbifromq.io%2Fzh-Hans%2Fblog%2Fbifromq-tech-architecture%2F" target="_blank">https://bifromq.io/zh-Hans/blog/bifromq-tech-architecture/</a>）中，曾提到 BifroMQ 將邏輯上的 MQTT 功能從負載的角度分解為若干子服務，每個子服務對應一類關鍵負載：</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3e3e3e">·bifromq-mqtt：負責 MQTT 協議連接負載</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3e3e3e">·bifromq-dist：負責訂閲和消息路由分發負載</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3e3e3e">·bifromq-inbox：負責持久會話中的離線消息隊列負載</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3e3e3e">·bifromq-retain：負責 Retain 消息存取負載</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">從部署的角度出發，BifroMQ StandardCluster 是將這些獨立負載的服務模塊"封裝"到一個節點服務進程的集羣模式，從邏輯上來説，此為 Standalone 運行模式的抽象（BifroMQ Standalone 可以看作是單個節點的 BifroMQ StandardCluster）。與其他支持集羣的 MQTT Broker 不同，BifroMQ 內置分佈式持久化功能，因此單個 BifroMQ 節點是"有狀態的"（Stateful）。</p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-6d871c8ad8353d28f90b010ef0e2e4b0a09.png" width="792" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:center">▲ 標準集羣的整體結構</p><p style="margin-left:0; margin-right:0; text-align:justify">注：本文所有插圖中括號內的﻿bifromq-xxx﻿，即為代碼中對應的模塊名稱</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3498db"><strong>▌消息分發能力的水平擴展</strong></span></p><p style="margin-left:0; margin-right:0">在 StandardCluster 集羣模式下，每個節點進程內的分發負載模塊（ 以下簡稱 Dist Service ）構成邏輯上的負載子集羣（Dist-SubCluster）。Dist Service 將訂閲信息存儲在內置的持久化引擎中，並通過持久化引擎的分佈式功能在節點之間同步路由信息。在 StandardCluster 模式下，通過增加節點的方式，即可以實現消息分發能力的水平擴展，特別是在 CleanSession 為 True 的情況下，這一點非常明顯，詳見官網測試報告。</p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-42840b4de22478548ca6934ee24df62ec21.png" width="792" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:center">▲ bifromq-dist 結構</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3498db"><strong>▌離線消息隊列的持久化、擴展性及高可靠性</strong></span></p><p style="margin-left:0; margin-right:0">與 Dist Service 模塊類似，節點進程內負責 MQTT 持久會話中離線消息隊列的 Inbox Service 模塊構成了另一個邏輯上的負載子集羣（以下簡稱 Inbox-SubCluster）。Inbox Service 將離線隊列消息持久化到內置的存儲引擎中，可以極大程度地減少因節點故障導致的數據丟失。在存儲方面，Inbox Service 利用內置存儲引擎的分片功能，在實現存儲規模和處理能力水平擴展的同時，通過靜態配置或運行時策略動態增加分片的副本數，可以進一步提高離線消息數據的可靠性，這對某些對數據可靠性要求更高的應用場景尤為重要。</p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-a071612e0fe715b733bad98bb4ca1353b8d.png" width="792" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:center">▲ bifromq-inbox 結構</p><p style="margin-left:0; margin-right:0; text-align:justify">注 1：由於增加分片副本數對 MQTT CleanSession 為 False 的消息負載有不可忽視的影響，需要根據實際需求確定資源投入以達到預期效果。因此，默認副本數為 1，該設置可以通過 JVM 啓動參數&nbsp;﻿inbox_store_range_voter_count﻿&nbsp;進行調整</p><p style="margin-left:0; margin-right:0; text-align:justify">注 2：Inbox Service 提供了離線消息隊列的全局訪問能力，因此 MQTT 客戶端重新連接到任何集羣節點時都可以訪問所屬隊列中的離線消息，無需引入在其他 MQTT Broker 集羣實現中常見的 sticky session 或 session migration 方案</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3498db"><strong>▌</strong><strong>Inbox 服務的基於負載的拆分策略</strong></span></p><p style="margin-left:0; margin-right:0">如前文所述，在 StandardCluster 部署下，單個節點進程內的 Inbox Service 利用了內置存儲引擎的分片功能來實現存儲規模和處理能力的水平擴展。然而，分片策略對實際運行效果有着決定性的影響。在 BifroMQ StandardCluster 版本中，已內置開箱即用的基於負載的拆分策略（以下簡稱 Load-based Splitting）。該策略通過統計最近一段時間內的負載情況來決定對 KV Range 的劃分，可以視為一種"後驗"拆分策略。當使用場景已經對離線消息負載的分佈有提前規劃和了解時，提前劃分 Range 往往能在負載到來時帶來更穩定的性能表現，而對於深度使用 BifroMQ 的用戶，可以通過 SPI 機制實現此類"先驗"拆分策略。</p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="600" src="https://oscimg.oschina.net/oscnet/up-46576e818cdeb9a1b9aafe883169c0428aa.png" width="400" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:center">▲inbox 服務拆分策略</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#3498db"><strong>▌</strong><strong>HTTP API 模塊</strong></span></p><p style="margin-left:0; margin-right:0">BifroMQ StandardCluster 版本同時引入了 HTTP API 功能，每個集羣節點均可通過配置開放 API 訪問端口。BifroMQ HTTP API 作為無狀態的全局接口，旨在支持業務層面的管理控制邏輯集成，訪問任何一個節點的 API 都可以實現對整個集羣的操作，詳見官網 API 使用指南</p><p style="margin-left:0; margin-right:0; text-align:center"><img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-d65f5da4462a78d93bd53c50c1b80d118c8.png" width="792" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:center">▲HTTP API 模塊結構</p><p style="margin-left:0px; margin-right:0px; text-align:center">&nbsp;</p><p style="margin-left:0; margin-right:0"><span><strong>混合負載對性能的影響</strong></span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#3e3e3e">在 StandardCluster 部署下，單個節點具備完整的 MQTT 協議功能，承擔各種類型的負載。因此，這種模式非常適用於以下兩類企業級應用場景：</span></p><p style="margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#3e3e3e">·業務產生的負載類型相對單一</span></p><p style="margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#3e3e3e">·</span><span style="color:#3e3e3e">業務產生的負載類型多元化，但產生時間相對分散。對於負載形式複雜且在時間維度上有集中產生的情況，我們建議用戶通過模擬負載測試來獲得單個 BifroMQ StandardCluster 集羣下的最佳資源配置和參數設置，或者考慮使用多個 BifroMQ StandardCluster 來承載不同類型的業務負載。另外，您還可以與我們聯繫，獲取 BifroMQ 商業版本的獨立負載集羣支持。</span></p><p style="margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="margin-left:0; margin-right:0"><span><strong>簡單部署和簡化運維</strong></span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">在以往 BifroMQ 技術架構文章中，曾提及 BifroMQ 集羣建立在一套內置的去中心化技術之上（base-cluster），無需依賴外部節點註冊和發現服務。因此，構建 BifroMQ StandardCluster 的部署過程非常簡單，只需指定任何一個集羣中的節點作為種子節點，即可完成新節點的加入。此外，BifroMQ 還內置了集羣分裂後的自愈能力，可以極大地簡化出現網絡分區（Network Partition）等故障時的運維操作。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span><strong>相關鏈接</strong></span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">·BifroMQ 官網（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbifromq.io%2F" target="_blank">https://bifromq.io/</a>）</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">·安裝包地址（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbaidu%2Fbifromq%2Freleases%2Ftag%2Fv2.0.0" target="_blank">https://github.com/baidu/bifromq/releases/tag/v2.0.0</a>）</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">·部署指南（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbifromq.io%2Fzh-Hans%2Fdocs%2F2.0.0%2Fdeploy%2Fcluster%2F" target="_blank">https://bifromq.io/zh-Hans/docs/2.0.0/deploy/cluster/</a>）</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span><strong>未來展望</strong></span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0">BifroMQ 團隊一直秉持技術中立理念，致力於大規模實現 MQTT 協議，從而提高可靠性和可維護性。我們期待更多社區參與和深入使用反饋，共同推動這一技術的成熟。此外，您還可以通過掃描下方二維碼加入開發者交流社區，與廣大同行進行交流學習。</p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="250" src="https://oscimg.oschina.net/oscnet/up-87a63b79b2a9bc4215a5e13869541f206e1.png" width="450" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 04:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266713</guid>
            <link>https://www.oschina.net/news/266713</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[BifroMQ-v2.0.0 發佈：支持標準集羣模式（StandardCluster）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#3e3e3e">百度天工 AIoT 團隊在 2023 年 7 月正式宣佈開源高性能分佈式 MQTT 物聯網消息中間件，並將其全新命名為 BifroMQ。歷時三個月，BifroMQ-v2.0.0 版本現已<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FT6CCbbEsdM9mBu_hJVRPGA" target="_blank">發佈</a>。</span></p><p><span style="background-color:#ffffff; color:#3e3e3e">新版本首次支持集羣模式，官方將其稱為標準集羣 StandardCluster（簡稱 StandardCluster）。</span><strong><span style="background-color:#ffffff; color:#3e3e3e">主要有以下特性：</span></strong></p><ul><li style="text-align:justify">集羣模式全面支持 MQTT 協議：在集羣模式下，每個節點均具備完整的 MQTT 協議功能，提供更高的可用性和擴展性。</li><li style="text-align:justify">新增 HTTP API 支持：除 MQTT 外，本版本新增對 HTTP API 的支持，更加靈活多變。</li><li style="text-align:justify">高性能不減：專注於在大規模負載環境下的高性能 MQTT 協議。</li><li style="text-align:justify">模塊化架構進一步優化：適應各種業務需求的分佈式集羣管理。</li><li style="text-align:justify">強力可擴展性：目標支持大規模多租戶的 Serverless 雲服務。</li></ul><h4><strong>BifroMQ 的集羣架構解析</strong></h4><p><strong>StandardCluster 的整體結構</strong></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">BifroMQ 將邏輯上的 MQTT 功能從負載的角度分解為若干子服務，每個子服務對應一類關鍵負載：</p><ul><li style="text-align:justify"><span style="color:#3e3e3e">bifromq-mqtt：負責 MQTT 協議連接負載</span></li><li style="text-align:justify"><span style="color:#3e3e3e">bifromq-dist：負責訂閲和消息路由分發負載</span></li><li style="text-align:justify"><span style="color:#3e3e3e">bifromq-inbox：負責持久會話中的離線消息隊列負載</span></li><li style="text-align:justify"><span style="color:#3e3e3e">bifromq-retain：負責 Retain 消息存取負載</span></li></ul><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">從部署的角度出發，BifroMQ StandardCluster 是將這些獨立負載的服務模塊"封裝"到一個節點服務進程的集羣模式，從邏輯上來説，此為 Standalone 運行模式的抽象（BifroMQ Standalone 可以看作是單個節點的 BifroMQ StandardCluster）。與其他支持集羣的 MQTT Broker 不同，BifroMQ 內置分佈式持久化功能，因此單個 BifroMQ 節點是"有狀態的"（Stateful）。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="340" src="https://oscimg.oschina.net/oscnet/up-10103acc9b9400c10279995130df8a8a450.png" width="500" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><strong>消息分發能力的水平擴展</strong></p><p style="margin-left:0; margin-right:0">在 StandardCluster 集羣模式下，每個節點進程內的分發負載模塊（ 簡稱 Dist Service ）構成邏輯上的負載子集羣（Dist-SubCluster）。Dist Service 將訂閲信息存儲在內置的持久化引擎中，並通過持久化引擎的分佈式功能在節點之間同步路由信息。公告稱，在 StandardCluster 模式下，通過增加節點的方式，即可以實現消息分發能力的水平擴展，特別是在 CleanSession 為 True 的情況下。</p><p style="margin-left:0; margin-right:0"><img height="361" src="https://oscimg.oschina.net/oscnet/up-e9a61c9398acd91228e41d3c1715da396bc.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>離線消息隊列的持久化、擴展性及高可靠性</strong></p><p style="margin-left:0; margin-right:0">與 Dist Service 模塊類似，節點進程內負責 MQTT 持久會話中離線消息隊列的 Inbox Service 模塊構成了另一個邏輯上的負載子集羣（以下簡稱 Inbox-SubCluster）。Inbox Service 將離線隊列消息持久化到內置的存儲引擎中，可以極大程度地減少因節點故障導致的數據丟失。在存儲方面，Inbox Service 利用內置存儲引擎的分片功能，在實現存儲規模和處理能力水平擴展的同時，通過靜態配置或運行時策略動態增加分片的副本數，可以進一步提高離線消息數據的可靠性，這對某些對數據可靠性要求更高的應用場景尤為重要。</p><p style="margin-left:0; margin-right:0"><img height="427" src="https://oscimg.oschina.net/oscnet/up-e83bad09a192ee073e83448271eeacd3340.png" width="500" referrerpolicy="no-referrer"></p><p><strong>Inbox 服務的基於負載的拆分策略</strong></p><p>如前文所述，在 StandardCluster 部署下，單個節點進程內的 Inbox Service 利用了內置存儲引擎的分片功能來實現存儲規模和處理能力的水平擴展。然而，分片策略對實際運行效果有着決定性的影響。在 BifroMQ StandardCluster 版本中，已內置開箱即用的基於負載的拆分策略（以下簡稱 Load-based Splitting）。該策略通過統計最近一段時間內的負載情況來決定對 KV Range 的劃分，可以視為一種"後驗"拆分策略。當使用場景已經對離線消息負載的分佈有提前規劃和了解時，提前劃分 Range 往往能在負載到來時帶來更穩定的性能表現，而對於深度使用 BifroMQ 的用戶，可以通過 SPI 機制實現此類"先驗"拆分策略。</p><p style="margin-left:0; margin-right:0"><img height="435" src="https://oscimg.oschina.net/oscnet/up-9ebbc30509ae5d8f8471705413c1acf321a.png" width="300" referrerpolicy="no-referrer"></p><p><strong>HTTP API 模塊</strong></p><p>BifroMQ StandardCluster 版本同時引入了 HTTP API 功能，每個集羣節點均可通過配置開放 API 訪問端口。BifroMQ HTTP API 作為無狀態的全局接口，旨在支持業務層面的管理控制邏輯集成，訪問任何一個節點的 API 都可以實現對整個集羣的操作。</p><p><img height="321" src="https://oscimg.oschina.net/oscnet/up-616f9216ef245596cf8317b83796422bcca.png" width="500" referrerpolicy="no-referrer"></p><h4>混合負載對性能的影響</h4><p style="color:#878787; margin-left:0; margin-right:0; text-align:justify"><span style="color:#3e3e3e">在 StandardCluster 部署下，單個節點具備完整的 MQTT 協議功能，承擔各種類型的負載。因此，這種模式非常適用於以下兩類企業級應用場景：</span></p><ul><li style="text-align:justify"><span style="color:#3e3e3e">業務產生的負載類型相對單一</span></li><li style="text-align:justify"><span style="color:#3e3e3e">業務產生的負載類型多元化，但產生時間相對分散。對於負載形式複雜且在時間維度上有集中產生的情況，官方建議用戶通過模擬負載測試來獲得單個 BifroMQ StandardCluster 集羣下的最佳資源配置和參數設置，或者考慮使用多個 BifroMQ StandardCluster 來承載不同類型的業務負載。</span></li></ul><h4 style="margin-left:0px; margin-right:0px; text-align:justify"><strong><span style="color:#3e3e3e">簡單部署和簡化運維</span></strong></h4><p><span style="color:#3e3e3e">BifroMQ 集羣建立在一套內置的去中心化技術之上（base-cluster），無需依賴外部節點註冊和發現服務。因此，構建 BifroMQ StandardCluster 的部署過程非常簡單，只需指定任何一個集羣中的節點作為種子節點，即可完成新節點的加入。此外，BifroMQ 還內置了集羣分裂後的自愈能力，可以極大地簡化出現網絡分區（Network Partition）等故障時的運維操作。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 12 Nov 2023 08:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266594/bifromq-2-0-0-released</guid>
            <link>https://www.oschina.net/news/266594/bifromq-2-0-0-released</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
