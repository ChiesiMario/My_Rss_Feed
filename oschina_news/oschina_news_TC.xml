<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 26 Dec 2023 03:37:28 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Fedora 40 計劃統一 /usr/bin 和 /usr/sbin]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>早在多年前，Fedora 曾合併了 /bin 和 /usr/bin。時至今日，針對 Fedora 40&nbsp;提交的一項最新更改<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fwiki%2FChanges%2FUnify_bin_and_sbin" target="_blank">提案</a>則提出，統一其&nbsp;/usr/bin&nbsp;和&nbsp;/usr/sbin&nbsp;位置；因為&nbsp;<span style="background-color:#ffffff; color:#121212">/bin 和 /sbin 之間的劃分已不再有用，且無人使用。</span></p><p>提案解釋稱：</p><blockquote><p>/usr/sbin 目錄成為 bin 的 symlink，這意味着 /usr/bin/foo 和 /usr/sbin/foo 等路徑指向同一個地方。/bin 和 /sbin 已經是 /usr/bin 和 /usr/sbin 的 symlink，因此 /bin/foo 和 /sbin/foo 實際上也指向同一個地方。/usr/sbin 將從默認的 $PATH 中刪除。</p></blockquote><p><img height="219" src="https://oscimg.oschina.net/oscnet/up-ed7d7efd2d93feaf5de7d017798772f87b4.png" width="700" referrerpolicy="no-referrer"></p><p>該變更提案認為這對 packagers 和 end-users 來説都是一種簡化，且 Fedora 將與 Debian 等其他 Linux 發行版更加兼容。</p><p><strong><span><span><span style="color:#373a3c"><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>對 Fedora 的好處：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><ul><li>Packagers&nbsp;不必考慮是將程序安裝在<code>%_bindir</code>還是<code>%_sbindir</code>。</li><li>用戶不必考慮程序是安裝在<code>%_bindir</code>還是<code>%_sbindir</code>.</li><li>Fedora 與其他發行版變得更加兼容。「例如，我們有 /sbin/ip，而 Debian 有 /bin/ip；我們有 /bin/chmem 和 /bin/isosize，而 Debian 有 /sbin/chmem 和 /sbin/isosize、 我們還有 /sbin/{addpart,delpart,lnstat,nstat,partx,ping,rdma,resizeepart,ss,udevadm,update-alternatives}，而 Debian 的這些都在 /bin 下，等等。」</li><li>Fedora 與 Arch 更加兼容，Arch 於幾年前進行了合併。</li><li><code>execvp</code>和相關函數遍歷的目錄更少。這對於速度可能並不重要，但在查看日誌或<code>strace</code>輸出時是一個很好的簡化。</li></ul><p><strong><span><span><span style="color:#373a3c"><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span><span>升級/兼容性影響</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span><span style="color:#373a3c"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>對於用戶來説，這種變化基本上是不可見的。在過渡過程中，兩套路徑都應正常工作，用戶在<code>$PATH</code>中應同時擁有這兩個目錄。一旦過渡完成，兩套路徑都將正常工作，但用戶在<code>$PATH</code>中只能看到<code>/usr/bin</code>。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>目前，該變更提案仍處於擬議狀態，需得到 FESCo 的批准後才能應用在四月發佈的 Fedora 40 中。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 26 Dec 2023 03:29:24 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272754/fedora-40-unify-usr-bin-sbin</guid>
            <link>https://www.oschina.net/news/272754/fedora-40-unify-usr-bin-sbin</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[2023 年度低代碼企業 TOP50 榜單公佈 — JeecgBoot 連續兩年榮登榜單]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p style="margin-left:0; margin-right:0">近日，中國科學院主管、科學出版社主辦的國家級核心期刊《互聯網週刊》聯合 eNet 研究院、德本諮詢評選的《2023 低代碼企業 50 強》榜單正式公佈。這一榜單的公佈引起了業內外的廣泛關注，因為其中涵蓋了低代碼開發領域的眾多傑出企業，展現了低代碼產業的發展趨勢和行業格局。</p></blockquote><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">在這份備受矚目的榜單中，知名企業釘釘、騰訊雲、華為雲等行業優秀廠商的產品悉數入選，充分展現了它們在低代碼領域的技術實力和市場影響力。而更加令人矚目的是，<code>JeecgBoot</code><span>&nbsp;</span>作為低代碼開發領域的領軍企業，連續兩年榮登榜單，憑藉其卓越的產品實力和市場表現，再次彰顯了其在行業中的領先地位和影響力。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">JeecgBoot 低代碼平台作為備受認可的低代碼開發平台，一直以來致力於為企業提供高效、靈活、可定製的低代碼開發解決方案。其產品以簡單易用、快速開發、可視化操作等特點而著稱，深受廣大企業用戶的青睞。JeecgBoot 連續兩年榮登《2023 低代碼企業 50 強》榜單，再次印證了其在低代碼開發領域的卓越地位和不斷增長的市場影響力。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">www.jeecg.com</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img alt="" height="330" src="https://oscimg.oschina.net/oscnet/up-458906dcd2cc0cb63a454761d96b1602826.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">同時在 2023 年，JeecgBoot 又推出了 「敲敲雲」 零代碼產品，將為低代碼市場帶來新的競爭對手和發展動力。這不僅豐富了 JeecgBoot 的產品線，也為企業用戶提供了更多元化的選擇。隨着低代碼和零代碼市場的不斷髮展，我們有理由相信，這將為整個數字化轉型領域帶來更多的機遇和活力。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">www.qiaoqiaoyun.com</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img alt="" height="300" src="https://oscimg.oschina.net/oscnet/up-cad61647c80a1dbdedac3adc1d490cb1917.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img alt="" height="2516" src="https://oscimg.oschina.net/oscnet/up-c3e1f9901ed0f7fbba1f83cc3cf120a9ab1.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 26 Dec 2023 03:09:24 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272750</guid>
            <link>https://www.oschina.net/news/272750</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[上雲？下雲？降本增笑？割韭菜？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>本月，滴滴崩潰事件鬧得轟轟烈烈，各種離譜派單層出不窮，而造成這一混亂的，則是底層出故障的雲。尷尬的是，這已經不是第一次雲崩潰事件了，距離上一次阿里雲事件，還不到一個月。</p><p>一時之間，各種有關「雲」的討論紛紛揚揚：有人眼饞馬斯克的 X 下雲省錢，覺得反正都有風險，還不如自己弄，這樣更可掌控，也更清楚；有人則認為上雲才是未來的趨勢，想要發揮出軟件的最大優勢，上雲更合適。</p><p>那麼，實際操作中，到底是自建雲更安全，還是公有云更有保障？對普通的廠商而言，該怎麼選擇呢？對此，開源中國邀請了前滴滴軟件開發工程師李鶴、AutoMQ 聯合創始人 &amp; CTO 周新宇、前淘寶 DBA 蔣明、磐吉雲數 CEO 馮若航、公眾號《瑞典馬工》主理人馬工，一起來討論。</p><p>&nbsp;</p><span id="OSC_h1_1"></span><h1>上雲到底有沒有必要？雲是不是在割韭菜？</h1><p><strong>正方：周新宇 speaking ——</strong></p><p>我個人大概是在 16 年就加入阿里巴巴巴的中間件團隊了，服務了很多客戶。從我個人的經驗來講：</p><p><strong>第一，沒有云之前，硬件出了問題，解決的門檻很高。</strong>阿里內部上雲之前，因為消息中間件集羣規模很大，硬件它總是在出問題，比如説因為網卡問題導致了 TCD 重視率很高，硬盤出現局部的不可寫；比如服務器某個硬件溫度過高，導致一些局部的節點不可用。好在阿里有專業的團隊幫忙解決，但這在小企業就很難負擔了。</p><p><strong>第二，公有云比專有云效率高。</strong>像我們專門做交付，交付完才是第一步，後面有很多的運維工作，這些運維工作，如果我們遠程去做的話，效率比較低，如果去駐廠的話，成本又比較高。公有云的模式，通過聚集算力和統一標準，帶來了很多效率上的提升。</p><p><strong>第三，雲計算能加速業務的創新，提高社會運轉效率。</strong>像在線教育行業，幾年前，基本上都利用了公有云的優勢來快速進行業務的創新。如果沒有云計算，如果不上雲，這些完全不可能發生。還有疫情期間的遠程會議，一定程度上保障了社會各方面的正常運轉。背後的釘釘這些企業軟件，也都是雲計算在提供算力。</p><p>過去，大部分企業還是以雲託管的方式上雲為主，基本上就是傳統的軟件架構，通過這個方式進行上雲。但不管怎麼樣，一定程度上解決了效率和創新問題。今天在降本增效的浪潮下，企業用雲，可能不能暴力地照搬以前的架構了，架構需要面向雲的能力去設計、去優化，把雲原生的能力發揮出來。</p><p>&nbsp;</p><p><strong>反方：馮若航 speaking ——</strong></p><p>我比較喜歡用實打實的數據來定量分析雲。我的觀點是：在降本增效成為主旋律的大背景下，對於有一定規模的雲上企業來説，下雲自建是一個非常經濟務實的選項。我認為公有云它是有適用光譜的，絕對不是他們宣稱的數字化萬金油。不在這個光譜範圍內的業務，如果選擇上雲，或者是留在雲上，那就是被割韭菜了。</p><p><strong>我這有歪詩一首：世人常道雲上好，託管服務煩惱少。我言云乃殺豬盤，溢價百倍實厚顏。賽博地主搞壟斷，坐地起價剝血汗。運維外包嫖開源，租賃電腦炒概念。</strong></p><p>公有云的商業模式概括起來就是一個事兒：租——租服務器租帶寬租磁盤租運維，這跟租房沒有什麼本質的區別，自建我們就可以類比為買房。那麼租房還是買房的決定性因素是什麼？我認為是租售比。房子的租售比一般在幾百一個月，那大家買房可能要掂量。那麼，服務器的租售比、雲算力的租售比一般在半年左右使用費=購買價格。雲磁盤的租售比就更離譜了，只有十幾天到一個月。你用一塊雲盤十幾天就能買下來，你用一台雲服務器，六個月就能把它買下來，那麼你為什麼要把一個業務跑在這租的東西上，而不是直接把它買下來？如果你的業務生命週期超過六個月，你可以考慮把它買下來，而不是租。</p><p>為什麼雲的價格這麼貴？我認為根本原因在硬件上。硬件遵循着摩爾定律在指數增長，成本在指數下降，而這個指數變化並沒有在公有云的價格上反映出來，所以公有云從最開始的普惠基礎設施，發展到今天變成了一個殺豬盤。它的資源租賃價格已經達到了自建單價的幾十倍上百倍，堪稱終極的成本刺客。</p><p>這也引發了一些新的變化，比如説馬斯克的 X（Twitter）、DHH 的 37Signals，算了賬單之後，明智地選擇了從雲上搬遷下來，節約了每年上千萬甚至上億的成本。我認為，這些案例對於整個行業，都是非常具有借鑑意義的里程碑標誌。</p><p>所以，<strong>我認為雲的適用光譜就是三件事——小規模，高彈性，全球化。不在這三個場景之內的業務，你選擇留在雲上，就是在為幾倍幾十倍的溢價交智商稅、被割韭菜。</strong></p><p>&nbsp;</p><p><strong>正方：周新宇 speaking ——</strong></p><p>我覺得這裏面有一個誤區，<strong>不能拿這個硬件的成本去跟軟件、甚至跟雲服務對比。</strong>比如説馮總以前寫過一篇文章，就是拿本地盤跟 EBS 價格做對比。實際上我認為 EBS 它本身是一個軟件服務，它背後是一整套的完整的分佈式系統，雲服務已經提供了至少三個九的可用性。但本地盤它是硬件，它的故障概率是比較高的，不同的廠商，年化的故障率可能都有差異，有些可能甚至高達 5% 左右。任何硬件壞了都可能導致無法訪問這個本地盤的數據，但在雲上，ECS 也好 EBS 也好，它們都是軟件，你可以理解為它們就是存算分離的。從應用角度來看，ECS、EBS 都是無狀態的，EBS 還解決了一個多副本問題。</p><p>如果今天要用本地盤，肯定得主副本，那數據的複製帶來的網絡帶寬消耗、計算資源消耗、存儲空間消耗，都需要考慮到成本里面。另外，EBS 它後面是一個大規模的存儲節點區域，是能夠應對大量磁盤故障的，也能夠解決這個數據完整性問題。如果真的要拿 EBS 跟本地盤去對比的話，我覺得至少得讓用戶去自建一套分佈式存儲系統，跟使用 EBS 做對比，還得把運維的人力成本也考慮進去。這些在自建、規模比較小的情況下，是很難算清楚的。</p><p>&nbsp;</p><p><strong>反方：馮若航 speaking ——</strong></p><p><strong>上雲的成本比自建要高得多。</strong>我自己 15 年的時候在淘寶的 CNZZ，友盟+這個部門算是第一波被推上阿里雲的內部 BU。在上雲之前，我們有一個自己的機房，幾百台服務器，一年所有成本算進去 1000 萬。後來上了阿里雲大數據全家桶數據庫 ODPS 這些東西，每年計算 3000 萬存儲 4000 萬。從 1000 萬變成 7000 萬這件事直接給了我對雲的第一印象，因為阿里雲是手把手出工程師加入我們團隊幫我們改造業務搬上雲的，從原來的每年 1000 萬搬到了後來的每年 7000 萬，而乾的事情，本質上卻還是一模一樣的，都是統計和計算規模，也沒有出現特別的變化。在上完雲之後，我們的效能並沒有出現變化，但是成本卻是實打實地翻了七倍。</p><p>這是我自己親身經歷的一個案例。如果説更有共性的一件事，我覺得可以參考一下 Amazon。AWS 在 2013 年提出的公有云價值，他舉了六個點：彈性、敏捷、全球化出海、將資本支出轉變為運營支出，以及更低的成本、消除重複建設。</p><p>但是，<strong>這些公有云價值主張在 2023 年很多已經不成立了，</strong>甚至説很多已經沒有價值了。我認為還有價值的點就是彈性、agility 和全球化出海，但是這裏面覆蓋的光譜其實並不多，特別是在高價值用戶羣體裏面並沒有覆蓋那麼多，更多是小微初創小規模業務會用到這些點。</p><p>比如這個 CAPEX 轉為 OPEX，將資本支出轉為運營支出。這一點，我認為除了對於那種連六個月都活不過的小業務有價值之外，凡是超過六個月，買肯定比租合算了。lower cost 是 AWS 當初相對於這些企業級解決方案來説的，它更便宜。比如説 Oracle 一盒 1 月你要付一萬塊錢，那麼 AWS 上的 RDS 每個月只要 1000 塊錢，是不是很便宜？但是那個時候，你可以説只有我這一家有云，所以我可以用這個價值定價，但現在誰家沒有一個 RDS ？開源的 RDS 管控都出來了。那麼這就變成了成本定價。既然是成本定價，我用雲數據庫加硬件，用這種開源的方案加上硬件 20 塊錢一盒，1 月不比這 1000 塊錢或者 400 塊錢的 RDS 要香嗎？lower cost 這個事兒已經完全變味兒了，現在不是 lower cost 是 higher cost。</p><p>至於消除重複建設這個事，我認為現在開源幹得已經比這好了，各家都有自己的 EC2 VPS，但是 K8s 很明顯一統了這些無狀態服務調度天下，所以我認為在 2023 年公有云的價值就剩下了全球化合規出海，它的適用光譜已經縮小到了小規模業務和高彈性業務和出海業務這三樣。以前我們業界大概有一個規模估算，你在雲上的年消費在 100 到 300 萬這個區間，你就應該考慮下雲了。我認為，隨着資源雲和開源平替的出現，100 萬-300 萬的閾值將會被進一步拉低至 10 萬-30 萬或者 1 萬-3 萬。我認為這件事很有可能會發生，而且正在發生。</p><p>&nbsp;</p><span id="OSC_h1_2"></span><h1>如今上雲還安全嗎？穩定性有多強？</h1><p><strong>反方：馬工 speaking ——</strong></p><p>對於安全，我有很多話説。作為一個軟件工程師最基本的是，你不能把密碼直接寫死、hard code 就編碼到你的代碼裏面，更不能把它提交到 Github 上，這屬於初級的實習生犯的錯誤對不對？</p><p>但是我看了一下，國內的騰訊雲阿里雲和華為雲什麼的，全都教用戶把那個 Access ID，編碼到代碼裏面。阿里雲和騰訊雲去年已經改正了，因為我寫文章揭露他們。但是至今為止，華為雲和火山引擎上面的範例裏面還是頁編碼，Access key，這是非常不負責任的一個做法。</p><p>我為什麼説他們是一個草台班子，因為這就相當於修了一座橋，然後把橋的地基給抽掉了，或者説做了一個保險庫，但是把鑰匙給插在那個鎖上了。就這樣還談安全？</p><p>我們可以看一下更近的例子，滴滴出了事故影響了上千萬的出行，它連具體的技術原因都沒提出來，只説我們會改進、我們是一個內部系統。但這個內部系統是什麼？你怎麼改進這個系統？基礎系統是外購的，還是自研的？什麼都沒説，但是北京那個地鐵追尾，人家就成立調查組了，調查組就會有調查結論，就會有限期改正通知書，你得覆盤，你得彙報，監管部門會過來檢查，然後發通知給其他的地鐵公司，讓別人吸取他的教訓。這才是一個真正的工程行業。</p><p>我贊同周新宇説的「雲廠商的故障比自建機房的故障更令人矚目」，但是，<strong>我的機房出故障，我可以得到最全面的信息，雲廠商出故障，我得不到所有的信息，甚至他不給我信息。</strong>比如阿里雲至今也沒有披露技術細節。甚至有一些廠商，他是隱瞞故障，他不會跟你通知，而是想着偷偷修復了你就不知道了。這是一個非常讓我們擔心的問題：沒有透明度。這樣你也無法從業務上規避它，只能求它別出事了。這是非常危險的。</p><p>&nbsp;</p><p><strong>正方：周新宇 speaking ——</strong></p><p>今天雲廠商確實做得不夠好，但這也是會改進的。雲廠商在安全和數據完成這塊都有很大的投入，我們以前做一個架構，要經過很多層的安全架構評審，並不是説啥都不做。當然，雲計算這個技術也好，雲計算這種商業模式也好，它肯定是有進步空間的，不能因為當前雲廠商某些地方還不夠成熟，就完全否定上雲的優勢或者是雲計算的優勢。</p><p>&nbsp;</p><p><strong>正方：蔣明 speaking ——</strong></p><p>尤其是大規模的數據庫用戶，還是上雲才能解決需求。像肯德基，阿里雲出事以後，他們就把業務遷到了抖音建的雲上，並沒有遷到自己的機房裏。</p><p>根據我的經驗，自建機房的話，如果只是一兩台機器託管一下的話，還是比較簡單的。但是當機器達到四五千台的時候，那你就會遇到 CPU 的故障、內存的故障和磁盤的故障，這時候，你就會很依賴監控系統。我有過大概 4000 多台物理機的這種機房託管經驗，當時用的是南京的管理系統，也是騰訊的開源軟件，實時監控用的是阿里的監控軟件 SLS，哪個磁盤出故障了，就發給線下的運維，讓他去換。如果全部都是自建的話，根本就做不到。</p><p>像我們現在的政務雲、水電煤背後的技術支持，全部都是在雲上的，政府的政務處理系統，銀行的交易系統也全部都在雲上，如果雲真的一無是處，那我們生活當中，支付寶就沒辦法掃了，錢也付不出去。</p><p>&nbsp;</p><p><strong>反方：馮若航 speaking ——</strong></p><p>我覺得你説的問題非常嚴峻，就是所謂的雲集中的問題。Gartner 最近發佈的 2023 年三季度新興風險報告裏面，<strong>雲集中風險已經連續第二年進入「五大新興風險」綜合榜單，在中國排第三位。</strong>雲集中説的就是雲廠商已成為了新的單點，爆炸半徑極大。阿里雲這一掛，有多少服務宕機了？如果政務雲金融雲這些都跑在阿里雲，那掛了怎麼辦？</p><p>去年阿里雲香港區域故障就導致香港政府很多單位的網站和電子政務不能用。</p><p>所以，<strong>這就是一個下雲的重要 argument ——為了安全性和自主可控。</strong>上雲其實就是放棄了自主可控，放棄了一部分的安全性。你沒有辦法對機密性、完整性去進行任何的驗證，甚至是追索。</p><p>我是搞信息安全的，安全裏面有三個點：CIA ——機密性，數據完整性和可用性。就是不丟，不壞，不宕。但是雲廠商它不給你兜機密性和完整性，它只給你兜可用性，而且是非常遜色的可用性。</p><p>比如説雲 RDS for PostgreSQL，這個雲數據庫的基礎版甚至都沒有望歸檔，也就是説它沒有數據庫 PITR 時間點恢復的能力，一個數據庫服務竟然沒有基礎的時間點恢復能力，我認為這對於一個數據庫用戶來説是完全不可接受的。至於機密性，那就更沒法保證了，你甚至沒有辦法去驗證發現任何數據丟失。但要是自建機房，就不會存在這樣的風險。</p><p>&nbsp;</p><span id="OSC_h1_3"></span><h1>中小企業該怎麼選？</h1><p><strong>正方：周新宇 speaking ——</strong></p><p>如果是一家初創企業，那肯定是毫無疑問要上雲，第一天就應該把你的 IT 設施構建在雲上，這樣未來的業務創新或試錯成本都非常低。這是，如果你的企業已經在重度用雲，今天因為成本的問題在考慮是否下雲，那我覺得是要慎重的，因為不管是上雲還是下雲，折騰一次代價是比較大的。所以説更好的方式是去分析雲上的賬單，這裏相對於自建有很大的優勢：在雲上你的一切價格賬單都是透明的，到底貴在哪裏，可以針對性地去降本。</p><p>&nbsp;</p><p><strong>正方：蔣明 speaking ——</strong></p><p>可以用阿里雲、騰訊雲、AWS 的基礎建設能力，比如 ECS 或 OSS，加上第三方的開源軟件，比如 TiDB、AutoMQ，這些軟件，它價格便宜，又能用雲廠商最便宜的基礎能力構建一個企業的自動化 DevOps 系統，讓你用最低的成本，在雲上創業。至於後面企業大了，像馬斯克的 X 公司，那自建雲是最佳的選擇，畢竟成本會更低。</p><p>&nbsp;</p><p><strong>反方：馮若航 speaking ——</strong></p><p>從務實的角度來講，小企業其實是適合雲的，但是你也不要把所有的東西都深度依賴雲。</p><p>第一，你有自建能力，這是你跟雲廠商談價格折扣的最大籌碼！</p><p>第二，優先使用資源雲。什麼是資源雲？像租用它的虛擬機，儘可能的避免使用它的專有服務、被供應商鎖定。</p><p>第三，如果你在雲上非要用這些服務，請避免使用 AKSKIAM 這些讓你陷入供應商鎖定的東西。這些不僅會讓你陷入雲單點故障中，更是會把你綁在一個你下不來的賬單下。</p><p>&nbsp;</p><p><strong>反方：馬工 speaking ——</strong></p><p>我覺得雲是一個操作系統，你用雲就相當於從 Windows 系統切換到 Linux，這需要非常大的努力，需要一個範式轉移。這個轉移路上，你必須要有人帶着你走。但我目前看雲自己也不知道怎麼走。這有一個大膽的估測：</p><p>90% 的雲廠商的員工，沒有自己的雲賬號；</p><p>90% 的雲廠商的員工，沒有考過雲的認證；</p><p>90% 的雲廠商的員工，從來沒有在雲上維護過或者部署過一個生產系統。</p><p>我覺得大家還是謹慎一點，除非雲廠商能夠證明雲計算的價值點，然後給出一個很明確的路徑，不然的話你就不要那麼急躁地為了雲而云。另外，騰訊會議或者釘釘那不是雲，跟微信一樣，只是一個很普通的 Saas 系統，這個跟你要負責任的企業 IT 系統是完全不一樣的。</p><p>&nbsp;</p><p>大家對此怎麼看呢？快留言説説你的經驗吧~</p><p>&nbsp;</p><p>直播回放如下，錯過的趕緊掃碼看看回放吧↓↓↓</p><p style="text-align:center"><img height="255" src="https://oscimg.oschina.net/oscnet/up-0da327351049eec05882b4fa1fb0a6df839.png" width="257" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 26 Dec 2023 02:32:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6852546/blog/10398475</guid>
            <link>https://my.oschina.net/u/6852546/blog/10398475</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[中國網絡安全審查認證和市場監管大數據中心正式掛牌]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>12 月 25 日，中國網絡安全審查認證和市場監管大數據中心（下稱網數中心）正式掛牌成立。</p><blockquote><p>根據中央編辦批覆，中國網絡安全審查技術與認證中心更名為中國網絡安全審查認證和市場監管大數據中心，整建制劃入市場監管總局信息中心，同時劃入競爭政策與大數據中心部分職能。主要職責是承擔網絡安全審查與認證相關標準研究和技術支撐、市場監管信息化建設、大數據分析應用、智慧監管建設等工作。</p></blockquote><p><img alt="" height="324" src="https://oscimg.oschina.net/oscnet/up-b50e4470001eac5b4504facfa10718e4195.jpg" width="500" referrerpolicy="no-referrer"></p><p>具體來説，網數中心的主要職責是：</p><p>依據《網絡安全法》《數據安全法》《個人信息保護法》《網絡安全審查辦法》及國家有關強制性產品認證法律法規，承擔網絡安全審查技術與方法研究、網絡安全審查技術支撐工作；在批准範圍內開展與網絡安全相關的產品、管理體系、服務、人員認證和培訓、檢驗檢測等工作；參與研究擬訂市場監管信息化發展規劃，協助指導全國市場監管系統信息化建設、管理和應用推廣工作；承擔市場監管業務應用系統和總局政務信息系統建設、運維及技術保障工作；承擔市場監管行業標準組織協調工作，承擔全國統一的市場監管信息化標準體系的建立完善工作；負責市場監管大數據中心建設、管理和運行維護工作，支撐智慧監管建設；受委託承擔市場監測技術支撐工作；開展網絡安全認證、市場監管信息化與大數據分析應用、智慧監管等領域的國際合作與交流。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 26 Dec 2023 02:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272732</guid>
            <link>https://www.oschina.net/news/272732</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微軟 Bing Chat 接入 GPT-4 Turbo 模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.windowslatest.com%2F2023%2F12%2F25%2Fmicrosoft-bing-chat-gets-chatgpt-4-turbo-for-free-code-interpreter-big-upgrade-ahead%2F" target="_blank">根據&nbsp;Windows Latest&nbsp;的報道</a></u>，微軟現已將 GPT-4 Turbo 模型接入 Bing Chat，並向部分用戶免費開放。</p><p>GPT-4 Turbo 模型是 OpenAI 在 11 月的開發者大會上公佈的最新模型，能力相比 GPT-4 更加強大。正常來説，該模型需要付費使用，<strong>但被選中的 Bing Chat 測試用戶可以免費體驗該模型的能力</strong>。微軟表示，測試用戶的選擇完全隨機，微軟稱之為稱之為「A / B」測試。</p><p>因此能否通過必應聊天使用 GPT-4 Turbo 完全憑運氣，但微軟已確認計劃在未來幾周內擴大推廣範圍。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1fe3a67b4f285f9fe3161322aa93bb4efc4.png" referrerpolicy="no-referrer"></p><p>微軟還計劃升級代碼解釋器功能，使其與 OpenAI 的功能保持一致。這意味着微軟 Copilot 中的代碼解釋器很快就能處理更復雜的編程或數據問題。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 26 Dec 2023 02:25:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272729/bing-chat-gets-chatgpt-4-turbo</guid>
            <link>https://www.oschina.net/news/272729/bing-chat-gets-chatgpt-4-turbo</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[開放籤開源電子簽章 1.0 版本上線一週的總結]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#4272ef"><strong><span>上線後的反饋</span></strong></span>&nbsp; &nbsp; &nbsp; &nbsp;</p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; &nbsp; 開放籤 1.0 版本於 12 月 15 日上線發佈後，給我們帶來了很多驚喜，也矯正了我們很多錯誤的觀點。</p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; &nbsp; 好的地方是我們開源工具版、企業版共有數百個用戶在使用。在開源社區獲取了 40 多個 start（感謝肯定），官網每天都有六七十的訪問量。這些小成績更加堅定了我們之前的判斷。</p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; &nbsp; 不太好的是我們沒有想明白企業版的收費邏輯，很多用戶諮詢企業版的收費方式，我們目前也沒啥標準，可能會給早期客戶帶來不好的感受。不瞞大家説，其實企業版的收費邏輯我們也沒有想好，因為我們產品出來前也沒有真實付費的用戶，所以收費這方面我們先跑跑再説。在沒有明確的收費邏輯前，我們先讓早期用戶免費用起來也是挺好的方式，最起碼能證明產品能力對用戶來説是有價值的，怎麼收費慢慢來吧。</p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; &nbsp; 兩個版本用戶反饋最多的問題主要有：</p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; &nbsp;<span>&nbsp;</span><strong>開源工具版：</strong>支持 SM2 算法、OFD 文件簽署、分辨率兼容等；</p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; &nbsp;<span>&nbsp;</span><strong>企業版：</strong>標準收費邏輯是什麼？（希望大家可以提供些建議）</p><h1><span style="color:#4272ef"><strong><span>下一步工作計劃</span></strong></span></h1><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; &nbsp;<span>&nbsp;</span><strong>開源工具版：</strong></p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; （1）支持 SM2 算法、OFD 文件簽署、分辨率兼容等；</p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; （2）前端頁面支持移動端的相關操作；</p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; &nbsp;<span>&nbsp;</span><strong>企業版：</strong></p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; （1）增加 CA 機構數字證書，支持具有法律效力的電子簽名；</p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; （2）增加業務線功能模塊，滿足各種簽署場景的靈活配置；</p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; （3）增加文件模板功能，滿足在線編輯文件模板；</p><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; （4）梳理企業版收費標準；</p><h1><strong><span style="color:#4272ef">總結</span></strong></h1><p style="color:#2c3e50; margin-left:0; margin-right:0; text-align:left">&nbsp; &nbsp; &nbsp; &nbsp; 開放籤 1.0 版本上線後確實給我們帶來了很多驚喜，也快速的驗證了我們很多的想法。接下來還需要以更快的速度迭代出更多好用的功能帶給用戶，儘快打通與用戶的真實互動，讓用戶早日應用在真實業務環境中。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 26 Dec 2023 02:13:15 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272720</guid>
            <link>https://www.oschina.net/news/272720</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[openKylin 榮譽+1！榮獲人民網【人民企業社會責任獎「年度案例獎」】]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>12 月 21 日，由人民日報社指導、人民網主辦的 2023 人民企業社會責任榮譽盛典暨第 18 屆人民企業社會責任獎頒獎活動在京順利舉辦，<strong>開放麒麟（openKylin）1.0 憑藉在開源創新領域的突出貢獻，榮獲人民企業社會責任獎年度案例獎。</strong></span></p><p style="margin-left:0; margin-right:0; text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-fba19d23cce6b40aadd0f4220d261f5d981.jpg" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:justify"><span>「人民企業社會責任獎」評選活動創設於 2006 年，是中央重點新聞網站在企業社會責任領域最早發起的活動之一。本次活動以「權威性、大眾化、公信力」為宗旨，以「勇毅實幹&nbsp;共向未來」為主題，設置了「年度企業獎」「年度案例獎」「鄉村振興獎」「綠色發展獎」「築夢未來獎」和「特別貢獻獎」六大獎項。分別從企業履責、公益行動、鄉村振興、綠色發展、兒童事業、共建「一帶一路」等維度徵集企業履行社會責任的實踐案例。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span>其中，「年度案例獎」重點關注 2023 年度企業、機構策劃並開展實施的具有深刻影響力的社會責任行動案例。與<span>開放麒麟（openKylin）1.0 一同入圍的<span><span>獲獎案例</span></span>還有：天貓黃扶手計劃「觀·愛」行動、安踏茁壯成長公益計劃、<span><span>亞馬遜雲科技「AI 在未來」公益計劃</span></span>等。</span></span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>今年 7 月 5 日，開放麒麟（openKylin）1.0 正式發佈，標誌着我國擁有了操作系統組件自主選型、操作系統獨立構建的能力，填補了我國在這一領域的空白。作為國內開源操作系統根社區，開放麒麟（openKylin）社區自成立起便積極推動開源生態建設。截至目前，openKylin 已累計發佈 6 個社區版本，下載量達 100 萬+；匯聚 400+社區會員、5500+開發者加入社區，並累計成立 94 個 SIG 組開展技術研究與創新。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>未來，開放麒麟（openKylin）社區也將保持初心，為構建良好開源生態發展持續努力，並攜手各界夥伴共築開源生態，用持續的技術創新和更加活躍的社區運營推動我國開源產業快速發展。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 26 Dec 2023 02:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272719</guid>
            <link>https://www.oschina.net/news/272719</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[LobeChat —— 聊天機器人框架]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>LobeChat 是一個開源、高性能的聊天機器人框架，支持語音合成、多模態和可擴展的功能調用插件系統。支持一鍵式免費部署私人 ChatGPT/LLM 網絡應用程序。</p><p><img height="190" src="https://static.oschina.net/uploads/space/2023/1218/154744_PdXB_4252687.png" width="500" referrerpolicy="no-referrer"></p><p>特性一覽：</p><h4 style="text-align:start">GPT 視覺認知</h4><p><img height="192" src="https://static.oschina.net/uploads/space/2023/1218/154508_TIgb_4252687.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#1f2328; text-align:start">LobeChat 已經支持 OpenAI 最新的<span>&nbsp;</span><a href="https://platform.openai.com/docs/guides/vision"><code>gpt-4-vision</code></a><span>&nbsp;</span>支持視覺識別的模型，這是一個具備視覺識別能力的多模態智能。 用戶可以輕鬆上傳圖片或者拖拽圖片到對話框中，助手將能夠識別圖片內容，並在此基礎上進行智能對話，構建更智能、更多元化的聊天場景。</p><p style="color:#1f2328; text-align:start">這一特性打開了新的互動方式，使得交流不再侷限於文字，而是可以涵蓋豐富的視覺元素。無論是日常使用中的圖片分享，還是在特定行業內的圖像解讀，助手都能提供出色的對話體驗。</p><h4 style="text-align:start">TTS &amp; STT 語音會話</h4><p><img height="194" src="https://static.oschina.net/uploads/space/2023/1218/154539_jFKr_4252687.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#1f2328; text-align:start">LobeChat 支持文字轉語音（Text-to-Speech，TTS）和語音轉文字（Speech-to-Text，STT）技術，能夠將文本信息轉化為清晰的語音輸出，用戶可以像與真人交談一樣與我們的對話代理進行交流。 用戶可以從多種聲音中選擇，給助手搭配合適的音源。 同時，對於那些傾向於聽覺學習或者想要在忙碌中獲取信息的用戶來説，TTS 提供了一個極佳的解決方案。</p><p style="color:#1f2328; text-align:start">在 LobeChat 中，項目團隊精心挑選了一系列高品質的聲音選項 (OpenAI Audio, Microsoft Edge Speech)，以滿足不同地域和文化背景用戶的需求。用戶可以根據個人喜好或者特定場景來選擇合適的語音，從而獲得個性化的交流體驗。</p><h4 style="text-align:start">Function Calling 插件系統</h4><p style="color:#1f2328; text-align:start">LobeChat 的插件生態系統是其核心功能的重要擴展，它極大地增強了 ChatGPT 的實用性和靈活性。通過利用插件，ChatGPT 能夠實現實時信息的獲取和處理，例如自動獲取最新新聞頭條，為用戶提供即時且相關的資訊。 此外，這些插件不僅侷限於新聞聚合，還可以擴展到其他實用的功能，如快速檢索文檔、獲取電商平台數據、以及其他各式各樣的第三方服務。</p></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 26 Dec 2023 02:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/lobechat</guid>
            <link>https://www.oschina.net/p/lobechat</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 跨平台的截圖/錄屏/錄音/錄像軟件 pear-rec]]>
            </title>
            <description>
                <![CDATA[<p align="center"><img src="https://027xiguapi.github.io/pear-rec/logo.png" height="120" referrerpolicy="no-referrer"></p><h1><a id="user-content-pear-rec" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#pear-rec"></a>pear-rec</h1><p><img src="https://img.shields.io/github/stars/027xiguapi/pear-rec" alt="stars" referrerpolicy="no-referrer"><img src="https://img.shields.io/badge/react-v18-blue" alt="react" referrerpolicy="no-referrer"><img src="https://img.shields.io/badge/electron-v26-blue" alt="react" referrerpolicy="no-referrer"><img src="https://img.shields.io/badge/express-v4-blue" alt="react" referrerpolicy="no-referrer"><img src="https://img.shields.io/badge/-TypeScript-blue?logo=typescript&amp;logoColor=white" alt="typescript" referrerpolicy="no-referrer"><img src="https://img.shields.io/badge/-Vite-646cff?logo=vite&amp;logoColor=white" alt="vite" referrerpolicy="no-referrer"></p><hr><h2><a id="user-content-readme" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#readme"></a>README</h2><p><a href="https://gitee.com/xiguapi027/pear-rec/blob/main/README.zh-CN.md">中文</a> | <a href="https://gitee.com/xiguapi027/pear-rec/blob/main/README.md">English</a> | <a href="https://gitee.com/xiguapi027/pear-rec/blob/main/README.de-DE.md">Deutsch</a></p><h2><a id="user-content-架構" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E6%9E%B6%E6%9E%84"></a>架構</h2><img src="https://027xiguapi.github.io/pear-rec/imgs/1700442414996.jpg" referrerpolicy="no-referrer"><h2><a id="user-content-簡介" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E7%AE%80%E4%BB%8B"></a>簡介</h2><blockquote><p>pear-rec(梨子 rec) 是一個跨平台的截圖、錄屏、錄音、錄像、錄製 (動圖)gif、查看圖片、查看視頻、查看音頻和修改圖片的軟件。</p><p>pear-rec(pear rec) 是基於 react + electron + vite + viewerjs + plyr + aplayer + react-screenshots + tui-image-editor + gif.js 的一個項目。</p><p>更多功能和 api 可以查看<a href="https://gitee.com/link?target=https%3A%2F%2F027xiguapi.github.io%2Fpear-rec">官網 (https://027xiguapi.github.io/pear-rec)</a> 或 <a href="https://xiguapi027.gitee.io/pear-rec" rel="nofollow">https://xiguapi027.gitee.io/pear-rec</a></p></blockquote><h2><a id="user-content-例子" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E4%BE%8B%E5%AD%90"></a>例子</h2><p><a href="https://gitee.com/link?target=https%3A%2F%2Fpear-rec-xiguapi.vercel.app%2F">網頁</a></p><h2><a id="user-content-下載地址" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80"></a>下載地址</h2><blockquote><p>gitee: <a href="https://gitee.com/xiguapi027/pear-rec">https://gitee.com/xiguapi027/pear-rec</a></p><p>github: <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2F027xiguapi%2Fpear-rec">https://github.com/027xiguapi/pear-rec</a></p></blockquote><h2><a id="user-content-源碼運行編譯" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E6%BA%90%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BC%96%E8%AF%91"></a>源碼運行&amp;編譯</h2><p>編譯需要<code>nodejs</code>和<code>pnpm</code>環境</p><h3><a id="user-content-測試環境" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"></a>測試環境</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">nodejs: 18</span><span id="LC2" class="line">pnpm: 8</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-開始" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E5%BC%80%E5%A7%8B"></a>開始</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c"># 拷貝代碼</span></span><span id="LC2" class="line">git clone https://gitee.com/xiguapi027/pear-rec.git</span><span id="LC3" class="line"><span class="c"># 進入項目</span></span><span id="LC4" class="line"><span class="nb">cd </span>pear-rec</span><span id="LC5" class="line"><span class="c"># 安裝依賴</span></span><span id="LC6" class="line">pnpm <span class="nb">install</span></span><span id="LC7" class="line"><span class="c"># 調試頁面</span></span><span id="LC8" class="line">pnpm run dev:web</span><span id="LC9" class="line"><span class="c"># 調試服務</span></span><span id="LC10" class="line">pnpm run dev:server</span><span id="LC11" class="line"><span class="c"># 調試軟件</span></span><span id="LC12" class="line">pnpm run dev:desktop</span><span id="LC13" class="line"><span class="c"># 運行頁面</span></span><span id="LC14" class="line">pnpm run start:web</span><span id="LC15" class="line"><span class="c"># 運行軟件</span></span><span id="LC16" class="line">pnpm run start:desktop</span><span id="LC17" class="line"><span class="c"># 編譯軟件</span></span><span id="LC18" class="line">pnpm run build:desktop</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-功能" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E5%8A%9F%E8%83%BD"></a>功能</h2><p>已經勾選的功能是開發過程最新功能，但可能還沒發佈在最新版本</p><ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 截屏 (react-screenshots)
<ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 框選裁切</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 框選大小位置可調整</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 取色器</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 放大鏡</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 畫筆（自由畫筆）</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 幾何形狀（邊框填充支持調節）</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 高級畫板設置</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 圖像濾鏡（支持局部馬賽克模糊和色彩調節）</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 自定義框選鬆開後的操作</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 以圖搜圖</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 掃描二維碼</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 快速截取全屏到剪貼板或自定義的目錄</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 截屏歷史記錄</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 窗口和控件選擇（使用 OpenCV 邊緣識別）</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 長截屏</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 多屏幕</li></ul></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 錄屏 (WebRTC)
<ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 錄製全屏</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 截圖</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 自定義大小</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 靜音</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 按鍵提示</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 光標位置提示</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 錄製欄</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 流寫入</li></ul></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 錄音 (WebRTC)
<ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 錄音設置</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 查看錄音</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 下載錄音</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 編輯錄音</li></ul></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 錄像
<ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 自定義比特率</li></ul></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 圖片預覽 (viewerjs)
<ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 放大</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 縮小</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 拖拽</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 翻轉</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 釘上層</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 查看</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 下載</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 打印</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> ocr</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 查看列表</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 以圖搜圖</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 掃描二維碼</li></ul></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 圖片編輯 (tui-image-editor)</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 視頻預覽 (plyr)</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 音頻預覽 (aplayer)</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 動圖 (gif) 編輯 (gif.js)</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 基本設置
<ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 用戶 uuid</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 保存地址</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 開機自啓動</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 國際化 (中、英、德)</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 服務設置</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 快捷鍵設置</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 重置設置</li></ul></li></ul><h2><a id="user-content-國際化 i18n" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E5%9B%BD%E9%99%85%E5%8C%96i18n"></a>國際化 (I18n)</h2><ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 簡體中文</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 英語</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 德語</li></ul><h2><a id="user-content-download" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#download"></a>Download</h2><table><thead><tr><th>系統</th><th>Windows</th><th>Linux</th><th>Macos</th></tr></thead><tbody><tr><td>鏈接</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2F027xiguapi%2Fpear-rec%2Freleases">下載</a></td><td>◯</td><td>◯</td></tr></tbody></table><p>國內可以用 <a href="https://gitee.com/link?target=https%3A%2F%2Fghproxy.com%2F">GitHub Proxy</a> 加速下載</p><h2><a id="user-content-反饋和交流" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E5%8F%8D%E9%A6%88%E5%92%8C%E4%BA%A4%E6%B5%81"></a>反饋和交流</h2><p>我們推薦使用 <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2F027xiguapi%2Fpear-rec%2Fissues">issue</a> 列表進行最直接有效的反饋，也可以下面的方式</p><ul><li>qq 羣</li></ul><p align="center"><img src="https://027xiguapi.github.io/pear-rec/imgs/pear-rec_qq_qrcode.png" referrerpolicy="no-referrer"></p><h2><a id="user-content-開源協議" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE"></a>開源協議</h2><p><a href="https://gitee.com/xiguapi027/pear-rec/blob/main/LICENSE">pear-rec(梨子 rec) 可在 Apache License V2 下使用。</a></p><p><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FMDN%2FCommunity%2FOpen_source_etiquette">開源項目禮節</a></p>]]>
            </description>
            <pubDate>Tue, 26 Dec 2023 01:56:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/xiguapi027/pear-rec</guid>
            <link>https://gitee.com/xiguapi027/pear-rec</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 揭開事件循環的神祕面紗]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img src="https://oscimg.oschina.net/oscnet/up-f9d098f5cee0090732c3958edc97164b6c7.png" alt="" referrerpolicy="no-referrer"></p><p>作者 |&nbsp;小萱</p><blockquote><p>導讀&nbsp;</p><p>這篇文章會全方位講解事件循環機制，從這篇文章你可以學到，「事件循環」和「瀏覽器渲染」的關係，瀏覽器 setTimeout、requestAnimationFrame（RAF）、requestIdleCallback（RIC）等 API 在事件循環的「執行時機」，導致瀏覽器卡頓的原因、交互指標是如何測量的以及如何提升網站的交互性能。</p></blockquote><blockquote><p><em>全文 10503 字，預計閲讀時間 27 分鐘。</em></p></blockquote><h1><strong>01 前言</strong></h1><p>我們常常會提到頁面性能，為什麼要優化長任務，又為什麼 React 要做時間切片呢。這篇文章把瀏覽器的渲染、事件循環與頁面性能串聯起來。</p><p>從這篇文章你可以學到，「事件循環」和「瀏覽器渲染」的關係，瀏覽器 setTimeout、</p><p>requestAnimationFrame（RAF）、requestIdleCallback（RIC）等 API 在事件循環的「執行時機」，導致瀏覽器卡頓的原因、交互指標是如何測量的以及如何提升網站的交互性能。</p><p>學完這些，你可以對為什麼動畫要用 RAF、又何時去用 RIC、該不該選擇 setTimeout、如何規避長任務之類的問題應對自如。</p><h1><strong>02 事件循環概述</strong></h1><h2><strong>2.1 為什麼要了解事件循環？</strong></h2><p>深入瞭解事件循環是性能優化的基礎。在討論事件循環之前，我們需要先了解瀏覽器的多進程和多線程架構。</p><h2><strong>2.2 瀏覽器的架構</strong></h2><p>回顧瀏覽器的架構，現代瀏覽器都是多進程和多線程的。</p><h3><strong>2.2.1 多進程</strong></h3><p>Chrome 瀏覽器使用多進程架構，意味着每個標籤頁（在某些瀏覽器中也包括每個擴展程序）通常在其自己的進程中運行。這樣做的好處是，一個標籤頁崩潰不會影響到其他標籤頁。</p><p>站點隔離特性，瀏覽器每個 tab，都是獨立的渲染進程，這點的好處是假設你打開三個標籤頁，一個標籤卡死不影響其他兩個。但如果三個標籤共用一個進程，一個卡死會導致全部都卡，這樣體驗很差。</p><p><img src="https://oscimg.oschina.net/oscnet/up-ea0fa24c2b466fa5d6ee4b2d3f43537fb03.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong><strong>△瀏覽器的多進程示意圖</strong></strong></p><h3><strong>2.2.2 多線程</strong></h3><p>每個瀏覽器進程都可以包含多個線程。例如，主線程用於執行 JavaScript 代碼和處理頁面佈局，而其他線程可能用於網絡請求、渲染等任務。</p><p><strong>主線程</strong></p><p>Web 應用程序需要在此單個主線程上執行某些關鍵操作。當您導航到 Web 應用程序時，瀏覽器將創建並向您的應用程序授予該線程，以便您的代碼在其上執行。</p><p>主線程指的是渲染進程下的主線程，負責解析 HTML、計算 CSS 樣式、執行 JavaScript、計算佈局、繪製圖層等任務。</p><p><img src="https://oscimg.oschina.net/oscnet/up-835102f787ff8cc334c66e30face4316758.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong><strong>△主進程即渲染進程包含的線程圖</strong></strong></p><p>某些任務<strong>必須</strong> 在主線程上運行。例如，任何直接需要訪問 DOM（即 DOM ﻿document﻿）的操作都必須在主線程上運行（因為 DOM 不是線程安全的）。這將包括大多數 UI 相關代碼。</p><p>主線程上一次只能運行 <strong>一個任務</strong>。</p><p>此外，一個任務<strong>必須在主線程上運行完成</strong>，然後才能運行另一個任務。瀏覽器沒有「部分」執行任務的機制，每個任務都完整地運行直至完成。</p><p>在下面的示例中，在瀏覽器展示界面的時候，按順序運行下面的任務，並且每個任務都在主線程上完成：</p><p><img src="https://oscimg.oschina.net/oscnet/up-b89c629a6370f9eaf9aeae593adc5bc8d21.png" alt="圖片" referrerpolicy="no-referrer"></p><h1><strong>03 事件循環的具體流程</strong></h1><p>我們這裏主要討論的是&nbsp;window event loop。也就是瀏覽器一個渲染進程內主線程所控制的&nbsp;Event Loop。</p><p><img src="https://oscimg.oschina.net/oscnet/up-7597949bda55e109f8b7f0eef42bde61edd.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong><strong>△發生一次事件循環的具體流程</strong></strong></p><p>發生一次事件循環，也就是瀏覽器一幀中可以用於執行﻿JS﻿的流程如下：</p><p>從 task queue 取出一個 task(宏任務) 執行並刪除 &nbsp;-&gt; 執行並清空隊列中全部 job(微任務) -&gt; requestAnimationFrame -- 瀏覽器更新渲染 -- requestIdleCallback</p><p><strong>3.1 更新渲染的步驟</strong></p><p>前兩個步驟，耳熟能詳，這裏不再討論，重點討論「更新渲染」之後的步驟。</p><p>1. Rendering opportunities: 標誌是否一次事件循環後會發生渲染。在每次事件循環的結束，不一定會發生渲染。導致不渲染的可能：無法維持當前刷新率、瀏覽器上下文不可見、瀏覽器判斷更新不會造成視覺改變並且 raf 的回調為空。</p><p>如果這些條件都不滿足，當前文檔不為空，設置 hasARenderingOpportunity 為 true。</p><p>2.如果窗口變化，執行 resize。</p><p>3.如果滾動，執行 scroll。</p><p>4.媒體查詢。</p><p>5.canvas 。</p><p>6.執行 RAF 回掉，傳遞迴掉參數 DOMHighResTimeStamp，開始執行回調的時間。</p><p>7.重新執行 Layout 等計算，渲染繪製界面。</p><p>8.如果滿足，任務隊列和微任務隊列都為空，並且渲染時機 hasARenderingOpportunity 為 false，執行算法是否執行 requestIdleCallback 的回調函數。</p><p><strong>3.2</strong><strong>執行順序與渲染</strong></p><p>來一道簡單的題目，將創建宏任務、微任務、RIC、RAF 的代碼同時定義，輸出執行順序。</p><pre><code>console.log('開始執行');
console.log('start');
setTimeout(() =&gt; {
  console.log('setTimeout');
}, 0);

requestAnimationFrame(() =&gt; {
  console.log('requestAnimationFrame');
});
new Promise((resolve, reject) =&gt; {
  console.log('Promise');
  resolve('promise resolved');
})

requestIdleCallback(() =&gt; {
  console.log('requestIdleCallback');
});

(async function asyncFunction() {
  console.log(await 'asyncFunction');
})();

console.log('執行結束');
// 開始執行
// Promise
// 執行結束
// promise resolved
// asyncFunction
// setTimeout
// requestAnimationFrame
// requestIdleCallback
</code></pre><p>你可能會疑問為什麼 RAF 會在 setTimeout(fn, 0) 之前執行，setTimeout(fn, 0) 的執行時機是延遲 0-4ms，RAF 可以粗暴理解為 settimeout(fn, Math.random() * 16.6)，因此 setTimeout 會優先。但如果在 setTimeout 執行之前主線程被其他的任務跑滿了，超過了一幀的耗時，setTimeout 會在 RAF 的回調之後執行（用例見下面的代碼段），因此 setTimeout 的延遲時間並不穩定，RAF 的執行時機穩定，在一幀內註冊的，都會在這一幀的結束，下一幀的開始之前執行。</p><pre><code>  let task = new Array(10000).fill(null).map((_, i) =&gt; () =&gt; {
    const span = document.createElement("span");
    span.innerText = i;
    console.log("==&gt;task", i);
  });
  task.forEach((i) =&gt; i());
  requestAnimationFrame(() =&gt; {
    console.log("===&gt;requestAnimationFrame");
  });
  setTimeout(() =&gt; {
    console.log("===&gt;setTimeout");
  }, 0);
  //輸出：
  // ===&gt;requestAnimationFrame
  // ===&gt;setTimeout
</code></pre><p>注意，Promise.then 的回調可以保證第一輪的準確性，如果繼續.then 發生的行為和瀏覽器版本有關，開發時不要過分依賴多.then 的回調順序，這是不可靠的。</p><p>上面提到渲染是在一次事件循環的「最後」發生，那麼對於多次「修改 dom」的操作，是會被合併取最後一次的結果作為佈局渲染。</p><pre><code>    const btn = document.querySelector(".btn");
    btn.addEventListener("click", () =&gt; {
      box.style.transform = "translateX(400px)";
      box.style.transition = "transform 1s ease-in-out";
      box.style.transform = "translateX(200px)";
    });
</code></pre><p>外層父容器 400px，這段代碼，表現是盒子從 0 到 200px，盒子設置 400px 的動作，被合併掉了。那如何實現盒子從 400px 呢，可以採取延遲到下一幀渲染。</p><p><img src="https://oscimg.oschina.net/oscnet/up-12acd27c0e4668c804c101feaff4900b941.gif" alt="圖片" referrerpolicy="no-referrer"></p><p><strong><strong>△演示效果</strong></strong></p><pre><code>    btn.addEventListener("click", () =&gt; {
      box.style.transform = "translateX(400px)";
      requestAnimationFrame(() =&gt; {
        requestAnimationFrame(() =&gt; {
          box.style.transition = "transform 1s ease-in-out";
          box.style.transform = "translateX(200px)";
        });
      });
    });
</code></pre><p>「嵌套的 RAF」可以保證回調在下一幀執行。當然，此處用 setTimeout 也可以達到同樣的延遲效果。</p><p><img src="https://oscimg.oschina.net/oscnet/up-aba5e3515d83ac5a4002123ffa2fe772441.gif" alt="圖片" referrerpolicy="no-referrer"></p><p><strong><strong>△延遲後的演示效果</strong></strong></p><h1><strong>04 任務隊列與執行時機</strong></h1><p><strong>執行 JavaScript task 是在渲染之前，如果在一幀之內 JavaScript 執行時間過長就會阻塞渲染，同樣會導致丟幀、卡頓</strong>，這裏的 js 執行時間過長，就是長任務，下面會仔細介紹。</p><p>對長任務的定義：如果任務耗時<strong>超過 50ms</strong>，則認為該任務是長任務。</p><p>當我們談到長任務造成頁面卡頓時，通常指的是主線程（Main Thread）上的任務。主線程指的是渲染進程下的主線程，負責解析 HTML、計算 CSS 樣式、執行 JavaScript、計算佈局、繪製圖層等任務。當主線程上的一個任務（例如一個 JavaScript 函數）運行時間過長時，它會阻塞主線程上的其他任務，包括但不限於 UI 更新和用戶交互事件的處理，從而導致頁面卡頓或不響應。</p><p><strong>JS 的執行和渲染的關係：</strong></p><p>JS 執行與 Paint 任務都發生在主線程，具體的繪製操作是交由合成線程完成，與主線程並不互斥，但是 JS 的執行時間過長，會導致 Paint 整理好的數據沒有及時提交給合成線程，因此頁面有幀沒有執行繪製，也就是掉幀。</p><p><img src="https://oscimg.oschina.net/oscnet/up-a9ff20ab17a1d01227807dc759a9caafc2e.png" alt="圖片" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-45b704b84e7ef58a85990b189f3cefe42ce.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong><strong>△JS 的執行和渲染的關係圖</strong></strong></p><h2><strong>4.1 為什麼不使用 setTimeout 做動畫</strong></h2><p><strong>raf 和 setTimeout 對比:</strong></p><p><em>（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjsfiddle.net%2Fhixuanxuan%2Fmrw6upgs%2F3%2F__%EF%BC%89" target="_blank">https://jsfiddle.net/hixuanxuan/mrw6upgs/3/__）</a></em></p><p><strong>1.不同步與顯示刷新率：</strong></p><p>瀏覽器通常以每秒 60 幀的速度刷新，大約每 16.67 毫秒刷新一次。如果你使用 setTimeout 來創建動畫，並嘗試每 16.67 毫秒運行一幀，你的代碼不會完全與瀏覽器的刷新速率同步，導致丟幀</p><p><strong>2.延遲執行：</strong></p><p>setTimeout 的延遲時間參數只是一個最小延遲時間，而不是保證執行的精確時間。如果主線程忙於其他任務，setTimeout 的回調可能會被延遲，導致丟幀</p><p><strong>3.計時器合併：</strong></p><p>瀏覽器渲染有渲染時機（Rendering opportunity），也就是瀏覽器會根據當前的瀏覽上下文判斷是否進行渲染，因為考慮到硬件的刷新頻率限制、頁面性能以及頁面是否存在後台等等因素，宏任務之間不一定會伴隨着瀏覽器繪製。如果兩個 Task 距離的很近，他們可能會被合併在一次渲染任務，得到的結果是意料之外的，如果 Task 距離較大，那他跟不上瀏覽器的刷新頻率，會導致丟幀。</p><p>RAF 的執行時機是在下一次渲染前調用，也就是説使用這個 API 允許你在下一次渲染開始之前更改 DOM，然後在本次渲染中立即體現，因此他是製作動畫的絕佳選擇。</p><p><strong>4.2 requestIdleCallback 的執行時機</strong></p><p>主要在瀏覽器的主線程空閒時執行，為了保證響應性，會計算一個截止時間，computeDeadline，它將決定何時執行&nbsp;requestIdleCallback&nbsp;中註冊的回調。下面是計算截止時間算法的簡要概述：</p><p><strong>1.設置初始截止時間：</strong></p><p>初始化時，將事件循環的最後閒置週期開始時間設置為當前時間。</p><p>設置一個基本的截止時間，該時間是事件循環的最後閒置週期開始時間加上 50 毫秒（為了保證對新用戶輸入的響應性）。為什麼要加這個 50ms，是因為瀏覽器為了提前應對一些可能會突發的用戶交互操作，比如用戶輸入文字。如果給的時間太長了，你的任務把主線程卡住了，那麼用戶的交互就得不到迴應了。50ms 可以確保用戶在無感知的延遲下得到迴應。</p><p><strong>2.檢查是否有待處理的渲染：</strong></p><p>初始化一個變量 hasPendingRenders 為 false。</p><p>遍歷相同事件循環的所有窗口，檢查每個窗口是否有未執行的 RAF 回調或可能的渲染更新。如果有，將 hasPendingRenders 設置為 true。</p><p><strong>3.基於 timeout 調整截止時間：</strong></p><p>如果 RIC 傳入第二個參數 timeout，更新截止時間為 timeout。這會強制瀏覽器不管多忙，都在超過這個時間之後去執行 rIC 的回調函數。</p><p><strong>4.考慮渲染的時間：</strong></p><p>如果 hasPendingRenders 為 true，計算下一個渲染的截止時間，基於事件循環的最後渲染機會時間和當前的刷新率。</p><p>如果下一個渲染的截止時間早於當前設置的截止時間，那麼更新截止時間為下一個渲染的截止時間。</p><p><strong>5.返回最終的截止時間：</strong></p><p>返回計算出的截止時間，這個時間將用於確定何時執行 requestIdleCallback 中註冊的回調。</p><p><strong>6.開始空閒期：</strong></p><p>對於相同事件循環的每個窗口，執行「開始空閒期」算法，使用 computeDeadline 作為參數，確定何時執行 requestIdleCallback 中註冊的回調。</p><p>也就是説，這個&nbsp;timeRemaining()&nbsp;的計算非常動態，會根據上面這些因素去決定。</p><h2><strong>4.3 React 如何實現 Time slice，沒有使用 RIC、setTimeout 的原因是什麼</strong></h2><p>沒使用 RIC 的原因是他在部分瀏覽器表現不佳，比如 safari。</p><p>需要滿足的條件：</p><p>1.暫停 JS 執行，將主線程去執行 style、layout、paint 等任務，讓瀏覽器有機會更新頁面。</p><p>2.在未來某個時刻可以繼續調度任務，執行上次還沒有完成的任務。</p><p>對於 react 的 Time Slice，他的目的是中斷當前 js 的執行，讓他去執行渲染相關任務，因此需要的 API 是在瀏覽器的 Paint 之後執行，瀏覽器並未提供除了 RIC 這樣的 API。RAF 的執行時機是在一幀的結束，此時創建宏任務開啓下一輪 Task，渲染的任務放在 RAF 裏在這一幀執行。如果使用 setTimeout(fn, 0) 創建宏任務，如果 timeout 嵌套的層級超過了 5 層，最低會有 4ms 的延遲，具體定義的代碼可以參考<strong>chrome 對計時器的定義</strong><em>（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fchromium.googlesource.com%2Fchromium%2Fblink%2F%2B%2Fmaster%2FSource%2Fcore%2Fframe%2FDOMTimer.cpp%EF%BC%89" target="_blank">https://chromium.googlesource.com/chromium/blink/+/master/Source/core/frame/DOMTimer.cpp）</a></em>，因此首選的是 message channel，優先級高於 setTimeout 可以在上一幀渲染結束後立即執行，這樣就實現了<strong>可以中斷的 JS 執行的效果</strong>。</p><h2><strong>4.4 模擬實現 requestIdecallback</strong></h2><p>要模擬實現 requestIdecallback 的效果，定義的任務隊列在瀏覽器完成渲染任務之後執行，擴展來説也可以用來測量瀏覽器渲染任務的執行時間。</p><p><strong>Background Tasks API - Web API 接口參考 | MDN</strong>（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FBackground_Tasks_API%EF%BC%89" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API）</a></p><pre><code>  // 當到時間了，立即執行的函數
  const performWorkUntilDeadline = () =&gt; {
    if (scheduledHostCallback !== null) {
      const currentTime = getCurrentTime();
      // 分配任務的剩餘時間，這個可執行時間是根據 fps 動態算的
      deadline = currentTime + yieldInterval;
      const hasTimeRemaining = true;
      // 調用已計劃的回調，並傳遞剩餘時間和當前時間。
      const hasMoreWork = scheduledHostCallback(
          hasTimeRemaining,
          currentTime,
        );
        if (!hasMoreWork) {
          isMessageLoopRunning = false;
          scheduledHostCallback = null;
        } else {
          // If there's more work, schedule the next message event at the end
          // of the preceding one.
          port.postMessage(null);
        }
    } else {
      isMessageLoopRunning = false;
    }
    // 給瀏覽器一個繪製的機會，並重置需要繪製的標誌。
    needsPaint = false;
  };
  
 
  const channel = new MessageChannel();
  const port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;

  requestHostCallback = function(callback) {
    scheduledHostCallback = callback;
    if (!isMessageLoopRunning) {
      isMessageLoopRunning = true;
      port.postMessage(null);
    }
  };
</code></pre><h1><strong>05 交互性能指標與優化方法</strong></h1><p>長任務對頁面的影響，帶來「卡頓」、「掉幀」等不好的體驗，常用衡量交互性能的指標有 TTI 和 FID，這些均可使用 web-vital 庫進行測量。下面展開對指標的詳細介紹。</p><h2><strong>5.1 交互性能的衡量指標</strong></h2><p>衡量交互性能的指標主要關注以下幾個方面：</p><h3><strong>5.1.1&nbsp;TTI （理想可交互時間）</strong></h3><p><strong>1.定義可交互：</strong></p><p>首先，需要明確什麼是「可交互」。一個頁面被認為是可交互的，意味着頁面的主要內容已經加載完畢，用戶可以進行點擊、輸入等交互操作，而且頁面能夠快速響應。</p><p><strong>2.監測首次內容繪製 (FCP) 和 DOMContentLoaded：</strong></p><p>測量 TTI 的過程通常開始於監測首次內容繪製 (FCP) 和 DOMContentLoaded 事件。這兩個事件分別表示瀏覽器開始繪製頁面內容和 DOM 結構加載完畢的時刻。</p><p><strong>3.長任務監測：</strong></p><p>長任務是指那些執行時間超過 50 毫秒的任務。長任務通常會阻塞主線程，延遲頁面的交互可用性。通過監測長任務，可以瞭解主線程何時變得空閒。</p><p><strong>4.尋找交互窗口：</strong></p><p>為了確定 TTI，需要找到一個至少 5 秒鐘主線程空閒的窗口，且該窗口應在首次內容繪製 (FCP) 之後。在這個 5 秒空閒窗口期間，沒有長任務執行，意味着用戶可以與頁面交互。一旦找到這個空閒窗口，記錄 TTI。如果未找到長任務，則 TTI 與 FCP 相同。</p><p><img src="https://oscimg.oschina.net/oscnet/up-f839eeb20c4ce164ffb346f0ee1b8f69072.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong><strong>△TTI 測量示意圖（源於 web.dev）</strong></strong></p><h3><strong>5.1.2&nbsp;FID（首次輸入延遲）</strong></h3><p>FID，即 First Input Delay，用於量化用戶在頁面加載時首次交互的響應延遲。一個低的 FID 表示頁面是快速響應用戶交互的，而一個高的 FID 表示頁面在響應用戶交互時有延遲。</p><p><strong>1.事件監聽:</strong></p><p>為了計算 FID，瀏覽器需要監聽用戶的交互事件，如點擊、鍵盤輸入或者觸摸事件。當用戶與頁面交互時，會觸發這些事件。</p><p><strong>2.事件處理時間:</strong></p><p>當事件被觸發時，瀏覽器會計算從事件觸發到瀏覽器開始處理事件的時間。這個時間就是 FID。它包括了瀏覽器將事件放入事件隊列、事件隊列的等待時間、以及瀏覽器開始處理事件的時間。</p><p><strong>3.事件處理:</strong></p><p>一旦事件開始被處理，瀏覽器會記錄下處理開始的時間。如果頁面在處理事件時非常忙碌，或者有其他高優先級的任務，那麼事件處理可能會被延遲，這會增加 FID。</p><h3><strong>5.1.3 INP（交互到下一次繪製）</strong></h3><p>INP，即 Interaction to Next Paint，主要關注的是用戶交互（如點擊、滾動或按鍵操作）到頁面響應的時間長度，具體到頁面上的某個元素的可視更新。</p><p>比起來 FID 關注的是頁面加載完成後用戶<strong>首次交互</strong>，INP 關注的是<strong>所有交互的最長渲染延遲</strong>，因此 INP 不僅僅代表第一印象，可以全面評估響應情況， 使 INP 比 FID 在衡量用戶交互體驗上更為可靠。</p><p>INP 將會在 2024 年 3 月取代 FID 成為標準性能指標。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3bf10348f63ae93f27266efad4b84531629.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong><strong>△交互到繪製的時間</strong></strong></p><h2><strong>5.2 如何優化交互性能指標</strong></h2><p><strong>1、拆分任務，這是避免長任務的有效手段。</strong></p><ul><li><p>利用 performance 進行分析，找出 long task</p></li><li><p>針對 long task，進行每個步驟的任務拆分，執行優先級高的，剩下的部分利用延遲代碼執行的方法進行中斷。</p></li></ul><p>比如，有個 Input 框，當輸入的內容發生變更，需要進行大量計算/創建 dom 等耗時操作，造成輸入卡頓。因此我們需要在用戶「嘗試發生互動」的時候，「退讓主線程」。</p><pre><code>// 通過 Promise 實現中斷後繼續執行，setTimeout 調用來延遲任務
function yieldToMain () {
  return new Promise(resolve =&gt; {
    setTimeout(resolve, 0);
  });
}
    async function saveSettings(tasks) {
      let deadline = performance.now() + 50;

      while (tasks.length &gt; 0) {
        // 判斷當前是否有用戶交互，isInputPending Chrome87+支持。
        // 可以採用判斷 Expire Time 達到類似效果
        if (
          navigator.scheduling?.isInputPending() ||
          performance.now() &gt;= deadline
        ) {
         // 如果有，退讓主線程，等主線程任務完成再回來繼續執行。
          await yieldToMain();
          deadline = performance.now() + 50;
          continue;
        }
        const task = tasks.shift();
        task();
      }
    }

    const performLongTask = () =&gt; {
       // 創建耗時的任務
      let task = new Array(10000).fill(null).map((_, i) =&gt; () =&gt; {
        const span = document.createElement("span");
        span.innerText = i;
      });
      saveSettings(task); // 任務切片
    };
    input.addEventListener("input", (e) =&gt; {
      input.value = e.target.value;
      performLongTask();
    });
</code></pre><p>2、非關鍵模塊，延遲執行。對於點擊率不高、非核心模塊等，採取 dynamic import 的方式，用到了再加載，或是延遲到一定時間後再加載，減少首次主線程所需要執行的任務。</p><p>3、對於視口內不可見的內容，延遲加載。</p><ul><li><p>圖片的延遲加載。</p></li><li><p>為 img 標籤 loading 設為 lazy，延遲加載資源，直到資源達到與視口的計算距離，Chrome77+支持。</p></li><li><p>利用 IntersectionObserver 監測圖片是否在可視區域，再進行渲染。推薦使用<strong>lazy-load-image-component</strong><em>（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Freact-lazy-load-image-component%EF%BC%89" target="_blank">https://www.npmjs.com/package/react-lazy-load-image-component）</a></em> 等庫。</p></li><li><p>減少大量 dom 的渲染。使用 content-visibility 延遲渲染屏幕外元素，Chrome85+支持。</p></li></ul><p>4、靈活的緩存策略。</p><ul><li>用 service-worker 跨站資源共享。</li></ul><p>除了資源可以採取強緩存+協商緩存配合的方式，用 service-worker 實現更為靈活的緩存策略。比如站點 a 和站點 b 僅滿足同源，技術棧渲染方式都完全不同，如何實現在訪問 a 的時候可以預取 b 的資源。站點 a 空閒的時候註冊 service-worker，訪問站點 b 即可從 cache 裏讀取緩存，提升加載速度。sw 不僅在緩存方面表現優秀，也可以幫我們實現離線應用，以及無法被瀏覽器強緩存的文件手動添加緩存（不同瀏覽器對可以強緩存的文件的體積限制不同）。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6d991b243783e8ba64b09daeb68baf2d6b8.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong><strong>△使用 sw 做跨站資源預取</strong></strong></p><h1><strong>06 總結</strong></h1><p>1.瀏覽器是多進程和多線程的，通常説主線程指的是渲染進程下的主線程。</p><p>2.主線程上一次只能運行一個任務，瀏覽器的繪製和主線程並不互斥，但長任務會導致延遲進入合成，甚至在這一幀不發生合成也就是掉幀。</p><p>3.在每次事件循環的結束，不一定會發生渲染。setTimeout 的執行時機並不穩定。</p><p>4.RAF 的執行時機穩定是在當前幀的最後，下一幀的開始之前，非常適合做動畫。</p><p>5.RIC 的執行時機並不穩定，computeDeadline 由被多因素影響計算得出，但可以傳遞 timeout 控制執行的 deadline。</p><p>6.用 TTI 和 FID（INP）去衡量頁面的交互性能。</p><p>7.用長任務拆分、延遲非關鍵模塊執行、延遲非可視區域圖片加載、減少頁面渲染以及配置靈活的緩存策略等手段，提升網站的交互性能。</p><p>——END——</p><p><strong>參考資料：</strong></p><p>[1]HTML living standand - evnet loop processing model:</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fwebappapis.html%23event-loop-processing-model" target="_blank">https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model</a></p><p><strong>推薦閲讀：</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247574835%26idx%3D1%26sn%3D31d1b6ec0ecf857f5fb12ca8a2816fb1%26chksm%3Dc03f954ff7481c599d34556eeaba1960a4261d2e304e86989a54fa9e334c15a9ff8d58aa00b1%26scene%3D21%23wechat_redirect" target="_blank">百度搜索展現服務重構：進步與優化</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247574780%26idx%3D1%26sn%3D8eda1e3f3dc06d6f10394be4a9df86f8%26chksm%3Dc03f9480f7481d968a54f75a113c16651a5c371ae43f078705f965d0a51a19491f41d2179ab7%26scene%3D21%23wechat_redirect" target="_blank">百度 APP iOS 端包體積 50M 優化實踐 (七) 編譯器優化</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247574670%26idx%3D1%26sn%3D45e9f922faad4fffceca07bc116b15eb%26chksm%3Dc03f94f2f7481de45ad4b17e0235eb0074e4d78dff760654e44aed98d6684d7e0ba1ccbeffcd%26scene%3D21%23wechat_redirect" target="_blank">百度搜索內容 HTAP 表格存儲系統</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247574408%26idx%3D1%26sn%3Dfc0f0b325a348a401d647f3cb048b68a%26chksm%3Dc03f93f4f7481ae2c964c6fd7ab54a8291edb7b2dae16c20c5e30e998a0bceb418d631d40abf%26scene%3D21%23wechat_redirect" target="_blank">大模型時代，「人人可 AI」的百度開發者平台長什麼樣？</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247574315%26idx%3D1%26sn%3De1fe788ba3ae4f0b2d503bfac899cefa%26chksm%3Dc03f9357f7481a413ba7325eb9064078f097e7586136b885d11db67b4a5955412312d2428869%26scene%3D21%23wechat_redirect" target="_blank">數十萬 QPS，百度熱點大事件搜索的穩定性保障實踐</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 26 Dec 2023 01:53:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/10322486</guid>
            <link>https://my.oschina.net/u/4939618/blog/10322486</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[開源，想説愛你不容易~]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h3>前言</h3><p>其實很早以前，我就想寫一篇文章，聊聊我之前的開源歷程，我不是什麼大牛，只是 github 上千萬項目中一名普通 owner，但是我熱愛開源，熱愛分享，熱愛編程，正因為如此，我打算藉着 teamlinker 開源之際，從一名普通開源從業者的角度和大家聊聊我開源生涯中的種種過往，對自己對別人也算是一種借鑑和啓發吧。</p><p>我不是計算機科班出身，只是秉持着從小對編程的熱愛，通過自學走上了軟件開發的道路，這一路上有風雨有彩虹，受到過質疑，但也受到過更多的鼓勵和支持，也正因為如此，我格外能感受到所謂的自我學習和提升是一件多麼不容易的事情，所以當我接觸到開源的時候，自然而然的就有種説不出的親切感，看着那些工整的源碼，就彷彿像一個老師，循循善誘的給我們講解着它的結構和功能，只要你願意探索，就可以在其中發現無窮的樂趣。</p><h3>從開源走向創業</h3><p>還記得在 2016 年的時候，我當時在一家軟件公司擔任技術總監的職務，其中遇到的一個令人頭疼的問題就是前後端總是為接口文檔的同步問題爭執不下，我當時就想如何有一個產品可以管理並且自動的同步接口文檔，讓前後端都有一個唯一的參照物的話，這個問題就可以得到很大的緩解，在網上找了一遍後並沒有發現滿意的產品，於是我決定自力更生，利用業餘時間，完成了這個接口文檔管理軟件的開發，取名為：DOClever（老粉應該還記得這個產品一開始的名字叫 SBDoc ~）。</p><p>其實在一開始的時候，我並沒有想太多，當時只是試探性的放到 github 上，並且給我的一些朋友試用，卻出乎意料的大受好評。看見大家的積極的反饋以及 github 上 star 數目的與日俱增，我獲得了作為程序員生涯以來第一次無與倫比的滿足感。真正感受到原來開源是一件這麼美妙的事情。</p><p>隨着 DOClever 業務的加劇以及用戶的擴大，在 2017 年的時候，我決定將 DOClever 做大做強，找了一些朋友，我們決定出來創業，當時也正值創業風口，我們的這個項目也很快受到了不少關注。我們當時主要的宣傳窗口就是開源中國，在這裏我們認識了很多志同道合的朋友，也得到了編輯們對我們項目的各種肯定與支持，在此我還是要好好感謝下開源中國，感謝你們對中國開源事業所做的貢獻。</p><h3>商業化的探索與反思</h3><p>創業後很快我面臨的便是廣大開源軟件共同遇到的一個問題：盈利。當時我試過很多方案，比如開源版本與收費版本分開，打造收費插件，產品免費服務收費等，但最後都發現很難真正落地，而我當時的想法也很單純，覺得只要產品好，用戶愛用就一定會有辦法掙錢，所以我當時的精力全部扎進了產品研發中，開發了接口自動化測試模塊，還大膽做出了一個決定：利用 electron 打造了桌面端，在當時的競品中，敢做桌面端的我們算是第一個了，桌面端出來後用戶的反饋很好，但是我們還是陷入無法盈利的惡性循環。也就是説你的產品不錯，大家愛用，給你捐點小錢也 ok，但是一旦觸及商業化，那麼對不起在下告辭了~</p><p>後來我們也接過一些企業的定製化服務，週期長，任務重，有的甚至要駐點，但是為了團隊的發展我們又不得不做，我內心知道這個不是長久之計，也實在不想把我們做成一個外包公司，我更希望大家能認可我們統一化的產品，如果你有什麼需求，可以給我們一點時間，我們可以把它打造成模塊化的功能。但是往往甲方爸爸告訴我：不行，你需要專門為我定製一個 VVVVVVIP 至尊特供版。</p><p>其實我事後有認真反思過商業化的問題，覺得主要有兩點，接口管理平台本身市場就那麼大，競品也不少，而且軟件的門檻也低，我之所以能脫穎而出無非是我免費開源，功能也不差，但用戶不是非我不可，很多用戶都是因為 postman 的協作功能需要收費而轉向了我們，這些人的需求也很明確，就是要用免費的。第二點就是對於稍微大一點公司，他們內部都有自己的 api 接口管理，不會輕易的去使用外面的平台，就算去使用，也會對你原來的平台改的面目全非，有點公司良心點的還會請你去做個宣講啥的，感謝你下。有的就直接 copy 你的代碼把它變成他們內部開發的一個平台，這對於我們開源創業者可謂是竹籃打水一場空。</p><h3>創業失敗</h3><p>在 2018 年年中的時候，我向現實做出了屈服，我解散了我們團隊，我也去了一家大廠面試。我記得當時那個面試官問我做過哪些項目的時候，我把我的 github 給他看了下，他滿意的笑了笑，於是我很快就被錄取了。DOClever 自此也停止了更新，我把精力都投入了新的工作中，日子就這樣一天天波瀾不驚的過去，直到有一天羣裏的一個小夥伴給我發了一個鏈接，我點進去一看直接無語了，也是一個接口管理平台，但是裏面的功能，業務邏輯甚至頁面的佈局和按鈕的擺放都和 DOClever 一摸一樣，霎那間我明白我們被抄襲了。可是我又能做些什麼呢，DOClever 很久沒有更新了，我當時的公司也註銷了，軟件著作權也失效了，我能做的就是祝福他們做的比我更好吧！</p><p>時光荏苒，如今，我也從那個大廠離開了，慶幸的是我在此期間積累了一些資本，至少可以做幾年自己想做的事情，回顧過往，你問我開源後悔嘛，我不後悔，卻又五味雜陳，因為開源我可以讓更多人認識我，瞭解我，實現自我價值，也能找到滿意的工作，五味雜陳是因為開源只是一個商業化的手段，不是目的，開源不光是源碼的公開，更是一種價值的傳遞，內心的堅持，精神的坦誠，它對於創業者的要求更高，而我還遠遠不夠。</p><h3>感悟</h3><p>我個人認為，開源創業需要滿足兩個條件：<br> 1、你的產品所在市場潛力夠大，而你的產品的業務和功能又有一定的不可替代性。<br> 2、必須要有一套清晰的盈利模式，哪些東西可以通過開源來吸引流量，哪些東西是你的壓箱底的寶貝，真正能讓用戶掏錢買單，這些我們自己是必須清楚的。很多人會吐槽國內的開源氛圍太差，全是伸手黨，你辛辛苦苦寫的東西，別人給你一包裝就是他自己的了。其實很多時候我們自己又何嘗不是呢，我們的產品幾乎沒有哪個不用開源框架或者開源庫的，但是不代表我們不尊重開源，國外的很多商用軟件都會把用到的開源包列舉出來一一感謝，這就是一個很好的例子，國內最近關於開源協議的幾起民事訴訟的勝訴我相信也將成為一個很好的典範。</p><h3>新的征程</h3><p>回到我現在在做的事情 Teamlinker，這是一個基於人工智能的團隊協作平台，融入了項目管理，視頻會議，文件共享等功能，可以最大程度的讓團隊成員協同辦公。很多人勸我 teamlinker 不要開源，但是我覺得作為一個技術從業者，我的骨子裏有一種自由分享的精神，我也非常期望能和別人的交流來讓我的產品變得更好，我想再試一試，失敗並不可怕，可怕是在同樣的地方跌倒卻再也不敢站起來了~</p><p>開源，想説愛你不容易，但是我卻甘之如飴。</p><p>後記：歡迎大家給我們的 teamlinker 提出一點建議和批評，如果能有一點小小的鼓勵那就更好啦。<br> 官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fteam-linker.com" target="_blank">https://team-linker.com</a><br> Github：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FTeamlinker%2FTeamlinker" target="_blank">https://github.com/Teamlinker/Teamlinker</a><br> Gitee：<a href="https://gitee.com/sx1989827/teamlinker">https://gitee.com/sx1989827/teamlinker</a></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 10:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272643</guid>
            <link>https://www.oschina.net/news/272643</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Angular v17 正式發佈！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">原文：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fblog.angular.io%2Fintroducing-angular-v17-4d7033312e4b" target="_blank">Introducing Angular v17</a></p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">上個月是 Angular 紅色盾牌誕生 13 週年。 AngularJS（注意是 AngularJS 不是 Angular，也就是 1.x 版本） 是新一波 JavaScript 框架的起點，旨在支持對豐富 Web 體驗日益增長的需求。今天，我們憑藉新的外觀和一系列前瞻性功能，通過 v17 帶領大家走向未來，為性能和開發體驗奠定了新的基礎。</p><div><img alt="" height="405" src="https://img2023.cnblogs.com/blog/999445/202312/999445-20231225182432043-179844286.webp" width="720" referrerpolicy="no-referrer"></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><strong>在 v17 中，我們很高興地介紹：</strong></p><ul><li><strong>Deferrable views 可延遲視圖將性能和開發體驗提升到一個新的水平，從開發預覽版正式穩定</strong></li><li><strong>在</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fkrausest.github.io%2Fjs-framework-benchmark%2Fcurrent.html" target="_blank">公共基準測試</a><strong>中，通過內置控制流的循環，運行時間提高了 90%</strong></li><li><strong>混合渲染的構建速度提高了 87%，客戶端渲染的構建速度提高了 67%</strong></li><li><strong>全新的外觀，代表了 Angular 面向未來的特徵</strong></li><li><strong>全新的互動學習教程，從簡單到深入，包括在線 Playground</strong></li><li><strong>以及許多其他功能和改進！</strong></li></ul><h2>面向未來的身份</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">在過去的幾個版本中，Angular 的復興一直在全力進行。我們一直在通過基於信號（signal-based）的反應性（reactivity）、hydration（水合作用）、獨立組件、組合指令和許多其他功能等改進來加快勢頭。儘管 Angular 發展迅速，但它的品牌卻未能跟上 —— 從 AngularJS 早期以來，它幾乎一模一樣。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><br><strong>今天，你喜愛的、經過數百萬開發者考驗的框架煥然一新，反映了其面向未來的開發體驗和性能！</strong></p><div><div><img alt="" src="https://img2023.cnblogs.com/blog/999445/202312/999445-20231225182439272-1046899011.gif" referrerpolicy="no-referrer"></div></div><h2>面向未來的文檔</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">與新品牌一起，我們還為 Angular 文檔開發了一個新家 — angular.dev。對於新的文檔網站，我們採用了新的結構、新的指南、改進的內容，並構建了一個交互式學習之旅平台，讓你可以直接在瀏覽器中按照自己的節奏學習 Angular 和 Angular CLI。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><br> 新的交互式學習體驗由<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fwebcontainers.io%2F" target="_blank">WebContainers</a><span>&nbsp;</span>提供支持，讓你可以在任何現代 Web 瀏覽器中使用 Angular CLI 的強大功能！</p><div><div><img alt="" src="https://img2023.cnblogs.com/blog/999445/202312/999445-20231225182816361-167791283.gif" referrerpolicy="no-referrer"><div>
   &nbsp;
  </div></div></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">今天，我們將推出 angular.dev 的 Beta 預覽版，並計劃在 v18 將其設為 Angular 的默認網站。你可以在<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F665420129" target="_blank">Angular.dev 它來了</a>（原文<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fblog.angular.io%2Fannouncing-angular-dev-1e1205fa3039" target="_blank">Announcing angular.dev</a>）中瞭解有關 Angular 新外觀和 angular.dev 的更多信息。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><br> 現在讓我深入瞭解 v17 的功能，我們迫不及待地想告訴你！</p><h2>內置控制流</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">為了改善開發體驗，我們發佈了新的塊模板語法，通過簡單的聲明性 API 為你提供強大的功能。在底層，Angular 編譯器將語法轉換為高效的 JavaScript 指令，可以執行控制流、延遲加載等等。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">我們使用新的塊語法來實現一個被優化的內置控制流。在進行用戶研究後，我們發現許多開發人員都在使用<span>&nbsp;</span><code>*ngIf</code><span>&nbsp;</span>、<span>&nbsp;</span><code>*ngSwitch</code><span>&nbsp;</span>和<span>&nbsp;</span><code>*ngFor</code><span>&nbsp;</span>時遇到了一些困難。自 2016 年開始使用 Angular 並在過去 5 年裏成為 Angular 團隊的一員，我個人仍然需要查找<span>&nbsp;</span><code>*ngFor</code><span>&nbsp;</span>和<span>&nbsp;</span><code>trackBy</code><span>&nbsp;</span>的語法。在收集了社區、合作伙伴的反饋並進行用戶體驗研究後，我們為 Angular 開發了一個新的內置控制流！</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">內置控制流程可以：</p><ul><li>更舒適的語法，更接近 JavaScript，因此更直觀，需要更少的文檔查找</li><li>得益於優化的類型收窄（type narrowing），可以進行更好的類型檢查</li><li>這是一個主要存在於構建時的概念，它可以減少運行時佔用空間（使其「消失」），從而可以將你的包大小減少多達 30 KB，並進一步提高你的 Core Web Vital 分數</li><li>它會自動在你的模板中可用，無需額外導入，過去的結構型指令需要在 common 模塊導入 NgIf、NgFor 等</li><li>稍後會介紹顯著的性能提升</li></ul><h2>條件語句</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">讓我們看一下與<code>*ngIf</code>的比較：</p><div><pre><code class="language-html"><span>&lt;</span><span style="color:#093e8b">div</span><span style="color:#d95350">*</span><span style="color:#1772f6">ngIf</span><span>=</span><span style="color:#d95350">"loggedIn; else anonymousUser"</span><span>&gt;</span>
  The user is logged in
<span>&lt;/</span><span style="color:#093e8b">div</span><span>&gt;</span><span>&lt;</span><span style="color:#093e8b">ng-template</span><span style="color:#d95350">#</span><span style="color:#1772f6">anonymousUser</span><span>&gt;</span>
  The user is not logged in
<span>&lt;/</span><span style="color:#093e8b">ng-template</span><span>&gt;</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">使用內置 if 語句，此條件將如下所示：</p><div><pre><code class="language-js"><span style="color:#d95350">@</span><span>if</span><span>(</span><span>loggedIn</span><span>)</span><span>{</span><span>The</span><span>user</span><span>is</span><span>logged</span><span>in</span><span>}</span><span style="color:#d95350">@</span><span>else</span><span>{</span><span>The</span><span>user</span><span>is</span><span>not</span><span>logged</span><span>in</span><span>}</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">與舊版<span>&nbsp;</span><code>*ngIf</code><span>&nbsp;</span>替代方案的 else 子句相比，能夠直接在<code>@else</code>中填寫模板內容是一項重大簡化。當前的控制流也使得<span>&nbsp;</span><code>@else if</code><span>&nbsp;</span>變得可能，過去的結構性指令是不可能做到的。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><code>*ngSwitch</code><span>&nbsp;</span>改進的效果更加明顯：</p><div><pre><code class="language-js"><span>&lt;</span><span>div</span><span>[</span><span>ngSwitch</span><span>]</span><span>=</span><span style="color:#d95350">"accessLevel"</span><span>&gt;</span><span>&lt;</span><span>admin</span><span>-</span><span>dashboard</span><span>*</span><span>ngSwitchCase</span><span>=</span><span style="color:#d95350">"admin"</span><span>/&gt;</span><span>&lt;</span><span>moderator</span><span>-</span><span>dashboard</span><span>*</span><span>ngSwitchCase</span><span>=</span><span style="color:#d95350">"moderator"</span><span>/&gt;</span><span>&lt;</span><span>user</span><span>-</span><span>dashboard</span><span>*</span><span>ngSwitchDefault</span><span>/&gt;</span><span>&lt;</span><span style="color:#d95350">/div&gt;</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">通過內置控制流，它變成：</p><div><pre><code class="language-js"><span style="color:#d95350">@</span><span>switch</span><span>(</span><span>accessLevel</span><span>)</span><span>{</span><span style="color:#d95350">@</span><span>case</span><span>(</span><span style="color:#d95350">'admin'</span><span>)</span><span>{</span><span>&lt;</span><span>admin</span><span>-</span><span>dashboard</span><span>/&gt;</span><span>}</span><span style="color:#d95350">@</span><span>case</span><span>(</span><span style="color:#d95350">'moderator'</span><span>)</span><span>{</span><span>&lt;</span><span>moderator</span><span>-</span><span>dashboard</span><span>/&gt;</span><span>}</span><span style="color:#d95350">@</span><span>default</span><span>{</span><span>&lt;</span><span>user</span><span>-</span><span>dashboard</span><span>/&gt;</span><span>}</span><span>}</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">新的控制流可以在<span>&nbsp;</span><code>@switch</code><span>&nbsp;</span>中的各個分支中實現更好的類型收窄，這在<span>&nbsp;</span><code>*ngSwitch</code><span>&nbsp;</span>結構型指令中是不可能做到的。</p><h2>內置 for 循環</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">我最喜歡的更新之一是我們引入的內置 for 循環，它除了開發體驗改進之外，還將 Angular 的渲染速度推向了另一個水平！</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">其基本語法是：</p><div><pre><code class="language-js"><span style="color:#d95350">@</span><span>for</span><span>(</span><span>user</span><span>of</span><span>users</span><span>;</span><span>track</span><span>user</span><span>.</span><span>id</span><span>)</span><span>{</span><span>{{</span><span>user</span><span>.</span><span>name</span><span>}}</span><span>}</span><span style="color:#d95350">@</span><span>empty</span><span>{</span><span>Empty</span><span>list</span><span>of</span><span>users</span><span>}</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">我們經常會在應用程序中看到由於<code>*ngFor</code>中缺少<code>trackBy</code>功能而導致的性能問題。<span>&nbsp;</span><code>@for</code>中的一些區別是 track 是強制性的，以確保快速比較性能。此外，它更容易使用，因為它只是一個表達式而不是組件類中的方法。內置的<code>@for</code>循環還具有通過可選的<span>&nbsp;</span><code>@empty</code><span>&nbsp;</span>塊進行零項集合的快捷方式。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><code>@for</code><span>&nbsp;</span>語句使用了新的比較算法，並且與<span>&nbsp;</span><code>*ngFor</code><span>&nbsp;</span>相比具有更優化的實現，這使得社區框架基準測試的運行時間提高了 90%！</p><div><img alt="" height="1456" src="https://img2023.cnblogs.com/blog/999445/202312/999445-20231225182921204-1508718499.webp" width="720" referrerpolicy="no-referrer"></div><h2>試一試！</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><strong>內置控制流現已在 v17 開發者預覽版中發佈！</strong></p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">內置控制流的設計目標之一是實現完全自動化的遷移。要在現有項目中嘗試它，請使用以下 Schematics 一鍵遷移：</p><div><pre><code class="language-text">ng generate @angular/core:control-flow</code></pre></div><h2>下一步是什麼？</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">你已經可以使用帶有最新語言服務的內置控制流，我們與 JetBrains 密切合作，以便在他們的產品中提供更好的支持。我們還與 Prettier 的<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fsosukesuzuki" target="_blank">Sosuke Suzuki<span>&nbsp;</span></a>聯繫，以確保 Angular 模板可以正確格式化。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">與<code>*ngIf</code>、<code>*ngFor</code>和<code>*ngSwitch</code>相比，內置控制流處理內容投影（content projection）的方式仍然存在一些差異，我們將在接下來的幾個月裏努力解決這些問題。除此之外，我們對內置控制流的實現和穩定性充滿信心，所以你今天就可以嘗試一下！我們希望將其保留在開發者預覽版中，直到下一個主要版本，以便我們可以為潛在的向後不兼容問題進行修復，以防我們找到進一步增強開發體驗的機會。</p><h2>延遲視圖（Deferrable views）</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">現在讓我們談談懶加載的未來！利用新的塊語法，我們開發了一種新的強大機制，你可以使用它來使你的應用程序更快。在博客文章的開頭，我説過可延遲視圖將性能和開發體驗提升到了一個新的水平，因為它們通過前所未有的舒適的實現了聲明性和強大的延遲加載。</p><div><img alt="" height="603" src="https://img2023.cnblogs.com/blog/999445/202312/999445-20231225182938849-2097420811.webp" width="720" referrerpolicy="no-referrer"></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">假設你有一個博客，並且你想延遲加載用戶評論列表。目前，你必須使用<span>&nbsp;</span><code>ViewContainerRef</code><span>&nbsp;</span>，同時還要管理清理、管理加載錯誤、顯示佔位符等一系列複雜的問題。處理各種極端情況可能會產生一些複雜代碼，這將很難測試和調試。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">新的可延遲視圖允許你使用一行聲明性代碼延遲加載評論列表及其所有的依賴項：</p><div><pre><code class="language-js"><span style="color:#d95350">@</span><span>defer</span><span>{</span><span>&lt;</span><span>comment</span><span>-</span><span>list</span><span>/&gt;</span><span>}</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">最令人難以置信的部分是，這一切都是通過編譯時轉換髮生的：Angular 通過查找<span>&nbsp;</span><code>@defer</code><span>&nbsp;</span>塊內部使用的組件、指令和管道、生成動態導入並管理加載過程來抽象所有複雜性以及狀態之間的切換。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">當某個 DOM 元素進入視口時開始延遲加載組件涉及許多更重要的邏輯和<code>IntersectionObserver</code><span>&nbsp;</span>API。<span>&nbsp;</span><strong>Angular 使使用<code>IntersectionObservers</code>就像添加可延遲視圖觸發器一樣簡單！</strong></p><div><pre><code class="language-js"><span style="color:#d95350">@</span><span>defer</span><span>(</span><span>on</span><span>viewport</span><span>)</span><span>{</span><span>&lt;</span><span>comment</span><span>-</span><span>list</span><span>/&gt;</span><span>}</span><span style="color:#d95350">@</span><span>placeholder</span><span>{</span><em>&lt;!--</em><span>A</span><span>placeholder</span><span>content</span><span>to</span><span>show</span><span>until</span><span>the</span><span>comments</span><span>load</span><span>--&gt;</span><span>&lt;</span><span>img</span><span>src</span><span>=</span><span style="color:#d95350">"comments-placeholder.png"</span><span>&gt;</span><span>}</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">在上面的示例中，Angular 首先渲染佔位符塊的內容。當它在可視窗（viewport）中可見時，<span>&nbsp;</span><code>&lt;comment-list/&gt;</code><span>&nbsp;</span>組件就會開始加載。加載完成後，Angular 會刪除佔位符並渲染組件。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">還有用於加載和錯誤狀態的塊：</p><div><pre><code class="language-js"><span style="color:#d95350">@</span><span>defer</span><span>(</span><span>on</span><span>viewport</span><span>)</span><span>{</span><span>&lt;</span><span>comment</span><span>-</span><span>list</span><span>/&gt;</span><span>}</span><span style="color:#d95350">@</span><span>loading</span><span>{</span><span>Loading</span><span style="color:#d95350">…</span><span>}</span><span style="color:#d95350">@</span><span>error</span><span>{</span><span>Loading</span><span>failed</span><span>:</span><span>(</span><span>}</span><span style="color:#d95350">@</span><span>placeholder</span><span>{</span><span>&lt;</span><span>img</span><span>src</span><span>=</span><span style="color:#d95350">"comments-placeholder.png"</span><span>&gt;</span><span>}</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">就是這樣！ Angular 為你管理了大量的複雜邏輯。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">可延遲視圖提供了更多觸發器：</p><ul><li><code>on idle</code><span>&nbsp;</span>- 當瀏覽器不做任何繁重的工作時延遲加載塊</li><li><code>on immediate</code><span>&nbsp;</span>— 自動開始延遲加載，不阻塞瀏覽器</li><li><code>on timer(&lt;time&gt;)</code><span>&nbsp;</span>— 使用計時器延遲加載</li><li><code>on viewport</code><span>&nbsp;</span>和<span>&nbsp;</span><code>on viewport(&lt;ref&gt;)</code><span>&nbsp;</span>- 可視窗還允許指定錨元素的引用。當錨元素可見時，Angular 將延遲加載組件並渲染它</li><li><code>on interaction</code><span>&nbsp;</span>和<span>&nbsp;</span><code>on interaction(&lt;ref&gt;)</code><span>&nbsp;</span>— 使你能夠在用戶與特定元素交互時啓動延遲加載</li><li><code>on hover</code><span>&nbsp;</span>和<span>&nbsp;</span><code>on hover(&lt;ref&gt;)</code><span>&nbsp;</span>- 當用戶懸停元素時觸發延遲加載</li><li><code>when &lt;expr&gt;</code><span>&nbsp;</span>— 使你能夠通過返回承諾的表達式指定你自己的條件</li></ul><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">可延遲視圖還提供了在渲染依賴項之前預取依賴項的能力。添加預取就像向 defer 塊添加<span>&nbsp;</span><code>prefetch</code><span>&nbsp;</span>語句一樣簡單，並且支持所有相同的觸發器。</p><div><pre><code class="language-text">@defer (on viewport; prefetch on idle) {
  &lt;comment-list /&gt;
}</code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><strong>今天，可延遲視圖在 v17 的開發者預覽版中可用！瞭解有關</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fangular.io%2Fguide%2Fdefer" target="_blank">本指南</a><strong>中該功能的更多信息。</strong></p><h2>下一步是什麼？</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">可延遲視圖已準備好使用，我們強烈鼓勵你嘗試一下！我們將它們保留在開發人員預覽中的原因是這樣我們可以收集更多反饋並在 API 中引入更改，直到我們將它們鎖定為像框架的其餘部分一樣遵循語義版本控制。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">目前，服務器端渲染將渲染指定的佔位符。一旦框架加載應用程序並對其進行水合，可延遲視圖將按照我們上面描述的方式工作。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">下一步，我們將探索在服務器上渲染延遲塊內的內容，並在客戶端上啓用部分水合。在這種情況下，客戶端不會下載延遲視圖的代碼，直到觸發器請求它。此時，Angular 將下載相關的 JavaScript 並僅對視圖的這一部分進行水合。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">還將有許多令人興奮的信號互操作性，敬請期待！</p><h2>改進的混合渲染體驗</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">今天，我們通過<code>ng new</code>中的提示，使服務器端渲染 (SSR) 和靜態站點生成（SSG 或預渲染）更接近開發人員：</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">這是我們長期以來一直想要做出的改變，但首先我們希望 Angular 的 SSR 開發體驗充滿信心。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">要不，你可以通過以下方式在新項目中啓用 SSR：</p><div><pre><code class="language-text">ng new my-app --ssr</code></pre></div><div><img alt="" src="https://img2023.cnblogs.com/blog/999445/202312/999445-20231225183105094-1291642340.gif" referrerpolicy="no-referrer"></div><h2>Hydration 從開發者預覽版正式穩定</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">在過去的 6 個月裏，我們看到數千個應用程序採用了水合作用 (hydration)。<strong>今天，我們很高興地宣佈，水合作用已不再是開發者預覽版，並且在所有使用服務器端渲染的新應用程序中默認啓用！</strong></p><h2>新的 @angular/ssr 包</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">我們將 Angular Universal 倉儲移至 Angular CLI 倉儲庫，並使服務器端渲染成為我們工具中更加不可或缺的一部分！</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">從今天開始，要向現有應用程序添加 Hybrid 渲染支持直接運行：</p><div><pre><code class="language-text">ng add @angular/ssr</code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">此命令將生成服務入口點，添加 SSR 和 SSG 構建功能，並默認啓用水合。<span>&nbsp;</span><code>@angular/ssr</code><span>&nbsp;</span>提供與當前處於維護模式的<span>&nbsp;</span><code>@nguniversal/express-engine</code><span>&nbsp;</span>等效的功能。如果你使用的是 express-engine，Angular CLI 會自動將您的代碼更新為<code>@angular/ssr</code><span>&nbsp;</span>。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><strong>從舊平台遷移到最新的 Angular 混合渲染解決方案後，Virgin Media O2 的銷售額增長了 112%。</strong>通過將<span>&nbsp;</span><code>NgOptimizedImage</code><span>&nbsp;</span>與帶有 DOM Hydration 的 Angular SSR 結合使用，累積佈局偏移平均減少了 99.4%。</p><h2>使用 SSR 部署你的應用程序</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">為了進一步增強開發體驗，我們與雲提供商密切合作，以實現順利部署到他們的平台。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">Firebase 現在將自動識別並以接近零配置部署你的 Angular 應用程序，並提供<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Ffirebase.google.com%2Fdocs%2Fhosting%2Fframeworks%2Fangular" target="_blank">新的框架感知 CLI 提前預覽</a>。</p><div><pre><code class="language-text">firebase experiments:enable webframeworks
firebase init hosting
firebase deploy</code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">framework-aware CLI 可識別 SSR、i18n、圖像優化等的使用，使你能夠在經濟高效的無服務器基礎設施上提供高性能的 Web 應用程序。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">對於那些擁有複雜 Angular monorepos 或只是喜歡本機工具的人，AngularFire 允許使用<span>&nbsp;</span><code>ng deploy</code><span>&nbsp;</span>部署到 Firebase：</p><div><pre><code class="language-text">ng add @angular/fire
ng deploy</code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">為了能夠普通開發人員也可以部署，我們在 Angular 的服務器端渲染中啓用了 ECMAScript 模塊支持，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fangular%2Fangular%2Fpull%2F50247" target="_blank">引入</a>了<span>&nbsp;</span><code>HttpClient</code><span>&nbsp;</span>的獲取後端，並與 CloudFlare 合作<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdevelopers.cloudflare.com%2Fpages%2Fframework-guides%2Fdeploy-an-angular-site%2F" target="_blank">簡化</a>了流程。</p><h2>新的生命週期鈎子</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">為了提高 Angular 的 SSR 和 SSG 的性能，從長遠來看，我們希望擺脫 DOM 模擬和直接 DOM 操作。同時，在大多數應用程序的生命週期中，它們需要與元素交互以實例化第三方庫、測量元素大小等。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">為了實現這一點，我們開發了一組新的生命週期掛鈎：</p><ul><li><code>afterRender</code><span>&nbsp;</span>— 註冊一個回調函數，每次應用程序完成渲染時調用</li><li><code>afterNextRender</code><span>&nbsp;</span>— 註冊一個回調函數，在下次應用程序完成渲染時調用，注意 Next 一個詞表示下一次，也就是隻會執行一次</li></ul><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">只有瀏覽器相關邏輯才會調用這些鈎子，這使你能夠將自定義 DOM 邏輯安全地直接插入組件中。例如，如果你想實例化圖表庫，可以使用<span>&nbsp;</span><code>afterNextRender</code><span>&nbsp;</span>：</p><div><pre><code class="language-js"><span style="color:#d95350">@</span><span>Component</span><span>({</span><span>selector</span><span>:</span><span style="color:#d95350">'my-chart-cmp'</span><span>,</span><span>template</span><span>:</span><span style="color:#d95350">`&lt;div #chart&gt;{{ ... }}&lt;/div&gt;`</span><span>,</span><span>})</span><span>export</span><span>class</span><span>MyChartCmp</span><span>{</span><span style="color:#d95350">@</span><span>ViewChild</span><span>(</span><span style="color:#d95350">'chart'</span><span>)</span><span>chartRef</span><span>:</span><span>ElementRef</span><span>;</span><span>chart</span><span>:</span><span>MyChart</span><span>|</span><span>null</span><span>;</span><span>constructor</span><span>()</span><span>{</span><span>afterNextRender</span><span>(()</span><span>=&gt;</span><span>{</span><span>this</span><span>.</span><span>chart</span><span>=</span><span>new</span><span>MyChart</span><span>(</span><span>this</span><span>.</span><span>chartRef</span><span>.</span><span>nativeElement</span><span>);</span><span>},</span><span>{</span><span>phase</span><span>:</span><span>AfterRenderPhase</span><span>.</span><span>Write</span><span>});</span><span>}</span><span>}</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">每個鈎子都支持一個階段值（例如讀取、寫入），Angular 將使用該階段值來安排回調以減少佈局抖動並提高性能。</p><h2>新項目默認使用 Vite 和 esbuild</h2><div><img alt="" src="https://img2023.cnblogs.com/blog/999445/202312/999445-20231225183618741-2002323503.webp" referrerpolicy="no-referrer"></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">如果沒有對 Angular CLI 的構建管道進行底層的改變，我們從一開始就無法在 Angular 中啓用 SSR！</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">在 v16 中，我們引入了 esbuild 和 Vite 構建的開發者預覽版。從那時起，許多開發人員和一些企業合作伙伴都對其進行了試驗，<strong>使他們的一些應用程序的構建時間縮短了 67%！</strong>今天，我們很高興地宣佈，新的應用程序構建器已從開發者預覽版中正式穩定，並且默認為所有新應用程序啓用！</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">此外，我們還更新了使用混合渲染時的構建管道。通過 SSR 和 SSG，您可以觀察到<span>&nbsp;</span><strong><code>ng build</code></strong><span>&nbsp;</span>的速度提高了 87%，<span>&nbsp;</span><strong><code>ng serve</code></strong><span>&nbsp;</span>的編輯刷新循環速度提高了 80%。</p><div><img alt="" height="445" src="https://img2023.cnblogs.com/blog/999445/202312/999445-20231225183719596-1185793546.webp" width="720" referrerpolicy="no-referrer"></div><p>原圖是 bin 文件的動畫，當前平台不支持，如果想查看進原文</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">在未來的次要版本中，我們將提供原理圖，以使用混合渲染（​​使用 SSG 或 SSR 進行客戶端渲染）自動遷移現有項目。如果你今天想測試新的應用程序構建器，請查看我們<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fangular.io%2Fguide%2Fesbuild" target="_blank">文檔</a>中的本指南。</p><h2>DevTools 中的依賴注入調試</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">去年，我們展示了 Angular DevTools 中依賴注入調試功能的預覽。在過去的幾個月裏，我們實現了全新的調試 API，使我們能夠插入框架的運行時並檢查注入器樹。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">Based on these APIs we built an inspection user interface that allows you to preview the:<br> 基於這些 API，我們構建了一個檢查用戶界面，允許您預覽：</p><ul><li>Dependencies of your components in the component inspector<br> 組件 Inspector 中查看組件的依賴關係</li><li>Injector tree and dependency resolution path<br> 注入器樹和依賴解析路徑</li><li>Providers declared within the individual injectors<br> 在各個注入器中聲明的提供程序</li></ul><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">You can find a quick preview of the features in the animation below. Learn more about<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fangular.io%2Fguide%2Fdevtools" target="_blank">Angular DevTools on angular.io</a>.<br> 你可以在下面的動畫中快速預覽這些功能。在<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fangular.io" target="_blank"><span style="color:#3498db"><span style="background-color:transparent">http://</span></span><span>angular.io</span></a><span>&nbsp;</span>上了解有關<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fangular.io%2Fguide%2Fdevtools" target="_blank">Angular DevTools</a><span>&nbsp;</span>的更多信息。</p><div><div><img alt="" src="https://img2023.cnblogs.com/blog/999445/202312/999445-20231225183907781-1326515808.gif" referrerpolicy="no-referrer"><div>
   &nbsp;
  </div></div></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><br> 下一步，我們將完善 UI 並致力於更好地可視化注入器層次結構、提供程序及其分辨率。</p><h2>從一開始就提供獨立 API</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">在過去一年半的時間裏收集了獨立組件、指令和管道的反饋並完善了它們的開發體驗後，我們有信心從一開始就在所有新應用程序中啓用它們。所有<code>ng generate</code>命令現在都將構建獨立組件、指令和管道。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">與此同時，我們還重新審視了<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2FAngular.io" target="_blank"><span style="background-color:transparent; color:transparent">http://</span><span>Angular.io</span></a><span>&nbsp;</span>和 Angular.dev 的整個文檔，以確保一致的學習體驗、開發實踐和建議。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">在可預見的未來，我們將保留 NgModules，但看到新的獨立 API 的好處，我們強烈建議你逐步將項目遷移到它們。我們還提供了一個示意圖，可以為您自動完成大部分工作：</p><div><pre><code class="language-text">ng generate @angular/core:standalone</code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">有關更多信息，請查看我們的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fangular.io%2Fguide%2Fstandalone-migration" target="_blank">遷移指南</a>。</p><h2>Reactivity 的下一步</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">Angular 新的基於信號的響應式系統是我們在該框架中所做的最大轉變之一。為了確保與基於 Zone.js 的變更檢測的向後兼容性和互操作性，我們一直在努力製作原型並設計前進的道路。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><strong>今天，我們很高興地宣佈 Angular Signals 從開發者預覽版正式穩定</strong>。目前，我們將把<span>&nbsp;</span><code>effect</code><span>&nbsp;</span>函數保留在開發者預覽中，以便我們可以進一步迭代它的語義。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">在接下來的幾個月中，我們將開始推出基於信號的輸入、視圖查詢等功能。到明年 5 月，在 Angular v18 中，我們將提供許多功能來進一步改善開發人員使用 Signals 的體驗。</p><h2>測試的下一步</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">我們正在繼續試驗 Jest，並確保我們構建一個高性能、靈活且直觀的解決方案，滿足開發人員的需求。我們還開始嘗試 Web Test Runner，併為初始實施提供了一個<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fangular%2Fangular-cli%2Fpull%2F25860" target="_blank">PR</a>。在不久的將來，我們可能會首先關注 Web Test Runner，以解鎖那些渴望擺脫 Karma 的項目。</p><h2>Material 3 的下一步</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">我們一直在與 Google 的 Material Design 團隊努力合作，重構 Angular Material 的內部結構，以納入<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fm3.material.io%2Ffoundations%2Fdesign-tokens%2Foverview" target="_blank">design tokens</a>，該系統將為組件提供更多的自定義選項並啓用<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fm3.material.io%2F" target="_blank">Material 3</a><span>&nbsp;</span>支持。雖然我們還沒有準備好為 v17 提供 design token 和 M3 支持，但我們預計很快會在 v17 小版本中提供這些功能。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">在 2022 年第四季度，我們宣佈推出基於 MDC 的新 Angular Material 組件，並棄用具有相同功能但 DOM 結構和樣式不同的舊組件。我們在 v15 中棄用了舊組件，並將在 v17 中刪除。即使它們不屬於 Angular Material v17 包的一部分，你仍然可以將應用程序更新到 Angular v17 並使用 v16 Angular Material 包。在 v18 之前，這將是一個選項，之後 Angular Material v16 將不再與較新版本的 Angular 兼容。我們還與<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fwww.herodevs.com%2Fsupport" target="_blank">HeroDevs</a><span>&nbsp;</span>的合作伙伴合作，他們將提供無休止的付費支持，以防你暫時無法執行遷移。</p><h2>生活質量提升</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">除了所有這些面向未來的功能之外，我們還從待辦事項中提供了一系列較小的開發人員體驗增強功能！</p><h2>實驗性視圖轉換支持</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fweb-platform%2Fview-transitions%2F" target="_blank">View Transitions API</a><span>&nbsp;</span>可在更改 DOM 時實現平滑轉換。在 Angular 路由器中，我們現在通過<span>&nbsp;</span><code>withViewTransitions</code><span>&nbsp;</span>功能提供對此 API 的直接支持。使用此功能，不可以使用瀏覽器的本機功能在路線之間創建動畫過渡。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">你現在可以通過在應用啓動時通過路由器的提供程序聲明配置此功能來將此特性添加到你的應用程序中：</p><div><pre><code class="language-js"><span>bootstrapApplication</span><span>(</span><span>App</span><span>,</span><span>{</span><span>providers</span><span>:</span><span>[</span><span>provideRouter</span><span>(</span><span>routes</span><span>,</span><span>withViewTransitions</span><span>()),</span><span>]</span><span>});</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><code>withViewTransitions</code><span>&nbsp;</span>接受帶有屬性<span>&nbsp;</span><code>onViewTransitionCreated</code><span>&nbsp;</span>的可選配置對象，這是一個為你提供一些額外控制的回調：</p><ul><li>決定是否要跳過特定動畫</li><li>向 Document 添加 Class 以自定義動畫並在動畫完成時刪除這些 Class</li><li>等等。</li></ul><h2>圖像指令中的自動預連接</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">Angular 圖像指令現在會自動為你作為參數提供給圖像加載器的域生成預連接鏈接。如果圖像指令無法自動識別源並且未檢測到 LCP 圖像的預連接鏈接，它將在開發過程中發出警告。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">在<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fangular.io%2Fguide%2Fimage-directive" target="_blank">圖像指令指南中</a>瞭解有關此功能的更多信息。</p><h2>延遲加載動畫模塊</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">此功能可以使你的初始捆綁包（壓縮後的 16KB）減少 60KB。社區貢獻者<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2FJeanMeche" target="_blank">Matthieu Riegler</a><span>&nbsp;</span>提出並實現了一項功能，允許你通過異步提供程序函數延遲加載動畫模塊：</p><div><pre><code class="language-js"><span>import</span><span>{</span><span>provideAnimationsAsync</span><span>}</span><span>from</span><span style="color:#d95350">'@angular/platform-browser/animations-async'</span><span>;</span><span>bootstrapApplication</span><span>(</span><span>RootCmp</span><span>,</span><span>{</span><span>providers</span><span>:</span><span>[</span><span>provideAnimationsAsync</span><span>()]</span><span>});</span></code></pre></div><h2>輸入值變換</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">常見的模式是具有接收布爾輸入的組件。然而，這對如何將值傳遞給此類組件設置了限制。例如，如果我們對 Expander 組件有以下定義：</p><div><pre><code class="language-js"><span style="color:#d95350">@</span><span>Component</span><span>({</span><span>standalone</span><span>:</span><span>true</span><span>,</span><span>selector</span><span>:</span><span style="color:#d95350">'my-expander'</span><span>,</span><span>template</span><span>:</span><span style="color:#d95350">`…`</span><span>})</span><span>export</span><span>class</span><span>Expander</span><span>{</span><span style="color:#d95350">@</span><span>Input</span><span>()</span><span>expanded</span><span>:</span><span>boolean</span><span>=</span><span>false</span><span>;</span><span>}</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">...我們嘗試將其用作：</p><div><pre><code class="language-js"><span>&lt;</span><span>my</span><span>-</span><span>expander</span><span>expanded</span><span>/&gt;</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">你會得到一個錯誤「字符串不能分配給布爾值」。輸入值轉換允許你通過配置輸入裝飾器來解決此問題：</p><div><pre><code class="language-js"><span style="color:#d95350">@</span><span>Component</span><span>({</span><span>standalone</span><span>:</span><span>true</span><span>,</span><span>selector</span><span>:</span><span style="color:#d95350">'my-expander'</span><span>,</span><span>template</span><span>:</span><span style="color:#d95350">`…`</span><span>})</span><span>export</span><span>class</span><span>Expander</span><span>{</span><span style="color:#d95350">@</span><span>Input</span><span>({</span><span>transform</span><span>:</span><span>booleanAttribute</span><span>})</span><span>expanded</span><span>:</span><span>boolean</span><span>=</span><span>false</span><span>;</span><span>}</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">可以在 GitHub 上找到原始功能請求 - 作為 HTML<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fangular%2Fangular%2Fissues%2F14761" target="_blank">二進制屬性的布爾屬性</a>和<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fangular%2Fangular%2Fissues%2F14761" target="_blank">作為 HTML 二進制屬性的布爾屬性。</a></p><h2>作為字符串的 styles 和 styleUrls</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">Angular 組件支持每個組件多個樣式表。然而，絕大多數情況下，當我想要設置組件的樣式時，我會創建一個數組，其中包含指向內聯樣式或引用外部樣式表的單個元素。一項新功能使你你可以切換</p><div><pre><code class="language-js"><span style="color:#d95350">@</span><span>Component</span><span>({</span><span>styles</span><span>:</span><span>[</span><span style="color:#d95350">`
</span><span style="color:#d95350">    ...
</span><span style="color:#d95350">  `</span><span>]</span><span>})</span><span>...</span><span style="color:#d95350">@</span><span>Component</span><span>({</span><span>styleUrls</span><span>:</span><span>[</span><span style="color:#d95350">'styles.css'</span><span>]</span><span>})...</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">到更簡單、更符合邏輯：</p><div><pre><code class="language-js"><span style="color:#d95350">@</span><span>Component</span><span>({</span><span>styles</span><span>:</span><span style="color:#d95350">`
</span><span style="color:#d95350">    ...
</span><span style="color:#d95350">  `</span><span>})</span><span>...</span><span style="color:#d95350">@</span><span>Component</span><span>({</span><span>styleUrl</span><span>:</span><span style="color:#d95350">'styles.css'</span><span>})</span><span>...</span></code></pre></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">當你使用數組時，我們仍然支持多個樣式表。這更簡單，更直觀，並且與自動格式化工具配合使用效果更好。</p><h2>社區原理圖 Schematics</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">為了支持社區原理圖的開發，我們提供了一些實用方法作為<span>&nbsp;</span><code>@schematics/angular/utility</code><span>&nbsp;</span>的一部分。現在，你可以將表達式直接導入到 Angular 應用程序的根目錄中，並將提供程序添加到 Angular 應用程序的根目錄中，以及向<span>&nbsp;</span><code>package.json</code><span>&nbsp;</span>添加依賴項的現有功能。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">你可以在<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fangular.io%2Fguide%2Fschematics-for-libraries" target="_blank">文檔中的原理圖指南</a>中瞭解更多信息。</p><h2>Angular 開發者培訓</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">我們與交互式 EdTech 平台 SoloLearn 合作，基於我們最近開發的「<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fwww.youtube.com%2Fwatch%253Fv%253DxAT0lHYhHMY%2526list%253DPL1w1q3fL4pmj9k1FrJ3Pe91EPub2_h4jF" target="_blank">Angular 介紹</a>」課程開發了新的 Angular 培訓。他們創建了一個互動學習之旅，在過去兩個月內覆蓋了超過 7 萬人！</p><div><img alt="" height="405" src="https://img2023.cnblogs.com/blog/999445/202312/999445-20231225183954852-1286944851.webp" width="720" referrerpolicy="no-referrer"></div><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">請在我們<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fblog.angular.io%2Fnew-free-interactive-angular-course-for-beginners-on-sololearn-7a4c4f91810a" target="_blank">最近的公告中</a>瞭解更多信息。</p><h2>社區亮點</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><strong>我們要感謝 346 位貢獻者，是他們讓 Angular v17 變得如此特別！</strong>我們想列出的一些亮點：</p><ul><li><code>HttpClient</code><span>&nbsp;</span>now can<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fangular%2Fangular%2Fpull%2F50247" target="_blank">use fetch as a backend</a><span>&nbsp;</span>which is one of the features enabling Angular to run in an edge worker. We’d like to thank to<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2FJeanMeche" target="_blank">Matthieu Riegler</a><span>&nbsp;</span>for the help<br><code>HttpClient</code><span>&nbsp;</span>現在可以<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fangular%2Fangular%2Fpull%2F50247" target="_blank">使用 fetch 作為後端</a>，這是使 Angular 能夠在 edge 工作線程中運行的功能之一。我們要感謝 Matthieu Riegler 的幫助</li><li>Matthieu 還啓用了<span>&nbsp;</span><code>HttpTransferCache</code><span>&nbsp;</span>的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fangular%2Fangular%2Fpull%2F52029" target="_blank">自定義</a>，它允許為 post 請求指定標頭、過濾器和緩存</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fcexbrayat" target="_blank">Cédric Exbrayat</a><span>&nbsp;</span>在新的應用程序構建器中引入了對<span>&nbsp;</span><code>namedChunks</code><span>&nbsp;</span>的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fangular%2Fangular-cli%2Fpull%2F25913" target="_blank">支持</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Ftomalaforge" target="_blank">Thomas Laforge</a><span>&nbsp;</span>的<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fangular-challenges.vercel.app%2F" target="_blank">Angular Challenges</a><span>&nbsp;</span>是一個優秀的資源，一直在幫助 Angular 開發人員更上一層樓</li><li>AnalogJS 一直在穩步發展並接近 1.0。祝賀<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fbrandonroberts" target="_blank">Brandon Roberts</a><span>&nbsp;</span>所做的出色工作！</li><li>祝賀<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fsantoshyadavdev" target="_blank">Santosh Yadav</a><span>&nbsp;</span>的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fwww.youtube.com%2Fwatch%253Fv%253D3qBXWUpoPHo" target="_blank"><span>&nbsp;</span>Angular 初學者課程</a>瀏覽量達到 100 萬次</li></ul><h2>用 Angular 構建未來</h2><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">在過去的六個月裏，我們一直在繼續 Angular 的復興，發佈了一些功能，以提供更好的開發體驗和性能。今天，我們很高興在 Angular 的全新品牌和<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fangular.dev%2F" target="_blank">angular.dev</a>.學習體驗中體現出這一勢頭。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">在下一個發佈週期中，預計 Angular 基於信號的響應式、Hybrid 渲染和學習之旅將發生大量演變。</p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start">我們很榮幸能夠成為你使用 Angular 構建未來的旅程的一部分！謝謝你！</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 10:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272640/angular-17-released</guid>
            <link>https://www.oschina.net/news/272640/angular-17-released</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Windows 也可以用 eBPF 了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>此項目<span style="background-color:#ffffff; color:#1f2328">允許在 Windows 上使用 Linux 生態中熟悉的現有 eBPF 工具鏈和應用接口。也就是説，該項目將現有的 eBPF 項目作為子模塊，並添加中間層，使其能在 Windows 上運行。</span></p><p><span style="background-color:#ffffff; color:#1f2328">下圖顯示了本項目的基本架構和相關組件：</span><img height="1140" src="https://static.oschina.net/uploads/space/2023/1225/174251_tkYJ_3820517.png" width="1556" referrerpolicy="no-referrer"></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>現有的 eBPF 工具鏈（clang 等）可用於從各種語言的源代碼生成 eBPF 字節碼。字節碼可以被任何應用程序使用，也可以通過 bpftool 或 Netsh 命令行工具使用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>eBPF 字節碼會被髮送到一個靜態驗證器（PREVAIL 驗證器），該驗證器託管在一個安全的用戶模式環境中，如系統服務、飛地或可信虛擬機。如果 eBPF 程序通過了驗證器的所有檢查，就可以加載到內核模式執行上下文中。通常情況下，這是通過 JIT 編譯器（通過 uBPF JIT 編譯器）將程序編譯成本地代碼並傳遞給執行上下文來實現的。在調試構建中，字節碼可直接加載到解釋器（從內核模式執行上下文中的 uBPF），但解釋器不會僅在調試模式中支持，不提供發佈構建頻道支持，因為它被認為安全性較低。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>安裝到內核模式執行上下文中的 eBPF 程序可以附加到各種鈎子上，並調用 eBPF shim 公開的各種輔助 API，eBPF shim 內部封裝了公共 Windows 內核 API，允許在現有版本的 Windows 上使用 eBPF。許多輔助程序已經存在，隨着時間的推移，還將添加更多鈎子和輔助程序。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start">此項目並不是 eBPF 的分支，<span style="background-color:#ffffff; color:#1f2328">eBPF for Windows 利用現有項目，包括 IOVisor uBPF 項目和 PREVAIL 校驗器，通過為代碼添加 Windows 特定的託管環境，將它們運行在 Windows 上。</span></p><p style="text-align:start"><span style="background-color:#ffffff; color:#1f2328">Linux 提供了許多鈎子和輔助工具，其中有些是 Linux 特有的（例如，使用 Linux 內部數據結構），不適用於其它平台，而其它鈎子和輔助工具則是通用的，目的是為 eBPF 程序提供支持。</span></p><p style="text-align:start"><span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>eBPF 還可以與 </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>HyperVisor-enforced Code Integrity（<span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>HyperVisor 強制代碼完整性，HVCI）一起使用</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#1f2328">。啓用 HVCI 後，eBPF 程序無法進行 JIT 編譯，但可以以本地模式或解釋模式運行。</span></p></div>
                                                                ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 10:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/ebpf-for-windows</guid>
            <link>https://www.oschina.net/p/ebpf-for-windows</link>
        </item>
        <item>
            <title>
                <![CDATA[崑崙萬維「天工 SkyAgents」Beta 版全網測試]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><strong><span><span><span><span style="color:#1f2329">12 月 25 日，崑崙萬維 AI Agents 開發平台「天工 SkyAgents」Beta 版正式開放測試，用戶可在 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmodel-platform.tiangong.cn%2F" target="_blank">https://model-platform.tiangong.cn/ </a>立即體驗。</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">崑崙萬維「天工 SkyAgents」AI Agents 開發平台，基於崑崙萬維「天工大模型」打造，具備從感知到決策，從決策到執行的自主學習和獨立思考能力。用戶可以通過自然語言構建自己的單個或多個「私人助理」，並能將不同任務模塊化，通過操作系統模塊的方式，實現執行包括問題預設、指定回覆、知識庫創建與檢索、意圖識別、文本提取、http 請求等</span></span></span></span><span><span><span>任務。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span>在大模型技術高速發展、AI Agents 應用不斷進步的當下，</span></span></span><span><span><span><span style="color:#1f2329">崑崙萬維「天工 SkyAgents」是我們在智能體領域的一次探索與嘗試。這個平台也許並不完美，但我們希望與廣大開發者們攜手共建、互助成長，不斷開拓人工智能技術的應用邊界。</span></span></span></span><span><span><span>現在不完美是為了未來的完美，我們一直在技術追求的過程中，堅信而勇於突破。</span></span></span></span></span></span></span></p><h4><span><span><span><span><strong><span><span><span>攜手探索，合作共創</span></span></span></strong></span></span></span></span></h4><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span>大模型時代，交互式 AI 有望成為未來大模型技術的主流落地方向。歷史告訴我們，新興事物的演進總會找到一個穩定的術語來描述這種載體，而 AI Agents（智能體）已經顯現出了巨大潛力。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span>目前，全球對智能體的關注異常熱烈，OpenAI 高度關注智能體領域，並在 OpenAI dev day 發佈會上發佈了自定義 GPTs 以及 Assistance API；DeepMind 的聯合創始人最近</span></span></span><span><span><span>也</span></span></span><span><span><span>提到下一代人工智能技術的發展方向將是交互式 AI，而不是生成式 AI。這種交互式 AI 很大程度上與智能體的描述是相符的，用戶可以通過要求智能體完成各種任務，而智能體則可以操作軟件或與人類協作，完成複雜場景的工作。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span>在技術範式上，崑崙萬維也在不斷思考驅動智能體技術快速發展的底層技術和架構。我們同時也清楚地認識到，即使在大模型的語言交互能力的加持下，我們離一個完全可以自動做決策並執行任務的智能體還有距離。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span>今天，崑崙萬維正式開放「天工 SkyAgents」Beta 版，</span></span></span><strong><u><span><span><span><u><span>作為我們在 AI Agents 技術能力和應用能力上的一次探索</span></u></span></span></span></u></strong><span><span><span>。我們希望通過此次探索，能讓越來越多的用戶與開發者能夠將大</span></span></span><span><span><span><span style="color:#1f2329">模型技術應用到工作生活中，打造出滿足日常需求、激發靈感創新的專屬 AI Agents。我們也希望更多對 AI Agents 感興趣的朋友們能夠與我們一同攜手共創。歡迎廣大夥伴們提出建議與意見。 </span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><img alt="" height="619" src="https://oscimg.oschina.net/oscnet/up-e7a06ccac57f87401c80becb561193a4041.png" width="1265" referrerpolicy="no-referrer"></p><h4><span><span><span><span><strong><span><span><span>什麼是 AI Agents？</span></span></span></strong></span></span></span></span></h4><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">Agent 一般譯為「智能體」或「代理」，其概念最早由麻省理工學院人工智能實驗室（MIT AI Lab）創始人之一 Marvin Minsky 在其 1986 年出版的《思維的社會》一書中提出。它由社會與社會行為概念被引入計算系統內，指的是在某一環境下，能持續自主地發揮作用的計算實體。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">AI Agents 指的則是由人工智能技術驅動，能夠感知環境、進行決策和執行動作的智能實體。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">AI Agents 並不是一個新興的概念，自人工智能技術學科建立以來，就陸續有圍繞 AI Agents 的研究出現。2012 年深度神經網絡浪潮興起後，有一支以強化學習訓練 AI Agents 的學術派系誕生，轟動全球的圍棋機器人 AlphaGo 可以看作是這一流派的研究成果。不過，此類 AI Agents 更適合對抗性遊戲場景，在真實世界中較難落地。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">然而，大模型的出現改變了這一切。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">2023 年，隨着大模型技術在自然語言理解、工程能力、數據能力、存儲能力等領域的突破，大量對話交互類「GPT」湧現，以大模型技術驅動的 AI Agents 在通用性、實用性、可落地性等都得到了飛速發展，在全球掀起了又一陣 AI Agents 熱潮。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">傳統大模型應用大多基於 Prompt（用戶提示詞）實現，Prompt 的質量將直接影響大模型的回答效果，</span></span></span></span><strong><span><span><span><span style="color:#1f2329">缺乏提示詞工程能力的普通用戶難以將大模型的真正能力發揮到極致</span></span></span></span></strong><span><span><span><span style="color:#1f2329">。而 AI Agents 只需要用戶給定工作目標，就可以通過獨立思考、調用工具去逐步完成任務，極大降低大模型技術應用門檻。</span></span></span></span></span></span></span></span></p><h4><span><span><span><span><strong><span><span><span>AI Agents 三大核心模塊：大腦、感知、執行</span></span></span></strong></span></span></span></span></h4><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">根據復旦大學論文《The Rise and Potential of Large Language Model Based Agents: A Survey》，AI Agents 可以劃分為大腦（Brain），感知（Perception）、執行（Action）三大模塊化能力。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:center"><img alt="" height="497" src="https://oscimg.oschina.net/oscnet/up-e9dac7f27a534b98ae08bc84f655f2b0dff.png" width="828" referrerpolicy="no-referrer"></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">（圖片來源：《The Rise and Potential of Large Language Model Based Agents: A Survey》） </span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">1. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">大腦（Brain）</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">大腦是 AI Agents 的「核心信息處理中心」，具備理解當前環境並形成「記憶（Memory）」的能力，同時也具備存儲並檢索長期記憶的能力。「大腦」可以根據「記憶」和當前接收的信息進行邏輯推理，並將複雜問題拆解成可實現的子任務，應對複雜場景任務。同時，通過 RAG（檢索增強生成）技術，AI Agent 可以根據當前場景和用戶設定的目標進行進一步決策，實現獨立思考、規劃（Planning）和推理（Reasoning）。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">2. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">感知（Perception）</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">感知模塊能夠讓 AI Agents 基於當前的環境和場景獲取足夠的信息，這正是其與傳統 RPA 系統的區別之處。RPA 系統在面對大量未知信息、難以預測的環境時無法進行工作，AI Agents 則可以通過感知信息並做出對應的思考和行動，從而實現感知、理解和自主探索世界。 </span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">3. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">執行（Action）</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">執行模塊賦予了 AI Agents 執行任務的權限和能力。AI Agents 在接收到用戶任務指令後，結合由感知模塊收集的當前場景信息，通過大腦進行總結和推理後，輸出到執行模塊中，使 AI Agents 能夠根據用戶需求完成指令。同時，AI Agents 擁有調用、使用工具（Tool use）的能力，這些工具可以幫助 Agents 更高效地完成複雜任務，同時也提高了其在某些具體場景中的可信度和靈活度，相關應用場景包括讓 AI Agents 購買飛機票、點外賣、完成企業 IT/客服/法律任務等。</span></span></span></span></span></span></span></span></p><h4><span><span><span><span><strong><span><span><span>天工 SkyAgents</span></span></span></strong></span></span></span></span></h4><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">「天工 SkyAgents」基於崑崙萬維「天工大模型」打造，擁有專屬「大腦」、「感知」、「執行」模塊。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">個人用戶/開發者可以通過「天工 SkyAgents」進行自然語言和簡單操作，無需代碼編程能力，即可在幾分鐘之內部署屬於自己的 AI Agents，完成行業研究報告、單據填寫、商標設計、甚至健身計劃、旅行航班預定等多項私人定製需求。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">企業用戶/開發者則可以將「天工 SkyAgents」的眾多能力按需拼裝成企業 IT、智能客服、企業培訓、HR、法律顧問等眾多個性化的應用，並支持一鍵服務部署，確保其在不同業務系統中的無縫接入。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">「天工 SkyAgents」的 AI 能力背後，是崑崙萬維 AI Agents 技術在模塊化任務組件、智能知識庫構建、第三方工具調用、個性化 AI Agents 一鍵分享等領域的能力積累。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">1. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">模塊化任務組件，零代碼打造專屬 AI Agents</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">當前，多數用戶既不具備代碼開發經驗，也不具備訓練大模型提示詞工程（Prompt Engineering）的能力，難以將眾多日常生活的實際需求通過對話問答形式快速實現，無法將大模型能力發揮到極致。為瞭解決這一問題，「天工 SkyAgents」將大量任務組件模塊化，集成了智能對話、信息加工、信息提取、信息分類、第三方數據獲取、向量檢索等能力。</span></span></span></span></span></span></span></span></p><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">智能對話：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">智能對話模塊藉助 AI 能力，將用戶發送的內容，通過大語言模型進行處理並回復給用戶指定內容。</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">信息加工：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">通過預設提示詞（Prompt）的方式讓大模型對特定信息輸入進行加工，以獲得符合需求的內容。</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">信息提取：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">通過大模型對語義的理解，可以從輸入信息中提取目標信息</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">信息分類：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">藉助大模型的智能分析，將用戶問題進行分類，針對不同類型的問題執行不同操作，方便進行個性化處理；</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">第三方數據獲取：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">第三方數據接入會攜帶相關的參數，系統向指定地址發送 POST 請求，並接收響應。系統在攜帶相關參數的同時，可以實現與其他應用服務的數據互聯互通。基於第三方數據獲取模塊可以極大擴展 AI Agents 的能力，打通數據庫操作、聯網搜索等更多場景。</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">向量檢索：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">針對常見的用戶提問，系統可以將問題添加進知識庫，便於搜索和查找。而對於「知識庫」模塊而言，用戶可以輸入問題，系統將在知識庫中搜索相關問題與解答，並用自然語言進行輸出。</span></span></span></span></span></span></span></span></li></ul><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">2. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">智能知識庫構建，支持大規模知識導入</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">大模型能力雖強，但也有其天生的弱項。一方面，大模型通過參數訓練獲得的知識只能停留在某一時點，更新成本很高；另一方面，大模型的訓練數據通常以通用知識為主，細分領域的數據往往缺乏。為瞭解決這一問題，「天工 SkyAgents」支持導入更多格式和更大規模的數據和知識，給大模型增加了「知識庫外腦」。</span></span></span></span></span></span></span></span></p><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">支持多種數據導入形式：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">文本、文件、網站、問答對、在線文檔等方式，輕鬆將已有知識進行導入</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">知識庫 Embedding：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">將知識庫中的內容元素表示為低維度的向量，使得知識庫中的元素可以更容易地進行計算相似性、尋找相鄰的實體等數學運算，從而提高了知識庫在 AI Agents 中的可操作性。</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">知識庫自由鏈接：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">每個 AI Agents 可以自由鏈接所屬知識庫並同時由多個知識庫進行內容供給，每個知識庫也可以同時鏈接多個 AI Agents，知識庫內容可根據需要啓用和棄用，實現更靈活的知識內容管理。</span></span></span></span></span></span></span></span></li></ul><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">3. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">第三方工具調用，多場景隨心應對</span></span></span></span></strong></span></span></span></span></p><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">第三方工具調用：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">工具調用能力是將 AI Agents 與大量對話類 GPT 區別開來的核心能力之一，比如在機票預訂場景中，除了對用戶需求與航班信息進行分析判斷，AI Agents 還需要調用票務平台、電子支付等不同工具。因此，除了基礎的模塊外，「天工 SkyAgents」還支持各類第三方工具的調用，用戶可以根據自身需要進行工具的開發，使得構建 AI Agent 時擁有更多靈活的自由度。</span></span></span></span></span></span></span></span></li></ul><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">4. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">個性化 AI Agents 一鍵分享</span></span></span></span></strong></span></span></span></span></p><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">一鍵分享：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">為了回饋廣大用戶與開發者們，更便捷地打造與使用 AI Agents，「天工 SkyAgents」上線新年專屬活動，推出理想伴侶、有緣機伴、暖心家園三款官方新年模版，並全面簡化了分發和使用流程。用戶根據自己的創意設計出的 AI Agents 可以通過鏈接的方式向更多人分享，使用者只需點擊鏈接，即可獲得對該 AI Agents 的訪問權。點擊創建：https://model-platform.tiangong.cn/</span></span></span></span></span></span></span></span></li></ul><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">能力更全面、應用更智能、分享更便捷、平台更好用。本次「天工 SkyAgents」beta 版的正式開放內容，將進一步推動大模型技術的普惠化，幫助缺乏代碼開發能力的個人與中小企業積極擁抱大模型技術，助力大模型走入千家萬戶，為人工智能生態發展貢獻力量。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:center"><span><span><span><span><strong><span><span style="background-color:#fbbfbc"><span><span>掃碼進入「天工開放平台」 ，快速構建 AI Agent</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:center"><img alt="" height="280" src="https://oscimg.oschina.net/oscnet/up-9032e1a9041a11a6ce891a3020335655fae.png" width="280" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 09:18:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272624</guid>
            <link>https://www.oschina.net/news/272624</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[燧原科技增資至 1 億元，騰訊為第一大股東]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">天眼查 App 顯示，上海燧原科技股份有限公司於近日發生工商變更，註冊資本由約 443 萬人民幣增至 1 億人民幣。</span></p><p><span style="color:#000000">上海燧原科技股份有限公司（曾用名：上海燧原科技有限公司）成立於 2018 年 3 月，法定代表人、董事長兼總經理為趙立東（ZHAO LIDONG），經營範圍含集成電路、計算機硬件研發、批發、零售，自有研發成果轉讓，並提供相關技術諮詢與技術服務，銷售自產產品，集成電路製造等。</span></p><p><span style="color:#000000">股東信息顯示，<span style="background-color:#ffffff">該公司由騰訊科技（上海）有限公司、趙立東、張亞林、國家集成電路產業投資基金二期股份有限公司等共同持股。其中，騰訊科技（上海）有限公司持股約 21.37%，為第一大股東。</span></span></p><p><img height="250" src="https://oscimg.oschina.net/oscnet/up-1732a5466871889cdbf8c8cbb652bc144ab.png" width="700" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 09:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272620</guid>
            <link>https://www.oschina.net/news/272620</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Ruby 3.3.0 正式發佈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Ruby 3.3.0 現已正式<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ruby-lang.org%2Fen%2Fnews%2F2023%2F12%2F25%2Fruby-3-3-0-released%2F" target="_blank">發佈</a>。新版本<span style="background-color:#ffffff">添加了一個名為 Prism 的新解析器，使用 Lrama 作為解析器生成器，添加了一個名為 RJIT 的新純 Ruby JIT 編譯器，以及許多性能改進，尤其是 YJIT。</span></span></p><p><span style="background-color:#ffffff; color:#333333">具體更新內容如下：</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:left"><strong><span style="color:#000000"><span style="background-color:#ffffff">Prism</span></span></strong></h4><ul style="margin-left:0; margin-right:0"><li>引入&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fruby%2Fprism" target="_blank">Prism 解析器</a>作為默認 gem 
  <ul style="margin-left:0; margin-right:0"><li>Prism 是一個可移植、容錯且可維護的 Ruby 語言遞歸下降解析器</li></ul></li><li>Prism 已做好生產準備並積極維護，用戶可以使用它代替 Ripper 
  <ul style="margin-left:0; margin-right:0"><li>具體介紹可查看&nbsp;Prism 的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fruby.github.io%2Fprism%2F" target="_blank">文檔</a>。</li><li>Prism 既是一個由 CRuby 內部使用的 C 庫，又是一個可供任何需要解析 Ruby 代碼的工具使用的 Ruby gem</li><li>Prism API 中值得注意的方法有： 
    <ul style="margin-left:0; margin-right:0"><li><code class="language-plaintext">Prism.parse(source)</code>返回 AST 作為解析結果對象的一部分</li><li><code class="language-plaintext">Prism.parse_comments(source)</code>返回&nbsp;comments</li><li><code class="language-plaintext">Prism.parse_success?(source)</code>如果沒有錯誤，則返回 true</li></ul></li></ul></li><li>現在可以使用<code class="language-plaintext">ruby --parser=prism</code>或<code class="language-plaintext">RUBYOPT="--parser=prism"</code>嘗試使用&nbsp; Prism 編譯器。值得注意的是，該 flag 僅用於調試。</li></ul><h4 style="margin-left:0px; margin-right:0px; text-align:left"><strong><span style="color:#000000"><span style="background-color:#ffffff">使用 Lrama 代替 Bison</span></span></strong></h4><ul style="margin-left:0; margin-right:0"><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fruby%2Flrama" target="_blank">用 Lrama LALR 解析器生成器</a>替換 Bison&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.ruby-lang.org%2Fissues%2F19637" target="_blank">[Feature #19637]</a><ul style="margin-left:0; margin-right:0"><li>更多詳情可參閲<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frubykaigi.org%2F2023%2Fpresentations%2Fspikeolaf.html" target="_blank">Ruby Parser 的未來願景</a></li><li>為了便於維護，Lrama 內部解析器被替換為 Racc 生成的 LR 解析器</li><li>支持參數化規則<code class="language-plaintext">(?, *, +)</code>，將在 Ruby parse.y 中使用</li></ul></li></ul><h4 style="margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000"><strong><span style="background-color:#ffffff">YJIT</span></strong></span></h4><ul style="margin-left:0; margin-right:0"><li>相對 Ruby 3.2 的主要性能改進 
  <ul style="margin-left:0; margin-right:0"><li>對 splat 和 rest 參數的支持已得到改進。</li><li>為虛擬機的堆棧操作分配了寄存器。</li><li>編譯更多帶有可選參數的調用。異常處理程序也被編譯。</li><li>不支持的調用類型和<span style="background-color:#ffffff; color:#333333">復態調用點</span>不再退出到解釋器。</li><li>Rails <code class="language-plaintext">#blank?</code>和 specialized<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frails%2Frails%2Fpull%2F49909" target="_blank"><code class="language-plaintext">#present?</code></a>等基本方法都是內聯的。</li><li>對<code class="language-plaintext">Integer#*</code>、<code class="language-plaintext">Integer#!=</code>、<code class="language-plaintext">String#!=</code>、<code class="language-plaintext">String#getbyte</code>、&nbsp;<code class="language-plaintext">Kernel#block_given?</code>、<code class="language-plaintext">Kernel#is_a?</code>、<code class="language-plaintext">Kernel#instance_of?</code>和<code class="language-plaintext">Module#===</code>進行了特別優化。</li><li>編譯速度現在比 Ruby 3.2 稍快。</li><li>現在比 Optcarrot 上的解釋器快 3 倍以上</li></ul></li><li>與 Ruby 3.2 相比顯着提高了內存使用率 
  <ul style="margin-left:0; margin-right:0"><li>編譯代碼的元數據佔用內存更少。</li><li>當應用程序的 ISEQ 超過 40,000 個時，<code class="language-plaintext">--yjit-call-threshold</code>會自動從 30 提高到 120。</li><li>添加<code class="language-plaintext">--yjit-cold-threshold</code>以跳過編譯 cold&nbsp;ISEQ。</li><li>在 Arm64 上生成更緊湊的代碼。</li></ul></li><li>Code GC 現在默認禁用 
  <ul style="margin-left:0; margin-right:0"><li><code class="language-plaintext">--yjit-exec-mem-size</code>被視為新代碼編譯停止的硬限制。</li><li>不會因 Code GC&nbsp;導致性能突然下降。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fshopify%2Fpitchfork" target="_blank">使用 Pitchfork</a>&nbsp;重新分叉的服務器上有更好的 copy-on-write&nbsp;行為&nbsp;。</li><li>如果需要，仍然可以使用<code class="language-plaintext">--yjit-code-gc</code>啓用&nbsp;code GC</li></ul></li><li>添加<code class="language-plaintext">RubyVM::YJIT.enable</code>以便在運行時啓用 YJIT 
  <ul style="margin-left:0; margin-right:0"><li>無需修改​​命令行參數或環境變量即可啓動 YJIT。Rails 7.2 將使用此方法<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frails%2Frails%2Fpull%2F49947" target="_blank">默認啓用 YJIT</a>&nbsp;。</li><li>這也可用於僅在應用程序完成啓動後啓用 YJIT。如果想在啓動時禁用 YJIT 的同時使用其他 YJIT 選項，可以使用<code class="language-plaintext">--yjit-disable</code>。</li></ul></li><li>默認情況下提供更多 YJIT stats 
  <ul style="margin-left:0; margin-right:0"><li>現在默認情況下還提供了<code class="language-plaintext">yjit_alloc_size</code>和更多與元數據相關的統計信息。</li><li>由<code class="language-plaintext">--yjit-stats</code>生成的 <code class="language-plaintext">ratio_in_yjit</code>stat 現在可在發行版中使用，不再需要特殊的 stats 或 dev 版本才能訪問大多數統計信息。</li></ul></li><li>添加更多 profiling 功能 
  <ul style="margin-left:0; margin-right:0"><li>添加<code class="language-plaintext">--yjit-perf</code>以方便使用 Linux perf 進行分析。</li><li><code class="language-plaintext">--yjit-trace-exits</code>現在支持使用<code class="language-plaintext">--yjit-trace-exits-sample-rate=N</code>進行採樣</li></ul></li><li>更全面的測試和多個錯誤修復</li></ul><h4 style="margin-left:0px; margin-right:0px; text-align:left"><strong><span style="color:#000000"><span style="background-color:#ffffff">RJIT</span></span></strong></h4><ul style="margin-left:0; margin-right:0"><li>引入了純 Ruby JIT 編譯器 RJIT 並取代了 MJIT。 
  <ul style="margin-left:0; margin-right:0"><li>RJIT 僅支持 Unix 平台上的 x86-64 架構。</li><li>與 MJIT 不同，它在運行時不需要 C 編譯器。</li></ul></li><li>RJIT 的存在僅用於實驗目的。 
  <ul style="margin-left:0; margin-right:0"><li>建議用戶在生產環境中繼續使用 YJIT。</li></ul></li><li>如果對為開發 JIT for Ruby 感興趣，可查看&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frubykaigi.org%2F2023%2Fpresentations%2Fk0kubun.html%23day3" target="_blank">k0kubun 在 RubyKaigi 第 3 天的演示</a>。</li></ul><h4 style="margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000"><strong><span style="background-color:#ffffff">M:N 線程調度器</span></strong></span></h4><ul style="margin-left:0; margin-right:0"><li>引入了 M:N 線程調度程序。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.ruby-lang.org%2Fissues%2F19842" target="_blank">[Feature#19842]</a><ul style="margin-left:0; margin-right:0"><li>M 個 Ruby 線程由 N 個本機線程（操作系統線程）管理，因此減少了線程創建和管理成本。</li><li>它可能會破壞 C 擴展兼容性，因此默認情況下會在主 Ractor 上禁用 M:N 線程調度程序。 
    <ul style="margin-left:0; margin-right:0"><li><code class="language-plaintext">RUBY_MN_THREADS=1</code>環境變量可在主 Ractor 上啓用 M:N 線程。</li><li>M:N 線程始終在非主 Ractor 上啓用。</li></ul></li><li><code class="language-plaintext">RUBY_MAX_CPU=n</code>環境變量用於設置<code class="language-plaintext">N</code>（本地線程的最大數量）的最大值。默認值為 8。 
    <ul style="margin-left:0; margin-right:0"><li>由於每個 Ractor 只能同時運行一個 Ruby 線程，因此將使用的本地線程數是<code class="language-plaintext">RUBY_MAX_CPU</code>中指定的線程數和正在運行的 Ractor 數量中較小的一個。因此，單 Ractor 應用程序（大多數應用程序）將只使用 1 個本地線程。</li><li>為了支持阻塞操作，可以使用<code class="language-plaintext">N</code>個以上的本地線程。</li></ul></li></ul></li></ul><p>更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ruby-lang.org%2Fen%2Fnews%2F2023%2F12%2F25%2Fruby-3-3-0-released%2F" target="_blank">查看官方公告</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 08:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272610/ruby-3-3-0-released</guid>
            <link>https://www.oschina.net/news/272610/ruby-3-3-0-released</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[國內第一個開源免費電子簽章系統發佈了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:left"><span><span><span><span><strong><span>一、前言 &nbsp;&nbsp;</span></strong><br> &nbsp;&nbsp;&nbsp;&nbsp;<span><span>如約而至，歷經一年的奮戰，開放籤電子簽章系統於 2023 年 12 月 15 日上線發佈了。</span></span><br> &nbsp;&nbsp;&nbsp;&nbsp;<span><span>開放籤是國內第一個開源免費的電子簽章系統，為企業構建安全、可信、可控、靈活的一站式電子簽章全服務體系產品鏈，我們相信將電子簽章技術、產品開源開放，能夠為產品與用戶之間帶來更多信任，讓電子簽署更加可信、簡單。</span></span><br><strong><span><span><strong>二、產品理念 &nbsp;&nbsp;</strong></span></span></strong><br> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong><span><span><strong>產品的核心價值理念：讓電子簽署更簡單。</strong></span></span></strong></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span>&nbsp; &nbsp; &nbsp; &nbsp;讓電子簽章技術更加簡單：目前，市場上掌握電子簽署完整技術的開發工程師比例相對較低，同時網上相關的技術資料和工具也比較分散，很難系統性的學習和應用。所以，我們希望開放籤可以將電子簽章技術和工具完整的、開源的提供出來，讓有技術能力的個人或團隊學習或自建電子簽章系統；</span></span><br><span><span>讓電子簽章應用更加簡單：在應用層面，我們希望可以降低企業應用電子簽章產品的門檻，免費下載，零採購成本使用；</span></span><br><strong><span><span><strong>三、產品矩陣和功能</strong></span></span></strong><br> &nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp; &nbsp;&nbsp;</strong><strong><span><span><strong>基於產品理念，開放籤的產品矩陣和功能如下：</strong></span></span></strong></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span>&nbsp; &nbsp; &nbsp; &nbsp;開源工具版：將電子簽章的核心技術代碼和工具進行開源，開源版採用更加寬鬆的 MIT 開源協議，且不受商業限制。產品功能包括：電子印章製作，手寫簽名生成，數字證書生成，PDF 文件轉圖片，電子簽章（關鍵字簽署、指定位置簽署），文件驗籤等。</span></span><br> &nbsp; &nbsp; &nbsp; &nbsp;<span><span>企業版：提供免費版本的電子簽章應用系統，用戶可以一鍵下載、部署安裝，部署完成後，用戶即可擁有電子簽章的基本功能。支持私有化部署、多租戶、SaaS 化等多種服務模式，提供在線簽署、電子簽章、電子印章管控、審批流程管理、數字證書服務等功能，滿足電子合同、電子保單、電子報告單、招投標文件、電子成績單、電子證明、金融憑證、會計憑證、電子處方等多種電子文件簽署場景。</span></span><br> &nbsp; &nbsp; &nbsp; &nbsp;<span><span>定製版：對於比較複雜的、定製的場景需求，開放籤提供本地化、深度定製化、專屬技術服務，為您提供專屬電子簽章平台。</span></span><br><strong><span><span><strong>四、開放籤產品地址</strong></span></span></strong><br><span><span>開源工具版下載地址：</span></span></span></span></span></span></p><p><a href="https://gitee.com/kaifangqian">gitee 倉庫地址</a>：https://gitee.com/kaifangqian</p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.kaifangqian.com" target="_blank">產品官網地址</a>：www.kaifangqian.com</p><p><span style="background-color:#ffffff; color:#4d4d4d">開放籤將始終以開源、開放的價值觀持續更新系統，為用戶提供更加開放、好用的電子簽章系統。</span></p><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 07:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272595</guid>
            <link>https://www.oschina.net/news/272595</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[和 ChatGPT 聊天費水，提 10 個問題或消耗半升水]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>《央視財經》報道稱，如果一個用戶向 ChatGPT 問了 10 到 50 個問題，可能會消耗掉 500 毫升的水。</p><p>因為訓練和運行 AI 大模型通常需要數以萬計的服務器來提供計算資源、存儲資源以及低延遲的網絡連接，這些服務器會以集羣的方式部署在名為「數據中心」的物理場所，當它們一起工作時，會在短時間內產生高度集中的熱量，所以需要大量的水資源進行冷卻。</p><p><img height="240" src="https://oscimg.oschina.net/oscnet/up-07526f86e0540f3acb7c39b414feef1d080.png" width="500" referrerpolicy="no-referrer"></p><p>以微軟和谷歌為例。2022 年，微軟一共用掉了約 17 億加侖（約 64 億升）水，相當於可以填滿約 2500 個奧運會規格的泳池；而谷歌的數據中心和辦公室則用掉了總計 56 億加侖（約 212 億升）水，相當於 8500 個奧運會規格的游泳池。</p><p>數據顯示，現在 AI 所需要的算力預計每 100 天就會翻一番，並且在未來五年內可能會增長超過一百萬倍。研究人員預計，到 2027 年，全球範圍內的 AI 需求可能會需要消耗掉 66 億立方米的水資源，幾乎相當於美國華盛頓州全年的取水量。</p><p>美國聖克拉拉大學馬庫拉應用倫理學中心高級主管，安·斯基特表示：「我認為很快就會有監管機構開始行動，而歐盟明年就會提高相關的監管要求，要求公司披露它們的用水情況。」</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 07:41:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272594</guid>
            <link>https://www.oschina.net/news/272594</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[openKylin 社區第三次理事會會議成功召開！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span><span style="color:#000000">2023 年 12 月 22 日下午，openKylin 社區第三次理事會會議在北京成功召開。本次會議由 openKylin 社區祕書長餘傑主持，麒麟軟件、普華基礎軟件、中科方德、麒麟信安、凝思軟件、中興新支點、元心科技、中國電科 32 所、技德系統、北京麟卓、先進操作系統創新中心、飛騰、兆芯、龍芯中科、景美、京東科技、玄鐵、申泰信息、海光等 21 家社區理事單位代表參會。</span></span></p><div><img alt="" height="720" src="https://oscimg.oschina.net/oscnet/up-89ff214b26c58cc74cf9c9fcbb41c82fefe.png" width="1080" referrerpolicy="no-referrer"></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社區諮詢委員會委員韓乃平為本次會議作開場致辭，向出席會議的各位來賓致以歡迎和感謝，並表示一個社區的良性發展，不僅需要主流軟硬件廠商的積極合作，更需要吸引全球眾多開源社區開發者不斷湧入。openKylin 作為我國開源操作系統根社區，通過聚合產、學、研、用等開源力量，在過去一年取得了行業矚目的成績，希望通過本次會議，共同商討如何更好推進社區發展，挖掘社區更多潛能，為推進中國信息化產業的發展作出更大的貢獻。</span></span></p><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-b126e34cb4bad1857b66cf44f36cad418cf.jpg" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#6ec1f5"><span style="background-color:#f7fcff">社區工作彙報</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社區副祕書長劉敏以線上形式參與會議，圍繞社區治理、基礎設施、SIG 組、社區版本、社區會員和品牌推廣等維度，向理事單位代表彙報 2023 年社區運營進展及 2024 年發展規劃。openKylin 社區技術委員會委員李劍峯從系統版本構建和社區技術創新等維度向理事單位代表進行彙報。</span></span></p><div><p style="text-align:center"><img alt="" height="2432" src="https://oscimg.oschina.net/oscnet/up-c40a204c7c674be4aca5f9baa697d7f0959.jpg" width="3648" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">2023 年，openKylin 社區發佈了 3 個系統版本，並圍繞桌面操作系統底層核心技術和用戶體驗提升，推出了「分級凍結」應用生命週期管理機制、軟硬件生態「原生兼容」技術、VirtIO-GPU 硬件視頻加速機制、新一代圖形顯示框架 wlcom 合成器、開明軟件包格式等一系列創新成果。</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">此外，面向快速發展的人工智能技術領域，openKylin 社區積極佈局，2023 年 6 月啓動了對 AI 大模型產品的生態兼容和系統級融合，發佈 openKylin AI 框架安裝助手，並在 openKylin 1.0 版本中支持桌面 AI 大模型插件和智能語音助手功能，推動桌面操作系統智能交互創新發展。</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#6ec1f5"><span style="background-color:#f7fcff">理事單位貢獻分享</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">北京麟卓總經理溫研發表《繪製輝煌，驅動未來--圖形 SIG 組工作彙報》主題分享，基於社區平台，北京麟卓成立了 GraphicSystem SIG，負責 openKylin 社區中 GPU 驅動的適配與優化、圖形軟件棧優化、基於 GPU 的通用計算、圖形處理系統綜合測試評估等與圖形系統相關的信息交流和配套軟件開發工作。未來，麟卓將於與社區加深合作，為拓展社區應用生態提供支撐。</span></span></p><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-8281f0b89a1a8051710c2f34a8299ec7806.jpg" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">元心科技研究院副院長李何佳發表《Flutter SIG 組的工作進展及後續工作方向》主題分享，加入社區後，元心科技參與了 Security SIG 相關工作，並對相關倉庫進行了 CVE 的漏洞修復。同時發起成立了 Flutter SIG，致力於為推進 Flutter 應用開發框架在 openKylin 社區的支持，包括對 Flutter 開發環境支持和 Flutter 應用運行支持。後續，將與 openKylin 社區緊密協作，共同開展更多技術嘗試與創新探索。</span></span></p><div><p style="text-align:center"><img alt="" height="2432" src="https://oscimg.oschina.net/oscnet/up-c1d070fd8ccd1211a40b6ec0ef66c5d8f84.jpg" width="3648" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">飛騰軟件支持經理鄭俊普發表《與開放的麒麟共飛騰》主題分享，飛騰與 openKylin 社區在技術支持、開源社區建設和生態活動等方面有着密切合作。基於社區，創建了 Phytium SIG，2024 年，飛騰將圍繞服務器平台上的 openKylin 內核和軟件適配開展工作，為社區生態繁榮貢獻一份力量。</span></span></p><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-42ac95fa812d4ddef5b497314b302201ea9.jpg" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">阿里巴巴達摩院，RISC-V 及生態高級技術專家王雲龍發表《openKylin&amp;玄鐵 RISC-V 合作進展》主題分享，王雲龍表示，玄鐵與 openKylin 社區在技術融合、軟件適配和生態推廣方面有着深度合作，基於玄鐵 CPU+openKylin 操作系統的基礎平台，聯合釘釘，三方共同努力完成了 27000+文件的編譯、Qt&amp;CEF 等核心組件、17 個第三方庫的構建工作，在 RISC-V 架構上首次實現了大型商業 IM 的流暢運行。</span></span></p><div><p style="text-align:center"><img alt="" height="2432" src="https://oscimg.oschina.net/oscnet/up-086ff4a6aea5896e7cea8088376720081e1.jpg" width="3648" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">景美產品總監邱江發表《國產 GPU 的 openKylin 開源之路》主題分享，景美在加入 openKylin 社區後發起成立 GPU SIG 組，並邀請了國內多家 GPU 廠商陸續加入並貢獻社區，目前已正式完成景美 JM9100 顯卡與 openKylin 1.0 版本操作系統的適配工作，其適配成果後續也將逐步合併到 openKylin 2.0 版本中。</span></span></p><div><p style="text-align:center"><img alt="" height="2432" src="https://oscimg.oschina.net/oscnet/up-4c6fb975407dd2b4754514f4b7c64beac2d.jpg" width="3648" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">兆芯高級產品經理張偉發表《共建 openKylin 社區》主題分享，兆芯加入社區 GPU SIG 後，積極開展 openKylin 內核在兆芯 CPU 平台上的驗證適配、性能優化、新需求支持等相關工作，協助社區有序推進 openKylin 開源操作系統的完善和版本更新，目前，兆芯最新一代開先 KX-6000G 處理器已與 openKylin 操作系統完成適配認證工作，並在 openKylin 社區代碼貢獻位列前茅。</span></span></p><div><p style="text-align:center"><img alt="" height="2432" src="https://oscimg.oschina.net/oscnet/up-7fbab6bb17d73843fd51af01b0036d508af.jpg" width="3648" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#6ec1f5"><span style="background-color:#f7fcff">閉門討論</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社區理事會作為社區決策機構和領導機構，主要職責為指導社區的發展方向，制定長期發展規劃和實施指導意見。會上，openKylin 副祕書長劉敏就 openKylin 社區章程更新向理事單位進行彙報。隨後，各理事單位圍繞</span><strong><span style="color:#000000">社區運營、生態共建、技術創新發展方向</span></strong><span style="color:#000000">等重大事宜發表了各自意見，並進行了深入討論。</span></span></p><div><p style="text-align:center"><img alt="" height="1549" src="https://oscimg.oschina.net/oscnet/up-ec6edfcdc1519d9b04b5729e9a7ed94fa38.jpg" width="3921" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#6ec1f5"><span style="background-color:#f7fcff">總結致辭</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">最後，由社區理事長朱晨對本次理事會進行總結致辭，朱晨表示，openKylin 社區的繁榮發展，離不開每一位貢獻者的辛勤付出。在今天上午的社區 2023 年度夥伴暨開發者大會上，我們對參與社區共建的優秀企業夥伴和個人開發者進行了表彰頒獎。我們很高興地看到，越來越多優秀夥伴加入，為打造國產開源操作系統根社區貢獻力量。</span></span></p><div><p style="text-align:center"><img alt="" height="720" src="https://oscimg.oschina.net/oscnet/up-6daf096096b8cee46f43e5562cd5d447400.png" width="1080" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">未來，openKylin 將繼續秉持「開源聚力、共創未來」的社區理念，持續推動技術創新和生態拓展，打造一個更加強大和優秀的桌面操作系統開源社區，同時將不斷提升自身在開源技術發展中的影響力，為推進中國信息化產業的發展作出更大的貢獻。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 06:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272584</guid>
            <link>https://www.oschina.net/news/272584</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[開源共創，攜手成長 | openKylin 夥伴暨開發者年度會議圓滿落幕！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span><span style="color:#000000">12 月 22 日，openKylin 夥伴暨開發者年度會議在北京成功召開。本次會議以「開源共創，攜手成長」為主題，邀請了社區傑出共建單位和開發者代表線下相聚，共鑑社區新進展、共享開源操作系統新技術、共研產業未來新趨勢。</span></span></p><div><p style="text-align:center"><img height="1280" src="https://oscimg.oschina.net/oscnet/up-95191a5aa9adb13597715074c98ca955469.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><em><span><strong><span style="color:#ffce73">01</span></strong></span></em></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#57b8f6">會議開場致辭</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社區理事、麒麟軟件總經理孔金珠在開場致辭中表示，過去一年裏，越來越多優秀的企業夥伴和開發者加入到 openKylin 開源大家庭中，為操作系統根技術創新奠定智囊基礎。在社區 400+生態夥伴和 5500+開發者的攜手共創下，openKylin 社區取得多項技術創新成果，實現了從系統效能、功能體驗、生態融合、應用開發等方面的全棧技術創新。此次會議是一次技術的交流，也是一次思想的碰撞，更是一次創新的啓程。希望通過交流和分享，碰撞出智慧的火花，進一步推動操作系統創新技術融合。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-5f02f52e732f362c83ecc5301f00c9bc212.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><em><span><strong><span style="color:#ffce73">02</span></strong></span></em></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#57b8f6">社區成果回顧</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社區生態委員會主任李震寧分享了 openKylin 進展成果及未來展望，李震寧表示，2023 年，在建立中國開源操作系統根社區的信念引領下，openKylin 社區匯聚了社會各界的產業力量、院士專家、高校師生、個人開發者，共同推動社區治理體系完善、社區產品打造、系統生態建設及使用體驗提升。openKylin 社區的快速發展，充分體現了開源作為一種創新的軟件協同生產模式所綻放的活力和無限潛能。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-08a7ee5efbc0ff067ea9d9b9ea7e78bc67e.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><ul><li><span><strong><span style="color:#000000">生態共建</span></strong><span style="color:#000000">方面，目前，openKylin 社區已匯聚了涵蓋操作系統、數據庫、辦公軟件、CPU、GPU、整機、人工智能等在內的 400+企業會員和 36 所研究型、教學型、應用型的各層次高等院校。</span></span></li><li><span><strong><span style="color:#000000">版本發佈</span></strong><span style="color:#000000">方面，openKylin 社區累計發佈 6 個版本，完成 20+核心組件選型工作，累計下載量超百萬。</span></span></li><li><span><strong><span style="color:#000000">創新演進</span></strong><span style="color:#000000">方面，成立 94 個 SIG 開展技術研究與創新，其中，開明包格式環境、wlcom 合成器、KARE 生態兼容、不可變系統和跨版本升級工具等社區最新重大技術成果都將融入到 openKylin 2.0 版本中，顛覆性創新帶來全新體驗。目前 openKylin 2.0 alpha 版本已發佈，面向開發者和嘗新用戶體驗。</span></span></li><li><span><strong><span style="color:#000000">智能融合</span></strong><span style="color:#000000">方面，發佈 openKylin AI 框架安裝助手，實現一鍵安裝 AI 框架，並在 openKylin 1.0 版本中實現支持桌面 AI 大模型插件和智能語音助手功能，從智能輸入、智能輸出兩方面入手，深度融合 AI 技術，推動桌面操作系統智能交互創新發展。</span></span></li><li><span><strong><span style="color:#000000">RISC-V 布</span></strong><span style="color:#000000">局方面，openKylin 社區正式加入 RISC-V 基金會，從源碼級別自主構建了 RISC-V 開源桌面操作系統版本成為其產業聯盟成員，支持 80% 以上市場主流 RISC-V 芯片，並攜手深度數智發佈全球首款 RISC-V 筆記本電腦 DC-ROMA。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">邁向 2024 年，openKylin 社區將立足新起點、實現新跨越。以開源、開放、平等、協作模式融智共創，為用戶及開發者創造全新體驗及價值。</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><em><span><strong><span style="color:#ffce73">03</span></strong></span></em></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#57b8f6">年度貢獻榜單揭曉</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社區的繁榮發展，離不開每一位貢獻者的辛勤付出。會上，openKylin 社區公佈了 2023 年度貢獻榜單並進行頒獎，以表彰在過去一年中為社區做出突出貢獻的傑出企業夥伴、高校共建先鋒、SIG 團隊和開發者菁英等。</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#888888">感謝每一位參與社區共建的小夥伴！歡迎更多企業、高校和開發者加入社區，共同打造中國開源操作系統根社區！以下為現場部分頒獎留影：</span></span></p><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-ec33487714ec154fceead05a87ff6e18c15.jpg" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-055afff730218da4aae68795a967a3d0076.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-28988997294bf968c922166fab67c3b46e8.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-538daf8e0d17bd318f74522b98e8a380362.jpg" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><em><span><strong><span style="color:#ffce73">04</span></strong></span></em></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#57b8f6">共建夥伴成果分享</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#000000">格蘭菲市場支持科主管嶽曉帥發表《格蘭菲 openKylin 社區會員開源實踐技術分享》主題演講，嶽曉帥表示，在加入 openKylin 社區後，格蘭菲積極參與社區共建，並加入社區 GPU SIG，目前已完成了 Arise1 平台與 openKylin 操作系統的兼容適配認證工作，並在功能、性能及兼容性方面表現優異。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-6caa8d88cb5fad2a0b4f66d85c5519373b4.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">信創海河實驗室副研究員王文竹發表《信創海河實驗室 openKylin 社區會員開源實踐分享》主題演講，王文竹表示，信創海河實驗室與 openKylin 社區在 RISC-V 版本共建、運營推廣和人才培養等方面有着緊密的合作關係。雙方攜手從源碼級別自主構建了 RISC-V 開源桌面操作系統版本，目前已實現 openKylin 對算能 RISC-V 產品的全方位支持，涵蓋了桌面環境、軟件生態、容器化部署和人工智能等多個關鍵領域。未來雙方將深化合作，共同推進 RISC-V 生態技術發展。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-488499cad322a4e5f7f7ca8e2efe730b22a.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">南開大學軟件學院團委書記王真發表《南開大學+openKylin: 共同推動開源社區國際化建設》主題演講，王真表示，南開大學軟件學院作為 openKylin 社區共建夥伴，創建了 InternationalPromotion SIG，負責對接 30+國家，103 位國外留學生開展相關國際化推廣工作，目前已開展四屆國際推廣交流活動，頒發尼泊爾、肯尼亞、塞拉利昂等 11 個國家星級推廣站點授權證書。未來，雙方將進一步攜手擴大國際項目交流圈，推動 openKylin 社區科技創新合作、技術推廣交流和成果轉化應用。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-a2b78bd919f34e066c3561280f2edccd3c0.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">儒特科技 CEO 馬鐵發表《QSFramework SIG 貢獻及成果分享》主題演講，儒特科技加入社區後，發起成立了 QSFramework SIG，SIG 團隊維護的開源項目青霜框架（QSFramework），是一款新形態、輕量化、微內核 Web 引擎。目前，已正式完成 QSFramework 與 openKylin 操作系統的兼容適配，並已發佈到 openKylin 2.0 軟件倉庫，感興趣的小夥伴可以下載體驗。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-09f68cf3fcaad8955597abd5839fa41d054.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">社區個人開發者孫聖博也分享了他與 openKylin 社區的結緣故事以及在社區的開源實踐之旅，孫聖博作為一名高中生，在加入社區後，發起成立了 Cutefish SIG 等，完成了 Cutefish 等桌面環境及相關組件與 openKylin 的兼容適配。同時，還積極參與社區 RISC-V 生態共建，併成立了 FAQ SIG，負責收集各渠道開發者、愛好者等用戶反饋的問題，建立相關標準化流程推動問題解答或解決。孫聖博的發言引發陣陣掌聲，讓更多的開發者感受到了開源的魅力與活力。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-b66fe15ad20ef69fcfdceeb97f16025fe9d.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><em><span><strong><span style="color:#ffce73">05</span></strong></span></em></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#57b8f6">會議落幕致辭</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社區生態委員會主任李震寧在總結致辭中提到，過去一年，正是有了大家的共同努力，openKylin 才能取得今天的靚麗成績。在 openKylin 社區，各界夥伴都可以在開源、開放、協作的模式下，基於產業發展現狀、院校科研積累和開發者實踐經驗等，開放自由的交流想法與建議，並進行實踐、檢驗與完善。通過本次會議，不僅加深了社區與企業夥伴、社區與個人開發者之間的瞭解，也為 openKylin 的發展提供了新的思路和方向。</span></span></p><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-55cfd98b21f0d69d4c5e8f11a5b09378305.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-863b3b1f00649033bd11bb0edd70ec04d76.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">展望未來，openKylin 社區也將持續把握髮展機遇，聚焦操作系統根技術，發揮社區平台支撐作用，聚合產、學、研、用及國內外開源力量，加速系統創新迭代，共同推動 openKylin 開源操作系統根社區構建，為推動形成眾研眾用眾創的開源軟件生態添磚加瓦，逐步走向同國際頂尖開源社區比肩的星辰大海。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 06:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272582</guid>
            <link>https://www.oschina.net/news/272582</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
