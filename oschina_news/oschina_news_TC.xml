<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Sun, 14 Jan 2024 19:10:20 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[2024 技術招聘狀況：AI 工具被視為作弊，Python 需求最大]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">技術招聘平台 CoderPad 最新發布了一份「<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcoderpad.io%2Fsurvey-reports%2Fcoderpad-and-codingame-state-of-tech-hiring-2024%2F" target="_blank">State of Tech Hiring 2024</a>」報告，基於來自 149 個不同國家/地區的 13,000 多名開發者、以及 143 個國家/地區約 5500 名 HR 人員的反饋。研究了開發人員對工作的期望和需求、技術招聘流程的演變以及 2024 年開發人員招聘優先事項和潛在障礙。</span></p><p><span style="color:#000000">報告指出，70% 的開發人員認為 AI 將有助於減少他們的工作量，並列舉了一些好處：代碼輔助、學習和教程、自動完成/代碼生成以及文檔和 API 支持等。ChatGPT 是最常用的 AI 工具，其他的還包括 Copilot、Bard、Bing AI 等。60% 的開發人員希望在工作中更多地使用 AI。</span></p><p><span style="color:#000000">但也有 33% 的受訪開發人員表示在工作中不使用任何 AI 工具：其中 29% 是因為本人不信任該技術，28% 的是因為僱主反對；四分之一的開發人員認為 AI 不可靠或效率低下。43% 的受訪者表示對 AI 所帶來的影響持樂觀態度；23% 的人持懷疑態度，還有 6% 甚至擔心這項技術會影響其職業或工作前景。</span></p><p><span style="color:#000000">值得一提的是，儘管有 67% 的開發者和 38% 的 HR 表示已經在工作中使用了 AI 工具，但對於招聘過程中 AI 工具的使用卻還存在一些爭議。近四分之一（23%）的 HR 認為面試者使用 AI 工具屬於作弊。只有 8% 的公司鼓勵在招聘過程中使用 AI，48% 的受訪者表示它的可接受性取決於使用情況。</span></p><p><span style="color:#000000">只有 19% 的開發人員會在招聘過程中公開使用 AI，還有三分之一的開發人員認為在面試或技術測試中使用 AI 工具是一種作弊行為。</span></p><p><span style="color:#000000">在被問及知名度以及招聘中需求最高的<strong>編程語言</strong>時，排名前十的分別是：Python、JavaScript、Java、C#、SQL、C++、TypeScript、HTML CSS、PHP、C。知名度和需求最高的框架則是 React 和 Node.js。</span></p><p><img height="1112" src="https://oscimg.oschina.net/oscnet/up-159c837d701bf90f73a6c17dbfc39c4cf78.png" width="500" referrerpolicy="no-referrer"></p><p>其他的一些發現還包括：</p><ul><li><span style="color:#000000">36% 的開發人員表示對承擔管理職責不感興趣。</span></li><li><span style="color:#000000">開發人員還希望有機會在工作中磨練自己的技術技能，其中最想學習的三項技能分別是 Web 開發、機器學習/深度學習和遊戲開發。</span></li><li><span style="color:#000000">全棧、後端和前端開發人員仍然是需求最大的崗位。此外，還有 21% 的組織希望在 2024 年聘請 ML/AI 專家，去年的這一比例為 18%。</span></li><li><span style="color:#000000">開發人員對工作安全的擔憂與日俱增，21% 的人表示，與一年前相比，他們的工作安全感降低了（去年為 17%）。37% 的人表示在過去 12 個月中沒有明顯變化，32% 的人表示感覺更有安全感。</span></li><li><span style="color:#000000">近一半的開發人員考慮在未來 12 個月內離職。</span></li></ul><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcoderpad.io%2Fsurvey-reports%2Fcoderpad-and-codingame-state-of-tech-hiring-2024%2F" target="_blank">查看完整報告</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 14 Jan 2024 03:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275663/state-of-tech-hiring-2024</guid>
            <link>https://www.oschina.net/news/275663/state-of-tech-hiring-2024</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Git 開發人員討論引入 Rust 的可能性]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Git 開發人員正討論在其代碼庫中使用 Rust 編程語言，以補充現有的 C 和 Python 語言的想法。</p><blockquote><p>去年年底的假期我花了一些時間思考如何將 Rust 引入 Git 項目。</p><p>將 Rust 引入 Linux 內核的工作正在緊鑼密鼓地進行中（見 [1]、[2]）。在他們既定的目標中，我認為有幾個這可能與 Git 項目潛在相關：</p><ul><li>降低內存安全錯誤、數據爭用、內存泄漏等風險。 得益於該語言的安全保證。</li><li>在 Rust 中重構或引入新代碼時更容易（假設幾乎不使用語言的「不安全」功能）。</li><li>通過使用更現代的語言，為 Git 做貢獻變得更容易，也更容易為更多程序員所使用。</li></ul><p>鑑於這些優勢的誘惑力，我認為至少值得考慮和討論如何讓 Rust 進入 Junio 的樹中。</p></blockquote><p><img height="296" src="https://oscimg.oschina.net/oscnet/up-89b0fcaa21f05d837885d3b9e645f5dcb9c.png" width="300" referrerpolicy="no-referrer"></p><p>然而，雖然 Rust 的內存安全特性對許多人來説是個利好，但 Git 開發者的反應卻好壞參半。部分<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FGCC-Rust-Developer-Discussion" target="_blank">原因是</a> Git 廣泛應用於多種不同的平台和 CPU 架構。目前，使用 Rust 幾乎必須使用基於 LLVM 的 rustc 編譯器。雖然 GCC 編譯器等正在努力添加可用的 Rust 支持，但目前這些替代方案還沒有投入生產。因此，如果 Rust 代碼被強制使用，Git 的使用可能會受到限制，否則他們可能不得不在初期將基於 Rust 的 Git 功能作為可選項。&nbsp;</p><p>更多詳情可以通過此<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Fgit%2FCALNs47s3tUQoOD4ejdoTn6y12ywjL0j5hWU-fUnBLe_o3vV5SQ%40mail.gmail.com%2FT%2F" target="_blank">郵件列表線程</a>進行了解。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 14 Jan 2024 03:18:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275659/git-rust-discussion</guid>
            <link>https://www.oschina.net/news/275659/git-rust-discussion</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Motūrus OS —— 適用於 x64 虛擬機的 Rust 優先操作系統]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Motūrus 項目為雲構建了一個簡單、快速、安全的操作系統（Motūrus OS）。</p><p>更具體地説，Motūrus OS（有時也稱作 Motor OS）是一種新的操作系統，針對基於虛擬機的工作負載，如網絡服務、"無服務器"、邊緣緩存等。</p><p>Motūrus OS 是基於 Rust 的微內核操作系統，專門針對虛擬化工作負載。它目前支持基於 x64 KVM 的虛擬機，可在 Qemu 或 Cloud Hypervisor 中運行。</p><p><img alt="" height="559" src="https://static.oschina.net/uploads/space/2024/0108/153945_gPrH_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Sun, 14 Jan 2024 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/motor-os</guid>
            <link>https://www.oschina.net/p/motor-os</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 捕獲數據更改 (CDC) 平台 Debezium]]>
            </title>
            <description>
                <![CDATA[<p><a href="https://gitee.com/link?target=http%3A%2F%2Fwww.apache.org%2Flicenses%2FLICENSE-2.0.html"><img src="http://img.shields.io/:license-apache%202.0-brightgreen.svg" alt="License" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=http%3A%2F%2Fsearch.maven.org%2F%23search%257Cga%257C1%257Cg%253A%2522io.debezium%2522"><img src="https://maven-badges.herokuapp.com/maven-central/io.debezium/debezium-parent/badge.svg" alt="Maven Central" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdebezium.zulipchat.com%2F%23narrow%2Fstream%2F302529-users"><img src="https://img.shields.io/badge/chat-users-brightgreen.svg" alt="User chat" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdebezium.zulipchat.com%2F%23narrow%2Fstream%2F302533-dev"><img src="https://img.shields.io/badge/chat-devs-brightgreen.svg" alt="Developer chat" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgroups.google.com%2Fforum%2F%23%21forum%2Fdebezium"><img src="https://img.shields.io/:mailing%20list-debezium-brightgreen.svg" alt="Google Group" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=http%3A%2F%2Fstackoverflow.com%2Fquestions%2Ftagged%2Fdebezium"><img src="http://img.shields.io/:stack%20overflow-debezium-brightgreen.svg" alt="Stack Overflow" referrerpolicy="no-referrer"></a></p><p>Copyright Debezium Authors.
Licensed under the <a href="https://gitee.com/link?target=http%3A%2F%2Fwww.apache.org%2Flicenses%2FLICENSE-2.0">Apache License, Version 2.0</a>.
The Antlr grammars within the debezium-ddl-parser module are licensed under the <a href="https://gitee.com/link?target=https%3A%2F%2Fopensource.org%2Flicenses%2FMIT">MIT License</a>.</p><p>中文 | <a href="https://gitee.com/opengauss/debezium/blob/master/README.md">English</a> | <a href="https://gitee.com/opengauss/debezium/blob/master/README_JA.md">Japanese</a></p><h1><a id="user-content-debezium-簡介" class="anchor" href="https://gitee.com/opengauss/debezium#debezium-%E7%AE%80%E4%BB%8B"></a>Debezium 簡介</h1><p>Debezium 是一個開源項目，為捕獲數據更改 (change data capture,CDC) 提供了一個低延遲的流式處理平台。你可以安裝並且配置 Debezium 去監控你的數據庫，然後你的應用就可以消費對數據庫的每一個行級別 (row-level) 的更改。只有已提交的更改才是可見的，所以你的應用不用擔心事務 (transaction) 或者更改被回滾 (roll back)。Debezium 為所有的數據庫更改事件提供了一個統一的模型，所以你的應用不用擔心每一種數據庫管理系統的錯綜複雜性。另外，由於 Debezium 用持久化的、有副本備份的日誌來記錄數據庫數據變化的歷史，因此，你的應用可以隨時停止再重啓，而不會錯過它停止運行時發生的事件，保證了所有的事件都能被正確地、完全地處理掉。</p><p>監控數據庫，並且在數據變動的時候獲得通知一直是很複雜的事情。關係型數據庫的觸發器可以做到，但是隻對特定的數據庫有效，而且通常只能更新數據庫內的狀態 (無法和外部的進程通信)。一些數據庫提供了監控數據變動的 API 或者框架，但是沒有一個標準，每種數據庫的實現方式都是不同的，並且需要大量特定的知識和理解特定的代碼才能運用。確保以相同的順序查看和處理所有更改，同時最小化影響數據庫仍然非常具有挑戰性。</p><p>Debezium 提供了模塊為你做這些複雜的工作。一些模塊是通用的，並且能夠適用多種數據庫管理系統，但在功能和性能方面仍有一些限制。另一些模塊是為特定的數據庫管理系統定製的，所以他們通常可以更多地利用數據庫系統本身的特性來提供更多功能。</p><h2><a id="user-content-debezium 基礎架構" class="anchor" href="https://gitee.com/opengauss/debezium#debezium%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"></a>Debezium 基礎架構</h2><p>Debezium 是一個捕獲數據更改 (CDC) 平台，並且利用 Kafka 和 Kafka Connect 實現了自己的持久性、可靠性和容錯性。每一個部署在 Kafka Connect 分佈式的、可擴展的、容錯性的服務中的 connector 監控一個上游數據庫服務器，捕獲所有的數據庫更改，然後記錄到一個或者多個 Kafka topic(通常一個數據庫表對應一個 kafka topic)。Kafka 確保所有這些數據更改事件都能夠多副本並且總體上有序 (Kafka 只能保證一個 topic 的單個分區內有序)，這樣，更多的客戶端可以獨立消費同樣的數據更改事件而對上游數據庫系統造成的影響降到很小 (如果 N 個應用都直接去監控數據庫更改，對數據庫的壓力為 N，而用 debezium 彙報數據庫更改事件到 kafka，所有的應用都去消費 kafka 中的消息，可以把對數據庫的壓力降到 1)。另外，客戶端可以隨時停止消費，然後重啓，從上次停止消費的地方接着消費。每個客戶端可以自行決定他們是否需要 exactly-once 或者 at-least-once 消息交付語義保證，並且所有的數據庫或者表的更改事件是按照上游數據庫發生的順序被交付的。</p><p>對於不需要或者不想要這種容錯級別、性能、可擴展性、可靠性的應用，他們可以使用內嵌的 Debezium connector 引擎來直接在應用內部運行 connector。這種應用仍需要消費數據庫更改事件，但更希望 connector 直接傳遞給它，而不是持久化到 Kafka 裏。</p><h2><a id="user-content-常見使用場景" class="anchor" href="https://gitee.com/opengauss/debezium#%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"></a>常見使用場景</h2><p>Debezium 有很多非常有價值的使用場景，我們在這兒僅僅列出幾個更常見的使用場景。</p><h3><a id="user-content-緩存失效 cache-invalidation" class="anchor" href="https://gitee.com/opengauss/debezium#%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88cache-invalidation"></a>緩存失效 (Cache invalidation)</h3><p>在緩存中緩存的條目 (entry) 在源頭被更改或者被刪除的時候立即讓緩存中的條目失效。如果緩存在一個獨立的進程中運行 (例如 Redis，Memcache，Infinispan 或者其他的)，那麼簡單的緩存失效邏輯可以放在獨立的進程或服務中，從而簡化主應用的邏輯。在一些場景中，緩存失效邏輯可以更復雜一點，讓它利用更改事件中的更新數據去更新緩存中受影響的條目。</p><h3><a id="user-content-簡化單體應用 simplifying-monolithic-applications" class="anchor" href="https://gitee.com/opengauss/debezium#%E7%AE%80%E5%8C%96%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8simplifying-monolithic-applications"></a>簡化單體應用 (Simplifying monolithic applications)</h3><p>許多應用更新數據庫，然後在數據庫中的更改被提交後，做一些額外的工作：更新搜索索引，更新緩存，發送通知，運行業務邏輯，等等。這種情況通常稱為雙寫 (dual-writes)，因為應用沒有在一個事務內寫多個系統。這樣不僅應用邏輯複雜難以維護，而且雙寫容易丟失數據或者在一些系統更新成功而另一些系統沒有更新成功的時候造成不同系統之間的狀態不一致。使用捕獲更改數據技術 (change data capture,CDC)，在源數據庫的數據更改提交後，這些額外的工作可以被放在獨立的線程或者進程 (服務) 中完成。這種實現方式的容錯性更好，不會丟失事件，容易擴展，並且更容易支持升級。</p><h3><a id="user-content-共享數據庫 sharing-databases" class="anchor" href="https://gitee.com/opengauss/debezium#%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%BA%93sharing-databases"></a>共享數據庫 (Sharing databases)</h3><p>當多個應用共用同一個數據庫的時候，一個應用提交的更改通常要被另一個應用感知到。一種實現方式是使用消息總線，儘管非事務性 (non-transactional) 的消息總線總會受上面提到的雙寫 (dual-writes) 影響。但是，另一種實現方式，即 Debezium，變得很直接：每個應用可以直接監控數據庫的更改，並且響應更改。</p><h3><a id="user-content-數據集成 data-integration" class="anchor" href="https://gitee.com/opengauss/debezium#%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90data-integration"></a>數據集成 (Data integration)</h3><p>數據通常被存儲在多個地方，尤其是當數據被用於不同的目的的時候，會有不同的形式。保持多系統的同步是很有挑戰性的，但是可以通過使用 Debezium 加上簡單的事件處理邏輯來實現簡單的 ETL 類型的解決方案。</p><h3><a id="user-content-命令查詢職責分離 cqrs" class="anchor" href="https://gitee.com/opengauss/debezium#%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBcqrs"></a>命令查詢職責分離 (CQRS)</h3><p>在命令查詢職責分離 <a href="https://gitee.com/link?target=http%3A%2F%2Fmartinfowler.com%2Fbliki%2FCQRS.html">Command Query Responsibility Separation (CQRS)</a> 架構模式中，更新數據使用了一種數據模型，讀數據使用了一種或者多種數據模型。由於數據更改被記錄在更新側 (update-side)，這些更改將被處理以更新各種讀展示。所以 CQRS 應用通常更復雜，尤其是他們需要保證可靠性和全序 (totally-ordered) 處理。Debezium 和 CDC 可以使這種方式更可行：寫操作被正常記錄，但是 Debezium 捕獲數據更改，並且持久化到全序流裏，然後供那些需要異步更新只讀視圖的服務消費。寫側 (write-side) 表可以表示面向領域的實體 (domain-oriented entities)，或者當 CQRS 和 <a href="https://gitee.com/link?target=http%3A%2F%2Fmartinfowler.com%2FeaaDev%2FEventSourcing.html">Event Sourcing</a> 結合的時候，寫側表僅僅用做追加操作命令事件的日誌。</p><h2><a id="user-content-building-debezium" class="anchor" href="https://gitee.com/opengauss/debezium#building-debezium"></a>Building Debezium</h2><p>使用 Debezium 代碼庫並在本地配置它需要以下軟件：</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgit-scm.com">Git</a> 2.2.1 or later</li><li>JDK 11 or later, e.g. <a href="https://gitee.com/link?target=http%3A%2F%2Fopenjdk.java.net%2Fprojects%2Fjdk%2F">OpenJDK</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fmaven.apache.org%2Findex.html">Apache Maven</a> 3.6.3 or later</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fdocs.docker.com%2Fengine%2Finstall%2F">Docker Engine</a> or <a href="https://gitee.com/link?target=https%3A%2F%2Fdocs.docker.com%2Fdesktop%2F">Docker Desktop</a> 1.9 or later</li></ul><p>有關平台上的安裝説明，請參閲上面的鏈接。您可以通過以下指令查看安裝版本</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ git --version</span><span id="LC2" class="line">$ javac -version</span><span id="LC3" class="line">$ mvn -version</span><span id="LC4" class="line">$ docker --version</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-為什麼選用-docker" class="anchor" href="https://gitee.com/opengauss/debezium#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E7%94%A8-docker"></a>為什麼選用 Docker?</h3><p>許多開源軟件項目使用 Git、Java 和 Maven，但需要 Docker 的情況不太常見。Debezium 被設計用來與許多外部系統進行通信，比如各種數據庫和服務，我們的集成測試驗證了 Debezium 成功地做到了這一點。但 Debezium 的構建系統使用 Docker 自動下載或創建必要的映像，併為每個系統啓動容器，而不是期望您在本地安裝所有這些軟件系統。然後，集成測試可以使用這些服務並驗證 Debezium 的行為是否符合預期，當集成測試完成時，Debezium 將自動停止它啓動的所有容器.</p><p>Debezium 還有一些不是用 Java 編寫的模塊，因此它們必須在目標操作系統上使用。Docker 讓我們的構建使用目標操作系統的映像和所有必要的開發工具來完成。</p><p>使用 Docker 有幾個優點：</p><ol><li>不需要在本地計算機上安裝、配置和運行每個所依賴的外部服務的特定版本，也不必在本地網絡上訪問它們。即使配置了，Debezium 也不會用到它們。</li><li>我們可以測試外部服務的多個版本。每個模塊可以啓動它需要的任何容器，因此不同的模塊可以輕鬆地使用不同版本的服務。</li><li>每個人都可以在本地運行完整的構建。 不必依賴遠程持續集成服務器在設置了所有必需服務的環境中運行構建。</li><li>所有構建都是一致的。當多個開發人員各自構建相同的代碼庫時，他們應該看到完全相同的結果——只要他們使用相同或等效的 JDK、Maven 和 Docker 版本。這是因為容器將在相同的操作系統上運行相同版本的服務。另外，所有的測試都是為了連接到運行在容器中的系統而設計的，因此沒有人需要修改連接屬性或特定於其本地環境的自定義配置。</li><li>不需要清理服務, 即使這些服務在本地修改和存儲數據. Docker <em>images</em> 被緩存, 所以 reusing 服務可以快速的啓動容器並保持一致性, 但是 Docker <em>containers</em> 永遠不會被重用：它們總是在原始的初始狀態下啓動，在關閉時被丟棄。集成測試依賴於容器，因此清理是自動處理的</li></ol><h3><a id="user-content-配置 docker 環境" class="anchor" href="https://gitee.com/opengauss/debezium#%E9%85%8D%E7%BD%AEdocker%E7%8E%AF%E5%A2%83"></a>配置 Docker 環境</h3><p>Docker Maven 插件通過檢查以下環境變量來解析 Docker 主機：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">export DOCKER_HOST=tcp://10.1.2.2:2376</span><span id="LC2" class="line">export DOCKER_CERT_PATH=/path/to/cdk/.vagrant/machines/default/virtualbox/.docker</span><span id="LC3" class="line">export DOCKER_TLS_VERIFY=1</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>Docker 類似的容器可以自動配置這些參數。</p><h3><a id="user-content-項目編譯" class="anchor" href="https://gitee.com/opengauss/debezium#%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91"></a>項目編譯</h3><p>首先從 Git 存儲庫獲取代碼：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ git clone https://github.com/debezium/debezium.git</span><span id="LC2" class="line">$ cd debezium</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>用 maven 構建項目
$ mvn clean install</p><p>為不同的 dbms 使用不同的容器構建。請注意，如果 Docker 未運行或未配置，則可能會出現一個神祕的錯誤——如果是這種情況，請始終驗證 Docker 是否正在運行，也許可以使用 Docker ps 列出正在運行的容器。</p><h3><a id="user-content-本地沒有 docker" class="anchor" href="https://gitee.com/opengauss/debezium#%E6%9C%AC%E5%9C%B0%E6%B2%A1%E6%9C%89docker"></a>本地沒有 Docker?</h3><p>您可以使用以下命令跳過集成測試和 docker 來構建項目：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ mvn clean install -DskipITs</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-使用 wal2json 或-pgoutput-logical-decoding-plug-ins-運行 postgres-connector 的測試" class="anchor" href="https://gitee.com/opengauss/debezium#%E4%BD%BF%E7%94%A8wal2json%E6%88%96-pgoutput-logical-decoding-plug-ins-%E8%BF%90%E8%A1%8Cpostgres-connector%E7%9A%84%E6%B5%8B%E8%AF%95"></a>使用 wal2json 或 pgoutput logical decoding plug-ins 運行 Postgres connector 的測試</h3><p>Postgres 連接器支持三個邏輯解碼插件，用於從 DB 服務器到連接器的流式更改：decoderbufs（默認）、wal2json 和 pgoutput。要使用 wal2json 運行 PG connector 的集成測試，請啓用「wal2json decoder」構建配置文件：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ mvn clean install -pl :debezium-connector-postgres -Pwal2json-decoder</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>要使用 pgoutput 運行 PG connector 的集成測試，請啓用「pgoutput decoder」和「postgres-10」構建配置文件：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ mvn clean install -pl :debezium-connector-postgres -Ppgoutput-decoder,postgres-10</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>在使用 wal2json 插件時，一些測試目前無法通過。</p><p>查找對<code>io.debezium.connector.postgresql.DecoderDifferences</code>中定義的類型的引用以找到這些測試。</p><h3><a id="user-content-對外部數據庫運行 postgres 連接器的測試-例如 amazon-rds" class="anchor" href="https://gitee.com/opengauss/debezium#%E5%AF%B9%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E8%A1%8Cpostgres%E8%BF%9E%E6%8E%A5%E5%99%A8%E7%9A%84%E6%B5%8B%E8%AF%95-%E4%BE%8B%E5%A6%82amazon-rds"></a>對外部數據庫運行 Postgres 連接器的測試, 例如：Amazon RDS</h3><p>如果您要針對非 RDS 集羣進行測試，請注意須是超級用戶，不僅要具有複製權限，而且還要有登錄 pg_hba.conf 中所有數據庫的權限。它還要求目標服務器上必須有 <em>postgis</em> 包，才能通過某些測試。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ mvn clean install -pl debezium-connector-postgres -Pwal2json-decoder \</span><span id="LC2" class="line">     -Ddocker.skip.build=true -Ddocker.skip.run=true -Dpostgres.host=&lt;your PG host&gt; \</span><span id="LC3" class="line">     -Dpostgres.user=&lt;your user&gt; -Dpostgres.password=&lt;your password&gt; \</span><span id="LC4" class="line">     -Ddebezium.test.records.waittime=10</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>根據需要調整超時值。</p><p>有關在 RDS 上設置要測試的數據庫的詳細信息，請參閲 <a href="https://gitee.com/opengauss/debezium/blob/master/debezium-connector-postgres/RDS.md">PostgreSQL on Amazon RDS</a></p><h2><a id="user-content-貢獻源碼 contributing" class="anchor" href="https://gitee.com/opengauss/debezium#%E8%B4%A1%E7%8C%AE%E6%BA%90%E7%A0%81contributing"></a>貢獻源碼 (Contributing)</h2><p>Debezium 社區歡迎任何願意以任何方式提供幫助的人，無論是報告問題、幫助文檔，還是提供代碼更改以修復錯誤、添加測試或實現新功能。有關詳細信息，請參閲本<a href="https://gitee.com/opengauss/debezium/blob/master/CONTRIBUTE.md">文檔</a>。</p>]]>
            </description>
            <pubDate>Sun, 14 Jan 2024 02:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/opengauss/debezium</guid>
            <link>https://gitee.com/opengauss/debezium</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 得物 SRE 視角下的藍綠髮布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1>一、前言</h1><p style="color:#24292f; text-align:start">發佈變更是影響穩定性的一個重大因素，為了發佈異常時能快速回滾，增加發布期間的穩定性，也為瞭解決多服務部署時互相依賴而導致的發佈時間增長等問題，得物在今年引入一種新的發佈模式--藍綠髮布。這種發佈模式帶來了穩定性和效率的提升，這裏我們以 SRE 的視角來解讀下得物的藍綠髮布。</p><span id="OSC_h1_2"></span><h1>二、常見的發佈形式有哪些？分別有什麼優勢？</h1><span id="OSC_h2_3"></span><h2>全量發佈</h2><p style="color:#24292f; text-align:start">全量發佈是早期企業進行系統升級的一種方式，因為早期的服務大多為大型機，單實例程序為主。並沒有形成當下流行的微服務架構，因此當發佈時往往需要停機發布。生產環境禁止使用這種方式進行部署！</p><span id="OSC_h2_4"></span><h2>滾動發佈</h2><p style="color:#24292f; text-align:start">滾動發佈顧名思義，假如生產中 16 台機器，我們可以分成 4 批。每批 4 台機器，每批機器執行更新，從版本 V1 更新為 V2，更新後重新將其投入使用，連續不斷的更新其他機器，直到集羣中所有的實例都更新為版本 B 後，結束髮布。</p><p style="color:#24292f; text-align:start">這種方式的好處就是更新過程體驗影響少，費用開銷也少，發佈期間無需額外新增機器。但是缺點也同樣明顯，一旦開始發佈後，回滾時長很久，在多個有關聯的服務部署時，需要上游服務完全發佈後，才能發佈下游服務，整體發佈時間也很長。</p><p style="color:#24292f; text-align:start"><strong>滾動發佈流程演示：</strong></p><p style="color:#24292f; text-align:start"><img alt="640.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/640.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><img alt="2.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/2.png" referrerpolicy="no-referrer"></p><span id="OSC_h2_5"></span><h2>藍綠髮布</h2><p style="color:#24292f; text-align:start">通常意義上的藍綠髮布一般是將服務分為兩組，藍組和綠組，正常運轉的情況下每組承載 50% 的流量。當準備發佈服務時, 將藍組流量設置為 0%，將綠組空閒出來，將服務部署到綠組的機器，然後利用 SLB 將流量切換到綠組的機器，讓綠組來運行業務，沒問題的話流量全部導向綠組，把藍組也進行服務更新。</p><p style="color:#24292f; text-align:start">傳統意義上的藍綠髮布優點在於發佈策略簡單，對於用戶幾乎無感知，可以實現平滑過度，在發佈期間發現問題後也可以快速的回滾。而缺點則是通常需要準備正常業務使資源倆倍以上的服務器，需要投入較大的資源成本。</p><p style="color:#24292f; text-align:start"><strong>藍綠髮布流程演示：</strong></p><p style="color:#24292f; text-align:start">切除綠集羣流量：</p><p style="color:#24292f; text-align:start"><img alt="12.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/12.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">當 A 組升級完畢，負載均衡重新接入 A 組，再把 B 組從負載列表中摘除，進行新版本的部署，A 組重新提供服務。</p><p style="color:#24292f; text-align:start"><img alt="13.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/13.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">最後，B 組也升級完成，負載均衡重新接入 B 組，此時，AB 組版本都已經升級完成，並且都對外提供服務。</p><span id="OSC_h2_6"></span><h2>灰度發佈</h2><p style="color:#24292f; text-align:start">灰度發佈，也被叫作金絲雀發佈。與藍綠部署、紅黑部署不同的是，<strong>灰度發佈屬於增量發佈方法</strong>。也就是説，服務升級的過程中，新舊版本會同時為用戶提供服務。</p><p style="color:#24292f; text-align:start">灰度發佈的具體流程是這樣的：在集羣的一小部分機器上部署新版本，給一部分用戶使用，以測試新版本的功能和性能；確認沒有問題之後，再對整個集羣進行升級。簡單地説，灰度發佈就是把部署好的服務分批次、逐步暴露給越來越多的用戶，直到最終完全上線。</p><p style="color:#24292f; text-align:start"><img alt="23.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/23.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">之所以叫作<strong>灰度發佈</strong>，是因為它介於黑與白之間，並不是版本之間的直接切換，而是一個平滑過渡的過程。</p><p style="color:#24292f; text-align:start">AB Test 就是一種灰度發佈方式，讓一部分用戶繼續用 A，一部分用戶開始用 B，如果用戶對 B 沒有什麼反對意見，那麼逐步擴大範圍，把所有用戶都遷移到 B 上面來。灰度發佈可以保證整體系統的穩定，在初始灰度的時候就可以發現並調整問題，以保證其影響度，而我們平常所説的金絲雀部署也就是灰度發佈的一種方式。</p><p style="color:#24292f; text-align:start">之所以又被叫作金絲雀發佈，是因為金絲雀對瓦斯極其敏感，17 世紀時英國礦井工人會攜帶金絲雀下井，以便及時發現危險。這就與灰色發佈過程中，先發布給一部分用戶來測試相似，因而得名。</p><p style="color:#24292f; text-align:start"><img alt="0.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/0.jpeg" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">對於灰度發佈來説，它的優點在於<span>&nbsp;</span><strong>如果前期出問題影響範圍很小，相對用戶體驗也少；可以做到及時發現、及時調整問題，影響範圍可控。</strong><span>&nbsp;</span>但是採取這種模式對自動化以及運維監控能力的要求非常高。</p><span id="OSC_h1_7"></span><h1>三、得物的藍綠布是如何實現的？</h1><p style="color:#24292f; text-align:start">前面講了「what」，我們現在來説下「how」。</p><p style="color:#24292f; text-align:start">在平時，我們也會保留藍綠兩個集羣，在發佈時，引入灰度的流量平滑過度，幫助我們完成整個發佈過程，下面以 SRE 的視角大致講一下藍綠髮布的架構與流程。</p><span id="OSC_h2_8"></span><h2>藍綠髮布的流程</h2><p style="color:#24292f; text-align:start">在這種架構下，整體的發佈流程如下：</p><ul><li><strong>日常流量</strong></li></ul><p style="color:#24292f; text-align:start">在未發佈時，我們接入藍綠髮布的服務是平均分成藍綠倆個集羣的。平時通過網關均勻切分流量，平均每個集羣 50% 的流量。</p><p style="color:#24292f; text-align:start"><img alt="9.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/9.png" referrerpolicy="no-referrer"></p><ul><li><strong>開始發佈</strong></li></ul><p style="color:#24292f; text-align:start">當進行藍綠髮布時，我們將需要發佈的應用創建在一個通道中 (這裏先説下只有一個通道部署的情況)。</p><p style="color:#24292f; text-align:start"><img alt="09.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/09.png" referrerpolicy="no-referrer"></p><ul><li><strong>藍集羣 (右側) 摘流</strong></li></ul><p style="color:#24292f; text-align:start">此時所有流量將只訪問綠集羣，如下圖所示，當藍集羣摘流完成後, 此時集羣沒有任何流量，即可進行部署。</p><p style="color:#24292f; text-align:start"><img alt="8.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/8.png" referrerpolicy="no-referrer"></p><ul><li><strong>藍集羣 (右側) 引流</strong></li></ul><p style="color:#24292f; text-align:start">當藍集羣發佈完成後，我們需要對藍集羣發佈後的服務進行確認。在確認部署成功後，則梯度的將流量引入更新後代碼的藍集羣 (右側)，最開始我們會切 1% 的流量，切流量後，我們可以在線上觀察藍服務的流量、錯誤率等。以此觀測發佈的版本是否有異常。之後，我們逐漸將流量切回 50%。注意，需要確保相關缺陷都在該環節暴露出來，因為這個環節另一半老版本的、穩定的代碼還在 Standby，可以隨時操作流量比例，進行流量遷移。</p><p style="color:#24292f; text-align:start"><img alt="7.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/7.jpeg" referrerpolicy="no-referrer"></p><blockquote><p>發佈過程中，藍、綠節點間流量不會互竄 (對比上圖，藍綠集羣間斜向箭頭沒有了)。 此階段需要注意 MQ 流量，因為 MQ 當前無法按比例進行切分，因此一旦開始切流，則 MQ 流量會恢復為 50%/50%。</p></blockquote><ul><li><strong>綠集羣 (左側) 摘流</strong></li></ul><p style="color:#24292f; text-align:start">通過擴大流量比例，流量全部切到藍集羣，這個階段流量已全部切到新代碼，可以讓測試同學介入進行新功能驗證以及迴歸測試。</p><p style="color:#24292f; text-align:start">在這個階段只要綠集羣還沒發佈，發現問題，仍然可以全部切回老代碼！</p><p style="color:#24292f; text-align:start">當測試驗證完成後，即可進行綠集羣發佈。發佈後則不可以回切了！就算要代碼回滾，也得等本次發佈結束後,再單獨對服務進行回滾。</p><p style="color:#24292f; text-align:start"><img alt="67.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/67.png" referrerpolicy="no-referrer"></p><ul><li><strong>綠集羣 (左側) 引流</strong></li></ul><p style="color:#24292f; text-align:start">在發佈後則開始進入綠集羣引流了，此時可以快速引流，因為已經沒有可以回滾的、穩定版本的代碼了。同樣，還在發佈階段，及時流量均衡，也不會出現互相交叉的流量。</p><p style="color:#24292f; text-align:start"><img alt="34.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/34.png" referrerpolicy="no-referrer"></p><ul><li><strong>發佈完成</strong></li></ul><p style="color:#24292f; text-align:start">發佈完成後，則去除通道，藍綠集羣可以繼續進行交互。</p><p style="color:#24292f; text-align:start"><img alt="32.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/32.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">如上圖所示，使用以上發佈流程具備以下好處：</p><ul><li><p>整個發佈過程是以藍、綠<strong>集羣維度</strong>並行調度、實施的，通過發佈平台統一操作，摘流，無需各業務域各自處理。</p></li><li><p>通過請求藍綠粘性，讓下游應用的新老版本代碼可以同時存在，無需阻塞等待下游應用全部升級到新代碼，解除了批次依賴。</p></li><li><p>發佈過程中有靈活的流量控制能力，可以按 1%、50% 等階梯流量驗證應用。</p></li><li><p>上述發佈流程，可以同時並存若干個，摘流、引流動作互不影響<span>&nbsp;</span><strong>(多發佈通道)</strong>。</p></li></ul><span id="OSC_h2_9"></span><h2>藍綠髮布的架構</h2><ol><li><strong>應用架構 [1]</strong></li></ol><p style="color:#24292f; text-align:start"><img alt="45.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/45.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>1.1 流量規則 SDK</strong></p><p style="color:#24292f; text-align:start">在所有需要接入藍綠髮布的程序中，首先需要升級流量規則 SDK，流量規則 SDK 是應用藍綠髮布能力的代碼底座，向中間件組件如 RPC、MQ、JOB 提供了主動查詢流量規則和被動接受流量規則變更事件的能力，各中間件組件響應流量規則進行合適的動作，實現各類型流量的動態摘流、動態引流。</p><p style="color:#24292f; text-align:start"><strong>1.2 核心能力</strong></p><ul><li><p>依賴配置中心做持久化存儲與事件推送。</p></li><li><p>所有配置讀取都是內存操作，只會在啓動時讀取一次配置中心的配置，後續配置變更都依賴於配置中心的事件推送。</p></li><li><p>提供瞭如下的能力：</p><ul><li><p>當前應用所在的發佈通道，是否在藍綠髮布中。</p></li><li><p>指定應用所在的發佈通道，是否在藍綠髮布中。</p></li><li><p>藍色流量百分比，範圍[0, 100]。</p></li></ul></li><li><p>提供瞭如下的事件推送：</p><ul><li><p>發佈開始事件 onStart。</p></li><li><p>發佈結束事件 onFinish。</p></li><li><p>切流事件 onFlowChange，切流事件又細分了以下幾個事件。</p></li><li><p>切流事件，藍色流量標佔比為 100，綠色流量標佔比為 0，onEnterAllBlue。</p></li><li><p>切流事件，藍色流量標佔比從 100 改為非 100，綠色流量標佔比從 0 改為非 0，onExitAllBlue。</p></li><li><p>切流事件，藍色標流量佔比為 0，綠色流量標佔比為 100，onEnterAllGreen。</p></li><li><p>切流事件，藍色標流量佔比從 0 改為非 0，綠色流量標佔比從 100 改為非 100，onExitAllGreen。</p></li></ul></li></ul><ol><li><strong>流量控制</strong></li></ol><p style="color:#24292f; text-align:start">得物目前的流量分為內部流量及外部流量，大部分流量情況如下：</p><ul><li><p>外部流量</p><ul><li><p>通過各類 Gateway 請求</p></li><li><p>通過 k8s Ingress 請求 (暫不支持藍綠髮布)</p></li></ul></li><li><p>內部流量</p><ul><li><p>通過 Gateway 互聯</p></li><li><p>通過 Dubbo/Feign RPC 協議互聯</p></li><li><p>通過 MQ 異步請求</p></li><li><p>通過 kafka 異步請求 (暫不支持)</p></li><li><p>JOB 類任務發起的流量</p></li><li><p>通過 k8s SVC 請求 (暫不支持藍綠髮布)</p></li></ul></li></ul><p style="color:#24292f; text-align:start">其中 Gateway 也是通過 Dubbo 或者 Feign 請求下游服務，因此也可統一為 RPC 類型，所以得物目前的流量主要包含 RPC、MQ、JOB 三種。</p><p style="color:#24292f; text-align:start"><strong>2.1 RPC</strong></p><p style="color:#24292f; text-align:start">我們 RPC 流量核心主要依賴註冊中心，通過 Dubbo 的負載均衡策略進行調整。</p><p style="color:#24292f; text-align:start"><img alt="02.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/02.png" referrerpolicy="no-referrer"></p><ul><li><strong>如何實現 RPC 流量比例控制</strong></li></ul><p style="color:#24292f; text-align:start">RPC 場景下應用的流量比例控制，取決於它的上游應用按照流量規則比例向其發起調用。核心是上游應用感知到下游應用實例權重。</p><p style="color:#24292f; text-align:start"><strong>當前應用通過流量規則 SDK 監聽到所在通道的流量規則變更時，修改註冊中心上的實例權重。</strong></p><p style="color:#24292f; text-align:start"><strong>上游應用通過註冊中心透明的感知下游應用的實例權重，通過加權負載均衡策略實現流量比例控制。</strong></p><p style="color:#24292f; text-align:start">Dubbo 原生的各類負載均衡策略都支持加權，也就是即便上游沒有升級藍綠依賴，下游應用依然可以通過藍綠實例權重控制自己藍綠集羣被調用的比例。</p><p style="color:#24292f; text-align:start">Feign 原生是不支持的，Fusion 框架重寫了負載均衡策略。</p><ul><li><strong>如何控制流量比例</strong></li></ul><p style="color:#24292f; text-align:start">藍色流量比例 Rate，藍色集羣實例權重 WB，綠色集羣實例權重 WG。</p><p style="color:#24292f; text-align:start">假設 Rate 從 1 調整到 99，一共有 4 個節點。</p><p style="color:#24292f; text-align:start">調整前 WB=1，WG=99，調整後 WB=99，WG=1，可能出現以下情況：</p><p style="color:#24292f; text-align:start"><img alt="03.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/03.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">-流量規則變更時，只讓藍或綠某一個集羣修改自己的權重。</p><p style="color:#24292f; text-align:start">權重值是相對的，只需要保證藍、綠集羣節點權重相對值服從流量比例即可，無需同時修改藍綠集羣所有節點的權重。實例權重初始值設為 100，修改權重時，儘可能保證一半集羣實例權重保持 100 不變，只修改另一側被調整的集羣實例的權重。</p><p style="color:#24292f; text-align:start">規則如下：</p><p style="color:#24292f; text-align:start">藍色流量比例 Rate，公式：W/(100+W) = Rate/100。</p><p>Rate = 50，藍色集羣實例權重=100，綠色集羣實例權重=100。</p><p>Rate &lt; 50，藍色集羣實例權重=100 * Rate / (100-Rate)，綠色集羣實例權重=100。</p><p>Rate &gt; 50，藍色集羣實例權重=100，綠色集羣實例權重=100 * Rate1 / (100-Rate1)，其中 Rate1=100 - Rate。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>只有一個顏色的集羣時，忽略權重。</strong></p><ul><li><p><strong>如何實現完全摘流</strong></p></li></ul><p style="color:#24292f; text-align:start">Dubbo 框架內置的所有負載均衡策略都會識別下游實例的權重進行加權篩選節點，無需上游升級依賴，下游應用實例權重置 0 後即可實現摘流。</p><p style="color:#24292f; text-align:start">Feign 框架默認不識別實例權重，不進行加權負載均衡，為了避免藍綠髮布項目落地時推動發佈鏈路上下游應用升級的困難，應用摘流時，會將自身註冊的所有<strong>Feign 服務反註冊</strong>，以保證 Feign 流量能被徹底摘流。</p><ul><li><strong>如何實現請求鏈路藍綠粘性 (一藍到底或一綠到底)</strong></li></ul><p style="color:#24292f; text-align:start">藍綠子集羣的代碼是不一樣的，按我們制定的發佈流程，藍集羣是新代碼，綠集羣是老代碼，如果不能固定請求鏈路的顏色，實現請求過程一藍到底或者一綠到底，那麼可能會出現上游新代碼調用到下游老代碼，出現代碼不兼容的異常。</p><p style="color:#24292f; text-align:start"><strong>將 RPC 請求第一次進入每個通道時的藍綠決策結果以 KV 形式 Append 到分佈式 Trace 的 baggage 中，全鏈路透傳、隔離、複用。</strong></p><p style="color:#24292f; text-align:start">如果 Trace 中有藍綠決策結果，則按照藍綠決策結果篩選節點；</p><p style="color:#24292f; text-align:start">否則按照流量比例篩選節點，並將決策結果（節點集羣顏色）Append 到 Trace。</p><p style="color:#24292f; text-align:start"><strong>baggage-key: x-deploy-channel-type。 baggage-value：key=通道標識，value=藍集羣或綠集羣標識，多個通道以&amp;分割。</strong><img alt="55.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/55.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>2.2 MQ(RocketMQ)</strong></p><p style="color:#24292f; text-align:start">核心是通過多消費組實現 MQ 流量隔離和控制。業務上創建的一個業務消費組，會在 MQ SDK 層面透明的創建 2 個衍生的顏色消費組。</p><p style="color:#24292f; text-align:start">發送消息時，會在消息頭上攜帶當前節點藍綠標。3 個消費組收到消息時，根據消息顏色和消費組顏色做顏色請和判斷，互斥的消費同一個 TOPIC 上的所有消息。</p><ul><li><p><strong>非摘流狀態</strong><img alt="00.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/00.png" referrerpolicy="no-referrer"></p></li><li><p><strong>摘流狀態</strong></p></li></ul><p style="color:#24292f; text-align:start">應用感知到通道內藍集羣摘流時，藍集羣節點關閉消費組、綠集羣節點啓動三種顏色消費組。此時，MQ 流量完全由綠集羣接管。</p><p style="color:#24292f; text-align:start"><img alt="24.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/24.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">通道內綠集羣摘流時同理。</p><ul><li><p><strong>過程詳解</strong></p><ul><li><p>原本一個消費組，拆分成三個消費組。</p></li><li><p>原始消費組 origin-consumer 用於消費無（藍綠）標識的流量。</p></li><li><p>藍色消費組 blue-consumer 用於消費「藍色」標識流量。</p></li><li><p>綠色消費組 green-consumer 用於消費「綠色」標識流量。</p></li></ul></li></ul><p style="color:#24292f; text-align:start"><img alt="98.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/98.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>2.3 JOB(elasticjob)</strong><img alt="76.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/76.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">elasticjob 在運行時會在業務應用集羣內利用 ZK 協調產生一個 Master 節點，由 Master 節點來按負載均衡策略將任務分配到各個執行器節點上。這個任務分配關係一經分配就會固定並在後續複用，除非是有應用進程上下線、JOB 分片數有變更。</p><p style="color:#24292f; text-align:start">改造 elasticjob 客戶端適配流量規則 SDK，正在藍綠髮布的應用，在感知到有集羣已經摘流時，會修改 ZK 上的狀態標識，將上述記錄的分配關係失效。</p><p style="color:#24292f; text-align:start">失效後，後續 JOB 執行時，會根據流量規則重新進行任務分配，避讓已經摘流的節點，以保證已經摘流的節點上不會有 JOB 執行。</p><ul><li><strong>過程詳解</strong></li></ul><p style="color:#24292f; text-align:start"><img alt="65.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/65.png" referrerpolicy="no-referrer"></p><span id="OSC_h2_10"></span><h2>藍綠接入注意事項</h2><p style="color:#24292f; text-align:start">因當前技術限制, 服務接入藍綠需要注意以下事項：</p><ul><li><p><strong>流量無法摘除的服務暫時無法接入</strong></p><ul><li><p>未通過網關進入服務流量：例如，通過域名 SLB 進入服務、通過 Ingress 進入服務的流量無法摘除。</p></li><li><p>消費 Kafka 的流量無法摘除：由於應用使用的原生 kafka 客戶端並全面鋪開、無法對切入提供支持。</p></li><li><p>未使用統一框架/註冊中心：未使用統一框架和註冊中心的 Java 應用、以及非 Java 類應用當前不支持藍綠髮布。</p></li></ul></li><li><p><strong>使用特別提醒</strong></p><ul><li><p>消費消息需冪等：使用消息中間件必須做冪等，這是基本要求，在消費組啓停管控中可能產生重複消息。</p></li><li><p>消費組線程數量：由於會有三個消費組、消費線程也會增加兩倍，有業務影響時需調低線程數。</p></li><li><p>需要好流量評估：藍綠髮布需一半節點承接線上流量、在應用升級藍綠集羣時做好確認。</p></li><li><p>升級到特定版本：使用藍綠髮布需要應用升級到框架指定版本，詳見接入指南。</p></li><li><p>Feign/HTTP 流量：針對使用框架 Feign 的 HTTP 流量，需上下游應用全部升級後方可使用。</p></li><li><p>使用 Dubbo 流量：使用框架 Dubbo 的服務只需要自身服務升級版本即可、無需上下游升級。</p></li></ul></li></ul><span id="OSC_h1_11"></span><h1>四、得物 SRE 團隊對藍綠髮布的相關支持</h1><span id="OSC_h2_12"></span><h2>容器集羣針對藍綠的改造</h2><p style="color:#24292f; text-align:start">我們容器的 workload 使用的 OpenKruise 來進行管理。在進行藍綠髮布之前，我們使用的單個 clonesets 進行控制。</p><p style="color:#24292f; text-align:start">以下圖所示，為我們一個測試非藍綠集羣，這裏就是使用單個 cloneset 進行控制的單實例。</p><p style="color:#24292f; text-align:start"><img alt="41.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/41.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">在進行藍綠改造後，我們將 workload 分為藍綠兩個 clonesets，通過這樣，我們可以實現藍綠髮布時候的單邊實例發佈。同時在我們管理平台界面，任是單個集羣界面， 以此來實現單集羣下，藍綠集羣的拆分。</p><p style="color:#24292f; text-align:start"><img alt="80.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/80.png" referrerpolicy="no-referrer"></p><span id="OSC_h2_13"></span><h2>藍綠髮布擴容資源優化</h2><p style="color:#24292f; text-align:start">前面就説過，藍綠髮布的一大缺點是通常需要準備平常流量 2 倍的資源，以應對藍綠髮布期間的流量。我們在加入藍綠髮布集羣時，也儘量會提醒需要增加資源以應對藍綠髮布。但如果毫無規劃的進行擴容，則會帶來以下幾個問題，比如長期保留擴容資源，則會帶來成本的答覆增長，而臨時的擴容，則代表着對人力的消耗增加，而且臨時的擴容也增長了對資源池管理的難度。可能在用戶擴容時，出現資源池不足的情況。</p><p style="color:#24292f; text-align:start">為了應對這個問題，我們針對藍綠髮布進行了優化。首先是在發佈流程中加入了擴縮容的環節。讓平台自動幫助進行服務的擴縮容。其次，在容器層面，我們利用雲服務商的彈性實例功能，來彌補常規資源池不足的情況，通過基於 Virtual Kubelet 技術接入到 k8s 中，<strong>支持秒級啓動，按量計費，可快速完成擴縮容，滿足業務的實時響應需求。</strong></p><p style="color:#24292f; text-align:start">注意: 在應用加入發佈通道時，因藍綠髮佈會導致流量減半，請務必對核心服務進行擴容<span>&nbsp;</span><strong>(SRE 建議擴容 30% 以上)。</strong></p><p style="color:#24292f; text-align:start"><img alt="08.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/08.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><img alt="06.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/06.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><img alt="021.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/021.jpeg" referrerpolicy="no-referrer"></p><span id="OSC_h2_14"></span><h2>發佈監控</h2><p style="color:#24292f; text-align:start">加入灰度的藍綠髮布，因為涉及流量切換過程，因此對監控要求非常高，需要及時觀測整個通道中的服務狀態，而歷史中單應用的監控頁面無法滿足發佈 owner 有效觀測。因此，針對這個問題，我們專門設計了通道級的藍綠髮布大盤，有效的觀測流量分佈情況，服務的請求情況等。通過該大盤，發佈 owner 能有效掌握本次發佈情況，決定是否繼續進行切流。</p><p style="color:#24292f; text-align:start"><img alt="043.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/043.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_15"></span><h1>五、藍綠髮布期間可能出現的問題及應急響應策略</h1><span id="OSC_h2_16"></span><h2>資源不足導致的服務異常</h2><ol><li><strong>發佈前擴容</strong></li></ol><p style="color:#24292f; text-align:start">根據藍綠髮布原理可知，我們在發佈時，只有 50% 的實例來支撐原先 100% 的流量， 因此務必在藍綠髮布前勾選發佈前臨時擴容。擴容量需要評估以下幾個數據：</p><ul><li>服務 CPU 水位情況</li></ul><p style="color:#24292f; text-align:start">根據歷史經驗，如日常水位 99 值在 20% 以內的服務，無需進行臨時擴容，而 99 值在 20%-30 以內的服務，建議擴容 20% 左右。而 99 值在 30-40% 之間的服務，應當擴容 30% 以上。同時也要考慮發佈當天的流量情況。</p><p style="color:#24292f; text-align:start">比如我們在七夕大促期間的發佈，因大促流量過高，我們許多服務在藍綠髮布時擴容達到了 50% 以上的情況，通過此方式，保證在切流期間，服務也能正常。</p><p style="color:#24292f; text-align:start">因為我們的服務大多以 JAVA 為主，內存大多用固定方式分配給了 JVM 堆，因此內存不是一個核心的參考指標。</p><ul><li>服務線程使用情況</li></ul><p style="color:#24292f; text-align:start">除了服務 CPU 外，服務線程也是一個核心參考指標，特別是 Dubbo 線程池以及 DB/Redis 的線程池。比如原先 Dubbo 線程池，max 為 200,10 個實例的服務，當日常 QPS 大於 1000 的時候，在藍綠髮布時就需要擴容了，否則實例數少了一半，意味着可用線程也少了一半，這個時候就會出現線程拒絕異常了。</p><ol><li><strong>發佈期間的資源不足</strong></li></ol><p style="color:#24292f; text-align:start">有些時候，我們評估不足會導致在開始發佈後因為資源不足導致的錯誤率上升，此時需要我們緊急處理，但為了發佈期間的穩定性，一旦我們開啓了藍綠通道，就不允許進行集羣的擴容了。此時需要 SRE 接入在後台進行處理，處理邏輯如下：</p><ul><li><p>確認待擴容集羣未處於發佈狀態。</p></li><li><p>手動修改藍/綠單邊集羣 cloneset 的 replicas 數據。</p></li><li><p>待發布完畢後，手動還原該 cloneset 的 replicas 數據。</p></li></ul><p style="color:#24292f; text-align:start"><strong>因該操作非標準操作，且存在風險，請儘量不要使用以上方式進行。</strong></p><span id="OSC_h2_17"></span><h2>發佈中出現流量不均衡的情況</h2><p style="color:#24292f; text-align:start">之前的一次測試中，我們在引流後出現了服務流量不均衡的問題，當時因為 Fusion 框架升級了 Dubbo 異步的改造中存在邏輯缺陷，導致流量無法均衡分佈。之後，通過回退 Fusion 框架版本後問題恢復。</p><p style="color:#24292f; text-align:start"><img alt="77.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/77.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">這是個比較危險的情況，某些節點會在發佈時承擔日常 400% 的流量，很容易造成服務雪崩。因此，在藍綠髮布中，負責人和 SRE 要加強服務的監控和關注力度，及時發現流量不均衡的情況並介入。</p><span id="OSC_h2_18"></span><h2>發佈中出現流量互竄的情況</h2><p style="color:#24292f; text-align:start">流量互竄的問題會有許多種情況：有因為切流前的 JOB 持續運行，導致雙邊集羣依舊有流量；有的因為鏈路中間節點沒有升級藍綠能力，導致流量錯位；有的因為 MQ 請求下游導致的流量錯位。這裏不針對問題進行一一分析，問題的解決僅能依靠框架的升級，這裏僅説下問題的影響和排查方法。</p><p style="color:#24292f; text-align:start">在藍綠髮布時，原先我們的預計是老代碼連老代碼，新代碼連新代碼，但出現異常請求時，可能出現新代碼連老代碼，或者老代碼連下游新代碼的情況，這個時候就會出現因為依賴不匹配，導致的服務異常。<img alt="243.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/243.png" referrerpolicy="no-referrer">要發現此類問題，我們首先要知道，在這種情況下，大多會出現單邊集羣錯誤率上升。通過我們的監控頁面，我們能很好的發現單邊錯誤率上升的情況。此時，我們就能根據這些錯誤的情況，在天眼的調用鏈分析中，查看錯誤的具體情況。此時需要我們判斷鏈路裏是否有出現流量異常的情況，查看節點的 Host name，可以判斷是藍或者綠集羣節點。<img alt="123.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/123.png" referrerpolicy="no-referrer"><img alt="60.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/60.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_19"></span><h1>六、歷史總結及展望未來</h1><span id="OSC_h2_20"></span><h2>藍綠髮布的效果</h2><p style="color:#24292f; text-align:start">自從交易域進行藍綠髮布以來，平均大版本的發佈時效較之前得到了較大的提升，同時近期大版本已沒有出現故障事件，在升級藍綠髮布後，我們可以提前在切流階段發現問題，並快速回切進行修復，避免了故障帶入生產。因此，現在藍綠髮布相比過去滾動部署，在效率和穩定性上均大有提升。</p><span id="OSC_h2_21"></span><h2>未來展望</h2><p style="color:#24292f; text-align:start">目前我們核心服務都已切換至藍綠集羣，這種為我們的多活打下了優勢，已經天然具備了多活的條件。因此，未來我們可以通過這種架構來部署我們的多活，這樣，當任何單機房出現異常後，能夠快速切換到另外一個機房，我們的抗風險能力也會有巨大的提升。</p><p style="color:#24292f; text-align:start"><strong>參考引用:</strong><span>&nbsp;</span>[1] 特別鳴謝，本節藍綠髮布架構及原理部分引用了得物中間件平台 「羊羽」同學的文章。</p><p style="color:#24292f; text-align:start"><strong>文/latte</strong></p><p style="color:#24292f; text-align:start">&nbsp;</p><p style="color:#252933; text-align:start">本文屬得物技術原創，更多精彩文章請看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.dewu.com" rel="nofollow" target="_blank">得物技術官網</a></p><p style="color:#252933; text-align:start">未經得物技術許可嚴禁轉載，否則依法追究法律責任！</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 14 Jan 2024 02:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/10773874</guid>
            <link>https://my.oschina.net/u/5783135/blog/10773874</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linus「溫馨提示」：Intel Xe 驅動代碼嚴重缺乏測試]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Linux 6.8 的 </span><span style="color:#121212">Direct Rendering Manager (DRM)&nbsp;</span><span style="color:#000000">內核圖形/顯示驅動程序更新包括新的英特爾"Xe"DRM 和 PowerVR Imagination 驅動程序、實驗形式的 AMD 色彩管理屬性、Raspberry Pi 5 圖形支持等。</span></p><p><span style="color:#000000">但 Linus Torvalds 最近在合併相關</span><span style="color:#333333">代碼</span><span style="color:#000000">時卻發現，一些新提交的 Intel Xe 驅動程序代碼"嚴重缺乏"測試。對此，他在內核郵件列表中<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Fdri-devel%2FCAHk-%3DwgPJttFz8yrdpPTN-ypMmDXHOKw9yi1nZSEq%2B7%2BtGftZA%40mail.gmail.com%2F" target="_blank">表達</a>了自己的不滿：</span></p><blockquote><p><span style="color:#000000">你的測試嚴重不足。甚至無法構建，原因似乎在於該&nbsp;commit b49e894c3fd8 ("drm/i915: Replace custom intel runtime_pm tracker with ref_tracker library")&nbsp;將"intel_wakeref_t"類型從"deep_stack_handle_t"改為了"unsigned long"......</span></p><p><span style="color:#000000">真令人不悅。我已經修復了那個損壞的 Xe compat 頭文件並完成了構建，但這絕對不是事情的本來應該有的樣子。我怎麼會遇到這種情況？竟然會沒有進行任何構建測試。</span></p><p><span style="color:#000000">為什麼 %^!@$% 頭文件會包含 C 文件？無論如何，這個錯誤都不應該發生。</span></p></blockquote><p><img height="281" src="https://oscimg.oschina.net/oscnet/up-7e522381a922470c222f72c566df84b3bea.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">與以前的一些「火爆」回覆相比，Linus 這次的措辭可以説是算的上溫和，並且也提出了一些合理的問題。事實上，在 2023 年底的&nbsp;Linux 基金會的日本開源峯會上，Linus 就<a href="https://www.oschina.net/news/269762/linus-torvalds-linux-future-ai">表示</a>自己已經收斂了脾氣，在吸取了一些教訓之後不會再 「對一些公司豎中指」。</span></p><p><span style="color:#000000">但也正如 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FTorvalds-Unhappy-Linux-6.8-DRM" target="_blank">Phoronix</a> 所言，無論如何 Linus 已經將新代碼合併到 Linux 6.8 中。希望這只是&nbsp;Intel Xe 驅動程序的一個 one-off issue，而沒有更大的代碼質量問題。</span></p><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Fdri-devel%2FCAHk-%3DwgPJttFz8yrdpPTN-ypMmDXHOKw9yi1nZSEq%2B7%2BtGftZA%40mail.gmail.com%2F" target="_blank">查看郵件列表</a>。</span></p><p><strong><span style="color:#000000">相關閲讀：</span></strong></p><ul><li><a href="https://www.oschina.net/news/269762/linus-torvalds-linux-future-ai" target="news">Linus Torvalds 收斂脾氣，談內核社區「老齡化」問題</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Sat, 13 Jan 2024 04:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275552/linus-torvalds-intel-xe-drive-code-linux-6-8</guid>
            <link>https://www.oschina.net/news/275552/linus-torvalds-intel-xe-drive-code-linux-6-8</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[三部門：到 2025 年初步形成支撐區塊鏈發展標準體系]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>工業和信息化部、中央網絡安全和信息化委員會辦公室、國家標準化管理委員會印發《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fzwgk%2Fzcwj%2Fwjfb%2Ftz%2Fart%2F2024%2Fart_c82be443223e4a5aa9cee2c435112e00.html" target="_blank">區塊鏈和分佈式記賬技術標準體系建設指南</a>》(下稱《指南》)。</p><p>其中提出，區塊鏈和分佈式記賬技術 (以下簡稱「區塊鏈」) 是新一代信息技術的重要組成部分，是分佈式網絡、加密技術、智能合約等多種技術集成的新型數據庫軟件。區塊鏈技術具有數據透明、不易篡改、可追溯等特性，有望解決網絡空間的信任和安全問題，推動互聯網從傳遞信息向傳遞價值變革，將成為推動元宇宙、Web3.0 等未來產業快速發展的重要數字基礎設施。</p><p><img height="316" src="https://oscimg.oschina.net/oscnet/up-380ad5c9a1d0ae2453b5bdb61fc89ff89ca.png" width="700" referrerpolicy="no-referrer"></p><p>《指南》提出建設目標：</p><p>到 2025 年，初步形成支撐區塊鏈發展的標準體系。建立標準體系建設和標準研製的總體規則，重點面向基礎共性、應用和服務等標準化領域，制定 30 項以上區塊鏈相關標準，基本滿足我國區塊鏈標準化需求。</p><p>到 2027 年，全面形成支撐區塊鏈發展的標準體系。制定 50 項以上區塊鏈相關標準，持續推動區塊鏈基礎共性、關鍵應用示範、安全保障等標準研製。適度超前佈局一批支撐未來產業發展需要的關鍵應用標準，有效指導我國區塊鏈技術和產業發展，提升技術與應用服務水平。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 13 Jan 2024 03:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275546</guid>
            <link>https://www.oschina.net/news/275546</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenVoice —— 多功能即時語音克隆]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">OpenVoice，這是一種多功能的即時語音克隆方法，只需要參考説話者的一個簡短的音頻剪輯即可複製他們的聲音並生成多種語言的語音。</span></p><p><span style="color:#000000">除了複製參考説話者的音色之外，OpenVoice 還可以對語音風格進行精細控制，包括情感、口音、節奏、停頓和語調。OpenVoice 還可以針對海量説話人訓練集中未包含的語言實現零樣本跨語言語音克隆。OpenVoice 的計算效率也很高，其成本比性能較差的商用 API 低數十倍。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong><span style="background-color:oklch(1 0 0)">準確的音色克隆</span></strong></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:oklch(1 0 0)">OpenVoice 可以準確克隆參考音色並生成多種語言和口音的語音。</span></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span style="color:#000000"><span style="background-color:oklch(1 0 0)">靈活的語音風格控制</span></span></strong></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:oklch(1 0 0)">OpenVoice 可以對語音風格（例如情感和口音）以及其他風格參數（包括節奏、停頓和語調）進行精細控制。</span></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong><span style="background-color:oklch(1 0 0)">零樣本跨語言語音克隆</span></strong></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:oklch(1 0 0)">參考語音和生成的語音可以是海量説話人多語言數據集之外的任何語言。</span></span></p></div>
                                                                ]]>
            </description>
            <pubDate>Sat, 13 Jan 2024 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/openvoice</guid>
            <link>https://www.oschina.net/p/openvoice</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | Windows 和 iOS 設備間文件傳輸 AirDropPlus]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-airdrop-plus" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#airdrop-plus"></a>AirDrop Plus</h1><p>用於 iOS 設備和 Windows 電腦之間進行文件傳輸，基於 HTTP，需要配合快捷指令使用</p><h1><a id="user-content-依賴" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E4%BE%9D%E8%B5%96"></a>依賴</h1><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">python==3.10.6</span><span id="LC2" class="line">flask==3.0.0</span><span id="LC3" class="line">win10toast==0.9</span><span id="LC4" class="line">psutil==5.9.6</span><span id="LC5" class="line">pyinstaller==6.2.0</span><span id="LC6" class="line">windows_toasts==1.0.1</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h1><a id="user-content-打包" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E6%89%93%E5%8C%85"></a>打包</h1><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">pyinstaller <span class="nt">--add-data</span><span class="s1">'config;config'</span><span class="nt">-w</span> AirDropPlus.py</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h1><a id="user-content-使用" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E4%BD%BF%E7%94%A8"></a>使用</h1><ol><li>Windows 端安裝 bonjour，這樣可以通過 「設備名.local」 訪問到 Windows，而不需要通過 IP 地址。
 <div><img src="https://gitee.com/yeytytytytyytyt/air-drop-plus/raw/master/pic/windows_device_name.png" alt="Image" referrerpolicy="no-referrer"></div></li><li>修改配置文件 config.ini，設置文件保存路徑和密鑰</li><li>手機端下載快捷指令
<ul><li>文件：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.icloud.com%2Fshortcuts%2Fdbbc2d75a611471babbe69e128db6702">https://www.icloud.com/shortcuts/dbbc2d75a611471babbe69e128db6702</a></li><li>剪貼板：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.icloud.com%2Fshortcuts%2F8b0a81ddf004422fbbb8fc8099546811">https://www.icloud.com/shortcuts/8b0a81ddf004422fbbb8fc8099546811</a></li></ul></li><li>設置快捷指令的主機為 Windows 的設備名 (不是用戶名).local，設置快捷指令的密鑰和 config.ini 中的密鑰相同
 <div><img src="https://gitee.com/yeytytytytyytyt/air-drop-plus/raw/master/pic/shortcut_conf.png" alt="Image" referrerpolicy="no-referrer"></div></li><li>發送文件時在文件分享菜單執行 AirDrop Plus 快捷指令。接收文件時，直接執行 AirDrop Plus 快捷指令
 <div><img src="https://gitee.com/yeytytytytyytyt/air-drop-plus/raw/master/pic/send_file.png" alt="Image" referrerpolicy="no-referrer"><img src="https://gitee.com/yeytytytytyytyt/air-drop-plus/raw/master/pic/receive_file.png" alt="Image" referrerpolicy="no-referrer"></div></li><li>同步剪貼板直接執行快捷指令，點擊發送或者接收!
 <div><img src="https://gitee.com/yeytytytytyytyt/air-drop-plus/raw/master/pic/sync_clipboard.png" alt="Image" referrerpolicy="no-referrer"></div></li><li>Windows 端退出在任務管理器中退出
 <div><img src="https://gitee.com/yeytytytytyytyt/air-drop-plus/raw/master/pic/exit.png" alt="Image" referrerpolicy="no-referrer"></div></li></ol><h1><a id="user-content-api" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#api"></a>API</h1><h2><a id="user-content-請求頭參數" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%8F%82%E6%95%B0"></a>請求頭參數</h2><table><thead><tr><th>參數名</th><th>類型</th><th>描述</th></tr></thead><tbody><tr><td>ShortcutVersion</td><td>String</td><td>快捷指令的版本，需要和 config.ini 中的 version 一致</td></tr><tr><td>Authorization</td><td>String</td><td>密鑰，需要和 config.ini 中的 key 一致</td></tr></tbody></table><h2><a id="user-content-文件發送" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E6%96%87%E4%BB%B6%E5%8F%91%E9%80%81"></a>文件發送</h2><blockquote><p>移動端發送一個文件到 PC</p></blockquote><h3><a id="user-content-請求" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82"></a>請求</h3><h4><a id="user-content-請求方式" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"></a>請求方式</h4><ul><li>HTTP 方法: POST</li><li>URL: /file/send</li></ul><h4><a id="user-content-請求參數" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"></a>請求參數</h4><ul><li>發送格式: 表單</li></ul><table><thead><tr><th>參數名</th><th>類型</th><th>描述</th></tr></thead><tbody><tr><td>file</td><td>File</td><td>要發送的文件</td></tr><tr><td>filename</td><td>String</td><td>發送的文件名</td></tr><tr><td>notify_content</td><td>String</td><td>讓 PC 端通知顯示的內容<br>如果是發送單個文件：這裏填寫的就是 filename 的內容<br>如果是發送 n 個文件：前 n-1 個的 notify_content 為空，第 n 個的 notify_content 包含 n 個文件的 filename，使用\n 分隔</td></tr></tbody></table><h3><a id="user-content-返回" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%BF%94%E5%9B%9E"></a>返回</h3><ul><li>返回類型: JSON</li><li>返回內容:
<div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="p">{</span></span><span id="LC2" class="line"><span class="w"></span><span class="nl">"success"</span><span class="p">:</span><span class="w"></span><span class="kc">true</span><span class="p">,</span></span><span id="LC3" class="line"><span class="w"></span><span class="nl">"msg"</span><span class="p">:</span><span class="w"></span><span class="s2">"發送成功"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="w"></span><span class="nl">"data"</span><span class="p">:</span><span class="w"></span><span class="kc">null</span></span><span id="LC5" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div></li></ul><h2><a id="user-content-文件發送列表" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E6%96%87%E4%BB%B6%E5%8F%91%E9%80%81%E5%88%97%E8%A1%A8"></a>文件發送列表</h2><blockquote><p>移動端發送文件列表到 PC（通知 PC 接下來要發送哪些文件）</p></blockquote><h3><a id="user-content-請求-1" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82-1"></a>請求</h3><h4><a id="user-content-請求方式-1" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F-1"></a>請求方式</h4><ul><li>HTTP 方法: POST</li><li>URL: /file/send/list</li></ul><h4><a id="user-content-請求參數-1" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-1"></a>請求參數</h4><ul><li>發送格式: 表單</li></ul><table><thead><tr><th>參數名</th><th>類型</th><th>描述</th></tr></thead><tbody><tr><td>file_list</td><td>String</td><td>要發送的文件列表，文件之間用\n 分隔，如：aaa.jpg\nbbb.png</td></tr></tbody></table><h3><a id="user-content-返回-1" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%BF%94%E5%9B%9E-1"></a>返回</h3><ul><li>返回類型: JSON</li><li>返回內容:
<div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="p">{</span></span><span id="LC2" class="line"><span class="w"></span><span class="nl">"success"</span><span class="p">:</span><span class="w"></span><span class="kc">true</span><span class="p">,</span></span><span id="LC3" class="line"><span class="w"></span><span class="nl">"msg"</span><span class="p">:</span><span class="w"></span><span class="s2">"發送成功"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="w"></span><span class="nl">"data"</span><span class="p">:</span><span class="w"></span><span class="kc">null</span></span><span id="LC5" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div></li></ul><h2><a id="user-content-文件接收列表" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E6%96%87%E4%BB%B6%E6%8E%A5%E6%94%B6%E5%88%97%E8%A1%A8"></a>文件接收列表</h2><blockquote><p>獲取 PC 複製的文件的文件地址列表</p></blockquote><h3><a id="user-content-請求-2" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82-2"></a>請求</h3><h4><a id="user-content-請求方式-2" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F-2"></a>請求方式</h4><ul><li>HTTP 方法: GET</li><li>URL: /file/receive/list</li></ul><h4><a id="user-content-請求參數-2" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-2"></a>請求參數</h4><ul><li>無</li></ul><h3><a id="user-content-返回-2" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%BF%94%E5%9B%9E-2"></a>返回</h3><ul><li>返回類型: JSON</li><li>返回內容:
<div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="p">{</span></span><span id="LC2" class="line"><span class="w"></span><span class="nl">"success"</span><span class="p">:</span><span class="w"></span><span class="kc">true</span><span class="p">,</span></span><span id="LC3" class="line"><span class="w"></span><span class="nl">"msg"</span><span class="p">:</span><span class="w"></span><span class="s2">""</span><span class="p">,</span></span><span id="LC4" class="line"><span class="w"></span><span class="nl">"data"</span><span class="p">:</span><span class="w"></span><span class="p">[</span><span class="s2">"c:/xx/xx/aa.txt"</span><span class="p">,</span><span class="w"></span><span class="s2">"c:/xx/xx/bb.txt"</span><span class="p">]</span></span><span id="LC5" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div></li></ul><h2><a id="user-content-文件接收" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E6%96%87%E4%BB%B6%E6%8E%A5%E6%94%B6"></a>文件接收</h2><blockquote><p>移動端接收 PC 上的文件</p></blockquote><h3><a id="user-content-請求-3" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82-3"></a>請求</h3><h4><a id="user-content-請求方式-3" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F-3"></a>請求方式</h4><ul><li>HTTP 方法: POST</li><li>URL: /file/receive</li></ul><h4><a id="user-content-請求參數-3" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-3"></a>請求參數</h4><ul><li>發送格式: 表單</li></ul><table><thead><tr><th>參數名</th><th>類型</th><th>描述</th></tr></thead><tbody><tr><td>path</td><td>String</td><td>要接收的文件的路徑</td></tr></tbody></table><h3><a id="user-content-返回-3" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%BF%94%E5%9B%9E-3"></a>返回</h3><ul><li>返回類型: 文件</li><li>返回內容: 文件</li></ul><h2><a id="user-content-剪貼板發送" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E5%89%AA%E8%B4%B4%E6%9D%BF%E5%8F%91%E9%80%81"></a>剪貼板發送</h2><blockquote><p>把移動端的剪貼板發送到 PC 的剪貼板</p></blockquote><h3><a id="user-content-請求-4" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82-4"></a>請求</h3><h4><a id="user-content-請求方式-4" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F-4"></a>請求方式</h4><ul><li>HTTP 方法: POST</li><li>URL: /clipboard/send</li></ul><h4><a id="user-content-請求參數-4" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-4"></a>請求參數</h4><ul><li>發送格式: 表單</li></ul><table><thead><tr><th>參數名</th><th>類型</th><th>描述</th></tr></thead><tbody><tr><td>clipboard</td><td>String</td><td>移動端剪貼板內容</td></tr></tbody></table><h3><a id="user-content-返回-4" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%BF%94%E5%9B%9E-4"></a>返回</h3><ul><li>返回類型: JSON</li><li>返回內容:
<div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="p">{</span></span><span id="LC2" class="line"><span class="w"></span><span class="nl">"success"</span><span class="p">:</span><span class="w"></span><span class="kc">true</span><span class="p">,</span></span><span id="LC3" class="line"><span class="w"></span><span class="nl">"msg"</span><span class="p">:</span><span class="w"></span><span class="s2">"發送成功"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="w"></span><span class="nl">"data"</span><span class="p">:</span><span class="w"></span><span class="kc">null</span></span><span id="LC5" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div></li></ul><h2><a id="user-content-剪貼板接收" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E5%89%AA%E8%B4%B4%E6%9D%BF%E6%8E%A5%E6%94%B6"></a>剪貼板接收</h2><blockquote><p>把 PC 端的剪貼板發送到移動端的剪貼板</p></blockquote><h3><a id="user-content-請求-5" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82-5"></a>請求</h3><h4><a id="user-content-請求方式-5" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F-5"></a>請求方式</h4><ul><li>HTTP 方法: GET</li><li>URL: /clipboard/receive</li></ul><h4><a id="user-content-請求參數-5" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-5"></a>請求參數</h4><ul><li>無</li></ul><h3><a id="user-content-返回-5" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%BF%94%E5%9B%9E-5"></a>返回</h3><ul><li>返回類型: JSON</li><li>返回內容:
<div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="p">{</span></span><span id="LC2" class="line"><span class="w"></span><span class="nl">"success"</span><span class="p">:</span><span class="w"></span><span class="kc">true</span><span class="p">,</span></span><span id="LC3" class="line"><span class="w"></span><span class="nl">"msg"</span><span class="p">:</span><span class="w"></span><span class="s2">""</span><span class="p">,</span></span><span id="LC4" class="line"><span class="w"></span><span class="nl">"data"</span><span class="p">:</span><span class="w"></span><span class="s2">"PC 端剪貼板的內容"</span></span><span id="LC5" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div></li></ul>]]>
            </description>
            <pubDate>Sat, 13 Jan 2024 02:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/yeytytytytyytyt/air-drop-plus</guid>
            <link>https://gitee.com/yeytytytytyytyt/air-drop-plus</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 開發同學的 「做事情」&「想事情」&「談事情」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:justify">回看在阿里的這幾年，乃至追溯到整個畢業後的工作過程，作為一名後端偏向業務向的一線開發，我一直在想，拋開技術棧和方案經驗等這些具體的細緻內容之外，究竟有什麼東西是能夠遷移到更多場景乃至生活上的體悟，思索良久，大抵可以此概述。</p><span id="OSC_h3_1"></span><h3>總會走的「路」</h3><p style="text-align:justify">想來，除少數天才外，所有人走進職場的開頭，都是從模仿開始的。這一點在工程領域尤甚，跟着前輩、師兄、領導，學習怎麼使用開發工具、生產環境，怎麼去受理需求，怎麼去按照既定的設計實施，最後開發測試完成上線，即便是之後換了新的工作環境，這些流程大致還是需要重走一遍的，當然，這一點我們的術語也稱其為「落地」（不排除落地中也包含着文化同化的部分）。</p><p style="text-align:justify">隨着在一個領域裏瞭解的越來越多，或者是在一個課題中越做越深、越做越細之後，慢慢的會對現狀產生懷疑、產生不滿，覺得現有的東西不夠完美，還能有進步空間，就開始想辦法去找新路子、做優化、搞設計，目標是突破現狀得到更好的結果。直到某一個領域完全符合了自己的想法（當然不排除也會走向自我和解），也能預見在未來的一段時間內能夠 cover 掉大多數的變化的時候，就會嘗試跳出邊界外，再去找一個相關的領域或者乾脆找一個完全新的領域去從頭開始。</p><p style="text-align:justify">對於一個技術人而言，這種從 0 到 1 再到 100 的過程，真的是會令人上癮的，畢竟與此相比，在別人成熟的東西上繼續添磚加瓦所帶來的成就感和獲得感會少的多，<strong>技術是需要技術熱情推動的</strong>，所以也就不奇怪為什麼很多團隊乃至公司在接手現成項目產品的時候，都會選擇技術重構、架構升級等，當然最主要的方面還是為瞭解決技術舊債和統一建設思路的問題，不過，誰敢説這裏面完全不存在哪怕一點點私心其實是為了這點子熱情呢（手動挽尊~狗頭）。</p><span id="OSC_h3_2"></span><h3>理出來的「核」</h3><p style="text-align:justify">無論是剛開始上手的初期，亦或是逐漸輕車熟路的中期，還是歷經數次大促不斷打磨過的後期，一名開發同學在不同歷史階段做的事情雖然會千差萬別，但畢竟還是同一個工種的事情，説的籠統一點無外乎需求、設計和開發，總會存在一些不變的道理。</p><p style="text-align:justify">很多事情，無論具體的細節隨着時間怎麼變，都會有存在一條很難直接言明的<strong>框架和脈絡</strong>，內涵於這件事情的本質屬性，讓人即便遇到了一件看似新鮮的工作內容，在瞭解了變化後還是會説一句「嗨，什麼嘛，不還是一回事」。然而，對所見事務按「相似性」進行歸納，是人類天生的一種學習能力，歸納法是人類認世界最簡單的實踐根本，人類大多數智慧都發生在生活和經歷中，是從具體生產、生活事例中歸納出來的通用性的結論，工作基本也是一樣，即所謂工作經驗。同意了這個觀點，再看看遇到新項目、新需求、新題目的時候，我們大多數時候的做法，還是先想想自己是不是曾經做過類似的事情，然後再去問問做過類似事情的人，以及來 ATA 上查查有沒有類似的項目分享學習經驗。説白了，只要是能描述清晰的問題，最終結論都是可解的，所有的不可解都是衡量代價後產生的問題。</p><p style="text-align:justify">直到現在，我還是在説具體的事或者同類的事，那麼現在跳出這個思考邊界，回到框架和脈絡這種本質屬性上。開發同學最喜歡做的事情之一就是抽象、封裝，那麼把這種好習慣用在寫代碼之外，就以開發工作而言，乃至工作而言，這事兒有沒有什麼東西，是這個領域解題思路的「核」？</p><p style="text-align:justify">在我看來，工作上的事，無非三個方面：<strong>做事情、想事情、談事情</strong>。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-ec80deb479d41d17354f46f007c00e97_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">做事情與想事情比較好理解，為什麼我會單獨列出來談事情，下文細聊，不過三者倒也真的算是相輔相成，只做不想謂之碼農，只想不做謂之吹牛，至於只談不想也不做算什麼，那不就是個傳聲筒唄，算什麼開發呢。</p><span id="OSC_h3_3"></span><h3>做事情</h3><p style="text-align:justify">「結果利他，過程利己。」</p><p style="text-align:justify">開發都要做些什麼事情，一言以蔽之「實現需求」，實現了能發佈上線，做出來的東西得好使，這才是硬道理。工程一事，不只是軟件工程，都是結果論調，沒做出來東西或者東西不好使，只流於表面誇讚思路超前、架構先進，然後講出來一套一套，這都是花架子，經不住推敲和敲打，常以此自省。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-b926ba0e453fd0026cd6d86eb651d96c_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">開發完整一些的流程，從收到需求開始，歷經分析、設計、實施、實現、驗證直到最終交付。但在上述流程之前，有一個易被忽略的環節，是需求調研的過程，目的是為了搞明白這需求是咋來的；而在流程之後，還有一個被忽略的環節，就是總結，這個總結不是為了理清項目成果，而是想清楚除了項目拿了結果，自己從中收穫了什麼。</p><p style="text-align:justify">大家都是老司機，標準流程怎麼幹不説了，僅僅聊些小體悟：</p><span id="OSC_h4_4"></span><h4><br><strong>調研</strong></h4><p style="text-align:justify">調研這件事，我一開始是走偏了的，曾經我試圖去自己走一走從用戶訴求到產品需求的轉換過程，但開發畢竟不是產品，雖然坊間經常説「人人都是產品經理」，但是不可否認的是，產品需要一定的思維和經驗，如果這過程這麼容易，那麼就不需要設置單獨的崗位來做這件事了，專業的事還是需要專業的人來幹。那如果不去關注這個轉換過程，開發同學還關心調研這事幹嘛，等着看 PRD 不就行了？行是行，但是不好。</p><p style="text-align:justify">不知道大家有沒有這樣一種經歷，辛辛苦苦做出來的東西，結果業務方拿到了以後説這個跟他們想的差的比較遠，然後產技會勸説先試着用用看，結果用過一段時間就反饋説東西不行用着彆扭，漸漸就不用了，長時間後產品落入了不再維護的境地裏。可這事，也不能總怪產品同學寫 PRD 不認真，也不能總怪技術同學做的不行，每一個個體由於自身的經驗和思考方式的不同，對待同一個場景的理解是不同的，PRD 能清晰的描述邏輯，但是未必能描述初衷，儘管 PRD 的第一小節永遠都是項目背景，別人嚼碎的東西咬着是不太費勁，但是就不知道一開始吃的是個啥了。</p><p style="text-align:justify">所以説，開發關注的調研是什麼呢？這個核，大概率就是那個初衷，甭管產品寫了啥，先去聽聽業務當初為啥跟你提起這件事、遇到了什麼問題，為啥必須系統化的去解決，是因為搞不定、還是費人力、還是為了玩出個花活，有了自己的認知，回頭再看看產品同學幫忙嚼碎後寫出的 PRD，是不是把這個初衷不小心自己給嚥下去了（別細想，怪噁心~），這樣的 PRD 評審才有意義。</p><span id="OSC_h4_5"></span><h4><strong>設計</strong></h4><p style="text-align:justify">每個開發都有做架構師的夢想，這沒毛病。一開始就是老老實實順序寫，後來就總想着封裝、抽象、控制反轉多玩點設計模式的花活，再後來就不滿足於此了，甭管啥需求，開發過程不沉澱出個框架、工具來就不行，這過程只要是追求成長的開發同學都會經歷，可這事吧，不怕不去幹，就怕乾的太過了，過猶不及。</p><p style="text-align:justify">所以怕的不是不設計，怕的是過度設計。</p><p style="text-align:justify">我超級喜歡輝子老師的<strong>CLED</strong>的概念，但是一度沒有把這幾種概念之間的邊界搞清楚，想來也有不少相同經歷的同學，為了追求無比閃耀的<strong>Configuration</strong>而做了一堆配置化的組件、工具、平台，動不動就上升到表達式的層面，嘗試把所有的業務邏輯以表達式的方式進行表述，然後就導致在工程代碼內完全看不懂這個系統到底處理了什麼業務邏輯，一扒代碼才發現這些邏輯都落在數據庫或者 Diamond 裏變成片段化的<strong>QLExpress</strong>或者<strong>SPEL</strong>了，再加上沒有圖形化的用於表述邏輯的配套設施，業務邏輯碎了一地。</p><p style="text-align:justify">回到設計的初衷，設計是為瞭解決問題存在的，不是為了單純的秀，<strong>簡單即好，適度設計</strong>。</p><span id="OSC_h4_6"></span><h4><strong>實施</strong></h4><p style="text-align:justify">驕傲是工程師的天性，具體一點，都會有一點設計潔癖和代碼潔癖，但是隨着工作的進行，總得慢慢的學會認識到一個道理：<strong>不是所有的事都能靠自己一個人搞定</strong>。所以上圖流程裏的實施和實現的區別，想説的也是這一點，實現是自己做的過程，實施是與別人與團隊一起做的過程，配合與協同，轉變思路是第一位的，這是起點。</p><p style="text-align:justify">那麼一開始怎麼做好配合呢，尤其是跟不熟悉的開發同學，在不熟悉做事風格的時候，怎麼來溝通防止彼此掣肘？一個比較好的解題思路就是設定好領域邊界，類比<strong>DDD</strong>裏的概念，大家共識上下文，但是彼此靠邊界做隔離，這裏的邊界的表現形式具體到過程裏可以是接口範式、可以是排期設定、可以業務邏輯，然後剩下的，因為相信，所以看見就好。</p><p style="text-align:justify">然後協同的問題就在於又怕太相信到完全看不見，「這事反正有人負責了，過程做到什麼程度無所謂了，反正最後能交付就好」，這種想法是非常危險的，過程要看得見，不要成了盲人，大家定一些關鍵節點的同步週期，合理控制下風險即可，當然也有頻繁到每日發日報同步項目進度的，大項目人多溝通不便時這麼搞比較好，但是人數少週期短的協作項目這樣反而就會很佔開發時間，還是老話，什麼事都要講究個適度。</p><span id="OSC_h4_7"></span><h4><strong>總結</strong></h4><p style="text-align:justify">這裏想談的總結不是那種項目戰報，而是那種給自己看的<strong>真總結</strong>。</p><p style="text-align:justify">需求項目做了一年又一年，除了產品本身外，有沒有給自己留下點能稱得上「<strong>持續發展</strong>」的東西？很多時候，連續時段的忙碌，就把總結與回顧的過程忽略掉了，交付完拍拍屁股進入下一個，偶爾想想得失，也是很碎片的一些想法觀點。其實細想想，這些細碎的東西整理整理就是所謂的<strong>產品觀、架構風格、方法論</strong>，或者這些東西才是要比項目的結果對個人的發展來説，重要得多的東西。</p><p style="text-align:justify">另外這些事光想可不行，零散細碎不成系統的東西是不易被記憶的，需要整理、需要寫下來。開發同學大多數不願意在文字上下功夫（Me too），但是多嘗試幾次就會發現，每次寫完總有一種醍醐灌頂、煥然一新的快感，也能在文字書寫的過程中重新審視自己的觀點，修正、優化、昇華，反覆捶打，終是精髓。當然每一件事都總結也不現實，沒那麼多時間，活還是要乾的，階段性的進行，加上定期的回顧，培養<strong>自身發展的節奏感就好</strong>。</p><p style="text-align:justify">對於一個技術開發人員來説，成長總在反覆的經歷每一個需求的過程中不斷打磨，回到寫在做事情開頭的一句話上：「<strong>結果利他，過程利己</strong>」，結果當然重要，拿人錢財替人消災，拿了薪水就要給出工作的結果，但是對於長線的發展而言，結果只是短暫的喜悅，而過程的體悟才是最該留在手裏的東西，這玩意才是實實在在能夠帶着陪伴一生的東西。開發同學總愛説沉澱，這沉澱也得分兩方面，看的見的沉澱是留在工程裏的框架、工具，看不見的沉澱都在自己的腦子裏，説白瞭如果幹了一件事，沒去細想或者想了一圈自己沒思考到什麼體悟，那麼這事基本等於白乾，所以對過程的思考這事要重視起來，好的善於做事情的人是耐得住寂寞的，也知道做的每一件事裏自己在表面的需求達成過程中還需要追求什麼沉澱，<strong>借事成己，才能不斷到達新的高度</strong>。</p><span id="OSC_h3_8"></span><h3>想事情</h3><p style="text-align:justify">「難的不是想解法，難的是想問題。」</p><p style="text-align:justify">開發同學的工程師特性是善於做事情的，但是進到做事情裏面去很容易，跳出來卻很難。</p><span id="OSC_h4_9"></span><h4><strong>自驅</strong></h4><p style="text-align:justify">跟一個開發同學説，來設計一個用於某項功能的組件、中間件，大部分同學還是很容想到解法去做到的，但是跳出這件事本身，由開發同學自己去發現當前系統架構中應該構建一個具備某項能力的通用部分，而又不陷入「<strong>過度設計，空造輪子</strong>」的泥潭，確實是需要一定的時間、項目、知識、經驗的積累，看看周圍師兄前輩的那種遊刃有餘感，<strong>不要慌、不要急、多發掘、多觀摩、多嘗試</strong>，其他的也不用再嘮叨，「饅頭會有的，麪包會有的，經驗也會有的」，這件事遲早會做的到並且慢慢老道愈發醇熟。這個過程就是技術層面，開始想問題的過程，換個常聽的詞就是<strong>技術自驅</strong>。</p><p style="text-align:justify">但是在另外一個方面，跳出技術實現這件事，一個開發同學需不需要對業務有一定的提問能力？私以為還是要的。</p><p style="text-align:justify">首先，對應到前文説的調研過程裏的初衷二字，要想理解業務同學初衷，前提是得懂業務才行，這裏的懂不單單是指能聽得懂，要想理解初衷，還需要能對現有存在的問題具備「<strong>同理心</strong>」，就是能確真理解業務提的這個問題的<strong>意義乃至情緒在哪</strong>。</p><p style="text-align:justify">其次，在此基礎上，換個自己的視角去看到業務這些事情還有什麼問題，説通俗點就是「<strong>眼裏得有活兒</strong>」，業務同學是業務的專家但不是開發，很難具備開發思維，或許很多時候甚至都不會想到某些日常工作<strong>可以應用化</strong>或者<strong>需要應用化</strong>，習慣了模式再加上做的熟練，業務同學都會有自己日常處理事情的 SOP，很多事可能用個 Excel 就把數據都處理了，也就不會想還要什麼系統，這些事情放在天生愛偷懶的工程師眼裏，標準的流程和重複的工作應該讓機器來幹，就會有一個系統的雛形出現了，這樣做出來的東西又有受眾、又能釋放人力、又能完成經驗的傳遞（<strong>標準化的系統會降低同類工作領域內熟練者和非熟練者之間的差距</strong>），實在的很，如果看到業務同學之前總用手動的扳手擰螺絲，那我們就來嘗試造一把電動的。</p><p style="text-align:justify">昇華點，再來想想終極的問題，那些業務同學告訴你現在他們做不到的事情，是不是技術能做到？很多事做不到，僅僅是因為只有一個理想化的思路，然而非人力不可為，但是，系統的出現或許就能解決的掉。當然要做到這一點，沒有長久的業務知識積累和自身對行業的理解是做不到的，也還有很長的路要走，但是要培養開始這樣思考的意識，想得多了總會有的，再換個常聽的詞就是<strong>技術賦能</strong>。</p><span id="OSC_h4_10"></span><h4><strong>審視</strong></h4><p style="text-align:justify">一開始做事情，在面對需求的時候，很容易就開始直接思考能不能做以及怎麼做的問題，但在此之前，其實還缺了問問題的過程，問什麼？問那些做事情以外的內容，不敢説自己的問題有多全面，但我更習慣將整個過程稱之為審視，我經常問的兩個問題，一個是為什麼要做，二是為什麼要我來做，<strong>一問價值，二問站位</strong>。</p><p style="text-align:justify">在價值的問題上，區別於調研階段的明確初衷以外，是要搞清楚這個事是不是個偽命題，以及這事這麼幹了能不能獲得解決問題目標方向上的最大收穫。其實，關於怎麼評估價值，不同的場景千千萬，難的不是<strong>如何定義價值</strong>，而是想到<strong>要先去定義價值</strong>，要明白俯首為牛的努力不完全可取。一件事情看不到價值就去做是去做苦功夫，<strong>但是苦勞不一定就是功勞，功勞更不一定有用</strong>，儘管很多事情在一開始的時候看不到結局，但是總會存在一個可以明確的初衷以及最初的判斷，不可能憑藉一句「我覺得行，我覺得有搞頭」就扎進去做事情的，現在只有自己一個人的時候，可能只是浪費了時間，如果將來有了團隊有了夥伴，這種模糊甚至於不過腦子的魯莽會導致整個團隊創造不出應有的價值，苦哈哈忙了一年沒個好收成。</p><p style="text-align:justify">在站位的問題上，很多時候我們問的出對價值的拷問，但是卻問不出站位的問題，站位和補位是有明顯差別的，<strong>如果一件事情誰都能做，那為什麼不是別人來做</strong>，難道僅因為跟我好説話就由我來做？其實並不盡然，一件事需要我做，總有需要我做以及適合我做且能做好的理由，哪怕僅僅是現階段的，但這卻是自身能區別於他人的理由，而這種區別也會體現在最終做事達成的結果上，每一個結果加上這個結果歷經的過程都會帶上非常濃重的個人或者團隊色彩，而這個色彩的積累又會成為一個人或者一個團隊區別於其他人或者其他團隊獨樹一幟的東西。</p><p style="text-align:justify">提問和思考總是同步的，把思路開放到編碼以外的事情上，看到事情會變得更加豐滿，回過頭來，再來思考什麼是想事情，大概就是對於現有的內容要分析透徹，找到切入點和站位以及在結果表象下的內在價值；對於未來的問題，找到問題發生的可能尋找機會，找到個人和團隊適合的發力點和着手點（抓手~）積極佈局。</p><span id="OSC_h3_11"></span><h3>談事情</h3><p style="text-align:justify">「凡人之所在，皆為江湖。」</p><p style="text-align:justify">更何況是我們這個號稱江湖的江湖？</p><p style="text-align:justify">其實在此前，我會認為做事情和想事情才是重中之重最核心的內容，對於談事情並不關注，工程師嘛，不愛整這些虛頭巴腦的東西（技術牛逼，天下第一），但是時間長了就發現，很多事情沒做成或者沒做好，不是硬件能力不行，明明所有的情景看上去都沒那麼難也想的到明確解法，但是就是不成事。大家不妨回憶下跨領域查線上問題的時候，是不是總有這樣一種感覺，明明問題的追查線路明確的很，就是你推他推，或者查着查着不知道在哪就沒下文了，到最後拖個兩三天甚至一週的時間才找到問題的原因，爛尾的也有不少。經歷這種事多了，慢慢開始對一句至理名言產生了認同的情緒：</p><p style="text-align:justify">「所有問題，最終都是人的問題。」</p><p style="text-align:justify">常在管理層的分享中聽到一個觀點説：「<strong>管理就是用人成事</strong>」，説到底還是這個觀點的延伸，給每一件事放到一個合適的位置上，找一堆合適的人，這件事就成了。但是人和人之間又不會像系統與系統間或者應用與應用間靠 MetaQ、HSF 就連起來了，還是得回到交流與溝通這些看似瑣碎的事情上。</p><p style="text-align:justify">同時，每個人走到後面，總會有自己要做事找資源或者成為 PM 的時候，對於開發這個領域而言，機器硬件上的事都有的商量，但是找人一起來共同做一件事的時候卻可能比要機器都難，總説開發資源，説到底不還是人。</p><p style="text-align:justify">只要是人，就要用人的方式來解決，「江湖不是打打殺殺，江湖是人情世故」。</p><span id="OSC_h4_12"></span><h4><strong>張嘴</strong></h4><p style="text-align:justify">回頭看，能圍着一件事穩穩當當的做，真的很可以稱之為一種幸福，不需要跟任何人扯皮、只用做好自己的事，對於一名開發工程師而言是做舒服的狀態。可是，就我的感受而言，當我慢慢走到前台需要用自己的嘴表達想法、推動進展的時候，才發覺這件事情或許會成為我乃至大多數工程師往前再走一步最致命的阻礙，張不開嘴，張嘴以後也不知道從何説起。</p><p style="text-align:justify">很多事情想明白需要做，也設計好了大概的執行思路，關鍵的問題在於，但凡有大作用的項目都需要有很多人蔘與，怎麼讓別人參與進來，讓他人接受，給他人闡述清楚能夠進場的位置並能共分成果卻成了這件事能否做下去的關鍵。説句不太上台面的話，有沒有人像我剛來的時候好奇過這樣一個問題，為啥這個環境裏再難的事，只要找一位「老阿里」出面，就能解決？按照我粗淺的認識不外乎兩個原因：老師傅們能找到更多的資源，多到可能原來都不是幹這一攤事情的人都能拉進來一起共擔風雨；老師傅們也深切知道別人到底想聽到什麼、關注什麼、擔心什麼、分享什麼，能把這事的前因後果、核心價值、風險回報講得明明白白，説服他人一起<strong>共同富裕</strong>。然後長此以往，老師傅們漸漸建立起了個人的品牌效應，大家慢慢就發現跟老師傅們合作有章法、效率高、有結果、不白乾、為人靠譜、值得信賴，如果下次還遇到老師傅攢局就值得一起搞，那可不就能達到振臂一呼，勇往無前的效果？從這一點來看一句説「<strong>資源的本質就是人情</strong>」，也沒什麼太偏頗的。</p><p style="text-align:justify">除了談資源外，與業務同學，需要理解需求的遠景，再來談定當前的近景，理想和規劃總是宏大，但是怎麼落到這一次的交付上；與產品同學，需要明確最終的產品設計方案與業務初衷是否有出入，迭代的分割與逐步推進節奏是否合理，找到一個既具備可行性又足以滿足階段性驗證的體量範圍，避免一上來大動干戈；與團隊內的技術夥伴，對於一大包的需求要素和工時，怎麼設定領域邊界，讓大家都能夠更專注於自己的內容去一起把事情做出來；與兄弟團隊的合作，怎麼商榷交互的邊界，團隊與團隊在某個具體問題上的劃分點在哪裏，才能既不衝突又無盲區。</p><p style="text-align:justify">相較於事情本身外，談事情看似雜亂無章，但是開始嘗試起來一但時間久了，也會形成自己的談事情風格和方法論，這種東西大部分<strong>只可意會不可言傳</strong>，重要的是<strong>要張嘴的意識</strong>，具體到場景和每個人的性格上，話術思路也不盡相同，或許有些事情別人談不妥，但是你就能有談妥的方案，最終也會沉澱為自身區別於他人的亮點，能説會道用的恰到好處了就不是貶義。</p><span id="OSC_h4_13"></span><h4><strong>閉嘴</strong></h4><p style="text-align:justify">張嘴好理解，但是閉嘴是什麼呢？</p><p style="text-align:justify"><strong>該聆聽的時候要閉嘴。</strong>一旦開始嘗試談事情，開始主導一些事情，這個過程在一段時間內容易上癮，慢慢就會變得無論什麼時候都想談，有點打開了新世界大門的新奇感。但是，這個時候就需要警惕了，如果開了一場會議，完事以後腦海裏只有自己的聲音，就需要反思是不是自己開始聽不進去事情了，是否忽略了合作人的觀點，儘管基層的開發工作沒那麼官僚，但是還是要避免一言堂的出現。要明白，<strong>啥都管就是啥都不管</strong>，人的精力有限，不可能每一件事都關注到，總要學着放手與放棄的，學着去交出主動權，多去聽別人有什麼想法，想怎麼搞，<strong>只要還在一張桌子上，説話叫談，聽話也叫談，張嘴用嘴，閉嘴用耳。</strong></p><p style="text-align:justify"><strong>有情緒的時候要閉嘴。</strong>談事情的時候切記不要帶着怨氣和敵意，很多人在談判的桌子上總強調氣場，這點沒錯，但是氣場不是聲音大、不是嗓子粗、不是拍桌子。不知道諸位有沒有遇到的這樣的場子，開會談邊界談需求的時候，聊着聊着就吵起來了，吵的飛起來，到最後彼此針對的不是這件事，就是針對這個人，「針對」已經不是找關鍵點了，而是真成了拿針對戳着，會議冗長沒準都開過吃飯的時間點，然後會議結束後也沒個結論，不僅浪費時間也浪費心情，有這個時間多去食堂幹碗飯不比什麼都強。己所不欲勿施於人，大家都是來工作的，開會就是開會，談事情就是事情，沒必要爭個誰把誰噴贏了，事情能辦成就行，再説一句，低頭不見抬頭見的，總這麼嗆着跟別人談事情，誰願意跟你談呢。善待周圍的同事吧，他們是夥伴，是戰友，很多事情都有的談，無論是工作還是生活上的事都可以聊一聊，互相學習下經驗，<strong>都是生來第一次做人，誰又敢説比別人活的通透，即便退隱江湖了，也不一定相忘於江湖。</strong></p><p style="text-align:justify">回到「談事情」這三個字上，這裏更想説的是一種意識，一種跳出事情、視人為人的意識，作為開發同學，學着認可説話是編碼以外的軟實力，慢慢的把自己的思路和做事方式轉變起來，把僅以用什麼樣的代碼來解決問題的觀點轉變下，也開始想想是否可用人來解決問題，不僅僅是團隊需要管理，人際關係也是。</p><span id="OSC_h3_14"></span><h3>在最後的「結」</h3><p style="text-align:justify">想法淺薄，行文拙劣，粗陋之談，個人觀點。</p><p style="text-align:justify">若有幫助，榮幸萬分，如覺無意，笑談也罷。</p><p style="text-align:justify">當然還是希望能與感興趣的同學多多交流~「永無止境，諸君共勉。」</p><p style="text-align:justify">作者｜向知</p><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1403806%3Futm_content%3Dg_1000387262" target="_blank">原文鏈接</a></strong></p><p style="text-align:justify"><strong>本文為阿里雲原創內容，未經允許不得轉載。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 13 Jan 2024 02:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10576005</guid>
            <link>https://my.oschina.net/yunqi/blog/10576005</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[羅永浩細紅線公司轉做大模型？內部人士：不實，仍專注 AR 研發]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>搜狐科技今天下午報道，羅永浩的細紅線 AR 業務軟硬件研發放緩、AR 相關業務裁員，或將轉向大模型行業。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-31b283e926e185d438709c4c767920d8593.png" referrerpolicy="no-referrer"></p><p>有行業高管向搜狐科技透露，羅永浩已不再做 AR 硬件，可能打算去做大模型，「他就是投機分子。」 一位被裁員的細紅線員工告訴搜狐科技，元旦前細紅線的 AR 業務確實有一輪裁員，且並非首輪裁員。該員工透露，「自研引擎方向不做了，設備這塊兒也不急了。」</p><p>據悉，細紅線的引擎和 XR 應用研發正式編 12 人，研發 10 人左右，整體裁了一半的人。據企查查顯示，細紅線科技人員規模不足 50 人，2022 年參保人數 35 人。該員工透露，公司給到的裁員解釋就一句話「這塊兒不做了」，入職不到半年的員工賠償方案也給了 N+1。該員工表示，入行後他的感知是，「該行業是長期積累才能出成果的，基本是長期燒錢投入。」他對裁員表示理解。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffinance.sina.com.cn%2Ftech%2Fshenji%2F2024-01-12%2Fdoc-inachcsx4929830.shtml" target="_blank">新浪科技進行了後續跟蹤報道</a></u>，針對媒體報道「羅永浩的細紅線公司業務從 AR 轉型大模型」一事，該公司人士稱，報道不實，羅永浩仍專注於 AR 軟硬件。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e250506e141bb2f5d72156e7043145e092d.png" referrerpolicy="no-referrer"></p><p>一個月前，羅永浩在直播時談及了其創業項目細紅線的進展。他表示，已經埋頭研發了一年，故意沒有聲音。</p><p>此前，羅永浩曾表示，絕對相信 AR 會是下一代計算平台，尤其是現在的 AR 在全球都沒有一個成功的品牌和標杆。他想在 AR 時代搶先做出一個像 2007 年的 iPhone + iOS 一樣的東西，成為下一個平台上類似蘋果一樣的公司。「這是最後一次機會，相信一定會給這個世界留下一些東西。」</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 10:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275479</guid>
            <link>https://www.oschina.net/news/275479</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[中電金信加入 openKylin，攜手推動金融應用生態建設]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span><span style="color:#000000">近日，中電金信軟件有限公司（以下簡稱「中電金信」）簽署了 openKylin 社區 CLA（Contributor License Agreement 貢獻者許可協議），正式加入 openKylin 開源社區。</span></span></p><div><p style="text-align:center"><img alt="" height="1079" src="https://oscimg.oschina.net/oscnet/up-0405c82222935966a1c10f116c1852f2647.png" width="829" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">中電金信，中國電子旗下成員企業，通過持續研發創新，參與國家重大工程，依託行業場景，構建金融級數字底座，打造全棧全域解決方案，提供領先的諮詢、軟件產品及開發、質量安全保障及運營服務，為金融等重點行業數字化轉型及安全發展提供強大動能，並以中國數字化轉型最佳實踐服務全球。</span></span></p><div><p style="text-align:center"><img alt="" height="410" src="https://oscimg.oschina.net/oscnet/up-efb7554bb3a11fbb0bfbd65ba61da97d2ba.png" width="940" referrerpolicy="no-referrer"></p></div><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span><span style="color:#000000">加入 openKylin 社區後，中電金信將利用自身在金融行業裏的優勢資源，依託 openKylin 社區開展金融應用生態匯聚平台建設與推廣，從而完善 openKylin 開源操作系統在金融領域的應用生態。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 09:06:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275465</guid>
            <link>https://www.oschina.net/news/275465</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[盤點 2023 「很刑」的 IT 民生事件：視頻軟件白嫖帶寬、程序員改 ETC 餘額……]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>關注 IT 相關民生事件，以老百姓的眼睛看 IT 圈，和開發者零距離接觸。回顧一下 2023 年那些很刑的 IT 民生事件。</p><hr><h4><a href="https://www.oschina.net/news/248591">愛奇藝客戶端「白嫖」電視機帶寬，後台滿速上傳</a></h4><p>一網友發帖稱，自己的電視機在息屏休眠狀態時，居然持續保持着 1-5M/s 的上傳速度，直至斷掉電源才停止上傳。</p><p>而這台新買的電視機上安裝的 APP 只有愛奇藝。在他強制關閉愛奇藝 APP 後，電視機的上傳速度馬上變為零。</p><p>對此，愛奇藝客服給出的迴應是，這是加速手段，對使用沒有影響，並提供了關閉 HCDN 開關的操作。HCDN (Hybrid CDN) 是愛奇藝技術團隊研發的大規模混合架構在線視頻數據分發技術。</p><p>有網友指出，這是愛奇藝客戶端將電視機當成了自己的 PCDN 服務器，因此會在後台持續執行上傳任務。這種白嫖電費、流量、存儲空間的操作，愛奇藝要給用戶打錢才對。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a9c6a586c98baf79a09b17e5874bea9908e.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/247736">人大畢業生盜取全校學生信息建顏值打分網站，</a><a href="https://www.oschina.net/news/247736">結局很「刑」</a></h4><p>中國人民大學一名碩士畢業生涉嫌在校期間非法獲取全校學生的個人信息， 並利用這些信息製作了一個給學生顏值打分的網站。</p><p>針對 「中國人民大學部分學生信息被非法獲取」 的情況，海淀警方接到報警，後立即開展調查。 經查，嫌疑人馬某某（男，25 歲，該校畢業生）涉嫌非法獲取該校部分學生，個人信息等違法犯罪行為，後被海淀公安分局依法刑事拘留。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9c5534c3ac21396855978eba5ff4ec4956f.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/247569">員工盜用公司遊戲源代碼「換皮」上線，半年盈利 1.5 億</a></h4><p>上海一遊戲公司三名員工利用職務之便，在從原公司離職前盜取了公司開發的手遊源代碼；並將該手遊的源代碼提供給了另一家網絡公司，對方進行簡單「換皮」之後就開始上線經營。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-23335c46b5ab4511525521a720cc3f319ce.jpg" referrerpolicy="no-referrer"></p><p>為了成功上線，離職員工還套用了原公司的《計算機軟件著作權登記證》和《網絡遊戲出版核發單》。警方鑑定發現，兩款遊戲在服務器數據表和服務器戰鬥服上的相似度達到 100%，服務器遊戲服和客戶端相似度也在 90% 左右。</p><p>據統計，自盜版遊戲上線半年以來，盈利超過 1. 5 億，盜取源代碼的三名員工分得利潤超過 1500 萬。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/259325">罰款 200 元，沒收 100 多萬</a></h4><p>2023 年 9 月，一微博博主發文稱自己 「翻牆訪問國際互聯網打工被處罰百萬」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-4c9d4c52a10a1b05cf39730b000daa514e2.png" referrerpolicy="no-referrer"></p><p>根據這名博主提供的資料，在 2019 年 9 月份至 2022 年 11 月期間，他在家中擅自使用非法信道進行國際聯網，為境外公司提供網絡顧問服務，違法所得共計人民幣 1058000 餘元。</p><p>根據《中華人民共和國計算機信息網絡國際聯網管理暫行規定》第六條和第十四條、《中華人民共和國計算機信息網絡國際聯網管理暫行規定實施辦法》第七條和第二十二條第一款之規定，這名博主受到了行政處罰，並處罰款貳佰元整，沒收違法所得一百零五萬八千元。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/267760">程序員篡改 ETC 餘額，一年私吞 260 餘萬元</a></h4><p>2023 年 9 月，上海警方接到某科技公司員工張女士報案稱，其公司發現計算機系統被他人篡改數據，導致公司賬戶錢款損失。民警對公司後台電子數據出現的異常賬戶進行提取，蒐證中發現，操作者很有可能是管理網站後台系統的員工，監守自盜的可能性較大。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/1123/140254_7G6Y_2720166.png" referrerpolicy="no-referrer"></p><p>民警隨即展開工作，最終嫌疑人曹某迫於壓力主動投案自首。曹某是該公司的軟件工程師，他坦白稱，去年 8 月發現公司網站後台的漏洞，用母親和朋友身份證註冊了兩個 ETC 賬戶。一年內兩個賬戶分別從公司提取來了 230 餘萬元和 36 萬元，總計 260 餘萬元。最終曹某因涉嫌盜竊罪被依法刑事拘留。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/question/4518173_2330072">知名主播售賣基於開源軟件的解決方案，收費 2 萬</a></h4><p>B 站 50 萬粉絲 up 主通過另一名知名主播購買基於開源軟件的導播台方案：將手機攝像頭畫面推流到 PC，再通過 OBS 推流，使用了 Zerotier + 芯象。共計支付 2 萬。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2b14fad8ac6829292d6a10e158067f840bc.png" referrerpolicy="no-referrer"></p><p>網友稱這名 up 主喜提超級憨憨大冤種獎。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/258135">網易伏羲迴應員工「因 BUG 被 HR 威脅」離世</a></h4><p>2023 年 9 月，網傳消息稱，網易伏羲團隊員工因工作原因在出租屋自殺離世；並表示，該員工曾 「因 BUG 被 HR 威脅」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-c6939d41a10f9b07824a2c51be44ec3f285.png" referrerpolicy="no-referrer"></p><p>9 月 14 日，網易伏羲針對此事發布內部信公佈事發經過，稱員工存在抑鬱傾向，HRBP 在瞭解到情況後為其安排了休假。並表示經過調查還原和分析，暫未發現 「HR 威脅」 相關動機和證據。</p><p>與此同時，該公司還公佈了一系列後續關懷方案。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/251050">新型 Apple ID 詐騙：開啓雙重認證仍被釣魚</a></h4><p>2023 年 7 月，V2EX 有網友發帖詳細描述了一個新的詐騙過程：在 Apple ID 開通雙重認證的情況下，被高仿的李鬼 App 誘騙出密碼，並被添加信任號碼、家庭共享，再通過家庭共享成員完成消費。但整個過程中，原設備並未出現新設備登錄時需要的雙重認證驗證碼，也就是説雙重驗證並未起作用。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ea62ba234788657a2c24a9dc589879e9f59.png" referrerpolicy="no-referrer"></p><p>根據博主 @BugOS 技術組，的測試，受信設備中的應用拉起隱藏 WebView 訪問 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fappleid.apple.com" target="_blank">appleid.apple.com</a> 無需雙重驗證，這一重大漏洞使得用戶掃個臉即可登錄。該 App 又用假的對話框騙取密碼，然後將詐騙者的手機號加入雙重認證的信任號碼，直接遠程抹掉設備，使用戶無法接收扣款信息，並進行盜刷。</p><p>並表示，當 iPhone 上出現輸入 Apple ID 密碼的窗口時，按 Home 鍵或上劃手勢嘗試退出一下，能退出的都是在詐騙。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/258341">1400 多萬部老年手機被植入木馬，「自動訂購」 增值業務</a></h4><p>四川省攀枝花市公安機關網安部門在 2023 年成功偵破一起非法控制計算機信息系統案。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/0916/113005_rqI2_2720166.png" referrerpolicy="no-referrer"></p><p>經警方調查，犯罪嫌疑人與老年手機方案商、生產商勾結，在老年機生產環節中植入木馬程序，在手機使用者不知情的情況下，後台訂購 SP 增值業務，並與 SP 商分成獲利（SP 即 Service Provider，服務提供商）。</p><p>2023 年 2 月，公安機關對該案開展集中收網，專案民警分別趕赴廣東、北京、海南、湖南等地共抓獲嫌疑人 29 名，凍結涉案資金 6000 餘萬元。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/260711">蘋果 App Store 免費榜第一是黃色軟件</a></h4><p>蘋果 App Store 被發現存在一個偽裝成學習軟件的黃色軟件，並且衝上了「免費 App」排行榜第一名。該軟件的年齡分級為 4 歲以上，但是會引導用戶進入賭博和其他黃色網站。有網友下載了這款軟件，想要學習英語字母，結果卻發現是一個色情視頻軟件。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-69f6205b4eceb10672c0a3cff67e4f52d48.png" referrerpolicy="no-referrer"></p><p>事件被曝光後，蘋果客服雖然進行了迴應，但直到當天下午仍未下架軟件。甚至排行榜更新後，App Store 免費榜第一、二名再次出現黃色軟件。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/261799">國美 App 抽獎頁面彈窗辱罵其創始人</a></h4><p>2023 年 10 月，在國美 iOS 和 Android App 的 「幸運大轉盤」 抽獎頁面出現了一個彈窗，裏麪包含辱罵國美電器董事長黃秀虹、創始人黃光裕的內容，以及指控國美 「拖欠工資」「拖欠貨款」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-5d1b6e65dedc28ef9f0bf144a3378dd109b.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/265338">繼 VS Code 後，開源直播推流軟件 OBS Studio 被賣 43 元</a></h4><p>百度搜索 "obs"，前幾條基本都是廣告。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9f209a6215794edd03066f3bc45f8b963b6.png" referrerpolicy="no-referrer"></p><p><img alt="up-aff319a90e79bfd09a3e9087d4164b93866.png" src="https://oscimg.oschina.net/oscnet/up-aff319a90e79bfd09a3e9087d4164b93866.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/267276">運營商神操作：後台斷網、停用寬帶賬號，強迫用戶更換光貓</a></h4><p>河南周口聯通為了強迫用戶更換光貓，公司在後台停掉用戶的寬帶賬號，導致用戶無法上網，然後讓工程師上門 「維修」， 謊稱光貓損壞，需要花 299 元換新。更換完後，聯通再在後台恢復用戶的網絡。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/1120/163843_Utox_2720166.png" referrerpolicy="no-referrer"></p><p>聯通公司不僅對老用戶進行這種強制更換光貓的行為，還會在給新用戶裝機的時候，故意使用破舊光貓，也就是之前強迫用戶換新留下的，而再過一段時間之後，又會告訴用戶使用的是舊光貓無法匹配，必須換新。聯通公司還會故意關掉用戶的短信服務，在後台增加增值業務，之後再把短信功能打開，以此牟利。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-6bca55961849d5db6bafd2b8cf31a04abc6.png" referrerpolicy="no-referrer"></p><p>這種強制更換光貓的行為並非新鮮事。早在 2022 年上半年，就有不少用戶投訴聯通公司，以寬帶升級為由強制用戶更換光貓，否則就無法上網。其中有的投訴明確是河南聯通公司，有的則未明確具體地區。</p><hr><p>其他年度盤點：</p><ul><li><u><strong><a href="https://www.oschina.net/news/273501">B 站崩了兩次、騰訊「3.29」一級事故……盤點 2023 十大宕機事故「冥場面」</a></strong></u></li><li><u><strong><a href="https://www.oschina.net/news/273843">MySQL 5.7、魔趣、李跳跳……盤點 2023 「停更」的項目和網站</a></strong></u></li><li><u><strong><a href="https://www.oschina.net/news/274330">.NET 8、Mojo🔥、Bun 1.0……最硬核極客的年度發版彙總</a></strong></u></li></ul><p>更多年度重磅事件回顧，<em><u><strong><span style="background-color:#e67e22">查看</span><a href="https://talk.gitee.com/report/china-open-source-2023-annual-report.pdf?fr=1024eye_news0112" target="_blank"><span style="background-color:#e67e22">《2023 中國開源開發者報告》</span></a></strong></u></em>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-d61e19776f176f066edf96c9d335883b471.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-ea5bc926c05237a7f7970438f10c5a0e3d2.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 07:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275447</guid>
            <link>https://www.oschina.net/news/275447</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linus 在 Linux 6.8 內核發現性能倒退問題]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Linus Torvalds 在內核郵件列表<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Flkml%2FCAHk-%3DwgWcYX2oXKtgvNN2LLDXP7kXkbo-xTfumEjmPbjSer2RQ%40mail.gmail.com%2F" target="_blank">指出</a></u>，他最近在合併 Linux 6.8 內核代碼的時候發現性能下降——具體表現是構建時間異常的久。</p><p>Linus 表示，以編譯構建空內核 (empty kernel build) 版本為例，創建時間從 22 秒變成了 44 秒，這也讓編譯構建完整內核的速度大大降低。Linus 稱導致性能衰退的代碼就出現在這些等待合併的 Pull 代碼中，所以他不得不還原某些東西 —— 這讓 Linux 6.8 內核的合併窗口期非常痛苦。&nbsp;</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-a76bd7e29f257c823ca9c6578aa7e8efd5d.png" referrerpolicy="no-referrer"></p></blockquote><p>Linus 繼續<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Flkml%2FZTz9RpZxfxysYCmt%40gmail.com%2FT%2F%23t" target="_blank">寫道</a></u>：</p><blockquote><p>如果沒猜錯的話，第一個錯誤提交是 9c0b4bb7f6303c9c4e2e34984c46f5a86478f84d，但為了乾淨地恢復，我必須對所有代碼都進行恢復。</p><p>這是在 32 核（64 線程）AMD Ryzen Threadripper 3970X 上實現的。</p><p>我將暫時把該還原保留在我的私有測試樹中（這樣我就又有了一台能正常工作的機器），但除非有人能快速解決這個問題，否則我會將其從主分支中移除。</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 07:24:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275438/linux-6-8-sched-regression</guid>
            <link>https://www.oschina.net/news/275438/linux-6-8-sched-regression</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[中國電信星辰 AI 大模型開源]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>中國電信宣佈將自研星辰 AI 大型模型全面開源，公開其底層代碼、算法邏輯及其預製的各種基礎大模型、開發模塊、訓練工具等核心產品能力。</p><p>用戶既可以直接調用大模型，也可以根據自身業務需求對大模型進行微調或個性化設置，或者加載自己的知識庫或數據，從而調整出更符合自身業務需求、更加個性化的理想結果。</p><p>根據介紹，由中國電信完全自主研發的國內領先星辰系列大模型，構建了語義、語音、視覺及多模態大模型完備的基礎框架。其中語義大模型於 11 月份發佈千億參數版本，在大模型知名榜單 CSL 排名第五、GAOKAO 排名第七、AGIEval 排名第八。</p><p>視覺大模型賦能 100+城市治理下游任務，算法日均調用量達 3.3 億次；多模態大模型聚焦圖文生成和圖文理解能力，採集超過 12 億的風格數據，文圖檢索精度達到 SOTA，支持 20+風格生成。</p><p>語音大模型可實現高精度多方言的語音識別以及多語種、多風格、多音色的語音合成。與此同時，中國電信星辰系列大模型在覆蓋視覺、語義、語音等多模態領域的 20 項國內外權威競賽中斬獲多項大獎，充分展現了國資央企在人工智能領域的自研實力和決心。</p><p>2023 年 11 月，中國電信宣佈成立了中電信人工智能科技有限公司，專注於 AI 核心技術的研發。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 05:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275416</guid>
            <link>https://www.oschina.net/news/275416</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[RustRover 中最常見的 Rust 編譯器錯誤（上）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><p style="text-align: center;" data-mpa-powered-by="yiban.io"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100021881" data-ratio="0.1836734693877551" src="https://oscimg.oschina.net/oscnet/d9b44586-4a1a-4d06-b939-38535ee2708a.gif" data-type="gif" data-w="637" style="display: inline;" referrerpolicy="no-referrer"></p><section style="font-size: 15px;color: rgb(33, 33, 33);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">Rust 編譯器相當挑剔， 如果它對輸入的源代碼不滿意，可能會發出 400 多種不同的錯誤（而且每個月都在增加！）。有些錯誤極其罕見，另一些則每天都困繞着 Rust 開發者。在這個博文系列中，我們將介紹開發者在 RustRover（JetBrains 推出的專屬 Rust IDE）中遇到的最常見 Rust 編譯器錯誤消息，並説明如何避免這些錯誤。首先，我們來看一下「最常見錯誤」實際上指的是什麼。</p><span id="OSC_h2_1"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">從 RustRover 的使用數據中識別最常見的錯誤</span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">任何 RustRover 用戶都可以選擇向 JetBrains <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.jetbrains.com.cn%2Fhelp%2Fidea%2Fsettings-usage-statistics.html" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">發送其匿名使用數據</a>。通過分析這些數據，我們可以觀察各種用戶模式並深入探究如何改進 IDE。當然，我們非常重視您的隱私，因此 IDE 收集的信息非常有限。例如，數據中的任何內容都無法追溯到用戶。但匿名數據仍然可以告訴我們 IDE 的一般使用情況，例如最常生成的錯誤消息類型。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">當選擇加入的用戶通過 IDE 啓動 Cargo Build 命令（例如，通過觸發需要構建項目的運行配置）並且 Rust 編譯器發出錯誤時，我們就會記錄<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror_codes%2Ferror-index.html" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">錯誤代碼</a>。這不包括用戶編寫代碼時出現的<em style="font-size: inherit;color: inherit;line-height: inherit;">所有</em>代碼問題，僅包括在用戶構建項目後仍然存在的問題。中間錯誤通常可以通過 IDE 的檢查和快速修復處理。用戶向我們發送的使用數據越多、使用 RustRover 的頻率越高，我們就越能瞭解他們的體驗，也就越能改進 IDE 的代碼輔助功能。因此，感謝所有加入的用戶通過其使用數據幫助我們改進 RustRover！</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">我們從運行 RustRover 的用戶處收集錯誤代碼，並根據遇到錯誤的用戶數量對其排名。本系列的這一部分將討論第 10 到 6 名最常見錯誤，下一部分將揭示前 5 名最常見錯誤。我們將研究這些錯誤背後的原因，探索簡單示例，並探討潛在修正方式。</p><span id="OSC_h2_2"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">常見錯誤 #10：E0412<em style="font-size: inherit;color: inherit;line-height: inherit;">（使用的類型名稱不在作用域內）</em></span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">Rust 在類型聲明點和類型名稱用法之間保持嚴格區分。每個類型名稱（包括泛型類型）都必須在某處聲明，並且在其使用作用域內可用。如果編譯器遇到類型名稱用法但沒有關於其聲明點的任何信息，則會發出 E0412。大約 12% 的 RustRover 用戶遇到過此錯誤。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">假設您輸入了 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">i42</code> 而不是 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">i32</code>， RustRover 會發現問題並高亮顯示未知類型名稱。編譯器提供了更多詳細信息並建議修正，點擊編譯器輸出中的 <em style="font-size: inherit;color: inherit;line-height: inherit;">Apply fix</em>（應用修正）按鈕即可輕鬆應用：</p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-imgfileid="100021882" data-ratio="0.562962962962963" src="https://oscimg.oschina.net/oscnet/b1e477d9-a790-4641-ae7b-73db95282f28.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption></figure></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">其他導致 E0412 的情況包括：</p><ul style="font-size: inherit;color: inherit;line-height: inherit;padding-left: 32px;" class="list-paddingleft-1"><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">忘記聲明類型。</span></p></li><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">將類型導入到當前作用域。</span></p></li><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">引入泛型類型名稱而使編譯器無法訪問類型。</span></p></li></ul><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">要修正這一問題，可以提供類型聲明（聲明結構或正確引入泛型類型名稱）或將類型引入作用域（通過 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">use</code> 子句）。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror_codes%2FE0412.html" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">官方 E0412 錯誤説明</a>給出了此錯誤的更多示例。</p><span id="OSC_h2_3"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">常見錯誤 #9：E0061（<em style="font-size: inherit;color: inherit;line-height: inherit;">調用函數時傳遞的實參數量無效</em>）</span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">雖然 RustRover 可以感知到這個錯誤並提供一系列修正，但 13% 的 RustRover 用戶會在構建項目之前忽略這個錯誤。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">錯誤本身不需要過多解釋：我們有一個函數，要麼在當前作用域中聲明，要麼從其他地方導入，而調用點給出的實參太少或太多。我們來看一個示例，並比較 RustRover 的建議和 Rust 編譯器的建議：</p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-imgfileid="100021892" data-ratio="0.562962962962963" src="https://oscimg.oschina.net/oscnet/a3e4b8f4-6b6a-4f1f-aa79-cfbb6ef242ba.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption></figure></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">這個示例展示了一個<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fadventofcode.com%2F" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">常見場景</a>：打開文件。如果我們習慣了使用其他編程語言編碼，就可能提供第二個實參，忘記在 Rust 中這個方法只需要一個實參。RustRover 和 Rust 編譯器都建議移除第二個實參。很好，我們不需要構建項目就可以從 IDE 獲得實用建議。注意代碼中的紅色波浪線，它們通常都有意義！</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">如果調用的函數是在我們自己的代碼中定義的，情況就更有趣了。假設我們繼續添加到相同的代碼示例：</p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-imgfileid="100021883" data-ratio="0.562962962962963" src="https://oscimg.oschina.net/oscnet/42fae6ba-c908-48d3-a891-c9bfceb1a339.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption></figure></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">在這種情況下，RustRover 建議向函數添加形參作為第一個替代方案，這應該沒有問題。但 Rust 編譯器則堅持將其移除。這種差異有其原因。編譯器的工作是確保程序正確，為此，最簡單的方式就是消除調用點的額外實參。然而，IDE 的作用是讓您更接近您想要達成的目標。如果您是為自己的函數輸入了這個實參，那麼您很有可能是有意為之，因此 RustRover 會嘗試幫助您完成工作。</p><span id="OSC_h2_4"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">常見錯誤 #8：E0282（<em style="font-size: inherit;color: inherit;line-height: inherit;">編譯器無法推斷類型並要求類型註解</em>）</span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">有時編譯器會不知所措，無法確定變量所需的類型，只能建議手動添加類型註解。如果您遇到過這個錯誤，您並不孤單，13.5% 的 RustRover 用戶也遇到過。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">E0282 這樣的錯誤主要源於泛型性。許多庫函數都採用泛型類型形參，但編譯器必須將這些形參實例化為具體類型，因而陷入困惑。請查看以下示例：</p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-imgfileid="100021884" data-ratio="0.562962962962963" src="https://oscimg.oschina.net/oscnet/978d3023-c1c4-4b46-83fc-18c4a6b2dc55.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption></figure></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">我們想要將字符串中的數字收集到容器中。然而，編譯器不能確定它們是什麼類型的數字或什麼類型的容器。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">編譯器建議首先指定容器類型。但是，如果應用此修正，我們將再次遇到相同類型的錯誤，涉及 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">str::parse</code>。<code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">collect</code> 和 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">parse</code> 都是泛型方法，但編譯器需要知道確切類型才能編譯使用它們的代碼。請注意，RustRover 沒有高亮顯示錯誤，因為我們仍在完善其類型檢查功能。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">可以通過多種方式修正這個問題，因為不止一個地方可以添加類型註解。我們可以指定 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">numbers</code> 向量的具體類型：</p><section style="font-size: 15px;color: rgb(33, 33, 33);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><pre style="font-size: inherit;color: inherit;line-height: inherit;"><code style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;padding: 0.5em;background: rgb(43, 43, 43);color: rgb(186, 186, 186);overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;display: -webkit-box !important;"><span style="font-size: inherit;line-height: inherit;color: rgb(224, 196, 108);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;numbers:&nbsp;Vec&nbsp;=&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(106, 135, 89);overflow-wrap: inherit !important;word-break: inherit !important;">"1&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;3"</span></code></pre></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">或者我們可以在調用 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">collect</code> 時提及相同的類型：</p><section style="font-size: 15px;color: rgb(33, 33, 33);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><pre style="font-size: inherit;color: inherit;line-height: inherit;"><code style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;padding: 0.5em;background: rgb(43, 43, 43);color: rgb(186, 186, 186);overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;display: -webkit-box !important;">&nbsp;&nbsp;&nbsp;.collect::&lt;Vec&gt;();</code></pre></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">最後，我們可以在不同的地方提及不同的類型：</p><section style="font-size: 15px;color: rgb(33, 33, 33);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><pre style="font-size: inherit;color: inherit;line-height: inherit;"><code style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;padding: 0.5em;background: rgb(43, 43, 43);color: rgb(186, 186, 186);overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;display: -webkit-box !important;">let&nbsp;numbers&nbsp;=&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(106, 135, 89);overflow-wrap: inherit !important;word-break: inherit !important;">"1&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;3"</span><br>&nbsp;&nbsp;&nbsp;.split_whitespace()<br>&nbsp;&nbsp;&nbsp;.map(str::parse::)<br>&nbsp;&nbsp;&nbsp;.map(Result::unwrap)<br>&nbsp;&nbsp;&nbsp;.collect::&lt;Vec&gt;();</code></pre></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">這個錯誤很容易修正，指定需要的類型即可。</p><span id="OSC_h2_5"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">常見錯誤 #7：E0432（<em style="font-size: inherit;color: inherit;line-height: inherit;">import 未解析</em>）</span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">RustRover 提供了大量自動補全功能。例如，我們首先在代碼中引入正則表達式：</p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-imgfileid="100021891" data-ratio="0.26296296296296295" src="https://oscimg.oschina.net/oscnet/991479fb-fa12-44ad-a42a-ed6fe504fef6.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption></figure></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">如果選擇第一個建議，除了補全本身，還會發生兩件事：</p><ul style="font-size: inherit;color: inherit;line-height: inherit;padding-left: 32px;" class="list-paddingleft-1"><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p>對 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">regex</code> crate 的依賴將添加到您的<kbd style="font-size: inherit;color: inherit;line-height: inherit;">Cargo.toml</kbd>中。</p></li><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">use regex::Regex;</code> 子句將添加到文件頂部。</p></li></ul><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">添加這樣的 use 子句時，import 會自動正確寫入。但有時您需要手動編寫 import，這時就可能出現 E0432 錯誤。15.5% 的 RustRover 用戶會不時遇到這種情況，最有可能是因為他們拼錯了 crate 或模塊名稱，嘗試導入不存在的內容，或者從某處複製粘貼後將錯誤的 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">use</code> 子句帶入代碼。第一個建議始終是檢查依賴項和名稱。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">有時 RustRover 可以幫助防止此錯誤。如果知道我們嘗試導入的 crate，它可以在您從外部源粘貼代碼時建議添加依賴項，或者通過以下快速修復提供支持：</p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-imgfileid="100021890" data-ratio="0.21388888888888888" src="https://oscimg.oschina.net/oscnet/b8d64c46-9612-4d85-8b3a-246fb1c68af8.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption></figure></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">將相應依賴項添加到<kbd style="font-size: inherit;color: inherit;line-height: inherit;">Cargo.toml</kbd>可以立即修正此錯誤。在 crate 可用後，對 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">use</code> 子句中的其他路徑組件使用自動補全能夠避免出現更多名稱問題。另請注意，某些名稱的可用性可能取決於 crate 的啓用功能。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">super</code> 或 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">crate</code> 這樣的特殊路徑名稱也可能存在問題，特別是在不同的 Rust 版本中要以不同的方式處理。請參閲<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror_codes%2FE0432.html" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">官方説明</a>瞭解詳情。</p><span id="OSC_h2_6"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">常見錯誤 #6：E0382（<em style="font-size: inherit;color: inherit;line-height: inherit;">內容移動到其他位置後變量才被使用</em>）</span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">接下來是所有權問題， 17% 的 RustRover 用戶遇到過這個錯誤。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror_codes%2FE0382.html" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">官方説明</a>相當詳細，並提供了許多示例。可惜，RustRover 在這裏沒有太大幫助。如果禁用<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.jetbrains.com.cn%2Fhelp%2Frust%2Frust-external-linters.html" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">外部 linter</a>，RustRover 的內部機制不會發現以下代碼有任何問題：</p><section style="font-size: 15px;color: rgb(33, 33, 33);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><pre style="font-size: inherit;color: inherit;line-height: inherit;"><code style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;padding: 0.5em;background: rgb(43, 43, 43);color: rgb(186, 186, 186);overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;display: -webkit-box !important;"><span style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">fn&nbsp;<span style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">main</span>(<span style="font-size: inherit;line-height: inherit;color: rgb(185, 185, 185);overflow-wrap: inherit !important;word-break: inherit !important;"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(203, 120, 50);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;vec&nbsp;=&nbsp;vec![<span style="font-size: inherit;line-height: inherit;color: rgb(104, 150, 186);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>,&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(104, 150, 186);overflow-wrap: inherit !important;word-break: inherit !important;">2</span>,&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(104, 150, 186);overflow-wrap: inherit !important;word-break: inherit !important;">3</span>,&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(104, 150, 186);overflow-wrap: inherit !important;word-break: inherit !important;">4</span>,&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(104, 150, 186);overflow-wrap: inherit !important;word-break: inherit !important;">5</span>];<br>&nbsp;&nbsp;&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(203, 120, 50);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;mut&nbsp;sum&nbsp;=&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(104, 150, 186);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>;<br>&nbsp;&nbsp;&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(203, 120, 50);overflow-wrap: inherit !important;word-break: inherit !important;">for</span>&nbsp;v&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(203, 120, 50);overflow-wrap: inherit !important;word-break: inherit !important;">in</span>&nbsp;vec&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;v;<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;println!(<span style="font-size: inherit;line-height: inherit;color: rgb(106, 135, 89);overflow-wrap: inherit !important;word-break: inherit !important;">"Sum&nbsp;of&nbsp;{vec:?}&nbsp;elements&nbsp;is&nbsp;{sum}"</span>);<br>}</code></pre></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">這段看似無辜的代碼在其他幾種編程語言中完全合法。我們有一個向量，想要計算其元素的總和。例如，假設我們使用 C 語言，不知道迭代器的函數式編程技巧，我們需要編寫傳統的 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">for</code> 循環。完成所有求和後，我們就可以輸出向量和計算結果。右側?</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">在 Rust 中不行，因為它有所有權規則。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">問題在於，<code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">for</code> 循環中的數據源擴展到具有整個向量的所有權的 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">into_iter()</code> 調用。因此，嘗試訪問 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">println!</code> 中向量的元素時，編譯器會表示它已被移動。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">修正很簡單，並且由編譯器建議：迭代 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">&amp;vec</code>，避免將其<em style="font-size: inherit;color: inherit;line-height: inherit;">移入</em>循環，而應改為<em style="font-size: inherit;color: inherit;line-height: inherit;">借用</em>。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">一般來説，建議始終跟蹤值所有權。移動值和借用值是 Rust 的基本概念， 理解它們是每個學習者的首要任務。</p><span id="OSC_h2_7"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">更新一覽</span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">在博文系列的第一部分中，我們根據 RustRover 中的使用數據定義了最常見的 Rust 編譯器錯誤，並討論了第 10 到第 6 名的錯誤。在下一部分中，我們將探索最常見的 5 個錯誤，並嘗試回答每個 Rust 開發者都會考慮的問題：「Rust 的哪一部分最麻煩？」</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><br></p></section><section style="font-size: 16px;"><section style="transform: perspective(0px);transform-style: flat;" powered-by="xiumi.us"><section style="margin-top: 10px;text-align: right;justify-content: flex-end;display: flex;flex-flow: row;transform: rotateY(180deg);"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="transform: perspective(0px);transform-style: flat;" powered-by="xiumi.us"><section style="transform: rotateY(180deg);"><section style="color: rgb(125, 125, 125);font-size: 13px;"><p><strong>本博文英文原作者：</strong><strong>Vitaly Bragilevsky</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></section></section></section></section><section style="" powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="text-align: center;justify-content: center;display: flex;flex-flow: row;margin-top: 10px;margin-bottom: 20px;" powered-by="xiumi.us"><section style="display: inline-block;width: auto;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 1px;min-width: 5%;height: auto;box-shadow: rgb(255, 92, 0) 6px 6px 0px 0px;padding: 8px;"><section style="text-align: left;" powered-by="xiumi.us"><section style="text-align: justify;font-size: 17px;color: rgb(255, 92, 0);"><p style="text-wrap: wrap;"><strong>RustRover 相關閲讀</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></section></section><a title="https://mp.weixin.qq.com/s?__biz=MzkwNDI5NzUyMQ==&amp;mid=2247503998&amp;idx=1&amp;sn=c80abda34362d92eb4077c7176fbf9c7&amp;chksm=c08bbd20f7fc34367671f223323fdcad7d4a69e299793bab51144717a9a3902159a5a51a4227&amp;token=702672088&amp;lang=zh_CN&amp;scene=21#wechat_redirect" formlinkparm="[{&quot;href&quot;:&quot;https://mp.weixin.qq.com/s?__biz=MzkwNDI5NzUyMQ==&amp;mid=2247503998&amp;idx=1&amp;sn=c80abda34362d92eb4077c7176fbf9c7&amp;chksm=c08bbd20f7fc34367671f223323fdcad7d4a69e299793bab51144717a9a3902159a5a51a4227&amp;token=702672088&amp;lang=zh_CN&amp;scene=21#wechat_redirect&quot;}]" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247503998%26idx%3D1%26sn%3Dc80abda34362d92eb4077c7176fbf9c7%26chksm%3Dc08bbd20f7fc34367671f223323fdcad7d4a69e299793bab51144717a9a3902159a5a51a4227%26token%3D702672088%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank" rel="noopener noreferrer" powered-by="xiumi.us" data-linktype="1"><section style="text-align: center;margin-top: 10px;margin-bottom: 10px;line-height: 0;"><section style="vertical-align: middle;display: inline-block;line-height: 0;border-style: outset;border-width: 0px;border-radius: 5px;overflow: hidden;box-shadow: rgb(0, 0, 0) 2px 2px 8px -3px;"><span class="js_jump_icon h5_image_link"><img class="rich_pages wxw-img" data-imgfileid="100021874" data-ratio="0.30277777777777776" data-s="300,640" src="https://oscimg.oschina.net/oscnet/97597ad8-c6b4-4ed0-9171-1519b6d10c34.png" data-type="png" data-w="1080" style="vertical-align: middle;width: 100%;display: inline;" referrerpolicy="no-referrer"></span></section></section></a><section style="margin-top: 10px;margin-bottom: 10px;" powered-by="xiumi.us"><section style="box-shadow: rgb(170, 170, 170) 0px 0px 10px inset;border-color: rgb(192, 200, 209);padding: 10px 18px;border-width: 1px;border-style: solid;background-color: rgb(240, 244, 255);border-radius: 5px;overflow: hidden;"><section style="margin: 10px 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 38px;flex: 0 0 auto;height: auto;align-self: center;"><section style="text-align: center;margin-top: 10px;margin-bottom: 10px;line-height: 0;" powered-by="xiumi.us"><section style="vertical-align: middle;display: inline-block;line-height: 0;width: 38px;height: auto;"><img data-imgfileid="100021893" data-ratio="1" data-s="300,640" src="https://oscimg.oschina.net/oscnet/3f016ec1-7ae6-4aa8-8bef-098c5a2090e4.png" data-type="png" data-w="256" style="vertical-align: middle;width: 100%;display: inline;" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: auto;min-width: 10%;flex: 0 0 auto;height: auto;align-self: center;margin-left: 10px;border-bottom: 3px solid rgb(0, 0, 0);border-bottom-right-radius: 0px;"><section style="" powered-by="xiumi.us"><section style="font-size: 19px;color: rgb(0, 0, 0);"><p style="text-wrap: wrap;"><strong>關於 RustRover</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></section></section><section style="" powered-by="xiumi.us"><section style="color: rgb(0, 0, 0);font-size: 15px;"><p style="text-wrap: wrap;"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247487178%26idx%3D2%26sn%3D6d95e4b411feb60da6108d3aee21d77d%26scene%3D21%23wechat_redirect" target="_blank" data-linktype="2"></a>RustRover 是 JetBrains 在 2023 年推出的面向 Rust 開發者的全新 IDE，正處於公開預覽階段，供大眾免費使用體驗。</p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><a title="https://www.jetbrains.com.cn/rust/" formlinkparm="[{&quot;href&quot;:&quot;https://www.jetbrains.com.cn/rust/&quot;}]" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.jetbrains.com.cn%2Frust%2F" target="_blank" rel="noopener noreferrer" powered-by="xiumi.us" data-linktype="2"><section style="text-align: center;margin-top: 15px;margin-bottom: 7.5px;"><section style="display: inline-block;border-radius: 5px;line-height: 2.3;background-color: rgb(255, 92, 0);font-size: 15px;color: rgb(240, 244, 255);width: 100%;"><p><strong>進一步瞭解 RustRover</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></a></section></section><section style="text-align: center;margin-top: 10px;margin-bottom: 10px;line-height: 0;" powered-by="xiumi.us"><section style="vertical-align: middle;display: inline-block;line-height: 0;box-shadow: rgb(125, 125, 125) 1px 1px 5px;"><img class="rich_pages wxw-img" data-imgfileid="100021880" data-ratio="0.5" data-s="300,640" src="https://oscimg.oschina.net/oscnet/0c16c138-101f-4fff-ae5f-55ba5a107279.png" data-type="png" data-w="1080" style="vertical-align: middle;width: 100%;display: inline;" referrerpolicy="no-referrer"></section></section><section style="" powered-by="xiumi.us"><section style="font-size: 13px;color: rgb(125, 125, 125);"><p style="text-wrap: wrap;"><strong>⏬ 戳「閲讀原文」瞭解更多信息</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公眾號 - JetBrains（JetBrainsChina）。<br>如有侵權，請聯繫 support@oschina.cn 刪除。<br>本文參與「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源創計劃</a>」，歡迎正在閲讀的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 03:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5494143/blog/10773826</guid>
            <link>https://my.oschina.net/u/5494143/blog/10773826</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Bytebase 2.13.1 - 支持 Apache Doris]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>🚀 新功能</h2><ul><li>支持 Apache Doris。</li><li>支持在對 MySQL 執行 DML 之前備份數據。</li><li>支持實例的最大連接數，用以控制每個實例的併發任務數量。</li><li>支持對導出數據的壓縮和加密。</li></ul><h2>🔔 重大變更</h2><ul><li>Bytebase API 的更改：重命名了預定義角色。如果您在使用這些角色，請更新您的代碼： 
  <ul><li>工作區級別：OWNER 更改為 workspaceAdmin，DBA 更改為 workspaceDBA，DEVELOPER 更改為 workspaceMember。</li><li>項目級別：OWNER 更改為 projectOwner，DEVELOPER 更改為 projectDeveloper，QUERIER 更改為 projectQuerier，EXPORTER 更改為 projectExporter，VIEWER 更改為 projectViewer，RELEASER 更改為 projectReleaser。</li></ul></li></ul><h2>🎄改進</h2><ul><li>支持在 Schema 編輯器中編輯索引。</li><li>在 SQL 編輯器中，按項目和數據庫分組工作表。</li><li>支持在環境發佈策略中選擇自定義項目角色。</li></ul><h2>🎠 社區</h2><p>視頻：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1dN4y1i7sq%2F" target="_blank">為什麼商業基礎軟件要開源？</a></p><h2>📕 安裝及升級</h2><p>參考<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbytebase%2Fbytebase%23installation" target="_blank">升級指南</a>。如果從之前版本升級，獲取新版本後，重新啓動升級即可。</p><hr><p>💡 更多資訊，請關注 Bytebase 公號：Bytebase</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 03:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6148470/blog/10773851</guid>
            <link>https://my.oschina.net/u/6148470/blog/10773851</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[榮耀迴應「任意門」抄襲錘子爭議]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在羅永浩<a href="https://www.oschina.net/news/275229/magicos-8-one-step">喊話</a>稱 「榮耀任意門」 抄襲錘子開源軟件一步 (One Step) 後，榮耀公司發佈聲明迴應外界質疑稱，MagicOS 8.0 中的任意門功能完全是公司自主獨立研發的成果。</p><p>榮耀強調，這一功能的開發過程中，公司研發團隊付出了大量的心血和努力，進行了深入的市場調研和用戶需求分析，以及無數次的試驗和優化。公司一直致力於技術創新和自主研發，尊重並保護知識產權，不會進行任何形式的抄襲行為。</p><p>針對與錘子手機 One Step 功能的相似之處，榮耀解釋稱，雖然兩者在功能上有一定的相似性，但在實現方式、技術細節和用戶體驗等方面存在顯著的差異。任意門功能是基於公司自身的技術積累和用戶需求進行開發的，旨在為用戶提供更加便捷、高效的操作體驗。</p><p>同時，榮耀也承認羅永浩作為一位資深科技人，其對於智能手機行業的洞察和構思具有超前性，對於榮耀等後輩企業的發展有着重要的啓示作用。對於此次爭議給新系統發佈帶來的影響，該公司表示將積極面對並妥善處理。</p><p>榮耀研發負責人鄧斌在接受採訪時也迴應道，「任意門」是榮耀獨立研發的基於意圖識別的交互邏輯，在那個時代是完全沒有的。</p><p>他解釋説，「任意門」與「一步」的核心區別在於，「任意門」所呈現的入口不是預先設定好的 icon，而是通過識別用戶的意圖後，動態智能地呈現真正具備智慧邏輯的東西。</p><p><img height="400" src="https://oscimg.oschina.net/oscnet/up-3dcf7c5dee29adad3776ba3384a41f9f88a.png" width="300" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 03:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275383</guid>
            <link>https://www.oschina.net/news/275383</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[幻方量化開源國內首個 MoE 大模型：DeepSeekMoE]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>幻方量化旗下組織深度求索發佈了國內首個開源 MoE 大模型 —— <strong>DeepSeekMoE</strong>，全新架構，免費商用。</p><blockquote><p>今年 4 月，幻方量化<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FUOMZmEXNY--fzK-KioGZLQ" target="_blank">發佈公告稱</a>，公司將集中資源和力量，全力投身到服務於全人類共同利益的人工智能技術之中，成立新的獨立研究組織，探索 AGI 的本質。幻方將這個新組織命名為「<strong>深度求索 (DeepSeek)</strong>」。</p></blockquote><p>DeepSeekMoE 的模型、代碼、論文均已同步發佈。</p><ul><li>模型下載：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fdeepseek-ai" target="_blank">https://huggingface.co/deepseek-ai</a></li><li>微調代碼：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdeepseek-ai%2FDeepSeek-MoE" target="_blank">https://github.com/deepseek-ai/DeepSeek-MoE</a></li><li>技術報告：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdeepseek-ai%2FDeepSeek-MoE%2Fblob%2Fmain%2FDeepSeekMoE.pdf" target="_blank">https://github.com/deepseek-ai/DeepSeek-MoE/blob/main/DeepSeekMoE.pdf</a></li></ul><p>據介紹，DeepSeekMoE 的多尺度（2B-&gt;16B-&gt;145B）模型效果均領先：</p><ul><li>DeepSeekMoE-2B 可接近 MoE 模型的理論上限&nbsp;2B Dense 模型性能（即相同 Attention/FFN 參數配比的 2B Dense 模型），僅用了 17.5% 計算量</li><li>DeepSeekMoE-16B 性能比肩 LLaMA2 7B 的同時，僅用了 40% 計算量，也是本次主力開源模型，40G 顯存可單卡部署</li><li>DeepSeekMoE-145B 上的早期實驗進一步證明該 MoE 架構明顯領先於 Google 的 MoE 架構 GShard，僅用 28.5%（甚至 18.2%）計算量即可匹配 67B Dense 模型的性能</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-ee5cc82817997477bc2758618cd51ea5ea5.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-d2bf70acad5d73ee4a448bac405e672196c.png" referrerpolicy="no-referrer"></p><p>混合專家模型 (Mixed Expert Models，簡稱 MoEs)&nbsp;是用於提高大語言模型效率和準確度的技術。這種方法的核心是將複雜任務劃分為更小、更易管理的子任務，每個子任務由專門的小型模型或 「專家」 負責，然後根據輸入數據的特性選擇性地激活這些 「專家」。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span>MoE 核心組成：</span></p><ol><li><p style="margin-left:0; margin-right:0"><span><strong>專家 (Experts)</strong>：</span><span style="background-color:#ffffff; color:#0f1419">訓練有素的小型神經網絡，擅長特定領域。</span><span>每個專家通常專注於處理一種特定類型的數據或任務。專家的設計可以是多種形式，如完全連接的網絡、卷積網絡等。</span></p></li><li><p style="margin-left:0; margin-right:0"><span><strong>門控機制 (Gating Mechanism)</strong>：</span><span style="background-color:#ffffff; color:#0f1419">MoE 架構決策者，</span><span>這是一個智能路由系統，負責決定哪些專家應該被激活來處理當前的輸入數據。門控機制基於輸入數據的特性，動態地將數據分配給不同的專家。</span></p></li></ol><p>官方稱 DeepSeekMoE 是自研的全新 MoE 框架，主要包含兩大創新：</p><ul><li><strong><strong><strong>細粒度專家</strong></strong>劃分</strong>：不同於傳統 MoE 直接從與標準 FFN 大小相同的 N 個專家裏選擇激活 K 個專家（如 Mistral 7B<em>8 採取 8 個專家選 2 專家），</em>DeepSeekMoE<em>把 N 個專家粒度劃分更細，在保證激活參數量<strong>不變</strong></em>的情況下，從 mN 個專家中選擇激活 mK 個專家（如 DeepSeekMoE 16B 採取 64 個專家選 8 個專家），如此可以更加靈活地組合多個專家</li><li><strong><strong><strong>共享</strong></strong>專家分離</strong>：DeepSeekMoE 把激活專家區分為共享專家（Shared Expert）和獨立路由專家（Routed Expert），此舉有利於將共享和通用的知識壓縮進公共參數，減少獨立路由專家參數之間的知識冗餘</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-3e3ad6f23bc6e17ac352dab0861fd3328d9.png" referrerpolicy="no-referrer"></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FT9-EGxYuHcGQgXArLXGbgg" target="_blank">點此查看詳情</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275378</guid>
            <link>https://www.oschina.net/news/275378</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[中國科協提名「鴻蒙操作系統」為 2023 年度國家科技進步獎]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>中國科學技術協會對《2023 年度國家科學技術獎提名項目》進行了公示，其中「<strong>鴻蒙智能終端操作系統基座與產業應用</strong>」被提名為國家科技進步獎，第一完成單位是華為技術有限公司。</p><p><img height="1454" src="https://oscimg.oschina.net/oscnet/up-4bc2e43bd185c14db69a21d67ec7105b0d7.png" width="1716" referrerpolicy="no-referrer"></p><p><em>來源：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cast.org.cn%2Fxw%2Ftzgg%2FZZRC%2Fart%2F2024%2Fart_8ae904c8dc4e40debd6fe906dc8b8808.html" target="_blank"><em>h</em>ttps://www.cast.org.cn/xw/tzgg/ZZRC/art/2024/art_8ae904c8dc4e40debd6fe906dc8b8808.html</a></u></em></p><p>公開資料顯示，「國家科學技術進步獎」創辦於 1984 年 9 月，是國務院設立的國家科學技術獎 5 大獎項（國家最高科學技術獎、國家自然科學獎、國家技術發明獎、國家科學技術進步獎、國際科學技術合作獎）之一。</p><p>國家科學技術進步獎主要授予在技術研究、技術開發、技術創新、推廣應用先進科學技術成果、促進高新技術產業化，以及完成重大科學技術工程、計劃等過程中作出創造性貢獻的中國公民和組織 。</p><p>國家科學技術進步獎的獎勵範圍涉及國民經濟的各個行業，是一項覆蓋面廣泛的科學技術獎。從候選人、候選單位所完成項目的性質來講，包括了新產品和新技術開發、新技術推廣應用、高新技術產業化、企業技術改造及技術進步、技術基礎和重大工程建設、重大設備研製中引進消化、吸收國外新技術，或自主開發創新的技術等。</p><p><em>延伸閲讀：<strong><u><a href="https://www.oschina.net/news/271838" target="_blank">2023 全球十大工程成就發佈：ChatGPT、鴻蒙操作系統、中國空間站等入選</a></u></strong></em></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 02:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275369</guid>
            <link>https://www.oschina.net/news/275369</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
