<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 01 Nov 2023 08:29:53 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[優惠券 10 幾萬元，中國首款商用可重構 5G 頻射收發芯片上架淘寶]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>近日，國資委淘寶店鋪「國資小新」上架了一款售價為 999999 元的硬核商品 ——</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0c0dfda1faab2057d6c1cd71a911022e482.png" referrerpolicy="no-referrer"></p><p>根據商品圖介紹，該款芯片名為「破風 8676」，是「中國首款商用可重構 5G 頻射收發芯片」，定價 999999 元人民幣。這款芯片因獨特的用途和「硬核」的定價被網友戲稱為「雙十一」期間最「硬核」的國貨。</p><p>報道稱，該芯片由中國移動研究院自主研發。產品介紹信息顯示，「破風 8676」可重構 5G 射頻收發芯片支持 1.7GHZ~6GHz 頻段範圍，能夠適配全球主流 4/5G 頻段、WiFi 及國內車聯網頻段：支持 2 個射頻通道，通道帶寬 200MHz；集成 DPD （數字預失真） 、CFR （削峯） 、高階 FIR （有限長單位衝激響應）濾波等功能。</p><p>公開信息顯示，上架這款芯片的店鋪「國資小新」由國務院國有資產監督管理委員會下屬機構負責運營。該賬號店鋪內還上架了由中國航發研製的「太行 110」重型燃氣輪機、由中國鐵建研製的全球最大豎井掘進機、航空工業集團研製直-20 直升機以及中核集團建設的全球首個陸上小型模塊化反應堆等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d3dff2bf8551179267c8ac2ee3cc6613cf1.png" referrerpolicy="no-referrer"></p><p>和「破風 8676」一樣，店鋪將上述產品均定價為 999999 元，並提示消費者該商品「僅展示可加購勿拍」。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 07:41:49 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264470</guid>
            <link>https://www.oschina.net/news/264470</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Layui 2.8.18 發佈，階段性穩定版 🎉]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div>
 經過 8 個預覽版的持續迭代，Layui 階段性穩定版本：&nbsp;2.8.18&nbsp;正式發佈。
</div><h3><strong>更新日誌</strong></h3><div><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flayui.dev%2Fdocs%2F2%2Fversions.html%232.8.18" target="_blank"><span style="color:#003884">https://layui.dev/docs/2/versions.html#2.8.18</span></a></div><h3><strong>提交記錄</strong></h3><div><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1391" target="_blank"><span style="color:#003884">#1391</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1395" target="_blank"><span style="color:#003884">#1395</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1399" target="_blank"><span style="color:#003884">#1399</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1408" target="_blank"><span style="color:#003884">#1408</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1413" target="_blank"><span style="color:#003884">#1413</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1416" target="_blank"><span style="color:#003884">#1416</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1417" target="_blank"><span style="color:#003884">#1417</span></a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flayui%2Flayui%2Fpull%2F1418" target="_blank"><span style="color:#003884">#1418</span></a></li></ul></div><h3><strong>參與貢獻 🎉</strong></h3><div><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsentsim" target="_blank"><span style="color:#003884">@sentsim</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FSight-wcg" target="_blank"><span style="color:#003884">@Sight-wcg</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsunxiaobin89" target="_blank"><span style="color:#003884">@sunxiaobin89</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FDiyar-IT" target="_blank"><span style="color:#003884">@Diyar-IT</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmek1986" target="_blank"><span style="color:#003884">@mek1986</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flitaohms" target="_blank"><span style="color:#003884">@litaohms</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwefly2" target="_blank"><span style="color:#003884">@wefly2</span></a>&nbsp;
 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fladudu" target="_blank"><span style="color:#003884">@ladudu</span></a></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 02:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264405/layui-2-8-18-released</guid>
            <link>https://www.oschina.net/news/264405/layui-2-8-18-released</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[深秋，寒露：是時候和 Zadig 説再見了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank"><img alt="" src="https://oscimg.oschina.net/oscnet/up-672c752071cec6bcdf28b3468d5bde60d1a.png" referrerpolicy="no-referrer"></a></p><div><div style="text-align:center"><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank">閲讀原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig">Zadig 在 Gitee</a></p><p><strong>推薦閲讀：</strong><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490415%26idx%3D1%26sn%3D1914c7fd25aac5d33b98663571bbb744%26chksm%3Dcfb457cff8c3ded9c02809aad88012fa802eac55222eebe70b8c637ca2c86a101045aa81e73a%26scene%3D21%23wechat_redirect" target="_blank">是時候和 Jenkins 説再見了</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank">Zadig vs. Jenkins 詳細比對：時代的選擇與開發者之選</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247489682%26idx%3D1%26sn%3Df4ac5ceb38547542061477a45d8dc86d%26chksm%3Dcfb45432f8c3dd24b727e0fb6db276b2d63b2751933e63a25b00b9d9fac2dd68efbd2cbd3863%26scene%3D21%23wechat_redirect" target="_blank">平台工程和 AI 時代的新 10 億開發者</a></p></div><div style="text-align:center">
   2023 年 11 月 1 日 
 </div><div style="text-align:center">
   秋風起，露成霜，正是一年最美時 
 </div><div style="text-align:center">
   Zadig 團隊踏入了 
 </div><div style="text-align:center">
   創業的第五個年頭 
 </div><div style="text-align:center">
   開源的第 888 天 
 </div><div style="text-align:center">
   然而今天 
 </div><div style="text-align:center">
   我們要向 Zadig 
 </div><div style="text-align:center">
   説再見了 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   深秋外象趨冷 
 </div><div style="text-align:center">
   實則萬物蟄伏 
 </div><div style="text-align:center">
   在孕育着新的生機 
 </div><div style="text-align:center">
   今天，我們向 Zadig 1.0 告別 
 </div><div style="text-align:center"><span style="color:#fd2968"><strong>迎來全新的 Zadig 2.0!</strong></span></div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   回顧開源的這兩年多時間裏 
 </div><div style="text-align:center">
   Zadig 1.0 已完成了 2 萬 6 千多次的企業下載 
 </div><div style="text-align:center">
   發佈了 21 個開源版本，10 個企業版本 
 </div><div style="text-align:center">
   在 2 千多家企業和團隊深度使用 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   我們創作了 157 篇原創技術和產品文章 
 </div><div style="text-align:center">
   製作了 52 個獨創的短視頻 
 </div><div style="text-align:center">
   與 100 多位國內外商業、技術和產品領域的同仁夥伴建立了深厚的鏈接 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   今天，Zadig 已不再是嬰兒 
 </div><div style="text-align:center">
   是一個堅定自信的少年 
 </div><div style="text-align:center">
   走進數千家企業和團隊的日常工作中 
 </div><div style="text-align:center">
   讓他們的工作更加高效愉悅 
 </div><div style="text-align:center">
   這段旅程，Zadig 背後的團隊和社區一起 
 </div><div style="text-align:center">
   合作共創 
 </div><div style="text-align:center">
   品味挫折 
 </div><div style="text-align:center">
   分享喜悅 
 </div><div style="text-align:center">
   追逐自由 
 </div></div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-fbb18b0ecc053068d166ea1f637149f273f.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-e94bae5f521bce7e3f5326d76218df7912c.png" referrerpolicy="no-referrer"></p><div><div style="text-align:center">
   今天，2023 年 11 月 1 日 
 </div><div style="text-align:center">
   我們團隊決定再度邁出一大步 
 </div><div style="text-align:center">
   正式宣佈： 
 </div><div style="text-align:center">
   開源 Zadig 與，企業版 ZadigX 產品合併！ 
 </div><div style="text-align:center">
   並全面啓用企業版功能，提供一鍵試用 
 </div><div style="text-align:center">
   與此同時，我們做出了重大的決定 
 </div><div style="text-align:center">
   全部開放服務端源代碼 
 </div><div style="text-align:center">
   接下來我們還將發佈嶄新的文檔站 
 </div><div style="text-align:center">
   並推出更加易用的新手在線教程 
 </div></div><span id="OSC_h1_1"></span><h1><span style="color:#fd2968"><em><strong>01</strong></em><strong>為何做出這一選擇？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-e6678f7e349d8523888cb8b7d3e0659b69a.png" referrerpolicy="no-referrer"></strong></p><div><div style="text-align:center">
   首先，我們希望通過更開放的方式 
 </div><div style="text-align:center">
   為這個不平凡的時代注入信心 
 </div><div style="text-align:center">
   在過去的三年中，我們共同經歷了許多挑戰 
 </div><div style="text-align:center">
   包括疫情、經濟動盪，資本衰退、互聯網紅利時代的結束，AI 時代的到來 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   其次，我們希望通過這次開放性嘗試，帶給每位 IT 從業者更多力量！ 
 </div><div style="text-align:center">
   開源 2 年半以來，社區裏的每個人，不論是 80 後、90 後還是 00 後 
 </div><div style="text-align:center">
   都經歷了前所未有的技術和經濟週期 
 </div><div style="text-align:center">
   似乎沒有人準備好，但這些挑戰都如期而至： 
 </div><div style="text-align:center">
   互聯網大規模的裁員和失業潮影響了我們每個人和每個家庭 
 </div><div style="text-align:center">
   「IT 行業的未來在哪裏？ 
 </div><div style="text-align:center">
   IT 人的未來在何方？ 
 </div><div style="text-align:center">
   什麼是時代需要的創新？ 
 </div><div style="text-align:center">
   什麼是適閤中國特色的 IT 創新之路？ 
 </div><div style="text-align:center">
   如何用技術讓這個世界更美好？」 
 </div></div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-7643c8b8c38bf97523b3e001c3806795bac.png" referrerpolicy="no-referrer"></p><p>作為 Zadig 的創始人，我會經常思考這些問題。顯然並沒有標準答案，有一點可以肯定：真正的創新是思想的進步和對他人帶來的積極影響。其實，開源代碼從來不是核心資產，我們希望用更開放的心態，和社區、用戶、客戶的小夥伴們更為緊密的配合，找到最佳的姿勢幫助到最需要的人，與同行者一起面對每一次成長和變化，直面每一次恐懼和不安。</p><p>同時，通過這次版本發佈和源碼開放，我們希望能夠讓更多的開發者看到 Zadig 的企業級全部功能，為希望成為客戶的用戶提供更為簡單的升級方式，從根本上提供更多安全感。通過新版本 Zadig，企業客戶可以一鍵輸入試用授權，快速實驗 Zadig 專業版能力，企業客戶更放心地嘗試新技術和新產品，助力各個行業、產業 IT 的數字化升級。</p><p>作為軟件交付和研發鏈路中重要的連接者，我們希望通過這次 Zadig V2.0.0 的開源和版本發佈，與同行的基礎軟件開發者們一起嘗試新模式，為建立新的開源商業秩序開一個頭。</p><span id="OSC_h1_2"></span><h1><span style="color:#fd2968"><em>02&nbsp;&nbsp;</em><strong>Zadig 產品具體有哪些變化？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-a6a559045246e08f1857b0e8666bab21df8.png" referrerpolicy="no-referrer"></strong></p><p>從源代碼層面上，本次產品合併以開源 Zadig v1.18.0（最新版） 為基礎，合併了原 ZadigX v1.8.0（即企業版）全部新功能代碼，統稱為 Zadig，產品版本正式定義為 Zadig v2.0.0，同時服務端代碼在 GitHub 上全部開源，產品功能差異通過授權區分基礎版和專業版。</p><p>對於已經在大規模使用 Zadig 的小夥伴，如果期待了解和親自體驗專業版功能，可以在平滑升級後免費激活並體驗專業版功能長達 30 天，到期後專業版產生的數據不刪除，原有基礎版功能仍可正常使用。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-d6ad9eba6f9b41f1d391901be2fd3ae39c0.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_3"></span><h1><span style="color:#fd2968"><em>03&nbsp;&nbsp;</em><strong>對現有用戶有哪些影響？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-91c5dba9d5f03113d993ebe2fa94c7638cd.png" referrerpolicy="no-referrer"></strong></p><p>對於社區開源用戶而言，將在原有開源基礎功能上進一步獲得更多企業級功能，包括環境管理睡眠進一步做資源成本的削減，同時支持服務級測試管理、自定義工作流也一次性開放了大量企業內置最佳實踐模板。同時 Zadig v2.0.0 在過去 V1.x 架構的基礎上架構的基礎上改進了易用性和性能，優化了安全細節，顯著提高了工作流並行和複雜場景的執行效率，效率提升高達 50%，Zadig 的資源運行成本也降低了近 30%。在之後迭代中，用戶也將持續獲得產品底層能力的可靠性，這些更新將幫助到更多企業，提升開發測試階段的雲原生持續交付能力，為開發者提供更出色的體驗。</p><p>對於企業客戶，我們用 ZadigX 品牌代表包含企業級功能和專業服務的解決方案，"X"代表為企業客戶提供更高質量的服務和保障，根據企業的具體難點和需求，接下來我們會面向企業推出一系列 DevOps 專家培訓、DevOps 效能提升、雲原生轉型、IT 數字化升級等企業級解決方案。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-8c8a7c1737a91a1e0f819e9dcb9a3c82b9c.png" referrerpolicy="no-referrer"></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-5b2c672b70e514e6133d7b885270d5fc71c.png" referrerpolicy="no-referrer"></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank">閲讀原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig">Zadig 在 Gitee</a></p><p><strong>推薦閲讀</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490415%26idx%3D1%26sn%3D1914c7fd25aac5d33b98663571bbb744%26chksm%3Dcfb457cff8c3ded9c02809aad88012fa802eac55222eebe70b8c637ca2c86a101045aa81e73a%26scene%3D21%23wechat_redirect" target="_blank">是時候和 Jenkins 説再見了</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank">Zadig vs. Jenkins 詳細比對：時代的選擇與開發者之選</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247489682%26idx%3D1%26sn%3Df4ac5ceb38547542061477a45d8dc86d%26chksm%3Dcfb45432f8c3dd24b727e0fb6db276b2d63b2751933e63a25b00b9d9fac2dd68efbd2cbd3863%26scene%3D21%23wechat_redirect" target="_blank">平台工程和 AI 時代的新 10 億開發者</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 07:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/koderover/blog/10140233</guid>
            <link>https://my.oschina.net/koderover/blog/10140233</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[阿里雲推出 AI 編碼助手：通義靈碼]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">阿里雲推出了一款基於通義大模型的智能編碼輔助工具 —— <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftongyi.aliyun.com%2Flingma%2F" target="_blank">通義靈碼</a>，提供行級/函數級實時續寫、自然語言生成代碼、單元測試生成、代碼註釋生成、代碼解釋、研發智能問答、異常報錯排查等能力，並針對阿里雲 SDK/OpenAPI 的使用場景調優，助力開發者高效、流暢的編碼。</span></p><p><span style="color:#000000">根據官網介紹，通義靈碼兼容 Visual Studio Code、JetBrains IDEs 等主流 IDE；且支持 Java、Python、Go、C/C++、JavaScript、TypeScript、PHP、Ruby、Rust、Scala 等主流編程語言。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>核心場景</strong></span></h4><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代碼智能生成</strong></span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000">經過海量優秀開源代碼數據訓練，可根據當前代碼文件及跨文件的上下文，為你生成行級/函數級代碼、單元測試、代碼註釋等。沉浸式編碼心流，秒級生成速度，讓你更專注在技術設計，高質高效地完成編碼工作。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>研發智能問答</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">基於海量研發文檔、產品文檔、通用研發知識、阿里雲的雲服務文檔和 SDK/OpenAPI 文檔等進行問答訓練，為你答疑解惑，助你輕鬆解決研發問題。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>產品優勢</strong></span></h4><ul style="margin-left:0; margin-right:0"><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>跨文件感知讓代碼生成更貼合業務場景：</strong>客戶端和模型層同步優化針對代碼跨文件上下文感知能力，生成代碼更加貼合當前代碼庫的業務場景。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>阿里雲服務使用場景友好：</strong>專門針對阿里雲的雲服務使用、SDK/OpenAPI 的使用等場景調優，編碼時能夠更加便捷地使用阿里雲服務；在對阿里雲使用有疑問時，智能編碼助手的回答也將更加有效。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>適配多 IDE 的原生設計，符合開發者使用習慣：</strong>適配 IDE 原生主題、交互模式，讓開發者感受到 IDE 原生的視覺和交互體驗，更符合開發者使用習慣。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>研發問答、文檔/代碼搜索能力，打造沉浸式編碼：</strong>無需切換工具，IDE 客戶端內即可滿足開發者編碼場景中的技術資料檢索、技術難題解答的訴求，打造開發者沉浸式編碼體驗。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>雙模引擎，自由切換：</strong>支持極速本地模型、雲端大模型兩種代碼補全模型，支持一鍵切換，滿足不同網絡環境、不同補全強度的場景訴求。</span></p></li></ul><h2 style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>功能介紹</strong></span></h2><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>行級/函數級實時續寫</strong></span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000">根據當前語法和跨文件的代碼上下文，實時生成行、函數建議代碼。</span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000"><img alt="" height="182" src="https://oscimg.oschina.net/oscnet/up-145ecbcb5413f83c4f6512faeb7572d39ba.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>自然語言生成代碼</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">通過自然語言描述你想要的功能，可直接在編輯器區生成代碼，編碼心流不間斷。</span></p><p><span style="color:#000000"><img alt="" height="186" src="https://oscimg.oschina.net/oscnet/up-515b87e9afaf2bfb1f9200538f114663d20.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>單元測試生成</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">支持根據 JUnit、Mockito、Spring Test、unit test、pytest 等框架生成單元測試。</span></p><p><span style="color:#000000"><img alt="" height="198" src="https://oscimg.oschina.net/oscnet/up-6512237992e15393d3abbc2c8e3c77d4063.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代碼註釋生成</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">一鍵生成方法註釋及行間註釋，節省你寫代碼註釋的時間，並能夠有效提升代碼可讀性。</span></p><p><span style="color:#000000"><img alt="" height="192" src="https://oscimg.oschina.net/oscnet/up-bd96048c8e3e6d01aa66c1136d8ca7ff355.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代碼解釋</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">支持 30 多種語言的識別，選中代碼後可自動識別編程語言並生成代碼解釋。跨越語言的邊界，讓你閲讀代碼更高效。</span></p><p><span style="color:#000000"><img alt="" height="154" src="https://oscimg.oschina.net/oscnet/up-615f625c27c7e8afe87ad83e1e7df085c76.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>研發領域自由問答</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">遇到編碼疑問、技術難題時，一鍵喚起通義靈碼，無需離開 IDE 客戶端，即可快速獲得答案和解決思路。聚焦研發領域知識的問答，幫助開發者快速解決問題。</span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><img alt="" height="214" src="https://oscimg.oschina.net/oscnet/up-70413ee56236fdc009f429692be9593d05b.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>異常報錯智能排查（Java）</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">當運行出現異常報錯時，一鍵啓動報錯排查的智能答疑，可結合運行代碼、異常堆棧等報錯上下文，快速給出排查思路或修復建議代碼。</span></p><p><span style="color:#000000"><img alt="" height="309" src="https://oscimg.oschina.net/oscnet/up-87d6c9327ffeb245c28f22c1c979fae8172.png" width="500" referrerpolicy="no-referrer"></span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>支持 IDE 及操作系統</strong></span></h4><ul style="margin-left:0; margin-right:0"><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">Windows 7 及以上、macOS、Linux</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">JetBrains IDEs （IntelliJ IDEA、PyCharm、GoLand、WebStorm 等）2020.3 及以上</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">Visual Studio Code 1.75.1 及以上</span></p></li></ul><p><span style="color:#000000">目前，通義靈碼已面向所有開發者開放公測，各大 IDE 插件市場均已上線。</span></p><p><span style="color:#000000">更多詳情<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftongyi.aliyun.com%2Flingma%2F" target="_blank">可查看官網</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264459</guid>
            <link>https://www.oschina.net/news/264459</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 開源藍心大模型-7B：70 億參數、適閤中國開發者]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在 2023 vivo 開發者大會上，vivo 宣佈開源 70 億參數級的藍心大模型-7B，以及對應的微調框架。據稱是行業首家開源大模型的手機廠商。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-27161d355f59c839fc4c9b6bb433e37dff3.png" referrerpolicy="no-referrer"></p><p>vivo 介紹道，他們提供<strong>藍心大模型開發套件 BlueKit</strong>，讓開發者不必考慮使用成本，專注於創新產品體驗。此外，vivo 還推出藍心開發者激勵計劃，<strong>提供一億元資源支持，包含技術、運營、品牌三大方面。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-93548b2298b63f816adaa7f7c40b07b00f0.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0c711a4b9bd565a2eb78daee566e4475c80.png" referrerpolicy="no-referrer"></p><hr><p>藍心大模型-7B 是 vivo 自研通用大模型矩陣中的其中一款。</p><p><img height="646" src="https://static.oschina.net/uploads/space/2023/1101/143959_y0Ws_2720166.png" width="1834" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1101/144435_2CXR_2720166.png" referrerpolicy="no-referrer"></p><p>整體如下：</p><ul><li><p>1B：端側大模型</p></li><li><p>7B：端雲兩用模型（開源）</p></li><li><p>70B：雲端主力模型</p></li><li><p>130B：雲端大模型</p></li><li><p>175B：雲端大模型</p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264455</guid>
            <link>https://www.oschina.net/news/264455</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Incus 0.2 發佈，系統容器和虛擬機管理器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 是一個現代、安全且強大的系統容器和虛擬機管理器，它為在容器或虛擬機內運行和管理完整的 Linux 系統提供了統一的體驗。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 以&nbsp;C</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>umulonimbus incus 或 anvil cloud&nbsp;<span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>命名，是 Canonical LXD 的社區分支。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>該分叉是為了迴應&nbsp;<a href="https://www.oschina.net/news/248011/lxd-under-canonical">Canonical&nbsp;從 Linux<span>&nbsp;</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><a href="https://www.oschina.net/news/248011/lxd-under-canonical">Containers community&nbsp;</a><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><a href="https://www.oschina.net/news/248011/lxd-under-canonical">接管 LXD 項目</a>的舉措。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 0.2 現已發佈，</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#222222">此版本整合了 LXD 5.19 中的大部分更改，並引入了一些額外的功能和改進。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span style="background-color:#ffffff; color:#222222"><img alt="" height="333" src="https://static.oschina.net/uploads/space/2023/1101/142856_LLE7_4252687.png" width="500" referrerpolicy="no-referrer"></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><span style="background-color:#ffffff; color:#222222">一些亮點更新內容如下：</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><strong><span style="background-color:#ffffff; color:#222222">虛擬機中的 NVME 存儲支持</span></strong></p><p><span style="background-color:#ffffff; color:#222222">虛擬機的磁盤類型設備新增了</span><code>io.bus</code><span style="background-color:#ffffff; color:#222222">configuration key。</span></p><p><span style="background-color:#ffffff; color:#222222">默認設置為</span><code>virtio-scsi</code><span style="background-color:#ffffff; color:#222222"><span>&nbsp;</span>，但現在也可以設置為</span><code>nvme</code><span style="background-color:#ffffff; color:#222222">，以便在虛擬機中將磁盤顯示為 NVME SSD。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>從 LXD 遷移的集羣支持</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>遷移工具<code>lxd-to-incus</code>現在支持集羣環境。此外，它還進行了更新以支持 LXD 5.19 作為源版本。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>這意味着任何使用 LXD 4.0 及更高版本（直到 5.19）的人現在都可以通過安裝 Incus 並運行<code>lxd-to-incus</code>輕鬆遷移到 Incus。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>非特權容器的新鏡像要求</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>當添加對 NixOS 作為容器鏡像的支持時，發現該特定鏡像當前無法在特權容器內運行。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>因此添加一個新的鏡像要求。可以將<code>requirements.privileged</code>設置為<code>false</code>，以防止該鏡像與特權容器一起使用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><pre><code>stgraber@dakara:~$ incus launch images:nixos nixos-priv -c security.privileged=true
Creating nixos-priv
Starting nixos-priv
Error: The image used by this instance is incompatible with privileged containers. Please unset security.privileged on the instance
Try `incus info --show-log local:nixos-priv` for more info
stgraber@dakara:~$</code></pre><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>服務器端自定義卷複製</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Incus 現在支持自定義卷的服務器端副本。這消除了客戶端充當中繼的需要，從而顯着加快了自定義卷的複製速度。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>命令行工具會自動檢測對此的支持並在可用時使用它。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>該功能首次在 LXD 中引入。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>靜態二進制文件現在可用於 64 位 Arm</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>作為發佈和測試的一部分提供的所有靜態二進制文件，現在都適用於 Intel 64 位和 Arm 64 位。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#222222"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdiscuss.linuxcontainers.org%2Ft%2Fincus-0-2-has-been-released%2F18185" target="_blank">查看官方公告</a>。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264451/incus-0-2-released</guid>
            <link>https://www.oschina.net/news/264451/incus-0-2-released</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 發佈自研操作系統藍河 (BlueOS)，系統框架採用 Rust 編寫]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 vivo 開發者大會今天正式開始。大會上，vivo 發佈了自研操作系統<strong>藍河 (BlueOS)</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-15a70d97c2f8f3654e7d6f94c8c92df5505.png" referrerpolicy="no-referrer"></p><p>vivo 稱「藍河操作系統」是面向通用人工智能時代的自研智慧操作系統 —— 底層接入了 AI 大模型，支持基於自然交互方式的應用開發。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135537_Q43j_2720166.png" referrerpolicy="no-referrer"></p><p>vivo 還表示，藍河操作系統<strong>採用 Rust 編寫「系統框架」</strong>——從源頭避免了內存使用不當引起的安全漏洞。據稱是行業首家<strong>。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f21c3eb7d2568b66e3cebdf8f628b9bb78b.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135659_sEFQ_2720166.png" referrerpolicy="no-referrer"></p><p>運行要求方面，在低至 200Mhz 主頻 32MB 內存，高至 4GHz 主頻 24GB 內存的各種設備上，藍河都能流暢運行。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/142454_nhO4_2720166.png" referrerpolicy="no-referrer"></p><p>據瞭解，藍河操作系統目前不會在 vivo 手機上提供，首款搭載藍河操作系統的 vivo 設備是 vivo Watch3 智能手錶。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b5c944705e833222c61dc1c96c7713648ca.png" referrerpolicy="no-referrer"></p><p>此外，<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1668726803%2FNqydVxKTF%3Frefer_flag%3D1001030103_" target="_blank">據稱藍河操作系統是基於 Linux/RTOS 的自研架構</a></u>，因此不兼容 Android 應用。不過它兼容 hapjs，以獲得更好的生態支持。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/152743_iniv_2720166.png" referrerpolicy="no-referrer"></p><blockquote><p>hapjs 項目是由開放原子開源基金會孵化及運營的開源項目，<strong>是快應用標準的開源實現</strong>，是基於智能硬件平台的輕型應用形態，由多智能硬件廠商組成的快應用聯盟聯合制定標準共同驅動。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1ed767bef366be3bde87f6dbd714fdbd581.png" referrerpolicy="no-referrer"></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264444</guid>
            <link>https://www.oschina.net/news/264444</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[macOS Sonoma 黑屏 bug，影響 Asahi Linux]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Asahi Linux 發佈了一篇文檔，説明瞭近期 macOS 黑屏情況。</p><blockquote><p><span style="color:#333333">Asahi Linux 項目致力於將 Linux 操作系統移植到蘋果的 Apple Silicon Macs 系列電腦設備上。</span></p><ul><li><a href="https://www.oschina.net/news/125751/asahi-linux-set-up" target="_blank">可移植蘋果 M1 的 Asahi Linux 項目正式啓</a></li></ul></blockquote><p>Asahi 解釋，macOS Sonoma 和 macOS Ventura 13.6 在其升級和啓動過程中發佈了多個嚴重的錯誤。這些錯誤結合在一起，可以創建出一種情況，即無論使用何種電源按鈕按壓組合，機器總是啓動到黑屏。這使用戶陷入困境，唯一的解決方案就是使用 DFU 恢復。</p><p>在某些設置和特定型號下，這種情況可能會發生，即多個 macOS 版本並行安裝（一個 Sonoma，一個更早的版本）。由於 Asahi Linux 的行為就像是 macOS 12.3/12.4/13.5（取決於型號和安裝時間），所以 macOS Sonoma 和 Asahi Linux 的雙啓動安裝會產生相同的問題。對於 macOS 13.6，這種情況甚至不需要雙啓動系統，只要作為唯一安裝的操作系統就可以觸發。</p><p>目前 Asahi Linux 安裝程序已經更新，現在它可以在啓動時自動進行完整性檢查並診斷系統。要運行它，請將此命令粘貼到 macOS 的終端中：</p><p style="text-align:start"><code>curl https://alx.sh | sh</code></p><p style="text-align:start">進入主菜單，用戶可以退出安裝程序，而不對系統做任何更改。</p><p style="text-align:start">Asahi Linux 具體説明瞭 macOS 啓動失敗的原因：</p><ul><li><p>macOS Sonoma 的升級使用先前安裝的版本作為系統恢復。這在某種程度上是有道理的，但並未考慮到舊版 RecoveryOS 與新固件之間的向後兼容性問題。如果這種不匹配導致 recoveryOS 無法啓動，那麼系統恢復將無法使用。</p></li><li><p>對於 14 英寸和 16 英寸的型號：一旦系統固件更新到 macOS Sonoma 版本，如果顯示器的刷新率設置為非 ProMotion，則該系統將無法正確地啓動舊版本的 macOS 安裝程序和 Asahi Linux。這包括當這些系統被設置為默認啓動操作系統時的恢復模式，以及至少在下一次操作系統升級之前的系統恢復。</p></li></ul><p>影響設備、系統：</p><ul><li><p>配備 ProMotion 顯示屏的 MacBook Pro 型號（14 英寸和 16 英寸）受到黑屏啓動錯誤的影響。</p></li><li><p>macOS Sonoma 14.0+（截至 2023 年 10 月 31 日尚未修復）</p></li><li><p>macOS Ventura 13.6+ (使用 14.0 固件)</p></li><li><p>可能受影響：macOS Monterey 12.7（未經確認）</p></li></ul><p><strong>如果還沒升級到 Sonoma，Asahi Linux&nbsp;<span style="background-color:#ffffff; color:#1f2328">建議等到蘋果解決這些問題後再進行升級。</span></strong></p><p>更多細節查看 Asahi 發佈的説明：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAsahiLinux%2Fdocs%2Fwiki%2FmacOS-Sonoma-Boot-Failures" target="_blank">https://github.com/AsahiLinux/docs/wiki/macOS-Sonoma-Boot-Failures</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 04:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264432/macos-sonoma-boot-failures</guid>
            <link>https://www.oschina.net/news/264432/macos-sonoma-boot-failures</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微信 iOS 版「史詩級」更新：「發送」按鈕獨立]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>微信 iOS 版昨天發佈了 8.0.43 更新，更新日誌一如既往地是「修復了一些已知問題」。</p><blockquote><p><img height="780" src="https://static.oschina.net/uploads/space/2023/1101/121221_VGwW_2720166.png" width="1810" referrerpolicy="no-referrer"></p></blockquote><p>不過熱心網友發現的一項重要變化衝上了微博熱搜：<span style="color:#e67e22"><strong>#微信新增獨立發送按鈕#</strong></span>。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-12f6e066aebe74a1bd7440aa69ef266c4b9.png" referrerpolicy="no-referrer"></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-877e90cea0d617b8694aa9a040acdc2080e.png" referrerpolicy="no-referrer"></p><p>沒錯，微信 for iOS 8.0.43 新增了「使用獨立的發送按鈕」開關。開啓後，iOS 自帶輸入法的「發送」按鍵變成「換行」按鍵，而輸入框右側增加了獨立的「發送」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-410e4a667b0d00dcd7c363e6c756adad620.png" referrerpolicy="no-referrer"></p><p>對使用 iOS 自帶輸入法用戶來説，這屬實是「史詩級」更新。</p><p>畢竟此前在輸入文字的時候如果想換行，需要在輸入框輕點或者長按呼出換行開關。現在「換行」和「發送」終於都有了獨立按鍵，感謝 Allen Zhang : )</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 04:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264431</guid>
            <link>https://www.oschina.net/news/264431</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gateway API v1.0：GA 版本出爐]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Gateway API v1.0 版本現已發佈。公告指出，此版本是該項目的一個重要里程碑。幾個關鍵的 API 已經升級為 GA（generally available，一般可用），同時其他重要功能已添加到實驗（Experimental）通道。</span></p><h4><span style="color:#000000"><strong>新增內容</strong></span></h4><p><span style="color:#000000"><strong>升級到 v1</strong></span></p><p><span style="color:#000000">此版本將 Gateway、GatewayClass 和 HTTPRoute 升級為 v1，意味着它們現在是一般可用的。這個 API 版本表示對 API 表面具有高度的信心，並提供向後兼容的保證。需要注意的是，雖然標準（Standard）通道中包含的這些 API 版本現在被認為是穩定的，但這並不意味着它們是完整的。這些 API 將繼續通過實驗通道接收新的功能，以滿足升級的標準。</span></p><p><span style="color:#000000"><strong>Logo</strong></span></p><p><span style="color:#000000">Gateway API 現在有了自己的 Logo！這個 Logo 是通過協作過程設計的，旨在代表這是一組用於在 Kubernetes 中進行南北向和東西向流量路由的 API：</span></p><p><img height="135" src="https://oscimg.oschina.net/oscnet/up-b9aa4cb25f206b6a9cd7b73608e412f035b.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><strong>CEL 驗證</strong></span></p><p><span style="color:#000000">過去，Gateway API 作為安裝 API 的一部分綁定了驗證 webhook。從 v1.0 開始，webhook 的安裝是可選的，僅建議在 Kubernetes 1.24 上使用。Gateway API 現在將 CEL ]驗證規則作為 CRDs 的一部分進行了包含。這種新形式的驗證在 Kubernetes 1.25+中得到支持，因此在大多數安裝中不再需要驗證 webhook。</span></p><p><span style="color:#000000"><strong>標準通道</strong></span></p><p><span style="color:#000000">此版本的主要重點是確保現有的 beta API 定義明確，並足夠穩定，可以升級為 GA。這導致了各種規範的澄清，以及一些改進，以提高與 Gateway API 交互時的整體用戶體驗。</span></p><p><span style="color:#000000"><strong>實驗通道</strong></span></p><p><span style="color:#000000">此版本中包含的大部分更改都限於實驗通道，包括 HTTPRoute 超時、從 Gateway 到後端的 TLS 配置、WebSocket 支持、Gateway 基礎設施標籤等。</span></p><hr><p><span style="color:#000000">接下來，項目團隊將繼續致力於努力穩定和升級 API 的其他實驗性功能。包括支持服務網格]、額外的路由類型（GRPCRoute、TCPRoute、TLSRoute[17]、UDPRoute）以及各種實驗性功能。</span></p><p><span style="color:#000000">以及將 ReferenceGrant 移入內置的 Kubernetes API 中，使其可以用於不僅僅是 Gateway API。「在 Gateway API 中，我們使用這個資源來安全地啓用跨命名空間引用，而這個概念現在被其他 SIGs 採納。這個 API 的新版本將歸 SIG Auth 所有，並且在遷移到內置的 Kubernetes API 時可能包含至少一些修改。」</span></p><p><span style="color:#000000">更多詳情可查看：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubernetes-sigs%2Fgateway-api%2Freleases%2Ftag%2Fv1.0.0" target="_blank">https://github.com/kubernetes-sigs/gateway-api/releases/tag/v1.0.0</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264423/gateway-api-1-0-released</guid>
            <link>https://www.oschina.net/news/264423/gateway-api-1-0-released</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[運營商在光貓內置反詐插件？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>網友發帖稱，自己的同事參加某運營商<strong>加 1 元提速 2000m 送 fttr 1+2 活動</strong>後，由於活動要求 45 天內保持在線並且要使用路由模式，這名同事就按照要求使用路由模式。</p><blockquote><p>FTTR (Fiber to The Remote)，是指光纖敷設到遠端節點，為光纖接入的基本技術方式。</p></blockquote><p>然後他發現自建的科學上網功能出現不能連接的情況，並且訪問&nbsp; xenyth.net 網站時直接跳轉到了反詐頁面，幾分鐘之後接到反詐熱線打來的電話，詢問他有沒有訪問一個叫做 xenyth.net 的詐騙網站。工作人員告訴他這是一個網購詐騙網站，付款後不會發貨，要求不再訪問，如有需要可以安排民警上門。</p><p><span style="background-color:#ffffff; color:#000000">後面這名同事搞到超級密碼後進入光貓，發現：</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9b10cd4d0019c4015f48be3f0d542493520.png" referrerpolicy="no-referrer"></p><p>最後附上卸載插件方法：</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/113529_5FaL_2720166.png" referrerpolicy="no-referrer"></p><p><em>via&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.v2ex.com%2Ft%2F986550" target="_blank">https://www.v2ex.com/t/986550</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264421</guid>
            <link>https://www.oschina.net/news/264421</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[四維縱橫完成超億元 B 輪融資]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">新一代超融合數據庫廠商四維縱橫<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fq_l-0lQ_GJxLTEXTjF30ag" target="_blank">宣佈</a>完成了上億元人民幣的 B 輪融資，本輪融資由用友、順義產業基金領投，廣州同創基金跟投。該公司表示，</span><span style="background-color:#ffffff">此次募集資金將會主要用於研發核心技術，建設商業生態鏈等方面。</span></span></p><p><span style="color:#000000"><img height="251" src="https://oscimg.oschina.net/oscnet/up-ecefb2dbc5ddf668afa56fccacfa3960e27.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">四維縱橫是一家成立於 2020 年的數據庫公司，以超融合數據庫 YMatrix 為企業提供集「分析、事務、時序」為一體的企業級數據庫產品服務。目前，四維縱橫，以 YMatrix 為核心，自研了全棧向量化執行器、分佈式數據庫災備、MARS3 存儲引擎、MatrixShift 遷移工具、MatrixGate 高性能寫入組件、MatrixUI 圖形化界面等一系列商業化套件。</span></p><p><span style="color:#000000"><img height="345" src="https://oscimg.oschina.net/oscnet/up-c609ba963a02c51a5f6c10587fc68105704.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">當前，YMatrix 已經被應用到證券、通信、銀行、保險、智能製造、車聯網等多個行業領域中，服務的客戶包括浪潮、中興、理想汽車、寧德時代、三一重工等多個頭部企業。</span></span></p><p><span style="color:#000000">公告指出，在本輪融資之後，四維縱橫將會以目前 YMatrix 產品技術能力為根基，以超融合理念為發展方向，繼續拓展新的應用領域，將 YMatrix 超融合數據庫產品應用於更多的場景中。另外，四維縱橫將進一步加快並夯實技術團隊的人員建設和技術基礎，為全球用戶提供更加全面的超融合解決方案。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264414</guid>
            <link>https://www.oschina.net/news/264414</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度上線「文心一言」會員，開通可解鎖文心大模型 4.0]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>百度大模型文心一言現已上線會員模式，開通後可解鎖文心大模型 4.0。</p><p><strong>目前文心一言基礎版功能依舊免費開放使用</strong>，可以滿足用戶的日常需求，如交互對話、問答等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-523eef7bc90f0772422e76d8d238e5a06f5.png" referrerpolicy="no-referrer"></p><p>據介紹，文心一言會員單月購買價格為 59.9 元，<strong>連續包月價格為 49.9 元</strong>（次月以 49.9 元 / 月自動續費，可隨時取消）。此外，百度還推出了文心一言 + 文心一格（白銀）的聯合會員，價格為 99 元 / 月。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2e89f249c9e05e483bc3e37a5c145a0001d.png" referrerpolicy="no-referrer"></p><p><strong>文心一言會員權益：</strong></p><ul><li><p>模型能力：文心大模型 4.0</p></li><li><p>圖片生成：文生圖能力全面升級</p></li><li><p>插件權益 （網頁端）：高階插件</p></li><li><p>靈感值 （App 端）：單月贈送 600 靈感值</p></li></ul><p><strong>文心一格會員權益：</strong></p><ul><li><p>極速生成多尺寸高清圖像</p></li><li><p>創作海報和藝術字</p></li><li><p>白銀會員權益：AI 編輯改圖修圖</p></li></ul><hr><p><u><a href="https://www.oschina.net/news/262086">文心大模型 4.0 於上個月正式亮相</a></u>，李彥宏表示，<strong>這是迄今為止最強大的文心大模型</strong>，實現了基礎模型的全面升級，在理解、生成、邏輯和記憶能力上都有着明顯提升，綜合水平「與 GPT-4 相比毫不遜色」。</p><p><img alt="up-cb21975862a8f7b014aeea47cbab52da1df.png" src="https://oscimg.oschina.net/oscnet/up-cb21975862a8f7b014aeea47cbab52da1df.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264412</guid>
            <link>https://www.oschina.net/news/264412</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenSign —— 開源 PDF 電子簽名解決方案]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenSign 是一個開源文檔電子簽名解決方案，旨在為 DocuSign、PandaDoc、SignNow、Adobe Sign、Smartwaiver、SignRequest、HelloSign 和 Zoho Sign 等商業平台提供安全、可靠且免費的替代方案。</p><p>特性：</p><ul><li><strong>安全簽名</strong>：利用最先進的加密算法來確保文檔的安全性和完整性。</li><li><strong>用戶友好的界面</strong>：設計時考慮到可用性，使技術和非技術用戶都能輕鬆使用。</li><li><strong>多平台支持</strong>：兼容各種瀏覽器和設備。</li><li><strong>邀請和協作用戶</strong>：將團隊中的多人帶入簽名流程，所有這些都在你自己的基礎設施內進行。</li><li><strong>安全</strong>：允許使用「OpenSigDrive」輕鬆、安全和無縫地組織文檔。</li><li><strong>審計跟蹤</strong>：保留與文檔簽名過程相關的所有活動的詳細日誌，包括 IP 地址和訪問時間。</li><li><strong>完成證書</strong>：所有參與者簽署文件後立即生成安全完成證書。</li><li><strong>API 支持</strong>：提供強大的 API，用於集成到其他軟件和服務中。</li></ul><p><img alt="" height="293" src="https://static.oschina.net/uploads/space/2023/1031/154224_RLJo_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="298" src="https://static.oschina.net/uploads/space/2023/1031/154242_mhWv_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="307" src="https://static.oschina.net/uploads/space/2023/1031/154356_RuMR_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/opensign</guid>
            <link>https://www.oschina.net/p/opensign</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 一站式分佈式任務調度系統 Hodor]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-hodorscheduler" class="anchor" href="https://gitee.com/dromara/hodor#hodorscheduler"></a>HodorScheduler</h1><h2><a id="user-content-介紹" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BB%8B%E7%BB%8D"></a>介紹</h2><p>Hodor 是一個專注於<strong>任務調度</strong>以及<strong>任務編排</strong>的<strong>一站式</strong>分佈式任務調度系統。</p><p>通過提供任務編程 API 和接口協議， 方便支持用戶使用不同的編程語言實現任務執行以及自定義任務類型的擴展，以滿足各種業務場景下的任務執行。</p><p>支持多種接入方式，支持 Java SDK 包方式、Java Agent 獨立進程方式接入，以及兼容 XXLJob 框架、Spring Task 框架任務無縫接入。</p><p>多語言執行器實現，計劃支持 Go 或者 Rust 語言執行器（正在設計與開發中）的接入，滿足在資源有限的執行器節點執行，比如物聯網場景下面的定時任務執行。</p><p>支持豐富的任務類型，除了支持普通的 Java、腳本任務的執行，也支持了大數據任務 Hadoop、Spark、Flink、Kettle 等主流任務的執行，滿足用戶的不同場景。</p><h2><a id="user-content-主要特性" class="anchor" href="https://gitee.com/dromara/hodor#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"></a>主要特性</h2><ol><li>支持 Cron、FixedRate、FixedDelay、OnceTime 方式配置定時任務，可以方便地實現各種定時任務需求。</li><li>支持 DAG 方式進行任務編排，使得任務之間的關係更加清晰，同時提高了系統的可擴展性和靈活性。</li><li>支持 Java 任務和大數據任務調度，兼容 XXLJob、SpringTask 調度任務，滿足不同場景下的任務調度需求。</li><li>支持可擴展執行器，用戶可以根據自己的需求自定義實現任務類型，從而更好地適應不同的業務場景。</li><li>支持任務靜態分片、動態分片、廣播、WorkFlow 等多種任務執行模式。</li><li>支持任務自動創建與手動創建以及批量創建等方式，任務的暫停、恢復、Kill 等動作，以及實時日誌查看等。</li><li>基於 CopySet 算法實現任務副本分配，提高了任務的可靠性和容錯性，從而保障了任務的高可用性。</li></ol><p>詳細文檔請查閲：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor">https://www.yuque.com/tomgs/hodor</a></p><h2><a id="user-content-架構設計" class="anchor" href="https://gitee.com/dromara/hodor#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"></a>架構設計</h2><p><img src="https://gitee.com/dromara/hodor/raw/master/docs/assets/img/hodor%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="hodor 架構設計圖" referrerpolicy="no-referrer"></p><h2><a id="user-content-快速開始" class="anchor" href="https://gitee.com/dromara/hodor#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"></a>快速開始</h2><p>項目結構：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">hodor-scheduler</span><span id="LC2" class="line">├─docs                                          # 文檔存放位置</span><span id="LC3" class="line">├─hodor-actuator                                # hodor 任務執行器</span><span id="LC4" class="line">│  ├─hodor-actuator-api                         # 執行器擴展接口</span><span id="LC5" class="line">│  ├─hodor-actuator-java                        # jar 包方式任務執行器</span><span id="LC6" class="line">│  ├─hodor-actuator-agent                       # 獨立進程方式任務執行器</span><span id="LC7" class="line">│  ├─hodor-actuator-xxljob                      # 支持 xxl-job 執行器</span><span id="LC8" class="line">│  └─hodor-actuator-springtask                  # 支持 spring task 執行器</span><span id="LC9" class="line">├─hodor-admin                                   # hodor 管理控制枱（TODO）</span><span id="LC10" class="line">├─hodor-client                                  # 提供與 hodor server 的交互 sdk</span><span id="LC11" class="line">├─hodor-common                                  # hodor 公共依賴</span><span id="LC12" class="line">├─hodor-core                                    # hodor 核心業務</span><span id="LC13" class="line">├─hodor-examples                                # hodor 測試用例</span><span id="LC14" class="line">├─hodor-cache                                   # hodor 擴展</span><span id="LC15" class="line">│  ├─hodor-cache-local                          # 基於本地內存的緩存</span><span id="LC16" class="line">│  ├─hodor-cache-embedded                       # 基於 embedded 的分佈式緩存</span><span id="LC17" class="line">│  └─hodor-cache-redis                          # 基於 redis 的分佈式緩存</span><span id="LC18" class="line">├─hodor-model                                   # hodor 公共數據模型</span><span id="LC19" class="line">├─hodor-storage                                 # hodor storage 模塊</span><span id="LC20" class="line">├─hodor-register                                # hodor 註冊中心</span><span id="LC21" class="line">│  ├─hodor-register-api</span><span id="LC22" class="line">│  ├─hodor-register-embedded                    # 基於 Raft 實現註冊中心</span><span id="LC23" class="line">│  └─hodor-register-zookeeper                   # 基於 zk 實現註冊中心</span><span id="LC24" class="line">├─hodor-remoting                                # hodor 通信框架</span><span id="LC25" class="line">│  ├─hodor-remoting-api</span><span id="LC26" class="line">│  └─hodor-remoting-netty</span><span id="LC27" class="line">├─hodor-scheduler                               # hodor 調度核心</span><span id="LC28" class="line">│  ├─hodor-scheduler-api</span><span id="LC29" class="line">│  └─hodor-scheduler-quartz</span><span id="LC30" class="line">└─hodor-server                                  # hodor 入口</span><span id="LC31" class="line"></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-本地源碼運行方式" class="anchor" href="https://gitee.com/dromara/hodor#%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"></a>本地源碼運行方式</h2><ol><li>在 mysql 下執行 docs 目錄下面的 hodor_ddl.sql。</li><li>在項目根目錄下通過 mvn package -DskipTests=true 命令編譯整個項目，因為涉及到一些代碼的自動生成。</li><li>進入到 hodor-server，啓動 HodorServer 調度器。</li><li>進入到 examples 下面的 hodor-actuator-java-example，啓動 java 任務執行器程序</li><li>java 執行器啓動完成後會自動將任務註冊到調度器裏面來</li></ol><h2><a id="user-content-任務使用説明" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"></a>任務使用説明</h2><p>詳細參考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fiqrsqxh2i2qt5ixi">執行器操作指南</a></p><h3><a id="user-content-java 任務接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#java%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>java 任務接入 demo</h3><p>詳細 demo 代碼參考 <em>hodor-examples/hodor-actuator-java-example</em> 模塊</p><blockquote><p>普通 java 任務</p></blockquote><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">group</span><span class="o">=</span><span class="s">"testGroup"</span><span class="o">,</span><span class="n">jobName</span><span class="o">=</span><span class="s">"test1"</span><span class="o">,</span><span class="n">cron</span><span class="o">=</span><span class="s">"0/30 * * * * ?"</span><span class="o">)</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="nc">String</span><span class="nf">test1</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC3" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [testGroup#test1] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC4" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC5" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job test1"</span><span class="o">);</span></span><span id="LC6" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"job argument: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getJobParameter</span><span class="o">());</span></span><span id="LC7" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executing......"</span><span class="o">);</span></span><span id="LC8" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executed"</span><span class="o">);</span></span><span id="LC9" class="line"><span class="k">return</span><span class="s">"a=123"</span><span class="o">;</span></span><span id="LC10" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><blockquote><p>動態分片任務</p></blockquote><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 任務動態切分</span></span><span id="LC2" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"splitStage"</span><span class="o">)</span></span><span id="LC3" class="line"><span class="kd">public</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">ShardData</span><span class="o">&gt;</span><span class="nf">split</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC4" class="line"><span class="nc">ShardData</span><span class="n">shardData</span><span class="o">=</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">id</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">params</span><span class="o">(</span><span class="s">"hello"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span></span><span id="LC5" class="line"><span class="nc">ShardData</span><span class="n">shardData1</span><span class="o">=</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">id</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">params</span><span class="o">(</span><span class="s">"world"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span></span><span id="LC6" class="line"><span class="k">return</span><span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">shardData</span><span class="o">,</span><span class="n">shardData1</span><span class="o">);</span></span><span id="LC7" class="line"><span class="o">}</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">// 任務並行執行</span></span><span id="LC10" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"parallelJob"</span><span class="o">)</span></span><span id="LC11" class="line"><span class="kd">public</span><span class="nc">String</span><span class="nf">parallelJob</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC12" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [parallelJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC13" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC14" class="line"><span class="kd">final</span><span class="nc">ShardData</span><span class="n">parentJobData</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobData</span><span class="o">(</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></span><span id="LC15" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job parallelJob, parentJobData: {}"</span><span class="o">,</span><span class="n">parentJobData</span><span class="o">);</span></span><span id="LC16" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job parallelJob, parentJobData: {}"</span><span class="o">,</span><span class="n">parentJobData</span><span class="o">);</span></span><span id="LC17" class="line"><span class="k">return</span><span class="s">"a=123"</span><span class="o">;</span></span><span id="LC18" class="line"><span class="o">}</span></span><span id="LC19" class="line"></span><span id="LC20" class="line"><span class="c1">// 任務彙總執行</span></span><span id="LC21" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"reduceJob2"</span><span class="o">)</span></span><span id="LC22" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">reduceJob</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC23" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC24" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC25" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"job argument: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getJobParameter</span><span class="o">());</span></span><span id="LC26" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executed"</span><span class="o">);</span></span><span id="LC27" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC28" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, results {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobExecuteResults</span><span class="o">()</span></span><span id="LC29" class="line"><span class="o">);</span></span><span id="LC30" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, statues {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobExecuteStatuses</span><span class="o">());</span></span><span id="LC31" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-xxljob 任務接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#xxljob%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>xxljob 任務接入 demo</h3><p>詳細 demo 代碼參考 <em>hodor-examples/hodor-actuator-xxljob-example</em> 模塊</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="cm">/**</span></span><span id="LC2" class="line"><span class="cm"> * 1、簡單任務示例（Bean 模式）</span></span><span id="LC3" class="line"><span class="cm"> */</span></span><span id="LC4" class="line"><span class="nd">@XxlJob</span><span class="o">(</span><span class="s">"demoJobHandler"</span><span class="o">)</span></span><span id="LC5" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">demoJobHandler</span><span class="o">()</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC6" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"XXL-JOB, Hello World."</span><span class="o">);</span></span><span id="LC7" class="line"></span><span id="LC8" class="line"><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"beat at:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span></span><span id="LC10" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC11" class="line"><span class="o">}</span></span><span id="LC12" class="line"><span class="c1">// default success</span></span><span id="LC13" class="line"><span class="o">}</span></span><span id="LC14" class="line"></span><span id="LC15" class="line"><span class="cm">/**</span></span><span id="LC16" class="line"><span class="cm"> * 2、分片廣播任務</span></span><span id="LC17" class="line"><span class="cm"> */</span></span><span id="LC18" class="line"><span class="nd">@XxlJob</span><span class="o">(</span><span class="s">"shardingJobHandler"</span><span class="o">)</span></span><span id="LC19" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">shardingJobHandler</span><span class="o">()</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC20" class="line"><span class="c1">// 分片參數</span></span><span id="LC21" class="line"><span class="kt">int</span><span class="n">shardIndex</span><span class="o">=</span><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">getShardIndex</span><span class="o">();</span></span><span id="LC22" class="line"><span class="kt">int</span><span class="n">shardTotal</span><span class="o">=</span><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">getShardTotal</span><span class="o">();</span></span><span id="LC23" class="line"></span><span id="LC24" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"分片參數：當前分片序號 = {}, 總分片數 = {}"</span><span class="o">,</span><span class="n">shardIndex</span><span class="o">,</span><span class="n">shardTotal</span><span class="o">);</span></span><span id="LC25" class="line"></span><span id="LC26" class="line"><span class="c1">// 業務邏輯</span></span><span id="LC27" class="line"><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">shardTotal</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span><span class="o">{</span></span><span id="LC28" class="line"><span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="n">shardIndex</span><span class="o">)</span><span class="o">{</span></span><span id="LC29" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"第 {} 片, 命中分片開始處理"</span><span class="o">,</span><span class="n">i</span><span class="o">);</span></span><span id="LC30" class="line"><span class="o">}</span><span class="k">else</span><span class="o">{</span></span><span id="LC31" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"第 {} 片, 忽略"</span><span class="o">,</span><span class="n">i</span><span class="o">);</span></span><span id="LC32" class="line"><span class="o">}</span></span><span id="LC33" class="line"><span class="o">}</span></span><span id="LC34" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-spring-task 任務接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#spring-task%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>spring task 任務接入 demo</h3><p>詳細 demo 代碼參考 <em>hodor-examples/hodor-actuator-springtask-example</em> 模塊</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedRate</span><span class="o">=</span><span class="mi">3000</span><span class="o">)</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task1</span><span class="o">()</span><span class="kd">throws</span><span class="nc">InterruptedException</span><span class="o">{</span></span><span id="LC3" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC4" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"執行 fixedRate 任務的時間："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC5" class="line"><span class="o">}</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedDelay</span><span class="o">=</span><span class="mi">4000</span><span class="o">)</span></span><span id="LC8" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task2</span><span class="o">()</span><span class="kd">throws</span><span class="nc">InterruptedException</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC10" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"執行 fixedDelay 任務的時間："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC11" class="line"><span class="o">}</span></span><span id="LC12" class="line"></span><span id="LC13" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">cron</span><span class="o">=</span><span class="s">"0/5 * * * * ?"</span><span class="o">)</span></span><span id="LC14" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task3</span><span class="o">()</span><span class="o">{</span></span><span id="LC15" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"執行 cron 任務的時間："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC16" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-agent-方式任務接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#agent-%E6%96%B9%E5%BC%8F%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>agent 方式任務接入 demo</h3><p>詳細參考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fiqrsqxh2i2qt5ixi">執行器操作指南</a> 中的 agent 方式的使用。</p><h2><a id="user-content-hodor 打包部署説明" class="anchor" href="https://gitee.com/dromara/hodor#hodor%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%AF%B4%E6%98%8E"></a>hodor 打包部署説明</h2><p>詳細參考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fgiukp9y4plqb55ng">安裝部署操作指南</a></p><h2><a id="user-content-交流學習" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BA%A4%E6%B5%81%E5%AD%A6%E4%B9%A0"></a>交流學習</h2><p>目前，Hodor 仍處於建設的過程中，團隊成員只能抽出空閒時間投入其中，主要精力還是放在日常工作中。
如果有興趣的同學想要參與 Hodor 的實現或者一起學習，歡迎通過微信聯繫我們，我們非常歡迎新的成員加入！</p><p>Hodor 的未來發展方向包括以下幾個方面：</p><ol><li>前端界面和控制枱開發，為用戶提供更加友好、直觀的任務管理界面。</li><li>執行器開發工作，包括執行編程框架和大數據任務執行器的優化，以提高系統的性能和穩定性。</li><li>通信協議改造，計劃將目前自定義的協議改造為 grpc 的方式，以提高系統的可擴展性和兼容性。</li><li>優化 CopySet 算法的實現，以支持機架感知，更好地分配任務副本。</li><li>開發多語言執行器，主要放在 go 和 rust 語言，以滿足用戶不同的需求和偏好。</li></ol><p>Wechat：(備註：Hodor)</p><p><img src="https://gitee.com/dromara/hodor/raw/master/docs/assets/img/wechat.png" alt="image-20220529141555032" referrerpolicy="no-referrer"></p>]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/dromara/hodor</guid>
            <link>https://gitee.com/dromara/hodor</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | Dubbo 路由及負載均衡性能優化]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="font-size: 15px;"><section style="text-align: right;margin-top: 10px;margin-bottom: -25px;" powered-by="xiumi.us"><section style="display: inline-block;width: 35px;height: 35px;vertical-align: top;overflow: hidden;border-width: 1px;border-radius: 100%;border-style: solid;border-color: transparent;background-color: rgb(255, 255, 255);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section><section style="text-align: center;font-size: 14px;" powered-by="xiumi.us"><p><span style="color: rgb(0, 82, 255);"><span style="color: rgb(0, 82, 255);letter-spacing: 0.578px;text-align: center;text-wrap: wrap;font-size: 14px;">揭祕 vivo 互聯網海量服務的研發之路&nbsp;</span><span style="color: rgb(0, 82, 255);text-align: center;text-wrap: wrap;font-size: 14px;letter-spacing: 0.034em;">報名中👇</span></span></p></section><section style="text-align: center;margin-top: 0.5em;margin-bottom: 0.5em;padding-left: 0.5em;padding-right: 0.5em;" powered-by="xiumi.us"><section style="border-width: 5px;border-style: solid;border-color: rgb(255, 255, 255);display: inline-block;line-height: 0;box-shadow: rgb(102, 102, 102) 0.2em 0.2em 0.5em;width: 70%;height: auto;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D2%26sn%3D949ce368a94c5950749a74fec56b98fb%26chksm%3Debdb8632dcac0f24fbac44050c9605d521f9728517b311f54639e1ab3bc0422ce95391b09636%26scene%3D21%23wechat_redirect" textvalue="你已選中了添加鏈接的內容" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="1"><span class="js_jump_icon h5_image_link"><img class="rich_pages wxw-img" data-cropselx1="0" data-cropselx2="384" data-cropsely1="0" data-cropsely2="384" data-ratio="0.21944444444444444" data-s="300,640" src="https://oscimg.oschina.net/oscnet/92614968-2ae5-4624-9416-5e3659137ef6.png" data-type="jpeg" data-w="1080" style="vertical-align: middle;width: 578px;height: 127px;" referrerpolicy="no-referrer"></span></a></section><span style="font-size: 14px;letter-spacing: 0.034em;text-align: justify;"></span></section></section><section style="font-size: 15px;line-height: 1.6;"><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">作者：vivo 互聯網中間件團隊- Wang Xiaochuang</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: left;" powered-by="xiumi.us"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);"><p style="text-wrap: wrap;">本文主要介紹在 vivo 內部針對 Dubbo 路由模塊及負載均衡的一些優化手段，主要是異步化+緩存，可減少在 RPC 調用過程中路由及負載均衡的 CPU 消耗，極大提升調用效率。</p></section></section><section style="margin-right: 0%;margin-bottom: -5px;margin-left: 0%;text-align: right;line-height: 1;font-size: 5px;transform: translate3d(5px, 0px, 0px);" powered-by="xiumi.us"><section style="width: 0px;display: inline-block;vertical-align: top;border-bottom: 0.6em solid rgb(160, 160, 160);border-right: 0.6em solid rgb(160, 160, 160);border-top: 0.6em solid transparent !important;border-left: 0.6em solid transparent !important;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>一、概要</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">vivo 內部 Java 技術棧業務使用的是 Apache Dubbo 框架，基於開源社區 2.7.x 版本定製化開發。在海量微服務集羣的業務實踐中，我們發現 Dubbo 有一些性能瓶頸的問題會極大影響業務邏輯的執行效率，尤其是在集羣規模數量較大時 (提供方數量&gt;100)，路由及負載均衡方面有着較大的 CPU 消耗，從採集的火焰圖分析高達 30%。為此我們針對 vivo 內部常用路由策略及負載均衡進行相關優化，並取得了較好的效果。接下來主要跟大家分析一下相關問題產生的根源，以及我們採用怎樣的方式來解決這些問題。（當前 vivo 內部使用的 Dubbo 的主流版本是基於 2.7.x 進行相關定製化開發。）</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>二、背景知識</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.1 Dubbo 客戶端調用流程</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1.&nbsp;相關術語介紹</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.35069075451647186" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bac7b7d2-f9db-4eb0-9f3d-5900e79ab3fe.png" data-type="png" data-w="941" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;主要流程</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">客戶端通過本地代理 Proxy 調用 ClusterInvoker，ClusterInvoker 從服務目錄 Directory 獲取服務列表後經過路由鏈獲取新的服務列表、負載均衡從路由後的服務列表中根據不同的負載均衡策略選取一個遠端 Invoker 後再發起遠程 RPC 調用。</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.562962962962963" data-s="300,640" src="https://oscimg.oschina.net/oscnet/c2e7d8db-665a-4a4f-b704-246b9544a375.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.2 Dubbo 路由機制</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Dubbo 的路由機制實際是基於簡單的責任鏈模式實現，同時 Router 繼承了 Comparable 接口，自定義的路由可以設置不同的優先級進而定製化責任鏈上 Router 的順序。基於責任鏈模式可以支持多種路由策略串行執行如就近路由+標籤路由，或條件路由+就近路由等，且路由的配置支持基於接口級的配置也支持基於應用級的配置。常見的路由方式主要有：就近路由，條件路由，標籤路由等。具體的執行過程如下圖所示：</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.0143112701252237" data-s="300,640" src="https://oscimg.oschina.net/oscnet/de6310ef-9be0-491d-8451-14b01a37e125.png" data-type="png" data-w="559" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 核心類</strong></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">Dubbo 路由的核心類主要有：<strong>RouterChain、RouterFactory 與 Router 。</strong></p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">（1）RouterChain</p><p style="text-wrap: wrap;">RouterChain 是路由鏈的入口，其核心字段有<br></p></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><strong>invokers（List&lt;invoker&gt; 類型）</strong></p><p>初始服務列表由服務目錄 Directory 設置，當前 RouterChain 要過濾的 Invoker 集合<br></p></li><li><p><strong>builtinRouters（List 類型）</strong></p><p>當前 RouterChain 包含的自動激活的 Router 集合<br></p></li><li><p><strong>routers（List 類型）</strong></p><p>包括所有要使用的路由由 builtinRouters 加上通過 addRouters() 方法添加的 Router 對象</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">RouterChain 核心邏輯</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">class</span><span class="code-snippet__title">RouterChain</span>&lt;<span class="code-snippet__title">T</span>&gt; </span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 註冊中心最後一次推送的服務列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers = Collections.emptyList();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 所有路由,包括原生 Dubbo 基於註冊中心的路由規則如「route://」 urls .</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> volatile <span class="code-snippet__keyword">List</span>&lt;Router&gt; routers = Collections.emptyList();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 初始化自動激活的路由</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span><span class="code-snippet__keyword">List</span>&lt;Router&gt; builtinRouters = Collections.emptyList();</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> RouterChain(URL url) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//通過 ExtensionLoader 加載可自動激活的 RouterFactory</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;RouterFactory&gt; extensionFactories = ExtensionLoader.getExtensionLoader(RouterFactory.class)</span></code><code><span class="code-snippet_outer">                .getActivateExtension(url, ROUTER_KEY);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 由工廠類生成自動激活的路由策略</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Router&gt; routers = extensionFactories.stream()</span></code><code><span class="code-snippet_outer">                .map(factory -&gt; factory.getRouter(url))</span></code><code><span class="code-snippet_outer">                .collect(Collectors.toList());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        initWithRouters(routers);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 添加額外路由</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> void addRouters(<span class="code-snippet__keyword">List</span>&lt;Router&gt; routers) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Router&gt; newRouters = <span class="code-snippet__keyword">new</span> ArrayList&lt;&gt;();</span></code><code><span class="code-snippet_outer">        newRouters.addAll(builtinRouters);</span></code><code><span class="code-snippet_outer">        newRouters.addAll(routers);</span></code><code><span class="code-snippet_outer">        Collections.sort(newRouters, comparator);</span></code><code><span class="code-snippet_outer">        this.routers = newRouters;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; route(URL url, Invocation invocation) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; finalInvokers = invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 遍歷全部的 Router 對象，執行路由規則</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (Router router : routers) {</span></code><code><span class="code-snippet_outer">            finalInvokers = router.route(finalInvokers, url, invocation);</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> finalInvokers;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）RouterFactory 為 Router 的工廠類</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">RouterFactory 接口定義</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@SPI</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">RouterFactory</span></span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Adaptive</span>(<span class="code-snippet__string">"protocol"</span>)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__function">Router <span class="code-snippet__title">getRouter</span><span class="code-snippet__params">(URL url)</span></span>;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（3）Router</p><p style="text-wrap: wrap;" powered-by="xiumi.us">Router 是真正的路由實現策略，由 RouterChain 進行調用，同時 Router 繼承了 Compareable 接口，可以根據業務邏輯設置不同的優先級。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">Router 主要接口定義</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">Router</span><span class="code-snippet__keyword">extends</span><span class="code-snippet__title">Comparable</span>&lt;<span class="code-snippet__title">Router</span>&gt; </span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     *</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers   帶過濾實例列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> url        消費方 url</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invocation 會話信息</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span> routed invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@throws</span> RpcException</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer">    &lt;T&gt; <span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; route(<span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 當註冊中心的服務列表發現變化，或有動態配置變更會觸發實例信息的變化</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 當時 2.7.x 的 Dubbo 並沒有真正使用這個方法，可基於此方法進行路由緩存</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers invoker list</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;      invoker's type</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">default</span> &lt;T&gt; void notify(<span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;同機房優先路由的實現</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="letter-spacing: 0.034em;">為方便大家瞭解路由的實現，給大家展示一下就近路由的核心代碼邏輯</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL consumerUrl, Invocation invocation) throws RpcException {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (!<span class="code-snippet__keyword">this</span>.enabled) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 獲取本地機房信息</span></span></code><code><span class="code-snippet_outer">        String local = getSystemProperty(LOC);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers == <span class="code-snippet__literal">null</span> || invokers.size() == <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">        List&lt;Invoker&lt;T&gt;&gt; result = new ArrayList&lt;Invoker&lt;T&gt;&gt;();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (Invoker invoker: invokers) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 獲取與本地機房一致的 invoker 並加入列表中</span></span></code><code><span class="code-snippet_outer">            String invokerLoc = getProperty(invoker, invocation, LOC);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (local.equals(invokerLoc)) {</span></code><code><span class="code-snippet_outer">                result.add(invoker);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (result.size() &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (fallback){</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 開啓服務降級，available.ratio = 當前機房可用服務節點數量 ／ 集羣可用服務節點數量</span></span></code><code><span class="code-snippet_outer">                int curAvailableRatio = (int) Math.floor(result.size() * <span class="code-snippet__number">100.0</span>d / invokers.size());</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (curAvailableRatio &lt;= availableRatio) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (force) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.3 Dubbo 負載均衡</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Dubbo 的負載均衡實現比較簡單基本都是繼承抽象類進行實現，主要作用就是根據具體的策略在路由之後的服務列表中篩選一個實例進行遠程 RPC 調用，默認的負載均衡策略是隨機。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">整體類圖如下所示：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.2824074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/22c30ee5-d60d-45b1-a737-bbf064f7c1cc.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">LoadBalance 接口定義</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@SPI</span>(RandomLoadBalance.NAME)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">LoadBalance</span></span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 從服務列表中篩選一個.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     *</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers   invokers.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> url        refer url</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invocation invocation.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span> selected invoker.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Adaptive</span>(<span class="code-snippet__string">"loadbalance"</span>)</span></code><code><span class="code-snippet_outer">    &lt;T&gt; <span class="code-snippet__function">Invoker&lt;T&gt; <span class="code-snippet__title">select</span><span class="code-snippet__params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span><span class="code-snippet__keyword">throws</span> RpcException</span>;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">隨機負載均衡核心代碼解析</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 預熱過程權重計算</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">static</span><span class="code-snippet__keyword">int</span><span class="code-snippet__title">calculateWarmupWeight</span>(<span class="code-snippet__params"><span class="code-snippet__keyword">int</span> uptime, <span class="code-snippet__keyword">int</span> warmup, <span class="code-snippet__keyword">int</span> weight</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> ww = (<span class="code-snippet__keyword">int</span>) (uptime / ((<span class="code-snippet__keyword">float</span>) warmup / weight));</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> ww &lt; <span class="code-snippet__number">1</span> ? <span class="code-snippet__number">1</span> : (Math.min(ww, weight));</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">int</span><span class="code-snippet__title">getWeight</span>(<span class="code-snippet__params">Invoker&lt;?&gt; invoker, Invocation invocation</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> weight;</span></code><code><span class="code-snippet_outer">       URL url = invoker.getUrl();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 多註冊中心場景下的，註冊中心權重獲取</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">           weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">       } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer">           weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (weight &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 獲取實例啓動時間</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">long</span> timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, <span class="code-snippet__number">0L</span>);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (timestamp &gt; <span class="code-snippet__number">0L</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">long</span> uptime = System.currentTimeMillis() - timestamp;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (uptime &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span><span class="code-snippet__number">1</span>;</span></code><code><span class="code-snippet_outer">                   }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 獲取預熱時間</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (uptime &gt; <span class="code-snippet__number">0</span> &amp;&amp; uptime &lt; warmup) {</span></code><code><span class="code-snippet_outer">                       weight = calculateWarmupWeight((<span class="code-snippet__keyword">int</span>)uptime, warmup, weight);</span></code><code><span class="code-snippet_outer">                   }</span></code><code><span class="code-snippet_outer">               }</span></code><code><span class="code-snippet_outer">           }</span></code><code><span class="code-snippet_outer">       }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> Math.max(weight, <span class="code-snippet__number">0</span>);</span></code><code><span class="code-snippet_outer">   }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">@Override</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">protected</span> &lt;T&gt; <span class="code-snippet__function">Invoker&lt;T&gt; <span class="code-snippet__title">doSelect</span>(<span class="code-snippet__params">List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Number of invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> length = invokers.size();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Every invoker has the same weight?</span></span></code><code><span class="code-snippet_outer">        boolean sameWeight = <span class="code-snippet__literal">true</span>;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// the weight of every invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span>[] weights = <span class="code-snippet__keyword">new</span><span class="code-snippet__keyword">int</span>[length];</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// the first invoker's weight</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> firstWeight = getWeight(invokers.<span class="code-snippet__keyword">get</span>(<span class="code-snippet__number">0</span>), invocation);</span></code><code><span class="code-snippet_outer">        weights[<span class="code-snippet__number">0</span>] = firstWeight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// The sum of weights</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> totalWeight = firstWeight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = <span class="code-snippet__number">1</span>; i &lt; length; i++) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> weight = getWeight(invokers.<span class="code-snippet__keyword">get</span>(i), invocation);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// save for later use</span></span></code><code><span class="code-snippet_outer">            weights[i] = weight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Sum</span></span></code><code><span class="code-snippet_outer">            totalWeight += weight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) {</span></code><code><span class="code-snippet_outer">                sameWeight = <span class="code-snippet__literal">false</span>;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (totalWeight &gt; <span class="code-snippet__number">0</span> &amp;&amp; !sameWeight) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on totalWeight.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Return a invoker based on the random value.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = <span class="code-snippet__number">0</span>; i &lt; length; i++) {</span></code><code><span class="code-snippet_outer">                offset -= weights[i];</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (offset &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers.<span class="code-snippet__keyword">get</span>(i);</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers.<span class="code-snippet__keyword">get</span>(ThreadLocalRandom.current().nextInt(length));</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>預熱解釋</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">預熱是為了讓剛啓動的實例流量緩慢增加,因為實例剛啓動時各種資源可能還沒建立連接，相關代碼可能還是處於解釋執行，仍未變為 JIT 執行，此時業務邏輯較慢，不應該加載過大的流量，否則有可能造成較多的超時。Dubbo 默認預熱時間為 10 分鐘，新部署的實例的流量會在預熱時間段內層線性增長，最終與其他實例保持一致。Dubbo 預熱機制的實現就是通過控制權重來實現。如默認權重 100，預熱時間 10 分鐘，則第一分鐘權重為 10，第二分鐘為 20，以此類推。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具體預熱效果圖如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.45765765765765765" data-s="300,640" src="https://oscimg.oschina.net/oscnet/752bc3b5-e121-4de3-b41b-022860b2700e.png" data-type="png" data-w="555" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>三、問題分析</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">使用 Dubbo 的業務方反饋，他們通過火焰圖分析發現 Dubbo 的負載均衡模塊+路由模塊佔用 CPU 超過了 30%，框架層面的使用率嚴重影響了業務邏輯的執行效率急需進行優化。通過火焰圖分析，具體佔比如下圖，其中該機器在業務忙時的 CPU 使用率在 60% 左右，閒時在 30% 左右。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.30970873786407765" data-s="300,640" src="https://oscimg.oschina.net/oscnet/81ae8f99-a18c-4416-8f9a-b6c012a14476.png" data-type="png" data-w="1030" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通過火焰圖分析，負載均衡主要的消耗是在 getWeight 方法。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.1388888888888889" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b1d57058-f760-43c5-83bc-166c07ca9d81.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">路由的主要消耗是在 route 方法：</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">同機房優先路由</p><p style="text-wrap: wrap;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.11296296296296296" data-s="300,640" src="https://oscimg.oschina.net/oscnet/fee26d17-6eb3-4103-b12d-cc8975696932.png" data-type="png" data-w="1080" style="font-size: 15px;letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" referrerpolicy="no-referrer"></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">接口級標籤路由+應用級標籤路由</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.14907407407407408" data-s="300,640" src="https://oscimg.oschina.net/oscnet/11c33b76-0ae1-45fe-aeef-a05793340801.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">這些方法都有一個特點，那就是遍歷執行。如負載均衡，針對每一個 invoker 都需要通過 getWeight 方法進行權重的計算；就近路由的 router 方法對於每一個 invoker 都需要通過 url 獲取及機房信息進行匹配計算。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">我們分析一下 getWeight 及 router 時間複雜度，發現是 O(n) 的時間複雜度，而且路由是由路由鏈組成的，每次每個 Router 的 route 方法調用邏輯都會遍歷實例列表，那麼當實例列表數量過大時，每次匹配的計算的邏輯過大，那麼就會造成大量的計算成本，導致佔用大量 cpu，同時也導致路由負載均衡效率低下。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">綜上所述，罪惡的的根源就是遍歷導致的，當服務提供方數量越多，影響越大。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>四、優化方案</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">知道了問題所在，我們來分析一下是否有優化空間。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.1 路由優化</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 優化一：關閉無效路由</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通過火焰圖分析，我們發現有部分業務即使完全不使用應用級的標籤路由，原生的 TagRouter 也存在遍歷邏輯，原因是為了支持靜態的標籤路由，其實這部分的開銷也不少，那對於根本不會使用應用級標籤路由的可以手動進行關閉。關閉方式如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">客戶端統一關閉<br></p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js"><code><span class="code-snippet_outer">dubbo.consumer.router=-tag</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">服務級別關閉</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">註解方式：</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@DubboReference(parameters = {<span class="code-snippet__meta-string">"router"</span>,<span class="code-snippet__meta-string">"-tag"</span>})</span></span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">xml 方式：</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer">&lt;dubbo:reference id=<span class="code-snippet__string">"demoService"</span> check=<span class="code-snippet__string">"false"</span><span class="code-snippet__keyword">interface</span>=<span class="code-snippet__string">"com.dubbo.study.n.api.DemoService"</span> router=<span class="code-snippet__string">"-tag"</span> /&gt;</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2. 優化二：提前計算路由結果並進行緩存</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">每次路由目前都是進行實時計算，但是在大多數情況下，我們的實例列表是穩定不變的，只有在發佈窗口或配置變更窗口內實例列表才會發生變更，那我們是否可以考慮緩存呢。如就近路由，可以以機房為 key 進行機房實例的全量緩存。針對接口級標籤路由可以緩存不同標籤值指定的實例信息。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">我們知道路由的執行過程是責任鏈模式，每一個 Router 的實例列表入參實際上是一個 Router 的結果，可參考公式：target = rn(…r3(r2(r1(src))))。那麼所有的路由可以基於註冊中心推送的原始服務列表進行路由計算並緩存，然後不同的路由結果相互取交集就能得到最終的結果，當實例信息發生變更時，緩存失效並重新計算。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>3. 緩存更新時機</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">當註冊中心或者動態配置有變更時，相關通知會給到服務目錄 Directory,Directory 收到通知後會重新創建服務列表，並把服務列表同步到路由鏈 RouterChain，RouterChain 再按順序通知其鏈上的 Router,各個 Router 再進行緩存清除並重新進行路由結果的計算及進行緩存。相關時序圖如下所示：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.42962962962962964" data-s="300,640" src="https://oscimg.oschina.net/oscnet/e8b71fb8-8926-40de-abe8-147ba10fa2ea.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>4. 具體路由流程</strong></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">進入具體路由方法時，先判斷是否存在緩存的路由值，且緩存值的 epoch 必須與上一個路由的 epoch 需一致，此時緩存才生效，然後緩存值與上個 Router 的結果取交集。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">如果不存在緩存或 epoch 不一致則重新進行實時的路由計算。</p><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.7803921568627451" data-s="300,640" src="https://oscimg.oschina.net/oscnet/024bfb79-3f68-4ca5-bf7f-bfd337d6c3d0.jpg" data-type="jpeg" data-w="1020" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us">引入 epoch 的原因主要是保證各個路由策略緩存信息的一致性，保證所有的緩存計算都是基於同一份原始數據。當實例信息發生變更時，epoch 會自動進行更新。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>5. BitMap 引入</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">上文我們説到，不同的路由策略之間的結果是取交集的，然後最終的結果才送入負載均衡流程。那如何在緩存的同時，加快交集的計算呢。答案就是基於位圖：BitMap。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">BitMap 的基本原理就是用一個 bit 位來存放某種狀態，適用於大規模數據的查找及位運算操作。如在路由場景，先基於全量的推送數據進行計算緩存。如果某個實例被路由選中，則其值為 1，若兩個路由的結果要取交集，那直接對 BitMap 進行"&amp;"運行即可。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">全量緩存示意圖：</p><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.4935185185185185" data-s="300,640" src="https://oscimg.oschina.net/oscnet/5fc6e016-b880-40ce-9d59-390fe111bfa8.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us">路由交集計算示步驟：</p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">按照路由鏈依次計算，</p><p style="text-wrap: wrap;">tagRouter-&gt;vivoTag-&gt;vivoNearestRouter</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（1）tagRouter 計算邏輯：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>按照 Invocation 計算出目標的 Tag,假設是 tag1</p></li><li><p>然後從緩存 Cache 根據 key:tag1,取出對應的 targetAddrPool</p></li><li><p>將原始傳入的 addrPool</p><p>與 targetAddrPool</p><p>得到結果 resultAddrPool</p></li><li><p>將 resultAddrPool 傳入 vivoTagRouter</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）vivoTag 計算邏輯：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>按照 Invocation 計算出目標的 Tag,假設是 tabB</p></li><li><p>然後從緩存 Cache 根據 key:tag1，取出對應的 targetAddrPool</p></li><li><p>將上一次傳入的 addrPool</p><p>與 targetAddrPool</p><p>得到結果 resultAddrPooll</p></li><li><p>將 resultAddrPool 傳入</p><p>vivoNearestRouter</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">（3）vivoNearestRouter 計算邏輯</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>從環境變量取出當前機房，假設是 bj01</p></li><li><p>然後從緩存 Cache 根據 key:bj01，取出對應的 targetAddrPool</p></li><li><p>將上一次傳入的 addrPool</p><p>與 targetAddrPool</p><p>取出 resultAddrPool</p></li><li><p>將上一次傳入的 addrPool</p><p>與 targetAddrPool</p><p>得到結果 resultAddrPool</p></li><li><p>將 resultAddrPool 為最終路由結果，傳遞給 LoadBalance</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6907407407407408" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bfad5e5c-e485-4ab8-8b25-208b5ca92c3d.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>6. 基於緩存的同機房優先路由源碼解析</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">緩存刷新</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * Notify router chain of the initial addresses from registry at the first time.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * Notify whenever addresses in registry change.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">public</span><span class="code-snippet__keyword">void</span><span class="code-snippet__title">setInvokers</span>(<span class="code-snippet__params">List&lt;Invoker&lt;T&gt;&gt; invokers</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 創建帶 epoch 的 BitList</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">this</span>.invokers = <span class="code-snippet__keyword">new</span> BitList&lt;Invoker&lt;T&gt;&gt;(invokers == <span class="code-snippet__literal">null</span> ? Collections.emptyList() : invokers,createBitListEpoch());</span></code><code><span class="code-snippet_outer">        routers.forEach(router -&gt; router.notify(<span class="code-snippet__keyword">this</span>.invokers));</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">同機房優先路由源碼解讀</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL consumerUrl, Invocation invocation) throws RpcException {</span></code><code><span class="code-snippet_outer">        …………<span class="code-snippet__comment">//省略非核心代碼</span></span></code><code><span class="code-snippet_outer">        BitList&lt;Invoker&lt;T&gt;&gt; bitList = (BitList&lt;Invoker&lt;T&gt;&gt;) invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//獲取路由結果</span></span></code><code><span class="code-snippet_outer">        BitList&lt;Invoker&lt;T&gt;&gt; result = getNearestInvokersWithCache(bitList);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (result.size() &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (fallback) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 開啓服務降級，available.ratio = 當前機房可用服務節點數量 ／ 集羣可用服務節點數量</span></span></code><code><span class="code-snippet_outer">                int curAvailableRatio = (int) Math.floor(result.size() * <span class="code-snippet__number">100.0</span>d / invokers.size());</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (curAvailableRatio &lt;= availableRatio) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (force) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }   </span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 獲取緩存列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span></span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> &lt;T&gt; BitList&lt;Invoker&lt;T&gt;&gt; getNearestInvokersWithCache(BitList&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer">        ValueWrapper valueWrapper = getCache(getSystemProperty(LOC));</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 是否存在緩存</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (valueWrapper != <span class="code-snippet__literal">null</span>) {</span></code><code><span class="code-snippet_outer">            BitList&lt;Invoker&lt;T&gt;&gt; invokerBitList = (BitList&lt;Invoker&lt;T&gt;&gt;) valueWrapper.<span class="code-snippet__keyword">get</span>();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 緩存的 epoch 與源列表是否一致</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers.isSameEpoch(invokerBitList)) {</span></code><code><span class="code-snippet_outer">                BitList&lt;Invoker&lt;T&gt;&gt; tmp = invokers.clone();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 結果取交集</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> tmp.and(invokerBitList);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 緩存不存在，實時計算放回</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> getNearestInvokers(invokers);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 新服務列表通知</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Override</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; void notify(List&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer">        clear();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers != <span class="code-snippet__literal">null</span> &amp;&amp; invokers instanceof BitList) {</span></code><code><span class="code-snippet_outer">            BitList&lt;Invoker&lt;T&gt;&gt; bitList = (BitList&lt;Invoker&lt;T&gt;&gt;) invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 設置最後一次更新的服務列表</span></span></code><code><span class="code-snippet_outer">            lastNotify = bitList.clone();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (!CollectionUtils.isEmpty(invokers) &amp;&amp; <span class="code-snippet__keyword">this</span>.enabled) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 獲取機房相同的服務列表並進行緩存</span></span></code><code><span class="code-snippet_outer">                setCache(getSystemProperty(LOC), getNearestInvokers(lastNotify));</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.2 負載均衡優化</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1.&nbsp;優化一</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">針對 getWeight 方法，我們發現有部分業務邏輯較為消耗 cpu,但是在大多數場景下業務方並不會使用到，於是進行優化。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">getWeight 方法優化</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="javascript"><code><span class="code-snippet_outer">優化前：</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//這裏主要要用多註冊中心場景下，註冊中心權重的獲取，絕大多數情況下並不會有這個邏輯</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">           weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">       }  </span></code><code><span class="code-snippet_outer">優化後：</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invoker <span class="code-snippet__keyword">instanceof</span> ClusterInvoker &amp;&amp; UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">            weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">   }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;優化二</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">遍歷是罪惡的源泉，而實例的數量決定這罪惡的深淺，我們有什麼辦法減少負載均衡過程中的遍歷呢。一是根據 group 及 version 劃分不同的集羣，但是這需要涉及到業務方代碼或配置層面的改動，會帶來額外的成本。所以我們放棄了。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">二是沒有什麼是加一層解決不了的問題，為了儘量減少進入負載均衡的節點數量，考慮新增一個墊底的路由策略，在走完所有的路由策略後，若節點數量&gt;自定義數量後，進行虛擬分組，虛擬分組的策略也可進行自定義，然後隨機篩選一組進入負載均衡。此時進入負載均衡的實例數量就會有倍數的下降。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">需要注意的是分組路由必須保證是在路由鏈的最後一環，否則會導致其他路由計算錯誤。</p></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.37984496124031" data-s="300,640" src="https://oscimg.oschina.net/oscnet/9ad0f113-9f91-4397-9e60-71b4b03e349f.png" data-type="png" data-w="645" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">分組路由示意</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * </span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers 待分組實例列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> groupNum 分組數量</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span></span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; doGroup(List&lt;Invoker&lt;T&gt;&gt; invokers, <span class="code-snippet__keyword">int</span> groupNum) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> listLength = invokers.size() / groupNum;</span></code><code><span class="code-snippet_outer">        List&lt;Invoker&lt;T&gt;&gt; result = <span class="code-snippet__keyword">new</span> ArrayList&lt;&gt;(listLength);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> random = ThreadLocalRandom.current().nextInt(groupNum);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = random; i &lt; invokers.size(); i = i + groupNum) {</span></code><code><span class="code-snippet_outer">            result.add(invokers.get(i));</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>五、優化效果</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">針對優化前和優化後，我們編寫 Demo 工程分別壓測了不配置路由/配置就近+標籤路由場景。Provider 節點梯度設置 100/500/1000/2000/5000，TPS 在 1000 左右，記錄了主機的 cpu 等性能指標，並打印火焰圖。發現，配置路由後，採用相同併發，優化後的版本 tps 明顯高於優化前版本，且新版本相較於沒有配置路由時 tps 顯著提高，下游節點數大於 2000 時，tps 提升達到 100% 以上，下游節點數越多，AvgCpu 優化效果越明顯，並且路由及負載均衡 CPU 佔比明顯更低，詳細數據可見下表：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.5994694960212201" data-s="300,640" src="https://oscimg.oschina.net/oscnet/1321713f-e488-4248-8ead-3e1db6f52543.png" data-type="png" data-w="754" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.7027777777777777" data-s="300,640" src="https://oscimg.oschina.net/oscnet/be116887-8e9c-4e6f-ba48-b83efffe2464.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">備註：-tag，表示顯式禁用原生 Dubbo 應用級標籤路由。該路由默認開啓。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>六、總結</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">經過我們關閉不必要的路由邏輯、對路由緩存+異步化計算、新增分組路由等優化後，Dubbo 在負載均衡及路由模塊整體的性能有了顯著的提升，為業務方節省了不少 CPU 資源。在正常業務場景下當提供方數量達到 2000 及以上時，tps 提升可達 100% 以上，消費方平均 CPU 使用率下降約 27%，且提供方數量越多優化效果越明顯。但是我們也發現當前的隨機負載均衡依然還是會消耗一定的 CPU 資源，且只能保證流量是均衡的。當前我們的應用基本部署在虛擬機及容器上。這兩者均存在超賣的狀況，且同等配置的宿主機性能存在較大差異等問題。最終會導致部分請求超時、無法最大化利用提供方的資源。我們下一步將會引入 Dubbo 3.2 的自適應負載均衡並進行調優減少其 CPU 使用率波動較大的問題，其次我們自身也擴展了基於 CPU 負載均衡的單一因子算法，最終實現不同性能的機器 CPU 負載趨於均衡，最大程度發揮集羣整體的性能。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="color: rgb(65, 95, 255);" powered-by="xiumi.us"><p style="text-wrap: wrap;">參考資料：</p></section><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;" powered-by="xiumi.us"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Fload-balance%2F" textvalue="Dubbo 負載均衡" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 負載均衡</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Ftraffic%2F" textvalue="Dubbo 流量管控" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 流量管控</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU4NzU0MDIzOQ%3D%3D%26mid%3D2247511003%26idx%3D3%26sn%3Defdf3f42790b74226b2ed45b701a6749%26scene%3D21%23wechat_redirect" textvalue="Dubbo 3 StateRouter：下一代微服務高效流量路由" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 3 StateRouter：下一代微服務高效流量路由</span></a></p></li></ol><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;"><section style="text-align: center;color: rgb(45, 66, 87);font-size: 11px;" powered-by="xiumi.us"><p>END</p></section></section><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: left;" powered-by="xiumi.us"><section style="padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;"><span style="display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);" title="" opera-tn-ra-cell="_$.pages:0.layers:0.comps:159.title1"><p>猜你喜歡</p></span></section><section style="border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;"><section style="font-size: 14px;text-align: left;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497343%26idx%3D1%26sn%3D959b66ceb9a8c2fe060b6981b41a807e%26chksm%3Debdb86eddcac0ffb229636ec51ec94433af75c7bc58aaa5ae52b4a2bf6a2d6d2ab11583b3174%26scene%3D21%23wechat_redirect" textvalue="記一次 Redis Cluster Pipeline 導致的死鎖問題" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">記一次 Redis Cluster Pipeline 導致的死鎖問題</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D1%26sn%3D5795a683e52f70384a13b34aa3daf731%26chksm%3Debdb8632dcac0f2468a461db09d8de6219af346e51436b91e6c946ee8b37e6ae8175b2f5d55e%26scene%3D21%23wechat_redirect" textvalue="深入理解 Netty FastThreadLocal" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">深入理解 Netty FastThreadLocal</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497336%26idx%3D1%26sn%3D777059b19e224f1a4fbb1550ad1de7e8%26chksm%3Debdb86eadcac0ffc78dc019c5685ad137fdddd6572238525d707152c102790f82917a473d52a%26scene%3D21%23wechat_redirect" textvalue="MySQL 到 TiDB：Hive Metastore 橫向擴展之路" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">MySQL 到 TiDB：Hive Metastore 橫向擴展之路</a></p></li></ul></section></section></section></section><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互聯網技術" data-alias="vivoVMIC" data-signature="分享 vivo 互聯網技術乾貨與沙龍活動，推薦最新行業動態與熱門會議。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公眾號 - vivo 互聯網技術（vivoVMIC）。<br>如有侵權，請聯繫 support@oschina.cn 刪除。<br>本文參與「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源創計劃</a>」，歡迎正在閲讀的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10136865</guid>
            <link>https://my.oschina.net/vivotech/blog/10136865</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌開放 .ing 頂級域名註冊]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Google <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.google%2Fproducts%2Fregistry%2Fintroducing-the-ing-top-level-domain%2F" target="_blank">宣佈開放 .ing 頂級域名註冊</a></u>，即日起用戶可通過<strong>支付額外費用（費率隨時間推移降低）的方式搶先註冊</strong>，搶先體驗期 (EAP) 截至 12 月 5 日。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1101/104932_JmaT_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>Google 表示藉助該域名企業可以註冊一些非常有趣的域名，比如在線設計和繪圖平台 Canva 註冊的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdesign.ing%2F" target="_blank">design.ing</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdraw.ing%2F" target="_blank">draw.ing</a>、Adobe Acrobat 註冊的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fedit.ing%2F" target="_blank">edit.ing</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsign.ing%2F" target="_blank">signing</a>&nbsp;等。</p><p>.ing 域名註冊地址：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fget.ing%2F" target="_blank">https://get.ing/</a></u></p><p><img height="1676" src="https://static.oschina.net/uploads/space/2023/1101/105256_D6p3_2720166.png" width="3310" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264406/the-ing-top-level-domain</guid>
            <link>https://www.oschina.net/news/264406/the-ing-top-level-domain</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微軟推送 Windows 11 23H2 更新]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#424242">微軟正式推出了<span>&nbsp;</span></span>Windows 11<span style="background-color:#ffffff; color:#424242"><span>&nbsp;</span>的「大更新」版本 <strong>Windows 11 23H2</strong>，用戶可以從官方網站下載正式的鏡像文件，進行全新安裝或者升級安裝。</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-dc52a4c9559bca2e4c971af4eeee2a191ea.png" referrerpolicy="no-referrer"></p><p>考慮到微軟計劃在 2024 年發佈下一代 Windows（可能是 Windows 12），因此&nbsp;23H2 會成為 Windows 11 的最後一個重大更新。</p><blockquote><p><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.microsoft.com%2Fsoftware-download%2Fwindows11" target="_blank">https://www.microsoft.com/software-download/windows11</a></em><br><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.windows.com%2Fwindowsexperience%2F2023%2F10%2F31%2Fhow-to-get-the-windows-11-2023-update%2F" target="_blank">https://blogs.windows.com/windowsexperience/2023/10/31/how-to-get-the-windows-11-2023-update/</a></em></p></blockquote><p><span style="background-color:#ffffff; color:#424242">此次更新添加了名為 Copilot 的 AI 聊天機器人，以及</span>包含微軟此前在 Moment 4 更新中推出的全部新功能，同時還會將內置的聊天應用替換為 Microsoft Teams 免費版。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-89e55171373efda1e01f2a70c140f4a9605.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f4c57381f3a06868203247bdcb41976fe47.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-13ed870d860b818aa514eaf8133f61ae383.png" referrerpolicy="no-referrer"></p><p>和之前的版本 21H2 和 22H2 一樣，Windows 11 23H2 將獲得兩年的支持，每月提供累積更新、修復和新功能。需要提醒的是，Windows 11 21H2 生命週期已經在本月早些時候結束。至於 22H2，微軟將在一年後，即 2024 年 10 月 4 日停止支持。</p><hr><p>以下是 Windows 11 23H2 的其他更新：</p><ul><li><strong>虛擬視頻編輯器</strong>：內置在 Clipchamp 視頻編輯應用中的自動合成功能，利用人工智能技術，使最終視頻的合成過程更容易。</li><li><strong>多語言屏幕閲讀</strong>：去年，微軟在 Windows 的講述人輔助功能中引入了使用人工智能讀取屏幕上文本的自然聲音，此次增加了對其他語言的支持。</li><li><strong>降低能耗</strong>：新的節能功能「自適應調光」可以在你不看屏幕時使屏幕變暗，在你再次看屏幕時重新變亮。</li><li><strong>更智能的截圖功能</strong>：使用 Windows 11 附帶的截圖應用，你可以從截圖中複製文本，並快速編輯電子郵件或電話號碼。</li><li><strong>備份</strong>：現在用戶可以備份之前安裝在 PC 上的應用程序，以便將來恢復它們。</li><li><strong>用文字作畫</strong>：用戶可以輸入幾個單詞並選擇一個樣式，然後畫圖應用會根據你的描述創建圖像。</li><li><strong>更多任務欄自定義</strong>：沒有運行的應用也可以顯示標籤，還可以隱藏時間和日期。</li><li><strong>記事本記憶功能</strong>：記事本會自動保存用戶的狀態。</li><li><strong>照片</strong>：用戶可以在搜索框中輸入關鍵詞和對象，找到存儲在 Overdrive 中的相關圖片。</li><li><strong>即時遊戲</strong>：用戶可以在微軟應用商店中找到休閒遊戲，無需先下載並安裝它們。</li></ul><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-fb28a2a6e8c4ede4b30e08510ca491aa24d.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b555601fed7548bcd1131d2568dd4606f25.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8be9bc80d3279e9bd4dbce568f25c323595.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-dcffdb984fc2f1427c2f174ad16a740329f.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264399/windows-11-2023-update</guid>
            <link>https://www.oschina.net/news/264399/windows-11-2023-update</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[深圳一公司獎勵程序員「黃金鍵帽」，價值近 2 萬元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 10 月 24 日，被眾多科技公司和業內人士稱為「程序員節」。當天，深圳一公司獎勵員工「<strong>黃金鍵帽</strong>」。</p><blockquote><p><img height="1658" src="https://static.oschina.net/uploads/space/2023/1031/185140_pBn0_2720166.png" width="1176" referrerpolicy="no-referrer"></p></blockquote><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F5558240479%2FNpm9Lffdj%3Fpagetype%3Dprofilefeed" target="_blank">據稱</a></u>這款空格鍵鍵帽是 40g 黃金，價值近 2 萬元。</p><p><img src="https://static.oschina.net/uploads/space/2023/1031/185850_Wq96_2720166.png" referrerpolicy="no-referrer"></p><p><em>△「黃金 C 鍵」是該公司去年的獎勵</em></p><p>獲得獎勵程序員根據代碼行數排名和部門推舉共同選出，最具分量的「黃金空格鍵」獎勵給有效代碼量最多的程序員。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 10:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264307</guid>
            <link>https://www.oschina.net/news/264307</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[前三季度互聯網企業利潤總額同比增 18.2%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年前三季度互聯網和相關服務業運行情況現已公佈。前三季度，互聯網業務收入增速小幅提升，利潤總額較快增長，研發經費持續下滑。</p><h4 style="margin-left:0px; margin-right:0px"><strong>一，總體運行情況</strong></h4><p><strong>互聯網業務收入增速小幅提升。</strong>前三季度，我國規模以上互聯網和相關服務企業 1（以下簡稱互聯網企業）完成互聯網業務收入 10294 億元，同比增長 3.4%。</p><p><img height="241" src="https://oscimg.oschina.net/oscnet/up-505b65f84338dd716295e76b74112009b70.png" width="500" referrerpolicy="no-referrer"></p><p><strong>利潤總額較快增長。</strong>前三季度，我國規模以上互聯網企業營業成本同比增長 7%，增速較上半年回落 0.4 個百分點。實現利潤總額 959.3 億元，同比增長 18.2%。</p><p><img height="239" src="https://oscimg.oschina.net/oscnet/up-54642fdf1ae20d26f1bc9494e46da1f4440.png" width="500" referrerpolicy="no-referrer"></p><p><strong>研發經費持續下滑。</strong>前三季度，我國規模以上互聯網企業共投入研發經費 495.9 億元，同比下降 6.1%。</p><p><img height="246" src="https://oscimg.oschina.net/oscnet/up-d14b35b6a1179d07e10ffc542ff0150925e.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px"><strong>二，分領域運行情況</strong></h4><p style="margin-left:0; margin-right:0"><strong>（一）信息服務領域企業收入小幅回落。</strong>前三季度，以信息服務為主的企業（包括新聞資訊、搜索、社交、遊戲、音樂視頻等）互聯網業務收入同比下降 2.7%。</p><p><strong>（二）生活服務領域企業收入較快增長。</strong>前三季度，以提供生活服務為主的平台企業（包括本地生活、租車約車、旅遊出行、金融服務、汽車、房屋住宅等）互聯網業務收入同比增長 9.8%。</p><p><strong>（三）網絡銷售領域企業收入增速持續提升。</strong>前三季度，主要提供網絡銷售服務的企業（包括大宗商品、農副產品、綜合電商、醫療用品、快遞等）互聯網業務收入同比增長 47.3%。</p><h4 style="margin-left:0px; margin-right:0px"><strong>三，分地區運行情況</strong></h4><p><strong>東部地區互聯網業務收入保持平穩增速。</strong>前三季度，東部地區完成互聯網業務收入 9613 億元，同比增長 4.5%，增速較上半年提升 0.7 個百分點，佔全國互聯網業務收入的比重為 93.4%。中部地區完成互聯網業務收入 329.5 億元，同比下降 9.7%，降幅較上半年擴大 2.2 個百分點。西部地區完成互聯網業務收入 325 億元，同比下降 7.5%，降幅較上半年收窄 3.2 個百分點。東北地區完成互聯網業務收入 26.5 億元，同比下降 33.3%，降幅較上半年收窄 6.4 個百分點。</p><p><img height="239" src="https://oscimg.oschina.net/oscnet/up-7b7896fe852aa2c94820a864e846f80cae2.png" width="500" referrerpolicy="no-referrer"></p><p><strong>長三角地區互聯網業務收入實現較快增長。</strong>前三季度，京津冀地區完成互聯網業務收入 3948 億元，同比增長 2.9%，增速較上半年回落 0.3 個百分點，佔全國互聯網業務收入的比重為 38.4%。長三角地區完成互聯網業務收入 4225 億元，同比增長 13.1%，增速較上半年提升 3.5 個百分點。</p><p><img height="300" src="https://oscimg.oschina.net/oscnet/up-f6cddc5c38e933857b00b43bd049054bd02.png" width="500" referrerpolicy="no-referrer"></p><p><strong>半數地區互聯網業務增速實現正增長。</strong>前三季度，互聯網業務累計收入居前 5 名的北京（增長 0.7%）、上海（增長 17.7%）、浙江（增長 5.1%）、廣東（下降 7.4%）和天津（增長 22.3%）共完成業務收入 9077 億元，同比增長 5.5%，佔全國比重達 88.2%。全國互聯網業務增速實現正增長的省（區、市）有 15 個。</p><p><img height="243" src="https://oscimg.oschina.net/oscnet/up-d691bf5c06989113a27d8f6cf4a88d4ab6e.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px"><strong>四，我國移動應用程序（APP）發展情況</strong></h4><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">根據全國 APP 技術檢測平台統計，截至 9 月底，我國國內市場上監測到活躍的 APP 數量 2 為 261 萬款（包括安卓和蘋果商店）。移動應用開發者數量為 84 萬，其中安卓開發者為 26 萬，蘋果開發者為 58 萬。9 月份，安卓應用商店在架應用累計下載量 542 億次。</p><p><span style="color:#888888">附註：</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#888888">1.規模以上互聯網和相關服務企業口徑由上年互聯網和相關服務收入 500 萬元以上調整為 2000 萬元及以上，文中所有同比增速均按可比口徑計算。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#888888">2.活躍的移動應用程序數量是指報告期內我國市場上經過用戶主動下載安裝的第三方移動應用的總個數，其中安卓應用數的計算方法是根據智能手機記錄的已安裝移動應用去重後獲得。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 10:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264303</guid>
            <link>https://www.oschina.net/news/264303</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
