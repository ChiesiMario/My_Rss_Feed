<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>開源中國-最新資訊</title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://rsshub.app/oschina/news" rel="self" type="application/rss+xml"></atom:link>
        <description>開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)</description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>en</language>
        <lastBuildDate>Wed, 27 Mar 2024 18:20:52 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>Zino 0.20 發佈：基於 Rust 語言的新一代組裝式應用開發框架</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#191b1f&quot;&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fzino-rs%2Fzino&quot; target=&quot;_blank&quot;&gt;Zino 開發框架&lt;/a&gt;已發佈 0.18 版本！這兩個多月的改進，主要集中在以下方面：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;background-color:#ffffff; color:rgba(0, 0, 0, 0.9)&quot;&gt;添加了 Plugin 類型，可用於加載異步初始化的插件，支持運行環境選擇以及依賴檢測&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#191b1f&quot;&gt;；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#191b1f&quot;&gt;進一步改善 ORM，添加時區設置，優化數據庫連接時 create_table 的錯誤信息；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;background-color:#ffffff; color:#191b1f&quot;&gt;引入#[schema(fetch_as = &quot;...&quot;)]&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#191b1f&quot;&gt;和#[schema(composable)]屬性標記，可用於組合模型數據；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;background-color:#ffffff; color:#191b1f&quot;&gt;移除對 http-body 的直接依賴，減少不必要的版本衝突；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#191b1f&quot;&gt;添加了數十個 Dioxus 組件。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;Zino 致力於打造 Rust 語言中最好用的企業級應用開發框架。 我們奉行『約定優於配置』的原則，借鑑 Node 的 Egg.js、Go 的 GoFrame、 Java 的 Spring Boot 等框架，提供開箱即用的功能模塊，極大提升開發效率； 並通過應用接口抽象與 Rust 的 axum、actix-web 等框架集成，打通社區生態資源。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;功能特色：&lt;/p&gt; 
&lt;ul style=&quot;list-style-type:disc; margin-left:0; margin-right:0&quot;&gt; 
 &lt;li&gt;開箱即用，快速開發應用。&lt;/li&gt; 
 &lt;li&gt;極簡設計、模塊化架構、高層次抽象。&lt;/li&gt; 
 &lt;li&gt;採用開放標準，倡導 API 優先的開發理念。&lt;/li&gt; 
 &lt;li&gt;兼顧開發效率和性能的平衡。&lt;/li&gt; 
 &lt;li&gt;為 MySQL 和 PostgreSQL 提供高度優化的 ORM。&lt;/li&gt; 
 &lt;li&gt;輕量級定時任務。&lt;/li&gt; 
 &lt;li&gt;統一訪問存儲服務、數據源以及聊天機器人。&lt;/li&gt; 
 &lt;li&gt;支持追蹤、度量和日誌。&lt;/li&gt; 
&lt;/ul&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/285052/zino-0-20-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/285052/zino-0-20-released</guid>
            <pubDate>Wed, 27 Mar 2024 16:07:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>ProxyPin 1.0.9 已經發布，全平台 HTTP 抓包工具</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;ProxyPin 1.0.9 已經發布，這是一個全平台 HTTP 抓包工具。&lt;/p&gt; 
&lt;p&gt;此版本更新內容包括：&lt;/p&gt; 
&lt;p&gt;證書安裝流程介紹：&lt;a href=&quot;https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1Qm4y157Gk%2F&quot; target=&quot;_blank&quot;&gt;https://www.bilibili.com/video/BV1Qm4y157Gk/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;iOS TF 下載地址： &lt;a href=&quot;https://gitee.com/link?target=https%3A%2F%2Ftestflight.apple.com%2Fjoin%2FgURGH6B4&quot; target=&quot;_blank&quot;&gt;https://testflight.apple.com/join/gURGH6B4&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;V1.0.9&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;展示請求發起的應用圖標&lt;/li&gt; 
 &lt;li&gt;關鍵詞匹配高亮&lt;/li&gt; 
 &lt;li&gt;腳本批量操作和導入導出&lt;/li&gt; 
 &lt;li&gt;腳本支持日誌查看，通過 console.log() 輸出&lt;/li&gt; 
 &lt;li&gt;設置增加自動開啓抓包&lt;/li&gt; 
 &lt;li&gt;Android 證書下載優化&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;English:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Display the application icon initiated by the request&lt;/li&gt; 
 &lt;li&gt;Keyword matching highlights&lt;/li&gt; 
 &lt;li&gt;Script batch operations and import/export&lt;/li&gt; 
 &lt;li&gt;The script supports log viewing, output through console.log()&lt;/li&gt; 
 &lt;li&gt;Setting Auto Start Recording Traffic&lt;/li&gt; 
 &lt;li&gt;Android certificate download optimization&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;詳情查看：&lt;a href=&quot;https://gitee.com/wanghongenpin/network-proxy-flutter/releases/1.0.9&quot;&gt;https://gitee.com/wanghongenpin/network-proxy-flutter/releases/1.0.9&lt;/a&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/285038/proxypin-1-0-9-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/285038/proxypin-1-0-9-released</guid>
            <pubDate>Wed, 27 Mar 2024 13:59:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>知識管理系統 WCP 3.2.1 發佈，添加大模型接口，支持私有知識智能問答</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;WCP 是一套 BS 架構的開源知識管理系統、知識庫系統。它能提供團隊知識庫建設的一整套功能，從知識創建、知識更新、知識推送到知識評價、知識激勵、知識統計以及基於以上功能權限控制等功能。&lt;/p&gt; 
&lt;p&gt;WCP 開源版本採用 springMVC、spring、hibernate 框架實現主要架構功能，由 lucene 提供全文檢索功能，並使用了其他若干主流開源項目。數據庫管理系統默認使用 mysql。可以部署在 tomcat 等主流中間件服務器上。&lt;/p&gt; 
&lt;p&gt;WCP 可以通過對大語言模型接口的調用來為用戶提供智能問答服務，該服務可以依賴知識庫中的知識進行問題回答。&lt;/p&gt; 
&lt;p&gt;-----------------------------------v3.2.2 功能列表--------------------------------------------&lt;/p&gt; 
&lt;p&gt;1.優化首頁樣式&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;398&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-b06f605804514dd170498c02fe70610b94f.png&quot; width=&quot;800&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;2.添加 AI 大模型問答功能（可針對知識庫中的知識進行問答對話，默認使用全文檢索+智能篩選的方式匹配知識，如果使用 milvus 向量數據庫進行知識匹配效果更好）&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;387&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-c52f7856e2adef629db940141be60216229.png&quot; width=&quot;800&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;377&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-5d4b4186de55878fcf0297c965c003c1890.png&quot; width=&quot;800&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/285027/wcp-3-2-1-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/285027/wcp-3-2-1-released</guid>
            <pubDate>Wed, 27 Mar 2024 12:43:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>武漢大學開設「雷軍班」：計算機專業、今年招收 15 名本科生</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;3 月 25 日，武漢大學官網對校長張平文調研計算機學院進行了報道，文章提到：「就雷軍班和機器人系建設方面，張平文希望學院提高站位、佈局未來，發揮雷軍校友捐贈的重要作用，凝心聚力早日把計算機學院建成國內知名、世界一流的學術高地。」&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-10c5c2cfd163009c4db026c83070c834fad.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;不少網友好奇，雷軍班是個什麼情況，跟企業家雷軍有什麼關係？&lt;/p&gt; 
&lt;p&gt;3 月 27 日，武漢大學計算機學院辦公室工作人員迴應記者稱：「&lt;strong&gt;在今年高考後，雷軍班將向全國招 15 名本科生，屬於計算機專業，吸納最優秀的有志向的學生就讀，本博貫通培養。&lt;/strong&gt;」&lt;/p&gt; 
&lt;p&gt;工作人員強調：「與其他普通本科班相比，這個班肯定是不一樣的。整個培養方面的各個環節都是高配置。」&lt;/p&gt; 
&lt;p&gt;另據武漢大學計算機學院官網 1 月 8 日報道，計算機學院院長杜博曾表示，「雷軍校友捐贈除了助力基礎學科研究和支持大學生培養，主要資助計算機學科發展和計算機領域科技創新。學院將加強師資力量，傳承人才培養優良傳統，發揚雷軍的創新精神，設立雷軍班，把有計算機天賦和有創新、創意、創業的優秀人才招進來。」&lt;/p&gt; 
&lt;p&gt;武漢大學是小米創始人雷軍的母校，他在去年 11 月 29 日的武漢大學 130 週年校慶日上宣佈，&lt;strong&gt;個人向母校捐贈 13 億元人民幣，刷新武大建校以來單筆最大捐贈額。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ddcdda06e0737310208f9c2696171fdb78b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;當時雷軍表示，此次捐贈主要聚焦三個方向：支持數理化文史哲六大學科基礎研究、支持計算機領域科技創新、支持大學生培養。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284988</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284988</guid>
            <pubDate>Wed, 27 Mar 2024 08:35:37 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>微軟任命新的 Windows 和 Surface 負責人</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;微軟任命 Pavan Davuluri 為新任 Windows 和 Surface 主管。去年，在前負責人&amp;nbsp;Panos Panay 跳槽前往亞馬遜之後，微軟就將 Windows 和 Surface 部門拆分為兩個不同的領導團隊；由&amp;nbsp;Davuluri 接管了 Surface 相關工作，Windows 方面則由 Mikhail Parakhin 進行領導。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;時至今日，該公司又將 Windows 和 Surface 整合，統一交由都將由 Davuluri 負責。微軟體驗和設備執行副總裁 Rajesh Jha 在一份內部備忘錄中&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2024%2F3%2F25%2F24111931%2Fmicrosoft-windows-surface-pavan-davuluri&quot; target=&quot;_blank&quot;&gt;解釋稱&lt;/a&gt;，因為 Parakhin 現在正在&quot;探索新的角色&quot;，但他並沒有有明確指出是在微軟內部還是外部。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Jha 在備忘錄中概述了新的 Windows 組織架構。指出 Davuluri 將領導一個合併的 Windows 和設備團隊，作為 Experiences + Devices (E+D) 部門的&quot;核心部分&quot;。「這將使我們能夠採取整體方法來構建跨 Windows 客戶端和雲的芯片、系統、體驗和設備，以適應這個 AI 時代。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;333&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-90467fe07ce648d6b571892737ebc09c654.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;以下是 Rajesh Jha 的備忘錄全文：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;我想分享繼上週宣佈並創建 Microsoft AI 組織之後 Windows 和 Web Experiences (WWE) 團隊的最新動態。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Mikhail Parakhin 決定探索新角色。Satya 和我對 Mikhail 的貢獻和領導表示感謝，並感謝他為幫助微軟引領新人工智能浪潮所做的一切。他將向 Kevin Scott 彙報工作，同時支持 WWE 的過渡。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;作為此變更的一部分，我們將 Windows Experiences 和 Windows + Devices 團隊合併為 Experiences + Devices (E+D) 部門的核心部分。這將使我們能夠採取整體方法來構建這個人工智能時代跨越 Windows 客戶端和雲的芯片、系統、體驗和設備。 Pavan Davuluri 將領導這個團隊並繼續向我彙報。 Shilpa Ranganathan 和 Jeff Johnson 及其團隊將直接向 Pavan 彙報。 Windows 團隊將繼續與 Microsoft AI 團隊在 AI、芯片和體驗方面密切合作。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Web Experiences 團隊將向新的 Microsoft AI 組織中的 Mustafa 彙報工作。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Jordi Ribas 將領導搜索、地圖和平台業務，Andrey Proskurin、Fatima Kardar 和 Nick Lee 向他彙報。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Rukmini Iyer 將領導廣告部，Paul Viola 和 Weiqing Tu 向她彙報。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Mike Davidson 繼續領導設計部門，並將與 Pavan 和團隊合作研究如何重新調整 Windows 設計。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Ali Akgun、Kya Sainsbury-Carter、Zhang Qi 和 Rajesh Sundaram 的角色保持不變。他們將與 Jordi、Mike 和 Rukmini 一起加入 Microsoft AI 領導團隊，全部向 Mustafa 彙報。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;我們很高興這個團隊能夠幫助 Microsoft AI 實現其打造世界一流的消費者 AI 產品的大膽雄心。我非常期待與 Mustafa 及其團隊密切合作，將包括 Copilot 在內的 AI 產品廣泛應用於我們的 E+D 產品和服務中。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Thanks,&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Rajesh&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284970/microsoft-windows-surface-pavan-davuluri</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284970/microsoft-windows-surface-pavan-davuluri</guid>
            <pubDate>Wed, 27 Mar 2024 07:39:43 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Podman 5.0 正式發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Podman 5.0 已正式發佈。新版本針對&amp;nbsp;Windows 和 Mac 平台完全重寫了代碼，並對這兩個平台上的虛擬機管理程序支持進行了重大改進。&lt;/p&gt; 
&lt;p&gt;Podman 5.0 的一大亮點是對&lt;code&gt;podman machine&lt;/code&gt;命令的徹底重寫。該功能允許用戶在 Windows 和 Mac 系統上啓動 Linux 虛擬機，使他們能夠無縫運行 Linux 容器。&lt;/p&gt; 
&lt;p&gt;重寫不僅提高了性能和穩定性，還增強了跨不同 VM 提供商的代碼共享，簡化了未來的維護和升級。此外，引入了對 Mac 上 Apple 虛擬化程序的支持，顯著提升了穩定性、啓動時間和文件共享性能。&lt;/p&gt; 
&lt;p&gt;一個值得注意的方便功能是新的&lt;code&gt;podman machine reset&lt;/code&gt;命令，使刪除由 Podman 管理的虛擬機比以往更容易。此外，這個版本改進了對&lt;code&gt;containers.conf&lt;/code&gt;配置文件的處理，確保用戶的修改得到保留。&lt;/p&gt; 
&lt;p&gt;Podman 5.0 還帶來了顯著的變化和棄用，以提升用戶體驗。一個關鍵更新是將 Pasta 作為無根網絡的默認後端，這個決定是由於其出色的性能。&lt;/p&gt; 
&lt;p&gt;在 Podman 4.9 版本中，已經開始將 BoltDB 數據庫後端改為 SQLite，現在這個決定已經得到了鞏固，為新安裝提供了增強的穩定性。&lt;/p&gt; 
&lt;p&gt;Podman 5 的網絡變化也值得注意。大多數平台不再支持 CNI 網絡，而是使用 Netavark，Podman 自己的網絡堆棧，承諾滿足或超越 CNI 的能力。&lt;/p&gt; 
&lt;p&gt;另一個重要的改進領域是 Docker 兼容性。Podman 5.0 引入了幾項調整，以確保與 Docker 的互操作性更加順暢，例如修改 podman inspect 的輸出，使其與 Docker 的對應版本更加接近。&lt;/p&gt; 
&lt;p&gt;此外，Podman 5.0 不再支持 cgroups v1，為未來在沒有 cgroups v2 的系統上運行不再可能鋪平了道路，進一步與現代 Linux 發行版對安全性和資源管理的關注保持一致。&lt;/p&gt; 
&lt;p&gt;詳情查看 &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.podman.io%2F2024%2F03%2Fpodman-5-0-has-been-released%2F&quot; target=&quot;_blank&quot;&gt;發佈公告&lt;/a&gt;&lt;/u&gt;。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284955/podman-5-0-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284955/podman-5-0-released</guid>
            <pubDate>Wed, 27 Mar 2024 06:56:19 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>日本政府稱有朝鮮 IT 人員冒充日本人接外包賺外匯</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;日本政府 26 日發佈了一份提醒國內 IT 相關企業注意的文件，指出疑似有朝鮮 IT 技術人員冒充日本人，在網上承接 IT 相關業務訂單。聯合國等表示，為了賺取外匯用於核與導彈開發，朝鮮正在利用技術人員。據稱，若把業務發包給此類人員，可能違反《外匯法》等。&lt;/p&gt; 
&lt;p&gt;文件由警察廳、外務省、財務省、經濟產業省聯名發佈。美國和韓國去年 10 月發出了類似提醒，日本則是首次。警察廳幹部透露稱「在日本也發現了案例，威脅高漲」。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2023/1023/112217_pba9_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;該文件等顯示，朝鮮技術人員在為 IT 相關業務發包方和自由技術人員提供中介服務的網站上，或者偽造身份，或者通過住在日本的親戚等進行註冊。據稱，他們大多在中國和俄羅斯工作並賺取報酬。&lt;strong&gt;其特點包括不參加視頻會議、頻繁變更收款賬戶、使用的日語不地道等&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;在日本，神奈川縣警方等 6 日以涉嫌違規領取失業補貼為由，逮捕了廣島縣 IT 相關公司社長等人。警方認為其有可能把業務發包給了朝鮮技術人員，正在查明案情。神奈川縣警方的調查中還發現，2022 年，另外的朝鮮技術人員以熟人名義承接了兵庫縣防災 APP 修改業務等。&lt;/p&gt; 
&lt;p&gt;延伸閲讀：&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/news/262984/north-korea-it-workers-remote-work&quot; target=&quot;_blank&quot;&gt;朝鮮 IT 開發者為美國公司從事遠程外包工作&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284953</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284953</guid>
            <pubDate>Wed, 27 Mar 2024 06:44:13 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>Linux 6.9 棄用 ext2 文件系統驅動程序</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在即將發佈的 6.9 Linux 內核中，ext2 文件系統驅動程序將被標記為已&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Fcommit%2F%3Fid%3Db960e8093e7a57de98724931d17b2fa86ff1105f&quot; target=&quot;_blank&quot;&gt;棄用&lt;/a&gt;。EXT2 第二代擴展文件系統是 Linux 內核所用的文件系統，最開始由 Rémy Card 設計用以代替 ext，於 1993 年 1 月加入 Linux 核心支持之中，至今已有三十多年的歷史。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Linux 開發人員 Michael Opdenacker 解釋稱，ext2 被棄用的主要原因在於，即使文件系統是用 256 字節的 inodes（mkfs.ext2 -I 256）創建的，文件系統驅動程序也會堅持使用 32 位日期。因此，驅動程序不支持超過 2038 年 1 月 19 日 03:14:07 UTC 的 inode 時間戳。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;對於仍在使用 ext2 及其驅動程序，並且系統日期正確設置為截止日期之前最多 30 年的日期的用戶，將收到此警告：&lt;/span&gt;&lt;/p&gt; 
&lt;pre style=&quot;margin-left:0; margin-right:0; text-align:start&quot;&gt;# mount -t ext2 /dev/sda1 /mnt
[  441.680685] ext2 filesystem being mounted at /mnt supports timestamps until 2038-01-19 (ox7fffffff)&lt;/pre&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;由於無法正確支持 2038 年 1 月 19 日之後的時間戳。官方建議 ext2 用戶升級到使用 ext4 驅動程序來訪問其文件系統，ext4 文件系統驅動程序與 ext2 完全兼容。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;416&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-9b1cc7bffe503a4e97379da4df9747b64d9.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;更多詳情可查看此&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbootlin.com%2Fblog%2Fext2-filesystem-driver-now-marked-as-deprecated%2F&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284942/ext2-deprecat-linux-6-9</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284942/ext2-deprecat-linux-6-9</guid>
            <pubDate>Wed, 27 Mar 2024 05:50:46 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>開源日報 | AI PC 的價值到底在哪？Windows 格式化對話框的 UI 用了 30 年；醜頭像生成器；獨立的 Redis Copyleft 分支</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;歡迎閲讀 OSCHINA 編輯部出品的開源日報，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#e67e22&quot;&gt;&lt;strong&gt;# 2024.3.26&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日要點&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;OpenSource Daily&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284729/inkscape-switches-to-gtk4&quot; target=&quot;_blank&quot;&gt;開源圖形編輯器 Inkscape 底層 UI 框架改用 GTK4&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;矢量圖形編輯器 Inkscape 開發分支的最新上游代碼已遷移至使用 GTK4，這是一次重大升級，同時也改進了架構，併為將來實現 GPU 加速做好了準備。&lt;/p&gt; 
&lt;p&gt;Inkscape 通過其 Mastodon 賬戶宣佈了向 GTK4 過渡的消息。由於各種問題，尤其是在 macOS 和 Windows 上的問題，下一個穩定版本（v1.4）仍將使用 GTK3。&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284749/redict-independent-fork-redis&quot; target=&quot;_blank&quot;&gt;Redict：一個獨立的 Redis Copyleft 分支&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;Redict 是由開發者 Drew DeVault 推出的一個 Redis OSS 7.2.4.2 的獨立、非商業性的分叉。基於 Redis OSS 的 BSD 3-Clause 源代碼，自此之後的所有更改均採用 Lesser GNU General Public license（LGPL-3.0-only）。&lt;/p&gt; 
&lt;p&gt;Redict 旨在作為 Redis OSS 7.2.4 的直接替代品。接下來，Redict 的目的是繼續開發 Redis OSS 兼容軟件的自由軟件發行版，暫時只進行最小程度的破壞性更改。&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日觀察&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img height=&quot;1142&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-720920b89166e12e4474df21d15cdb13e1d.png&quot; width=&quot;3290&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- &lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sohu.com%2Fa%2F766955186_166680&quot; target=&quot;_blank&quot;&gt;集微網&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-df160bed3a4a1edeecfaf0ea94367e6ffce.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微博&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1834645454%2FO6OaUrIXM&quot; target=&quot;_blank&quot;&gt;dingtingli&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;今日推薦&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-3dd733b17408eabbeef0376a1b161484ca2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ftxstc55%2Fugly-avatar&quot; target=&quot;_blank&quot;&gt;https://github.com/txstc55/ugly-avatar&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;事件點評&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-bce40dbed054e00f3808407c9d3f805a8b7.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;每日項目榜&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;每日 GitHub 精選&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-4f54b79a6c20ed322ca67c7d78f425b439b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;在線閲讀完整日報內容，訪問：&lt;/span&gt;&lt;/strong&gt;&lt;br&gt; &lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://report.oschina.net/api/files/jhim80u9qm1ofsw/sq4hlnesqz46pu8/37_ai_pc_windows_ui_30_redis_copyleft_jwb07bWFPR.pdf&quot; target=&quot;_blank&quot;&gt;開源日報第 037 期：AI PC 的價值到底在哪？Windows 格式化對話框的 UI 用了 30 年；醜頭像生成器；獨立的 Redis Copyleft 分支&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/h4&gt; 
&lt;/blockquote&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;歡迎掃碼下載「開源中國 APP」&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;隨時在線閲讀完整日報內容 ↓&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7871d27245192b8ecfcd21043d309382749.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;889&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-842e51ced6d226559af1af95c8041338cb2.gif&quot; width=&quot;400&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284926</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284926</guid>
            <pubDate>Wed, 27 Mar 2024 03:28:20 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>羅永浩本週日晚將首度直播賣「雲」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;阿里雲官微宣佈，羅永浩將於 3 月 31 日晚首次淘寶直播賣雲，選品涵蓋雲服務器、雲存儲及企業網盤等熱門阿里雲產品，重點面向創業者及中小企業羣體。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;475&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d2c9f7747404286dff54e6e9df56b4abb39.webp&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此前的 2 月 29 日，阿里雲宣佈全線降價 20%。根據阿里雲官網報價數據顯示，降價清單中的雲服務器 ECS 最高降 36%、對象存儲 OSS 最高降 55%、雲數據庫 RDS 最高降 40%，都是雲上用戶使用頻率最高的核心產品。此次史上最大規模降價引發了一波中小企業上雲熱潮。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;最近披露的財報顯示，阿里雲正通過減少利潤率較低的項目制合約類收入，持續提高收入質量。阿里雲智能集團資深副總裁、公共雲事業部總裁劉偉光此前表示，阿里雲期待與行業共同鑄造中國雲計算產業的規模效應。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284923</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284923</guid>
            <pubDate>Wed, 27 Mar 2024 03:10:20 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>egui 0.27 發佈，面向 Web 和原生應用的 Rust GUI 庫</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;egui 是易於使用、可移植的即時模式 (immediate mode) GUI 庫，採用 Rust 編寫，提供了一種簡單而直觀的方式來創建圖形用戶界面，並且可運行在 Web 和原生應用中。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-051b7caef2c757433d4cec01c2d77678d2d.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在線體驗：&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.egui.rs%2F&quot;&gt;https://www.egui.rs/&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;最新發布的&amp;nbsp;egui 0.27 主要變化：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;重寫點擊測試邏輯 (hit test logic)&lt;/li&gt; 
 &lt;li&gt;改進菜單&lt;/li&gt; 
 &lt;li&gt;優化陰影效果&lt;br&gt; &lt;br&gt; &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-5a9a8b855f8845b5649f1fa05ed61e55018.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;br&gt; &amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;支持與 UI 在後台進行交互&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Femilk%2Fegui%2Freleases%2Ftag%2F0.27.0&quot; style=&quot;font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Apple Color Emoji&amp;quot;, &amp;quot;Segoe UI Emoji&amp;quot;, &amp;quot;Segoe UI Symbol&amp;quot;, &amp;quot;Segoe UI&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif;&quot; target=&quot;_blank&quot;&gt;詳情查看 Release Notes&lt;/a&gt;&lt;span style=&quot;font-family:-apple-system,BlinkMacSystemFont,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;,&amp;quot;Segoe UI&amp;quot;,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;Helvetica Neue&amp;quot;,Helvetica,Arial,sans-serif&quot;&gt;。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284915/egui-0-27-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284915/egui-0-27-released</guid>
            <pubDate>Wed, 27 Mar 2024 02:33:31 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Zstd 1.5.6 發佈，Chrome 已支持 Zstandard 編碼</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Zstd 1.5.6 已發佈。此次發佈的部分原因是 Chrome 123 添加了對 Web 流量的 Zstd 編碼支持。Chrome 現在支持使用 Zstandard (zstd) 作為內容編碼，以加快頁面加載速度並節省帶寬。&lt;/p&gt; 
&lt;p&gt;雖然 Chrome 支持 Zstd 編碼是件好事，但目前 Web 服務器對 Zstd 編碼的支持還很有限。Zstd 團隊希望 1.5.6 發佈後，新版本能得到更多 Web 瀏覽器的採用，並繼續得到其他軟件的支持。&lt;/p&gt; 
&lt;p&gt;Zstd 1.5.6 還添加了一個新的穩定參數&quot;ZSTD_c_targetCBlockSize&quot;，以更好地處理 Web 瀏覽器中的增量更新、細粒度二進制大小選擇以及其他各種增強功能。&lt;/p&gt; 
&lt;p&gt;Zstd 1.5.6 現在還能更好地支持 SPARC64、ARM64EC 和 RISC-V 架構，以及 QNX、AIX、Solaris 和 HP-UX 操作系統。&lt;/p&gt; 
&lt;p&gt;詳情查看&amp;nbsp;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffacebook%2Fzstd%2Freleases%2Ftag%2Fv1.5.6&quot; target=&quot;_blank&quot;&gt;Release Notes&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284909/zstd-1-5-6-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284909/zstd-1-5-6-released</guid>
            <pubDate>Wed, 27 Mar 2024 02:16:31 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>適用於原生 Arm64 設備的 Chrome 即將發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;谷歌與高通公司（Qualcomm）共同&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2024%2F3%2F26%2F24112273%2Fchrome-native-windows-on-arm-qualcomm-snapdragon&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;，將於本週發佈針對 Windows on Arm 的 Chrome 瀏覽器優化版。事實上早在兩個月前，就曾有用戶在 Chrome 瀏覽器的 Canary 頻道發現過該瀏覽器的早期版本，現如今谷歌終於正式將其正式推出。高通公司表示，該版本&quot;將從今天開始推出&quot;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;292&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-6bba083617132dcd93860160703973230b4.webp&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;對於使用基於 Arm 處理器的 Windows 機器的 Chrome 瀏覽器用戶來説，該版本的發佈將是一件大事，因為他們現在可以使用速度更快的原生瀏覽器了。相比之下，他們以前只能在模擬狀態下運行性能緩慢的 x64 版 Chrome 瀏覽器。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;高通最新推出的基於 Arm 的 Windows 處理器被稱為驍龍 X Elite（Snapdragon X Elite），預計將於今年夏天上市，據稱將帶來不俗的性能表現。谷歌經過 Arm 優化的 Chrome 瀏覽器在技術上可以在任何基於 Arm 的 Windows PC 上運行，與處理器製造商無關，但高通公司是目前唯一一家為 Windows 生產基於 Arm 處理器的公司。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;谷歌公司的 Hiroshi Lockheimer 表示：「我們設計的 Chrome 瀏覽器快速、安全且易於在台式機和移動終端上使用。我們與高通公司的密切合作將有助於確保 Chrome 瀏覽器用戶在當前 Arm 兼容 PC 上瀏覽網頁時獲得最佳體驗。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;這並不是谷歌第一次發佈經過 Arm 優化的 Chrome 瀏覽器版本，早在 2020 年，谷歌就為蘋果基於 Arm 的 Mac 發佈了原生版本的瀏覽器。長期以來，這家搜索巨頭還在 ChromeOS 中為 Chromebook 提供基於 Arm 處理器的支持。但是，在以消費者為中心的 Surface 設備有望全面轉向 Arm 的這一年，為 Windows 發佈基於 Arm 的世界上最流行的 Windows 瀏覽器原生版本，將極大地推動 Windows on Arm 的發展。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284903/chrome-native-arm-based-windows-pc</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284903/chrome-native-arm-based-windows-pc</guid>
            <pubDate>Wed, 27 Mar 2024 02:03:39 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>Java 8 內存管理原理解析及內存故障排查實踐</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                    &lt;div class=&quot;rich_media_content js_underline_content
                       autoTypeSetting24psection
            &quot; id=&quot;js_content&quot;&gt; 
 &lt;section style=&quot;font-size: 15px;line-height: 1.6;&quot;&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;作者：vivo 互聯網服務器團隊-&amp;nbsp; Zeng Zhibin&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;&quot;&gt; 
    &lt;section style=&quot;text-align: left;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);&quot;&gt; 
      &lt;p style=&quot;text-wrap: wrap;&quot;&gt;介紹 Java8 虛擬機的內存區域劃分、內存垃圾回收工作原理解析、虛擬機內存分配配置，介紹各垃圾收集器優缺點及場景應用、實踐內存故障場景排查診斷，方便讀者面臨內存故障時有一個明確的思路和方向。&lt;/p&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
    &lt;section style=&quot;margin-right: 0%;margin-bottom: -5px;margin-left: 0%;text-align: right;line-height: 1;font-size: 5px;transform: translate3d(5px, 0px, 0px);&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;width: 0px;display: inline-block;vertical-align: top;border-bottom: 0.6em solid rgb(160, 160, 160);border-right: 0.6em solid rgb(160, 160, 160);border-top: 0.6em solid transparent !important;border-left: 0.6em solid transparent !important;&quot;&gt; 
      &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;一、背景&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 是一種流行的編程語言，可以在不同的操作系統上運行。它具有跨平台、面向對象、自動內存管理等特點，Java 程序在運行時需要使用內存來存儲數據和程序狀態。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 的自動內存管理機制是由 JVM 中的垃圾收集器來實現的，垃圾收集器會定期掃描堆內存中的對象，檢測並清除不再使用的對象，以釋放內存資源。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 的自動內存管理機制帶來了許多好處，首先，它可以避免程序員手動管理內存時的錯誤，例如內存泄漏和懸空指針等問題。其次，它可以提高程序的運行效率，因為程序員不需要頻繁地手動分配和釋放內存，而是可以將更多時間和精力專注於程序的業務邏輯，最後，它可以提高程序的可靠性和穩定性，因為垃圾收集器可以自動檢測和清除不再使用的內存資源，避免內存溢出等問題。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;瞭解和掌握垃圾收集器原理可以幫助提高程序的性能、穩定性和可維護性。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;font-size: 14px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;名詞解釋：&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;響應速度&lt;/strong&gt;：響應速度指程序或系統對一個請求的響應有多迅速。比如，用戶查詢數據響應時間，對響應速度要求很高的系統，較大的停頓時間是不可接受的。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;：吞吐量關注在一個特定時間段內應用系統的最大工作量，例如每小時批處理系統能完成的任務數量，在吞吐量方面優化的系統，較長的 GC 停頓時間也是可以接受的，因為高吞吐量應用更關心的是如何儘可能快地完成整個任務，不考慮快速響應用戶請求。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;GC 導致的應用暫停時間影響系統響應速度，GC 處理線程的 CPU 使用率影響系統吞吐量。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;二、Java&amp;nbsp;8&amp;nbsp;的內存管理&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;2.1 JVM（Java 虛擬機）內存劃分&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 運行時數據區域劃分，Java 虛擬機在執行 Java 程序時，將其所管理的內存劃分為不同的數據區域，每個區域都有特定的用途和創建銷燬的時間。其中，有些區域在虛擬機進程啓動時就存在，而有些區域則是隨着用戶線程的啓動和結束而建立和銷燬。這些數據區域包括程序計數器、虛擬機棧、本地方法棧、堆、方法區等，每個區域都有其自身的特點和作用。瞭解這些數據區域的使用方式和特點，可以更好地理解 Java 虛擬機的內存管理機制和運行原理。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;JVM 的內存區域劃分可分為：1.堆內存空間、2.Java 虛擬機棧區域、3.程序計數器、4.本地方法棧、5.元空間區域、6.直接內存。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014615&quot; data-ratio=&quot;0.774074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/1e56b454-4e41-465a-8ba6-8c53e10fc02c.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014616&quot; data-ratio=&quot;0.9365079365079365&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/ec4c9ff4-4b80-46ad-aff9-ce2ce396b38b.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1008&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;堆內存空間&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;：JVM 中佔用內存空間最大的是堆，平常對象的創建大部分都是在堆上分配內存的，是垃圾回收的主要目標和方向。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;本地方法棧區域&lt;/strong&gt;：Native Mehod Stack 與 Java 虛擬機棧的作用非常相似，區別是 Java 虛擬機棧為虛擬機執行 Java 方法或者為字節碼而服務，本地方法棧是為了 Java 虛擬機棧得到 Native 方法。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;Java 虛擬機棧區域&lt;/strong&gt;：負責 Java 的解釋過程、程序的執行過程、入棧和出棧，它是與線程相關的，當啓動一個新的線程時，Java 程序就會分配一個 Java 虛擬機棧提供運行；Java 虛擬機棧從方法入棧到具體字節碼執行是一個雙層棧結構，可以棧裏包含棧。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;程序計數器&lt;/strong&gt;：記錄線程執行位置，線程私有，因為操作系統不停的調度，無法獲取到線程被調度之前的位置，程序計數器提供了這樣一個線程執行位置。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;元空間區域&lt;/strong&gt;：在原來的老的 Java 7 之前劃分中，永久代用來存放類的元數據信息、靜態變量以及常量池等。在現在 Java8 後類的元信息存儲在元空間中，靜態變量和常量池等併入堆中，相當於原來的永久代中的數據，被元空間和堆內存給瓜分了。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;直接內存&lt;/strong&gt;：使用了 Java 的直接內存的 API 的內存，例如緩衝 ByteBuffer，可以控制虛擬機參數調整大小，而本地內存是使用了 native 函數操作的內存，是不受 JVM 管理控制。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;堆內存空間&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;JVM 回收的主要目標是堆內存，對象主要的創建分配內存在堆上進行，堆可以想象成一個對象池子，對象不停創建放入池子中，而 JVM 垃圾回收是不停的回收池子中一些被標記為可回收對象的對象，啓動回收線程進行打掃戰場，當回收對象的速度趕不上程序的創建時，池子就會立馬滿，當滿了之後從而發生溢出，就是常見的 OOM。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;GC 的速度和堆的內存中存活對象的數量有關，與堆內存所有的對象無關，GC 的速度和堆內存的大小無關，如一個 4GB 大小的堆內存和一個 16GB 的堆內存，只要 2 個堆內存存活對象都是一樣多的時候，GC 速度都是基本差不多。每次垃圾回收也不是必須要把垃圾清理乾淨，重要的是保證不把正在使用的對象給標記清除掉。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;2.2 堆內存管理&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;JVM 中佔用內存空間最大的是堆內存，平常對象的創建大部分都是在堆上分配內存的，是 Java 垃圾回收的主要目標和方向、是 Java 內存管理機制的核心組成部分，它可以自動管理 Java 程序的內存分配和釋放，Java 垃圾收集器可以自動檢測和回收不再使用的內存，以便重新分配給其他需要內存的程序。這種自動內存管理的機制可以提高程序的運行效率和可靠性，防止因內存泄漏等問題導致程序崩潰或性能下降，Java 垃圾收集器使用了不同的垃圾回收算法和垃圾收集器實現，以適應不同的應用場景和需求。Java 垃圾收集器的性能特徵和優化技術也是 Java 程序員需要了解和掌握的重要知識。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;因此，瞭解 Java 垃圾回收的背景、原理和實踐經驗對於編寫高效、可靠的 Java 程序非常重要。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.1 對象如何被判斷為可回收&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;JVM 怎麼判斷堆內存裏面的對象是否可回收的，就是當一個對象沒有任何引用指向它了，它就是可回收對象，判斷的方式有兩種算法，一個是引用計數法，一個是可達性分析法。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;可回收對象：&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;424&quot; data-imgfileid=&quot;100014617&quot; data-ratio=&quot;0.7333333333333333&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/891ef4a1-7e31-4cc2-81d3-8e27a1779354.jpg&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;width: 578px;height: 424px;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（1）引用計數法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;給對象中添加一個引用計數器，每當有一個地方引用它時，這個計數器值加一，當引用失效斷開時，計數器值就減一，在任何時刻時計數器為 0 的時候，代表這個對象是可以被回收的，沒有任何引用使用它了。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014618&quot; data-ratio=&quot;0.6796296296296296&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/bce27aab-824a-4e0d-ab6b-789c5e0799ba.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;引用計數法是有缺點，當對象直接互相依賴引用時，這些對象的計數器都不能為 0，都不能被回收。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（2）可達性分析法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;它使用 tracing（鏈路追蹤）方式尋找存活對象的方法，通過一些列稱為「GC Roots」的對象作為初始點，從這些初始點開始向下查找，直到向下查找沒有任何鏈路時，代表這個對象可以被回收，這種算法是目前 Java 唯一且默認使用來判定可回收的算法。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014620&quot; data-ratio=&quot;0.6796296296296296&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/0f23e95f-e8c9-4525-8d62-34b5ac4636b4.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.2 GC Roots 的概念和對象類型&lt;/strong&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ol class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: decimal;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;Java 虛擬機棧中引用的對象，例如各個線程被調用的方法棧用到的參數、局部變量或者臨時變量等。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;方法區的靜態類屬性引用對象或者説 Java 類中的引用類型的靜態變量。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;方法區中的常量引用或者運行時常量池中的引用類型變量。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;JVM 內部的內存數據結構的一些引用、同步的監控對象（被修飾同步鎖）。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;JNI 中的引用對象。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ol&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;當然，被 GC Roots 追溯到的對象不是一定不會被垃圾回收，具體需要看情況，Java 對象與對象引用存在四種引用級別：分別是強引用、軟引用、弱引用、虛引用，默認的對象關係是強引用，只有在和 GCRoots 沒有關係時才會被回收；軟引用用於維護一些可有可無的對象，當內存足夠時不會被回收；弱引用只要發生了垃圾回收就會被清理；虛引用人如其名形同虛設，任何對象都與它無關。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.3 垃圾對象回收算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;當 JVM 定位到了那些對象可回收時，這個時候是通過三個算法標記清除，分別是標記清除算法、複製算法、標記壓縮算法。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（1）標記清除算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;首先標記出所有需要回，收的對象，在標記完成後，統一回收掉所有被標記的對象，但是該算法缺點是執行效率低，當大量對象時需要大量標記和清理動作，而且容易產生內存碎片化，當需要一塊連續內存時，會因為碎片化無法分配。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014621&quot; data-ratio=&quot;0.2324074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/d964fb76-5184-4844-a6a8-c1e2e8c0d9a0.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（2）標記壓縮算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;標記壓縮算法跟清除算法很像，只不過它對內存進行了整理， 讓存活對象都向內存空間的一端移動，然後將邊界的其它對象全部清理，這樣能達到內存碎片化問題，不過它比清除算法多了移步動作。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014622&quot; data-ratio=&quot;0.1527777777777778&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/eb4ba1e3-b7b5-42f5-9087-2567b4355f6d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（3）複製算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;為瞭解決標記-清除算法面對大量可回收對象時執行效率低的問題，將存活對象複製到一塊空置的空間裏，然後將原來的區域全部清理，缺點是需要額外空間存放存活對象。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014623&quot; data-ratio=&quot;0.3425925925925926&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/a0b97901-6eeb-445a-8dd8-46b6bc0481ce.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.4 分代垃圾回收模型概念和原理&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;堆內存分代模型圖&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014624&quot; data-ratio=&quot;0.25277777777777777&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/5f8f3b05-14d8-4730-9825-0dbb1e914d4f.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;當 JVM 進行 GC（垃圾回收）時，JVM 會發起「Stop the world」，所有的業務線程都進行停止，進入 SafePoint 狀態，JVM 回收垃圾線程開始進行標記和追溯，如何解決這種停止和如何減少 STW 的時間呢？&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;目前主流垃圾收集器採用分代垃圾回收方式，大部分對象的聲明週期都比較短，只有少部分的對象才存活的比較長，分代垃圾回收會在邏輯上把堆內存空間分為兩部分，一部分為年輕代，一部分為老年代。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;（1）年輕代空間&lt;/strong&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;年輕代主要是存放新生成的對象，一般佔用堆空間的三分之一空間，因為會頻繁創建對象，所以年輕代 GC 頻率是最高的。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;分為 Eden 空間、Survivor1（from）區、Survivor2（to）區，S1 和 S2 總要有一塊空間是空的，為了方便年輕代存活對象來回存放，晉升存活對象年齡。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;三個區的默認比例是 8:1:1，可以通過配置參數調整比例。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;年輕代回收發起 Minor GC（YongGC），當 Eden 內存區域被佔滿之後就發起 GC，短暫的 STW，基於垃圾收集器。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;（2）老年代空間&lt;/strong&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;是堆內存中最大的空間， ，裏面的對象都是比較穩定或者老頑固，GC 頻率不會頻繁執行。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014625&quot; data-ratio=&quot;0.4685185185185185&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/b655ab3a-9352-4372-b97a-570be86cd06d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;老年代對象：&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ol class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: decimal;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;正常提升&lt;/strong&gt;：由年輕代存活對象年齡到達閾值時，這個對象則會被移動到老年代中。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;分配擔保&lt;/strong&gt;：如果年輕代中的空間不足時，此時有新的對象需要分配對象空間，需要依賴其它內存進行分配擔保，老年代擔保直接創建。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;大對象&lt;/strong&gt;：當創建需要大量連續內存空間的對象時，如長字符串或者數組等，大小超過了閾值時，直接在老年代分配。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;動態年齡對象&lt;/strong&gt;：有的垃圾收集器不需要到達指定年齡大小直接晉升老年代，比如相同年齡的對象的大小總和 &amp;gt; Survivor 空間的 50%， 年齡大於等於該年齡對象直接移動老年代，無需等待正常提升。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ol&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;老年代回收發起 Major GC / FULL GC，當老年代滿時會觸發 MajorGC，通常至少經歷過一次 Minor GC，再緊接着進行 Major GC， Major GC 清理 Tenured 區，用於回收老年代（CMS 才能單獨清理）。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;FUll GC：清除整個堆空間，一般來説是針對整個新生代、老生代、元空間的全局範圍的清理。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;不管是 Major GC 還是 Full GC， STW 的耗時都是 Ygc 的十倍以上，所以説對象能在年輕代被回收是最優的。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;Full GC 觸發條件：&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;老年代空間不足。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;元空間不足擴容導致。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;程序代碼執行 System.gc 時可能會執行。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;當程序創建一個大對象時，Eden 區域放不下大對象，老年代內存擔保分配，老年代也不足空間時。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;年輕代存留對象晉升老年代時，老年代空間不足時。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.5 Java 對象內存分配過程&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014626&quot; data-ratio=&quot;0.6027777777777777&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/d2937f98-1501-4a47-ab87-fd64453954f6.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&amp;nbsp;對象的分配過程&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ol class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: decimal;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;編譯器通過逃逸分析優化手段，確定對象是否在棧上分配還是堆上分配。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;如果在堆上分配，則確定是否大對象，如果是則直接進入老年代空間分配， 不然則走 3。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;對比 tlab， 如果 tlab_top + size &amp;lt;= tlab_end， 則在 tlab 上直接分配，並且增加 tlab_top 值，如果 tlab 不足以空間放當前對象，則重新申請一個 tlab 嘗試放入當前對象，如果還是不行則往下走 4。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;分配在 Eden 空間，當 eden 空間不足時發生 YGC， 倖存者區是否年齡晉升、動態年齡、老年代剩餘空間不足發生 Full GC 。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;當 YGC 之後仍然不足當前對象放入，則直接分配老年代。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ol&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;TLAB&lt;strong&gt;作用原理&lt;/strong&gt;：Java 在內存新生代 Eden 區域開闢了一小塊線程私有區域，這塊區域為 TLAB，默認佔 Eden 區域大小的 1%， 作用於小對象，因為小對象用完即丟，不存在線程共享，快速消亡 GC，JVM 優先將小對象分配在 TLAB 是線程私有的，所以沒有鎖的開銷，效率高，每次只需要線程在自己的緩衝區分配即可，不需要進行鎖同步堆 。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;對象除了基本類型的不一定是在堆內存分配，在 JVM 擁有逃逸分析，能夠分析出一個新的對象所擁有的範圍，從而決定是否要將這個對象分配到堆上，是 JVM 的默認行為；Java 逃逸分析是一種優化技術，可以通過分析 Java 對象的作用域和生命週期，確定對象的內存分配位置和生命週期，從而減少不必要的內存分配和垃圾回收。可以在棧上分配，可以在棧幀上創建和銷燬，分離對象或標量替換，同步消除。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 2px;border-color: transparent;background-color: rgb(255, 255, 255);padding: 1px;&quot;&gt; 
    &lt;section style=&quot;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;display: inline-block;width: 100%;height: 200px;vertical-align: top;overflow-y: auto;&quot;&gt; 
      &lt;section style=&quot;overflow: hidden;&quot;&gt; 
       &lt;section style=&quot;margin-bottom: 120px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
        &lt;section style=&quot;text-align: justify;&quot;&gt; 
         &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
          &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; TaoYiFenxi {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; obj;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; setObj() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        obj = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; getObject() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; obj1 = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; obj1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; test1() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        synchronized (&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
         &lt;/section&gt; 
        &lt;/section&gt; 
       &lt;/section&gt; 
      &lt;/section&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.6 JVM 垃圾收集器特點與原理&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（1）Serial 垃圾收集器、Serial Old 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014627&quot; data-ratio=&quot;0.5712962962962963&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/04a94627-31bb-4e85-a8a8-5ae052deed2b.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Serial 收集器採用複製算法， 作用在年輕代的一款垃圾收集器，串行運行，執行過程中會 STW，是使用單個線程進行垃圾回收，響應速度優先。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Serial Old 收集器採用標記整理算法，作用在老年代的一款收集器，串行運行，執行過程中會暫停所有用戶線程，會 STW，使用單個線程進行垃圾回收，響應速度優先。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用場景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;適合內存小几十兆以內，比較適合簡單的服務或者單 CPU 服務，避免了線程交互的開銷。&lt;br&gt;&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;優點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;小堆內存且單核 CPU 執行效率高。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;堆內存大，多核 CPU 不適合，回收時長非常長。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（2）Parallel Scavenge 垃圾收集器、Parallel Old 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014628&quot; data-ratio=&quot;0.5722222222222222&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/8cf072c7-a51e-4f76-b268-577b9c499ab2.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Parallel Scavenge 垃圾收集器採用了複製算法，作用在年輕代的一款垃圾收集器，是並行的多線程運行，執行過程中會發生 STW，關注與程序吞吐量。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Parallel Old 垃圾收集器採用標記整理算法，作用，作用在老年代的一款垃圾收集器， 是並行的多線程運行，執行過程中會發生 STW，關注與程序吞吐量。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Parallel Scavenge + Parallel Old 組合是 Java8 當中默認使用的一個組合垃圾回收。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;所謂的吞吐量是 CPU 用於運行用戶代碼時間與 CPU 總消耗時間的比值，也就是説吞吐量 = 運行用戶代碼時間 / (運行用戶代碼時間 + 垃圾收集器時間)， 錄入程序運行了 100 分鐘，垃圾收集器花費時間 1 分鐘&lt;span style=&quot;letter-spacing: 0.034em;&quot;&gt;，則吞吐量達到了 99%。&lt;/span&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用場景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;適用於內存在幾個 G 之間，適用於後台計算服務或者不需要太多交互的服務，保證吞吐量的服務。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;優點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;可控吞吐量、保證吞吐量，並行收集。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;回收期間 STW，隨着堆內存增大，回收暫停時間增大。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（3）Par New 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Par New 垃圾收集器採用了複製算法，作用在年輕代的一款垃圾收集器， 也是並行多線程運行，跟 Parallel 非常相似，是它的增強版本，或者説是 Serial 收集器的多線程版本，是搭配 CMS 垃圾收集器特製的一個收集器。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;使用場景：&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;搭配 CMS 使用&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（4）CMS 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;CMS 是一款多線程+分段操作的一款垃圾收集器。其最大的優點就是將一次完整的回收過程拆分成多個步驟，並且在執行的某些過程中可以使用戶線程可以繼續運行，分別有初始標記，併發標記，重新標記，併發清理和併發重置。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014629&quot; data-ratio=&quot;0.5064814814814815&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/fa0a6a57-a712-446f-b037-0153ff732161.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;CMS 是一款多線程+分段操作的一款垃圾收集器。其最大的優點就是將一次完整的回收過程拆分成多個步驟，並且在執行的某些過程中可以使用戶線程可以繼續運行，分別有初始標記，併發標記，重新標記，併發清理和併發重置。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;CMS 分段&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;初始標記階段&lt;/strong&gt;， 這個階段會暫停用戶線程， 掃描所有的根對象，因為根對象比較少，所以一般 stw 時間都非常短。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;併發標記階段&lt;/strong&gt;，這個階段與用戶線程一起執行，會一直沿着根往下掃描，不停的識別對象是否為垃圾，標記，採用了三色算法， 在對象頭 (Mark World) 標識了一個顏色屬性，不同的顏色代表不同階段，掃描過程中給與對象一個顏色，記錄掃描位置，防止 cpu 時間片切換不需要重新掃描。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;重新標記階段&lt;/strong&gt;， 這個階段暫停用戶線程， 修正一些漏標對象，回掃發生引用變化的對象。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;併發清理階段&lt;/strong&gt;， 這個階段與用戶線程一起執行，標記清除已經成為垃圾的對象。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;三色標記&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;黑色&lt;/strong&gt;：代表了自己已經被掃描完畢，並且自己的引用對象也已經確定完畢。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;灰色&lt;/strong&gt;：代表自己已經被掃描完畢了， 但是自己的引用還沒標記完。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;白色：則代表還沒有被掃描過。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;標記過程結束後，所有未被標記的對象都是不可達的，可以被回收。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014630&quot; data-ratio=&quot;0.725925925925926&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/c4354e81-0441-4f2c-839a-825920ac5e2d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;三色標記算法的&lt;strong&gt;問題場景&lt;/strong&gt;：當業務線程做了對象引用變更，會發生 B 對象不會被掃描，當成垃圾回收。&lt;/p&gt; 
  &lt;section style=&quot;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 2px;border-color: transparent;background-color: rgb(255, 255, 255);padding: 1px;&quot;&gt; 
    &lt;section style=&quot;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;display: inline-block;width: 100%;height: 200px;vertical-align: top;overflow-y: auto;&quot;&gt; 
      &lt;section style=&quot;overflow: hidden;&quot;&gt; 
       &lt;section style=&quot;margin-bottom: 120px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
        &lt;section style=&quot;text-align: justify;&quot;&gt; 
         &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
          &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Demo3&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        R r = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; R();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        B b = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; B();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GCroot 遍歷 R， R 為黑色， R 下面的 a 引用鏈還未掃完置灰灰色，R.b 無引用， 切換時間分片&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a.b = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 業務線程發生了引用改變， 原本 r.a.b 的引用置為 null&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a.b = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 線程回來繼續上次掃描，發現 r.a.b 無引用，則認為 b 對象無任何引用清除&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.b = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 回收了 b， 業務線程無法使用 b&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;R&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    B b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    B b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;B&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
         &lt;/section&gt; 
        &lt;/section&gt; 
       &lt;/section&gt; 
      &lt;/section&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014631&quot; data-ratio=&quot;0.45185185185185184&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/c965a3e4-1d3c-41bd-8a87-f1e559362200.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;當 GC 線程標記 A 時，CPU 時間片切換，業務線程進行了對象引用改變，這時候時間片回到了 GC 線程，繼續掃描對象 A， 發現 A 沒有任何引用，則會將 A 賦值黑色掃描完畢，這樣 B 則不會被掃描，會標記 B 是垃圾， 在清理階段將 B 回收掉，錯誤的回收正常的對象，發生業務異常。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;CMS 基於這種錯誤標記的解決方案是採取寫屏障 + 增量更新 Incremental Update ， 在業務線程發生對象變化時，重新將 R 標識為灰色，重新掃描一遍，Incremental Update 在特殊場景下還是會產生漏標。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014632&quot; data-ratio=&quot;0.8445378151260504&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/4dce9b78-c6ab-4129-b955-11ce7716fe3d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;952&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 2px;border-color: transparent;background-color: rgb(255, 255, 255);padding: 1px;&quot;&gt; 
    &lt;section style=&quot;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;display: inline-block;width: 100%;height: 200px;vertical-align: top;overflow-y: auto;&quot;&gt; 
      &lt;section style=&quot;overflow: hidden;&quot;&gt; 
       &lt;section style=&quot;margin-bottom: 120px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
        &lt;section style=&quot;text-align: justify;&quot;&gt; 
         &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
          &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Demo3&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// Incremental Update 還會產生的問題&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        R r = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; R();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        A a = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        A b = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a1 = a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 線程切換， r 掃完 a1， 但是沒有掃完 a2， 還是灰色&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a2 = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 業務線程發生引用切換， r 置灰灰色（本身灰色）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a1 = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 線程繼續掃完 a2， R 為黑色， b 對象又漏了~&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;R&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A a1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A a2;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
         &lt;/section&gt; 
        &lt;/section&gt; 
       &lt;/section&gt; 
      &lt;/section&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;當 GC 1 線程正在標記 O， 已經標記完 O 的屬性 O.1， 準備標記 O.2 時，業務線程把屬性 O,1 = B，這時候將 O 對象再次標記成灰色， GC 1 線程切回，將 O.2 線程標記完成，這時候認為 O 已經全部標記完成，O 標記為黑色， B 對象產生了漏標， CMS 針對 Incremental Update 產生的問題，只能在 remark 階段，暫停所有線程，將這些發生過引用改變過的，重新掃描一遍。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用場景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;適用於互聯網或者 B/S 服務， 響應速度優先，適合 6G 左右。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;優點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;併發收集， 低停頓，回收過程中最耗時的是併發標記和併發清除，它都能與用戶線程保持一起工作。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;收集器對 CPU 的資源非常敏感，會佔用用戶線程部分使用，導致程序會變得緩慢，吞吐量下降。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;無法處理浮動垃圾，在併發清理階段用戶線程還是在運行，這時候產生的新垃圾無法在這次當中處理，只有等待下次才會清理。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;因為 CMS 使用了 Incremental Update，remark 階段還是會所有暫停，重新掃描發生引用改變的 GC root，效率慢耗時高。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;因為收集器是基於標記清除算法實現的，所以在收集器回收結束後，內存會產生碎片化，當碎片化非常嚴重的時候，這時候有大對象進入無法分配內存時會觸發 FullGC，特殊場景下會使用 Serial 收集器，導致停頓不可控。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（5）G1 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 也是採用三色標記分段式進行回收的算法， 不過它是寫屏障 + STAB 快照實現，G1 設定的目標是在延遲可控（低暫停）的情況下獲得儘可能高的吞吐量，仍然可以通過併發的方式讓 Java 程序繼續運行，G1 垃圾收集器在很多方面彌補了 CMS 的不足，比如 CMS 使用的是 mark-sweep 標記清除算法，自然會產生內存碎片 (CMS 只能在 Full GC 時，STW 整理內存碎片)，然而 G1 整體來看是基於標記整理算法實現的收集器，但是從局部來看也是基於複製算法實現的，高效的整理剩餘內存，而不需要管理內存碎片它。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 同樣有年輕代和老年代的概念，只不過物理空間劃分已經不存在，邏輯分區還存在，G1 會把堆切成若干份，每一份當作一個目標，在部分上目標很容易達成，G1 在進行垃圾回收的時候，將會根據最大停頓時間設置值動態選取部分小堆區垃圾回收。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014633&quot; data-ratio=&quot;0.6731481481481482&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/3baad622-5f9e-4052-8a43-43203fcb039b.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 的特點是儘量追求吞吐量，追求響應時間，併發收集，壓縮空閒空間不會延長 GC 暫停時間，更容易預測 GC 暫停時間，能充分利用 CPU、多核環境下的硬件優勢，使用多個 CPU 對 STW 進行控制 (200ms 以內) 靈活的分區回收，優先回收花費時間少的或者垃圾比例高的 region 新老比例也是動態調整，不需要配置；年齡晉升也是 15，但是可以動態年齡，當倖存者 region 超過了 50 時，會把年齡最大的放入老年代。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 動態 Y 區域設置，G1 每個分區都可能是年輕代或者老年代，但是同一時刻只屬於一個代，分代概念還存在，邏輯上分代方便複用以前分代邏輯，在物理上不需要連續，這樣能帶來額外好處，有的分區內垃圾比較多，有的分區比較少，G1 會優先回收垃圾比較多的分區，這樣可以花費少量的時間來回收這些分區垃圾，即收集最多垃圾分區；但是新生代回收不適合這種，新生代達到閾值時發生 YGC，對整個新生代進行回收或者晉升倖存，新生代也分區是方便動態調整分區大小，在進行垃圾回收時，會將存活對象拷貝到另一個可用分區上，這樣也能避免一定程度的內存碎片化過程，每個分區的大小都是在 1M- 32M 之間，取決 2 的冪次方。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;Humingous&lt;/strong&gt;：如果一個對象佔用的空間超過了分區容量 50% 以上，G1 收集器就認為這是一個巨型對象。這些巨型對象，默認直接會被分配在年老代，但是如果它是一個短期存在的巨型對象，就會對垃圾收集器造成負面影響；為瞭解決這個問題，G1 劃分了一個 Humongous 區，它用來專門存放巨型對象。如果一個 H 區裝不下一個巨型對象，那麼 G1 會尋找連續的 H 分區來存儲。為了能找到連續的 H 區，有時候不得不啓動 Full GC。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;CardTable&lt;/strong&gt;：記錄每一塊 card 內存區域是否 dirty，如果在發生 YGC 時，怎麼知道那些是存活對象，並且其它代區域有沒有引用這部分對象，於是把內存劃分了很多 card 區域， 每個區域大小不超過 512b，當該 card 區域裏的對象有引用關係，將當前 card 置為「dirty」， 並且使用卡表（CardTable）來記錄每一塊 card 是否 dirty，在進行 GC 時，不用遍歷所有的空間， 只需要遍歷卡表中為&quot;dirty&quot;或者説布爾符合條件的 card 區域進行回掃。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014634&quot; data-ratio=&quot;0.6703703703703704&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/317b89d9-596b-458e-ba5d-b9c955eb7575.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;CSet&lt;/strong&gt;：Collection SET 用於記錄可被回收分區的集合組， G1 使用不同算法，動態的計算出那些分區是需要被回收的，將其放到 CSet 中，在 CSet 當中存活的數據都會在 GC 過程中拷貝到另一個可用分區，CSet 可以是所有類型分區，它需要額外佔用內存，堆空間的 1%。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;RSet&lt;/strong&gt;：RememberedSet 每個 Region 都有一個 Rset，是一個記錄了其他 Region 中的對象到本身 Region 的引用，它可以使得垃圾收集器不需要掃描整個堆去找到誰的引用了當前分區對象，是 G1 高效回收的關鍵點，也是三色算法的一個以來點。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014635&quot; data-ratio=&quot;0.2824074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/a1cb4f90-eef7-4393-9c20-eb6badbc354e.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;RSet 和卡表的區別是什麼？&lt;/strong&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;p&gt;卡表記錄的是堆內存中 card 有沒有變成&quot;dirty&quot;， 但是它本身不知道 dirty 裏面哪些是引用了的對象，它是一個大維度的一個記錄，RSet 是記錄自身 Region 中對象引用了其它 Region 中的那些對象，詳細的記錄對方引用對象信息，G1 使用了兩者的結合，實現了增量式的垃圾回收，並優化跨區引用的最終處理。&lt;/p&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;SATB 算法&lt;/strong&gt;：是一種基於快照的算法，它可以避免在垃圾回收時出現對象漏標或者重複標記的問題，從而提高垃圾回收的準確性和效率，在垃圾回收開始時，對堆中的對象引用進行快照，然後在併發標記階段中記錄下所有被修改過對象引用，保存到 satb_mark_queue 中，最後在重新標記階段重新掃描這些對象，標記所有被修改的對象，保證了準確性和效率。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;SATB 算法在 remark 階段不需要暫停遍歷整個堆對象，只需要掃描「satb_mark_queue」隊列中的記錄，避免了這個階段長耗時，而 cms 的增量算法在這個階段是需要重新掃描 GC Roots 標記整個堆對象，導致了不可控時間暫停，總的來説 G1 是通過回收領域應用並行化策略，將原來的幾塊大內存塊回收問題，演變成了 N 個小內存塊回收，使得回收效率可以高度並行化，停頓時間可控，可以與用戶線程併發執行，將一塊內存分而治之。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014636&quot; data-ratio=&quot;0.35462962962962963&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/7545f663-b201-495f-9cf2-b522f1c96976.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;G1 默認當分區內存佔用閾值達到總內存的 45%，會發生 Mixed gc（混和 GC），YoungGC + 併發回收 Mixed GC 過程：初始標記（stw）、併發標記、最終標記 (重新標記 stw)、篩選回收（stw 並行）。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用場景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;響應速度優先，較高的吞吐量，面向服務端，使用內存 6G 以上。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;優點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;並行與併發收集，分代分區收集，優先垃圾收集，空間整合，可控或者可預測停頓時間。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;收集中產生內存，G1 的每個 region 都需要有一份記憶集和卡表記錄跨代指針，這導致記憶集可能佔用堆空間 10-20% 甚至更多空間。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;執行過程中額外負載開銷加大，寫屏障進行維護卡表操作外，還需要原始快照能夠減少併發標記和重新標記階段的消耗，避免最終標記階段停頓過長，運行過程中會產生由跟蹤引用變化帶來的額外開銷負擔，比 CMS 增量算法消耗更多，CMS 的寫屏障實現直接是同步操作， 而 G1 是把寫屏障和寫後屏障中要做的事情放到隊列裏異步處理。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 對於 Full GC 是沒有處理流程， 一旦發生 Full GC G1 的回收執行的是單線程的 Serial 回收器進行回收。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.7 垃圾收集器配置使用&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;機器配置：64 位 4C8G&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;Java 程序使用 CMS 收集器進行內存垃圾回收初始內存劃分情況：&lt;/p&gt; 
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-Xms4096M&amp;nbsp;-Xmx4096M&amp;nbsp;-XX:+HeapDumpOnOutOfMemoryError&amp;nbsp;-XX:HeapDumpPath=&lt;span class=&quot;code-snippet__regexp&quot;&gt;/data/&lt;/span&gt;{runuser}/logs/other&amp;nbsp;-XX:+UseConcMarkSweepGC&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014637&quot; data-ratio=&quot;0.5889967637540453&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/9ca62bea-63ea-499e-b9e7-0d0f7a002676.png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;span style=&quot;letter-spacing: 0.034em;&quot;&gt;CMS 跟 parNew 佔比情況， 默認下 ParNew 佔用整個堆的空間為：機器位數 * CPU 核數 * 13 /10 ， 當前機器配置計算得出 64 * 4 * 13 / 10 = 332M ， 與圖上數值差別不大。&lt;/span&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 程序使用 G1 收集器進行內存垃圾回收初始內存劃分情況：&lt;/p&gt; 
   &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
    &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-Xms4096M&amp;nbsp;-Xmx4096M&amp;nbsp;-XX:+HeapDumpOnOutOfMemoryError&amp;nbsp;-XX:HeapDumpPath=&lt;span class=&quot;code-snippet__regexp&quot;&gt;/data/&lt;/span&gt;{runuser}/logs/other&amp;nbsp;-XX:+UseG1GC&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
   &lt;/section&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014638&quot; data-ratio=&quot;0.5726495726495726&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/f87fe847-d5a8-4609-b631-234fab58b8c7.png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;G1 新老年代的佔比是動態調整， 隨着運行時根據實際情況劃分空間。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;Java8 默認 ParallerGC 收集器初始內存劃分情況：&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014639&quot; data-ratio=&quot;0.5694591728525981&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/b3a135dc-2a00-4a54-acd4-c3600b573ab9.png&quot; data-type=&quot;png&quot; data-w=&quot;943&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;parallel GC 回收器默認堆 old 區與 young 區內存大小比例 2：1， 圖上數值差別不大。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;三、內存診斷實踐&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;3.1 內存快照生成&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;當發生線上應用告警，告警相關內存故障問題時， 應當如何進行故障排查呢？首先應用在發生內存溢出無法執行時，應 DUMP 當前內存快照，需要在 Java 程序執行啓動命令時添加上：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;-XX:+HeapDumpOnOutOfMemoryError&amp;nbsp;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;-XX:HeapDumpPath=${filePath} 參數&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&amp;nbsp;當發生時自動生成一份當前內存快照，方便與開發人員使用快照文件進行問題診斷分析。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;在 Java 應用運行時，想手動生成內存快照，可以使用 JDK 自帶幾個問題排查工具，可以使用 jmap 工具生成指定 PID 內存快照，不過需要耗費較長的一個時間，會暫停應用程序執行，使用 jcmd 工具可以快速的 DUMP 內存快照，因為在堆轉儲存文件過程中，jcmd 可以利用虛擬機中的一些優化技術，例如分代堆、增量式垃圾回收等技術，相比傳統的 jmap 效率高很多，一般來説在 DUMP 內存前會進行一次&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Full FC，可以指定屏蔽這次 Full GC，保留當前所有內存中的對象。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;除了自帶的內存診斷工具， 也可以使用 Arthas 診斷工具，提供了多個命令來幫助診斷內存問題，例如 dashboard（當前 Java 程序內存實時數據面板）、JVM（查看當前 JVM 信息，包括使用的 gc 收集器、內存分區分佈情況等信息）、heapdump（當前內存快照類似 jmap 命令的 heap dump）、memory（當前內存分區及佔用情況）、monitor（監控模式，可監控內存及查看對象佔用情況）profiler（火焰圖可以輸出多種火焰圖，內存分區佔用火焰圖）等相關內存命令。這些命令可以幫助獲取應用程序的內存快照、堆內存使用情況等信息，能快速定位內存問題。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;引用：&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farthas.aliyun.com%2Fdoc%2Fcommands.html&quot; textvalue=&quot;Arthas 命令列表&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Arthas 命令列表&lt;/a&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;3.2 dump 內存快照分析&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;（1）jhat 是 Java 開發工具包自帶的一款堆內存分析工具，它可以幫助解決 Java 應用程序的內存問題。Jhat 可以讀取 Java 應用程序生成的堆轉儲文件，並以 HTML 格式展示內存中的對象信息和引用關係，支持 OQL 查詢和靈活的過濾和排序功能。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;用例&amp;nbsp;&lt;span style=&quot;background-color: rgb(214, 214, 214);&quot;&gt; jhat E:\diydump\Java_pid2680.hprof&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014640&quot; data-ratio=&quot;0.597&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/ed38fad9-e21f-4c52-b7db-b83e26d1ef28.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;All classes including platform&lt;/strong&gt;：列舉應用程序中所有類的信息，並快速定位內存問題。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;Show all members of the rootset&lt;/strong&gt;：顯示堆內存中所有根對象的信息，包括系統對象、靜態對象、本地對象等。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;Show instance counts for all classes (including platform)&lt;/strong&gt;：顯示所有類的實例數量。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;Show heap histogram&lt;/strong&gt;：顯示程序堆內存的直方圖，可以知道每個類的實例數量和佔用內存大小等信息，快速知道內存泄漏原因。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;（2）jvisualvm 也是 Java 開發工具包裏自帶的一款圖形化工具，可以用於監控和診斷 Java 應用程序的性能問題。使用它可以實時查看 Java 應用程序的內存使用情況、CPU 使用情況、線程情況等，並可以進行內存分析、CPU 分析、線程分析等內容。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;以 Java_pid2680.hprof 為例，進行內存分析內存泄漏原因：&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014641&quot; data-ratio=&quot;0.4685185185185185&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/cecd7993-3d90-45ea-9aec-eb5bbc6a811b.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;（3）MAT 是基於 Eclipse 的內存分析工具，是一個快速、功能豐富的 Java 內存分析工具，能夠快速的分析出 dump 文件中各項結果，快速給出內存泄漏原因報告。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;還是以 Java_pid2680.hprof 文件進行分析，比原生的 jhat 方便很多，功能也比原生的更加豐富：&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014642&quot; data-ratio=&quot;0.5074074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/f7caef82-cb1c-4a39-9ee8-103c551796d8.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;MAT 的一些常用功能點介紹（如圖所示）：&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;Overview &lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;標籤內容有比較多塊內容，其中 details 末塊介紹總共使用內存大小，類的數量，實例的數量，類的加載器，以及實例的內存直方圖；&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;Biggest Objects by Retained Size&lt;/strong&gt;模塊，使用了餅狀圖列出了當前內存中佔用最大的幾個對象，按照百分比劃分，點擊不同的餅狀塊能夠看到具體對象及其對象屬性等信息；&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;actions&lt;/strong&gt;模塊，這裏擁有不同的分析功能，Histogram 生成視圖列出每個類所對應的對象個數以及佔用內存大小，Dominator Tree 生成視圖尋找出大對象，每個實例對象的內存佔比比重；&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;Reports&lt;/strong&gt;模塊是生成報告，其中 Leak Suspects 可以自動分析內存泄漏主要原因報告，可以通過報告準確定位泄漏原因或者可能造成泄漏的原因，並且可以定位到具體累積實例，線程 stack 等信息。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;例子中：leak Suspects 報告給出「0xfe3be480」 非常多內存， Gc root Thread 所引用，在發生 gc 時，不是可回收對象，無法回收內存，導致內存溢出。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014643&quot; data-ratio=&quot;0.4861111111111111&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/df138f30-3373-4dfb-a6d2-95dba48cdf83.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;四、總結&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;本文介紹了 Java 程序中的內存模型，內存模型劃分多份內存區域，不同區域的作用介紹及不同區域的線程之間的內存共享範圍，可以幫助開發人員更加理解 Java 中內存管理的機制和原理。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;堆是內存模型中最大的一塊內存區域，以堆的空間劃分詳細的介紹了內存分代，部分垃圾收集器即是物理分代和邏輯分代，G1 收集器則物理不分代邏輯保留了以前分代，講述了不同收集器的原理實現和優缺點，可以根據項目的業務屬性，機器配置等因素選擇最優的收集器，幫助程序使用最優的收集器可以使得程序的吞吐量和響應速度達到最佳狀態。還講述了不同的參數調優收集器，並且當發生了程序內存溢出崩潰，如何進行內存分析，介紹不同工具的使用，快速定位內存溢出的罪魁禍首，從而在代碼層面上根本解決這類問題。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;margin-top: 0.5em;margin-bottom: 0.5em;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;border-top: 1px dotted rgb(90, 98, 114);&quot;&gt; 
      &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;text-align: center;color: rgb(45, 66, 87);font-size: 11px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p&gt;END&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;margin-top: 0.5em;margin-bottom: 0.5em;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;border-top: 1px dotted rgb(90, 98, 114);&quot;&gt; 
      &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: left;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;&quot;&gt; 
    &lt;span style=&quot;display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);&quot; title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:234.title1&quot;&gt;&lt;p&gt;猜你喜歡&lt;/p&gt;&lt;/span&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;&quot;&gt; 
    &lt;section style=&quot;font-size: 14px;text-align: left;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;padding-left: 40px;list-style-position: outside;&quot;&gt; 
      &lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247498348%26idx%3D1%26sn%3Da070a524928c6d312a56ead073e14a7c%26chksm%3Debdb8afedcac03e89c1a233dc19e01b468331219eaad321cb6346c0f73a2c06135503e6a83a6%26scene%3D21%23wechat_redirect&quot; textvalue=&quot;vivo 統一接入網關 VUA 轉發性能優化實踐&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;vivo 統一接入網關 VUA 轉發性能優化實踐&lt;/a&gt;&lt;/p&gt;&lt;/li&gt; 
      &lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247498342%26idx%3D1%26sn%3Db314e59b249a74cd76464d16895d8696%26chksm%3Debdb8af4dcac03e2defb1d7339379dadf13f2597f924f5c974e1083c668c971016d199fb1d07%26scene%3D21%23wechat_redirect&quot; textvalue=&quot;Sharding-JDBC 源碼解析與 vivo 的定製開發&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Sharding-JDBC 源碼解析與 vivo 的定製開發&lt;/a&gt;&lt;/p&gt;&lt;/li&gt; 
      &lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247498320%26idx%3D1%26sn%3Dc0180b1567a8b362c3c23c51528dfb7d%26chksm%3Debdb8ac2dcac03d4a3113cf75191bbf134746649184986b161fc521f4e340e1753ad6afbf744%26scene%3D21%23wechat_redirect&quot; textvalue=&quot;vivo 在離線混部探索與實踐&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;vivo 在離線混部探索與實踐&lt;/a&gt;&lt;/p&gt;&lt;/li&gt; 
     &lt;/ul&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
 &lt;/section&gt; 
 &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt; 
  &lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo 互聯網技術&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互聯網技術乾貨與沙龍活動，推薦最新行業動態與熱門會議。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;&gt;&lt;/mp-common-profile&gt; 
 &lt;/section&gt; 
 &lt;p style=&quot;display: none;&quot;&gt; 
  &lt;mp-style-type data-value=&quot;3&quot;&gt;&lt;/mp-style-type&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color: #858585; font-size: 13px;&quot;&gt;本文分享自微信公眾號 - vivo 互聯網技術（vivoVMIC）。&lt;br&gt;如有侵權，請聯繫 support@oschina.cn 刪除。&lt;br&gt;本文參與「&lt;a href=&quot;https://www.oschina.net/sharing-plan&quot; target=&quot;_blank&quot;&gt;OSC 源創計劃&lt;/a&gt;」，歡迎正在閲讀的你也加入，一起分享。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://my.oschina.net/vivotech/blog/11048619</link>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/11048619</guid>
            <pubDate>Wed, 27 Mar 2024 01:51:40 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>大數據應用場景落地實踐</title>
            <description></description>
            <link>https://www.oschina.net/event/2331846</link>
            <guid isPermaLink="false">https://www.oschina.net/event/2331846</guid>
            <pubDate>Tue, 26 Mar 2024 09:29:17 GMT</pubDate>
        </item>
        <item>
            <title>mybatis-mp - 亮點八：mybatis-xml returnType 的 ORM 映射</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;strong&gt;mybatis-mp - 亮點八:&amp;nbsp; 可對 xml 實體類返回，進行自動映射：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;當你需要寫一個很複雜的 sql 時，你可能會選擇用 xml 去做例如：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;findUserList&quot; returnType=&quot;User&quot;&amp;gt;

&amp;nbsp; &amp;nbsp; &amp;nbsp; select id,user_name as userName,nick_name as nickName,password from user where xx and xx2 and xx3 ........

&amp;lt;/select&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style=&quot;color:#e74c3c&quot;&gt;如上：你可能需要自己，一個一個 as userName , as nickName 之類的，是不是很麻煩&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;現在好，只要接入 mybatis-mp；這些完全不用寫了，如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;findUserList&quot; returnType=&quot;User&quot;&amp;gt;

&amp;nbsp; &amp;nbsp; &amp;nbsp; select id,user_name,nick_name,password from user where xx and xx2 and xx3 ........

&amp;lt;/select&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;自動幫你進行了映射，而且不僅僅支持實體，還支持 VO；省去了很多麻煩步驟！&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284803</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284803</guid>
            <pubDate>Tue, 26 Mar 2024 06:44:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>Ubuntu LTS 支持延長至 12 年</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Canonical &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fubuntu.com%2F%2Fblog%2Fcanonical-expands-long-term-support-to-12-years-starting-with-ubuntu-14-04-lts&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;全面推出 Legacy Support —— 一個 Ubuntu Pro 插件，可將 Ubuntu LTS 版本的安全性和支持範圍擴大到 12 年。適用於 Ubuntu 14.04 LTS 及以上版本。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;312&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2a2eb37bed9123652265f19a8da71c4a8b3.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此前，Ubuntu 的 LTS 版本一般將獲得 5 年的安全更新、錯誤修復和精選應用程序更新。Ubuntu Pro 則會在此基礎上額外增加 5 年的安全保障，為現代的 LTS 版本提供長達十年的支持。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;通過此次推出的 Legacy Support 插件，Ubuntu Pro 用戶將可以在原有的基礎上，額外再兩年的安全維護和支持。這意味着，Ubuntu 14.04 LTS 及以上版本的 LTS 從發佈之日起將可獲得長達 12 年的支持期。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Canonical 支持工程全球副總裁 Maximilian Morgan 稱，「我們很高興能為客戶提供額外幾年的 Ubuntu LTS 版本安全維護和支持......通過 Legacy Support，我們使企業能夠滿懷信心地引導其運營需求和對開源的投資，確保他們的系統在未來許多年內保持可用、安全和支持。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;這意味着原定於今年 4 月結束支持的 Ubuntu 14.04 LTS &quot;Trusty Tahr&quot; 將推遲至 2026 年 4 月，從而為 IT 人員預留了更多的時間來計劃和準備升級到更新的版本。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284787/ubuntu-lts-12-years</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284787/ubuntu-lts-12-years</guid>
            <pubDate>Tue, 26 Mar 2024 06:21:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>蘋果和中國百度尚未達成人工智能技術供應協議</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;此前有報道稱蘋果公司已與百度達成合作，將在該地區使用百度的大模型 AI 功能。但現在又有消息稱，雙方並未達成這樣的協議。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-2550020989aa58a4082d974f67ffa94e71c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.chinastarmarket.cn%2Fdetail%2F1628550&quot; target=&quot;_blank&quot;&gt;https://www.chinastarmarket.cn/detail/1628550&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;《中國日報》指出，這些早先的報道不正確。該刊物稱，蘋果和百度尚未就人工智能合作達成一致，它是從熟悉蘋果公司運作的消息來源獲得這一信息的。有關兩家公司已達成協議的報道只是媒體的猜測。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-5cf43246dfdeb31ea068b82961ff89dc3e3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.chinadaily.com.cn%2Fa%2F202403%2F26%2FWS6602b2c1a31082fc043bec68.html&quot; target=&quot;_blank&quot;&gt;https://www.chinadaily.com.cn/a/202403/26/WS6602b2c1a31082fc043bec68.html&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;不過無論蘋果公司目前簽訂的任何合同的具體情況如何，至少該公司很可能會與中國公司合作，這樣做容易避免潛在的監管問題。&lt;/p&gt; 
&lt;p&gt;百度股價在最初的報道中上漲了 2.55%。百度和蘋果公司均未對此發表評論。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284945</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284945</guid>
            <pubDate>Tue, 26 Mar 2024 06:07:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>Rust 1.77.0 發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;Rust 1.77.0 穩定版已正式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.rust-lang.org%2F2024%2F03%2F21%2FRust-1.77.0.html&quot; target=&quot;_blank&quot;&gt;發佈&lt;/a&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;，主要帶來以下變化：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;C-string literals&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;Rust 現在支持 &amp;nbsp;C-string literals&amp;nbsp;(&amp;nbsp;&lt;code&gt;c&quot;abc&quot;&lt;/code&gt;)，它在&lt;code&gt;&amp;amp;&#39;static CStr&lt;/code&gt;類型的內存中擴展為以 nul 字節結束的字符串。這使得編寫與需要以 nul 結尾的字符串的外語接口互操作的代碼變得更加容易，並且在編譯時執行所有相關的錯誤檢查（例如，缺少內部 nul 字節）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h4 style=&quot;text-align:start&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;Support for recursion in &lt;code&gt;async fn&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;由於編譯器限制，異步函數以前無法調用自身。在 1.77 中，該限制已被取消；因此只要使用某種間接形式來避免函數狀態的無限大，就允許遞歸調用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;這意味着這樣的代碼現在可以工作：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre style=&quot;text-align:start&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span style=&quot;color:#b854d4&quot;&gt;async&lt;/span&gt; &lt;span style=&quot;color:#b854d4&quot;&gt;fn&lt;/span&gt; &lt;span style=&quot;color:#6684e1&quot;&gt;fib&lt;/span&gt;(n: &lt;span style=&quot;color:#b65611&quot;&gt;u32&lt;/span&gt;) -&amp;gt; &lt;span style=&quot;color:#b65611&quot;&gt;u32&lt;/span&gt; {
   &lt;span style=&quot;color:#b854d4&quot;&gt;match&lt;/span&gt; n {
       &lt;span style=&quot;color:#b65611&quot;&gt;0&lt;/span&gt; | &lt;span style=&quot;color:#b65611&quot;&gt;1&lt;/span&gt; =&amp;gt; &lt;span style=&quot;color:#b65611&quot;&gt;1&lt;/span&gt;,
       _ =&amp;gt; &lt;span style=&quot;color:#b65611&quot;&gt;Box&lt;/span&gt;::pin(fib(n-&lt;span style=&quot;color:#b65611&quot;&gt;1&lt;/span&gt;)).&lt;span style=&quot;color:#b854d4&quot;&gt;await&lt;/span&gt; + &lt;span style=&quot;color:#b65611&quot;&gt;Box&lt;/span&gt;::pin(fib(n-&lt;span style=&quot;color:#b65611&quot;&gt;2&lt;/span&gt;)).&lt;span style=&quot;color:#b854d4&quot;&gt;await&lt;/span&gt;
   }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;h4 style=&quot;text-align:start&quot;&gt;&lt;strong&gt;offset_of!&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;1.77.0 穩定了 struct fields​​​​​​​ 的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fmem%2Fmacro.offset_of.html&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;offset_of!&lt;/code&gt;&lt;/a&gt;，它提供了對 struct 相關公共字段的字節偏移量的訪問。這個宏在需要字段偏移量而又沒有類型實例的情況下非常有用。&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;用戶現在可以使用&lt;code&gt;offset_of!(StructName, field)&lt;/code&gt;訪問公共字段的偏移量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h4 style=&quot;text-align:start&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;默認情況下在發佈配置文件中啓用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;strip&lt;/h4&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;未在 outputs 中啓用&amp;nbsp;debuginfo 的&amp;nbsp;Cargo profiles（例如&lt;code&gt;debug = 0&lt;/code&gt;）將默認啓用&lt;code&gt;strip = &quot;debuginfo&quot;&lt;/code&gt;。​​​​​​​&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;之所以需要這樣做，主要是因為（預編譯）標準庫附帶有 debuginfo，這意味着即使本地編譯沒有明確請求 debuginfo，靜態鏈接的結果也會包含標準庫中的 debuginfo。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;穩定的 API&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.array.html%23method.each_ref&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;array::each_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.array.html%23method.each_mut&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;array::each_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fcore%2Fnet%2Findex.html&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;core::net&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.f32.html%23method.round_ties_even&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;f32::round_ties_even&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.f64.html%23method.round_ties_even&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;f64::round_ties_even&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fmem%2Fmacro.offset_of.html&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;mem::offset_of!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.first_chunk&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::first_chunk&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.first_chunk_mut&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::first_chunk_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.split_first_chunk&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::split_first_chunk&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.split_first_chunk_mut&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::split_first_chunk_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.last_chunk&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::last_chunk&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.last_chunk_mut&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::last_chunk_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.split_last_chunk&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::split_last_chunk&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.split_last_chunk_mut&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::split_last_chunk_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.chunk_by&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::chunk_by&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fprimitive.slice.html%23method.chunk_by_mut&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;slice::chunk_by_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fops%2Fenum.Bound.html%23method.map&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;Bound::map&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Ffs%2Fstruct.File.html%23method.create_new&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;File::create_new&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fsync%2Fstruct.Mutex.html%23method.clear_poison&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;Mutex::clear_poison&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fstable%2Fstd%2Fsync%2Fstruct.RwLock.html%23method.clear_poison&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;RwLock::clear_poison&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Other changes&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;可查看&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frust-lang%2Frust%2Freleases%2Ftag%2F1.77.0&quot; target=&quot;_blank&quot;&gt;Rust&lt;/a&gt;&lt;span style=&quot;color:#000000&quot;&gt;、&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frust-lang%2Fcargo%2Fblob%2Fmaster%2FCHANGELOG.md%23cargo-177-2024-03-21&quot; target=&quot;_blank&quot;&gt;Cargo&lt;/a&gt;&amp;nbsp;和&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frust-lang%2Frust-clippy%2Fblob%2Fmaster%2FCHANGELOG.md%23rust-177&quot; target=&quot;_blank&quot;&gt;Clippy&lt;/a&gt;&amp;nbsp;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;中發生的所有變化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;詳情可&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.rust-lang.org%2F2024%2F03%2F21%2FRust-1.77.0.html&quot; target=&quot;_blank&quot;&gt;查看官方公告&lt;/a&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;&lt;span style=&quot;color:#333333&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284778/rust-1-77-0-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284778/rust-1-77-0-released</guid>
            <pubDate>Tue, 26 Mar 2024 06:01:32 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Ugly avatar —— 醜頭像生成器</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;Ugly avatar 是生成醜頭像的在線工具。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-c1df4ccc6fa20c1982e151f5404498a50a0.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

&lt;p&gt;體驗地址：&lt;a href=&quot;https://txstc55.github.io/ugly-avatar/&quot;&gt;https://txstc55.github.io/ugly-avatar/&lt;/a&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/ugly-avatar</link>
            <guid isPermaLink="false">https://www.oschina.net/p/ugly-avatar</guid>
            <pubDate>Tue, 26 Mar 2024 04:21:50 GMT</pubDate>
        </item>
    </channel>
</rss>