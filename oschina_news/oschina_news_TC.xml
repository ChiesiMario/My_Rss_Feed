<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 11 Dec 2023 09:26:13 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[榮耀申請魔方大模型商標]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#222222">天眼查信息顯示，榮耀終端有限公司近日申請註冊「榮耀魔方大模型」商標，國際分類為網站服務，當前商標狀態為等待實質審查。</span></p><p><img height="275" src="https://oscimg.oschina.net/oscnet/up-7baf34d7d00360b976559630121d67b0da4.png" width="700" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#222222">此前，該公司曾申請兩枚「MAGIC&nbsp;大模型」商標。榮耀 CEO 趙明曾發文稱，榮耀即將推出自研端側 AI 大模型和全新雲服務。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 08:25:44 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270492</guid>
            <link>https://www.oschina.net/news/270492</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[HashiCorp 採用 BSL 後續，Linux 基金會孵化 Vault 開源替代品]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">今年 8 月，<span style="background-color:#ffffff">專注於雲基礎設施的軟件供應商 HashiCorp&nbsp;</span>宣佈<span style="background-color:#ffffff">修改其核心產品的開源協議。</span><strong style="color:#333333">所有 HashiCorp 產品的未來版本</strong><span style="background-color:#ffffff">將從 Mozilla Public License v2.0 (MPL 2.0) 變更為&nbsp;</span><strong style="color:#333333">Business Source License (BSL, also known as BUSL) v1.1</strong><span style="background-color:#ffffff">，其中包括&nbsp;Vault、Boundary、Consul、Nomad、Packer、Terraform、Vagrant 和 Waypoint 等。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">採用 BSL 1.1 的項目，其代碼仍會公開 (source-available)，</span><strong style="color:#333333">但只允許在特定條件下進行復制、修改、重新分發、非商業使用和商業使用</strong><span style="background-color:#ffffff">&nbsp;—— 主要是添加了商業使用方面的限制。</span></span></p><p><span style="color:#000000">此後，社區在抗議無效後選擇創建了 Terraform 的分支項目 OpenTofu（原名 OpenTF），並託管在了 Linux 基金會下。</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">時至今日，有消息稱 Linux 基金會正計劃幫助孵化一個私密信息管理工具 Vault 的開源替代品。DevOps 自動化公司 Scalr 的聯合創始人兼首席執行官 Sebastian Stadil 和 OpenTofu 的組織者之一<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theregister.com%2F2023%2F12%2F08%2Fhashicorp_openbao_fork%2F" target="_blank">透露</a>，Vault 開源替代品的項目名為 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwiki.lfedge.org%2Fdisplay%2FOH%2FOpenBao%2B%2528Hashicorp%2BVault%2BFork%2Beffort%2529%2BFAQ" target="_blank">OpenBao</a>，是競爭對手在 MPL 2.0 協議下創建的一個&nbsp;Vault 分支。</span></span></p><p><img height="287" src="https://oscimg.oschina.net/oscnet/up-1f318fa9f93212c7ed6a67c0b91e135c731.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">OpenTofu 計劃在本月晚些時候發佈候選版本，OpenBao 也將開始接受新的貢獻。Stadil 表示，「如果有兩個相同的項目，一個是開源的，一個不是，我個人認為，道德上的選擇是使用開源項目，並以某種方式提供幫助。」</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">不過鑑於 OpenTofu 和 OpenBao 都是新近開發的項目，項目的可行性和持久性受到了很多關注。針對這一擔憂，Stadil 表示拒絕代表其他公司發言。事實上，他還被告知不要透露任何關於其他組織支持這些項目的消息。對於那些想要了解更多詳情的人，他建議可以訪問項目的 repos。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">當被問及 HashiCorp 重新授權其軟件的理由時，Stadil 回答稱，官方的説法是 Terraform 對互聯網至關重要，而長期以來人們一直希望將其置於 Linux 基金會的監督之下。「如果 HashiCorp 將來願意加入我們的 OpenTofu，我們會很樂見其成」。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">但</span><span style="background-color:#ffffff">他無法推測 HashiCorp 的內部決策過程。Stadil 指出，Hashicorp 一直在燒錢，隨着利率的上升，這家軟件公司選擇採取措施創造更多收入也不足為奇。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">上週，HashiCorp 公佈了 2024 財年第三財季的營收報告。營收 1.461 億美元，同比增長 17%。按照美國通用會計準則（GAAP），淨虧損為 3950 萬美元，低於去年同期的 7200 萬美元。</span></span></p><p><strong><span style="color:#000000"><span style="background-color:#ffffff">相關閲讀：</span></span></strong></p><ul><li><a href="https://www.oschina.net/news/253275/hashicorp-adopts-business-source-license" target="_blank">HashiCorp 核心產品變更開源協議，未來將採用 BSL</a></li><li><p style="margin-left:0px; margin-right:0px; text-align:start"><a href="https://www.oschina.net/news/255700/opentf-fork-terraform" target="_blank">HashiCorp 採用 BSL 後，社區創建 Terraform 分支 OpenTF</a></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 07:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270477/hashicorp-vault-openbao-fork</guid>
            <link>https://www.oschina.net/news/270477/hashicorp-vault-openbao-fork</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[周熱點 | Linus 收斂火爆脾氣，談內核社區「老齡化」問題；Firefox 或將被淘汰；谷歌發佈最強 AI 模型 Gemini............]]>
            </title>
            <description>
                <![CDATA[回顧一週熱門資訊。2023.12.04-2023.12.10]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 06:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649094041&#38;idx=1&#38;sn=18ed1a99fdf7fbbbc52688a346795664&#38;chksm=880c4c8abf7bc59cbaf66865402e963af1309b4bb627cd89ae402f319f12ce5c56561126ea09&#38;token=1220110296&#38;lang=zh_CN#rd</guid>
            <link>https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649094041&#38;idx=1&#38;sn=18ed1a99fdf7fbbbc52688a346795664&#38;chksm=880c4c8abf7bc59cbaf66865402e963af1309b4bb627cd89ae402f319f12ce5c56561126ea09&#38;token=1220110296&#38;lang=zh_CN#rd</link>
        </item>
        <item>
            <title>
                <![CDATA[GitHub.com 跑了 1200 多台 MySQL 主機，如何無縫升級到 8.0？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>GitHub 團隊近日<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.blog%2F2023-12-07-upgrading-github-com-to-mysql-8-0%2F" target="_blank">分享</a></u>了他們將 GitHub.com 的底層數據庫無縫升級到 MySQL 8.0 的經驗。</p><p>據介紹，GitHub 使用 MySQL 來存儲大量關係數據，因此在不影響網站服務級別目標 (SLO) 的情況下升級主機集羣（<strong>1200 多台 MySQL 主機</strong>）絕非易事。其團隊表示，為了升級到 MySQL 8.0，他們規劃、測試和升級本身總共花費了一年多的時間，並且需要 GitHub 內部多個團隊的協作。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-613c88c0257637ef029cdd9528c6f8a3217.png" referrerpolicy="no-referrer"></p><p><strong>GitHub 的 MySQL 基礎設施概覽：</strong></p><ul><li>由 1200 多台主機組成，包括數據中心中的<strong> Azure 虛擬機和裸機主機</strong></li><li>存儲超過 300 TB 的數據，並在 50 多個數據庫集羣中每秒處理 550 萬次查詢</li><li>每個集羣都配置為具有主副設置的高可用性</li><li>分區存儲數據——利用水平和垂直分片來擴展 MySQL 集羣，以及使用 MySQL 集羣來存儲特定產品領域的數據。此外還為大結構域 (large-domain) 提供了水平分片的 Vitess 集羣，這些區域的增長超出了單主 MySQL 集羣的規模</li><li>龐大的工具生態，包括 Percona Toolkit、gh-ost、orchestrator、freno 和用於操作主機集羣的內部自動化工具</li></ul><p>由於需要操作兩個版本的 MySQL，因此 GitHub 內部使用的工具和自動化設施需要能夠兼容處理混合版本，並瞭解 5.7 和 8.0 之間<strong>新的、不同的或已棄用的語法</strong>。</p><p>為了滿足可用性標準，GitHub 團隊採取了逐步升級策略，滿足在整個過程中進行 checkpoint 和回滾的需求。下面是他們制定的升級計劃：</p><ul><li><strong>步驟 1：升級滾動副本 (rolling replica)</strong><br><img alt="" src="https://oscimg.oschina.net/oscnet/up-c9d574db1e2fec9bf7da0d7c92091b0fb19.png" referrerpolicy="no-referrer"><p>&nbsp;</p></li><li><strong>步驟 2：升級備份拓撲 (replication topology)</strong><br><img alt="" src="https://oscimg.oschina.net/oscnet/up-305231a10282f80062ca4f1d665c36305ee.png" referrerpolicy="no-referrer"><p>&nbsp;</p></li><li><strong>步驟 3：將 MySQL 8.0 主機提升為主集羣</strong><br><img alt="" src="https://oscimg.oschina.net/oscnet/up-0e9f6defe7e920b0167c797000292c7e390.png" referrerpolicy="no-referrer"><p>&nbsp;</p></li><li><strong>步驟 4：升級面向內部的實例類型</strong></li><li><strong>步驟 5：清理，</strong>確認集羣不需要回滾併成功升級到 MySQL 8.0 後，刪除 5.7 服務器。驗證工作會至少經歷一個完整的 24 小時流量週期，以確保在高峯流量期間不會出現問題。</li></ul><p>至於為什麼要升級到 MySQL 8.0，GitHub 團隊表示主要是因為 MySQL 5.7 的生命週期即將結束。此外升級後可以獲得最新安全補丁、錯誤修復和性能增強的 MySQL 版本。他們還希望測試 8.0 中的新功能並從中受益，包括即時 DDL、隱形索引和壓縮的 bin 日誌等。</p><p>詳細的技術細節查看：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.blog%2F2023-12-07-upgrading-github-com-to-mysql-8-0%2F" target="_blank">https://github.blog/2023-12-07-upgrading-github-com-to-mysql-8-0/</a></u></em></p><hr><p>延伸閲讀</p><ul><li><u><a href="https://www.oschina.net/news/188164/github-recent-service-disruptions">GitHub 解釋近期頻繁宕機原因：MySQL 不堪重負</a></u></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 05:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270460/upgrading-github-com-to-mysql-8-0</guid>
            <link>https://www.oschina.net/news/270460/upgrading-github-com-to-mysql-8-0</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[TIOBE 12 月：C# 有望成為年度編程語言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#000000"><span style="background-color:#ffffff">TIOBE 公佈了 2023&nbsp;年 12 月的</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tiobe.com%2Ftiobe-index%2F" target="_blank">編程語言排行榜</a><span style="background-color:#ffffff; color:#000000"><span style="background-color:#ffffff">。</span></span></p><p><img height="77" src="https://oscimg.oschina.net/oscnet/up-e944f70ee629593d3b3ba2ac7d008e89e4b.png" width="700" referrerpolicy="no-referrer"></p><p>2023 年度 TIOBE 編程語言名單即將出爐，其中最有望勝出的當屬&nbsp;C#。事實上，早在 2022 年&nbsp;C# 就有望奪得該桂冠，但卻在最後時刻被&nbsp;C++ 反超。而在今年，C# 的勝率又多出了幾分；因為該語言在一年內的增長率為 +2.38%，與其最接近的競爭者 Fortran 和 F# 的增長率則僅分別上漲了 +0.64% 和 +0.48%。</p><p>此外，Top 20 中的大部分語言人氣都出現了下降。<span style="background-color:#ffffff; color:#000000">TIOBE CEO&nbsp;Paul Jansen 評論稱，</span>「答案就在所有小語言所在的長尾（long tail）部分。這些語言的受歡迎程度都在上升，而且越來越接近大語言」。例如：一年前，排名第 50 位的語言得分僅為 0.14%，但現在第 50 位語言的得分已經達到了 0.24%。</p><p><strong style="color:#333333">TIOBE 12 月 TOP 20 編程語言</strong></p><p><img height="414" src="https://oscimg.oschina.net/oscnet/up-b25283a71bbac81145079c4b2848ccc6e95.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#000000">相較上月，除了 Ruby<span>&nbsp;</span>(18→19)、R (19→20) 以及 Rust (20→18) 之間出現了小範圍波動外，Top&nbsp;10-20 榜單沒有其他任何排名變化，這也是近期以來榜單變動最小的一次。</span></p><p><strong style="color:#333333">TOP 10 編程語言 TIOBE 指數走勢（2002-2024）</strong></p><p><img height="228" src="https://oscimg.oschina.net/oscnet/up-c048f61fdb18f5fa94fbc07b575f6acc8f9.png" width="700" referrerpolicy="no-referrer"></p><p><strong style="color:#333333">第 21-50 名編程語言排行</strong></p><p><img height="430" src="https://oscimg.oschina.net/oscnet/up-e1c00e5bc23507475a73c563cbdb213cdc9.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#000000">第 51-100 名如下，由於它們之間的數值差異較小，僅以文本形式列出（按字母排序）：</span></p><p>&nbsp;</p><blockquote><p>4th Dimension/4D, ABC, Algol, Apex, ATLAS, AutoLISP, Bash, Boo, Carbon, CIL, CL (OS/400), Clipper, Clojure, Curl, Eiffel, Elm, Erlang, GAMS, Groovy, Icon, Inform, Io, J#, LabVIEW, Ladder Logic, LiveCode, Maple, Modula-2, MOO, MQL5, NATURAL, Nim, OCaml, OpenEdge ABL, PostScript, Pure Data, Q, Racket, Ring, RPG, Smalltalk, Snap!, Solidity, SPARK, SPSS, Tcl, VHDL, Wolfram, X10, Zig</p></blockquote><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">TIOBE 編程社區指數（The TIOBE Programming Community index）是一個衡量編程語言受歡迎程度的指標，該指數每月更新一次。評判的依據來自世界範圍內的工程師、課程和第三方供應商，包括流行的搜索引擎，如 Google、必應、雅虎、維基百科、亞馬遜、YouTube 和百度都被用於指數計算。值得注意的是，TIOBE 指數並不代表編程語言的好壞或編寫代碼的多少。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">該指數可以用來檢查你的編程技能是否還能跟上時代的步伐，或者在開始建立一個新的軟件系統時，基於指數對採用何種編程語言做出決策。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tiobe.com%2Ftiobe-index%2Fprogramminglanguages_definition%2F" target="_blank">TIOBE 指數</a><span style="color:#000000">的定義方式，以及詳細榜單信息<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tiobe.com%2Ftiobe-index%2F" target="_blank">均可查看官網</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 03:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270438/tiobe-index-2023012</guid>
            <link>https://www.oschina.net/news/270438/tiobe-index-2023012</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[因 EXT4 數據損壞錯誤，Debian 12.3 推遲發佈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Debian 團隊發佈公告稱，由於 Linux 內核 6.1.64-1 中的<strong> ext4 文件系統出現數據損壞問題</strong>，因此原計劃昨天發佈的 Debian 12.3 將會被推遲，同時進行修復。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-6b960c796ab8ff358469f03578c81866ec1.png" referrerpolicy="no-referrer"></p><p>來源：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.debian.org%2FNews%2F2023%2F2023120902" target="_blank">https://www.debian.org/News/2023/2023120902</a></u></p></blockquote><p>據介紹，此 bug 由從 Linux 6.5 回溯的一個有問題補丁導致，它引起了 EXT4 和 iomap 代碼之間的幹擾，可能導致舊內核上的數據損壞。</p><p>這個問題主要出現在最近的 Linux 6.1 LTS 點版本中，新的 Linux 6.1.66 版本已經回滾了有問題的提交。Debian 的 bug 報告稱這個問題為「非嚴重的數據丟失」，因此應該是可以恢復的。</p><p>但由於 Debian 12.3 原本計劃發佈的內核版本受到了影響，因此被推遲發佈。建議 Debian 12 用戶在 Linux 6.1.66 內核鏡像推出之前不要升級系統。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 03:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270435/debian-12-3-delayed-ext4-corrupt</guid>
            <link>https://www.oschina.net/news/270435/debian-12-3-delayed-ext4-corrupt</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[周鴻禕：有人找我做養豬大模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在 2023 中國企業領袖年會上，360 創始人周鴻禕對於最近的 AI 大模型熱潮發表了看法。</p><p>他表示，（感覺）大家對大模型充滿了一種無限的嚮往或者不切實際的膜拜，之前還有人找他做養豬大模型。他認為，大模型的技術路線突破才短短几年，目前還存在着很多缺點。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-391bf18f540407673913ddee0ac73938969.png" referrerpolicy="no-referrer"></p><p>來源：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2Ftv%2Fshow%2F1034%3A4977511076134973%3Ffrom%3Dold_pc_videoshow" target="_blank">https://weibo.com/tv/show/1034:4977511076134973</a></u></p></blockquote><p>他希望大家對大模型有一個正確的認知，<strong>不要高估現在大模型的能力，不要低估大模型未來發展的潛力</strong>，雖然它現在已經可以跟實體產業相結合，但它還不能完全接管此類業務，應該揚長避短髮揮它的長處，因為很多短板還有待解決。</p><p>目前國內各大企業、科研機構和高校等單位已公開的 AI 大模型至少已經達到了 188 個，而首批通過《生成式人工智能服務管理暫行辦法》備案的大模型已於 8 月 31 日公佈，第二批通過備案的 AI 大模型也已於 11 月開放服務。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3a3b3aaeff5f0043de536b6f5f44b963797.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270430</guid>
            <link>https://www.oschina.net/news/270430</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[理想汽車全自研多模態認知大模型 —— Mind GPT]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>理想汽車於 12 月 10 日晚正式發佈 OTA 5.0 版本，並計劃於 12 月 19 日開啓全量用戶推送。官方介紹稱，在 OTA 5.0 中，理想同學最大的變化是引入了 Mind GPT 的能力。</p><p>Mind GPT 是理想全自研的多模態認知大模型，據稱他們從 0 到 1 構建了 Mind GPT 原始基座模型，<strong>模型結構採用了自研的 TaskFormer 神經網絡架構</strong>，基於用車、娛樂、出行等場景使用 SFT、RLHF 等技術進行了一系列的訓練，讓 Mind GPT 擁有了理解、生成、知識記憶及推理的三大能力。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-7aa6319e367ca499b8541b306ec3892d181.png" referrerpolicy="no-referrer"></p><p>目前 Mind GPT 還處於內測版本階段，那麼 Mind GPT 在行業裏到底是什麼水平呢？</p><p>官方稱在目前國內極具權威性的，中文大語言模型評測榜單 C-EVAL，覆蓋了人文、社科、理工等多個方向共 52 個學科，Mind GPT 在 58 個參加測評的大模型中排行第一名；同時，還有涵蓋從基礎學科到高級專業包含 67 個主題領域的評測榜單 CMMLU，Mind GPT 也獲得第一名，拿下了雙冠軍。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d89ae63875873819f3b3676b6fea16d8c81.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-af86f00982833de97dd852d6a57f17288dd.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 02:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270426</guid>
            <link>https://www.oschina.net/news/270426</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[大灣區一體化算力服務平台正式發佈，算力規模超 5000P]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>12 月 10 日，在第二屆數字政府建設峯會暨數字灣區發展論壇上，深圳市前海管理局、國家（深圳·前海）新型互聯網交換中心（下稱「前海交換中心」）共同<strong>發佈粵港澳大灣區一體化算力服務平台，並正式成立前海算力服務聯盟</strong>。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-e379cb9cc7c4002e4f3fb84f03c47a13c02.png" referrerpolicy="no-referrer"></p></blockquote><p>據介紹，該平台由前海管理局提出設想和要求，在深圳市通管局、市工信局的支持下，由前海交換中心和紫金山實驗室共同開發部署。</p><p>官方透露，該平台自 10 月 31 日試運行以來，匯聚的算力規模大幅增長近 4 倍，<strong>總規模已達 5180 PFLOPS</strong>，主流芯片覆蓋率超 75%，並已為 10 餘個企業、高校、科研機構的人工智能團隊提供算力服務。</p><ul><li><p><strong>在算力調度方面</strong>，創新多維一體編排算法，實現算力高效調度和智能供給；</p></li><li><p><strong>在算力交易方面</strong>，平台不收取中介費用，促進供需雙方合作與交易；</p></li><li><p><strong>在算力應用方面</strong>，高度集成各類算法工具，實現應用一鍵部署、資源秒級開通，進一步降低門檻、提升效率；</p></li><li><p><strong>在算力安全方面</strong>，構建算網一體化安全防護體系，持續強化算力安全保障。</p></li></ul><p><img height="360" src="https://static.oschina.net/uploads/space/2023/1211/102814_wKUa_2720166.png" width="640" referrerpolicy="no-referrer"></p><p>同時， <strong>大灣區首個算力服務行業組織 —— 前海算力服務聯盟正式成立</strong>，首批成員單位包括前海科創集團、前海交換中心、紫金山實驗室、華為、深圳商湯、萬國數據、世紀互聯、深圳數據交易所、深圳科創學院、香港中文大學未來智聯網絡研究院、粵港澳大灣區大數據研究院。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 02:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270418</guid>
            <link>https://www.oschina.net/news/270418</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[郭煒：開源大俠是怎樣煉成的]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 6 月 1 日，首個由國人主導的開源數據集成工具 Apache SeaTunnel 正式宣佈從 Apache 軟件基金會孵化器畢業成為頂級項目。歷經 18 個月的孵化，這個項目終於瓜熟蒂落，社區貢獻者 200+，代碼 24.5 萬行，上千家企業使用，風光無限。令人難以想象，郭煒剛接手它時，倉庫被封、貢獻者四散的落魄樣子。</p><p>&nbsp;</p><span id="OSC_h1_1"></span><h1>大俠出手， SeaTunnel 浴火重生</h1><p>SeaTunnel 原名 Waterdrop，於 2017 年由樂視創建，並於同年在 Github 上開源，是一個大數據集成處理平台。當時國內各種數據引擎風起雲湧，卻少有項目解決數據源之間的無縫集成和高速同步問題，因此 Waterdrop 在其中顯得頗為亮眼。可惜這種亮眼卻為它招來了橫禍——開源項目 Waterdrop 的商標被搶注了，而且對方的法務還發送律師函給開源的發起者和 Github 。</p><p>由於開源項目的名稱不屬於【商標】，而國內的商標又是【申請在先】原則，誰先申請誰先得到，因此 Waterdrop</p><p>一下子百口莫辯，落了下風， Github 在收到律師函後，把 Github 上 Waterdrop 的整個倉庫都封了，所有的代碼、PR、Issue 也全都無法訪問，而且 Waterdrop 的創始團隊還面臨訴訟糾紛。沒辦法，團隊只能在圈內四處求助，機緣巧合之下，遇到了郭煒。</p><p>郭煒，人稱「郭大俠」，平時就愛在開源圈內熱心給大家幫忙。創始團隊找到郭煒後，郭煒看到這樣的事情，又是這樣有前途的項目，不忍心袖手旁觀，他便把項目接了過來，一邊找律師解決法律糾紛，一邊利用自己的資源輾轉聯繫微軟的 Github 管理人員解釋，幫助項目解封。</p><p>2021 年，爭議終於告一段落，Waterdrop 改名 SeaTunnel，得以繼續運轉。可大俠並不放心，畢竟團隊才 3 個人，維護社區已是夠嗆，哪還有能力顧及法律合規的事情？萬一這劇情重來一遍，可就不是鬧着玩的了。郭煒開始當 SeaTunnel 的 Mentor，手把手帶起了開源項目，並致力於把項目孵化到 Apache 基金會裏面。一方面，基金會是專業的，有專人管理法務，比現在的草台班子好多了。另一方面，SeaTunnel 也可以接替退役的 Apache Sqoop，解決數據源之間數據打通的問題。</p><p>最終，在多位導師的幫助下，2021 年 12 月 9 日，SeaTunnel 正式通過 Apache 軟件基金會的投票決議，順利進入 Apache 孵化器，成為基金會中第一個誕生自中國的數據集成平台項目，目標是「連接萬源，同步如飛」。</p><p>如今，SeaTunnel 從 Apache 軟件基金會孵化器畢業成為頂級項目，也在全球擁有很多企業用戶和開發者，早已告別最初的窘迫。郭大俠也輕輕招手，奔赴了下一個難題。</p><p style="text-align:center"><img height="664" src="https://oscimg.oschina.net/oscnet/up-8c5e3b11d68a2569fa44bc1e66d5f395f95.png" width="500" referrerpolicy="no-referrer"></p><p>&nbsp;</p><span id="OSC_h1_2"></span><h1>大俠當年也是開源「小趴菜」</h1><p>SeaTunnel 團隊最初之所以求助郭煒，是因為他成功運營過多個開源社區，在圈內早已小有名氣。時間回撥到 2010 年，郭煒就開始接觸開源了。那時候他在 Hadoop 社區裏當「潛水黨」，以一個小白的身份，旁觀各路大神在裏面交流技術問題，給出」炫酷「的解決方案。「在開源社區裏，你能看到很多全新的項目，全新的技術，能不斷學到新東西，保持走在技術圈的前排，這是別的渠道無法替代的。書上的東西太陳舊了，網上的東西又特別雜，只有在開源社區，才能純粹地瞭解新技術，瞭解開源圈在關注啥。」</p><p>當然，郭煒這樣的「 e 人」不會一直坐邊角。很快他就融入了社區，經常參加線下 meetup，也 contribute 過不少文檔。但在開源社區裏，郭煒這個名字就是一個「 nobody 」。到聯想工作之後，郭煒繼續堅持開源，也把開源帶到了聯想。在聯想 COC 核心技術架構委員會，郭煒作為全球大數據平台負責人，一直在當開源佈道者，推動開源技術的應用，許多同事都是因為他的宣傳才「入坑」的。</p><p>但那時候在企業內部做開源佈道，也是困難重重。首先開源當時並沒有現下這麼火，很多人對開源知之甚少，唯一的印象就是「免費」。其次，習慣了商業軟件的企業，更傾向於沿用原來的選擇，畢竟商業軟件雖然收費，可是有人售後，有人負責。而開源軟件，雖然免費，卻有風險，遇到問題，誰來解決呢？尤其是對於全球化的大公司而言，開源在當地還可能存在法律風險，哪怕這是個「省錢」的決定，想拍板也不容易。</p><p><strong>郭煒坦言，在大企業內部做開源推廣，就是要承擔很多的責任。</strong>説白了就是，這個鍋一開始你得背一背，才能讓一些關鍵的業務用戶用起來。等他們用起來覺得不錯了，你才能壓住質疑，談下一步的推廣。當時為了推廣 Hadoop、Spark 且要符合各國的法務規範，郭煒要跟全球的同事開會，會議從早上六點排到了夜裏兩三點，一遍一遍地跟大家科普這個項目是什麼、怎麼用、出問題怎麼辦、合不合規、為什麼要用它......經過跟業務部門「過五關斬六將」的 battle，最後一個美國的部門率先接受了 Spark，之後因為口碑不錯，才慢慢推廣到了其他國家、其他部門。</p><p>「我們開源社區裏面的每一個用戶都是很珍貴、很不容易的，尤其是那些為剛出來的新開源項目做企業內部推廣的小夥伴，每一個都是勇士。他們在企業內部推廣一項新技術，不僅需要做很多工作，更是拿自己頭上的烏紗帽在為社區佈道、保駕護航。所以，我們關注開源社區，我們不能只看到 contributor、committer、PMC，更要看到我們社區裏的普通用戶、他們的艱辛和不易。」郭煒説，<strong>「其實每一個使用開源的人，都是這個社區的 contributor，他們做了很多的 contribution，只不過沒有體現在代碼上面而已。」</strong></p><p>&nbsp;</p><span id="OSC_h1_3"></span><h1>從開源 User 變 Owner，大俠不好當</h1><p>2016 年，郭煒加入易觀，擔任 CTO（首席技術官）。當時公司在做一款用戶行為分析的產品，主要依靠 Presto 進行二次修改來適配場景。有一天，郭煒正在網上閒逛，突然發現有個新項目，跟自家產品的場景有點像。於是就測試了一下，結果發現比自家產品快 10 倍！郭煒一下子就被震驚了。</p><p><strong>這個項目就是 ClickHouse，俄羅斯的 Yandex 於 2016 年開源的</strong><strong>列式存儲數據庫</strong><strong>（</strong><strong>DBMS</strong><strong>），主要用於在線分析處理查詢（</strong><strong>OLAP</strong><strong>），能夠使用 </strong><strong>SQL</strong><strong> 查詢實時生成分析數據報告。</strong></p><p>郭煒自問在數據技術圈已屬「先鋒達人」，各種研究都是隨時關注的，可即便這樣也沒聽説過這個項目，想來其他人知道它的概率就更低了。這樣的好東西，怎麼能忍住不分享呢？於是，郭煒聯繫了 ClickHouse 的全球社區負責人 Ivan，提出幫忙運營中國的社區。ClickHouse 同意了。</p><p>但是，萬事開頭難，從 0 到 1 新建一個開源社區，就更難。沒人知道你是誰，沒人願意用你。郭煒訪談了早期快手、新浪用戶，並組建了社區羣。但是這第一個羣，花了一年半的時間才湊滿。線下社區的人就更少了，第一次 ClickHouse meetup，才來了 11 個人。</p><p>由於這是屬於個人愛好的行為，ClickHouse 的各種運營活動都得自己做。日常的建羣、驗證、答疑、指導等等，都是下班和週末抽空完成的，每天晚上 11 點，就是郭煒的 ClickHouse 支持時間。最開始的時候，還要到每個羣裏手把手教大家 ClickHouse 怎麼用、怎麼裝、怎麼配？週末還要找到一些關鍵用戶，跟他們聊天、吃飯，把他們組織起來，邀請他們來參加線下的組局等等。</p><p>「<strong>做開源不是到各種大會上去講一講就完了，</strong><strong>開源</strong><strong>布</strong><strong>道師</strong><strong>高光背後其實是無數的日常瑣碎。</strong>想要運營好一個社區是很繁瑣的，比方説羣裏有人發廣告，你得把他踢出去；有人在裏邊吵架了，你要怎麼維護？有人向社區扔臭雞蛋了，你怎麼判斷是不是開源項目的問題？如果項目有問題，我們怎麼樣虛心接受？這些都是在社區維護裏面要去做的事。一點一滴長年累月的積累，才能真的把社區這件事做好。」郭煒説，「你看前 Apache 的董事會主席 Craig，這樣的頂級大佬，都 70 多歲了，還在基金會裏做 secretary 給大家建 Apache 的賬號，你就知道社區運營有多瑣碎了。在哪裏都一樣的。」</p><p>所幸，在這條路上，郭煒不是一個人在戰鬥。隨着 ClickHouse 用戶的增加，社區隊伍也愈發壯大了。微信羣達到 10 個的時候，郭煒開始招募志願者，幫忙處理羣事務。線下的 meetup，一開始一二十人，在公司找個會議室就能辦。後來發展到線下兩三百人，線上一千多人，普通場地都裝不下了，郭煒就到處找朋友借場地，再自掏腰包飛過去組織。有一次在上海的 Meetup，報名的有 300 多人，但是找不到 Meetup 的地方，當時的趣頭條大數據負責人金海就找公司幫忙提供了一個酒店，有布台，有大屏，有 4 個 session，跟開源大會一樣。還有當年在閲文集團的劉文成，是 ClickHouse 的小 C，幫忙回答各種問題。在這些貢獻者的幫助下，ClickHouse 中國社區終於辦上了正規的 meetup。</p><p style="text-align:center"><img height="898" src="https://oscimg.oschina.net/oscnet/up-3c53346abc745644c05c6c876f2b686ccc7.png" width="1860" referrerpolicy="no-referrer"></p><p>三年後的 2019 年，ClickHouse 爆火，截至目前，ClickHouse 仍是 OLAP 方面用戶最多的社區。在整個社區裏，中國用戶也是最多的。頭條、阿里等企業用戶也相繼加入。在這一年的 meetup，社區邀請了俄羅斯 Yandex 公司 ClickHouse 開源社區創始人 Alexey Milovidov，他説：<strong>「中國的 ClickHouse 用戶量能取得這樣爆發性的增長（一個季度內用戶增長了四倍），離不開 William（郭煒）在中國的推廣。」</strong><strong></strong></p><p>&nbsp;</p><span id="OSC_h1_4"></span><h1>功成不在我，失敗猶更多</h1><p>能得到 ClickHouse 創始人的認可，郭煒很開心。不過他還是覺得，ClickHouse 能達到現在的程度，與其説是因為他這個推動者，不如説是因為這個產品本身的優秀和中國開源小夥伴們的支持。「在數據和大數據領域裏，中國對開源的接受程度和開源的使用速度在全球都是最快的，比美國還要快。這得益於中國互聯網的發展速度，和大量互聯網公司的使用。也許開源商業的天花板沒有美國那麼高，但是中國捲起來的速度更快。<strong>中國往往能快速接受一個新技術，然後快速卷，快速迭代，加上中國有廣大的開發者和用戶基礎，做起開源來有得天獨厚的優勢。</strong>」</p><p>現在回頭看，這四五年裏，郭煒自己和小夥伴們，都受益良多。當初跟他一起在社區裏改代碼的小夥伴們，現在薪資都翻了四五倍了。其中一個志願者小 C 劉文成，被騰訊選中，從一個小廠跳槽到了微信裏面做 ClickHouse 的維護。「人人為我，我為人人。你在社區裏面做的貢獻，大家都是看得見的。你的技術水平被大家認可了，那你獲得的機會自然也會比別人多。<strong>我覺得這就是開源社區的魅力吧，在這裏大家都是平等的，是金子很快就會發光。</strong>這也算是對社區貢獻者的一種回報吧。只不過這種回報不是金錢上的，而是別人對你的認可和你的影響力上的。」郭煒説。</p><p>當然，也不是所有的開源項目都能像 ClickHouse 那麼幸運。大俠也會遇到挫折，運營的開源項目中失敗的更多，有好多開源項目親自運營了兩三年，star 數才十幾個。自己做開源項目，哪有那麼容易成功呢？「犯錯沒關係，犯的錯誤多了你積累的經驗也會多。你看我現在做產品能成功，背後反而是那些失敗的經驗在發揮作用。做其他事也一樣。」郭煒兩手一攤，「因為每個人的成功，都有當時特殊的時代背景和需求，所以成功的經驗，反而不重要，失敗的經驗更重要，它才能指導你怎麼避免犯錯。所以每一個成功的背後，可能都有 99 個失敗，只不過大家最後只能看到那 1 個成功的而已。」</p><p>經過無數失敗的郭煒，也鍛煉出了自己看項目的眼光。「<strong>我覺得做開源社區，最關鍵的是要看準這個產品的定位：它到底解決什麼問題，用什麼樣的技術框架？如果真的看好這個社區的發展的話，就到裏面去跟社區一起成長好了。」</strong>郭煒説，「產品有 bug 沒關係，每個社區都不是完美的，當初 ClickHouse 也有各種各樣的問題，但只要你把大的架構定好之後，剩下的細節就在這個基礎上去迭代、去完善就好了。ClickHouse 當時解決的其實就是寬表和日誌查詢問題，就這一件事。然後它把當時最新的技術——向量計算，直接放到引擎裏，速度就是比我原來的 Presto 快十倍。它就解決這個問題，且解決得最好，所以在社區也能發展得很好。」</p><p><strong>看準了產品思路、底層邏輯和創始團隊之後，剩下的事情就是堅持了。</strong>「 ClickHouse 2016 年剛剛開源的時候，我就把它引進中國了，那時候還默默無聞，直到 2019 年才爆火。前面這幾年，完全就是靠熬過去的。你要相信你的眼光，持續堅持，不能半途而廢。有時候一個開源社區最後能不能成功，就看你堅持的時間夠不夠長了。」郭煒説，「等到社區真的成長起來，影響力足夠大的時候，裏面的每一個小夥伴都會受益。」</p><p>&nbsp;</p><span id="OSC_h1_5"></span><h1>多重身份，在開源與商業間做平衡</h1><p>2022 年 4 月，Ted Liu（劉天棟）突然來通知郭煒：我們提名你做 Apache Software Foundation（ASF）Member，你寫個材料吧！就這樣，郭煒成了 Apache 基金會 Member。「收到這個榮譽的時候，特別開心，覺得這是大家對我的肯定，同時覺得自己身上的責任更重了，也更有動力去考察和維護好 Apache 的每一個項目。」</p><p>而在 2023 年，郭煒身上又多了一個身份，白鯨開源的 CEO。很少有人同時當基金會 Member 和商業公司的領導人，郭煒會不會覺得衝突呢？做決策的時候，是先考慮開源還是商業化？如果開源和商業化功能打架，大俠不就很難辦？</p><p>不過，郭煒對此很淡定，他認為，開源和商業化並不衝突，甚至是相輔相成的。<strong>一個開源項目如果想長治久安可持續</strong><strong>發展</strong><strong>，那商業化大概是不可避免的。</strong>如果沒有商業公司去承接對核心開發者和貢獻者的支持，去滿足深度用戶的需求，久而久之，純靠愛發電的核心貢獻者可能也會難以為繼。</p><p>「像白鯨開源這樣做（Apache SeaTunnel 和 DolphinScheduler）商業化的公司，不是開源的對立面，而是開源的促進者。」郭煒説，「商業能夠更好地保住開源的調性和核心貢獻者的飯碗，讓他們能夠持續地在開源上發力。同樣地，有些深度的用戶，當開源項目無法完全滿足他的需求，或者需要有人幫他在企業內部做推廣的時候，有一個商業實體來幫他一起做這件事，那這個佈道師也會輕鬆一點，而不必像我當初那樣獨自一個人舌戰羣儒，過五關斬六將。」</p><p>可是，開源項目之所以商業化困難，恰恰是因為公開了代碼。商業和開源究竟如何取捨？哪些應該開源，哪些不開源？遇到衝突的時候，又該如何抉擇？</p><p>郭煒笑笑，露了一手聰明的「切糕大法」：「首先從產品定位來講，你得把你的開源主力用戶羣和你的非開源主力用戶羣分開——如果技術水平很強，而且自己還有時間有預算去折騰，那就用開源的好了。如果時間不夠，人力預算又不足，那使用商業版更省心。所以，這兩者的使用人羣是不同的，你的開源軟件和商業軟件定位也不一樣。明白了這個，你糾結的點也就沒那麼多了。」</p><p>按照慣例，最新的功能都會被放到開源版裏面，相對穩定的、有行業屬性的功能則通常放到商業版裏，兩邊不時互通有無。郭煒要做的，就是把握好兩邊放功能的時間和節奏就行了。「至於具體哪些功能放到商業版、哪些功能放到開源版，這就是刀法怎麼切的問題了：切得少了，你這個商業版沒有價值；切多了，又會影響社區。那怎麼來把握，就是一門藝術而不是技術了，這隻可意會不可言傳哪（笑~）」</p><p>總的來説，郭煒對中國的開源商業環境非常看好。畢竟中國對開源的接受程度很高。雖然從開源社區到商業公司和商業產品這一條路大家還在摸索，但至少，郭煒接觸到的新一代決策者，已經跟過去不一樣了：他們明白開源會讓公司的技術和國際接軌、和全球最新的科技接軌。無論是傳統公司還是互聯網企業，都在逐步嘗試使用開源原生的商業軟件。</p><p>「中國開源商業的氛圍和整體的步伐，正在覺醒。」甚至中國開源走向全球，郭煒也覺得大有希望：「畢竟中國有這麼好的土壤，特別在大數據領域裏，有這麼多的數據、終端、場景、性能......卷出來的項目，它一定是全球排名前列的，最終跟海外商業場景相結合，一定能賣得很好。」</p><p>&nbsp;</p><span id="OSC_h1_6"></span><h1>開源老將，在醞釀下一個社區</h1><p>在開源圈裏，郭大俠也有自己的偶像：「Craig 給我做了一個榜樣，他都 70 多了還在堅持為開源做貢獻，我覺得我活到 70 歲時候也能繼續做開源，他就是我的榜樣。哈哈。」</p><p>活到老學到老，這也許不止是郭煒一個人的開源理想，但至少，郭煒堅持到了現在。</p><p>如今，作為開源老將，郭煒又在關注下一個熱點了——大模型，特別是開源的大模型。「我認為將來的每一款軟件，都會被大模型和相關的 AI 技術再改造一遍、重做一遍。下一步如果再去孵化項目，可能就是跟大模型相關的了。」郭煒説，「如果只是訓練大模型，那麼國內外只有寥寥幾家公司能玩得起。但是大模型生態上下游的公司如果要做好，還是有很多機會的。那麼，哪些東西能夠促進大模型的應用、降低大模型的使用門檻、讓大模型真正跑起來，尤其是大模型跟數據之間的關聯，將會是我關注的重點。」</p><p>郭大俠收拾行囊，又奔赴了下一場挑戰。</p><p>不知道接下來，他又會遇到怎樣的故事呢？</p><div style="text-align:center"><img height="750" src="https://oscimg.oschina.net/oscnet/up-5203b04a5dc96550855c4bae1487b99f11a.png" width="500" referrerpolicy="no-referrer"></div><div>
  &nbsp; 
</div><div>
  &nbsp; 
</div><div><blockquote><div><span style="color:#16a085"><strong><span style="background-color:#f6f6f6">【溯源】</span><span style="background-color:#f6f6f6">在每一場對話中，追溯關於開源的故事，認識那些極客、自由，並堅持着的開源人。</span></strong></span></div></blockquote><p style="color:#494949; margin-left:0; margin-right:0; text-align:left"><span><span>OSCHINA 推出的開源人物專訪欄目【溯源】。</span></span></p><p style="color:#494949; margin-left:0; margin-right:0; text-align:left"><span><span>溯源，意指向源頭追溯，為開源求解。問渠哪得清如許，為有源頭活水來。每一個開源參與者，都是掀起開源浪潮最鮮活的源泉。所有開源故事，共同構建着我們今天看到的開源世界。</span></span></p><p style="color:#494949; margin-left:0; margin-right:0; text-align:left"><span><span>開源剛出現的數十年裏，為開源奔走的黑客團體都在遭受來自社會主流的冷漠和排斥。即便現在的軟件行業已經大喊出 「擁抱開源」 的口號，問題也依然存在。</span></span></p><p style="color:#494949; margin-left:0; margin-right:0; text-align:left"><span><span>我們不知道開源貢獻者、開源佈道師，以及所有參與開源的人還會面臨多少阻礙，但給予我們信心的是，更多的人在投身開源事業。</span></span></p><p style="color:#494949; margin-left:0; margin-right:0; text-align:left"><span><span>所以 OSCHINA 希望面向開發者社區，尋找每一個積極參與開源、對開源有想法的人，瞭解他們以及他們的開源故事，窺探故事中的開源事業發展規律。</span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">【溯源】系列文章：</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">01&nbsp;<a href="https://my.oschina.net/u/4105562/blog/4721676"><span style="background-color:#ffffff; color:#494949">適兕</span><span>&nbsp;</span>：成為開源佈道師</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">02&nbsp;<a href="https://my.oschina.net/u/4489239/blog/4875125">衞劍釩：開源圈的 「世外高手」</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">03&nbsp;<a href="https://my.oschina.net/u/4489239/blog/4945872" target="_blank">「工具人」 趙生宇：清北本碩，為開源從阿里辭職去同濟讀博</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">04&nbsp;<a href="https://my.oschina.net/u/4489239/blog/5047833" target="_blank">吳晟：開源對我來説，社交是最重要的</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">05&nbsp;<a href="https://my.oschina.net/u/4489239/blog/6215354" target="_blank">悟空劉歧：技術瑕疵不除不快，開源社區代碼説話</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">06&nbsp;<a href="https://my.oschina.net/u/3859945/blog/5504643" target="_blank">姜寧，帶程序員前往開源 「烏託邦」</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">【溯源】專欄正在徵集開源人物故事，如果你認為自己或是身邊的人對開源做出過獨特貢獻，歡迎留言評論，讓我們聽聽 TA 的故事。</p></div></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6852546/blog/10320168</guid>
            <link>https://my.oschina.net/u/6852546/blog/10320168</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[phpy —— Python 與 PHP 互調用庫]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>phpy 是<code>Python</code>與<code>PHP</code>互調用庫，可以在<code>PHP</code>中使用<code>Python</code>語言的函數和類庫，或者在<code>Python</code>中使用<code>PHP</code>的包。 但不是語言內嵌。編碼依然使用各自的原生語法。</p><p><code>phpy</code>使得<code>PHP</code>可以調用所有<code>Python</code>的包，包括當下非常流行的<code>PyTorch</code>、<code>transformers</code>、<code>TensorFlow</code>等<code>AI</code>庫，以及<code>Numpy</code>、<code>Pandas</code>、<code>Scikit</code>等科學計算庫，還可以使用<code>PyQt</code>、<code>wxPython</code>等圖形界面庫。</p><ul><li>目前僅支持 Linux 平台（理論上可以支持所有操作系統，待實現）</li><li>不支持 Python 多線程、<code>async-io</code>特性</li></ul><h2>PHP 調用 Python</h2><p>編譯安裝<code>phpy.so</code>作為擴展加載，修改<code>php.ini</code>追加<code>extension=phpy.so</code>即可。</p><p>例子：</p><pre><code>$os = PyCore::import("os");
$un = $os-&gt;uname();
echo strval($un);</code></pre><h2>Python 中調用 PHP</h2><p>直接作為<code>C++ Mudule</code>，import 加載即可。</p><pre><code>import phpy

content = phpy.call('file_get_contents', 'test.txt')

o = phpy.Object('redis')
assert o.call('connect', '127.0.0.1', 6379)
rdata = phpy.call('uniqid')
assert o.call('set', 'key', rdata)
assert o.call('get', 'key') == rdata</code></pre><h2>實現原理</h2><p>在進程內同時創建了<code>ZendVM</code>和<code>CPython VM</code>，直接在進程堆棧空間內使用<code>C</code>函數互相調用， 開銷只有<code>zval &lt;-&gt; PyObject</code>結構體轉換，因此性能是非常高的。</p><h2 style="margin-left:0; margin-right:0; text-align:left">實際案例</h2><h3 style="margin-left:0; margin-right:0; text-align:left">基於<span>&nbsp;</span><code>tkinter</code><span>&nbsp;</span>實現<span>&nbsp;</span><code>GUI</code><span>&nbsp;</span>的例子</h3><div style="text-align:left"><pre style="margin-left:0; margin-right:0"><code class="language-php"><span><span><span style="color:#6a737d">&lt;?</span></span></span><span><span><span style="color:#6a737d">php</span></span></span><span></span><span style="color:#056de8"><span>$tkinter</span></span><span></span><span><span>=</span></span><span></span><span><span>PyCore</span></span><span><span>::</span></span><span style="color:#056de8"><span>import</span></span><span><span>(</span></span><span style="color:#f1403c"><span><span style="color:#032f62">'tkinter'</span></span></span><span><span>);</span></span><span></span><span style="color:#056de8"><span>$root</span></span><span></span><span><span>=</span></span><span></span><span style="color:#056de8"><span>$tkinter</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>Tk</span></span><span><span>();</span></span><span></span><span style="color:#056de8"><span>$root</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>title</span></span><span><span>(</span></span><span style="color:#f1403c"><span><span style="color:#032f62">'我的窗口'</span></span></span><span><span>);</span></span><span></span><span style="color:#056de8"><span>$root</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>geometry</span></span><span><span>(</span></span><span style="color:#f1403c"><span><span style="color:#032f62">"500x500"</span></span></span><span><span>);</span></span><span></span><span style="color:#056de8"><span>$root</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>resizable</span></span><span><span>(</span></span><span><span><span style="color:#d73a49">False</span></span></span><span><span>,</span></span><span></span><span><span><span style="color:#d73a49">False</span></span></span><span><span>);</span></span><span></span><span style="color:#056de8"><span>$button</span></span><span></span><span><span>=</span></span><span></span><span style="color:#056de8"><span>$tkinter</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>Button</span></span><span><span>(</span></span><span style="color:#056de8"><span>$root</span></span><span><span>,</span></span><span></span><span><span>text</span></span><span><span>:</span></span><span></span><span style="color:#f1403c"><span><span style="color:#032f62">"Click Me!!"</span></span></span><span><span>,</span></span><span></span><span><span>command</span></span><span><span>:</span></span><span></span><span><span>PyCore</span></span><span><span>::</span></span><span style="color:#056de8"><span>fn</span></span><span><span>(</span></span><span><span><span><span style="color:#d73a49">function</span></span></span></span><span><span></span></span><span><span><span><span>()</span></span></span></span><span><span></span></span><span><span>{</span></span><span></span><span><span>var_dump</span></span><span><span>(</span></span><span><span>func_get_args</span></span><span><span>());</span></span><span></span><span><span><span style="color:#d73a49">echo</span></span></span><span></span><span style="color:#f1403c"><span><span style="color:#032f62">'click me!!'</span></span></span><span></span><span><span>.</span></span><span></span><span><span>PHP_EOL</span></span><span><span>;</span></span><span></span><span><span>}));</span></span><span></span><span style="color:#056de8"><span>$button</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>pack</span></span><span><span>();</span></span><span></span><span style="color:#056de8"><span>$tkinter</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>mainloop</span></span><span><span>();</span></span></code></pre></div><div style="text-align:left"><img src="https://static.oschina.net/uploads/img/202312/09171840_0Wzd.jpg" referrerpolicy="no-referrer"></div></div>
                                                                ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 01:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/phpy</guid>
            <link>https://www.oschina.net/p/phpy</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 開源基礎密碼庫，銅鎖/Tongsuo]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-概述" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E6%A6%82%E8%BF%B0"></a>概述</h1><p>銅鎖/Tongsuo 是一個提供現代密碼學算法和安全通信協議的開源基礎密碼庫，為存儲、網絡、密鑰管理、隱私計算等諸多業務場景提供底層的密碼學基礎能力，實現數據在傳輸、使用、存儲等過程中的私密性、完整性和可認證性，為數據生命週期中的隱私和安全提供保護能力。</p><p>銅鎖獲得了國家密碼管理局商用密碼檢測中心頒發的商用密碼產品認證證書，助力用戶在國密改造、密評、等保等過程中，更加嚴謹地滿足我國商用密碼技術合規的要求。可在<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fmisc%2Fst247r05s8b5dtct">此處</a>下載資質原始文件。</p><img src="https://github.com/Tongsuo-Project/Tongsuo/blob/master/validation-android.png" width="50%" height="50%" referrerpolicy="no-referrer"><h1><a id="user-content-特性" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E7%89%B9%E6%80%A7"></a>特性</h1><p>銅鎖提供如下主要的功能特性：</p><ul><li>技術合規能力
<ul><li>符合 GM/T 0028《密碼模塊安全技術要求》的"軟件密碼模塊安全一級"資質</li><li>符合 GM/T 0005-2021《隨機性檢測規範》</li></ul></li><li>零知識證明（ZKP）
<ul><li>Bulletproofs range</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fts%2Fbulletproofs">Bulletproofs R1CS</a></li></ul></li><li>密碼學算法
<ul><li>中國商用密碼算法：SM2、SM3、SM4、<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fts%2Fcopzp3">祖沖之</a>等</li><li>國際主流算法：ECDSA、RSA、AES、SHA 等</li><li>同態加密算法：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fmisc%2Fec-elgamal">EC-ElGamal</a>、<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fmisc%2Frdibad">Paillier</a>等</li><li>後量子密碼學*：Kyber、Dilithium 等</li></ul></li><li>安全通信協議
<ul><li>支持 GB/T 38636-2020 TLCP 標準，即<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fts%2Fhedgqf">雙證書國密</a>通信協議</li><li>支持<a href="https://gitee.com/link?target=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc8998">RFC 8998</a>，即 TLS 1.3 +<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fts%2Fgrur3x">國密單證書</a></li><li>支持<a href="https://gitee.com/link?target=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc9000">QUIC</a> API</li><li>支持<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fts%2Fleubbg">Delegated Credentials</a>功能，基於<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.ietf.org%2Farchive%2Fid%2Fdraft-ietf-tls-subcerts-10.txt">draft-ietf-tls-subcerts-10</a></li><li>支持<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fts%2Fdf5pyi">TLS 證書壓縮</a></li><li>支持緊湊 TLS 協議*</li></ul></li></ul><p>注：*號表示正在支持中</p><h1><a id="user-content-典型應用" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"></a>典型應用</h1><p>開源應用（Opensource Application）</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fangie.software%2Fen%2F">Angie</a>, Angie 是一個可以替換掉 NGINX 的新型 Web 服務器，我們建議使用銅鎖的用戶優先選擇 Angie (We highly recommend you to replace NGINX with Angie to enable Tongsuo's functionality)</li><li>Apache APISIX</li><li>Tengine</li></ul><p>商業應用 (Commercial Application)</p><ul><li>支付寶 App</li><li>OceanBase 數據庫</li><li>阿里雲</li><li>天威誠信</li></ul><h1><a id="user-content-編譯和安裝" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85"></a>編譯和安裝</h1><p>一般來説，典型的編譯和安裝過程如下：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">./config --prefix=/path/to/install/dir</span><span id="LC2" class="line">make</span><span id="LC3" class="line">make install</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如果是 Windows，則需要：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">perl Configure enable-ntls</span><span id="LC2" class="line">nmake</span><span id="LC3" class="line">nmake install</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>以上將會安裝銅鎖的頭文件、library 文件和銅鎖二進製程序。如果需要在獨立的 build 目錄中編譯銅鎖以保證源代碼倉庫的整潔，則可以：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">cd tongsuo-build</span><span id="LC2" class="line">/path/to/Tongsuo/source/config --prefix=/path/to/dest</span><span id="LC3" class="line">make</span><span id="LC4" class="line">make install</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>目前銅鎖支持的操作系統有：各種 Linux 發行版、macOS、Android、iOS 和 Windows。在這些操作系統上，還需要事先準備好對應的環境：</p><ul><li>make</li><li>Perl 5，以及 Text::Template 模塊</li><li>C 編譯器</li><li>C 庫</li></ul><p>銅鎖對第三方庫的依賴很少，但是目前依然對 Perl 依賴較大。</p><p>如果希望執行自動化測試用例，則需：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">make test</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>在安裝的時候，可以選擇只安裝 library 文件：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">make install_runtime_libs</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如果還需要安裝頭文件以便於基於銅鎖開發應用程序，則可以：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">make install_dev</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>也可以只安裝銅鎖二進製程序和其依賴的銅鎖 library 文件：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">make install_programs</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>銅鎖的 Configure 腳本提供了大量的用於開關各種特性的選項。一般來講，使用<code>enable-xxx</code>做為對某個特性的開啓，而使用<code>no-xxx</code>來關閉某個特性。例如，<code>enable-ntls</code>即開啓 TLCP，而<code>no-rsa</code>則是不編譯 RSA 算法。</p><h1><a id="user-content-文檔" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E6%96%87%E6%A1%A3"></a>文檔</h1><p>銅鎖的相關文檔組織在 <a href="https://gitee.com/link?target=https%3A%2F%2Fyuque.com%2Ftsdoc">銅鎖文檔網站</a> 上。</p><h1><a id="user-content-交流羣" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E4%BA%A4%E6%B5%81%E7%BE%A4"></a>交流羣</h1><p>銅鎖使用釘釘羣進行用戶答疑和交流，歡迎掃碼入羣（也可直接搜索羣號：44810299）：
<img src="https://github.com/Tongsuo-Project/Tongsuo/blob/master/tongsuo-dingtalk.jpg" width="50%" height="50%" referrerpolicy="no-referrer"></p><h1><a id="user-content-報告安全缺陷" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E6%8A%A5%E5%91%8A%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7"></a>報告安全缺陷</h1><p>銅鎖目前使用螞蟻集團的威脅蒐集系統，請訪問如下地址進行安全缺陷的報告：</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fsecurity.alipay.com%2F">https://security.alipay.com/</a></li></ul><p>注意：對於非安全相關的 Bug，請使用 GitHub 的 Issues 進行提交。</p>]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 01:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/babassl/Tongsuo</guid>
            <link>https://gitee.com/babassl/Tongsuo</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 併發情況如何實現加鎖來保證數據一致性？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1>單體架構下鎖的實現方案</h1><span id="OSC_h3_2"></span><h3>1. ReentrantLock 全局鎖</h3><p>ReentrantLock（可重入鎖），指的是一個線程再次對已持有的鎖保護的臨界資源時，重入請求將會成功。</p><p>簡單的與我們常用的 Synchronized 進行比較：</p><table><thead><tr><th>&nbsp;</th><th><strong>ReentrantLock</strong></th><th><strong>Synchronized</strong></th></tr></thead><tbody><tr><td><strong>鎖實現機制</strong></td><td>依賴 AQS</td><td>監視器模式</td></tr><tr><td><strong>靈活性</strong></td><td>支持響應超時、中斷、嘗試獲取鎖</td><td>不靈活</td></tr><tr><td><strong>釋放形式</strong></td><td>必須顯示調用 unlock() 釋放鎖</td><td>自動釋放監視器</td></tr><tr><td><strong>鎖類型</strong></td><td>公平鎖 &amp; 非公平鎖</td><td>非公平鎖</td></tr><tr><td><strong>條件隊列</strong></td><td>可關聯多個條件隊列</td><td>關聯一個條件隊列</td></tr><tr><td><strong>可重入性</strong></td><td>可重入</td><td>可重入</td></tr></tbody></table><p><strong>AQS 機制</strong>：如果被請求的共享資源空閒，那麼就當前請求資源的線程設置為有效的工作線程，將共享資源通過 CAS<code>compareAndSetState</code>設置為鎖定狀態；如果共享資源被佔用，就採用一定的阻塞等待喚醒機制（CLH 變體的 FIFO 雙端隊列）來保證鎖分配。</p><p><strong>可重入性</strong>：無論是公平鎖還是非公平鎖的情況，加鎖過程會利用一個 state 值</p><pre><code>private volatile int state

</code></pre><ul><li>state 值初始化的時候為 0，表示沒有任何線程持有鎖</li><li>當有線程來請求該鎖時，state 值會自增 1，同一個線程多次獲取鎖，就會多次+1，這就是可重入的概念</li><li>解鎖也是對 state 值自減 1，一直到 0，此線程對鎖釋放。</li></ul><pre><code>public class LockExample {

    static int count = 0;
    static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {

        Runnable runnable = new Runnable() {
            @Override
            public void run() {

                try {
                    // 加鎖
                    lock.lock();
                    for (int i = 0; i &lt; 10000; i++) {
                        count++;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                finally {
                    // 解鎖，放在 finally 子句中，保證鎖的釋放
                    lock.unlock();
                }
            }
        };

        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println("count: " + count);
    }
}

/**
 * 輸出
 * count: 20000
 */

</code></pre><span id="OSC_h3_3"></span><h3>2. Mysql 行鎖、樂觀鎖</h3><p>樂觀鎖即是無鎖思想，一般都是基於 CAS 思想實現的，而在 MySQL 中通過 version 版本號 + CAS 無鎖形式實現樂觀鎖；例如 T1，T2 兩個事務一起併發執行時，當 T2 事務執行成功提交後，會對 version+1，所以 T1 事務執行的 version 條件就無法成立了。</p><p>對 sql 語句進行加鎖以及狀態機的操作，也可以避免不同線程同時對 count 值訪問導致的數據不一致問題。</p><pre><code>// 樂觀鎖 + 狀態機
update
    table_name
set
    version = version + 1,
    count = count + 1
where
    id = id AND version = version AND count = [修改前的 count 值];

// 行鎖 + 狀態機
 update
    table_name
set
    count = count + 1
where
    id = id AND count = [修改前的 count 值]
for update;

</code></pre><span id="OSC_h3_4"></span><h3>3. 細粒度的 ReetrantLock 鎖</h3><p>如果我們直接採用 ReentrantLock 全局加鎖，那麼這種情況是一條線程獲取到鎖，整個程序全部的線程來到這裏都會阻塞；但是我們在項目裏面想要針對每個用戶在操作的時候實現互斥邏輯，所以我們需要更加細粒度的鎖。</p><pre><code>public class LockExample {
    private static Map&lt;String, Lock&gt; lockMap = new ConcurrentHashMap&lt;&gt;();
    
    public static void lock(String userId) {
        // Map 中添加細粒度的鎖資源
        lockMap.putIfAbsent(userId, new ReentrantLock());
        // 從容器中拿鎖並實現加鎖
        lockMap.get(userId).lock();
    }
    public static void unlock(String userId) {
        // 先從容器中拿鎖，確保鎖的存在
        Lock locak = lockMap.get(userId);
        // 釋放鎖
        lock.unlock();
    }
}

</code></pre><p><strong>弊端</strong>：如果每一個用戶請求共享資源，就會加鎖一次，後續該用戶就沒有在登錄過平台，但是鎖對象會一直存在於內存中，這等價於發生了內存泄漏，所以鎖的超時和淘汰機制機制需要實現。</p><span id="OSC_h3_5"></span><h3>4. 細粒度的 Synchronized 全局鎖</h3><p>上面的加鎖機制使用到了鎖容器<code>ConcurrentHashMap</code>，該容易為了線程安全的情況，多以底層還是會用到<code>Synchronized</code>機制，所以有些情況，使用 lockMap 需要加上兩層鎖。</p><p>那麼我們是不是可以直接使用<code>Synchronized</code>來實現細粒度的鎖機制</p><pre><code>public class LockExample {
    public static void syncFunc1(Long accountId) {
        String lock = new String(accountId + "").intern();

        synchronized (lock) {

            System.out.println(Thread.currentThread().getName() + "拿到鎖了");
            // 模擬業務耗時
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            System.out.println(Thread.currentThread().getName() + "釋放鎖了");
        }
    }

    public static void syncFunc2(Long accountId) {
        String lock = new String(accountId + "").intern();

        synchronized (lock) {

            System.out.println(Thread.currentThread().getName() + "拿到鎖了");
            // 模擬業務耗時
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            System.out.println(Thread.currentThread().getName() + "釋放鎖了");
        }
    }

    // 使用 Synchronized 來實現更加細粒度的鎖
    public static void main(String[] args) {
        new Thread(()-&gt; syncFunc1(123456L), "Thread-1").start();
        new Thread(()-&gt; syncFunc2(123456L), "Thread-2").start();
    }
}

/**
 * 打印
 * Thread-1 拿到鎖了
 * Thread-1 釋放鎖了
 * Thread-2 拿到鎖了
 * Thread-2 釋放鎖了
 */

</code></pre><ul><li>從代碼中我們發現實現加鎖的對象其實就是一個與用戶 ID 相關的一個字符串對象，這裏可能會有疑問，我每一個新的線程進來，new 的都是一個新的字符串對象，只不過字符串內容一樣，怎麼能夠保證可以安全的鎖住共享資源呢；</li><li>這其實需要歸功於後面的<code>intern()</code>函數的功能；</li><li><code>intern()</code>函數用於在運行時將字符串添加到堆空間中的字符串常量池中，如果字符串已經存在，返回字符串常量池中的引用。</li></ul><span id="OSC_h1_6"></span><h1>分佈式架構下鎖的實現方案</h1><p><strong>核心問題</strong>：我們需要找到一個多個進程之間所有線程可見的區域來定義這個互斥量。</p><p>一個優秀的分佈式鎖的實現方案應該滿足如下幾個特性：</p><ol><li>分佈式環境下，可以保證不同進程之間的線程互斥</li><li>同一時刻，同時只允許一條線程成功獲取到鎖資源</li><li>保證互斥量的地方需要保證高可用性</li><li>要保證可以高性能的獲取鎖和釋放鎖</li><li>可以支持同一線程的鎖重入性</li><li>具備合理的阻塞機制，競爭鎖失敗的線程要有相應的處理方案</li><li>支持非阻塞式的獲取鎖。獲取鎖失敗的線程可以直接返回</li><li>具備合理的鎖失效機制，如超時失效等，可以確保避免死鎖情況出現</li></ol><span id="OSC_h3_7"></span><h3>Redis 實現分佈式鎖</h3><ul><li>redis 屬於中間件，可獨立部署；</li><li>對於不同的 Java 進程來説都是可見的，同時性能也非常可觀</li><li>依賴與 redis 本身提供的指令<code>setnx key value</code>來實現分佈式鎖；區別於普通<code>set</code>指令的是隻有當 key 不存在時才會設置成功，key 存在時會返回設置失敗</li></ul><p>代碼實例：</p><pre><code>// 扣庫存接口
@RequestMapping("/minusInventory")
public String minusInventory(Inventory inventory) {
    // 獲取鎖
    String lockKey = "lock-" + inventory.getInventoryId();
    int timeOut = 100;
    Boolean flag = stringRedisTemplate.opsForValue()
            .setIfAbsent(lockKey, "竹子-熊貓",timeOut,TimeUnit.SECONDS);
    // 加上過期時間，可以保證死鎖也會在一定時間內釋放鎖
    stringRedisTemplate.expire(lockKey,timeOut,TimeUnit.SECONDS);
    
    if(!flag){
        // 非阻塞式實現
        return "服務器繁忙...請稍後重試！！！";
    }
    
    // ----只有獲取鎖成功才能執行下述的減庫存業務----        
    try{
        // 查詢庫存信息
        Inventory inventoryResult =
            inventoryService.selectByPrimaryKey(inventory.getInventoryId());
        
        if (inventoryResult.getShopCount() &lt;= 0) {
            return "庫存不足，請聯繫賣家....";
        }
        
        // 扣減庫存
        inventoryResult.setShopCount(inventoryResult.getShopCount() - 1);
        int n = inventoryService.updateByPrimaryKeySelective(inventoryResult);
    } catch (Exception e) { // 確保業務出現異常也可以釋放鎖，避免死鎖
        // 釋放鎖
        stringRedisTemplate.delete(lockKey);
    }
    
    if (n &gt; 0)
        return "端口-" + port + ",庫存扣減成功！！！";
    return "端口-" + port + ",庫存扣減失敗！！！";
}

作者：竹子愛熊貓
鏈接：https://juejin.cn/post/7038473714970656775

</code></pre><p><strong>過期時間的合理性分析：</strong></p><p>因為對於不同的業務，我們設置的過期時間的長短都會不一樣，太長了不合適，太短了也不合適；</p><p>所以我們想到的解決方案是設置一條子線程，給當前鎖資源續命。具體實現是，子線程間隔 2-3s 去查詢一次 key 是否過期，如果還沒有過期則代表業務線程還在執行業務，那麼則為該 key 的過期時間加上 5s。</p><p>但是為了避免主線程意外死亡後，子線程會一直為其續命，造成「長生鎖」的現象，所以將子線程變為主（業務）線程的守護線程，這樣子線程就會跟着主線程一起死亡。</p><pre><code>// 續命子線程
public class GuardThread extends Thread { 
    private static boolean flag = true;

    public GuardThread(String lockKey, 
        int timeOut, StringRedisTemplate stringRedisTemplate){
        ……
    }

    @Override
    public void run() {
        // 開啓循環續命
        while (flag){
            try {
                // 先休眠一半的時間
                Thread.sleep(timeOut / 2 * 1000);
            }catch (Exception e){
                e.printStackTrace();
            }
            // 時間過了一半之後再去續命
            // 先查看 key 是否過期
            Long expire = stringRedisTemplate.getExpire(
                lockKey, TimeUnit.SECONDS);
            // 如果過期了，代表主線程釋放了鎖
            if (expire &lt;= 0){
                // 停止循環
                flag = false;
            }
            // 如果還未過期
            // 再為則續命一半的時間
            stringRedisTemplate.expire(lockKey,expire
                + timeOut/2,TimeUnit.SECONDS);
        }
    }
}


// 創建子線程為鎖續命
GuardThread guardThread = new GuardThread(lockKey,timeOut,stringRedisTemplate);
// 設置為當前，業務線程，的守護線程
guardThread.setDaemon(true);
guardThread.start();

作者：竹子愛熊貓 
鏈接：https://juejin.cn/post/7038473714970656775

</code></pre><span id="OSC_h3_8"></span><h3>Redis 主從架構下鎖失效的問題</h3><p>為了在開發過程保證 Redis 的高可用，會採用主從複製架構做讀寫分離，從而提升 Redis 的吞吐量以及可用性。但是如果一條線程在 redis 主節點上獲取鎖成功之後，主節點還沒有來得及複製給從節點就宕機了，此時另一條線程訪問 redis 就會在從節點上面訪問，同時也獲取鎖成功，這時候臨界資源的訪問就會出現安全性問題了。</p><p><strong>解決辦法：</strong></p><ul><li>紅鎖算法（官方提出的解決方案）：多台獨立的 Redis 同時寫入數據，在鎖失效時間之內，一半以上的機器寫成功則返回獲取鎖成功，失敗的時候釋放掉那些成功的機器上的鎖。但這種做法缺點是成本高需要獨立部署多台 Redis 節點。</li><li>額外記錄鎖狀態：再額外通過其他獨立部署的中間件（比如 DB）來記錄鎖狀態，在新線程獲取鎖之前需要先查詢 DB 中的鎖持有記錄，只要當鎖狀態為未持有時再嘗試獲取分佈式鎖。<strong>但是</strong>這種情況缺點顯而易見，獲取鎖的過程實現難度複雜，性能開銷也非常大；另外還需要配合定時器功能更新 DB 中的鎖狀態，保證鎖的合理失效機制。</li><li>使用 Zookepper 實現</li></ul><span id="OSC_h3_9"></span><h3>Zookeeper 實現分佈式鎖</h3><p>Zookeeper 數據區別於 redis 的數據，數據是實時同步的，主節點寫入後需要一半以上的節點都寫入才會返回成功。所以如果像電商、教育等類型的項目追求高性能，可以放棄一定的穩定性，推薦使用 redis 實現；例如像金融、銀行、政府等類型的項目，追求高穩定性，可以犧牲一部分性能，推薦使用 Zookeeper 實現。</p><span id="OSC_h3_10"></span><h3><strong>分佈式鎖性能優化</strong></h3><p>上面加鎖確實解決了併發情況下線程安全的問題，但是我們面對 100w 個用戶同時去搶購 1000 個商品的場景該如何解決呢？</p><p><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-28-16-5151742Rx9fXhfc11ZcV.png" referrerpolicy="no-referrer"></p><ul><li>可與將共享資源做一下提前預熱，分段分散存儲一份。搶購時間為下午 15：00，提前再 14：30 左右將商品數量分成 10 份，並將每一塊數據進行分別加鎖，來防止併發異常。</li><li>另外也需要在 redis 中寫入 10 個 key，每一個新的線程進來先隨機的分配一把鎖，然後進行後面的減庫存邏輯，完成之後釋放鎖，以便之後的線程使用。</li><li>這種分佈式鎖的思想就是，將原先一把鎖就可以實現的多線程同步訪問共享資源的功能，為了提高瞬時情況下多線程的訪問速度，還需要保證併發安全的情況下一種實現方式。</li></ul><span id="OSC_h3_11"></span><h3>參考文章：</h3><ol><li><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7236213437800890423%23heading-3" target="_blank">https://juejin.cn/post/7236213437800890423</a></p></li><li><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7038473714970656775" target="_blank">https://juejin.cn/post/7038473714970656775</a></p></li><li><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.meituan.com%2F2019%2F12%2F05%2Faqs-theory-and-apply.html" target="_blank">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></p></li></ol><blockquote><p>作者：京東科技，焦澤斌</p><p>來源：京東雲開發者社區，轉載請註明來源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 01:46:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10319213</guid>
            <link>https://my.oschina.net/u/4090830/blog/10319213</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[驚人發現：加班與生產力下降之間的聯繫]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Slack 的勞動力指數揭示瞭如何安排工作日以最大化員工生產力、幸福感和滿意度的新發現。</p><p><strong>概要：</strong> 你在工作上如何花費時間，它又在怎樣消耗你？Slack 的勞動力指數是基於對全球 10,000 多名辦公室員工的調查回覆得出的，揭示瞭如何安排工作日以最大化生產力和增強員工幸福感和滿意度的新發現。</p><p>主要知識點包括：</p><ul><li>在工作日結束時下線的員工比那些覺得有義務在下班後工作的員工的生產力得分高出 20%。</li><li>在工作日中抽出時間休息可以提高員工的生產力和幸福感，但有一半的辦公室員工表示他們很少或從不休息。</li><li>平均而言，辦公室員工表示每天理想的專注時間約為四個小時，而每天超過兩個小時的會議是大多數員工感到會議負擔過重的臨界點。</li><li>每四個辦公室員工中就有三個表示在下午 3 點到 6 點的時間段工作，但其中只有四分之一的人認為這些時間高效。</li></ul><p>幾十年來，許多人在辦公室加班被視為努力工作和生產力的標誌，甚至是一種榮譽的象徵。但 Slack 的新研究表明，儘管存在這種長期觀念，但下班後工作往往與<em>較低</em>的生產力水平相關，並且可能是一個警告信號，表明員工正在處理過多的任務，需要幫助確定優先順序和平衡時間。</p><p>根據 Slack 對全球 10,000 多名辦公員工的調查，最新的勞動力指數結果顯示生產力差距取決於是什麼促使員工加班至深夜（或凌晨）。每五個辦公員工中就有兩個（37%）每週至少有幾次在公司的標準工作時間之外登錄系統，其中超過一半（54%）的員工表示這是由於感受到壓力，而不是自己選擇加班。</p><p>那些覺得有義務在業餘時間工作的員工比那些在標準工作日結束時下班的員工生產力得分低 20%。這些員工還報告：</p><ul><li>與工作相關的壓力大 2.1 倍</li><li>對整體工作環境的滿意度低 1.7 倍</li><li>疲憊程度高 2 倍</li></ul><p><img src="https://d34u8crftukxnk.cloudfront.net/slackpress/prod/sites/6/Workforce-Lab-Blog-Graphics-Pulse-11_V2_After-Hours-Horchata.png" alt="受到壓力而需要在非工作時間工作的員工全天的工作效率低 20%" referrerpolicy="no-referrer"></p><p>這兩組員工都表示，他們用於工作的時間約 70% 是富有成效的——這表明那些加班的員工與他們的同事一樣努力——但那些在非工作時間工作的員工比那些按時上下班的員工更容易認為他們的生產力被相互衝突的優先事項所阻礙（高出 50%）。</p><p>另一方面，那些選擇在標準工作時間之外工作的員工，以更好地安排自己的時間表或追求個人抱負，他們的健康狀況和生產力得分沒有負面影響，甚至略有提高。</p><blockquote><p>「長期以來，從我們如何分配時間到如何定義生產力，許多工作的重點都放在數量而非質量上。始終感覺需要迎頭趕上正在損害員工和企業的利益。這更加突顯了建立信任文化的重要性，在這種文化中，員工在需要確定優先事項並平衡工作時間以便完成工作時，敢於表達自己的需求。」</p></blockquote><h2>關於生產率，關鍵不在於工作時間的長短，而在於質量</h2><p>根據勞動力指數的結果，全球範圍內有相當一部分辦公員工難以平衡工作時間，不同職業層級的員工面臨不同程度的問題。</p><p>超過四分之一的辦公員工（27%）表示他們花費太多時間開會，其中超過一半（55%）的高管也認同這一點。同樣比例（25%）的員工表示他們花費太多時間在電子郵件上，其中 43% 的高管也表示同樣的情況。</p><p>五分之一（20%）的員工表示他們沒有足夠的時間與同事溝通，這個問題在初級員工中最為明顯。</p><p>令人擔憂的是，數據顯示各個層級的許多員工都在沒有休息的情況下完成日常任務：在接受調查的辦公員工中，有一半（50%）的人表示他們很少或從不休息。這些員工發生職業倦怠的可能性要高 1.7 倍。</p><p>然而，那些經常休息的同事表現出更高的工作與生活平衡能力（高 62%）、更強的應對壓力和焦慮的能力（高 43%）、更高的整體滿意度（高 43%），並且出人意料的是，他們的生產力得分高出 13%。</p><blockquote><p>「為什麼我們都開始相信，如果我們始終處於工作狀態，為了成功我們需要精疲力竭？這可以追溯到第一次工業革命，當時我們開始崇拜機器。機器的目標是儘量減少停機時間。但對於作為人類操作系統來説，停機時間並非缺陷，而是其特點。精英運動員知道恢復是達到最佳表現的一部分。休息時間則是生產力的一個乘數。」</p><p>健康和生產力平台 Thrive Global 創始人兼首席執行官阿麗安娜·赫芬頓（Arianna Huffington）如是説。</p></blockquote><p><img src="https://d34u8crftukxnk.cloudfront.net/slackpress/prod/sites/6/Workforce-Lab-Blog-Graphics-Pulse-11_V2_Taking-Breaks-Horchata.png" alt="經常休息的員工生產力高出 13%" referrerpolicy="no-referrer"></p><h2>最佳工作時間：無論你是晨型人還是夜貓子，下午的低迷期都是真實存在的</h2><p>平均而言，辦公員工表示他們工作時間內只有 70% 的時間是高效的。當被問及工作效率最佳時間時，答案差異很大，有些員工喜歡在早上工作，有些則偏愛在晚上。但不管他們的偏好如何，大多數（71%）辦公員工都認為下午晚些時候是最不適合工作的時間，從下午 3 點到 6 點這段時間內，工作效率急劇下降。</p><p><img src="https://d34u8crftukxnk.cloudfront.net/slackpress/prod/sites/6/Workforce-Lab-Blog-Graphics-Pulse-11_V2_Afternoon-Slump-Purple.png" alt="" referrerpolicy="no-referrer"></p><p>儘管有四分之三的辦公員工表示在下午 3 點到 6 點這段時間內工作，但只有四分之一的人認為這段時間工作效率很高。</p><blockquote><p>「這表明生產效率並非線性增長。生產效率是在一天中不間斷地爆發式增長和下降，並不一定在規定的時間窗口內，而且絕對不是連續八小時。‘下午的低迷期’不應該被視為一件壞事；對於許多員工來説，這可能是休息的理想時間，這將提高他們當天的整體工作效率。」</p><p>Slack 研究與分析部高級副總裁兼勞動力實驗室負責人 Christina Janzer</p></blockquote><p>那些會管理時間的人往往更高效。他們使用時間管理策略的可能性高出 1.6 倍，更有可能安排一段時間來完成特定任務，只在特定時間查看電子郵件，並設置專注計時器，這樣的可能性高出 2.2 倍。</p><h2>工作的「適居帶」：如何平衡工作日以優化生產力</h2><p>儘管沒有一種適用於所有行業、角色和職位的通用時間表，但仔細研究數據會發現一個公式，可以幫助員工獲得成功。</p><p>研究表明，無論職位高低，理想的工作日安排都存在一個「適居帶」，即專注時間、協作時間、社交聯繫和休息時間的平衡。平均而言，辦公員工表示每天理想的專注時間約為四個小時。每天超過兩個小時的會議是大多數員工表示他們在會議上花費「太多時間」的臨界點，所有職位級別都出現了類似的模式。表示在會議上花費太多時間的人更有可能説他們沒有足夠的時間來集中注意力。相比之下，約有 10% 的辦公員工（在新公司工作不到一年或 30 歲以下的員工中最常見）表示他們在會議上花費的時間_太少_，這也與歸屬感和生產力的降低有關。</p><blockquote><p>「專注時間、協作時間、連接和休息就像工作日的宏量營養素。正確的平衡可以為你提供最佳工作所需的能量。我們不能把這些工作的關鍵組成部分孤立起來考慮。為了最有效地工作，我們必須為協作工作和專注工作創造空間。」</p><p>Slack 和 Salesforce 員工成功部高級副總裁 David Ard</p></blockquote><h2>辦公員工最希望 AI 提供什麼幫助？協助和自動化以合理安排會議並騰出時間</h2><p>在辦公員工時間管理困難的同時，他們也對 AI 工具的潛力感到興奮，認為它可以更好地平衡他們的時間。</p><p>絕大多數高管——94%——感到整合 AI 的緊迫性，其中一半的高管表示有強烈的緊迫感。然而，我們的調查顯示 AI 的採用仍處於初級階段，只有五分之一的辦公員工表示他們使用過 AI 工具。</p><p>鑑於採用率很低，大多數辦公員工（超過 80%）表示 AI 工具尚未提高他們的工作效率也就不足為奇了。但他們預計 AI 將協助解決工作日中最大的難題之一：會議。員工期望 AI 未來能夠提供最大價值的三大活動是：1）會議記錄和回顧；2）寫作協助；3）工作流程自動化。</p><blockquote><p>「各個職位級別的員工可能會驚訝地發現，每天超過兩小時的會議會降低生產力。對於許多團隊領導者來説，今天達到這個目標可能不切實際。但新一代的 AI 工具可能是救星。能夠準確總結會議記錄並自動化常見工作流程的 AI 助手可能是騰出時間、成功平衡的關鍵。」</p><p>Slack 研究和勞動力實驗室高級副總裁兼負責人 Christina Janzer</p></blockquote><p><strong>你是在努力工作還是聰明地工作？在我們關於如何優化工作時間的研究中深入探討這些問題。參加我們的網絡研討會「新研究揭示高效工作日的祕訣」</strong></p><h2>研究方法</h2><p><em>《勞動力指數》於 2023 年 8 月 24 日至 9 月 15 日對美國、澳大利亞、法國、德國、日本和英國的 10,333 名員工進行了調查。調查由 Qualtrics 負責，並未針對 Slack 或 Salesforce 的員工或客戶進行。所有受訪者都是全職員工（每週工作 30 小時或以上），擔任以下其中一種職位，或表示他們「處理數據、分析信息或進行創造性思維」：執行管理層（例如總裁/合夥人、首席執行官、首席財務官、C 級高管）、高級管理層（例如執行副總裁、資深副總裁）、中級管理層（例如部門/團隊經理、副總裁）、初級管理層（例如經理、團隊負責人）、高級職員（非管理職位）、技術辦公室員工（例如分析師、圖形設計師）。為簡潔起見，我們將調查對象稱為「辦公室員工」或「辦公員工」。</em></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 10 Dec 2023 08:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/1434828/blog/10320336</guid>
            <link>https://my.oschina.net/u/1434828/blog/10320336</link>
            <author>
                <![CDATA[andalousie]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Mistral AI 用「磁鏈鏈接」開源了 87 GB 的 8x7B MoE 模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>有「歐洲版 OpenAI」之稱的大模型創業公司——Mistral AI 昨天發佈了一條<strong>僅包含磁力鏈接</strong>的推文：</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-6d2f1eed8e7b0598bb332db3f7da2a8db77.png" referrerpolicy="no-referrer"></p><p>來源：<u><em><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2FMistralAI%2Fstatus%2F1733150512395038967" target="_blank">https://twitter.com/MistralAI/status/1733150512395038967</a></strong></em></u></p></blockquote><p>網友打開該磁力鏈接後發現居然是一個大小為 87 GB 的種子。從命名和目錄結構來看，這是一個 PyTorch 模型文件。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f146450c2aefd9e4dd128ccf383b4348362.png" referrerpolicy="no-referrer"></p></blockquote><p>上圖的「params.json」JSON 格式文件顯然是該模型的主要參數信息，具體如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-1c197917ca03f170a988e23832ba8a2f592.png" referrerpolicy="no-referrer"></p><p>結合參數和文件名信息，Mistral AI 這次「開源」的&nbsp;<strong>mixtral-8x7b-32kseqlen&nbsp;</strong>是一個基於<strong>混合專家 (Mixture of Experts, MoE)</strong>&nbsp;的大模型，<strong>由 8 個 70 億參數規模 (8×7b) 的專家網絡組成</strong>。據稱是全球首個開源 MoE 大模型。</p><p>MoE 是用於提高大語言模型效率和準確度的技術。這種方法的核心是將複雜任務劃分為更小、更易管理的子任務，每個子任務由專門的小型模型或「專家」負責，然後根據輸入數據的特性選擇性地激活這些「專家」。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span>MoE 核心組成：</span></p><ol><li><p style="margin-left:0; margin-right:0"><span><strong>專家 (Experts)</strong>：</span><span style="background-color:#ffffff; color:#0f1419">訓練有素的小型神經網絡，擅長特定領域。</span><span>每個專家通常專注於處理一種特定類型的數據或任務。專家的設計可以是多種形式，如完全連接的網絡、卷積網絡等。</span></p></li><li><p style="margin-left:0; margin-right:0"><span><strong>門控機制 (Gating Mechanism)</strong>：</span><span style="background-color:#ffffff; color:#0f1419">MoE 架構決策者，</span><span>這是一個智能路由系統，負責決定哪些專家應該被激活來處理當前的輸入數據。門控機制基於輸入數據的特性，動態地將數據分配給不同的專家。</span></p></li></ol><p>根據 mixtral-8x7b-32kseqlen 的參數信息，該模型對每個 token 的推理使用 2 個專家進行處理（和傳聞中的 GPT-4 一樣）。</p><blockquote><p>此前<u><a href="https://www.oschina.net/news/249106/gpt-4-architecture-infrastructure" target="_blank">揭祕 GPT-4 技術細節</a></u>的文章提到，GPT-4 是由 16 個專家組成的 MoE 模型，每個專家則是一個包含 1110 億參數的大模型，每次前向傳遞路由經過 2 個專家模型。</p></blockquote><p>Mistral AI 目前仍沒公佈除模型下載鏈接外的任何信息，如果不想下載但又想體驗一把，可以訪問下面的網站：</p><ul><li><strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Freplicate.com%2Fnateraw%2Fmixtral-8x7b-32kseqlen" target="_blank">https://replicate.com/nateraw/mixtral-8x7b-32kseqlen</a></u></strong></li><li><strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fapp.fireworks.ai%2Fmodels%2Ffireworks%2Fmixtral-8x7b-fw-chat" target="_blank"><span style="background-color:rgba(0, 0, 0, 0); color:inherit">https://</span>app.fireworks.ai/models/firewor<span style="background-color:rgba(0, 0, 0, 0); color:inherit">ks/mixtral-8x7b-fw-chat</span></a></u></strong></li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-93dba40a2cac79b8ffbc7720a6db69dfd02.png" referrerpolicy="no-referrer"></p><p>對了，這不是 Mistral AI 第一次用「留種」的方式發佈開源大模型。Mistral AI 在 9 月底發佈的那條磁力鏈接是其開源的第一個大模型 Mistral-7B，該模型至今仍被稱為「最好的 7B 模型」，在每個基準測試中都優於 Llama-2 13B，並且在代碼、數學和推理方面優於 LLaMA-1 34B。</p><p><img src="https://oscimg.oschina.net/oscnet/up-28671bd6c309caf5b0fcc86e275681ef529.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 10 Dec 2023 07:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270317/mixtral-8x7b-32kseqlen</guid>
            <link>https://www.oschina.net/news/270317/mixtral-8x7b-32kseqlen</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[餘承東：華為明年將推出顛覆性產品，改寫行業歷史]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>12 月 9 日，2023 華為花粉年會在松山湖基地舉行。華為常務董事、終端 BG CEO、智能汽車解決方案 BU 董事長餘承東在年會上表示，<strong>明年會推出非常有引領性、創新性、顛覆性的產品。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d15077f4297790d71ee33fb17fcdc27333c.png" referrerpolicy="no-referrer"></p><p><strong><strong>餘承東直言：「到時候你可以看到我們怎麼樣能夠</strong>改寫這個行業的歷史</strong>。希望能夠不斷地帶來超越大家的期待，做別人想不到的事情或者想到但做不到的事，甚至是他們不敢想的事情。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e2b780aafbf00c463c0e8273e50a58bead5.png" referrerpolicy="no-referrer"></p><p>餘承東還預告，華為明年將會推出鴻蒙原生應用與原生體驗的產品，「<strong>那將會是整個中國終端類操作系統裏真正的王者</strong>」。</p><p>此前，有消息稱華為可能明年推出不兼容 Android 的鴻蒙版本。11 月 20 日，據澎湃新聞報道，一華為相關人士表示，推出時間還不確定，未來 iOS、鴻蒙、Android 將為三個各自獨立的系統。</p><p>稍早前據證券時報報道，有業內人士亦表示：「華為內部確實有這計劃，就是明年推出不兼容 Android 的鴻蒙版本，但目前內部還沒有下發相關通知，所以具體何時推出暫不明確。」</p><p>在 9 月 25 日舉行的華為秋季全場景新品發佈會上，華為常務董事、終端 BG CEO、智能汽車解決方案 BU 董事長餘承東宣佈，鴻蒙原生應用全面啓動，HarmonyOS NEXT 開發者預覽版將在 2024 年第一季度面向開發者開放。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-619518ef25720c3272f8663f57f84ce9cbb.png" referrerpolicy="no-referrer"></p><p>會上，華為與近 40 家合作伙伴舉辦鴻蒙生態合作簽約儀式，包括：小紅書、招商銀行、攜程旅行、美圖、58 同城、360 瀏覽器、網易有道詞典、石墨文檔、classln 應用、洪恩識字、漢王科技、作業幫、億圖腦圖 MindMaster 應用、會見會議、2345 好壓、寶寶巴士、喜馬拉雅、訊飛聽見、浩辰 CAD、掌上生活、郵儲銀行、鈦媒體、駕考寶典、書生電子、交通銀行、中信銀行、興業證券、央廣網、搜狐新聞、蜻蜓 FM、京東健康、動卡空間、東方財富、天天基金、大智慧、深圳 CA 簽章、中軟國際、中國音像與數字出版協會等應用與服務商。</p><p>10 月 26 日，包含支付寶、小紅書、嗶哩嗶哩、滴滴出行、同程旅行、哈囉等十餘家知名互聯網企業，參加了華為在上海舉行的鴻蒙生態夥伴聯合創新會，瞭解 HarmonyOS NEXT 的能力與特性，現場達成 10+創新場景合作意向。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 10 Dec 2023 03:15:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270290</guid>
            <link>https://www.oschina.net/news/270290</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[黑客攻擊招聘 APP 短信驗證碼接口用於「撞庫」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>央視新聞報道了招聘 APP 遭黑客攻擊導致 300 萬條數據泄露的案件。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-e4acf1c1251a484866c2db701cf03469b78.png" referrerpolicy="no-referrer"></p><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F2656274875%2FNwrWnni5v%3Fpagetype%3Dprofilefeed" target="_blank">https://www.weibo.com/2656274875/NwrWnni5v?pagetype=profilefeed</a></u></em></p></blockquote><p>根據報道，前段時間北京警方接到轄區內一家互聯網公司報案，稱該公司求職招聘類 App 的短信驗證碼接口遭受 1300 餘萬次攻擊，且成功匹配註冊賬號 30 餘萬個。北京警方迅速研判，<strong>確定這是一起黑客利用網站漏洞非法獲取賬號信息並用於違法活動的案件</strong>。</p><p>據瞭解，犯罪嫌疑人喻某交代稱，自己於 2022 年 10 月 18 日在該招聘平台註冊賬號，並數次嘗試驗證接口。<strong>他發現該網站的簽名算法相對單一，便利用該弱點編寫指令，製作黑客軟件對網站進行「撞庫」攻擊</strong>。</p><p>同時，他還利用類似方式對其他各大網站進行滲透，並伺機查詢網站漏洞，<strong>以此為誘餌向他人兜售自己編寫的惡意程序、黑客工具，從中牟利</strong>。經過民警不懈努力，專案組成功在四川成都將另一名嫌疑人焦某抓獲，<strong>現場起獲各類公司、人員數據 330 餘萬條</strong>。</p><p>犯罪嫌疑人喻某、焦某因破壞計算機信息系統罪被依法刑事拘留，案件正進一步辦理中。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 10 Dec 2023 02:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270288</guid>
            <link>https://www.oschina.net/news/270288</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Eclipse 4.30 正式發佈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Eclipse 4.30 <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.eclipse.org%2Flists%2Feclipse-dev%2Fmsg12229.html" target="_blank">已正式發佈</a></u>。</p><blockquote><p>下載地址：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdownload.eclipse.org%2Feclipse%2Fdownloads%2Fdrops4%2FR-4.30-202312010110%2F" target="_blank">https://download.eclipse.org/</a></u></em></p></blockquote><p><strong>主要變化</strong></p><ol><li><p>支持新的 Java 語言特性：包括 JEP 440: Record Patterns 和 JEP 441: Pattern Matching for Switch</p></li><li><p>針對 Java 編輯器的快速修復功能：<span style="font-family:-apple-system,BlinkMacSystemFont,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;,&quot;Segoe UI&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif">包括添加默認 case、移除默認 case 和插入 break 語句等。</span><img alt="" src="https://oscimg.oschina.net/oscnet/up-329b23386ea4f45add7417bc2b198bfb628.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3db6224b26cb93f37c8b8f305527edf1eba.png" referrerpolicy="no-referrer"></p></li><li><p>清理和快速修復以替換棄用的方法調用：新增了一個清理功能，可以替換帶有 Javadoc 的棄用方法調用。</p></li><li><p>快速輔助重命名常量字段：新增了一個快速輔助功能，可以將靜態常量字段重命名為符合標準語法的形式。<br><img alt="" src="https://oscimg.oschina.net/oscnet/up-7eb8135dd37ddf8e7bb0b037efaa8257b73.png" referrerpolicy="no-referrer"></p></li><li><p>面向 JDT 開發者推動重構和建議到 jdt.manipulations：大量代碼從 org.eclipse.jdt.ui 推動到 org.eclipse.jdt.core.manipulations，這將允許這些操作在無 header 環境中使用。</p></li></ol><p>詳情查看&nbsp;<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Feclipse.dev%2Feclipse%2Fnews%2F4.30%2F" target="_blank">https://eclipse.dev/eclipse/news/4.30/</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 09 Dec 2023 09:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270231/eclipse-4-30-ga</guid>
            <link>https://www.oschina.net/news/270231/eclipse-4-30-ga</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[systemd 新組件 systemd-bsod — 為 Linux 引入「藍屏」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>systemd 255 近日<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsystemd%2Fsystemd%2Freleases%2Ftag%2Fv255" target="_blank">發佈了穩定版</a></u>，其新增的"<strong>systemd-bsod</strong>"實驗性組件讓人眼前一亮——沒錯，正是大名鼎鼎的「藍屏死機」（Blue Screen of Death，簡稱 BSOD）。</p><p>BSOD 是微軟 Windows 操作系統在無法從一個系統錯誤中恢復過來時，為保護電腦數據文件不被破壞而強制顯示的屏幕圖像。Windows 的藍屏死機提示已成為標誌性畫面，大部分是系統崩潰的現象。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-51d3ac36bc416abe53fe1c0517c774a1824.png" referrerpolicy="no-referrer"></p><p><em>上圖是 Windows 10 的藍屏死機畫面（版本 1607-21H2），它包含了一個悲傷的顏文字和一個用於快速排查錯誤的二維碼</em>。</p><p>簡而言之，BSOD 就是用於展示錯誤信息的診斷工具。雖然大家討厭看到藍屏界面，但這不意味着 BSOD 本身是一個壞方案。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d1cfdcf33e390c881d32ad1ef5146419e5e.png" referrerpolicy="no-referrer"></p><p>根據&nbsp;systemd 更新日誌的介紹，當日誌級別設置為"<strong>LOG_EMERG</strong>"時，如果 Linux 系統出現引導錯誤，新組件"systemd-bsod"會全屏顯示報錯信息（即 BSOD）。和 Windows 的 BSOD 類似，它也會生成二維碼，以便用戶通過手機獲取啓動失敗報錯的更多信息。</p><p>"systemd-bsod" 屬於&nbsp;<span>Outreachy 項目的一部分，該項目是為開發開源工具的人員提供實習機會的組織。</span></p><p>systemd-bsod 目前處於實驗性階段，GitHub 上的更新日誌也指出它仍會有改動。但不管怎樣，不少主流 Linux 發行版如 Ubuntu、Fedora、Debian 和 Red Hat 都採用了 systemd。所以 2024 年，相信不少 Linux 發行版都會引入「藍屏」。</p><p>對了，systemd 創始人兼首席開發者 Lennart Poettering 去年<u><a href="https://www.oschina.net/news/202119/systemd-creator-microsoft" target="_blank">被微軟從 Red Hat 挖走</a></u>&nbsp;—— 繼續專注於開發 systemd。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 09 Dec 2023 05:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270207/systemd-255-bsod</guid>
            <link>https://www.oschina.net/news/270207/systemd-255-bsod</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[從瀏覽器原理出發聊聊 Chrome 插件]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h3_1"></span><h3>瀏覽器架構演進</h3><p style="text-align:justify"><strong>單進程瀏覽器時代</strong></p><p style="text-align:justify">單進程瀏覽器是指瀏覽器的所有功能模塊都是運行在同一個進程裏，這些模塊包含了網絡、插件、JavaScript 運行環境、渲染引擎和頁面等。在 2007 年之前，市面上瀏覽器都是單進程的。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-3442db3861bb3221f7e853cfffa1ea45_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">單進程瀏覽器的架構</p><p style="text-align:justify">很多功能模塊運行在一個進程裏，是導致單進程瀏覽器不穩定、不流暢和不安全的一個主要因素。</p><ul><li><strong>不穩定：</strong>早期瀏覽器需要藉助於插件來實現諸如 Web 視頻、Web 遊戲等各種強大的功能，但是插件是最容易出問題的模塊，並且還運行在瀏覽器進程之中，所以一個插件的意外崩潰會引起整個瀏覽器的崩潰。除了插件之外，渲染引擎模塊也是不穩定的，通常一些複雜的 JavaScript 代碼就有可能引起渲染引擎模塊的崩潰。和插件一樣，渲染引擎的崩潰也會導致整個瀏覽器的崩潰。</li><li><strong>不流暢：</strong>所有頁面的渲染模塊、JavaScript 執行環境以及插件都是運行在同一個線程中的，這就意味着同一時刻只能有一個模塊可以執行。如果一個腳本非常耗時，它就會獨佔整個線程，這樣導致其他運行在該線程中的頁面沒有機會去執行任務，導致整個瀏覽器失去響應，變卡頓。</li><li><strong>不安全：</strong>當你在頁面運行一個插件時，插件可以操作系統資源，如果是個惡意插件，那麼它就可以釋放病毒、竊取你的賬號密碼，引發安全性問題。</li></ul><span id="OSC_h4_2"></span><h4><strong>多進程瀏覽器時代</strong></h4><p style="text-align:justify"><strong>早期架構</strong></p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-98f663221fa15549837f9cd878d40653_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">2008 年 Chrome 發佈時的進程架構</p><p style="text-align:justify">從圖中可以看出，早期的架構已經對瀏覽器的能力進行了拆分，主要拆分為三類：<strong>瀏覽器進程、插件進程和渲染進程。</strong>每個頁面是運行在單獨的渲染進程中的，同時頁面裏的插件也是運行在單獨的插件進程之中，進程之間是通過 IPC 機制進行通信。這就解決了單進程時代瀏覽器的各種問題：</p><ul><li><strong>解決不穩定：</strong>由於進程是相互隔離的，所以當一個頁面或者插件崩潰時，影響到的僅僅是當前的頁面進程或者插件進程，並不會影響到瀏覽器和其他頁面。</li><li><strong>解決不流暢：</strong>JavaScript 運行在渲染進程中，所以即使 JavaScript 阻塞了渲染進程，也只會影響當前的渲染頁面，並不會影響瀏覽器和其他頁面，因為其他頁面的腳本運行在它們自己的渲染進程中。</li><li><strong>解決不安全：</strong>Chrome 把插件進程和渲染進程鎖在沙箱裏面，沙箱裏面的程序可以運行，但是不能在硬盤上寫入任何數據，也不能在敏感位置讀取任何數據，這樣即使在渲染進程或者插件進程裏面執行了惡意程序，惡意程序也無法突破沙箱去獲取系統權限。</li></ul><p style="text-align:justify"><strong>近期架構</strong></p><p style="text-align:justify">相較之前，近期的架構又有了很多新的變化。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-4c1b8fc023fcd2ad0aa618575cdbc74b_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">近期 Chrome 進程架構</p><p style="text-align:justify">從圖中可以看出，最新的 Chrome 瀏覽器包括：<strong>1 個瀏覽器主進程、1 個 GPU 進程、1 個網絡進程、多個渲染進程和多個插件進程。</strong></p><ul><li><strong>瀏覽器進程：</strong>主要負責界面顯示、用戶交互、子進程管理，同時提供存儲等功能。可以理解瀏覽器進程是一個統一的"<strong>調度大師</strong>"去調度其他進程，比如我們在地址欄輸入 url 時，瀏覽器進程首先會調用網絡進程。</li><li><strong>渲染進程：</strong>核心任務是將 HTML、CSS 和 JavaScript 轉換為用戶可以交互的網頁，排版引擎 Blink 和 JavaScript 引擎 V8 都是運行在該進程中，默認情況下，Chrome 會為每個 Tab 標籤創建一個渲染進程。出於安全考慮，渲染進程都是運行在沙箱模式下。</li><li><strong>GPU 進程：</strong>其實，Chrome 剛開始發佈的時候是沒有 GPU 進程的。而 GPU 的使用初衷是為了實現 3D CSS 的效果，只是隨後網頁、Chrome 的 UI 界面都選擇採用 GPU 來繪製，這使得 GPU 成為瀏覽器普遍的需求。最後，Chrome 在其多進程架構上也引入了 GPU 進程。</li><li><strong>網絡進程：</strong>主要負責頁面的網絡資源加載，之前是作為一個模塊運行在瀏覽器進程裏面的，直至最近才獨立出來，成為一個單獨的進程。</li><li><strong>插件進程：</strong>主要是負責插件的運行，因插件易崩潰，所以需要通過插件進程來隔離，以保證插件進程崩潰不會對瀏覽器和頁面造成影響。</li></ul><p style="text-align:justify"><strong>當前架構</strong></p><p style="text-align:justify">目前 Chrome 瀏覽器的架構正在發生一些改變，稱為<strong>面向服務的架構 (SOA)</strong>，目的是將和瀏覽器本身（Chrome）相關的部分拆分為一個個不同的服務，服務化之後，這些功能既可以放在不同的進程裏面運行也可以合併為一個單獨的進程運行。這樣做的主要原因是讓 Chrome 在不同性能的硬件上有不同的表現。當 Chrome 運行在一些性能比較好的硬件時，瀏覽器進程相關的服務會被放在不同的進程運行以提高系統的穩定性。相反如果硬件性能不好，這些服務就會被放在同一個進程裏面執行來減少內存的佔用。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-42fd4b754c12dcb3981338f765d81a60_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">面向服務的架構</p><span id="OSC_h3_3"></span><h3>插件運行機制</h3><p style="text-align:justify">在運行機制前，我們先來回顧一下打開頁面會發生什麼：</p><span id="OSC_h4_4"></span><h4><strong>打開頁面發生了什麼</strong></h4><ul><li>用戶新增一個 tab，此時系統瀏覽器進程、渲染進程、GPU 進程、網絡進程會被創建好；</li><li>用戶輸入 url，瀏覽器進程檢查 url，組裝協議，構成完整的 url；</li><li>瀏覽器進程通過進程間通信（IPC）把 url 請求發送給網絡進程；</li><li>網絡進程接收到 url 請求後檢查本地緩存是否緩存了該請求資源，如果有則將該資源返回給瀏覽器進程；</li><li>如果沒有，網絡進程向 web 服務器發起 http 請求（網絡請求）；</li><li>網絡進程解析響應流程； 
  <ul><li>檢查狀態碼，非 200 執行狀態碼對應的處理邏輯；</li><li>200 響應處理：檢查響應類型 Content-Type，如果是字節流類型，則將該請求提交給下載管理器，不再進行後續的渲染，如果是 html 則通知瀏覽器進程準備渲染進程進行渲染；</li></ul></li><li>準備渲染進程 
  <ul><li>瀏覽器進程檢查當前 url 是否和之前打開的渲染進程根域名是否相同，如果相同，則複用原來的進程，如果不同，則開啓新的渲染進程；</li></ul></li><li>傳輸數據、更新狀態 
  <ul><li>渲染進程準備好後，瀏覽器向渲染進程發起「提交文檔」的消息，渲染進程接收到消息和網絡進程建立傳輸數據的「管道」；</li><li>渲染進程接收完數據後，向瀏覽器發送確認消息；</li><li>瀏覽器進程接收到確認消息後更新瀏覽器界面狀態：安全、地址欄 url、前進後退的歷史狀態、更新 web 頁面；</li></ul></li></ul><span id="OSC_h4_5"></span><h4><strong>打開插件發生了什麼</strong></h4><p style="text-align:justify">插件的運行相較於頁面會有簡化</p><p style="text-align:justify">1.我們打開瀏覽器，新增一個空白 tab 頁</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-fbdf73e0cfb877800ffc5a6b290cbee8_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">2.tab 欄空白處右鍵，選擇任務管理器，打開任務管理器面板</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-71e105d5e40961a19574affc5d405506_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">3.可以看到運行了 6 個進程，分別是瀏覽器進程、GPU 進程、網絡進程、存儲進程、渲染進程和擴展進程。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-fd99f7006599b3a820d7ffb6dbeaab0d_720w.webp" referrerpolicy="no-referrer"></p><ul><li>擴展進程中運行 Extension Page，主要包括 backgrount.html 和 popup.html； 
  <ul><li>backgrount.html 中沒有任何內容，是通過 background.js 創建生成，當瀏覽器打開時，會自動加載插件的 background.js 文件，它獨立於網頁並且一直運行在後台，它主要通過調用瀏覽器提供的 API 和瀏覽器進行交互；</li><li>popup.html 有內容的，跟我們普通的 web 頁面一樣，由 html、css、Javascript 組成，它是按需加載的，需要用戶去點擊地址欄的按鈕去觸發，才能彈出頁面；</li></ul></li><li>渲染進程主要運行 Web Page,當打開頁面時，會將 content_script.js 加載並注入到該網頁的環境中，它和網頁中引入的 Javascript 一樣，可以操作該網頁的 DOM Tree，改變頁面的展示效果；</li><li>GPU 進程主要為插件界面的渲染提供硬件能力支持；</li><li>網絡進程主要處理插件中的外部資源請求，比如 nexydy 插件依賴到一些外部 js；</li><li>存儲進程為插件提供本地存儲能力，比如使用 chrome.storage.local 進行持久化存儲；</li><li>瀏覽器進程在這裏更多起到橋樑作用，作為中轉可以實現 Extension Page 和 content_script.js 之間的消息通信。</li></ul><span id="OSC_h3_6"></span><h3>插件基本介紹</h3><span id="OSC_h4_7"></span><h4><strong>版本發展</strong></h4><p style="text-align:justify">chrome 插件存在三個版本，分別是<strong>Manifest V1、Manifest V2 和 Manifest V3</strong>。其中 MV1 版本已經被廢棄了，目前市面上存在 MV2 和 MV3 版本，以 MV2 為主流，在被 MV3 慢慢取代。時間線：</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-950393136d16d081528b01b5fbc794f1_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>Manifest V2 新特性</strong></p><p style="text-align:justify"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%2Fmv2%2FmanifestVersion%2F%253Fspm%253Da2c6h.13046898.publish-article.26.c7c96ffa7eZ9TZ%2523manifest-v1-changes" target="_blank">https://developer.chrome.com/docs/extensions/mv2/manifestVersion/#manifest-v1-changes</a></p><ul><li>設置了默認的內容安全策略`script-src 'self'; object-src 'self';`。有關內容安全策略的詳細配置，可以參考 MDN 文檔；</li><li>默認情況下，插件包內的資源不再可供外部網站使用。需要通過清單 web_accessible_resources 屬性將其顯式列入白名單；</li><li>browser action API 更改；</li><li>page action API 更改；</li><li>chrome.extension 代替 chrome.self 來指向插件本身；</li><li>chrome.extension.getTabContentses 和 chrome.extension.getExtensionTabs 廢棄，使用 extension.getViews 替代；</li><li>Port.tab 廢棄，使用 runtime.Port 替代；</li></ul><p style="text-align:justify"><strong>Manifest V3 新特性</strong></p><ul><li>Service worker 替換 Background Page；</li><li>網絡請求修改廢棄 webRequest API 使用新的 declarativentrequest API 來處理；</li><li>不再允許執行遠程託管的代碼，只能執行擴展包內包含的 JS；</li><li>Promises 已經被添加到許多方法中，但仍支持回調作為替代方法；</li><li>Browser Action API 和 Page Action API 被統一為單獨的 Action API；</li><li>Web 可訪問的資源，可以只對指定的站點和擴展可用；</li><li>內容安全策略 (CSP)，現在可以為單個對象中的不同執行上下文指定單獨的 CSP；</li><li>executeScript 的變化，不能再執行任意字符串，只能執行腳本文件和函數；</li></ul><p style="text-align:justify"><strong>切換 MV3 會帶來的問題</strong></p><ul><li>由於 background 不再支持 page 頁面配置 background.html，因此也無法調用 window 對象上的 XMLHttpRequest 來構建 ajax 請求，也就是説我們不能像 V2 版本一樣，在 background.html 中使用 XMLHttpRequest 來發送請求了，而是需要使用 fetch 來獲取接口數據；</li><li>由於 service workers 是短暫的，在不使用時會終止，這意味着它們在整個插件運行期間會不斷的啓動、運行和終止，也就是不穩定的；因此我們可能需要對 V2 中 background.js 的代碼邏輯進行一些改造，以往我們會習慣將一些數據直接存儲到全局變量，比如像下面這樣：</li></ul><pre><code>// V2 background.js
let saveUserName = "";

// 其他頁面，比如 content-script 或者 popup 中存儲數據
chrome.runtime.onMessage.addListener(({ type, name }) =&gt; {
  if (type === "set-name") {
    saveUserName = name;
  }
});

// 點擊 popup 時展示數據
chrome.action.onClicked.addListener((tab) =&gt; {
  // 這裏 saveUserName 可能為空字符串
  console.log(saveUserName, "saveUserName");
});</code></pre><ul><li>因此在 V3 中，需要對這種全局變量數據進行改造，改造的方式也很簡單，就是將數據持久化保存到 storage 中，需要用到的地方隨用隨取：</li></ul><pre><code>// V3 service worker
chrome.runtime.onMessage.addListener(({ type, name }) =&gt; {
  if (type === "set-name") {
    chrome.storage.local.set({ name });
  }
});

chrome.action.onClicked.addListener(async (tab) =&gt; {
  const { name } = await chrome.storage.local.get(["name"]);
  chrome.tabs.sendMessage(tab.id, { name });
});</code></pre><ul><li>由<strong>webRequest API</strong>切換至<strong>declarativentrequest API</strong>，很多代碼邏輯需要重構；</li></ul><p style="text-align:justify"><strong>為什麼切換 MV3？</strong></p><p style="text-align:justify">從 Manifest V1 到 Manifest V2，可以看到 Chrome 想提高插件的隱私和安全，同時也優化了不少 API。而 Manifest V3 除了安全性更完善外，還在性能上下了功夫。Manifest V3 的核心非常明確，就是限制擴展對系統資源的使用。一直以來高資源佔用都是 Chrome 為人詬病的痛點，而且擴展由於在後台運行，如果出現問題，更是難以定位和管理。雖然增加了諸多限制，但 Manifest V3 還是有優點的：</p><ul><li>Service Worker 使擴展不再能常駐後台，讓擴展所佔用的資源可以被回收，降低了瀏覽器整體的開銷；</li><li>限制規則的數量，相當於控制了單一擴展在規則計算方面的資源使用上限；</li></ul><p style="text-align:justify">這些變化可以讓 Chrome 變得更加流暢，對於用戶來説是好事。</p><span id="OSC_h4_8"></span><h4><strong>展示形式</strong></h4><p style="text-align:justify">Chrome 插件有以下常見的 8 中展現形式：</p><p style="text-align:justify"><strong>browserAction(瀏覽器右上角)</strong></p><p style="text-align:justify">在瀏覽器右上角擴展程序一欄顯示，包含一個圖標、名稱和 popup</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-d1c2fce69c1223a54300c9a2ea96eb9b_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">山海關插件 popup</p><p style="text-align:justify"><strong>pageAction(地址欄右側)</strong></p><p style="text-align:justify">pageAction 指的是在當某些特定頁面打開才顯示的圖標。在早些版本的 Chrome 是將 pageAction 放在地址欄的最右邊，左鍵單擊彈出 popup，右鍵單擊則彈出相關默認的選項菜單。而新版的 Chrome 更改了這一策略，pageAction 和普通的 browserAction 一樣也是放在瀏覽器右上角，只不過沒有點亮時是灰色的，點亮了才是彩色的，灰色時無論左鍵還是右鍵單擊都是彈出選項。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-00231bae7597112980d8851b90979347_720w.webp" referrerpolicy="no-referrer"></p><p><strong>右鍵菜單</strong></p><p style="text-align:justify">通過開發 Chrome 插件可以自定義瀏覽器的右鍵菜單，主要是通過 chrome.contextMenus API 實現，右鍵菜單可以出現在不同的上下文，比如普通頁面、選中的文字、圖片、鏈接，等等。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-21338dc0d8e7b00dd4bcd5ef3922e777_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">掘金插件右鍵菜單</p><p style="text-align:justify"><strong>override(覆蓋特定頁面)</strong></p><p style="text-align:justify">使用 override 可以將 Chrome 默認的一些特定頁面替換掉，改為使用擴展提供的頁面。擴展可以替代如下頁面：</p><ul><li>歷史記錄：從工具菜單上點擊歷史記錄時訪問的頁面，或者從地址欄直接輸入 chrome://history</li><li>新標籤頁：當創建新標籤的時候訪問的頁面，或者從地址欄直接輸入 chrome://newtab</li><li>書籤：瀏覽器的書籤，或者直接輸入 chrome://bookmarks</li></ul><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-c730b7492405900d5f1c3cd9131abf06_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">掘金插件替換了新標籤頁</p><p style="text-align:justify"><strong>devtools(開發者工具)</strong></p><p style="text-align:justify">Chrome 允許插件在開發者工具 (devtools) 上開發，主要表現在：</p><ul><li>自定義一個和多個和 Elements、Console、Sources 等同級別的面板；</li><li>自定義側邊欄 (sidebar)，目前只能自定義 Elements 面板的側邊欄；</li></ul><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-1dca64511239cf86d0d29e29fccc403d_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">React Developer Tools</p><p style="text-align:justify"><strong>option(選項頁)</strong></p><p style="text-align:justify">插件的設置頁面，可以在右上角入口右鍵，有一個選項標籤</p><div style="text-align:center"><img height="610" src="https://pic1.zhimg.com/80/v2-9fc5b949ed631b4718e3af633977c024_720w.webp" width="672" referrerpolicy="no-referrer"></div><div style="text-align:center">
  &nbsp; 
</div><div style="text-align:center"><img height="506" src="https://pic1.zhimg.com/80/v2-bb3b7e3db84d9b3f544b5fd3e1295b90_720w.webp" width="880" referrerpolicy="no-referrer"></div><p style="text-align:justify"><strong>omnibox</strong></p><p style="text-align:justify">omnibox 是向用戶提供搜索建議的一種方式，可以在搜索欄輸入特定的標識然後按 Tab 進入搜索。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-670f0e06b91ac66ccda32a21a111d409_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">JSON Viewer 插件</p><p style="text-align:justify"><strong>桌面通知</strong></p><p style="text-align:justify">Chrome 提供了一個 chrome.notificationsAPI 以便插件推送桌面通知，暫未找到 chrome.notifications 和 HTML5 自帶的 Notification 的顯著區別及優勢。在後台 JS 中，無論是使用 chrome.notifications 還是 Notification 都不需要申請權限（HTML5 方式需要申請權限），直接使用即可。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-e9d3bc3ad06b822b37b4e3ba8543a8a5_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_9"></span><h4><strong>核心介紹</strong></h4><p style="text-align:justify"><strong>manifest.json</strong></p><p style="text-align:justify">這是一個 Chrome 插件最重要也是必不可少的文件，用來配置所有和插件相關的配置，必須放在根目錄。其中，manifest_version、name、version3 個是必不可少的。</p><p style="text-align:justify"><strong>Manifest V2</strong></p><pre><code>{
// 清單文件的版本，這裏先使用 2 演示
"manifest_version": 2,
// 插件的名稱
"name": "...",
// 插件的版本
"version": "1.0.0",
// 插件描述
"description": "...",
// 圖標，一般偷懶全部用一個尺寸的也沒問題
"icons": {
"16": "img/icon.png",
"48": "img/icon.png",
"128": "img/icon.png"
  },
// 會一直常駐的後台 JS 或後台頁面
"background": {
"scripts": ["js/background.js"]
  },
// 瀏覽器右上角圖標設置，browser_action、page_action、app 必須三選一
"browser_action": {
"default_icon": "img/icon.png",
"default_title": "...",
"default_popup": "popup.html"
  },
// 當某些特定頁面打開才顯示的圖標
"page_action": {
"default_icon": "img/icon.png",
"default_title": "...",
"default_popup": "popup.html"
  },
// 需要直接注入頁面的 JS
"content_scripts": [{
"matches": ["&lt;all_urls&gt;"],
"js": ["js/content-script.js"],
"css": ["css/custom.css"],
// 代碼注入的時機，document_start, document_end, document_idle，默認 document_idle
"run_at": "document_start"
    },
  ],
// 權限申請
"permissions": [
"contextMenus", // 右鍵菜單
"tabs", // 標籤
"notifications", // 通知
"webRequest", // web 請求
"webRequestBlocking",
"storage", // 插件本地存儲
"https://*/*" // 可以通過 executeScript 或者 insertCSS 訪問的網站
  ],
// 普通頁面能夠直接訪問的插件資源列表，如果不設置是無法直接訪問的
"web_accessible_resources": ["js/inject.js"],
"homepage_url": "...", // 插件主頁
"chrome_url_overrides": { // 覆蓋瀏覽器默認頁面
"newtab": "newtab.html"
  },
"options_ui": { // 插件選項頁
"page": "options.html",
"chrome_style": true
  },
"omnibox": { "keyword" : "..." }, // 向地址欄註冊一個關鍵字以提供搜索建議，只能設置一個關鍵字
"default_locale": "zh_CN", // 默認語言
"devtools_page": "devtools.html", // devtools 頁面入口，注意只能指向一個 HTML 文件，不能是 JS 文件
"content_security_policy": "...", // 安全策略
"web_accessible_resources": [ // 可以加載的資源
    RESOURCE_PATHS
  ]
}</code></pre><p style="text-align:justify"><strong>Manifest V3（僅展示與 V2 版本的不同點）</strong></p><pre><code>{
"manifest_version": 3,
"background": {
"service_worker": js/background.js"
  },
  "action": { //browser_action 和 page_action，統一為 Action
    "default_icon": "img/icon.png",
    "default_title": "這是一個示例 Chrome 插件",
    "default_popup": "popup.html"
  }
  "content_security_policy": {
    "extension_pages": "...",
    "sandbox": "..."
  },
  "web_accessible_resources": [{
    "resources": [RESOURCE_PATHS]
  }]
}</code></pre><p style="text-align:justify"><strong>content-scripts</strong></p><p style="text-align:justify">是 Chrome 插件中向頁面注入腳本的一種形式（雖然名為 script，其實還可以包括 css 的），藉助 content-scripts 我們可以實現通過配置的方式輕鬆向指定頁面注入 JS 和 CSS。content-scripts 和原始頁面共享 DOM，但不共享 JS。如要訪問頁面 JS（例如某個 JS 變量），只能通過 injected js 來實現。content-scripts 不能訪問絕大部分 chrome API，除了下面這 4 種：</p><ul><li>chrome.extension</li><li>chrome.i18n</li><li>chrome.runtime</li><li>chrome.storage</li></ul><p style="text-align:justify">這些 API 絕大部分時候都夠用了，有需要調用其它 API 的話，可以通過通信讓 background 或 service worker 來幫忙調用</p><p style="text-align:justify"><strong>background</strong></p><p style="text-align:justify">後台是一個常駐的頁面，它的生命週期是插件中所有類型頁面中最長的，它隨着瀏覽器的打開而打開，隨着瀏覽器的關閉而關閉，所以通常把需要一直運行的、啓動就運行的、全局的代碼放在 background 裏面。background 的權限非常高，幾乎可以調用所有的 Chrome 擴展 API（除了 devtools），而且它可以無限制跨域，可以跨域訪問任何網站而無需要求對方設置 CORS。background 的概念在 MV3 版本中變為了 service worker，區別在於生命週期變短了，service worker 是短暫的基於事件的腳本，所以不適合用來保存全局變量。</p><p style="text-align:justify"><strong>popup</strong></p><p style="text-align:justify">popup 是點擊右上角圖標時打開的一個小窗口網頁，焦點離開網頁就立即關閉，一般用來做一些臨時性的交互。權限級別和 background 差不多，就是生命週期比較短。</p><p style="text-align:justify"><strong>injected-script</strong></p><p style="text-align:justify">chrome 插件中其實沒有 injected-script 這一概念，這是開發者們在開發過程中衍生出來的一種概念，指的是通過 DOM 操作的方式向頁面注入的一種 JS。因為 content-script 無法訪問頁面中的 JS，雖然可以操作 DOM，但是 DOM 卻不能調用它，也就是無法在 DOM 中通過綁定事件的方式調用 content-script 中的代碼。但是在網頁中增加一個按鈕來調用插件的能力是一個比較常見的需求，所以誕生了 injected-script。</p><span id="OSC_h4_10"></span><h4><strong>插件通信機制</strong></h4><p style="text-align:justify">講通信機制之前，先回顧一下插件中存在的腳本類型。Chrome 插件的 JS 主要可以分為這 5 類：injected script、content-script、popup js、background js 和 devtools js。</p><p style="text-align:justify"><strong>權限對比</strong></p><table><tbody><tr><td style="text-align:justify">JS 種類</td><td style="text-align:justify">可訪問的 API</td><td style="text-align:justify">DOM 訪問情況</td><td style="text-align:justify">JS 訪問情況</td><td style="text-align:justify">直接跨域</td></tr><tr><td style="text-align:justify">injected</td><td style="text-align:justify">和普通 JS 無任何差別，不能訪問任何擴展 API</td><td style="text-align:justify">可以訪問</td><td style="text-align:justify">可以訪問</td><td style="text-align:justify">不可以</td></tr><tr><td style="text-align:justify">content</td><td style="text-align:justify">只能訪問 extension、runtime 等部分 API</td><td style="text-align:justify">可以訪問</td><td style="text-align:justify">不可以</td><td style="text-align:justify">不可以</td></tr><tr><td style="text-align:justify">popup</td><td style="text-align:justify">可訪問絕大部分 API，除了 devtools 系列</td><td style="text-align:justify">不可直接訪問</td><td style="text-align:justify">不可以</td><td style="text-align:justify">可以</td></tr><tr><td style="text-align:justify">background</td><td style="text-align:justify">可訪問絕大部分 API，除了 devtools 系列</td><td style="text-align:justify">不可直接訪問</td><td style="text-align:justify">不可以</td><td style="text-align:justify">可以</td></tr><tr><td style="text-align:justify">devtools</td><td style="text-align:justify">只能訪問 devtools、extension、runtime 等部分 API</td><td style="text-align:justify">可以</td><td style="text-align:justify">可以</td><td style="text-align:justify">不可以</td></tr></tbody></table><p style="text-align:justify">通過權限對比可以看到，每一種腳本在權限上都不相同，所以各種腳本間的相互通信就非常重要，這也是插件能夠實現眾多功能的基礎。</p><p style="text-align:justify"><strong>通信概覽</strong></p><table><tbody><tr><td style="text-align:justify">&nbsp;</td><td style="text-align:justify">injected</td><td style="text-align:justify">content</td><td style="text-align:justify">popup</td><td style="text-align:justify">background</td></tr><tr><td style="text-align:justify">injected</td><td style="text-align:justify">-</td><td style="text-align:justify">window.postMessage</td><td style="text-align:justify">-</td><td style="text-align:justify">-</td></tr><tr><td style="text-align:justify">content</td><td style="text-align:justify">window.postMessage</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.runtime.sendMessage chrome.runtime.connect</td><td style="text-align:justify">chrome.runtime.sendMessage chrome.runtime.connect</td></tr><tr><td style="text-align:justify">popup</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.tabs.sendMessage chrome.tabs.connect</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.extension. getBackgroundPage</td></tr><tr><td style="text-align:justify">background</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.tabs.sendMessage chrome.tabs.connect</td><td style="text-align:justify">chrome.extension.getViews</td><td style="text-align:justify">-</td></tr><tr><td style="text-align:justify">devtools</td><td style="text-align:justify">chrome.devtools. inspectedWindow.eval</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.runtime.sendMessage</td><td style="text-align:justify">chrome.runtime.sendMessage</td></tr></tbody></table><span id="OSC_h3_11"></span><h3>一些常見插件的實現思路</h3><span id="OSC_h4_12"></span><h4><strong>埋點日誌檢測</strong></h4><p style="text-align:justify">一般業務中都會進行一些埋點上報，埋點的本質就是發送一些帶特定參數的請求，前端本地調試的時候想實時查看埋點信息通常需要去查看上報接口的入參，或者去對應的埋點平台查看，這樣非常不方便。基於這個，我們可以使用插件來幫助我們快速的可視化查看埋點信息：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-d9e6e16e3db7cd8922d8b437219a96e2_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_13"></span><h4><strong>頁面注入小工具</strong></h4><p style="text-align:justify">插件的另一個常見用法就是往頁面注入一些工具代碼，比如去除頁面廣告工具。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-0de602a3e05ff59d5e0b6f1450c44d76_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h3_14"></span><h3>總結</h3><ul><li>隨着瀏覽器不斷的發展，Chrome 逐漸把一些基礎服務獨立出來，類似於一個跨平台的線上操作系統。</li><li>Chrome 插件提供的能力很豐富，比如代碼注入、跨域請求、持久化方案、各種通信機制等，開發者可以發揮想象，組裝不同能力以適應不同場景的需求，基本可以實現現代 web 所能支持的所有功能。</li><li>Chrome 插件 MV2 版本將在 24 年 1 月全面廢棄，需要儘快遷移至 MV3 版本。</li></ul><span id="OSC_h3_15"></span><h3><strong>參考資料：</strong></h3><p>《瀏覽器工作原理與實踐》：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Ftime.geekbang.org%2Fcolumn%2Fintro%2F100033601%253Fspm%253Da2c6h.13046898.publish-article.27.c7c96ffa7eZ9TZ%2526tab%253Dcatalog" target="_blank">https://time.geekbang.org/column/intro/100033601?tab=catalog</a></p><p>《Inside look at modern web browser》：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fblog%2Finside-browser-part1%2F%253Fspm%253Da2c6h.13046898.publish-article.28.c7c96ffa7eZ9TZ" target="_blank">https://developer.chrome.com/blog/inside-browser-part1/</a></p><p>《圖解瀏覽器的基本工作原理》：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F47407398%3Fspm%3Da2c6h.13046898.publish-article.29.c7c96ffa7eZ9TZ" target="_blank">https://zhuanlan.zhihu.com/p/47407398</a></p><p>《Welcome to Manifest V3》：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%2Fmv3%2Fintro%2F%253Fspm%253Da2c6h.13046898.publish-article.30.c7c96ffa7eZ9TZ" target="_blank">https://developer.chrome.com/docs/extensions/mv3/intro/</a></p><p>MDN 文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCSP%253Fspm%253Da2c6h.13046898.publish-article.31.c7c96ffa7eZ9TZ" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP</a>web_accessible_resources：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%2Fmv2%2Fmanifest%2Fweb_accessible_resources%2F%253Fspm%253Da2c6h.13046898.publish-article.32.c7c96ffa7eZ9TZ" target="_blank">https://developer.chrome.com/docs/extensions/mv2/manifest/web_accessible_resources/</a></p><p style="text-align:justify">作者｜閔子</p><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1381666%3Futm_content%3Dg_1000385322" target="_blank">原文鏈接</a></strong></p><p style="text-align:justify"><strong>本文為阿里雲原創內容，未經允許不得轉載。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 07:07:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10319584</guid>
            <link>https://my.oschina.net/yunqi/blog/10319584</link>
            <author>
                <![CDATA[阿里云云棲號]]>
            </author>
        </item>
    </channel>
</rss>
