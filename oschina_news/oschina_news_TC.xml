<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 08 Nov 2023 06:13:03 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 跨平台終端仿真軟件 quardCRT]]>
            </title>
            <description>
                <![CDATA[<p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Fwindows.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/windows.yml?branch=main&amp;logo=windows" alt="Windows ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Flinux.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/linux.yml?branch=main&amp;logo=linux" alt="Linux ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Fmacos.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/macos.yml?branch=main&amp;logo=apple" alt="Macos ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.codefactor.io%2Frepository%2Fgithub%2Fqqxiaoming%2FquardCRT"><img src="https://img.shields.io/codefactor/grade/github/qqxiaoming/quardCRT.svg?logo=codefactor" alt="CodeFactor" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/license/qqxiaoming/quardCRT.svg?colorB=f48041&amp;logo=gnu" alt="License" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Freleases"><img src="https://img.shields.io/github/tag/QQxiaoming/quardCRT.svg?logo=git" alt="GitHub tag (latest SemVer)" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Freleases"><img src="https://img.shields.io/github/downloads/QQxiaoming/quardCRT/total.svg?logo=pinboard" alt="GitHub All Releases" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/stars/QQxiaoming/quardCRT.svg?logo=github" alt="GitHub stars" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/forks/QQxiaoming/quardCRT.svg?logo=github" alt="GitHub forks" referrerpolicy="no-referrer"></a><a href="https://gitee.com/QQxiaoming/quardCRT"><img src="https://gitee.com/QQxiaoming/quardCRT/badge/star.svg?theme=dark" alt="Gitee stars" referrerpolicy="no-referrer"></a><a href="https://gitee.com/QQxiaoming/quardCRT"><img src="https://gitee.com/QQxiaoming/quardCRT/badge/fork.svg?theme=dark" alt="Gitee forks" referrerpolicy="no-referrer"></a></p><h1><a id="user-content-quardcrt" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#quardcrt"></a>quardCRT</h1><p><a href="https://gitee.com/QQxiaoming/quardCRT/blob/main/README.md">English</a> | 簡體中文</p><p>quardCRT 一款終端仿真軟件，支持多種後端協議，無依賴跨平台使用，windows/linux/mac 使用體驗完全一致，支持多標籤頁和歷史記錄管理。</p><table><thead><tr><th align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/windows.png" alt="img2" referrerpolicy="no-referrer"></th></tr></thead><tbody><tr><td align="center">Windows</td></tr><tr><td align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/macos.png" alt="img1" referrerpolicy="no-referrer"></td></tr><tr><td align="center">MacOS</td></tr><tr><td align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/linux.png" alt="img3" referrerpolicy="no-referrer"></td></tr><tr><td align="center">Linux</td></tr></tbody></table><p>其他協議選擇界面：</p><p><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/img.png" alt="img" referrerpolicy="no-referrer"></p><h2><a id="user-content-功能描述" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E5%8A%9F%E8%83%BD%E6%8F%8F%E8%BF%B0"></a>功能描述</h2><ul><li><p>目前支持的終端協議包括：</p><ul><li>telnet (支持帶 websocket 封裝)</li><li>serial</li><li>loaclshell</li><li>rawsocket</li><li>windows:NamedPipe（linux/macos:unix domain socket）</li></ul></li><li><p>多標籤頁管理，標籤頁克隆，標籤頁拖拽排序</p></li><li><p>雙列分屏</p></li><li><p>工作目錄書籤</p></li><li><p>自動化發送</p></li><li><p>HEX 顯示</p></li><li><p>會話記錄管理</p></li><li><p>終端樣式配置（配色方案，字體）</p></li><li><p>終端背景圖片配置（支持透明度設置，支持 gif 動畫和視頻）</p></li><li><p>終端滾動行數設置</p></li><li><p>支持深色/淺色主題</p></li><li><p>支持多語言（中文/英文/日文）</p></li></ul><h2><a id="user-content-貢獻" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E8%B4%A1%E7%8C%AE"></a>貢獻</h2><p>如果您對本項目有建議或想法，歡迎在 GitHub 或 Gitee 上提交 issue 和 pull requests。</p><p>目前項目建議使用版本 Qt6.2.0 及更高版本。</p><h2><a id="user-content-特別" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E7%89%B9%E5%88%AB"></a>特別</h2><p>項目目前為個人業餘時間開發，為提高開發效率，本項目較為大量的使用了 GitHub Copilot 協助代碼編寫，部分代碼的人類可讀性可能不是很好，作者也會盡量在後續版本中進行優化。</p><h2><a id="user-content-感謝" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E6%84%9F%E8%B0%A2"></a>感謝</h2><p>本項目代碼引用或部份參考或依賴了以下開源項目，項目完全尊重原項目開源協議，並在此表示感謝。</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FColinDuquesnoy%2FQDarkStyleSheet">QDarkStyleSheet</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fdridk%2FQFontIcon">QFontIcon</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fsilderan%2FQTelnet">QTelnet</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Flxqt%2Fqtermwidget">qtermwidget</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fkafeg%2Fptyqt">ptyqt</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fbitmeal%2Fargv_split">argv_split</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmbadolato%2FiTerm2-Color-Schemes">iTerm2-Color-Schemes</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Frprichard%2Fwinpty">winpty</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FSM-nzberg%2FQtFancyTabWidget">QtFancyTabWidget</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fteknoraver%2Fqtftp">qtftp</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FJuliaStrings%2Futf8proc">utf8proc</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Ffcitx%2Ffcitx-qt5">fcitx-qt5</a></li></ul>]]>
            </description>
            <pubDate>Wed, 08 Nov 2023 06:05:57 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/QQxiaoming/quardCRT</guid>
            <link>https://gitee.com/QQxiaoming/quardCRT</link>
        </item>
        <item>
            <title>
                <![CDATA[極致性能優化：前端 SSR 渲染利器 Qwik.js]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><span><span>引言</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>前端性能已成為網站和應用成功的關鍵要素之一。用戶期望快速加載的頁面和流暢的交互，而前端框架的選擇對於實現這些目標至關重要。然而，傳統的前端框架在某些情況下可能面臨性能挑戰且存在技術壁壘。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在這個充滿挑戰的背景下，我們引入了 Qwik.js 框架。Qwik.js 不僅是一個前端框架，更是一種前端性能的終極解決方案。它不僅提供了卓越的性能，還以其獨特的特點和優勢脫穎而出。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>讓我們一起深入探索 Qwik.js，發現它如何超越傳統，成為前端性能優化的新標杆。</span></span></span></p><span id="OSC_h1_2"></span><h1><span><span><span>一、現有框架的問題</span></span></span></h1><span id="OSC_h4_3"></span><h4><span>1.</span><span><span><span><span>傳統 CSR 方案</span></span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>慢加載時間：</span></strong></span></span><span><span><span> CSR 技術通常要求在瀏覽器中加載和渲染整個頁面，這導致初始頁面加載時間較長。用戶必須等待頁面完全加載才能進行交互。 </span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>搜索引擎優化（SEO）問題：</span></strong></span></span><span><span><span> 由於頁面內容是在客戶端生成的，搜索引擎爬蟲可能無法正確解析和索引頁面內容，這影響了網站的 SEO 效果。 </span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>不利於低帶寬用戶：</span></strong></span></span><span><span><span> 對於低帶寬用戶或網絡條件較差的用戶，CSR 頁面加載時間更長，用戶體驗更差。 </span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>首屏渲染延遲：</span></strong></span></span><span><span><span> CSR 通常需要等待 JavaScript 文件的下載和執行，這導致了首屏渲染的延遲，影響了用戶的第一印象。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>問題分析</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>A. 渲染階段耗時分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="108" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-13xZmbiiPDHyfVKHl.png" width="588" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>B. 請求鏈路分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="311" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-14Jn48bC9MLjg7uj48.png" width="291" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>C. 瀏覽器執行渲染分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="230" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-15HAl9koUb6m9MG98.png" width="345" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h4_4"></span><h4><span><span><span>2. 傳統 SSR 方案</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>複雜的水合過程：</span></strong></span></span><span><span><span> 涉及複雜的水合過程，包括將數據傳輸到客戶端並在客戶端重新渲染頁面。這增加了頁面加載時間和網絡開銷。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>A. 請求鏈路分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="366" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-27a6p7RKalKkQgqE12.png" width="275" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>B. 瀏覽器執行渲染分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="236" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-23GQJadOUFvz9gVjT.png" width="387" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h4_5"></span><h4><span><span><span>什麼是水合（Hydration）？</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>"hydration"（水合）是指通過客戶端 JavaScript 將靜態 HTML 網頁轉化為動態網頁的過程，以實現對 HTML 元素的事件處理。這個過程可以通過將事件處理程序附加到 HTML 元素上來完成</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="304" src="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F4f48568655904e4586ba34b413beb790?width=580" width="390" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>深入瞭解水合（hydration）過程，水合的難點在於知道我們需要什麼事件處理程序以及它們應該附加到哪裏。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>WHAT（什麼）</span></strong></span></span><span><span><span>：事件處理程序是一個封閉包，包含了事件處理程序的行為。它定義了當用戶觸發此事件時應該發生什麼。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>WHERE（哪裏）</span></strong></span></span><span><span><span>：指的是需要將 WHAT（事件處理程序）附加到的 DOM 元素的位置，這包括了事件類型。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>更復雜的部分在於，WHAT（事件處理程序）是一個封閉包，它封閉了 APP_STATE（應用程序狀態）和 FRAMEWORK_STATE（框架內部狀態）：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>APP_STATE（應用程序狀態）</span></strong></span></span><span><span><span>：這是應用程序的狀態。APP_STATE 通常是人們所説的狀態。沒有 APP_STATE，您的應用程序將無法向用戶展示任何動態內容。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>FRAMEWORK_STATE（框架內部狀態）</span></strong></span></span><span><span><span>：這是框架的內部狀態。沒有 FRAMEWORK_STATE，框架不知道應該更新哪些 DOM 節點以及何時應該更新它們。這包括組件樹和對渲染函數的引用等內容。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>那麼，我們如何恢復 WHAT（APP_STATE + FRAMEWORK_STATE）和 WHERE 呢？方法是通過下載並執行當前 HTML 中的組件。在 HTML 中下載和執行已渲染的組件是水合的昂貴部分。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>換句話説，水合是一種通過在瀏覽器中急切地執行應用程序代碼來恢復 APP_STATE 和 FRAMEWORK_STATE 的方法，它涉及以下步驟：</span></span></span></p><ol><li><span><span><span><span>下載組件代碼。</span></span></span></span></li><li><span><span><span><span>執行組件代碼。</span></span></span></span></li><li><span><span><span><span>恢復 WHAT（事件處理程序閉包）和 WHERE（DOM 元素），以獲取事件處理程序閉包。</span></span></span></span></li><li><span><span><span><span>將 WHAT（事件處理程序閉包）附加到 WHERE（DOM 元素）。</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這個過程的關鍵是將 APP_STATE 和 FRAMEWORK_STATE 從已渲染的組件中恢復，以確保應用程序在客戶端獲得正確的狀態和行為。這對於實現前端與後端的協同工作以提供動態用戶體驗至關重要。</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="298" src="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F0e1bbc52c75747328b846dcfa76c28f2?width=905" width="660" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_6"></span><h1><span><span><span>二、Qwik.js 框架的特點</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可恢復性（Resumability）：一種無開銷的水合替代方案，那麼，如何設計一個沒有水合且沒有開銷的系統呢？</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>為了消除開銷，框架不僅必須避免恢復（RECOVERY），還必須避免上述所提到的第四步。第四步是將 WHAT 附加到 WHERE，這是可以避免的成本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>要避免這種成本，您需要三樣東西：</span></span></span></p><ol><li><span><span><span><span>將所有所需的信息序列化為 HTML 的一部分。序列化的信息需要包括 WHAT、WHERE、APP_STATE 和 FRAMEWORK_STATE。</span></span></span></span></li><li><span><span><span><span>一個全局事件處理程序，依賴事件冒泡來攔截所有事件。事件處理程序需要是全局的，這樣我們就不需要急切地在特定的 DOM 元素上單獨註冊所有事件。</span></span></span></span></li><li><span><span><span><span>一個工廠函數，可以延遲恢復事件處理程序（WHAT）。</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這種方法的關鍵是在 HTML 中序列化所有必需的信息，以及使用全局事件處理程序來攔截和處理事件，而不必顯式將事件處理程序附加到特定的 DOM 元素上。這樣可以避免昂貴的步驟四，從而提供無開銷的可恢復性，同時仍能實現前端的互動性和性能優化。</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="304" src="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F04681212764f4025b2b5f5c6a258ad6e?width=905" width="675" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>A. 渲染階段耗時分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="118" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-28K9JFlwTqhvJg8Ai.png" width="500" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>B. 請求鏈路分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="383" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-28R2YSlad187SVu7u.png" width="207" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>C. 瀏覽器執行渲染分析</span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" height="229" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-14-51g7EMHDw7dtR18CZV.png" width="342" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-11-19-32gB18uqO0IYVB18KxX.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_7"></span><h1><span><span><span>四、效果和成果</span></span></span></h1><div><img alt="" height="371" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-18-15-06LfwBVIHYE9RvLeU.png" width="823" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-11-20-00jYipo69U6Njn9Sm.gif" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_8"></span><h1><span><span><span>五、挑戰</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Qwik.js 無水合方案可能會帶來一些挑戰，其中包括以下幾個方面：</span></span></span></p><ol><li><span><span><span><strong><span>新技術的學習曲線</span></strong></span></span><span><span><span>： 採用新的前端架構或技術，如 Qwik.js，通常需要團隊成員學習和適應新的工作流程和最佳實踐。這可能需要一些時間和培訓來確保團隊熟練掌握新技術。</span></span></span></span></li><li><span><span><span><strong><span>服務器開銷增加</span></strong></span></span><span><span><span>： 在無水合方案中，服務器可能需要更多的計算資源來序列化和提供所需的信息，以及處理全局事件處理程序。這可能會導致服務器開銷的增加，特別是在大量併發請求的情況下。</span></span></span></span></li><li><span><span><span><strong><span>Node.js 併發挑戰</span></strong></span></span><span><span><span>： 對於 Node.js 服務器，處理大量併發請求可能會帶來挑戰。在無水合方案中，服務器可能需要同時處理多個請求，因此需要考慮服務器的併發性能和擴展性。</span></span></span></span></li></ol><blockquote><p>作者：京東創新零售，李健</p><p>來源：京東雲開發者社區，轉載請註明來源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Wed, 08 Nov 2023 05:57:57 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10141047</guid>
            <link>https://my.oschina.net/u/4090830/blog/10141047</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[M3 MacBook Pro 無法從預裝的 'Ventura' 系統升級至 'Sonoma']]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>配備標準 M3 芯片的新款入門級 14 英寸 MacBook Pro 已經開始發貨。部分用戶發現，這款新產品預裝的是 macOS Ventura (13.5)，目前無法通過 OTA 升級的方式升級至 macOS Sonoma (14)。</p><p>這些用戶<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Faaronp613%2Fstatus%2F1721742053170684065" target="_blank">表示</a></u>，他們嘗試在「系統設置」中更新到 macOS Sonoma 時，系統提示 macOS Ventura 13.5 是可用的最新版本，而非 macOS Sonoma 14.1。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1108/115949_tV93_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>via<em><u>&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2FZONEofTECH%2Fstatus%2F1721868285732344224" target="_blank">https://twitter.com/ZONEofTECH/status/1721868285732344224</a></u></em></p><p>目前尚不清楚蘋果何時會解決這個問題。軟件研究員 Nicolás Álvarez 表示，受影響用戶可以下載 <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fswcdn.apple.com%2Fcontent%2Fdownloads%2F54%2F11%2F042-41700-A_6GDS7ETYNV%2Fzxpkgymp3w9bm3py7ybs9n9ud27qwnwx7u%2FInstallAssistant.pkg" target="_blank">macOS Sonoma 14.1 安裝助手</a></u>（兼容 M3 版本）並手動安裝更新。</p><p>據稱這個問題也會<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F9to5mac.com%2F2023%2F11%2F07%2Fm3-macbook-pro-imac-sonoma-fails%2F" target="_blank">影響</a></u>搭載 M3 芯片的新款 iMac。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 04:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265559/macbook-pro-m3-macos-sonoma-update-issue</guid>
            <link>https://www.oschina.net/news/265559/macbook-pro-m3-macos-sonoma-update-issue</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[IBM 推出 5 億美元企業 AI 風險投資基金]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">IBM&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.prnewswire.com%2Fnews-releases%2Fibm-launches-500-million-enterprise-ai-venture-fund-301979178.html" target="_blank">宣佈</a>計劃對專注於企業 AI 的初創公司進行更多投資，將啓動一項 5 億美元的風險投資基金。該基金將投資「一系列&nbsp;AI&nbsp;公司 —— 從早期階段到高速增長的初創公司 —— 專注於加速企業的生成式 AI 技術和研究。」</span></p><p><span style="color:#000000">今年 8 月份，IBM&nbsp;還參與了開源 AI 平台 Hugging Face 的 2.35 億美元 D 輪融資。並在近期參投了 AI 模型和資產安全廠商 HiddenLayer 的 5000 萬美元 A 輪融資，此輪融資也是今年專注於保護 AI 的網絡安全公司籌集的最大一筆 A 輪融資。</span></p><p><img height="188" src="https://oscimg.oschina.net/oscnet/up-4118d3cd5048d2cdd19ef109bc0e70b828e.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000">IBM 方面表示，其企業 AI 風險基金將投資於當前和未來的&nbsp;AI&nbsp;領導者，幫助世界各地的企業實現 AI 的商業潛力。該基金由 IBM 的一支專業團隊領導，為每家初創公司提供與 IBM 建立有意義的合作伙伴關係的機會，同時獲得產品和工程以及上市方面的運營專業知識策略。</span></p><p><span style="color:#000000">IBM 軟件高級副總裁兼首席商務官 Rob Thomas 稱，</span></p><p><span style="color:#000000">「到 2030 年，&nbsp;AI&nbsp;預計將創造近 16 萬億美元的生產力。隨着 IBM 企業&nbsp;AI&nbsp;風險投資基金的推出，我們正在開闢另一個渠道，利用 AI 革命的巨大潛力，為 IBM 和我們所投資的公司帶來實實在在的積極成果。這筆基金是我們通過 watsonx 加倍履行我們對負責任的 AI&nbsp;創新的承諾，並幫助企業將這一變革性技術付諸實踐的又一方式。」</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 03:37:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265552/ibm-500-million-enterprise-ai-venture-fund</guid>
            <link>https://www.oschina.net/news/265552/ibm-500-million-enterprise-ai-venture-fund</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[蘋果副總裁迴應「黃金內存」：「統一內存架構」的 8GB 近似於其它系統的 16GB]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>B 站 up 主 @林亦 LYi 最近採訪了蘋果全球產品營銷副總裁 Bob Borchers，期間聊到了大家關心的「祖傳黃金 8GB 內存」問題。</p><p>針對蘋果入門級 MacBook Pro 只給 8GB 內存的問題，Bob Borchers 表示蘋果 MacBook Pro 採用了統一內存架構，所以它與其它系統的內存並不完全相同。因為蘋果內存利用率更高，再加上蘋果的內存壓縮技術，蘋果 M3 款 MacBook Pro 中&nbsp;8GB 內存和其它系統的 16GB 表現接近，所以不能只看紙面參數，要關注實際體驗。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-93ec8d8aebc69057228bb55fb8b7229e485.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a317c842c946aae94e3674f1efda6cef21e.png" referrerpolicy="no-referrer"></p><p>【8G 內存？蘋果高管怎麼看 M3 MacBook Pro？】<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV16M411Q7BG%2F" target="_blank">https://www.bilibili.com/video/BV16M411Q7BG/</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 03:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265547</guid>
            <link>https://www.oschina.net/news/265547</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度向華為訂購 1600 片昇騰 910B AI 芯片，60% 訂單已交付]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reuters.com%2Ftechnology%2Fbaidu-placed-ai-chip-order-huawei-shift-away-nvidia-sources-2023-11-07%2F">根據路透社的報道</a></u>，百度為 200 台服務器訂購了 1600 片昇騰 (Ascend) 910B AI 芯片。到 10 月份，華為已向百度交付了超過 60% 的訂單。</p><p>消息人士稱，訂單總價值約為 4.5 億元人民幣（6183 萬美元），華為將在今年年底前交付所有芯片。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-fb485132e1507877526a821c6e4d46168e9.png" referrerpolicy="no-referrer"></p></blockquote><p>分析稱，與過去通常從英偉達訂購的數千顆芯片相比，儘管這個訂單量規模較小，但知情人士表示它具有重要意義。</p><p>據瞭解，百度與騰訊和阿里巴巴等中國同行一樣，都是英偉達的長期客戶。不過百度此前並不是華為的 AI 芯片客戶。</p><p>儘管華為的 Ascend 芯片在性能上仍被認為遠不如 NVIDIA 的芯片，但消息人士稱，華為的 Ascend 芯片是中國目前最先進的國產芯片，並表示："他們訂購 910B 芯片是為了應對未來可能無法再從 NVIDIA 購買芯片的情況。"</p><p>根據華為網站的公開信息，自 2020 年以來，華為一直與百度合作，使其人工智能平台與華為硬件兼容。今年 8 月，兩家公司表示將深化百度 Ernie AI 模型與華為 Ascend 芯片之間的兼容性。</p><p>天風證券點評稱，昇騰 910B 為 910 的半代升級款，<strong>其性能對標英偉達 A100</strong>，此前星火一體機是 910B 芯片首個對外商業化應用產品。據測算，英偉達限令升級後 2024 年 AI 國產芯片新增市場空間 700 億 +。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 02:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265543</guid>
            <link>https://www.oschina.net/news/265543</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Fedora 39 正式發佈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Fedora 39 已正式發佈。此版本採用 Linux 6.5 內核，更新的版本將作為穩定版更新發布。</p><p><img src="https://static.oschina.net/uploads/space/2023/1108/111228_g9O6_2720166.png" referrerpolicy="no-referrer"></p><p><strong>下載地址</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fworkstation%2Fdownload%2F" target="_blank">Fedora Workstation 39</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fserver%2Fdownload%2F" target="_blank">Fedora Server 39</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fiot%2Fdownload%2F" target="_blank">Fedora IoT 39</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fcloud%2Fdownload%2F" target="_blank">Fedora Cloud 39</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoraproject.org%2Fcoreos%2Fdownload%3Fstream%3Dnext" target="_blank">Fedora CoreOS 「next」 stream</a></li></ul><p>Fedora Workstation 39 搭載 GNOME 45 桌面環境、LibreOffice 7.6 辦公套件、LLVM 17 編譯器棧以及許多其他可用的更新軟件包。</p><p>Fedora 39 還有各種工具鏈升級，如 GCC 13.2 和 GNU Binutils 2.40、Glibc 2.38 以及其他更新，如 Python 3.12 和 RPM 4.19。Fedora Onyx 也將作為 Fedora 不可變變體與 Budgie 桌面正式亮相。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d3bc4d25724768ddc84dd034104a3f7e4e9.png" referrerpolicy="no-referrer"></p><p><strong>以下是官方介紹譯文：</strong></p><p>2003 年 11 月 6 日，Fedora 項目發佈了 Fedora Core 1。二十年後的今天 Fedora Linux 39 正式發佈，這是為台式機、筆記本電腦、服務器、雲、邊緣設備以及您能想到的任何其他設備打造的完整的社區操作系統。</p><p>Fedora 工作站現在採用 GNOME 45，它帶來了更好的性能和許多可用性增強功能，包括一個新的工作區切換器和一個大為改進的圖片查看器。</p><p>如果您正在尋找不同的桌面體驗，Budgie 特別興趣小組已經創建了 Fedora Onyx，這是一個基於 Budgie 的"原子"桌面，與 Fedora Silverblue 的精神一脈相承。</p><p>當然，這還不是全部，系統還提供了 KDE Plasma 桌面、Xfce、Cinnamon 等桌面。</p><p>Fedora 雲鏡像將在 Microsoft Azure（除了 Google Cloud 和 AWS 之外）正式可用。此外，我們的雲鏡像現在已配置為 cloud-init（由您選擇）安裝更新，並在首次調配時重啓，這樣您就可以知道您正在運行的是最新的安全更新。</p><p>一如既往，Fedora 39 更新了很多很多其他軟件包，包含 gcc 13.2、binutils 2.40、glibc 2.38、gdb 13.2 和 rpm 4.19。它還更新了流行的編程語言棧，包括 Python 3.12 和 Rust 1.73。</p><p>特別值得一提的是，系統包含了 Inkscape 的最新版本，這是一款流行的矢量圖形插圖和繪圖工具。Inkscape 昨天也滿 20 週歲了。</p><p>原文：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffedoramagazine.org%2Fannouncing-fedora-linux-39%2F" target="_blank">https://fedoramagazine.org/announcing-fedora-linux-39/</a></u></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 02:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265540/fedora-linux-39</guid>
            <link>https://www.oschina.net/news/265540/fedora-linux-39</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[騰訊開源高性能輕量級跨平台 QUIC 協議庫-TQUIC]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">騰訊開源了一個<span style="background-color:#ffffff">基於 RUST 語言開發的 QUIC 協議庫 -&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FwRC2htPOMYevTgfxIY1uWw" target="_blank">TQUIC</a>，<span style="background-color:#ffffff">旨在打造一個穩定、快速、高性能並具有廣泛技術影響力的傳輸協議庫。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">「</span>由於 QUIC 所具備的廣泛性、長期性、創新性特點，我們開源了自研的 TQUIC 協議庫，也希望借 TQUIC 開源的機會, 吸引更多的同學共建，一起促進傳輸協議的發展，提升互聯網快速和安全的傳輸體驗。<span style="background-color:#ffffff">」</span></span></p><p style="color:#353535; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">TQUIC 協議庫具有如下的優勢：</span></p><ul><li style="text-align:start"><span style="color:#000000"><strong>快傳輸：</strong>TQUIC 是業界支持擁塞控制算法最豐富的協議庫，在全部場景下表現符合 RFC 預期，在弱網和部分場景下傳輸效果領先 2%-30%。</span></li><li style="text-align:start"><span style="color:#000000"><strong>高性能：</strong>TQUIC 在大部分測試場景下的單機處理性能優於同類開源產品 5%，部分場景下單機處理性能領先 20%。</span></li><li style="text-align:start"><span style="color:#000000"><strong>高質量<span style="background-color:#ffffff">：</span></strong>QUIC 協議棧涵蓋 10+篇核心的 RFC 標準或草案，同時涉及到傳輸層、安全層、應用層，複雜度遠大於 TCP。TQUIC 單元測試覆蓋率 95% 以上，與業界四個主流 QUIC 實現的互操性測試用例通過率為 100%， 同時採用基於形式化規範 (SIGCOMM2019 論文成果）的測試方法，嚴格保障了協議一致性。</span></li><li style="text-align:start"><span style="color:#000000"><strong>易用性：</strong>TQUIC 易於使用，支持靈活的配置和豐富的可觀察性；TQUIC 提供了 Rust/C/C++多語言接口，未來計劃進一步提供 Kotlin/Swift 等語言接口。</span></li><li style="text-align:start"><span style="color:#000000"><strong>基於 RUST<span style="background-color:#ffffff">：</span></strong>TQUIC 基於內存安全語言編寫，不受緩衝區溢出漏洞和其他與內存相關缺陷影響。</span></li><li style="text-align:start"><span style="color:#000000"><strong>豐富特性<span style="background-color:#ffffff">：</span></strong>TQUIC 支持所有 QUIC 和 HTTP/3 規範的重要特性。</span></li></ul><p>架構圖：</p><p><img alt="" height="373" src="https://oscimg.oschina.net/oscnet/up-96c0da66ae752f38efa3109e35055f2ffe9.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#353535; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">TQUIC 將跨平台兼容及多併發模型支持作為關鍵的設計目標。TQUIC 核心採用了網絡 IO 及事件循環抽象化設計。TQUIC 核心並不依賴於套接字，而是通過用戶提供的回調來實現。同時，TQUIC 核心沒有強加特定的事件循環要求，它提供了幫助用戶調度事件的函數。TQUIC 的靈活性使得易於在各種系統中的定製和集成。</span></p><p style="color:#353535; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">TQUIC 接口層提供了面向主流平台編程語言的高層級封裝接口，支持同步、異步語義接口，兼容不同的併發模型，並簡化用戶的使用。</span></p><p><span style="color:#000000"><strong>後續規劃：</strong></span></p><ul><li style="text-align:start"><span style="color:#000000">對接開源技術生態，擴大 TQUIC 使用場景，進一步提升 TQUIC 使用體驗。</span></li><li style="text-align:start"><span style="color:#000000">發表相關論文，並逐步開源更多 TQUIC 高級特性和算法。</span></li><li style="text-align:start"><span style="color:#000000">追蹤 QUIC 協議的演進和創新，並持續提升 TQUIC 核心能力。</span></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 02:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265538</guid>
            <link>https://www.oschina.net/news/265538</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Bun 招募運行時工程師，要求 C/C++ 或 Zig 經驗，可遠程]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Bun 公司正在招聘運行時工程師。Bun 是速度極快的 JavaScript 運行時，採用 Zig 編寫，集打包器、轉譯器和包管理器於一身。</p><h4><strong>任職要求</strong></h4><ul><li><p>在系統編程語言如 Zig 或 C/C++方面有豐富的經驗</p></li><li><p>對互聯網技術如 JavaScript/TypeScript 和 HTTP 有深入理解</p></li><li><p>熱衷於編寫快速高效的代碼</p></li></ul><h4><strong>加分項</strong></h4><ul><li><p>具有 Zig 的經驗（大部分的 Bun 都是用 Zig 編寫的）</p></li><li><p>具有 JavaScript 運行時深入層面的經驗：JavaScriptCore、V8、SpiderMonkey</p></li><li><p>理解 UNIX 系統、內核、TCP/UDP 網絡</p></li><li><p>理解如何構建多租戶，大規模分佈式系統</p></li><li><p>開源軟件的維護者或頻繁的貢獻者</p></li></ul><h4><strong>福利</strong></h4><ul><li><p>位置：舊金山市中心有自己的辦公室，並且每天提供免費午餐</p></li><li><p>遠程工作 OK：如果願意搬到舊金山，會提供額外的獎金，但可以在任何地方遠程辦公</p></li><li><p>薪酬：提供具有競爭力的薪酬，包括創業公司的股權，並根據貢獻提供成長空間</p></li><li><p>醫療保健：提供靈活的健康計劃，涵蓋身體和精神健康護理</p></li><li><p>休假：每年享有四周的帶薪休假，包括靈活的病假、家庭假和心理健康假</p></li><li><p>補貼：通勤到辦公室，電腦硬件，辦公室設置，以及健身習慣等方面提供支持</p></li></ul><p><img height="1762" src="https://static.oschina.net/uploads/space/2023/1108/103613_dUzY_3820517.png" width="1458" referrerpolicy="no-referrer"></p><p>詳情查看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fapply.workable.com%2Foven%2Fj%2FA7A1388873%2F" target="_blank">https://apply.workable.com/oven/j/A7A1388873</a></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 02:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265534/bun-hiring-runtime-engineer</guid>
            <link>https://www.oschina.net/news/265534/bun-hiring-runtime-engineer</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[HelloGitHub 社區動態，開啓新的篇章！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107191851907-206780890.png" alt="" referrerpolicy="no-referrer"></p><p>今天這篇文章是 HelloGitHub 社區動態的第一篇文章，所以我想多説兩句，聊聊為啥開啓這個系列。</p><p>我是 2016 年創建的 HelloGitHub，它從最初的一份分享開源項目的月刊，現如今已經成長為 7w+ Star 的開源項目、1w+ 用戶的開源社區、全網 50w+ 的自媒體。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185115225-596937695.png" alt="" referrerpolicy="no-referrer"></p><p>我本是一名普通的程序員，三流的技術水平、毫無文筆、開源門外漢，起初連 Git 都不會，也不知道什麼是開源，就一個猛子扎進來做了 HelloGitHub。為了想讓更多人看到 HelloGitHub 月刊，稀裏糊塗地就做起了「自媒體」。我為了圓自己的站長夢，餓着肚子咬牙重構了 HelloGitHub.com 網站，從最初的 Web 1.0 的月刊展示，升級到了 Web 2.0 的開源社區。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231108085617330-199475160.png" alt="" referrerpolicy="no-referrer"></p><p>聰明的人追着風口跑，很容易就賺到錢了。像我這種愚笨的人，只做「分享開源項目」這一件事情，就花了 7 年的事情，錢沒賺到人還瘦了兩圈😂。</p><p>有人説我不會玩流量，確實我不會，因為在我眼裏每一次點擊、每一個閲讀、每一位粉絲背後都是我的一位朋友。説起來真是慚愧，就是我和朋友們的溝通太少了，因為<strong>我總想一個人、一台電腦、一把鍵盤，做出讓人拍手稱讚的事情</strong>。這件事我試過了，我自己搞不了！</p><p>有錯就要認，捱打要立正。所以，我決定經常和朋友們説説關於 HelloGitHub 社區的事情，<strong>希望通過這個系列打開一個窗口，讓社區成員瞭解項目的發展方向，想加入進來的人知道自己能做些什麼</strong>，同時我也能多瞭解大家的想法，多和朋友們討論，凝聚更多人的力量。</p><p>所以，就有了這篇「HelloGitHub 社區動態」的文章，我是這樣想的：以後每個月月初寫一下上個月關於 HelloGitHub 社區發生的事兒、未來要做的事兒、大家一起能做的事兒。<strong>一羣人做一件值得驕傲的事情</strong>，這事兒沒準能成！</p><p>我要説的就這些，下面正文開始。</p><h2>一、介紹</h2><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185411363-1285676789.gif" alt="" referrerpolicy="no-referrer"></p><p>HelloGitHub 是一個分享 GitHub 上有趣、入門級開源項目的開源社區，由一羣熱愛開源的小夥伴運營，我們<strong>因開源而相聚，為興趣而付出</strong>，希望通過分享和講解開源項目，幫助大家找到編程的樂趣、輕鬆搞定問題的技術方案、令人驚歎的開源神器，從而順應內心的渴望，毫無保留地踏上開源之旅。</p><h2>二、社區動態</h2><p>接下來，我將和「在座」的各位彙報下 10 月份的 HelloGitHub 開源社區的項目進展、貢獻者和未來計劃，歡迎朋友們為社區的建設提供建議、反饋和做貢獻，讓我們並肩攜手共創 HelloGitHub 社區。</p><ul><li>項目進展：介紹主要項目的最新進展情況，包括新增功能、修復的問題、</li><li>貢獻者：表彰和讚揚過去一個月對項目做出傑出貢獻的個人，歡迎新加入開源社區的貢獻者，以及在做的事情和經驗分享。</li><li>下一步計劃：聊一聊接下來要做的事情。</li></ul><h3>2.1 項目進展</h3><p>HelloGitHub 的項目概覽：</p><ol><li>月刊：這裏有好玩、有趣、入門級的開源項目，每月 28 號發刊。</li><li>熱點速遞：每週一更新的週刊，分享和介紹 GitHub 過去一週的熱點項目。</li><li>講解系列：通過一篇文章的篇幅帶你入門一款開源項目，不定期更新。</li><li>社區網站：圍繞開源項目建立的社區，大家可以在這裏分享、發現、評論、打分、收藏感興趣的開源項目。</li></ol><p><strong>社區網站</strong></p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185145824-1576267720.gif" alt="" referrerpolicy="no-referrer"></p><p>上個月主要做了用戶反饋最多的「標籤功能」的優化，入口在 PC 端訪問社區的左側「管理標籤」按鈕（需登錄）。詳情如下：</p><ol><li>為標籤設置了分組，分成了編程語言、技術棧、應用類型、其它共 4 組，方便用戶更快地找到自己感興趣的標籤，對於沒有編程能力的朋友也可以通過桌面應用、Android、Windows、macOS 等標籤找到開箱即用的應用。</li><li>支持拖拽的方式選擇標籤和排序。</li><li>新增 PHP、Ruby、Flutter、嵌入式、Docker、Vue 等 13 個標籤。</li></ol><blockquote><p>地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhellogithub.com%2F" target="_blank">https://hellogithub.com/</a></p></blockquote><p><strong>內容</strong></p><p>HelloGitHub 自媒體 10 月份共發佈了 4 篇 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzA5MzYyNzQ0MQ%3D%3D%26action%3Dgetalbum%26album_id%3D1332112026222641153%26scene%3D173%26from_msgid%3D2247516881%26from_itemidx%3D1%26count%3D3%26nolastread%3D1%23wechat_redirect" target="_blank">GitHub 熱點速遞</a>、1 篇<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzA5MzYyNzQ0MQ%3D%3D%26action%3Dgetalbum%26album_id%3D1332147780885856258%26scene%3D173%26from_msgid%3D2247516865%26from_itemidx%3D1%26count%3D3%26nolastread%3D1%23wechat_redirect" target="_blank">講解開源項目的文章</a>、1 篇 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzA5MzYyNzQ0MQ%3D%3D%26action%3Dgetalbum%26album_id%3D1331197538447310849%26scene%3D173%26from_msgid%3D2247516838%26from_itemidx%3D1%26count%3D3%26nolastread%3D1%23wechat_redirect" target="_blank">HelloGitHub 月刊</a>。</p><h3>2.2 貢獻者</h3><p>因為這是第一篇社區動態，所以我必須要感謝下 2023 至今的所有貢獻者，他們的每個貢獻對於我來説都是雪中送炭，主要集中於 HelloGitHub 社區前端代碼的貢獻。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185421588-1660267532.png" alt="" referrerpolicy="no-referrer"></p><ul><li>@胤玄、@cqh：完成管理標籤功能的設計和優化</li><li>@胤玄：修復月刊目錄的問題、修復了彈出對話框後背景頁面滾動的問題</li><li>@GJSSS：修復圖片預覽時沒有關閉圖標的問題、主題切換按鈕的樣式</li><li>@Maidang：修復黑暗主題下點擊詳情頁的問題</li></ul><p><strong>如何貢獻</strong></p><p>如果你會寫代碼可以加入到 HelloGitHub 社區的開發中，前後端都需要。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185426160-863675536.png" alt="" referrerpolicy="no-referrer"></p><blockquote><p>需求列表：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FHelloGitHub-Team%2Fgeese%2Fissues%2F38" target="_blank">https://github.com/HelloGitHub-Team/geese/issues/38</a></p></blockquote><p>如果你喜歡寫文章歡迎投稿到 HelloGitHub，可以是你上手開源項目的經過、開源項目評測對比、有趣的開源項目集合等，不用擔心寫得不夠好，只要是用心寫的內容，我會和你一同完成它。</p><p>如果你發現了優秀的開源項目，歡迎分享到 HelloGitHub 讓更多人知道。</p><p><img src="https://img2023.cnblogs.com/blog/759200/202311/759200-20231107185430278-2003963940.gif" alt="" referrerpolicy="no-referrer"></p><p>希望 HelloGitHub 能成為你開源之路的第一站，讓我們一同成長，一起做值得驕傲的事情。</p><h3>2.3 下一步計劃</h3><p>為了能讓「社區動態」持續更新，所以每個月必須做出點成績來，才能向大家彙報。第一期我就説一下我自己下一步的打算，後面會結合朋友們的想法，來制定下一步計劃：</p><ol><li>幫助新加入的貢獻者為 HelloGitHub 做貢獻，多溝通、提供保姆級幫助。</li><li>完成網站搜索功能的優化，打通公眾號，即在公眾號發消息也能得到開源項目搜索結果。</li><li>為網站加入 AIGC 的功能，比如：根據自然語言描述推薦開源項目。</li><li>我想採訪一些「民間」做開源的人，講出他們的故事。</li><li>做視頻自媒體，這個事情我一直想做但始終沒有走出第一步，希望有人能推我一把。</li><li>天冷了是時候吃一頓火鍋了，搞一個線下的「開源人火鍋局」，互認識一下聊聊開源的酸甜苦辣，看看有沒有臭味相投的人。</li></ol><p>對上面的計劃感興趣的小夥伴，歡迎與我聯繫一起搞事情，也可以留言説出你的想法。</p><h2>三、最後</h2><p>如果把開源當成是一個愛好的話，就不會去深究為什麼要花時間在上面，因為從中能得到快樂和滿足感，就夠了。</p><p>最後，希望有了大家的陪伴，我們彼此的開源之路不再孤單和苦悶，而是充滿更多的歡聲笑語。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 02:17:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/HelloGitHub/blog/10141490</guid>
            <link>https://my.oschina.net/HelloGitHub/blog/10141490</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[LME - 日誌記錄和保護性監控解決方案]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Logging Made Easy (LME) 是一個免費、開放的日誌記錄和保護性監控解決方案，為所有組織提供服務。</p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Logging Made Easy 最初由 NCSC 創建，現在由 CISA 維護，是一個為小型組織提供的自助安裝教程，旨在為 Windows 客戶端獲得基本級別的集中安全日誌記錄並提供檢測攻擊的功能。它是多個免費和開放軟件平台的結合，LME 幫助讀者將它們集成在一起以產生端到端的日誌記錄功能。還提供了一些預製的配置文件和腳本。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>該項目可以：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>顯示已註冊設備上運行管理命令的位置</li><li>查看誰在使用哪台機器</li><li>結合威脅報告，可以以策略、技術和程序 (TTP) 的形式查詢攻擊者的存在</li></ul><p><img height="229" src="https://static.oschina.net/uploads/space/2023/1101/164801_RGai_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 01:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/lme</guid>
            <link>https://www.oschina.net/p/lme</link>
        </item>
        <item>
            <title>
                <![CDATA[Xmake v2.8.5 發佈，支持鏈接排序和單元測試]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake" target="_blank">Xmake</a><span>&nbsp;</span>是一個基於 Lua 的輕量級跨平台構建工具。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它非常的輕量，沒有任何依賴，因為它內置了 Lua 運行時。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它使用 xmake.lua 維護項目構建，相比 makefile/CMakeLists.txt，配置語法更加簡潔直觀，對新手非常友好，短時間內就能快速入門，能夠讓用戶把更多的精力集中在實際的項目開發上。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們能夠使用它像 Make/Ninja 那樣可以直接編譯項目，也可以像 CMake/Meson 那樣生成工程文件，另外它還有內置的包管理系統來幫助用戶解決 C/C++ 依賴庫的集成使用問題。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">目前，Xmake 主要用於 C/C++ 項目的構建，但是同時也支持其他 native 語言的構建，可以實現跟 C/C++ 進行混合編譯，同時編譯速度也是非常的快，可以跟 Ninja 持平。</p><div><pre><code>Xmake = Build backend + Project Generator + Package Manager + [Remote|Distributed] Build + Cache
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">儘管不是很準確，但我們還是可以把 Xmake 按下面的方式來理解：</p><div><pre><code>Xmake ≈ Make/Ninja + CMake/Meson + Vcpkg/Conan + distcc + ccache/sccache
</code></pre></div><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake" target="_blank">項目源碼</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fxmake.io%2F%23%2Fzh-cn%2F" target="_blank">官方文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fxmake.io%2F%23%2Fzh-cn%2Fabout%2Fcourse" target="_blank">入門課程</a></li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><img src="https://github.com/xmake-io/xmake-docs/raw/master/assets/img/index/package.gif" width="650px" referrerpolicy="no-referrer"></p><h2>新特性介紹</h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在介紹新特性之前，我們有一個好消息要告訴大家，Xmake 最近進入了 Debian 的官方倉庫：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpackages.debian.org%2Fsid%2Fxmake" target="_blank">https://packages.debian.org/sid/xmake</a>， 等到明年 4 月份 Ubuntu 24.04 發佈，我們應該就能直接通過<span>&nbsp;</span><code>apt install xmake</code><span>&nbsp;</span>命令去快速安裝 Xmake 了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">同時也感謝 @Lance Lin 的幫助，他全程幫助我們維護並上傳 Xmake 包到 Debian 倉庫，真的非常感謝！</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">接下來，我們來介紹下 2.8.5 版本引入的一些改動，這個版本帶來了很多的新特性，尤其是對鏈接排序，鏈接組的支持，還有對<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>內置單元測試的支持。 另外，我們還新增了 Apple XROS 平台的構建支持，可以用於構建蘋果新的 VisionOS 上的程序，還有我們還提供了更加靈活通用的<span>&nbsp;</span><code>check_sizeof</code><span>&nbsp;</span>檢測接口，用於快速檢測類型的大小。</p><h3>鏈接重排序支持</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這是一個存在了兩年多的需求，主要用於調整 target 內部的鏈接順序。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">由於 xmake 提供了<span>&nbsp;</span><code>add_links</code>,<span>&nbsp;</span><code>add_deps</code>,<span>&nbsp;</span><code>add_packages</code>,<span>&nbsp;</span><code>add_options</code><span>&nbsp;</span>接口，可以配置目標、依賴，包和選項中的鏈接，儘管<span>&nbsp;</span><code>add_links</code><span>&nbsp;</span>本身的鏈接順序可以根據添加順序來調整。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是 links，deps 和 packages 之間的鏈接順序，只能按固定順序生成，無法靈活調整，這對於一些複雜的項目，就有點顯得力不從心了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">而我們在這個版本，徹底解決了這個問題，新增了<span>&nbsp;</span><code>add_linkorders</code><span>&nbsp;</span>接口，可用於配置目標、依賴、包、選項、鏈接組引入的各種鏈接順序。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">更多詳情和背景，請見：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F1452" target="_blank">#1452</a></p><h4>排序鏈接</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">為了更加靈活的調整 target 內部的各種鏈接順序，我們可以通過<span>&nbsp;</span><code>add_linkorders</code><span>&nbsp;</span>這個新接口來實現，例如：</p><div><pre><code><span style="color:#000000">add_links</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><span style="color:#ff00ff">"c"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>,</strong><span style="color:#ff00ff">"e"</span><strong>)</strong><em>-- e -&gt; b -&gt; a</em><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"e"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><span style="color:#ff00ff">"a"</span><strong>)</strong><em>-- e -&gt; d</em><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"e"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">add_links 是配置的初始鏈接順序，然後我們通過 add_linkorders 配置了兩個局部鏈接依賴<span>&nbsp;</span><code>e -&gt; b -&gt; a</code><span>&nbsp;</span>和<span>&nbsp;</span><code>e -&gt; d</code><span>&nbsp;</span>後。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">xmake 內部就會根據這些配置，生成 DAG 圖，通過拓撲排序的方式，生成最終的鏈接順序，提供給鏈接器。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">當然，如果存在循環依賴，產生了環，它也會提供警告信息。</p><h4>排序鏈接和鏈接組</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，對於循環依賴，我們也可以通過<span>&nbsp;</span><code>add_linkgroups</code><span>&nbsp;</span>配置鏈接組的方式也解決。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">並且<span>&nbsp;</span><code>add_linkorders</code><span>&nbsp;</span>也能夠對鏈接組進行排序。</p><div><pre><code><span style="color:#000000">add_links</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><span style="color:#ff00ff">"c"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>,</strong><span style="color:#ff00ff">"e"</span><strong>)</strong><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"c"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>,</strong><strong>{</strong><span style="color:#000000">name</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">group</span><strong>=</strong><strong>true</strong><strong>})</strong><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"e"</span><strong>,</strong><span style="color:#ff00ff">"linkgroup::foo"</span><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果要排序鏈接組，我們需要對每個鏈接組取個名，<code><span>{</span><span>name</span><span><span>&nbsp;</span></span><span>=</span><span><span>&nbsp;</span></span><span>"foo"</span><span>}</span></code><span>&nbsp;</span>，然後就能在<span>&nbsp;</span><code>add_linkorders</code><span>&nbsp;</span>裏面通過<span>&nbsp;</span><code>linkgroup::foo</code><span>&nbsp;</span>去引用配置了。</p><h4>排序鏈接和 frameworks</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以排序鏈接和 macOS/iPhoneOS 的 frameworks。</p><div><pre><code><span style="color:#000000">add_links</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><span style="color:#ff00ff">"c"</span><strong>,</strong><span style="color:#ff00ff">"d"</span><strong>,</strong><span style="color:#ff00ff">"e"</span><strong>)</strong><span style="color:#000000">add_frameworks</span><strong>(</strong><span style="color:#ff00ff">"Foundation"</span><strong>,</strong><span style="color:#ff00ff">"CoreFoundation"</span><strong>)</strong><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"e"</span><strong>,</strong><span style="color:#ff00ff">"framework::CoreFoundation"</span><strong>)</strong></code></pre></div><h4>完整例子</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">相關的完整例子，我們可以看下：</p><div><pre><code><span style="color:#000000">add_rules</span><strong>(</strong><span style="color:#ff00ff">"mode.debug"</span><strong>,</strong><span style="color:#ff00ff">"mode.release"</span><strong>)</strong><span style="color:#000000">add_requires</span><strong>(</strong><span style="color:#ff00ff">"libpng"</span><strong>)</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"bar"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"shared"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/foo.cpp"</span><strong>)</strong><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"m"</span><strong>,</strong><span style="color:#ff00ff">"pthread"</span><strong>,</strong><strong>{</strong><span style="color:#000000">whole</span><strong>=</strong><strong>true</strong><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"foo"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"static"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/foo.cpp"</span><strong>)</strong><span style="color:#000000">add_packages</span><strong>(</strong><span style="color:#ff00ff">"libpng"</span><strong>,</strong><strong>{</strong><span style="color:#000000">public</span><strong>=</strong><strong>true</strong><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"demo"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">add_deps</span><strong>(</strong><span style="color:#ff00ff">"foo"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/main.cpp"</span><strong>)</strong><span style="color:blue">if</span><span style="color:#000000">is_plat</span><strong>(</strong><span style="color:#ff00ff">"linux"</span><strong>,</strong><span style="color:#ff00ff">"macosx"</span><strong>)</strong><span style="color:blue">then</span><span style="color:#000000">add_syslinks</span><strong>(</strong><span style="color:#ff00ff">"pthread"</span><strong>,</strong><span style="color:#ff00ff">"m"</span><strong>,</strong><span style="color:#ff00ff">"dl"</span><strong>)</strong><span style="color:blue">end</span><span style="color:blue">if</span><span style="color:#000000">is_plat</span><strong>(</strong><span style="color:#ff00ff">"macosx"</span><strong>)</strong><span style="color:blue">then</span><span style="color:#000000">add_frameworks</span><strong>(</strong><span style="color:#ff00ff">"Foundation"</span><strong>,</strong><span style="color:#ff00ff">"CoreFoundation"</span><strong>)</strong><span style="color:blue">end</span><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"framework::Foundation"</span><strong>,</strong><span style="color:#ff00ff">"png16"</span><strong>,</strong><span style="color:#ff00ff">"foo"</span><strong>)</strong><span style="color:#000000">add_linkorders</span><strong>(</strong><span style="color:#ff00ff">"dl"</span><strong>,</strong><span style="color:#ff00ff">"linkgroup::syslib"</span><strong>)</strong><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"m"</span><strong>,</strong><span style="color:#ff00ff">"pthread"</span><strong>,</strong><strong>{</strong><span style="color:#000000">name</span><strong>=</strong><span style="color:#ff00ff">"syslib"</span><strong>,</strong><span style="color:#000000">group</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">完整工程在：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fblob%2Fmaster%2Ftests%2Fprojects%2Fc%252B%252B%2Flinkorders%2Fxmake.lua" target="_blank">linkorders example</a></p><h3>鏈接組支持</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，這個版本，我們還新增了鏈接組的原生支持，它目前主要用於 linux 平台的編譯，僅支持 gcc/clang 編譯器。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">需要注意的是 gcc/clang 裏面的鏈接組概念主要特指：<code>-Wl,--start-group</code></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">而 Xmake 對齊進行了封裝，做了進一步抽象，並且不僅僅用於處理<span>&nbsp;</span><code>-Wl,--start-group</code>，還可以處理<span>&nbsp;</span><code>-Wl,--whole-archive</code><span>&nbsp;</span>和<span>&nbsp;</span><code>-Wl,-Bstatic</code>。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">下面我們會一一對其進行講解。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">更多詳情見：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F1452" target="_blank">#1452</a></p><h4>–start-group 支持</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><code>-Wl,--start-group</code><span>&nbsp;</span>和<span>&nbsp;</span><code>-Wl,--end-group</code><span>&nbsp;</span>是用於處理複雜庫依賴關係的鏈接器選項，確保鏈接器可以解決符號依賴併成功連接多個庫。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 xmake 中，我們可以通過下面的方式實現：</p><div><pre><code><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它會對應生成<span>&nbsp;</span><code>-Wl,--start-group -la -lb -Wl,--end-group</code><span>&nbsp;</span>鏈接選項。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果 a 和 b 庫之間有符號的循環依賴，也不會報鏈接錯誤，能夠正常鏈接成功。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">對於不支持的平台和編譯，會退化成<span>&nbsp;</span><code>-la -lb</code></p><h4>–whole-archive 支持</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><code>--whole-archive</code><span>&nbsp;</span>是一個鏈接器選項，通常用於處理靜態庫。 它的作用是告訴鏈接器將指定的靜態庫中的所有目標文件都包含到最終可執行文件中，而不僅僅是滿足當前符號依賴的目標文件。 這可以用於確保某些庫的所有代碼都被鏈接，即使它們在當前的符號依賴關係中沒有直接引用。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">更多信息，可以參考 gcc/clang 的文檔。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 xmake 中，我們可以通過下面的方式實現：</p><div><pre><code><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><strong>{</strong><span style="color:#000000">whole</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它會對應生成<span>&nbsp;</span><code>-Wl,--whole-archive -la -lb -Wl,--no-whole-archive</code><span>&nbsp;</span>鏈接選項。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">對於不支持的平台和編譯，會退化成<span>&nbsp;</span><code>-la -lb</code></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，我們可以同時配置 group/whole：</p><div><pre><code><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><strong>{</strong><span style="color:#000000">whole</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">group</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><h4>-Bstatic 支持</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><code>-Bstatic</code><span>&nbsp;</span>也是用於編譯器（如 gcc）的選項，用於指示編譯器在鏈接時只使用靜態庫而不使用共享庫。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">更多信息，可以參考 gcc/clang 的文檔。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 xmake 中，我們可以通過下面的方式實現：</p><div><pre><code><span style="color:#000000">add_linkgroups</span><strong>(</strong><span style="color:#ff00ff">"a"</span><strong>,</strong><span style="color:#ff00ff">"b"</span><strong>,</strong><strong>{</strong><span style="color:#000000">static</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它會對應生成<span>&nbsp;</span><code>-Wl,-Bstatic -la -lb -Wl,-Bdynamic</code><span>&nbsp;</span>鏈接選項。</p><h3>單元測試支持</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">新版本中，我們還增加了一個內置的測試命令：<code>xmake test</code>，我們只需要在需要測試的 target 上通過 add_tests 配置一些測試用例，就可以自動執行測試。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">即使當前 target 被設置成了<span>&nbsp;</span><code>set_default(false)</code>，在執行測試的時候，xmake 也還是會先自動編譯它們，然後自動運行所有的測試。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們可以先看個整體的例子，大概知道下它是怎麼樣子的。</p><div><pre><code><span style="color:#000000">add_rules</span><strong>(</strong><span style="color:#ff00ff">"mode.debug"</span><strong>,</strong><span style="color:#ff00ff">"mode.release"</span><strong>)</strong><span style="color:blue">for</span><span style="color:#000000">_</span><strong>,</strong><span style="color:#000000">file</span><span style="color:blue">in</span><span style="color:black">ipairs</span><strong>(</strong><span style="color:#000000">os</span><strong>.</strong><span style="color:#000000">files</span><strong>(</strong><span style="color:#ff00ff">"src/test_*.cpp"</span><strong>))</strong><span style="color:blue">do</span><span style="color:blue">local</span><span style="color:#000000">name</span><strong>=</strong><span style="color:#000000">path</span><strong>.</strong><span style="color:#000000">basename</span><strong>(</strong><span style="color:#000000">file</span><strong>)</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#000000">name</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/"</span><strong>..</strong><span style="color:#000000">name</span><strong>..</strong><span style="color:#ff00ff">".cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"default"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"args"</span><strong>,</strong><strong>{</strong><span style="color:#000000">runargs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#ff00ff">"bar"</span><strong>}})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"pass_output"</span><strong>,</strong><strong>{</strong><span style="color:#000000">trim_output</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">runargs</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello foo"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"fail_output"</span><strong>,</strong><strong>{</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"hello2 .*"</span><strong>,</strong><span style="color:#ff00ff">"hello xmake"</span><strong>}})</strong><span style="color:blue">end</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這個例子，自動掃描源碼目錄下的<span>&nbsp;</span><code>test_*.cpp</code><span>&nbsp;</span>源文件，然後每個文件自動創建一個測試目標，它被設置成了<span>&nbsp;</span><code>set_default(false)</code>，也就是正常情況下，默認不會編譯它們。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是，如果執行<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>進行測試，它們就會被自動編譯，然後測試運行，運行效果如下：</p><div><pre><code>ruki-2:test ruki<span style="color:black">$ </span>xmake <span style="color:black">test
</span>running tests ...
<strong>[</strong>  2%]: test_1/args        .................................... passed 7.000s
<strong>[</strong>  5%]: test_1/default     .................................... passed 5.000s
<strong>[</strong>  8%]: test_1/fail_output .................................... passed 5.000s
<strong>[</strong> 11%]: test_1/pass_output .................................... passed 6.000s
<strong>[</strong> 13%]: test_2/args        .................................... passed 7.000s
<strong>[</strong> 16%]: test_2/default     .................................... passed 6.000s
<strong>[</strong> 19%]: test_2/fail_output .................................... passed 6.000s
<strong>[</strong> 22%]: test_2/pass_output .................................... passed 6.000s
<strong>[</strong> 25%]: test_3/args        .................................... passed 7.000s
<strong>[</strong> 27%]: test_3/default     .................................... passed 7.000s
<strong>[</strong> 30%]: test_3/fail_output .................................... passed 6.000s
<strong>[</strong> 33%]: test_3/pass_output .................................... passed 6.000s
<strong>[</strong> 36%]: test_4/args        .................................... passed 6.000s
<strong>[</strong> 38%]: test_4/default     .................................... passed 6.000s
<strong>[</strong> 41%]: test_4/fail_output .................................... passed 5.000s
<strong>[</strong> 44%]: test_4/pass_output .................................... passed 6.000s
<strong>[</strong> 47%]: test_5/args        .................................... passed 5.000s
<strong>[</strong> 50%]: test_5/default     .................................... passed 6.000s
<strong>[</strong> 52%]: test_5/fail_output .................................... failed 6.000s
<strong>[</strong> 55%]: test_5/pass_output .................................... failed 5.000s
<strong>[</strong> 58%]: test_6/args        .................................... passed 7.000s
<strong>[</strong> 61%]: test_6/default     .................................... passed 6.000s
<strong>[</strong> 63%]: test_6/fail_output .................................... passed 6.000s
<strong>[</strong> 66%]: test_6/pass_output .................................... passed 6.000s
<strong>[</strong> 69%]: test_7/args        .................................... failed 6.000s
<strong>[</strong> 72%]: test_7/default     .................................... failed 7.000s
<strong>[</strong> 75%]: test_7/fail_output .................................... failed 6.000s
<strong>[</strong> 77%]: test_7/pass_output .................................... failed 5.000s
<strong>[</strong> 80%]: test_8/args        .................................... passed 7.000s
<strong>[</strong> 83%]: test_8/default     .................................... passed 6.000s
<strong>[</strong> 86%]: test_8/fail_output .................................... passed 6.000s
<strong>[</strong> 88%]: test_8/pass_output .................................... failed 5.000s
<strong>[</strong> 91%]: test_9/args        .................................... passed 6.000s
<strong>[</strong> 94%]: test_9/default     .................................... passed 6.000s
<strong>[</strong> 97%]: test_9/fail_output .................................... passed 6.000s
<strong>[</strong>100%]: test_9/pass_output .................................... passed 6.000s

<span style="color:#8f5902">80% </span>tests passed, 7 tests failed out of 36, spent 0.242s
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><img alt="" src="https://tboox.org/assets/img/manual/xmake-test1.png" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以執行<span>&nbsp;</span><code>xmake test -vD</code><span>&nbsp;</span>查看詳細的測試失敗的錯誤信息：</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><img alt="" src="https://tboox.org/assets/img/manual/xmake-test2.png" referrerpolicy="no-referrer"></p><h4>運行指定測試目標</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以指定運行指定 target 的某個測試：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test </span>targetname/testname
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">或者按模式匹配的方式，運行一個 target 的所有測試，或者一批測試：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test </span>targetname/<span style="color:blue">*</span><span style="color:#8f5902">$ </span>xmake <span style="color:black">test </span>targetname/foo<span style="color:blue">*</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">也可以運行所有 target 的同名測試：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span><span style="color:blue">*</span>/testname
</code></pre></div><h4>並行化運行測試</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">其實，默認就是並行化運行的，但是我們可以通過<span>&nbsp;</span><code>-jN</code><span>&nbsp;</span>調整運行的並行度。</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -jN
</code></pre></div><h4>分組運行測試</h4><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -g <span style="color:#ff00ff">"foo"</span><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -g <span style="color:#ff00ff">"foo*"</span></code></pre></div><h4>添加測試到目標（無參數）</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果沒有配置任何參數，僅僅配置了測試名到<span>&nbsp;</span><code>add_tests</code>，那麼僅僅測試這個目標程序的是否會運行失敗，根據退出代碼來判斷是否通過測試。</p><div><pre><code>target("test")
    add_tests("testname")
</code></pre></div><h4>配置運行參數</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過<span>&nbsp;</span><code><span>{</span><span>runargs</span><span><span>&nbsp;</span></span><span>=</span><span><span>&nbsp;</span></span><span>{</span><span>"arg1"</span><span>,</span><span><span>&nbsp;</span></span><span>"arg2"</span><span>}}</span></code><span>&nbsp;</span>的方式，給<span>&nbsp;</span><code>add_tests</code><span>&nbsp;</span>配置指定測試需要運行的參數。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，一個 target 可以同時配置多個測試用例，每個測試用例可獨立運行，互不衝突。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">runargs</span><strong>=</strong><span style="color:#ff00ff">"arg1"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">runargs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"arg1"</span><strong>,</strong><span style="color:#ff00ff">"arg2"</span><strong>}})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果我們沒有配置 runargs 到<span>&nbsp;</span><code>add_tests</code>，那麼我們也會嘗試從被綁定的 target 中，獲取<span>&nbsp;</span><code>set_runargs</code><span>&nbsp;</span>設置的運行參數。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">set_runargs</span><strong>(</strong><span style="color:#ff00ff">"arg1"</span><strong>,</strong><span style="color:#ff00ff">"arg2"</span><strong>)</strong></code></pre></div><h4>配置運行目錄</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過 rundir 設置測試運行的當前工作目錄，例如：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">rundir</span><strong>=</strong><span style="color:#000000">os</span><strong>.</strong><span style="color:#000000">projectdir</span><strong>()})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果我們沒有配置 rundir 到<span>&nbsp;</span><code>add_tests</code>，那麼我們也會嘗試從被綁定的 target 中，獲取<span>&nbsp;</span><code>set_rundir</code><span>&nbsp;</span>設置的運行目錄。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">set_rundir</span><strong>(</strong><span style="color:#ff00ff">"$(projectdir)"</span><strong>)</strong></code></pre></div><h4>配置運行環境</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過 runenvs 設置一些運行時候的環境變量，例如：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">runenvs</span><strong>=</strong><strong>{</strong><span style="color:#000000">LD_LIBRARY_PATH</span><strong>=</strong><span style="color:#ff00ff">"/lib"</span><strong>}})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果我們沒有配置 runenvs 到<span>&nbsp;</span><code>add_tests</code>，那麼我們也會嘗試從被綁定的 target 中，獲取<span>&nbsp;</span><code>add_runenvs</code><span>&nbsp;</span>設置的運行環境。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">add_runenvs</span><strong>(</strong><span style="color:#ff00ff">"LD_LIBRARY_PATH"</span><strong>,</strong><span style="color:#ff00ff">"/lib"</span><strong>)</strong></code></pre></div><h4>匹配輸出結果</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">默認情況下，<code>xmake test</code><span>&nbsp;</span>會根據測試運行的退出代碼是否為 0，來判斷是否測試通過。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">當然，我們也可以通過配置測試運行的輸出結果是否滿足我們的指定的匹配模式，來判斷是否測試通過。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">主要通過這兩個參數控制：</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#f8f8fd; border-bottom:2px solid #777777; border-collapse:collapse; border-top:2px solid #777777; color:#333333; font-family:&quot;Helvetica Neue&quot;,Helvetica,Arial,&quot;Microsoft YaHei&quot;,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin:8px 0px; orphans:2; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; word-spacing:0px"><tbody><tr><th style="text-align:left">參數</th><th style="text-align:left">説明</th></tr></tbody><tbody><tr><td>pass_outputs</td><td>如果輸出匹配，則測試通過</td></tr><tr><td>fail_outputs</td><td>如果輸出匹配，則測試失敗</td></tr></tbody></table><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">傳入<span>&nbsp;</span><code>pass_outputs</code><span>&nbsp;</span>和<span>&nbsp;</span><code>fail_outputs</code><span>&nbsp;</span>的是一個 lua 匹配模式的列表，但模式稍微做了一些簡化，比如對<span>&nbsp;</span><code>*</code><span>&nbsp;</span>的處理。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果要匹配成功，則測試通過，可以這麼配置：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname1"</span><strong>,</strong><strong>{</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname2"</span><strong>,</strong><strong>{</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello *"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname3"</span><strong>,</strong><strong>{</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"hello"</span><strong>,</strong><span style="color:#ff00ff">"hello *"</span><strong>}})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果要匹配成功，則測試失敗，可以這麼配置：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname1"</span><strong>,</strong><strong>{</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname2"</span><strong>,</strong><strong>{</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello *"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname3"</span><strong>,</strong><strong>{</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><strong>{</strong><span style="color:#ff00ff">"hello"</span><strong>,</strong><span style="color:#ff00ff">"hello *"</span><strong>}})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以同時配置它們：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">由於一些測試輸出的結果，尾部會有一些換行什麼的空白字符，幹擾匹配模式，我們可以再配置<span>&nbsp;</span><code>trim_output = true</code>，先截斷空白字符後，再做匹配。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">trim_output</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們還可以配置<span>&nbsp;</span><code><span>{</span><span>plain</span><span><span>&nbsp;</span></span><span>=</span><span><span>&nbsp;</span></span><span>true</span><span>}</span></code><span>&nbsp;</span>是禁用 lua 模式匹配，僅僅做最基礎的平坦文本匹配。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>,</strong><strong>{</strong><span style="color:#000000">plain</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">pass_outputs</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>,</strong><span style="color:#000000">fail_outputs</span><strong>=</strong><span style="color:#ff00ff">"hello"</span><strong>})</strong></code></pre></div><h4>配置測試組</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過<span>&nbsp;</span><code>group = "foo"</code><span>&nbsp;</span>來配置一個測試組，進行分組測試：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname1"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname2"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><span style="color:#ff00ff">"foo"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname3"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><span style="color:#ff00ff">"bar"</span><strong>})</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname4"</span><strong>,</strong><strong>{</strong><span style="color:#000000">group</span><strong>=</strong><span style="color:#ff00ff">"bae"</span><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">其中 testname1/testname2 是一個組 foo，另外兩個是在另外一個組。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">然後，我們就可以使用<span>&nbsp;</span><code>xmake test -g groupname</code><span>&nbsp;</span>來進行分組測試了。</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -g <span style="color:#ff00ff">"foo"</span><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span> -g <span style="color:#ff00ff">"foo*"</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">!&gt; 運行分組，也是支持模式匹配的。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，如果沒有設置<span>&nbsp;</span><code>group</code><span>&nbsp;</span>參數給<span>&nbsp;</span><code>add_tests</code>，我們也可以默認獲取綁定到 target 的組名。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">set_group</span><strong>(</strong><span style="color:#ff00ff">"foo"</span><strong>)</strong></code></pre></div><h4>自定義測試腳本</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們還新增了<span>&nbsp;</span><code>before_test</code>,<span>&nbsp;</span><code>on_test</code><span>&nbsp;</span>和<span>&nbsp;</span><code>after_test</code><span>&nbsp;</span>配置腳本，用戶可以在 rule 和 target 域，自定義配置它們實現定製化的測試執行。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">on_test</span><strong>(</strong><span style="color:blue">function</span><strong>(</strong><span style="color:#000000">target</span><strong>,</strong><span style="color:#000000">opt</span><strong>)</strong><span style="color:black">print</span><strong>(</strong><span style="color:#000000">opt</span><strong>.</strong><span style="color:#000000">name</span><strong>,</strong><span style="color:#000000">opt</span><strong>.</strong><span style="color:#000000">runenvs</span><strong>,</strong><span style="color:#000000">opt</span><strong>.</strong><span style="color:#000000">runargs</span><strong>,</strong><span style="color:#000000">opt</span><strong>.</strong><span style="color:#000000">pass_outputs</span><strong>)</strong><em>-- do test</em><em>-- ...</em><em>-- passed</em><span style="color:blue">return</span><strong>true</strong><em>-- failied</em><span style="color:blue">return</span><strong>false</strong><strong>,</strong><span style="color:#000000">errors</span><span style="color:blue">end</span><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">其中，opt 裏面可以獲取到所有傳入<span>&nbsp;</span><code>add_tests</code><span>&nbsp;</span>的參數，我們在 on_test 裏面自定義測試邏輯，然後返回 true 就是測試通過，返回 false 就是測試失敗，然後繼續返回測試失敗的錯誤信息。</p><h4>自動化構建</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">由於測試目標在正常開發構建階段，通常是不需要被構建的，因此我們會設置<span>&nbsp;</span><code>set_default(false)</code>。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"testname"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是運行<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>進行測試時候，這些測試對應的 target 還是會被自動構建，確保能夠被運行。</p><div><pre><code><span style="color:#8f5902">$ </span>xmake <span style="color:black">test</span><strong>[</strong> 25%]: cache compiling.release src/main.cpp
<strong>[</strong> 50%]: linking.release <span style="color:black">test
</span>running tests ...
<strong>[</strong>100%]: <span style="color:black">test</span>/testname .................................... passed 6.000s

<span style="color:#8f5902">100% </span>tests passed, 0 tests failed out of 1, spent 0.006s
</code></pre></div><h4>首次測試失敗就終止</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">默認情況下，<code>xmake test</code><span>&nbsp;</span>會等到所有測試都運行完，不管裏面有多少是沒通過的。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">而有時候，我們想在第一個測試沒通過，就直接中斷測試，那麼我們可以通過下面的配置啓用：</p><div><pre><code><span style="color:#000000">set_policy</span><strong>(</strong><span style="color:#ff00ff">"test.return_zero_on_failure"</span><strong>,</strong><strong>true</strong><strong>)</strong></code></pre></div><h4>測試失敗返回 0</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">默認情況下，只要有一個測試沒通過，等到<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>運行完成，它都會返回非 0 退出代碼，這對於一些 CI 環境非常有用，可以中斷 CI 的其他腳本繼續運行。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">然後觸發信號告訴 CI，我們需要生成測試報告和告警了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">然後，如果我們想要壓制這種行為，可以強制將<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>的退出代碼總是設置成 0。</p><div><pre><code><span style="color:#000000">set_policy</span><strong>(</strong><span style="color:#ff00ff">"test.return_zero_on_failure"</span><strong>,</strong><strong>true</strong><strong>)</strong></code></pre></div><h4>僅僅測試編譯</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">有時候，我們僅僅想要測試代碼是否通過編譯，或者沒有通過編譯，不需要運行它們，那麼可以通過配置<span>&nbsp;</span><code>build_should_pass</code><span>&nbsp;</span>和<span>&nbsp;</span><code>build_should_fail</code><span>&nbsp;</span>來實現。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_10"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/compile.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"compile_fail"</span><strong>,</strong><strong>{</strong><span style="color:#000000">build_should_fail</span><strong>=</strong><strong>true</strong><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_11"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/compile.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"compile_pass"</span><strong>,</strong><strong>{</strong><span style="color:#000000">build_should_pass</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這通常用於一些測試代碼中帶有<span>&nbsp;</span><code>static_assert</code><span>&nbsp;</span>的場景，例如：</p><div><pre><code><span style="color:blue">template</span><strong>&lt;</strong><span style="color:blue">typename</span><span style="color:#000000">T</span><strong>&gt;</strong><span style="color:blue">bool</span><span style="color:#000000">foo</span><strong>(</strong><span style="color:#000000">T</span><span style="color:#000000">val</span><strong>)</strong><strong>{</strong><span style="color:blue">if</span><span style="color:blue">constexpr</span><strong>(</strong><span style="color:#000000">std</span><strong>::</strong><span style="color:#000000">is_same_v</span><strong>&lt;</strong><span style="color:#000000">T</span><strong>,</strong><span style="color:blue">int</span><strong>&gt;</strong><strong>)</strong><strong>{</strong><span style="color:#000000">printf</span><strong>(</strong><span style="color:#ff00ff">"int!</span><span style="color:#ff00ff">\n</span><span style="color:#ff00ff">"</span><strong>);</strong><strong>}</strong><span style="color:blue">else</span><span style="color:blue">if</span><span style="color:blue">constexpr</span><strong>(</strong><span style="color:#000000">std</span><strong>::</strong><span style="color:#000000">is_same_v</span><strong>&lt;</strong><span style="color:#000000">T</span><strong>,</strong><span style="color:blue">float</span><strong>&gt;</strong><strong>)</strong><strong>{</strong><span style="color:#000000">printf</span><strong>(</strong><span style="color:#ff00ff">"float!</span><span style="color:#ff00ff">\n</span><span style="color:#ff00ff">"</span><strong>);</strong><strong>}</strong><span style="color:blue">else</span><strong>{</strong><span style="color:blue">static_assert</span><strong>(</strong><span style="color:black">false</span><strong>,</strong><span style="color:#ff00ff">"unsupported type"</span><strong>);</strong><strong>}</strong><strong>}</strong><span style="color:blue">int</span><span style="color:#000000">main</span><strong>(</strong><span style="color:blue">int</span><strong>,</strong><span style="color:blue">char</span><strong>**</strong><strong>)</strong><strong>{</strong><span style="color:#000000">foo</span><strong>(</strong><span style="color:#ff00ff">"BAD"</span><strong>);</strong><span style="color:blue">return</span><strong>0</strong><strong>;</strong><strong>}</strong></code></pre></div><h4>配置額外的代碼編譯</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們還可以在配置測試用例的時候，對每個測試配置額外需要編譯的代碼，以及一些宏定義，實現內聯測試。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">xmake 會為每個測試單獨編譯一個獨立的可執行程序去運行它，但這並不會影響到 target 在生產環境的編譯結果。</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_13"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/test_1.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"stub_1"</span><strong>,</strong><strong>{</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#ff00ff">"tests/stub_1.cpp"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"STUB_1"</span><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_14"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/test_2.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"stub_2"</span><strong>,</strong><strong>{</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#ff00ff">"tests/stub_2.cpp"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"STUB_2"</span><strong>})</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test_15"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">set_default</span><strong>(</strong><strong>false</strong><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/test_1.cpp"</span><strong>)</strong><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#ff00ff">"stub_n"</span><strong>,</strong><strong>{</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#ff00ff">"tests/stub_n*.cpp"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"STUB_N"</span><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">以 doctest 為例，我們可以在不修改任何 main.cpp 的情況下，外置單元測試：</p><div><pre><code><span style="color:#000000">add_rules</span><strong>(</strong><span style="color:#ff00ff">"mode.debug"</span><strong>,</strong><span style="color:#ff00ff">"mode.release"</span><strong>)</strong><span style="color:#000000">add_requires</span><strong>(</strong><span style="color:#ff00ff">"doctest"</span><strong>)</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"doctest"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"binary"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/*.cpp"</span><strong>)</strong><span style="color:blue">for</span><span style="color:#000000">_</span><strong>,</strong><span style="color:#000000">testfile</span><span style="color:blue">in</span><span style="color:black">ipairs</span><strong>(</strong><span style="color:#000000">os</span><strong>.</strong><span style="color:#000000">files</span><strong>(</strong><span style="color:#ff00ff">"tests/*.cpp"</span><strong>))</strong><span style="color:blue">do</span><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#000000">path</span><strong>.</strong><span style="color:#000000">basename</span><strong>(</strong><span style="color:#000000">testfile</span><strong>),</strong><strong>{</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#000000">testfile</span><strong>,</strong><span style="color:#000000">remove_files</span><strong>=</strong><span style="color:#ff00ff">"src/main.cpp"</span><strong>,</strong><span style="color:#000000">languages</span><strong>=</strong><span style="color:#ff00ff">"c++11"</span><strong>,</strong><span style="color:#000000">packages</span><strong>=</strong><span style="color:#ff00ff">"doctest"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN"</span><strong>})</strong><span style="color:blue">end</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">定義 DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN 會引入額外的 main 入口函數，因此我們需要配置 remove_files 去移除已有的 main.cpp 文件。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">運行效果如下：</p><div><pre><code>ruki-2:doctest ruki<span style="color:black">$ </span>xmake <span style="color:black">test
</span>running tests ...
<strong>[</strong> 50%]: doctest/test_1 .................................... failed 0.009s
<strong>[</strong>100%]: doctest/test_2 .................................... passed 0.009s

<span style="color:#8f5902">50% </span>tests passed, 1 tests failed out of 2, spent 0.019s
ruki-2:doctest ruki<span style="color:black">$ </span>xmake <span style="color:black">test</span> -v
running tests ...
<strong>[</strong> 50%]: doctest/test_1 .................................... failed 0.026s
<strong>[</strong>doctest] doctest version is <span style="color:#ff00ff">"2.4.11"</span><strong>[</strong>doctest] run with <span style="color:#ff00ff">"--help"</span><span style="color:blue">for </span>options
<strong>===============================================================================</strong>
tests/test_1.cpp:7:
TEST CASE:  testing the factorial <span style="color:blue">function

</span>tests/test_1.cpp:8: ERROR: CHECK<strong>(</strong> factorial<strong>(</strong>1<strong>)</strong><strong>==</strong> 10 <strong>)</strong> is NOT correct!
  values: CHECK<strong>(</strong> 1 <strong>==</strong> 10 <strong>)</strong><strong>===============================================================================</strong><strong>[</strong>doctest] <span style="color:black">test </span>cases: 1 | 0 passed | 1 failed | 0 skipped
<strong>[</strong>doctest] assertions: 4 | 3 passed | 1 failed |
<strong>[</strong>doctest] Status: FAILURE!

run failed, <span style="color:black">exit </span>code: 1
<strong>[</strong>100%]: doctest/test_2 .................................... passed 0.010s

<span style="color:#8f5902">50% </span>tests passed, 1 tests failed out of 2, spent 0.038s
</code></pre></div><h4>測試動態庫</h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">通常，<code>add_tests</code><span>&nbsp;</span>僅用於對可執行程序進行運行測試，運行動態庫需要有一個額外的 main 主入口，因此我們需要額外配置一個可執行程序去加載它，例如：</p><div><pre><code><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"doctest_shared"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"shared"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"src/foo.cpp"</span><strong>)</strong><span style="color:blue">for</span><span style="color:#000000">_</span><strong>,</strong><span style="color:#000000">testfile</span><span style="color:blue">in</span><span style="color:black">ipairs</span><strong>(</strong><span style="color:#000000">os</span><strong>.</strong><span style="color:#000000">files</span><strong>(</strong><span style="color:#ff00ff">"tests/*.cpp"</span><strong>))</strong><span style="color:blue">do</span><span style="color:#000000">add_tests</span><strong>(</strong><span style="color:#000000">path</span><strong>.</strong><span style="color:#000000">basename</span><strong>(</strong><span style="color:#000000">testfile</span><strong>),</strong><strong>{</strong><span style="color:#000000">kind</span><strong>=</strong><span style="color:#ff00ff">"binary"</span><strong>,</strong><span style="color:#000000">files</span><strong>=</strong><span style="color:#000000">testfile</span><strong>,</strong><span style="color:#000000">languages</span><strong>=</strong><span style="color:#ff00ff">"c++11"</span><strong>,</strong><span style="color:#000000">packages</span><strong>=</strong><span style="color:#ff00ff">"doctest"</span><strong>,</strong><span style="color:#000000">defines</span><strong>=</strong><span style="color:#ff00ff">"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN"</span><strong>})</strong><span style="color:blue">end</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">通過<span>&nbsp;</span><code>kind = "binary"</code><span>&nbsp;</span>可以將每個單元測試改為 binary 可執行程序，並通過<span>&nbsp;</span><code>DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN</code><span>&nbsp;</span>引入 main 入口函數。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這樣就能實現動態庫目標中外置可運行的單元測試。</p><h3>新增類型大小檢測</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在先前的版本中，我們可以通過<span>&nbsp;</span><code>check_csnippets</code><span>&nbsp;</span>和<span>&nbsp;</span><code>output = true</code><span>&nbsp;</span>的方式，來實現類型檢測。</p><div><pre><code><span style="color:#000000">check_csnippets</span><strong>(</strong><span style="color:#ff00ff">"INT_SIZE"</span><strong>,</strong><span style="color:#ff00ff">'printf("%d", sizeof(int)); return 0;'</span><strong>,</strong><strong>{</strong><span style="color:#000000">output</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">number</span><strong>=</strong><strong>true</strong><strong>})</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是這種方式，是通過嘗試運行測試代碼，然後獲取運行輸出結果，提取類型大小信息。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">這對於交叉編譯，就不適用了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 2.8.5 版本中，我們新增了<span>&nbsp;</span><code>check_sizeof</code><span>&nbsp;</span>輔助接口，可以通過直接解析測試程序的二進制文件，提取類型大小信息。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">由於不需要運行測試，這種方式不僅可以支持交叉編譯，而且對檢測效率也有極大的提升，使用也更加的簡單。</p><div><pre><code><span style="color:#000000">includes</span><strong>(</strong><span style="color:#ff00ff">"@builtin/check"</span><strong>)</strong><span style="color:#000000">target</span><strong>(</strong><span style="color:#ff00ff">"test"</span><strong>)</strong><span style="color:#000000">set_kind</span><strong>(</strong><span style="color:#ff00ff">"static"</span><strong>)</strong><span style="color:#000000">add_files</span><strong>(</strong><span style="color:#ff00ff">"*.cpp"</span><strong>)</strong><span style="color:#000000">check_sizeof</span><strong>(</strong><span style="color:#ff00ff">"LONG_SIZE"</span><strong>,</strong><span style="color:#ff00ff">"long"</span><strong>)</strong><span style="color:#000000">check_sizeof</span><strong>(</strong><span style="color:#ff00ff">"STRING_SIZE"</span><strong>,</strong><span style="color:#ff00ff">"std::string"</span><strong>,</strong><strong>{</strong><span style="color:#000000">includes</span><strong>=</strong><span style="color:#ff00ff">"string"</span><strong>})</strong></code></pre></div><div><pre><code><span style="color:#8f5902">$ </span>xmake f -c
checking <span style="color:blue">for </span>LONG_SIZE ... 8
checking <span style="color:blue">for </span>STRING_SIZE ... 24
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">另外，我也可以通過<span>&nbsp;</span><code>target:check_sizeof</code><span>&nbsp;</span>在腳本域進行檢測。</p><h3>新增 Apple XROS 平台</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">蘋果在 Xcode15 中新增了 visionOS 設備的構建支持，因此我們也在第一時間對其進行了支持，只需要執行：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake f -p applexros
<span style="color:#8f5902">$ </span>xmake
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">就可以完成 visionOS/XROS 平台的構建。</p><h3>支持代碼合併</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">最後，我們還提供了一個小工具模塊，它可以用於快速合併指定 target 裏面的所有 c/c++ 和，頭文件源碼到單個源文件。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">會生成類似 sqlite3.c 的這種單源碼文件，用戶可以根據自己的實際需求來決定是否使用這個功能。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">而在做合併的時候，Xmake 會將內部 includes 頭文件全部展開，並生成 DAG，通過拓撲排序引入。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">默認它會處理所有 target 的合併，例如：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake l cli.amalgamate
build/tbox.c generated!
build/tbox.h generated!
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以指定合併需要的目標：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake l cli.amalgamate tbox
build/tbox.c generated!
build/tbox.h generated!
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">也可以在合併每個源文件時候，指定一個自定義的 unique ID 的宏定義，來處理符號衝突問題。</p><div><pre><code><span style="color:#8f5902">$ </span>xmake l cli.amalgamate -u MY_UNIQUEU_ID
build/tbox.c generated!
build/tbox.h generated!
</code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">如果多個源文件內部有重名符號，就可以判斷這個<span>&nbsp;</span><code>MY_UNIQUEU_ID</code><span>&nbsp;</span>宏是否被定義，如果定義了，説明是在單文件中，就自己在源碼中處理下重名符號。</p><div><pre><code><em>#ifdef MY_UNIQUEU_ID
</em><em>// do some thing
</em><em>#endif
</em></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以指定輸出位置：</p><div><pre><code><span style="color:#8f5902">$ </span>xmake l cli.amalgamate -o /xxx
/xxx/tbox.c generated!
/xxx/tbox.h generated!
</code></pre></div><h3>新增 windows.manifest.uac 策略</h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">通過這個策略，我們可以快速方便的設置並啓用 Windows UAC。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它支持以下幾個 Level：</p><ul><li>invoker: asInvoker</li><li>admin: requireAdministrator</li><li>highest: highestAvailable</li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">例如：</p><div><pre><code><span style="color:#000000">set_policy</span><strong>(</strong><span style="color:#ff00ff">"windows.manifest.uac"</span><strong>,</strong><span style="color:#ff00ff">"admin"</span><strong>)</strong></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">它等價於設置</p><div><pre><code><span style="color:blue">if</span><span style="color:#000000">is_plat</span><strong>(</strong><span style="color:#ff00ff">"windows"</span><strong>)</strong><span style="color:blue">then</span><span style="color:#000000">add_ldflags</span><strong>(</strong><span style="color:#ff00ff">"/manifest:embed"</span><strong>,</strong><strong>{</strong><span style="color:#ff00ff">"/manifestuac:level='requireAdministrator' uiAccess='false'"</span><strong>},</strong><strong>{</strong><span style="color:#000000">force</span><strong>=</strong><strong>true</strong><strong>,</strong><span style="color:#000000">expand</span><strong>=</strong><strong>false</strong><strong>})</strong><span style="color:blue">end</span></code></pre></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">但是更加方便簡潔，並且不需要判斷平台，其他平台自動忽略。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">我們也可以通過<span>&nbsp;</span><code>windows.manifest.uac.ui</code><span>&nbsp;</span>策略，設置 Windows UAC 的 uiAccess，如果沒有設置它，默認是 false。</p><div><pre><code><span style="color:#000000">set_policy</span><strong>(</strong><span style="color:#ff00ff">"windows.manifest.uac.ui"</span><strong>,</strong><strong>true</strong><strong>)</strong></code></pre></div><h2>更新日誌</h2><h3>新特性</h3><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F1452" target="_blank">#1452</a>: 支持鏈接順序調整，鏈接組</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F1438" target="_blank">#1438</a>: 支持代碼 amalgamation</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F3381" target="_blank">#3381</a>: 添加<span>&nbsp;</span><code>xmake test</code><span>&nbsp;</span>支持</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F4276" target="_blank">#4276</a>: 支持自定義域 API</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fpull%2F4286" target="_blank">#4286</a>: 添加 Apple XROS 支持</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F4345" target="_blank">#4345</a>: 支持檢測類型大小 sizeof</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fpull%2F4369" target="_blank">#4369</a>: 添加 windows.manifest.uac 策略</li></ul><h3>改進</h3><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F4284" target="_blank">#4284</a>: 改進內置 includes 模塊</li></ul><h3>Bugs 修復</h3><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxmake-io%2Fxmake%2Fissues%2F4256" target="_blank">#4256</a>: 為 vsxmake 生成器修復 c++ modules intellisense</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 06 Nov 2023 01:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265506/xmake-v2-8-5</guid>
            <link>https://www.oschina.net/news/265506/xmake-v2-8-5</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Mozilla Firefox 開發將完全轉向 Git，放棄 Mercurial]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Mozilla 負責工作流和發佈管理的高級工程經理&nbsp;Glob&nbsp;在 firefox-dev 郵件列表中<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgroups.google.com%2Fa%2Fmozilla.org%2Fg%2Ffirefox-dev%2Fc%2FQnfydsDj48o%2Fm%2F8WadV0_dBQAJ" target="_blank">表示</a>，Firefox 開發正在從 Mercurial 轉向 GIT，以減輕開發團隊的壓力。</span></p><blockquote><p><span style="color:#000000">長期以來，Firefox Desktop 開發一直同時支持 Mercurial 和 Git 用戶。這種雙 SCM 要求給部分已經捉襟見肘的團隊帶來了沉重負擔。我們已經決定將 Firefox 開發轉移到 Git。</span></p><ul><li><span style="color:#000000">我們將繼續使用 Bugzilla、moz-phab、Phabricator 和 Lando。</span></li><li><span style="color:#000000">儘管我們將在 GitHub 上託管版本庫，但我們的貢獻工作流程將保持不變，而且我們目前不會接受拉取請求。</span></li></ul></blockquote><p><span style="color:#000000">目前相關事項仍在規劃中，預計至少六個月後才會開始全面的 Git 過渡。過渡完成後，Mercurial 將從 Firefox 開發工作流程中完全淘汰。</span></p><p><img height="225" src="https://oscimg.oschina.net/oscnet/up-4b4cc1a8fcad1764d254f09eae44065f9c2.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">根據介紹，這項工作將分為兩個部分進行：首先是面向開發人員的工作。項目團隊將把主倉庫從 Mercurial 切換到 Git，同時在開發人員的工作站上移除對 Mercurial 的支持。開發人員將需要在本地使用 Git，並繼續使用 moz-phab 提交補丁以供審核。</span></p><p><span style="color:#000000">然後是後端基礎架構的零散遷移。各個團隊計劃逐步將 Mercurial 上的基礎架構遷移到 Git 上。在這一階段結束時，預計可實現從基礎架構中完全移除對 Mercurial 的支持。</span></p><p><span style="color:#000000">Mercurial 是一款開源的分佈式源代碼控制管理工具，採用 Python 語言實現，易於學習和使用，擴展性強。它可以有效地處理任何規模的項目，並提供簡單直觀的界面。Mercurial 由 Olivia Mackall 於 2005 年創建，作為 BitKeeper 的替代品用於管理 Linux 內核的源代碼，以應對 BitKeeper 免費版的停產。</span></p><p><span style="color:#000000">更多詳細信息可查看</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgroups.google.com%2Fa%2Fmozilla.org%2Fg%2Ffirefox-dev%2Fc%2FQnfydsDj48o%2Fm%2F8WadV0_dBQAJ" target="_blank">郵件列表公告</a><span style="color:#000000">。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 10:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265431/firefox-going-git</guid>
            <link>https://www.oschina.net/news/265431/firefox-going-git</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[DALL·E 3 繪圖來啦，開源 AI 聊天、繪圖軟件 AIdea 現已支持 DALL·E 3]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p style="color:inherit; margin-left:0; margin-right:0">昨晚 OpenAI 的開發者大會後開放了 DALL·E 3 的 API，今天花了一點時間在 AIdea 中增加了對 DALL·E 3 的支持。</p><blockquote><p style="color:inherit; margin-left:0; margin-right:0">簡單來説，AIdea 類似於 POE，它是一款集成了主流大語言模型以及繪圖模型的開源 APP。如果你還不知道它，那麼可以簡單看看這篇文章 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzA3NTU1NDk4Mg%3D%3D%26mid%3D2454663369%26idx%3D1%26sn%3Dfc5ae7e09e5da885fecbe90747900bc9%26chksm%3D88d55900bfa2d016578008ec30550acbab49cf9ed5cd0b454c3ce8d308ff7cc1ab9416637f19%23rd" target="_blank">花了小半年開發了一個 AI 套殼 APP，然而大勢已過，直接開源了</a>。</p><p style="color:inherit; margin-left:0; margin-right:0">AIdea 項目前後端所有代碼均採用 MIT 協議開源。</p></blockquote><img alt="operate-note" src="https://ssl.aicode.cc/ai-server/assets/broadcast/dalle-preview.jpg" referrerpolicy="no-referrer"><p>operate-note</p><img alt="image" src="https://ssl.aicode.cc/ai-server/assets/broadcast/dalle-preview-result.png" referrerpolicy="no-referrer"><p>image</p><p style="color:inherit; margin-left:0; margin-right:0">下載體驗地址</p><p style="color:inherit; margin-left:0; margin-right:0">https://aidea.aicode.cc/</p><blockquote><p style="color:inherit; margin-left:0; margin-right:0">注意：AIdea 項目前後端所有代碼均採用 MIT 協議開源，但是在線體驗服務並不免費（PS. 很多大語言模型每日都有免費使用次數）。</p></blockquote><p style="color:inherit; margin-left:0; margin-right:0">AIdea 是一款集成了主流大語言模型以及繪圖模型的 APP ， 採用 Flutter + Golang 開發，代碼完全開源，支持以下功能：</p><ul><li><span style="color:inherit">OpenAI 的 GPT-3.5 ，GPT-4 大語言模型</span></li><li><span style="color:inherit">Anthropic 的 Claude instant ，Claude 2.0 大語言模型</span></li><li><span style="color:inherit">國產模型：通義千問，文心一言，訊飛星火，商湯日日新，騰訊混元，百川 53B ，360 智腦</span></li><li><span style="color:inherit">開源模型：Llama2 ，ChatGLM2 ，AquilaChat 7B ，Bloomz 7B 等，後續還將開放更多</span></li><li><span style="color:inherit">文生圖、圖生圖、超分辨率、黑白圖片上色等功能，集成 Stable Diffusion 模型，支持 SDXL 1.0</span></li></ul><p style="color:inherit; margin-left:0; margin-right:0">Github 地址：</p><ul><li><span style="color:inherit">客戶端（ Flutter ）： https://github.com/mylxsw/aidea</span></li><li><span style="color:inherit">服務端（ Golang ）： https://github.com/mylxsw/aidea-server</span></li></ul></div></div>
                                    ]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 09:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265412</guid>
            <link>https://www.oschina.net/news/265412</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[龍芯中科董事長、總經理胡偉武答網友與投資者]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>龍芯中科 2023 年第三季度業績説明會於昨日召開，在與投資者和網友互動問答環節，<span style="background-color:#ffffff; color:#333333">龍芯中科董事長、總經理胡偉武解答了許多問題。</span></p><p><span style="background-color:#ffffff; color:#333333">下文摘錄了部分問答（回答者均為龍芯中科</span>董事長、總經理，胡偉武<span style="background-color:#ffffff; color:#333333">）。</span></p><p>完整回顧：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frsc.sseinfo.com%2FroadshowIndex.do%3Fid%3D16536" target="_blank">https://rsc.sseinfo.com/roadshowIndex.do?id=16536</a></u></em></p><hr><h4><strong>開源、技術相關</strong></h4><p>您好！先前路演中，提過龍芯對於開源（個人理解為免費授權）與收費的思考，圈子裏很多同學對關於「不開源」的論述有顧忌。能否藉此機會明確下：龍芯法務對第三方獨立完成的龍架構軟硬件實現，以及善意的二次創作（如將指令集手冊整理為方便查閲的網站等）持何種態度？</p><p>另外社區 Linux 發行版能否打包龍芯原創軟件（如 Lbrowser、LATX、應用合作社等）？目前這些軟件缺乏 EULA，保守起見是不能打包的，對這些系統的用戶不太友好。</p><blockquote><p>在 11 月底的發佈會上，龍芯會與使用龍芯 IP 及架構的開放授權客戶簽約，敬請關注。</p><p>開源與兼容是一個矛盾，Linux 沒打敗 Windows、OpenCL 在 Cuda 面前輸得一塌糊塗，主要是參與者沒有形成合力。我們正在找到一條既開源又兼容的路徑，使得大量基於龍架構做芯片的人軟件是兼容的。</p><p>感謝你關於 Linux 發行版的建議，我們會認真考慮。</p></blockquote><p>&nbsp;</p><p>關於生態建設方面，目前雖説龍芯 Loongnix 被官方稱作「開源社區」，但它工單系統、代碼倉庫等不公開，協作渠道只有 service@loongnix.cn 一個郵箱，很難想像如何組織起有效的第三方參與。</p><p>作為國內為數不多的「根社區」，龍芯是否考慮將相關設施開放公開訪問，為其他行業參與者樹立樣板？</p><blockquote><p>我們正在改進，建設統一入口的龍芯生態社區。</p></blockquote><p>&nbsp;</p><p>請問龍芯有無計劃開發 ARM 的二進制翻譯, 在什麼契機下面向市場和社會公開?</p><blockquote><p>有。目前重點是在龍芯平台上運行 X86/Windows 應用，下一步要在龍芯平台上運行 ARM/Android 應用（已經開始部署）。</p><p>我以前説過要通過指令系統的創新消滅指令系統差異，一步步都會做到的。</p></blockquote><p>&nbsp;</p><p>龍芯的編程框架、二進制編譯進展如何了？編程框架大概何時能發佈？軟件的可通用性在開放市場很重要。</p><blockquote><p>二進制翻譯在別的問題回答過了。通用編程框架計劃隨龍芯 GPGPU 同步推出。</p></blockquote><p>&nbsp;</p><p>二進制翻譯目前進展怎麼樣，什麼時候可以產品化</p><blockquote><p>X86/Linux 的二進制翻譯趨於穩定。X86/Windows 的打印機、IE 瀏覽器兼容問題基本解決，正在做通用平台，最近有很多應用可用了，而且比較流暢，但這是個大工程。</p><p>我希望，二進制翻譯結合 3B6000 的推出可以到個人電腦的開放市場試試看。</p></blockquote><p>&nbsp;</p><p>胡老師好，請問：<br> 1，龍芯 3 系調頻技術何時能夠實現？<br> 2，龍芯系統（Loongnix）何時能夠升級至新世界？<br> 3，後續是否有推動商業軟件遷移至新世界的計劃？ 謝謝！</p><blockquote><p>Loongnix 升級至新世界與 Debian 對龍芯的支持同步，請關注 Debian 對龍架構的支持。</p><p>我們已經基本解決了在新世界上運行老世界應用的兼容性問題，正與統信等操作系統企業合作，爭取下一版操作系統支持新世界。</p></blockquote><p>&nbsp;</p><p>龍芯有無計劃結合自身 JIT 方面優勢做一些產品的適配和服務器或高性能領域的研發?</p><blockquote><p>感謝肯定與建議，是可以在這方面做工作，甚至未來可以做些芯片級的加速。</p></blockquote><p>&nbsp;</p><p>很期待公司的 GPGPU，能否適當吐露一些進展或者目標嗎？比如是否會研發自己的神經網絡框架？專門的 gpgpu 產品的計算能力大概在多少 (如 int8 或 float32)？</p><blockquote><p>在 2K3000 中 INT8 大概 8TOPS，在 9A1000 中 INT8 大概 32TOPS。同時，多個 9A1000 通過龍鏈互連形成更高性能。</p></blockquote><p>&nbsp;</p><p>請問可以説明一下龍鏈技術有哪些優勢嗎？</p><blockquote><p>一般高速互連包括物理、鏈路、協議層，像 PCIE 這樣的接口協議每一層都要打包拆包，nvlink 及 CXL 這樣的協議，協議層直接面向物理層設計，提高了效率。龍鏈跟 3A5000 的片間互聯協議比，片間互聯延遲成倍降低，帶寬提高了好幾倍，大大提高多片協同工作的性能。</p><p>龍鏈跟 nvlink 比，速率還低一些（目前每位速率是 16Gbps，下一步將提高到 32Gbps），但效率已經不錯了。</p></blockquote><h4>&nbsp;</h4><h4>行業、政策相關</h4><p>請問胡老師，3A6000 何時正式發佈？龍芯能否跳過 3B6000 直接研發 7nm 的 3A7000, 時不我待！</p><blockquote><p>3A6000 將於 11 月底正式發佈，十幾家整機/ODM 企業將發佈其整機產品。</p><p>我感覺在目前的工藝上還應該提高性能 20%-30%。換個新工藝也就提高這麼多。7nm 流片費用很高，一次得上億元，不能用該工藝試錯，用已有工藝完成結構試錯後再改到更先進工藝。</p><p>另外，龍芯堅持 IP 的自主研發，在新工藝上，要研製 DDR5 PHY、PCIE PHY、各類寄存器堆、鎖相環等 IP，現在已經開展對新工藝的評估，2024 年將研製這些 IP 並開展測試片研製，等這些 IP 成熟了，3B6000 也完成了對新結構的驗證，時間是對得上的。</p></blockquote><p>&nbsp;</p><p>對於目前信創的主要競爭對手海光和華為各自的競爭力如何看？</p><blockquote><p>（1）商業模式不同，龍芯可以比作 Intel，華為是整機企業可以比作 IBM，海光與曙光也形成了事實上的 IBM 模式。<br> （2）龍芯做生態，他們做產品，這是主要不同。<br> （3）龍芯把信創作為走向開放市場路上的驛站，作為試錯場景，最終面向開放市場和海外市場。</p></blockquote><p>&nbsp;</p><p>目前在龍芯桌面主機上還是看到一些挑內存現象，請問後續龍芯這方面有沒有優化計劃，儘可能做到市場主流品牌的內存插上即用。</p><blockquote><p>感謝你的問題。我們會進行持續改進。</p></blockquote><p>&nbsp;</p><p>您認為龍芯的銷售是否存在不接地氣的情況呢？</p><blockquote><p>理論上，龍芯主要面對整機企業，在整機企業積極性不足的情況下直接推動一些用戶單位。</p><p>過去確實存在對計算機產業鏈不熟悉的情況，過去一年多已經有較大進步，從整機、渠道、應用單位三個環節完善產業鏈。</p></blockquote><p>&nbsp;</p><p>作為一個國產愛好者，請問龍芯 3a6000 對國產的電腦配件適配情況怎麼樣？比如長江致鈦、摩爾線程、金百達等的適配情況。</p><blockquote><p>我們與自主內存、硬盤、顯卡的很多合作伙伴都已經完成適配或者正在適配。</p></blockquote><p>&nbsp;</p><p>請問胡老師，龍芯與俄羅斯方面的合作是否會更深入，我個人認為龍芯應該積極與俄方合作，有利於雙方打破僵局</p><blockquote><p>謝謝你的建議。 目前龍芯的營收均來自境內客戶。</p><p>龍芯是一個通用 CPU 企業，會聯合一帶一路國家打造獨立於 X86 和 ARM 體系的第三套體系。</p></blockquote><p>&nbsp;</p><p>龍芯 cpu 的性能還是不錯的，但是絕大部分人對於專業軟件的測試成績是沒有概念的。可否在線下設立一些龍芯電腦體驗店，或者開放一些遠程桌面？讓有心支持國產的消費者親身體驗下是否能夠滿足自身需求來決定購買。</p><blockquote><p>謝謝建議。我們會認真考慮實施。</p></blockquote><p>&nbsp;</p><p>胡老師，很看好龍芯的 gpgpu 發展，相信有一天也會跟龍芯的 CPU 一樣在國內一騎絕塵，請問龍芯有沒有在車機或者智能芯片佈局的計劃，做出像高通 8155 車機芯片，地平線征程系列那樣的智駕芯片計劃？</p><blockquote><p>龍芯目前主要做面向推理的 AI 芯片，形成 CPU+GPGPU 的最佳解決方案。</p><p>我相信，隨着應用的拓展，龍芯芯片的 AI 應用會很普遍。</p></blockquote><p>&nbsp;</p><p>胡老師您好！請問 2022/2023 年政策性市場停滯的原因主要是什麼？2024/2025 年政策性市場能否像預期一樣放量？</p><blockquote><p>感覺 2023Q4，政務類政策性市場部分回暖。我自己對 2024/2025 年預期不變。</p></blockquote><p>&nbsp;</p><p>龍芯以前介紹過車規級 mcu 印象説的好像是流片了，目前有沒有新進展？龍芯對於新能源汽車領域有沒有大的佈局？感覺這塊是一個大的市場，特別是當前形勢下，龍芯這種有硬實力的 CPU 企業在國產替代大有可為。</p><blockquote><p>已經與部分汽車企業開展 MCU 替換工作。龍芯會把電機驅動作為重點方向。</p></blockquote><p>&nbsp;</p><p>1、可否簡單介紹一下一帶一路國家市場整體佈局節奏和規劃？<br> 2、農村包圍城市的大策略是對的，不過如果整機終端有標杆性大客戶是否可以更好的帶動芯片銷售？<br> 3、龍芯芯片整體性能不錯的情況下，解決特定的某一項或兩項需求痛點，形成差異化優勢，也許可以脫穎而出？&nbsp;</p><blockquote><p>總體上説，龍芯要聯合一帶一路國家形成新型信息技術體系和產業生態，在不斷探索中。</p><p>信創市場會帶動龍芯技術進步，同時也有不少品牌整機客戶支持龍芯，整機客戶主要是看性價比。</p><p>我相信，如果龍芯性價比達到一定水平，肯定會有越來越多的品牌整機使用。同時，要做第三套生態，一定要重構產業鏈。 感謝你的建議，我最近多次講的「點面結合」中的「點」與你的第三點建議是一致的。</p></blockquote><p>&nbsp;</p><p>能否加快 GPGPU 的研發，不要怕花錢，這是一個新興市場，速度越快越好。</p><blockquote><p>待 2K3000 中得到驗證後，會加速研發的。主要是自主研發需要迭代。</p></blockquote><p>&nbsp;</p><p>有企業採購和技術人員表示龍芯銷售人員很不專業，沒法解釋龍芯的特點和優點，沒法迴應對手的攻擊銷售術語，沒銷售技巧，有的地區銷售人員甚至已經消失了很長時間。請問龍芯銷售人員是否熟悉龍芯產品，日常是否使用過龍芯自家的產品，以後怎麼提高。</p><blockquote><p>龍芯公司包括辦公電腦、郵件服務器、網站服務器、OA 服務器、ERP 服務器、網絡安全產品，均使用龍芯 CPU。</p><p>龍芯的銷售需要改進的地方挺多的，正在改進中。但我要求銷售要有底線。</p><p>總體上，龍芯發展的主要矛盾還是產品能否滿足市場需求的矛盾，主要體現在系統性價比和軟件生態。</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 07:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265392</guid>
            <link>https://www.oschina.net/news/265392</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[馬斯克旗下 AI 公司推出 PromptIDE 工具]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>馬斯克旗下 AI 公司 xAI <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.ai%2Fprompt-ide%2F" target="_blank">宣佈推出 PromptIDE 工具</a></u>，需要使用 X 賬戶登錄。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8e71bf70af935eb153aa1cc26a973d0f5c9.png" referrerpolicy="no-referrer"></p><p><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.ai%2Fprompt-ide%2F" target="_blank">https://x.ai/prompt-ide/</a></u></em></p><p>PromptIDE 是一個<strong>用於提示工程和可解釋性研究的集成開發環境</strong>。它通過 SDK 加速提示工程，該 SDK 允許實現複雜的提示技術和豐富的分析功能，從而實現網絡輸出可視化。</p><p>IDE 的核心是一個 Python 代碼編輯器，它可以與新的 SDK 結合實現複雜的提示。在 IDE 中執行提示時，用戶會看到一些有用的分析和建議，例如精確標記化等等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-cabd374d49271e12b2b6a54648df587857b.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-162ef024f3eb0fff93e05bc242b6fe28ba8.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f6174ba792122df3fda5a272ff68e00d9e9.png" referrerpolicy="no-referrer"></p><p>xAI 官方表示，他們開發 PromptIDE 是為了向社區的工程師和研究人員<strong>透明地提供 Grok-1 的透明訪問權限</strong>。該 IDE 旨在賦予用戶權力，幫助他們快速探索大型語言模型（LLMs）的魅力。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 06:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265374</guid>
            <link>https://www.oschina.net/news/265374</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Kotlin Multiplatform 已穩定，可用於生產環境]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Kotlin Multiplatform (KMP) 是一項由 JetBrains 構建的開源技術，使開發者能夠在跨平台共享代碼的同時保留原生編程的優勢。</p><p>現在，這項技術取得了備受期待的進展，<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.jetbrains.com%2Fzh-hans%2Fkotlin%2F2023%2F11%2Fkotlin-multiplatform-stable%2F" target="_blank">已經穩定</a></u>並完全做好了投入生產環境的準備</strong>。</p><p>根據介紹，Kotlin Multiplatform (KMP) 以靈活性和適應性為設計核心，模糊了跨平台與原生開發之間的界限。它使開發者可以重用盡可能多的代碼，根據需要編寫原生代碼，並將共享的 Kotlin 代碼無縫集成到任何項目中。</p><p>Kotlin Multiplatform 技術的核心由許多部分組成，例如編譯器支持、語言功能、庫 API、IDE、構建工具等。 這些部分覆蓋了最熱門的代碼共享用例，並且在 Kotlin 1.9.20 中得到穩定。&nbsp;</p><p>除了核心之外，KMP 還有一些仍在繼續開發的更高級部分。 expect/actual 類就是此類功能的一個示例（請勿與 expect/actual_函數_混淆，它們在 Kotlin 1.9.20 中已完全穩定）。 此類功能被明確標記為非穩定，Kotlin 會在您使用它們時發出通知。 請注意實驗性警告和相應文檔，以便明智地決定是否要在項目中使用此類功能。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 06:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265360/kotlin-multiplatform-stable</guid>
            <link>https://www.oschina.net/news/265360/kotlin-multiplatform-stable</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[為何在中國 MySQL 遠比 PostgreSQL 流行]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>首先在全球範圍內，MySQL 一直是領先於 PostgreSQL (下文簡稱 PG) 的。下圖是 DB-Engines 的趨勢圖，雖然 PG 是近 10 年增長最快的數據庫，但 MySQL 依然保持着優勢。</p><p><img src="https://oscimg.oschina.net/oscnet/up-943fdb4a9b2ff5a9040e1f0a443fe665886.png" alt="file" referrerpolicy="no-referrer"></p><p>再來看一下 Google Trends 過去一年的對比</p><p><img src="https://oscimg.oschina.net/oscnet/up-4a64141dd049238fd27345827ffd7e5d471.png" alt="file" referrerpolicy="no-referrer"></p><p>MySQL 也依然是明顯領先的。而進一步看一下地域分佈的話</p><p><img src="https://oscimg.oschina.net/oscnet/up-39b2eaeb8b9c510967dd62f75af4a8cf61b.png" alt="file" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-a51209b047cbb5f68ad8d87ac6969ccd9b3.png" alt="file" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-1d990264d0a3d36b944e38fa0338ee15ff4.png" alt="file" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-b7fb383ef09d1fbc8784858360e9c030704.png" alt="file" referrerpolicy="no-referrer"></p><p>絕大多數地區依然是 MySQL 領先，份額對比在 60:40 ~ 70:30 之間；少數幾個國家如俄羅斯不分伯仲；印度的對比是 85:15；而中國則是達到了 96:4，也是 Google Trends 上差異最明顯的國家。</p><p><img src="https://oscimg.oschina.net/oscnet/up-48a053900767e1a4a26b5038be28b01ca14.png" alt="file" referrerpolicy="no-referrer"></p><p>筆者從 2009 年左右開始學習數據庫相關知識，接觸到了 MySQL 5.1 和 PG 8.x。而深度在工作中使用則是 2013 年，那時加入 Google Cloud SQL 開始維護數據庫，MySQL 從 5.5 開始，到之後 2017 年 Cloud SQL 推出了 PG 服務，從 9.6 開始，後來一直同時維護 Google 內部的 MySQL 和 PG 分支，也就一直關注着兩邊的發展。18 年回國後，進一步熟悉了國內的生態。</p><p>下面就來嘗試分析一下 MySQL 在中國流行度遙遙領先於 PG 的原因。</p><h2>Windows</h2><p><img src="https://oscimg.oschina.net/oscnet/up-393e3ce9aef8da2d8ca168b6c4945f400e0.png" alt="file" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-6cd2aa611a6a67133459c549a20ea4ee1ea.png" alt="file" referrerpolicy="no-referrer"></p><p>MySQL 在 1998 年就提供了 Windows 版本，而 PostgreSQL 則到了 2005 年才正式推出。之前讀到的原因是 Windows 早期的版本一直無法很好支持 PostgreSQL 的進程模型。</p><h2>上手門檻</h2><p>MySQL 上手更簡單，舉幾個例子：</p><ol><li>連 PG，一定需要指定數據庫，而 MySQL 就不需要。psql 大家碰到的問題是嘗試連接時報錯 FATAL Database xxx does not exist。而 mysql 碰到的問題是連接上去後，執行查詢再提示 no database selected。</li><li>訪問控制的配置，首先 PG 和 MySQL 都有用戶系統，但 PG 還要配置一個額外的 pg_hba (host-based authentication) 文件。</li><li>MySQL 的層級關係是：實例 -&gt; 數據庫 -&gt; 表，而 PG 的關係是：實例（也叫集羣）&gt; 數據庫 &gt; Schema &gt; 表。PG 多了一層，而且從行為表現上，PG 的 schema 類似於 MySQL 數據庫，而 PG 的數據庫類似於 MySQL 的實例。PG 的這個額外層級在絕大多數場景是用不到的，大家從習慣上還是喜歡用數據庫作為分割邊界，而不是 schema。所以往往 PG 數據庫下，也就一個 public schema，這多出來的一層 schema 就是額外的負擔。</li><li>因為上面機制的不同，PG 是無法直接做跨庫查詢的，早年要通過 dblink 插件，後來被 FDW (foreign data wrapper) 取代。</li><li>PG 有更加全面的權限體系，數據庫對象都有明確的所有者，但這也導致在做測試時，更經常碰到權限問題。</li></ol><p>雖然 PostgreSQL 的設計更加嚴謹，但也更容易把人勸退。就像問卷設計的一個技巧是第一題放一個無腦就能答上來的二選一，這個的目的在於讓對方開始答題。</p><h2>性能</h2><p>最早 Google 搜索和廣告業務都是跑在 MySQL 上的，我讀到過當時選型的備忘。其實一開始團隊是傾向於 PG 的（我猜測是 PG 的工程質量更加符合團隊的技術品味），但後來測試發現 MySQL 的性能要好不少，所以就選型了 MySQL。 現在兩者的性能對比已經完全不一樣了，而且性能和業務關聯性很強，取決於 SQL 複雜度，併發，延遲這些不同的組合。目前在大部分場景下，MySQL 和 PG 的性能是相當的。有興趣可以閲讀 Mark Callaghan 的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsmalldatum.blogspot.com%2F" target="_blank">文章</a>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-20048f51f41d640c952b6e72e999482fa56.png" alt="file" referrerpolicy="no-referrer"></p><h2>互聯網</h2><p><img src="https://oscimg.oschina.net/oscnet/up-1b0ded268bcf2b706ee0bda661440fe355e.png" alt="file" referrerpolicy="no-referrer"></p><p>最重要的是 LAMP 技術棧，Linux + Apache + MySQL + PHP，誕生於 1998 年，和互聯網崛起同步，LAMP 技術棧的普及也帶火了 MySQL。這個技術棧的綁定是如此之深，所以時至今日，MySQL 官方客戶端 MySQL Workbench 也還是不及 phpMyAdmin 流行。</p><p><img src="https://oscimg.oschina.net/oscnet/up-4f443115ae5ddd25c7f4efc873b6bec34b1.png" alt="file" referrerpolicy="no-referrer"></p><h2>大廠的號召力</h2><p>前面提到的 Mark Callaghan 一開始在 Google 的 MySQL 團隊，他們給生態做了很多貢獻，後來 Google 內部開始用 Spanner 替換 MySQL，Mark 他們就跑到了 Facebook 繼續做，又進一步發展了 MySQL 的生態，像當時互聯網公司都需要的高可用方案 MHA (Master High Availability) 就是 Mark 在 FB 時期打磨成熟的。當時整個互聯網技術以 Google 為瞻，傳播鏈差不多是 Google &gt; Facebook / Twitter &gt; 國內互聯網大廠 &gt; 其他中小廠。MySQL 在互聯網公司的壟斷就這樣形成了。 相對的，那段時間 PG 有影響力的文章不多，我唯一有印象的是 Instagram 分享他們 sharding 的方案，提到<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Finstagram-engineering.com%2Fsharding-ids-at-instagram-1cf5a71e5a5c" target="_blank">用的是 PostgreSQL</a>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b511dcc014674f7745bcd2edf432506cbab.png" alt="file" referrerpolicy="no-referrer"></p><h2>生態</h2><p>有了大量使用後，自然就有人去解決碰到的各種問題。先是 InnoDB 橫空出世，解決了事務和性能問題。主從，中間件分庫分表方案解決了海量服務的擴展和高可用問題。各種 MySQL 相關書籍，培訓資料也冒了出來，應該不少人都讀過高性能 MySQL (High Performance MySQL) 這本書。</p><p><img src="https://oscimg.oschina.net/oscnet/up-954d19d8f6018c57329fd50b3652dcc5036.png" alt="file" referrerpolicy="no-referrer"></p><p>業界有 Percona 這樣專注於做 MySQL 技術諮詢的公司，他們還研發了一系列工具，比如做大表變更的 pt-online-schema-change（後來 GitHub 還發布了改良版 gh-ost)，做備份的 xtrabackup。</p><p>國內也做了不少的貢獻，阿里給上游貢獻了許多 replication 的改進。SQL 審核優化這塊，有去哪兒研發的 Inception，小米團隊的 SOAR。Parser 有 PingCAP 的 MySQL Parser。</p><p>相對而言 PG 在工具鏈的生態還是差不少，比如 PG 生態裏沒有開箱即用的 Parser，沒有 Parser 也就無法做 SQL 審核。Bytebase 在實現相關功能時，就只能從頭開始做。當然這也成為了 Bytebase 產品的核心競爭力，我們是市面上對 PG 變更審核，查詢脫敏支持最好的工具，除了大表變更外，功能完全對標 MySQL。</p><p><img src="https://oscimg.oschina.net/oscnet/up-16c2362dc10347956a5b1dc7da2439ef870.png" alt="file" referrerpolicy="no-referrer"></p><h2>總結和展望</h2><p>回到中國 MySQL 遠比 PostgreSQL 流行的原因，在上面所有列出的要素裏，我覺得最核心的還是第一條，MySQL 很早就能跑在 Windows 上，而 PG 不能。因為有了能跑 Windows 這個點，MySQL 成為了 LAMP 的一部分，到後來成為了支撐整個互聯網的基石。當時國內大家手頭裝的都是 windows 操作系統，要開發 web 應用，都用 LAMP 架構，就順便把 MySQL 帶上了。</p><p>此外國內還有更明顯的頭部效應。國內所有互聯網公司的技術體系都源自阿里，比如拿研發環境來説，SIT (System Integration Test) 是我回國加入螞蟻后才接觸到的名詞，但後來在其他各個地方又都反覆遇到。數據庫方案也是如此，全套照搬了阿里的 MySQL 方案。就連技術職級也是，找工作先確認對標 P 幾。</p><p><img src="https://oscimg.oschina.net/oscnet/up-55e41a87f7cea2aa21be981e85c7da47cda.png" alt="file" referrerpolicy="no-referrer"></p><p>就在上月，MySQL 5.7 宣佈了 EOL，算是給 MySQL 5 系，這個支撐了過去 15 年中國互聯網的功勳做了一個告別。</p><p>隨着 MySQL 的辭舊，PG 的崛起，在這 AI 的黎明，VR 的前夜，下一個 15 年，MySQL 和 PG 之間相愛相殺的故事又該會如何演繹呢。</p><p>I<img src="https://oscimg.oschina.net/oscnet/up-bdfb31b1abfc4e24e554005b63351ad9d26.png" alt="file" referrerpolicy="no-referrer"></p><hr><p>💡 更多資訊，請關注 Bytebase 公號：Bytebase</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 03:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6148470/blog/10141073</guid>
            <link>https://my.oschina.net/u/6148470/blog/10141073</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[答開源創業 15 問：選協議、維權、公關、找錢・・・・・・]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><div><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#e74c3c"><strong>11 月 8 日 19:00，OSCHINA 直播 ——【開源漫談】第 5 期</strong></span>，邀請了三位大咖，請他們來聊一聊開源創業遇到的一些難題。他們分別是：</p><ul><li><strong>高春輝</strong>，中國第一個人站長，卓越網、手機之家、ECSHOP 軟件、《愛壁紙 HD》應用創始人，全球領先級 ip 庫 http://ipip.net 創始人</li><li><strong>王春生</strong>，禪道軟件公司的創始人，二十年的 IT 老兵，14 年的創業者</li><li><strong>朱峯</strong>，津津樂道播客網絡創始人、主播。連續創業者，商業經驗豐富；有多年社區運營經驗；資深開發者</li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong>這次直播，將盡可能地回答這 15 個問題：</strong></p><div><ol><li><p>開源軟件有漏洞，跟作者沒關係？</p></li><li><p>怎麼判斷自己的項目能不能拿來創業？</p></li><li><p>開源軟件協議應當選擇最寬鬆的？</p></li><li><p>應該努力地將軟件捐獻給基金會？</p></li><li><p>項目捐給了基金會，比如 Apache 基金會，需要作者將「版權授權 + 專利授權 + 商標轉讓」給基金會，那作者還能掌控項目代碼嗎？</p></li><li><p>用戶量增長最快的時候，當時採取了什麼推廣方式？</p></li><li><p>開源是怎麼掙錢的？</p></li><li><p>軟件被侵權了怎麼辦？</p></li><li><p>網上出現了負面輿論，怎麼「公關」？</p></li><li><p>如何看待免費用戶提出的一些功能改進、BUG 修復、技術支持等要求？</p></li><li><p>要創業，去哪裏找錢？</p></li><li><p>要不要接受投資？因為哪些原因拒絕有些投資？哪些條件不能妥協？</p></li><li><p>技術人員怎麼轉型做管理？</p></li><li><p>怎麼做到連續創業成功的？有什麼可供其他創業者借鑑的經驗？</p></li><li><p>作為創業者，時間和精力怎麼分配？最重要的角色是什麼？</p></li></ol><p>&nbsp;</p><hr><p><strong>直播主題：</strong>關於開源創業的 15 件小事</p></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong>直播時間：</strong>11 月 8 日（週三） 19:00-20:30</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong>直播平台：</strong>「OSC 開源社區」 視頻號</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong>主辦方：</strong>開源中國</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="background-color:#ffffff; color:#333333">微信掃碼預約直播，歡迎加入 OSC 直播交流羣，一起嘮嗑～</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img height="2373" src="https://oscimg.oschina.net/oscnet/up-14591ad92c8670ed66d7d67145a7305fc09.jpg" width="700" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong>直播福利</strong></p><ul><li><p style="margin-left:0; margin-right:0">互動抽獎：在直播評論區提問，被直播嘉賓回覆的用戶可獲 OSC T 恤 1 件，名額不限。</p></li><li><p style="margin-left:0; margin-right:0">福袋抽獎：直播中將有多輪抽獎，參與就有機會獲得 OSC T 恤、筆記本、馬克杯 、前沿技術書籍等。</p></li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">我們直播間見吧～</p><div><hr></div><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong>另外，本次直播得到了諸多社區或組織的大力支持，在此特別表示感謝：</strong></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span><strong>渠成開源社區</strong></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>渠成開源社區由禪道項目管理軟件團隊發起，社區的經營主體為青島渠成開源計算機網絡技術研究中心，是非營利性社會服務活動的社會組織。 渠成開源社區主要面向一線開源軟件生產者、貢獻者、組織者、贊助商和用戶，以解決具體實際問題為宗旨，旨在打造以開源軟件為核心紐帶的開源生態系統，真正做到讓每一個優秀的開源軟件都能實現商業化。</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>官網：<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.qucheng.cc" target="_blank">www.qucheng.cc</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span><strong>禪道</strong></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>禪道是一款開源的全生命週期項目管理軟件，基於敏捷和 CMMI 管理理念進行設計，集產品管理、項目管理、質量管理、文檔管理、組織管理和事務管理於一體，完整地覆蓋了項目管理的核心流程。 禪道自 2009 年發佈至今，累計為國內數十萬計的公司或團隊提供了專業的項目管理工具。</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zentao.net%2F" target="_blank">https://www.zentao.net/</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span><strong>津津樂道博客</strong></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>津津樂道播客成立於 2016 年 2 月，是天津猿行天下科技有限公司旗下的播客品牌。津津樂道播客主創團隊由多位行業資深人士組成，本着分享體驗、傳播經驗的原則，團隊在 IT、科技、旅遊、教育等領域，製作了多檔播客節目，並獲得市場好評。</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdao.fm%2F" target="_blank">https://dao.fm/</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><strong><span><span><span><span><span><span><span style="color:#000000"><span><span>IPIP.net &nbsp;</span></span></span></span></span></span></span></span></span></strong></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>IPIP 專注 IP 地理位置以及 IP 畫像數據的研究、整理與發行，我們的主力產品 IP 地理位置數據庫主要基於 BGP/ASN 數據以及遍佈全球的網絡監測點進行城市級 IP 地域數據標註，準確度遠高於國內國外同類產品。 &nbsp;</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ipip.net%2F" target="_blank">https://www.ipip.net/</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><strong><span><span><span><span><span><span><span style="color:#000000"><span><span>GreatSQL 社區 &nbsp;</span></span></span></span></span></span></span></span></span></strong></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>GreatSQL 社區成立於 2021 年，由萬裏數據庫發起，致力於通過開放的社區合作，構建國內自主開源數據庫版本及開源數據庫技術，推動中國開源數據庫及應用生態繁榮發展。GreatSQL 是適用於金融級應用的國內自主開源數據庫，具備高性能、高可靠、高易用性、高安全等多個核心特性，可以作為 MySQL 或 Percona Server 的可選替換，用於線上生產環境，且完全免費併兼容 MySQL 或 Percona Server。</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>官網鏈接：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgreatsql.cn%2F" target="_blank">https://greatsql.cn/</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>Gitee 倉庫：<a href="https://gitee.com/GreatSQL">https://gitee.com/GreatSQL</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span><strong>愛可生開源社區</strong></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>愛可生開源社區，一個有深度的 MySQL 開源社區。社區成立於 2017 年，以開源高質量的運維工具、日常分享技術乾貨內容、數據庫技術佈道為己任；目前開源的產品有：SQL 審核工具 SQLE、分佈式中間件 DBLE 和數據傳輸組件 DTLE。在這裏，你將收穫：高質量的技術內容，企業級數據庫工具及服務，豐富的社區活動。</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>鏈接：<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopensource.actionsky.com%2F" target="_blank">https://opensource.actionsky.com/</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span><strong>PG 中文社區</strong></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>PostgreSQL 中文社區是一個非盈利的民間組織，目前成員都以志願者身份加入，成立的目的在於構建 PG 數據庫技術生態圈子 (內核、用戶培訓機構、廠商、服務商、軟件開發商、高校形成 「業務與利益雙向驅動」 的良性發展生態圈)；幫助企業解決人才培養和企業商用數據庫成本問題，社區會在各運營平台發佈 PostgreSQL 最新信息和 PostgreSQL 相關技術文章，推動 PG 技術在中國的發展。</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>官網鏈接：<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.postgres.cn%2Findex.php%2Fv2%2Fhome" target="_blank">http://www.postgres.cn/index.php/v2/home</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span><strong>凹語言</strong></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>凹語言是一個面向 WebAssembly 設計的靜態類型編譯型語言，目標是簡化 WASM 應用的開發。目前已經發布 MVP 版本，並提供了在線的純瀏覽器 Playground 和貪吃蛇案例實現。</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>主頁：<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwa-lang.org" target="_blank">https://wa-lang.org</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><strong><span><span><span><span><span><span><span style="color:#000000"><span><span>KCL 社區 &nbsp;</span></span></span></span></span></span></span></span></span></strong></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>KCL&nbsp;是一個開源的基於約束的記錄及函數語言，作為沙盒項目託管在 CNCF 基金會。KCL 通過成熟的編程語言技術和實踐來改進對大量繁雜配置比如雲原生 Kubernetes 配置場景的編寫，致力於構建圍繞配置的更好的模塊化、擴展性和穩定性，更簡單的邏輯編寫，以及更簡單的自動化和生態工具集成。 &nbsp;</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>官網鏈接：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fkcl-lang.io+GitHub" target="_blank">https://kcl-lang.io GitHub</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>倉庫：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkcl-lang" target="_blank">https://github.com/kcl-lang</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span><strong>AllData</strong></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>AllData 大數據產品是可定義數據中台，以數據平台為底座，以數據中台為橋樑，以機器學習平台，GPT 平台為框架，提供全鏈路數字化解決方案。</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>項目地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Falldatacenter%2Falldata" target="_blank">https://github.com/alldatacenter/alldata</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>社區官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Falldata.readthedocs.io%2Fzh%2Fmaster%2F" target="_blank">https://alldata.readthedocs.io/zh/master/</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><strong><span><span><span><span><span><span><span style="color:#000000"><span><span>得物技術</span></span></span></span></span></span></span></span></span></strong></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>得物技術一直以 "上海最好的技術團隊" 為目標，現已建立上海、北京、杭州三地研發協同與管理機制，實現研發過程數據化、自動化；覆蓋供應鏈、業務支撐、算法、前端等領域，是得物業務背後強有力的技術力量支撐。 &nbsp;&nbsp;</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>官網鏈接：<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.dewu.com%2F" target="_blank">https://tech.dewu.com/</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><strong><span><span><span><span><span><span><span style="color:#000000"><span><span>重慶軟件園 &nbsp;</span></span></span></span></span></span></span></span></span></strong></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>重慶軟件園位於重慶經開區，佔地 110 萬平方米，佈局四大組團，是重慶市首批軟件產業園 (綜合型)、A 區入選重慶市軟件和信息服務業 「滿天星」 示範樓宇 (首批)，於 2019 年 9 月 16 日正式開園，堅持 「做生態 = 做產業，做人才 = 做產業，做服務 = 做產業」 的發展理念，建設集科技、人文、生態、智慧為一體的領軍型軟件園區。聚焦 「3+2」 產業佈局，實現新一代信息技術產業集羣發展。</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>園區聚集軟件類企業近 2000 家，軟件人才近 3 萬人，已登記 4000 多項軟件著作權，研發投入超 50 億，40 餘項專利將獲得科技獎，營收上億企業近 20 家。立足南岸區、重慶經開區優質產業資源，聚焦軟件信息服務業、智能製造、綠色環保 、汽車軟件汽車電子、大健康等產業，推動軟件產業高質量發展，重慶軟件園將全面貫徹落實 「滿天星」 計劃，力爭到 2026 年成功建成中國軟件名園。 &nbsp;</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>園區官網：<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.chongqingpark.com%2F" target="_blank">http://www.chongqingpark.com/</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><strong><span><span><span><span><span><span><span style="color:#000000"><span><span>東方瑞通 &nbsp;</span></span></span></span></span></span></span></span></span></strong></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>東方瑞通成立於 1998 年，是國內較早的 IT 高級技術培訓企業之一，擁有華為、紅帽、微軟、PMI、VMware、Oracle 等 33 餘家國際廠商授權資質，以培養 it 人才為主，目前覆蓋領域：虛擬化、操作系統、網絡、安全、數據庫、IT 管理、軟件開發等細分領域，提供線上，線下交流培訓課程與活動。</span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>官網鏈接：<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.easthome.com" target="_blank">www.easthome.co</a></span></span></span></span></span></span></span></span></span></p><p style="color:#333333; text-align:left"><strong>秦派軟件</strong></p><p style="color:#333333; text-align:left">北京秦派軟件科技有限公司 (Pulsarware® Technologies Ltd.) 是一家致力於開發生產力工具軟件的技術公司，成立之初立志要在工具軟件領域深耕，踐行精益求精的研發精神，努力推出優質的生產力工具軟件服務國內外的開發者，提升開發者的工作效率，同時創造出商業價值和社會價值。</p><p style="color:#333333; text-align:left">ATOMDB™ 數據庫管理客戶端是秦派軟件研發的一款服務廣大開發者的工具軟件。可以讓開發者方便地執行查詢，創建和管理數據庫，支持管理市場上主流的數據庫管理系統。例如： TIDB, PolarDB, GreatDB, 人大金倉, 神舟通用, TDengine, MySQL, PostgreSQL, Microsoft SQL Server, Oracle 等等。軟件設計支持 Windows、MacOS、Linux 等操作系統，軟件採用插件擴展的方式對多數據庫進行支持。</p><p style="color:#333333; text-align:left"><span><span><span><span><span><span><span style="color:#000000"><span><span>官網鏈接：</span></span></span></span></span></span></span></span></span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fatomdb.com" target="_blank">atomdb.com</a></p></div></div></div>
                                    ]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 02:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/3859945/blog/10141334</guid>
            <link>https://my.oschina.net/u/3859945/blog/10141334</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 推出用戶自定義版 ChatGPT]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">OpenAI 在其召開的首屆開發者大會上，宣佈了平台上的多項更新。其中一項<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Fblog%2Fintroducing-gpts" target="_blank">公告</a>就是，該公司現在允許用戶為特定目的創建自己的 ChatGPT 自定義版本，稱為 GPTs。</span></p><p><span style="color:#000000">「GPTs 是一種新方式，任何人都可以創建 ChatGPT 的定製版本，以便在日常生活、特定任務、工作或家庭中更有幫助，然後與其他人分享該創作。例如，GPTs 可以幫助你學習任何棋盤遊戲的規則、幫助你指導孩子的數學或設計貼紙。」</span></p><p><img height="217" src="https://oscimg.oschina.net/oscnet/up-ccd8211246bf15a936a5b191c4b025deef9.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">該公司表示，GPTs 適用於所有人，無需編程即可使用。用戶可以製作其以供企業內部使用，也可以個人使用。「創建一個 GPT 就像開始對話一樣簡單，只需給它指令和額外知識，然後選擇它能做的事情，比如搜索網頁、製作圖片或分析數據。」</span></p><p><span style="color:#000000">感興趣的用戶可以在 </span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fchat.openai.com%2Fcreate" target="_blank">chat.openai.com/create</a><span style="color:#000000">上試用。目前 ChatGPT Plus 和企業版用戶已經可以試用 GPT 示例，包括 Canva 和 Zapier AI Actions。OpenAI&nbsp;計劃後續將面向更多用戶提供 GPTs。</span></p><p><span style="color:#000000">OpenAI</span>&nbsp;方面<span style="color:#000000">還在公告中表示，他們相信最好的 GPT <span style="background-color:#ffffff">將來自社區的構建者</span>。並透露 GPT 商店將於本月晚些時候推出，以便用戶可以找到並使用其他人創建的 GPT。他們將重點關注不同類別中最有用的 GPT，構建者還可以通過其上架的 GPT 的被使用率來進行獲利。</span></p><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Fblog%2Fintroducing-gpts" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 05 Nov 2023 02:55:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/265331/openai-custom-versions-chatgpt</guid>
            <link>https://www.oschina.net/news/265331/openai-custom-versions-chatgpt</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
