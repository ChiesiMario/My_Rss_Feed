<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-最新資訊]]>
        </title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="https://rsshub.app/oschina/news" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 15 Nov 2023 04:33:07 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[懸賞十幾萬元以用 Rust 重寫 Prettier]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Facebook 法國前端工程師、React Native 和 Prettier 的聯合創始人 Vjeux&nbsp;在 Twitter </span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2FVjeux%2Fstatus%2F1722733472522142022" target="_blank">發帖</a><span style="color:#000000">，尋求有能力的開發者來使用 Rust 重寫前端代碼格式化工具&nbsp;Prettier，並懸賞 1 萬美元。</span></p><blockquote><p><span style="color:#000000">使用 Rust 實現更快、更美觀的 printers 引起了廣泛關注。但主要問題在於，它們都無法與 prettier 的長尾格式化邏輯相匹配。</span></p><p><span style="color:#000000">如果用 Rust 編寫的項目能通過通過 95% 以上的 prettier JavaScript 測試，我將懸賞 1 萬美元。</span></p></blockquote><p><img alt="" height="229" src="https://oscimg.oschina.net/oscnet/up-6f7c5921c3486449f168f164f0c04ed72c1.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Vercel 的首席執行官&nbsp;Guillermo Rauch&nbsp;也跟帖<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Frauchg%2Fstatus%2F1723400569392656771" target="_blank">表示</a>，進一步對該懸賞進行加碼，將賞金升級到了 2 萬美元。</span></p><p><span style="color:#000000">此外，Wasmer 官方也附議了&nbsp;Vjeux 的這一提議，並表示將額外提供 2500 美元的獎勵。「我們喜歡這一倡議！如果項目編譯到 WASIX 並（通過 CI）發佈到 Wasmer，我們將為項目所有者額外獎勵 2500 美元。」</span></p><p><span style="color:#000000">Prettier 是一個 「有主見」 的代碼格式化工具。它通過解析你的代碼並根據自己的規則 re-printing（將最大行長考慮在內），並在必要時對代碼進行封裝，從而實現一致的風格。簡而言之，這個工具能夠使輸出代碼保持風格一致。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 04:05:02 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266545/rewriting-prettier-rust</guid>
            <link>https://www.oschina.net/news/266545/rewriting-prettier-rust</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[11.25 源創會杭州站報名開啓：從數據到大模型應用]]>
            </title>
            <description>
                <![CDATA[11.25 源創會杭州站報名開啓：從數據到大模型應用]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 03:41:02 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/action/visit/ad?id=1558</guid>
            <link>https://www.oschina.net/action/visit/ad?id=1558</link>
        </item>
        <item>
            <title>
                <![CDATA[開源多媒體播放器 VLC 發佈 3.0.20，為 Windows 添加 AV1 硬件解碼]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>開源多媒體播放器 VLC 近日了發佈了最新版本 3.0.20。</p><p><img alt="" height="319" src="https://oscimg.oschina.net/oscnet/up-b17d30ec88965ab4d14a96a982f5e49804d.png" width="500" referrerpolicy="no-referrer"></p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.videolan.org%2Fnews.html%23news-2023-11-02" target="_blank">公告寫道</a></u>，這是 VLC 3.0 分支的中度更新：它升級了編解碼器，修復了 FLAC 的質量問題，並改進了多種格式的播放，包括改進字幕渲染。它還修復了使用逐幀操作時的凍結問題。在 macOS 上，音頻佈局問題也得到了解決。</p><p>更新日誌如下：</p><ul><li>VLC 3.0.20 是 "Vetinari" 系列的第 21 次更新</li><li>改進了多種格式的播放，包括某些字幕的渲染</li><li>升級編解碼器</li><li>修復 FLAC 渲染質量問題</li><li>修復使用某些舊版 AMD GPU 顯卡驅動程序播放大量文件存在的問題</li><li>在 Windows 上添加 AV1 硬件解碼</li><li>升級了大量第三方庫</li><li>提升 SMB 與 Windows 11 主機的兼容性</li><li>優化本地化翻譯</li><li>修復兩個安全問題，詳見：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.videolan.org%2Fsecurity%2Fsb-vlc3019.html" target="_blank">1</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.videolan.org%2Fsecurity%2Fsb-vlc3020.html" target="_blank">2</a></li></ul><p>下載地址：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.videolan.org%2Fvlc%2Freleases%2F3.0.20.html" target="_blank">https://www.videolan.org/vlc/releases/3.0.20.html</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 03:25:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266538/vlc-3-0-20</guid>
            <link>https://www.oschina.net/news/266538/vlc-3-0-20</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[李彥宏：百度目前 20% 代碼由 AI 完成]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#222222">11 月 15 日，李彥宏在深圳舉行的西麗湖論壇上表示，</span><span style="background-color:#ffffff; color:#3b3b3b">百度已經對旗下各產品線進行了 AI 原生化重構，</span><span style="background-color:#ffffff; color:#222222">百度每 100 行代碼，20 行就由 AI 完成。</span></p><p><span style="background-color:#ffffff; color:#222222">他表示，大模型是基礎底座，類似操作系統不會太多，重複開發大模型是對基礎資源的浪費。 文心一言有了很大進步，其調用量比國內其他兩百家還多。</span></p><p><span style="background-color:#ffffff; color:#222222">目前，文心一言已有 800 萬開發者，開發者可以通過插件調用文心一言。</span></p><p><img height="304" src="https://static.oschina.net/uploads/space/2023/1115/111350_ZpLo_4252687.png" width="700" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 03:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266536</guid>
            <link>https://www.oschina.net/news/266536</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[「零一萬物」 迴應 Yi 開源大模型「套殼」 Llama]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>李開復旗下 AI 公司<span style="background-color:#ffffff; color:#333333">「</span>零一萬物<span style="background-color:#ffffff; color:#333333">」&nbsp;</span>(<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2F01.AI" target="_blank">01.AI</a>)&nbsp;<span style="background-color:#ffffff; color:#333333">上週</span><u><a href="https://www.oschina.net/news/265142/01-ai-valued-at-1b-open-source-yi-llm" target="_blank">宣佈</a></u><strong>推出&nbsp;Yi-34B 和&nbsp;Yi-6B 兩個開源大模型。</strong>其公佈的基準測試結果顯示雖然模型參數少於其它大模型，但性能更出色。零一萬物的估值高達 10 億美元，已躋身獨角獸行列。</p><p>Yi 正式開源數日後，在其<span style="background-color:#ffffff; color:#333333"><span>&nbsp;</span>Hugging Face 主頁的討論區中，有人指出&nbsp;</span>Yi-34B 完全使用了 Meta 開源大模型 Llama 的架構，最明顯的變化只是修改了張量 (Tensor) 名稱。</p><p><img alt="111349_Novu_2720166.png" src="https://static.oschina.net/uploads/space/2023/1114/111349_Novu_2720166.png" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#333333">來源：</span><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11" target="_blank">https://huggingface.co/01-ai/Yi-34B/discussions/11</a></u></em></p><p>根據公開的信息，Yi 系列開源大模型沒有在開源 License 中提及 Llama。上面的帖子內容經過廣泛傳播後，零一萬物的 Yi 系列大模型被質疑是 Llama 的套殼。</p><p>昨天，「零一萬物」 正式公開回應了此事。根據該公司開源團隊總監<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">&nbsp;</a></u><span style="background-color:#ffffff"><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">Richard Lin 的跟帖回覆</a></u>，他們承認了修改 Llama 張量名稱的做法不妥，並會按照建議進行修改。</span></p><p>Richard Lin 稱此問題是團隊的疏忽。因為在大量的訓練實驗中，<strong>他們對代碼進行了多次重命名，以滿足實驗要求</strong>。但最後沒有在發佈之前將它們改回來。他為這個失誤造成的混亂表示抱歉。</p><p><span style="background-color:#ffffff">與此同時，Richard Lin 邀請這名指出問題的開發者提交包含上述改動的 PR——對 Yi 的張量名稱進行重命名以符合 Llama 架構。</span></p><p><img src="https://oscimg.oschina.net/oscnet/up-5607cfe7fee8c2aaf087104396bd1d3d785.png" referrerpolicy="no-referrer"></p><p>最後，<span style="background-color:#ffffff">Richard Lin&nbsp;</span>表示團隊會增強對流程的執行，避免此類錯誤再次發生，他們也將再次檢查所有代碼，確保其他一切正常。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266525</guid>
            <link>https://www.oschina.net/news/266525</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[EmotiVoice —— 多音色提示控制 TTS 引擎]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong>EmotiVoice（易魔聲）</strong>是一個強大的開源 TTS 引擎，支持中英文雙語，包含 2000 多種不同的音色，以及特色的<strong>情感合成</strong>功能，支持合成包含快樂、興奮、悲傷、憤怒等廣泛情感的語音。</p><p>EmotiVoice 提供一個易於使用的 Web 界面，還有用於批量生成結果的腳本接口。</p><p>點此查看具體示例：<em><u><a href="https://github.com/netease-youdao/EmotiVoice/blob/main/README.zh.md">https://github.com/netease-youdao/EmotiVoice/blob/main/README.zh.md</a></u></em></p></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/emotivoice</guid>
            <link>https://www.oschina.net/p/emotivoice</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 3D 裸眼風扇屏]]>
            </title>
            <description>
                <![CDATA[<p>項目説明</p><p>本項目是製作一個 3D 裸眼風扇廣告機，它是一款裸眼 D 的新型產品，採用晶片、磁鐵、發光二極管 (LED) 技能及螺旋槳葉片組合而成,葉片在驅動下隨之動彈，繼而顯現出 D 浮空影像。同時還設計了喇叭，可以實現播放視頻、聽音樂功能</p><p>視頻介紹：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1tN411y7ZS%2F">https://www.bilibili.com/video/BV1tN411y7ZS/</a></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/EE64VlOi1zKg5iufuLVZ46TzYQD5CyY1EIlaoftN.png" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p>開源協議</p><p>依據 GPL 3.0 開源協議，可以複製、修改和傳播，並且不限制商業使用。</p><p>項目相關功能</p><p>1.圖片顯示，160x160 的分辨率，上傳 jpeg 圖片格式，可以顯示多張圖片</p><p>2.視頻播放，不能直接播放 MP4 文件，需要單獨解碼後才能播放</p><p>3.音樂播放，可以播放音樂 wav 文件。</p><p>4.雲端控制，使用手機 APP 進行控制。包括上傳圖片，開啓/停止功能，按鈕選擇功能</p><p>項目屬性</p><p>本項目為首次公開，為本人原創項目。項目未曾在別的比賽中獲獎。</p><p>項目進度</p><p>2023 年 2 月 14 日，開始設計</p><p>2023 年 3 月 30 日，完成第一版設計，40x40 分辨率</p><p>2023 年 4 月 4 日，開始設計第二版本提高清晰度，160x160 分辨率</p><p>2023 年 4 月 15 日，開始編寫 ESP32 程序，調試電機驅動，LED 顯示，音樂播放功能。</p><p>2023 年 5 月 10 日，開始編寫手機 APP，實現聯網遠程控制。</p><p>設計原理</p><p>電路部分</p><p>主控芯片選擇 ESP32S3，帶有 WiFi 功能，可以實現雲端控制。ESP32S3 作為一個雙核 240MHZ 處理器，有足夠的性能解碼 JPEG 圖片，mp3 音樂文件。</p><p>電機驅動採用 TMC2209 芯片來驅動一個 28 步進電機，低速時可以靜音驅動，帶來很好的體驗，不會影響音樂播放帶來噪音。</p><p>LED 燈採用 WS2812 幻彩燈珠，1615 的小體積封裝提高分辨率</p><p>音頻驅動採用 MAX98357 芯片，可以驅動一個 3W 的小喇叭。</p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/CFYaQ1z8zbUII5cQohjbOsVbOxdZFypDSe3vojc9.png" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/RHMgoiHGHXX0bkLdOpdoSmeQOL4TWiKnvqgOOZ2d.png" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p>外殼部分</p><p>使用 FreeCAD 軟件進行外殼設計。在本次結構設計中有一個難點就是如何給電路板供電，採用電池供電但是續航不久，於是不採用。使用外置電源不用考慮續航問題，但繞線是個問題。於是設計了一個採用軸承導電的機構。其他零件使用 3D 打印出來。</p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/1tbNw9FV6ZrYcSQyd77pQUfiaCVZzsD01rQS1G1d.png" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p>軟件説明</p><p>ESP32 主控</p><p>ESP32 主控主要是編寫 LED 驅動程序，JPEG 圖片解碼程序，wav 音樂解碼播放，已及通 MQTT 訂閲來接收雲端數據，實現遠程控制。如下是一些主要代碼</p><p>手機 APP</p><p>手機 App 是使用前端 html 和 JavaScript 寫的一個網頁，然後對網頁打包成安卓應用。實現的功能主要有上傳圖片，控制 esp32 的各種功能。部分程序如下</p><p>此外為了實現流暢播放視頻，我單獨使用 python 腳本對視頻進行了解碼。</p><p>實物展示</p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/BDFCIOQkqrGEZcxuzO4QxZbk8wA5NyMuNJfNLNzm.jpeg" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/JH1S503sxnVDZRkepAYyLV9BkgoL1VhoYjJtwW90.jpeg" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/YWbrYCHZBPEeR5dIZoKDOrNhZc62yBtoJYfjzUgY.jpeg" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>其他</p><p>視頻講解稍後上傳</p>]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/qzr123/3-d-bare-eye-fan-screen</guid>
            <link>https://gitee.com/qzr123/3-d-bare-eye-fan-screen</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | MYSQL 事務的底層原理]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><span><span>事務的底層原理</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在事務的實現機制上，MySQL 採用的是 WAL：Write-ahead logging，預寫式日誌，機制來實現的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在使用 WAL 的系統中，所有的修改都先被寫入到日誌中，然後再被應用到系統中。通常包含 redo 和 undo 兩部分信息。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>為什麼需要使用 WAL，然後包含 redo 和 undo 信息呢？舉個例子，如果一個系統直接將變更應用到系統狀態中，那麼在機器掉電重啓之後系統需要知道操作是成功了，還是隻有部分成功或者是失敗了。如果使用了 WAL，那麼在重啓之後系統可以通過比較日誌和系統狀態來決定是繼續完成操作還是撤銷操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>redo log 稱為重做日誌，每當有操作時，在數據變更之前將操作寫入 redo log，這樣當發生掉電之類的情況時系統可以在重啓後繼續操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>undo log 稱為撤銷日誌，當一些變更執行到一半無法完成時，可以根據撤銷日誌恢復到變更之間的狀態。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>MySQL 中用 redo log 來在系統 Crash 重啓之類的情況時修復數據，而 undo log 來保證事務的原子性。</span></span></span></p><span id="OSC_h2_2"></span><h2><span><span><span>事務 id</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>一個事務可以是一個只讀事務，或者是一個讀寫事務：可以通過 START TRANSACTION READ ONLY 語句開啓一個只讀事務。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在只讀事務中不可以對普通的表進行增、刪、改操作，但可以對用戶臨時表做增、刪、改操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以通過 START TRANSACTION READ WRITE 語句開啓一個讀寫事務，或者使用 BEGIN、START TRANSACTION 語句開啓的事務默認也算是讀寫事務。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在讀寫事務中可以對錶執行增刪改查操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>如果某個事務執行過程中對某個表執行了增、刪、改操作，那麼 InnoDB 存儲引擎就會給它分配一個獨一無二的事務 id，針對 MySQL 5.7 分配方式如下：</span></strong></span></span></p><ul><li><span><span><span><span>對於只讀事務來説，只有在它第一次對某個用戶創建的臨時表執行增、刪、改操作時才會為這個事務分配一個事務 id，否則的話是不分配事務 id 的。</span></span></span></span></li><li><span><span><span><span>對於讀寫事務來説，只有在它第一次對某個表執行增、刪、改操作時才會為這個事務分配一個事務 id，否則的話也是不分配事務 id 的。</span></span></span></span></li><li><span><span><span><span>有的時候雖然開啓了一個讀寫事務，但是在這個事務中全是查詢語句，並沒有執行增、刪、改的語句，那也就意味着這個事務並不會被分配一個事務 id。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>這個事務 id 本質上就是一個數字，它的分配策略和隱藏列 row_id 的分配策略大抵相同，具體策略如下：</span></strong></span></span></p><ul><li><span><span><span><span>服務器會在內存中維護一個全局變量，每當需要為某個事務分配一個事務 id 時，就會把該變量的值當作事務 id 分配給該事務，並且把該變量自增 1。</span></span></span></span></li><li><span><span><span><span>每當這個變量的值為 256 的倍數時，就會將該變量的值刷新到系統表空間的頁號為 5 的頁面中一個稱之為 Max Trx ID 的屬性處，這個屬性佔用 8 個字節的存，儲空間。</span></span></span></span></li><li><span><span><span><span>當系統下一次重新啓動時，會將上邊提到的 Max Trx ID 屬性加載到內存中，將該值加上 256 之後賦值給全局變量，因為在上次關機時該全局變量的值可能大於 Max Trx ID 屬性值。</span></span></span></span></li><li><span><span><span><span>這樣就可以保證整個系統中分配的事務 id 值是一個遞增的數字。先被分配 id 的事務得到的是較小的事務 id，後被分配 id 的事務得到的是較大的事務 id。</span></span></span></span></li></ul><span id="OSC_h2_3"></span><h2><span><span><span>mvcc</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>全稱 Multi-Version Concurrency Control，即多版本併發控制，主要是為了提高數據庫的併發性能。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>同一行數據平時發生讀寫請求時，會上鎖阻塞住。但 MVCC 用更好的方式去處理讀寫請求，做到在發生讀寫請求衝突時不用加鎖。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這個讀是指的快照讀，而不是當前讀，當前讀是一種加鎖操作，是悲觀鎖。</span></span></span></p><span id="OSC_h3_4"></span><h3><span><span><span>MVCC 原理</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在事務併發執行遇到的問題如下：</span></span></span></p><ul><li><span><span><span><span>髒讀：如果一個事務讀到了另一個未提交事務修改過的數據，那就意味着發生了髒讀；</span></span></span></span></li><li><span><span><span><span>不可重複讀：如果一個事務只能讀到另一個已經提交的事務修改過的數據，並且其他事務每對該數據進行一次修改並提交後，該事務都能查詢得到最新值，那就意味着發生了不可重複讀；</span></span></span></span></li><li><span><span><span><span>幻讀：如果一個事務先根據某些條件查詢出一些記錄，之後另一個事務又向表中插入了符合這些條件的記錄，原先的事務再次按照該條件查詢時，能把另一個事務插入的記錄也讀出來，那就意味着發生了幻讀，幻讀強調的是一個事務按照某個相同條件多次讀取記錄時，後讀取時讀到了之前沒有讀到的記錄，幻讀只是重點強調了讀取到了之前讀取沒有獲取到的記錄。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>MySQL 在 REPEATABLE READ 隔離級別下，是可以很大程度避免幻讀問題的發生的。</span></strong></span></span></p><span id="OSC_h4_5"></span><h4><span><span><span>版本鏈</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於使用 InnoDB 存儲引擎的表來説，它的聚簇索引記錄中都包含兩個必要的隱藏列：</span></span></span></p><ul><li><span><span><span><span>trx_id：每次一個事務對某條聚簇索引記錄進行改動時，都會把該事務的事務 id 賦值給 trx_id 隱藏列；</span></span></span></span></li><li><span><span><span><span>roll_pointer：每次對某條聚簇索引記錄進行改動時，都會把舊的版本寫入到 undo 日誌中，然後這個隱藏列就相當於一個指針，可以通過它來找到該記錄修，改前的信息；</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>演示</span></strong></span></span></p><pre><code><span><span><span style="color:#708090">-- 創建表</span></span><span><span></span></span><span><span style="color:#0077aa">CREATE</span></span><span><span></span></span><span><span style="color:#0077aa">TABLE</span></span><span><span> mvcc_test </span></span><span><span style="color:#999999">(</span></span><span><span>
id </span></span><span><span style="color:#0077aa">INT</span></span><span><span style="color:#999999">,</span></span><span><span>
name </span></span><span><span style="color:#0077aa">VARCHAR</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">100</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">,</span></span><span><span>
domain </span></span><span><span style="color:#0077aa">varchar</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">100</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">PRIMARY</span></span><span><span></span></span><span><span style="color:#0077aa">KEY</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>id</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">Engine</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#0077aa">InnoDB</span></span><span><span></span></span><span><span style="color:#0077aa">CHARSET</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span>utf8</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 添加數據</span></span><span><span></span></span><span><span style="color:#0077aa">INSERT</span></span><span><span></span></span><span><span style="color:#0077aa">INTO</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">VALUES</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'habit'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'演示 mvcc'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>假設插入該記錄的事務 id=50，那麼該條記錄的展示如圖：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-497oLuqeLE7xPfzmr.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>假設之後兩個事務 id 分別為 70、90 的事務對這條記錄進行 UPDATE 操作。</span></span></span></p><div><table cellspacing="0" style="--tw-ring-color:rgba(59,130,246,.5); --tw-ring-inset:var(--tw-empty,/*!*/ /*!*/); --tw-ring-offset-color:#ffffff; --tw-ring-offset-shadow:0 0 #0000; --tw-ring-offset-width:0px; --tw-ring-shadow:0 0 #0000; --tw-shadow:0 0 #0000; border-collapse:collapse; border-color:inherit; border-style:solid; border-width:0px; box-sizing:border-box; margin:0px; outline:none; padding:0px; text-indent:0px; width:auto"><tbody><tr><th style="background-color:var(--w-e-textarea-slight-bg-color); text-align:center"><span><span><span>trx_id=70</span></span></span></th><th style="background-color:var(--w-e-textarea-slight-bg-color); text-align:center"><span><span><span>trx_id=90</span></span></span></th></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>begin</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>begin</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_70_01' where id=1</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_70_02' where id=1</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>commit</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_90_01' where id=1</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_90_02' where id=1</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>commit</span></span></span></td></tr></tbody></table></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>每次對記錄進行改動，都會記錄一條 undo 日誌，每條 undo 日誌也都有一個 roll_pointer 屬性，可以將這些 undo 日誌都連起來，串成一個鏈表。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-49y0loF49tpKQ7swfq.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>對該記錄每次更新後，都會將舊值放到一條 undo 日誌中，就算是該記錄的一箇舊版本，隨着更新次數的增多，所有的版本都會被 roll_pointer 屬性連接成一個鏈表，把這個鏈表稱之為版本鏈，版本鏈的頭節點就是當前記錄最新的值。另外，每個版本中還包含生成該版本時對應的事務 id。於是可以利用這個記錄的版本鏈來控制併發事務訪問相同記錄的行為，那麼這種機制就被稱之為：</span></span></span><span><span><strong><span>多版本併發控制，即 MVCC。</span></strong></span></span></p><span id="OSC_h4_6"></span><h4><span><span><span>ReadView</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於使用 READ UNCOMMITTED 隔離級別的事務來説，由於可以讀到未提交事務修改過的記錄，所以直接讀取記錄的最新版本就好了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於使用 SERIALIZABLE 隔離級別的事務來説，InnoDB 使用加鎖的方式來訪問記錄。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於使用 READ COMMITTED 和 REPEATABLE READ 隔離級別的事務來説，都必須保證讀到已經提交了的事務修改過的記錄，也就是説假如另一個事務已經修改了記錄但是尚未提交，是不能直接讀取最新版本的記錄的，核心問題就是：READ COMMITTED 和 REPEATABLE READ 隔離級別在不可重複讀和幻讀上的區別是從哪裏來的，其實結合前面的知識，這兩種隔離級別關鍵是需要判斷一下版本鏈中的哪個版本是當前事務可見的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>為此，InnoDB 提出了一個 ReadView 的概念，這個 ReadView 中主要包含 4 個比較重要的內容：</span></strong></span></span></p><ul><li><span><span><span><span>m_ids：表示在生成 ReadView 時當前系統中活躍的讀寫事務的事務 id 列表；</span></span></span></span></li><li><span><span><span><span>min_trx_id：表示在生成 ReadView 時當前系統中活躍的讀寫事務中最小的事務 id，也就是 m_ids 中的最小值；</span></span></span></span></li><li><span><span><span><span>max_trx_id：表示在生成 ReadView 時系統中應該分配給下一個事務的 id 值，注：max_trx_id 並不是 m_ids 中的最大值，事務 id 是遞增分配的。比方説現在有 id 為 1，2，3 這三個事務，之後 id 為 3 的事務提交了。那麼一個新的讀事務在生成 ReadView 時，m_ids 就包括 1 和 2，min_trx_id 的值就是 1，max_trx_id 的值就是 4；</span></span></span></span></li><li><span><span><span><span>creator_trx_id：表示生成該 ReadView 的事務的事務 id；</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>有了這個 ReadView，這樣在訪問某條記錄時，只需要按照下邊的步驟判斷記錄的某個版本是否可見：</span></span></span></p><ol><li><span><span><span><span>如果被訪問版本的 trx_id 屬性值與 ReadView 中的 creator_trx_id 值相同，意味着當前事務在訪問它自己修改過的記錄，所以該版本可以被當前事務訪問；</span></span></span></span></li><li><span><span><span><span>如果被訪問版本的 trx_id 屬性值小於 ReadView 中的 min_trx_id 值，表明生成該版本的事務在當前事務生成 ReadView 前已經提交，所以該版本可以被當前事務訪問；</span></span></span></span></li><li><span><span><span><span>如果被訪問版本的 trx_id 屬性值大於或等於 ReadView 中的 max_trx_id 值，表明生成該版本的事務在當前事務生成 ReadView 後才開啓，所以該版本不可以被當前事務訪問；</span></span></span></span></li><li><span><span><span><span>如果被訪問版本的 trx_id 屬性值在 ReadView 的 min_trx_id 和 max_trx_id 之間 min_trx_id &lt; trx_id &lt; max_trx_id，那就需要判斷一下 trx_id 屬性值是不是在 m_ids 列表中，如果在，説明創建 ReadView 時生成該版本的事務還是活躍的，該版本不可以被訪問；如果不在，説明創建 ReadView 時生成該版本的事務已經被提交，該版本可以被訪問；</span></span></span></span></li><li><span><span><span><span>如果某個版本的數據對當前事務不可見的話，那就順着版本鏈找到下一個版本的數據，繼續按照上邊的步驟判斷可見性，依此類推，直到版本鏈中的最後一個版本。如果最後一個版本也不可見的話，那麼就意味着該條記錄對該事務完全不可見，查詢結果就不包含該記錄；</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 MySQL 中，READ COMMITTED 和 REPEATABLE READ 隔離級別的一個非常大的區別就是它們生成 ReadView 的時機不同。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>還是以表 mvcc_test 為例，假設現在表 mvcc_test 中只有一條由事務 id 為 50 的事務插入的一條記錄，接下來看一下 READ COMMITTED 和 REPEATABLE READ 所謂的生成 ReadView 的時機不同到底不同在哪裏。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>READ COMMITTED：</span></strong></span></span><span><span><span> 每次讀取數據前都生成一個 ReadView；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比方説現在系統裏有兩個事務 id 分別為 70、90 的事務在執行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- T 70</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此時表 mvcc_test 中 id 為 1 的記錄得到的版本鏈表如下所示：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-50mpbjn7HMKz7hBhK.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>假設現在有一個使用 READ COMMITTED 隔離級別的事務開始執行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 READ COMMITTED 隔離級別的事務</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值為'habit'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>這個 SELECE1 的執行過程如下：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在執行 SELECT 語句時會先生成一個 ReadView，ReadView 的 m_ids 列表的內容就是[70, 90]，min_trx_id 為 70，max_trx_id 為 91，creator_trx_id 為 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然後從版本鏈中挑選可見的記錄，從圖中可以看出，最新版本的列 name 的內容是 habit_trx_id_70_02，該版本的 trx_id 值為 70，在 m_ids 列表內，所以不符合可見性要求第 4 條：</span></span></span><span><span><code><strong><span>如果被訪問版本的 trx_id 屬性值在 ReadView 的 min_trx_id 和 max_trx_id 之間 min_trx_id &lt; trx_id &lt; max_trx_id，那就需要判斷一下 trx_id 屬性值是不是在 m_ids 列表中，如果在，説明創建 ReadView 時生成該版本的事務還是活躍的，該版本不可以被訪問；如果不在，説明創建 ReadView 時生成該版本的事務已經被提交，該版本可以被訪問。</span></strong></code></span></span><span><span><span>根據 roll_pointer 跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit_trx_id_70_01，該版本的 trx_id 值也為 70，也在 m_ids 列表內，所以也不符合要求，繼續跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit，該版本的 trx_id 值為 50，小於 ReadView 中的 min_trx_id 值，所以這個版本是符合要求的第 2 條：</span></span></span><span><span><strong><span>如果被訪問版本的 trx_id 屬性值小於 ReadView 中的 min_trx_id 值，表明生成該版本的事務在當前事務生成 ReadView 前已經提交，所以該版本可以被當前事務訪問。</span></strong></span></span><span><span><span>最後返回的版本就是這條列 name 為 habit 的記錄。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>之後，把事務 id 為 70 的事務提交一下，然後再到事務 id 為 90 的事務中更新一下表 mvcc_test 中 id 為 1 的記錄：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- T 90</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此時表 mvcc 中 id 為 1 的記錄的版本鏈就長這樣：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-507DFORnJ7Is10E8bC.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>然後再到剛才使用 READ COMMITTED 隔離級別的事務中繼續查找這個 id 為 1 的記錄，如下：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 READ COMMITTED 隔離級別的事務</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 均未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值為'habit'</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE2：Transaction 70 提交，Transaction 90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值為'habit_trx_id_70_02'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>這個 SELECE2 的執行過程如下：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在執行 SELECT 語句時又會單獨生成一個 ReadView，該 ReadView 的 m_ids 列表的內容就是[90]，min_trx_id 為 90，max_trx_id 為 91，creator_trx_id 為 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然後從版本鏈中挑選可見的記錄，從圖中可以看出，最新版本的列 name 的內容是 habit_trx_id_90_02，該版本的 trx_id 值為 90，在 m_ids 列表內，所以不符合可見性要求，根據 roll_pointer 跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit_trx_id_90_01，該版本的 trx_id 值為 90，也在 m_ids 列表內，所以也不符合要求，繼續跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit_trx_id_70_02，該版本的 trx_id 值為 70，小於 ReadView 中的 min_trx_id 值 90，所以這個版本是符合要求的，最後返回這個版本中列 name 為 habit_trx_id_70_02 的記錄。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>以此類推，如果之後事務 id 為 90 的記錄也提交了，再次在使用 READ COMMITTED 隔離級別的事務中查詢表 mvcc_test 中 id 值為 1 的記錄時，得到的結果就是 habit_trx_id_90_02 了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>總結：</span></strong></span></span><span><span><span>使用 READ COMMITTED 隔離級別的事務在每次查詢開始時都會生成一個獨立的 ReadView。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>REPEATABLE READ：</span></strong></span></span><span><span><span>在第一次讀取數據時生成一個 ReadView；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於使用 REPEATABLE READ 隔離級別的事務來説，只會在第一次執行查詢語句時生成一個 ReadView，之後的查詢就不會重複生成了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比方説現在系統裏有兩個事務 id 分別為 70、90 的事務在執行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- T 70</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此時表 mvcc_test 中 id 為 1 的記錄得到的版本鏈表如下所示：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-51UwvDNOV077PoRbf.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>假設現在有一個使用 REPEATABLE READ 隔離級別的事務開始執行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 REPEATABLE READ 隔離級別的事務</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值為'habit'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>這個 SELECE1 的執行過程如下：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在執行 SELECT 語句時會先生成一個 ReadView，ReadView 的 m_ids 列表的內容就是[70, 90]，min_trx_id 為 70，max_trx_id 為 91，creator_trx_id 為 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然後從版本鏈中挑選可見的記錄，從圖中可以看出，最新版本的列 name 的內容是 habit_trx_id_70_02，該版本的 trx_id 值為 70，在 m_ids 列表內，所以不符合可見性要求，根據 roll_pointer 跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit_trx_id_70_01，該版本的 trx_id 值也為 70，也在 m_ids 列表內，所以也不符合要求，繼續跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit，該版本的 trx_id 值為 50，小於 ReadView 中的 min_trx_id 值，所以這個版本是符合要求的，最後返回的就是這條列 name 為 habit 的記錄。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>之後，把事務 id 為 70 的事務提交一下，然後再到事務 id 為 90 的事務中更新一下表 mvcc_test 中 id 為 1 的記錄：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 REPEATABLE READ 隔離級別的事務</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此刻，表 mvcc_test 中 id 為 1 的記錄的版本鏈就長這樣：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-51h9D8xW10EuQBNz51m.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>然後再到剛才使用 REPEATABLE READ 隔離級別的事務中繼續查找這個 id 為 1 的記錄，如下：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 REPEATABLE READ 隔離級別的事務</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 均未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值為'habit'</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE2：Transaction 70 提交，Transaction 90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span> &nbsp;</span></span><span><span style="color:#708090">-- 得到的列 name 的值為'habit'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這個 SELECE2 的執行過程如下：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>因為當前事務的隔離級別為 REPEATABLE READ，而之前在執行 SELECE1 時已經生成過 ReadView 了，所以此時直接複用之前的 ReadView，之前的 ReadView 的 m_ids 列表的內容就是[70, 90]，min_trx_id 為 70，max_trx_id 為 91， creator_trx_id 為 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然後從版本鏈中挑選可見的記錄，從圖中可以看出，最新版本的列 name 的內容是 habit_trx_id_90_02，該版本的 trx_id 值為 90，在 m_ids 列表內，所以不符合可見性要求，根據 roll_pointer 跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit_trx_id_90_01，該版本的 trx_id 值為 90，也在 m_ids 列表內，所以也不符合要求，繼續跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit_trx_id_70_02，該版本的 trx_id 值為 70，而 m_ids 列表中是包含值為 70 的事務 id 的，所以該版本也不符合要求，同理下一個列 name 的內容是 habit_trx_id_70_01 的版本也不符合要求。繼續跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit，該版本的 trx_id 值為 50，小於 ReadView 中的 min_trx_id 值 70，所以這個版本是符合要求的，最後返回給用戶的版本就是這條列 name 為 habit 的記錄。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>也就是説兩次 SELECT 查詢得到的結果是重複的，記錄的列 name 值都是 habit，這就是可重複讀的含義。如果之後再把事務 id 為 90 的記錄提交了，然後再到剛才使用 REPEATABLE READ 隔離級別的事務中繼續查找這個 id 為 1 的記錄，得到的結果還是 habit。</span></span></span></p><span id="OSC_h3_7"></span><h3><span><span><span>MVCC 下的幻讀解決和幻讀現象</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>REPEATABLE READ 隔離級別下 MVCC 可以解決不可重複讀問題，那麼幻讀呢？MVCC 是怎麼解決的？幻讀是一個事務按照某個相同條件多次讀取記錄時，後讀取時讀到了之前沒有讀到的記錄，而這個記錄來自另一個事務添加的新記錄。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以想想，在 REPEATABLE READ 隔離級別下的事務 T1 先根據某個搜索條件讀取到多條記錄，然後事務 T2 插入一條符合相應搜索條件的記錄並提交，然後事務 T1 再根據相同搜索條件執行查詢。結果會是什麼？按照 ReadView 中的比較規則中的第 3 條和第 4 條不管事務 T2 比事務 T1 是否先開啓，事務 T1 都是看不到 T2 的提交的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>但是，在 REPEATABLE READ 隔離級別下 InnoDB 中的 MVCC 可以很大程度地避免幻讀現象，而不是完全禁止幻讀。怎麼回事呢？來看下面的情況：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-51wOnqygonsF10mmAn.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>首先在事務 T1 中執行：</span></span></span><span><span><code><span>select * from mvcc_test where id = 30;</span></code></span></span><span><span><span> 這個時候是找不到 id = 30 的記錄的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在事務 T2 中，執行插入語句：</span></span></span><span><span><code><span>insert into mvcc_test values(30,'luxi','luxi');</span></code></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此時回到事務 T1，執行：</span></span></span></p><pre><code><span><span><span style="color:#0077aa">update</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">set</span></span><span><span> domain</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#669900">'luxi_t1'</span></span><span><span></span></span><span><span style="color:#0077aa">where</span></span><span><span> id</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#990055">30</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">select</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">from</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">where</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">30</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>事務 T1 很明顯出現了幻讀現象。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 REPEATABLE READ 隔離級別下，T1 第一次執行普通的 SELECT 語句時生成了一個 ReadView，之後 T2 向 mvcc_test 表中新插入一條記錄並提交。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>ReadView 並不能阻止 T1 執行 UPDATE 或者 DELETE 語句來改動這個新插入的記錄，由於 T2 已經提交，因此改動該記錄並不會造成阻塞，但是這樣一來，這條新記錄的 trx_id 隱藏列的值就變成了 T1 的事務 id。之後 T1 再使用普通的 SELECT 語句去查詢這條記錄時就可以看到這條記錄了，也就可以把這條記錄返回給客戶端。因為這個特殊現象的存在，可以認為 MVCC 並不能完全禁止幻讀。</span></span></span></p><span id="OSC_h3_8"></span><h3><span><span><span>mvcc 總結</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>從上邊的描述中可以看出來，所謂的 MVCC（Multi-Version Concurrency Control ，多版本併發控制）指的就是在使用 READ COMMITTD、REPEATABLE READ 這兩種隔離級別的事務在執行普通的 SELECT 操作時訪問記錄的版本鏈的過程，這樣子可以使不同事務的讀寫、寫讀操作併發執行，從而提升系統性能。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>READ COMMITTD、REPEATABLE READ 這兩個隔離級別的一個很大不同就是：生成 ReadView 的時機不同，READ COMMITTD 在每一次進行普通 SELECT 操作前都會生成一個 ReadView，而 REPEATABLE READ 只在第一次進行普通 SELECT 操作前生成一個 ReadView，之後的查詢操作都重複使用這個 ReadView 就好了，從而基本上可以避免幻讀現象。</span></span></span></p><span id="OSC_h2_9"></span><h2><span><span><span>InnoDB 的 Buffer Pool</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於使用 InnoDB 作為存儲引擎的表來説，不管是用於存儲用戶數據的索引，包括：聚簇索引和二級索引，還是各種系統數據，都是以頁的形式存放在表空間中的，而所謂的表空間只不過是 InnoDB 對文件系統上一個或幾個實際文件的抽象，也就是説數據還是存儲在磁盤上的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>但是磁盤的速度慢，所以 InnoDB 存儲引擎在處理客戶端的請求時，當需要訪問某個頁的數據時，就會把完整的頁的數據全部加載到內存中，即使只需要訪問一個頁的一條記錄，那也需要先把整個頁的數據加載到內存中。將整個頁加載到內存中後就可以進行讀寫訪問了，在進行完讀寫訪問之後並不着急把該頁對應的內存空間釋放掉，而是將其緩存起來，這樣將來有請求再次訪問該頁面時，就可以省去磁盤 IO 的開銷了。</span></span></span></p><span id="OSC_h3_10"></span><h3><span><span><span>Buffer Pool</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>InnoDB 為了緩存磁盤中的頁，在 MySQL 服務器啓動的時候就向操作系統申請了一片連續的內存，這塊連續內存叫做：Buffer Pool，中文名：緩衝池。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>默認情況下 Buffer Pool 只有 128M 大小。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>查看該值：</span></span></span><span><span><code><span>show variables like 'innodb_buffer_pool_size';</span></code></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以在啓動服務器的時候配置 innodb_buffer_pool_size 參數的值，它表示 Buffer Pool 的大小，配置如下：</span></span></span></p><pre><code><span><span><span>[server]
innodb_buffer_pool_size = 268435456</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>其中，268435456 的單位是字節，也就是指定 Buffer Pool 的大小為 256M，Buffer Pool 也不能太小，最小值為 5M，當小於該值時會自動設置成 5M。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>啓動 MySQL 服務器的時候，需要完成對 Buffer Pool 的初始化過程，就是先向操作系統申請 Buffer Pool 的內存空間，然後把它劃分成若干對控制塊和緩，存頁。但是此時並沒有真實的磁盤頁被緩存到 Buffer Pool 中，之後隨着程序的運行，會不斷的有磁盤上的頁被緩存到 Buffer Pool 中。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 Buffer Pool 中會創建多個緩存頁，默認的緩存頁大小和在磁盤上默認的頁大小是一樣的，都是 16KB。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>那麼怎麼知道該頁在不在 Buffer Pool 中呢？</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在查找數據的時候，先通過哈希表中查找 key 是否在哈希表中，如果在證明 Buffer Pool 中存在該緩存也信息，如果不存在證明不存該緩存也信息，則通過讀取磁盤加載該頁信息放到 Buffer Pool 中，哈希表中的 key 是通過表空間號+ 頁號作組成的，value 是 Buffer Pool 的緩存頁。</span></span></span></p><span id="OSC_h3_11"></span><h3><span><span><span>flush 鏈表的管理</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果修改了 Buffer Pool 中某個緩存頁的數據，那它就和磁盤上的頁不一致了，這樣的緩存頁也被稱為：</span></span></span><span><span><strong><span>髒頁</span></strong></span></span><span><span><span>。最簡單的做法就是每發生一次修改就立即同步到磁盤上對應的頁上，但是頻繁的往磁盤中寫數據會嚴重的影響程序的性能。所以每次修改緩存頁後，並不着急把修改同步到磁盤上，而是在未來的某個時間進行同步。 但是如果不立即同步到磁盤的話，那之後再同步的時候怎麼知道 Buffer Pool 中哪些頁是髒頁，哪些頁從來沒被修改過呢？總不能把所有的緩存頁都同步到磁盤上吧，如果 Buffer Pool 被設置的很大，那一次性同步會非常慢。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>所以，需要再創建一個存儲髒頁的鏈表，凡是修改過的緩存頁對應的控制塊都會作為一個節點加入到一個鏈表中，因為這個鏈表節點對應的緩存頁都是需要被刷新到磁盤上的，所以也叫 flush 鏈表。</span></span></span></p><span id="OSC_h3_12"></span><h3><span><span><span>刷新髒頁到磁盤</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>後台有專門的線程每隔一段時間負責把髒頁刷新到磁盤，這樣可以不影響用戶線程處理正常的請求。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>從 flush 鏈表中刷新一部分頁面到磁盤，後台線程也會定時從 flush 鏈表中刷新一部分頁面到磁盤，刷新的速率取決於當時系統是不是很繁忙。這種刷新頁面的方式被稱之為：BUF_FLUSH_LIST。</span></span></span></p><span id="OSC_h2_13"></span><h2><span><span><span>redo 日誌</span></span></span></h2><span id="OSC_h3_14"></span><h3><span><span><span>redo 日誌的作用</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>InnoDB 存儲引擎是以頁為單位來管理存儲空間的，增刪改查操作其實本質上都是在訪問頁面，包括：讀頁面、寫頁面、創建新頁面等操作。在真正訪問頁面之前，需要把在磁盤上的頁緩存到內存中的 Buffer Pool 之後才可以訪問。但是在事務的時候又強調過一個稱之為持久性的特性，就是説對於一個已經提交的事務，在事務提交後即使系統發生了崩潰，這個事務對數據庫中所做的更改也不能丟失。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果只在內存的 Buffer Pool 中修改了頁面，假設在事務提交後突然發生了某個故障，導致內存中的數據都失效了，那麼這個已經提交了的事務對數據庫中所做的更改也就跟着丟失了，這是所不能忍受的。那麼如何保證這個持久性呢？一個很簡單的做法就是在事務提交完成之前把該事務所修改的所有頁面都刷新到磁盤，但是這個簡單粗暴的做法有些問題：</span></span></span></p><ol><li><span><span><span><span>刷新一個完整的數據頁太浪費了；有時候僅僅修改了某個頁面中的一個字節，但是在 InnoDB 中是以頁為單位來進行磁盤 IO 的，也就是説在該事務提交時不得不將一個完整的頁面從內存中刷新到磁盤，一個頁面默認是 16KB 大小，只修改一個字節就要刷新 16KB 的數據到磁盤上顯然是太浪費了。</span></span></span></span></li><li><span><span><span><span>隨機 IO 刷起來比較慢；一個事務可能包含很多語句，即使是一條語句也可能修改許多頁面，該事務修改的這些頁面可能並不相鄰，這就意味着在將某個事務修改的 Buffer Pool 中的頁面刷新到磁盤時，需要進行很多的隨機 IO，隨機 IO 比順序 IO 要慢，尤其對於傳統的機械硬盤來説。</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>只是想讓已經提交了的事務對數據庫中數據所做的修改永久生效，即使後來系統崩潰，在重啓後也能把這種修改恢復出來。其實沒有必要在每次事務提交時就把該事務在內存中修改過的全部頁面刷新到磁盤，只需要把修改了哪些東西記錄一下就好，比方説：某個事務將系統表空間中的第 5 號頁面中偏移量為 5000 處的那個字節的值 0 改成 5 只需要記錄一下：</span></span></span><span><span><strong><span>將第 5 號表空間的 5 號頁面的偏移量為 5000 處的值更新為：5</span></strong></span></span><span><span><span>。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這樣在事務提交時，把上述內容刷新到磁盤中，即使之後系統崩潰了，重啓之後只要按照上述內容所記錄的步驟重新更新一下數據頁，那麼該事務對數據庫中所做的修改又可以被恢復出來，也就意味着滿足持久性的要求。因為在系統崩潰重啓時需要按照上述內容所記錄的步驟重新更新數據頁，所以上述內容也被稱之為：</span></span></span><span><span><strong><span>重做日誌，即：redo log</span></strong></span></span><span><span><span>。與在事務提交時將所有修改過的內存中的頁面刷新到磁盤中相比，只將該事務執行過程中產生的 redo log 刷新到磁盤的好處如下：</span></span></span></p><ol><li><span><span><span><span>redo log 佔用的空間非常小存儲表空間 ID、頁號、偏移量以及需要更新的值所需的存儲空間是很小的；</span></span></span></span></li><li><span><span><span><span>redo log 是順序寫入磁盤的在執行事務的過程中，每執行一條語句，就可能產生若干條 redo log，這些日誌是按照產生的順序寫入磁盤的，也就是使用順序 IO；</span></span></span></span></li></ol><span id="OSC_h3_15"></span><h3><span><span><span>redo log 的寫入過程</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>InnoDB 為了更好的進行系統崩潰恢復，把一次原子操作生成的 redo log 都放在了大小為 512 字節的塊（block）中。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>為瞭解決磁盤速度過慢的問題而引入了 Buffer Pool。同理，寫入 redo log 時也不能直接寫到磁盤上，實際上在服務器啓動時就向操作系統申請了一大片稱之為 redo log buffer 的連續內存空間，即：redo log 緩衝區，也可以簡稱：log buffer。這片內存空間被劃分成若干個連續的 redo log block，可以通過啓動參數 innodb_log_buffer_size 來指定 log buffer 的大小，該啓動參數的默認值為：16MB。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>向 log buffer 中寫入 redo log 的過程是順序的，也就是先往前邊的 block 中寫，當該 block 的空閒空間用完之後再往下一個 block 中寫。</span></span></span></p><span id="OSC_h4_16"></span><h4><span><span><span>redo log 刷盤時機</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>log buffer 什麼時候會寫入到磁盤呢？</span></strong></span></span></p><ul><li><span><span><span><span>log buffer 空間不足時，如果不停的往這個有限大小的 log buffer 裏塞入日誌，很快它就會被填滿。InnoDB 認為如果當前寫入 log buffer 的 redo log 量已，經佔滿了 log buffer 總容量的大約一半左右，就需要把這些日誌刷新到磁盤上。</span></span></span></span></li><li><span><span><span><span>事務提交時，必須要把修改這些頁面對應的 redo log 刷新到磁盤。</span></span></span></span></li><li><span><span><span><span>後台有一個線程，大約每秒都會刷新一次 log buffer 中的 redo log 到磁盤。</span></span></span></span></li><li><span><span><span><span>正常關閉服務器時等等。</span></span></span></span></li></ul><span id="OSC_h2_17"></span><h2><span><span><span>undo 日誌</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>事務需要保證原子性，也就是事務中的操作要麼全部完成，要麼什麼也不做。但是偏偏有時候事務執行到一半會出現一些情況，比如：</span></span></span></p><ul><li><span><span><span><span>情況一：事務執行過程中可能遇到各種錯誤，比如服務器本身的錯誤，操作系統錯誤，甚至是突然斷電導致的錯誤。</span></span></span></span></li><li><span><span><span><span>情況二：程序員可以在事務執行過程中手動輸入 ROLLBACK 語句結束當前的事務的執行。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這兩種情況都會導致事務執行到一半就結束，但是事務執行過程中可能已經修改了很多東西，為了保證事務的原子性，需要把東西改回原先的樣子，這個過程就稱之為回滾，即：rollback，這樣就可以造成這個事務看起來什麼都沒做，所以符合原子性要求。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>每當要對一條記錄做改動時，都需要把回滾時所需的東西都給記下來。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比方説：</span></span></span></p><ul><li><span><span><span><span>插入一條記錄時，至少要把這條記錄的主鍵值記下來，之後回滾的時候只需要把這個主鍵值對應的記錄刪掉。</span></span></span></span></li><li><span><span><span><span>刪除了一條記錄，至少要把這條記錄中的內容都記下來，這樣之後回滾時再把由這些內容組成的記錄插入到表中。</span></span></span></span></li><li><span><span><span><span>修改了一條記錄，至少要把修改這條記錄前的舊值都記錄下來，這樣之後回滾時再把這條記錄更新為舊值。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這些為了回滾而記錄的這些東西稱之為撤銷日誌，即：undo log。這裏需要注意的一點是，由於查詢操作並不會修改任何用戶記錄，所以在查詢操作執行時，並不需要記錄相應的 undo log。</span></span></span></p><span id="OSC_h3_18"></span><h3><span><span><span>undo 日誌的格式</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>為了實現事務的原子性，InnoDB 存儲引擎在實際進行增、刪、改一條記錄時，都需要先把對應的 undo 日誌記下來。一般每對一條記錄做一次改動，就對應着一條 undo 日誌，但在某些更新記錄的操作中，也可能會對應着 2 條 undo 日誌。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>一個事務在執行過程中可能新增、刪除、更新若干條記錄，也就是説需要記錄很多條對應的 undo 日誌，這些 undo 日誌會被從 0 開始編號，也就是説根據生成的順序分別被稱為第 0 號 undo 日誌、第 1 號 undo 日誌、...、第 n 號 undo 日誌等，這個編號也被稱之為 undo no。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這些 undo 日誌是被記錄到類型為 FIL_PAGE_UNDO_LOG 的頁面中。這些頁面可以從系統表空間中分配，也可以從一種專門存放 undo 日誌的表空間，也就是所謂的 undo tablespace 中分配。</span></span></span></p><blockquote><p>作者：京東物流，張士欣</p><p>來源：京東雲開發者社區，自圓其説 Tech 轉載請註明來源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10142911</guid>
            <link>https://my.oschina.net/u/4090830/blog/10142911</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[🎁有獎問答 | 從 kkFileView 項目出發，聊聊怎麼做開源項目]]>
            </title>
            <description>
                <![CDATA[<h1 class="header article-title"><a href="https://www.oschina.net/question/4700705_2331356">高手問答第 309 期 —— 從 kkFileView 項目出發，聊聊怎麼做開源項目</a><div class="ui red label horizontal" data-tooltip="置頂">頂</div></h1><div class="extra ui horizontal list meta-wrap"><div class="item"><a href="https://my.oschina.net/u/4700705" class="__user"><span>小白兔愛吃大灰狼</span></a> 發佈於，昨天 17:36
                    </div><div class="item">閲讀 253</div><div class="item collect-btn " data-id="2331356" data-user-id="4700705" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i> 收藏 <span data-collect-count="" data-id="2331356" data-obj-type="2">0</span></div><div class="item comment-count"><a href="https://www.oschina.net/question/4700705_2331356#comments" class="normal"><i class="comment outline icon"></i> 答案 <span data-article-reply-count="">1</span></a></div></div><div class="tags"><a class="ui horizontal label" href="https://www.oschina.net/question/topic/masteronline" target="_blank"><img src="https://static.oschina.net/uploads/logo/masteronline_9WTeU.png" referrerpolicy="no-referrer">高手問答</a></div><div class="content" id="articleContent"><p><span><span>開源項目是每一個開發者無法繞過的一個詞，無論你是否主動接觸開源項目，他就在你身邊，和你的工作息息相關。本期嘉賓 KL 博主 6 年前一次偶然的機會接觸開源項目後，彷彿打開了代碼世界的大門，打通了任督二脈。這裏有書本上，你在公司裏沒有的知識和能量。從開源獲取，然後反饋開源，是博主一直踐行的開源原則，截止目前，博主開源了數 10+ 的項目，也參與了很多社區的項目，比如 apollo 、skywalking 、seata 等。其中 kkFileView 是博主開源最成功的一個項目，目前 kkFileView 獲得過開源中國 GVP 項目，在 Gitee 的所有推薦項目裏的 star 排名第 10 ，19281 個 star。kkFileView 一直保持着開源的初心，踐行着佛性開源的路子做着開源項目。也因為如下：</span></span></p><ul><li><span><span>好的開源項目一定是架構優良可持續擴展優化的</span></span></li><li><span><span>好的開源項目一定是有需求場景，解決實際問題的</span></span></li><li><span><span>好的開源項目一定是有經濟支撐可持續維護迭代的</span></span></li><li><span><span>好的開源項目一定是説明齊全，容易上手的</span></span></li></ul><p><span><span>kkFileView 可以一直健康發展迭代。</span></span></p><blockquote><p><span><span>kkFileView 項目地址：</span><a href="https://gitee.com/kekingcn/file-online-preview" target="_blank" rel="nofollow">https://gitee.com/kekingcn/file-online-preview</a></span></p></blockquote><p><strong><span><span>OSCHINA 本期高手問答（11 月 15 日-11 月 21 日）將以「從 kkFileView 項目聊聊怎麼做開源項目」為切入點，聊一聊怎麼做好開源項目，可討論的內容包括帶不限於以下：</span></span></strong></p><ul><li><span><span>怎麼參與開源項目</span></span></li><li><span><span>怎麼上手一個新的開源項目</span></span></li><li><span><span>怎麼開源一個自己的開源項目</span></span></li><li><span><span>kkFileView 項目相關話題</span></span></li><li><span><span>怎麼從開源項目裏學以致用</span></span></li><li><span><span>等等</span></span></li></ul><p><span style="background-color:#ffffff; color:#000000">有其他相關問題，也歡迎大家積極提問！</span></p><h1>嘉賓簡介</h1><p><span><span style="color:#000000">陳凱玲，網名：KL，在社區裏一直以」KL 博主「自稱。先後就職於凱京集團和 TapTap，一直從事 Java 架構、中間件、SRE 等開發工作。是開源項目 kkFileView&nbsp; 作者，也是 Apollo 配置中心社區的 PMC。</span></span></p><ul><li><span><span style="color:#000000">Gitee 主頁：</span><a href="https://gitee.com/kailing" target="_blank" rel="nofollow">https://gitee.com/kailing</a></span></li><li><span><span>OSC 主頁：</span><a href="https://my.oschina.net/klblog" target="_blank" rel="nofollow">https://my.oschina.net/klblog</a></span></li><li><span><span>個人博客：</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.kailing.pub%2F" target="_blank" rel="nofollow">http://www.kailing.pub/</a></span></li></ul><p><span><img alt="" height="533" src="https://oscimg.oschina.net/oscnet/up-25fffd13ffa4a26b83d8d969dd57c9be8ce.jpg" width="400" referrerpolicy="no-referrer"></span></p><p><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>為了鼓勵踴躍提問，我們會在問答結束後從提問者中抽取 5 名幸運會員贈予定製開源魔方一個</span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>！</span></span></span></span></span></span></span></span></p><p><img alt="" height="356" src="https://oscimg.oschina.net/oscnet/up-d8b90a25d803f6b37329dec2c8bae8bdd2c.jpg" width="400" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#27ae60">OSChina 高手問答一貫的風格，不歡迎任何與主題無關的討論和噴子。</span></p><p>下面歡迎大家就<span>用戶畫像和大數據技術相關</span>問題向 <a href="https://my.oschina.net/klblog" rel="nofollow"><strong>KL 博主</strong><strong><span style="color:#000000">&nbsp;</span></strong></a>提問，直接回帖提問既可。</p></div><div class="poll-wrap"></div><div class="additional-remarks"></div><div class="ui basic center aligned segment action"><div class="ui big buttons"><a class="ui basic button collect-btn hover" data-id="2331356" data-user-id="4700705" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i>收藏 (<span data-collect-count="" data-id="2331356" data-obj-type="2">0</span>)</a><div class="ui basic dropdown share button osc-share dropdown-share" data-tag="share-question"><i class="share icon"></i><span>分享</span><div class="menu"><a class="item" data-platform="weibo" data-value="weibo"><i class="weibo icon"></i>微博</a><a class="item" data-platform="qq" data-value="qq"><i class="qq icon"></i>QQ</a><a class="item" data-platform="wechat" data-value="wechat"><i class="weixin icon"></i>微信</a></div></div></div><div class="ui basic segment"><a class="ban" ban-report="" data-id="2331356" data-obj-type="2" data-url="https://www.oschina.net/question/4700705_2331356"><i class="flag red icon"></i>舉報</a></div></div>
            ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/question/4700705_2331356</guid>
            <link>https://www.oschina.net/question/4700705_2331356</link>
        </item>
        <item>
            <title>
                <![CDATA[小米澎湃 OS 首個開發版開始推送：底層重構、安裝包大小 6GB]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米 13 系列、Redmi K60 系列用戶已經陸續收到澎湃 OS 開發版&nbsp;OS1.0.23.11.8.DEV 推送，安裝包大小分別為 6.0GB 和 5.9GB。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1e7dfa814e55e981dd76d5f952068e89b6b.png" referrerpolicy="no-referrer"></p><p>更新日誌：</p><p><strong>Xiaomi HyperOS</strong></p><ul><li>小米澎湃 OS 打造「人車家全生態」操作系統。</li></ul><p><strong>底層重構</strong></p><ul><li><p>小米澎湃 OS 底層重構，發揮卓越的硬件性能關鍵；</p></li><li><p>任務識別染色技術，根據任務重要程度動態管控資源分配，更強性能更低功耗；</p></li><li><p>超低功耗渲染框架，提升續航能力並提供更流暢的動畫效果；</p></li><li><p><strong>SOC 一體化調頻，串聯整機硬件資源，更快響應算力需求變化，丟幀更少更流暢；</strong></p></li><li><p>智慧 IO 引擎，焦點 IO 優先執行，避免搶佔更流暢；</p></li><li><p>內存管理引擎升級，降低系統內存管理資源消耗，提升整體性能及流暢度，大幅提升可用內存及後台駐留能力煥新存儲技術，減少存儲碎片化，讓手機久用如新；</p></li><li><p>智能選網能力升級，弱網環境網絡更流暢；</p></li><li><p>超級近場通信，更高互傳速率，更低傳輸功耗；</p></li><li><p>信號智選引擎，動態調整天線策略，提升信號穩定性。</p></li></ul><p><strong>跨端智聯</strong></p><ul><li><p>Xiaomi HyperConnect 跨端互聯框架，讓設備高效連接，極致協同；</p></li><li><p><strong>全新融合設備中心，所有設備動態實時組網，在控制中心即可查看並操控周圍設備；</strong></p></li><li><p>跨設備體驗全面升級，支持跨設備調用攝像頭、屏幕、通信等多種硬件能力；</p></li><li><p>應用、音視頻、剪貼板等數據和服務，支持在多設備間自由流轉。</p></li></ul><p><strong>全域安全</strong></p><ul><li><p>面向設備互聯的安全隱私架構；</p></li><li><p>設備間通過 TEE 相互校驗安全，數據傳輸硬件級加密；</p></li><li><p>跨端隱私體系，包含互聯權限管理、互聯行為提醒和互聯行為記錄。</p></li></ul><p><strong>生命感美學</strong></p><ul><li><p>面向全球化的生命感美學，營造出細膩舒適的視覺和輕盈連貫的動效，多元融合的表達式帶來全新的系統美學體驗；</p></li><li><p><strong>全新動效語言，帶來輕盈連貫的全局動效體驗；</strong></p></li><li><p>生命力色彩系統，富有生命氣息的自然色，讓界面煥然一新；</p></li><li><p>統一的系統字體，為全球而設計；</p></li><li><p>全新天氣設計，實時氣象引擎創造超現實的視覺體驗；</p></li><li><p>全局焦點通知體系，動態展示關鍵信息變化；</p></li><li><p>全新藝術鎖屏，讓你的每張照片都變成海報，更有動態玻璃材質，亮屏瞬間精美絕倫；</p></li><li><p>桌面圖標設計升級，色彩造型全面煥新；</p></li><li><p>自研多重渲染技術，呈現細膩舒適的自然視效；</p></li><li><p><strong>重構多任務窗口管理，統一交互，高效易用。</strong></p></li></ul><p>此外，小米還提醒用戶本次更新為安卓跨版本升級，為降低升級風險，建議提前備份個人數據。本次更新啓動加載時間相對較長，<strong>啓動後短時間內可能出現微熱、微卡等性能、功耗問題</strong>，請耐心等待。部分三方應用由於自身未進行版本適配會影響正常使用，請謹慎升級。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ec01c02cb932dd2ff826fdfebe25a3d342c.png" referrerpolicy="no-referrer"></p><p>澎湃 OS 開發版&nbsp;OS1.0.23.11.8.DEV、OS1.0.23.11.13.DEV&nbsp;版本提前至今日（11 月 14 日）起陸續推送更新，覆蓋機型包括小米 14/ Pro 系列、小米 13 / Pro / Ultra 系列、Redmi K60 / Pro 系列。</p><p>此外，原定於 11 月中下旬發佈小米澎湃 OS 開發版的小米 MIX Fold 3、MIX Fold 2 目前進展正常，將按原定計劃進行推送。</p><p>延伸閲讀</p><ul><li><a href="https://www.oschina.net/news/263829" target="news">小米 14 開機動畫顯示澎湃 OS 基於 Android</a></li><li><a href="https://www.oschina.net/news/263645" target="news">小米澎湃 OS 正式發佈，Xiaomi Vela 將開源</a></li><li><a href="https://www.oschina.net/news/263025" target="news">雷軍公佈小米澎湃 OS 完整系統架構，稱底層全部重構</a></li><li><a href="https://www.oschina.net/news/262088" target="news">雷軍：小米全新操作系統澎湃 OS 正式版已完成封包</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266511</guid>
            <link>https://www.oschina.net/news/266511</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[.NET 8 正式 GA，最新 LTS 版本]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>.NET 8 <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fannouncing-dotnet-8%2F" target="_blank">已正式 GA</a></u>。</p><p>微軟稱 .NET 8 提供了數以千計的性能、穩定性和安全性改進，以及平台和工具增強功能，有助於提高開發者的工作效率和創新速度。</p><p>比如 .NET 8 為 Android 和 WASM 引入了<u><a href="https://www.oschina.net/news/258112/dotnet-8-rc1">全新的 AOT 模式</a></u>、改進 System.Text.Json，以及為容器添加 Azure Managed Identity 支持。此外，Linux 上的 .NET 8 獨立體積<u><a href="https://www.oschina.net/news/266051">減少 50%</a></u>。</p><blockquote><p><em>延伸閲讀：</em><u><em><a href="https://www.oschina.net/news/258091/performance-improvements-in-dot-net-8" target="_blank">.NET 8 性能大幅提升，比 .NET 7 更快</a></em></u></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ff03787397a0c87db779b9a9f69c320f1a5.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-011ebda9040166e191e3e635bc6cbd30a5f.png" referrerpolicy="no-referrer"></p><p>通過此版本，.NET 重塑了構建可按需擴展的智能雲原生應用程序和高流量服務的方式。無論是部署到 Linux 還是 Windows，使用容器還是雲應用程序模型，.NET 8 都可以支持開發者更輕鬆地構建這些應用程序。它包括一組經過驗證的庫，目前 Microsoft 的許多大規模服務都在使用這些庫，以幫助應對可觀察性、彈性、可擴展性、可管理性等方面的基本挑戰。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-4ddd74bf8b72f89c60e1125c5cd19e84eca.png" referrerpolicy="no-referrer"></p><p>.NET 8 還支持將 OpenAI 的 GPT 等大語言模型 (LLM) 直接集成到 .NET 應用程序中。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0af7e466e53f9b88e00546b1ef7ae27371d.png" referrerpolicy="no-referrer"></p><p>開發者可通過 Blazor 使用單個強大的組件模型來處理所有 Web UI 需求，使用 .NET MAUI 將移動應用程序部署到最新版本的 iOS 和 Android。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-48c2bd6fe11d828b1519184c68ccee59222.png" referrerpolicy="no-referrer"></p><p><strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdotnet%2Fcore%2Fblob%2Fmain%2Frelease-notes%2F8.0%2F8.0.0%2F8.0.0.md%3FWT.mc_id%3Ddotnet-35129-website" target="_blank">.NET 8.0.0 Release Notes</a></u>&nbsp;| <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fannouncing-dotnet-8%2F" target="_blank">發佈公告</a></u></strong></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 00:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266507/dotnet-8-ga</guid>
            <link>https://www.oschina.net/news/266507/dotnet-8-ga</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[🚀 第一時間適配 .NET8.0，Furion v4.9.1 版本發佈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>適配 .NET8.0</h2><p><strong>於 2023 年 11 月 15 日，微軟正式對外發布了 .NET8.0 正式版。</strong></p><p>Furion 開發團隊第一時間進行了升級適配，這一次升級非常順利，升級過程中<strong>只遇到兩個破壞性更改（都是運行時錯誤）</strong>，所以迅速發佈了 v4.9.0，v4.9.0.1，v4.9.1 三個修正版本。</p><p><img height="130" src="https://oscimg.oschina.net/oscnet/up-7fa7ccb98b763beb3d257948361fe1a7c75.png" width="860" referrerpolicy="no-referrer"></p><h2>歲月如梭</h2><p>時間過得真快啊，轉眼間 Furion 已經發布了超過 3 年。在這三年間，我們發佈了 900 多個版本，修復了 5000 多個問題，合併了 1000 多個請求。經歷了各種挑戰和困難，但也收穫了很多。無論是酸、甜、苦還是鹹，我們都一一體驗過了。</p><p><strong>繼續加油吧。</strong></p><p><img height="1328" src="https://oscimg.oschina.net/oscnet/up-4960bb2a7443d464f06cb55ea0548c908d8.png" width="1718" referrerpolicy="no-referrer"></p><h2>時過境遷</h2><p>當初在發佈新版本的定時任務模塊時，我寫下了下面這段話。時過境遷，再次看到曾經寫下的文字，那段充滿黑暗和孤獨的日子仍然歷歷在目。</p><p><img height="687" src="https://oscimg.oschina.net/oscnet/up-b048b0a7b5b9efd1030c57d42147cb098c6.png" width="974" referrerpolicy="no-referrer"></p><h2><strong>走向成年</strong></h2><p>這裏記錄了 Furion 從誕生的一切重要時刻，它就像孩子一樣，懵懵懂懂開始走向成年。</p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Ffurion.baiqian.ltd%2Fdocs%2Fcourse" target="_blank">http://furion.baiqian.ltd/docs/course</a></p><p><img height="1328" src="https://oscimg.oschina.net/oscnet/up-f49bd231351d00c7ae9277ce5a5803136c3.png" width="1718" referrerpolicy="no-referrer"></p><p><img height="1328" src="https://oscimg.oschina.net/oscnet/up-557104565bb43862565761ecfe4fd6cc3a4.png" width="1718" referrerpolicy="no-referrer"></p><h2>努力見證</h2><p>三年間，發佈了 900 多個版本，每一條版本記錄都是努力的見證。</p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Ffurion.baiqian.ltd%2Fdocs%2Fupgrade" target="_blank">http://furion.baiqian.ltd/docs/upgrade</a></p><p><img height="1328" src="https://oscimg.oschina.net/oscnet/up-1b34eca9d627886bbf660635e91105ce950.png" width="1718" referrerpolicy="no-referrer"></p><p><img height="1328" src="https://oscimg.oschina.net/oscnet/up-80f28e24e11c4766e20b720e778da29c14b.png" width="1718" referrerpolicy="no-referrer"></p><h2>項目信息</h2><ul><li>Gitee：<strong><a href="https://gitee.com/dotnetchina/Furion">https://gitee.com/dotnetchina/Furion</a></strong></li><li>Github：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FMonkSoul%2FFurion" target="_blank">https://github.com/MonkSoul/Furion</a></li><li>文檔：<strong><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Ffurion.baiqian.ltd%2F" target="_blank">http://furion.baiqian.ltd/</a></strong></li></ul><h2>本期更新</h2><ul><li><p style="margin-left:0; margin-right:0"><strong>新特性</strong></p><ul><li>[新增] 補償策略模塊功能<span>&nbsp;</span>4.9.1<span>&nbsp;</span>⏱️2023.11.15<span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/tree/v4/framework/Furion/RescuePolicy">【源碼地址】</a><span>&nbsp;</span><a href="https://gitee.com/dotnetchina/Furion/commit/dfc63e7f0ffd2e03653f11a3e49a21646902ddc4">dfc63e7</a></li></ul></li><li><p style="margin-left:0; margin-right:0"><strong>突破性變化</strong></p><ul><li>[升級]<span>&nbsp;</span><strong>框架底層適配<span>&nbsp;</span><code>.NET8.0</code><span>&nbsp;</span>正式版</strong><span>&nbsp;</span>4.9.1<span>&nbsp;</span>⏱️2023.11.15</li><li>[升級]<span>&nbsp;</span><strong>框架腳手架適配<span>&nbsp;</span><code>.NET8.0</code><span>&nbsp;</span>正式版</strong><span>&nbsp;</span>4.9.1<span>&nbsp;</span>⏱️2023.11.15</li></ul></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 16:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266501/furion-4-9-1-released</guid>
            <link>https://www.oschina.net/news/266501/furion-4-9-1-released</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Milvus 上新！全新 Range Search 功能，可精準控制搜索結果]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Range Search 功能誕生於社區。</p><p>某天，一位做系統推薦的用戶在社區提出了需求，希望 Milvus 能提供一個新功能，可以返回向量距離在一定範圍之內的結果。而這不是個例，開發者在做相似性查詢時，經常需要對結果做二次過濾。</p><p>為了幫助用戶解決這一問題，Milvus 推出了全新功能—— Range Search（範圍搜索）。本文將帶各位詳解這一新功能，包括 Range Search 的基本介紹、使用場景及其背後的技術細節。</p><h2>01.什麼是 Range Search？</h2><p>顧名思義，Range Search 即範圍搜索。不同於 KNN Search 返回最相似的 TOP-K 個結果，Range Search 會返回向量距離落於某一區間的 TOP-K 個結果。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b4b328c7dc3151d09d501d9cc11ac3e0591.png" alt="" referrerpolicy="no-referrer"></p><p>那麼，何時選擇 Range Search 而非 Top-K 搜索？</p><p>Range Search 最典型的應用場景就是推薦系統。比如商品推薦，一個好的推薦系統，返回的應該是與用戶點擊的商品有一定相似度，但又不太相似的結果。太相似或太不相似的推薦都會導致推薦效果不盡如人意。</p><p>在有 Range Search 功能之前，做推薦系統的用戶只能先執行一次 KNN Search，再在 Milvus 系統之外對查詢結果進行二次過濾。如今，有了 Range Search 功能，他們可以直接調用 Range Search，一次性得到所需要的結果。</p><p>Range Search 新增了 2 個參數，分別是：</p><ul><li><p>radius（半徑） - 指相似性的外邊界</p></li><li><p>range_filter（範圍過濾器） - 指相似性的內邊界</p></li></ul><h2>02.Range Search 的技術實現細節</h2><p>接下來，我們深入 Range Search 功能的架構和算法，探討其優勢、侷限性以及 Range Search 與第三方算法庫集成。</p><p>Range Search 重用了現有的搜索流程，二者在上層所有數據通路幾乎完全是一樣的。以下是接收到搜索請求時所採取的步驟：</p><ul><li><p>SDK 接到一個用戶的查詢請求，在 search param 中包含了 radius 和 range_filter 信息；</p></li><li><p>proxy 在收到這個查詢請求後，生成一個 SearchTask 傳給 querynode；</p></li><li><p>querynode 在收到 SearchTask 後，通過 cgo 調用 segcore 的 Search 接口；</p></li><li><p>segcore 會解析 search_param 中帶的參數，如果有 radius，則調用 knowhere::RangeSearch；</p></li><li><p>knowhere 再根據索引類型調用到對應的第三方庫的 range_search 函數。</p></li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-312561d846ee7db2cdde2205ba34b589dd6.png" alt="" referrerpolicy="no-referrer"></p><p>目前，所有的第三方庫索引都只支持單邊 Range Search，也就是隻接收一個參數 radius，而且返回的結果是全量未排序的結果。下表概述了不同索引類型的 Range Search 策略「</p><p><img src="https://oscimg.oschina.net/oscnet/up-f9423ca4e4532ca21a092bf739084b2aa65.png" alt="" referrerpolicy="no-referrer"></p><p>對於 binary 類型的索引，HAMMING 和 JACCARD 全部都支持 Range Search，SUBSTRUCTURE/SUPERSTRUCTURE 由於返回值是 true/false，不滿足 Range Search 的語義，所以不支持 Range Search。其餘 float 類型索引，對於 L2/IP/COSINE 全部支持 Range Search。</p><p>下表是所有支持 Range Search 的索引類型和 metric type：</p><p><img src="https://oscimg.oschina.net/oscnet/up-4cd875d0cf7b27184d6fe91878755240514.png" alt="" referrerpolicy="no-referrer"></p><h2>03.Range Search 使用方法</h2><p>如需使用 Range Search，只需要修改搜索請求中的搜索參數。接下來我會講一下的詳細使用指南，在指南的最後還提供了 Python 示例代碼。</p><h3>開始前</h3><p>請確保已安裝並運行 Milvus。</p><p>請確保已創建 1 個 Collection，併為該 Collection 創建索引。</p><h3>Range Search 參數</h3><ul><li><p>radius：必要參數。決定搜索請求將執行 Range Search 還是 KNN Search。</p></li><li><p>range_filter：可選參數。如果設置該參數，函數將對結果進行二次過濾。</p></li></ul><p>通過上述兩個參數，我們可以根據不同應用場景和需求微調 Range Search 的行為。以下為示例代碼：</p><pre><code class="language-plaintext">default_index = {"index_type": "HNSW","metric_type": "L2","params": {"M":48,"efConstruction":500}
}
collection.create_index("float_vector", default_index)
search_params = {"metric_type": "L2","limit": TOPK,
                 "params": {"ef":32,"range_filter":1.0,"radius":2.0}
}
res = collection.search(vectors[:nq], "float_vector", search_params, limit)
</code></pre><h2>04.參數檢查</h2><p>下表列出了所有 metric type 對應的 radius 合法值範圍：</p><p><img src="https://oscimg.oschina.net/oscnet/up-3931e0822befd3dcc21a619d6051825e253.png" alt="" referrerpolicy="no-referrer"></p><p>由於不同 metric type 對應的 radius 合法值範圍不同，Milvus 不會檢查 radius 的合法性，而是隻檢查 radius 和 range_filter 的相對合法性：</p><ul><li><p>對於 L2/Hamming/Jaccard，range_filter &lt; radius</p></li><li><p>對於 IP/Cosine，range_filter &gt; radius</p></li></ul><h2>05.總結</h2><p>Milvus 的 Range Search 功能不僅限於推薦引擎，還可以廣泛應用在內容匹配、異常檢測和 NLP 搜索等任務中。通過利用 radius 和 range_filter 兩個參數，用戶可以精準定製查詢，滿足不同用例的需求。</p><p>Range Search 現已正式登陸 Zilliz Cloud Beta 版！如需體驗 Range Search 功能，請將 Zilliz Cloud（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzilliz.com.cn%2Fcloud%EF%BC%89" target="_blank">https://zilliz.com.cn/cloud）</a> 集羣升級至 Beta 版或下載 Milvus 2.3.x（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmilvus.io%2Fdocs%2Finstall_cluster-milvusoperator.md%EF%BC%89%E3%80%82%E5%8F%A6%E5%A4%96%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%A4%A7%E5%AE%B6%E5%9C%A8%E4%BD%BF%E7%94%A8" target="_blank">https://milvus.io/docs/install_cluster-milvusoperator.md）。另外，如果大家在使用</a> Range Search 功能中遇到任何問題或者建議，歡迎向我們反饋！</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 10:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4209276/blog/10143103</guid>
            <link>https://my.oschina.net/u/4209276/blog/10143103</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[2023 年收入最高的 10 種編程語言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在過去的一年時間裏（2022 年 10 月 1 日到 2023 年 10 月 1 日） ，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Fblog%2Ftop-10-highest-paid-programming-languages%2F" target="_blank">DevJobsScanner</a> 分析了來自世界各地的超過 1000 萬份開發工作機會，以瞭解市場以及最熱門、薪酬最高的編程語言。值得注意的是，本項研究只關注了來自美國的職位。在總共 1000 萬個開發工作崗位中，有 130 萬個有工資。在這 130 萬個職位中，有 23 萬個職位屬於編程語言類。在這 23 萬個職位中，約有 8.6 萬個職位來自美國。</p><h4><strong>10 - Java</strong></h4><p><img height="144" src="https://oscimg.oschina.net/oscnet/up-da0d9c70bef29cef379fa443218b09df6dd.png" width="300" referrerpolicy="no-referrer"></p><p>Java 位列第十。DevJobsScanner 指出，Java 的工作機會大多要求份非常豐富的經驗，Spring 等 Java 框架也是該行業的高薪職位。Java 開發人員的平均年薪約為 11.8 萬美元。</p><ul style="margin-left:0; margin-right:0"><li>平均工資：~$118k</li><li>薪資中位數：$117k</li><li>發現的工作數量（帶薪水）：23K 個</li></ul><p>查看具體的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-java-jobs%2F" target="_blank">&nbsp;Java 職位</a>。</p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><strong><span style="color:#000000">9-Python</span></strong></h4><p><img height="91" src="https://oscimg.oschina.net/oscnet/up-9bb3fb64562542db24cf36832f6b43d5966.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Python 是當今最流行的語言之一，也是排名第九的高薪職位。Python 是一種 non-typed 的高級語言。它擁有全方位的實用工具，從腳本和工具到使用 Django 框架編寫整個 Web 應用程序。該語言多被用於數據科學。</span></p><p><span style="color:#000000">調查結果顯示，雖然 Python 開發人員的平均工資為每年 12.5 萬美元，但有些薪資已經達到了每年 50 萬美元。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工資：~$125K</span></li><li><span style="color:#000000">薪資中位數：$120k</span></li><li><span style="color:#000000">發現的工作數量（帶薪水）：14K 個</span></li></ul><p>&nbsp;查看具體的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-java-jobs%2F" target="_blank">&nbsp;</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-python-jobs%2F" target="_blank">Python 職位</a>。</p><h4><strong>8 - Swift</strong></h4><p><img height="123" src="https://oscimg.oschina.net/oscnet/up-3a30ea9fb6d3c66be2a2ad231125f7a79ba.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Swift 是，蘋果公司開發的一種現代通用語言。它有多種用途，但最常見、流行的用途是開發 iOS 和 Mac 應用程序。Swift 開發人員的平均年薪為 12.7 萬美元。</span></p><ul style="margin-left:0; margin-right:0"><li>平均工資：~$127k</li><li>薪資中位數：$125k</li><li><span style="color:#000000">發現的工作數量（帶薪水）</span>：174 個</li></ul><p>查看具體的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-swift-jobs%2F" target="_blank">Swift 職位</a>。</p><h4><strong>7 - Go</strong></h4><p><img height="120" src="https://oscimg.oschina.net/oscnet/up-963f146d826e179eefe3c93c441a54055da.png" width="300" referrerpolicy="no-referrer"></p><p>Go 語言由&nbsp;Google 團隊成員於 2007 年推出，一直廣受歡迎。它簡單、易用，能快速完成任務。Go 深受 C 語言的影響，但在內存安全、垃圾收集和結構類型方面也有重大改進。</p><ul style="margin-left:0; margin-right:0"><li>平均工資：~$130k</li><li>薪資中位數：$128k</li><li><span style="color:#000000">發現的工作數量（帶薪水）</span>：1.2K 個</li></ul><p>查看具體的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-go-jobs%2F" target="_blank">Go 職位</a>。</p><h4><strong>6 - Ruby</strong></h4><p><img height="128" src="https://oscimg.oschina.net/oscnet/up-21b412b86bcb795c62b42a25bdd199348fd.png" width="300" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">Ruby 語言已經流行多年並且現在仍然很流行。調查顯示，Ruby 需求相當高，而且大部分都是高薪。</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">Ruby 主要流行於 Web 開發，與著名的 Ruby on Rails 框架結合使用。它也有一些其他的實用工具，從腳本和原型設計到遊戲開發（使用 DragonRuby）。DevJobsScanner 認為，鑑於&nbsp;Ruby 的多樣性，學習該語言永遠不會是一個糟糕的選擇；它也是一種高級語言，可以快速開發應用程序（類似於 Python）。</span></p><blockquote><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">Ruby 開發人員的工資中位數（13.6 萬美元）超過了平均工資（13.2 萬美元）。這表明對中級和高級 Ruby 專業人員的強勁需求，説明掌握 Ruby 方面的專業知識往往能帶來高於平均水平的薪酬。</span></p></blockquote><ul style="margin-left:0; margin-right:0"><li>平均工資：~$132k</li><li>薪資中位數：$136k</li><li>找到的工作數量（帶薪水）：3.4K 個</li></ul><p>&nbsp;查看具體的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-ruby-jobs%2F" target="_blank">Ruby 職位</a>。</p><h4><strong>5 - Scala</strong></h4><p><img height="146" src="https://oscimg.oschina.net/oscnet/up-551dddb9d865060c07593f99b8a5b10d1e9.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">排在前五位的是 Scala。Scala 是一種結合了面向對象和函數式編程的高級語言。它可以編譯成 Java 字節碼，並在 Java 虛擬機（JVM）上運行。它的設計初衷是為瞭解決 Java 所面臨的一些"缺陷"和批評。它擁有一個強大的愛好者社區，以及良好的周邊庫，可以輕鬆上手。</span></p><p><span style="color:#000000">雖然 Scala 開發人員的平均年薪為 13.5 萬美元，但有些職位的年薪最高可達約 40 萬美元。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工資：~$135k</span></li><li><span style="color:#000000">薪資中位數：$130k</span></li><li><span style="color:#000000">找到的工作數量（帶薪水）： 533 個</span></li></ul><p>查看具體的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-scala-jobs%2F" target="_blank">Scala 職位</a>。</p><h4><strong>4 - C/C++</strong></h4><p><img height="179" src="https://oscimg.oschina.net/oscnet/up-6e86e1cf5b0d7679b684b0158bb78cd21ed.png" width="200" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">C/C++ 穩居前 4 位，平均年薪約為 13.6 萬美元。 C++ 在行業中的應用非常廣泛，視頻遊戲、服務器、數據庫、空間探測器等許多領域都可以找到 C++ 的身影。區塊鏈生態系統中也大量使用 C++，比特幣或 Solidity 智能合約語言均完全由 C++ 編寫。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工資：~$136K</span></li><li><span style="color:#000000">薪資中位數：$125k</span></li><li><span style="color:#000000">找到的工作數量（帶薪水）：3K 個</span></li></ul><p><span style="color:#000000">&nbsp;查看具體的</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-c%2B%2B-jobs%2F" target="_blank">&nbsp;C/C++ 職位</a>。</p><h4><strong>3-ABAP</strong></h4><p><img height="124" src="https://oscimg.oschina.net/oscnet/up-c183b86954e313b623cd8417d793c87f6ba.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">ABAP 是 2023 年企業資源規劃 (ERP) 生態系統中最有價值的語言之一。ABAP 是 SAP 創建的一種高級編程語言，用於在 SAP 平台上開發應用程序。自 20 世紀 80 年代以來，它一直是 SAP 應用程序的支柱，允許自定義開發和修改 SAP 應用程序。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工資：~$137k</span></li><li><span style="color:#000000">薪資中位數：$134k</span></li><li><span style="color:#000000">找到的工作數量（帶薪水）：134 個</span></li></ul><p>查看具體的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-abap-jobs%2F" target="_blank">ABAP 職位</a>。</p><h4><strong>2 - Rust</strong></h4><p><img height="141" src="https://oscimg.oschina.net/oscnet/up-d07474ac36e203ae14401437617eca9135b.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Rust 平均薪資約為 15.6 萬美元，且該語言的薪資和受歡迎程度都在持續上升。Rust&nbsp;與 C++ 類似，但具有內存安全或安全併發等更高級的功能，使其成為高性能大型應用程序的完美選擇。該語言最近在 web3/區塊鏈領域頗受歡迎，例如 Solana 合約不是用 Solidity 製作的，而是採用的 Rust。</span></p><p><span style="color:#000000">雖然 Rust 開發人員的平均年薪為 15.6 萬美元，但有些職位的年薪達到了 50 萬美元。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工資：~$156k</span></li><li><span style="color:#000000">薪資中位數：$150k</span></li><li><span style="color:#000000">找到的工作數量（帶薪水）：197 個</span></li></ul><p><span style="color:#000000">查看具體的&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-rust-jobs%2F" target="_blank">Rust 職位</a>。</p><h4><span style="color:#000000"><strong>1 - Solidity</strong></span></h4><p><img height="109" src="https://oscimg.oschina.net/oscnet/up-49425fe9eab67498220eef604ab1e04f8fe.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">位居 2023 年薪資排行榜首的是 Solidity，平均薪資為 18.8 萬美元。這門以太坊背後的前團隊發明的語言最近受到了廣泛關注。相關職位的求職者人數少，從而使得薪酬直線上升。Solidity 是一種高級面向對象編程語言。它用於編寫當今大多數區塊鏈中運行的智能合約背後的邏輯。</span></p><p>&nbsp;</p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工資：~$188k</span></li><li><span style="color:#000000">薪資中位數：1$180k</span></li><li><span style="color:#000000">找到的工作數量（帶薪水）：136 個</span></li></ul><p><span style="color:#000000">查看具體的&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-solidity-jobs%2F" target="_blank">Solidity 職位</a><span style="color:#000000">。</span></p><hr><p><strong>完整列表</strong></p><p><img height="657" src="https://oscimg.oschina.net/oscnet/up-9139be9626b0c984bca34d0c24578038302.png" width="500" referrerpolicy="no-referrer"></p><p><strong>薪資分佈圖</strong></p><p><img height="820" src="https://oscimg.oschina.net/oscnet/up-844c88902e330224b38a8a0448482adf31d.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Fblog%2Ftop-10-highest-paid-programming-languages%2F" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 08:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266426/top-10-highest-paid-programming-languages</guid>
            <link>https://www.oschina.net/news/266426/top-10-highest-paid-programming-languages</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[國內最大、性能媲美 GPT 3.5，元象開源 650 億參數高性能大模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#1f2328; text-align:start"><strong>XVERSE-65B</strong><span>&nbsp;</span>是由深圳元象科技自主研發的支持多語言的大語言模型（Large Language Model），參數規模為 650 億，本次開源的模型為底座模型<span>&nbsp;</span><strong>XVERSE-65B</strong>，主要特點如下：</p><ul><li><strong>模型結構</strong>：XVERSE-65B 使用主流 Decoder-only 的標準 Transformer 網絡結構，支持 16K 的上下文長度（Context Length），能滿足更長的多輪對話、知識問答與摘要等需求，模型應用場景更廣泛。</li><li><strong>訓練數據</strong>：構建了 2.6 萬億 token 的高質量、多樣化的數據對模型進行充分訓練，包含中、英、俄、西等 40 多種語言，通過精細化設置不同類型數據的採樣比例，使得中英兩種語言表現優異，也能兼顧其他語言效果。</li><li><strong>分詞</strong>：基於 BPE（Byte-Pair Encoding）算法，使用上百 GB 語料訓練了一個詞表大小為 100,534 的分詞器，能夠同時支持多語言，而無需額外擴展詞表。</li><li><strong>訓練框架</strong>：訓練中採用 FlashAttention2 加速計算，3D 並行基礎上採用虛擬流水線（virtual pipeline）技術，降低較長流水線和 16k 上下文窗口產生的過高氣泡率，在千卡集羣的峯值算力利用率達到業界前列。同時通過集羣基礎設施運營、資源調度、訓練框架和調度平台協同等持續優化，打造出高穩定、低中斷、強容錯的訓練系統，將每週有效訓練率提升至 98.6%。</li></ul><h4 style="margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000"><strong>評測結果</strong></span></h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000"><img height="454" src="https://oscimg.oschina.net/oscnet/up-2cd1eb2bb0579c1ae7d9b7cdba455e38df6.png" width="500" referrerpolicy="no-referrer">&nbsp;</span></p><h4 style="text-align:start"><strong>硬件需求</strong></h4><p style="color:#1f2328; text-align:start">下表列出了在 XVERSE-65B 上進行推理和微調所需要的硬件資源：</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#1f2328; display:block; font-family:-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Noto Sans&quot;,Helvetica,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; max-width:100%; orphans:2; overflow:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:max-content; word-spacing:0px"><thead><tr><th>&nbsp;</th><th>類型</th><th>方法</th><th>內存</th><th>GPU</th></tr></thead><tbody><tr><td style="border-style:solid; border-width:1px">XVERSE-65B</td><td style="border-style:solid; border-width:1px">訓練</td><td style="border-style:solid; border-width:1px">LoRA with ZeRO-3</td><td style="border-style:solid; border-width:1px">1500GB</td><td style="border-style:solid; border-width:1px">8*A800 80G</td></tr><tr><td style="border-style:solid; border-width:1px">XVERSE-65B</td><td style="border-style:solid; border-width:1px">推理</td><td style="border-style:solid; border-width:1px">BF16/FP16</td><td style="border-style:solid; border-width:1px">500GB</td><td style="border-style:solid; border-width:1px">2*A800 80G</td></tr></tbody></table></div>
                                                                ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 08:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/xverse-65b</guid>
            <link>https://www.oschina.net/p/xverse-65b</link>
        </item>
        <item>
            <title>
                <![CDATA[從 JDK 11 升級到 JDK 17 的最全實踐乾貨]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h1><strong>1、前言</strong></h1><p>上篇文章給大家帶來了<a href="https://my.oschina.net/u/4090830/blog/10111749">JDK8 升級 JDK11 的最全實踐，</a>相信大家閲讀後已經對 JDK11 有了比較深入的瞭解。2021 年 9 月 14 日，Oracle 發佈了可以長期支持的 JDK17 版本，那麼從 JDK11 到 JDK17，到底帶來了哪些特性呢？亞毫秒級的 ZGC 效果到底怎麼樣呢？值得我們升級嗎？而且升級過程會遇到哪些問題呢？帶着這些問題，本篇文章將帶來完整的 JDK11 升級 JDK17 最全實踐。</p><h1><strong>2、為什麼升級 JDK17</strong></h1><p><strong>1）長期支持版本</strong></p><p>JDK17 是 Oracle 官方在 2021 年 9 月 14 日發佈的一個長期支持（LTS）版本，意味着它將獲得長期的更新和支持，有助於保持程序的穩定性和可靠性。</p><p><strong>2）性能提升</strong></p><p>更好的垃圾回收器。綜合評估，從 Java 8 升級到 Java 11，**G1GC 平均速度提升 16.1%，ParallelGC 為 4.5%****，**從 Java 11 升級到 Java 17，<strong>G1GC 平均速度提升 8.66%，ParallelGC 為 6.54%</strong>（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.optaplanner.org%2Fblog%2F2021%2F09%2F15%2FHowMuchFasterIsJava17.html" target="_blank">基於 OptaPlanner 的用例基準測試表明）</a></p><p>最大的亮點是帶來了<strong>穩定版的 ZGC 垃圾回收器，達到亞毫秒級停頓。</strong></p><p><strong>3）新語法和特性</strong></p><p>Switch 表達式簡化、Text Blocks 文本塊、instanceof 的模式匹配升級和 NullPointerException 提示信息改進等</p><p>4）<strong>支持最新的技術和框架</strong></p><p>Spring framework6 和 Spring Boot3 都默認使用 Java 17 作為最低版本</p><h1><strong>3、升級後壓測效果</strong></h1><blockquote><p><strong>先給出結論：</strong></p><p>1、JDK17 相對於 JDK8 和 JDK11，<strong>所有垃圾回收器的性能都有很明顯的提升，特別是穩定版的 ZGC 垃圾回收器</strong></p><p>2、<strong>不論任何機器配置下，都推薦使用 ZGC</strong>，ZGC 的停頓時間達到亞毫秒級，吞吐量也比較高</p></blockquote><p><strong>我在 JDOS 平台上選擇了不同配置的機器（2C4G、4C8G、8C16G），並分別使用 JDK8、JDK11 和 JDK17 進行部署和壓測。</strong></p><p>整個壓測過程限時 60 分鐘，用 180 個虛擬用戶併發請求一個接口，每次接口請求都創建 512Kb 的數據。最終產出不同 GC 回收器的各項指標數據，來分析 GC 的性能提升效果。</p><p><strong>以下是壓測的性能情況：</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-07-18-46yVgvcZ9YUGOrY9x.png" alt="" referrerpolicy="no-referrer"></p><h1><strong>4、OracleJDK 和 OpenJDK 的選擇</strong></h1><p>2021 年 9 月，Oracle 宣佈 JDK17 可以免費商用，直到下一個 LTS 版本之後繼續提供整整一年，同時 Oracle 將繼續按照自 Java 9 以來的相同版本和時間表提供 GPL 下的 Oracle OpenJDK 版本。</p><p>2023 年 9 月，OracleJDK 發佈了新的 LTS 版本 JDK21，這就意味着從<strong>2024 年 9 月開始，在生產環境使用 OracleJDK17 將需要付費。</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-01-20-01PLCD1wvvcxLRLNv.png" alt="" referrerpolicy="no-referrer"></p><p>參考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.oracle.com%2Fhk%2Fjava%2Ftechnologies%2Fdownloads%2F%23java17" target="_blank">https://www.oracle.com/hk/java/technologies/downloads/#java17</a></p><p>OracleJDK 和 OpenJDK 這兩個之間沒有真正的技術差別，因為針對 Oracle JDK 構建過程是基於 OpenJDK 的。自從 JDK11 開始，OracleJDK 和 OpenJDK 在功能上基本相同，所以推薦使用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjdk.java.net%2Farchive%2F" target="_blank">OpenJDK17</a> 或其他開源的 JDK 版本，這些開源版本都是基於 OpenJDK 構建並提供長期支持的,比如：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fadoptopenjdk.net%2F" target="_blank">AdoptOpenJDK</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevelopers.redhat.com%2Fproducts%2Fopenjdk%2Foverview" target="_blank">RedHatOpenJDK。</a></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-02-11-19DsSkxKErEDeigz2.png" alt="" referrerpolicy="no-referrer"></p><p>官方參考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.oracle.com%2Fjava%2Fpost%2Foracle-jdk-releases-for-java-11-and-later" target="_blank">https://blogs.oracle.com/java/post/oracle-jdk-releases-for-java-11-and-later</a></p><h1><strong>5、JDK11 到 JDK17 帶來了哪些新特性</strong></h1><h3><strong>5.1、JVM 改進</strong></h3><p>1、ZGC 垃圾回收器從實驗性功能更改為<strong>正式產品功能</strong>，從 JDK11 引入以來，經過持續的迭代升級，目前已經足夠穩定。<strong>需要手動開啓，開啓方式：-XX:+UseZGC</strong></p><p>2、G1 垃圾回收器仍然作為默認垃圾回收器，進行改進升級，主要包括可中止的混合收集集合、NUMA 可識別內存分配等</p><p>3、JDK14 開始刪除 CMS 垃圾回收器</p><p>4、JDK14 開始棄用 ParallelScavenge 和 SerialOld GC 的組合使用</p><p>5、JDK15 禁用偏向鎖，默認禁用：-XX:+UseBiasedLocking</p><p>6、NullPointerException 提示信息改進</p><p>JDK14 以前的出現 NullPointerException 時，只能定位到所在異常行，無法定位具體是哪個變量。改進後的 NullPointerException，可以清晰描述具體變量，提升了空指針異常的可讀性。</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-27-10-50TTuaDvegXKr9SAo.png" alt="" referrerpolicy="no-referrer"></p><h3><strong>5.2、新語法特性</strong></h3><h4><strong>5.2.1、Switch 表達式簡化</strong></h4><p>switch 表達式帶來了簡化式的編碼方式，提供了新的分支切換方式，即 -&gt; 符號，右則表達式方法體在執行完分支方法之後，自動結束 switch 分支，同時 -&gt; 右則方法塊中可以是表達式、代碼塊或者是手動拋出的異常</p><p>參考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F361" target="_blank">https://openjdk.org/jeps/361</a></p><p><strong>傳統寫法</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-17-22rnaBICUHwCBlYZf.png" alt="" referrerpolicy="no-referrer"></p><p><strong>新寫法</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-10-18Z48ZmbyE6jT10uWqP.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.2、Text Blocks 文本塊</strong></h4><p>參考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F378" target="_blank">https://openjdk.org/jeps/378</a></p><p>通過編寫 """，來減少轉義字符和換行符，達到簡化代碼和提高代碼可讀性的目的</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-18-16tXnkRnYOGkQhTMS.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.3、Record 類型</strong></h4><p>參考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F395" target="_blank">https://openjdk.org/jeps/395</a></p><p>record 是 JDK 14 引入的關鍵字，用於聲明不可變的數據類。它適用於存儲純粹的值類型數據，如接口傳輸數據、座標點和只讀的日誌記錄。與 lombok 相比，record 簡化了定義純粹數據類型的過程。由於 record 類是不可變的，成員變量只能設置一次且無法更改，無需提供顯式的 setter() 方法。</p><p><strong>1、定義 Point 類，使用關鍵字 record，未定義 get/set</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-25-19-50LjIj50MDXubzNv07.png" alt="" referrerpolicy="no-referrer"></p><p><strong>2、查看編譯後的字節碼文件</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-12-05MfRyF9o9FOD120oS.png" alt="" referrerpolicy="no-referrer"></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-12-077FA41CoAIm41MkgIY.png" alt="" referrerpolicy="no-referrer"></p><p><strong>3、使用 Point 類</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-12-11LdZCsODuD8JpjE0.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.4、instanceof 的模式匹配升級</strong></h4><ul><li>instanceof 類型判斷再也不需要強制轉換</li></ul><p>參考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F394" target="_blank">https://openjdk.org/jeps/394</a></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-25-18-20mhLGcH20q20N25D0a.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.5、密封的類和接口</strong></h4><p>參考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F409" target="_blank">https://openjdk.org/jeps/409</a></p><p>JDK15 開始，引入了 sealed 普通類或接口類，這些類只允許被指定的類或者 interface 進行擴展和實現。</p><p>使用修飾符 sealed，您可以將一個類聲明為密封類。密封的類使用關鍵字 permits 列出可以直接擴展它的類。子類可以是最終的，非密封的或密封的</p><p>比較實用的一個特性，可以用來限制類的層次結構</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-19-23EeeAvjyEjufkdfY.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.6、其他優化和升級</strong></h4><p>感興趣的同學，推薦閲讀 OpenJDK 官方文檔説明，從 JDK11 到 JDK17 的改動： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fprojects%2Fjdk%2F17%2Fjeps-since-jdk-11" target="_blank">https://openjdk.org/projects/jdk/17/jeps-since-jdk-11</a></p><h1><strong>6、升級步驟</strong></h1><h3><strong>6.1、JDK 選擇</strong></h3><p>OpenJDK17 下載：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjdk.java.net%2Farchive%2F" target="_blank">https://jdk.java.net/archive/</a></p><p>行雲鏡像：jdt-base-tomcat/java-jdt-centos7.4-openjdk-17.0.2-tomcat8.0.53</p><h3><strong>6.2、pom 編譯配置升級</strong></h3><p>maven 編譯所需 JDK 升級至 17</p><pre><code>&lt;properties&gt;
    &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
&lt;/properties&gt;

</code></pre><h3><strong>6.3、SpringBoot 升級</strong></h3><p>SpringBoot 版本升級到<strong>2.7.15</strong>，Spring 版本升級為<strong>5.3.29</strong></p><p><strong>為什麼不升級到 SpringBoot3？</strong></p><p>Spring Boot 3.0 最低要求 Java 17，SpringBoot3.0 帶來了很多變化，和 SpringBoot2 差異較大。 考慮到公司很多中間件都是基於 SpringBoot2 構建的，所以此處推薦升級到 SpringBoot2 的最高版本 2.7.15。</p><p><strong>POM 升級</strong></p><pre><code>&lt;parent&gt;
 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
 &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
 &lt;version&gt;2.7.15&lt;/version&gt;
&lt;/parent&gt;

</code></pre><p>也可以通過設置 dependencyManagement 的方式：</p><pre><code>&lt;properties&gt;
    &lt;!-- 框架版本配置--&gt;
    &lt;springboot-version&gt;2.7.15&lt;/springboot-version&gt;
    &lt;springframework.version&gt;5.3.29&lt;/springframework.version&gt;
&lt;/properties&gt;  

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
            &lt;version&gt;${springboot-version}&lt;/version&gt;
            &lt;scope&gt;import&lt;/scope&gt;
            &lt;type&gt;pom&lt;/type&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;
            &lt;version&gt;${springframework.version}&lt;/version&gt;
            &lt;scope&gt;import&lt;/scope&gt;
            &lt;type&gt;pom&lt;/type&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

</code></pre><p>參考：</p><p>spring 升級指南： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-framework%2Fwiki%2FSpring-Framework-Versions" target="_blank">https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions</a></p><p>springboot 版本官網： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspring.io%2Fprojects%2Fspring-boot%23learn" target="_blank">https://spring.io/projects/spring-boot#learn</a></p><p><strong>循環依賴問題</strong></p><p>SpringBoot 升級到 2.7.15 後，如果應用中存在循環依賴的問題，啓動時會報如下錯誤：</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-22-10-48Z10IRCapBcpKAVDi.png" alt="" referrerpolicy="no-referrer"></p><p><strong>原因</strong>：官方文檔不鼓勵循環依賴引用，默認情況下是禁止的</p><p><strong>解決方案：</strong></p><p>第一種：推薦更新應用中 bean 的依賴關係來解決</p><p>第二種：配置文件中加入以下配置，<strong>為了和舊版本保持一致，此配置推薦添加</strong></p><pre><code>#放開循環依賴
spring.main.allow-circular-references=true

</code></pre><h3><strong>6.4、常用中間件升級</strong></h3><h4><strong>6.4.1、Lombok 版本升級到 1.18.20 以上</strong></h4><pre><code>&lt;dependency&gt;
 &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
 &lt;artifactId&gt;lombok&lt;/artifactId&gt;
 &lt;version&gt;1.18.20&lt;/version&gt;
&lt;/dependency&gt;

</code></pre><p>如果不升級，編譯時會報錯如下：</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-13-20-01itBREuaDZdAzrpZ.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>6.4.2、swgger 問題，springfox3.0.0 和 springboot2.7 版本不兼容</strong></h4><p><strong>異常：</strong></p><pre><code>Failed to start bean 'documentationPluginsBootstrapper'; nested exception is java.lang.NullPointerException: 
Cannot invoke "org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.getPatterns()" because "this.condition" is null

</code></pre><p><strong>解決方案：</strong></p><pre><code>/**
 * 增加如下配置可解決 Spring Boot 2.7.15 與 Swagger 3.0.0 不兼容問題
 **/
@Bean
public BeanPostProcessor springfoxHandlerProviderBeanPostProcessor() {
return new BeanPostProcessor() {

@Override
 public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
if (bean instanceof WebMvcRequestHandlerProvider || bean instanceof WebFluxRequestHandlerProvider) {
                customizeSpringfoxHandlerMappings(getHandlerMappings(bean));
            }
return bean;
}

private &lt;T extends RequestMappingInfoHandlerMapping&gt; void customizeSpringfoxHandlerMappings(List&lt;T&gt; mappings) {
            List&lt;T&gt; copy = mappings.stream().filter(mapping -&gt; mapping.getPatternParser() == null).collect(Collectors.toList());
            mappings.clear();
            mappings.addAll(copy);
        }

@SuppressWarnings("unchecked")
private List&lt;RequestMappingInfoHandlerMapping&gt; getHandlerMappings(Object bean) {
try {
                Field field = ReflectionUtils.findField(bean.getClass(), "handlerMappings");
                field.setAccessible(true);
return (List&lt;RequestMappingInfoHandlerMapping&gt;) field.get(bean);
            } catch (IllegalArgumentException | IllegalAccessException e) {
throw new IllegalStateException(e);
            }
        }
    };
}

</code></pre><p>參考：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F950787" target="_blank">https://developer.aliyun.com/article/950787</a></p><h4><strong>6.4.3、AKS 升級（針對直接從 JDK8 升級的情況）</strong></h4><p><strong>異常</strong>：Causedby: java.lang.NoClassDefFoundError: javax/xml/bind/JAXBException</p><p><strong>原因</strong>：Java11 刪除了 Java EE modules，其中就包括 java.xml.bind (JAXB)。</p><p><strong>解決方案：</strong></p><p>手動引入如下包即可</p><pre><code>&lt;!-- API, java.xml.bind module --&gt; 
&lt;dependency&gt;
      &lt;groupId&gt;jakarta.xml.bind&lt;/groupId&gt;
      &lt;artifactId&gt;jakarta.xml.bind-api&lt;/artifactId&gt;
      &lt;version&gt;2.3.2&lt;/version&gt;
&lt;/dependency&gt; 
&lt;!-- Runtime, com.sun.xml.bind module --&gt;
&lt;dependency&gt;
       &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
       &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
       &lt;version&gt;2.3.2&lt;/version&gt;
&lt;/dependency&gt;

</code></pre><h4><strong>6.4.4、Concrete 配置中心阻塞升級</strong></h4><p>使用 Concrete 時，啓動時異常：</p><pre><code> Unable to make field private static final java.lang.reflect.Method jdk.proxy2.$Proxy97.m0 accessible: 
 module jdk.proxy2 does not "opens jdk.proxy2" to unnamed module @61d47554

</code></pre><p><strong>原因：</strong></p><p>分析下 Concrete 報錯的原因，如下圖，包內 com.wangyin.concrete.spring.ConcreteConfigProcessor#postProcessAfterInitialization（212 行）的實現邏輯</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-14-00LgxgUIrSYEUTxjm.png" alt="" referrerpolicy="no-referrer"></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-13-44BFAP7OjBiZqyaDb.png" alt="" referrerpolicy="no-referrer"></p><p><strong>解決方案：</strong></p><p>1、在 JVM 啓動參數中設置--add-opens jdk.proxy2 來開啓私有字段的訪問，但因為動態代理生成的包名是隨機不明確的，<strong>所以這種方案不可行</strong>。JDK 官方文檔也明確表示不支持訪問動態代理內部的隨機字段。官方説明：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcr.openjdk.org%2F%7Emr%2Fjigsaw%2Fspec%2Fapi%2Fjava%2Flang%2Freflect%2FProxy.html" target="_blank">https://cr.openjdk.org/~mr/jigsaw/spec/api/java/lang/reflect/Proxy.html</a></p><p>2、代碼修改，只需把 f.setAccessible(true) 移到 Modifier.isStatic(f.getModifiers()) 的判斷下方即可。原因是方法 Modifier.isStatic(f.getModifiers()) 本來就要跳過靜態字段，這樣修改直接避免了訪問。<strong>推動 concrete 團隊修復問題或更換使用 Ducc 配置中心</strong></p><h3><strong>6.5、JVM 啓動參數配置</strong></h3><h4><strong>6.5.1、開啓 ZGC</strong></h4><p><strong>啓動參數中配置：</strong>-XX:+UseZGC</p><p>移除-XX:ConcGCThreads，行雲部署下 JVM 參數配置需要清除</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-17-15-14Lyy3vSkGQSvlvGe.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>6.5.2、不同中間件所需啓動參數</strong></h4><p>升級 JDK17 後，項目啓動時可能會遇到如下兩種類型的異常：</p><p>1、cannot access class sun.util.calendar.ZoneInfo (in module java.base) because <strong>module java.base</strong> does not <strong>export sun.util.calendar</strong> to unnamed module @0x2611f533</p><p>2、Unable to make field final int java.math.BigInteger.signum accessible: <strong>module java.base</strong> does not "<strong>opens java.math</strong>" to unnamed module @525f1e4e</p><p><strong>異常原因：</strong></p><p>自從 JDK9 中引入了模塊化功能後，再到 JDK17，對於包掃描和反射的權限控制更加的嚴格。常見的庫比如（Spring）大量用到包掃描和反射，所以常出現此錯誤。</p><p><strong>解決方案：</strong></p><p>一個粗暴的解決辦法是將沒開放的 module 強制對外開放，即保持和 Java9 之前的版本一致。</p><ul><li>--add-exports 導出包，意味着其中的所有公共類型和成員都可以在編譯和運行時訪問。</li><li>--add-opens 打開包，意味着其中的所有類型和成員（不僅是公共類型）都可以在運行時訪問。</li></ul><p>主要區別在於<code>--add-opens</code>允許「深度反射」，即非公共成員的訪問，才可以調用<code>setAccessible(true)</code></p><p>參考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F44056405%2Fwhats-the-difference-between-add-exports-and-add-opens-in-java-9" target="_blank">https://stackoverflow.com/questions/44056405/whats-the-difference-between-add-exports-and-add-opens-in-java-9</a></p><p><strong>SGM 需要加入：</strong></p><pre><code>--add-opens java.management/java.lang.management=ALL-UNNAMED 
--add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED 
--add-opens java.management/sun.management=ALL-UNNAMED

</code></pre><p><strong>R2M 需要加入：</strong></p><pre><code>--add-opens java.base/java.time=ALL-UNNAMED

</code></pre><p><strong>Ducc 需要加入：</strong></p><pre><code>--add-opens java.base/java.util.concurrent=ALL-UNNAMED
--add-opens java.base/java.util.concurrent.locks=ALL-UNNAMED
--add-opens java.base/java.security=ALL-UNNAMED
--add-opens java.base/jdk.internal.loader=ALL-UNNAMED
--add-opens java.management/com.sun.jmx.mbeanserver=ALL-UNNAMED 
--add-opens java.base/java.net=ALL-UNNAMED 
--add-opens java.base/sun.nio.ch=ALL-UNNAMED 

</code></pre><p><strong>AKS 需要加入：</strong></p><pre><code>--add-exports java.base/sun.security.action=ALL-UNNAMED
--add-opens java.base/java.lang=ALL-UNNAMED
--add-opens java.base/java.math=ALL-UNNAMED
--add-opens java.base/java.util=ALL-UNNAMED
--add-opens java.base/sun.util.calendar=ALL-UNNAMED

</code></pre><h3><strong>6.6、啓動後的驗證</strong></h3><p>1.推薦先升級 JDK11，再到 JDK17，一邊升級一邊進行驗證觀察</p><p>2.觀察日誌是否有異常，特別是上面説到的啓動時異常</p><p>3.觀察監控類軟件，比如 SGM、UMP 等監控是否正常</p><p>4.推薦逐步有序切量，並做好常態化壓測，防止影響核心業務</p><p>5.升級完成後，<strong>最好能做個全流程的功能測試，防止功能異常</strong></p><h1><strong>7、總結</strong></h1><blockquote><p>1、升級後，除了可以使用新的語法特性，最大的亮點是可以使用亞毫秒級停頓的 GC 性能（至少百倍的 GC 性能提升），所以 <strong>強烈建議升級到 JDK17</strong></p><p>2、整個升級過程並不複雜，主要涉及到中間件版本的升級和啓動參數的配置</p></blockquote><p>如果還停留在 JDK8，推薦先升級 JDK11，再到 JDK17，具體升級步驟先參考我的上篇文章「<a href="https://my.oschina.net/u/4090830/blog/10111749">JDK8 升級 JDK11 最全實踐乾貨來了</a>」，再參考本章中的升級步驟。</p><p>希望以上分享可以給大家帶來實際的幫助，升級過程中如果遇到問題，歡迎大家在評論區回覆。</p><blockquote><p>作者：京東科技，曲振富</p><p>來源：京東雲開發者社區，轉載請註明來源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 07:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10142895</guid>
            <link>https://my.oschina.net/u/4090830/blog/10142895</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[AlmaLinux 9.3 正式發佈，CentOS 最佳替代方案之一]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>AlmaLinux 9.3 <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Falmalinux.org%2Fblog%2F2023-11-13-announcing-93-stable%2F" target="_blank">已正式發佈</a></u>，代號「Shamrock Pampas Cat」。目前提供的 ISO 鏡像文件支持如下 4 種架構：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmirrors.almalinux.org%2Fisos%2Fx86_64%2F9.3.html" target="_blank">Intel/AMD (x86_64)</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmirrors.almalinux.org%2Fisos%2Faarch64%2F9.3.html" target="_blank">ARM64 (aarch64)</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmirrors.almalinux.org%2Fisos%2Fppc64le%2F9.3.html" target="_blank">IBM PowerPC (ppc64le)</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmirrors.almalinux.org%2Fisos%2Fs390x%2F9.3.html" target="_blank">IBM Z (s390x)</a></li></ul><blockquote><p>AlmaLinux 是開放源碼的、社區驅動的項目，它從紅帽企業版 Linux (RHEL) 的源碼編譯而來。AlmaLinux 跟 RHEL 8 完全在二進制上兼容，它由 CloudLinux OS 的創建者打造。AlmaLinux 團隊承諾永久免費提供 AlmaLinux 操作系統，項目永久開源且不採取任何限制，不收取任何費用，支持至 2029 年。</p><p>2020 年 Red Hat 決定停止將 CentOS Linux 作為獨立發行版，改為推出滾動更新發行版 CentOS Stream，把它作為企業發行版 RHEL 的上游 beta 版本。社區立即推出了多個項目替代 CentOS，其中最為突出的是兩個項目：Rocky Enterprise Software Foundation 贊助的 Rocky Linux；另一個是 AlmaLinux OS Foundation 的 AlmaLinux。</p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-990d29cc9bd5b9f0f68183ea6d2b6c47315.png" referrerpolicy="no-referrer"></p><p>公告寫道，AlmaLinux 9.3&nbsp;旨在提高靈活性和可靠性，並增強混合環境中的安全性。該版本繼續對自動化和系統管理進行簡化。Web 控制枱增強功能簡化了管理任務。此外，用戶可以配置運行狀況，以檢查虛擬機中 Podman 容器和 vsock 設備的操作。Application Streams 更新為開發人員提供了靈活性和自定義選項，而不會影響平台的穩定性。</p><p>此版本引入了針對容器和虛擬機的新安全特性和運行狀況檢查選項。此外還提供了支持混合雲創新所需的靈活性、穩定性和可靠性。</p><p>工具鏈也進行了更新，包括使用 GCC 11.4.1 作為默認系統編譯器，以及 GCC 13，LLVM 16.0.6，Rust 1.71.1，Go 1.20.10，Keylime 7.3.0，Node.js20，Redis 7，Apache 2.4.57，Grafana 9.2.10，PCP 6.0.5，Valgrind 3.21，SystemTap 4.9，elfutils 0.189，OpenSCAP 1.3.8，SEtools 4.4.3 和 pcsc-lite-ccid 1.5.2。</p><p>安全方面，AlmaLinux OS 9.3 改進了對 FIPS-140-3 標準要求的所有 TLS 1.2 連接所需的擴展主密鑰 （EMS） 擴展 （RFC 7627） 的支持，並將 SCAP 安全指南更新到 0.1.69 版本，其中帶來了三個符合 CCN-STIC-610A22 指南和 ANSSI 配置文件 2.0 的新 SCAP 配置文件。</p><hr><p>延伸閲讀</p><ul><li><a href="https://www.oschina.net/news/262448/almalinux-stays-rhel-compatible">AlmaLinux 不使用「紅帽代碼」，如何保持兼容 RHEL</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 06:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266400/almalinux-9-3-stable</guid>
            <link>https://www.oschina.net/news/266400/almalinux-9-3-stable</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[開源模型 Zephyr-7B🪁發佈 —— 跨越三大洲的合作]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p><span style="background-color:#ffffff; color:#333333">最近我們剛剛發佈了新的開源模型 Zephry-7B🪁，</span><span style="background-color:#ffffff; color:#333333">這個模型的誕生離不開全球三大洲開源社區的協作 ❤️。</span></p><p><span style="background-color:#ffffff; color:#333333">我們的 CSO Thomas 錄了一個視頻介紹了它的起源故事。</span></p><p><img height="377" src="https://oscimg.oschina.net/oscnet/up-da1e6db4fb09e0c752bd317fe94e1e1d4a3.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#333333">✨ 就在幾個月前，巴黎的一個新團隊發佈了他們首個模型: Mistral 7B，這個模型體積小巧但性能強勁，在基準測試中的表現超過了所有同類模型。而且這是個開源模型，這意味着大家都可以在此基礎上進行開發。</span></p><p><span style="background-color:#ffffff; color:#333333">✨ 開發者 Lewis 在瑞士伯爾尼，Ed 在法國南部里昂，他們倆都是 Hugging Face H4 團隊的一員。在 Hugging Face 舉辦的一次小聚中，他們邊喝咖啡邊討論用斯坦福大學新發表的 DPO 方法對模型進行微調的可能性。於是大家決定用他們已經構建好的代碼庫來嘗試一下💪</span></p><p><br><span style="background-color:#ffffff; color:#333333">✨接下來的一天，他們在 HF hub 上找到了一些公開的數據集，主要是由清華的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzk0NzM3OTc2Nw%3D%3D%26mid%3D2247487177%26idx%3D1%26sn%3Dcfbeb254d91501fdeadda5103f1d2279%26scene%3D21%23wechat_redirect" target="_blank">OpenBMB</a> 團隊新近開源的兩個大型、高質量的微調數據集: UltraFeedback 和 UltraChat 📊</span></p><p><br><span style="background-color:#ffffff; color:#333333">✨ 經過幾輪訓練實驗，他們的想法得到了證實: 這個新模型非常強大，在伯克利和斯坦福的基準測試中是他們見過的最強模型。Clémentine 是 Hugging Face Open LLM Leaderboard 的領頭人，她對模型的深入分析確認了其卓越性能。於是 H4 團隊中另一位成員 Sasha Rush 教授迅速起草了一篇研究報告，將所有細節分享給整個社區 📰</span></p><p><br><span style="background-color:#ffffff; color:#333333">✨ 幾天後，這個名為 Zephyr 的模型、研究論文以及所有細節都向世界公開了。不久之後，全球各地的公司開始應用這一模型。LlamaIndex，一個知名的數據框架和社區，分享了這個模型在實際用例基準測試中超乎預期的表現。與此同時，研究者和實踐者們在 Hugging Face hub 上討論着這篇論文和相關工作。</span></p><p>&nbsp;</p><p><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff; color:#333333">✨</span><span style="background-color:#ffffff; color:#333333"></span>很難相信，這一切的實現僅僅用了幾周時間 🤯！這一切都得益於世界各地 (歐洲、加利福尼亞、中國) 對知識、模型、研究和數據集的開放，以及開源社區之間的相互協作 🤝</span></p><p><br><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff; color:#333333">✨</span><span style="background-color:#ffffff; color:#333333"></span>這樣的故事在開源社區比比皆是，也正是這些人和事讓開源社區始終保持不斷創新的原動力 🔥</span></p><p><br><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff; color:#333333">✨ </span>齊心協力，我們可以一起創造出驚人的成果 ❤️</span></p><p>&nbsp;</p></div><p style="color:#858585">本文分享自微信公眾號 - Hugging Face（gh_504339124f0f）。<br> 如有侵權，請聯繫 support@oschina.cn 刪除。<br> 本文參與「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源創計劃</a>」，歡迎正在閲讀的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 06:32:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/HuggingFace/blog/10142118</guid>
            <link>https://my.oschina.net/HuggingFace/blog/10142118</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[🔥 周熱點 | 阿里雲嚴重故障；開源軟件 OBS Studio 被賣 43 元；蘋果迴應 8GB 近似於其它系統的 16GB.....]]>
            </title>
            <description>
                <![CDATA[回顧一週熱門資訊。2023.11.06-2023.11.12]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 03:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649093948&#38;idx=1&#38;sn=706606fa2f64f52b06fc8b4cee57747b&#38;chksm=880c4c2fbf7bc5397b5a8f8cf06c3879715d17a1760fae142652daea51d149d354fc1dcbc442&#38;token=293181062&#38;lang=zh_CN#rd</guid>
            <link>https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649093948&#38;idx=1&#38;sn=706606fa2f64f52b06fc8b4cee57747b&#38;chksm=880c4c2fbf7bc5397b5a8f8cf06c3879715d17a1760fae142652daea51d149d354fc1dcbc442&#38;token=293181062&#38;lang=zh_CN#rd</link>
        </item>
        <item>
            <title>
                <![CDATA[Google Play 收緊 Android 應用開發者規則]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">谷歌<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid-developers.googleblog.com%2F2023%2F11%2Fensuring-high-quality-apps-on-google-play.html" target="_blank">宣佈</a>收緊在 Google Play 商店發佈應用程序的 Android 開發者規則，引入了一些新的政策和計劃，以提高整個平台的應用程序質量。</span></p><p><span style="color:#000000">公告指出，現在將要求擁有新創建的個人 Play Console 帳戶的開發者在發佈前，至少 2 周內與至少 20 人一起測試他們的應用程序。他們認為，此舉將幫助開發人員提前發現問題獲得用戶反饋，預計該</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsupport.google.com%2Fgoogleplay%2Fandroid-developer%2Fanswer%2F14151465" target="_blank">要求</a><span style="color:#000000">將在「未來幾天」出現在 Play 管理中心。</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">與此同時，</span>Google Play 的<span style="background-color:#ffffff">審核團隊還將加強對應用程序的審核，預計整體應用程序審核時間表不會發生重大變化。</span></span><span style="color:#000000"><span style="background-color:#ffffff">但該公司</span>警告稱，隨着這些變化的推出，少數應用程序的審批時間可能會加長，<span style="background-color:#ffffff">例如為兒童設計的應用程序或請求某些設備權限的應用程序。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">「</span>我們的全球審核團隊現在花更多時間評估新應用程序，以確保它們提供有價值的用戶體驗，不會通過應用程序或場外活動欺騙或欺詐用戶，並遵守我們的政策。<span style="background-color:#ffffff">」</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">此前，谷歌方面曾宣佈所有開發者在 Google Play 上發佈應用程序前必須滿足一系列擴展的驗證要求，以打擊惡意軟件行為。時至今日，該公司還</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsupport.google.com%2Fgoogleplay%2Fandroid-developer%2Fanswer%2F14177239" target="_blank"><span style="color:#2980b9">分享</span></a><span style="color:#000000">了一些內容，指導幫助擁有現有帳戶的開發者如何完成這些驗證，以符合更新後的&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsupport.google.com%2Fgoogleplay%2Fandroid-developer%2Fanswer%2F10788890" target="_blank">Play 管理中心要求政策</a><span style="color:#000000">。</span></p><p><span style="color:#000000">開發者將可以自行選擇完成賬戶驗證的截止日期。截止日期以先到先得的方式提供，因此官方建議用戶儘早進行選擇，以確保能在合適的時間內完成驗證。如果開發者沒有在 2024 年 2 月 29 日之前選擇截止日期，平台將自動為其指定一個截止日期。</span></p><p><span style="color:#000000"><img alt="" height="237" src="https://oscimg.oschina.net/oscnet/up-bdd9ea4f2ac3077b8a399d99314c569aae1.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">另一方面，公告表示，為了繼續為用戶提供優質內容，回報開發者在質量方面的投資，該公司<span style="background-color:#ffffff">已經開始：</span></span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">向用戶提供有關應用程序是否在其設備（包括手機、大屏幕和可穿戴設備）上運行不佳的信息</span></li><li><span style="color:#000000">呈現更多高質量的本地和區域內容</span></li></ul><p><span style="color:#000000">並計劃將從 2024 年開始添加一個標識官方應用程序的徽章標識，以幫助用戶找到所需的應用程序。&nbsp;</span></p><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid-developers.googleblog.com%2F2023%2F11%2Fensuring-high-quality-apps-on-google-play.html" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 03:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266381/google-play-tightens-up-rules-android-app-developers</guid>
            <link>https://www.oschina.net/news/266381/google-play-tightens-up-rules-android-app-developers</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
