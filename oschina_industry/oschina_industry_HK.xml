<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-綜合資訊]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 07 Dec 2023 06:42:42 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[防禦性編程幾大基本原則]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">當開發人員遇到意外的錯誤無法修復時，他們會「添加一些防禦性代碼」來使代碼更安全，更容易找到問題所在。有時候，僅僅這樣做就能解決問題。他們會加強數據驗證——確保檢查輸入和輸出字段以及返回值。審查並改進錯誤處理——也許在「不可能」的情況周圍添加一些檢查。增加一些有用的日誌記錄和診斷功能。換句話説，這些<strong>本應該從一開始就存在的代碼</strong>。</p><blockquote><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">防禦性編程的整個目的是為了防範你意想不到的錯誤。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">——Steve McConnell，《代碼大全》</p></blockquote><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">防禦性編程的幾個基本原則在 Steve McConnell 經典著作《代碼大全》中有詳細解釋：</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>保護你的代碼免受「外部」傳入的無效數據影響</strong>，無論你認為「外部」是指什麼地方。這裏指來自外部系統、用户、文件或模塊/組件之外的任何數據。建立「壁壘」、「安全區域」或「信任邊界」——邊界之外的一切都是危險的，邊界之內的一切都是安全的。在壁壘代碼中，驗證所有輸入數據：檢查所有輸入參數的正確類型、長度和取值範圍。再次檢查限制和範圍。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">在檢查完壞數據後，決定如何處理它。<strong>防禦性編程並不意味着吞沒錯誤或隱藏錯誤</strong>。它是關於在健壯性（如果遇到可處理的問題則繼續運行）和正確性（永遠不返回錯誤結果）之間做出權衡。選擇一種處理壞數據的策略：立即返回錯誤並停止運行（快速失敗），返回一箇中立值，替換數據值等等。確保策略明確且一致。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>不要假設你代碼之外的函數調用或方法調用會按照廣告所述正常工作</strong>。確保你理解並測試了周圍外部 API 和庫的錯誤處理機制。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>使用斷言來記錄假設，並突出顯示「不可能」的條件</strong>，至少在開發和測試階段如此。這對於長期由不同人維護或高可靠性代碼特別重要。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">巧妙地<strong>添加診斷代碼、日誌記錄和跟蹤功能</strong>，以幫助解釋運行時發生了什麼問題，尤其是當遇到問題時。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>標準化錯誤處理</strong>。決定如何處理「正常錯誤」或「預期錯誤」和警告，並始終保持一致。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>只在需要時使用異常處理</strong>，並確保你對語言的異常處理機制瞭如指掌。將異常作為正常處理流程的一部分的程序會遭受經典意義上代碼結構混亂的可讀性和可維護性問題。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">Michael Nygard 在《發佈！》中還提到了其他幾個規則，比如永遠不要無限期等待外部調用，尤其是遠程調用。當出現問題時，無限期可能會很長時間。使用超時/重試邏輯以及他的斷路器穩定模式來處理遠程故障。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">對於 C 和 C++等編程語言，防禦性編程還包括使用安全函數調用來避免緩衝區溢出和常見編碼錯誤。</p><blockquote><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">原文：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fswreflections.blogspot.com%2F2012%2F03%2Fdefensive-programming-being-just-enough.html" target="_blank">https://swreflections.blogspot.com/2012/03/defensive-programming-being-just-enough.html</a></p></blockquote><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 06:33:36 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269921/defensive-programming</guid>
            <link>https://www.oschina.net/news/269921/defensive-programming</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[向量數據庫領域又來一個很屌的項目，PostgresML]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#1f2328">PostgresML 是 PostgreSQL 的機器學習擴展，能讓你使用 SQL 查詢對文本和表格數據進行訓練和推理。有了 PostgresML，你可以將機器學習模型無縫集成到 PostgreSQL 數據庫中，並利用尖端算法的強大功能高效處理數據。</span></p><ul><li>執行自然語言處理任務，如情感分析、提問和回答、翻譯、總結和文本生成</li><li>從 HuggingFace 模型 Hub 訪問數千種最先進的語言模型，如 GPT-2、GPT-J 和 GPT-Neo</li><li>針對不同任務，在自己的文本數據上微調大型語言模型</li><li>將現有的 PostgreSQL 數據庫用作向量數據庫，從存儲在數據庫中的文本生成 <span style="background-color:#ffffff; color:#1f2328">embedding</span></li></ul><p><img height="1550" src="https://static.oschina.net/uploads/space/2023/1207/115401_hs4U_3820517.png" width="3300" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#1f2328">針對文本數據操作：</span></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><strong>翻譯</strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><em>SQL 查詢</em></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><div style="text-align:start"><pre><span><span><span><span><span><span><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--fgColor-default, var(--color-fg-default))"><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span><span><span style="color:var(--color-prettylights-syntax-keyword)">SELECT</span></span><span><span style="color:var(--color-prettylights-syntax-constant)">pgml</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">transform</span></span>(
    <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>translation_en_to_fr<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
    inputs <span><span style="color:var(--color-prettylights-syntax-keyword)">=&gt;</span></span> ARRAY[
        <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>Welcome to the future!<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
        <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>Where have you been all this time?<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>
    ]
) <span><span style="color:var(--color-prettylights-syntax-keyword)">AS</span></span> french;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre><div><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><em>結果</em></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div>&nbsp;</div></div><div style="text-align:start"><pre><span><span><span><span><span><span><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--fgColor-default, var(--color-fg-default))"><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span>                         french                                 
<span><span style="color:var(--color-prettylights-syntax-comment)"><span><span style="color:var(--color-prettylights-syntax-comment)">--</span></span>----------------------------------------------------------</span></span>

[
    {<span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>translation_text<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>: <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>Bienvenue à l'avenir!<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>},
    {<span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>translation_text<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>: <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>Où êtes-vous allé tout ce temps?<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>}
]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre><div><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><strong>情感分析</strong> SQL 查詢</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div>&nbsp;</div></div><div style="text-align:start"><pre><span><span><span><span><span><span><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--fgColor-default, var(--color-fg-default))"><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span><span><span style="color:var(--color-prettylights-syntax-keyword)">SELECT</span></span><span><span style="color:var(--color-prettylights-syntax-constant)">pgml</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">transform</span></span>(
    task   <span><span style="color:var(--color-prettylights-syntax-keyword)">=&gt;</span></span><span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>text-classification<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
    inputs <span><span style="color:var(--color-prettylights-syntax-keyword)">=&gt;</span></span> ARRAY[
        <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>I love how amazingly simple ML has become!<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>, 
        <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>I hate doing mundane and thankless tasks. ☹️<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>
    ]
) <span><span style="color:var(--color-prettylights-syntax-keyword)">AS</span></span> positivity;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre><div><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><em>結果</em></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div>&nbsp;</div></div><div style="text-align:start"><pre><span><span><span><span><span><span><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--fgColor-default, var(--color-fg-default))"><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span>                    positivity
<span><span style="color:var(--color-prettylights-syntax-comment)"><span><span style="color:var(--color-prettylights-syntax-comment)">--</span></span>----------------------------------------------------</span></span>
[
    {<span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>label<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>: <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>POSITIVE<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>, <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>score<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>: <span><span style="color:var(--color-prettylights-syntax-constant)">0</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">9995759129524232</span></span>}, 
    {<span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>label<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>: <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>NEGATIVE<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>, <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>score<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>: <span><span style="color:var(--color-prettylights-syntax-constant)">0</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">9903519749641418</span></span>}
]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre></div><p>針對表格數據操作：</p><ul><li><a href="https://postgresml.org/docs/training/algorithm_selection">47+ 種分類和迴歸算法</a></li><li><a href="https://postgresml.org/blog/postgresml-is-8x-faster-than-python-http-microservices">推理速度比基於 HTTP 的模型服務快 8 - 40 倍</a></li><li><a href="https://postgresml.org/blog/scaling-postgresml-to-one-million-requests-per-second">每秒數百萬次事務</a></li><li><a href="https://github.com/postgresml/pgcat">橫向可擴展性</a></li></ul><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><strong>訓練分類模型</strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><em>訓練</em></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><div style="text-align:start"><pre><span><span><span><span><span><span><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--fgColor-default, var(--color-fg-default))"><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span><span><span style="color:var(--color-prettylights-syntax-keyword)">SELECT</span></span><span><span style="color:var(--color-prettylights-syntax-keyword)">*</span></span><span><span style="color:var(--color-prettylights-syntax-keyword)">FROM</span></span><span><span style="color:var(--color-prettylights-syntax-constant)">pgml</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">train</span></span>(
    <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>Handwritten Digit Image Classifier<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
    algorithm <span><span style="color:var(--color-prettylights-syntax-keyword)">=&gt;</span></span><span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>xgboost<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
    <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>classification<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
    <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>pgml.digits<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
    <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>target<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>
);</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre><div><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><em>推理</em></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div>&nbsp;</div></div><div style="text-align:start"><pre><span><span><span><span><span><span><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--fgColor-default, var(--color-fg-default))"><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span><span><span style="color:var(--color-prettylights-syntax-keyword)">SELECT</span></span><span><span style="color:var(--color-prettylights-syntax-constant)">pgml</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">predict</span></span>(
    <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>My Classification Project<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>, 
    ARRAY[<span><span style="color:var(--color-prettylights-syntax-constant)">0</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">1</span></span>, <span><span style="color:var(--color-prettylights-syntax-constant)">2</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">0</span></span>, <span><span style="color:var(--color-prettylights-syntax-constant)">5</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">0</span></span>]
) <span><span style="color:var(--color-prettylights-syntax-keyword)">AS</span></span> prediction;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre></div></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 04:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/postgresml</guid>
            <link>https://www.oschina.net/p/postgresml</link>
        </item>
        <item>
            <title>
                <![CDATA[騰訊 TDesignFlutter 組件庫開源啦🎉🎉🎉]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>簡介</span></span></span></span></strong></span></span></span></h1><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>作為一款誕生於騰訊內部開源、經過超 500 項內部業務檢驗的企業級設計體系，TDesign 彙集了騰訊眾多優秀組件庫能力和設計研發經驗。之前，TDesign 已經支持 Vue2、Vue Next、React 等業界主流技術棧，方便使用者快速開發桌面端、移動端以及小程序等多個版本的應用程序，從而更好地服務設計師和開發者，助力企業提升設計研發效能，為產品體驗設計帶來新的思路。</span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>Flutter 跨平台框架自 2018 年開源以來，迅速發展，擁有大量用户。Flutter 採用自繪引擎，可以在不同平台上實現高性能、流暢的用户界面，用户體驗出色。此外，Flutter 的跨平台特性使開發者只需編寫一次代碼，即可在多個平台上運行，減少開發和維護成本。Flutter 以其高效的開發流程、卓越的性能和跨平台能力，成為跨平台應用開發的首選框架。</span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>TDesignFlutter 不但擁有 Flutter 流暢的跨平台開發體驗，而且擁有 TDesign 美觀一致的設計資源。二者結合，開發者可以直接使用 TDesign 的組件構建 Flutter 應用，加快開發速度的同時，也確保了應用程序的一致性。在騰訊內部，TDesignFlutter 已支持多個產品線上穩定運行。</span></span></span></span></span></span></span></span></span></p><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>組件概覽</span></span></span></span></strong></span></span></span></h1><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>TDesignFlutter 已上線 Text、Button、Input 等 29 個基礎組件。詳情可查閲：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftdesign.tencent.com%2Fflutter%2Foverview" target="_blank">https://tdesign.tencent.com/flutter/overview</a></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><img height="1562" src="https://static.oschina.net/uploads/space/2023/1207/121232_iU7V_3820517.png" width="1270" referrerpolicy="no-referrer"></p><p><span><span><span><span><span><span><span style="color:#333333"><span><span>此外，Collapse(摺疊面板)、Upload(上傳工具) 等組件已在開發測試中，相信很快可以和大家見面。</span></span></span></span></span></span></span></span></span></p><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>常用組件</span></span></span></span></strong></span></span></span></h1><p style="margin-left:0pt; text-align:left"><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>Text:</span></span></span></span></strong></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#6d6e6f"><span><span>支持系統 Text 所有屬性，可無縫切換。中文居中處理，並將常用屬性扁平化，使用更加方便。</span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><img height="1548" src="https://static.oschina.net/uploads/space/2023/1207/121252_uk09_3820517.png" width="808" referrerpolicy="no-referrer"></p><p><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>Button:</span></span></span></span></strong></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#6d6e6f"><span><span>豐富的主題樣式，統一的設計規範。</span></span></span></span></span></span></span></span></span></span></p><div>
 &nbsp;
</div><div><div><p style="margin-left:0; margin-right:0; text-align:left"><img height="1395" src="https://static.oschina.net/uploads/space/2023/1207/121309_8Dew_3820517.png" width="1600" referrerpolicy="no-referrer"></p></div></div><p><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>Icon:</span></span></span></span></strong></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#6d6e6f"><span><span>內容豐富的圖標，使用 ttf 格式，簡單易用，避免失真。</span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><img height="1574" src="https://static.oschina.net/uploads/space/2023/1207/121324_6oME_3820517.png" width="810" referrerpolicy="no-referrer"></p><p><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>複雜組件:</span></span></span></span></strong></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#6d6e6f"><span><span>完善的功能，統一的交互，易用的封裝。</span></span></span></span></span></span></span></span></span></span></p><div>
 &nbsp;
</div><div><div><p style="margin-left:0; margin-right:0; text-align:left"><img height="1440" src="https://static.oschina.net/uploads/space/2023/1207/121344_TPc4_3820517.png" width="2184" referrerpolicy="no-referrer"></p></div></div><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>快速上手</span></span></span></span></strong></span></span></span></h1><h3><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>簡單使用</span></span></span></span></strong></span></span></span></h3><ul><li><span><span><span><span><span><span><span style="color:#333333"><span><span>在 pubbspec.yaml 引入依賴。</span></span></span></span></span></span></span></span></span></li></ul><pre><span style="background-color:#fafafa"><span><code><span><span><span><span><span style="color:#000000"><span><span>dependencies</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>tdesign_flutter</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> ^0.1.0</span></span></span></span></span></span></span></code></span></span></pre><ul><li><span><span><span><span><span><span><span style="color:#333333"><span><span>在文件頭部引入：import 'package:tdesign_flutter/tdesign_flutter.dart';</span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span style="color:#333333"><span><span>然後就可以使用 TDesignFlutter 的組件了:</span></span></span></span></span></span></span></span></span></li></ul><pre><span style="background-color:#fafafa"><span><code><span><span><span><span><span style="color:#dd4a68"><span><span>TDText</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>'測試文本'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>),</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>TDButton</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>text</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>'演示按鈕'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>`</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> theme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>TDButtonTheme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>primary</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>`</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>),</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>Icon</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>TDIcons</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>add_circle</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>)</span></span></span></span></span></span></span></code></span></span></pre><p style="margin-left:0; margin-right:0; text-align:left"><img height="740" src="https://static.oschina.net/uploads/space/2023/1207/121407_Tmg5_3820517.png" width="1052" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h3><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>自定義主題</span></span></span></span></strong></span></span></span></h3><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>TDesignFlutter 提供自定義主題的能力，可通過 json 文件配置顏色/字體尺寸/字體樣式/圓角/陰影等主題樣式。通過 TDTheme.of(context) 或者 TDTheme.defaultData() 獲取主題數據。</span></span></span></span></span></span></span></span></span></p><pre><span style="background-color:#fafafa"><span><code><span><span><span><span><span style="color:#000000"><span><span> TDTheme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>of</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>context</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>).</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>brandNormalColor</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> TDTheme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>defaultData</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>().</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>fontBodyLarge</span></span></span></span></span></span></span></code></span></span></pre><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>使用示例：</span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>下列代碼不設置特殊主題，使用 TDesingFlutter 默認主題：</span></span></span></span></span></span></span></span></span></p><pre><span style="background-color:#fafafa"><span><code><span><span><span><span><span style="color:#000000"><span><span>TDText</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>'測試文本'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> textColor</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> TDTheme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>of</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>context</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>).</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>brandNormalColor</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> font</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> TDTheme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>of</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>context</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>).</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>fontBodyMedium</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>),</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>const</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>TDButton</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> text</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>'演示按鈕'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> theme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> TDButtonTheme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>primary</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>)</span></span></span></span></span></span></span></code></span></span></pre><div>
 &nbsp;
</div><div><div><p style="margin-left:0; margin-right:0; text-align:left"><img height="320" src="https://static.oschina.net/uploads/space/2023/1207/121427_v0uq_3820517.png" width="638" referrerpolicy="no-referrer"></p></div></div><p><span><span><span><span><span><span><span style="color:#333333"><span><span>設置自定主題如下：</span></span></span></span></span></span></span></span></span></p><pre><span style="background-color:#fafafa"><span><code><span><span><span><span><span style="color:#dd4a68"><span><span>MaterialApp</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> theme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>ThemeData</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> extensions</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>[</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>TDThemeData</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>fromJson</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>'test'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> testThemeConfig</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>)</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>!</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>],</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>)</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> ……</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>)</span></span></span></span></span></span></span></code></span></span></pre><p style="margin-left:0; margin-right:0; text-align:left">&nbsp;</p><pre><span style="background-color:#fafafa"><span><code><span><span><span><span><span style="color:#000000"><span><span>String testThemeConfig </span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>=</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>''</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>{</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"test"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>{</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"color"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>{</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"brandNormalColor"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"#D7B386"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>},</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"font"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>{</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"fontBodyMedium"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>{</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"size"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#990055"><span><span>40</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"lineHeight"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#990055"><span><span>55</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>}</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>}</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>}</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>}</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>''</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>;</span></span></span></span></span></span></span></code></span></span></pre><div>
 &nbsp;
</div><div><div><p style="margin-left:0; margin-right:0; text-align:left"><img height="344" src="https://static.oschina.net/uploads/space/2023/1207/121450_rEcV_3820517.png" width="524" referrerpolicy="no-referrer"></p></div></div><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>適用場景</span></span></span></span></strong></span></span></span></h1><ul><li><span><span><span><span><span><span><span style="color:#333333"><span><span>如果你是一個全新的業務，想要快速構建美觀一致的 FlutterAPP。 √</span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span style="color:#333333"><span><span>如果你使用 Flutter 系統組件構建了 APP，想要一款簡單易用、可快速遷移的組件庫提升開發效率。 √</span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span style="color:#333333"><span><span>如果你想客户端和 web 端使用風格統一的組件，或者後續需要支持 pc 桌面端應用。 √</span></span></span></span></span></span></span></span></span></li></ul><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>後續規劃</span></span></span></span></strong></span></span></span></h1><ul><li><span><span><span><span><span><span><span style="color:#333333"><span><span>提供更多可靠實用的組件</span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span style="color:#333333"><span><span>適配 Flutter Web 和 PC 桌面端,支持更多應用場景</span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span style="color:#333333"><span><span>提供更完善的單元測試模塊和性能檢測能力，確保組件更可靠和流暢</span></span></span></span></span></span></span></span></span></li></ul><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>反饋和共建</span></span></span></span></strong></span></span></span></h1><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>TDesignFlutter 現已開放，歡迎廣大設計師和開發者使用和反饋，參與共建通用企業級設計體系。</span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftdesign.tencent.com%2Fflutter" target="_blank">https://tdesign.tencent.com/flutter</a></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>項目地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FTencent%2Ftdesign-flutter" target="_blank">https://github.com/Tencent/tdesign-flutter</a></span></span></span></span></span></span></span></span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 04:16:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269901/tdesignflutter-opensource</guid>
            <link>https://www.oschina.net/news/269901/tdesignflutter-opensource</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Windows 10 將於 2025 年 10 月 14 日終止支持]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">微軟發佈<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcommunity.microsoft.com%2Ft5%2Fwindows-it-pro-blog%2Fplan-for-windows-10-eos-with-windows-11-windows-365-and-esu%2Fba-p%2F4000414" target="_blank">公告</a>稱，<span style="background-color:#ffffff">Windows 10 將於 2025 年 10 月 14 日終止支持 (EOS)。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">當 Windows 10 終止支持時，官方將不再提供問題的錯誤修復、漏洞的安全修復、時區更新或可能發生的問題的技術支持。22H2 版本是 Windows 10 的最終版本。Windows 10 的所有版本 22H2 都將在 2025 年 10 月 14 日前繼續支持每月安全更新。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">距離&nbsp;Windows 10 EOS&nbsp; 僅剩不到兩年的時間，</span>微軟方面敦促用户儘快向&nbsp;<span style="background-color:#ffffff">Windows 11&nbsp;</span>系統遷移，並提供了一系列的過渡指南。</span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">「<span style="background-color:#ffffff">Windows 11 是迄今為止最安全的 Windows。其廣泛的功能（包括 Windows 中的 Copilot）旨在幫助你的組織保持安全和高效。這些措施包括內置的高級加密、數據和憑據保護、強大的系統安全和網絡安全，以及針對不斷變化的威脅的智能防護措施。</span>」</span></p><p style="margin-left:0; margin-right:0; text-align:left"><img height="269" src="https://oscimg.oschina.net/oscnet/up-33aa42a83be38c18ba69809b1d17613b0f4.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">儘管如此，微軟 Windows 服務和交付團隊成員 Jason Leznek 也表示：「雖然我們強烈建議遷移到 Windows 11，但我們也理解有些情況可能會妨礙用户在 EOS&nbsp; 日期之前更換 Windows 10 設備。因此，微軟將提供擴展安全更新 (Extended Security Updates)。」</span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#000000"><span style="background-color:#ffffff">與 Windows 7 </span><span style="background-color:#ffffff">ESU&nbsp;</span><span style="background-color:#ffffff">一樣，</span>Windows 10 用户可以選擇購買安全更新的年度訂閲，可在服務終止日期後的三年內繼續接收每月的安全更新。不過，Windows 10 ESU 計劃只提供<span style="background-color:#ffffff">關鍵和/或重要的安全更新</span>。一字兒較小缺陷的補丁、功能請求或其他更改不一定會被考慮，技術支持也僅限於安全問題。</span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">目前有關&nbsp;<span style="background-color:#ffffff">Windows 10 ESU 的相關定價尚未公佈。Windows 7 ESU 定價為： 每台 Windows 7 Pro 設備第一年的價格為 50 美元；第二年為 100 美元；第三年為 200 美元。</span><span style="background-color:#ffffff">對於 Windows Enterprise 客户，價格則僅為其一半。</span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><strong><span style="color:#000000"><span style="background-color:#ffffff">相關閲讀：</span></span></strong></p><ul><li style="text-align:left"><a href="https://www.oschina.net/news/264497/pigc-microsoft-extends-windows-10-support" target="_blank">公益組織請願微軟延長 Windows 10 支持</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 03:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269897</guid>
            <link>https://www.oschina.net/news/269897</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[維基百科推出「可編程」新項目：Wikifunctions]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>維基媒體基金會&nbsp;<span>(Wikimedia Foundation) <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwikimediafoundation.org%2Fnews%2F2023%2F12%2F05%2Fintroducing-wikifunctions-first-wikimedia-project-to-launch-in-a-decade-creates-new-forms-of-knowledge%2F" target="_blank">宣佈推出</a></u>&nbsp;</span><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wikifunctions.org%2Fwiki%2FWikifunctions%3AMain_Page" target="_blank">Wikifunctions</a></strong><span>，據稱這是該組織十多年來的第一個新項目。該項目讓志願者編輯<strong>能夠協作創建和維護一個函數庫</strong>——用於回答問題並增強有關維基媒體項目及其他項目的知識。</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-304d34c058f3401b98838b2b5ccf0208c6b.png" referrerpolicy="no-referrer"></p><p>「函數」是一系列編程指令，它根據提供的數據進行計算。通過 Wikifunctions，這些函數可以以任何語言存在，因此對於許多用户來説，<strong>這將是他們首次能夠用母語閲讀和編寫函數的項目</strong>。</p><p>Wikifunctions 的目標是使這些函數路徑更加容易訪問。它將提供一個單一的共享空間，簡化維護人員的工作並增加函數的可訪問性。最終，Wikifunctions 將與維基百科和其他維基媒體項目集成，為知識創造開闢新的機會。該項目將以維基百科的結構化數據為基礎，從其他維基媒體項目中彙集不同的數據源，從而利用函數代碼創建新形式的知識。</p><p><img src="https://oscimg.oschina.net/oscnet/up-eaa77a99abda8b84621cb9c8d3ccb01908a.png" referrerpolicy="no-referrer"></p><p><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wikifunctions.org%2Fwiki%2FWikifunctions%3AMain_Page" target="_blank">https://www.wikifunctions.org/wiki/Wikifunctions:Main_Page</a></u></em></p><p>Wikifunctions 作為底層技術基礎設施，將支持維基媒體基金會更廣泛的舉措，使人們能夠在維基百科上以更多語言分享更多知識。通過該項目，用户將能夠使用他們的母語創建和維護內容，其他用户可以在維基媒體項目提供的 300 多種語言中訪問這些內容。</p><p>Wikifunctions 於 2020 年獲得維基媒體基金會董事會的批准，今年早些時候作為只讀網站上線，現在任何人、任何地方都可以使用它。Wikifunctions 得到了 Google.org、洛克菲勒基金會和維基媒體捐贈基金的資助。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 03:37:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269893/wikifunctions-wikimedia</guid>
            <link>https://www.oschina.net/news/269893/wikifunctions-wikimedia</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[充電頭也能 OTA 升級？蘋果為電源適配器推送固件更新]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>蘋果公司近日為 30W 和 140W 的 USB-C 電源適配器推送了固件更新。</p><p>用户通過 MagSafe 3 或者 USB-C 連接到 Mac 設備之後，系統會自動開始更新。更新之後打開「系統信息」應用，點擊「電源」選項即可查看最新版本。</p><p>30W USB-C 電源適配器安裝的最新版本為&nbsp;<strong>Ver.1030053</strong>（上個版本為&nbsp;<span style="background-color:#ffffff; color:#333333">Ver.1030052</span>），ID 從 0x1674 升級到&nbsp;<strong>0x7003</strong>；</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-bf26c2e7e5c248d1a0aff7b7428adbbeb91.png" referrerpolicy="no-referrer"></p><p>140W USB-C 電源適配器安裝更新後版本號升級至&nbsp;<strong>Ver.1040073</strong>（上個版本為 <span style="background-color:#ffffff; color:#333333">Ver.1040068</span>）。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-01b90e9cd0dcfa5ab9bcb0ef1d2ab2b4b10.png" referrerpolicy="no-referrer"></p><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.macotakara.jp%2Fetc%2Fsupport%2Fentry-45789.html" target="_blank">https://www.macotakara.jp/etc/support/entry-45789.html</a></u></em>、<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.macotakara.jp%2Fetc%2Fsupport%2Fentry-45790.html" target="_blank">https://www.macotakara.jp/etc/support/entry-45790.html</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 03:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269879</guid>
            <link>https://www.oschina.net/news/269879</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[SQLite 重寫了 JSON 函數 —— 推出 JSONB]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>SQLite <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsqlite.org%2Fforum%2Fforumpost%2Ffa6f64e3dc1a5d97" target="_blank">宣佈推出 JSONB</a></u>，這是對 SQLite JSON 函數的重寫，宣稱比現有 JSON 函數「快幾倍」。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-7eec133035c4e37c1ac26035e420dcc9574.png" referrerpolicy="no-referrer"></p></blockquote><p>在過去幾年中，SQLite 開發者為改進 JSON 數據與該 SQL 數據庫的<strong>庫集成</strong>做了大量工作。最新的工作是<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsqlite.org%2Fsrc%2Finfo%2F7f0c79b94e8f55e5" target="_blank">已合併的 JSONB</a></u>。JSONB 對 SQLite JSON 函數進行了重寫，將 JSON 的內部使用從二進製表示形式更改改為連續的字節數組，可以作為 SQL BLOB 讀取或寫入。</p><p>JSONB 有助於降低解析 JSON 文本和表示用於存儲的 JSON 的開銷。</p><p>此外，JSONB 保留所有舊功能，並且所有 JSON 函數也可以接受 JSONB 二進制內容。如需瞭解有關 SQLite JSONB 功能及其更快性能潛力的更多信息，查看<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsqlite.org%2Fforum%2Fforumpost%2Ffa6f64e3dc1a5d97" target="_blank">https://sqlite.org/forum/forumpost/fa6f64e3dc1a5d97</a></u></em>。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 02:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269878/sqlite-lands-jsonb</guid>
            <link>https://www.oschina.net/news/269878/sqlite-lands-jsonb</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | JDK 21 虛擬線程原理及性能分析]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1>一、背景</h1><p style="color:#24292f; text-align:start">JDK21 在 9 月 19 號正式發佈，帶來了較多亮點，其中虛擬線程備受矚目，毫不誇張的説，它改變了高吞吐代碼的編寫方式，只需要小小的變動就可以讓目前的 IO 密集型程序的吞吐量得到提升，寫出高吞吐量的代碼不再困難。</p><p style="color:#24292f; text-align:start">本文將詳細介紹虛擬線程的使用場景，實現原理以及在 IO 密集型服務下的性能壓測效果。</p><span id="OSC_h1_2"></span><h1>二、為了提升吞吐性能，我們所做的優化</h1><p style="color:#24292f; text-align:start">在講虛擬線程之前，我們先聊聊為了提高吞吐性能，我們所做的一些優化方案。</p><span id="OSC_h2_3"></span><h2>串行模式</h2><p style="color:#24292f; text-align:start">在當前的微服務架構下，處理一次用户/上游的請求，往往需要多次調用下游服務、數據庫、文件系統等，再將所有請求的數據進行處理最終的結果返回給上游。<img alt="2.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/2.png" referrerpolicy="no-referrer"><img alt="3.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/3.png" referrerpolicy="no-referrer">在這種模式下，使用串行模式去查詢數據庫，下游 Dubbo/Http 接口，文件系統完成一次請求，接口整體的耗時等於各個下游的返回時間之和，這種寫法雖然簡單，但是接口耗時長、性能差，無法滿足 C 端高 QPS 場景下的性能要求。</p><span id="OSC_h2_4"></span><h2>線程池+Future 異步調用</h2><p style="color:#24292f; text-align:start">為瞭解決串行調用的低性能問題，我們會考慮使用並行異步調用的方式，最簡單的方式便是使用線程池 +Future 去並行調用。<img alt="4.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/4.jpeg" referrerpolicy="no-referrer">典型代碼如下：<img alt="11.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/11.png" referrerpolicy="no-referrer">這種方式雖然解決了大部分場景下的串行調用低性能問題，但是也存在着嚴重的弊端，由於存在 Future 的前後依賴關係，當使用場景存在大量的前後依賴時，會使得<strong>線程資源和 CPU 大量浪費在阻塞等待上</strong>，導致資源利用率低。</p><span id="OSC_h2_5"></span><h2>線程池+CompletableFuture 異步調用</h2><p style="color:#24292f; text-align:start">為了降低 CPU 的阻塞等待時間和提升資源的利用率，我們會使用 CompletableFuture 對調用流程進行編排，降低依賴之間的阻塞。</p><p style="color:#24292f; text-align:start">CompletableFuture 是由 Java8 引入的，在 Java8 之前一般通過 Future 實現異步。Future 用於表示異步計算的結果，如果存在流程之間的依賴關係，那麼只能通過阻塞或者輪詢的方式獲取結果，同時原生的 Future 不支持設置回調方法，Java8 之前若要設置回調可以使用 Guava 的 ListenableFuture，回調的引入又會導致回調地獄，代碼基本不具備可讀性。</p><p style="color:#24292f; text-align:start">而 CompletableFuture 是對 Future 的擴展，原生支持通過設置回調的方式處理計算結果，同時也支持組合編排操作，一定程度解決了回調地獄的問題。</p><p style="color:#24292f; text-align:start">使用 CompletableFuture 的實現方式如下：<img alt="101.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/101.png" referrerpolicy="no-referrer">CompletableFuture 雖然一定程度上面緩解了 CPU 資源<strong>大量浪費在阻塞等待上的問題</strong>，但是隻是緩解，核心的問題始終沒有解決。這兩個問題導致 CPU 無法充分被利用，系統吞吐量容易達到瓶頸。</p><ul><li><strong>線程資源浪費瓶頸始終在 IO 等待上</strong>，導致 CPU 資源利用率較低。目前大部分服務是 IO 密集型服務，一次請求的處理耗時大部分都消耗在等待下游 RPC，數據庫查詢的 IO 等待中，此時線程仍然只能阻塞等待結果返回，導致 CPU 的利用率很低。</li><li><strong>線程數量存在限制</strong>，<span>&nbsp;</span><strong>為了增加併發度，我們會給線程池配置更大的線程數</strong>，但是線程的數量是有限制的，Java 的線程模型是 1:1 映射平台線程的，導致 Java 線程創建的成本很高，不能無限增加。同時隨着 CPU 調度線程數的增加，會導致更嚴重的資源爭用，寶貴的 CPU 資源被損耗在上下文切換上。</li></ul><span id="OSC_h1_6"></span><h1>三、一請求一線程的模型</h1><p style="color:#24292f; text-align:start">在給出最終解決方案之前，我們先聊一聊 Web 應用中常見的一請求一線程的模型。</p><p style="color:#24292f; text-align:start">在 Web 中我們最常見的請求模型就是使用一請求一線程的模型，每個請求都由單獨的線程處理。此模型易於理解和實現，對編碼的可讀性，Debug 都非常友好，但是，它有一些缺點。當線程執行阻塞操作（如連接到數據庫或進行網絡調用）時，線程會被阻塞，直到操作完成，這意味着線程在此期間將無法處理任何其他請求。<img alt="45.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/45.jpeg" referrerpolicy="no-referrer">當遇到大促或突發流量等場景導致服務承受的請求數增大時，為了保證每個請求在儘可能短的時間內返回，減少等待時間，我們經常會採用以下方案：</p><ul><li><strong>擴大服務最大線程數</strong>，簡單有效，由於存在下列問題，導致平台線程有最大數量限制，不能大量擴充。 
  <ul><li>系統資源有限導致系統線程總量有限，進而導致與系統線程一一對應的平台線程有限。</li><li>平台線程的調度依賴於系統的線程調度程序，當平台線程創建過多，會消耗大量資源用於處理線程上下文切換。</li><li>每個平台線程都會開闢一塊大小約 1m 私有的棧空間，大量平台線程會佔據大量內存。<img alt="44.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/44.png" referrerpolicy="no-referrer"></li></ul></li><li><strong>垂直擴展，升級機器配置，水平擴展，增加服務節點</strong>，也就是俗稱的升配擴容大法，效果好，也是最常見的方案，缺點是會增加成本，同時有些場景下擴容並不能 100% 解決問題。</li><li><strong>採用異步/響應式編程方案</strong>，例如 RPC NIO 異步調用，WebFlux，Rx-Java 等非阻塞的基於 Ractor 模型的框架，使用事件驅動使得少量線程即可實現高吞吐的請求處理，擁有較好的性能與優秀的資源利用，缺點是學習成本較高兼容性問題較大，編碼風格與目前的一請求一線程的模型差異較大，理解難度大，同時對於代碼的調試比較困難。</li></ul><p style="color:#24292f; text-align:start"><strong>那麼有沒有一種方法可以易於編寫，方便遷移，符合日常編碼習慣，同時性能很不錯，CPU 資源利用率較高的方案呢?</strong></p><p style="color:#24292f; text-align:start"><strong>JDK21 中的虛擬線程可能給出了答案</strong>， JDK 提供了與 Thread 完全一致的抽象 Virtual Thread 來應對這種經常阻塞的情況，阻塞仍然是會阻塞，但是換了阻塞的對象，由昂貴的平台線程阻塞改為了成本很低的虛擬線程的阻塞，當代碼調用到阻塞 API 例如 IO，同步，Sleep 等操作時，JVM 會自動把<span>&nbsp;</span><strong>Virtual Thread 從平台線程上卸載</strong>，平台線程就會去處理下一個虛擬線程，通過這種方式，提升了平台線程的利用率，讓平台線程不再阻塞在等待上，<strong>從底層實現了少量平台線程就可以處理大量請求，提高了服務吞吐和 CPU 的利用率。</strong></p><span id="OSC_h1_7"></span><h1>四、虛擬線程</h1><span id="OSC_h2_8"></span><h2>線程術語定義</h2><p style="color:#24292f; text-align:start"><strong>操作系統線程（OS Thread）</strong>：由操作系統管理，是操作系統調度的基本單位。</p><p style="color:#24292f; text-align:start"><strong>平台線程（Platform Thread）</strong>：Java.Lang.Thread 類的每個實例，都是一個平台線程，是 Java 對操作系統線程的包裝，與操作系統是 1:1 映射。</p><p style="color:#24292f; text-align:start"><strong>虛擬線程（Virtual Thread）</strong>：一種輕量級，由 JVM 管理的線程。對應的實例 java.lang.VirtualThread 這個類。</p><p style="color:#24292f; text-align:start"><strong>載體線程（Carrier Thread）</strong>：指真正負責執行虛擬線程中任務的平台線程。一個虛擬線程裝載到一個平台線程之後，那麼這個平台線程就被稱為虛擬線程的載體線程。</p><span id="OSC_h2_9"></span><h2>虛擬線程定義</h2><p style="color:#24292f; text-align:start">JDK 中 java.lang.Thread 的每個實例都是一個平台線程。平台線程在底層操作系統線程上運行 Java 代碼，並在代碼的整個生命週期內獨佔操作系統線程，平台線程實例本質是由系統內核的線程調度程序進行調度，並且<strong>平台線程的數量受限於操作系統線程的數量</strong>。</p><p style="color:#24292f; text-align:start"><strong>而虛擬線程 (Virtual Thread) 它不與特定的操作系統線程相綁定</strong>。它在平台線程上運行 Java 代碼，但在代碼的整個生命週期內不獨佔平台線程。**這意味着許多虛擬線程可以在同一個平台線程上運行他們的 Java 代碼，共享同一個平台線程。**同時虛擬線程的成本很低，<strong>虛擬線程的數量可以比平台線程的數量大得多。</strong><img alt="17.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/17.png" referrerpolicy="no-referrer"></p><span id="OSC_h2_10"></span><h2>虛擬線程創建</h2><p style="color:#24292f; text-align:start"><strong>方法一：直接創建虛擬線程</strong></p><pre><code>Thread vt = Thread.startVirtualThread(() -&gt; {
    System.out.println("hello wolrd virtual thread");
});
</code></pre><p style="color:#24292f; text-align:start"><strong>方法二：創建虛擬線程但不自動運行，手動調用 start() 開始運行</strong></p><pre><code>Thread.ofVirtual().unstarted(() -&gt; {
    System.out.println("hello wolrd virtual thread");
});
vt.start();
</code></pre><p style="color:#24292f; text-align:start"><strong>方法三：通過虛擬線程的 ThreadFactory 創建虛擬線程</strong></p><pre><code>ThreadFactory tf = Thread.ofVirtual().factory();
Thread vt = tf.newThread(() -&gt; {
    System.out.println("Start virtual thread...");
    Thread.sleep(1000);
    System.out.println("End virtual thread. ");
});
vt.start();
</code></pre><p style="color:#24292f; text-align:start"><strong>方法四：Executors.newVirtualThreadPer</strong><span>&nbsp;</span><strong>-TaskExecutor()</strong></p><pre><code>
ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
executor.submit(() -&gt; {
    System.out.println("Start virtual thread...");
    Thread.sleep(1000);
    System.out.println("End virtual thread.");
    return true;
});
</code></pre><span id="OSC_h2_11"></span><h2>虛擬線程實現原理</h2><p style="color:#24292f; text-align:start">虛擬線程是由 Java 虛擬機調度，而不是操作系統。虛擬線程佔用空間小，同時使用輕量級的任務隊列來調度虛擬線程，避免了線程間基於內核的上下文切換開銷，因此可以極大量地創建和使用。</p><p style="color:#24292f; text-align:start"><strong>簡單來看，虛擬線程實現如下：virtual thread =continuation+scheduler+runnable</strong></p><p style="color:#24292f; text-align:start">虛擬線程會把任務（java.lang.Runnable 實例）包裝到一個 Continuation 實例中:</p><ul><li>當任務需要阻塞掛起的時候，會調用 Continuation 的 yield 操作進行阻塞，虛擬線程會從平台線程卸載。</li><li>當任務解除阻塞繼續執行的時候，調用 Continuation.run 會從阻塞點繼續執行。</li></ul><p style="color:#24292f; text-align:start">Scheduler 也就是執行器，由它將任務提交到具體的載體線程池中執行。</p><ul><li>它是 java.util.concurrent.Executor 的子類。</li><li>虛擬線程框架提供了一個默認的 FIFO 的 ForkJoinPool 用於執行虛擬線程任務。</li></ul><p style="color:#24292f; text-align:start">Runnable 則是真正的任務包裝器，由 Scheduler 負責提交到載體線程池中執行。</p><p style="color:#24292f; text-align:start">JVM 把虛擬線程分配給平台線程的操作稱為 mount（掛載），取消分配平台線程的操作稱為 unmount（卸載）：</p><p style="color:#24292f; text-align:start"><strong>mount 操作</strong>：虛擬線程掛載到平台線程，虛擬線程中包裝的 Continuation 堆棧幀數據會被拷貝到平台線程的線程棧，這是一個從堆複製到棧的過程。</p><p style="color:#24292f; text-align:start"><strong>unmount 操作</strong>：虛擬線程從平台線程卸載，此時虛擬線程的任務還沒有執行完成，所以虛擬線程中包裝的 Continuation 棧數據幀會會留在堆內存中。</p><p style="color:#24292f; text-align:start">從 Java 代碼的角度來看，其實是看不到虛擬線程及載體線程共享操作系統線程的，會認為虛擬線程及其載體都在同一個線程上運行，因此，在同一虛擬線程上多次調用的代碼可能會在每次調用時掛載的載體線程都不一樣。JDK 中使用了<span>&nbsp;</span><strong>FIFO 模式的 ForkJoinPool 作為虛擬線程的調度器</strong>，從這個調度器看虛擬線程任務的執行流程大致如下：</p><ul><li>調度器（線程池）中的平台線程等待處理任務。<img alt="66.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/66.png" referrerpolicy="no-referrer"></li><li>一個虛擬線程被分配平台線程，該平台線程作為載體線程執行虛擬線程中的任務。<img alt="90.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/90.png" referrerpolicy="no-referrer"></li><li>虛擬線程運行其 Continuation，Mount(掛載) 平台線程後，最終執行 Runnable 包裝的用户實際任務。<img alt="009.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/009.png" referrerpolicy="no-referrer"></li><li>虛擬線程任務執行完成，標記 Continuation 終結，標記虛擬線程為終結狀態，清空上下文，等待 GC 回收，解除掛載載體線程會返還到調度器（線程池）中等待處理下一個任務。<img alt="102.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/102.png" referrerpolicy="no-referrer"></li></ul><p style="color:#24292f; text-align:start">上面是沒有阻塞場景的虛擬線程任務執行情況，如果遇到了阻塞 (例如 Lock 等) 場景，會觸發 Continuation 的 yield 操作讓出控制權，等待虛擬線程重新分配載體線程並且執行，具體見下面的代碼：</p><pre><code> ReentrantLock lock = new ReentrantLock();
        Thread.startVirtualThread(() -&gt; {
            lock.lock();    
        });
        // 確保鎖已經被上面的虛擬線程持有
        Thread.sleep(1000);  
        Thread.startVirtualThread(() -&gt; {
            System.out.println("first");
            會觸發 Continuation 的 yield 操作
            lock.lock(); 
            try {
                System.out.println("second");
            } finally {
                lock.unlock();
            }
            System.out.println("third");
        });
        Thread.sleep(Long.MAX_VALUE);
    }
</code></pre><p>虛擬線程中任務執行時候調用 Continuation#run()<span>&nbsp;</span><strong>先執行了部分任務代碼，然後嘗試獲取鎖</strong>，該操作是阻塞操作會導致 Continuation 的 yield 操作讓出控制權，如果 yield 操作成功，會從載體線程 unmount，載體線程棧數據會移動到 Continuation 棧的數據幀中，保存在堆內存中，虛擬線程任務完成，此時虛擬線程和 Continuation 還沒有終結和釋放，載體線程被釋放到執行器中等待新的任務；如果 Continuation 的 yield 操作失敗，則會對載體線程進行 Park 調用，<strong>阻塞在載體線程上，此時虛擬線程和載體線程同時會被阻塞</strong>，本地方法，Synchronized 修飾的同步方法都會導致 yield 失敗。<img alt="008.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/008.png" referrerpolicy="no-referrer"></p><p>當鎖持有者釋放鎖之後，<strong>會喚醒虛擬線程獲取鎖</strong>，獲取鎖成功後，虛擬線程會重新進行 mount，讓虛擬線程任務再次執行，<strong>此時有可能是分配到另一個載體線程中執行</strong>，Continuation 棧會的數據幀會被恢復到載體線程棧中，然後再次調用 Continuation#run() 恢復任務執行。<img alt="172.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/172.png" referrerpolicy="no-referrer"></p><p>虛擬線程任務執行完成，標記 Continuation 終結，標記虛擬線程為終結狀態，清空上下文變量，解除載體線程的掛載載體線程返還到調度器（線程池）中作為平台線程等待處理下一個任務。</p><p style="color:#24292f; text-align:start">Continuation 組件十分重要，<strong>它既是用户真實任務的包裝器，同時提供了虛擬線程任務暫停/繼續的能力，以及虛擬線程與平台線程數據轉移功能，當任務需要阻塞掛起的時候，調用 Continuation 的 yield 操作進行阻塞。當任務需要解除阻塞繼續執行的時候，則調用 Continuation 的 run 恢復執行。</strong></p><p style="color:#24292f; text-align:start">通過下面的代碼可以看出 Continuation 的神奇之處，通過在編譯參數加上--add-exports java.base/jdk.internal.vm=ALL-UNNAMED 可以在本地運行。</p><pre><code>ContinuationScope scope = new ContinuationScope("scope");
Continuation continuation = new Continuation(scope， () -&gt; {
    System.out.println("before yield 開始");
    Continuation.yield(scope);
    System.out.println("after yield 結束");
});
System.out.println("1 run");
// 第一次執行 Continuation.run
continuation.run();
System.out.println("2 run");
// 第二次執行 Continuation.run
continuation.run();
System.out.println("Done");
</code></pre><p style="color:#24292f; text-align:start"><img alt="756.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/756.png" referrerpolicy="no-referrer">通過上述案例可以看出，<strong>Continuation 實例進行 yield 調用後，再次調用其 run 方法就可以從 yield 的調用之處繼續往下執行，從而實現了程序的中斷和恢復。</strong></p><span id="OSC_h2_12"></span><h2>虛擬線程內存佔用評估</h2><p style="color:#24292f; text-align:start"><strong>單個平台線程的資源佔用：</strong></p><ul><li>根據 JVM 規範，預留 1 MB 線程棧空間。</li><li>平台線程實例，會佔據 2000+ byte 數據。</li></ul><p style="color:#24292f; text-align:start"><strong>單個虛擬線程的資源佔用：</strong></p><ul><li>Continuation 棧會佔用數百 byte 到數百 KB 內存空間，是作為堆棧塊對象存儲在 Java 堆中。</li><li>虛擬線程實例會佔據 200 - 240 byte 數據。</li></ul><p style="color:#24292f; text-align:start">從對比結果來看，<strong>理論上單個平台線程佔用的內存空間至少是 KB 級別的，而單個虛擬線程實例佔用的內存空間是 byte 級別</strong>，兩者的內存佔用差距較大，這也是虛擬線程可以大批量創建的原因。</p><p style="color:#24292f; text-align:start">下面通過一段程序去測試平台線程和虛擬線程的內存佔用：</p><pre><code>private static final int COUNT = 4000;

/**
 *  -XX:NativeMemoryTracking=detail
 *
 * @param args args
 */
public static void main(String[] args) throws Exception {
    for (int i = 0; i &lt; COUNT; i++) {
        new Thread(() -&gt; {
            try {
                Thread.sleep(Long.MAX_VALUE);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }， String.valueOf(i)).start();
    }
    Thread.sleep(Long.MAX_VALUE);
}
</code></pre><p style="color:#24292f; text-align:start">上面的程序運行後啓動 4000 平台線程，通過 -XX:NativeMemoryTracking=detail 參數和 JCMD 命令查看所有線程佔據的內存空間如下：<img alt="890.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/890.jpeg" referrerpolicy="no-referrer">內存佔用大部分來自創建的平台線程，<strong>總線程棧空間佔用約為 8096 MB，兩者加起來佔據總使用內存（8403MB）的 96% 以上。</strong></p><p style="color:#24292f; text-align:start">用類似的方式編寫運行虛擬線程的程序：</p><pre><code>private static final int COUNT = 4000;

/**
 * -XX:NativeMemoryTracking=detail
 *
 * @param args args
 */
public static void main(String[] args) throws Exception {
    for (int i = 0; i &lt; COUNT; i++) {
        Thread.startVirtualThread(() -&gt; {
            try {
                Thread.sleep(Long.MAX_VALUE);
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
    }
    Thread.sleep(Long.MAX_VALUE);
}
</code></pre><p style="color:#24292f; text-align:start">上面的程序運行後啓動 4000 虛擬線程：<img alt="123.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/123.jpeg" referrerpolicy="no-referrer">堆內存的實際佔用量和總內存的實際佔用量都不超過 300 MB，可以證明虛擬線程在大量創建的前提下也不會去佔用過多的內存，且<strong>虛擬線程的堆棧是作為堆棧塊對象存儲在 Java 的堆中的，可以被 GC 回收，又降低了虛擬線程的佔用。</strong></p><span id="OSC_h2_13"></span><h2>虛擬線程的侷限及使用建議</h2><ul><li>虛擬線程存在 native 方法或者外部方法 (Foreign Function &amp; Memory API，jep 424 ) 調用不能進行 yield 操作，此時載體線程會被阻塞。</li><li>當運行在 synchronized 修飾的代碼塊或者方法時，不能進行 yield 操作，此時載體線程會被阻塞，推薦使用 ReentrantLock。</li><li><strong>ThreadLocal 相關問題</strong>，目前虛擬線程仍然是支持 ThreadLocal 的，但是由於虛擬線程的數量非常多，會導致 Threadlocal 中存的線程變量非常多，需要頻繁 GC 去清理，對性能會有影響，官方建議儘量少使用 ThreadLocal，同時不要在虛擬線程的 ThreadLocal 中放大對象，目前官方是想通過 ScopedLocal 去替換掉 ThreadLocal，但是在 21 版本還沒有正式發佈，<strong>這個可能是大規模使用虛擬線程的一大難題</strong>。</li><li><strong>無需池化虛擬線程</strong><span>&nbsp;</span>虛擬線程佔用的資源很少，因此可以大量地創建而無須考慮池化，它不需要跟平台線程池一樣，平台線程的創建成本比較昂貴，所以通常選擇去池化，去做共享，<strong>但是池化操作本身會引入額外開銷</strong>，對於虛擬線程池化反而是得不償失，使用虛擬線程我們拋棄池化的思維，用時創建，用完就扔。</li></ul><span id="OSC_h2_14"></span><h2>虛擬線程適用場景</h2><ul><li>大量的 IO 阻塞等待任務，例如下游 RPC 調用，DB 查詢等。</li><li>大批量的處理時間較短的計算任務。</li><li>Thread-per-request (一請求一線程) 風格的應用程序，例如主流的 Tomcat 線程模型或者基於類似線程模型實現的 SpringMVC 框架 ，這些應用只需要小小的改動就可以帶來巨大的吞吐提升。</li></ul><span id="OSC_h1_15"></span><h1>五、虛擬線程壓測性能分析</h1><p style="color:#24292f; text-align:start">在下面的測試中，我們將模擬最常使用的場景-使用 Web 容器去處理 Http 請求。</p><p style="color:#24292f; text-align:start"><strong>場景一：</strong><span>&nbsp;</span>在 Spring Boot 中使用內嵌的 Tomcat 去處理 Http 請求，<strong>使用默認的平台線程池作為 Tomcat 的請求處理線程池。</strong></p><p style="color:#24292f; text-align:start"><strong>場景二</strong>：使用<strong>Spring -WebFlux</strong>創建基於事件循環模型的應用程序，進行響應式請求處理。</p><p style="color:#24292f; text-align:start"><strong>場景三：</strong><span>&nbsp;</span>在 Spring Boot 中使用內嵌的 Tomcat 去處理 Http 請求，<strong>使用虛擬線程池作為 Tomcat 的請求處理線程池</strong><span>&nbsp;</span>(Tomcat 已支持虛擬線程)。</p><span id="OSC_h2_16"></span><h2>測試流程</h2><ul><li>Jmeter 開啓 500 個線程去並行發起請求。每個線程將等待請求響應後再發起下一次請求，單次請求超時時間為 10s，測試時間持續 60s。</li><li>測試的 Web Server 將接受 Jmeter 的請求，並調用慢速服務器獲取響應並返回。</li><li>慢速服務器以隨機超時響應。最大響應時間為 1000ms。平均響應時間為 500ms。<img alt="46.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/46.png" referrerpolicy="no-referrer"></li></ul><span id="OSC_h2_17"></span><h2>衡量指標</h2><p style="color:#24292f; text-align:start"><strong>吞吐量和平均響應時間</strong>，吞吐量越高，平均響應時間越低，性能就越好。</p><span id="OSC_h2_18"></span><h2>Tomcat+普通線程池</h2><p style="color:#24292f; text-align:start">默認情況下，Tomcat 使用一請求一線程模型處理請求，當 Tomcat 收到請求時，會從線程池中取一個線程去處理請求，該分配的線程將一直保持佔用狀態，直到請求結束才會釋放。當線程池中沒有線程時，請求會一直阻塞在隊列中，直到有請求結束釋放線程。默認隊列長度為 Integer.MAX。</p><span id="OSC_h3_19"></span><h3>默認線程池</h3><p style="color:#24292f; text-align:start">默認情況下，線程池最多包含 200 個線程。這基本上意味着單個時間點最多處理 200 個請求。對於每個請求服務都會以阻塞的方式調用平均 RT500ms 的慢速服務器。因此，可以預期每秒 400 個請求的吞吐量，最終壓測結果非常接近預期值，為 388 req/sec。<img alt="112.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/112.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>增加線程池</strong></p><p style="color:#24292f; text-align:start">生產環境為了吞吐考慮,一般不會使用默認值,會把線程池增大到 server.tomcat.threads.max=500+，調整到 500+ 之後的壓測結果如下：<img alt="998.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/998.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">可以看出最終的吞吐量和線程數量呈比例上升，同時由於線程數的增加，請求等待減少，平均 RT 趨向於慢速服務器的響應平均 RT。</p><p style="color:#24292f; text-align:start">但是需要注意的是，平台線程的創建受到內存和 Java 線程映射模型的限制，不能無限擴展，同時大量線程會導致 CPU 資源大量消耗在上下文切換時，整體性能反而降低。</p><span id="OSC_h2_20"></span><h2>WebFlux</h2><p style="color:#24292f; text-align:start">WebFlux 跟傳統的 Tomcat 線程模型不一樣，他不會為每個請求分配一個專用線程，而是使用事件循環模型通過非阻塞 I/O 操作同時處理多個請求，這使得它能夠用有限的線程數量處理大量的併發請求。</p><p style="color:#24292f; text-align:start">在壓測的場景下，使用 WebClient 來進行一個非阻塞的 Http 調用慢速處理器，並使用 RouterFunction 來做請求映射和處理。</p><pre><code>@Bean
public WebClient slowServerClient() {
    return WebClient.builder()
            .baseUrl("http://127.0.0.1:8000")
            .build();
}

@Bean
public RouterFunction&lt;ServerResponse&gt; routes(WebClient slowServerClient) {
    return route(GET("/")， (ServerRequest req) -&gt; ok()
            .body(
                    slowServerClient
                            .get()
                            .exchangeToFlux(resp -&gt; resp.bodyToFlux(Object.class))，
                    Object.class
            ));
}

</code></pre><p style="color:#24292f; text-align:start">WebFlux 壓測結果如下：<img alt="087.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/087.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">可以看到，WebFlux 的請求完全沒有阻塞，僅用了 25 個線程就達到了 964 req/sec 的吞吐。</p><span id="OSC_h2_21"></span><h2>Tomcat+虛擬線程池</h2><p style="color:#24292f; text-align:start">與平台線程相比，虛擬線程的內存佔用量要低得多，運行程序大量的創建虛擬線程，而不會耗盡系統資源；同時當遇到 Thread.sleep()，CompletableFuture.await()，等待 I/O，獲取鎖時，虛擬線程會自動卸載，JVM 可以自動切換到另外的等待就緒的虛擬線程，提升單個平台線程的利用率，保證平台線程不會浪費在無意義的阻塞等待上。</p><p style="color:#24292f; text-align:start">要想使用虛擬線程，需要先在啓動參數中加上 --enable-preview，同時 Tomcat 在 10 版本已支持虛擬線程，我們只需要替換 Tomcat 的平台線程池為虛擬線程池即可。</p><pre><code>@Bean
public TomcatProtocolHandlerCustomizer&lt;?&gt; protocolHandler() {
    return protocolHandler -&gt;
            protocolHandler.setExecutor(Executors.newVirtualThreadPerTaskExecutor());
}


private final RestTemplate restTemplate;

@GetMapping
public ResponseEntity&lt;Object&gt; callSlowServer(){
    return restTemplate.getForEntity("http://127.0.0.1:8000"， Object.class);
}
</code></pre><p style="color:#24292f; text-align:start">最終壓測結果如下：<img alt="665.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/665.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">可以看到虛擬線程的壓測結果實際上與 WebFlux 的情況相同，<strong>但我們根本沒有使用任何複雜的響應式編程技術</strong>。同時對慢速服務器的調用，也使用常規的阻塞 RestTemplate。<strong>我們所做的只是用虛擬線程執行器替換線程池就達到更復雜的 Webflux 寫法相同的效果。</strong></p><p style="color:#24292f; text-align:start">總的壓測結果如下：<img alt="109.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/109.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">通過以上壓測結果，我們可以得出以下結論：</p><ul><li>傳統的線程池模式效果差強人意，可以通過提高線程數量可以提升吞吐，但是需要考慮到系統容量和資源限制，但是對於大部分場景來説使用線程池去處理阻塞操作仍然是主流且不錯的選擇。</li><li>WebFlux 的效果非常好，但是考慮到需要完全按照響應式風格進行開發，成本及難度較大，同時 WebFlux 與現有的一些主流框架存在一些兼容問題，例如 Mysql 官方 IO 庫不支持 NIO、Threadlocal 兼容問題等等。現有應用的遷移基本要重寫所有代碼，改動量和風險都不可控。</li><li><strong>虛擬線程的效果非常好，最大的優勢就是我們沒有修改代碼或採用任何反應式技術，唯一更改是將線程池替換為虛擬線程</strong>。雖然改動較小，但與使用線程池相比，性能結果得到了顯著改善。</li></ul><p style="color:#24292f; text-align:start">基於上述的壓測結果，可以較為樂觀的認為虛擬線程會顛覆我們目前的服務和框架中的請求處理方法。</p><span id="OSC_h1_22"></span><h1>六、總結</h1><p style="color:#24292f; text-align:start">過去很長時間，在編寫服務端應用時，我們對於每個請求，都使用獨佔的線程來處理，請求之間是相互獨立的，這就是<span>&nbsp;</span><strong>一請求一線程的模型</strong>這種方式易於理解和編程實現，也易於調試和性能調優。</p><p style="color:#24292f; text-align:start">然而，一請求一線程風格並不能簡單地使用平台線程來實現，因為平台線程是操作系統中線程的封裝。操作系統的線程會申請成本較高，存在數量上限。**對於一個要併發處理海量請求的服務器端應用來説，對每個請求都創建一個平台線程是不現實的。**在這種前提下，湧現出一批非阻塞 I/O 和異步編程框架，如 WebFlux ，RX-Java。當某個請求在等待 I/O 操作時，它會暫時讓出線程，並在 I/O 操作完成之後繼續執行。通過這種方式，可以用少量線程同時處理大量的請求。這些框架可以提升系統的吞吐量，但是要求開發人員必須熟悉所使用的底層框架，並按照響應式的風格來編寫代碼，響應式框架的調試困難，學習成本，兼容問題使得大部分人望而卻步 。 在使用虛擬線程之後，一切都將改變，開發人員可以使用目前最習慣舒服的方式來編寫代碼，<strong>高性能和高吞吐由虛擬線程自動幫你完成，這極大地降低了編寫高併發服務應用的難度。</strong></p><p style="color:#24292f; text-align:start"><strong>參考文檔：</strong></p><p style="color:#24292f; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F444" target="_blank">https://openjdk.org/jeps/444</a></p><p style="color:#24292f; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F514719325" target="_blank">https://zhuanlan.zhihu.com/p/514719325</a></p><p style="color:#24292f; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.vlts.cn%2Fpost%2Fvirtual-thread-source-code%23%25E5%2589%258D%25E6%258F%2590" target="_blank">https://www.vlts.cn/post/virtual-thread-source-code#%E5%89%8D%E6%8F%90</a></p><p style="color:#24292f; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F499342616" target="_blank">https://zhuanlan.zhihu.com/p/499342616</a></p><p style="color:#24292f; text-align:start">*<strong>文/creed</strong></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">本文屬得物技術原創，更多精彩文章請看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.dewu.com" target="_blank">得物技術官網</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">未經得物技術許可嚴禁轉載，否則依法追究法律責任！</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 02:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/10319533</guid>
            <link>https://my.oschina.net/u/5783135/blog/10319533</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[蘋果開源深度學習框架 MLX，專門針對 Apple Silicon 芯片優化]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>蘋果開源了針對 Apple Silicon 芯片優化的 MLX 深度學習框架，並表示該框架可以簡化研究人員在&nbsp;<span>Mac、iPad、iPhone 平台設計和部署模型的過程。</span></p><p><img src="https://oscimg.oschina.net/oscnet/up-5c9da56834a3118a57e83b8ae26e0181df3.png" referrerpolicy="no-referrer"></p><p>地址：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fml-explore%2Fmlx" target="_blank">https://github.com/ml-explore/mlx</a></u></em></p><p>根據介紹，該深度學習框架提供了與主流開發工具接軌的 API、支持延遲計算、採用動態設計並軟硬結合、對研究人員較為友好，且具有統一內存優勢。</p><p><strong>MLX 主要特性</strong></p><ul><li><p><strong>提供開發者熟悉的 API</strong>：MLX 具有和 NumPy 接近的 Python API，此外還擁有功能齊全的 C++ API，它與 Python API 非常相似。 MLX 具有<code>mlx.nn</code>和<code>mlx.optimizers</code>等更高級別的包，其 API 緊密貼合 PyTorch，以簡化構建更復雜的模型</p></li><li><p><strong>可組合函數轉換</strong>：MLX 具有用於自動微分、自動矢量化和計算圖優化的可組合函數轉換</p></li><li><p><strong>惰性計算 (Lazy computation)</strong>：MLX 中的計算是惰性計算。數組僅在需要時才會具體化</p></li><li><p><strong>動態圖構建</strong>：MLX 中的計算圖採用動態構建，更改函數參數的形狀不會觸發緩慢的編譯，並且調試簡單直觀</p></li><li><p><strong>多設備：</strong>可以在任何支持的設備上運行（當前為 CPU 和 GPU），確保用户能夠充分利用硬件</p></li><li><p><strong>具備統一內存優勢</strong>：MLX 和其他框架的顯着區別是採用統一內存模型。 MLX 中的數組位於共享內存中，可以在任何支持的設備類型上執行 MLX 陣列上的操作，而無需移動數據。</p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 02:25:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269870</guid>
            <link>https://www.oschina.net/news/269870</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[麥當勞中國啓動鴻蒙原生應用開發]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">麥當勞中國 12 月 6 日與華為達成鴻蒙合作協議，正式宣佈麥當勞中國 APP 將基於 HarmonyOS NEXT 啓動鴻蒙原生應用開發。</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">中國市場已經成為了麥當勞全球的第二大市場。</span>麥當勞中國在中國市場坐擁 5500 多家餐廳，擁有超過 20 萬員工，每年服務顧客超過十億人次，成為首批啓動鴻蒙原生應用開發的全球大型連鎖餐飲企業。</span></p><p><span style="color:#000000"><img alt="" height="334" src="https://oscimg.oschina.net/oscnet/up-0f4b27f891e839fc65b056b51f6d64a2c7d.jpg" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">目前，美團、去哪兒、新浪、釘釘、螞蟻集團、小紅書、58 集團、嗶哩嗶哩、高德地圖等均已啓動鴻蒙原生應用開發。</span></p><p><span style="background-color:#ffffff; color:#000000">華為終端雲服務開發者服務與平台部總裁望嶽表示：「麥當勞中國啓動鴻蒙原生應用開發，是鴻蒙生態發展在餐飲界的又一次重要突破。」</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 02:22:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269869</guid>
            <link>https://www.oschina.net/news/269869</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[睿思芯科正式加入 deepin（深度）社區，共同推進 RISC-V 生態繁榮！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">內容來源：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Findex%2Fzh" target="_blank">deepin 社區</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">近日，睿思芯科與&nbsp;deepin（深度）社區簽署了&nbsp;CLA（Contributor License Agreement，貢獻者許可協議），正式宣佈加入&nbsp;deepin（深度）社區。</p><p style="color:#333333; margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="383" src="https://storage.deepin.org/thread/202312070959511778_%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98__2023-12-07+09_58_20.jpeg" width="900" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">作為一家專注於 RISC-V 芯片設計開發的公司，睿思芯科始終致力於為用户提供高算力、低功耗和高安全性的處理器產品。通過加入 deepin（深度）社區，睿思芯科將進一步加強與開源社區的合作，推動技術創新和生態發展：</p><ul><li><p>在產品方面，睿思芯科將積極參與 deepin（深度）操作系統的適配和優化，共同探索和開發新的功能和應用，為 deepin 用户提供更好的體驗；</p></li><li><p>在技術方面，將持續推動 deepin（深度）操作系統與 RISC-V 芯片的技術創新和發展，提升 deepin（深度）操作系統在 RISC-V 芯片上的性能和安全性；</p></li><li>在生態方面，將更多地參與 deepin（深度）社區的活動和項目，與 deepin 的眾多合作伙伴一起，為用户提供更可靠的 RISC-V 芯片產品和服務，共同打造繁榮的 deepin 生態。</li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><strong>「生態合作既要腳踏實地，也需要仰望星空。」</strong>對於此次合作，統信軟件生態中心硬件生態部總經理蘇毓航表示，「站在操作系統的角度來看，對於和睿思芯科及 RISC-V 的產品及生態發展，可以關注以下三個方向：<strong>第一，基於 deepin（深度）社區進行第一階段的產品適配，同時放眼全球生態，堅持開放思維，尋找差異化發展之路；第二，專注實現應用場景的落地，尤其是在 AIoT、專用芯片、數據中心、邊緣計算市場的應用；第三，共同培育人才和開發者生態，精簡指令集的工具鏈及操作系統軟件生態建設仍需要高水平的人才。</strong>」</p><hr><h4><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Findex%2Fzh" target="_blank"><strong>關於 deepin（深度）&nbsp;社區</strong></a></h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">deepin（深度）社區成立於 2008 年，是國內歷史悠久，全球規模最大且最活躍的開源 OS 社區之一，也是中國首個桌面操作系統根社區，致力通過社區開發與協作，為所有人提供自由、開放的交流平台以及最好的開源操作系統，推動桌面系統的開源與革新。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">目前，deepin（深度）社區註冊用户近 15 萬人，總髮帖量 100 萬+，共創建 44 個 SIG 組，累計解決 Issue 達 8000+，PR 超 15000+，總開源代碼超過 1000 萬行。同時，deepin（深度）社區積極吸納全球開源智慧，推動操作系統技術和產品創新，用户遍佈全球 100 多個國家和地區，已有 6 個海外分支社區，涵蓋西班牙、巴西、意大利、俄羅斯等，鏡像站點 150+，全球用户累計超過 300 萬+。</p><h4><strong>關於睿思芯科</strong></h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">睿思芯科成立於 2018 年，主要開發基於 RISC-V 的處理器，提供垂直領域處理器設計及芯片解決方案，滿足從邊緣計算到數據中心等各領域的要求，客户涵蓋國內外多家知名企業，開展處理器 IP 授權和 SoC 開發合作。公司創始團隊來自於加州大學伯克利分校 RISC-V 原創項目組，擁有 RISC-V CPU 領域的深厚學識和卓越人才，具備世界一流的研發實力，致力於高端處理器解決方案的自主研發，聚焦 RISC-V CPU 核心技術和產品的研究與突破。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 02:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269863</guid>
            <link>https://www.oschina.net/news/269863</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌正式發佈最強 AI 模型 Gemini]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>12 月 6 日，谷歌宣佈推出其認為規模最大、功能最強大的人工智能模型 <strong>Gemini</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3b160dbfcd5f47ad00f617e0c64f7c2889e.png" referrerpolicy="no-referrer"></p><p>Gemini 將包括三種不同的套件：<strong>Gemini Ultra、Gemini Pro 和 Gemini Nano</strong>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-e8d709129890d597fe88456b9f64fdb2a43.jpg" referrerpolicy="no-referrer"></p><p><strong><em>Gemini Ultra 能力最強，Gemini Pro 可擴展多任務，Gemini Nano 適用於特定任務和移動設備。</em></strong></p><p>Google DeepMind 首席執行官兼聯合創始人 Demis Hassabis 説道，Gemini 是一個多模態大模型，這意味着它可以概括並無縫地理解、操作和組合不同類型的信息，包括文本、代碼、音頻、圖像和視頻。</p><p>據介紹，從自然圖像、音頻和視頻理解到數學推理， Gemini Ultra 在大型語言模型研發中被廣泛使用的 32 個學術基準測試集中，在其中 30 個測試集的性能超過了目前最強的大語言模型 GPT-4。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-5f610c5aa071ded6d966aa4faa37051e950.png" referrerpolicy="no-referrer"></p><p>Gemini Ultra 在 MMLU（大規模多任務語言理解數據集）中的得分率高達 90.0%，首次超越了人類專家。MMLU 結合了數學、物理、歷史、法律、醫學和倫理學等 57 個科目來測試大模型的知識儲備和解決問題的能力。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-6952202902ed32051c87ec7c36aa9e34475.png" referrerpolicy="no-referrer"></p><blockquote><p><strong>更多評測數據查看：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeepmind.google%2Ftechnologies%2Fgemini%2F%23introduction" target="_blank">https://deepmind.google/technologies/gemini/#introduction</a></em></u></strong></p></blockquote><p>Google 將在其產品中添加 Gemini。從今天開始，<strong>Bard 將使用 Gemini Pro 的微調版本來執行更高級的推理、規劃、理解等。這是 Bard 自推出以來最大的升級</strong>。</p><p>Google 還將 Gemini 引入了 Pixel。Pixel 8 Pro 將是第一款運行 Gemini Nano 的智能手機。</p><p>在接下來的幾個月中，Gemini 將出現在 Google 更多的產品和服務中，例如搜索、廣告、Chrome 和 Duet AI。</p><p><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.google%2Ftechnology%2Fai%2Fgoogle-gemini-ai%2F" target="_blank">詳情查看谷歌官方通告</a></em></u>。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 00:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269844/google-gemini-ai</guid>
            <link>https://www.oschina.net/news/269844/google-gemini-ai</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[把電腦分辨率改成 500% —— 「賽博燈泡」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>今天網上衝浪看到了一個新梗：<strong>「賽博燈泡」</strong>，和古早的「別吞燈泡」老梗一樣——</p><p><img src="https://static.oschina.net/uploads/space/2023/1206/194014_qo1V_2720166.gif" referrerpolicy="no-referrer"></p><p>不聽勸的網友看到後紛紛將電腦分辨率調成 500%，結果不負眾望：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b58bdd1d9ac016386d141c5f1775643896a.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-eeb007b40937823463cc0131b6201723aab.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-8828681c7e3dd14ebf15b515bab9e525c4d.png" referrerpolicy="no-referrer"></p><p>現實中這樣的例子比比皆是：別舔冬天的欄杆、別吃 xxx 辣薯片等等。觸發這些經典名場面的條件很容易就能總結：</p><p>1.嘗試門檻低<br> 2.後果嚴重，但又沒有那麼嚴重<br> 3.明確警告「不要嘗試」</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-83e00d1164813fed613e5e6aeeb4d39b0c1.png" referrerpolicy="no-referrer"></p></blockquote><p>對了，誰能説一下怎麼恢復到正常的分辨率。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 11:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269806</guid>
            <link>https://www.oschina.net/news/269806</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米 14 系列手機內核源代碼已託管至 GitHub]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米 14 系列手機 (Xiaomi 14 &amp; Xiaomi 14 Pro) 的內核源代碼已上傳至 GitHub。提交記錄顯示，AOSP 版本基於 Android U，標籤為 KERNEL.PLATFORM.3.0.r1-03200-kernel.0-1。</p><p><img height="1372" src="https://oscimg.oschina.net/oscnet/up-613df6bb8f2fb67ba1e36658886adfa4bab.png" width="1776" referrerpolicy="no-referrer"></p><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FMiCode%2FXiaomi_Kernel_OpenSource%2Fcommit%2F317e609aa4fb956c3aff565b62215e5a8041ca0c" target="_blank">https://github.com/MiCode/Xiaomi_Kernel_OpenSource/commit</a></u></em></p><p>由於 Android 系統是基於 Linux 的，而 Linux 採用 GPLv2 授權，根據 GPL 協議的要求，派生作品均需要發佈源代碼。小米從 2018 年開始把新機型的內核源碼開源，<strong>開源時間通常為新機發布後的三個月內</strong>。從 2019 年的小米 9 開始，小米將開源時間改為新機上市同時開源。</p><p>因此從小米 9 系列開始，幾乎總會在發佈當天或者隔一天就公開源碼，不過這次的小米 14 系列機型慢了一個多月。</p><p><strong>延伸閲讀</strong></p><ul><li><a href="https://www.oschina.net/news/125036/xiaomi-mi10-kernel-code">小米開源新機 Mi 11 內核源碼</a></li><li><a href="https://www.oschina.net/news/114993/xiaomi-redmi-note-9-pro-max-8-kernel-source-code">小米開源 Redmi Note 8 Pro 和 Note 9 Pro 系列的內核源碼</a></li><li><a href="https://www.oschina.net/news/114529/xiaomi-redmi-k30-pro-kernel-source-code">小米開源 Redmi K30 Pro 內核源碼</a></li><li><a href="https://www.oschina.net/news/104598/xiaomi-9-open-source-kernel-code">小米 9 開源內核代碼，上市即開源</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 10:55:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269796</guid>
            <link>https://www.oschina.net/news/269796</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[揭秘 Zadig V2.0.0 新開源架構：效率飆升 50% 的背後故事！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-07cd622e59f2c7ab34d05817fd5cd569_720w.jpg?source=d16d100b" referrerpolicy="no-referrer"></p><p>11 月初，Zadig 官方合併了 Zadig 系列產品並正式發佈了 V2.0.0 全新架構「 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26scene%3D21%23wechat_redirect" rel="nofollow" target="_blank">深秋，寒露：是時候和 Zadig 説再見了</a>」，此次合併基於開源 Zadig v1.18.0 最新版，並整合了 ZadigX v1.8.0 企業版的全部新功能代碼。新版本定名為 Zadig v2.0.0，服務端代碼完全開源於 GitHub。對於社區用户而言，V2.0.0 在原有開源基礎上提供更多企業級功能，改進了易用性和性能，優化了安全細節，工作流並行和複雜場景的執行效率顯著提高，提升效率高達 50%。Zadig 的資源運行成本也降低了近 30%。未來迭代中，所有用户將持續獲得產品底層能力的可靠性，助力更多企業提升雲原生持續交付能力，為開發者提供更出色的體驗。對於已在大規模使用 Zadig 的用户，平滑升級後可以免費激活並體驗專業版功能長達 30 天，到期後數據保留，基礎版功能仍可正常使用。以下將詳細介紹架構升級細節、業務及系統架構變化內容。</p><span id="OSC_h1_1"></span><h1><span style="color:#fd2968"><strong>Why Zadig V2.0.0 架構升級背景</strong></span></h1><p>隨着業務的不斷擴展，Zadig 面臨的挑戰也在不斷演變。為了確保持續發展、滿足用户需求，對 V1.x 系統架構進行升級已成為迫切需求。我們主要考慮到以下方面：</p><ol><li><p><span style="color:#fd2968"><strong>性能需求：</strong></span> v1.x 版本在處理大量請求時出現性能瓶頸，尤其在用户數量增加和權限配置複雜的情況下。升級旨在提高系統響應速度，改善用户體驗。</p></li><li><p><span style="color:#fd2968"><strong>安全需求：</strong></span> 隨着系統功能逐漸完善，用户關注點轉向使用體驗和安全性。v1.x 版本中的權限系統可能存在配置信息泄露問題。為了滿足更細粒度權限管控和更復雜用户系統的需求，我們需要進行架構升級。</p></li></ol><span id="OSC_h1_2"></span><h1><span style="color:#fd2968"><strong>升級涉及的組件變化</strong></span></h1><p>Zadig 的底層部署基於標準的 Helm Chart，組件資源和配置在 Chart 中定義。從 Zadig v1.x.0 到 Zadig v2.0.0，以下是組件的變化：</p><p><span style="color:#fd2968"><strong><em>新增服務</em></strong></span></p><ul><li><p>user: 2.0.0</p></li><li><p>time-nlp: 2.0.0</p></li><li><p>redis: latest</p></li></ul><p><span style="color:#fd2968"><strong><em>下線服務</em></strong></span></p><ul><li><p>nsq</p></li><li><p>opa</p></li><li><p>resource-server</p></li></ul><p>Zadig 使用標準 Helm 執行部署，組件資源以及配置均在 Chart 中定義，Chart 結構如下：</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-4a8fc9307e967dd7b083328d50a0d35d_720w.jpg?source=d16d100b" referrerpolicy="no-referrer"></p><span id="OSC_h1_3"></span><h1><span style="color:#fd2968"><strong>升級後的架構圖示</strong></span></h1><p>Zadig V2.0.0 業務和系統架構圖如下所示，幫助深入瞭解 Zadig v2.0.0 的整體業務和技術架構。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-dea2f29c4699ac8a1de1baa5c6464012_720w.jpg?source=d16d100b" referrerpolicy="no-referrer"></p><p style="text-align:center"><span style="color:#999999">Zadig v2.0.0 業務架構</span></p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-810c1ca4d6ee9df7ab44a9ee09561b9b_720w.jpg?source=d16d100b" referrerpolicy="no-referrer"></p><p style="text-align:center"><span style="color:#999999">Zadig v2.0.0 系統架構</span></p><span id="OSC_h1_4"></span><h1><span style="color:#fd2968"><strong>業務效果顯著</strong></span></h1><span id="OSC_h3_5"></span><h3><span style="color:#fd2968">01-工作流效率提升：</span></h3><p>使用模板構建、執行和列表頁面加載速度顯著提高，使用户操作更為高效。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-47a242e9dccb5a756698aabb9ad65ff5_720w.jpg?source=d16d100b" referrerpolicy="no-referrer"></p><span id="OSC_h3_6"></span><h3><span style="color:#fd2968">02-環境頁面加載效率提升：</span></h3><p>頁面加載效率提高了 40%，大大提升了診斷問題的速度。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-2390dc99af5c1e44f6198ce4a2c8308d_720w.jpg?source=d16d100b" referrerpolicy="no-referrer"></p><span id="OSC_h3_7"></span><h3><span style="color:#fd2968">03-系統資源優化：</span></h3><p>預計系統整體負載將減少 30% - 40%，涉及 CPU 和內存資源的節約。</p><p style="text-align:center"><img alt="" src="https://pica.zhimg.com/80/v2-7e36013d61672f0cd8eac5dd05d8d000_720w.jpg?source=d16d100b" referrerpolicy="no-referrer"></p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-f3258c8a46c58c0e87567ace72745773_720w.jpg?source=d16d100b" referrerpolicy="no-referrer"></p><p style="text-align:center"><span style="color:#999999">內部性能測試結果，不同場景下存在數據差異性，僅供參考</span></p><hr><p style="text-align:center">&nbsp;</p><p style="text-align:center"><span style="color:#fd2968">立即體驗 Zadig V2.0 新架構，開啓高效交付之旅！</span></p><p style="text-align:center"><span style="color:#fd2968"><strong>Zadig 開放，鏈接，專業</strong></span></p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-1390b9a380108bf281ae5a0946a15087_720w.jpg?source=d16d100b" referrerpolicy="no-referrer"></p><p style="text-align:center">&nbsp;</p><p style="text-align:center"><strong>推薦閲讀</strong></p><p style="text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490415%26idx%3D1%26sn%3D1914c7fd25aac5d33b98663571bbb744%26chksm%3Dcfb457cff8c3ded9c02809aad88012fa802eac55222eebe70b8c637ca2c86a101045aa81e73a%26scene%3D21%23wechat_redirect" rel="nofollow" target="_blank">是時候和 Jenkins 説再見了</a></p><p style="text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491180%26idx%3D1%26sn%3D3320b05425fb5608aa0ddb994376d7ff%26chksm%3Dcfb452ccf8c3dbda46e16a0728daeed32cd172d4753b31bf89dc8471078dc4116404c820426c%26scene%3D21%23wechat_redirect" rel="nofollow" target="_blank">Jenkins 任務如何遷移到 Zadig 工作流</a></p><p style="text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491208%26idx%3D1%26sn%3D6d1a8fc08eae6c00c180939da8e213eb%26chksm%3Dcfb45228f8c3db3efac6c9116f0a26cacdb6e8c6dcf71e8756608d3ae908d13a1c6676f80dbf%26scene%3D21%23wechat_redirect" rel="nofollow" target="_blank">Jenkins 遷移 Zadig，新項目實施上線效率提升 6 倍</a></p><p style="text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" rel="nofollow" target="_blank">Zadig vs. Jenkins 詳細比對：時代的選擇與開發者之選</a></p><p style="text-align:center">&nbsp;</p><p style="text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491208%26idx%3D1%26sn%3D6d1a8fc08eae6c00c180939da8e213eb%26chksm%3Dcfb45228f8c3db3efac6c9116f0a26cacdb6e8c6dcf71e8756608d3ae908d13a1c6676f80dbf%23rd" rel="nofollow">閲讀原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" rel="nofollow">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig" rel="nofollow">Zadig 在 Gitee</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 10:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/koderover/blog/10319356</guid>
            <link>https://my.oschina.net/koderover/blog/10319356</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[AppFlowy — 基於 Flutter 和 Rust 的 Notion 開源替代品]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>AppFlowy 是 Notion 的開源替代品，一個項目和知識管理工具，使用 Flutter 和 Rust 構建。</p><p><img alt="" height="356" src="https://static.oschina.net/uploads/space/2021/1117/163830_I7Uj_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><strong>特性：</strong></p><ul><li style="text-align:start"><span><span><span><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span>專為需要更多控制和靈活性的團隊而打造</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><ul><li style="text-align:start"><span><span>100% 數據控制。你</span></span><span><span>可以隨時隨地託管 AppFlowy；沒有供應商鎖定。</span></span></li><li><span><span>無限定製。</span></span><span><span>使用開放的核心代碼庫以您的方式設計和修改 AppFlowy。</span></span></li><li><span><span>一個代碼庫支持多個平台</span></span>。<span><span>AppFlowy 是用 Flutter 和 Rust 構建的。這意味着更快的開發、更好的原生體驗和更可靠的性能。</span></span></li></ul></li><li><p style="margin-left:0px; margin-right:0px; text-align:start"><span><span><span><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span>專為關心數據安全和移動體驗的個人打造</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p>&nbsp;</p><p style="margin-left:0px; margin-right:0px; text-align:start"><span><span><strong>100% 控制你的數據</strong></span></span>。<span><span>在你的本地機器上下載並安裝 AppFlowy，用户擁有並控制自己的個人數據。</span></span></p></li><li><p style="margin-left:0px; margin-right:0px; text-align:start"><span><span><strong>廣泛的可擴展。</strong></span></span><span><span>對於那些沒有編碼經驗的人，AppFlowy 使你能夠創建適合你需求的應用程序。它建立在社區驅動的工具箱上，包括模板、插件、主題等。</span></span></p><p>&nbsp;</p></li><li><p><span><span><strong>真正的 </strong></span></span><strong>Native&nbsp;</strong><span><span><strong>體驗。</strong>支持離線模式，更快、更穩定。它還可以更好地與不同的設備集成。此外，AppFlowy 使用户能夠訪問網絡上不可用的功能和可能性。</span></span></p><p>&nbsp;</p><p style="margin-left:0px; margin-right:0px; text-align:start">&nbsp;</p>
&nbsp;

<p>&nbsp;</p></li></ul></li></ul><p>&nbsp;</p></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 08:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/appflowy</guid>
            <link>https://www.oschina.net/p/appflowy</link>
        </item>
        <item>
            <title>
                <![CDATA[Linus Torvalds 收斂脾氣，談內核社區「老齡化」問題]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Linus Torvalds 近日出席了&nbsp;Linux 基金會的日本開源峯會，並與他的好友、Verizon 開源負責人 Dirk Hohndel <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zdnet.com%2Farticle%2Flinus-torvalds-on-state-of-linux-today-and-how-ai-figures-in-its-future%2F" target="_blank">談及了</a> Linux 的現狀。</span></p><p><span style="color:#000000">兩人首先談到了&nbsp;Linux 內核版本的迭代。Linus 在飛往東京參會前發佈了&nbsp;Linux 6.7 的第四個候選版本，預計穩定版將在避免大家節假日加班的前提下，在聖誕節前後正式發佈。他不想在"聖誕節前後出現合併窗口，因為這會破壞我的聖誕節"。為了讓準備 6.8 版本的維護人員和開發人員放心，合併窗口將推遲一到兩週再打開。</span></p><p><span style="color:#000000"><img alt="" height="308" src="https://oscimg.oschina.net/oscnet/up-d6f819fe06c7232fd0491dd32727607667e.webp" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">就經常被提及的<strong>內核維護人員疲態和壓力問題</strong>，Linus 首先否認了維護者必須是一個「無所不能的超級開發者」角色的説法，「要成為一名維護者，你必須有一定的品味來評判其他人的代碼。其中一些可能是天生的，但大多數都需要後天的練習。你必須能夠審視其他人的代碼，並能夠判斷'這是一個好方法還是一個壞方法？' 而這通常只是一個多年經驗的問題。」</span></p><p><span style="color:#000000">Linus 指出，Linux 內核現在確實擁有一些優秀的維護者。但問題在於，大家基本需要保持一個隨時在線的工作狀態，無法自由的安排假期，除非是可以找到能換班的其他維護者。</span></p><p><span style="color:#000000">對&nbsp;Linus 自己來説，因為熱愛所以保持在線不是什麼問題，然而並不是所有人都能和他一樣。「幾個月前，我去度假的時候也帶着筆記本電腦。如果沒有筆記本電腦，我會覺得很無聊。這就是我的工作。但我意識到，這不是每個人都能過的生活，尤其是當你必須為之付出多年心血的時候。」</span></p><p><span style="color:#000000">事實上，人際關係的處理也是 Linus 需要繼續學習的方面。「寫代碼很容易。因為有確定的正確答案和錯誤答案。但人際關係很難，要試着與其他開發人員和維護人員一起和諧工作，尤其是當維護人員的工作目標各不相同時......這可能會帶來很大的壓力。」</span></p><p><span style="color:#000000">Linus 表示，自己的火爆脾氣已經有所收斂。在吸取了一些教訓之後，他已經不會再「對一些公司豎中指」了。</span></p><p><span style="color:#000000">總的來説，他認為開源不僅僅是編程問題，很多時候也與交流有關。「維護者是翻譯者。我指的不一定是語言，我的意思是上下文、代碼的原因。這是一項艱鉅的工作。但是，如果你想成為一名維護者，相信我，頂層還有空間。」</span></p><p><span style="color:#000000">此外，Linus&nbsp;還回答了一個「<strong>Linux 內核社區的老齡化</strong>」的問題。Hohndel 指出，如果把目光投向未來五年，很多頂級 Linux 內核人員將開始步入 60 多歲，第一批人員甚至已經接近 70 多歲。</span></p><p><span style="color:#000000">對此 Linus 坦承道，"我們中的很多人確實都已經白髮蒼蒼了。但部分原因在於，我們的維護者已經工作了 30 多年。他們仍然存在、仍很活躍，最終仍將與我同在。<strong>We have a community where people do stick around</strong>"。</span></p><p><span style="color:#000000">Linus 也贊同了&nbsp;Hohndel 有關內核社區的老化是一把「雙刃劍」的説法。並以 Rust 舉例稱："我喜歡內核 Rust 方面的一點是，有一位維護者明顯比大多數維護者年輕得多。我們可以清楚地看到，內核中的某些領域引入了更多的年輕人。例如，在驅動程序方面，你會更容易找到年輕人，而這也是我們培養大量維護者的傳統方式，包括 Greg。"</span></p><p><span style="color:#000000">雙方還談到了 <strong>Rust 語言在 Linux 內核中的應用</strong>。Linus 稱：「它一直在增長，但我們還沒有任何內核部分真正依賴於 Rust。對我來説，Rust 是具有技術意義的事物之一，但對我個人來説，更重要的是作為內核和開發人員，我們不能停滯不前。」</span></p><p><span style="color:#000000">他透露，明年將在內核中開始集成驅動程序，甚至一些主要的子系統也將開始積極使用 Rust。並表示，想讓 Rust 成為內核的重要組成部分，還需數年的時間。「<strong>但它肯定會成為內核的一部分</strong>」。</span></p><p><span style="color:#000000">正在風頭上的人工智能大語言模型（LLM）自然也得到了 Linus &nbsp;的關注。但&nbsp;Linus 並不擔心 AI 威脅，"很明顯，自動化一直在幫助人們編寫代碼。這根本不是什麼新鮮事。"</span></p><p><span style="color:#000000">他反而更希望 AI 工具能提供真正的幫助，譬如識別一些愚蠢且低級的錯誤。「我們實際上需要加強自動更正功能。我認為 <strong>AI 是一種可以幫助我們做得更好的工具。</strong>」</span></p><p><span style="color:#000000">而 AI 所存在的幻覺問題在&nbsp;Linus 的眼中就更不值一提了。他頗帶諷刺意味的回答稱，"我每天都能看到一些在沒有 AI 的情況下所犯的錯。所以我才不那麼擔心。我認為，我們自己犯錯誤的能力還不錯。"</span></p><p><span style="color:#000000">最後，Linus 還表達了自己對開源和開放性的概念被越來越多的人所接受的欣喜。</span></p><blockquote><p><span style="color:#000000">「我特別喜歡這一事實，因為我還記得三十年前我啓動這個項目時的情景，人們會問我：'為什麼？'人們會説，'但你怎麼賺錢？'現在，這個問題再也不會出現了。開放已經成為行業的標準。人們理所當然地認為，當你必須開展大型項目時，無論是編程還是數據，最終都會因為項目太大而需要在公司之間共享。」&nbsp;</span></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 08:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269762/linus-torvalds-linux-future-ai</guid>
            <link>https://www.oschina.net/news/269762/linus-torvalds-linux-future-ai</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[黃仁勳：華為是英偉達在 AI 芯片領域的強大競爭對手]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>英偉達 CEO 黃仁勳週三表示，在生產最好的人工智能芯片競賽中，<strong>華為是英偉達「非常強大」的競爭對手之一</strong>。他還透露，<strong>英偉達正在與美國政府密切合作，確保面向中國市場的新芯片符合出口限制</strong>。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-ebe690ba54b830bcaf6d6e4a24e29d23565.png" referrerpolicy="no-referrer"></p><p>來源：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffinance.yahoo.com%2Fnews%2Fnvidia-sees-huawei-formidable-ai-034901190.html" target="_blank">https://finance.yahoo.com/news/nvidia-sees-huawei-formidable-ai-034901190.html</a></em></u></p></blockquote><p>黃仁勳在新加坡接受採訪時稱，華為、英特爾以及越來越多的半導體初創公司對英偉達在人工智能加速器市場的主導地位構成了嚴峻的挑戰。尤其是總部位於深圳的華為已成長為中國事實上的芯片技術巨頭，並於今年憑藉令人驚訝的先進中國製造智能手機處理器重新回到聚光燈下。</p><p>黃仁勳説道：「我們在中國和中國以外都有很多競爭對手。我們的大多數競爭對手並不真正關心我在哪裏。無論我們走到哪裏，他們都想和我們競爭。」</p><p>黃仁勳在訪問新加坡期間，與新加坡總理李顯龍進行了會面，討論新加坡在全球人工智能競賽中競爭的戰略。英偉達的芯片已經成為人工智能熱潮中最熱門的商品，因為它們提供了最有效的方法來訓練像 ChatGPT 這樣的大型數據模型。</p><p>在訪問新加坡之前，黃仁勳本週較早時訪問了日本，與日本首相和經濟大臣進行了會晤，並承諾將與日本公司合作，在日本建立一個半導體工廠網絡。</p><p>延伸閲讀</p><ul><li><em><u><a href="https://www.oschina.net/news/268075" target="_blank">英偉達推遲發佈中國特供版 AI 芯片</a></u></em></li><li><em><u><a href="https://www.oschina.net/news/265728" target="_blank">英偉達或將推出針對中國區的最新改良版 AI 芯片</a></u></em></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 08:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269760</guid>
            <link>https://www.oschina.net/news/269760</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[馬斯克計劃為 xAI 籌集 10 億美元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">在推出首款生成式 AI 聊天機器人 Grok 一個月後，埃隆·馬斯克 (Elon Musk) 正在尋求為他的人工智能初創公司 xAI 籌集 10 億美元資金。</span></p><p><span style="color:#000000">根據<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sec.gov%2FArchives%2Fedgar%2Fdata%2F2002695%2F000200269523000002%2FxslFormDX01%2Fprimary_doc.xml" target="_blank">美國證券交易委員會（SEC）的一份文件</a>顯示，馬斯克迄今已從四位不願透露姓名的投資者那裏籌集了約 1.35 億美元，第一筆交易發生在 11 月 29 日。這意味着他還需要大約 8.65 億美元才能實現 10 億美元的目標。</span></p><p><img height="307" src="https://oscimg.oschina.net/oscnet/up-92bcab6572974a70bd8bac1be41330bcf20.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">馬斯克於今年 7 月份宣佈 xAI 公司正式成立，並將與 OpenAI 的 ChatGPT、谷歌的 Bard 或 Anthropic 的 Claude 展開競爭。Grok 是 xAI 團隊發佈其首個 AI 大模型產品，一款仿照《銀河系漫遊指南》設計的人工智能。</span></p><p><span style="color:#000000">根據 xAI 的説法，Grok 與現有 AI 和大語言模型的不同之處在於，它可以完全訪問來自 X（即 Twitter）的實時知識。並且可以回答幾乎任何問題，包括其他 AI 機器人不會回答的一些"辛辣"問題，略帶詼諧和「反叛」。</span></p><p><strong><span style="color:#000000">相關閲讀：</span></strong></p><ul><li><a href="https://www.oschina.net/news/249159/elonmusk-announced-xai" target="news">馬斯克宣佈成立 xAI 公司</a></li><li><a href="https://www.oschina.net/news/265129/xai-grok" target="news">馬斯克旗下 xAI 發佈首個 AI 大模型產品 Grok</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 06:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269746/elon-musk-raise-1-billion-xai</guid>
            <link>https://www.oschina.net/news/269746/elon-musk-raise-1-billion-xai</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[新一代國產超算「天河星逸」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#424242">在今日舉行的 2023 年超算創新應用大會上，國家超算廣州中心正式發佈新一代國產超級計算系統「</span><strong>天河星逸</strong><span style="background-color:#ffffff; color:#424242">」。「天河星逸」以應用為中心，</span><strong>採用國產先進計算架構、高性能多核處理器、高速互連網絡、大規模存儲等關鍵技術構建</strong><span style="background-color:#ffffff; color:#424242">，全面滿足高性能計算、AI 大模型訓練、大數據分析等應用場景需求</span>，將為廣州市、廣東省和粵港澳大灣區的前沿科技突破、戰略工程建設、產業升級轉型提供強勁的高端算力與平台支撐。</p><p><span style="background-color:#ffffff; color:#424242">新華社介紹道，</span><strong>「天河星逸」在通用 CPU 計算能力、網絡能力、存儲能力以及應用服務能力等多方面較「天河二號」實現倍增</strong><span style="background-color:#ffffff; color:#424242">。</span></p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-3ee6121a56e8c7ec3596ef6c9322b230587.png" referrerpolicy="no-referrer"></p><p>來源：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1699432410%2FNvRi6gjwm%3Fpagetype%3Dprofilefeed" target="_blank">https://weibo.com/1699432410/NvRi6gjwm</a></em></u></p></blockquote><p>國家超算廣州中心業務主機「天河二號」研製工程總設計師廖湘科<u><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.news.cn%2Ftech%2F2023-12%2F06%2Fc_1130011222.htm" target="_blank">表示</a></u>，「天河二號」於 2013 年研製成功，並曾連續多次奪得 TOP500 世界超算冠軍，是我國超算系統研製進入世界領先行列的重要標誌，但國產超算應用一直是我國超算髮展面臨的挑戰。「在多方支持下，國家超算廣州中心組建一流人才團隊，開發了一系列面向領域的超算應用平台，支持各行各業取得了顯著的應用實效，有力拓展了國產超算應用生態。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-de7c6d56410ddf4e67b2b1214b80708ae2c.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 05:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269737</guid>
            <link>https://www.oschina.net/news/269737</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
