<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-綜合資訊]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 08 Dec 2023 03:12:24 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[百度 Comate 榮獲「2023 AIIA 人工智能十大先鋒應用案例」獎]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>12 月 7-8 日，中國人工智能產業發展聯盟（AIIA）第十次全體會議暨 2023 年通用人工智能創新發展論壇在重慶召開。</span>大會圍繞軟件工程、基礎平台、科學智能、具身智能等技術創新，數據、開源開放、安全治理等產業關鍵要素，以及金融、汽車等重點行業應用等人工智能最新熱點展開。</p><p><span>作為大會重磅環節，從今年 10 月起，AIIA 啓動</span><strong>「2023 人工智能十大先鋒應用案例徵集」活動</strong><span>，旨在甄選具有高價值、標杆性、真落地的行業典型應用實踐，打造 AI 界「奧斯卡」。經過為期 2 個月的徵集評審，從百餘項入圍案例中，</span><strong>百度智能代碼助手 Comate 脱穎而出，斬獲「2023AIIA 人工智能十大先鋒應用案例」獎，也是本次十大先鋒應用案例獎中的唯一軟件工程領域 AI 應用</strong><span><strong>。</strong></span></p><p><img height="846" src="https://static.oschina.net/uploads/space/2023/1208/110825_3Ktq_3820517.png" width="1269" referrerpolicy="no-referrer"></p><p><strong>（現場頒獎）</strong></p><p>從在百度內部全面落地應用，到面向企業開發者發佈「國內首個商用全場景智能編程助手」，再到 SaaS 版全面開放，百度 Comate 厚積薄發，持續引領 AI 原生研發新範式。</p><p>目前，百度 Comate 已覆蓋 100+種編程語言，支持 10+種主流 IDE，覆蓋編程前、後、移動端，支持軟硬件不同開發場景，為研發全生命週期提供全場景智能輔助，大幅提升研發效率的同時，也提升了工程師的工作倖福感。</p><p><img height="716" src="https://static.oschina.net/uploads/space/2023/1208/110838_ghZG_3820517.png" width="1268" referrerpolicy="no-referrer"></p><p><span>在技術創新優勢上，依賴文心大模型、飛槳深度學習平台以及百度多年積累的技術經驗，Comate 智能代碼助手具備</span><strong>模型訓練、推理加速、工程實踐和安全保障四重技術創新</strong><span>，並在</span><strong>代碼續寫、代碼解釋、NL2Code、Code Debug 等能力上領先行業與競品</strong><span>。</span></p><p><img height="712" src="https://static.oschina.net/uploads/space/2023/1208/110849_LSh5_3820517.png" width="1267" referrerpolicy="no-referrer"></p><p>在應用實效上，基於模型層多種能力，百度 Comate 具有優秀的代碼推薦、單測生成、自然語言代碼生成和代碼修復等能力；並通過開放 SaaS 版和私有化部署能力，滿足個人用户、中小企業和大型企業的不同需求。在百度內部，通過 Comate 生成代碼佔比 20%，整體採納率達 40%；SaaS 版開箱即用，註冊企業累計 4000+，註冊用户超 10000；涵蓋金融、汽車、互聯網、高端製造等在內的數十家大型企業已與 Comate 達成私有化部署合作。</p><p><img height="717" src="https://static.oschina.net/uploads/space/2023/1208/110902_P8vm_3820517.png" width="1269" referrerpolicy="no-referrer"></p><p>未來，百度 Comate 還將持續強化產品能力建設，堅守安全性的同時增強開放性，為企業和個人用户提供更智能、更高效、更便捷的代碼輔助服務，助力研發效率持續提升，加速產業創新落地。</p><p>馬上申請免費試用，還有超多限時福利！</p><p><img height="533" src="https://static.oschina.net/uploads/space/2023/1208/110911_Fwzq_3820517.png" width="300" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:11:17 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270054/comate-aiia-2023-news</guid>
            <link>https://www.oschina.net/news/270054/comate-aiia-2023-news</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[網信辦發佈《網絡安全事件報告管理辦法（徵求意見稿）》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>國家互聯網信息辦公室就《網絡安全事件報告管理辦法（徵求意見稿）》公開徵求意見。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-c1eb5e22a141f8e4fc99760bb45a85f397d.png" referrerpolicy="no-referrer"></p><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.cac.gov.cn%2F2023-12%2F08%2Fc_1703609634347501.htm" target="_blank">http://www.cac.gov.cn/2023-12/08/c_1703609634347501.htm</a></u></em></p></blockquote><p>徵求意見稿提出，運營者在發生網絡安全事件時，應當及時啓動應急預案進行處置。按照《網絡安全事件分級指南》，<strong>屬於較大、重大或特別重大網絡安全事件的，應當於 1 小時內進行報告</strong>。</p><p>其中，<strong>網絡和系統歸屬中央和國家機關各部門及其管理的企事業單位的，運營者應當向本部門網信工作機構報告</strong>。屬於重大、特別重大網絡安全事件的，各部門網信工作機構在收到報告後應當於 1 小時內向國家網信部門報告。</p><p><strong>網絡和系統為關鍵信息基礎設施的，運營者應當向保護工作部門、公安機關報告</strong>。屬於重大、特別重大網絡安全事件的，保護工作部門在收到報告後，應當於 1 小時內向國家網信部門、國務院公安部門報告。</p><p><strong>其他網絡和系統運營者應當向屬地網信部門報告</strong>。屬於重大、特別重大網絡安全事件的，屬地網信部門在收到報告後，應當於 1 小時內逐級向上級網信部門報告。</p><p>有行業主管監管部門的，<strong>運營者還應當按照行業主管監管部門要求報告</strong>。</p><p>運營者應當按照《網絡安全事件信息報告表》報告事件，至少包括下列內容：</p><ul><li><p><strong>事發單位名稱及發生事件的設施、系統、平台的基本情況</strong>；</p></li><li><p><strong>事件發現或發生時間、地點、事件類型、已造成的影響和危害，已採取的措施及效果</strong>。對勒索軟件攻擊事件，還應當包括要求支付贖金的金額、方式、日期等；</p></li><li><p>事態發展趨勢及可能進一步造成的影響和危害；</p></li><li><p>初步分析的事件原因；</p></li><li><p>進一步調查分析所需的線索，包括可能的攻擊者信息、攻擊路徑、存在的漏洞等；</p></li><li><p>擬進一步採取的應對措施以及請求支援事項；</p></li><li><p>事件現場的保護情況；</p></li><li><p>其他應當報告的情況。</p></li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-c423dc28f0c5f4929c6ec12f752d357f88f.png" referrerpolicy="no-referrer"></p><p>當事件處置結束後，運營者應當於 5 個工作日內對事件原因、應急處置措施、危害、責任處理、整改情況、教訓等進行全面分析總結，形成報告按照原渠道上報。</p><hr><p>附網絡安全事件分級指南：</p><p><img height="1406" src="https://oscimg.oschina.net/oscnet/up-3bd9fcd558b1e34d9278bc32bdf7f4a8048.png" width="1030" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-b5c16894520b3208bea288209ff7de41132.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-66e96efeef0f4b5e2538e297a57ab5d40a8.png" referrerpolicy="no-referrer"></p><p><img height="1486" src="https://oscimg.oschina.net/oscnet/up-79b90dfeb4395d333078f97cdaff1a28129.png" width="936" referrerpolicy="no-referrer"></p><p><img height="1488" src="https://oscimg.oschina.net/oscnet/up-77f78a766c7e070b24b239150c9ec5de38f.png" width="934" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-dd98b736f8b6a5c76679267826d5058dada.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:01:17 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270052</guid>
            <link>https://www.oschina.net/news/270052</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[支付寶啓動鴻蒙原生應用開發]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>支付寶與華為終端宣佈合作，基於 HarmonyOS NEXT 啓動支付寶鴻蒙原生應用開發。</p><p><img alt="" height="326" src="https://oscimg.oschina.net/oscnet/up-a9aa0abdc54a1c436a2c973752477f7b5a2.webp" width="500" referrerpolicy="no-referrer"></p><p>支付寶事業羣總裁倪行軍表示，雙方的合作將進一步滿足用户在不同終端、不同場景下享受智慧生活服務的需求；同時，華為在支付寶小程序領域的數字化佈局也有利於提升商家在兩個生態中的經營效率。</p><p><span style="background-color:#ffffff; color:#2b2b2b">支付寶目前服務商家已達 8000 萬。通過支付寶 App，有近 400 萬個商家機構小程序，掃碼點單、生活繳費等超過 1000 項生活服務。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 02:36:17 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270047</guid>
            <link>https://www.oschina.net/news/270047</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米發佈《小米澎湃 OS 技術白皮書》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米正式發佈《小米澎湃 OS 技術白皮書》（下簡稱《白皮書》）。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-7edcacdddcb86895ce723541906e9102497.png" referrerpolicy="no-referrer"></p><p><strong><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcdn-file.hyperos.mi.com%2Fhyperos-file%2F%25E5%25B0%258F%25E7%25B1%25B3%25E6%25BE%258E%25E6%25B9%2583OS%25E6%258A%2580%25E6%259C%25AF%25E7%2599%25BD%25E7%259A%25AE%25E4%25B9%25A6V1.0.pdf" target="_blank">小米澎湃 OS 技術白皮書 V1.0</a></em></u></strong></p></blockquote><p>根據《白皮書》介紹，小米澎湃 OS 是一個為下一代的計算與多種設備生態設計的系統。</p><p><span style="background-color:rgba(255, 255, 255, 0.65); color:#151631">《白皮書》</span>對小米澎湃 OS 系統架構進行了詳細介紹、包括對各個子系統的架構以及關鍵技術的闡述，以及開發團隊對各個子系統的設計思路。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1dff4e9939fb63c6ac59b0c14f3aa700571.png" referrerpolicy="no-referrer"></p><p>小米表示：「希望通過分享這些技術成果和見解，激發更多的創意和合作，推動整個行業的進步，共同構建「人車家全生態」的未來。」</p><p>小米 CEO 雷軍在《白皮書》的序言中説道，2016 年，小米就開始研發跨端應用框架。2019 年，開始並行研發純自研通用系統 Mina OS，並在部分產品上小規模量產驗證，同時在實驗室中也成功在手機上跑通，其中部分技術成果也已融入小米澎湃 OS。2021 年，小米開啓了車機 OS 的研發。2022 年初，小米決定統一 MIUI、Vela、Mina、車機 OS 四個系統的軟件架構。自此，小米的操作系統底層合併完成。</p><blockquote><p><img height="1690" src="https://oscimg.oschina.net/oscnet/up-2b2e2aa832685a84d24571029ea1b7cccf2.png" width="1760" referrerpolicy="no-referrer"></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 02:32:17 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270045</guid>
            <link>https://www.oschina.net/news/270045</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux 內核源代碼官網 git.kernel.org 原生支持深色模式]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Linux 內核開發者收到了一份提前的聖誕禮物 ——&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgit.kernel.org%2F" target="_blank">git.kernel.org</a>&nbsp;Web 界面已原生支持深色模式。對於開發者來説，深色模模式可以增強瀏覽官方 Linux 內核 Git 倉庫，以及其他開發分支的查看體驗。</p><p><img src="https://oscimg.oschina.net/oscnet/up-7e14e90ceb4a018a01f4aebacdc75e3f470.png" referrerpolicy="no-referrer"></p><p>從提交記錄可以看到，幾個月前就已經有補丁將 CSS 暗模式支持添加到 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fgit.kernel.org" target="_blank">git.kernel.org</a> cgit Web 界面，現在終於上線了。</p><p><img src="https://oscimg.oschina.net/oscnet/up-514a596f11bc68a1ff4ba9c95167bba29c7.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 02:18:17 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270043</guid>
            <link>https://www.oschina.net/news/270043</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 前後端分離的全棧開源項目 AirPower]]>
            </title>
            <description>
                <![CDATA[<p align="center"><img width="300" src="https://gitee.com/air-power/AirPower4T/raw/web/assets/img/airpower.png" referrerpolicy="no-referrer"></p><p align="center"><img src="https://svg.hamm.cn/?key=Lang&amp;value=TypeScript&amp;bg=green" referrerpolicy="no-referrer"><img src="https://svg.hamm.cn/?key=Base&amp;value=Vue3" referrerpolicy="no-referrer"><img src="https://svg.hamm.cn/?key=Build&amp;value=Vite" referrerpolicy="no-referrer"><img src="https://svg.hamm.cn/?key=UI&amp;value=ElementPlus" referrerpolicy="no-referrer"></p><p><a href="https://gitee.com/air-power/AirPower4T">Gitee</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FHammCn%2FAirPower4T">Github</a> / <a href="https://gitee.com/air-power/AirPower4T/blob/web/CHANGELOG.md">CHANGELOG</a></p><h2><a id="user-content--這是個什麼項目" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E8%BF%99%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%A1%B9%E7%9B%AE"></a>📖 這是個什麼項目</h2><blockquote><p>你當前查看的是 <code>web</code> 分支，我們也同時提供了 <code>wechat</code>、<code>uniapp</code> 等分支：） 你可以先閲讀 <a href="https://gitee.com/link?target=https%3A%2F%2Fjuejin.cn%2Fpost%2F7273290114921889807">掘金專欄</a> 的一些文章，也可以體驗 <a href="https://gitee.com/link?target=https%3A%2F%2Fservice.hamm.cn">線上示例 DEMO</a>，如果你喜歡這個項目，歡迎給我們大大的 ⭐️⭐️⭐️</p></blockquote><p>為了滿足前端開發標準化、工程化、系統化等等需求，我們設計並開發了一個開發組件庫和常用類庫和方法庫的集合基礎腳手架，其中包含了一些頁面通用的佈局、常用的彈窗和交互、提示信息以及網絡請求，強類型面向對象的約束規範等，以滿足日常開發的快捷、穩健、標準化等要求。</p><p><strong>AirPower</strong> 是一個基於 <code>Vue3</code><code>TypeScript</code><code>Element Plus</code><code>Vite</code> 的開發基礎庫，使用 <strong>裝飾器</strong>、<strong>面向對象</strong>、<strong>Hook</strong> 等前端開發方式。</p><h2><a id="user-content--為何起名 airpower" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E4%B8%BA%E4%BD%95%E8%B5%B7%E5%90%8Dairpower"></a>🎈 為何起名<strong>AirPower</strong></h2><p>早期是子倉庫方式的設計, 這個依賴庫跟宿主項目在一起, 所以為了排前面, 選擇使用<strong>A</strong>開頭的單詞, 後來想起 <strong>Apple</strong> 家難產了的一個產品的名稱, <strong>AirPower</strong>, 作者是 Apple 十年老粉, 那就順便致敬下 <strong>Apple</strong>.</p><h2><a id="user-content--有哪些功能設計" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1"></a>🎉 有哪些功能 (設計)</h2><ol><li><strong>Model</strong> / <strong>Entity</strong> 所有的數據交互都以數據模型實例的方式進行, 不再直接使用 JSON.</li><li><strong>Service</strong> 使用服務類對所有的網絡請求進行抽象, 通過繼承方式實現相似代碼的複用</li><li><strong>Component</strong> 提供了很多後台管理系統常用的組件和一些反饋組件</li><li><strong>Hook</strong> 提供了與 Service 交互的一些通用的交互 Hooks</li><li><strong>Enum</strong> 提供了很多很多很多的枚舉</li><li><strong>Decorator</strong> 提供了很多很多很多的裝飾器</li><li>提供了類似 <strong>Java</strong> BeanCopy 相關的數據轉換方式, 提供了完整的面向對象實現</li><li>......</li></ol><h2><a id="user-content--代碼風格展示" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%B1%95%E7%A4%BA"></a>💻 代碼風格展示</h2><p><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/1.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/2.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/3.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/4.png" referrerpolicy="no-referrer"></p><h2><a id="user-content--如何使用初始化" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96"></a>🔑 如何使用 (初始化)?</h2><p>你可以通過我們提供的 <code>AirPower 宿主倉庫</code> 項目來完成 <strong>AirPower</strong> 宿主項目的初始化:</p><p>AirPowerWebStarter via <a href="https://gitee.com/air-power/AirPowerWebStarter/blob/main/README.md">Gitee</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FHammCn%2FAirPowerWebStarter%2Fblob%2Fmain%2FREADME.md">Github</a></p><h2><a id="user-content--我們的建議" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E6%88%91%E4%BB%AC%E7%9A%84%E5%BB%BA%E8%AE%AE"></a>🛎 我們的建議</h2><p>我們提供的 <strong>AirPower 宿主倉庫</strong> 裏面提供了一些 <code>ESlint 規則</code><code>路由配置</code><code>環境變量配置</code><code>tsconfig</code><code>vite.config</code>, 以及很多的 <strong>demo</strong> 代碼, 你可以進行參考。</p><p>如果你有什麼疑問或者問題，你也可以加入開發者交流 QQ 羣 (<code>555156313</code>) 進行諮詢，當然，我們更建議你發起 <a href="https://gitee.com/air-power/AirPower4T/issues/new">Gitee issue</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FHammCn%2FAirPower4T%2Fissues%2Fnew">Github issue</a></p><h2><a id="user-content--enjoy-it" class="anchor" href="https://gitee.com/air-power/AirPower4T#-enjoy-it"></a>⏰ Enjoy it</h2><p>好了, 那麼接下來你可以愉快的開發了, 如果你有什麼建議或者意見, 可以在本倉庫中提交你的 <strong>issues</strong>, 你可以為這個依賴庫進行 <strong>添磚加瓦</strong>!</p><blockquote><p>☕️Java: 加瓦? 什麼 Java?</p></blockquote><h2><a id="user-content--來點圖示例" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E6%9D%A5%E7%82%B9%E5%9B%BE%E7%A4%BA%E4%BE%8B"></a>📷 來點*圖 (示例)</h2><p><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/5.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/6.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/7.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/8.png" referrerpolicy="no-referrer"></p>]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 10:39:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/air-power/AirPower4T</guid>
            <link>https://gitee.com/air-power/AirPower4T</link>
        </item>
        <item>
            <title>
                <![CDATA[周星馳 Web3 團隊下個月上線獨立 App]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>12 月 7 日，新浪科技報道稱，周星馳 Web3 團隊透露，周星馳旗下 Web3 初創公司 Moonbox&nbsp;最早將於明年 1 月份完成上線 Moonbox App，屆時 App 將免費向用户開放。</p><p>目前，App 研發工作已經基本完成，Moonbox 團隊在 NFT 玩法上下了很多功夫，已設計出基於 AI 和 NFT 聊天的互動玩法，「周星馳將以 Moonbox First Creator 身份與大家見面」。</p><p>與此同時，周星馳參與創作的 NobodyNFT 新品，也將隨之發售，用户可以通過 App 和每個 Nobody NFT 角色聊天互動以瞭解人物性格、愛好、背景故事。</p><p>據悉，2023 年 8 月，周星馳曾公開宣佈入局 Web3+AI，並第一時間與 OKX 進行互動。周星馳當時在 INS 發文稱，「感恩找到一班志同道合的 Web3 夥伴，正在研究 Web3+AI 項目，希望做個我的 AI 代替我。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1fa24c9504d7b6c03e1cf018b165b6154e6.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 09:06:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269952</guid>
            <link>https://www.oschina.net/news/269952</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[新概念「防禦性編程」：讓自己穩拿鐵飯碗]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img height="559" src="https://static.oschina.net/uploads/space/2023/1207/164342_Cpqj_3820517.png" width="400" referrerpolicy="no-referrer"></p><p>&nbsp;</p><blockquote><p>譯者：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FcoderLMN" target="_blank"><span style="color:#3498db"><span style="background-color:#fdfdfd">/coderLMN</span></span></a></p><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>翻譯鏈接：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcoderlmn.github.io%2FfrontEndCourse%2Funmaintainable.html" target="_blank">https://coderlmn.github.io/frontEndCourse/unmaintainable.html</a></p></blockquote><hr><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>讓自己穩拿鐵飯碗 ;-)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><p><strong>-- Roedy Green</strong><br><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>（老碼農翻譯，略有刪節）</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br> &nbsp;</p><hr><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>簡介</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>永遠不要（把自己遇到的問題）歸因於（他人的）惡意，這恰恰説明瞭（你自己的）無能。&nbsp;</em>-- 拿破崙</p></blockquote><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>為了造福大眾，在 Java 編程領域創造就業機會，兄弟我在此傳授大師們的秘籍。這些大師寫的代碼極其難以維護，後繼者就是想對它做最簡單的修改都需要花上數年時間。而且，如果你能對照秘籍潛心修煉，你甚至可以給自己弄個鐵飯碗，因為除了你之外，沒人能維護你寫的代碼。再而且，如果你能練就秘籍中的<strong>全部</strong>招式，那麼連你自己都無法維護你的代碼了！</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>你不想練功過度走火入魔吧。那就不要讓你的代碼<strong>一眼看去</strong>就完全無法維護，只要它<strong>實質上是</strong>那樣就行了。否則，你的代碼就有被重寫或重構的風險！</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>總體原則</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>Quidquid latine dictum sit, altum sonatur.</em><br> (隨便用拉丁文寫點啥都會顯得高大上。)</p></blockquote><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>想挫敗維護代碼的程序員，你必須先明白他的思維方式。他接手了你的龐大程序，沒有時間把它全部讀一遍，更別説理解它了。他無非是想快速找到修改代碼的位置、改代碼、編譯，然後就能交差，並希望他的修改不會出現意外的副作用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>他查看你的代碼不過是管中窺豹，一次只能看到一小段而已。你要確保他永遠看不到全貌。要儘量和讓他難以找到他想找的代碼。但更重要的是，要讓他不能有把握<strong>忽略</strong>任何東西。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>程序員都被編程慣例洗腦了，還為此自鳴得意。每一次你處心積慮地違背編程慣例，都會迫使他必須用放大鏡去仔細閲讀你的每一行代碼。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>你可能會覺得每個語言特性都可以用來讓代碼難以維護，其實不然。你必須精心地誤用它們才行。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>命名</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>"當我使用一個單詞的時候" Humpty Dumpty 曾經用一種輕蔑的口氣説, "它就是我想表達的意思，不多也不少。「</em><br> - Lewis Carroll -- 《愛麗絲魔鏡之旅》， 第 6 章</p></blockquote><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>編寫無法維護代碼的技巧的重中之重是變量和方法命名的藝術。如何命名是和編譯器無關的。這就讓你有巨大的自由度去利用它們迷惑維護代碼的程序員。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>妙用&nbsp;寶寶起名大全</h4><p>買本寶寶起名大全，你就永遠不缺變量名了。比如&nbsp;<span style="color:#000099"><span>Fred</span></span>&nbsp;就是個好名字，而且鍵盤輸入它也省事。如果你就想找一些容易輸入的變量名，可以試試&nbsp;<span style="color:#000099"><span>adsf</span></span>&nbsp;或者&nbsp;<span style="color:#000099"><span>aoeu</span></span>之類。</p><h4>單字母變量名</h4><p>如果你給變量起名為 a,b,c，用簡單的文本編輯器就沒法搜索它們的引用。而且，沒人能猜到它們的含義。</p><h4>創造性的拼寫錯誤</h4><p>如果你必須使用描述性的變量和函數名，那就把它們都拼錯。還可以把某些函數和變量名拼錯，再把其他的拼對 (例如 SetPintleOpening 和 SetPintalClosing) ，我們就能有效地將 grep 或 IDE 搜索技術玩弄於股掌之上。這招超級管用。還可以混淆不同語言（比如<em>colour</em>&nbsp;-- 英國英語，和&nbsp;<em>color</em>&nbsp;-- 美國英語)。</p><h4>抽象</h4><p>在命名函數和變量的時候，充分利用抽象單詞，例如&nbsp;<em>it</em>,&nbsp;<em>everything</em>,&nbsp;<em>data</em>,&nbsp;<em>handle</em>,&nbsp;<em>stuff</em>,&nbsp;<em>do</em>,&nbsp;<em>routine</em>,&nbsp;<em>perform</em>&nbsp;和數字，例如 e.g.&nbsp;<span style="color:#000099"><span>routineX48</span></span>,&nbsp;<span style="color:#000099"><span>PerformDataFunction</span></span>,&nbsp;<span style="color:#000099"><span>DoIt</span></span>,&nbsp;<span style="color:#000099"><span>HandleStuff</span></span>&nbsp;還有&nbsp;<span style="color:#000099"><span>do_args_method</span></span>。</p><h4>首字母大寫的縮寫</h4><p>用首字母大寫縮寫（比如 GNU 代表 GNU's Not Unix) 使代碼簡潔難懂。真正的漢子 (無論男女) 從來不説明這種縮寫的含義，他們生下來就懂。</p><h4>辭典大輪換</h4><p>為了打破沉悶的編程氣氛，你可以用一本辭典來查找儘量多的同義詞。例如&nbsp;<em>display</em>,&nbsp;<em>show</em>,&nbsp;<em>present</em>。在註釋裏含糊其辭地暗示這些命名之間有細微的差別，其實根本沒有。不過，如果有兩個命名相似的函數真的有重大差別，那倒是一定要確保它們用相同的單詞來命名 (例如，對於 "寫入文件", "在紙上書寫" 和 "屏幕顯示" 都用&nbsp;<em>print</em>&nbsp;來命名)。 在任何情況下都不要屈服於編寫明確的項目詞彙表這種無理要求。你可以辯解説，這種要求是一種不專業的行為，它違反了結構化設計的<em>信息隱藏原則</em>。</p><h4>首字母大寫</h4><p>隨機地把單詞中間某個音節的首字母大寫。例如&nbsp;<span style="color:#000099"><span>ComputeReSult()</span></span>。</p><h4>重用命名</h4><p>在語言規則允許的地方，儘量把類、構造器、方法、成員變量、參數和局部變量都命名成一樣。更高級的技巧是在{}塊中重用局部變量。這樣做的目的是迫使維護代碼的程序員認真檢查每個示例的範圍。特別是在 Java 代碼中，可以把普通方法偽裝成構造器。</p><h4>使用非英語字母</h4><p>在命名中偷偷使用不易察覺的非英語字母，例如看上去沒啥不對是吧？嘿嘿嘿...這裏的第二個 ínt 的&nbsp;<strong>í</strong>&nbsp;實際上是東北歐字母，並不是英語中的 i 。在簡單的文本編輯器裏，想看出這一點點區別幾乎是不可能的。</p><h4>巧妙利用編譯器對於命名長度的限制</h4><p>如果編譯器只區分命名的前幾位，比如前 8 位，那麼就把後面的字母寫得不一樣。比如，其實是同一個變量，有時候寫成&nbsp;<em>var_unit_update()</em>&nbsp;，有時候又寫成&nbsp;<em>var_unit_setup()</em>，看起來是兩個不同的函數調用。而在編譯的時候，它們其實是同一個變量&nbsp;<em>var_unit</em>。</p><h4>下劃線，一位真正的朋友</h4><p>可以拿 _ 和 __ 作為標示符。</p><h4>混合多語言</h4><p>隨機地混用兩種語言（人類語言或計算機語言都行）。如果老闆要求使用他指定的語言，你就告訴他你用自己的語言更有利於組織你的思路，萬一這招不管用，就去控訴這是語言歧視，並威脅起訴老闆要求鉅額精神損失賠償。</p><h4>擴展 ASCII 字符</h4><p>擴展 ASCII 字符用於變量命名是完全合法的，包括 ß, Ð, 和 ñ 等。在簡單的文本編輯器裏，除了拷貝/粘貼，基本上沒法輸入。</p><h4>其他語言的命名</h4><p>使用外語字典作為變量名的來源。例如，可以用德語單詞&nbsp;<em>punkt</em>&nbsp;代替&nbsp;<em>point</em>。除非維護代碼的程序員也像你一樣熟練掌握了德語. 不然他就只能盡情地在代碼中享受異域風情了。</p><h4>數學命名</h4><p>用數學操作符的單詞來命名變量。例如：</p><p>openParen<span>&nbsp;</span><strong>=</strong><span>&nbsp;</span>(slash<span>&nbsp;</span><strong>+</strong><span>&nbsp;</span>asterix)<span>&nbsp;</span><strong>/</strong><span>&nbsp;</span>equals;<br> (左圓括號 = (斜槓 + 星號)/等號;)</p><h4>令人眩暈的命名</h4><p>用帶有完全不相關的感情色彩的單詞來命名變量。例如：這一招可以讓閲讀代碼的人陷入迷惑之中，因為他們在試圖想清楚這些命名的邏輯時，會不自覺地聯繫到不同的感情場景裏而無法自拔。</p><p>marypoppins<span>&nbsp;</span><strong>=</strong><span>&nbsp;</span>(superman<span>&nbsp;</span><strong>+</strong><span>&nbsp;</span>starship)<span>&nbsp;</span><strong>/</strong><span>&nbsp;</span>god;<br> (歡樂滿人間 = (超人 + 星河戰隊)/上帝;)</p><h4>何時使用 i</h4><p>永遠不要把&nbsp;<span style="color:#000099"><span>i</span></span>&nbsp;用作最內層的循環變量。 用什麼命名都行，就是別用<span style="color:#000099"><span>i</span></span>。把&nbsp;<span style="color:#000099"><span>i</span></span>&nbsp;用在其他地方就隨便了，用作非整數變量尤其好。</p><h4>慣例 -- 明修棧道，暗度陳倉</h4><p>忽視&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fjava.sun.com%2Fdocs%2Fcodeconv%2F" target="_blank">Java 編碼慣例</a>，Sun 就是這樣做的。幸運的是，你違反了它編譯器也不會打小報告。這一招的目的是搞出一些在某些特殊情況下有細微差別的名字來。如果你被強迫遵循駝峯法命名，你還是可以在某些模稜兩可的情況下顛覆它。例如，<em>input<strong>F</strong>ile<strong>n</strong>ame</em>&nbsp;和&nbsp;<em>input<strong>f</strong>ile<strong>N</strong>ame</em>&nbsp;兩個命名都可以合法使用。在此基礎上自己發明一套複雜到變態的命名慣例，然後就可以痛扁其他人，説他們違反了慣例。</p><h4>小寫的 l 看上去很像數字 1</h4><p>用小寫字母 l 標識 long 常數。例如 10l 更容易被誤認為是 101 而不是 10L 。 禁用所有能讓人準確區分 uvw wW gq9 2z 5s il17|!j oO08 `'" ;,. m nn rn {[()]} 的字體。要做個有創造力的人。</p><h4>把全局命名重用為私有</h4><p>在 A 模塊裏聲明一個全局數組，然後在 B 模塊的頭文件裏在聲明一個同名的私有數組，這樣看起來你在 B 模塊裏引用的是那個全局數組，其實卻不是。不要在註釋裏提到這個重複的情況。</p><h4>誤導性的命名</h4><p>讓每個方法都和它的名字藴含的功能有一些差異。例如，一個叫&nbsp;<span style="color:#000099"><span>isValid(x)</span></span>的方法在判斷完參數 x 的合法性之後，還順帶着把它轉換成二進制並保存到數據庫裏。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>偽裝</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>當一個 bug 需要越長的時間才會暴露，它就越難被發現。</em><br> - Roedy Green（本文作者）</p></blockquote><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>編寫無法維護代碼的另一大秘訣就是偽裝的藝術，即隱藏它或者讓它看起來像其他東西。很多招式有賴於這樣一個事實：編譯器比肉眼或文本編輯器更有分辨能力。下面是一些偽裝的最佳招式。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>把代碼偽裝成註釋，反之亦然</h4><p>下面包括了一些被註釋掉的代碼，但是一眼看去卻像是正常代碼。 如果不是用綠色標出來，你能注意到這三行代碼被註釋掉了麼？</p><pre><code>for(j=0; j&lt;array_len; j+ =8)
    {
    total += array[j+0 ];
    total += array[j+1 ];
    total += array[j+2 ]; /* Main body of
    total += array[j+3]; * loop is unrolled
    total += array[j+4]; * for greater speed.
    total += array[j+5]; */
    total += array[j+6 ];
    total += array[j+7 ];
    }</code></pre><h4>用連接符隱藏變量</h4><p>對於下面的定義</p><p>#define local_var xy_z</p><p>可以把 "xy_z" 打散到兩行裏：</p><p>#define local_var xy\<br> _z // local_var OK</p><p>這樣全局搜索 xy_z 的操作在這個文件裏就一無所獲了。 對於 C 預處理器來説，第一行最後的 "\" 表示繼續拼接下一行的內容。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>文檔</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><em>任何傻瓜都能説真話，而要把謊編圓則需要相當的智慧。</em><br> - Samuel Butler (1835 - 1902)
</blockquote><p style="text-align:start">&nbsp;</p><blockquote><em>不正確的文檔往往比沒有文檔還糟糕。</em><br> - Bertrand Meyer
</blockquote><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>既然計算機是忽略註釋和文檔的，你就可以在裏邊堂而皇之地編織彌天大謊，讓可憐的維護代碼的程序員徹底迷失。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>在註釋中撒謊</h4><p>實際上你不需要主動地撒謊，只要沒有及時保持註釋和代碼更新的一致性就可以了。</p><h4>只記錄顯而易見的東西</h4><p>往代碼裏摻進去類似於&nbsp;<span style="color:green">/* 給 i 加 1 */</span>&nbsp;這樣的註釋，但是永遠不要記錄包或者方法的整體設計這樣的乾貨。 &nbsp;</p><h4>記錄 How 而不是 Why</h4><p>只解釋一個程序功能的細節，而不是它要完成的任務是什麼。這樣的話，如果出現了一個 bug，修復者就搞不清這裏的代碼應有的功能。</p><h4>該寫的別寫</h4><p>比如你在開發一套航班預定系統，那就要精心設計，讓它在增加另一個航空公司的時候至少有 25 處代碼需要修改。永遠不要在文檔裏説明要修改的位置。後來的開發人員要想修改你的代碼門都沒有，除非他們能把每一行代碼都讀懂。</p><h4>計量單位</h4><p>永遠不要在文檔中説明任何變量、輸入、輸出或參數的計量單位，如英尺、米、加侖等。計量單位對數豆子不是太重要，但在工程領域就相當重要了。同理，永遠不要説明任何轉換常量的計量單位，或者是它的取值如何獲得。要想讓代碼更亂的話，你還可以在註釋裏寫上錯誤的計量單位，這是赤裸裸的欺騙，但是非常有效。如果你想做一個惡貫滿盈的人，不妨自己發明一套計量單位，用自己或某個小人物的名字命名這套計量單位，但不要給出定義。萬一有人挑刺兒，你就告訴他們，你這麼做是為了把浮點數運算湊成整數運算而進行的轉換。 &nbsp;</p><h4>坑</h4><p>永遠不要記錄代碼中的坑。如果你懷疑某個類裏可能有 bug，天知地知你知就好。如果你想到了重構或重寫代碼的思路，看在老天爺的份上，千萬別寫出來。切記電影《小鹿斑比》裏那句台詞&nbsp;<em>"如果你不能説好聽的話，那就什麼也不要説。"</em>。萬一這段代碼的原作者看到你的註釋怎麼辦？萬一老闆看到了怎麼辦？萬一客户看到了怎麼辦？搞不好最後你自己被解僱了。一句」這裏需要修改「的匿名註釋就好多了，尤其是當看不清這句註釋指的是哪裏需要修改的情況下。切記難得糊塗四個字，這樣大家都不會感覺受到了批評。 &nbsp;</p><h4>説明變量</h4><p><strong>永遠不要</strong>&nbsp;對變量聲明加註釋。有關變量使用的方式、邊界值、合法值、小數點後的位數、計量單位、顯示格式、數據錄入規則等等，後繼者完全可以自己從程序代碼中去理解和整理嘛。如果老闆強迫你寫註釋，就把方法體代碼混進去，但絕對不要對變量聲明寫註釋，即使是臨時變量！</p><h4>在註釋裏挑撥離間</h4><p>為了阻撓任何僱傭外部維護承包商的傾向，可以在代碼中散佈針對其他同行軟件公司的攻擊和抹黑，特別是可能接替你工作的其中任何一家。例如：</p><p><span style="color:green">/* 優化後的內層循環<br> 這套技巧對於 SSI 軟件服務公司的那幫蠢材來説太高深了，他們只會<br> 用 &lt;math.h&gt; 裏的笨例程，消耗 50 倍的內存和處理時間。<br> */</span><br> class&nbsp;<strong>clever_SSInc</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;{<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;..</strong>&nbsp;<strong>.</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;}</p><p><span>可能的話，除了註釋之外，這些攻擊抹黑的內容也要摻到代碼裏的重要部分，這樣如果管理層想清理掉這些攻擊性的言論然後發給外部承包商去維護，就會破壞代碼結構。</span></p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>程序設計</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><em>編寫無法維護代碼的基本規則就是：在儘可能多的地方，以儘可能多的方式表述每一個事實。</em><br> - Roedy Green
</blockquote><p style="text-align:start">編寫可維護代碼的關鍵因素是隻在一個地方表述應用裏的一個事實。如果你的想法變了，你也只在一個地方修改，這樣就能保證整個程序正常工作。所以，編寫無法維護代碼的關鍵因素就是反覆地表述同一個事實，在儘可能多的地方，以儘可能多的方式進行。令人高興的是，像 Java 這樣的語言讓編寫這種無法維護代碼變得非常容易。例如，改變一個被引用很多的變量的類型幾乎是不可能的，因為所有造型和轉換功能都會出錯，而且關聯的臨時變量的類型也不合適了。而且，如果變量值要在屏幕上顯示，那麼所有相關的顯示和數據錄入代碼都必須一一找到並手工進行修改。類似的還有很多，比如由 C 和 Java 組成的 Algol 語言系列，Abundance 甚至 Smalltalk 對於數組等結構的處理，都是大有可為的。</p><h4>Java 造型</h4><p>Java 的造型機制是上帝的禮物。你可以問心無愧地使用它，因為 Java 語言本身就需要它。每次你從一個 Collection 裏獲取一個對象，你都必須把它造型為原始類型。這樣這個變量的類型就必須在無數地方表述。如果後來類型變了，所有的造型都要修改才能匹配。如果倒黴的維護代碼的程序員沒有找全（或者修改太多），編譯器能不能檢測到也不好説。類似的，如果變量類型從<span style="color:#000099"><span>short</span></span>&nbsp;變成&nbsp;<span style="color:#000099"><span>int</span></span>，所有匹配的造型也都要從<span style="color:#000099"><span>(short)</span></span>&nbsp;改成&nbsp;<span style="color:#000099"><span>(int)</span></span>。</p><h4>利用 Java 的冗餘</h4><p>Java 要求你給每個變量的類型寫兩次表述。 Java 程序員已經習慣了這種冗餘，他們不會注意到你的兩次表述有細微的差別，例如</p><p>Bubbleg<em>u</em>m<span>&nbsp;</span><strong>b</strong><span>&nbsp;</span><strong>=</strong><span>&nbsp;</span>new Bubbleg<em>o</em>m();</p><p>不幸的是 ++ 操作符的盛行讓下面這種偽冗餘代碼得手的難度變大了：</p><p>swim<em>m</em>er<span>&nbsp;</span><strong>=</strong><span>&nbsp;</span>swim<em>n</em>er<span>&nbsp;</span><strong>+</strong><span>&nbsp;</span>1;</p><h4>永遠不做校驗</h4><p>永遠不要對輸入數據做任何的正確性或差異性檢查。這樣能表現你對公司設備的絕對信任，以及你是一位信任所有項目夥伴和系統管理員的團隊合作者。總是返回合理的值，即使數據輸入有問題或者錯誤。 &nbsp;</p><h4>有禮貌，無斷言</h4><p>避免使用 assert() 機制，因為它可能把三天的 debug 盛宴變成 10 分鐘的快餐。</p><h4>避免封裝</h4><p>為了提高效率，不要使用封裝。方法的調用者需要所有能得到的外部信息，以便了解方法的內部是如何工作的。 &nbsp;</p><h4>複製粘貼修改</h4><p>以效率的名義，使用，複製+粘貼+修改。這樣比寫成小型可複用模塊效率高得多。在用代碼行數衡量你的進度的小作坊裏，這招尤其管用。</p><h4>使用靜態數組</h4><p>如果一個庫裏的模塊需要一個數組來存放圖片，就定義一個靜態數組。沒人會有比 512 X 512 更大的圖片，所以固定大小的數組就可以了。為了最佳精度，就把它定義成 double 類型的數組。 &nbsp;</p><h4>傻瓜接口</h4><p>編寫一個名為 "WrittenByMe" 之類的空接口，然後讓你的所有類都實現它。然後給所有你用到的 Java 內置類編寫包裝類。這裏的思想是確保你程序裏的每個對象都實現這個接口。最後，編寫所有的方法，讓它們的參數和返回類型都是這個 WrittenByMe。這樣就幾乎不可能搞清楚某個方法的功能是什麼，並且所有類型都需要好玩的造型方法。更出格的玩法是，讓每個團隊成員編寫它們自己的接口 (例如 WrittenByJoe)，程序員用到的任何類都要實現他自己的接口。這樣你就可以在大量無意義接口中隨便找一個來引用對象了。</p><h4>巨型監聽器</h4><p>永遠不要為每個組件創建分開的監聽器。對所有按鈕總是用同一個監聽器，只要用大量的 if...else 來判斷是哪一個按鈕被點擊就行了。 &nbsp;</p><h4>好事成堆 TM</h4><p>狂野地使用封裝和 OO 思想。例如，這段很可能看起來不怎麼好笑。別擔心，只是時候未到而已。</p><p>myPanel<strong>.</strong>add( getMyButton<strong>(</strong><strong>)</strong>&nbsp;);<br> private JButton&nbsp;<strong>getMyButton</strong>()</p><p>&nbsp;&nbsp;&nbsp;&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;return myButton;<br> &nbsp;&nbsp;&nbsp;&nbsp;}</p><h4>友好的朋友</h4><p>在 C++ 裏儘量多使用 friend 聲明。再把創建類的指針傳遞給已創建類。現在你不用浪費時間去考慮接口了。另外，你應該用上關鍵字<em>private</em>&nbsp;和&nbsp;<em>protected</em>&nbsp;來表明你的類封裝得很好。</p><h4>使用三維數組</h4><p>大量使用它們。用扭曲的方式在數組之間移動數據，比如，用 arrayA 裏的行去填充 arrayB 的列。這麼做的時候，不管三七二十一再加上 1 的偏移值，這樣很靈。讓維護代碼的程序員抓狂去吧。 &nbsp;</p><h4>混合與匹配</h4><p>存取方法和公共變量神馬的都要給他用上。這樣的話，你無需調用存取器的開銷就可以修改一個對象的變量，還能宣稱這個類是個"Java Bean"。對於那些試圖添加日誌函數來找出改變值的源頭的維護代碼的程序員，用這一招來迷惑他尤其有效。 &nbsp;</p><h4>沒有秘密!</h4><p>把每個方法和變量都聲明為 public。畢竟某個人某天可能會需要用到它。一旦方法被聲明為 public 了，就很難縮回去。對不？這樣任何它覆蓋到的代碼都很難修改了。它還有個令人愉快的副作用，就是讓你看不清類的作用是什麼。如果老闆質問你是不是瘋了，你就告訴他你遵循的是經典的透明接口原則。</p><h4>全堆一塊</h4><p>把你所有的沒用的和過時的方法和變量都留在代碼裏。畢竟説起來，既然你在 1976 年用過一次，誰知道你啥時候會需要再用到呢？當然程序是改了，但它也可能會改回來嘛，你"不想要重新發明輪子"（領導們都會喜歡這樣的口氣）。如果你還原封不動地留着這些方法和變量的註釋，而且註釋寫得又高深莫測，甭管維護代碼的是誰，恐怕都不敢對它輕舉妄動。</p><h4>就是 Final</h4><p>把你所有的葉子類都聲明為 final。畢竟説起來，你在項目裏的活兒都幹完了，顯然不會有其他人會通過擴展你的類來改進你的代碼。這種情況甚至可能有安全漏洞。 java.lang.String 被定義成 final 也許就是這個原因吧？如果項目組其他程序員有意見，告訴他們這樣做能夠提高運行速度。</p><h4>避免佈局</h4><p>永遠不要用到佈局。當維護代碼的程序員想增加一個字段，他必須手工調整屏幕上顯示所有內容的絕對座標值。如果老闆強迫你使用佈局，那就寫一個巨型的 GridBagLayout 並在裏面用絕對座標進行硬編碼。</p><h4>全局變量，怎麼強調都不過分</h4><p>如果上帝不願意我們使用全局變量，他就不會發明出這個東西。不要讓上帝失望，儘量多使用全局變量。每個函數最起碼都要使用和設置其中的兩個，即使沒有理由也要這麼做。畢竟，任何優秀的維護代碼的程序員都會很快搞清楚這是一種偵探工作測試，有利於讓他們從笨蛋中脱穎而出。 &nbsp;</p><h4>再一次説説全局變量</h4><p>全局變量讓你可以省去在函數裏描述參數的麻煩。充分利用這一點。在全局變量中選那麼幾個來表示對其他全局變量進行操作的類型。</p><h4>局部變量</h4><p>永遠不要用局部變量。在你感覺想要用的時候，把它改成一個實例或者靜態變量，並無私地和其他方法分享它。這樣做的好處是，你以後在其他方法裏寫類似聲明的時候會節省時間。C++程序員可以百尺竿頭更進一步，把所有變量都弄成全局的。</p><h4>配置文件</h4><p>配置文件通常是以，關鍵字 = 值，的形式出現。在加載時這些值被放入 Java 變量中。最明顯的迷惑技術就是把有細微差別的名字用於關鍵字和 Java 變量.甚至可以在配置文件裏定義運行時根本不會改變的常量。參數文件變量和簡單變量比，維護它的代碼量起碼是後者的 5 倍。</p><h4>子類</h4><p>對於編寫無法維護代碼的任務來説，面向對象編程的思想簡直是天賜之寶。如果你有一個類，裏邊有 10 個屬性（成員/方法），可以考慮寫一個基類，裏面只有一個屬性，然後產生 9 層的子類，每層增加一個屬性。等你訪問到最終的子類時，你才能得到全部 10 個屬性。如果可能，把每個類的聲明都放在不同的文件裏。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>編碼迷局</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><h4>迷惑 C</h4><p>從互聯網上的各種混亂 C 語言競賽中學習，追隨大師們的腳步。</p><h4>追求極致</h4><p>總是追求用最迷惑的方式來做普通的任務。例如，要用數組來把整數轉換為相應的字符串，可以這麼做：</p><p>char *p;<br> switch (n)<br> {<br> case 1:<br> &nbsp;&nbsp;&nbsp;&nbsp;p = "one";<br> &nbsp;&nbsp;&nbsp;&nbsp;if (0)<br> case 2:<br> &nbsp;&nbsp;&nbsp;&nbsp;p = "two";<br> &nbsp;&nbsp;&nbsp;&nbsp;if (0)<br> case 3:<br> &nbsp;&nbsp;&nbsp;&nbsp;p = "three";<br> &nbsp;&nbsp;&nbsp;&nbsp;printf("%s", p);<br> &nbsp;&nbsp;&nbsp;&nbsp;break;<br> }</p><h4>一致性的小淘氣</h4><p>當你需要一個字符常量的時候，可以用多種不同格式： ' ', 32, 0x20, 040。在 C 或 Java 裏 10 和 010 是不同的數（0 開頭的表示 16 進制），你也可以充分利用這個特性。</p><h4>造型</h4><p>把所有數據都以 void * 形式傳遞，然後再造型為合適的結構。不用結構而是通過位移字節數來造型也很好玩。</p><h4>嵌套 Switch</h4><p>Switch 裏邊還有 Switch，這種嵌套方式是人類大腦難以破解的。 &nbsp;</p><h4>利用隱式轉化</h4><p>牢記編程語言中所有的隱式轉化細節。充分利用它們。數組的索引要用浮點變量，循環計數器用字符，對數字執行字符串函數調用。不管怎麼説，所有這些操作都是合法的，它們無非是讓源代碼更簡潔而已。任何嘗試理解它們的維護者都會對你感激不盡，因為他們必須閲讀和學習整個關於隱式數據類型轉化的章節，而這個章節很可能是他們來維護你的代碼之前完全忽略了的。</p><h4>分號!</h4><p>在所有語法允許的地方都加上分號，例如：</p><p>if(a);<br> else;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;<strong>d</strong>;<br> &nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;<strong>=</strong>&nbsp;c;<br> &nbsp;&nbsp;&nbsp;&nbsp;}<br> &nbsp;&nbsp;&nbsp;&nbsp;;</p><h4>使用八進制數</h4><p>把八進制數混到十進制數列表裏，就像這樣：</p><p>array&nbsp;<strong>=</strong>&nbsp;new int&nbsp;<strong>[</strong><strong>]</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;111<strong>,</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;120<strong>,</strong><br><span style="color:red">&nbsp;&nbsp;&nbsp;&nbsp;013</span><strong>,</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;121<strong>,</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;};</p><h4>嵌套</h4><p>儘可能深地嵌套。優秀的程序員能在一行代碼裏寫 10 層 ()，在一個方法裏寫 20 層{}。 &nbsp;</p><h4>C 數組</h4><p>C 編譯器會把&nbsp;<span style="color:#000099"><span>myArray[i]</span></span>&nbsp;轉換成&nbsp;<span style="color:#000099"><span>*(myArray + i)</span></span>，它等同於&nbsp;<span style="color:#000099"><span>*(i + myArray)</span></span>&nbsp;也等同於&nbsp;<span style="color:#000099"><span>i[myArray]</span></span>。 高手都知道怎麼用好這個招。可以用下面的函數來產生索引，這樣就把代碼搞亂了：</p><p><span style="color:#000099"><span>int myfunc(int q, int p) { return p%q; }<br> ...<br> myfunc(6291, 8)[Array];</span></span></p><p>遺憾的是，這一招只能在本地 C 類裏用，Java 還不行。</p><h4>放長線釣大魚</h4><p>一行代碼裏堆的東西越多越好。這樣可以省下臨時變量的開銷，去掉換行和空格還可以縮短源文件大小。記住，要去掉運算符兩邊的空格。優秀的程序員總是能突破某些編輯器對於 255 個字符行寬的限制。</p><h4>異常</h4><p>我這裏要向你傳授一個編程中鮮為人知的秘訣。異常是個討厭的東西。良好的代碼永遠不會出錯，所以異常實際上是不必要的。不要把時間浪費在這上面。子類異常是給那些知道自己代碼會出錯的低能兒用的。在整個應用裏，你只用在 main() 裏放一個 try/catch，裏邊直接調用 System.exit() 就行了。在每個方法頭要貼上標準的拋出集合定義，到底會不會拋出異常你就不用管了。 &nbsp;</p><h4>使用異常的時機</h4><p>在非異常條件下才要使用異常。比如終止循環就可以用&nbsp;<span style="color:#000099"><span>ArrayIndexOutOfBoundsException</span></span>。還可以從異常裏的方法返回標準的結果。 &nbsp;</p><h4>狂熱奔放地使用線程</h4><p>如題。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>測試</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>在程序裏留些 bug，讓後繼的維護代碼的程序員能做點有意思的事。精心設計的 bug 是無跡可尋的，而且誰也不知道它啥時候會冒出來。要做到這一點，最簡單的辦法的就是不要測試代碼。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>永不測試</h4><p>永遠不要測試負責處理錯誤、當機或操作系故障的任何代碼。反正這些代碼永遠也不會執行，只會拖累你的測試。還有，你怎麼可能測試處理磁盤錯誤、文件讀取錯誤、操作系統崩潰這些類型的事件呢？為啥你要用特別不穩定的計算機或者用測試腳手架來模擬這樣的環境？現代化的硬件永遠不會崩潰，誰還願意寫一些僅僅用於測試的代碼？這一點也不好玩。如果用户抱怨，你就怪到操作系統或者硬件頭上。他們永遠不會知道真相的。</p><h4>永遠不要做性能測試</h4><p>嘿，如果軟件運行不夠快，只要告訴客户買個更快的機器就行了。如果你真的做了性能測試，你可能會發現一個瓶頸，這會導致修改算法，然後導致整個產品要重新設計。誰想要這種結果？而且，在客户那邊發現性能問題意味着你可以免費到外地旅遊。你只要備好護照和最新照片就行了。</p><h4>永遠不要寫任何測試用例</h4><p>永遠不要做代碼覆蓋率或路徑覆蓋率測試。自動化測試是給那些窩囊廢用的。搞清楚哪些特性佔到你的例程使用率的 90%，然後把 90% 的測試用在這些路徑上。畢竟説起來，這種方法可能只測試到了大約你代碼的 60%，這樣你就節省了 40% 的測試工作。這能幫助你趕上項目後端的進度。等到有人發現所有這些漂亮的「市場特性」不能正常工作的時候，你早就跑路了。一些有名的大軟件公司就是這樣測試代碼的，所以你也應該這樣做。如果因為某種原因你還沒走，那就接着看下一節。 &nbsp;</p><h4>測試是給懦夫用的</h4><p>勇敢的程序員會跳過這個步驟。太多程序員害怕他們的老闆，害怕丟掉工作，害怕客户的投訴郵件，害怕遭到起訴。這種恐懼心理麻痹了行動，降低了生產率。有科學研究成果表明，取消測試階段意味着經理有把握能提前確定交付時間，這對於規劃流程顯然是有利的。消除了恐懼心理，創新和實驗之花就隨之綻放。程序員的角色是生產代碼，調試工作完全可以由技術支持和遺留代碼維護組通力合作來進行。</p><p>如果我們對自己的編程能力有充分信心，那麼測試就沒有必要了。如果我們邏輯地看待這個問題，隨便一個傻瓜都能認識到測試根本都不是為瞭解決技術問題，相反，它是一種感性的信心問題。針對這種缺乏信心的問題，更有效的解決辦法就是完全取消測試，送我們的程序員去參加自信心培訓課程。畢竟説起來，如果我們選擇做測試，那麼我們就要測試每個程序的變更，但其實我們只需要送程序員去一次建立自信的培訓課就行了。很顯然這麼做的成本收益是相當可觀的。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>編程語言的選擇</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>計算機語言正在逐步進化，變得更加傻瓜化。使用最新的語言是不人性的。儘可能堅持使用你會用的最老的語言，先考慮用穿孔紙帶，不行就用匯編，再不行用 FORTRAN 或者 COBOL，再不行就用 C 還有 BASIC，實在不行再用 C++。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>FØRTRAN</h4><p>用 FORTRAN 寫所有的代碼。如果老闆問你為啥，你可以回答説有很多它非常有用的庫，你用了可以節約時間。不過，用 FORTRAN 寫出可維護代碼的概率是 0，所以，要達到不可維護代碼編程指南里的要求就容易多了。</p><h4>用 ASM</h4><p>把所有的通用工具函數都轉成彙編程序。</p><h4>用 QBASIC</h4><p>所有重要的庫函數都要用 QBASIC 寫，然後再寫個彙編的封包程序來處理 large 到 medium 的內存模型映射。</p><h4>內聯彙編</h4><p>在你的代碼裏混雜一些內聯的彙編程序，這樣很好玩。這年頭幾乎沒人懂彙編程序了。只要放幾行彙編代碼就能讓維護代碼的程序員望而卻步。</p><h4>宏彙編調用 C</h4><p>如果你有個彙編模塊被 C 調用，那就儘可能經常從彙編模塊再去調用 C，即使只是出於微不足道的用途，另外要充分利用 goto, bcc 和其他炫目的彙編秘籍。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>與他人共事之道</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><h4>老闆才是真行家</h4><p>如果你的老闆認為他 20 年的 FORTRAN 編程經驗對於現代軟件開發具有很高的指導價值，你務必嚴格採納他的所有建議。投桃報李，你的老闆也會信任你。這會對你的職業發展有利。你還會從他那裏學到很多搞亂程序代碼的新方法。</p><h4>顛覆技術支持</h4><p>確保代碼中到處是 bug 的有效方法是永遠不要讓維護代碼的程序員知道它們。這需要顛覆技術支持工作。永遠不接電話。使用自動語音答覆「感謝撥打技術支持熱線。需要人工服務請按 1，或在嘀聲後留言。」，請求幫助的電子郵件必須忽略，不要給它分配服務追蹤號。對任何問題的標準答覆是「我估計你的賬户被鎖定了，有權限幫你恢復的人現在不在。」 &nbsp;</p><h4>沉默是金</h4><p>永遠不要對下一個危機保持警覺。如果你預見到某個問題可能會在一個固定時間爆發，摧毀西半球的全部生命，不要公開討論它。不要告訴朋友、同事或其他你認識的有本事的人。在任何情況下都不要發表任何可能暗示到這種新的威脅的內容。只發送一篇正常優先級的、語焉不詳的備忘錄給管理層，保護自己免遭秋後算賬。如果可能的話，把這篇稀裏糊塗的信息作為另外一個更緊急的業務問題的附件。這樣就可以心安理得地休息了，你知道將來你被強制提前退休之後一段時間，他們又會求着你回來，並給你對數級增長的時薪！ &nbsp;</p><h4>每月一書俱樂部</h4><p>加入一個計算機每月一書俱樂部。選擇那些看上去忙着寫書不可能有時間真的去寫代碼的作者。去書店裏找一些有很多圖表但是沒有代碼例子的書。瀏覽一下這些書，從中學會一些迂腐拗口的術語，用它們就能唬住那些自以為是的維護代碼的程序員。你的代碼肯定會給他留下深刻印象。如果人們連你寫的術語都理解不了，他們一定會認為你非常聰明，你的算法非常深奧。不要在你的算法説明裏作任何樸素的類比。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>自立門户</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>你一直想寫系統級的代碼。現在機會來了。忽略標準庫，&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.roll-your-own.com%2F" target="_blank">編寫你自己的標準</a><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>，這將會是你簡歷中的一個亮點。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>推出你自己的 BNF 範式</h4><p>總是用你自創的、獨一無二的、無文檔的 BNF 範式記錄你的命令語法。永遠不要提供一套帶註解的例子（合法命令和非法命令之類）來解釋你的語法體系。那樣會顯得完全缺乏學術嚴謹性。確保沒有明顯的方式來區分終結符和中間符號。永遠不要用字體、顏色、大小寫和其他任何視覺提示幫助讀者分辨它們。在你的 BNF 範式用和命令語言本身完全一樣的標點符號，這樣讀者就永遠無法分清一段 (...), [...], {...} 或 "..." 到底是你在命令行裏真正輸入的，還是想提示在你的 BNF 範式裏哪個語法元素是必需的、可重複的、或可選的。不管怎麼樣，如果他們太笨，搞不清你的 BNF 範式的變化，就沒資格使用你的程序。 &nbsp;</p><h4>推出你自己的內存分配</h4><p>地球人兒都知道，調試動態存儲是複雜和費時的。與其逐個類去確認它沒有內存溢出，還不如自創一套存儲分配機制呢。其實它無非是從一大片內存中 malloc 一塊空間而已。用不着釋放內存，讓用户定期重啓動系統，這樣不就清除了堆麼。重啓之後系統需要追蹤的就那麼一點東西，比起解決所有的內存泄露簡單得不知道到哪裏去了！而且，只要用户記得定期重啓系統，他們也永遠不會遇到堆空間不足的問題。一旦系統被部署，你很難想象他們還能改變這個策略。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>其他雜七雜八的招</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>如果你給某人一段程序，你會讓他困惑一天；如果你教他們如何編程，你會讓他困惑一輩子。&nbsp;</em>-- Anonymous</p></blockquote><h4>不要重編譯</h4><p>讓我們從一條可能是有史以來最友好的技巧開始：把代碼編譯成可執行文件。如果它能用，就在源代碼裏做一兩個微小的改動 -- 每個模塊都照此辦理。<strong>但是不要費勁巴拉地再編譯一次了。</strong>&nbsp;你可以留着等以後有空而且需要調試的時候再説。多年以後，等可憐的維護代碼的程序員更改了代碼之後發現出錯了，他會有一種錯覺，覺得這些肯定是他自己最近修改的。這樣你就能讓他毫無頭緒地忙碌很長時間。</p><h4>挫敗調試工具</h4><p>對於試圖用行調試工具追蹤來看懂你的代碼的人，簡單的一招就能讓他狼狽不堪，那就是把每一行代碼都寫得很長。特別要把 then 語句，和 if 語句放在同一行裏。他們無法設置斷點。他們也無法分清在看的分支是哪個 if 裏的。</p><h4>公制和美製</h4><p>在工程方面有兩種編碼方式。一種是把所有輸入都轉換為公制（米制）計量單位，然後在輸出的時候自己換算回各種民用計量單位。另一種是從頭到尾都保持各種計量單位混合在一起。總是選擇第二種方式，這就是美國之道！ &nbsp;</p><h4>持續改進</h4><p>要持續不懈地改進。要常常對你的代碼做出「改進」，並強迫用户經常升級 -- 畢竟沒人願意用一個過時的版本嘛。即便他們覺得他們對現有的程序滿意了，想想看，如果他們看到你又「完善「了它，他們會多麼開心啊！不要告訴任何人版本之間的差別，除非你被逼無奈 -- 畢竟，為什麼要告訴他們本來永遠也不會注意到的一些 bug 呢？</p><h4>「關於」</h4><p>「關於」一欄應該只包含程序名、程序員姓名和一份用法律用語寫的版權聲明。理想情況下，它還應該鏈接到幾 MB 的代碼，產生有趣的動畫效果。但是，裏邊永遠不要包含程序用途的描述、它的版本號、或最新代碼修改日期、或獲取更新的網站地址、或作者的 email 地址等。這樣，所有的用户很快就會運行在不同的版本上，在安裝 N+1 版之前就試圖安裝 N+2 版。</p><h4>變更</h4><p>在兩個版本之間，你能做的變更自然是多多益善。你不會希望用户年復一年地面對同一套老的接口或用户界面，這樣會很無聊。最後，如果你能在用户不注意的情況下做出這些變更，那就更好了 -- 這會讓他們保持警惕，戒驕戒躁。</p><h4>無需技能</h4><p>寫無法維護代碼不需要多高的技能。喊破嗓子不如甩開膀子，不管三七二十一開始寫代碼就行了。記住，管理層還在按代碼行數考核生產率，即使以後這些代碼裏的大部分都得刪掉。</p><h4>只帶一把錘子</h4><p>一招鮮吃遍天，輕裝前進。如果你手頭只有一把錘子，那麼所有的問題都是釘子。</p><h4>規範體系</h4><p>有可能的話，忽略當前你的項目所用語言和環境中被普羅大眾所接受的編程規範。比如，編寫基於 MFC 的應用時，就堅持使用 STL 編碼風格。</p><h4>翻轉通常的 True False 慣例</h4><p>把常用的 true 和 false 的定義反過來用。這一招聽起來平淡無奇，但是往往收穫奇效。你可以先藏好下面的定義：</p><p>#define TRUE 0<br> #define FALSE 1</p><p>把這個定義深深地藏在代碼中某個沒人會再去看的文件裏不易被發現的地方，然後讓程序做下面這樣的比較</p><p>if ( var == TRUE )</p><p>if ( var != FALSE )</p><p>某些人肯定會迫不及待地跳出來「修正」這種明顯的冗餘，並且在其他地方照着常規去使用變量 var：</p><p>if ( var )</p><p>還有一招是為&nbsp;<span style="color:#000099"><span>TRUE</span></span>&nbsp;和&nbsp;<span style="color:#000099"><span>FALSE</span></span>賦予相同的值，雖然大部分人可能會看穿這種騙局。給它們分別賦值 1 和 2 或者 -1 和 0 是讓他們瞎忙乎的方式裏更精巧的，而且這樣做看起來也不失對他們的尊重。你在 Java 裏也可以用這一招，定義一個叫&nbsp;<span style="color:#000099"><span>TRUE</span></span>&nbsp;的靜態常量。在這種情況下，其他程序員更有可能懷疑你乾的不是好事，因為 Java 裏已經有了內建的標識符&nbsp;<span style="color:#000099"><span>true</span></span>。</p><h4>第三方庫</h4><p>在你的項目裏引入功能強大的第三方庫，然後不要用它們。潛規則就是這樣，雖然你對這些好的工具仍然一無所知，卻還是可以在你簡歷的「其他工具」一節中寫上這些沒用過的庫。</p><h4>不要用庫</h4><p>假裝不知道有些庫已經直接在你的開發工具中引入了。如果你用 VC++編程，忽略 MFC 或 STL 的存在，手工編寫所有字符串和數組的實現；這樣有助於保持你的指針技術，並自動阻止任何擴展代碼功能的企圖。</p><h4>創建一套 Build 順序</h4><p>把這套順序規則做得非常晦澀，讓維護者根本無法編譯任何他的修改代碼。秘密保留&nbsp;SmartJ&nbsp;，它會讓&nbsp;<span style="color:#000099"><span>make</span></span>腳本形同廢物。類似地，偷偷地定義一個&nbsp;<span style="color:#000099"><span>javac</span></span>&nbsp;類，讓它和編譯程序同名。説到大招，那就是編寫和維護一個定製的小程序，在程序裏找到需要編譯的文件，然後通過直接調用&nbsp;<span style="color:#000099"><span>sun.tools.javac.Main</span></span>&nbsp;編譯類來進行編譯。</p><h4>Make 的更多玩法</h4><p>用一個 makefile-generated-batch-file 批處理文件從多個目錄複製源文件，文件之間的覆蓋規則在文檔中是沒有的。這樣，無需任何炫酷的源代碼控制系統，就能實現代碼分支，並阻止你的後繼者弄清哪個版本的 DoUsefulWork() 才是他需要修改的那個。</p><h4>蒐集編碼規範</h4><p>儘可能蒐集所有關於編寫可維護代碼的建議，例如&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.squarebox.co.uk%2Fjavatips.html" target="_blank">SquareBox 的建議</a>&nbsp;，然後明目張膽地違反它們。</p><h4>規避公司的編碼規則</h4><p>某些公司有嚴格的規定，不允許使用數字標識符，你必須使用預先命名的常量。要挫敗這種規定背後的意圖太容易了。比如，一位聰明的 C++ 程序員是這麼寫的：</p><p>#define K_ONE 1<br> #define K_TWO 2<br> #define K_THOUSAND 999</p><h4>編譯器警告</h4><p>一定要保留一些編譯器警告。在 make 裏使用 「-」 前綴強制執行，忽視任何編譯器報告的錯誤。這樣，即使維護代碼的程序員不小心在你的源代碼裏造成了一個語法錯誤，make 工具還是會重新把整個包 build 一遍，甚至可能會成功！而任何程序員要是手工編譯你的代碼，看到屏幕上冒出一堆其實無關緊要的警告，他們肯定會覺得是自己搞壞了代碼。同樣，他們一定會感謝你讓他們有找錯的機會。學有餘力的同學可以做點手腳讓編譯器在打開編譯錯誤診斷工具時就沒法編譯你的程序。當然了，編譯器也許能做一些腳本邊界檢查，但是真正的程序員是不用這些特性的，所以你也不該用。既然你用自己的寶貴時間就能找到這些精巧的 bug，何必還多此一舉讓編譯器來檢查錯誤呢？</p><h4>把 bug 修復和升級混在一起</h4><p>永遠不要推出什麼「bug 修復"版本。一定要把 bug 修復和數據庫結構變更、複雜的用户界面修改，還有管理界面重寫等混在一起。那樣的話，升級就變成一件非常困難的事情，人們會慢慢習慣 bug 的存在並開始稱他們為特性。那些真心希望改變這些」特性「的人們就會有動力升級到新版本。這樣從長期來説可以節省你的維護工作量，並從你的客户那裏獲得更多收入。</p><h4>在你的產品發佈每個新版本的時候都改變文件結構</h4><p>沒錯，你的客户會要求向上兼容，那就去做吧。不過一定要確保向下是不兼容的。這樣可以阻止客户從新版本回退，再配合一套合理的 bug 修復規則（見上一條），就可以確保每次新版本發佈後，客户都會留在新版本。學有餘力的話，還可以想辦法讓舊版本壓根無法識別新版本產生的文件。那樣的話，老版本系統不但無法讀取新文件，甚至會否認這些文件是自己的應用系統產生的！温馨提示：PC 上的 Word 文字處理軟件就典型地精於此道。</p><h4>抵消 Bug</h4><p>不用費勁去代碼裏找 bug 的根源。只要在更高級的例程里加入一些抵銷它的代碼就行了。這是一種很棒的智力測驗，類似於玩 3D 棋，而且能讓將來的代碼維護者忙乎很長時間都想不明白問題到底出在哪裏：是產生數據的低層例程，還是莫名其妙改了一堆東西的高層代碼。這一招對天生需要多回合執行的編譯器也很好用。你可以在較早的回合完全避免修復問題，讓較晚的回合變得更加複雜。如果運氣好，你永遠都不用和編譯器前端打交道。學有餘力的話，在後端做點手腳，一旦前端產生的是正確的數據，就讓後端報錯。</p><h4>使用旋轉鎖</h4><p>不要用真正的同步原語，多種多樣的旋轉鎖更好 -- 反覆休眠然後測試一個 (non-volatile 的) 全局變量，直到它符合你的條件為止。相比系統對象，旋轉鎖使用簡便」，通用「性強」，靈活「多變，實為居家旅行必備。</p><h4>隨意安插 sync 代碼</h4><p>把某些系統同步原語安插到一些用不着它們的地方。本人曾經在一段不可能會有第二個線程的代碼中看到一個臨界區（critical section）代碼。本人當時就質問寫這段代碼的程序員，他居然理直氣壯地説這麼寫是為了表明這段代碼是很」關鍵「（也是 critical）的！</p><h4>優雅降級</h4><p>如果你的系統包含了一套 NT 設備驅動，就讓應用程序負責給驅動分配 I/O 緩衝區，然後在任何交易過程中對內存中的驅動加鎖，並在交易完成後釋放或解鎖。這樣一旦應用非正常終止，I/O 緩存又沒有被解鎖，NT 服務器就會當機。但是在客户現場不太可能會有人知道怎麼弄好設備驅動，所以他們就沒有選擇（只能請你去免費旅遊了）。</p><h4>定製腳本語言</h4><p>在你的 C/S 應用裏嵌入一個在運行時按字節編譯的腳本命令語言。</p><h4>依賴於編譯器的代碼</h4><p>如果你發現在你的編譯器或解釋器裏有個 bug，一定要確保這個 bug 的存在對於你的代碼正常工作是至關重要的。畢竟你又不會使用其他的編譯器，其他任何人也不允許！</p><h4>一個貨真價實的例子</h4><p>下面是一位大師編寫的真實例子。讓我們來瞻仰一下他在這樣短短几行 C 函數裏展示的高超技巧。</p><pre><code>void* Realocate(void*buf, int os, int ns)
{
    void*temp;
    temp = malloc(os);
    memcpy((void*)temp, (void*)buf, os);
    free(buf);
    buf = malloc(ns);
    memset(buf, 0, ns);
    memcpy((void*)buf, (void*)temp, ns);
    return buf;
}</code></pre><ul><li>重新發明瞭標準庫裏已有的簡單函數。</li><li><em>Realocate</em>&nbsp;這個單詞拼寫錯誤。所以説，永遠不要低估創造性拼寫的威力。</li><li>無緣無故地給輸入緩衝區產生一個臨時的副本。</li><li>無緣無故地造型。 memcpy() 裏有 (void*)，這樣即使我們的指針已經是 (void*) 了也要再造型一次。另外這樣可以傳遞任何東西作為參數，加 10 分。</li><li>永遠不必費力去釋放臨時內存空間。這樣會導致緩慢的內存泄露，一開始看不出來，要程序運行一段時間才行。</li><li>把用不着的東西也從緩衝區裏拷貝出來，以防萬一。這樣只會在 Unix 上產生 core dump，Windows 就不會。</li><li>很顯然，os 和 ns 的含義分別是」old size" 和 "new size"。</li><li>給 buf 分配內存之後，memset 初始化它為 0。不要使用 calloc()，因為某些人會重寫 ANSI 規範，這樣將來保不齊 calloc() 往 buf 裏填的就不是 0 了。（雖然我們複製過去的數據量和 buf 的大小是一樣的，不需要初始化，不過這也無所謂啦）</li></ul><h4>如何修復 "unused variable" 錯誤</h4><p>如果你的編譯器冒出了 "unused local variable" 警告，不要去掉那個變量。相反，要找個聰明的辦法把它用起來。我最喜歡的方法是：<br><span style="color:#000099"><span>i = i;</span></span></p><h4>大小很關鍵</h4><p>差點忘了説了，函數是越大越好。跳轉和 GOTO 語句越多越好。那樣的話，想做任何修改都需要分析很多場景。這會讓維護代碼的程序員陷入千頭萬緒之中。如果函數真的體型龐大的話，對於維護代碼的程序員就是哥斯拉怪獸了，它會在他搞清楚情況之前就殘酷無情地將他們踩翻在地。</p><h4>一張圖片頂 1000 句話，一個函數就是 1000 行</h4><p>把每個方法體寫的儘可能的長 -- 最好是你寫的任何方法或函數都沒有少於 1000 行代碼的，而且裏邊深度嵌套，這是必須的。</p><h4>少個文件</h4><p>一定要保證一個或多個關鍵文件是找不到的。利用 includes 裏邊再 includes 就能做到這一點。例如，在你的 main 模塊裏，你寫上：</p><p>#include &lt;stdcode.h&gt;</p><p>Stdcode.h 是有的。但是在 stdcode.h 裏，還有個引用：</p><p>#include "a:\\refcode.h"</p><p>然後，refcode.h 就沒地方能找到了。</p><p><span>到處可寫，無處可讀</span></p><p>至少要把一個變量弄成這樣：到處被設置，但是幾乎沒有哪裏用到它。不幸的是，現代編譯器通常會阻止你做相反的事：到處讀，沒處寫。不過你在 C 或 C++ 裏還是可以這樣做的。</p><blockquote><p><em><strong>原始博文發佈於：&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmindprod.com%2Funmain.html" target="_blank">Roedy Green's Mindproducts&nbsp;</a>。</strong></em></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 08:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269949/unmaintainable-new-defensive-programming</guid>
            <link>https://www.oschina.net/news/269949/unmaintainable-new-defensive-programming</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[美國 CISA 建議放棄 C/C++，消除內存安全漏洞]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">美國網絡安全與基礎設施安全局 (CISA) 發佈了一份名為「<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cisa.gov%2Fresources-tools%2Fresources%2Fcase-memory-safe-roadmaps" target="_blank">The Case for Memory Safe Roadmaps</a>」的文件，詳細介紹了軟件廠商應如何過渡到內存安全編程語言 (MSL)，以消除內存安全漏洞。</span></p><p><span style="color:#000000">CISA 認為，內存安全錯誤經常會造成重大損失，需要加以杜絕；因此敦促企業和技術領導者密切關注軟件開發中的內存安全。而&nbsp;C 和 C++ 等編程語言就是內存不安全編程語言的典範；它們可能導致內存不安全代碼，但仍然是當今使用最廣泛的語言之一。</span></p><p><img height="339" src="https://oscimg.oschina.net/oscnet/up-5d0b5ed6634487780b08f8f39114dd5ed99.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">該指南文件由美國網絡安全與基礎設施安全局 (CISA)、國家安全局 (NSA)、聯邦調查局 (FBI)，以及澳大利亞、加拿大、英國和新西蘭的網絡安全機構聯合制定。旨在敦促每家軟件廠商的高級管理人員通過優先考慮實施 MSL 的設計和開發實踐來降低客户風險；同時敦促他們創建併發布內存安全路線圖，以便客户瞭解所面臨的內存安全風險。</span></p><blockquote><p><span style="color:#000000">「MSL 可以消除內存安全漏洞。因此，過渡到 MSL 可能會大大降低投資於旨在減少這些漏洞或將其影響降至最低的活動的必要性。此外，將不安全的代碼庫遷移到 MSL 的投資將以更安全的產品的形式帶來長期回報--這也抵消了過渡到 MSL 的部分前期成本。」</span></p></blockquote><p><span style="color:#000000">文件指出，微軟<span style="background-color:#ffffff">約 70% 的 CVE 是內存安全漏洞</span>（基於 2006-2018 年的 CVE），Mozilla 的 34 個關鍵/高危漏洞中有 32 個是內存安全漏洞。谷歌 Chromium 項目中所發現的漏洞，有約 70% 是內存安全漏洞；且 2021 年的零日漏洞中也有 67% 是內存安全漏洞。</span></p><p><span style="color:#000000">雖然一些組織為了減少&nbsp;<span style="background-color:#ffffff">C/C++</span> 內存不安全代碼引入的風險，投入了大量資金用於開發人員培訓。但 CISA 等機構認為，「雖然培訓可以減少程序員可能引入的漏洞數量，但考慮到內存安全缺陷的普遍性，內存安全漏洞的出現幾乎是不可避免的。」</span></p><p><span style="color:#000000">鑑於此，他們<span style="background-color:#ffffff">建議組織放棄 C/C++，轉而使用 C#、Go、Java、Python、Rust 和 Swift&nbsp;等「內存安全語言」。</span></span></p><p><img height="355" src="https://oscimg.oschina.net/oscnet/up-e6e47911a81e83c6770f76378917ec074f9.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cisa.gov%2Fsites%2Fdefault%2Ffiles%2F2023-12%2FThe-Case-for-Memory-Safe-Roadmaps-508c.pdf" target="_blank">查看完整文檔</a>。</span></p><hr><p><strong><span style="color:#000000">相關閲讀：</span></strong></p><ul><li><a href="https://www.oschina.net/news/217425/nsa-memory-safe-programming-language" target="_blank">美國國家安全局建議從 C/C++ 切換到內存安全語言</a></li><li><a href="https://www.oschina.net/news/226780/c-plus-plus-bjarne-stroustrup-safety" target="news">C++ 之父：Rust 等內存安全語言的安全性並不優於 C++</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 07:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269933/cisa-the-case-for-memory-safe-roadmaps</guid>
            <link>https://www.oschina.net/news/269933/cisa-the-case-for-memory-safe-roadmaps</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Firefox 會被淘汰嗎？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>近期關於 Firefox 的一篇文章引起了<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D38531104" target="_blank">廣泛討論</a></u>。作者表示，Firefox 正處於危險邊緣，可能很快就會被淘汰。</p><blockquote><img src="https://oscimg.oschina.net/oscnet/up-3d6519dad6718f830b4b0fc8ad29f4f8032.png" referrerpolicy="no-referrer"><p>來源 <em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.brycewray.com%2Fposts%2F2023%2F11%2Ffirefox-brink%2F" target="_blank">https://www.brycewray.com/posts/2023/11/firefox-brink/</a></u></em></p></blockquote><p>文章提到，根據美國政府網站的開發指南 (<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdesignsystem.digital.gov%2F" target="_blank">U.S. Web Design System</a>, USWDS)，<strong>如果 Firefox 的市場份額低於 2%</strong>（參考 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fanalytics.usa.gov" target="_blank">analytics.usa.gov</a> 的統計使用率），那麼美國政府的網站可以不再兼容 Firefox。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1df9adfb989c674f23068f0710d9ed2993c.png" referrerpolicy="no-referrer"></p><p>過去 90 天，訪問 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fanalytics.usa.gov" target="_blank">analytics.usa.gov</a> 的瀏覽器中 Chrome 佔 49%，Safari 佔 34.8%，Edge 8.5%，<strong>Firefox 只有 2.2 %</strong>——已經非常接近臨界點。如果 Firefox 失去了美國政府網站的支持，這有可能在整個 Web 開發界產生漣漪效應。因為政府的決定會影響到無數企業，就像多米諾骨牌倒下一樣，會有越來越多的網站跟隨步伐不兼容 Firefox，導致 Firefox 處於淘汰邊緣。</p><p><img src="https://oscimg.oschina.net/oscnet/up-dcc027785814f919e453f18776391477b5d.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-4df67b9659f2a95d258721fbfed00bafe07.png" referrerpolicy="no-referrer"></p><p>有人可能會問；「政府網站不兼容 Firefox 又怎樣？這只是針對美國政府的舉措，並不會影響任何其他網站。」但作者認為：</p><ol><li><p>一旦 Firefox 在政府的訪問者分析中跌破 2% 的閾值，USWDS 就會告訴政府網站開發者他們不必再支持 Firefox。</p></li><li><p>消息傳出後，不僅前端開發社區，就連一些 Web 開發者所服務的企業 IT 部門也會迅速知曉。許多企業與政府有大量業務往來，因此，政府在 IT 方面的任何舉措都會影響企業。</p></li><li><p>企業會將這一變化視為<strong>降低開發成本和縮短交付時間</strong>的機會，因為它提供了一個藉口，可以從開發工作流程中移除一些測試（在極少數情況下還包括特定代碼）。</p></li></ol><p>下圖清晰展示了瀏覽器三巨頭從 2009 到 2023 的市場份額變化情況，Firefox 在 2009 年 11 月達到了 31.82% 的峯值，此後便是持續下滑。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a1b0aacdd134ed153115b0354c1ba76e9d4.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 06:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269923/firefox-on-the-brink</guid>
            <link>https://www.oschina.net/news/269923/firefox-on-the-brink</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[防禦性編程幾大基本原則]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">當開發人員遇到意外的錯誤無法修復時，他們會「添加一些防禦性代碼」來使代碼更安全，更容易找到問題所在。有時候，僅僅這樣做就能解決問題。他們會加強數據驗證——確保檢查輸入和輸出字段以及返回值。審查並改進錯誤處理——也許在「不可能」的情況周圍添加一些檢查。增加一些有用的日誌記錄和診斷功能。換句話説，這些<strong>本應該從一開始就存在的代碼</strong>。</p><blockquote><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">防禦性編程的整個目的是為了防範你意想不到的錯誤。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">——Steve McConnell，《代碼大全》</p></blockquote><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">防禦性編程的幾個基本原則在 Steve McConnell 經典著作《代碼大全》中有詳細解釋：</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>保護你的代碼免受「外部」傳入的無效數據影響</strong>，無論你認為「外部」是指什麼地方。這裏指來自外部系統、用户、文件或模塊/組件之外的任何數據。建立「壁壘」、「安全區域」或「信任邊界」——邊界之外的一切都是危險的，邊界之內的一切都是安全的。在壁壘代碼中，驗證所有輸入數據：檢查所有輸入參數的正確類型、長度和取值範圍。再次檢查限制和範圍。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">在檢查完壞數據後，決定如何處理它。<strong>防禦性編程並不意味着吞沒錯誤或隱藏錯誤</strong>。它是關於在健壯性（如果遇到可處理的問題則繼續運行）和正確性（永遠不返回錯誤結果）之間做出權衡。選擇一種處理壞數據的策略：立即返回錯誤並停止運行（快速失敗），返回一箇中立值，替換數據值等等。確保策略明確且一致。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>不要假設你代碼之外的函數調用或方法調用會按照廣告所述正常工作</strong>。確保你理解並測試了周圍外部 API 和庫的錯誤處理機制。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>使用斷言來記錄假設，並突出顯示「不可能」的條件</strong>，至少在開發和測試階段如此。這對於長期由不同人維護或高可靠性代碼特別重要。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">巧妙地<strong>添加診斷代碼、日誌記錄和跟蹤功能</strong>，以幫助解釋運行時發生了什麼問題，尤其是當遇到問題時。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>標準化錯誤處理</strong>。決定如何處理「正常錯誤」或「預期錯誤」和警告，並始終保持一致。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>只在需要時使用異常處理</strong>，並確保你對語言的異常處理機制瞭如指掌。將異常作為正常處理流程的一部分的程序會遭受經典意義上代碼結構混亂的可讀性和可維護性問題。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">Michael Nygard 在《發佈！》中還提到了其他幾個規則，比如永遠不要無限期等待外部調用，尤其是遠程調用。當出現問題時，無限期可能會很長時間。使用超時/重試邏輯以及他的斷路器穩定模式來處理遠程故障。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">對於 C 和 C++等編程語言，防禦性編程還包括使用安全函數調用來避免緩衝區溢出和常見編碼錯誤。</p><blockquote><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">原文：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fswreflections.blogspot.com%2F2012%2F03%2Fdefensive-programming-being-just-enough.html" target="_blank">https://swreflections.blogspot.com/2012/03/defensive-programming-being-just-enough.html</a></p></blockquote><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 06:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269921/defensive-programming</guid>
            <link>https://www.oschina.net/news/269921/defensive-programming</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[向量數據庫領域又來一個很屌的項目，PostgresML]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#1f2328">PostgresML 是 PostgreSQL 的機器學習擴展，能讓你使用 SQL 查詢對文本和表格數據進行訓練和推理。有了 PostgresML，你可以將機器學習模型無縫集成到 PostgreSQL 數據庫中，並利用尖端算法的強大功能高效處理數據。</span></p><ul><li>執行自然語言處理任務，如情感分析、提問和回答、翻譯、總結和文本生成</li><li>從 HuggingFace 模型 Hub 訪問數千種最先進的語言模型，如 GPT-2、GPT-J 和 GPT-Neo</li><li>針對不同任務，在自己的文本數據上微調大型語言模型</li><li>將現有的 PostgreSQL 數據庫用作向量數據庫，從存儲在數據庫中的文本生成 <span style="background-color:#ffffff; color:#1f2328">embedding</span></li></ul><p><img height="1550" src="https://static.oschina.net/uploads/space/2023/1207/115401_hs4U_3820517.png" width="3300" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#1f2328">針對文本數據操作：</span></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><strong>翻譯</strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><em>SQL 查詢</em></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><div style="text-align:start"><pre><span><span><span><span><span><span><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--fgColor-default, var(--color-fg-default))"><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span><span><span style="color:var(--color-prettylights-syntax-keyword)">SELECT</span></span><span><span style="color:var(--color-prettylights-syntax-constant)">pgml</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">transform</span></span>(
    <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>translation_en_to_fr<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
    inputs <span><span style="color:var(--color-prettylights-syntax-keyword)">=&gt;</span></span> ARRAY[
        <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>Welcome to the future!<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
        <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>Where have you been all this time?<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>
    ]
) <span><span style="color:var(--color-prettylights-syntax-keyword)">AS</span></span> french;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre><div><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><em>結果</em></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div>&nbsp;</div></div><div style="text-align:start"><pre><span><span><span><span><span><span><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--fgColor-default, var(--color-fg-default))"><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span>                         french                                 
<span><span style="color:var(--color-prettylights-syntax-comment)"><span><span style="color:var(--color-prettylights-syntax-comment)">--</span></span>----------------------------------------------------------</span></span>

[
    {<span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>translation_text<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>: <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>Bienvenue à l'avenir!<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>},
    {<span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>translation_text<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>: <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>Où êtes-vous allé tout ce temps?<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>}
]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre><div><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><strong>情感分析</strong> SQL 查詢</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div>&nbsp;</div></div><div style="text-align:start"><pre><span><span><span><span><span><span><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--fgColor-default, var(--color-fg-default))"><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span><span><span style="color:var(--color-prettylights-syntax-keyword)">SELECT</span></span><span><span style="color:var(--color-prettylights-syntax-constant)">pgml</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">transform</span></span>(
    task   <span><span style="color:var(--color-prettylights-syntax-keyword)">=&gt;</span></span><span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>text-classification<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
    inputs <span><span style="color:var(--color-prettylights-syntax-keyword)">=&gt;</span></span> ARRAY[
        <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>I love how amazingly simple ML has become!<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>, 
        <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>I hate doing mundane and thankless tasks. ☹️<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>
    ]
) <span><span style="color:var(--color-prettylights-syntax-keyword)">AS</span></span> positivity;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre><div><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><em>結果</em></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div>&nbsp;</div></div><div style="text-align:start"><pre><span><span><span><span><span><span><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--fgColor-default, var(--color-fg-default))"><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span>                    positivity
<span><span style="color:var(--color-prettylights-syntax-comment)"><span><span style="color:var(--color-prettylights-syntax-comment)">--</span></span>----------------------------------------------------</span></span>
[
    {<span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>label<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>: <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>POSITIVE<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>, <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>score<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>: <span><span style="color:var(--color-prettylights-syntax-constant)">0</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">9995759129524232</span></span>}, 
    {<span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>label<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>: <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>NEGATIVE<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>, <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">"</span></span>score<span><span style="color:var(--color-prettylights-syntax-string)">"</span></span></span></span>: <span><span style="color:var(--color-prettylights-syntax-constant)">0</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">9903519749641418</span></span>}
]</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre></div><p>針對表格數據操作：</p><ul><li><a href="https://postgresml.org/docs/training/algorithm_selection">47+ 種分類和迴歸算法</a></li><li><a href="https://postgresml.org/blog/postgresml-is-8x-faster-than-python-http-microservices">推理速度比基於 HTTP 的模型服務快 8 - 40 倍</a></li><li><a href="https://postgresml.org/blog/scaling-postgresml-to-one-million-requests-per-second">每秒數百萬次事務</a></li><li><a href="https://github.com/postgresml/pgcat">橫向可擴展性</a></li></ul><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><strong>訓練分類模型</strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><em>訓練</em></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><div style="text-align:start"><pre><span><span><span><span><span><span><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--fgColor-default, var(--color-fg-default))"><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span><span><span style="color:var(--color-prettylights-syntax-keyword)">SELECT</span></span><span><span style="color:var(--color-prettylights-syntax-keyword)">*</span></span><span><span style="color:var(--color-prettylights-syntax-keyword)">FROM</span></span><span><span style="color:var(--color-prettylights-syntax-constant)">pgml</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">train</span></span>(
    <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>Handwritten Digit Image Classifier<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
    algorithm <span><span style="color:var(--color-prettylights-syntax-keyword)">=&gt;</span></span><span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>xgboost<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
    <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>classification<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
    <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>pgml.digits<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>,
    <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>target<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>
);</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre><div><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><em>推理</em></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div><div>&nbsp;</div></div><div style="text-align:start"><pre><span><span><span><span><span><span><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--fgColor-default, var(--color-fg-default))"><span style="background-color:var(--bgColor-muted, var(--color-canvas-subtle))"><span><span><span style="color:var(--color-prettylights-syntax-keyword)">SELECT</span></span><span><span style="color:var(--color-prettylights-syntax-constant)">pgml</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">predict</span></span>(
    <span><span style="color:var(--color-prettylights-syntax-string)"><span><span style="color:var(--color-prettylights-syntax-string)">'</span></span>My Classification Project<span><span style="color:var(--color-prettylights-syntax-string)">'</span></span></span></span>, 
    ARRAY[<span><span style="color:var(--color-prettylights-syntax-constant)">0</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">1</span></span>, <span><span style="color:var(--color-prettylights-syntax-constant)">2</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">0</span></span>, <span><span style="color:var(--color-prettylights-syntax-constant)">5</span></span>.<span><span style="color:var(--color-prettylights-syntax-constant)">0</span></span>]
) <span><span style="color:var(--color-prettylights-syntax-keyword)">AS</span></span> prediction;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre></div></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 04:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/postgresml</guid>
            <link>https://www.oschina.net/p/postgresml</link>
        </item>
        <item>
            <title>
                <![CDATA[騰訊 TDesignFlutter 組件庫開源啦🎉🎉🎉]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>簡介</span></span></span></span></strong></span></span></span></h1><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>作為一款誕生於騰訊內部開源、經過超 500 項內部業務檢驗的企業級設計體系，TDesign 彙集了騰訊眾多優秀組件庫能力和設計研發經驗。之前，TDesign 已經支持 Vue2、Vue Next、React 等業界主流技術棧，方便使用者快速開發桌面端、移動端以及小程序等多個版本的應用程序，從而更好地服務設計師和開發者，助力企業提升設計研發效能，為產品體驗設計帶來新的思路。</span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>Flutter 跨平台框架自 2018 年開源以來，迅速發展，擁有大量用户。Flutter 採用自繪引擎，可以在不同平台上實現高性能、流暢的用户界面，用户體驗出色。此外，Flutter 的跨平台特性使開發者只需編寫一次代碼，即可在多個平台上運行，減少開發和維護成本。Flutter 以其高效的開發流程、卓越的性能和跨平台能力，成為跨平台應用開發的首選框架。</span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>TDesignFlutter 不但擁有 Flutter 流暢的跨平台開發體驗，而且擁有 TDesign 美觀一致的設計資源。二者結合，開發者可以直接使用 TDesign 的組件構建 Flutter 應用，加快開發速度的同時，也確保了應用程序的一致性。在騰訊內部，TDesignFlutter 已支持多個產品線上穩定運行。</span></span></span></span></span></span></span></span></span></p><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>組件概覽</span></span></span></span></strong></span></span></span></h1><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>TDesignFlutter 已上線 Text、Button、Input 等 29 個基礎組件。詳情可查閲：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftdesign.tencent.com%2Fflutter%2Foverview" target="_blank">https://tdesign.tencent.com/flutter/overview</a></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><img height="1562" src="https://static.oschina.net/uploads/space/2023/1207/121232_iU7V_3820517.png" width="1270" referrerpolicy="no-referrer"></p><p><span><span><span><span><span><span><span style="color:#333333"><span><span>此外，Collapse(摺疊面板)、Upload(上傳工具) 等組件已在開發測試中，相信很快可以和大家見面。</span></span></span></span></span></span></span></span></span></p><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>常用組件</span></span></span></span></strong></span></span></span></h1><p style="margin-left:0pt; text-align:left"><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>Text:</span></span></span></span></strong></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#6d6e6f"><span><span>支持系統 Text 所有屬性，可無縫切換。中文居中處理，並將常用屬性扁平化，使用更加方便。</span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><img height="1548" src="https://static.oschina.net/uploads/space/2023/1207/121252_uk09_3820517.png" width="808" referrerpolicy="no-referrer"></p><p><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>Button:</span></span></span></span></strong></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#6d6e6f"><span><span>豐富的主題樣式，統一的設計規範。</span></span></span></span></span></span></span></span></span></span></p><div>
 &nbsp;
</div><div><div><p style="margin-left:0; margin-right:0; text-align:left"><img height="1395" src="https://static.oschina.net/uploads/space/2023/1207/121309_8Dew_3820517.png" width="1600" referrerpolicy="no-referrer"></p></div></div><p><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>Icon:</span></span></span></span></strong></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#6d6e6f"><span><span>內容豐富的圖標，使用 ttf 格式，簡單易用，避免失真。</span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><img height="1574" src="https://static.oschina.net/uploads/space/2023/1207/121324_6oME_3820517.png" width="810" referrerpolicy="no-referrer"></p><p><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>複雜組件:</span></span></span></span></strong></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#6d6e6f"><span><span>完善的功能，統一的交互，易用的封裝。</span></span></span></span></span></span></span></span></span></span></p><div>
 &nbsp;
</div><div><div><p style="margin-left:0; margin-right:0; text-align:left"><img height="1440" src="https://static.oschina.net/uploads/space/2023/1207/121344_TPc4_3820517.png" width="2184" referrerpolicy="no-referrer"></p></div></div><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>快速上手</span></span></span></span></strong></span></span></span></h1><h3><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>簡單使用</span></span></span></span></strong></span></span></span></h3><ul><li><span><span><span><span><span><span><span style="color:#333333"><span><span>在 pubbspec.yaml 引入依賴。</span></span></span></span></span></span></span></span></span></li></ul><pre><span style="background-color:#fafafa"><span><code><span><span><span><span><span style="color:#000000"><span><span>dependencies</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>tdesign_flutter</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> ^0.1.0</span></span></span></span></span></span></span></code></span></span></pre><ul><li><span><span><span><span><span><span><span style="color:#333333"><span><span>在文件頭部引入：import 'package:tdesign_flutter/tdesign_flutter.dart';</span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span style="color:#333333"><span><span>然後就可以使用 TDesignFlutter 的組件了:</span></span></span></span></span></span></span></span></span></li></ul><pre><span style="background-color:#fafafa"><span><code><span><span><span><span><span style="color:#dd4a68"><span><span>TDText</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>'測試文本'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>),</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>TDButton</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>text</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>'演示按鈕'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>`</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> theme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>TDButtonTheme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>primary</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>`</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>),</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>Icon</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>TDIcons</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>add_circle</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>)</span></span></span></span></span></span></span></code></span></span></pre><p style="margin-left:0; margin-right:0; text-align:left"><img height="740" src="https://static.oschina.net/uploads/space/2023/1207/121407_Tmg5_3820517.png" width="1052" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h3><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>自定義主題</span></span></span></span></strong></span></span></span></h3><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>TDesignFlutter 提供自定義主題的能力，可通過 json 文件配置顏色/字體尺寸/字體樣式/圓角/陰影等主題樣式。通過 TDTheme.of(context) 或者 TDTheme.defaultData() 獲取主題數據。</span></span></span></span></span></span></span></span></span></p><pre><span style="background-color:#fafafa"><span><code><span><span><span><span><span style="color:#000000"><span><span> TDTheme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>of</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>context</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>).</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>brandNormalColor</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> TDTheme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>defaultData</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>().</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>fontBodyLarge</span></span></span></span></span></span></span></code></span></span></pre><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>使用示例：</span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>下列代碼不設置特殊主題，使用 TDesingFlutter 默認主題：</span></span></span></span></span></span></span></span></span></p><pre><span style="background-color:#fafafa"><span><code><span><span><span><span><span style="color:#000000"><span><span>TDText</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>'測試文本'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> textColor</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> TDTheme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>of</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>context</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>).</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>brandNormalColor</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> font</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> TDTheme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>of</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>context</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>).</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>fontBodyMedium</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>),</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>const</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>TDButton</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> text</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>'演示按鈕'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> theme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> TDButtonTheme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>primary</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>)</span></span></span></span></span></span></span></code></span></span></pre><div>
 &nbsp;
</div><div><div><p style="margin-left:0; margin-right:0; text-align:left"><img height="320" src="https://static.oschina.net/uploads/space/2023/1207/121427_v0uq_3820517.png" width="638" referrerpolicy="no-referrer"></p></div></div><p><span><span><span><span><span><span><span style="color:#333333"><span><span>設置自定主題如下：</span></span></span></span></span></span></span></span></span></p><pre><span style="background-color:#fafafa"><span><code><span><span><span><span><span style="color:#dd4a68"><span><span>MaterialApp</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> theme</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>ThemeData</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> extensions</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>[</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>TDThemeData</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>.</span></span></span></span></span></span></span><span><span><span><span><span style="color:#dd4a68"><span><span>fromJson</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>(</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>'test'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> testThemeConfig</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>)</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>!</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>],</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>)</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span> ……</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>)</span></span></span></span></span></span></span></code></span></span></pre><p style="margin-left:0; margin-right:0; text-align:left">&nbsp;</p><pre><span style="background-color:#fafafa"><span><code><span><span><span><span><span style="color:#000000"><span><span>String testThemeConfig </span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>=</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>''</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>{</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"test"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>{</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"color"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>{</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"brandNormalColor"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"#D7B386"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>},</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"font"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>{</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"fontBodyMedium"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>{</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"size"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#990055"><span><span>40</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>,</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>"lineHeight"</span></span></span></span></span></span></span><span><span><span><span><span style="color:#9a6e3a"><span><span>:</span></span></span></span></span></span></span><span><span><span><span><span style="color:#990055"><span><span>55</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>}</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>}</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>}</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>}</span></span></span></span></span></span></span><span><span><span><span><span style="color:#669900"><span><span>''</span></span></span></span></span></span></span><span><span><span><span><span style="color:#000000"><span><span>'</span></span></span></span></span></span></span><span><span><span><span><span style="color:#999999"><span><span>;</span></span></span></span></span></span></span></code></span></span></pre><div>
 &nbsp;
</div><div><div><p style="margin-left:0; margin-right:0; text-align:left"><img height="344" src="https://static.oschina.net/uploads/space/2023/1207/121450_rEcV_3820517.png" width="524" referrerpolicy="no-referrer"></p></div></div><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>適用場景</span></span></span></span></strong></span></span></span></h1><ul><li><span><span><span><span><span><span><span style="color:#333333"><span><span>如果你是一個全新的業務，想要快速構建美觀一致的 FlutterAPP。 √</span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span style="color:#333333"><span><span>如果你使用 Flutter 系統組件構建了 APP，想要一款簡單易用、可快速遷移的組件庫提升開發效率。 √</span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span style="color:#333333"><span><span>如果你想客户端和 web 端使用風格統一的組件，或者後續需要支持 pc 桌面端應用。 √</span></span></span></span></span></span></span></span></span></li></ul><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>後續規劃</span></span></span></span></strong></span></span></span></h1><ul><li><span><span><span><span><span><span><span style="color:#333333"><span><span>提供更多可靠實用的組件</span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span style="color:#333333"><span><span>適配 Flutter Web 和 PC 桌面端,支持更多應用場景</span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span><span><span style="color:#333333"><span><span>提供更完善的單元測試模塊和性能檢測能力，確保組件更可靠和流暢</span></span></span></span></span></span></span></span></span></li></ul><h1><span><span><span><strong><span><span style="color:#1a1a1a"><span><span>反饋和共建</span></span></span></span></strong></span></span></span></h1><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>TDesignFlutter 現已開放，歡迎廣大設計師和開發者使用和反饋，參與共建通用企業級設計體系。</span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftdesign.tencent.com%2Fflutter" target="_blank">https://tdesign.tencent.com/flutter</a></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#333333"><span><span>項目地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FTencent%2Ftdesign-flutter" target="_blank">https://github.com/Tencent/tdesign-flutter</a></span></span></span></span></span></span></span></span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 04:16:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269901/tdesignflutter-opensource</guid>
            <link>https://www.oschina.net/news/269901/tdesignflutter-opensource</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Windows 10 將於 2025 年 10 月 14 日終止支持]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">微軟發佈<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcommunity.microsoft.com%2Ft5%2Fwindows-it-pro-blog%2Fplan-for-windows-10-eos-with-windows-11-windows-365-and-esu%2Fba-p%2F4000414" target="_blank">公告</a>稱，<span style="background-color:#ffffff">Windows 10 將於 2025 年 10 月 14 日終止支持 (EOS)。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">當 Windows 10 終止支持時，官方將不再提供問題的錯誤修復、漏洞的安全修復、時區更新或可能發生的問題的技術支持。22H2 版本是 Windows 10 的最終版本。Windows 10 的所有版本 22H2 都將在 2025 年 10 月 14 日前繼續支持每月安全更新。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">距離&nbsp;Windows 10 EOS&nbsp; 僅剩不到兩年的時間，</span>微軟方面敦促用户儘快向&nbsp;<span style="background-color:#ffffff">Windows 11&nbsp;</span>系統遷移，並提供了一系列的過渡指南。</span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">「<span style="background-color:#ffffff">Windows 11 是迄今為止最安全的 Windows。其廣泛的功能（包括 Windows 中的 Copilot）旨在幫助你的組織保持安全和高效。這些措施包括內置的高級加密、數據和憑據保護、強大的系統安全和網絡安全，以及針對不斷變化的威脅的智能防護措施。</span>」</span></p><p style="margin-left:0; margin-right:0; text-align:left"><img height="269" src="https://oscimg.oschina.net/oscnet/up-33aa42a83be38c18ba69809b1d17613b0f4.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">儘管如此，微軟 Windows 服務和交付團隊成員 Jason Leznek 也表示：「雖然我們強烈建議遷移到 Windows 11，但我們也理解有些情況可能會妨礙用户在 EOS&nbsp; 日期之前更換 Windows 10 設備。因此，微軟將提供擴展安全更新 (Extended Security Updates)。」</span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#000000"><span style="background-color:#ffffff">與 Windows 7 </span><span style="background-color:#ffffff">ESU&nbsp;</span><span style="background-color:#ffffff">一樣，</span>Windows 10 用户可以選擇購買安全更新的年度訂閲，可在服務終止日期後的三年內繼續接收每月的安全更新。不過，Windows 10 ESU 計劃只提供<span style="background-color:#ffffff">關鍵和/或重要的安全更新</span>。一字兒較小缺陷的補丁、功能請求或其他更改不一定會被考慮，技術支持也僅限於安全問題。</span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">目前有關&nbsp;<span style="background-color:#ffffff">Windows 10 ESU 的相關定價尚未公佈。Windows 7 ESU 定價為： 每台 Windows 7 Pro 設備第一年的價格為 50 美元；第二年為 100 美元；第三年為 200 美元。</span><span style="background-color:#ffffff">對於 Windows Enterprise 客户，價格則僅為其一半。</span></span></p><p style="margin-left:0; margin-right:0; text-align:left"><strong><span style="color:#000000"><span style="background-color:#ffffff">相關閲讀：</span></span></strong></p><ul><li style="text-align:left"><a href="https://www.oschina.net/news/264497/pigc-microsoft-extends-windows-10-support" target="_blank">公益組織請願微軟延長 Windows 10 支持</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 03:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269897</guid>
            <link>https://www.oschina.net/news/269897</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[維基百科推出「可編程」新項目：Wikifunctions]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>維基媒體基金會&nbsp;<span>(Wikimedia Foundation) <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwikimediafoundation.org%2Fnews%2F2023%2F12%2F05%2Fintroducing-wikifunctions-first-wikimedia-project-to-launch-in-a-decade-creates-new-forms-of-knowledge%2F" target="_blank">宣佈推出</a></u>&nbsp;</span><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wikifunctions.org%2Fwiki%2FWikifunctions%3AMain_Page" target="_blank">Wikifunctions</a></strong><span>，據稱這是該組織十多年來的第一個新項目。該項目讓志願者編輯<strong>能夠協作創建和維護一個函數庫</strong>——用於回答問題並增強有關維基媒體項目及其他項目的知識。</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-304d34c058f3401b98838b2b5ccf0208c6b.png" referrerpolicy="no-referrer"></p><p>「函數」是一系列編程指令，它根據提供的數據進行計算。通過 Wikifunctions，這些函數可以以任何語言存在，因此對於許多用户來説，<strong>這將是他們首次能夠用母語閲讀和編寫函數的項目</strong>。</p><p>Wikifunctions 的目標是使這些函數路徑更加容易訪問。它將提供一個單一的共享空間，簡化維護人員的工作並增加函數的可訪問性。最終，Wikifunctions 將與維基百科和其他維基媒體項目集成，為知識創造開闢新的機會。該項目將以維基百科的結構化數據為基礎，從其他維基媒體項目中彙集不同的數據源，從而利用函數代碼創建新形式的知識。</p><p><img src="https://oscimg.oschina.net/oscnet/up-eaa77a99abda8b84621cb9c8d3ccb01908a.png" referrerpolicy="no-referrer"></p><p><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wikifunctions.org%2Fwiki%2FWikifunctions%3AMain_Page" target="_blank">https://www.wikifunctions.org/wiki/Wikifunctions:Main_Page</a></u></em></p><p>Wikifunctions 作為底層技術基礎設施，將支持維基媒體基金會更廣泛的舉措，使人們能夠在維基百科上以更多語言分享更多知識。通過該項目，用户將能夠使用他們的母語創建和維護內容，其他用户可以在維基媒體項目提供的 300 多種語言中訪問這些內容。</p><p>Wikifunctions 於 2020 年獲得維基媒體基金會董事會的批准，今年早些時候作為只讀網站上線，現在任何人、任何地方都可以使用它。Wikifunctions 得到了 Google.org、洛克菲勒基金會和維基媒體捐贈基金的資助。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 03:37:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269893/wikifunctions-wikimedia</guid>
            <link>https://www.oschina.net/news/269893/wikifunctions-wikimedia</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[充電頭也能 OTA 升級？蘋果為電源適配器推送固件更新]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>蘋果公司近日為 30W 和 140W 的 USB-C 電源適配器推送了固件更新。</p><p>用户通過 MagSafe 3 或者 USB-C 連接到 Mac 設備之後，系統會自動開始更新。更新之後打開「系統信息」應用，點擊「電源」選項即可查看最新版本。</p><p>30W USB-C 電源適配器安裝的最新版本為&nbsp;<strong>Ver.1030053</strong>（上個版本為&nbsp;<span style="background-color:#ffffff; color:#333333">Ver.1030052</span>），ID 從 0x1674 升級到&nbsp;<strong>0x7003</strong>；</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-bf26c2e7e5c248d1a0aff7b7428adbbeb91.png" referrerpolicy="no-referrer"></p><p>140W USB-C 電源適配器安裝更新後版本號升級至&nbsp;<strong>Ver.1040073</strong>（上個版本為 <span style="background-color:#ffffff; color:#333333">Ver.1040068</span>）。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-01b90e9cd0dcfa5ab9bcb0ef1d2ab2b4b10.png" referrerpolicy="no-referrer"></p><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.macotakara.jp%2Fetc%2Fsupport%2Fentry-45789.html" target="_blank">https://www.macotakara.jp/etc/support/entry-45789.html</a></u></em>、<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.macotakara.jp%2Fetc%2Fsupport%2Fentry-45790.html" target="_blank">https://www.macotakara.jp/etc/support/entry-45790.html</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 03:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269879</guid>
            <link>https://www.oschina.net/news/269879</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[SQLite 重寫了 JSON 函數 —— 推出 JSONB]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>SQLite <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsqlite.org%2Fforum%2Fforumpost%2Ffa6f64e3dc1a5d97" target="_blank">宣佈推出 JSONB</a></u>，這是對 SQLite JSON 函數的重寫，宣稱比現有 JSON 函數「快幾倍」。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-7eec133035c4e37c1ac26035e420dcc9574.png" referrerpolicy="no-referrer"></p></blockquote><p>在過去幾年中，SQLite 開發者為改進 JSON 數據與該 SQL 數據庫的<strong>庫集成</strong>做了大量工作。最新的工作是<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsqlite.org%2Fsrc%2Finfo%2F7f0c79b94e8f55e5" target="_blank">已合併的 JSONB</a></u>。JSONB 對 SQLite JSON 函數進行了重寫，將 JSON 的內部使用從二進製表示形式更改改為連續的字節數組，可以作為 SQL BLOB 讀取或寫入。</p><p>JSONB 有助於降低解析 JSON 文本和表示用於存儲的 JSON 的開銷。</p><p>此外，JSONB 保留所有舊功能，並且所有 JSON 函數也可以接受 JSONB 二進制內容。如需瞭解有關 SQLite JSONB 功能及其更快性能潛力的更多信息，查看<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsqlite.org%2Fforum%2Fforumpost%2Ffa6f64e3dc1a5d97" target="_blank">https://sqlite.org/forum/forumpost/fa6f64e3dc1a5d97</a></u></em>。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 02:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269878/sqlite-lands-jsonb</guid>
            <link>https://www.oschina.net/news/269878/sqlite-lands-jsonb</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | JDK 21 虛擬線程原理及性能分析]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1>一、背景</h1><p style="color:#24292f; text-align:start">JDK21 在 9 月 19 號正式發佈，帶來了較多亮點，其中虛擬線程備受矚目，毫不誇張的説，它改變了高吞吐代碼的編寫方式，只需要小小的變動就可以讓目前的 IO 密集型程序的吞吐量得到提升，寫出高吞吐量的代碼不再困難。</p><p style="color:#24292f; text-align:start">本文將詳細介紹虛擬線程的使用場景，實現原理以及在 IO 密集型服務下的性能壓測效果。</p><span id="OSC_h1_2"></span><h1>二、為了提升吞吐性能，我們所做的優化</h1><p style="color:#24292f; text-align:start">在講虛擬線程之前，我們先聊聊為了提高吞吐性能，我們所做的一些優化方案。</p><span id="OSC_h2_3"></span><h2>串行模式</h2><p style="color:#24292f; text-align:start">在當前的微服務架構下，處理一次用户/上游的請求，往往需要多次調用下游服務、數據庫、文件系統等，再將所有請求的數據進行處理最終的結果返回給上游。<img alt="2.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/2.png" referrerpolicy="no-referrer"><img alt="3.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/3.png" referrerpolicy="no-referrer">在這種模式下，使用串行模式去查詢數據庫，下游 Dubbo/Http 接口，文件系統完成一次請求，接口整體的耗時等於各個下游的返回時間之和，這種寫法雖然簡單，但是接口耗時長、性能差，無法滿足 C 端高 QPS 場景下的性能要求。</p><span id="OSC_h2_4"></span><h2>線程池+Future 異步調用</h2><p style="color:#24292f; text-align:start">為瞭解決串行調用的低性能問題，我們會考慮使用並行異步調用的方式，最簡單的方式便是使用線程池 +Future 去並行調用。<img alt="4.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/4.jpeg" referrerpolicy="no-referrer">典型代碼如下：<img alt="11.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/11.png" referrerpolicy="no-referrer">這種方式雖然解決了大部分場景下的串行調用低性能問題，但是也存在着嚴重的弊端，由於存在 Future 的前後依賴關係，當使用場景存在大量的前後依賴時，會使得<strong>線程資源和 CPU 大量浪費在阻塞等待上</strong>，導致資源利用率低。</p><span id="OSC_h2_5"></span><h2>線程池+CompletableFuture 異步調用</h2><p style="color:#24292f; text-align:start">為了降低 CPU 的阻塞等待時間和提升資源的利用率，我們會使用 CompletableFuture 對調用流程進行編排，降低依賴之間的阻塞。</p><p style="color:#24292f; text-align:start">CompletableFuture 是由 Java8 引入的，在 Java8 之前一般通過 Future 實現異步。Future 用於表示異步計算的結果，如果存在流程之間的依賴關係，那麼只能通過阻塞或者輪詢的方式獲取結果，同時原生的 Future 不支持設置回調方法，Java8 之前若要設置回調可以使用 Guava 的 ListenableFuture，回調的引入又會導致回調地獄，代碼基本不具備可讀性。</p><p style="color:#24292f; text-align:start">而 CompletableFuture 是對 Future 的擴展，原生支持通過設置回調的方式處理計算結果，同時也支持組合編排操作，一定程度解決了回調地獄的問題。</p><p style="color:#24292f; text-align:start">使用 CompletableFuture 的實現方式如下：<img alt="101.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/101.png" referrerpolicy="no-referrer">CompletableFuture 雖然一定程度上面緩解了 CPU 資源<strong>大量浪費在阻塞等待上的問題</strong>，但是隻是緩解，核心的問題始終沒有解決。這兩個問題導致 CPU 無法充分被利用，系統吞吐量容易達到瓶頸。</p><ul><li><strong>線程資源浪費瓶頸始終在 IO 等待上</strong>，導致 CPU 資源利用率較低。目前大部分服務是 IO 密集型服務，一次請求的處理耗時大部分都消耗在等待下游 RPC，數據庫查詢的 IO 等待中，此時線程仍然只能阻塞等待結果返回，導致 CPU 的利用率很低。</li><li><strong>線程數量存在限制</strong>，<span>&nbsp;</span><strong>為了增加併發度，我們會給線程池配置更大的線程數</strong>，但是線程的數量是有限制的，Java 的線程模型是 1:1 映射平台線程的，導致 Java 線程創建的成本很高，不能無限增加。同時隨着 CPU 調度線程數的增加，會導致更嚴重的資源爭用，寶貴的 CPU 資源被損耗在上下文切換上。</li></ul><span id="OSC_h1_6"></span><h1>三、一請求一線程的模型</h1><p style="color:#24292f; text-align:start">在給出最終解決方案之前，我們先聊一聊 Web 應用中常見的一請求一線程的模型。</p><p style="color:#24292f; text-align:start">在 Web 中我們最常見的請求模型就是使用一請求一線程的模型，每個請求都由單獨的線程處理。此模型易於理解和實現，對編碼的可讀性，Debug 都非常友好，但是，它有一些缺點。當線程執行阻塞操作（如連接到數據庫或進行網絡調用）時，線程會被阻塞，直到操作完成，這意味着線程在此期間將無法處理任何其他請求。<img alt="45.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/45.jpeg" referrerpolicy="no-referrer">當遇到大促或突發流量等場景導致服務承受的請求數增大時，為了保證每個請求在儘可能短的時間內返回，減少等待時間，我們經常會採用以下方案：</p><ul><li><strong>擴大服務最大線程數</strong>，簡單有效，由於存在下列問題，導致平台線程有最大數量限制，不能大量擴充。 
  <ul><li>系統資源有限導致系統線程總量有限，進而導致與系統線程一一對應的平台線程有限。</li><li>平台線程的調度依賴於系統的線程調度程序，當平台線程創建過多，會消耗大量資源用於處理線程上下文切換。</li><li>每個平台線程都會開闢一塊大小約 1m 私有的棧空間，大量平台線程會佔據大量內存。<img alt="44.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/44.png" referrerpolicy="no-referrer"></li></ul></li><li><strong>垂直擴展，升級機器配置，水平擴展，增加服務節點</strong>，也就是俗稱的升配擴容大法，效果好，也是最常見的方案，缺點是會增加成本，同時有些場景下擴容並不能 100% 解決問題。</li><li><strong>採用異步/響應式編程方案</strong>，例如 RPC NIO 異步調用，WebFlux，Rx-Java 等非阻塞的基於 Ractor 模型的框架，使用事件驅動使得少量線程即可實現高吞吐的請求處理，擁有較好的性能與優秀的資源利用，缺點是學習成本較高兼容性問題較大，編碼風格與目前的一請求一線程的模型差異較大，理解難度大，同時對於代碼的調試比較困難。</li></ul><p style="color:#24292f; text-align:start"><strong>那麼有沒有一種方法可以易於編寫，方便遷移，符合日常編碼習慣，同時性能很不錯，CPU 資源利用率較高的方案呢?</strong></p><p style="color:#24292f; text-align:start"><strong>JDK21 中的虛擬線程可能給出了答案</strong>， JDK 提供了與 Thread 完全一致的抽象 Virtual Thread 來應對這種經常阻塞的情況，阻塞仍然是會阻塞，但是換了阻塞的對象，由昂貴的平台線程阻塞改為了成本很低的虛擬線程的阻塞，當代碼調用到阻塞 API 例如 IO，同步，Sleep 等操作時，JVM 會自動把<span>&nbsp;</span><strong>Virtual Thread 從平台線程上卸載</strong>，平台線程就會去處理下一個虛擬線程，通過這種方式，提升了平台線程的利用率，讓平台線程不再阻塞在等待上，<strong>從底層實現了少量平台線程就可以處理大量請求，提高了服務吞吐和 CPU 的利用率。</strong></p><span id="OSC_h1_7"></span><h1>四、虛擬線程</h1><span id="OSC_h2_8"></span><h2>線程術語定義</h2><p style="color:#24292f; text-align:start"><strong>操作系統線程（OS Thread）</strong>：由操作系統管理，是操作系統調度的基本單位。</p><p style="color:#24292f; text-align:start"><strong>平台線程（Platform Thread）</strong>：Java.Lang.Thread 類的每個實例，都是一個平台線程，是 Java 對操作系統線程的包裝，與操作系統是 1:1 映射。</p><p style="color:#24292f; text-align:start"><strong>虛擬線程（Virtual Thread）</strong>：一種輕量級，由 JVM 管理的線程。對應的實例 java.lang.VirtualThread 這個類。</p><p style="color:#24292f; text-align:start"><strong>載體線程（Carrier Thread）</strong>：指真正負責執行虛擬線程中任務的平台線程。一個虛擬線程裝載到一個平台線程之後，那麼這個平台線程就被稱為虛擬線程的載體線程。</p><span id="OSC_h2_9"></span><h2>虛擬線程定義</h2><p style="color:#24292f; text-align:start">JDK 中 java.lang.Thread 的每個實例都是一個平台線程。平台線程在底層操作系統線程上運行 Java 代碼，並在代碼的整個生命週期內獨佔操作系統線程，平台線程實例本質是由系統內核的線程調度程序進行調度，並且<strong>平台線程的數量受限於操作系統線程的數量</strong>。</p><p style="color:#24292f; text-align:start"><strong>而虛擬線程 (Virtual Thread) 它不與特定的操作系統線程相綁定</strong>。它在平台線程上運行 Java 代碼，但在代碼的整個生命週期內不獨佔平台線程。**這意味着許多虛擬線程可以在同一個平台線程上運行他們的 Java 代碼，共享同一個平台線程。**同時虛擬線程的成本很低，<strong>虛擬線程的數量可以比平台線程的數量大得多。</strong><img alt="17.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/17.png" referrerpolicy="no-referrer"></p><span id="OSC_h2_10"></span><h2>虛擬線程創建</h2><p style="color:#24292f; text-align:start"><strong>方法一：直接創建虛擬線程</strong></p><pre><code>Thread vt = Thread.startVirtualThread(() -&gt; {
    System.out.println("hello wolrd virtual thread");
});
</code></pre><p style="color:#24292f; text-align:start"><strong>方法二：創建虛擬線程但不自動運行，手動調用 start() 開始運行</strong></p><pre><code>Thread.ofVirtual().unstarted(() -&gt; {
    System.out.println("hello wolrd virtual thread");
});
vt.start();
</code></pre><p style="color:#24292f; text-align:start"><strong>方法三：通過虛擬線程的 ThreadFactory 創建虛擬線程</strong></p><pre><code>ThreadFactory tf = Thread.ofVirtual().factory();
Thread vt = tf.newThread(() -&gt; {
    System.out.println("Start virtual thread...");
    Thread.sleep(1000);
    System.out.println("End virtual thread. ");
});
vt.start();
</code></pre><p style="color:#24292f; text-align:start"><strong>方法四：Executors.newVirtualThreadPer</strong><span>&nbsp;</span><strong>-TaskExecutor()</strong></p><pre><code>
ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
executor.submit(() -&gt; {
    System.out.println("Start virtual thread...");
    Thread.sleep(1000);
    System.out.println("End virtual thread.");
    return true;
});
</code></pre><span id="OSC_h2_11"></span><h2>虛擬線程實現原理</h2><p style="color:#24292f; text-align:start">虛擬線程是由 Java 虛擬機調度，而不是操作系統。虛擬線程佔用空間小，同時使用輕量級的任務隊列來調度虛擬線程，避免了線程間基於內核的上下文切換開銷，因此可以極大量地創建和使用。</p><p style="color:#24292f; text-align:start"><strong>簡單來看，虛擬線程實現如下：virtual thread =continuation+scheduler+runnable</strong></p><p style="color:#24292f; text-align:start">虛擬線程會把任務（java.lang.Runnable 實例）包裝到一個 Continuation 實例中:</p><ul><li>當任務需要阻塞掛起的時候，會調用 Continuation 的 yield 操作進行阻塞，虛擬線程會從平台線程卸載。</li><li>當任務解除阻塞繼續執行的時候，調用 Continuation.run 會從阻塞點繼續執行。</li></ul><p style="color:#24292f; text-align:start">Scheduler 也就是執行器，由它將任務提交到具體的載體線程池中執行。</p><ul><li>它是 java.util.concurrent.Executor 的子類。</li><li>虛擬線程框架提供了一個默認的 FIFO 的 ForkJoinPool 用於執行虛擬線程任務。</li></ul><p style="color:#24292f; text-align:start">Runnable 則是真正的任務包裝器，由 Scheduler 負責提交到載體線程池中執行。</p><p style="color:#24292f; text-align:start">JVM 把虛擬線程分配給平台線程的操作稱為 mount（掛載），取消分配平台線程的操作稱為 unmount（卸載）：</p><p style="color:#24292f; text-align:start"><strong>mount 操作</strong>：虛擬線程掛載到平台線程，虛擬線程中包裝的 Continuation 堆棧幀數據會被拷貝到平台線程的線程棧，這是一個從堆複製到棧的過程。</p><p style="color:#24292f; text-align:start"><strong>unmount 操作</strong>：虛擬線程從平台線程卸載，此時虛擬線程的任務還沒有執行完成，所以虛擬線程中包裝的 Continuation 棧數據幀會會留在堆內存中。</p><p style="color:#24292f; text-align:start">從 Java 代碼的角度來看，其實是看不到虛擬線程及載體線程共享操作系統線程的，會認為虛擬線程及其載體都在同一個線程上運行，因此，在同一虛擬線程上多次調用的代碼可能會在每次調用時掛載的載體線程都不一樣。JDK 中使用了<span>&nbsp;</span><strong>FIFO 模式的 ForkJoinPool 作為虛擬線程的調度器</strong>，從這個調度器看虛擬線程任務的執行流程大致如下：</p><ul><li>調度器（線程池）中的平台線程等待處理任務。<img alt="66.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/66.png" referrerpolicy="no-referrer"></li><li>一個虛擬線程被分配平台線程，該平台線程作為載體線程執行虛擬線程中的任務。<img alt="90.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/90.png" referrerpolicy="no-referrer"></li><li>虛擬線程運行其 Continuation，Mount(掛載) 平台線程後，最終執行 Runnable 包裝的用户實際任務。<img alt="009.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/009.png" referrerpolicy="no-referrer"></li><li>虛擬線程任務執行完成，標記 Continuation 終結，標記虛擬線程為終結狀態，清空上下文，等待 GC 回收，解除掛載載體線程會返還到調度器（線程池）中等待處理下一個任務。<img alt="102.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/102.png" referrerpolicy="no-referrer"></li></ul><p style="color:#24292f; text-align:start">上面是沒有阻塞場景的虛擬線程任務執行情況，如果遇到了阻塞 (例如 Lock 等) 場景，會觸發 Continuation 的 yield 操作讓出控制權，等待虛擬線程重新分配載體線程並且執行，具體見下面的代碼：</p><pre><code> ReentrantLock lock = new ReentrantLock();
        Thread.startVirtualThread(() -&gt; {
            lock.lock();    
        });
        // 確保鎖已經被上面的虛擬線程持有
        Thread.sleep(1000);  
        Thread.startVirtualThread(() -&gt; {
            System.out.println("first");
            會觸發 Continuation 的 yield 操作
            lock.lock(); 
            try {
                System.out.println("second");
            } finally {
                lock.unlock();
            }
            System.out.println("third");
        });
        Thread.sleep(Long.MAX_VALUE);
    }
</code></pre><p>虛擬線程中任務執行時候調用 Continuation#run()<span>&nbsp;</span><strong>先執行了部分任務代碼，然後嘗試獲取鎖</strong>，該操作是阻塞操作會導致 Continuation 的 yield 操作讓出控制權，如果 yield 操作成功，會從載體線程 unmount，載體線程棧數據會移動到 Continuation 棧的數據幀中，保存在堆內存中，虛擬線程任務完成，此時虛擬線程和 Continuation 還沒有終結和釋放，載體線程被釋放到執行器中等待新的任務；如果 Continuation 的 yield 操作失敗，則會對載體線程進行 Park 調用，<strong>阻塞在載體線程上，此時虛擬線程和載體線程同時會被阻塞</strong>，本地方法，Synchronized 修飾的同步方法都會導致 yield 失敗。<img alt="008.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/008.png" referrerpolicy="no-referrer"></p><p>當鎖持有者釋放鎖之後，<strong>會喚醒虛擬線程獲取鎖</strong>，獲取鎖成功後，虛擬線程會重新進行 mount，讓虛擬線程任務再次執行，<strong>此時有可能是分配到另一個載體線程中執行</strong>，Continuation 棧會的數據幀會被恢復到載體線程棧中，然後再次調用 Continuation#run() 恢復任務執行。<img alt="172.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/172.png" referrerpolicy="no-referrer"></p><p>虛擬線程任務執行完成，標記 Continuation 終結，標記虛擬線程為終結狀態，清空上下文變量，解除載體線程的掛載載體線程返還到調度器（線程池）中作為平台線程等待處理下一個任務。</p><p style="color:#24292f; text-align:start">Continuation 組件十分重要，<strong>它既是用户真實任務的包裝器，同時提供了虛擬線程任務暫停/繼續的能力，以及虛擬線程與平台線程數據轉移功能，當任務需要阻塞掛起的時候，調用 Continuation 的 yield 操作進行阻塞。當任務需要解除阻塞繼續執行的時候，則調用 Continuation 的 run 恢復執行。</strong></p><p style="color:#24292f; text-align:start">通過下面的代碼可以看出 Continuation 的神奇之處，通過在編譯參數加上--add-exports java.base/jdk.internal.vm=ALL-UNNAMED 可以在本地運行。</p><pre><code>ContinuationScope scope = new ContinuationScope("scope");
Continuation continuation = new Continuation(scope， () -&gt; {
    System.out.println("before yield 開始");
    Continuation.yield(scope);
    System.out.println("after yield 結束");
});
System.out.println("1 run");
// 第一次執行 Continuation.run
continuation.run();
System.out.println("2 run");
// 第二次執行 Continuation.run
continuation.run();
System.out.println("Done");
</code></pre><p style="color:#24292f; text-align:start"><img alt="756.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/756.png" referrerpolicy="no-referrer">通過上述案例可以看出，<strong>Continuation 實例進行 yield 調用後，再次調用其 run 方法就可以從 yield 的調用之處繼續往下執行，從而實現了程序的中斷和恢復。</strong></p><span id="OSC_h2_12"></span><h2>虛擬線程內存佔用評估</h2><p style="color:#24292f; text-align:start"><strong>單個平台線程的資源佔用：</strong></p><ul><li>根據 JVM 規範，預留 1 MB 線程棧空間。</li><li>平台線程實例，會佔據 2000+ byte 數據。</li></ul><p style="color:#24292f; text-align:start"><strong>單個虛擬線程的資源佔用：</strong></p><ul><li>Continuation 棧會佔用數百 byte 到數百 KB 內存空間，是作為堆棧塊對象存儲在 Java 堆中。</li><li>虛擬線程實例會佔據 200 - 240 byte 數據。</li></ul><p style="color:#24292f; text-align:start">從對比結果來看，<strong>理論上單個平台線程佔用的內存空間至少是 KB 級別的，而單個虛擬線程實例佔用的內存空間是 byte 級別</strong>，兩者的內存佔用差距較大，這也是虛擬線程可以大批量創建的原因。</p><p style="color:#24292f; text-align:start">下面通過一段程序去測試平台線程和虛擬線程的內存佔用：</p><pre><code>private static final int COUNT = 4000;

/**
 *  -XX:NativeMemoryTracking=detail
 *
 * @param args args
 */
public static void main(String[] args) throws Exception {
    for (int i = 0; i &lt; COUNT; i++) {
        new Thread(() -&gt; {
            try {
                Thread.sleep(Long.MAX_VALUE);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }， String.valueOf(i)).start();
    }
    Thread.sleep(Long.MAX_VALUE);
}
</code></pre><p style="color:#24292f; text-align:start">上面的程序運行後啓動 4000 平台線程，通過 -XX:NativeMemoryTracking=detail 參數和 JCMD 命令查看所有線程佔據的內存空間如下：<img alt="890.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/890.jpeg" referrerpolicy="no-referrer">內存佔用大部分來自創建的平台線程，<strong>總線程棧空間佔用約為 8096 MB，兩者加起來佔據總使用內存（8403MB）的 96% 以上。</strong></p><p style="color:#24292f; text-align:start">用類似的方式編寫運行虛擬線程的程序：</p><pre><code>private static final int COUNT = 4000;

/**
 * -XX:NativeMemoryTracking=detail
 *
 * @param args args
 */
public static void main(String[] args) throws Exception {
    for (int i = 0; i &lt; COUNT; i++) {
        Thread.startVirtualThread(() -&gt; {
            try {
                Thread.sleep(Long.MAX_VALUE);
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
    }
    Thread.sleep(Long.MAX_VALUE);
}
</code></pre><p style="color:#24292f; text-align:start">上面的程序運行後啓動 4000 虛擬線程：<img alt="123.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/123.jpeg" referrerpolicy="no-referrer">堆內存的實際佔用量和總內存的實際佔用量都不超過 300 MB，可以證明虛擬線程在大量創建的前提下也不會去佔用過多的內存，且<strong>虛擬線程的堆棧是作為堆棧塊對象存儲在 Java 的堆中的，可以被 GC 回收，又降低了虛擬線程的佔用。</strong></p><span id="OSC_h2_13"></span><h2>虛擬線程的侷限及使用建議</h2><ul><li>虛擬線程存在 native 方法或者外部方法 (Foreign Function &amp; Memory API，jep 424 ) 調用不能進行 yield 操作，此時載體線程會被阻塞。</li><li>當運行在 synchronized 修飾的代碼塊或者方法時，不能進行 yield 操作，此時載體線程會被阻塞，推薦使用 ReentrantLock。</li><li><strong>ThreadLocal 相關問題</strong>，目前虛擬線程仍然是支持 ThreadLocal 的，但是由於虛擬線程的數量非常多，會導致 Threadlocal 中存的線程變量非常多，需要頻繁 GC 去清理，對性能會有影響，官方建議儘量少使用 ThreadLocal，同時不要在虛擬線程的 ThreadLocal 中放大對象，目前官方是想通過 ScopedLocal 去替換掉 ThreadLocal，但是在 21 版本還沒有正式發佈，<strong>這個可能是大規模使用虛擬線程的一大難題</strong>。</li><li><strong>無需池化虛擬線程</strong><span>&nbsp;</span>虛擬線程佔用的資源很少，因此可以大量地創建而無須考慮池化，它不需要跟平台線程池一樣，平台線程的創建成本比較昂貴，所以通常選擇去池化，去做共享，<strong>但是池化操作本身會引入額外開銷</strong>，對於虛擬線程池化反而是得不償失，使用虛擬線程我們拋棄池化的思維，用時創建，用完就扔。</li></ul><span id="OSC_h2_14"></span><h2>虛擬線程適用場景</h2><ul><li>大量的 IO 阻塞等待任務，例如下游 RPC 調用，DB 查詢等。</li><li>大批量的處理時間較短的計算任務。</li><li>Thread-per-request (一請求一線程) 風格的應用程序，例如主流的 Tomcat 線程模型或者基於類似線程模型實現的 SpringMVC 框架 ，這些應用只需要小小的改動就可以帶來巨大的吞吐提升。</li></ul><span id="OSC_h1_15"></span><h1>五、虛擬線程壓測性能分析</h1><p style="color:#24292f; text-align:start">在下面的測試中，我們將模擬最常使用的場景-使用 Web 容器去處理 Http 請求。</p><p style="color:#24292f; text-align:start"><strong>場景一：</strong><span>&nbsp;</span>在 Spring Boot 中使用內嵌的 Tomcat 去處理 Http 請求，<strong>使用默認的平台線程池作為 Tomcat 的請求處理線程池。</strong></p><p style="color:#24292f; text-align:start"><strong>場景二</strong>：使用<strong>Spring -WebFlux</strong>創建基於事件循環模型的應用程序，進行響應式請求處理。</p><p style="color:#24292f; text-align:start"><strong>場景三：</strong><span>&nbsp;</span>在 Spring Boot 中使用內嵌的 Tomcat 去處理 Http 請求，<strong>使用虛擬線程池作為 Tomcat 的請求處理線程池</strong><span>&nbsp;</span>(Tomcat 已支持虛擬線程)。</p><span id="OSC_h2_16"></span><h2>測試流程</h2><ul><li>Jmeter 開啓 500 個線程去並行發起請求。每個線程將等待請求響應後再發起下一次請求，單次請求超時時間為 10s，測試時間持續 60s。</li><li>測試的 Web Server 將接受 Jmeter 的請求，並調用慢速服務器獲取響應並返回。</li><li>慢速服務器以隨機超時響應。最大響應時間為 1000ms。平均響應時間為 500ms。<img alt="46.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/46.png" referrerpolicy="no-referrer"></li></ul><span id="OSC_h2_17"></span><h2>衡量指標</h2><p style="color:#24292f; text-align:start"><strong>吞吐量和平均響應時間</strong>，吞吐量越高，平均響應時間越低，性能就越好。</p><span id="OSC_h2_18"></span><h2>Tomcat+普通線程池</h2><p style="color:#24292f; text-align:start">默認情況下，Tomcat 使用一請求一線程模型處理請求，當 Tomcat 收到請求時，會從線程池中取一個線程去處理請求，該分配的線程將一直保持佔用狀態，直到請求結束才會釋放。當線程池中沒有線程時，請求會一直阻塞在隊列中，直到有請求結束釋放線程。默認隊列長度為 Integer.MAX。</p><span id="OSC_h3_19"></span><h3>默認線程池</h3><p style="color:#24292f; text-align:start">默認情況下，線程池最多包含 200 個線程。這基本上意味着單個時間點最多處理 200 個請求。對於每個請求服務都會以阻塞的方式調用平均 RT500ms 的慢速服務器。因此，可以預期每秒 400 個請求的吞吐量，最終壓測結果非常接近預期值，為 388 req/sec。<img alt="112.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/112.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>增加線程池</strong></p><p style="color:#24292f; text-align:start">生產環境為了吞吐考慮,一般不會使用默認值,會把線程池增大到 server.tomcat.threads.max=500+，調整到 500+ 之後的壓測結果如下：<img alt="998.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/998.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">可以看出最終的吞吐量和線程數量呈比例上升，同時由於線程數的增加，請求等待減少，平均 RT 趨向於慢速服務器的響應平均 RT。</p><p style="color:#24292f; text-align:start">但是需要注意的是，平台線程的創建受到內存和 Java 線程映射模型的限制，不能無限擴展，同時大量線程會導致 CPU 資源大量消耗在上下文切換時，整體性能反而降低。</p><span id="OSC_h2_20"></span><h2>WebFlux</h2><p style="color:#24292f; text-align:start">WebFlux 跟傳統的 Tomcat 線程模型不一樣，他不會為每個請求分配一個專用線程，而是使用事件循環模型通過非阻塞 I/O 操作同時處理多個請求，這使得它能夠用有限的線程數量處理大量的併發請求。</p><p style="color:#24292f; text-align:start">在壓測的場景下，使用 WebClient 來進行一個非阻塞的 Http 調用慢速處理器，並使用 RouterFunction 來做請求映射和處理。</p><pre><code>@Bean
public WebClient slowServerClient() {
    return WebClient.builder()
            .baseUrl("http://127.0.0.1:8000")
            .build();
}

@Bean
public RouterFunction&lt;ServerResponse&gt; routes(WebClient slowServerClient) {
    return route(GET("/")， (ServerRequest req) -&gt; ok()
            .body(
                    slowServerClient
                            .get()
                            .exchangeToFlux(resp -&gt; resp.bodyToFlux(Object.class))，
                    Object.class
            ));
}

</code></pre><p style="color:#24292f; text-align:start">WebFlux 壓測結果如下：<img alt="087.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/087.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">可以看到，WebFlux 的請求完全沒有阻塞，僅用了 25 個線程就達到了 964 req/sec 的吞吐。</p><span id="OSC_h2_21"></span><h2>Tomcat+虛擬線程池</h2><p style="color:#24292f; text-align:start">與平台線程相比，虛擬線程的內存佔用量要低得多，運行程序大量的創建虛擬線程，而不會耗盡系統資源；同時當遇到 Thread.sleep()，CompletableFuture.await()，等待 I/O，獲取鎖時，虛擬線程會自動卸載，JVM 可以自動切換到另外的等待就緒的虛擬線程，提升單個平台線程的利用率，保證平台線程不會浪費在無意義的阻塞等待上。</p><p style="color:#24292f; text-align:start">要想使用虛擬線程，需要先在啓動參數中加上 --enable-preview，同時 Tomcat 在 10 版本已支持虛擬線程，我們只需要替換 Tomcat 的平台線程池為虛擬線程池即可。</p><pre><code>@Bean
public TomcatProtocolHandlerCustomizer&lt;?&gt; protocolHandler() {
    return protocolHandler -&gt;
            protocolHandler.setExecutor(Executors.newVirtualThreadPerTaskExecutor());
}


private final RestTemplate restTemplate;

@GetMapping
public ResponseEntity&lt;Object&gt; callSlowServer(){
    return restTemplate.getForEntity("http://127.0.0.1:8000"， Object.class);
}
</code></pre><p style="color:#24292f; text-align:start">最終壓測結果如下：<img alt="665.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/665.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">可以看到虛擬線程的壓測結果實際上與 WebFlux 的情況相同，<strong>但我們根本沒有使用任何複雜的響應式編程技術</strong>。同時對慢速服務器的調用，也使用常規的阻塞 RestTemplate。<strong>我們所做的只是用虛擬線程執行器替換線程池就達到更復雜的 Webflux 寫法相同的效果。</strong></p><p style="color:#24292f; text-align:start">總的壓測結果如下：<img alt="109.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/109.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">通過以上壓測結果，我們可以得出以下結論：</p><ul><li>傳統的線程池模式效果差強人意，可以通過提高線程數量可以提升吞吐，但是需要考慮到系統容量和資源限制，但是對於大部分場景來説使用線程池去處理阻塞操作仍然是主流且不錯的選擇。</li><li>WebFlux 的效果非常好，但是考慮到需要完全按照響應式風格進行開發，成本及難度較大，同時 WebFlux 與現有的一些主流框架存在一些兼容問題，例如 Mysql 官方 IO 庫不支持 NIO、Threadlocal 兼容問題等等。現有應用的遷移基本要重寫所有代碼，改動量和風險都不可控。</li><li><strong>虛擬線程的效果非常好，最大的優勢就是我們沒有修改代碼或採用任何反應式技術，唯一更改是將線程池替換為虛擬線程</strong>。雖然改動較小，但與使用線程池相比，性能結果得到了顯著改善。</li></ul><p style="color:#24292f; text-align:start">基於上述的壓測結果，可以較為樂觀的認為虛擬線程會顛覆我們目前的服務和框架中的請求處理方法。</p><span id="OSC_h1_22"></span><h1>六、總結</h1><p style="color:#24292f; text-align:start">過去很長時間，在編寫服務端應用時，我們對於每個請求，都使用獨佔的線程來處理，請求之間是相互獨立的，這就是<span>&nbsp;</span><strong>一請求一線程的模型</strong>這種方式易於理解和編程實現，也易於調試和性能調優。</p><p style="color:#24292f; text-align:start">然而，一請求一線程風格並不能簡單地使用平台線程來實現，因為平台線程是操作系統中線程的封裝。操作系統的線程會申請成本較高，存在數量上限。**對於一個要併發處理海量請求的服務器端應用來説，對每個請求都創建一個平台線程是不現實的。**在這種前提下，湧現出一批非阻塞 I/O 和異步編程框架，如 WebFlux ，RX-Java。當某個請求在等待 I/O 操作時，它會暫時讓出線程，並在 I/O 操作完成之後繼續執行。通過這種方式，可以用少量線程同時處理大量的請求。這些框架可以提升系統的吞吐量，但是要求開發人員必須熟悉所使用的底層框架，並按照響應式的風格來編寫代碼，響應式框架的調試困難，學習成本，兼容問題使得大部分人望而卻步 。 在使用虛擬線程之後，一切都將改變，開發人員可以使用目前最習慣舒服的方式來編寫代碼，<strong>高性能和高吞吐由虛擬線程自動幫你完成，這極大地降低了編寫高併發服務應用的難度。</strong></p><p style="color:#24292f; text-align:start"><strong>參考文檔：</strong></p><p style="color:#24292f; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F444" target="_blank">https://openjdk.org/jeps/444</a></p><p style="color:#24292f; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F514719325" target="_blank">https://zhuanlan.zhihu.com/p/514719325</a></p><p style="color:#24292f; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.vlts.cn%2Fpost%2Fvirtual-thread-source-code%23%25E5%2589%258D%25E6%258F%2590" target="_blank">https://www.vlts.cn/post/virtual-thread-source-code#%E5%89%8D%E6%8F%90</a></p><p style="color:#24292f; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F499342616" target="_blank">https://zhuanlan.zhihu.com/p/499342616</a></p><p style="color:#24292f; text-align:start">*<strong>文/creed</strong></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">本文屬得物技術原創，更多精彩文章請看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.dewu.com" target="_blank">得物技術官網</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">未經得物技術許可嚴禁轉載，否則依法追究法律責任！</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 02:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/10319533</guid>
            <link>https://my.oschina.net/u/5783135/blog/10319533</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[蘋果開源深度學習框架 MLX，專門針對 Apple Silicon 芯片優化]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>蘋果開源了針對 Apple Silicon 芯片優化的 MLX 深度學習框架，並表示該框架可以簡化研究人員在&nbsp;<span>Mac、iPad、iPhone 平台設計和部署模型的過程。</span></p><p><img src="https://oscimg.oschina.net/oscnet/up-5c9da56834a3118a57e83b8ae26e0181df3.png" referrerpolicy="no-referrer"></p><p>地址：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fml-explore%2Fmlx" target="_blank">https://github.com/ml-explore/mlx</a></u></em></p><p>根據介紹，該深度學習框架提供了與主流開發工具接軌的 API、支持延遲計算、採用動態設計並軟硬結合、對研究人員較為友好，且具有統一內存優勢。</p><p><strong>MLX 主要特性</strong></p><ul><li><p><strong>提供開發者熟悉的 API</strong>：MLX 具有和 NumPy 接近的 Python API，此外還擁有功能齊全的 C++ API，它與 Python API 非常相似。 MLX 具有<code>mlx.nn</code>和<code>mlx.optimizers</code>等更高級別的包，其 API 緊密貼合 PyTorch，以簡化構建更復雜的模型</p></li><li><p><strong>可組合函數轉換</strong>：MLX 具有用於自動微分、自動矢量化和計算圖優化的可組合函數轉換</p></li><li><p><strong>惰性計算 (Lazy computation)</strong>：MLX 中的計算是惰性計算。數組僅在需要時才會具體化</p></li><li><p><strong>動態圖構建</strong>：MLX 中的計算圖採用動態構建，更改函數參數的形狀不會觸發緩慢的編譯，並且調試簡單直觀</p></li><li><p><strong>多設備：</strong>可以在任何支持的設備上運行（當前為 CPU 和 GPU），確保用户能夠充分利用硬件</p></li><li><p><strong>具備統一內存優勢</strong>：MLX 和其他框架的顯着區別是採用統一內存模型。 MLX 中的數組位於共享內存中，可以在任何支持的設備類型上執行 MLX 陣列上的操作，而無需移動數據。</p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 02:25:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269870</guid>
            <link>https://www.oschina.net/news/269870</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[麥當勞中國啓動鴻蒙原生應用開發]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">麥當勞中國 12 月 6 日與華為達成鴻蒙合作協議，正式宣佈麥當勞中國 APP 將基於 HarmonyOS NEXT 啓動鴻蒙原生應用開發。</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">中國市場已經成為了麥當勞全球的第二大市場。</span>麥當勞中國在中國市場坐擁 5500 多家餐廳，擁有超過 20 萬員工，每年服務顧客超過十億人次，成為首批啓動鴻蒙原生應用開發的全球大型連鎖餐飲企業。</span></p><p><span style="color:#000000"><img alt="" height="334" src="https://oscimg.oschina.net/oscnet/up-0f4b27f891e839fc65b056b51f6d64a2c7d.jpg" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">目前，美團、去哪兒、新浪、釘釘、螞蟻集團、小紅書、58 集團、嗶哩嗶哩、高德地圖等均已啓動鴻蒙原生應用開發。</span></p><p><span style="background-color:#ffffff; color:#000000">華為終端雲服務開發者服務與平台部總裁望嶽表示：「麥當勞中國啓動鴻蒙原生應用開發，是鴻蒙生態發展在餐飲界的又一次重要突破。」</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 02:22:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269869</guid>
            <link>https://www.oschina.net/news/269869</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
