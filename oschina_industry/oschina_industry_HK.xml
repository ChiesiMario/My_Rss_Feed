<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-綜合資訊]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Sun, 10 Dec 2023 06:19:26 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[每日一博 | 從瀏覽器原理出發聊聊 Chrome 插件]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h3_1"></span><h3>瀏覽器架構演進</h3><p style="text-align:justify"><strong>單進程瀏覽器時代</strong></p><p style="text-align:justify">單進程瀏覽器是指瀏覽器的所有功能模塊都是運行在同一個進程裏，這些模塊包含了網絡、插件、JavaScript 運行環境、渲染引擎和頁面等。在 2007 年之前，市面上瀏覽器都是單進程的。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-3442db3861bb3221f7e853cfffa1ea45_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">單進程瀏覽器的架構</p><p style="text-align:justify">很多功能模塊運行在一個進程裏，是導致單進程瀏覽器不穩定、不流暢和不安全的一個主要因素。</p><ul><li><strong>不穩定：</strong>早期瀏覽器需要藉助於插件來實現諸如 Web 視頻、Web 遊戲等各種強大的功能，但是插件是最容易出問題的模塊，並且還運行在瀏覽器進程之中，所以一個插件的意外崩潰會引起整個瀏覽器的崩潰。除了插件之外，渲染引擎模塊也是不穩定的，通常一些複雜的 JavaScript 代碼就有可能引起渲染引擎模塊的崩潰。和插件一樣，渲染引擎的崩潰也會導致整個瀏覽器的崩潰。</li><li><strong>不流暢：</strong>所有頁面的渲染模塊、JavaScript 執行環境以及插件都是運行在同一個線程中的，這就意味着同一時刻只能有一個模塊可以執行。如果一個腳本非常耗時，它就會獨佔整個線程，這樣導致其他運行在該線程中的頁面沒有機會去執行任務，導致整個瀏覽器失去響應，變卡頓。</li><li><strong>不安全：</strong>當你在頁面運行一個插件時，插件可以操作系統資源，如果是個惡意插件，那麼它就可以釋放病毒、竊取你的賬號密碼，引發安全性問題。</li></ul><span id="OSC_h4_2"></span><h4><strong>多進程瀏覽器時代</strong></h4><p style="text-align:justify"><strong>早期架構</strong></p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-98f663221fa15549837f9cd878d40653_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">2008 年 Chrome 發佈時的進程架構</p><p style="text-align:justify">從圖中可以看出，早期的架構已經對瀏覽器的能力進行了拆分，主要拆分為三類：<strong>瀏覽器進程、插件進程和渲染進程。</strong>每個頁面是運行在單獨的渲染進程中的，同時頁面裏的插件也是運行在單獨的插件進程之中，進程之間是通過 IPC 機制進行通信。這就解決了單進程時代瀏覽器的各種問題：</p><ul><li><strong>解決不穩定：</strong>由於進程是相互隔離的，所以當一個頁面或者插件崩潰時，影響到的僅僅是當前的頁面進程或者插件進程，並不會影響到瀏覽器和其他頁面。</li><li><strong>解決不流暢：</strong>JavaScript 運行在渲染進程中，所以即使 JavaScript 阻塞了渲染進程，也只會影響當前的渲染頁面，並不會影響瀏覽器和其他頁面，因為其他頁面的腳本運行在它們自己的渲染進程中。</li><li><strong>解決不安全：</strong>Chrome 把插件進程和渲染進程鎖在沙箱裏面，沙箱裏面的程序可以運行，但是不能在硬盤上寫入任何數據，也不能在敏感位置讀取任何數據，這樣即使在渲染進程或者插件進程裏面執行了惡意程序，惡意程序也無法突破沙箱去獲取系統權限。</li></ul><p style="text-align:justify"><strong>近期架構</strong></p><p style="text-align:justify">相較之前，近期的架構又有了很多新的變化。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-4c1b8fc023fcd2ad0aa618575cdbc74b_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">近期 Chrome 進程架構</p><p style="text-align:justify">從圖中可以看出，最新的 Chrome 瀏覽器包括：<strong>1 個瀏覽器主進程、1 個 GPU 進程、1 個網絡進程、多個渲染進程和多個插件進程。</strong></p><ul><li><strong>瀏覽器進程：</strong>主要負責界面顯示、用户交互、子進程管理，同時提供存儲等功能。可以理解瀏覽器進程是一個統一的"<strong>調度大師</strong>"去調度其他進程，比如我們在地址欄輸入 url 時，瀏覽器進程首先會調用網絡進程。</li><li><strong>渲染進程：</strong>核心任務是將 HTML、CSS 和 JavaScript 轉換為用户可以交互的網頁，排版引擎 Blink 和 JavaScript 引擎 V8 都是運行在該進程中，默認情況下，Chrome 會為每個 Tab 標籤創建一個渲染進程。出於安全考慮，渲染進程都是運行在沙箱模式下。</li><li><strong>GPU 進程：</strong>其實，Chrome 剛開始發佈的時候是沒有 GPU 進程的。而 GPU 的使用初衷是為了實現 3D CSS 的效果，只是隨後網頁、Chrome 的 UI 界面都選擇採用 GPU 來繪製，這使得 GPU 成為瀏覽器普遍的需求。最後，Chrome 在其多進程架構上也引入了 GPU 進程。</li><li><strong>網絡進程：</strong>主要負責頁面的網絡資源加載，之前是作為一個模塊運行在瀏覽器進程裏面的，直至最近才獨立出來，成為一個單獨的進程。</li><li><strong>插件進程：</strong>主要是負責插件的運行，因插件易崩潰，所以需要通過插件進程來隔離，以保證插件進程崩潰不會對瀏覽器和頁面造成影響。</li></ul><p style="text-align:justify"><strong>當前架構</strong></p><p style="text-align:justify">目前 Chrome 瀏覽器的架構正在發生一些改變，稱為<strong>面向服務的架構 (SOA)</strong>，目的是將和瀏覽器本身（Chrome）相關的部分拆分為一個個不同的服務，服務化之後，這些功能既可以放在不同的進程裏面運行也可以合併為一個單獨的進程運行。這樣做的主要原因是讓 Chrome 在不同性能的硬件上有不同的表現。當 Chrome 運行在一些性能比較好的硬件時，瀏覽器進程相關的服務會被放在不同的進程運行以提高系統的穩定性。相反如果硬件性能不好，這些服務就會被放在同一個進程裏面執行來減少內存的佔用。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-42fd4b754c12dcb3981338f765d81a60_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">面向服務的架構</p><span id="OSC_h3_3"></span><h3>插件運行機制</h3><p style="text-align:justify">在運行機制前，我們先來回顧一下打開頁面會發生什麼：</p><span id="OSC_h4_4"></span><h4><strong>打開頁面發生了什麼</strong></h4><ul><li>用户新增一個 tab，此時系統瀏覽器進程、渲染進程、GPU 進程、網絡進程會被創建好；</li><li>用户輸入 url，瀏覽器進程檢查 url，組裝協議，構成完整的 url；</li><li>瀏覽器進程通過進程間通信（IPC）把 url 請求發送給網絡進程；</li><li>網絡進程接收到 url 請求後檢查本地緩存是否緩存了該請求資源，如果有則將該資源返回給瀏覽器進程；</li><li>如果沒有，網絡進程向 web 服務器發起 http 請求（網絡請求）；</li><li>網絡進程解析響應流程； 
  <ul><li>檢查狀態碼，非 200 執行狀態碼對應的處理邏輯；</li><li>200 響應處理：檢查響應類型 Content-Type，如果是字節流類型，則將該請求提交給下載管理器，不再進行後續的渲染，如果是 html 則通知瀏覽器進程準備渲染進程進行渲染；</li></ul></li><li>準備渲染進程 
  <ul><li>瀏覽器進程檢查當前 url 是否和之前打開的渲染進程根域名是否相同，如果相同，則複用原來的進程，如果不同，則開啓新的渲染進程；</li></ul></li><li>傳輸數據、更新狀態 
  <ul><li>渲染進程準備好後，瀏覽器向渲染進程發起「提交文檔」的消息，渲染進程接收到消息和網絡進程建立傳輸數據的「管道」；</li><li>渲染進程接收完數據後，向瀏覽器發送確認消息；</li><li>瀏覽器進程接收到確認消息後更新瀏覽器界面狀態：安全、地址欄 url、前進後退的歷史狀態、更新 web 頁面；</li></ul></li></ul><span id="OSC_h4_5"></span><h4><strong>打開插件發生了什麼</strong></h4><p style="text-align:justify">插件的運行相較於頁面會有簡化</p><p style="text-align:justify">1.我們打開瀏覽器，新增一個空白 tab 頁</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-fbdf73e0cfb877800ffc5a6b290cbee8_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">2.tab 欄空白處右鍵，選擇任務管理器，打開任務管理器面板</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-71e105d5e40961a19574affc5d405506_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">3.可以看到運行了 6 個進程，分別是瀏覽器進程、GPU 進程、網絡進程、存儲進程、渲染進程和擴展進程。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-fd99f7006599b3a820d7ffb6dbeaab0d_720w.webp" referrerpolicy="no-referrer"></p><ul><li>擴展進程中運行 Extension Page，主要包括 backgrount.html 和 popup.html； 
  <ul><li>backgrount.html 中沒有任何內容，是通過 background.js 創建生成，當瀏覽器打開時，會自動加載插件的 background.js 文件，它獨立於網頁並且一直運行在後台，它主要通過調用瀏覽器提供的 API 和瀏覽器進行交互；</li><li>popup.html 有內容的，跟我們普通的 web 頁面一樣，由 html、css、Javascript 組成，它是按需加載的，需要用户去點擊地址欄的按鈕去觸發，才能彈出頁面；</li></ul></li><li>渲染進程主要運行 Web Page,當打開頁面時，會將 content_script.js 加載並注入到該網頁的環境中，它和網頁中引入的 Javascript 一樣，可以操作該網頁的 DOM Tree，改變頁面的展示效果；</li><li>GPU 進程主要為插件界面的渲染提供硬件能力支持；</li><li>網絡進程主要處理插件中的外部資源請求，比如 nexydy 插件依賴到一些外部 js；</li><li>存儲進程為插件提供本地存儲能力，比如使用 chrome.storage.local 進行持久化存儲；</li><li>瀏覽器進程在這裏更多起到橋樑作用，作為中轉可以實現 Extension Page 和 content_script.js 之間的消息通信。</li></ul><span id="OSC_h3_6"></span><h3>插件基本介紹</h3><span id="OSC_h4_7"></span><h4><strong>版本發展</strong></h4><p style="text-align:justify">chrome 插件存在三個版本，分別是<strong>Manifest V1、Manifest V2 和 Manifest V3</strong>。其中 MV1 版本已經被廢棄了，目前市面上存在 MV2 和 MV3 版本，以 MV2 為主流，在被 MV3 慢慢取代。時間線：</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-950393136d16d081528b01b5fbc794f1_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>Manifest V2 新特性</strong></p><p style="text-align:justify"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%2Fmv2%2FmanifestVersion%2F%253Fspm%253Da2c6h.13046898.publish-article.26.c7c96ffa7eZ9TZ%2523manifest-v1-changes" target="_blank">https://developer.chrome.com/docs/extensions/mv2/manifestVersion/#manifest-v1-changes</a></p><ul><li>設置了默認的內容安全策略`script-src 'self'; object-src 'self';`。有關內容安全策略的詳細配置，可以參考 MDN 文檔；</li><li>默認情況下，插件包內的資源不再可供外部網站使用。需要通過清單 web_accessible_resources 屬性將其顯式列入白名單；</li><li>browser action API 更改；</li><li>page action API 更改；</li><li>chrome.extension 代替 chrome.self 來指向插件本身；</li><li>chrome.extension.getTabContentses 和 chrome.extension.getExtensionTabs 廢棄，使用 extension.getViews 替代；</li><li>Port.tab 廢棄，使用 runtime.Port 替代；</li></ul><p style="text-align:justify"><strong>Manifest V3 新特性</strong></p><ul><li>Service worker 替換 Background Page；</li><li>網絡請求修改廢棄 webRequest API 使用新的 declarativentrequest API 來處理；</li><li>不再允許執行遠程託管的代碼，只能執行擴展包內包含的 JS；</li><li>Promises 已經被添加到許多方法中，但仍支持回調作為替代方法；</li><li>Browser Action API 和 Page Action API 被統一為單獨的 Action API；</li><li>Web 可訪問的資源，可以只對指定的站點和擴展可用；</li><li>內容安全策略 (CSP)，現在可以為單個對象中的不同執行上下文指定單獨的 CSP；</li><li>executeScript 的變化，不能再執行任意字符串，只能執行腳本文件和函數；</li></ul><p style="text-align:justify"><strong>切換 MV3 會帶來的問題</strong></p><ul><li>由於 background 不再支持 page 頁面配置 background.html，因此也無法調用 window 對象上的 XMLHttpRequest 來構建 ajax 請求，也就是説我們不能像 V2 版本一樣，在 background.html 中使用 XMLHttpRequest 來發送請求了，而是需要使用 fetch 來獲取接口數據；</li><li>由於 service workers 是短暫的，在不使用時會終止，這意味着它們在整個插件運行期間會不斷的啓動、運行和終止，也就是不穩定的；因此我們可能需要對 V2 中 background.js 的代碼邏輯進行一些改造，以往我們會習慣將一些數據直接存儲到全局變量，比如像下面這樣：</li></ul><pre><code>// V2 background.js
let saveUserName = "";

// 其他頁面，比如 content-script 或者 popup 中存儲數據
chrome.runtime.onMessage.addListener(({ type, name }) =&gt; {
  if (type === "set-name") {
    saveUserName = name;
  }
});

// 點擊 popup 時展示數據
chrome.action.onClicked.addListener((tab) =&gt; {
  // 這裏 saveUserName 可能為空字符串
  console.log(saveUserName, "saveUserName");
});</code></pre><ul><li>因此在 V3 中，需要對這種全局變量數據進行改造，改造的方式也很簡單，就是將數據持久化保存到 storage 中，需要用到的地方隨用隨取：</li></ul><pre><code>// V3 service worker
chrome.runtime.onMessage.addListener(({ type, name }) =&gt; {
  if (type === "set-name") {
    chrome.storage.local.set({ name });
  }
});

chrome.action.onClicked.addListener(async (tab) =&gt; {
  const { name } = await chrome.storage.local.get(["name"]);
  chrome.tabs.sendMessage(tab.id, { name });
});</code></pre><ul><li>由<strong>webRequest API</strong>切換至<strong>declarativentrequest API</strong>，很多代碼邏輯需要重構；</li></ul><p style="text-align:justify"><strong>為什麼切換 MV3？</strong></p><p style="text-align:justify">從 Manifest V1 到 Manifest V2，可以看到 Chrome 想提高插件的隱私和安全，同時也優化了不少 API。而 Manifest V3 除了安全性更完善外，還在性能上下了功夫。Manifest V3 的核心非常明確，就是限制擴展對系統資源的使用。一直以來高資源佔用都是 Chrome 為人詬病的痛點，而且擴展由於在後台運行，如果出現問題，更是難以定位和管理。雖然增加了諸多限制，但 Manifest V3 還是有優點的：</p><ul><li>Service Worker 使擴展不再能常駐後台，讓擴展所佔用的資源可以被回收，降低了瀏覽器整體的開銷；</li><li>限制規則的數量，相當於控制了單一擴展在規則計算方面的資源使用上限；</li></ul><p style="text-align:justify">這些變化可以讓 Chrome 變得更加流暢，對於用户來説是好事。</p><span id="OSC_h4_8"></span><h4><strong>展示形式</strong></h4><p style="text-align:justify">Chrome 插件有以下常見的 8 中展現形式：</p><p style="text-align:justify"><strong>browserAction(瀏覽器右上角)</strong></p><p style="text-align:justify">在瀏覽器右上角擴展程序一欄顯示，包含一個圖標、名稱和 popup</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-d1c2fce69c1223a54300c9a2ea96eb9b_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">山海關插件 popup</p><p style="text-align:justify"><strong>pageAction(地址欄右側)</strong></p><p style="text-align:justify">pageAction 指的是在當某些特定頁面打開才顯示的圖標。在早些版本的 Chrome 是將 pageAction 放在地址欄的最右邊，左鍵單擊彈出 popup，右鍵單擊則彈出相關默認的選項菜單。而新版的 Chrome 更改了這一策略，pageAction 和普通的 browserAction 一樣也是放在瀏覽器右上角，只不過沒有點亮時是灰色的，點亮了才是彩色的，灰色時無論左鍵還是右鍵單擊都是彈出選項。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-00231bae7597112980d8851b90979347_720w.webp" referrerpolicy="no-referrer"></p><p><strong>右鍵菜單</strong></p><p style="text-align:justify">通過開發 Chrome 插件可以自定義瀏覽器的右鍵菜單，主要是通過 chrome.contextMenus API 實現，右鍵菜單可以出現在不同的上下文，比如普通頁面、選中的文字、圖片、鏈接，等等。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-21338dc0d8e7b00dd4bcd5ef3922e777_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">掘金插件右鍵菜單</p><p style="text-align:justify"><strong>override(覆蓋特定頁面)</strong></p><p style="text-align:justify">使用 override 可以將 Chrome 默認的一些特定頁面替換掉，改為使用擴展提供的頁面。擴展可以替代如下頁面：</p><ul><li>歷史記錄：從工具菜單上點擊歷史記錄時訪問的頁面，或者從地址欄直接輸入 chrome://history</li><li>新標籤頁：當創建新標籤的時候訪問的頁面，或者從地址欄直接輸入 chrome://newtab</li><li>書籤：瀏覽器的書籤，或者直接輸入 chrome://bookmarks</li></ul><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-c730b7492405900d5f1c3cd9131abf06_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">掘金插件替換了新標籤頁</p><p style="text-align:justify"><strong>devtools(開發者工具)</strong></p><p style="text-align:justify">Chrome 允許插件在開發者工具 (devtools) 上開發，主要表現在：</p><ul><li>自定義一個和多個和 Elements、Console、Sources 等同級別的面板；</li><li>自定義側邊欄 (sidebar)，目前只能自定義 Elements 面板的側邊欄；</li></ul><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-1dca64511239cf86d0d29e29fccc403d_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">React Developer Tools</p><p style="text-align:justify"><strong>option(選項頁)</strong></p><p style="text-align:justify">插件的設置頁面，可以在右上角入口右鍵，有一個選項標籤</p><div style="text-align:center"><img height="610" src="https://pic1.zhimg.com/80/v2-9fc5b949ed631b4718e3af633977c024_720w.webp" width="672" referrerpolicy="no-referrer"></div><div style="text-align:center">
  &nbsp; 
</div><div style="text-align:center"><img height="506" src="https://pic1.zhimg.com/80/v2-bb3b7e3db84d9b3f544b5fd3e1295b90_720w.webp" width="880" referrerpolicy="no-referrer"></div><p style="text-align:justify"><strong>omnibox</strong></p><p style="text-align:justify">omnibox 是向用户提供搜索建議的一種方式，可以在搜索欄輸入特定的標識然後按 Tab 進入搜索。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-670f0e06b91ac66ccda32a21a111d409_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">JSON Viewer 插件</p><p style="text-align:justify"><strong>桌面通知</strong></p><p style="text-align:justify">Chrome 提供了一個 chrome.notificationsAPI 以便插件推送桌面通知，暫未找到 chrome.notifications 和 HTML5 自帶的 Notification 的顯著區別及優勢。在後台 JS 中，無論是使用 chrome.notifications 還是 Notification 都不需要申請權限（HTML5 方式需要申請權限），直接使用即可。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-e9d3bc3ad06b822b37b4e3ba8543a8a5_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_9"></span><h4><strong>核心介紹</strong></h4><p style="text-align:justify"><strong>manifest.json</strong></p><p style="text-align:justify">這是一個 Chrome 插件最重要也是必不可少的文件，用來配置所有和插件相關的配置，必須放在根目錄。其中，manifest_version、name、version3 個是必不可少的。</p><p style="text-align:justify"><strong>Manifest V2</strong></p><pre><code>{
// 清單文件的版本，這裏先使用 2 演示
"manifest_version": 2,
// 插件的名稱
"name": "...",
// 插件的版本
"version": "1.0.0",
// 插件描述
"description": "...",
// 圖標，一般偷懶全部用一個尺寸的也沒問題
"icons": {
"16": "img/icon.png",
"48": "img/icon.png",
"128": "img/icon.png"
  },
// 會一直常駐的後台 JS 或後台頁面
"background": {
"scripts": ["js/background.js"]
  },
// 瀏覽器右上角圖標設置，browser_action、page_action、app 必須三選一
"browser_action": {
"default_icon": "img/icon.png",
"default_title": "...",
"default_popup": "popup.html"
  },
// 當某些特定頁面打開才顯示的圖標
"page_action": {
"default_icon": "img/icon.png",
"default_title": "...",
"default_popup": "popup.html"
  },
// 需要直接注入頁面的 JS
"content_scripts": [{
"matches": ["&lt;all_urls&gt;"],
"js": ["js/content-script.js"],
"css": ["css/custom.css"],
// 代碼注入的時機，document_start, document_end, document_idle，默認 document_idle
"run_at": "document_start"
    },
  ],
// 權限申請
"permissions": [
"contextMenus", // 右鍵菜單
"tabs", // 標籤
"notifications", // 通知
"webRequest", // web 請求
"webRequestBlocking",
"storage", // 插件本地存儲
"https://*/*" // 可以通過 executeScript 或者 insertCSS 訪問的網站
  ],
// 普通頁面能夠直接訪問的插件資源列表，如果不設置是無法直接訪問的
"web_accessible_resources": ["js/inject.js"],
"homepage_url": "...", // 插件主頁
"chrome_url_overrides": { // 覆蓋瀏覽器默認頁面
"newtab": "newtab.html"
  },
"options_ui": { // 插件選項頁
"page": "options.html",
"chrome_style": true
  },
"omnibox": { "keyword" : "..." }, // 向地址欄註冊一個關鍵字以提供搜索建議，只能設置一個關鍵字
"default_locale": "zh_CN", // 默認語言
"devtools_page": "devtools.html", // devtools 頁面入口，注意只能指向一個 HTML 文件，不能是 JS 文件
"content_security_policy": "...", // 安全策略
"web_accessible_resources": [ // 可以加載的資源
    RESOURCE_PATHS
  ]
}</code></pre><p style="text-align:justify"><strong>Manifest V3（僅展示與 V2 版本的不同點）</strong></p><pre><code>{
"manifest_version": 3,
"background": {
"service_worker": js/background.js"
  },
  "action": { //browser_action 和 page_action，統一為 Action
    "default_icon": "img/icon.png",
    "default_title": "這是一個示例 Chrome 插件",
    "default_popup": "popup.html"
  }
  "content_security_policy": {
    "extension_pages": "...",
    "sandbox": "..."
  },
  "web_accessible_resources": [{
    "resources": [RESOURCE_PATHS]
  }]
}</code></pre><p style="text-align:justify"><strong>content-scripts</strong></p><p style="text-align:justify">是 Chrome 插件中向頁面注入腳本的一種形式（雖然名為 script，其實還可以包括 css 的），藉助 content-scripts 我們可以實現通過配置的方式輕鬆向指定頁面注入 JS 和 CSS。content-scripts 和原始頁面共享 DOM，但不共享 JS。如要訪問頁面 JS（例如某個 JS 變量），只能通過 injected js 來實現。content-scripts 不能訪問絕大部分 chrome API，除了下面這 4 種：</p><ul><li>chrome.extension</li><li>chrome.i18n</li><li>chrome.runtime</li><li>chrome.storage</li></ul><p style="text-align:justify">這些 API 絕大部分時候都夠用了，有需要調用其它 API 的話，可以通過通信讓 background 或 service worker 來幫忙調用</p><p style="text-align:justify"><strong>background</strong></p><p style="text-align:justify">後台是一個常駐的頁面，它的生命週期是插件中所有類型頁面中最長的，它隨着瀏覽器的打開而打開，隨着瀏覽器的關閉而關閉，所以通常把需要一直運行的、啓動就運行的、全局的代碼放在 background 裏面。background 的權限非常高，幾乎可以調用所有的 Chrome 擴展 API（除了 devtools），而且它可以無限制跨域，可以跨域訪問任何網站而無需要求對方設置 CORS。background 的概念在 MV3 版本中變為了 service worker，區別在於生命週期變短了，service worker 是短暫的基於事件的腳本，所以不適合用來保存全局變量。</p><p style="text-align:justify"><strong>popup</strong></p><p style="text-align:justify">popup 是點擊右上角圖標時打開的一個小窗口網頁，焦點離開網頁就立即關閉，一般用來做一些臨時性的交互。權限級別和 background 差不多，就是生命週期比較短。</p><p style="text-align:justify"><strong>injected-script</strong></p><p style="text-align:justify">chrome 插件中其實沒有 injected-script 這一概念，這是開發者們在開發過程中衍生出來的一種概念，指的是通過 DOM 操作的方式向頁面注入的一種 JS。因為 content-script 無法訪問頁面中的 JS，雖然可以操作 DOM，但是 DOM 卻不能調用它，也就是無法在 DOM 中通過綁定事件的方式調用 content-script 中的代碼。但是在網頁中增加一個按鈕來調用插件的能力是一個比較常見的需求，所以誕生了 injected-script。</p><span id="OSC_h4_10"></span><h4><strong>插件通信機制</strong></h4><p style="text-align:justify">講通信機制之前，先回顧一下插件中存在的腳本類型。Chrome 插件的 JS 主要可以分為這 5 類：injected script、content-script、popup js、background js 和 devtools js。</p><p style="text-align:justify"><strong>權限對比</strong></p><table><tbody><tr><td style="text-align:justify">JS 種類</td><td style="text-align:justify">可訪問的 API</td><td style="text-align:justify">DOM 訪問情況</td><td style="text-align:justify">JS 訪問情況</td><td style="text-align:justify">直接跨域</td></tr><tr><td style="text-align:justify">injected</td><td style="text-align:justify">和普通 JS 無任何差別，不能訪問任何擴展 API</td><td style="text-align:justify">可以訪問</td><td style="text-align:justify">可以訪問</td><td style="text-align:justify">不可以</td></tr><tr><td style="text-align:justify">content</td><td style="text-align:justify">只能訪問 extension、runtime 等部分 API</td><td style="text-align:justify">可以訪問</td><td style="text-align:justify">不可以</td><td style="text-align:justify">不可以</td></tr><tr><td style="text-align:justify">popup</td><td style="text-align:justify">可訪問絕大部分 API，除了 devtools 系列</td><td style="text-align:justify">不可直接訪問</td><td style="text-align:justify">不可以</td><td style="text-align:justify">可以</td></tr><tr><td style="text-align:justify">background</td><td style="text-align:justify">可訪問絕大部分 API，除了 devtools 系列</td><td style="text-align:justify">不可直接訪問</td><td style="text-align:justify">不可以</td><td style="text-align:justify">可以</td></tr><tr><td style="text-align:justify">devtools</td><td style="text-align:justify">只能訪問 devtools、extension、runtime 等部分 API</td><td style="text-align:justify">可以</td><td style="text-align:justify">可以</td><td style="text-align:justify">不可以</td></tr></tbody></table><p style="text-align:justify">通過權限對比可以看到，每一種腳本在權限上都不相同，所以各種腳本間的相互通信就非常重要，這也是插件能夠實現眾多功能的基礎。</p><p style="text-align:justify"><strong>通信概覽</strong></p><table><tbody><tr><td style="text-align:justify">&nbsp;</td><td style="text-align:justify">injected</td><td style="text-align:justify">content</td><td style="text-align:justify">popup</td><td style="text-align:justify">background</td></tr><tr><td style="text-align:justify">injected</td><td style="text-align:justify">-</td><td style="text-align:justify">window.postMessage</td><td style="text-align:justify">-</td><td style="text-align:justify">-</td></tr><tr><td style="text-align:justify">content</td><td style="text-align:justify">window.postMessage</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.runtime.sendMessage chrome.runtime.connect</td><td style="text-align:justify">chrome.runtime.sendMessage chrome.runtime.connect</td></tr><tr><td style="text-align:justify">popup</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.tabs.sendMessage chrome.tabs.connect</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.extension. getBackgroundPage</td></tr><tr><td style="text-align:justify">background</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.tabs.sendMessage chrome.tabs.connect</td><td style="text-align:justify">chrome.extension.getViews</td><td style="text-align:justify">-</td></tr><tr><td style="text-align:justify">devtools</td><td style="text-align:justify">chrome.devtools. inspectedWindow.eval</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.runtime.sendMessage</td><td style="text-align:justify">chrome.runtime.sendMessage</td></tr></tbody></table><span id="OSC_h3_11"></span><h3>一些常見插件的實現思路</h3><span id="OSC_h4_12"></span><h4><strong>埋點日誌檢測</strong></h4><p style="text-align:justify">一般業務中都會進行一些埋點上報，埋點的本質就是發送一些帶特定參數的請求，前端本地調試的時候想實時查看埋點信息通常需要去查看上報接口的入參，或者去對應的埋點平台查看，這樣非常不方便。基於這個，我們可以使用插件來幫助我們快速的可視化查看埋點信息：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-d9e6e16e3db7cd8922d8b437219a96e2_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_13"></span><h4><strong>頁面注入小工具</strong></h4><p style="text-align:justify">插件的另一個常見用法就是往頁面注入一些工具代碼，比如去除頁面廣告工具。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-0de602a3e05ff59d5e0b6f1450c44d76_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h3_14"></span><h3>總結</h3><ul><li>隨着瀏覽器不斷的發展，Chrome 逐漸把一些基礎服務獨立出來，類似於一個跨平台的線上操作系統。</li><li>Chrome 插件提供的能力很豐富，比如代碼注入、跨域請求、持久化方案、各種通信機制等，開發者可以發揮想象，組裝不同能力以適應不同場景的需求，基本可以實現現代 web 所能支持的所有功能。</li><li>Chrome 插件 MV2 版本將在 24 年 1 月全面廢棄，需要儘快遷移至 MV3 版本。</li></ul><span id="OSC_h3_15"></span><h3><strong>參考資料：</strong></h3><p>《瀏覽器工作原理與實踐》：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Ftime.geekbang.org%2Fcolumn%2Fintro%2F100033601%253Fspm%253Da2c6h.13046898.publish-article.27.c7c96ffa7eZ9TZ%2526tab%253Dcatalog" target="_blank">https://time.geekbang.org/column/intro/100033601?tab=catalog</a></p><p>《Inside look at modern web browser》：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fblog%2Finside-browser-part1%2F%253Fspm%253Da2c6h.13046898.publish-article.28.c7c96ffa7eZ9TZ" target="_blank">https://developer.chrome.com/blog/inside-browser-part1/</a></p><p>《圖解瀏覽器的基本工作原理》：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F47407398%3Fspm%3Da2c6h.13046898.publish-article.29.c7c96ffa7eZ9TZ" target="_blank">https://zhuanlan.zhihu.com/p/47407398</a></p><p>《Welcome to Manifest V3》：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%2Fmv3%2Fintro%2F%253Fspm%253Da2c6h.13046898.publish-article.30.c7c96ffa7eZ9TZ" target="_blank">https://developer.chrome.com/docs/extensions/mv3/intro/</a></p><p>MDN 文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCSP%253Fspm%253Da2c6h.13046898.publish-article.31.c7c96ffa7eZ9TZ" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP</a>web_accessible_resources：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%2Fmv2%2Fmanifest%2Fweb_accessible_resources%2F%253Fspm%253Da2c6h.13046898.publish-article.32.c7c96ffa7eZ9TZ" target="_blank">https://developer.chrome.com/docs/extensions/mv2/manifest/web_accessible_resources/</a></p><p style="text-align:justify">作者｜閔子</p><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1381666%3Futm_content%3Dg_1000385322" target="_blank">原文鏈接</a></strong></p><p style="text-align:justify"><strong>本文為阿里雲原創內容，未經允許不得轉載。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 10 Dec 2023 04:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10319584</guid>
            <link>https://my.oschina.net/yunqi/blog/10319584</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[餘承東：華為明年將推出顛覆性產品，改寫行業歷史]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>12 月 9 日，2023 華為花粉年會在松山湖基地舉行。華為常務董事、終端 BG CEO、智能汽車解決方案 BU 董事長餘承東在年會上表示，<strong>明年會推出非常有引領性、創新性、顛覆性的產品。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d15077f4297790d71ee33fb17fcdc27333c.png" referrerpolicy="no-referrer"></p><p><strong><strong>餘承東直言：「到時候你可以看到我們怎麼樣能夠</strong>改寫這個行業的歷史</strong>。希望能夠不斷地帶來超越大家的期待，做別人想不到的事情或者想到但做不到的事，甚至是他們不敢想的事情。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e2b780aafbf00c463c0e8273e50a58bead5.png" referrerpolicy="no-referrer"></p><p>餘承東還預告，華為明年將會推出鴻蒙原生應用與原生體驗的產品，「<strong>那將會是整個中國終端類操作系統裏真正的王者</strong>」。</p><p>此前，有消息稱華為可能明年推出不兼容 Android 的鴻蒙版本。11 月 20 日，據澎湃新聞報道，一華為相關人士表示，推出時間還不確定，未來 iOS、鴻蒙、Android 將為三個各自獨立的系統。</p><p>稍早前據證券時報報道，有業內人士亦表示：「華為內部確實有這計劃，就是明年推出不兼容 Android 的鴻蒙版本，但目前內部還沒有下發相關通知，所以具體何時推出暫不明確。」</p><p>在 9 月 25 日舉行的華為秋季全場景新品發佈會上，華為常務董事、終端 BG CEO、智能汽車解決方案 BU 董事長餘承東宣佈，鴻蒙原生應用全面啓動，HarmonyOS NEXT 開發者預覽版將在 2024 年第一季度面向開發者開放。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-619518ef25720c3272f8663f57f84ce9cbb.png" referrerpolicy="no-referrer"></p><p>會上，華為與近 40 家合作伙伴舉辦鴻蒙生態合作簽約儀式，包括：小紅書、招商銀行、攜程旅行、美圖、58 同城、360 瀏覽器、網易有道詞典、石墨文檔、classln 應用、洪恩識字、漢王科技、作業幫、億圖腦圖 MindMaster 應用、會見會議、2345 好壓、寶寶巴士、喜馬拉雅、訊飛聽見、浩辰 CAD、掌上生活、郵儲銀行、鈦媒體、駕考寶典、書生電子、交通銀行、中信銀行、興業證券、央廣網、搜狐新聞、蜻蜓 FM、京東健康、動卡空間、東方財富、天天基金、大智慧、深圳 CA 簽章、中軟國際、中國音像與數字出版協會等應用與服務商。</p><p>10 月 26 日，包含支付寶、小紅書、嗶哩嗶哩、滴滴出行、同程旅行、哈囉等十餘家知名互聯網企業，參加了華為在上海舉行的鴻蒙生態夥伴聯合創新會，瞭解 HarmonyOS NEXT 的能力與特性，現場達成 10+創新場景合作意向。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 10 Dec 2023 03:15:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270290</guid>
            <link>https://www.oschina.net/news/270290</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[黑客攻擊招聘 APP 短信驗證碼接口用於「撞庫」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>央視新聞報道了招聘 APP 遭黑客攻擊導致 300 萬條數據泄露的案件。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-e4acf1c1251a484866c2db701cf03469b78.png" referrerpolicy="no-referrer"></p><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F2656274875%2FNwrWnni5v%3Fpagetype%3Dprofilefeed" target="_blank">https://www.weibo.com/2656274875/NwrWnni5v?pagetype=profilefeed</a></u></em></p></blockquote><p>根據報道，前段時間北京警方接到轄區內一家互聯網公司報案，稱該公司求職招聘類 App 的短信驗證碼接口遭受 1300 餘萬次攻擊，且成功匹配註冊賬號 30 餘萬個。北京警方迅速研判，<strong>確定這是一起黑客利用網站漏洞非法獲取賬號信息並用於違法活動的案件</strong>。</p><p>據瞭解，犯罪嫌疑人喻某交代稱，自己於 2022 年 10 月 18 日在該招聘平台註冊賬號，並數次嘗試驗證接口。<strong>他發現該網站的簽名算法相對單一，便利用該弱點編寫指令，製作黑客軟件對網站進行「撞庫」攻擊</strong>。</p><p>同時，他還利用類似方式對其他各大網站進行滲透，並伺機查詢網站漏洞，<strong>以此為誘餌向他人兜售自己編寫的惡意程序、黑客工具，從中牟利</strong>。經過民警不懈努力，專案組成功在四川成都將另一名嫌疑人焦某抓獲，<strong>現場起獲各類公司、人員數據 330 餘萬條</strong>。</p><p>犯罪嫌疑人喻某、焦某因破壞計算機信息系統罪被依法刑事拘留，案件正進一步辦理中。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 10 Dec 2023 02:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270288</guid>
            <link>https://www.oschina.net/news/270288</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[systemd 新組件 systemd-bsod — 為 Linux 引入「藍屏」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>systemd 255 近日<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsystemd%2Fsystemd%2Freleases%2Ftag%2Fv255" target="_blank">發佈了穩定版</a></u>，其新增的"<strong>systemd-bsod</strong>"實驗性組件讓人眼前一亮——沒錯，正是大名鼎鼎的「藍屏死機」（Blue Screen of Death，簡稱 BSOD）。</p><p>BSOD 是微軟 Windows 操作系統在無法從一個系統錯誤中恢復過來時，為保護電腦數據文件不被破壞而強制顯示的屏幕圖像。Windows 的藍屏死機提示已成為標誌性畫面，大部分是系統崩潰的現象。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-51d3ac36bc416abe53fe1c0517c774a1824.png" referrerpolicy="no-referrer"></p><p><em>上圖是 Windows 10 的藍屏死機畫面（版本 1607-21H2），它包含了一個悲傷的顏文字和一個用於快速排查錯誤的二維碼</em>。</p><p>簡而言之，BSOD 就是用於展示錯誤信息的診斷工具。雖然大家討厭看到藍屏界面，但這不意味着 BSOD 本身是一個壞方案。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d1cfdcf33e390c881d32ad1ef5146419e5e.png" referrerpolicy="no-referrer"></p><p>根據&nbsp;systemd 更新日誌的介紹，當日誌級別設置為"<strong>LOG_EMERG</strong>"時，如果 Linux 系統出現引導錯誤，新組件"systemd-bsod"會全屏顯示報錯信息（即 BSOD）。和 Windows 的 BSOD 類似，它也會生成二維碼，以便用户通過手機獲取啓動失敗報錯的更多信息。</p><p>"systemd-bsod" 屬於&nbsp;<span>Outreachy 項目的一部分，該項目是為開發開源工具的人員提供實習機會的組織。</span></p><p>systemd-bsod 目前處於實驗性階段，GitHub 上的更新日誌也指出它仍會有改動。但不管怎樣，不少主流 Linux 發行版如 Ubuntu、Fedora、Debian 和 Red Hat 都採用了 systemd。所以 2024 年，相信不少 Linux 發行版都會引入「藍屏」。</p><p>對了，systemd 創始人兼首席開發者 Lennart Poettering 去年<u><a href="https://www.oschina.net/news/202119/systemd-creator-microsoft" target="_blank">被微軟從 Red Hat 挖走</a></u>&nbsp;—— 繼續專注於開發 systemd。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 09 Dec 2023 05:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270207/systemd-255-bsod</guid>
            <link>https://www.oschina.net/news/270207/systemd-255-bsod</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[雷軍 30 年前寫的論文：《計算機病毒判定專家系統原理與設計》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>雷軍 1992 年發表的《計算機病毒判定專家系統原理與設計》論文在網上曝光，引發熱議。</p><p>這份論文詳細地描述了計算機病毒判定專家系統的原理與具體設計方法，一定程度上解決了流行病毒的判定問題。論文結語寫道：<strong>研製解決流行病毒判定問題的專家系統，在目前具有相當大的使用價值。本文介紹的這種智能判定方法大大優於傳統的檢測方法，具有準確率高，適用性廣的有點，還可以不斷髮展和擴充。關於這種方法，目前國內外文獻上尚未提及。（參考文獻略）</strong></p><p>附論文原文：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-00e57539a1c6a07aa17cb70f341f3f2d3c1.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-9babb896439e0b4a049532c7537dba1318f.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-c000968b49128269073f6f38373e6162709.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-a14bb1726495836bf7d6d463cbbefdb16a1.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-63cb2ee41ae8f0981dc0a88d94251dd61fb.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-d7986af830afb49d055c14584452431d642.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-dea1bb17744fa373895687fd84a7d5520ab.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-b68d4f4408348e18bba5c70dd2006a1a855.png" referrerpolicy="no-referrer"></p><p>來源：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F5714719345%2FNvR23gzWc%3Fpagetype%3Dviewer" target="_blank">https://weibo.com/5714719345/NvR23gzWc?pagetype=viewer</a></em></u></p><p>華為消費者 BG 戰略 Marketing 部副總裁李昌竹轉發了該論文的微博，<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1402329495%2FNwbO90AHM%3Fpagetype%3Dprofilefeed" target="_blank">並説道</a></u>：<strong>「技術創新和前沿探索都是值得尊敬和學習的。」</strong></p><p><img src="https://oscimg.oschina.net/oscnet/up-4cbc7936df3d1ad8b4a787215eb1fbea304.png" referrerpolicy="no-referrer"></p><p>1992 年，雷軍還與求伯君合著了《深入 DOS 編程》一書。在接下來的兩年裏，雷軍涉獵廣泛，寫過加密軟件、殺毒軟件、財務軟件、CAD 軟件、中文系統以及各種實用小工具等。</p><p><img src="https://oscimg.oschina.net/oscnet/up-389de1159783b7b408cade4d27be661e412.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-d80cc19de34a8b5e73cfe14690d437a0a70.png" referrerpolicy="no-referrer"></p><p>公開資料顯示，1987 年，雷軍畢業於原沔陽中學（現湖北省仙桃中學），同年考上了武漢大學計算機系。</p><p>1992 年初，雷軍加盟金山公司。先後出任金山公司北京開發部經理、珠海公司副總經理、北京金山軟件公司總經理等職務。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 09 Dec 2023 03:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270190</guid>
            <link>https://www.oschina.net/news/270190</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[大家好，我龍博，我們做了個很酷的開源工具]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Hello ，大家好，我是龍博，目前擔任 ILLA Cloud 的 CEO 。 創業之前在字節跳動和快手寫代碼，一直以來都是一個熱愛技術的小夥伴！</p><h2>介紹一下我們產品</h2><p>ILLA Cloud 是一個非常好用的開源低代碼工具，我們已經完整的迭代兩年了。</p><p>傳送門：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Filla.cloud" target="_blank">https://illa.cloud</a></p><p>Github: <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fillacloud%2Filla-builder" target="_blank">https://github.com/illacloud/illa-builder</a></p><p>我們的 star 都是我們用户一個一個點上去的，我們沒有進行任何的操作行為，所以 star 並沒有那麼多，還在衝擊 1w ，希望大家多給我們點贊～</p><p>我們是一個開箱即用的低代碼工具，希望大家能使用一下去解決公司裏面搭建內部系統的問題，專注各種管理後台，也就是大家無法購買到的系統，只能通過傳統前端方式構建，大家都知道沒有前端喜歡寫後台，^_^</p><p>使用我們可以構建出來相對比較美觀的各種內部工具，保證大家的 App ，Web 網站有一個好用的管理後台工具。</p><p><img src="https://cdn.illacloud.com/illa-blog/Discussion/Frame%2033402x.png" alt="低代碼" referrerpolicy="no-referrer"></p><p>我們也有很多用户在使用我們的產品搭建屬於自己公司的內部 AI 工具，比如使用 Agent 去做郵件生成，使用低代碼工具搭建屬於自己的 Stable Diffusion 面板。</p><p><img src="https://cdn.illacloud.com/illa-blog/Discussion/discussion2.png" alt="AI" referrerpolicy="no-referrer"></p><p>我們在過去的大量工作裏面支持了大量的集成能力，主流的數據庫和接口都支持了。我們還同 Hugging Face 達成了官方的合作，保證每一個用户都可以快速的訪問 Hugging Face 中的模型從而讓自己構建出來的產品有大量開箱即用的 AI 能力</p><h2>關於我們公司</h2><p>我們是 2022 年元旦之後開始創立的，目前這個產品已經完整迭代兩年了，才敢宣傳一下，我們相信這裏的小夥伴對產品都有極高的追求滴！</p><p>我們產品在創立初期也獲得了高領資本，源碼資本，奇績創壇的融資，所以大家不用擔心我們的生存問題。感謝國內頂級的資本對開源事業的支持，我們相信開源可以讓產品更加的茁壯成長。</p><p>主要是真心邀請大家一起構建我們的產品，我們相信中國的開發者是全世界最優秀的一羣人（數據上看也確實是），我們作為一家服務開發者的公司非常榮幸可以讓大家來用一用我們的產品。</p><h2>最後</h2><p>如果你對我們產品感興趣，歡迎找我聊聊，我的 v：owen_longbo</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 10:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/xlyg/blog/10320194</guid>
            <link>https://my.oschina.net/xlyg/blog/10320194</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[商湯科技發佈 AI 編程助手「代碼小浣熊 Raccoon」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>商湯科技宣佈，基於商湯自研大語言模型的智能編程助手 —— 代碼小浣熊 Raccoon (<strong>R</strong>accoon is<strong>A</strong>nother&nbsp;<strong>C</strong>ode&nbsp;<strong>CO</strong>-pil<strong>O</strong>t&nbsp;<strong>N</strong>avigator) 已開放公測。</p><p>代碼小浣熊 Raccoon 支持 Python、Java、JavaScript、C++、Go、SQL 等 30+ 主流編程語言和 VS Code、IntelliJ IDEA 等主流 IDE。主要特性如下：</p><ul><li><p>代碼編寫建議覆蓋 30 多種主流編程語言，依據上下文，自動生成代碼。</p></li><li><p>開放對話功能，理解用户的自然語言需求描述。</p></li><li><p>預設基於註釋生成代碼、跨編程語言翻譯、單元測試用例生成、代碼修正、代碼重構、技術領域知識問答等功能。</p></li><li><p>支持用户自定義需求：包括需求文檔生成、代碼生成註釋、代碼的解釋文檔生成、技術文檔生成等開放式能力。</p></li></ul><blockquote><p><strong>體驗地址：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.sensetime.com" target="_blank">https://code.sensetime.com</a></u></em><br> 使用文檔</strong>：<strong><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.sensetime.com%2Fdocs" target="_blank">https://code.sensetime.com/docs</a></em></u></strong></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2c679cff58be01097976aee3c1003e89b3a.png" referrerpolicy="no-referrer"></p><p><img height="722" src="https://oscimg.oschina.net/oscnet/up-21140dc87019c7b03213e62078c9e35292d.png" width="2398" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-fa0feda14f70e8765c400cbbda8eb386722.png" referrerpolicy="no-referrer"></p><p>代碼小浣熊由商湯自研大語言模型提供支持，覆蓋軟件需求分析、架構設計、代碼編寫、軟件測試等環節，滿足用户代碼編寫、數據分析、編程學習等各類需求。在實際應用中，可幫助開發者提升編程效率超 50%。</p><p>在最新權威代碼生成測試集 HumanEval 的測試中，該模型精度表現驚豔，一次通過率甚至達到驚人的 71%，已經大幅超越 GPT-3.5。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 07:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270111</guid>
            <link>https://www.oschina.net/news/270111</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[虛擬機成為 Android 的核心結構]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>安卓虛擬化框架（AVF）將出現在即將推出的部分安卓 14 設備上。AVF 於 Android 13 首次在 Pixel 設備上推出，為開發特權應用程序的平台開發人員提供了新的功能。</p><p>有了 AVF，我們將更廣泛地支持安卓的虛擬化。虛擬化被廣泛應用和部署，以隔離工作負載和操作系統。它可以有效地擴展基礎設施、測試環境、兼容傳統軟件、創建虛擬桌面等。</p><p style="text-align:start">有了 AVF，虛擬機就成了安卓操作系統的核心結構，類似於安卓利用 Linux 進程的方式。開發人員可以靈活選擇虛擬機的隔離級別：</p><ul><li><p>單向隔離：安卓（主機）可以控制和檢查虛擬機的內容。這些虛擬機最常用於沙箱和隔離，使多個操作系統能在同一台機器/設備上運行，由一個操作系統主機（Android）控制和監視所有其他操作系統。</p></li></ul><ul><li><p>雙向隔離（隔離虛擬機）：Android（主機）和虛擬機（客户機）完全相互隔離。處理或存儲敏感數據的開發人員可能會受益於隔離虛擬機。隔離虛擬機具有雙向屏障，主機（Android）和虛擬機都無法訪問對方，除非通過明確商定的通信渠道。這有兩個主要特性：</p></li></ul><blockquote><blockquote><ol><li><p>主機（Android）無法訪問虛擬機內的工作負載和數據（保密）。</p></li><li><p>即使 Android 一直到（包括）主機內核都受到攻擊，隔離的虛擬機也不會受到攻擊。</p></li></ol></blockquote></blockquote><h3 style="text-align:start"><strong>AVF 的意義</strong></h3><h4 style="text-align:start"><strong>隔離</strong></h4><p style="text-align:start">有了隔離虛擬機，開發人員現在有了 Trustzone 之外的另一種選擇，可用於需要在不升級權限的情況下與 Android 隔離的用例。</p><h4 style="text-align:start"><strong>便攜性</strong></h4><p style="text-align:start">虛擬機及其內部運行的應用程序的可移植性遠高於可信 applets。例如，帶有 Linux 應用程序有效載荷的基於 Linux 的虛擬機可以在所有支持 AVF 的設備上運行。這意味着開發人員只需構建一次應用程序，就可以將其部署到任何地方。與移植到 Trustzone 操作系統相比，虛擬機還能無縫、輕鬆地移植基於 Linux 的現有應用程序。</p><h4 style="text-align:start"><strong>性能</strong></h4><p style="text-align:start">AVF 設計輕巧、高效、靈活。虛擬機可以：</p><ul><li><p>根據開發者的需要，小到一個 C 語言程序，大到整個操作系統；</p></li><li><p>做到持續性或間歇性；</p></li><li><p>根據整個系統的健康狀況增加或縮小內存；</p></li><li><p>遵循 Android 的調度程序提示和低內存警告。</p></li></ul><h4 style="text-align:start"><strong>可擴展性</strong></h4><p style="text-align:start">AVF 在設計時考慮到了開發人員的需求。虛擬機可以定製，以滿足特定用例的需求。只要符合 AVF 規定的某些啓動和通信協議，開發人員就可以部署任何虛擬機有效載荷。</p><p style="text-align:start">除了將虛擬化的強大功能引入安卓系統，實現虛擬桌面、沙箱、AVF 使用隔離虛擬機的所有可能性外，還能使以下常見的安卓使用場景（以及更多使用場景）受益：</p><ul><li><p>生物識別：通過在隔離的虛擬機中部署生物識別可信 applets，開發人員將獲得隔離保證、生物識別算法所需的更多計算能力、與 Trustzone 操作系統無關的輕鬆更新能力以及更簡化的部署。</p></li></ul><ul><li><p>DRM：Widevine 可在安卓設備上實現流式 DRM。一旦部署在隔離的虛擬機中，無論安卓設備上部署的各種 Trustzone 操作系統的細節如何，Widevine 的更新在這些設備上都會變得更加容易。</p></li></ul><h3 style="text-align:start"><strong>AVF 使用</strong></h3><p style="text-align:start">AVF 提供了簡單的應用程序接口，用於查詢設備創建虛擬機的能力及其支持的類型，以及從創建虛擬機的應用程序和服務與這些虛擬機建立安全的通信渠道。</p><p style="text-align:start">例如，檢查 AVF API 的可用性，以及隔離虛擬機和常規虛擬機的可用性：</p><pre><code>VirtualMachineManager manager =
     (VirtualMachineManager)context.
          getSystemService(VirtualMachineManager.class);
if (manager == null) {
    // AVF not supported
} else {
    int capabilities = manager.getCapabilities();
    if ((capabilities &amp; CAPABILITY_PROTECTED_VM) != 0) {
        // protected VM is supported
    }
    if ((capabilities &amp; CAPABILITY_NON_PROTECTED_VM) != 0) {
        // non protected VM is supported
    }
}
</code></pre><p style="text-align:start">有關 AVF 及其 API 的其他文檔，請<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fvirtualization" target="_blank">點擊此處查看</a>。</p><h3 style="text-align:start"><strong>AVF 組件</strong></h3><p><img align="left" alt="AVF Component architecture" height="219" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjqoflrFdKllbCL-ksao2ozMc0Vwp3eAXNadr58iaiCyd4noAKVuwaetGcVVoU1s1s_g3FA94wCHv_wg8AYbnczEY518U98tUwpYqkyLM-H2IbKpJcNY55xg6yCw5KO2Nk5HW2uAxAGNBXVdDVm8dNdG4das2y7RBWaQCWleykRilaLbd0sfFnb0JOXgC0/s1600/image1.png" width="453" referrerpolicy="no-referrer"></p><p>AVF 由框架 API、<strong>Hypervisor </strong>和虛擬機管理器組成。<strong>Hypervisor </strong>確保虛擬機（包括 Android）相互隔離，就像 Linux 內核對進程的隔離一樣。不過，與 Linux 內核相比，AVF <strong>Hypervisor</strong>（pKVM）的代碼量要小得多（約 50 倍）。</p><h4 style="text-align:start"><strong>Hypervisor (</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fvirtualization%2Farchitecture%23hypervisor" target="_blank"><strong>pKVM</strong></a><strong>)&nbsp;</strong></h4><p style="text-align:start"><strong>Hypervisor </strong>側重於開源可用性、安全性、虛擬機的設備分配以及虛擬機之間的隔離安全。它的攻擊面較小，符合較高的安全保證級別。受保護的 KVM <strong>Hypervisor</strong>（pKVM）完全支持 AVF API 和功能。</p><p style="text-align:start">pKVM 構建在 Linux 中基於內核的虛擬機（KVM）這一行業標準之上。這意味着所有依賴基於 KVM 的虛擬機的現有操作系統和工作負載都能通過 pKVM 在安卓設備上無縫運行。</p><h4 style="text-align:start"><strong>虛擬機管理器 (</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fexternal%2Fcrosvm%2F" target="_blank"><strong>crosvm</strong></a><strong>)</strong></h4><p style="text-align:start">crosvm 是基於 Rust 的虛擬機管理器（VMM），是 <strong>Hypervisor </strong>與 AVF 框架之間的橋樑。它負責創建、管理和銷燬虛擬機。此外，它還提供了一個跨多個 <strong>Hypervisor </strong>實現的抽象層。</p><h4 style="text-align:start"><strong>隔離虛擬機</strong></h4><p style="text-align:start">隔離的虛擬機對 Android 來説是不可見的，即在 Android 中運行的任何進程都無法檢查、查看或篡改此類虛擬機的內容。這一保證由 <strong>Hypervisor </strong>提供。</p><h4 style="text-align:start"><strong>虛擬機</strong></h4><p style="text-align:start">虛擬機與隔離的虛擬機相同，只是擁有正確權限的 Android 進程可以訪問虛擬機。</p><h4 style="text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fvirtualization%2Fmicrodroid" target="_blank"><strong>Microdroid</strong></a></h4><p style="text-align:start">Microdroid 是一個經過精簡的 Android 操作系統軟件包，可作為啓動虛擬機（VM）的模板。它為開發人員在虛擬機中構建和運行工作負載提供了熟悉的環境。Microdroid 使用熟悉的 Android 工具和庫，如 Bionic、Binder IPC 和 keystore 支持。</p><h4 style="text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fvirtualization%2Fvirtualization-service" target="_blank"><strong>虛擬化服務</strong></a></h4><p style="text-align:start">VirtualizationService 管理所有客户虛擬機（無論是否隔離）。它主要通過管理 crosvm 實例來實現。它還公開了 AIDL API，系統服務或特權應用程序可使用該 API 啓動、監控和停止虛擬機。</p><h4 style="text-align:start"><strong>RpcBinder</strong></h4><p style="text-align:start">RpcBinder 是為 Android 界面定義語言（AIDL）開發的全新後端。RpcBinder 可使用現有的 binder 線協議與虛擬機進行通信。這意味着：</p><ol><li><p>開發人員可以使用他們已經熟悉的語言和基礎架構（AIDL）編寫虛擬機接口。</p></li><li><p>只需繼續使用現有的 AIDL 接口，即使綁定端點轉移到虛擬機中也是如此。</p></li></ol><h3 style="text-align:start"><strong>Android 14 有哪些新功能？</strong></h3><p style="text-align:start">安卓 14 不僅使 AVF 可以在更多設備上使用，還提供了一個新的工具包，使用户可以使用 AVF 及其組件構建更多內容：</p><ul><li><p><strong>用於 AVF 的安卓系統應用程序接口</strong>&nbsp;</p></li></ul><blockquote><p>特權應用程序現在可以使用虛擬機來執行需要隔離的關鍵工作負載；</p></blockquote><ul><li><p><strong>Hypervisor DevEx 工具包</strong>&nbsp;</p></li></ul><blockquote><p>添加了跟蹤功能、改進的可調試性和監控功能，以提供洞察力並協助平台開發人員在隔離虛擬機內進行開發；</p></blockquote><ul><li><p><strong>Hypervisor 供應商模塊</strong></p></li></ul><blockquote><p>通過供應商模塊擴展，我們的合作伙伴可以定製谷歌的 pKVM，以滿足他們的特定需求，實現差異化；</p></blockquote><ul><li><p><strong>改善系統健康</strong>&nbsp;</p></li></ul><blockquote><p>安卓 14 中，基於 microdroid 的虛擬機啓動速度比安卓 13 快 2 倍，而內存使用量卻只有安卓 13 的一半。</p></blockquote><p>AVF 框架的其它部分可讓 Android 服務和應用程序輕鬆使用虛擬化。例如，使用 AIDL 作為傳輸層抽象虛擬機之間的通信，管理虛擬機生命週期或虛擬機的創建方式。</p><blockquote><p>原文鏈接：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid-developers.googleblog.com%2F2023%2F12%2Fvirtual-machines-as-core-android-primitive.html" target="_blank">https://android-developers.googleblog.com/2023/12/virtual-machines-as-core-android-primitive.html</a></p><p><em>Posted by Sandeep Patil – Principal Software Engineer, and Irene Ang – Product Manager</em></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270066/virtual-machines-as-core-android-primitive</guid>
            <link>https://www.oschina.net/news/270066/virtual-machines-as-core-android-primitive</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenTiny Vue 3.12.0 發佈：文檔大優化！增加水印和二維碼兩個新組件🎈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>你好，我是 Kagol。</p><p>非常高興跟大家宣佈，2023 年 11 月 30 日，OpenTiny Vue 發佈了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Freleases%2Ftag%2Fv3.12.0" target="_blank">v3.12.0</a> 🎉。</p><p>OpenTiny 每次大版本發佈，都會給大家帶來一些實用的新特性，10.24 我們發佈了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Freleases%2Ftag%2Fv3.11.0" target="_blank">v3.11.0</a> 版本，增加了富文本、ColorPicker 等 4 個新組件，該版本共有 23 位貢獻者參與。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7293122369610940452" target="_blank">🎊OpenTiny Vue 3.11.0 發佈：增加富文本、ColorPicker 等 4 個新組件，迎來了貢獻者大爆發！</a></p><p>本次 3.12.0 版本主要有以下更新：</p><ul><li>全面優化 54 個高頻組件的 Demo / API 文檔，讓文檔更加清晰易懂、符合預期</li><li>Watermark 水印組件</li><li>QrCode 二維碼組件</li></ul><p>本次版本共有 21 位貢獻者參與開發，其中有 8 位是新貢獻者，歡迎新朋友們👏</p><p>以下是新貢獻者：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffanbingbing16" target="_blank">@fanbingbing16</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F686" target="_blank">#686</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdyh333" target="_blank">@dyh333</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F667" target="_blank">#667</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbetavs" target="_blank">@betavs</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F719" target="_blank">#719</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbetterdancing" target="_blank">@betterdancing</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F742" target="_blank">#742</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FDavid-TechNomad" target="_blank">@David-TechNomad</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F772" target="_blank">#772</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffalcon-jin" target="_blank">@falcon-jin</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F844" target="_blank">#844</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwuyiping0628" target="_blank">@wuyiping0628</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F944" target="_blank">#944</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FJames-9696" target="_blank">@James-9696</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F970" target="_blank">#970</a></li></ul><p>也感謝老朋友們對 OpenTiny 的辛苦付出！</p><p>大家可以更新 <code>@opentiny/vue@3.12.0</code> 進行體驗！</p><h2>組件文檔優化</h2><p>為了提升開發者閲讀文檔的體驗，從 9 月份至今，我們花了整整三個月時間對 54 個高頻組件的 demo / api 文檔進行全面的優化。</p><p>希望你能喜歡這波優化，如果你在使用過程中，發現有描述不清楚、不合理、不美觀之處，也希望你能給我們提交&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fissues" target="_blank">Issue</a>&nbsp;進行反饋。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7309352577146126373" target="_blank">🎉開發者的福音：TinyVue 組件庫文檔大優化！類型更詳細，描述更清晰！</a></p><h2>Watermark 水印</h2><p>水印組件用於保護文檔的版權，防止文檔被非法複製或盜用，常見的使用場景有：</p><ul><li>在公司內部文檔中添加水印，以防止機密信息泄露</li><li>在商業合同或法律文件中添加水印，以保護文件的真實性和完整性</li><li>在電子書籍或其他數字內容中添加水印，以防止盜版和非法傳播</li><li>在社交媒體發佈圖片時添加水印，以保護自己的版權</li></ul><p>Watermark 使用方式很簡單，只需要用水印組件包裹要添加水印的內容即可。</p><pre><code class="language-html">&lt;template&gt;
  &lt;tiny-watermark v-bind="params"&gt;
    &lt;div style="height: 500px"&gt;&lt;/div&gt;
  &lt;/tiny-watermark&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { reactive } from 'vue'
import { Watermark as TinyWatermark } from '@opentiny/vue'

const params = reactive({
  content: ['I ❤️ TinyVue', 'TinyVue is 👍'],
})
&lt;/script&gt;
</code></pre><p>效果如下： <img src="https://oscimg.oschina.net/oscnet/up-562c09e08e9917cda421a6a2587e3ea3c93.png" alt="" referrerpolicy="no-referrer"></p><p>其中水印內容可以支持調整寬高、旋轉角度、字體、間距等，並且支持圖片水印。</p><p>圖片水印效果：</p><p><img src="https://oscimg.oschina.net/oscnet/up-fd8835c16270be5786afdb4a6e2c654618c.png" alt="" referrerpolicy="no-referrer"></p><p>水印組件鏈接：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue%2Fzh-CN%2Fos-theme%2Fcomponents%2Fwatermark" target="_blank">https://opentiny.design/tiny-vue/zh-CN/os-theme/components/watermark</a></p><p>歡迎體驗！</p><h2>QrCode 二維碼</h2><p>二維碼組件的使用場景非常豐富：</p><ul><li>線下演講時，可以在 PPT 放個人微信的二維碼，方便聽眾用手機掃碼獲得講師的聯繫方式，進行進一步的溝通</li><li>商家可以在產品上印製二維碼，用户通過掃描二維碼來獲取產品信息或説明書</li><li>用户通過掃描二維碼來登錄網站或應用，提高登錄的安全性和便捷性</li></ul><p>QrCode 使用方式也很簡單，只需要傳入鏈接地址即可。</p><pre><code class="language-html">&lt;template&gt;
  &lt;tiny-qr-code v-bind="params"&gt;&lt;/tiny-qr-code&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { QrCode as TinyQrCode } from '@opentiny/vue'

const params = {
  value: 'https://opentiny.design/tiny-vue'
}
&lt;/script&gt;
</code></pre><p>效果如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-6cd3890d8cffa77d3bdc957eba9a64ebdf0.png" alt="" referrerpolicy="no-referrer"></p><p>可以嘗試掃描上面的二維碼，將會進入 TinyVue 官網。</p><p>二維碼的大小、顏色、背景、間距等都支持配置，同時也支持自定義圖片。</p><p>自定義圖片的二維碼效果：</p><p><img src="https://oscimg.oschina.net/oscnet/up-1c1ee113e783fece7810d1d2f23432dc9fd.png" alt="" referrerpolicy="no-referrer"></p><p>二維碼組件鏈接：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue%2Fzh-CN%2Fos-theme%2Fcomponents%2Fqr-code" target="_blank">https://opentiny.design/tiny-vue/zh-CN/os-theme/components/qr-code</a></p><p>歡迎體驗！</p><hr><p>歡迎加入 OpenTiny 開源社區。</p><p>添加微信小助手：opentiny-official，一起參與共建！</p><p>開源不易，請給&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">TinyVue</a>&nbsp;點個 Star ⭐ 鼓勵下，感謝你對我們 OpenTiny 的大力支持！</p><p>源碼：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">https://github.com/opentiny/tiny-vue</a></p><p><img src="https://oscimg.oschina.net/oscnet/up-8eccff9b756a679b6502e7d270961b07240.png" alt="" referrerpolicy="no-referrer"></p><h2>聯繫我們</h2><p>GitHub：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">https://github.com/opentiny/tiny-vue</a>（歡迎 Star ⭐）</p><p>官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue" target="_blank">https://opentiny.design/tiny-vue</a></p><p>B 站：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspace.bilibili.com%2F15284299" target="_blank">https://space.bilibili.com/15284299</a></p><p>公眾號：OpenTiny</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4863191/blog/10320008</guid>
            <link>https://my.oschina.net/u/4863191/blog/10320008</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[2023 年，再來聊聊：微服務、中台？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>阿里巴巴市值被拼多多反超後，互聯網上出現了各種對比和分析兩家公司的文章，基本都是圍繞組織架構、商業模式、企業願景等宏觀方面展開。</p><p>片刻之間，阿里此前的各種「戰略」似乎都成了「昏招」。這不，曾經他們引以為豪的「中台」也被拿出來批判了。</p><p><img src="https://static.oschina.net/uploads/space/2023/1208/115007_40xS_2720166.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1208/115136_JIEp_2720166.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-3b2b9bdc8dc5a4b3e10ffbfff09cc03a74d.png" referrerpolicy="no-referrer"></p><blockquote><p>阿里巴巴是中國第一個明確提出「中台戰略」的企業。在 2015 年年中的時候，馬雲參觀了芬蘭遊戲公司 Supercell。這家公司的員工人數非常少，還不到 200 人，但是一年的利潤高達 15 億美金。雖然開發了像《部落衝突》這樣的知名遊戲，但這家公司開發遊戲的團隊規模都很小，只有六七個人而已。</p><p>這麼小規模的團隊，怎麼做成了這麼大的業務呢？其中一個原因是他們把遊戲開發過程中，要用的一些通用的遊戲素材和算法整理出來，把這些作為工具提供給所有的小團隊。</p><p>同一套工具，可以支持好幾個小團隊研發遊戲。這種管理方式，就是一個「中台」的模型。</p><p>參觀完之後，馬雲非常受啓發，不久後阿里集團就正式提出了「<strong>大中台、小前台」</strong>的中台戰略，通過將原本分散到各個業務的支持部門，比如技術部門、數據部門集中到一起。</p><p>這樣，原本分散的支持部門聚合在一起後可以進行快速的服務迭代，更高效地支撐前線，大幅降低支持部門的重複投資建設。從此中台漸入中國企業家的視野。</p></blockquote><hr><p>説到中台，必然離不開「微服務」——這也是前幾年非常火熱的技術概念，但現在已經沒什麼話題度了。所以 2023 年，大家對微服務、中台有什麼切身感受嗎，一起來聊聊。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270064</guid>
            <link>https://www.oschina.net/news/270064</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米澎湃 OS 首批正式版開始陸續推送]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>小米澎湃 OS 官方微博發佈動態稱，小米澎湃 OS 第一批正式版正在逐步推送中。</span></p><p><span>5 款機型已於 12 月 7 日起開始陸續推送，分別為 Xiaomi 13 Pro、Xiaomi 13、Redmi K60 Pro、Redmi K60、Xiaomi Pad 6 Max 14。更多機型即將陸續推送。</span></p><p><span>Xiaomi MIX Fold 3、Xiaomi MIX Fold 2、Xiaomi Pad 6 Pro、Xiaomi Pad 6 則預計於 2024 年 1 月開始陸續推送。</span></p><p><img height="667" src="https://oscimg.oschina.net/oscnet/up-b95d11366413ac08d4ed48c93d084478d52.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:32:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270061</guid>
            <link>https://www.oschina.net/news/270061</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[中國信通院發佈《區塊鏈白皮書（2023 年）》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">2023 年 12 月 7 日，中國信息通信研究院（簡稱「中國信通院」）在「2023 年 Web3.0 創新大賽暨頒獎典禮」上<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F6_R6Mvw1xEPoTaTRoInFfQ" target="_blank">發佈</a>了《區塊鏈白皮書（2023 年）》並對白皮書進行了深度解讀。</span></p><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">白皮書在之前基礎上，重點融入了「2023 年區塊鏈生態及產業發展情況調研」相關結果分析，並系統梳理了 2023 年國內外區塊鏈技術、應用創新熱點，以及產業生態發展新動態，特別是在全球 Web3.0 快速推進、數據要素價值加快釋放的背景下，展望我國區塊鏈技術應用和產業發展新趨勢。</span></p><h4 style="margin-left:0px; margin-right:0px"><strong>白皮書核心觀點</strong></h4><p style="margin-left:0; margin-right:0"><strong>1. 區塊鏈技術面向高擴展、高性能和高安全持續演進。</strong>當前，區塊鏈技術沿公有鏈和聯盟鏈兩大技術路線分別演進，公有鏈聚焦高性能、高擴展性和高安全性強化技術創新，聯盟鏈則面向自主化、廣域化、規模化應用實現持續優化。當前融合二者優勢的開放聯盟鏈也迎來快速發展，有望成為 Web3.0 時代數據價值釋放和協作共享的技術底座。</p><p style="margin-left:0; margin-right:0"><strong>2. 區塊鏈技術與公共服務、實體經濟等領域深度融合。</strong>全球區塊鏈應用範圍從金融領域逐步向外延展，在實體經濟、政務服務、公共服務、數字原生等領域加速落地，場景創新、模式創新層出不窮，行業生態逐步完善。此外，數字資產應用拓展了要素的發展邊界，數字身份已成為數字世界的重要入口，區塊鏈通過獨特的機制正在成為促進數據要素供給流通與價值釋放的重要基礎設施，為構建 Web3.0 應用生態提供有力支撐。</p><p style="margin-left:0; margin-right:0"><strong>3. 多國政府積極佈局 Web3.0 產業發展。</strong>全球多個國家和地區政府正在積極佈局 Web3.0 發展，着力提升區塊鏈治理及監管能力，沿不同路徑持續推進區塊鏈基礎設施建設。我國區塊鏈產業佈局更加全面、協作更加緊密，標準體系日益完善，區塊鏈基礎設施建設初見成效，國產自主生態正穩步發展壯大。</p><p style="margin-left:0; margin-right:0"><strong>4. 全球加快優化區塊鏈監管治理體系。</strong>全球範圍內多個國家和地區正加快推動區塊鏈監管治理體系優化，探索基於區塊鏈的 Web3.0、數字資產等發展路徑。我國地方政府積極開展相關佈局，以政策扶持、機制創新等方式促進產業發展與監管合規同步推進，為數字經濟發展提供新路徑和新模式</p><p style="margin-left:0; margin-right:0"><img height="278" src="https://oscimg.oschina.net/oscnet/up-4dcdb04a180dee8c68991d52429f2a6c2cf.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="303" src="https://oscimg.oschina.net/oscnet/up-cc6a0478e95ab4852645905ddfd7661997b.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="309" src="https://oscimg.oschina.net/oscnet/up-e9d6c8a146fce01dab3e8838032809ad6f1.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="304" src="https://oscimg.oschina.net/oscnet/up-fc41d1b4f65c0ba86ad662b7019a04e50d2.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="307" src="https://oscimg.oschina.net/oscnet/up-e3b923b9f287991de935689803c56da9f6a.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="309" src="https://oscimg.oschina.net/oscnet/up-2862283eaefbd74a141207fba2634893f29.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="304" src="https://oscimg.oschina.net/oscnet/up-85f57208cc7017a701696280ab3e56b201a.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="311" src="https://oscimg.oschina.net/oscnet/up-264fed980163542fda3951f73cfafa9c9ef.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="311" src="https://oscimg.oschina.net/oscnet/up-22eb41296a9f9d624589657f9570e1a3818.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="306" src="https://oscimg.oschina.net/oscnet/up-5aec9e8e8721925137d746e323b3a4b472e.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="310" src="https://oscimg.oschina.net/oscnet/up-354bc09172ab7fb04087f99b2d259a2737c.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="313" src="https://oscimg.oschina.net/oscnet/up-d1edf6f022b4fb437c2d1ec45461338d608.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="303" src="https://oscimg.oschina.net/oscnet/up-9afaffbca935ed920989d45296f9ef7df9d.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="301" src="https://oscimg.oschina.net/oscnet/up-5d0ebfdcc4b0800d3d6aef007e153610e30.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="310" src="https://oscimg.oschina.net/oscnet/up-ef45c8ef4adcf6de0893a2b7c1585484e5e.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="310" src="https://oscimg.oschina.net/oscnet/up-7112a4582a8090126bac3344cffcd931c4b.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="306" src="https://oscimg.oschina.net/oscnet/up-4d508541738c8fc65a2f367dfeb655bda8b.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="311" src="https://oscimg.oschina.net/oscnet/up-a8bb5722b74ee290874eb54b2373cb00ff6.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="306" src="https://oscimg.oschina.net/oscnet/up-50cbdf8186a0c4335d77afaa69acda349e2.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270058</guid>
            <link>https://www.oschina.net/news/270058</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度 Comate 榮獲「2023 AIIA 人工智能十大先鋒應用案例」獎]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>12 月 7-8 日，中國人工智能產業發展聯盟（AIIA）第十次全體會議暨 2023 年通用人工智能創新發展論壇在重慶召開。</span>大會圍繞軟件工程、基礎平台、科學智能、具身智能等技術創新，數據、開源開放、安全治理等產業關鍵要素，以及金融、汽車等重點行業應用等人工智能最新熱點展開。</p><p><span>作為大會重磅環節，從今年 10 月起，AIIA 啓動</span><strong>「2023 人工智能十大先鋒應用案例徵集」活動</strong><span>，旨在甄選具有高價值、標杆性、真落地的行業典型應用實踐，打造 AI 界「奧斯卡」。經過為期 2 個月的徵集評審，從百餘項入圍案例中，</span><strong>百度智能代碼助手 Comate 脱穎而出，斬獲「2023AIIA 人工智能十大先鋒應用案例」獎，也是本次十大先鋒應用案例獎中的唯一軟件工程領域 AI 應用</strong><span><strong>。</strong></span></p><p><img height="846" src="https://static.oschina.net/uploads/space/2023/1208/110825_3Ktq_3820517.png" width="1269" referrerpolicy="no-referrer"></p><p><strong>（現場頒獎）</strong></p><p>從在百度內部全面落地應用，到面向企業開發者發佈「國內首個商用全場景智能編程助手」，再到 SaaS 版全面開放，百度 Comate 厚積薄發，持續引領 AI 原生研發新範式。</p><p>目前，百度 Comate 已覆蓋 100+種編程語言，支持 10+種主流 IDE，覆蓋編程前、後、移動端，支持軟硬件不同開發場景，為研發全生命週期提供全場景智能輔助，大幅提升研發效率的同時，也提升了工程師的工作倖福感。</p><p><img height="716" src="https://static.oschina.net/uploads/space/2023/1208/110838_ghZG_3820517.png" width="1268" referrerpolicy="no-referrer"></p><p><span>在技術創新優勢上，依賴文心大模型、飛槳深度學習平台以及百度多年積累的技術經驗，Comate 智能代碼助手具備</span><strong>模型訓練、推理加速、工程實踐和安全保障四重技術創新</strong><span>，並在</span><strong>代碼續寫、代碼解釋、NL2Code、Code Debug 等能力上領先行業與競品</strong><span>。</span></p><p><img height="712" src="https://static.oschina.net/uploads/space/2023/1208/110849_LSh5_3820517.png" width="1267" referrerpolicy="no-referrer"></p><p>在應用實效上，基於模型層多種能力，百度 Comate 具有優秀的代碼推薦、單測生成、自然語言代碼生成和代碼修復等能力；並通過開放 SaaS 版和私有化部署能力，滿足個人用户、中小企業和大型企業的不同需求。在百度內部，通過 Comate 生成代碼佔比 20%，整體採納率達 40%；SaaS 版開箱即用，註冊企業累計 4000+；涵蓋金融、汽車、互聯網、高端製造等在內的數十家大型企業已與 Comate 達成私有化部署合作。</p><p><img height="1842" src="https://static.oschina.net/uploads/space/2023/1208/192440_aMPH_3820517.png" width="3260" referrerpolicy="no-referrer"></p><p>未來，百度 Comate 還將持續強化產品能力建設，堅守安全性的同時增強開放性，為企業和個人用户提供更智能、更高效、更便捷的代碼輔助服務，助力研發效率持續提升，加速產業創新落地。</p><p>馬上申請免費試用，還有超多限時福利！</p><p><img height="533" src="https://static.oschina.net/uploads/space/2023/1208/110911_Fwzq_3820517.png" width="300" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:10:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270054/comate-aiia-2023-news</guid>
            <link>https://www.oschina.net/news/270054/comate-aiia-2023-news</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[網信辦發佈《網絡安全事件報告管理辦法（徵求意見稿）》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>國家互聯網信息辦公室就《網絡安全事件報告管理辦法（徵求意見稿）》公開徵求意見。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-c1eb5e22a141f8e4fc99760bb45a85f397d.png" referrerpolicy="no-referrer"></p><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.cac.gov.cn%2F2023-12%2F08%2Fc_1703609634347501.htm" target="_blank">http://www.cac.gov.cn/2023-12/08/c_1703609634347501.htm</a></u></em></p></blockquote><p>徵求意見稿提出，運營者在發生網絡安全事件時，應當及時啓動應急預案進行處置。按照《網絡安全事件分級指南》，<strong>屬於較大、重大或特別重大網絡安全事件的，應當於 1 小時內進行報告</strong>。</p><p>其中，<strong>網絡和系統歸屬中央和國家機關各部門及其管理的企事業單位的，運營者應當向本部門網信工作機構報告</strong>。屬於重大、特別重大網絡安全事件的，各部門網信工作機構在收到報告後應當於 1 小時內向國家網信部門報告。</p><p><strong>網絡和系統為關鍵信息基礎設施的，運營者應當向保護工作部門、公安機關報告</strong>。屬於重大、特別重大網絡安全事件的，保護工作部門在收到報告後，應當於 1 小時內向國家網信部門、國務院公安部門報告。</p><p><strong>其他網絡和系統運營者應當向屬地網信部門報告</strong>。屬於重大、特別重大網絡安全事件的，屬地網信部門在收到報告後，應當於 1 小時內逐級向上級網信部門報告。</p><p>有行業主管監管部門的，<strong>運營者還應當按照行業主管監管部門要求報告</strong>。</p><p>運營者應當按照《網絡安全事件信息報告表》報告事件，至少包括下列內容：</p><ul><li><p><strong>事發單位名稱及發生事件的設施、系統、平台的基本情況</strong>；</p></li><li><p><strong>事件發現或發生時間、地點、事件類型、已造成的影響和危害，已採取的措施及效果</strong>。對勒索軟件攻擊事件，還應當包括要求支付贖金的金額、方式、日期等；</p></li><li><p>事態發展趨勢及可能進一步造成的影響和危害；</p></li><li><p>初步分析的事件原因；</p></li><li><p>進一步調查分析所需的線索，包括可能的攻擊者信息、攻擊路徑、存在的漏洞等；</p></li><li><p>擬進一步採取的應對措施以及請求支援事項；</p></li><li><p>事件現場的保護情況；</p></li><li><p>其他應當報告的情況。</p></li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-c423dc28f0c5f4929c6ec12f752d357f88f.png" referrerpolicy="no-referrer"></p><p>當事件處置結束後，運營者應當於 5 個工作日內對事件原因、應急處置措施、危害、責任處理、整改情況、教訓等進行全面分析總結，形成報告按照原渠道上報。</p><hr><p>附網絡安全事件分級指南：</p><p><img height="1406" src="https://oscimg.oschina.net/oscnet/up-3bd9fcd558b1e34d9278bc32bdf7f4a8048.png" width="1030" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-b5c16894520b3208bea288209ff7de41132.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-66e96efeef0f4b5e2538e297a57ab5d40a8.png" referrerpolicy="no-referrer"></p><p><img height="1486" src="https://oscimg.oschina.net/oscnet/up-79b90dfeb4395d333078f97cdaff1a28129.png" width="936" referrerpolicy="no-referrer"></p><p><img height="1488" src="https://oscimg.oschina.net/oscnet/up-77f78a766c7e070b24b239150c9ec5de38f.png" width="934" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-dd98b736f8b6a5c76679267826d5058dada.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270052</guid>
            <link>https://www.oschina.net/news/270052</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[支付寶啓動鴻蒙原生應用開發]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>支付寶與華為終端宣佈合作，基於 HarmonyOS NEXT 啓動支付寶鴻蒙原生應用開發。</p><p><img alt="" height="326" src="https://oscimg.oschina.net/oscnet/up-a9aa0abdc54a1c436a2c973752477f7b5a2.webp" width="500" referrerpolicy="no-referrer"></p><p>支付寶事業羣總裁倪行軍表示，雙方的合作將進一步滿足用户在不同終端、不同場景下享受智慧生活服務的需求；同時，華為在支付寶小程序領域的數字化佈局也有利於提升商家在兩個生態中的經營效率。</p><p><span style="background-color:#ffffff; color:#2b2b2b">支付寶目前服務商家已達 8000 萬。通過支付寶 App，有近 400 萬個商家機構小程序，掃碼點單、生活繳費等超過 1000 項生活服務。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 02:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270047</guid>
            <link>https://www.oschina.net/news/270047</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米發佈《小米澎湃 OS 技術白皮書》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米正式發佈《小米澎湃 OS 技術白皮書》（下簡稱《白皮書》）。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-7edcacdddcb86895ce723541906e9102497.png" referrerpolicy="no-referrer"></p><p><strong><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcdn-file.hyperos.mi.com%2Fhyperos-file%2F%25E5%25B0%258F%25E7%25B1%25B3%25E6%25BE%258E%25E6%25B9%2583OS%25E6%258A%2580%25E6%259C%25AF%25E7%2599%25BD%25E7%259A%25AE%25E4%25B9%25A6V1.0.pdf" target="_blank">小米澎湃 OS 技術白皮書 V1.0</a></em></u></strong></p></blockquote><p>根據《白皮書》介紹，小米澎湃 OS 是一個為下一代的計算與多種設備生態設計的系統。</p><p><span style="background-color:rgba(255, 255, 255, 0.65); color:#151631">《白皮書》</span>對小米澎湃 OS 系統架構進行了詳細介紹、包括對各個子系統的架構以及關鍵技術的闡述，以及開發團隊對各個子系統的設計思路。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1dff4e9939fb63c6ac59b0c14f3aa700571.png" referrerpolicy="no-referrer"></p><p>小米表示：「希望通過分享這些技術成果和見解，激發更多的創意和合作，推動整個行業的進步，共同構建「人車家全生態」的未來。」</p><p>小米 CEO 雷軍在《白皮書》的序言中説道，2016 年，小米就開始研發跨端應用框架。2019 年，開始並行研發純自研通用系統 Mina OS，並在部分產品上小規模量產驗證，同時在實驗室中也成功在手機上跑通，其中部分技術成果也已融入小米澎湃 OS。2021 年，小米開啓了車機 OS 的研發。2022 年初，小米決定統一 MIUI、Vela、Mina、車機 OS 四個系統的軟件架構。自此，小米的操作系統底層合併完成。</p><blockquote><p><img height="1690" src="https://oscimg.oschina.net/oscnet/up-2b2e2aa832685a84d24571029ea1b7cccf2.png" width="1760" referrerpolicy="no-referrer"></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 02:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270045</guid>
            <link>https://www.oschina.net/news/270045</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux 內核源代碼官網 git.kernel.org 原生支持深色模式]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Linux 內核開發者收到了一份提前的聖誕禮物 ——&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgit.kernel.org%2F" target="_blank">git.kernel.org</a>&nbsp;Web 界面已原生支持深色模式。對於開發者來説，深色模模式可以增強瀏覽官方 Linux 內核 Git 倉庫，以及其他開發分支的查看體驗。</p><p><img src="https://oscimg.oschina.net/oscnet/up-7e14e90ceb4a018a01f4aebacdc75e3f470.png" referrerpolicy="no-referrer"></p><p>從提交記錄可以看到，幾個月前就已經有補丁將 CSS 暗模式支持添加到 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fgit.kernel.org" target="_blank">git.kernel.org</a> cgit Web 界面，現在終於上線了。</p><p><img src="https://oscimg.oschina.net/oscnet/up-514a596f11bc68a1ff4ba9c95167bba29c7.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 02:17:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270043</guid>
            <link>https://www.oschina.net/news/270043</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 前後端分離的全棧開源項目 AirPower]]>
            </title>
            <description>
                <![CDATA[<p align="center"><img width="300" src="https://gitee.com/air-power/AirPower4T/raw/web/assets/img/airpower.png" referrerpolicy="no-referrer"></p><p align="center"><img src="https://svg.hamm.cn/?key=Lang&amp;value=TypeScript&amp;bg=green" referrerpolicy="no-referrer"><img src="https://svg.hamm.cn/?key=Base&amp;value=Vue3" referrerpolicy="no-referrer"><img src="https://svg.hamm.cn/?key=Build&amp;value=Vite" referrerpolicy="no-referrer"><img src="https://svg.hamm.cn/?key=UI&amp;value=ElementPlus" referrerpolicy="no-referrer"></p><p><a href="https://gitee.com/air-power/AirPower4T">Gitee</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FHammCn%2FAirPower4T">Github</a> / <a href="https://gitee.com/air-power/AirPower4T/blob/web/CHANGELOG.md">CHANGELOG</a></p><h2><a id="user-content--這是個什麼項目" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E8%BF%99%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%A1%B9%E7%9B%AE"></a>📖 這是個什麼項目</h2><blockquote><p>你當前查看的是 <code>web</code> 分支，我們也同時提供了 <code>wechat</code>、<code>uniapp</code> 等分支：） 你可以先閲讀 <a href="https://gitee.com/link?target=https%3A%2F%2Fjuejin.cn%2Fpost%2F7273290114921889807">掘金專欄</a> 的一些文章，也可以體驗 <a href="https://gitee.com/link?target=https%3A%2F%2Fservice.hamm.cn">線上示例 DEMO</a>，如果你喜歡這個項目，歡迎給我們大大的 ⭐️⭐️⭐️</p></blockquote><p>為了滿足前端開發標準化、工程化、系統化等等需求，我們設計並開發了一個開發組件庫和常用類庫和方法庫的集合基礎腳手架，其中包含了一些頁面通用的佈局、常用的彈窗和交互、提示信息以及網絡請求，強類型面向對象的約束規範等，以滿足日常開發的快捷、穩健、標準化等要求。</p><p><strong>AirPower</strong> 是一個基於 <code>Vue3</code><code>TypeScript</code><code>Element Plus</code><code>Vite</code> 的開發基礎庫，使用 <strong>裝飾器</strong>、<strong>面向對象</strong>、<strong>Hook</strong> 等前端開發方式。</p><h2><a id="user-content--為何起名 airpower" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E4%B8%BA%E4%BD%95%E8%B5%B7%E5%90%8Dairpower"></a>🎈 為何起名<strong>AirPower</strong></h2><p>早期是子倉庫方式的設計, 這個依賴庫跟宿主項目在一起, 所以為了排前面, 選擇使用<strong>A</strong>開頭的單詞, 後來想起 <strong>Apple</strong> 家難產了的一個產品的名稱, <strong>AirPower</strong>, 作者是 Apple 十年老粉, 那就順便致敬下 <strong>Apple</strong>.</p><h2><a id="user-content--有哪些功能設計" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1"></a>🎉 有哪些功能 (設計)</h2><ol><li><strong>Model</strong> / <strong>Entity</strong> 所有的數據交互都以數據模型實例的方式進行, 不再直接使用 JSON.</li><li><strong>Service</strong> 使用服務類對所有的網絡請求進行抽象, 通過繼承方式實現相似代碼的複用</li><li><strong>Component</strong> 提供了很多後台管理系統常用的組件和一些反饋組件</li><li><strong>Hook</strong> 提供了與 Service 交互的一些通用的交互 Hooks</li><li><strong>Enum</strong> 提供了很多很多很多的枚舉</li><li><strong>Decorator</strong> 提供了很多很多很多的裝飾器</li><li>提供了類似 <strong>Java</strong> BeanCopy 相關的數據轉換方式, 提供了完整的面向對象實現</li><li>......</li></ol><h2><a id="user-content--代碼風格展示" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%B1%95%E7%A4%BA"></a>💻 代碼風格展示</h2><p><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/1.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/2.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/3.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/4.png" referrerpolicy="no-referrer"></p><h2><a id="user-content--如何使用初始化" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96"></a>🔑 如何使用 (初始化)?</h2><p>你可以通過我們提供的 <code>AirPower 宿主倉庫</code> 項目來完成 <strong>AirPower</strong> 宿主項目的初始化:</p><p>AirPowerWebStarter via <a href="https://gitee.com/air-power/AirPowerWebStarter/blob/main/README.md">Gitee</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FHammCn%2FAirPowerWebStarter%2Fblob%2Fmain%2FREADME.md">Github</a></p><h2><a id="user-content--我們的建議" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E6%88%91%E4%BB%AC%E7%9A%84%E5%BB%BA%E8%AE%AE"></a>🛎 我們的建議</h2><p>我們提供的 <strong>AirPower 宿主倉庫</strong> 裏面提供了一些 <code>ESlint 規則</code><code>路由配置</code><code>環境變量配置</code><code>tsconfig</code><code>vite.config</code>, 以及很多的 <strong>demo</strong> 代碼, 你可以進行參考。</p><p>如果你有什麼疑問或者問題，你也可以加入開發者交流 QQ 羣 (<code>555156313</code>) 進行諮詢，當然，我們更建議你發起 <a href="https://gitee.com/air-power/AirPower4T/issues/new">Gitee issue</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FHammCn%2FAirPower4T%2Fissues%2Fnew">Github issue</a></p><h2><a id="user-content--enjoy-it" class="anchor" href="https://gitee.com/air-power/AirPower4T#-enjoy-it"></a>⏰ Enjoy it</h2><p>好了, 那麼接下來你可以愉快的開發了, 如果你有什麼建議或者意見, 可以在本倉庫中提交你的 <strong>issues</strong>, 你可以為這個依賴庫進行 <strong>添磚加瓦</strong>!</p><blockquote><p>☕️Java: 加瓦? 什麼 Java?</p></blockquote><h2><a id="user-content--來點圖示例" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E6%9D%A5%E7%82%B9%E5%9B%BE%E7%A4%BA%E4%BE%8B"></a>📷 來點*圖 (示例)</h2><p><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/5.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/6.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/7.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/8.png" referrerpolicy="no-referrer"></p>]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 10:39:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/air-power/AirPower4T</guid>
            <link>https://gitee.com/air-power/AirPower4T</link>
        </item>
        <item>
            <title>
                <![CDATA[周星馳 Web3 團隊下個月上線獨立 App]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>12 月 7 日，新浪科技報道稱，周星馳 Web3 團隊透露，周星馳旗下 Web3 初創公司 Moonbox&nbsp;最早將於明年 1 月份完成上線 Moonbox App，屆時 App 將免費向用户開放。</p><p>目前，App 研發工作已經基本完成，Moonbox 團隊在 NFT 玩法上下了很多功夫，已設計出基於 AI 和 NFT 聊天的互動玩法，「周星馳將以 Moonbox First Creator 身份與大家見面」。</p><p>與此同時，周星馳參與創作的 NobodyNFT 新品，也將隨之發售，用户可以通過 App 和每個 Nobody NFT 角色聊天互動以瞭解人物性格、愛好、背景故事。</p><p>據悉，2023 年 8 月，周星馳曾公開宣佈入局 Web3+AI，並第一時間與 OKX 進行互動。周星馳當時在 INS 發文稱，「感恩找到一班志同道合的 Web3 夥伴，正在研究 Web3+AI 項目，希望做個我的 AI 代替我。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1fa24c9504d7b6c03e1cf018b165b6154e6.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 09:06:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269952</guid>
            <link>https://www.oschina.net/news/269952</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[新概念「防禦性編程」：讓自己穩拿鐵飯碗]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img height="559" src="https://static.oschina.net/uploads/space/2023/1207/164342_Cpqj_3820517.png" width="400" referrerpolicy="no-referrer"></p><p>&nbsp;</p><blockquote><p>譯者：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FcoderLMN" target="_blank"><span style="color:#3498db"><span style="background-color:#fdfdfd">/coderLMN</span></span></a></p><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>翻譯鏈接：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcoderlmn.github.io%2FfrontEndCourse%2Funmaintainable.html" target="_blank">https://coderlmn.github.io/frontEndCourse/unmaintainable.html</a></p></blockquote><hr><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>讓自己穩拿鐵飯碗 ;-)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><p><strong>-- Roedy Green</strong><br><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>（老碼農翻譯，略有刪節）</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br> &nbsp;</p><hr><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>簡介</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>永遠不要（把自己遇到的問題）歸因於（他人的）惡意，這恰恰説明瞭（你自己的）無能。&nbsp;</em>-- 拿破崙</p></blockquote><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>為了造福大眾，在 Java 編程領域創造就業機會，兄弟我在此傳授大師們的秘籍。這些大師寫的代碼極其難以維護，後繼者就是想對它做最簡單的修改都需要花上數年時間。而且，如果你能對照秘籍潛心修煉，你甚至可以給自己弄個鐵飯碗，因為除了你之外，沒人能維護你寫的代碼。再而且，如果你能練就秘籍中的<strong>全部</strong>招式，那麼連你自己都無法維護你的代碼了！</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>你不想練功過度走火入魔吧。那就不要讓你的代碼<strong>一眼看去</strong>就完全無法維護，只要它<strong>實質上是</strong>那樣就行了。否則，你的代碼就有被重寫或重構的風險！</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>總體原則</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>Quidquid latine dictum sit, altum sonatur.</em><br> (隨便用拉丁文寫點啥都會顯得高大上。)</p></blockquote><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>想挫敗維護代碼的程序員，你必須先明白他的思維方式。他接手了你的龐大程序，沒有時間把它全部讀一遍，更別説理解它了。他無非是想快速找到修改代碼的位置、改代碼、編譯，然後就能交差，並希望他的修改不會出現意外的副作用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>他查看你的代碼不過是管中窺豹，一次只能看到一小段而已。你要確保他永遠看不到全貌。要儘量和讓他難以找到他想找的代碼。但更重要的是，要讓他不能有把握<strong>忽略</strong>任何東西。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>程序員都被編程慣例洗腦了，還為此自鳴得意。每一次你處心積慮地違背編程慣例，都會迫使他必須用放大鏡去仔細閲讀你的每一行代碼。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>你可能會覺得每個語言特性都可以用來讓代碼難以維護，其實不然。你必須精心地誤用它們才行。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>命名</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>"當我使用一個單詞的時候" Humpty Dumpty 曾經用一種輕蔑的口氣説, "它就是我想表達的意思，不多也不少。「</em><br> - Lewis Carroll -- 《愛麗絲魔鏡之旅》， 第 6 章</p></blockquote><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>編寫無法維護代碼的技巧的重中之重是變量和方法命名的藝術。如何命名是和編譯器無關的。這就讓你有巨大的自由度去利用它們迷惑維護代碼的程序員。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>妙用&nbsp;寶寶起名大全</h4><p>買本寶寶起名大全，你就永遠不缺變量名了。比如&nbsp;<span style="color:#000099"><span>Fred</span></span>&nbsp;就是個好名字，而且鍵盤輸入它也省事。如果你就想找一些容易輸入的變量名，可以試試&nbsp;<span style="color:#000099"><span>adsf</span></span>&nbsp;或者&nbsp;<span style="color:#000099"><span>aoeu</span></span>之類。</p><h4>單字母變量名</h4><p>如果你給變量起名為 a,b,c，用簡單的文本編輯器就沒法搜索它們的引用。而且，沒人能猜到它們的含義。</p><h4>創造性的拼寫錯誤</h4><p>如果你必須使用描述性的變量和函數名，那就把它們都拼錯。還可以把某些函數和變量名拼錯，再把其他的拼對 (例如 SetPintleOpening 和 SetPintalClosing) ，我們就能有效地將 grep 或 IDE 搜索技術玩弄於股掌之上。這招超級管用。還可以混淆不同語言（比如<em>colour</em>&nbsp;-- 英國英語，和&nbsp;<em>color</em>&nbsp;-- 美國英語)。</p><h4>抽象</h4><p>在命名函數和變量的時候，充分利用抽象單詞，例如&nbsp;<em>it</em>,&nbsp;<em>everything</em>,&nbsp;<em>data</em>,&nbsp;<em>handle</em>,&nbsp;<em>stuff</em>,&nbsp;<em>do</em>,&nbsp;<em>routine</em>,&nbsp;<em>perform</em>&nbsp;和數字，例如 e.g.&nbsp;<span style="color:#000099"><span>routineX48</span></span>,&nbsp;<span style="color:#000099"><span>PerformDataFunction</span></span>,&nbsp;<span style="color:#000099"><span>DoIt</span></span>,&nbsp;<span style="color:#000099"><span>HandleStuff</span></span>&nbsp;還有&nbsp;<span style="color:#000099"><span>do_args_method</span></span>。</p><h4>首字母大寫的縮寫</h4><p>用首字母大寫縮寫（比如 GNU 代表 GNU's Not Unix) 使代碼簡潔難懂。真正的漢子 (無論男女) 從來不説明這種縮寫的含義，他們生下來就懂。</p><h4>辭典大輪換</h4><p>為了打破沉悶的編程氣氛，你可以用一本辭典來查找儘量多的同義詞。例如&nbsp;<em>display</em>,&nbsp;<em>show</em>,&nbsp;<em>present</em>。在註釋裏含糊其辭地暗示這些命名之間有細微的差別，其實根本沒有。不過，如果有兩個命名相似的函數真的有重大差別，那倒是一定要確保它們用相同的單詞來命名 (例如，對於 "寫入文件", "在紙上書寫" 和 "屏幕顯示" 都用&nbsp;<em>print</em>&nbsp;來命名)。 在任何情況下都不要屈服於編寫明確的項目詞彙表這種無理要求。你可以辯解説，這種要求是一種不專業的行為，它違反了結構化設計的<em>信息隱藏原則</em>。</p><h4>首字母大寫</h4><p>隨機地把單詞中間某個音節的首字母大寫。例如&nbsp;<span style="color:#000099"><span>ComputeReSult()</span></span>。</p><h4>重用命名</h4><p>在語言規則允許的地方，儘量把類、構造器、方法、成員變量、參數和局部變量都命名成一樣。更高級的技巧是在{}塊中重用局部變量。這樣做的目的是迫使維護代碼的程序員認真檢查每個示例的範圍。特別是在 Java 代碼中，可以把普通方法偽裝成構造器。</p><h4>使用非英語字母</h4><p>在命名中偷偷使用不易察覺的非英語字母，例如看上去沒啥不對是吧？嘿嘿嘿...這裏的第二個 ínt 的&nbsp;<strong>í</strong>&nbsp;實際上是東北歐字母，並不是英語中的 i 。在簡單的文本編輯器裏，想看出這一點點區別幾乎是不可能的。</p><h4>巧妙利用編譯器對於命名長度的限制</h4><p>如果編譯器只區分命名的前幾位，比如前 8 位，那麼就把後面的字母寫得不一樣。比如，其實是同一個變量，有時候寫成&nbsp;<em>var_unit_update()</em>&nbsp;，有時候又寫成&nbsp;<em>var_unit_setup()</em>，看起來是兩個不同的函數調用。而在編譯的時候，它們其實是同一個變量&nbsp;<em>var_unit</em>。</p><h4>下劃線，一位真正的朋友</h4><p>可以拿 _ 和 __ 作為標示符。</p><h4>混合多語言</h4><p>隨機地混用兩種語言（人類語言或計算機語言都行）。如果老闆要求使用他指定的語言，你就告訴他你用自己的語言更有利於組織你的思路，萬一這招不管用，就去控訴這是語言歧視，並威脅起訴老闆要求鉅額精神損失賠償。</p><h4>擴展 ASCII 字符</h4><p>擴展 ASCII 字符用於變量命名是完全合法的，包括 ß, Ð, 和 ñ 等。在簡單的文本編輯器裏，除了拷貝/粘貼，基本上沒法輸入。</p><h4>其他語言的命名</h4><p>使用外語字典作為變量名的來源。例如，可以用德語單詞&nbsp;<em>punkt</em>&nbsp;代替&nbsp;<em>point</em>。除非維護代碼的程序員也像你一樣熟練掌握了德語. 不然他就只能盡情地在代碼中享受異域風情了。</p><h4>數學命名</h4><p>用數學操作符的單詞來命名變量。例如：</p><p>openParen<span>&nbsp;</span><strong>=</strong><span>&nbsp;</span>(slash<span>&nbsp;</span><strong>+</strong><span>&nbsp;</span>asterix)<span>&nbsp;</span><strong>/</strong><span>&nbsp;</span>equals;<br> (左圓括號 = (斜槓 + 星號)/等號;)</p><h4>令人眩暈的命名</h4><p>用帶有完全不相關的感情色彩的單詞來命名變量。例如：這一招可以讓閲讀代碼的人陷入迷惑之中，因為他們在試圖想清楚這些命名的邏輯時，會不自覺地聯繫到不同的感情場景裏而無法自拔。</p><p>marypoppins<span>&nbsp;</span><strong>=</strong><span>&nbsp;</span>(superman<span>&nbsp;</span><strong>+</strong><span>&nbsp;</span>starship)<span>&nbsp;</span><strong>/</strong><span>&nbsp;</span>god;<br> (歡樂滿人間 = (超人 + 星河戰隊)/上帝;)</p><h4>何時使用 i</h4><p>永遠不要把&nbsp;<span style="color:#000099"><span>i</span></span>&nbsp;用作最內層的循環變量。 用什麼命名都行，就是別用<span style="color:#000099"><span>i</span></span>。把&nbsp;<span style="color:#000099"><span>i</span></span>&nbsp;用在其他地方就隨便了，用作非整數變量尤其好。</p><h4>慣例 -- 明修棧道，暗度陳倉</h4><p>忽視&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fjava.sun.com%2Fdocs%2Fcodeconv%2F" target="_blank">Java 編碼慣例</a>，Sun 就是這樣做的。幸運的是，你違反了它編譯器也不會打小報告。這一招的目的是搞出一些在某些特殊情況下有細微差別的名字來。如果你被強迫遵循駝峯法命名，你還是可以在某些模稜兩可的情況下顛覆它。例如，<em>input<strong>F</strong>ile<strong>n</strong>ame</em>&nbsp;和&nbsp;<em>input<strong>f</strong>ile<strong>N</strong>ame</em>&nbsp;兩個命名都可以合法使用。在此基礎上自己發明一套複雜到變態的命名慣例，然後就可以痛扁其他人，説他們違反了慣例。</p><h4>小寫的 l 看上去很像數字 1</h4><p>用小寫字母 l 標識 long 常數。例如 10l 更容易被誤認為是 101 而不是 10L 。 禁用所有能讓人準確區分 uvw wW gq9 2z 5s il17|!j oO08 `'" ;,. m nn rn {[()]} 的字體。要做個有創造力的人。</p><h4>把全局命名重用為私有</h4><p>在 A 模塊裏聲明一個全局數組，然後在 B 模塊的頭文件裏在聲明一個同名的私有數組，這樣看起來你在 B 模塊裏引用的是那個全局數組，其實卻不是。不要在註釋裏提到這個重複的情況。</p><h4>誤導性的命名</h4><p>讓每個方法都和它的名字藴含的功能有一些差異。例如，一個叫&nbsp;<span style="color:#000099"><span>isValid(x)</span></span>的方法在判斷完參數 x 的合法性之後，還順帶着把它轉換成二進制並保存到數據庫裏。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>偽裝</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>當一個 bug 需要越長的時間才會暴露，它就越難被發現。</em><br> - Roedy Green（本文作者）</p></blockquote><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>編寫無法維護代碼的另一大秘訣就是偽裝的藝術，即隱藏它或者讓它看起來像其他東西。很多招式有賴於這樣一個事實：編譯器比肉眼或文本編輯器更有分辨能力。下面是一些偽裝的最佳招式。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>把代碼偽裝成註釋，反之亦然</h4><p>下面包括了一些被註釋掉的代碼，但是一眼看去卻像是正常代碼。 如果不是用綠色標出來，你能注意到這三行代碼被註釋掉了麼？</p><pre><code>for(j=0; j&lt;array_len; j+ =8)
    {
    total += array[j+0 ];
    total += array[j+1 ];
    total += array[j+2 ]; /* Main body of
    total += array[j+3]; * loop is unrolled
    total += array[j+4]; * for greater speed.
    total += array[j+5]; */
    total += array[j+6 ];
    total += array[j+7 ];
    }</code></pre><h4>用連接符隱藏變量</h4><p>對於下面的定義</p><p>#define local_var xy_z</p><p>可以把 "xy_z" 打散到兩行裏：</p><p>#define local_var xy\<br> _z // local_var OK</p><p>這樣全局搜索 xy_z 的操作在這個文件裏就一無所獲了。 對於 C 預處理器來説，第一行最後的 "\" 表示繼續拼接下一行的內容。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>文檔</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><em>任何傻瓜都能説真話，而要把謊編圓則需要相當的智慧。</em><br> - Samuel Butler (1835 - 1902)
</blockquote><p style="text-align:start">&nbsp;</p><blockquote><em>不正確的文檔往往比沒有文檔還糟糕。</em><br> - Bertrand Meyer
</blockquote><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>既然計算機是忽略註釋和文檔的，你就可以在裏邊堂而皇之地編織彌天大謊，讓可憐的維護代碼的程序員徹底迷失。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>在註釋中撒謊</h4><p>實際上你不需要主動地撒謊，只要沒有及時保持註釋和代碼更新的一致性就可以了。</p><h4>只記錄顯而易見的東西</h4><p>往代碼裏摻進去類似於&nbsp;<span style="color:green">/* 給 i 加 1 */</span>&nbsp;這樣的註釋，但是永遠不要記錄包或者方法的整體設計這樣的乾貨。 &nbsp;</p><h4>記錄 How 而不是 Why</h4><p>只解釋一個程序功能的細節，而不是它要完成的任務是什麼。這樣的話，如果出現了一個 bug，修復者就搞不清這裏的代碼應有的功能。</p><h4>該寫的別寫</h4><p>比如你在開發一套航班預定系統，那就要精心設計，讓它在增加另一個航空公司的時候至少有 25 處代碼需要修改。永遠不要在文檔裏説明要修改的位置。後來的開發人員要想修改你的代碼門都沒有，除非他們能把每一行代碼都讀懂。</p><h4>計量單位</h4><p>永遠不要在文檔中説明任何變量、輸入、輸出或參數的計量單位，如英尺、米、加侖等。計量單位對數豆子不是太重要，但在工程領域就相當重要了。同理，永遠不要説明任何轉換常量的計量單位，或者是它的取值如何獲得。要想讓代碼更亂的話，你還可以在註釋裏寫上錯誤的計量單位，這是赤裸裸的欺騙，但是非常有效。如果你想做一個惡貫滿盈的人，不妨自己發明一套計量單位，用自己或某個小人物的名字命名這套計量單位，但不要給出定義。萬一有人挑刺兒，你就告訴他們，你這麼做是為了把浮點數運算湊成整數運算而進行的轉換。 &nbsp;</p><h4>坑</h4><p>永遠不要記錄代碼中的坑。如果你懷疑某個類裏可能有 bug，天知地知你知就好。如果你想到了重構或重寫代碼的思路，看在老天爺的份上，千萬別寫出來。切記電影《小鹿斑比》裏那句台詞&nbsp;<em>"如果你不能説好聽的話，那就什麼也不要説。"</em>。萬一這段代碼的原作者看到你的註釋怎麼辦？萬一老闆看到了怎麼辦？萬一客户看到了怎麼辦？搞不好最後你自己被解僱了。一句」這裏需要修改「的匿名註釋就好多了，尤其是當看不清這句註釋指的是哪裏需要修改的情況下。切記難得糊塗四個字，這樣大家都不會感覺受到了批評。 &nbsp;</p><h4>説明變量</h4><p><strong>永遠不要</strong>&nbsp;對變量聲明加註釋。有關變量使用的方式、邊界值、合法值、小數點後的位數、計量單位、顯示格式、數據錄入規則等等，後繼者完全可以自己從程序代碼中去理解和整理嘛。如果老闆強迫你寫註釋，就把方法體代碼混進去，但絕對不要對變量聲明寫註釋，即使是臨時變量！</p><h4>在註釋裏挑撥離間</h4><p>為了阻撓任何僱傭外部維護承包商的傾向，可以在代碼中散佈針對其他同行軟件公司的攻擊和抹黑，特別是可能接替你工作的其中任何一家。例如：</p><p><span style="color:green">/* 優化後的內層循環<br> 這套技巧對於 SSI 軟件服務公司的那幫蠢材來説太高深了，他們只會<br> 用 &lt;math.h&gt; 裏的笨例程，消耗 50 倍的內存和處理時間。<br> */</span><br> class&nbsp;<strong>clever_SSInc</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;{<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;..</strong>&nbsp;<strong>.</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;}</p><p><span>可能的話，除了註釋之外，這些攻擊抹黑的內容也要摻到代碼裏的重要部分，這樣如果管理層想清理掉這些攻擊性的言論然後發給外部承包商去維護，就會破壞代碼結構。</span></p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>程序設計</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><em>編寫無法維護代碼的基本規則就是：在儘可能多的地方，以儘可能多的方式表述每一個事實。</em><br> - Roedy Green
</blockquote><p style="text-align:start">編寫可維護代碼的關鍵因素是隻在一個地方表述應用裏的一個事實。如果你的想法變了，你也只在一個地方修改，這樣就能保證整個程序正常工作。所以，編寫無法維護代碼的關鍵因素就是反覆地表述同一個事實，在儘可能多的地方，以儘可能多的方式進行。令人高興的是，像 Java 這樣的語言讓編寫這種無法維護代碼變得非常容易。例如，改變一個被引用很多的變量的類型幾乎是不可能的，因為所有造型和轉換功能都會出錯，而且關聯的臨時變量的類型也不合適了。而且，如果變量值要在屏幕上顯示，那麼所有相關的顯示和數據錄入代碼都必須一一找到並手工進行修改。類似的還有很多，比如由 C 和 Java 組成的 Algol 語言系列，Abundance 甚至 Smalltalk 對於數組等結構的處理，都是大有可為的。</p><h4>Java 造型</h4><p>Java 的造型機制是上帝的禮物。你可以問心無愧地使用它，因為 Java 語言本身就需要它。每次你從一個 Collection 裏獲取一個對象，你都必須把它造型為原始類型。這樣這個變量的類型就必須在無數地方表述。如果後來類型變了，所有的造型都要修改才能匹配。如果倒黴的維護代碼的程序員沒有找全（或者修改太多），編譯器能不能檢測到也不好説。類似的，如果變量類型從<span style="color:#000099"><span>short</span></span>&nbsp;變成&nbsp;<span style="color:#000099"><span>int</span></span>，所有匹配的造型也都要從<span style="color:#000099"><span>(short)</span></span>&nbsp;改成&nbsp;<span style="color:#000099"><span>(int)</span></span>。</p><h4>利用 Java 的冗餘</h4><p>Java 要求你給每個變量的類型寫兩次表述。 Java 程序員已經習慣了這種冗餘，他們不會注意到你的兩次表述有細微的差別，例如</p><p>Bubbleg<em>u</em>m<span>&nbsp;</span><strong>b</strong><span>&nbsp;</span><strong>=</strong><span>&nbsp;</span>new Bubbleg<em>o</em>m();</p><p>不幸的是 ++ 操作符的盛行讓下面這種偽冗餘代碼得手的難度變大了：</p><p>swim<em>m</em>er<span>&nbsp;</span><strong>=</strong><span>&nbsp;</span>swim<em>n</em>er<span>&nbsp;</span><strong>+</strong><span>&nbsp;</span>1;</p><h4>永遠不做校驗</h4><p>永遠不要對輸入數據做任何的正確性或差異性檢查。這樣能表現你對公司設備的絕對信任，以及你是一位信任所有項目夥伴和系統管理員的團隊合作者。總是返回合理的值，即使數據輸入有問題或者錯誤。 &nbsp;</p><h4>有禮貌，無斷言</h4><p>避免使用 assert() 機制，因為它可能把三天的 debug 盛宴變成 10 分鐘的快餐。</p><h4>避免封裝</h4><p>為了提高效率，不要使用封裝。方法的調用者需要所有能得到的外部信息，以便了解方法的內部是如何工作的。 &nbsp;</p><h4>複製粘貼修改</h4><p>以效率的名義，使用，複製+粘貼+修改。這樣比寫成小型可複用模塊效率高得多。在用代碼行數衡量你的進度的小作坊裏，這招尤其管用。</p><h4>使用靜態數組</h4><p>如果一個庫裏的模塊需要一個數組來存放圖片，就定義一個靜態數組。沒人會有比 512 X 512 更大的圖片，所以固定大小的數組就可以了。為了最佳精度，就把它定義成 double 類型的數組。 &nbsp;</p><h4>傻瓜接口</h4><p>編寫一個名為 "WrittenByMe" 之類的空接口，然後讓你的所有類都實現它。然後給所有你用到的 Java 內置類編寫包裝類。這裏的思想是確保你程序裏的每個對象都實現這個接口。最後，編寫所有的方法，讓它們的參數和返回類型都是這個 WrittenByMe。這樣就幾乎不可能搞清楚某個方法的功能是什麼，並且所有類型都需要好玩的造型方法。更出格的玩法是，讓每個團隊成員編寫它們自己的接口 (例如 WrittenByJoe)，程序員用到的任何類都要實現他自己的接口。這樣你就可以在大量無意義接口中隨便找一個來引用對象了。</p><h4>巨型監聽器</h4><p>永遠不要為每個組件創建分開的監聽器。對所有按鈕總是用同一個監聽器，只要用大量的 if...else 來判斷是哪一個按鈕被點擊就行了。 &nbsp;</p><h4>好事成堆 TM</h4><p>狂野地使用封裝和 OO 思想。例如，這段很可能看起來不怎麼好笑。別擔心，只是時候未到而已。</p><p>myPanel<strong>.</strong>add( getMyButton<strong>(</strong><strong>)</strong>&nbsp;);<br> private JButton&nbsp;<strong>getMyButton</strong>()</p><p>&nbsp;&nbsp;&nbsp;&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;return myButton;<br> &nbsp;&nbsp;&nbsp;&nbsp;}</p><h4>友好的朋友</h4><p>在 C++ 裏儘量多使用 friend 聲明。再把創建類的指針傳遞給已創建類。現在你不用浪費時間去考慮接口了。另外，你應該用上關鍵字<em>private</em>&nbsp;和&nbsp;<em>protected</em>&nbsp;來表明你的類封裝得很好。</p><h4>使用三維數組</h4><p>大量使用它們。用扭曲的方式在數組之間移動數據，比如，用 arrayA 裏的行去填充 arrayB 的列。這麼做的時候，不管三七二十一再加上 1 的偏移值，這樣很靈。讓維護代碼的程序員抓狂去吧。 &nbsp;</p><h4>混合與匹配</h4><p>存取方法和公共變量神馬的都要給他用上。這樣的話，你無需調用存取器的開銷就可以修改一個對象的變量，還能宣稱這個類是個"Java Bean"。對於那些試圖添加日誌函數來找出改變值的源頭的維護代碼的程序員，用這一招來迷惑他尤其有效。 &nbsp;</p><h4>沒有秘密!</h4><p>把每個方法和變量都聲明為 public。畢竟某個人某天可能會需要用到它。一旦方法被聲明為 public 了，就很難縮回去。對不？這樣任何它覆蓋到的代碼都很難修改了。它還有個令人愉快的副作用，就是讓你看不清類的作用是什麼。如果老闆質問你是不是瘋了，你就告訴他你遵循的是經典的透明接口原則。</p><h4>全堆一塊</h4><p>把你所有的沒用的和過時的方法和變量都留在代碼裏。畢竟説起來，既然你在 1976 年用過一次，誰知道你啥時候會需要再用到呢？當然程序是改了，但它也可能會改回來嘛，你"不想要重新發明輪子"（領導們都會喜歡這樣的口氣）。如果你還原封不動地留着這些方法和變量的註釋，而且註釋寫得又高深莫測，甭管維護代碼的是誰，恐怕都不敢對它輕舉妄動。</p><h4>就是 Final</h4><p>把你所有的葉子類都聲明為 final。畢竟説起來，你在項目裏的活兒都幹完了，顯然不會有其他人會通過擴展你的類來改進你的代碼。這種情況甚至可能有安全漏洞。 java.lang.String 被定義成 final 也許就是這個原因吧？如果項目組其他程序員有意見，告訴他們這樣做能夠提高運行速度。</p><h4>避免佈局</h4><p>永遠不要用到佈局。當維護代碼的程序員想增加一個字段，他必須手工調整屏幕上顯示所有內容的絕對座標值。如果老闆強迫你使用佈局，那就寫一個巨型的 GridBagLayout 並在裏面用絕對座標進行硬編碼。</p><h4>全局變量，怎麼強調都不過分</h4><p>如果上帝不願意我們使用全局變量，他就不會發明出這個東西。不要讓上帝失望，儘量多使用全局變量。每個函數最起碼都要使用和設置其中的兩個，即使沒有理由也要這麼做。畢竟，任何優秀的維護代碼的程序員都會很快搞清楚這是一種偵探工作測試，有利於讓他們從笨蛋中脱穎而出。 &nbsp;</p><h4>再一次説説全局變量</h4><p>全局變量讓你可以省去在函數裏描述參數的麻煩。充分利用這一點。在全局變量中選那麼幾個來表示對其他全局變量進行操作的類型。</p><h4>局部變量</h4><p>永遠不要用局部變量。在你感覺想要用的時候，把它改成一個實例或者靜態變量，並無私地和其他方法分享它。這樣做的好處是，你以後在其他方法裏寫類似聲明的時候會節省時間。C++程序員可以百尺竿頭更進一步，把所有變量都弄成全局的。</p><h4>配置文件</h4><p>配置文件通常是以，關鍵字 = 值，的形式出現。在加載時這些值被放入 Java 變量中。最明顯的迷惑技術就是把有細微差別的名字用於關鍵字和 Java 變量.甚至可以在配置文件裏定義運行時根本不會改變的常量。參數文件變量和簡單變量比，維護它的代碼量起碼是後者的 5 倍。</p><h4>子類</h4><p>對於編寫無法維護代碼的任務來説，面向對象編程的思想簡直是天賜之寶。如果你有一個類，裏邊有 10 個屬性（成員/方法），可以考慮寫一個基類，裏面只有一個屬性，然後產生 9 層的子類，每層增加一個屬性。等你訪問到最終的子類時，你才能得到全部 10 個屬性。如果可能，把每個類的聲明都放在不同的文件裏。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>編碼迷局</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><h4>迷惑 C</h4><p>從互聯網上的各種混亂 C 語言競賽中學習，追隨大師們的腳步。</p><h4>追求極致</h4><p>總是追求用最迷惑的方式來做普通的任務。例如，要用數組來把整數轉換為相應的字符串，可以這麼做：</p><p>char *p;<br> switch (n)<br> {<br> case 1:<br> &nbsp;&nbsp;&nbsp;&nbsp;p = "one";<br> &nbsp;&nbsp;&nbsp;&nbsp;if (0)<br> case 2:<br> &nbsp;&nbsp;&nbsp;&nbsp;p = "two";<br> &nbsp;&nbsp;&nbsp;&nbsp;if (0)<br> case 3:<br> &nbsp;&nbsp;&nbsp;&nbsp;p = "three";<br> &nbsp;&nbsp;&nbsp;&nbsp;printf("%s", p);<br> &nbsp;&nbsp;&nbsp;&nbsp;break;<br> }</p><h4>一致性的小淘氣</h4><p>當你需要一個字符常量的時候，可以用多種不同格式： ' ', 32, 0x20, 040。在 C 或 Java 裏 10 和 010 是不同的數（0 開頭的表示 16 進制），你也可以充分利用這個特性。</p><h4>造型</h4><p>把所有數據都以 void * 形式傳遞，然後再造型為合適的結構。不用結構而是通過位移字節數來造型也很好玩。</p><h4>嵌套 Switch</h4><p>Switch 裏邊還有 Switch，這種嵌套方式是人類大腦難以破解的。 &nbsp;</p><h4>利用隱式轉化</h4><p>牢記編程語言中所有的隱式轉化細節。充分利用它們。數組的索引要用浮點變量，循環計數器用字符，對數字執行字符串函數調用。不管怎麼説，所有這些操作都是合法的，它們無非是讓源代碼更簡潔而已。任何嘗試理解它們的維護者都會對你感激不盡，因為他們必須閲讀和學習整個關於隱式數據類型轉化的章節，而這個章節很可能是他們來維護你的代碼之前完全忽略了的。</p><h4>分號!</h4><p>在所有語法允許的地方都加上分號，例如：</p><p>if(a);<br> else;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;<strong>d</strong>;<br> &nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;<strong>=</strong>&nbsp;c;<br> &nbsp;&nbsp;&nbsp;&nbsp;}<br> &nbsp;&nbsp;&nbsp;&nbsp;;</p><h4>使用八進制數</h4><p>把八進制數混到十進制數列表裏，就像這樣：</p><p>array&nbsp;<strong>=</strong>&nbsp;new int&nbsp;<strong>[</strong><strong>]</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;111<strong>,</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;120<strong>,</strong><br><span style="color:red">&nbsp;&nbsp;&nbsp;&nbsp;013</span><strong>,</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;121<strong>,</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;};</p><h4>嵌套</h4><p>儘可能深地嵌套。優秀的程序員能在一行代碼裏寫 10 層 ()，在一個方法裏寫 20 層{}。 &nbsp;</p><h4>C 數組</h4><p>C 編譯器會把&nbsp;<span style="color:#000099"><span>myArray[i]</span></span>&nbsp;轉換成&nbsp;<span style="color:#000099"><span>*(myArray + i)</span></span>，它等同於&nbsp;<span style="color:#000099"><span>*(i + myArray)</span></span>&nbsp;也等同於&nbsp;<span style="color:#000099"><span>i[myArray]</span></span>。 高手都知道怎麼用好這個招。可以用下面的函數來產生索引，這樣就把代碼搞亂了：</p><p><span style="color:#000099"><span>int myfunc(int q, int p) { return p%q; }<br> ...<br> myfunc(6291, 8)[Array];</span></span></p><p>遺憾的是，這一招只能在本地 C 類裏用，Java 還不行。</p><h4>放長線釣大魚</h4><p>一行代碼裏堆的東西越多越好。這樣可以省下臨時變量的開銷，去掉換行和空格還可以縮短源文件大小。記住，要去掉運算符兩邊的空格。優秀的程序員總是能突破某些編輯器對於 255 個字符行寬的限制。</p><h4>異常</h4><p>我這裏要向你傳授一個編程中鮮為人知的秘訣。異常是個討厭的東西。良好的代碼永遠不會出錯，所以異常實際上是不必要的。不要把時間浪費在這上面。子類異常是給那些知道自己代碼會出錯的低能兒用的。在整個應用裏，你只用在 main() 裏放一個 try/catch，裏邊直接調用 System.exit() 就行了。在每個方法頭要貼上標準的拋出集合定義，到底會不會拋出異常你就不用管了。 &nbsp;</p><h4>使用異常的時機</h4><p>在非異常條件下才要使用異常。比如終止循環就可以用&nbsp;<span style="color:#000099"><span>ArrayIndexOutOfBoundsException</span></span>。還可以從異常裏的方法返回標準的結果。 &nbsp;</p><h4>狂熱奔放地使用線程</h4><p>如題。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>測試</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>在程序裏留些 bug，讓後繼的維護代碼的程序員能做點有意思的事。精心設計的 bug 是無跡可尋的，而且誰也不知道它啥時候會冒出來。要做到這一點，最簡單的辦法的就是不要測試代碼。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>永不測試</h4><p>永遠不要測試負責處理錯誤、當機或操作系故障的任何代碼。反正這些代碼永遠也不會執行，只會拖累你的測試。還有，你怎麼可能測試處理磁盤錯誤、文件讀取錯誤、操作系統崩潰這些類型的事件呢？為啥你要用特別不穩定的計算機或者用測試腳手架來模擬這樣的環境？現代化的硬件永遠不會崩潰，誰還願意寫一些僅僅用於測試的代碼？這一點也不好玩。如果用户抱怨，你就怪到操作系統或者硬件頭上。他們永遠不會知道真相的。</p><h4>永遠不要做性能測試</h4><p>嘿，如果軟件運行不夠快，只要告訴客户買個更快的機器就行了。如果你真的做了性能測試，你可能會發現一個瓶頸，這會導致修改算法，然後導致整個產品要重新設計。誰想要這種結果？而且，在客户那邊發現性能問題意味着你可以免費到外地旅遊。你只要備好護照和最新照片就行了。</p><h4>永遠不要寫任何測試用例</h4><p>永遠不要做代碼覆蓋率或路徑覆蓋率測試。自動化測試是給那些窩囊廢用的。搞清楚哪些特性佔到你的例程使用率的 90%，然後把 90% 的測試用在這些路徑上。畢竟説起來，這種方法可能只測試到了大約你代碼的 60%，這樣你就節省了 40% 的測試工作。這能幫助你趕上項目後端的進度。等到有人發現所有這些漂亮的「市場特性」不能正常工作的時候，你早就跑路了。一些有名的大軟件公司就是這樣測試代碼的，所以你也應該這樣做。如果因為某種原因你還沒走，那就接着看下一節。 &nbsp;</p><h4>測試是給懦夫用的</h4><p>勇敢的程序員會跳過這個步驟。太多程序員害怕他們的老闆，害怕丟掉工作，害怕客户的投訴郵件，害怕遭到起訴。這種恐懼心理麻痹了行動，降低了生產率。有科學研究成果表明，取消測試階段意味着經理有把握能提前確定交付時間，這對於規劃流程顯然是有利的。消除了恐懼心理，創新和實驗之花就隨之綻放。程序員的角色是生產代碼，調試工作完全可以由技術支持和遺留代碼維護組通力合作來進行。</p><p>如果我們對自己的編程能力有充分信心，那麼測試就沒有必要了。如果我們邏輯地看待這個問題，隨便一個傻瓜都能認識到測試根本都不是為瞭解決技術問題，相反，它是一種感性的信心問題。針對這種缺乏信心的問題，更有效的解決辦法就是完全取消測試，送我們的程序員去參加自信心培訓課程。畢竟説起來，如果我們選擇做測試，那麼我們就要測試每個程序的變更，但其實我們只需要送程序員去一次建立自信的培訓課就行了。很顯然這麼做的成本收益是相當可觀的。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>編程語言的選擇</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>計算機語言正在逐步進化，變得更加傻瓜化。使用最新的語言是不人性的。儘可能堅持使用你會用的最老的語言，先考慮用穿孔紙帶，不行就用匯編，再不行用 FORTRAN 或者 COBOL，再不行就用 C 還有 BASIC，實在不行再用 C++。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>FØRTRAN</h4><p>用 FORTRAN 寫所有的代碼。如果老闆問你為啥，你可以回答説有很多它非常有用的庫，你用了可以節約時間。不過，用 FORTRAN 寫出可維護代碼的概率是 0，所以，要達到不可維護代碼編程指南里的要求就容易多了。</p><h4>用 ASM</h4><p>把所有的通用工具函數都轉成彙編程序。</p><h4>用 QBASIC</h4><p>所有重要的庫函數都要用 QBASIC 寫，然後再寫個彙編的封包程序來處理 large 到 medium 的內存模型映射。</p><h4>內聯彙編</h4><p>在你的代碼裏混雜一些內聯的彙編程序，這樣很好玩。這年頭幾乎沒人懂彙編程序了。只要放幾行彙編代碼就能讓維護代碼的程序員望而卻步。</p><h4>宏彙編調用 C</h4><p>如果你有個彙編模塊被 C 調用，那就儘可能經常從彙編模塊再去調用 C，即使只是出於微不足道的用途，另外要充分利用 goto, bcc 和其他炫目的彙編秘籍。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>與他人共事之道</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><h4>老闆才是真行家</h4><p>如果你的老闆認為他 20 年的 FORTRAN 編程經驗對於現代軟件開發具有很高的指導價值，你務必嚴格採納他的所有建議。投桃報李，你的老闆也會信任你。這會對你的職業發展有利。你還會從他那裏學到很多搞亂程序代碼的新方法。</p><h4>顛覆技術支持</h4><p>確保代碼中到處是 bug 的有效方法是永遠不要讓維護代碼的程序員知道它們。這需要顛覆技術支持工作。永遠不接電話。使用自動語音答覆「感謝撥打技術支持熱線。需要人工服務請按 1，或在嘀聲後留言。」，請求幫助的電子郵件必須忽略，不要給它分配服務追蹤號。對任何問題的標準答覆是「我估計你的賬户被鎖定了，有權限幫你恢復的人現在不在。」 &nbsp;</p><h4>沉默是金</h4><p>永遠不要對下一個危機保持警覺。如果你預見到某個問題可能會在一個固定時間爆發，摧毀西半球的全部生命，不要公開討論它。不要告訴朋友、同事或其他你認識的有本事的人。在任何情況下都不要發表任何可能暗示到這種新的威脅的內容。只發送一篇正常優先級的、語焉不詳的備忘錄給管理層，保護自己免遭秋後算賬。如果可能的話，把這篇稀裏糊塗的信息作為另外一個更緊急的業務問題的附件。這樣就可以心安理得地休息了，你知道將來你被強制提前退休之後一段時間，他們又會求着你回來，並給你對數級增長的時薪！ &nbsp;</p><h4>每月一書俱樂部</h4><p>加入一個計算機每月一書俱樂部。選擇那些看上去忙着寫書不可能有時間真的去寫代碼的作者。去書店裏找一些有很多圖表但是沒有代碼例子的書。瀏覽一下這些書，從中學會一些迂腐拗口的術語，用它們就能唬住那些自以為是的維護代碼的程序員。你的代碼肯定會給他留下深刻印象。如果人們連你寫的術語都理解不了，他們一定會認為你非常聰明，你的算法非常深奧。不要在你的算法説明裏作任何樸素的類比。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>自立門户</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>你一直想寫系統級的代碼。現在機會來了。忽略標準庫，&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.roll-your-own.com%2F" target="_blank">編寫你自己的標準</a><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>，這將會是你簡歷中的一個亮點。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>推出你自己的 BNF 範式</h4><p>總是用你自創的、獨一無二的、無文檔的 BNF 範式記錄你的命令語法。永遠不要提供一套帶註解的例子（合法命令和非法命令之類）來解釋你的語法體系。那樣會顯得完全缺乏學術嚴謹性。確保沒有明顯的方式來區分終結符和中間符號。永遠不要用字體、顏色、大小寫和其他任何視覺提示幫助讀者分辨它們。在你的 BNF 範式用和命令語言本身完全一樣的標點符號，這樣讀者就永遠無法分清一段 (...), [...], {...} 或 "..." 到底是你在命令行裏真正輸入的，還是想提示在你的 BNF 範式裏哪個語法元素是必需的、可重複的、或可選的。不管怎麼樣，如果他們太笨，搞不清你的 BNF 範式的變化，就沒資格使用你的程序。 &nbsp;</p><h4>推出你自己的內存分配</h4><p>地球人兒都知道，調試動態存儲是複雜和費時的。與其逐個類去確認它沒有內存溢出，還不如自創一套存儲分配機制呢。其實它無非是從一大片內存中 malloc 一塊空間而已。用不着釋放內存，讓用户定期重啓動系統，這樣不就清除了堆麼。重啓之後系統需要追蹤的就那麼一點東西，比起解決所有的內存泄露簡單得不知道到哪裏去了！而且，只要用户記得定期重啓系統，他們也永遠不會遇到堆空間不足的問題。一旦系統被部署，你很難想象他們還能改變這個策略。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>其他雜七雜八的招</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>如果你給某人一段程序，你會讓他困惑一天；如果你教他們如何編程，你會讓他困惑一輩子。&nbsp;</em>-- Anonymous</p></blockquote><h4>不要重編譯</h4><p>讓我們從一條可能是有史以來最友好的技巧開始：把代碼編譯成可執行文件。如果它能用，就在源代碼裏做一兩個微小的改動 -- 每個模塊都照此辦理。<strong>但是不要費勁巴拉地再編譯一次了。</strong>&nbsp;你可以留着等以後有空而且需要調試的時候再説。多年以後，等可憐的維護代碼的程序員更改了代碼之後發現出錯了，他會有一種錯覺，覺得這些肯定是他自己最近修改的。這樣你就能讓他毫無頭緒地忙碌很長時間。</p><h4>挫敗調試工具</h4><p>對於試圖用行調試工具追蹤來看懂你的代碼的人，簡單的一招就能讓他狼狽不堪，那就是把每一行代碼都寫得很長。特別要把 then 語句，和 if 語句放在同一行裏。他們無法設置斷點。他們也無法分清在看的分支是哪個 if 裏的。</p><h4>公制和美製</h4><p>在工程方面有兩種編碼方式。一種是把所有輸入都轉換為公制（米制）計量單位，然後在輸出的時候自己換算回各種民用計量單位。另一種是從頭到尾都保持各種計量單位混合在一起。總是選擇第二種方式，這就是美國之道！ &nbsp;</p><h4>持續改進</h4><p>要持續不懈地改進。要常常對你的代碼做出「改進」，並強迫用户經常升級 -- 畢竟沒人願意用一個過時的版本嘛。即便他們覺得他們對現有的程序滿意了，想想看，如果他們看到你又「完善「了它，他們會多麼開心啊！不要告訴任何人版本之間的差別，除非你被逼無奈 -- 畢竟，為什麼要告訴他們本來永遠也不會注意到的一些 bug 呢？</p><h4>「關於」</h4><p>「關於」一欄應該只包含程序名、程序員姓名和一份用法律用語寫的版權聲明。理想情況下，它還應該鏈接到幾 MB 的代碼，產生有趣的動畫效果。但是，裏邊永遠不要包含程序用途的描述、它的版本號、或最新代碼修改日期、或獲取更新的網站地址、或作者的 email 地址等。這樣，所有的用户很快就會運行在不同的版本上，在安裝 N+1 版之前就試圖安裝 N+2 版。</p><h4>變更</h4><p>在兩個版本之間，你能做的變更自然是多多益善。你不會希望用户年復一年地面對同一套老的接口或用户界面，這樣會很無聊。最後，如果你能在用户不注意的情況下做出這些變更，那就更好了 -- 這會讓他們保持警惕，戒驕戒躁。</p><h4>無需技能</h4><p>寫無法維護代碼不需要多高的技能。喊破嗓子不如甩開膀子，不管三七二十一開始寫代碼就行了。記住，管理層還在按代碼行數考核生產率，即使以後這些代碼裏的大部分都得刪掉。</p><h4>只帶一把錘子</h4><p>一招鮮吃遍天，輕裝前進。如果你手頭只有一把錘子，那麼所有的問題都是釘子。</p><h4>規範體系</h4><p>有可能的話，忽略當前你的項目所用語言和環境中被普羅大眾所接受的編程規範。比如，編寫基於 MFC 的應用時，就堅持使用 STL 編碼風格。</p><h4>翻轉通常的 True False 慣例</h4><p>把常用的 true 和 false 的定義反過來用。這一招聽起來平淡無奇，但是往往收穫奇效。你可以先藏好下面的定義：</p><p>#define TRUE 0<br> #define FALSE 1</p><p>把這個定義深深地藏在代碼中某個沒人會再去看的文件裏不易被發現的地方，然後讓程序做下面這樣的比較</p><p>if ( var == TRUE )</p><p>if ( var != FALSE )</p><p>某些人肯定會迫不及待地跳出來「修正」這種明顯的冗餘，並且在其他地方照着常規去使用變量 var：</p><p>if ( var )</p><p>還有一招是為&nbsp;<span style="color:#000099"><span>TRUE</span></span>&nbsp;和&nbsp;<span style="color:#000099"><span>FALSE</span></span>賦予相同的值，雖然大部分人可能會看穿這種騙局。給它們分別賦值 1 和 2 或者 -1 和 0 是讓他們瞎忙乎的方式裏更精巧的，而且這樣做看起來也不失對他們的尊重。你在 Java 裏也可以用這一招，定義一個叫&nbsp;<span style="color:#000099"><span>TRUE</span></span>&nbsp;的靜態常量。在這種情況下，其他程序員更有可能懷疑你乾的不是好事，因為 Java 裏已經有了內建的標識符&nbsp;<span style="color:#000099"><span>true</span></span>。</p><h4>第三方庫</h4><p>在你的項目裏引入功能強大的第三方庫，然後不要用它們。潛規則就是這樣，雖然你對這些好的工具仍然一無所知，卻還是可以在你簡歷的「其他工具」一節中寫上這些沒用過的庫。</p><h4>不要用庫</h4><p>假裝不知道有些庫已經直接在你的開發工具中引入了。如果你用 VC++編程，忽略 MFC 或 STL 的存在，手工編寫所有字符串和數組的實現；這樣有助於保持你的指針技術，並自動阻止任何擴展代碼功能的企圖。</p><h4>創建一套 Build 順序</h4><p>把這套順序規則做得非常晦澀，讓維護者根本無法編譯任何他的修改代碼。秘密保留&nbsp;SmartJ&nbsp;，它會讓&nbsp;<span style="color:#000099"><span>make</span></span>腳本形同廢物。類似地，偷偷地定義一個&nbsp;<span style="color:#000099"><span>javac</span></span>&nbsp;類，讓它和編譯程序同名。説到大招，那就是編寫和維護一個定製的小程序，在程序裏找到需要編譯的文件，然後通過直接調用&nbsp;<span style="color:#000099"><span>sun.tools.javac.Main</span></span>&nbsp;編譯類來進行編譯。</p><h4>Make 的更多玩法</h4><p>用一個 makefile-generated-batch-file 批處理文件從多個目錄複製源文件，文件之間的覆蓋規則在文檔中是沒有的。這樣，無需任何炫酷的源代碼控制系統，就能實現代碼分支，並阻止你的後繼者弄清哪個版本的 DoUsefulWork() 才是他需要修改的那個。</p><h4>蒐集編碼規範</h4><p>儘可能蒐集所有關於編寫可維護代碼的建議，例如&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.squarebox.co.uk%2Fjavatips.html" target="_blank">SquareBox 的建議</a>&nbsp;，然後明目張膽地違反它們。</p><h4>規避公司的編碼規則</h4><p>某些公司有嚴格的規定，不允許使用數字標識符，你必須使用預先命名的常量。要挫敗這種規定背後的意圖太容易了。比如，一位聰明的 C++ 程序員是這麼寫的：</p><p>#define K_ONE 1<br> #define K_TWO 2<br> #define K_THOUSAND 999</p><h4>編譯器警告</h4><p>一定要保留一些編譯器警告。在 make 裏使用 「-」 前綴強制執行，忽視任何編譯器報告的錯誤。這樣，即使維護代碼的程序員不小心在你的源代碼裏造成了一個語法錯誤，make 工具還是會重新把整個包 build 一遍，甚至可能會成功！而任何程序員要是手工編譯你的代碼，看到屏幕上冒出一堆其實無關緊要的警告，他們肯定會覺得是自己搞壞了代碼。同樣，他們一定會感謝你讓他們有找錯的機會。學有餘力的同學可以做點手腳讓編譯器在打開編譯錯誤診斷工具時就沒法編譯你的程序。當然了，編譯器也許能做一些腳本邊界檢查，但是真正的程序員是不用這些特性的，所以你也不該用。既然你用自己的寶貴時間就能找到這些精巧的 bug，何必還多此一舉讓編譯器來檢查錯誤呢？</p><h4>把 bug 修復和升級混在一起</h4><p>永遠不要推出什麼「bug 修復"版本。一定要把 bug 修復和數據庫結構變更、複雜的用户界面修改，還有管理界面重寫等混在一起。那樣的話，升級就變成一件非常困難的事情，人們會慢慢習慣 bug 的存在並開始稱他們為特性。那些真心希望改變這些」特性「的人們就會有動力升級到新版本。這樣從長期來説可以節省你的維護工作量，並從你的客户那裏獲得更多收入。</p><h4>在你的產品發佈每個新版本的時候都改變文件結構</h4><p>沒錯，你的客户會要求向上兼容，那就去做吧。不過一定要確保向下是不兼容的。這樣可以阻止客户從新版本回退，再配合一套合理的 bug 修復規則（見上一條），就可以確保每次新版本發佈後，客户都會留在新版本。學有餘力的話，還可以想辦法讓舊版本壓根無法識別新版本產生的文件。那樣的話，老版本系統不但無法讀取新文件，甚至會否認這些文件是自己的應用系統產生的！温馨提示：PC 上的 Word 文字處理軟件就典型地精於此道。</p><h4>抵消 Bug</h4><p>不用費勁去代碼裏找 bug 的根源。只要在更高級的例程里加入一些抵銷它的代碼就行了。這是一種很棒的智力測驗，類似於玩 3D 棋，而且能讓將來的代碼維護者忙乎很長時間都想不明白問題到底出在哪裏：是產生數據的低層例程，還是莫名其妙改了一堆東西的高層代碼。這一招對天生需要多回合執行的編譯器也很好用。你可以在較早的回合完全避免修復問題，讓較晚的回合變得更加複雜。如果運氣好，你永遠都不用和編譯器前端打交道。學有餘力的話，在後端做點手腳，一旦前端產生的是正確的數據，就讓後端報錯。</p><h4>使用旋轉鎖</h4><p>不要用真正的同步原語，多種多樣的旋轉鎖更好 -- 反覆休眠然後測試一個 (non-volatile 的) 全局變量，直到它符合你的條件為止。相比系統對象，旋轉鎖使用簡便」，通用「性強」，靈活「多變，實為居家旅行必備。</p><h4>隨意安插 sync 代碼</h4><p>把某些系統同步原語安插到一些用不着它們的地方。本人曾經在一段不可能會有第二個線程的代碼中看到一個臨界區（critical section）代碼。本人當時就質問寫這段代碼的程序員，他居然理直氣壯地説這麼寫是為了表明這段代碼是很」關鍵「（也是 critical）的！</p><h4>優雅降級</h4><p>如果你的系統包含了一套 NT 設備驅動，就讓應用程序負責給驅動分配 I/O 緩衝區，然後在任何交易過程中對內存中的驅動加鎖，並在交易完成後釋放或解鎖。這樣一旦應用非正常終止，I/O 緩存又沒有被解鎖，NT 服務器就會當機。但是在客户現場不太可能會有人知道怎麼弄好設備驅動，所以他們就沒有選擇（只能請你去免費旅遊了）。</p><h4>定製腳本語言</h4><p>在你的 C/S 應用裏嵌入一個在運行時按字節編譯的腳本命令語言。</p><h4>依賴於編譯器的代碼</h4><p>如果你發現在你的編譯器或解釋器裏有個 bug，一定要確保這個 bug 的存在對於你的代碼正常工作是至關重要的。畢竟你又不會使用其他的編譯器，其他任何人也不允許！</p><h4>一個貨真價實的例子</h4><p>下面是一位大師編寫的真實例子。讓我們來瞻仰一下他在這樣短短几行 C 函數裏展示的高超技巧。</p><pre><code>void* Realocate(void*buf, int os, int ns)
{
    void*temp;
    temp = malloc(os);
    memcpy((void*)temp, (void*)buf, os);
    free(buf);
    buf = malloc(ns);
    memset(buf, 0, ns);
    memcpy((void*)buf, (void*)temp, ns);
    return buf;
}</code></pre><ul><li>重新發明瞭標準庫裏已有的簡單函數。</li><li><em>Realocate</em>&nbsp;這個單詞拼寫錯誤。所以説，永遠不要低估創造性拼寫的威力。</li><li>無緣無故地給輸入緩衝區產生一個臨時的副本。</li><li>無緣無故地造型。 memcpy() 裏有 (void*)，這樣即使我們的指針已經是 (void*) 了也要再造型一次。另外這樣可以傳遞任何東西作為參數，加 10 分。</li><li>永遠不必費力去釋放臨時內存空間。這樣會導致緩慢的內存泄露，一開始看不出來，要程序運行一段時間才行。</li><li>把用不着的東西也從緩衝區裏拷貝出來，以防萬一。這樣只會在 Unix 上產生 core dump，Windows 就不會。</li><li>很顯然，os 和 ns 的含義分別是」old size" 和 "new size"。</li><li>給 buf 分配內存之後，memset 初始化它為 0。不要使用 calloc()，因為某些人會重寫 ANSI 規範，這樣將來保不齊 calloc() 往 buf 裏填的就不是 0 了。（雖然我們複製過去的數據量和 buf 的大小是一樣的，不需要初始化，不過這也無所謂啦）</li></ul><h4>如何修復 "unused variable" 錯誤</h4><p>如果你的編譯器冒出了 "unused local variable" 警告，不要去掉那個變量。相反，要找個聰明的辦法把它用起來。我最喜歡的方法是：<br><span style="color:#000099"><span>i = i;</span></span></p><h4>大小很關鍵</h4><p>差點忘了説了，函數是越大越好。跳轉和 GOTO 語句越多越好。那樣的話，想做任何修改都需要分析很多場景。這會讓維護代碼的程序員陷入千頭萬緒之中。如果函數真的體型龐大的話，對於維護代碼的程序員就是哥斯拉怪獸了，它會在他搞清楚情況之前就殘酷無情地將他們踩翻在地。</p><h4>一張圖片頂 1000 句話，一個函數就是 1000 行</h4><p>把每個方法體寫的儘可能的長 -- 最好是你寫的任何方法或函數都沒有少於 1000 行代碼的，而且裏邊深度嵌套，這是必須的。</p><h4>少個文件</h4><p>一定要保證一個或多個關鍵文件是找不到的。利用 includes 裏邊再 includes 就能做到這一點。例如，在你的 main 模塊裏，你寫上：</p><p>#include &lt;stdcode.h&gt;</p><p>Stdcode.h 是有的。但是在 stdcode.h 裏，還有個引用：</p><p>#include "a:\\refcode.h"</p><p>然後，refcode.h 就沒地方能找到了。</p><p><span>到處可寫，無處可讀</span></p><p>至少要把一個變量弄成這樣：到處被設置，但是幾乎沒有哪裏用到它。不幸的是，現代編譯器通常會阻止你做相反的事：到處讀，沒處寫。不過你在 C 或 C++ 裏還是可以這樣做的。</p><blockquote><p><em><strong>原始博文發佈於：&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmindprod.com%2Funmain.html" target="_blank">Roedy Green's Mindproducts&nbsp;</a>。</strong></em></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 08:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269949/unmaintainable-new-defensive-programming</guid>
            <link>https://www.oschina.net/news/269949/unmaintainable-new-defensive-programming</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
