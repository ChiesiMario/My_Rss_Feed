<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-綜合資訊]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 16 Nov 2023 02:54:22 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[小米官宣 Xiaomi Vela 全面開源，底層內核為 NuttX]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米澎湃 OS 剛剛在微博<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F1786860821%2FNsNK2mfse%3Fpagetype%3Dprofilefeed" target="_blank">宣佈</a></u>，Xiaomi Vela 採用 Apache 2.0 License 面向全球軟硬件開發者正式開源。</p><p><img height="1352" src="https://static.oschina.net/uploads/space/2023/1116/102959_ekSh_2720166.png" width="2000" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2e4d78299513d8dd8e48dd44f9f1c80cbea.png" referrerpolicy="no-referrer"></p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fiot.mi.com%2Fvela" target="_blank">根據官網的介紹</a></u>，Xiaomi Vela 是小米基於開源實時操作系統<strong><u><a href="https://www.oschina.net/p/nuttx">NuttX</a></u></strong>打造的物聯網嵌入式軟件平台，Vela 在各種物聯網硬件平台上提供統一的軟件服務，支持豐富的組件和易用的框架，打通碎片化的物聯網應用場景。‘Vela’ 一詞源自拉丁語中船帆的含義，也是南方星空中最亮的星座之一。</p><p><strong>Xiaomi Vela 主要特性</strong></p><ul><li>高效性能：Vela 基於 NuttX 內核，具有高實時性、低功耗、低延遲等特點，適用於各種資源受限的嵌入式設備。</li><li>豐富組件：Vela 提供了多種常用的組件，如網絡、音頻、視頻、圖形、安全等，方便開發者快速構建應用。</li><li>易用框架：Vela 提供了一套統一的應用框架，支持 Lua、JavaScript 等腳本語言開發應用，並提供了豐富的 API 和文檔。</li><li>萬物互聯：Vela 支持多種通信協議和標準，如 WiFi、BLE、Zigbee、MQTT 等，並提供了小米妙享技術，實現設備之間的無縫連接和協同。</li></ul><p><strong>Xiaomi Vela 系統架構如下</strong></p><p><img src="https://oscimg.oschina.net/oscnet/up-9bc7edd16b77b3d0ef73407769d0dc0b404.png" referrerpolicy="no-referrer"></p><ul><li><strong>底層 NuttX 內核</strong>：提供最基本的任務調度、跨進程間通信、文件系統等基礎 OS 功能，同時也提供簡潔高效的設備驅動、輕量級的 TCP/IP 協議棧和電源管理等組件。</li><li><strong>應用框架</strong>：分為上下兩層，下層是為擴展系統服務而提供的通用應用框架，上層是針對不同的物聯網應用而開發的定製應用框架，例如多媒體應用框架和傳感應用框架，提供 Cloud SDK 可以方便開發者更快速的接入小米雲服務。</li><li><strong>開發者工具</strong>：除了常見的 Logger 和 Debugger 工具，Xiaomi Vela 還提供 Emulator 工具來幫助開發者提升調試效率，使用 Emulator，開發者可以利用 PC 端豐富的調試工具和調試信息，降低嵌入式系統開發和調試的難度。</li></ul><hr><p>延伸閲讀</p><ul><li><a href="https://www.oschina.net/news/263025" target="_blank">雷軍公佈小米澎湃 OS 完整系統架構，稱底層全部重構</a></li><li><a href="https://www.oschina.net/news/263645" target="_blank">小米澎湃 OS 正式發佈，Xiaomi Vela 將開源</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 02:33:31 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266688/xiaomi-vela-opensource</guid>
            <link>https://www.oschina.net/news/266688/xiaomi-vela-opensource</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Socket.D —— 基於語義消息流的網絡協議]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">Socket.D&nbsp;是一個基於連接的、可擴展的、消息驅動的傳輸協議。具有異步，自動分片，背壓流控，雙向通訊，多路複用，斷線重連，支持籤權，基於主題消息等特性。</p><ul><li>具有語言無關性的二進制通信協議（支持 tcp, ws, udp）</li><li>異步非阻塞消息驅動通信</li><li>可以進行流量控制、自動連接恢復</li><li>支持雙向通信（如：單鏈接雙向 RPC 接口調用）</li><li>更加適合分佈式通信場景</li><li>支持 ssl，支持國密 ssl</li><li>消息有由元信息和數據組成，通過元信息實現可擴展性</li><li>接口簡單</li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">開發時，主要交互只有 2 接口對象（更多可見：<a href="https://gitee.com/noear/socketd/blob/main/API.md">API.md</a><span>&nbsp;</span>）：</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#40485b; display:block; font-family:-apple-system,&quot;system-ui&quot;,&quot;Segoe UI&quot;,Helvetica,Arial,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;,&quot;Liberation Sans&quot;,&quot;PingFang SC&quot;,&quot;Microsoft YaHei&quot;,&quot;Hiragino Sans GB&quot;,&quot;Wenquanyi Micro Hei&quot;,&quot;WenQuanYi Zen Hei&quot;,&quot;ST Heiti&quot;,SimHei,SimSun,&quot;WenQuanYi Zen Hei Sharp&quot;,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:left; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:835px; word-break:initial; word-spacing:0px"><thead><tr><th>接口</th><th>描述</th><th>説明</th></tr></thead><tbody><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">listener</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">監聽器</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">（可雙向互聽）</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">會話</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">（可雙向互發）</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::send</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">發送</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::sendAndRequest</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">發送並請求</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">要求一次答覆</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::sendAndSubscribe</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">發送並訂閲</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答覆結束之前，不限答覆次數</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::reply</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答覆</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::replyEnd</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答覆結束</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr></tbody></table><h3 style="margin-left:0; margin-right:0; text-align:left">適用場景：</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">可用於 MSG、RPC、IM、MQ，等一些的場景開發，可替代 http, websocket, grpc 等一些協議。比如移動設備與服務器的連接，比如一些微服務場景等等。</p></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 02:22:55 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/socketd</guid>
            <link>https://www.oschina.net/p/socketd</link>
        </item>
        <item>
            <title>
                <![CDATA[ChatGPT 代碼解釋器存在巨大安全漏洞]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenAI 近日為 ChatGPT 推出了全新的代碼解釋器（Code Interpreter）工具，可以幫助程序員調試、完善代碼編程工作。該工具可以利用 AI 來編寫 Python 代碼，所編寫的代碼甚至可以在沙盒中運行。</p><p>不過根據 Johann Rehberger 網絡安全專家、Tom's Hardware 等多家國外媒體<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tomshardware.com%2Fnews%2Fchatgpt-code-interpreter-security-hole" target="_blank">報道</a></u>，由於該代碼解釋器工具可以處理任何電子表格文件，並能以圖表的形式分析和呈現數據，<strong>黑客可以欺騙 ChatGPT 聊天機器人，讓其執行來自第三方 URL 的指令</strong>。</p><p>Tom's Hardware 媒體復現了相關漏洞，創建虛假的環境變量文件，利用 ChatGPT 的功能處理此數據，然後將其發送到外部惡意站點。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1ca35470cf685c96d916ec4c8a97265c843.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-df3cfd0173073986a718e72cfaab32eb096.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-787cc41d51a67b812ef60dda6ed6532d570.png" referrerpolicy="no-referrer"></p><p>ChatGPT 可以響應 Linux 命令，可以訪問相關信息和文件，黑客通過這種方式，可以在用户沒有防備的情況下，訪問相關的敏感數據。</p><p>目前需要訂閲 ChatGPT Plus，才能訪問該代碼解釋工具，但這個漏洞引發了網絡安全專家的擔憂。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 02:21:55 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266683/chatgpt-code-interpreter-security-hole</guid>
            <link>https://www.oschina.net/news/266683/chatgpt-code-interpreter-security-hole</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 基於 Kotlin 的 AndroidX 仿微信圖片選擇器 MXImagePicker]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-imagepicker" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#imagepicker"></a>ImagePicker</h1><h2><a id="user-content-介紹" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E4%BB%8B%E7%BB%8D"></a>介紹</h2><h2><a id="user-content-基於 kotlinandroidx 的仿微信圖片選擇器" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E5%9F%BA%E4%BA%8Ekotlinandroidx%E7%9A%84%E4%BB%BF%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9%E5%99%A8"></a>基於 Kotlin，AndroidX 的仿微信圖片選擇器
<a href="https://gitee.com/link?target=https%3A%2F%2Fjitpack.io%2F%23com.gitee.zhangmengxiong%2FMXImagePicker"><img src="https://jitpack.io/v/com.gitee.zhangmengxiong/MXImagePicker.svg" alt="" referrerpolicy="no-referrer"></a></h2><p>Gradle 引用</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="n">implementation</span><span class="s1">'com.gitee.zhangmengxiong:MXImagePicker:1.6.3'</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p><img src="https://gitee.com/zhangmengxiong/MXImagePicker/raw/master/imgs/screenshot1.png" alt="Image text" referrerpolicy="no-referrer"><img src="https://gitee.com/zhangmengxiong/MXImagePicker/raw/master/imgs/screenshot2.png" alt="Image text" referrerpolicy="no-referrer"><img src="https://gitee.com/zhangmengxiong/MXImagePicker/raw/master/imgs/screenshot3.png" alt="Image text" referrerpolicy="no-referrer"></p><h2><a id="user-content-使用方法" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"></a>使用方法</h2><h4><a id="user-content-第一步項目增加 androidx 庫和 glide 圖片加載庫圖片縮放庫" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E7%AC%AC%E4%B8%80%E6%AD%A5%E9%A1%B9%E7%9B%AE%E5%A2%9E%E5%8A%A0androidx%E5%BA%93%E5%92%8Cglide%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE%E5%BA%93"></a>第一步：項目增加 Androidx 庫和 Glide 圖片加載庫、圖片縮放庫</h4><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="n">implementation</span><span class="s2">"androidx.appcompat:appcompat:x.x.x"</span></span><span id="LC2" class="line"><span class="n">implementation</span><span class="s2">"androidx.recyclerview:recyclerview:x.x.x"</span></span><span id="LC3" class="line"><span class="n">implementation</span><span class="s2">"com.github.bumptech.glide:glide:x.x.x"</span></span><span id="LC4" class="line"><span class="n">implementation</span><span class="s2">"androidx.constraintlayout:constraintlayout:2.0.4"</span></span><span id="LC5" class="line"><span class="n">implementation</span><span class="s2">"com.github.chrisbanes:PhotoView:2.3.0"</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-第二步使用前需要修改 androidmanifestxml 配置添加相冊存儲權限" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%BD%BF%E7%94%A8%E5%89%8D%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9androidmanifestxml%E9%85%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C%E5%AD%98%E5%82%A8%E6%9D%83%E9%99%90"></a>第二步：使用前需要修改‘AndroidManifest.xml’配置：添加相冊、存儲權限</h4><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 如果 Android 版本 &lt; 33 需要以下權限：</span></span><span id="LC2" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">CAMERA</span></span><span id="LC3" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">READ_EXTERNAL_STORAGE</span></span><span id="LC4" class="line"><span class="c1">// 如果 Android 版本 &gt;= 33 需要以下權限：</span></span><span id="LC5" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">CAMERA</span></span><span id="LC6" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">READ_MEDIA_IMAGES</span></span><span id="LC7" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">READ_MEDIA_VIDEO</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">// targetSdkVersion &gt;= 29 的應用需要在 application 節點添加以下屬性</span></span><span id="LC10" class="line"><span class="n">android</span><span class="p">:</span><span class="n">requestLegacyExternalStorage</span><span class="p">=</span><span class="s">"true"</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>注意：<code>沒有權限進入選擇頁面會報錯！</code></p><h4><a id="user-content-第三步啓動選擇頁面" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E7%AC%AC%E4%B8%89%E6%AD%A5%E5%90%AF%E5%8A%A8%E9%80%89%E6%8B%A9%E9%A1%B5%E9%9D%A2"></a>第三步：啓動選擇頁面</h4><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">val</span><span class="py">intent</span><span class="p">=</span><span class="nc">MXPickerBuilder</span><span class="p">().</span><span class="nf">setMaxSize</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nf">createIntent</span><span class="p">(</span><span class="k">this</span><span class="p">)</span></span><span id="LC2" class="line"><span class="nf">startActivityForResult</span><span class="p">(</span><span class="n">intent</span><span class="p">,</span><span class="mh">0x22</span><span class="p">)</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-預加載説明" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E9%A2%84%E5%8A%A0%E8%BD%BD%E8%AF%B4%E6%98%8E"></a>預加載説明</h5><p>預加載可以提前搜索本機圖片/視頻資源，減少首次進入選擇頁面時空白時間</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nc">MXImagePicker</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">application</span><span class="p">)</span></span><span id="LC2" class="line"><span class="nc">MXScanBiz</span><span class="p">.</span><span class="nf">scanAll</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="n">lifecycleScope</span><span class="p">)</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-mxpickerbuilder 參數説明" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#mxpickerbuilder%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"></a>MXPickerBuilder 參數説明</h5><ol><li><code>setMaxSize(size: Int)</code> 設置最大選擇文件個數</li><li><code>setType(type: PickerType)</code> 設置類型
<ul><li>PickerType.Image = 圖片</li><li>PickerType.Video = 視頻</li><li>PickerType.ImageAndVideo = 圖片 + 視頻，混合選擇</li></ul></li><li><code>setCameraEnable(enable: Boolean)</code> 設置是否啓動拍攝功能，默認=true</li><li><code>setMaxVideoLength(length: Int)</code> 當類型=Video 時，可以選擇視頻最大時長限制，單位：秒，默認=-1 無限制</li><li><code>setMaxListSize(size: Int)</code> 最長列表加載長度，防止圖片過多時產生 OOM -1=不限制，默認限制長度=1000 條</li></ol><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 在圖片選擇器 Activity 創建時會回調這個方法，一般會通過這個來改變導航欄、狀態欄的 Theme,demo 中搭配`ImmersionBar`來實現沉浸式效果</span></span><span id="LC2" class="line"><span class="nc">MXImagePicker</span><span class="p">.</span><span class="nf">registerActivityCallback</span><span class="p">{</span><span class="n">activity</span><span class="p">-&gt;</span></span><span id="LC3" class="line"><span class="nc">ImmersionBar</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="n">activity</span><span class="p">)</span></span><span id="LC4" class="line"><span class="p">.</span><span class="nf">autoDarkModeEnable</span><span class="p">(</span><span class="k">true</span><span class="p">)</span></span><span id="LC5" class="line"><span class="p">.</span><span class="nf">statusBarColorInt</span><span class="p">(</span><span class="n">activity</span><span class="p">.</span><span class="n">resources</span><span class="p">.</span><span class="nf">getColor</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">picker_color_background</span><span class="p">))</span></span><span id="LC6" class="line"><span class="p">.</span><span class="nf">fitsSystemWindows</span><span class="p">(</span><span class="k">true</span><span class="p">)</span></span><span id="LC7" class="line"><span class="p">.</span><span class="nf">navigationBarColor</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">picker_color_background</span><span class="p">)</span></span><span id="LC8" class="line"><span class="p">.</span><span class="nf">init</span><span class="p">()</span></span><span id="LC9" class="line"><span class="p">}</span></span><span id="LC10" class="line"></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-頁面顏色設置" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E9%A1%B5%E9%9D%A2%E9%A2%9C%E8%89%B2%E8%AE%BE%E7%BD%AE"></a>頁面顏色設置</h5><p>將下面顏色值放如主項目的資源 xml 中，可以修改頁面對應的顏色顯示</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c">&lt;!--  頁面背景色  --&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;color</span><span class="na">name=</span><span class="s">"mx_picker_color_background"</span><span class="nt">&gt;</span>#333333<span class="nt">&lt;/color&gt;</span></span><span id="LC3" class="line"></span><span id="LC4" class="line"><span class="c">&lt;!--  字體、icon 顏色  --&gt;</span></span><span id="LC5" class="line"><span class="nt">&lt;color</span><span class="na">name=</span><span class="s">"mx_picker_color_important"</span><span class="nt">&gt;</span>#F1F1F1<span class="nt">&lt;/color&gt;</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="c">&lt;!--  選中狀態顏色  --&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;color</span><span class="na">name=</span><span class="s">"mx_picker_color_select"</span><span class="nt">&gt;</span>#03CE65<span class="nt">&lt;/color&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-多語言設置" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E7%BD%AE"></a>多語言設置</h5><p>將下面字符串定義放入對應的語言目錄中，可以修改頁面對應的文字提示</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_select"</span><span class="nt">&gt;</span>選擇<span class="nt">&lt;/string&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_all"</span><span class="nt">&gt;</span>全部<span class="nt">&lt;/string&gt;</span></span><span id="LC3" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_image_limit_tip"</span><span class="nt">&gt;</span>您最多隻能選擇 %s 張圖片！<span class="nt">&lt;/string&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_video_limit_tip"</span><span class="nt">&gt;</span>您最多隻能選擇 %s 個視頻！<span class="nt">&lt;/string&gt;</span></span><span id="LC5" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_video_limit_length_tip"</span><span class="nt">&gt;</span>只能選擇 %s 秒以內的視頻<span class="nt">&lt;/string&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_need_permission_storage_camera"</span><span class="nt">&gt;</span>需要寫入存儲、相機權限<span class="nt">&lt;/string&gt;</span></span><span id="LC7" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_need_permission_storage"</span><span class="nt">&gt;</span>需要讀取存儲權限<span class="nt">&lt;/string&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_open_failed"</span><span class="nt">&gt;</span>打開失敗！<span class="nt">&lt;/string&gt;</span></span><span id="LC9" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_preview"</span><span class="nt">&gt;</span>預覽<span class="nt">&lt;/string&gt;</span></span><span id="LC10" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_not_compress"</span><span class="nt">&gt;</span>原圖<span class="nt">&lt;/string&gt;</span></span><span id="LC11" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_take_pic"</span><span class="nt">&gt;</span>拍攝圖片<span class="nt">&lt;/string&gt;</span></span><span id="LC12" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_take_video"</span><span class="nt">&gt;</span>拍攝視頻<span class="nt">&lt;/string&gt;</span></span><span id="LC13" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_show_list"</span><span class="nt">&gt;</span>圖片查看<span class="nt">&lt;/string&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>dimens.xml 資源</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c">&lt;!--  頂部導航欄高度  --&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;dimen</span><span class="na">name=</span><span class="s">"mx_picker_bar_height"</span><span class="nt">&gt;</span>50dp<span class="nt">&lt;/dimen&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-自定義圖片加載器默認使用 glide" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%99%A8%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8glide"></a>自定義圖片加載器（默認使用 Glide）</h5><p>通過繼承實現接口<code>IImageLoader</code> ,並註冊到服務<code>MXImagePicker</code>即可</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 數據對象</span></span><span id="LC2" class="line"><span class="kd">data class</span><span class="nc">MXItem</span><span class="p">(</span><span class="kd">val</span><span class="py">path</span><span class="p">:</span><span class="nc">String</span><span class="p">,</span><span class="kd">val</span><span class="py">time</span><span class="p">:</span><span class="nc">Long</span><span class="p">,</span><span class="kd">val</span><span class="py">type</span><span class="p">:</span><span class="nc">MXPickerType</span><span class="p">,</span><span class="kd">val</span><span class="py">duration</span><span class="p">:</span><span class="nc">Int</span><span class="p">=</span><span class="mi">0</span><span class="p">)</span></span><span id="LC3" class="line"></span><span id="LC4" class="line"><span class="c1">// 全局註冊加載器，可以卸載 Application 裏面，不影響啓動速度</span></span><span id="LC5" class="line"><span class="nc">MXImagePicker</span><span class="p">.</span><span class="nf">registerImageLoader</span><span class="p">{</span><span class="n">activity</span><span class="p">,</span><span class="n">item</span><span class="p">,</span><span class="n">imageView</span><span class="p">-&gt;</span></span><span id="LC6" class="line"><span class="k">if</span><span class="p">(</span><span class="nc">File</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">path</span><span class="p">).</span><span class="nf">exists</span><span class="p">())</span><span class="p">{</span></span><span id="LC7" class="line"><span class="nc">Glide</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="n">activity</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="nc">File</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">path</span><span class="p">))</span></span><span id="LC8" class="line"><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">mx_icon_picker_image_place_holder</span><span class="p">).</span><span class="nf">into</span><span class="p">(</span><span class="n">imageView</span><span class="p">)</span></span><span id="LC9" class="line"><span class="p">}</span><span class="k">else</span><span class="k">if</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">startsWith</span><span class="p">(</span><span class="s">"http"</span><span class="p">))</span><span class="p">{</span></span><span id="LC10" class="line"><span class="nc">Glide</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="n">activity</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">path</span><span class="p">)</span></span><span id="LC11" class="line"><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">mx_icon_picker_image_place_holder</span><span class="p">).</span><span class="nf">into</span><span class="p">(</span><span class="n">imageView</span><span class="p">)</span></span><span id="LC12" class="line"><span class="p">}</span><span class="k">else</span><span class="p">{</span></span><span id="LC13" class="line"><span class="nc">Glide</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="n">activity</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">uri</span><span class="p">)</span></span><span id="LC14" class="line"><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">mx_icon_picker_image_place_holder</span><span class="p">).</span><span class="nf">into</span><span class="p">(</span><span class="n">imageView</span><span class="p">)</span></span><span id="LC15" class="line"><span class="p">}</span></span><span id="LC16" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-第四步獲取返回結果" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E7%AC%AC%E5%9B%9B%E6%AD%A5%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"></a>第四步：獲取返回結果</h4><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">override</span><span class="k">fun</span><span class="nf">onActivityResult</span><span class="p">(</span><span class="n">requestCode</span><span class="p">:</span><span class="nc">Int</span><span class="p">,</span><span class="n">resultCode</span><span class="p">:</span><span class="nc">Int</span><span class="p">,</span><span class="n">data</span><span class="p">:</span><span class="nc">Intent</span><span class="p">?)</span><span class="p">{</span></span><span id="LC2" class="line"><span class="k">super</span><span class="p">.</span><span class="nf">onActivityResult</span><span class="p">(</span><span class="n">requestCode</span><span class="p">,</span><span class="n">resultCode</span><span class="p">,</span><span class="n">data</span><span class="p">)</span></span><span id="LC3" class="line"><span class="k">if</span><span class="p">(</span><span class="n">resultCode</span><span class="p">==</span><span class="nc">RESULT_OK</span><span class="p">&amp;&amp;</span><span class="n">requestCode</span><span class="p">==</span><span class="mh">0x22</span><span class="p">)</span><span class="p">{</span></span><span id="LC4" class="line"><span class="kd">val</span><span class="py">paths</span><span class="p">=</span><span class="nc">MXPickerBuilder</span><span class="p">.</span><span class="nf">getPickerResult</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">?:</span><span class="k">return</span><span class="c1">//返回 List&lt;String&gt;類型數據</span></span><span id="LC5" class="line"><span class="nf">println</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span></span><span id="LC6" class="line"><span class="p">}</span></span><span id="LC7" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-調取攝像頭單獨拍攝照片" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E8%B0%83%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4%E5%8D%95%E7%8B%AC%E6%8B%8D%E6%91%84%E7%85%A7%E7%89%87"></a>調取攝像頭單獨拍攝照片</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">val</span><span class="py">builder</span><span class="p">=</span><span class="nc">MXCaptureBuilder</span><span class="p">().</span><span class="nf">setType</span><span class="p">(</span><span class="nc">MXPickerType</span><span class="p">.</span><span class="nc">Image</span><span class="p">)</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="nf">startActivityForResult</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="nf">createIntent</span><span class="p">(</span><span class="k">this</span><span class="p">),</span><span class="mh">0x11</span><span class="p">)</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="c1">// 在 onActivityResult 獲取結果</span></span><span id="LC6" class="line"><span class="kd">val</span><span class="py">file</span><span class="p">=</span><span class="n">builder</span><span class="p">.</span><span class="nf">getCaptureFile</span><span class="p">()</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-調取攝像頭單獨拍攝視頻" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E8%B0%83%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4%E5%8D%95%E7%8B%AC%E6%8B%8D%E6%91%84%E8%A7%86%E9%A2%91"></a>調取攝像頭單獨拍攝視頻</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">val</span><span class="py">builder</span><span class="p">=</span><span class="nc">MXCaptureBuilder</span><span class="p">().</span><span class="nf">setType</span><span class="p">(</span><span class="nc">MXPickerType</span><span class="p">.</span><span class="nc">Video</span><span class="p">).</span><span class="nf">setMaxVideoLength</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span></span><span id="LC2" class="line"><span class="nf">startActivityForResult</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="nf">createIntent</span><span class="p">(</span><span class="k">this</span><span class="p">),</span><span class="mh">0x11</span><span class="p">)</span></span><span id="LC3" class="line"></span><span id="LC4" class="line"><span class="c1">// 在 onActivityResult 獲取結果</span></span><span id="LC5" class="line"><span class="kd">val</span><span class="py">file</span><span class="p">=</span><span class="n">builder</span><span class="p">.</span><span class="nf">getCaptureFile</span><span class="p">()</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-圖片查看器" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8"></a>圖片查看器</h3><p><img src="https://gitee.com/zhangmengxiong/MXImagePicker/raw/master/imgs/screenshot3.png" alt="Image text" referrerpolicy="no-referrer"></p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nc">MXImgShowActivity</span><span class="p">.</span><span class="k">open</span><span class="p">(</span></span><span id="LC2" class="line"><span class="k">this</span><span class="p">,</span><span class="nf">arrayListOf</span><span class="p">(</span></span><span id="LC3" class="line"><span class="s">"http://videos.jzvd.org/v/餃子主動.jpg"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="s">"http://videos.jzvd.org/v/餃子運動.jpg"</span></span><span id="LC5" class="line"><span class="p">),</span><span class="s">"圖片詳情"</span></span><span id="LC6" class="line"><span class="p">)</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-單張圖片壓縮" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E5%8D%95%E5%BC%A0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9"></a>單張圖片壓縮</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">val</span><span class="py">file</span><span class="p">=</span><span class="nc">File</span><span class="p">(</span><span class="s">".../xx.png"</span><span class="p">)</span></span><span id="LC2" class="line"><span class="kd">val</span><span class="py">scaleImg</span><span class="p">=</span><span class="nc">MXImageCompress</span><span class="p">.</span><span class="nf">from</span><span class="p">(</span><span class="n">context</span><span class="p">)</span></span><span id="LC3" class="line"><span class="p">.</span><span class="nf">setCacheDir</span><span class="p">(</span><span class="n">applicationContext</span><span class="p">.</span><span class="n">cacheDir</span><span class="p">)</span><span class="c1">// 緩存目錄</span></span><span id="LC4" class="line"><span class="p">.</span><span class="nf">setSupportAlpha</span><span class="p">(</span><span class="k">true</span><span class="p">)</span><span class="c1">// 支持透明通道 (’.png‘格式) 默認=’.jpg‘格式</span></span><span id="LC5" class="line"><span class="p">.</span><span class="nf">setTargetFileSize</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="c1">// 設置壓縮文件大小目標值，單位：Kb 默認=0 自然壓縮</span></span><span id="LC6" class="line"><span class="p">.</span><span class="nf">setTargetPixel</span><span class="p">(</span><span class="mi">2400</span><span class="p">)</span><span class="c1">// 設置壓縮文件寬或高目標值，單位：像素</span></span><span id="LC7" class="line"><span class="p">.</span><span class="nf">compress</span><span class="p">(</span><span class="n">file</span><span class="p">)</span></span><span id="LC8" class="line"></span></pre><div class="markdown-code-block-copy-btn"></div></div></div>]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 02:20:14 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/zhangmengxiong/MXImagePicker</guid>
            <link>https://gitee.com/zhangmengxiong/MXImagePicker</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 百度搜索智能化算力調控分配方法]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img src="https://oscimg.oschina.net/oscnet/up-24c7ae180da549d2d3ab12f4b6a9d4899ff.png" alt="" referrerpolicy="no-referrer"></p><p>作者 | 泰來</p><blockquote><p>導讀</p><p>隨着近年深度學習技術的發展，搜索算法複雜度不斷上升，算力供給需求出現了爆發式的增長。伴隨着 AI 技術逐步走到深水區，算法紅利在逐步消失，邊際效應日益顯著，算力效能的提升尤為重要，同時隨着宏觀經濟影響，大規模的算力需求供給也遭遇到了瓶頸。同時隨着流量、時間或系統故障時帶來的容量變化，總算力約束也在時刻改變，週期性的出現波峯、波谷，以及會因為流量突增、網絡抖動等原因導致系統出現穩定性問題。</p><p>在此背景下，需要一種更加智能化、個性化的算力調控分配方法，不斷提高系統的自適應性，使得在給定資源上限的情況下，最大化資源投入的性價，同時在故障時刻發生時自適應的調整算力分配，降低系統負載。</p></blockquote><blockquote><p><em>全文 4328 字，預計閲讀時間 11 分鐘。</em></p></blockquote><h1><strong>01 問題與挑戰</strong></h1><p>互聯網行業十餘年的蓬勃發展及硬件性能的持續攀升，使得 Ranking 相關算法進入到了深度學習時代，模型、技術創新層出不窮。但隨着技術逐步進入到深水區，在同樣的算力需求下對效果的增長邊際已經非常明顯。</p><p>同時伴隨當前宏觀經濟影響，大規模算力的需求供給也持續遭遇瓶頸，如何在有限的算力資源內不斷創造出更大的效果價值是一項非常有挑戰性的工作。</p><p><img src="https://oscimg.oschina.net/oscnet/up-630522985830d91e7f1357f55777b530f87.png" alt="圖片" referrerpolicy="no-referrer"></p><p>為此我們不斷探索根據流量價值及系統狀態自適應的進行算力分配，使得總體投入產出比不斷提升。</p><p><img src="https://oscimg.oschina.net/oscnet/up-a64376c135fecc2ffcb80b1ecc848497a0b.png" alt="圖片" referrerpolicy="no-referrer"></p><h1><strong>02 整體思路</strong></h1><p>目前搜索系統流轉過程中調控手段彼此相互之間是獨立的，調控的算子的輸入輸出沒有全局視角，調控算子彼此割裂、聯動和管理是比較困難的，且調控手段大多基於靜態閾值配置。但我們認為系統中請求經過每層的調控算子是有狀態的，理想的級聯繫統中每種調控算子應該是全局可見的，需要從全局的視角更好的審視業務系統，站在更高的維度去看算力調控分配這項工作。</p><p>我們在微觀和宏觀兩方案開展了相關調控工作：</p><p><strong>1.微觀</strong>：忽略系統容量狀態，在當前時刻下根據流量產生的價值來動態的分配算力，使得在給定算力總約束下獲得全局最優。</p><p><img src="https://oscimg.oschina.net/oscnet/up-98985f8b2a15f8558c83df58a4ebe18715d.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong>2.宏觀</strong>：隨着流量、時間或系統故障時帶來的容量變化，總算力約束在不斷改變，需要在給定的資源及響應時間限制下，計算出在當前限制條件下的最優分配方式。動態的調整系統核心階段的計算強度，合理調控峯值算力。並基於搜索系統的實時狀態反饋，自動的調節系統的安全狀態。使搜索系統能夠在速度、資源、效果、穩定性等多個維度上進行自適應的調控。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1e6e541b843bafcd142fbd5bd3d69ef3dba.png" alt="圖片" referrerpolicy="no-referrer"></p><h2><strong>2.1 問題建模</strong></h2><p><strong>變量説明：</strong></p><p>第 i 條流量\(r_i\)。</p><p>流量 i 在階段 j 的具體信息，例如隊列長度，模型選型等，可以用表示，其中的 alpha beta gamma 都可以根據經驗進行設定並用實驗來驗證。</p><p>\(Q_(i,j) = [α*queue_length, β*cpu_usage, γ*gpu_uasage]\)</p><p>流量在第 j 階段的折扣因子\(Y_i\)。</p><p>第 i 條流量的價值\(O_i=Y(r_i,Q_(i,1),Q_(i,2),…,Q_(i,N) )\)</p><p><img src="https://oscimg.oschina.net/oscnet/up-7c9ce2b9226f138fc1dd8bbc65e9ea1234b.png" alt="圖片" referrerpolicy="no-referrer"></p><p>目標：通過調控流量在各個階段的信息例如隊列長度、模型選型等，從而調節折扣因子，最終實現流量價值最大化，假設 M 條流量經過 N 個階段表達如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-de28539ee4bac5fbd6df6f7e3f1317cb2fd.png" alt="圖片" referrerpolicy="no-referrer"></p><p>C1 成本約束，對於任意一個階段，都必須小於等於其成本；</p><p>C2 時間約束，對於任意一個請求流量，在 N 個階段的耗時綜合都必須小於等於規定的耗時；</p><p>C3 輔助約束，對於任意一個請求任意一個階段都必須有大於等於 0 的值。</p><p>對於一個實時的搜索系統來説，在線進行上述的優化並不太實際也會帶來比較多的困難。為了簡化分析和提高系統的魯棒性，我們將上述 N 個階段拆封成 N 個子問題，這樣方便對各個階段進行監控和可靠的幹預，提高系統的魯棒性，例如當系統出現巨大的變化時，可以隨時動態調整各個階段的參數。簡化問題求解，將 C1、C2 約束進行一定的拆分。</p><p><img src="https://oscimg.oschina.net/oscnet/up-f6430b5dc5daf55c8c881024c8212a8e1b4.png" alt="圖片" referrerpolicy="no-referrer"></p><p>具體來説，對於階段 j，流量的價值最大化，我們可以看作是上述的一個子問題。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6946e0b198d88545b3f7e182609a5ae6124.png" alt="圖片" referrerpolicy="no-referrer"></p><p>假設\(Y_j （r_i,Q_(i,j)）\) 是單調遞增的，但其對\(Q_(i,j)\) 的導數是單調遞減的，也就是其價值會隨着配置資源的增加而越來越緩慢的增加。</p><h2><strong>2.2 示例説明</strong></h2><p><strong>示例：用相關性精排階段的彈性候選集進行舉例</strong></p><p>假設將流量 i 細化成第 i 條 Query，j 階段則為具體篩選階段，增加一個維度 k 表示 URL 級別的參數和特徵信息。在正排候選集篩選階段 k 信息表示為多個特徵的分數信息，authority_feature【權威性特徵】、click_feature【點擊特徵】...correlation_feature【相關性特徵】。</p><p>則在正排候選集篩選階段請求 i 的第 k 條 url 的信息可以表示為：</p><p><img src="https://oscimg.oschina.net/oscnet/up-0d31f093be129945380d88fc27f864dce80.png" alt="圖片" referrerpolicy="no-referrer"></p><p>流量 i 在彈性候選集下的折扣因子，可以看作是 1 - 刪掉 URL 數量在原本可出現在最終排序的 Top40 的概率，假如候選集合中完全沒有刪除的 URL 則無折扣損失，若是候選集合中刪除了 URL，但對最終 Top40 的召回無影響，也可以看作是對總價值無折扣影響。</p><p><img src="https://oscimg.oschina.net/oscnet/up-c740c592761c36f2c38a784c92ba5018ff8.png" alt="圖片" referrerpolicy="no-referrer"></p><p>具體來説，針對第 i 條 query 的 k 條 url 的具體信息，我們採用多個維度的特徵進行考量。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1d1ec5ab10bfc446a85c856a1d408835f4c.png" alt="圖片" referrerpolicy="no-referrer"></p><p>其中</p><p><img src="https://oscimg.oschina.net/oscnet/up-c45ba9cae44e13b3fb3f8f399a3e20c6626.png" alt="圖片" referrerpolicy="no-referrer"></p><p>如果是 0 表示丟棄，1 表示留下第 k 條 url，希臘字母表示的是採取的閾值標準，例如評分位於後 x%。如果一個 url 的所有特徵貢獻度排名都處於分佈的末尾，則會將該 url 從候選集中剔除。</p><p><img src="https://oscimg.oschina.net/oscnet/up-50089654880969967f46124956cfddd37f6.png" alt="圖片" referrerpolicy="no-referrer"></p><h1><strong>03 關鍵技術</strong></h1><p>過去傳統的調控方式下，既不知道上游階段做過哪些調控動作，也不知道在自己的階段上做的調控動作，下游是如何反饋的，只能追求自己的局部最優。而我們認為在搜索這種分層的級聯繫統下，越往下流轉看到的特徵和信號越多，調控動作應該隨着流轉過程發生狀態轉變，不應該是靜態的。我們創新的採用彈性級聯調控框架將調控手段進行組合，追求全局的最優解，從全鏈路上提升算力投入產出的性價比。</p><p><img src="https://oscimg.oschina.net/oscnet/up-58fe63995a5a07653dc25586db731a312e6.png" alt="圖片" referrerpolicy="no-referrer"></p><p>具體做法，我們構建的彈性級聯框架包含四個部分：</p><p><strong>1、調控算子集合</strong>，將調控動作按照 Query 級別、URL 級別、Feature 級別進行劃分，調控算子擁有相同基類，接口規範統一；</p><p><strong>2、計算中心</strong>，負責實時計算各種調控動作所需的各類信號、以及流量價值的判斷、容量信號的獲取等；</p><p><strong>3、參數集合</strong>，經過計算中心產出的特徵和信號，固化超參數，使得模塊內超參數全局可見，跨模塊之間按照規定協議統一進行交互；</p><p><strong>4、調控決策器</strong>，主要負責根據參數集合，確定各個階段的調控檔位設置並調用算子集合裏的算子進行執行，每個調控階段包含控制流（Control Level）和反饋流（FeedbackLevel），控制流能結合當前階段看到的特徵和信號給出它下游其他階段的調控檔位，反饋流是當前階段參考其他階段給出的調控檔位建議和當前階段看到的特徵和信號確定實際執行的調控檔位。通過這種方式，每個調控階段既能看到到其他階段實際執行的調控狀態，同時也能根據它們對當前階段的指導建議進行綜合判斷，最終在全鏈路上獲取全局最優解。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3d45fec8e8b0e24a58b2e608cce248a3628.png" alt="圖片" referrerpolicy="no-referrer"></p><p>如上圖左側可以看到整個彈性級聯框架的組成部分，右側是舉例正排階段的彈性候選集的實際計算過程，將各種維度的特徵通過計算中心生成價值參數，用於調控決策器進行決策，然後給出實際的正排計算集合。我們不僅建立控制反饋流級聯自適應調控系統，而且還提供了一個全局視角的彈性算力分配控制中心。彈性算力系統主要通過對集羣各種維度指標的獲取、策略分析及週期性執行最適合當前機器負載狀態的策略組合參數來實現其核心彈性算力分配決策。</p><p>根據當前搜索系統，當前智能彈性調參把系統定義和描述為下面 4 種狀態：系統異常狀態，負載峯值狀態，彈性過渡狀態，負載低谷狀態，根據不同的系統狀態，執行當前狀態的策略集合，從而使資源使用率及業務收益效果最優。具體方案見下圖：</p><p><img src="https://oscimg.oschina.net/oscnet/up-34531ef341d0092f4c8826b061a4c72cb68.png" alt="圖片" referrerpolicy="no-referrer"></p><p>主要包含流程如下：</p><p><strong>信息採集</strong>：自動化的週期性採集業務日誌（流量 pv，流量分類，流量質量）和機器狀態（CPU/MEM 使用率）等信息。對於這些信息進行深入挖掘分析，主要從以下幾個時間維度進行採集：</p><p>1、峯值時間段模塊狀態信號；</p><p>2、前 n 個採集週期模塊狀態信號；</p><p>3、前一天同時刻前 n 個採集週期模塊狀態信號；</p><p>4、前一週同時刻前 n 個採集週期模塊狀態信號。</p><p>系統狀態預估:&nbsp;對各種維度信息採集，之後通過人工規則，在線策略，離線預估等手段評估系統當前狀態，把目前系統劃分為系統異常狀態，系統負載峯值狀態，系統負載低谷狀態，系統負載過渡狀態。下面是系統狀態定義規則，及狀態轉移圖：</p><p><strong>系統異常狀態</strong>：系統發生故障，例如系統可用性 SLA，CPU 負載率，結果空值率等不符合預期。</p><p><strong>系統負載峯值狀態</strong>：系統請求數，CPU 負載率等系統容量指標大於指定閾值。</p><p><strong>系統負載低谷狀態</strong>：系統請求數，CPU 負載率等系統容量指標小於指定閾值。</p><p><strong>系統負載過渡狀態</strong>：負載峯值和低谷之間的過渡狀態。</p><p><img src="https://oscimg.oschina.net/oscnet/up-8a94ecc0c3d4bfc093470cc02d2f1a4dff4.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong>檔位判斷</strong>：根據系統狀態抽象成便於系統決策的系統檔位，及每個檔位內需要關注的系統問題。</p><p><strong>1、異常檔位</strong>：如何快速服務降級，保證保證系統質量。</p><p><strong>2、峯值檔位</strong>：需要關注系統的穩定性和響應時間，以確保系統在高負載下依然能夠穩定運行。</p><p><strong>3、低谷檔位</strong>：可以考慮優化系統資源的分配，提升資源的投入產出比。在探測到系統出現異常故障狀態時。</p><p><strong>4、過渡檔位</strong>：一種中間狀態，它的主要作用是在系統從低負載狀態過渡到高負載狀態，或從高負載狀態過渡到低負載狀態時，提供一個緩衝階段，以避免系統狀態的突然跳變。過渡檔位不進行策略的調整，而是保持系統在一個相對穩定的狀態。這樣做的目的是為了避免頻繁的策略調整帶來的系統震動，保證系統的穩定性。</p><p><strong>方案決策執行：</strong></p><p>降級檔位主要應對系統異常或重大風險，其對應的策略包括關閉被動觸發流量，以及降低召回集合，降低複雜模型計算等策，通過這種方式降低系統的負載，保證核心業務的正常運行。低谷檔位對應的是彈性策略集，這些策略主要目的是在低谷期加強複雜策略的計算，提升搜索效果。而在峯值檔位，我們主要採用削峯策略，包括減少被動觸發流量，以確保系統在高負載下依然能夠穩定運行。</p><p><strong>示例：視頻搜索彈性擴觸發：</strong></p><p>在系統資源容量低谷階段，根據指標採集數據計算當前系統容量資源冗餘情況，基於冗餘資源進行擴觸發比例計算，通過彈性算力決策模塊下發觸發信號，利用閒時資源擴大流量的觸發面。</p><h1><strong>04 總結與展望</strong></h1><p>通過基於彈性級聯框架的調控方式，提升了分層系統的效益比，對於每個用户請求實施精細化、差異化的調控組合，在算力效能提升上取得了不錯的成績。</p><p>算力分配是架構研究的核心問題之一，未來會在以下兩個方面持續開展系統性工作：</p><p>1、結合 AI 大模型的推理能力在調控組合上可以做到更加精細化，在算力效能的提升上會帶來更大的挖掘空間；</p><p>2、通過自適應的宏觀調控給系統穩定性帶來了柔性降級能力，後續會在這個方向上持續深耕，不斷提升系統自動化的處置能力。</p><p>——END——</p><p><strong>推薦閲讀</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247573568%26idx%3D1%26sn%3D393c3af07b86b342aba082cb42ae6594%26chksm%3Dc03f903cf748192a906d259791b7a49b4a34742a656379482051df9c8c0411af15290af1b2b6%26scene%3D21%23wechat_redirect" target="_blank">UBC SDK 日誌級別重複率優化實踐</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247573374%26idx%3D1%26sn%3D9d9d6dd9fa1476416facc30344724b0f%26chksm%3Dc03fef02f7486614370c5f861cf8139e7f37c35e856eda45b4cf1c7269ae82fbe315e1750254%26scene%3D21%23wechat_redirect" target="_blank">百度搜索深度學習模型業務及優化實踐</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247573218%26idx%3D1%26sn%3De5082b7c4b4c14ed9365c18ac74bc8b2%26chksm%3Dc03fee9ef7486788a9ddac5e35cd9c4e1c7bd001b533ca57b9835af04560f09a0ae95ef058c7%26scene%3D21%23wechat_redirect" target="_blank">文生圖大型實踐：揭秘百度搜索 AIGC 繪畫工具的背後故事！</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247572968%26idx%3D1%26sn%3D6895f4d29410e3a2fc2a9884df0a078a%26chksm%3Dc03fed94f7486482f93bbdbce036341e82f50a4822eb3d91ffbd76ca018d47fe35a9f77bdd99%26scene%3D21%23wechat_redirect" target="_blank">大模型在代碼缺陷檢測領域的應用實踐</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247572835%26idx%3D1%26sn%3D7d08b04901206d41bf39c8b07087b391%26chksm%3Dc03fed1ff74864095e11f2f4eb75b15c4abbef06649c719201f782f1f3a653cd22e9fd7f5dac%26scene%3D21%23wechat_redirect" target="_blank">通過 Python 腳本支持 OC 代碼重構實踐（二）：數據項提供模塊接入數據通路的代碼生成</a></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 02:16:55 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/10143329</guid>
            <link>https://my.oschina.net/u/4939618/blog/10143329</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[李彥宏：百度目前 20% 代碼由 AI 完成]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#222222">11 月 15 日，李彥宏在深圳舉行的西麗湖論壇上表示，</span><span style="background-color:#ffffff; color:#3b3b3b">百度已經對旗下各產品線進行了 AI 原生化重構，</span><span style="background-color:#ffffff; color:#222222">百度每 100 行代碼，20 行就由 AI 完成。</span></p><p><span style="background-color:#ffffff; color:#222222">他表示，大模型是基礎底座，類似操作系統不會太多，重複開發大模型是對基礎資源的浪費。文心一言有了很大進步，其調用量比國內其他兩百家還多。</span></p><p><span style="background-color:#ffffff; color:#222222">目前，文心一言已有 800 萬開發者，開發者可以通過插件調用文心一言。</span></p><p><img height="304" src="https://static.oschina.net/uploads/space/2023/1115/111350_ZpLo_4252687.png" width="700" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 03:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266536</guid>
            <link>https://www.oschina.net/news/266536</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[「零一萬物」 迴應 Yi 開源大模型「套殼」 Llama]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>李開復旗下 AI 公司<span style="background-color:#ffffff; color:#333333">「</span>零一萬物<span style="background-color:#ffffff; color:#333333">」&nbsp;</span>(<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2F01.AI" target="_blank">01.AI</a>)&nbsp;<span style="background-color:#ffffff; color:#333333">上週</span><u><a href="https://www.oschina.net/news/265142/01-ai-valued-at-1b-open-source-yi-llm" target="_blank">宣佈</a></u><strong>推出&nbsp;Yi-34B 和&nbsp;Yi-6B 兩個開源大模型。</strong>其公佈的基準測試結果顯示雖然模型參數少於其它大模型，但性能更出色。零一萬物的估值高達 10 億美元，已躋身獨角獸行列。</p><p>Yi 正式開源數日後，在其<span style="background-color:#ffffff; color:#333333"><span>&nbsp;</span>Hugging Face 主頁的討論區中，有人指出&nbsp;</span>Yi-34B 完全使用了 Meta 開源大模型 Llama 的架構，最明顯的變化只是修改了張量 (Tensor) 名稱。</p><p><img alt="111349_Novu_2720166.png" src="https://static.oschina.net/uploads/space/2023/1114/111349_Novu_2720166.png" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#333333">來源：</span><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11" target="_blank">https://huggingface.co/01-ai/Yi-34B/discussions/11</a></u></em></p><p>根據公開的信息，Yi 系列開源大模型沒有在開源 License 中提及 Llama。上面的帖子內容經過廣泛傳播後，零一萬物的 Yi 系列大模型被質疑是 Llama 的套殼。</p><p>昨天，「零一萬物」 正式公開回應了此事。根據該公司開源團隊總監<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">&nbsp;</a></u><span style="background-color:#ffffff"><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">Richard Lin 的跟帖回覆</a></u>，他們承認了修改 Llama 張量名稱的做法不妥，並會按照建議進行修改。</span></p><p>Richard Lin 稱此問題是團隊的疏忽。因為在大量的訓練實驗中，<strong>他們對代碼進行了多次重命名，以滿足實驗要求</strong>。但最後沒有在發佈之前將它們改回來。他為這個失誤造成的混亂表示抱歉。</p><p><span style="background-color:#ffffff">與此同時，Richard Lin 邀請這名指出問題的開發者提交包含上述改動的 PR——對 Yi 的張量名稱進行重命名以符合 Llama 架構。</span></p><p><img src="https://oscimg.oschina.net/oscnet/up-5607cfe7fee8c2aaf087104396bd1d3d785.png" referrerpolicy="no-referrer"></p><p>最後，<span style="background-color:#ffffff">Richard Lin&nbsp;</span>表示團隊會增強對流程的執行，避免此類錯誤再次發生，他們也將再次檢查所有代碼，確保其他一切正常。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266525</guid>
            <link>https://www.oschina.net/news/266525</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 3D 裸眼風扇屏]]>
            </title>
            <description>
                <![CDATA[<p>項目説明</p><p>本項目是製作一個 3D 裸眼風扇廣告機，它是一款裸眼 D 的新型產品，採用晶片、磁鐵、發光二極管 (LED) 技能及螺旋槳葉片組合而成,葉片在驅動下隨之動彈，繼而顯現出 D 浮空影像。同時還設計了喇叭，可以實現播放視頻、聽音樂功能</p><p>視頻介紹：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1tN411y7ZS%2F">https://www.bilibili.com/video/BV1tN411y7ZS/</a></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/EE64VlOi1zKg5iufuLVZ46TzYQD5CyY1EIlaoftN.png" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p>開源協議</p><p>依據 GPL 3.0 開源協議，可以複製、修改和傳播，並且不限制商業使用。</p><p>項目相關功能</p><p>1.圖片顯示，160x160 的分辨率，上傳 jpeg 圖片格式，可以顯示多張圖片</p><p>2.視頻播放，不能直接播放 MP4 文件，需要單獨解碼後才能播放</p><p>3.音樂播放，可以播放音樂 wav 文件。</p><p>4.雲端控制，使用手機 APP 進行控制。包括上傳圖片，開啓/停止功能，按鈕選擇功能</p><p>項目屬性</p><p>本項目為首次公開，為本人原創項目。項目未曾在別的比賽中獲獎。</p><p>項目進度</p><p>2023 年 2 月 14 日，開始設計</p><p>2023 年 3 月 30 日，完成第一版設計，40x40 分辨率</p><p>2023 年 4 月 4 日，開始設計第二版本提高清晰度，160x160 分辨率</p><p>2023 年 4 月 15 日，開始編寫 ESP32 程序，調試電機驅動，LED 顯示，音樂播放功能。</p><p>2023 年 5 月 10 日，開始編寫手機 APP，實現聯網遠程控制。</p><p>設計原理</p><p>電路部分</p><p>主控芯片選擇 ESP32S3，帶有 WiFi 功能，可以實現雲端控制。ESP32S3 作為一個雙核 240MHZ 處理器，有足夠的性能解碼 JPEG 圖片，mp3 音樂文件。</p><p>電機驅動採用 TMC2209 芯片來驅動一個 28 步進電機，低速時可以靜音驅動，帶來很好的體驗，不會影響音樂播放帶來噪音。</p><p>LED 燈採用 WS2812 幻彩燈珠，1615 的小體積封裝提高分辨率</p><p>音頻驅動採用 MAX98357 芯片，可以驅動一個 3W 的小喇叭。</p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/CFYaQ1z8zbUII5cQohjbOsVbOxdZFypDSe3vojc9.png" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/RHMgoiHGHXX0bkLdOpdoSmeQOL4TWiKnvqgOOZ2d.png" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p>外殼部分</p><p>使用 FreeCAD 軟件進行外殼設計。在本次結構設計中有一個難點就是如何給電路板供電，採用電池供電但是續航不久，於是不採用。使用外置電源不用考慮續航問題，但繞線是個問題。於是設計了一個採用軸承導電的機構。其他零件使用 3D 打印出來。</p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/1tbNw9FV6ZrYcSQyd77pQUfiaCVZzsD01rQS1G1d.png" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p>軟件説明</p><p>ESP32 主控</p><p>ESP32 主控主要是編寫 LED 驅動程序，JPEG 圖片解碼程序，wav 音樂解碼播放，已及通 MQTT 訂閲來接收雲端數據，實現遠程控制。如下是一些主要代碼</p><p>手機 APP</p><p>手機 App 是使用前端 html 和 JavaScript 寫的一個網頁，然後對網頁打包成安卓應用。實現的功能主要有上傳圖片，控制 esp32 的各種功能。部分程序如下</p><p>此外為了實現流暢播放視頻，我單獨使用 python 腳本對視頻進行了解碼。</p><p>實物展示</p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/BDFCIOQkqrGEZcxuzO4QxZbk8wA5NyMuNJfNLNzm.jpeg" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/JH1S503sxnVDZRkepAYyLV9BkgoL1VhoYjJtwW90.jpeg" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/YWbrYCHZBPEeR5dIZoKDOrNhZc62yBtoJYfjzUgY.jpeg" alt="輸入圖片説明" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>其他</p><p>視頻講解稍後上傳</p>]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/qzr123/3-d-bare-eye-fan-screen</guid>
            <link>https://gitee.com/qzr123/3-d-bare-eye-fan-screen</link>
        </item>
        <item>
            <title>
                <![CDATA[向開源作者提問「項目還活着嗎」非常粗魯且無禮]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>最近幾個月，開源 AI 項目的創始人 Max Woolf 經歷了一場關於自己的工作的 「存在危機」。</p><p>他表示自己對 AI 的負面抵制情緒日益強烈，以及 AI 行業進展神速，Max 發現自己無法跟上進度，陷入了對開源工作的質疑。在此期間，他暫停了 GitHub 上自己開源項目的開發，其中包括 ChatGPT 的 Python 接口 simpleaichat。</p><p><img src="https://static.oschina.net/uploads/space/2023/1115/190841_hkBi_2720166.png" referrerpolicy="no-referrer"></p><p><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fminimaxir%2Fsimpleaichat" target="_blank">https://github.com/minimaxir/simpleaichat</a></u></em></p><p>簡單來説，Max 壓力太大，需要休息一段時間。按理來説，他的代碼不應該有問題，因為項目本身設計就考慮到了他可能暫停開發的情況。</p><p>然而當 Max 想重操舊業時，卻在自己項目的 GitHub 上收到了質疑開發是否已經停止的問題。儘管沒有任何證據表明代碼出問題，但項目 Stars 數高達 3k 的 simpleaichat 還是收到了 「這個項目被放棄了嗎」 的問題。</p><p><img height="302" src="https://static.oschina.net/uploads/space/2023/1115/190713_TFZG_2720166.png" width="1454" referrerpolicy="no-referrer"></p><p>這讓 Max 感到既震驚又氣憤。他認為，這種質疑開發者的行為是在施加不必要的壓力，也顯得無禮。</p><p>事實上，開源項目從來沒有 「必須持續開發」 的硬性規定。大多數開源許可協議都明確寫明軟件 「按原樣」 提供，不承諾後續維護。但部分社區成員似乎默認開源項目有更新的義務，這讓 Max 和其他開源開發者感到困擾。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9f8029289e5c8978243bb08f62b2b0a4dcf.png" referrerpolicy="no-referrer"></p><p>他認為，開源的最大優勢是可以隨時分叉。如果有開發者認為某項目 「死了」, 大可以複製代碼自行維護。但是有些人卻以 「分叉」 來威脅原作者，這讓原作者不堪重負。</p><p>AI 行業進展迅速，也加重了這一問題。受 ChatGPT 熱潮影響，部分 AI 新創通過風險投資大規模運營，讓人產生開源 AI 必須 「快速迭代」 的誤解。</p><p>Max 表示，這種對開源項目 「活躍度」 的不合理期待，已經成為阻止他繼續開源工作的主要障礙。他正在考慮通過創業來全職維護自己的項目，但前景未卜。</p><p>他認為，質疑開源項目是否 「死了」 的問題本身，不可能讓開發者產生繼續工作的動力。開源社區如果不能保持友善，只會讓更多優秀項目消失。</p><p>原文：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fminimaxir.com%2F2023%2F11%2Fopen-source-dead-github%2F" target="_blank">https://minimaxir.com/2023/11/open-source-dead-github/</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 10:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266608/open-source-dead-github</guid>
            <link>https://www.oschina.net/news/266608/open-source-dead-github</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[零一萬物對 Yi-34B 訓練過程的説明]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>事件背景：</p><ul><li><a href="https://www.oschina.net/news/266377">李開復旗下 AI 公司「零一萬物」開源的 Yi 大模型照搬 Llama 架構</a></li><li><a href="https://www.oschina.net/news/266525">「零一萬物」 迴應 Yi 開源大模型「套殼」 Llama</a></li></ul><hr><p>零一萬物今天正式發文迴應 Yi 開源大模型引起的爭議：</p><blockquote><p>就零一萬物的觀察和分析，大模型社區在技術架構方面現在是一個處於接近往通用化逐步收攏的階段，基本上國際主流大模型都是基於<strong>Transformer</strong>的架構，做 attention，activation，normalization，positional embedding 等部分的改動，LLaMA、Chinchilla、Gopher 等模型的架構和 GPT 架構大同小異，全球開源社區基於主流架構的模型變化非常之多，生態呈現欣欣向榮，國內已發佈的開源模型也絕大多數採用漸成行業標準的 GPT/LLaMA 的架構。然而，大模型持續發展與尋求突破口的<strong>核心點不僅在於架構，而是在於訓練得到的參數</strong>。</p><p>模型訓練過程好比做一道菜，架構只是決定了做菜的原材料和大致步驟，這在大多數人的認知中也逐步形成共識。<strong>要訓練出好的模型，還需要更好的「原材料」（數據）和對每一個步驟細節的把控（訓練方法和具體參數）</strong>。由於大模型技術發展還在非常初期，從技術觀點來説，行業共識是與主流模型保持一致的模型結構，更有利於整體的適配與未來的迭代。</p><p>零一萬物在訓練模型過程中，沿用了 GPT/LLaMA 的基本架構，由於 LLaMA 社區的開源貢獻，讓零一萬物可以快速起步。零一萬物<strong>從零開始訓練</strong>了 Yi-34B 和 Yi-6B 模型，並根據實際的訓練框架重新實現了訓練代碼，用自建的數據管線構建了高質量配比的訓練數據集（從 3PB 原始數據精選到 3T token 高質量數據）。除此以外，在 Infra 部分進行算法、硬件、軟件聯合端到端優化，實現訓練效率倍級提升和極強的容錯能力等原創性突破。<strong>這些科學訓模的系統性工作，往往比起基本模型結構能起到巨大的作用跟價值。</strong></p><p>零一萬物團隊在訓練前的實驗中，嘗試了不同的數據配比科學地選取了最優的數據配比方案，投注大部分精力調整訓練方法、數據配比、數據工程、細節參數、baby sitting（訓練過程監測）技巧等。這一系列超越模型架構之外，研究與工程並進且具有前沿突破性的研發任務，才是真正屬於模型訓練內核<strong>最為關鍵、能夠形成大模型技術護城河 know-how 積累</strong>。在模型訓練同時，零一萬物也針對模型結構中的若干關鍵節點進行了大量的實驗和對比驗證。舉例來説，我們實驗了 Group Query Attention（GQA）、Multi-Head Attention（MHA）、Vanilla Attention 並選擇了 GQA，實驗了 Pre-Norm 和 Post-Norm 在不同網絡寬度和深度上的變化，並選擇了 Pre-Norm，使用了 RoPE ABF 作為 positional embedding 等。也正是在這些實驗與探索過程中，為了執行對比實驗的需要，模型對部分推理參數進行了重新命名。</p><p>在零一萬物初次開源過程中，我們發現用和開源社區普遍使用的 LLaMA 架構會對開發者更為友好，對於沿用 LLaMA 部分推理代碼經實驗更名後的疏忽，原始出發點是為了充分測試模型，並非刻意隱瞞來源。<strong>零一萬物對此提出説明，並表達誠摯的歉意</strong>，我們正在各開源平台重新提交模型及代碼並補充 LLaMA 協議副本的流程中，承諾儘速完成各開源社區的版本更新。</p><p>我們非常感謝社區的反饋，零一萬物在開源社區剛剛起步，希望和大家攜手共創社區繁榮，在近期發佈 Chat Model 之後，我們將擇期發佈技術報告，Yi Open-source 會盡最大努力虛心學習，持續進步。</p><p><em>開源社區討論參考：</em><br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">https://huggingface.co/01-ai/Yi-34B/discussions/11#6553145873a5a6f938658491</a></p></blockquote><p>創新工場 CMO 在轉發上文的朋友圈中表示：「沿用行業演進漸成通用、生態擁抱的基礎架構就成了「套模、山寨」？（就像手機 app 開發者都得益於 iOS、Android 的共通架構）。零一萬物會持續從社區中虛心學習，持續進步。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-76f874328ebdab1a891bfc44ea094f539e4.png" referrerpolicy="no-referrer"></p><p>原文：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FaDclX74mPPtjQvco3GYmZQ" target="_blank">https://mp.weixin.qq.com/s/aDclX74mPPtjQvco3GYmZQ</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 09:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266597</guid>
            <link>https://www.oschina.net/news/266597</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[CodeFuse 開源 ModelCache 大模型語義緩存]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p style="margin-left:0; margin-right:0"><img alt="" src="https://img.alicdn.com/imgextra/i2/O1CN01Moy0hq1P2Cgi8LERe_!!6000000001782-2-tps-900-383.png" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span>CodeFuse 開源火熱進行中！本次開源的是 ModelCache 大模型語義緩存，可大幅降低大模型應用的推理成本，提升用户體驗。</span></p><p style="margin-left:0; margin-right:0"><span>CodeFuse-ModelCache 項目地址：</span></p><p style="margin-left:0; margin-right:0"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-ModelCache" target="_blank" rel="nofollow"><span>https://github.com/codefuse-ai/CodeFuse-ModelCache</span></a></p><span id="OSC_h2_1"></span><h2><strong><span style="color:#000000">0 背景</span></strong></h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">在 LLM 技術浪潮席捲全球的背景下，大型模型快速增長的參數規模，對部署所需的推理資源帶來了極大的挑戰。為了提高大型模型的推理性能和效率，我們嘗試從緩存角度解決當前大模型規模化服務部署的困境。類似傳統應用，大模型的用户訪問同樣具有時間和空間的局部性（例如：熱門話題相關內容，熱門 GitHub repo）。如果有了緩存層，在遇到相似請求時，就無需調用大模型服務，直接從緩存的數據中返回已有的結果給用户，會大幅降低推理成本，提升用户體驗。</span></p><span id="OSC_h2_2"></span><h2><span style="color:#333333">1 大模型緩存的意義</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">當前大模型服務面臨一下三個挑戰：</span></p><ol><li><span style="color:#333333">成本高：大模型參數量千億級別，單實例就需要多張 A10 卡，規模化部署成本高昂。因此，當前大模型服務基本按照處理的 token 數量計費，導致用户側使用成本也居高不下。</span></li><li><span style="color:#333333">速度慢：大型模型的推理速度也是一個關鍵問題。在許多實時應用中，如對話系統、業務助手，響應時間要求非常高，通常在毫秒級別。然而，大型模型的推理速度往往較慢，在秒級，導致無法實時返回結果，用户體驗下降。</span></li><li><span style="color:#333333">穩定性無保障：由於單實例部署成本高昂，當前大模型服務接受到大流量請求時，通過限流的方式，防止服務不可用。</span></li></ol><span id="OSC_h2_3"></span><h2><span>2 方案調研</span></h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">我們對開源方案 GPTCache 進行了調研，其是致力於構建用於存儲 LLM 響應的語義緩存的項目，該項目提供了語義相似度匹配框架，並提供了相對完善的功能模塊和接口。具有以下優點：<span>&nbsp;</span></span></p><ul><li><span style="color:#333333">項目的活躍性，它不斷引入新功能，使得我們能夠緊跟最新的發展動態。<span>&nbsp;</span></span></li><li><span style="color:#333333">具備開放的功能模塊，可以進行調整和優化，這為業務的擴展提供了便利。</span></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#333333">GPTCache 的整體架構如圖 1 所示：</span></p><p style="margin-left:0; margin-right:0; text-align:left"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/275821/1699497539548-420014c2-90f5-45dc-929f-15a2e3d32ebf.png" width="642" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:center"><span style="color:#333333">圖 1. GPTCache 架構</span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">但是，GPTCache 在落地應用上仍存在諸多不足，包括：</span></p><ol><li><span style="color:#333333">架構上將大模型調用和數據回寫對用户進行了黑盒處理，使得大模型產品在流式輸出、安全審核、問題排查等方面變的複雜。</span></li><li><span style="color:#333333">默認採用 faiss 和 sqlite 作為存儲，不能進行分佈式部署，尤其是在關係型數據庫方面，SqlAlchemy 框架無法支持螞蟻的 OceanBase。</span></li><li><span style="color:#333333">數據和資源隔離上，無法處理多模型多版本場景。</span></li><li><span style="color:#333333">不支持多輪會話，尤其是當模型有 system 指令時，無法很好兼容。更多待改進功能會在 3.3 部分會做詳細介紹。</span></li></ol><span id="OSC_h2_4"></span><h2><span>3 ModelCache 建設</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">針對上述問題，我們基於 GPTCache 進行了二次開發，構建螞蟻內部緩存產品 ModelCache，整體架構見圖 2，接下來會詳細介紹我們的工作，包括：3.1 整體架構；3.2 功能升級。在功能升級部分，會詳細介紹 ModelCache 中新增的功能點。</span></p><span id="OSC_h3_5"></span><h3><span>3.1 整體架構</span></h3><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/305114/1699892547016-2e6263cc-8940-4c43-bffb-5bbd06c57998.png" width="941.818161404823" referrerpolicy="no-referrer"></p><p style="margin-left:16em; margin-right:0"><span>圖 2. ModelCache 架構及上下游</span></p><span id="OSC_h4_6"></span><h4><span style="color:#000000">3.1.1 技術架構</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在初始架構中，將大模型調用和數據回寫對用户進行了黑盒處理。然而，這種架構導致問題排查繁瑣，以及流式輸出和數據安全審核等方面難以滿足企業級要求。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">因此，我們對架構進行了重新調整，ModelCache 採用了輕量化的接入方式，不打擾大模型產品的功能實現。我們設計 ModelCache 為類 redis 結構，提供了開放式的數據查詢、數據回寫、數據管理等 API，同時解</span><span style="color:#000000">耦</span><span style="color:#333333">了大模型調用，可作為一個獨立模塊嵌入到大模型產品。通過 ModelCache，產品側能夠更加靈活地管理和使用大模型，提高系統的可維護性和可擴展性。</span></p><span id="OSC_h4_7"></span><h4><span style="color:#000000">3.1.2 核心模塊</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在 ModelCache 中，包含了一系列核心模塊，包括 adapter、embedding、</span><span style="color:inherit">rank</span><span style="color:#333333">和 data_manager 等，具體功能如下：</span></p><ol><li><span>adapter 模塊：其主要功能是處理各種任務的業務邏輯，並且能夠將 embedding、</span><span style="color:inherit">rank</span><span>、data_manager 等模塊串聯起來。</span></li><li><span style="color:inherit">embedding 模塊：該模塊主要負責將文本轉換為語義向量表示，它將用户的查詢轉換為向量形式，並用於後續的召回或存儲操作。</span></li><li><span style="color:inherit">rank 模塊：用於對召回的向量進行相似度排序和評估，可根據 L2 距離、餘弦相似度或者評估模型，對兩個向量進行相似度評分，並進行排序。</span></li><li><span style="color:inherit">data_manager 模塊：該模塊主要用於管理數據庫，包括向量數據庫和關係型數據庫，它負責數據的存儲、查詢、更新和刪除等操作。</span></li></ol><ol><li><ol><li><span style="color:inherit">向量數據庫（Milvus）：</span><span style="color:#333333">Milvus 作為一個高性能、可擴展、多功能的向量數據庫，適用於多種需要向量檢索的應用場景。</span></li><li><span style="color:#333333">關係型數據庫（OceanBase）：我們採用螞蟻的 OceanBase 數據庫，存儲用户 query、LLM 相應、模型版本等信息。</span></li></ol></li></ol><span id="OSC_h4_8"></span><h4><span>3.1.3 功能對比</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">功能方面，為瞭解決 huggingface 網絡問題並提升推理速度，增加了 embedding 本地推理能力。鑑於 SqlAlchemy 框架存在一些限制，我們對關係數據庫交互模塊進行了重寫，以更靈活地實現數據庫操作。在實踐中，大型模型產品需要與多個用户和多個模型對接，因此在 ModelCache 中增加了對多租户的支持，同時也初步兼容了系統指令和多輪會話。更詳細的功能對比請參見表 1。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333"><img alt="" src="https://img.alicdn.com/imgextra/i4/O1CN01P0Zr401heMlvow7LH_!!6000000004302-0-tps-716-788.jpg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0; text-align:center"><span>表 1. ModelCache 與 GPTCache 功能點對比</span></p><span id="OSC_h3_9"></span><h3><span>3.2 功能升級</span></h3><p style="margin-left:0; margin-right:0"><span style="color:inherit">為了將 Cache 產品應用於企業級用户，並實現真正的落地效果，我們對其功能進行了大量迭代升級，核心功能如圖 3 所示。</span></p><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/2756586/1693799564935-9cb1f565-58a4-4f83-af78-54aaace84668.png" width="657" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:center"><span>圖 3. ModelCache 核心功能</span></p><span id="OSC_h4_10"></span><h4><span>3.2.1 數據管理</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">Cache 需要確保過時或不必要的數據不會在緩存中累積，緩存管理是 Cache 中關鍵的一環，為此，我們實現了兩個重要的功能：</span></p><ul><li><span>一鍵清空能力：</span><span style="color:#333333">ModelCache 中提供了數據移除接口，使用户能夠一鍵清空其緩存。這項功能確保當模型版本或者參數發生變更時，前期版本的數據不會對線上的回答造成幹擾。</span></li><li><span>緩存淘汰策略：</span><span style="color:#333333">ModelCache 支持可定製化的緩存淘汰策略，使用户能夠根據自身需求來定製緩存。</span></li></ul><span id="OSC_h4_11"></span><h4><span>3.2.2 數據隔離</span></h4><p style="margin-left:0; margin-right:0"><span>在實際應用中，數據隔離是一個重要的功能，為了滿足不同場景的需求，ModelCache 實現了多種數據隔離功能，包括：</span></p><ul><li><span>環境隔離： 支持在不同環境中進行數據隔離，包括 DEV、預發和線上環境。這些環境可能存在模型版本和參數上的差異，因此確保了數據在不同環境中的獨立性。</span></li><li><span>模型隔離： 支持模型級別的隔離，使用向量數據庫表和 OB 表字段實現獨立存儲。通過這種方式，不同模型之間的數據可以得到有效的隔離，確保數據的安全性和完整性。</span></li></ul><span id="OSC_h4_12"></span><h4><span>3.2.3 數據迴流</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">數據迴流功能具有知識持久化的能力，能夠確保系統重要數據得到有效地保存和持續使用，從而支持系統的長期發展。為此，Cache 中提供了數據迴流功能，使得系統中的數據能夠得到有效的持久化，這項功能採用異步方式進行，儘可能減少對系統性能的影響。</span></p><span id="OSC_h4_13"></span><h4><span>3.2.4 system 指令及多輪對話支持</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在 ModelCache 中，提供了 system 指令和多輪對話支持，以滿足用户的需求。具體如下：</span></p><ul><li><span style="color:#333333">system 指令支持： ModelCache 中支持 system 指令，尤其是後續用户可以自定義 system 指令的情況下，會區分不同 system 指令下對話的語義相似性，保持 Cache 的穩定性，未來，我們還計劃將 system 指令與會話進行分離，以進一步提升系統的靈活性和可擴展性。</span></li><li><span style="color:#333333">多輪對話能力： ModelCache 還支持多輪對話，即能夠匹配連續對話的語義相似性。</span></li></ul><span id="OSC_h4_14"></span><h4><span>3.2.5 可遷移性</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">ModelCache 具有出色的可遷移性，能夠適應不同的場景，OceanBase 可以無縫遷移至 mysql 等產品，Milvus 也是一種可快速部署的數據庫服務，所以無論是專有云還是公有云都能夠快速應對，並提供高質量的服務。這種可遷移性意味着，ModelCache 可以為用户提供更加靈活和可擴展的部署方案，以滿足不同的需求和場景。</span></p><span id="OSC_h4_15"></span><h4><span>3.2.6 Embedding 能力</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在當前的 cache 中，用户可使用中文通用 embedding 模型（text2vec-base-chinese）。我們也支持大模型 embedding 層的嵌入能力，這使得 embedding 能夠更好地適應模型本身的語義，但僅使用大模型的 embedding 層，演變成了詞袋模型，無法獲取各個 token 的權重。為此，我們在訓練 SGPT（GPT Sentence Embeddings<span>&nbsp;</span></span><span>for Semantic<span>&nbsp;</span></span><span style="color:#333333">Search），以更好的支持 ModelCache。</span></p><span id="OSC_h2_16"></span><h2>&nbsp;</h2><span id="OSC_h2_17"></span><h2><span>4 效果統計</span></h2><span id="OSC_h4_18"></span><h4><span>4.1 效率統計</span></h4><p style="margin-left:0; margin-right:0"><span>依據螞蟻內部大模型產品的 GOC 日誌信息，統計了緩存命中時長和直接調用模型時長，因為產品端採用了流式輸出，時間上會有一定的增加。經過實際系統統計，命中緩存可以將平均耗時降低 10 倍，整體有效提速率可達 14.5%。有效提速率的定義參見下面公式：</span></p><p style="margin-left:0; margin-right:0"><span><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/ba80167f7563caedd5661a48c7813188.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">根據迴流數據（排除流式輸出的延遲），對緩存的耗時進行了評估，緩存未命中的耗時已經控制在數百毫秒量級，我們仍在持續進行查詢耗時的優化。</span></p><span id="OSC_h4_19"></span><h4><span>4.2 embedding 模型的持續優化</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在緩存場景中，我們發現僅僅評估語義相似性是不夠的，核心目標應該是判斷 query 對應的大型模型輸出是否一致（query 的語義相似不等價於大型模型的回覆一致）。例如下面的 query，一詞之差，但生成的結果是完全不同的</span></p><ul><li><ul><li><span style="color:#333333">query: 從 1 遍歷到 1000，找出所有能被 13 和 23 整除的數字，用 Python 實現</span></li><li><span style="color:#333333">query: 從 1 遍歷到 1000，找出所有能被 13 和 23 整除的數字，用 Java 實現</span></li></ul></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#333333">我們調研了 SentenceTransformer 領域的諸多模型，但都無法滿足緩存場景的需求。因此訓練了一個面向企業級應用的 embedding 模型，並希望在此基礎上進一步提升語義相似度評估的準確性，以提高緩存的準確率。</span></p><span id="OSC_h2_20"></span><h2><span>5 未來展望</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">未來，我們旨在提供性能更強、精度更高的解決方案，以滿足 LLM Cache 場景下的需求。將不斷地進行研究和優化，以確保 Cache 系統能夠在實際應用中取得最佳的性能和準確性</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">在性能方面，將通過深入優化各個環節，包括算法、數據和計算資源，以實現更快的召回時間，目標是將整體處理時間壓縮到 300 毫秒以內，以提供更快捷高效的用户體驗。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">在精度方面，將注重語義模型的建設，通過深入研究和改進語義表示技術，致力於提升模型對複雜語義的準確理解能力，從而更精準地匹配用户的 query。此外，還會對相似度評估模塊進行優化，以進一步提升召回率。我們將綜合考慮多種評估指標，如準確度、召回率和 F1 分數，以確保模型在各個方面都取得顯著的提升。</span></p><span id="OSC_h2_21"></span><h2>&nbsp;</h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">想了解更多 CodeFuse 詳情，點擊進入</span><span style="color:#000000">CodeFuse 官網：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcodefuse.alipay.com%2F" target="_blank" rel="nofollow">https://codefuse.alipay.com</a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 08:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6942768/blog/10143074</guid>
            <link>https://my.oschina.net/u/6942768/blog/10143074</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Seata 進入 Apache 孵化器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#191919">Apache 基金會郵件列表<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fincubator.apache.org%2Fprojects%2Fseata.html" target="_blank">顯示</a>，2023 年 10 月 29 日，分佈式事務開源項目 Seata 正式通過 Apache 基金會的投票決議，正式成為 Apache 孵化器項目。</span></p><p><span style="background-color:#ffffff; color:#191919">Seata 是一款開源的分佈式事務解決方案，致力於在微服務架構下提供高性能和簡單易用的分佈式事務服務。</span></p><p><img height="243" src="https://oscimg.oschina.net/oscnet/up-d0f430ca0d175df97cdbcae3599abb935b9.png" width="700" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">2019 年 1 月，阿里巴巴中間件團隊發起了開源項目<span>&nbsp;</span><a href="https://www.oschina.net/p/fescar" target="_blank">Fescar</a>（Fast &amp; EaSy Commit And Rollback），和社區一起共建開源分佈式事務解決方案。Fescar 的願景是讓分佈式事務的使用像本地事務的使用一樣，簡單和高效，並逐步解決開發者們遇到的分佈式事務方面的所有難題。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong>Fescar 開源後，螞蟻金服加入 Fescar 社區參與共建，並在 Fescar 0.4.0 版本中貢獻了 TCC 模式。</strong></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">為了打造更中立、更開放、生態更加豐富的分佈式事務開源社區，經過社區核心成員的投票，大家決定對 Fescar&nbsp;進行品牌升級，並更名為<span>&nbsp;</span><strong>Seata</strong>，意為：<strong>Simple Extensible Autonomous Transaction Architecture</strong>，是一套一站式分佈式事務解決方案。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 08:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266588/seata-apache-incubator</guid>
            <link>https://www.oschina.net/news/266588/seata-apache-incubator</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux 內核中 Rust 的最新狀態]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">在近日舉行的 Linux Plumbers Conference 上，Linux 和 Rust 開發人員 Miguel Ojeda 向 Linux 內核開發人員介紹了有關 Linux 內核中 Rust 的最新情況。簡而言之，Rust Linux 正在不斷走向成熟，並得到了思科、三星和 Canonical 等開發者和供應商的大力支持。</span></p><p><span style="color:#000000">目前，一些發行版已經張開雙臂擁抱 Rust。例如，Ubuntu 已經提供了「構建和測試樹外內核模塊所需的所有必要工具鏈和內核要求」。</span></p><p><span style="color:#000000">三大 Linux Rust 工具鏈也正在形成。一個是 rustc 的 GCC codegen，該工具鏈無需修改源代碼即可編譯並啓動主線 Rust 和 Linux。</span></p><p><span style="color:#000000">另一個是 GCC Front-End for Rust，它可以由現有的 rustc 前端加載，但受益於 GCC 的優化；不過該項目仍處於 alpha 階段。還有一個是 Coccinelle for Rust；Coccinelle 是一個用於製作大規模 Linux 內核 C 源代碼的工具，而 Coccinelle for Rust 正試圖將這一功能引入 Rust 代碼庫。</span></p><p><span style="color:#000000">一些開發者還在嘗試使用 Rust 編寫驅動程序。至於一些使 Rust 與 Linux 完全集成所需的日常工作，均可以在&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frust-for-linux.com%2F" target="_blank">Rust for Linux</a> 這一官方網站查詢更多詳情。</span></p><p><img height="222" src="https://oscimg.oschina.net/oscnet/up-331334d8e76a3e1efb2f883a44a9c3d254b.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">開發了兩年之久的原始 rust 代碼分支已經退役；代碼還在，但已被凍結和歸檔。今後，rust-next 分支將包含新的 Rust 特性，並在 Linux 內核的下一個合併窗口中提交。而這個分支，顧名思義就是 Linux Next 的一部分。</span></p><p><span style="color:#000000">Rust-fixes 分支則包含 Linux 內核當前週期的 Rust 修復。還有一個用於集成的實驗分支 Rust-dev ，是一個"look good enough"的補丁隊列。</span></p><p><span style="color:#000000">理所當然的是，前進之路並非一帆風順。Rust on Linux 的開發人員在過程中發現了一些問題：例如，當兩個或多個線程等待另一個線程結束時，死鎖在 Rust 中是安全的，因為它們不會導致未定義的行為，但它們在 Linux 內核中卻不安全。目前開發人員正在努力解決這個問題。</span></p><p><span style="color:#000000">另一方面，開發人員還在擔心如何處理 Rust 版本的問題。因為最新版本的 Rust Linux 兼容一些不穩定的功能，所以他們無法保證較新的 Rust 版本能在 Linux 中運行。Linux Rust 程序員現下正在跟蹤最新版本的 Rust 編譯器。</span></p><p><span style="color:#000000">與此相關的一個問題是，大眾對將 Rust 支持反向移植到的 Linux 的 LTS 版本（特別是 5.15 和 6.1）中越來越感興趣。但 Linux 通常不允許將 Rust 移植到 LTS Linux 中。因此，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zdnet.com%2Farticle%2Frust-in-linux-where-we-are-and-where-were-going-next%2F" target="_blank">ZDNet</a> 指出，如果你真的非常想要在舊版的 LTS 內核中獲得功能齊全的 Rust 支持，那麼你就需要以某種方式支付費用。</span></p><p><span style="color:#000000">總的來説，Rust 無疑正在成為 Linux 開發的重要語言。但在這一進程中無疑還有許多挑戰需要克服，正如 Ojeda&nbsp;所述，雖然「核心團隊隨着新成員的加入而成長」，但前進之路上仍有很多工作要完成。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 08:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266584/rust-in-linux</guid>
            <link>https://www.oschina.net/news/266584/rust-in-linux</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Telegram 演示運行於 visionOS 的原生應用]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Telegram 創始人帕維爾-杜羅夫 (Pavel Durov) 今天展示了 Telegram 即將推出的 visionOS 應用程序的簡短一瞥，這是我們目前看到的首批第三方 visionOS 應用程序概念之一。</p><p>在 Telegram 上提供的視頻中，Telegram 應用採用了半透明設計，與周圍區域融為一體，這也是蘋果為 visionOS 所採用的設計語言。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-22ca9cb9d4938d2680c3ed6406f83b992af.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1115/150409_gDLb_2720166.png" referrerpolicy="no-referrer"></p><p>該應用的側邊欄列出了用户正在進行的所有可用對話。播放的視頻會從界面中跳出，變得更加身臨其境，而 emoji 字符則會佔據顯示屏，並在分享時以獨特的方式呈現出動畫效果。用户可以使用虛擬鍵盤或通過 Siri 聽寫來發送信息。</p><p>與主頁界面上的所有 visionOS 圖標一樣，Telegram 圖標在被視覺選中時會以動畫的形式彈出，動畫可作為應用程序被突出顯示的視覺提示。由於 Vision Pro 頭顯使用眼睛和手勢導航，因此手指輕點即可啓動應用。</p><p>蘋果預計將於 2024 年初推出 Vision Pro，也就是四月份或之前。隨着首發日期的臨近，我們很快就會看到許多其他第三方應用程序的 VisionOS 體驗。</p><p><strong>演示視頻可用 Telegram 觀看：</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ft.me%2Fdurov%2F239" target="_blank">https://t.me/durov/239</a></p><hr><p>延伸閲讀</p><ul><li><a href="https://www.oschina.net/news/244019/visionos-apples-latest-operating-system">蘋果宣佈最新操作系統：visionOS</a></li><li><a href="https://www.oschina.net/news/251993">Vision Pro 新專利：可模擬生成氣味</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 07:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266572/telegram-visionos-app</guid>
            <link>https://www.oschina.net/news/266572/telegram-visionos-app</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[ChatGPT Plus 臨時暫停新用户註冊，CEO 稱服務器扛不住了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenAI 首席執行官 Sam Altman 今日<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fsama%2Fstatus%2F1724626002595471740" target="_blank">發表推文稱</a></u>，目前暫時暫停 ChatGPT Plus 新用户註冊，原因是<strong>「自 DevDay 大會後，ChatGPT 使用量的激增超出了我們的承受能力，我們希望確保每個人都有良好的體驗」</strong>。</p><p><img src="https://static.oschina.net/uploads/space/2023/1115/134613_H0qt_2720166.png" referrerpolicy="no-referrer"></p><blockquote><p>via&nbsp;<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fsama%2Fstatus%2F1724626002595471740" target="_blank">https://twitter.com/sama/status/1724626002595471740</a></u></em></p></blockquote><p><span>上週 ChatGPT 因為流量過高導致服務不穩定，</span><u><a href="https://www.oschina.net/news/265693">而中斷了 2 個小時</a></u><span>。半年前，OpenAI 剛上線 ChatGPT Plus 訂閲計劃時，也是這番操作：</span><em><u><a href="https://www.oschina.net/news/235524/openai-has-temporarily-stopped-selling-the-plus" target="_blank">OpenAI 暫時關閉 ChatGPT Plus 升級</a></u></em><span>。</span></p><p>根據調查機構&nbsp;Writerbuddy.ai&nbsp;公佈的一份報告，排名前 50 名的 AI 工具在 10 個月中累計被訪問 240 億次，<strong>而其中 ChatGPT 達到了驚人的 146 億次，佔比超過 60%，平均每月訪問 15 億次</strong>。排名前十的還有 Hugging Face、谷歌 BARD、Novel AI、Capcut、Janitor AI 和 Civit AI 等等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b6328a3f5e61c49394df02d7c0d63287218.png" referrerpolicy="no-referrer"></p><p>OpenAI 於 11 月 7 日舉行了其首屆開發者大會 DevDay，期間<u><a href="https://www.oschina.net/news/265331/openai-custom-versions-chatgpt"> CEO 重磅推出 GPTs </a></u>——允許開發者和公司定製 ChatGPT，以滿足他們的特定需求和服務。</p><p><img height="802" src="https://static.oschina.net/uploads/space/2023/1115/141558_VJJd_2720166.png" width="1452" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#000000">GPTs 是一種新方式，任何人都可以創建 ChatGPT 的定製版本，以便在日常生活、特定任務、工作或家庭中更有幫助，然後與其他人分享該創作。例如，GPTs 可以幫助你學習任何棋盤遊戲的規則、幫助你指導孩子的數學或設計貼紙。</span></p><p><em>DevDay 大會回顧</em></p><ul><li><u><em><a href="https://www.oschina.net/news/265330" target="_blank">OpenAI 開發者大會：GPT-4 Turbo、GPTs 商店、128k 上下文窗口、大降價</a></em></u></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 05:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266554</guid>
            <link>https://www.oschina.net/news/266554</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[懸賞十幾萬元以用 Rust 重寫 Prettier]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Facebook 法國前端工程師、React Native 和 Prettier 的聯合創始人 Vjeux&nbsp;在 Twitter </span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2FVjeux%2Fstatus%2F1722733472522142022" target="_blank">發帖</a><span style="color:#000000">，尋求有能力的開發者來使用 Rust 重寫前端代碼格式化工具&nbsp;Prettier，並懸賞 1 萬美元。</span></p><blockquote><p><span style="color:#000000">使用 Rust 實現更快、更美觀的 printers 引起了廣泛關注。但主要問題在於，它們都無法與 prettier 的長尾格式化邏輯相匹配。</span></p><p><span style="color:#000000">如果用 Rust 編寫的項目能通過通過 95% 以上的 prettier JavaScript 測試，我將懸賞 1 萬美元。</span></p></blockquote><p><img alt="" height="229" src="https://oscimg.oschina.net/oscnet/up-6f7c5921c3486449f168f164f0c04ed72c1.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Vercel 的首席執行官&nbsp;Guillermo Rauch&nbsp;也跟帖<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Frauchg%2Fstatus%2F1723400569392656771" target="_blank">表示</a>，進一步對該懸賞進行加碼，將賞金升級到了 2 萬美元。</span></p><p><span style="color:#000000">此外，Wasmer 官方也附議了&nbsp;Vjeux 的這一提議，並表示將額外提供 2500 美元的獎勵。「我們喜歡這一倡議！如果項目編譯到 WASIX 並（通過 CI）發佈到 Wasmer，我們將為項目所有者額外獎勵 2500 美元。」</span></p><p><span style="color:#000000">Prettier 是一個 「有主見」 的代碼格式化工具。它通過解析你的代碼並根據自己的規則 re-printing（將最大行長考慮在內），並在必要時對代碼進行封裝，從而實現一致的風格。簡而言之，這個工具能夠使輸出代碼保持風格一致。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 04:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266545/rewriting-prettier-rust</guid>
            <link>https://www.oschina.net/news/266545/rewriting-prettier-rust</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[11.25 源創會杭州站報名開啓：從數據到大模型應用]]>
            </title>
            <description>
                <![CDATA[11.25 源創會杭州站報名開啓：從數據到大模型應用]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 03:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/action/visit/ad?id=1558</guid>
            <link>https://www.oschina.net/action/visit/ad?id=1558</link>
        </item>
        <item>
            <title>
                <![CDATA[EmotiVoice —— 多音色提示控制 TTS 引擎]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong>EmotiVoice（易魔聲）</strong>是一個強大的開源 TTS 引擎，支持中英文雙語，包含 2000 多種不同的音色，以及特色的<strong>情感合成</strong>功能，支持合成包含快樂、興奮、悲傷、憤怒等廣泛情感的語音。</p><p>EmotiVoice 提供一個易於使用的 Web 界面，還有用於批量生成結果的腳本接口。</p><p>點此查看具體示例：<em><u><a href="https://github.com/netease-youdao/EmotiVoice/blob/main/README.zh.md">https://github.com/netease-youdao/EmotiVoice/blob/main/README.zh.md</a></u></em></p></div>
                                                                ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/emotivoice</guid>
            <link>https://www.oschina.net/p/emotivoice</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | MYSQL 事務的底層原理]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><span><span>事務的底層原理</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在事務的實現機制上，MySQL 採用的是 WAL：Write-ahead logging，預寫式日誌，機制來實現的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在使用 WAL 的系統中，所有的修改都先被寫入到日誌中，然後再被應用到系統中。通常包含 redo 和 undo 兩部分信息。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>為什麼需要使用 WAL，然後包含 redo 和 undo 信息呢？舉個例子，如果一個系統直接將變更應用到系統狀態中，那麼在機器掉電重啓之後系統需要知道操作是成功了，還是隻有部分成功或者是失敗了。如果使用了 WAL，那麼在重啓之後系統可以通過比較日誌和系統狀態來決定是繼續完成操作還是撤銷操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>redo log 稱為重做日誌，每當有操作時，在數據變更之前將操作寫入 redo log，這樣當發生掉電之類的情況時系統可以在重啓後繼續操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>undo log 稱為撤銷日誌，當一些變更執行到一半無法完成時，可以根據撤銷日誌恢復到變更之間的狀態。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>MySQL 中用 redo log 來在系統 Crash 重啓之類的情況時修復數據，而 undo log 來保證事務的原子性。</span></span></span></p><span id="OSC_h2_2"></span><h2><span><span><span>事務 id</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>一個事務可以是一個只讀事務，或者是一個讀寫事務：可以通過 START TRANSACTION READ ONLY 語句開啓一個只讀事務。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在只讀事務中不可以對普通的表進行增、刪、改操作，但可以對用户臨時表做增、刪、改操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以通過 START TRANSACTION READ WRITE 語句開啓一個讀寫事務，或者使用 BEGIN、START TRANSACTION 語句開啓的事務默認也算是讀寫事務。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在讀寫事務中可以對錶執行增刪改查操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>如果某個事務執行過程中對某個表執行了增、刪、改操作，那麼 InnoDB 存儲引擎就會給它分配一個獨一無二的事務 id，針對 MySQL 5.7 分配方式如下：</span></strong></span></span></p><ul><li><span><span><span><span>對於只讀事務來説，只有在它第一次對某個用户創建的臨時表執行增、刪、改操作時才會為這個事務分配一個事務 id，否則的話是不分配事務 id 的。</span></span></span></span></li><li><span><span><span><span>對於讀寫事務來説，只有在它第一次對某個表執行增、刪、改操作時才會為這個事務分配一個事務 id，否則的話也是不分配事務 id 的。</span></span></span></span></li><li><span><span><span><span>有的時候雖然開啓了一個讀寫事務，但是在這個事務中全是查詢語句，並沒有執行增、刪、改的語句，那也就意味着這個事務並不會被分配一個事務 id。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>這個事務 id 本質上就是一個數字，它的分配策略和隱藏列 row_id 的分配策略大抵相同，具體策略如下：</span></strong></span></span></p><ul><li><span><span><span><span>服務器會在內存中維護一個全局變量，每當需要為某個事務分配一個事務 id 時，就會把該變量的值當作事務 id 分配給該事務，並且把該變量自增 1。</span></span></span></span></li><li><span><span><span><span>每當這個變量的值為 256 的倍數時，就會將該變量的值刷新到系統表空間的頁號為 5 的頁面中一個稱之為 Max Trx ID 的屬性處，這個屬性佔用 8 個字節的存，儲空間。</span></span></span></span></li><li><span><span><span><span>當系統下一次重新啓動時，會將上邊提到的 Max Trx ID 屬性加載到內存中，將該值加上 256 之後賦值給全局變量，因為在上次關機時該全局變量的值可能大於 Max Trx ID 屬性值。</span></span></span></span></li><li><span><span><span><span>這樣就可以保證整個系統中分配的事務 id 值是一個遞增的數字。先被分配 id 的事務得到的是較小的事務 id，後被分配 id 的事務得到的是較大的事務 id。</span></span></span></span></li></ul><span id="OSC_h2_3"></span><h2><span><span><span>mvcc</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>全稱 Multi-Version Concurrency Control，即多版本併發控制，主要是為了提高數據庫的併發性能。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>同一行數據平時發生讀寫請求時，會上鎖阻塞住。但 MVCC 用更好的方式去處理讀寫請求，做到在發生讀寫請求衝突時不用加鎖。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這個讀是指的快照讀，而不是當前讀，當前讀是一種加鎖操作，是悲觀鎖。</span></span></span></p><span id="OSC_h3_4"></span><h3><span><span><span>MVCC 原理</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在事務併發執行遇到的問題如下：</span></span></span></p><ul><li><span><span><span><span>髒讀：如果一個事務讀到了另一個未提交事務修改過的數據，那就意味着發生了髒讀；</span></span></span></span></li><li><span><span><span><span>不可重複讀：如果一個事務只能讀到另一個已經提交的事務修改過的數據，並且其他事務每對該數據進行一次修改並提交後，該事務都能查詢得到最新值，那就意味着發生了不可重複讀；</span></span></span></span></li><li><span><span><span><span>幻讀：如果一個事務先根據某些條件查詢出一些記錄，之後另一個事務又向表中插入了符合這些條件的記錄，原先的事務再次按照該條件查詢時，能把另一個事務插入的記錄也讀出來，那就意味着發生了幻讀，幻讀強調的是一個事務按照某個相同條件多次讀取記錄時，後讀取時讀到了之前沒有讀到的記錄，幻讀只是重點強調了讀取到了之前讀取沒有獲取到的記錄。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>MySQL 在 REPEATABLE READ 隔離級別下，是可以很大程度避免幻讀問題的發生的。</span></strong></span></span></p><span id="OSC_h4_5"></span><h4><span><span><span>版本鏈</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於使用 InnoDB 存儲引擎的表來説，它的聚簇索引記錄中都包含兩個必要的隱藏列：</span></span></span></p><ul><li><span><span><span><span>trx_id：每次一個事務對某條聚簇索引記錄進行改動時，都會把該事務的事務 id 賦值給 trx_id 隱藏列；</span></span></span></span></li><li><span><span><span><span>roll_pointer：每次對某條聚簇索引記錄進行改動時，都會把舊的版本寫入到 undo 日誌中，然後這個隱藏列就相當於一個指針，可以通過它來找到該記錄修，改前的信息；</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>演示</span></strong></span></span></p><pre><code><span><span><span style="color:#708090">-- 創建表</span></span><span><span></span></span><span><span style="color:#0077aa">CREATE</span></span><span><span></span></span><span><span style="color:#0077aa">TABLE</span></span><span><span> mvcc_test </span></span><span><span style="color:#999999">(</span></span><span><span>
id </span></span><span><span style="color:#0077aa">INT</span></span><span><span style="color:#999999">,</span></span><span><span>
name </span></span><span><span style="color:#0077aa">VARCHAR</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">100</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">,</span></span><span><span>
domain </span></span><span><span style="color:#0077aa">varchar</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">100</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">PRIMARY</span></span><span><span></span></span><span><span style="color:#0077aa">KEY</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>id</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">Engine</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#0077aa">InnoDB</span></span><span><span></span></span><span><span style="color:#0077aa">CHARSET</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span>utf8</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 添加數據</span></span><span><span></span></span><span><span style="color:#0077aa">INSERT</span></span><span><span></span></span><span><span style="color:#0077aa">INTO</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">VALUES</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'habit'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'演示 mvcc'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>假設插入該記錄的事務 id=50，那麼該條記錄的展示如圖：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-497oLuqeLE7xPfzmr.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>假設之後兩個事務 id 分別為 70、90 的事務對這條記錄進行 UPDATE 操作。</span></span></span></p><div><table cellspacing="0" style="--tw-ring-color:rgba(59,130,246,.5); --tw-ring-inset:var(--tw-empty,/*!*/ /*!*/); --tw-ring-offset-color:#ffffff; --tw-ring-offset-shadow:0 0 #0000; --tw-ring-offset-width:0px; --tw-ring-shadow:0 0 #0000; --tw-shadow:0 0 #0000; border-collapse:collapse; border-color:inherit; border-style:solid; border-width:0px; box-sizing:border-box; margin:0px; outline:none; padding:0px; text-indent:0px; width:auto"><tbody><tr><th style="background-color:var(--w-e-textarea-slight-bg-color); text-align:center"><span><span><span>trx_id=70</span></span></span></th><th style="background-color:var(--w-e-textarea-slight-bg-color); text-align:center"><span><span><span>trx_id=90</span></span></span></th></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>begin</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>begin</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_70_01' where id=1</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_70_02' where id=1</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>commit</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_90_01' where id=1</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_90_02' where id=1</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>commit</span></span></span></td></tr></tbody></table></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>每次對記錄進行改動，都會記錄一條 undo 日誌，每條 undo 日誌也都有一個 roll_pointer 屬性，可以將這些 undo 日誌都連起來，串成一個鏈表。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-49y0loF49tpKQ7swfq.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>對該記錄每次更新後，都會將舊值放到一條 undo 日誌中，就算是該記錄的一箇舊版本，隨着更新次數的增多，所有的版本都會被 roll_pointer 屬性連接成一個鏈表，把這個鏈表稱之為版本鏈，版本鏈的頭節點就是當前記錄最新的值。另外，每個版本中還包含生成該版本時對應的事務 id。於是可以利用這個記錄的版本鏈來控制併發事務訪問相同記錄的行為，那麼這種機制就被稱之為：</span></span></span><span><span><strong><span>多版本併發控制，即 MVCC。</span></strong></span></span></p><span id="OSC_h4_6"></span><h4><span><span><span>ReadView</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於使用 READ UNCOMMITTED 隔離級別的事務來説，由於可以讀到未提交事務修改過的記錄，所以直接讀取記錄的最新版本就好了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於使用 SERIALIZABLE 隔離級別的事務來説，InnoDB 使用加鎖的方式來訪問記錄。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於使用 READ COMMITTED 和 REPEATABLE READ 隔離級別的事務來説，都必須保證讀到已經提交了的事務修改過的記錄，也就是説假如另一個事務已經修改了記錄但是尚未提交，是不能直接讀取最新版本的記錄的，核心問題就是：READ COMMITTED 和 REPEATABLE READ 隔離級別在不可重複讀和幻讀上的區別是從哪裏來的，其實結合前面的知識，這兩種隔離級別關鍵是需要判斷一下版本鏈中的哪個版本是當前事務可見的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>為此，InnoDB 提出了一個 ReadView 的概念，這個 ReadView 中主要包含 4 個比較重要的內容：</span></strong></span></span></p><ul><li><span><span><span><span>m_ids：表示在生成 ReadView 時當前系統中活躍的讀寫事務的事務 id 列表；</span></span></span></span></li><li><span><span><span><span>min_trx_id：表示在生成 ReadView 時當前系統中活躍的讀寫事務中最小的事務 id，也就是 m_ids 中的最小值；</span></span></span></span></li><li><span><span><span><span>max_trx_id：表示在生成 ReadView 時系統中應該分配給下一個事務的 id 值，注：max_trx_id 並不是 m_ids 中的最大值，事務 id 是遞增分配的。比方説現在有 id 為 1，2，3 這三個事務，之後 id 為 3 的事務提交了。那麼一個新的讀事務在生成 ReadView 時，m_ids 就包括 1 和 2，min_trx_id 的值就是 1，max_trx_id 的值就是 4；</span></span></span></span></li><li><span><span><span><span>creator_trx_id：表示生成該 ReadView 的事務的事務 id；</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>有了這個 ReadView，這樣在訪問某條記錄時，只需要按照下邊的步驟判斷記錄的某個版本是否可見：</span></span></span></p><ol><li><span><span><span><span>如果被訪問版本的 trx_id 屬性值與 ReadView 中的 creator_trx_id 值相同，意味着當前事務在訪問它自己修改過的記錄，所以該版本可以被當前事務訪問；</span></span></span></span></li><li><span><span><span><span>如果被訪問版本的 trx_id 屬性值小於 ReadView 中的 min_trx_id 值，表明生成該版本的事務在當前事務生成 ReadView 前已經提交，所以該版本可以被當前事務訪問；</span></span></span></span></li><li><span><span><span><span>如果被訪問版本的 trx_id 屬性值大於或等於 ReadView 中的 max_trx_id 值，表明生成該版本的事務在當前事務生成 ReadView 後才開啓，所以該版本不可以被當前事務訪問；</span></span></span></span></li><li><span><span><span><span>如果被訪問版本的 trx_id 屬性值在 ReadView 的 min_trx_id 和 max_trx_id 之間 min_trx_id &lt; trx_id &lt; max_trx_id，那就需要判斷一下 trx_id 屬性值是不是在 m_ids 列表中，如果在，説明創建 ReadView 時生成該版本的事務還是活躍的，該版本不可以被訪問；如果不在，説明創建 ReadView 時生成該版本的事務已經被提交，該版本可以被訪問；</span></span></span></span></li><li><span><span><span><span>如果某個版本的數據對當前事務不可見的話，那就順着版本鏈找到下一個版本的數據，繼續按照上邊的步驟判斷可見性，依此類推，直到版本鏈中的最後一個版本。如果最後一個版本也不可見的話，那麼就意味着該條記錄對該事務完全不可見，查詢結果就不包含該記錄；</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 MySQL 中，READ COMMITTED 和 REPEATABLE READ 隔離級別的一個非常大的區別就是它們生成 ReadView 的時機不同。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>還是以表 mvcc_test 為例，假設現在表 mvcc_test 中只有一條由事務 id 為 50 的事務插入的一條記錄，接下來看一下 READ COMMITTED 和 REPEATABLE READ 所謂的生成 ReadView 的時機不同到底不同在哪裏。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>READ COMMITTED：</span></strong></span></span><span><span><span> 每次讀取數據前都生成一個 ReadView；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比方説現在系統裏有兩個事務 id 分別為 70、90 的事務在執行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- T 70</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此時表 mvcc_test 中 id 為 1 的記錄得到的版本鏈表如下所示：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-50mpbjn7HMKz7hBhK.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>假設現在有一個使用 READ COMMITTED 隔離級別的事務開始執行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 READ COMMITTED 隔離級別的事務</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值為'habit'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>這個 SELECE1 的執行過程如下：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在執行 SELECT 語句時會先生成一個 ReadView，ReadView 的 m_ids 列表的內容就是[70, 90]，min_trx_id 為 70，max_trx_id 為 91，creator_trx_id 為 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然後從版本鏈中挑選可見的記錄，從圖中可以看出，最新版本的列 name 的內容是 habit_trx_id_70_02，該版本的 trx_id 值為 70，在 m_ids 列表內，所以不符合可見性要求第 4 條：</span></span></span><span><span><code><strong><span>如果被訪問版本的 trx_id 屬性值在 ReadView 的 min_trx_id 和 max_trx_id 之間 min_trx_id &lt; trx_id &lt; max_trx_id，那就需要判斷一下 trx_id 屬性值是不是在 m_ids 列表中，如果在，説明創建 ReadView 時生成該版本的事務還是活躍的，該版本不可以被訪問；如果不在，説明創建 ReadView 時生成該版本的事務已經被提交，該版本可以被訪問。</span></strong></code></span></span><span><span><span>根據 roll_pointer 跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit_trx_id_70_01，該版本的 trx_id 值也為 70，也在 m_ids 列表內，所以也不符合要求，繼續跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit，該版本的 trx_id 值為 50，小於 ReadView 中的 min_trx_id 值，所以這個版本是符合要求的第 2 條：</span></span></span><span><span><strong><span>如果被訪問版本的 trx_id 屬性值小於 ReadView 中的 min_trx_id 值，表明生成該版本的事務在當前事務生成 ReadView 前已經提交，所以該版本可以被當前事務訪問。</span></strong></span></span><span><span><span>最後返回的版本就是這條列 name 為 habit 的記錄。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>之後，把事務 id 為 70 的事務提交一下，然後再到事務 id 為 90 的事務中更新一下表 mvcc_test 中 id 為 1 的記錄：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- T 90</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此時表 mvcc 中 id 為 1 的記錄的版本鏈就長這樣：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-507DFORnJ7Is10E8bC.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>然後再到剛才使用 READ COMMITTED 隔離級別的事務中繼續查找這個 id 為 1 的記錄，如下：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 READ COMMITTED 隔離級別的事務</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 均未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值為'habit'</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE2：Transaction 70 提交，Transaction 90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值為'habit_trx_id_70_02'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>這個 SELECE2 的執行過程如下：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在執行 SELECT 語句時又會單獨生成一個 ReadView，該 ReadView 的 m_ids 列表的內容就是[90]，min_trx_id 為 90，max_trx_id 為 91，creator_trx_id 為 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然後從版本鏈中挑選可見的記錄，從圖中可以看出，最新版本的列 name 的內容是 habit_trx_id_90_02，該版本的 trx_id 值為 90，在 m_ids 列表內，所以不符合可見性要求，根據 roll_pointer 跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit_trx_id_90_01，該版本的 trx_id 值為 90，也在 m_ids 列表內，所以也不符合要求，繼續跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit_trx_id_70_02，該版本的 trx_id 值為 70，小於 ReadView 中的 min_trx_id 值 90，所以這個版本是符合要求的，最後返回這個版本中列 name 為 habit_trx_id_70_02 的記錄。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>以此類推，如果之後事務 id 為 90 的記錄也提交了，再次在使用 READ COMMITTED 隔離級別的事務中查詢表 mvcc_test 中 id 值為 1 的記錄時，得到的結果就是 habit_trx_id_90_02 了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>總結：</span></strong></span></span><span><span><span>使用 READ COMMITTED 隔離級別的事務在每次查詢開始時都會生成一個獨立的 ReadView。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>REPEATABLE READ：</span></strong></span></span><span><span><span>在第一次讀取數據時生成一個 ReadView；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於使用 REPEATABLE READ 隔離級別的事務來説，只會在第一次執行查詢語句時生成一個 ReadView，之後的查詢就不會重複生成了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比方説現在系統裏有兩個事務 id 分別為 70、90 的事務在執行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- T 70</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此時表 mvcc_test 中 id 為 1 的記錄得到的版本鏈表如下所示：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-51UwvDNOV077PoRbf.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>假設現在有一個使用 REPEATABLE READ 隔離級別的事務開始執行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 REPEATABLE READ 隔離級別的事務</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值為'habit'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>這個 SELECE1 的執行過程如下：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在執行 SELECT 語句時會先生成一個 ReadView，ReadView 的 m_ids 列表的內容就是[70, 90]，min_trx_id 為 70，max_trx_id 為 91，creator_trx_id 為 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然後從版本鏈中挑選可見的記錄，從圖中可以看出，最新版本的列 name 的內容是 habit_trx_id_70_02，該版本的 trx_id 值為 70，在 m_ids 列表內，所以不符合可見性要求，根據 roll_pointer 跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit_trx_id_70_01，該版本的 trx_id 值也為 70，也在 m_ids 列表內，所以也不符合要求，繼續跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit，該版本的 trx_id 值為 50，小於 ReadView 中的 min_trx_id 值，所以這個版本是符合要求的，最後返回的就是這條列 name 為 habit 的記錄。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>之後，把事務 id 為 70 的事務提交一下，然後再到事務 id 為 90 的事務中更新一下表 mvcc_test 中 id 為 1 的記錄：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 REPEATABLE READ 隔離級別的事務</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此刻，表 mvcc_test 中 id 為 1 的記錄的版本鏈就長這樣：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-51h9D8xW10EuQBNz51m.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>然後再到剛才使用 REPEATABLE READ 隔離級別的事務中繼續查找這個 id 為 1 的記錄，如下：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 REPEATABLE READ 隔離級別的事務</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 均未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值為'habit'</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE2：Transaction 70 提交，Transaction 90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span> &nbsp;</span></span><span><span style="color:#708090">-- 得到的列 name 的值為'habit'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這個 SELECE2 的執行過程如下：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>因為當前事務的隔離級別為 REPEATABLE READ，而之前在執行 SELECE1 時已經生成過 ReadView 了，所以此時直接複用之前的 ReadView，之前的 ReadView 的 m_ids 列表的內容就是[70, 90]，min_trx_id 為 70，max_trx_id 為 91， creator_trx_id 為 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然後從版本鏈中挑選可見的記錄，從圖中可以看出，最新版本的列 name 的內容是 habit_trx_id_90_02，該版本的 trx_id 值為 90，在 m_ids 列表內，所以不符合可見性要求，根據 roll_pointer 跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit_trx_id_90_01，該版本的 trx_id 值為 90，也在 m_ids 列表內，所以也不符合要求，繼續跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit_trx_id_70_02，該版本的 trx_id 值為 70，而 m_ids 列表中是包含值為 70 的事務 id 的，所以該版本也不符合要求，同理下一個列 name 的內容是 habit_trx_id_70_01 的版本也不符合要求。繼續跳到下一個版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一個版本的列 name 的內容是 habit，該版本的 trx_id 值為 50，小於 ReadView 中的 min_trx_id 值 70，所以這個版本是符合要求的，最後返回給用户的版本就是這條列 name 為 habit 的記錄。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>也就是説兩次 SELECT 查詢得到的結果是重複的，記錄的列 name 值都是 habit，這就是可重複讀的含義。如果之後再把事務 id 為 90 的記錄提交了，然後再到剛才使用 REPEATABLE READ 隔離級別的事務中繼續查找這個 id 為 1 的記錄，得到的結果還是 habit。</span></span></span></p><span id="OSC_h3_7"></span><h3><span><span><span>MVCC 下的幻讀解決和幻讀現象</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>REPEATABLE READ 隔離級別下 MVCC 可以解決不可重複讀問題，那麼幻讀呢？MVCC 是怎麼解決的？幻讀是一個事務按照某個相同條件多次讀取記錄時，後讀取時讀到了之前沒有讀到的記錄，而這個記錄來自另一個事務添加的新記錄。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以想想，在 REPEATABLE READ 隔離級別下的事務 T1 先根據某個搜索條件讀取到多條記錄，然後事務 T2 插入一條符合相應搜索條件的記錄並提交，然後事務 T1 再根據相同搜索條件執行查詢。結果會是什麼？按照 ReadView 中的比較規則中的第 3 條和第 4 條不管事務 T2 比事務 T1 是否先開啓，事務 T1 都是看不到 T2 的提交的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>但是，在 REPEATABLE READ 隔離級別下 InnoDB 中的 MVCC 可以很大程度地避免幻讀現象，而不是完全禁止幻讀。怎麼回事呢？來看下面的情況：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-51wOnqygonsF10mmAn.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>首先在事務 T1 中執行：</span></span></span><span><span><code><span>select * from mvcc_test where id = 30;</span></code></span></span><span><span><span> 這個時候是找不到 id = 30 的記錄的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在事務 T2 中，執行插入語句：</span></span></span><span><span><code><span>insert into mvcc_test values(30,'luxi','luxi');</span></code></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此時回到事務 T1，執行：</span></span></span></p><pre><code><span><span><span style="color:#0077aa">update</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">set</span></span><span><span> domain</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#669900">'luxi_t1'</span></span><span><span></span></span><span><span style="color:#0077aa">where</span></span><span><span> id</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#990055">30</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">select</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">from</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">where</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">30</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>事務 T1 很明顯出現了幻讀現象。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 REPEATABLE READ 隔離級別下，T1 第一次執行普通的 SELECT 語句時生成了一個 ReadView，之後 T2 向 mvcc_test 表中新插入一條記錄並提交。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>ReadView 並不能阻止 T1 執行 UPDATE 或者 DELETE 語句來改動這個新插入的記錄，由於 T2 已經提交，因此改動該記錄並不會造成阻塞，但是這樣一來，這條新記錄的 trx_id 隱藏列的值就變成了 T1 的事務 id。之後 T1 再使用普通的 SELECT 語句去查詢這條記錄時就可以看到這條記錄了，也就可以把這條記錄返回給客户端。因為這個特殊現象的存在，可以認為 MVCC 並不能完全禁止幻讀。</span></span></span></p><span id="OSC_h3_8"></span><h3><span><span><span>mvcc 總結</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>從上邊的描述中可以看出來，所謂的 MVCC（Multi-Version Concurrency Control ，多版本併發控制）指的就是在使用 READ COMMITTD、REPEATABLE READ 這兩種隔離級別的事務在執行普通的 SELECT 操作時訪問記錄的版本鏈的過程，這樣子可以使不同事務的讀寫、寫讀操作併發執行，從而提升系統性能。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>READ COMMITTD、REPEATABLE READ 這兩個隔離級別的一個很大不同就是：生成 ReadView 的時機不同，READ COMMITTD 在每一次進行普通 SELECT 操作前都會生成一個 ReadView，而 REPEATABLE READ 只在第一次進行普通 SELECT 操作前生成一個 ReadView，之後的查詢操作都重複使用這個 ReadView 就好了，從而基本上可以避免幻讀現象。</span></span></span></p><span id="OSC_h2_9"></span><h2><span><span><span>InnoDB 的 Buffer Pool</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>對於使用 InnoDB 作為存儲引擎的表來説，不管是用於存儲用户數據的索引，包括：聚簇索引和二級索引，還是各種系統數據，都是以頁的形式存放在表空間中的，而所謂的表空間只不過是 InnoDB 對文件系統上一個或幾個實際文件的抽象，也就是説數據還是存儲在磁盤上的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>但是磁盤的速度慢，所以 InnoDB 存儲引擎在處理客户端的請求時，當需要訪問某個頁的數據時，就會把完整的頁的數據全部加載到內存中，即使只需要訪問一個頁的一條記錄，那也需要先把整個頁的數據加載到內存中。將整個頁加載到內存中後就可以進行讀寫訪問了，在進行完讀寫訪問之後並不着急把該頁對應的內存空間釋放掉，而是將其緩存起來，這樣將來有請求再次訪問該頁面時，就可以省去磁盤 IO 的開銷了。</span></span></span></p><span id="OSC_h3_10"></span><h3><span><span><span>Buffer Pool</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>InnoDB 為了緩存磁盤中的頁，在 MySQL 服務器啓動的時候就向操作系統申請了一片連續的內存，這塊連續內存叫做：Buffer Pool，中文名：緩衝池。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>默認情況下 Buffer Pool 只有 128M 大小。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>查看該值：</span></span></span><span><span><code><span>show variables like 'innodb_buffer_pool_size';</span></code></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以在啓動服務器的時候配置 innodb_buffer_pool_size 參數的值，它表示 Buffer Pool 的大小，配置如下：</span></span></span></p><pre><code><span><span><span>[server]
innodb_buffer_pool_size = 268435456</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>其中，268435456 的單位是字節，也就是指定 Buffer Pool 的大小為 256M，Buffer Pool 也不能太小，最小值為 5M，當小於該值時會自動設置成 5M。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>啓動 MySQL 服務器的時候，需要完成對 Buffer Pool 的初始化過程，就是先向操作系統申請 Buffer Pool 的內存空間，然後把它劃分成若干對控制塊和緩，存頁。但是此時並沒有真實的磁盤頁被緩存到 Buffer Pool 中，之後隨着程序的運行，會不斷的有磁盤上的頁被緩存到 Buffer Pool 中。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 Buffer Pool 中會創建多個緩存頁，默認的緩存頁大小和在磁盤上默認的頁大小是一樣的，都是 16KB。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>那麼怎麼知道該頁在不在 Buffer Pool 中呢？</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在查找數據的時候，先通過哈希表中查找 key 是否在哈希表中，如果在證明 Buffer Pool 中存在該緩存也信息，如果不存在證明不存該緩存也信息，則通過讀取磁盤加載該頁信息放到 Buffer Pool 中，哈希表中的 key 是通過表空間號+ 頁號作組成的，value 是 Buffer Pool 的緩存頁。</span></span></span></p><span id="OSC_h3_11"></span><h3><span><span><span>flush 鏈表的管理</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果修改了 Buffer Pool 中某個緩存頁的數據，那它就和磁盤上的頁不一致了，這樣的緩存頁也被稱為：</span></span></span><span><span><strong><span>髒頁</span></strong></span></span><span><span><span>。最簡單的做法就是每發生一次修改就立即同步到磁盤上對應的頁上，但是頻繁的往磁盤中寫數據會嚴重的影響程序的性能。所以每次修改緩存頁後，並不着急把修改同步到磁盤上，而是在未來的某個時間進行同步。 但是如果不立即同步到磁盤的話，那之後再同步的時候怎麼知道 Buffer Pool 中哪些頁是髒頁，哪些頁從來沒被修改過呢？總不能把所有的緩存頁都同步到磁盤上吧，如果 Buffer Pool 被設置的很大，那一次性同步會非常慢。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>所以，需要再創建一個存儲髒頁的鏈表，凡是修改過的緩存頁對應的控制塊都會作為一個節點加入到一個鏈表中，因為這個鏈表節點對應的緩存頁都是需要被刷新到磁盤上的，所以也叫 flush 鏈表。</span></span></span></p><span id="OSC_h3_12"></span><h3><span><span><span>刷新髒頁到磁盤</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>後台有專門的線程每隔一段時間負責把髒頁刷新到磁盤，這樣可以不影響用户線程處理正常的請求。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>從 flush 鏈表中刷新一部分頁面到磁盤，後台線程也會定時從 flush 鏈表中刷新一部分頁面到磁盤，刷新的速率取決於當時系統是不是很繁忙。這種刷新頁面的方式被稱之為：BUF_FLUSH_LIST。</span></span></span></p><span id="OSC_h2_13"></span><h2><span><span><span>redo 日誌</span></span></span></h2><span id="OSC_h3_14"></span><h3><span><span><span>redo 日誌的作用</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>InnoDB 存儲引擎是以頁為單位來管理存儲空間的，增刪改查操作其實本質上都是在訪問頁面，包括：讀頁面、寫頁面、創建新頁面等操作。在真正訪問頁面之前，需要把在磁盤上的頁緩存到內存中的 Buffer Pool 之後才可以訪問。但是在事務的時候又強調過一個稱之為持久性的特性，就是説對於一個已經提交的事務，在事務提交後即使系統發生了崩潰，這個事務對數據庫中所做的更改也不能丟失。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果只在內存的 Buffer Pool 中修改了頁面，假設在事務提交後突然發生了某個故障，導致內存中的數據都失效了，那麼這個已經提交了的事務對數據庫中所做的更改也就跟着丟失了，這是所不能忍受的。那麼如何保證這個持久性呢？一個很簡單的做法就是在事務提交完成之前把該事務所修改的所有頁面都刷新到磁盤，但是這個簡單粗暴的做法有些問題：</span></span></span></p><ol><li><span><span><span><span>刷新一個完整的數據頁太浪費了；有時候僅僅修改了某個頁面中的一個字節，但是在 InnoDB 中是以頁為單位來進行磁盤 IO 的，也就是説在該事務提交時不得不將一個完整的頁面從內存中刷新到磁盤，一個頁面默認是 16KB 大小，只修改一個字節就要刷新 16KB 的數據到磁盤上顯然是太浪費了。</span></span></span></span></li><li><span><span><span><span>隨機 IO 刷起來比較慢；一個事務可能包含很多語句，即使是一條語句也可能修改許多頁面，該事務修改的這些頁面可能並不相鄰，這就意味着在將某個事務修改的 Buffer Pool 中的頁面刷新到磁盤時，需要進行很多的隨機 IO，隨機 IO 比順序 IO 要慢，尤其對於傳統的機械硬盤來説。</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>只是想讓已經提交了的事務對數據庫中數據所做的修改永久生效，即使後來系統崩潰，在重啓後也能把這種修改恢復出來。其實沒有必要在每次事務提交時就把該事務在內存中修改過的全部頁面刷新到磁盤，只需要把修改了哪些東西記錄一下就好，比方説：某個事務將系統表空間中的第 5 號頁面中偏移量為 5000 處的那個字節的值 0 改成 5 只需要記錄一下：</span></span></span><span><span><strong><span>將第 5 號表空間的 5 號頁面的偏移量為 5000 處的值更新為：5</span></strong></span></span><span><span><span>。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這樣在事務提交時，把上述內容刷新到磁盤中，即使之後系統崩潰了，重啓之後只要按照上述內容所記錄的步驟重新更新一下數據頁，那麼該事務對數據庫中所做的修改又可以被恢復出來，也就意味着滿足持久性的要求。因為在系統崩潰重啓時需要按照上述內容所記錄的步驟重新更新數據頁，所以上述內容也被稱之為：</span></span></span><span><span><strong><span>重做日誌，即：redo log</span></strong></span></span><span><span><span>。與在事務提交時將所有修改過的內存中的頁面刷新到磁盤中相比，只將該事務執行過程中產生的 redo log 刷新到磁盤的好處如下：</span></span></span></p><ol><li><span><span><span><span>redo log 佔用的空間非常小存儲表空間 ID、頁號、偏移量以及需要更新的值所需的存儲空間是很小的；</span></span></span></span></li><li><span><span><span><span>redo log 是順序寫入磁盤的在執行事務的過程中，每執行一條語句，就可能產生若干條 redo log，這些日誌是按照產生的順序寫入磁盤的，也就是使用順序 IO；</span></span></span></span></li></ol><span id="OSC_h3_15"></span><h3><span><span><span>redo log 的寫入過程</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>InnoDB 為了更好的進行系統崩潰恢復，把一次原子操作生成的 redo log 都放在了大小為 512 字節的塊（block）中。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>為瞭解決磁盤速度過慢的問題而引入了 Buffer Pool。同理，寫入 redo log 時也不能直接寫到磁盤上，實際上在服務器啓動時就向操作系統申請了一大片稱之為 redo log buffer 的連續內存空間，即：redo log 緩衝區，也可以簡稱：log buffer。這片內存空間被劃分成若干個連續的 redo log block，可以通過啓動參數 innodb_log_buffer_size 來指定 log buffer 的大小，該啓動參數的默認值為：16MB。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>向 log buffer 中寫入 redo log 的過程是順序的，也就是先往前邊的 block 中寫，當該 block 的空閒空間用完之後再往下一個 block 中寫。</span></span></span></p><span id="OSC_h4_16"></span><h4><span><span><span>redo log 刷盤時機</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>log buffer 什麼時候會寫入到磁盤呢？</span></strong></span></span></p><ul><li><span><span><span><span>log buffer 空間不足時，如果不停的往這個有限大小的 log buffer 裏塞入日誌，很快它就會被填滿。InnoDB 認為如果當前寫入 log buffer 的 redo log 量已，經佔滿了 log buffer 總容量的大約一半左右，就需要把這些日誌刷新到磁盤上。</span></span></span></span></li><li><span><span><span><span>事務提交時，必須要把修改這些頁面對應的 redo log 刷新到磁盤。</span></span></span></span></li><li><span><span><span><span>後台有一個線程，大約每秒都會刷新一次 log buffer 中的 redo log 到磁盤。</span></span></span></span></li><li><span><span><span><span>正常關閉服務器時等等。</span></span></span></span></li></ul><span id="OSC_h2_17"></span><h2><span><span><span>undo 日誌</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>事務需要保證原子性，也就是事務中的操作要麼全部完成，要麼什麼也不做。但是偏偏有時候事務執行到一半會出現一些情況，比如：</span></span></span></p><ul><li><span><span><span><span>情況一：事務執行過程中可能遇到各種錯誤，比如服務器本身的錯誤，操作系統錯誤，甚至是突然斷電導致的錯誤。</span></span></span></span></li><li><span><span><span><span>情況二：程序員可以在事務執行過程中手動輸入 ROLLBACK 語句結束當前的事務的執行。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這兩種情況都會導致事務執行到一半就結束，但是事務執行過程中可能已經修改了很多東西，為了保證事務的原子性，需要把東西改回原先的樣子，這個過程就稱之為回滾，即：rollback，這樣就可以造成這個事務看起來什麼都沒做，所以符合原子性要求。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>每當要對一條記錄做改動時，都需要把回滾時所需的東西都給記下來。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比方説：</span></span></span></p><ul><li><span><span><span><span>插入一條記錄時，至少要把這條記錄的主鍵值記下來，之後回滾的時候只需要把這個主鍵值對應的記錄刪掉。</span></span></span></span></li><li><span><span><span><span>刪除了一條記錄，至少要把這條記錄中的內容都記下來，這樣之後回滾時再把由這些內容組成的記錄插入到表中。</span></span></span></span></li><li><span><span><span><span>修改了一條記錄，至少要把修改這條記錄前的舊值都記錄下來，這樣之後回滾時再把這條記錄更新為舊值。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這些為了回滾而記錄的這些東西稱之為撤銷日誌，即：undo log。這裏需要注意的一點是，由於查詢操作並不會修改任何用户記錄，所以在查詢操作執行時，並不需要記錄相應的 undo log。</span></span></span></p><span id="OSC_h3_18"></span><h3><span><span><span>undo 日誌的格式</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>為了實現事務的原子性，InnoDB 存儲引擎在實際進行增、刪、改一條記錄時，都需要先把對應的 undo 日誌記下來。一般每對一條記錄做一次改動，就對應着一條 undo 日誌，但在某些更新記錄的操作中，也可能會對應着 2 條 undo 日誌。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>一個事務在執行過程中可能新增、刪除、更新若干條記錄，也就是説需要記錄很多條對應的 undo 日誌，這些 undo 日誌會被從 0 開始編號，也就是説根據生成的順序分別被稱為第 0 號 undo 日誌、第 1 號 undo 日誌、...、第 n 號 undo 日誌等，這個編號也被稱之為 undo no。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這些 undo 日誌是被記錄到類型為 FIL_PAGE_UNDO_LOG 的頁面中。這些頁面可以從系統表空間中分配，也可以從一種專門存放 undo 日誌的表空間，也就是所謂的 undo tablespace 中分配。</span></span></span></p><blockquote><p>作者：京東物流，張士欣</p><p>來源：京東雲開發者社區，自圓其説 Tech 轉載請註明來源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 02:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10142911</guid>
            <link>https://my.oschina.net/u/4090830/blog/10142911</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[🎁有獎問答 | 從 kkFileView 項目出發，聊聊怎麼做開源項目]]>
            </title>
            <description>
                <![CDATA[<h1 class="header article-title"><a href="https://www.oschina.net/question/4700705_2331356">高手問答第 309 期 —— 從 kkFileView 項目出發，聊聊怎麼做開源項目</a><div class="ui red label horizontal" data-tooltip="置頂">頂</div></h1><div class="extra ui horizontal list meta-wrap"><div class="item"><a href="https://my.oschina.net/u/4700705" class="__user"><span>小白兔愛吃大灰狼</span></a> 發佈於，前天 17:36
                    </div><div class="item">閲讀 703</div><div class="item collect-btn " data-id="2331356" data-user-id="4700705" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i> 收藏 <span data-collect-count="" data-id="2331356" data-obj-type="2">0</span></div><div class="item comment-count"><a href="https://www.oschina.net/question/4700705_2331356#comments" class="normal"><i class="comment outline icon"></i> 答案 <span data-article-reply-count="">5</span></a></div></div><div class="tags"><a class="ui horizontal label" href="https://www.oschina.net/question/topic/masteronline" target="_blank"><img src="https://static.oschina.net/uploads/logo/masteronline_9WTeU.png" referrerpolicy="no-referrer">高手問答</a></div><div class="content" id="articleContent"><p><span><span>開源項目是每一個開發者無法繞過的一個詞，無論你是否主動接觸開源項目，他就在你身邊，和你的工作息息相關。本期嘉賓 KL 博主 6 年前一次偶然的機會接觸開源項目後，彷彿打開了代碼世界的大門，打通了任督二脈。這裏有書本上，你在公司裏沒有的知識和能量。從開源獲取，然後反饋開源，是博主一直踐行的開源原則，截止目前，博主開源了數 10+ 的項目，也參與了很多社區的項目，比如 apollo 、skywalking 、seata 等。其中 kkFileView 是博主開源最成功的一個項目，目前 kkFileView 獲得過開源中國 GVP 項目，在 Gitee 的所有推薦項目裏的 star 排名第 10 ，19281 個 star。kkFileView 一直保持着開源的初心，踐行着佛性開源的路子做着開源項目。也因為如下：</span></span></p><ul><li><span><span>好的開源項目一定是架構優良可持續擴展優化的</span></span></li><li><span><span>好的開源項目一定是有需求場景，解決實際問題的</span></span></li><li><span><span>好的開源項目一定是有經濟支撐可持續維護迭代的</span></span></li><li><span><span>好的開源項目一定是説明齊全，容易上手的</span></span></li></ul><p><span><span>kkFileView 可以一直健康發展迭代。</span></span></p><blockquote><p><span><span>kkFileView 項目地址：</span><a href="https://gitee.com/kekingcn/file-online-preview" target="_blank" rel="nofollow">https://gitee.com/kekingcn/file-online-preview</a></span></p></blockquote><p><strong><span><span>OSCHINA 本期高手問答（11 月 15 日-11 月 21 日）將以「從 kkFileView 項目聊聊怎麼做開源項目」為切入點，聊一聊怎麼做好開源項目，可討論的內容包括帶不限於以下：</span></span></strong></p><ul><li><span><span>怎麼參與開源項目</span></span></li><li><span><span>怎麼上手一個新的開源項目</span></span></li><li><span><span>怎麼開源一個自己的開源項目</span></span></li><li><span><span>kkFileView 項目相關話題</span></span></li><li><span><span>怎麼從開源項目裏學以致用</span></span></li><li><span><span>等等</span></span></li></ul><p><span style="background-color:#ffffff; color:#000000">有其他相關問題，也歡迎大家積極提問！</span></p><h1>嘉賓簡介</h1><p><span><span style="color:#000000">陳凱玲，網名：KL，在社區裏一直以」KL 博主「自稱。先後就職於凱京集團和 TapTap，一直從事 Java 架構、中間件、SRE 等開發工作。是開源項目 kkFileView&nbsp; 作者，也是 Apollo 配置中心社區的 PMC。</span></span></p><ul><li><span><span style="color:#000000">Gitee 主頁：</span><a href="https://gitee.com/kailing" target="_blank" rel="nofollow">https://gitee.com/kailing</a></span></li><li><span><span>OSC 主頁：</span><a href="https://my.oschina.net/klblog" target="_blank" rel="nofollow">https://my.oschina.net/klblog</a></span></li><li><span><span>個人博客：</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.kailing.pub%2F" target="_blank" rel="nofollow">http://www.kailing.pub/</a></span></li></ul><p><span><img alt="" height="533" src="https://oscimg.oschina.net/oscnet/up-25fffd13ffa4a26b83d8d969dd57c9be8ce.jpg" width="400" referrerpolicy="no-referrer"></span></p><p><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>為了鼓勵踴躍提問，我們會在問答結束後從提問者中抽取 5 名幸運會員贈予定製開源魔方一個</span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>！</span></span></span></span></span></span></span></span></p><p><img alt="" height="356" src="https://oscimg.oschina.net/oscnet/up-d8b90a25d803f6b37329dec2c8bae8bdd2c.jpg" width="400" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#27ae60">OSChina 高手問答一貫的風格，不歡迎任何與主題無關的討論和噴子。</span></p><p>下面歡迎大家就「怎麼做好開源項目」<span>相關</span>問題向 <a href="https://my.oschina.net/klblog" rel="nofollow"><strong>KL 博主</strong><strong><span style="color:#000000">&nbsp;</span></strong></a>提問，直接回帖提問既可。</p></div><div class="poll-wrap"></div><div class="additional-remarks"></div><div class="ui basic center aligned segment action"><div class="ui big buttons"><a class="ui basic button collect-btn hover" data-id="2331356" data-user-id="4700705" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i>收藏 (<span data-collect-count="" data-id="2331356" data-obj-type="2">0</span>)</a><div class="ui basic dropdown share button osc-share dropdown-share" data-tag="share-question"><i class="share icon"></i><span>分享</span><div class="menu"><a class="item" data-platform="weibo" data-value="weibo"><i class="weibo icon"></i>微博</a><a class="item" data-platform="qq" data-value="qq"><i class="qq icon"></i>QQ</a><a class="item" data-platform="wechat" data-value="wechat"><i class="weixin icon"></i>微信</a></div></div></div><div class="ui basic segment"><a class="ban" ban-report="" data-id="2331356" data-obj-type="2" data-url="https://www.oschina.net/question/4700705_2331356"><i class="flag red icon"></i>舉報</a></div></div>
            ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 02:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/question/4700705_2331356</guid>
            <link>https://www.oschina.net/question/4700705_2331356</link>
        </item>
    </channel>
</rss>
