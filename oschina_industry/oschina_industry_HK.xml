<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>開源中國-綜合資訊</title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="http://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml"></atom:link>
        <description>開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)</description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>en</language>
        <lastBuildDate>Wed, 27 Mar 2024 13:06:00 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>武漢大學開設「雷軍班」：計算機專業、今年招收 15 名本科生</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;3 月 25 日，武漢大學官網對校長張平文調研計算機學院進行了報道，文章提到：「就雷軍班和機器人系建設方面，張平文希望學院提高站位、佈局未來，發揮雷軍校友捐贈的重要作用，凝心聚力早日把計算機學院建成國內知名、世界一流的學術高地。」&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-10c5c2cfd163009c4db026c83070c834fad.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;不少網友好奇，雷軍班是個什麼情況，跟企業家雷軍有什麼關係？&lt;/p&gt; 
&lt;p&gt;3 月 27 日，武漢大學計算機學院辦公室工作人員迴應記者稱：「&lt;strong&gt;在今年高考後，雷軍班將向全國招 15 名本科生，屬於計算機專業，吸納最優秀的有志向的學生就讀，本博貫通培養。&lt;/strong&gt;」&lt;/p&gt; 
&lt;p&gt;工作人員強調：「與其他普通本科班相比，這個班肯定是不一樣的。整個培養方面的各個環節都是高配置。」&lt;/p&gt; 
&lt;p&gt;另據武漢大學計算機學院官網 1 月 8 日報道，計算機學院院長杜博曾表示，「雷軍校友捐贈除了助力基礎學科研究和支持大學生培養，主要資助計算機學科發展和計算機領域科技創新。學院將加強師資力量，傳承人才培養優良傳統，發揚雷軍的創新精神，設立雷軍班，把有計算機天賦和有創新、創意、創業的優秀人才招進來。」&lt;/p&gt; 
&lt;p&gt;武漢大學是小米創始人雷軍的母校，他在去年 11 月 29 日的武漢大學 130 週年校慶日上宣佈，&lt;strong&gt;個人向母校捐贈 13 億元人民幣，刷新武大建校以來單筆最大捐贈額。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ddcdda06e0737310208f9c2696171fdb78b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;當時雷軍表示，此次捐贈主要聚焦三個方向：支持數理化文史哲六大學科基礎研究、支持計算機領域科技創新、支持大學生培養。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284988</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284988</guid>
            <pubDate>Wed, 27 Mar 2024 08:35:37 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>微軟任命新的 Windows 和 Surface 負責人</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;微軟任命 Pavan Davuluri 為新任 Windows 和 Surface 主管。去年，在前負責人&amp;nbsp;Panos Panay 跳槽前往亞馬遜之後，微軟就將 Windows 和 Surface 部門拆分為兩個不同的領導團隊；由&amp;nbsp;Davuluri 接管了 Surface 相關工作，Windows 方面則由 Mikhail Parakhin 進行領導。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;時至今日，該公司又將 Windows 和 Surface 整合，統一交由都將由 Davuluri 負責。微軟體驗和設備執行副總裁 Rajesh Jha 在一份內部備忘錄中&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2024%2F3%2F25%2F24111931%2Fmicrosoft-windows-surface-pavan-davuluri&quot; target=&quot;_blank&quot;&gt;解釋稱&lt;/a&gt;，因為 Parakhin 現在正在&quot;探索新的角色&quot;，但他並沒有有明確指出是在微軟內部還是外部。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Jha 在備忘錄中概述了新的 Windows 組織架構。指出 Davuluri 將領導一個合併的 Windows 和設備團隊，作為 Experiences + Devices (E+D) 部門的&quot;核心部分&quot;。「這將使我們能夠採取整體方法來構建跨 Windows 客户端和雲的芯片、系統、體驗和設備，以適應這個 AI 時代。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;333&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-90467fe07ce648d6b571892737ebc09c654.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;以下是 Rajesh Jha 的備忘錄全文：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;我想分享繼上週宣佈並創建 Microsoft AI 組織之後 Windows 和 Web Experiences (WWE) 團隊的最新動態。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Mikhail Parakhin 決定探索新角色。Satya 和我對 Mikhail 的貢獻和領導表示感謝，並感謝他為幫助微軟引領新人工智能浪潮所做的一切。他將向 Kevin Scott 彙報工作，同時支持 WWE 的過渡。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;作為此變更的一部分，我們將 Windows Experiences 和 Windows + Devices 團隊合併為 Experiences + Devices (E+D) 部門的核心部分。這將使我們能夠採取整體方法來構建這個人工智能時代跨越 Windows 客户端和雲的芯片、系統、體驗和設備。 Pavan Davuluri 將領導這個團隊並繼續向我彙報。 Shilpa Ranganathan 和 Jeff Johnson 及其團隊將直接向 Pavan 彙報。 Windows 團隊將繼續與 Microsoft AI 團隊在 AI、芯片和體驗方面密切合作。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Web Experiences 團隊將向新的 Microsoft AI 組織中的 Mustafa 彙報工作。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Jordi Ribas 將領導搜索、地圖和平台業務，Andrey Proskurin、Fatima Kardar 和 Nick Lee 向他彙報。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Rukmini Iyer 將領導廣告部，Paul Viola 和 Weiqing Tu 向她彙報。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Mike Davidson 繼續領導設計部門，並將與 Pavan 和團隊合作研究如何重新調整 Windows 設計。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Ali Akgun、Kya Sainsbury-Carter、Zhang Qi 和 Rajesh Sundaram 的角色保持不變。他們將與 Jordi、Mike 和 Rukmini 一起加入 Microsoft AI 領導團隊，全部向 Mustafa 彙報。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;我們很高興這個團隊能夠幫助 Microsoft AI 實現其打造世界一流的消費者 AI 產品的大膽雄心。我非常期待與 Mustafa 及其團隊密切合作，將包括 Copilot 在內的 AI 產品廣泛應用於我們的 E+D 產品和服務中。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Thanks,&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Rajesh&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284970/microsoft-windows-surface-pavan-davuluri</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284970/microsoft-windows-surface-pavan-davuluri</guid>
            <pubDate>Wed, 27 Mar 2024 07:39:43 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>日本政府稱有朝鮮 IT 人員冒充日本人接外包賺外匯</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;日本政府 26 日發佈了一份提醒國內 IT 相關企業注意的文件，指出疑似有朝鮮 IT 技術人員冒充日本人，在網上承接 IT 相關業務訂單。聯合國等表示，為了賺取外匯用於核與導彈開發，朝鮮正在利用技術人員。據稱，若把業務發包給此類人員，可能違反《外匯法》等。&lt;/p&gt; 
&lt;p&gt;文件由警察廳、外務省、財務省、經濟產業省聯名發佈。美國和韓國去年 10 月發出了類似提醒，日本則是首次。警察廳幹部透露稱「在日本也發現了案例，威脅高漲」。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2023/1023/112217_pba9_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;該文件等顯示，朝鮮技術人員在為 IT 相關業務發包方和自由技術人員提供中介服務的網站上，或者偽造身份，或者通過住在日本的親戚等進行註冊。據稱，他們大多在中國和俄羅斯工作並賺取報酬。&lt;strong&gt;其特點包括不參加視頻會議、頻繁變更收款賬户、使用的日語不地道等&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;在日本，神奈川縣警方等 6 日以涉嫌違規領取失業補貼為由，逮捕了廣島縣 IT 相關公司社長等人。警方認為其有可能把業務發包給了朝鮮技術人員，正在查明案情。神奈川縣警方的調查中還發現，2022 年，另外的朝鮮技術人員以熟人名義承接了兵庫縣防災 APP 修改業務等。&lt;/p&gt; 
&lt;p&gt;延伸閲讀：&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/news/262984/north-korea-it-workers-remote-work&quot; target=&quot;_blank&quot;&gt;朝鮮 IT 開發者為美國公司從事遠程外包工作&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284953</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284953</guid>
            <pubDate>Wed, 27 Mar 2024 06:44:13 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>蘋果和中國百度尚未達成人工智能技術供應協議</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;此前有報道稱蘋果公司已與百度達成合作，將在該地區使用百度的大模型 AI 功能。但現在又有消息稱，雙方並未達成這樣的協議。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-2550020989aa58a4082d974f67ffa94e71c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.chinastarmarket.cn%2Fdetail%2F1628550&quot; target=&quot;_blank&quot;&gt;https://www.chinastarmarket.cn/detail/1628550&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;《中國日報》指出，這些早先的報道不正確。該刊物稱，蘋果和百度尚未就人工智能合作達成一致，它是從熟悉蘋果公司運作的消息來源獲得這一信息的。有關兩家公司已達成協議的報道只是媒體的猜測。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-5cf43246dfdeb31ea068b82961ff89dc3e3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.chinadaily.com.cn%2Fa%2F202403%2F26%2FWS6602b2c1a31082fc043bec68.html&quot; target=&quot;_blank&quot;&gt;https://www.chinadaily.com.cn/a/202403/26/WS6602b2c1a31082fc043bec68.html&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;不過無論蘋果公司目前簽訂的任何合同的具體情況如何，至少該公司很可能會與中國公司合作，這樣做容易避免潛在的監管問題。&lt;/p&gt; 
&lt;p&gt;百度股價在最初的報道中上漲了 2.55%。百度和蘋果公司均未對此發表評論。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284945</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284945</guid>
            <pubDate>Wed, 27 Mar 2024 06:08:20 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>Linux 6.9 棄用 ext2 文件系統驅動程序</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在即將發佈的 6.9 Linux 內核中，ext2 文件系統驅動程序將被標記為已&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Fcommit%2F%3Fid%3Db960e8093e7a57de98724931d17b2fa86ff1105f&quot; target=&quot;_blank&quot;&gt;棄用&lt;/a&gt;。EXT2 第二代擴展文件系統是 Linux 內核所用的文件系統，最開始由 Rémy Card 設計用以代替 ext，於 1993 年 1 月加入 Linux 核心支持之中，至今已有三十多年的歷史。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Linux 開發人員 Michael Opdenacker 解釋稱，ext2 被棄用的主要原因在於，即使文件系統是用 256 字節的 inodes（mkfs.ext2 -I 256）創建的，文件系統驅動程序也會堅持使用 32 位日期。因此，驅動程序不支持超過 2038 年 1 月 19 日 03:14:07 UTC 的 inode 時間戳。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;對於仍在使用 ext2 及其驅動程序，並且系統日期正確設置為截止日期之前最多 30 年的日期的用户，將收到此警告：&lt;/span&gt;&lt;/p&gt; 
&lt;pre style=&quot;margin-left:0; margin-right:0; text-align:start&quot;&gt;# mount -t ext2 /dev/sda1 /mnt
[  441.680685] ext2 filesystem being mounted at /mnt supports timestamps until 2038-01-19 (ox7fffffff)&lt;/pre&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;由於無法正確支持 2038 年 1 月 19 日之後的時間戳。官方建議 ext2 用户升級到使用 ext4 驅動程序來訪問其文件系統，ext4 文件系統驅動程序與 ext2 完全兼容。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;416&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-9b1cc7bffe503a4e97379da4df9747b64d9.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;更多詳情可查看此&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbootlin.com%2Fblog%2Fext2-filesystem-driver-now-marked-as-deprecated%2F&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284942/ext2-deprecat-linux-6-9</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284942/ext2-deprecat-linux-6-9</guid>
            <pubDate>Wed, 27 Mar 2024 05:50:46 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>開源日報 | AI PC 的價值到底在哪？Windows 格式化對話框的 UI 用了 30 年；醜頭像生成器；獨立的 Redis Copyleft 分支</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;歡迎閲讀 OSCHINA 編輯部出品的開源日報，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#e67e22&quot;&gt;&lt;strong&gt;# 2024.3.26&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日要點&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;OpenSource Daily&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284729/inkscape-switches-to-gtk4&quot; target=&quot;_blank&quot;&gt;開源圖形編輯器 Inkscape 底層 UI 框架改用 GTK4&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;矢量圖形編輯器 Inkscape 開發分支的最新上游代碼已遷移至使用 GTK4，這是一次重大升級，同時也改進了架構，併為將來實現 GPU 加速做好了準備。&lt;/p&gt; 
&lt;p&gt;Inkscape 通過其 Mastodon 賬户宣佈了向 GTK4 過渡的消息。由於各種問題，尤其是在 macOS 和 Windows 上的問題，下一個穩定版本（v1.4）仍將使用 GTK3。&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284749/redict-independent-fork-redis&quot; target=&quot;_blank&quot;&gt;Redict：一個獨立的 Redis Copyleft 分支&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;Redict 是由開發者 Drew DeVault 推出的一個 Redis OSS 7.2.4.2 的獨立、非商業性的分叉。基於 Redis OSS 的 BSD 3-Clause 源代碼，自此之後的所有更改均採用 Lesser GNU General Public license（LGPL-3.0-only）。&lt;/p&gt; 
&lt;p&gt;Redict 旨在作為 Redis OSS 7.2.4 的直接替代品。接下來，Redict 的目的是繼續開發 Redis OSS 兼容軟件的自由軟件發行版，暫時只進行最小程度的破壞性更改。&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日觀察&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img height=&quot;1142&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-720920b89166e12e4474df21d15cdb13e1d.png&quot; width=&quot;3290&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- &lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sohu.com%2Fa%2F766955186_166680&quot; target=&quot;_blank&quot;&gt;集微網&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-df160bed3a4a1edeecfaf0ea94367e6ffce.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微博&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1834645454%2FO6OaUrIXM&quot; target=&quot;_blank&quot;&gt;dingtingli&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;今日推薦&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-3dd733b17408eabbeef0376a1b161484ca2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ftxstc55%2Fugly-avatar&quot; target=&quot;_blank&quot;&gt;https://github.com/txstc55/ugly-avatar&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;事件點評&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-bce40dbed054e00f3808407c9d3f805a8b7.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;每日項目榜&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;每日 GitHub 精選&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-4f54b79a6c20ed322ca67c7d78f425b439b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;在線閲讀完整日報內容，訪問：&lt;/span&gt;&lt;/strong&gt;&lt;br&gt; &lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://report.oschina.net/api/files/jhim80u9qm1ofsw/sq4hlnesqz46pu8/37_ai_pc_windows_ui_30_redis_copyleft_jwb07bWFPR.pdf&quot; target=&quot;_blank&quot;&gt;開源日報第 037 期：AI PC 的價值到底在哪？Windows 格式化對話框的 UI 用了 30 年；醜頭像生成器；獨立的 Redis Copyleft 分支&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/h4&gt; 
&lt;/blockquote&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;歡迎掃碼下載「開源中國 APP」&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;隨時在線閲讀完整日報內容 ↓&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7871d27245192b8ecfcd21043d309382749.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;889&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-842e51ced6d226559af1af95c8041338cb2.gif&quot; width=&quot;400&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284926</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284926</guid>
            <pubDate>Wed, 27 Mar 2024 03:28:20 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>羅永浩本週日晚將首度直播賣「雲」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;阿里雲官微宣佈，羅永浩將於 3 月 31 日晚首次淘寶直播賣雲，選品涵蓋雲服務器、雲存儲及企業網盤等熱門阿里雲產品，重點面向創業者及中小企業羣體。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;475&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d2c9f7747404286dff54e6e9df56b4abb39.webp&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此前的 2 月 29 日，阿里雲宣佈全線降價 20%。根據阿里雲官網報價數據顯示，降價清單中的雲服務器 ECS 最高降 36%、對象存儲 OSS 最高降 55%、雲數據庫 RDS 最高降 40%，都是雲上用户使用頻率最高的核心產品。此次史上最大規模降價引發了一波中小企業上雲熱潮。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;最近披露的財報顯示，阿里雲正通過減少利潤率較低的項目制合約類收入，持續提高收入質量。阿里雲智能集團資深副總裁、公共雲事業部總裁劉偉光此前表示，阿里雲期待與行業共同鑄造中國雲計算產業的規模效應。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284923</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284923</guid>
            <pubDate>Wed, 27 Mar 2024 03:10:20 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>適用於原生 Arm64 設備的 Chrome 即將發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;谷歌與高通公司（Qualcomm）共同&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2024%2F3%2F26%2F24112273%2Fchrome-native-windows-on-arm-qualcomm-snapdragon&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;，將於本週發佈針對 Windows on Arm 的 Chrome 瀏覽器優化版。事實上早在兩個月前，就曾有用户在 Chrome 瀏覽器的 Canary 頻道發現過該瀏覽器的早期版本，現如今谷歌終於正式將其正式推出。高通公司表示，該版本&quot;將從今天開始推出&quot;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;292&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-6bba083617132dcd93860160703973230b4.webp&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;對於使用基於 Arm 處理器的 Windows 機器的 Chrome 瀏覽器用户來説，該版本的發佈將是一件大事，因為他們現在可以使用速度更快的原生瀏覽器了。相比之下，他們以前只能在模擬狀態下運行性能緩慢的 x64 版 Chrome 瀏覽器。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;高通最新推出的基於 Arm 的 Windows 處理器被稱為驍龍 X Elite（Snapdragon X Elite），預計將於今年夏天上市，據稱將帶來不俗的性能表現。谷歌經過 Arm 優化的 Chrome 瀏覽器在技術上可以在任何基於 Arm 的 Windows PC 上運行，與處理器製造商無關，但高通公司是目前唯一一家為 Windows 生產基於 Arm 處理器的公司。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;谷歌公司的 Hiroshi Lockheimer 表示：「我們設計的 Chrome 瀏覽器快速、安全且易於在台式機和移動終端上使用。我們與高通公司的密切合作將有助於確保 Chrome 瀏覽器用户在當前 Arm 兼容 PC 上瀏覽網頁時獲得最佳體驗。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;這並不是谷歌第一次發佈經過 Arm 優化的 Chrome 瀏覽器版本，早在 2020 年，谷歌就為蘋果基於 Arm 的 Mac 發佈了原生版本的瀏覽器。長期以來，這家搜索巨頭還在 ChromeOS 中為 Chromebook 提供基於 Arm 處理器的支持。但是，在以消費者為中心的 Surface 設備有望全面轉向 Arm 的這一年，為 Windows 發佈基於 Arm 的世界上最流行的 Windows 瀏覽器原生版本，將極大地推動 Windows on Arm 的發展。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284903/chrome-native-arm-based-windows-pc</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284903/chrome-native-arm-based-windows-pc</guid>
            <pubDate>Wed, 27 Mar 2024 02:03:39 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>Java 8 內存管理原理解析及內存故障排查實踐</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                    &lt;div class=&quot;rich_media_content js_underline_content
                       autoTypeSetting24psection
            &quot; id=&quot;js_content&quot;&gt; 
 &lt;section style=&quot;font-size: 15px;line-height: 1.6;&quot;&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;作者：vivo 互聯網服務器團隊-&amp;nbsp; Zeng Zhibin&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;&quot;&gt; 
    &lt;section style=&quot;text-align: left;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);&quot;&gt; 
      &lt;p style=&quot;text-wrap: wrap;&quot;&gt;介紹 Java8 虛擬機的內存區域劃分、內存垃圾回收工作原理解析、虛擬機內存分配配置，介紹各垃圾收集器優缺點及場景應用、實踐內存故障場景排查診斷，方便讀者面臨內存故障時有一個明確的思路和方向。&lt;/p&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
    &lt;section style=&quot;margin-right: 0%;margin-bottom: -5px;margin-left: 0%;text-align: right;line-height: 1;font-size: 5px;transform: translate3d(5px, 0px, 0px);&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;width: 0px;display: inline-block;vertical-align: top;border-bottom: 0.6em solid rgb(160, 160, 160);border-right: 0.6em solid rgb(160, 160, 160);border-top: 0.6em solid transparent !important;border-left: 0.6em solid transparent !important;&quot;&gt; 
      &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;一、背景&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 是一種流行的編程語言，可以在不同的操作系統上運行。它具有跨平台、面向對象、自動內存管理等特點，Java 程序在運行時需要使用內存來存儲數據和程序狀態。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 的自動內存管理機制是由 JVM 中的垃圾收集器來實現的，垃圾收集器會定期掃描堆內存中的對象，檢測並清除不再使用的對象，以釋放內存資源。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 的自動內存管理機制帶來了許多好處，首先，它可以避免程序員手動管理內存時的錯誤，例如內存泄漏和懸空指針等問題。其次，它可以提高程序的運行效率，因為程序員不需要頻繁地手動分配和釋放內存，而是可以將更多時間和精力專注於程序的業務邏輯，最後，它可以提高程序的可靠性和穩定性，因為垃圾收集器可以自動檢測和清除不再使用的內存資源，避免內存溢出等問題。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;瞭解和掌握垃圾收集器原理可以幫助提高程序的性能、穩定性和可維護性。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;font-size: 14px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;名詞解釋：&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;響應速度&lt;/strong&gt;：響應速度指程序或系統對一個請求的響應有多迅速。比如，用户查詢數據響應時間，對響應速度要求很高的系統，較大的停頓時間是不可接受的。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;：吞吐量關注在一個特定時間段內應用系統的最大工作量，例如每小時批處理系統能完成的任務數量，在吞吐量方面優化的系統，較長的 GC 停頓時間也是可以接受的，因為高吞吐量應用更關心的是如何儘可能快地完成整個任務，不考慮快速響應用户請求。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;GC 導致的應用暫停時間影響系統響應速度，GC 處理線程的 CPU 使用率影響系統吞吐量。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;二、Java&amp;nbsp;8&amp;nbsp;的內存管理&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;2.1 JVM（Java 虛擬機）內存劃分&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 運行時數據區域劃分，Java 虛擬機在執行 Java 程序時，將其所管理的內存劃分為不同的數據區域，每個區域都有特定的用途和創建銷燬的時間。其中，有些區域在虛擬機進程啓動時就存在，而有些區域則是隨着用户線程的啓動和結束而建立和銷燬。這些數據區域包括程序計數器、虛擬機棧、本地方法棧、堆、方法區等，每個區域都有其自身的特點和作用。瞭解這些數據區域的使用方式和特點，可以更好地理解 Java 虛擬機的內存管理機制和運行原理。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;JVM 的內存區域劃分可分為：1.堆內存空間、2.Java 虛擬機棧區域、3.程序計數器、4.本地方法棧、5.元空間區域、6.直接內存。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014615&quot; data-ratio=&quot;0.774074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/1e56b454-4e41-465a-8ba6-8c53e10fc02c.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014616&quot; data-ratio=&quot;0.9365079365079365&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/ec4c9ff4-4b80-46ad-aff9-ce2ce396b38b.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1008&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;堆內存空間&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;：JVM 中佔用內存空間最大的是堆，平常對象的創建大部分都是在堆上分配內存的，是垃圾回收的主要目標和方向。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;本地方法棧區域&lt;/strong&gt;：Native Mehod Stack 與 Java 虛擬機棧的作用非常相似，區別是 Java 虛擬機棧為虛擬機執行 Java 方法或者為字節碼而服務，本地方法棧是為了 Java 虛擬機棧得到 Native 方法。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;Java 虛擬機棧區域&lt;/strong&gt;：負責 Java 的解釋過程、程序的執行過程、入棧和出棧，它是與線程相關的，當啓動一個新的線程時，Java 程序就會分配一個 Java 虛擬機棧提供運行；Java 虛擬機棧從方法入棧到具體字節碼執行是一個雙層棧結構，可以棧裏包含棧。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;程序計數器&lt;/strong&gt;：記錄線程執行位置，線程私有，因為操作系統不停的調度，無法獲取到線程被調度之前的位置，程序計數器提供了這樣一個線程執行位置。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;元空間區域&lt;/strong&gt;：在原來的老的 Java 7 之前劃分中，永久代用來存放類的元數據信息、靜態變量以及常量池等。在現在 Java8 後類的元信息存儲在元空間中，靜態變量和常量池等併入堆中，相當於原來的永久代中的數據，被元空間和堆內存給瓜分了。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;直接內存&lt;/strong&gt;：使用了 Java 的直接內存的 API 的內存，例如緩衝 ByteBuffer，可以控制虛擬機參數調整大小，而本地內存是使用了 native 函數操作的內存，是不受 JVM 管理控制。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;堆內存空間&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;JVM 回收的主要目標是堆內存，對象主要的創建分配內存在堆上進行，堆可以想象成一個對象池子，對象不停創建放入池子中，而 JVM 垃圾回收是不停的回收池子中一些被標記為可回收對象的對象，啓動回收線程進行打掃戰場，當回收對象的速度趕不上程序的創建時，池子就會立馬滿，當滿了之後從而發生溢出，就是常見的 OOM。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;GC 的速度和堆的內存中存活對象的數量有關，與堆內存所有的對象無關，GC 的速度和堆內存的大小無關，如一個 4GB 大小的堆內存和一個 16GB 的堆內存，只要 2 個堆內存存活對象都是一樣多的時候，GC 速度都是基本差不多。每次垃圾回收也不是必須要把垃圾清理乾淨，重要的是保證不把正在使用的對象給標記清除掉。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;2.2 堆內存管理&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;JVM 中佔用內存空間最大的是堆內存，平常對象的創建大部分都是在堆上分配內存的，是 Java 垃圾回收的主要目標和方向、是 Java 內存管理機制的核心組成部分，它可以自動管理 Java 程序的內存分配和釋放，Java 垃圾收集器可以自動檢測和回收不再使用的內存，以便重新分配給其他需要內存的程序。這種自動內存管理的機制可以提高程序的運行效率和可靠性，防止因內存泄漏等問題導致程序崩潰或性能下降，Java 垃圾收集器使用了不同的垃圾回收算法和垃圾收集器實現，以適應不同的應用場景和需求。Java 垃圾收集器的性能特徵和優化技術也是 Java 程序員需要了解和掌握的重要知識。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;因此，瞭解 Java 垃圾回收的背景、原理和實踐經驗對於編寫高效、可靠的 Java 程序非常重要。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.1 對象如何被判斷為可回收&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;JVM 怎麼判斷堆內存裏面的對象是否可回收的，就是當一個對象沒有任何引用指向它了，它就是可回收對象，判斷的方式有兩種算法，一個是引用計數法，一個是可達性分析法。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;可回收對象：&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;424&quot; data-imgfileid=&quot;100014617&quot; data-ratio=&quot;0.7333333333333333&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/891ef4a1-7e31-4cc2-81d3-8e27a1779354.jpg&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;width: 578px;height: 424px;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（1）引用計數法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;給對象中添加一個引用計數器，每當有一個地方引用它時，這個計數器值加一，當引用失效斷開時，計數器值就減一，在任何時刻時計數器為 0 的時候，代表這個對象是可以被回收的，沒有任何引用使用它了。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014618&quot; data-ratio=&quot;0.6796296296296296&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/bce27aab-824a-4e0d-ab6b-789c5e0799ba.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;引用計數法是有缺點，當對象直接互相依賴引用時，這些對象的計數器都不能為 0，都不能被回收。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（2）可達性分析法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;它使用 tracing（鏈路追蹤）方式尋找存活對象的方法，通過一些列稱為「GC Roots」的對象作為初始點，從這些初始點開始向下查找，直到向下查找沒有任何鏈路時，代表這個對象可以被回收，這種算法是目前 Java 唯一且默認使用來判定可回收的算法。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014620&quot; data-ratio=&quot;0.6796296296296296&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/0f23e95f-e8c9-4525-8d62-34b5ac4636b4.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.2 GC Roots 的概念和對象類型&lt;/strong&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ol class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: decimal;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;Java 虛擬機棧中引用的對象，例如各個線程被調用的方法棧用到的參數、局部變量或者臨時變量等。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;方法區的靜態類屬性引用對象或者説 Java 類中的引用類型的靜態變量。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;方法區中的常量引用或者運行時常量池中的引用類型變量。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;JVM 內部的內存數據結構的一些引用、同步的監控對象（被修飾同步鎖）。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;JNI 中的引用對象。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ol&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;當然，被 GC Roots 追溯到的對象不是一定不會被垃圾回收，具體需要看情況，Java 對象與對象引用存在四種引用級別：分別是強引用、軟引用、弱引用、虛引用，默認的對象關係是強引用，只有在和 GCRoots 沒有關係時才會被回收；軟引用用於維護一些可有可無的對象，當內存足夠時不會被回收；弱引用只要發生了垃圾回收就會被清理；虛引用人如其名形同虛設，任何對象都與它無關。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.3 垃圾對象回收算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;當 JVM 定位到了那些對象可回收時，這個時候是通過三個算法標記清除，分別是標記清除算法、複製算法、標記壓縮算法。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（1）標記清除算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;首先標記出所有需要回，收的對象，在標記完成後，統一回收掉所有被標記的對象，但是該算法缺點是執行效率低，當大量對象時需要大量標記和清理動作，而且容易產生內存碎片化，當需要一塊連續內存時，會因為碎片化無法分配。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014621&quot; data-ratio=&quot;0.2324074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/d964fb76-5184-4844-a6a8-c1e2e8c0d9a0.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（2）標記壓縮算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;標記壓縮算法跟清除算法很像，只不過它對內存進行了整理， 讓存活對象都向內存空間的一端移動，然後將邊界的其它對象全部清理，這樣能達到內存碎片化問題，不過它比清除算法多了移步動作。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014622&quot; data-ratio=&quot;0.1527777777777778&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/eb4ba1e3-b7b5-42f5-9087-2567b4355f6d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（3）複製算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;為瞭解決標記-清除算法面對大量可回收對象時執行效率低的問題，將存活對象複製到一塊空置的空間裏，然後將原來的區域全部清理，缺點是需要額外空間存放存活對象。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014623&quot; data-ratio=&quot;0.3425925925925926&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/a0b97901-6eeb-445a-8dd8-46b6bc0481ce.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.4 分代垃圾回收模型概念和原理&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;堆內存分代模型圖&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014624&quot; data-ratio=&quot;0.25277777777777777&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/5f8f3b05-14d8-4730-9825-0dbb1e914d4f.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;當 JVM 進行 GC（垃圾回收）時，JVM 會發起「Stop the world」，所有的業務線程都進行停止，進入 SafePoint 狀態，JVM 回收垃圾線程開始進行標記和追溯，如何解決這種停止和如何減少 STW 的時間呢？&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;目前主流垃圾收集器採用分代垃圾回收方式，大部分對象的聲明週期都比較短，只有少部分的對象才存活的比較長，分代垃圾回收會在邏輯上把堆內存空間分為兩部分，一部分為年輕代，一部分為老年代。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;（1）年輕代空間&lt;/strong&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;年輕代主要是存放新生成的對象，一般佔用堆空間的三分之一空間，因為會頻繁創建對象，所以年輕代 GC 頻率是最高的。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;分為 Eden 空間、Survivor1（from）區、Survivor2（to）區，S1 和 S2 總要有一塊空間是空的，為了方便年輕代存活對象來回存放，晉升存活對象年齡。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;三個區的默認比例是 8:1:1，可以通過配置參數調整比例。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;年輕代回收發起 Minor GC（YongGC），當 Eden 內存區域被佔滿之後就發起 GC，短暫的 STW，基於垃圾收集器。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;（2）老年代空間&lt;/strong&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;是堆內存中最大的空間， ，裏面的對象都是比較穩定或者老頑固，GC 頻率不會頻繁執行。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014625&quot; data-ratio=&quot;0.4685185185185185&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/b655ab3a-9352-4372-b97a-570be86cd06d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;老年代對象：&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ol class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: decimal;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;正常提升&lt;/strong&gt;：由年輕代存活對象年齡到達閾值時，這個對象則會被移動到老年代中。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;分配擔保&lt;/strong&gt;：如果年輕代中的空間不足時，此時有新的對象需要分配對象空間，需要依賴其它內存進行分配擔保，老年代擔保直接創建。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;大對象&lt;/strong&gt;：當創建需要大量連續內存空間的對象時，如長字符串或者數組等，大小超過了閾值時，直接在老年代分配。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;動態年齡對象&lt;/strong&gt;：有的垃圾收集器不需要到達指定年齡大小直接晉升老年代，比如相同年齡的對象的大小總和 &amp;gt; Survivor 空間的 50%， 年齡大於等於該年齡對象直接移動老年代，無需等待正常提升。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ol&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;老年代回收發起 Major GC / FULL GC，當老年代滿時會觸發 MajorGC，通常至少經歷過一次 Minor GC，再緊接着進行 Major GC， Major GC 清理 Tenured 區，用於回收老年代（CMS 才能單獨清理）。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;FUll GC：清除整個堆空間，一般來説是針對整個新生代、老生代、元空間的全局範圍的清理。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;不管是 Major GC 還是 Full GC， STW 的耗時都是 Ygc 的十倍以上，所以説對象能在年輕代被回收是最優的。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;Full GC 觸發條件：&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;老年代空間不足。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;元空間不足擴容導致。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;程序代碼執行 System.gc 時可能會執行。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;當程序創建一個大對象時，Eden 區域放不下大對象，老年代內存擔保分配，老年代也不足空間時。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;年輕代存留對象晉升老年代時，老年代空間不足時。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.5 Java 對象內存分配過程&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014626&quot; data-ratio=&quot;0.6027777777777777&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/d2937f98-1501-4a47-ab87-fd64453954f6.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&amp;nbsp;對象的分配過程&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ol class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: decimal;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;編譯器通過逃逸分析優化手段，確定對象是否在棧上分配還是堆上分配。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;如果在堆上分配，則確定是否大對象，如果是則直接進入老年代空間分配， 不然則走 3。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;對比 tlab， 如果 tlab_top + size &amp;lt;= tlab_end， 則在 tlab 上直接分配，並且增加 tlab_top 值，如果 tlab 不足以空間放當前對象，則重新申請一個 tlab 嘗試放入當前對象，如果還是不行則往下走 4。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;分配在 Eden 空間，當 eden 空間不足時發生 YGC， 倖存者區是否年齡晉升、動態年齡、老年代剩餘空間不足發生 Full GC 。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;當 YGC 之後仍然不足當前對象放入，則直接分配老年代。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ol&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;TLAB&lt;strong&gt;作用原理&lt;/strong&gt;：Java 在內存新生代 Eden 區域開闢了一小塊線程私有區域，這塊區域為 TLAB，默認佔 Eden 區域大小的 1%， 作用於小對象，因為小對象用完即丟，不存在線程共享，快速消亡 GC，JVM 優先將小對象分配在 TLAB 是線程私有的，所以沒有鎖的開銷，效率高，每次只需要線程在自己的緩衝區分配即可，不需要進行鎖同步堆 。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;對象除了基本類型的不一定是在堆內存分配，在 JVM 擁有逃逸分析，能夠分析出一個新的對象所擁有的範圍，從而決定是否要將這個對象分配到堆上，是 JVM 的默認行為；Java 逃逸分析是一種優化技術，可以通過分析 Java 對象的作用域和生命週期，確定對象的內存分配位置和生命週期，從而減少不必要的內存分配和垃圾回收。可以在棧上分配，可以在棧幀上創建和銷燬，分離對象或標量替換，同步消除。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 2px;border-color: transparent;background-color: rgb(255, 255, 255);padding: 1px;&quot;&gt; 
    &lt;section style=&quot;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;display: inline-block;width: 100%;height: 200px;vertical-align: top;overflow-y: auto;&quot;&gt; 
      &lt;section style=&quot;overflow: hidden;&quot;&gt; 
       &lt;section style=&quot;margin-bottom: 120px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
        &lt;section style=&quot;text-align: justify;&quot;&gt; 
         &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
          &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; TaoYiFenxi {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; obj;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; setObj() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        obj = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; getObject() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; obj1 = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; obj1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; test1() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        synchronized (&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
         &lt;/section&gt; 
        &lt;/section&gt; 
       &lt;/section&gt; 
      &lt;/section&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.6 JVM 垃圾收集器特點與原理&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（1）Serial 垃圾收集器、Serial Old 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014627&quot; data-ratio=&quot;0.5712962962962963&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/04a94627-31bb-4e85-a8a8-5ae052deed2b.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Serial 收集器採用複製算法， 作用在年輕代的一款垃圾收集器，串行運行，執行過程中會 STW，是使用單個線程進行垃圾回收，響應速度優先。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Serial Old 收集器採用標記整理算法，作用在老年代的一款收集器，串行運行，執行過程中會暫停所有用户線程，會 STW，使用單個線程進行垃圾回收，響應速度優先。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用場景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;適合內存小几十兆以內，比較適合簡單的服務或者單 CPU 服務，避免了線程交互的開銷。&lt;br&gt;&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;優點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;小堆內存且單核 CPU 執行效率高。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;堆內存大，多核 CPU 不適合，回收時長非常長。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（2）Parallel Scavenge 垃圾收集器、Parallel Old 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014628&quot; data-ratio=&quot;0.5722222222222222&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/8cf072c7-a51e-4f76-b268-577b9c499ab2.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Parallel Scavenge 垃圾收集器採用了複製算法，作用在年輕代的一款垃圾收集器，是並行的多線程運行，執行過程中會發生 STW，關注與程序吞吐量。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Parallel Old 垃圾收集器採用標記整理算法，作用，作用在老年代的一款垃圾收集器， 是並行的多線程運行，執行過程中會發生 STW，關注與程序吞吐量。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Parallel Scavenge + Parallel Old 組合是 Java8 當中默認使用的一個組合垃圾回收。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;所謂的吞吐量是 CPU 用於運行用户代碼時間與 CPU 總消耗時間的比值，也就是説吞吐量 = 運行用户代碼時間 / (運行用户代碼時間 + 垃圾收集器時間)， 錄入程序運行了 100 分鐘，垃圾收集器花費時間 1 分鐘&lt;span style=&quot;letter-spacing: 0.034em;&quot;&gt;，則吞吐量達到了 99%。&lt;/span&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用場景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;適用於內存在幾個 G 之間，適用於後台計算服務或者不需要太多交互的服務，保證吞吐量的服務。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;優點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;可控吞吐量、保證吞吐量，並行收集。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;回收期間 STW，隨着堆內存增大，回收暫停時間增大。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（3）Par New 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Par New 垃圾收集器採用了複製算法，作用在年輕代的一款垃圾收集器， 也是並行多線程運行，跟 Parallel 非常相似，是它的增強版本，或者説是 Serial 收集器的多線程版本，是搭配 CMS 垃圾收集器特製的一個收集器。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;使用場景：&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;搭配 CMS 使用&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（4）CMS 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;CMS 是一款多線程+分段操作的一款垃圾收集器。其最大的優點就是將一次完整的回收過程拆分成多個步驟，並且在執行的某些過程中可以使用户線程可以繼續運行，分別有初始標記，併發標記，重新標記，併發清理和併發重置。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014629&quot; data-ratio=&quot;0.5064814814814815&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/fa0a6a57-a712-446f-b037-0153ff732161.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;CMS 是一款多線程+分段操作的一款垃圾收集器。其最大的優點就是將一次完整的回收過程拆分成多個步驟，並且在執行的某些過程中可以使用户線程可以繼續運行，分別有初始標記，併發標記，重新標記，併發清理和併發重置。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;CMS 分段&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;初始標記階段&lt;/strong&gt;， 這個階段會暫停用户線程， 掃描所有的根對象，因為根對象比較少，所以一般 stw 時間都非常短。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;併發標記階段&lt;/strong&gt;，這個階段與用户線程一起執行，會一直沿着根往下掃描，不停的識別對象是否為垃圾，標記，採用了三色算法， 在對象頭 (Mark World) 標識了一個顏色屬性，不同的顏色代表不同階段，掃描過程中給與對象一個顏色，記錄掃描位置，防止 cpu 時間片切換不需要重新掃描。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;重新標記階段&lt;/strong&gt;， 這個階段暫停用户線程， 修正一些漏標對象，回掃發生引用變化的對象。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;併發清理階段&lt;/strong&gt;， 這個階段與用户線程一起執行，標記清除已經成為垃圾的對象。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;三色標記&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;黑色&lt;/strong&gt;：代表了自己已經被掃描完畢，並且自己的引用對象也已經確定完畢。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;灰色&lt;/strong&gt;：代表自己已經被掃描完畢了， 但是自己的引用還沒標記完。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;白色：則代表還沒有被掃描過。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;標記過程結束後，所有未被標記的對象都是不可達的，可以被回收。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014630&quot; data-ratio=&quot;0.725925925925926&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/c4354e81-0441-4f2c-839a-825920ac5e2d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;三色標記算法的&lt;strong&gt;問題場景&lt;/strong&gt;：當業務線程做了對象引用變更，會發生 B 對象不會被掃描，當成垃圾回收。&lt;/p&gt; 
  &lt;section style=&quot;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 2px;border-color: transparent;background-color: rgb(255, 255, 255);padding: 1px;&quot;&gt; 
    &lt;section style=&quot;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;display: inline-block;width: 100%;height: 200px;vertical-align: top;overflow-y: auto;&quot;&gt; 
      &lt;section style=&quot;overflow: hidden;&quot;&gt; 
       &lt;section style=&quot;margin-bottom: 120px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
        &lt;section style=&quot;text-align: justify;&quot;&gt; 
         &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
          &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Demo3&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        R r = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; R();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        B b = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; B();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GCroot 遍歷 R， R 為黑色， R 下面的 a 引用鏈還未掃完置灰灰色，R.b 無引用， 切換時間分片&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a.b = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 業務線程發生了引用改變， 原本 r.a.b 的引用置為 null&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a.b = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 線程回來繼續上次掃描，發現 r.a.b 無引用，則認為 b 對象無任何引用清除&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.b = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 回收了 b， 業務線程無法使用 b&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;R&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    B b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    B b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;B&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
         &lt;/section&gt; 
        &lt;/section&gt; 
       &lt;/section&gt; 
      &lt;/section&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014631&quot; data-ratio=&quot;0.45185185185185184&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/c965a3e4-1d3c-41bd-8a87-f1e559362200.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;當 GC 線程標記 A 時，CPU 時間片切換，業務線程進行了對象引用改變，這時候時間片回到了 GC 線程，繼續掃描對象 A， 發現 A 沒有任何引用，則會將 A 賦值黑色掃描完畢，這樣 B 則不會被掃描，會標記 B 是垃圾， 在清理階段將 B 回收掉，錯誤的回收正常的對象，發生業務異常。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;CMS 基於這種錯誤標記的解決方案是採取寫屏障 + 增量更新 Incremental Update ， 在業務線程發生對象變化時，重新將 R 標識為灰色，重新掃描一遍，Incremental Update 在特殊場景下還是會產生漏標。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014632&quot; data-ratio=&quot;0.8445378151260504&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/4dce9b78-c6ab-4129-b955-11ce7716fe3d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;952&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 2px;border-color: transparent;background-color: rgb(255, 255, 255);padding: 1px;&quot;&gt; 
    &lt;section style=&quot;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;display: inline-block;width: 100%;height: 200px;vertical-align: top;overflow-y: auto;&quot;&gt; 
      &lt;section style=&quot;overflow: hidden;&quot;&gt; 
       &lt;section style=&quot;margin-bottom: 120px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
        &lt;section style=&quot;text-align: justify;&quot;&gt; 
         &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
          &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Demo3&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// Incremental Update 還會產生的問題&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        R r = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; R();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        A a = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        A b = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a1 = a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 線程切換， r 掃完 a1， 但是沒有掃完 a2， 還是灰色&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a2 = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 業務線程發生引用切換， r 置灰灰色（本身灰色）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a1 = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 線程繼續掃完 a2， R 為黑色， b 對象又漏了~&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;R&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A a1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A a2;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
         &lt;/section&gt; 
        &lt;/section&gt; 
       &lt;/section&gt; 
      &lt;/section&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;當 GC 1 線程正在標記 O， 已經標記完 O 的屬性 O.1， 準備標記 O.2 時，業務線程把屬性 O,1 = B，這時候將 O 對象再次標記成灰色， GC 1 線程切回，將 O.2 線程標記完成，這時候認為 O 已經全部標記完成，O 標記為黑色， B 對象產生了漏標， CMS 針對 Incremental Update 產生的問題，只能在 remark 階段，暫停所有線程，將這些發生過引用改變過的，重新掃描一遍。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用場景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;適用於互聯網或者 B/S 服務， 響應速度優先，適合 6G 左右。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;優點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;併發收集， 低停頓，回收過程中最耗時的是併發標記和併發清除，它都能與用户線程保持一起工作。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;收集器對 CPU 的資源非常敏感，會佔用用户線程部分使用，導致程序會變得緩慢，吞吐量下降。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;無法處理浮動垃圾，在併發清理階段用户線程還是在運行，這時候產生的新垃圾無法在這次當中處理，只有等待下次才會清理。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;因為 CMS 使用了 Incremental Update，remark 階段還是會所有暫停，重新掃描發生引用改變的 GC root，效率慢耗時高。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;因為收集器是基於標記清除算法實現的，所以在收集器回收結束後，內存會產生碎片化，當碎片化非常嚴重的時候，這時候有大對象進入無法分配內存時會觸發 FullGC，特殊場景下會使用 Serial 收集器，導致停頓不可控。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（5）G1 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 也是採用三色標記分段式進行回收的算法， 不過它是寫屏障 + STAB 快照實現，G1 設定的目標是在延遲可控（低暫停）的情況下獲得儘可能高的吞吐量，仍然可以通過併發的方式讓 Java 程序繼續運行，G1 垃圾收集器在很多方面彌補了 CMS 的不足，比如 CMS 使用的是 mark-sweep 標記清除算法，自然會產生內存碎片 (CMS 只能在 Full GC 時，STW 整理內存碎片)，然而 G1 整體來看是基於標記整理算法實現的收集器，但是從局部來看也是基於複製算法實現的，高效的整理剩餘內存，而不需要管理內存碎片它。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 同樣有年輕代和老年代的概念，只不過物理空間劃分已經不存在，邏輯分區還存在，G1 會把堆切成若干份，每一份當作一個目標，在部分上目標很容易達成，G1 在進行垃圾回收的時候，將會根據最大停頓時間設置值動態選取部分小堆區垃圾回收。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014633&quot; data-ratio=&quot;0.6731481481481482&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/3baad622-5f9e-4052-8a43-43203fcb039b.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 的特點是儘量追求吞吐量，追求響應時間，併發收集，壓縮空閒空間不會延長 GC 暫停時間，更容易預測 GC 暫停時間，能充分利用 CPU、多核環境下的硬件優勢，使用多個 CPU 對 STW 進行控制 (200ms 以內) 靈活的分區回收，優先回收花費時間少的或者垃圾比例高的 region 新老比例也是動態調整，不需要配置；年齡晉升也是 15，但是可以動態年齡，當倖存者 region 超過了 50 時，會把年齡最大的放入老年代。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 動態 Y 區域設置，G1 每個分區都可能是年輕代或者老年代，但是同一時刻只屬於一個代，分代概念還存在，邏輯上分代方便複用以前分代邏輯，在物理上不需要連續，這樣能帶來額外好處，有的分區內垃圾比較多，有的分區比較少，G1 會優先回收垃圾比較多的分區，這樣可以花費少量的時間來回收這些分區垃圾，即收集最多垃圾分區；但是新生代回收不適合這種，新生代達到閾值時發生 YGC，對整個新生代進行回收或者晉升倖存，新生代也分區是方便動態調整分區大小，在進行垃圾回收時，會將存活對象拷貝到另一個可用分區上，這樣也能避免一定程度的內存碎片化過程，每個分區的大小都是在 1M- 32M 之間，取決 2 的冪次方。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;Humingous&lt;/strong&gt;：如果一個對象佔用的空間超過了分區容量 50% 以上，G1 收集器就認為這是一個巨型對象。這些巨型對象，默認直接會被分配在年老代，但是如果它是一個短期存在的巨型對象，就會對垃圾收集器造成負面影響；為瞭解決這個問題，G1 劃分了一個 Humongous 區，它用來專門存放巨型對象。如果一個 H 區裝不下一個巨型對象，那麼 G1 會尋找連續的 H 分區來存儲。為了能找到連續的 H 區，有時候不得不啓動 Full GC。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;CardTable&lt;/strong&gt;：記錄每一塊 card 內存區域是否 dirty，如果在發生 YGC 時，怎麼知道那些是存活對象，並且其它代區域有沒有引用這部分對象，於是把內存劃分了很多 card 區域， 每個區域大小不超過 512b，當該 card 區域裏的對象有引用關係，將當前 card 置為「dirty」， 並且使用卡表（CardTable）來記錄每一塊 card 是否 dirty，在進行 GC 時，不用遍歷所有的空間， 只需要遍歷卡表中為&quot;dirty&quot;或者説布爾符合條件的 card 區域進行回掃。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014634&quot; data-ratio=&quot;0.6703703703703704&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/317b89d9-596b-458e-ba5d-b9c955eb7575.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;CSet&lt;/strong&gt;：Collection SET 用於記錄可被回收分區的集合組， G1 使用不同算法，動態的計算出那些分區是需要被回收的，將其放到 CSet 中，在 CSet 當中存活的數據都會在 GC 過程中拷貝到另一個可用分區，CSet 可以是所有類型分區，它需要額外佔用內存，堆空間的 1%。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;RSet&lt;/strong&gt;：RememberedSet 每個 Region 都有一個 Rset，是一個記錄了其他 Region 中的對象到本身 Region 的引用，它可以使得垃圾收集器不需要掃描整個堆去找到誰的引用了當前分區對象，是 G1 高效回收的關鍵點，也是三色算法的一個以來點。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014635&quot; data-ratio=&quot;0.2824074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/a1cb4f90-eef7-4393-9c20-eb6badbc354e.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;RSet 和卡表的區別是什麼？&lt;/strong&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;p&gt;卡表記錄的是堆內存中 card 有沒有變成&quot;dirty&quot;， 但是它本身不知道 dirty 裏面哪些是引用了的對象，它是一個大維度的一個記錄，RSet 是記錄自身 Region 中對象引用了其它 Region 中的那些對象，詳細的記錄對方引用對象信息，G1 使用了兩者的結合，實現了增量式的垃圾回收，並優化跨區引用的最終處理。&lt;/p&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;SATB 算法&lt;/strong&gt;：是一種基於快照的算法，它可以避免在垃圾回收時出現對象漏標或者重複標記的問題，從而提高垃圾回收的準確性和效率，在垃圾回收開始時，對堆中的對象引用進行快照，然後在併發標記階段中記錄下所有被修改過對象引用，保存到 satb_mark_queue 中，最後在重新標記階段重新掃描這些對象，標記所有被修改的對象，保證了準確性和效率。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;SATB 算法在 remark 階段不需要暫停遍歷整個堆對象，只需要掃描「satb_mark_queue」隊列中的記錄，避免了這個階段長耗時，而 cms 的增量算法在這個階段是需要重新掃描 GC Roots 標記整個堆對象，導致了不可控時間暫停，總的來説 G1 是通過回收領域應用並行化策略，將原來的幾塊大內存塊回收問題，演變成了 N 個小內存塊回收，使得回收效率可以高度並行化，停頓時間可控，可以與用户線程併發執行，將一塊內存分而治之。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014636&quot; data-ratio=&quot;0.35462962962962963&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/7545f663-b201-495f-9cf2-b522f1c96976.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;G1 默認當分區內存佔用閾值達到總內存的 45%，會發生 Mixed gc（混和 GC），YoungGC + 併發回收 Mixed GC 過程：初始標記（stw）、併發標記、最終標記 (重新標記 stw)、篩選回收（stw 並行）。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用場景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;響應速度優先，較高的吞吐量，面向服務端，使用內存 6G 以上。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;優點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;並行與併發收集，分代分區收集，優先垃圾收集，空間整合，可控或者可預測停頓時間。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺點：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;收集中產生內存，G1 的每個 region 都需要有一份記憶集和卡表記錄跨代指針，這導致記憶集可能佔用堆空間 10-20% 甚至更多空間。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;執行過程中額外負載開銷加大，寫屏障進行維護卡表操作外，還需要原始快照能夠減少併發標記和重新標記階段的消耗，避免最終標記階段停頓過長，運行過程中會產生由跟蹤引用變化帶來的額外開銷負擔，比 CMS 增量算法消耗更多，CMS 的寫屏障實現直接是同步操作， 而 G1 是把寫屏障和寫後屏障中要做的事情放到隊列裏異步處理。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 對於 Full GC 是沒有處理流程， 一旦發生 Full GC G1 的回收執行的是單線程的 Serial 回收器進行回收。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.7 垃圾收集器配置使用&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;機器配置：64 位 4C8G&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;Java 程序使用 CMS 收集器進行內存垃圾回收初始內存劃分情況：&lt;/p&gt; 
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-Xms4096M&amp;nbsp;-Xmx4096M&amp;nbsp;-XX:+HeapDumpOnOutOfMemoryError&amp;nbsp;-XX:HeapDumpPath=&lt;span class=&quot;code-snippet__regexp&quot;&gt;/data/&lt;/span&gt;{runuser}/logs/other&amp;nbsp;-XX:+UseConcMarkSweepGC&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014637&quot; data-ratio=&quot;0.5889967637540453&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/9ca62bea-63ea-499e-b9e7-0d0f7a002676.png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;span style=&quot;letter-spacing: 0.034em;&quot;&gt;CMS 跟 parNew 佔比情況， 默認下 ParNew 佔用整個堆的空間為：機器位數 * CPU 核數 * 13 /10 ， 當前機器配置計算得出 64 * 4 * 13 / 10 = 332M ， 與圖上數值差別不大。&lt;/span&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 程序使用 G1 收集器進行內存垃圾回收初始內存劃分情況：&lt;/p&gt; 
   &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
    &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-Xms4096M&amp;nbsp;-Xmx4096M&amp;nbsp;-XX:+HeapDumpOnOutOfMemoryError&amp;nbsp;-XX:HeapDumpPath=&lt;span class=&quot;code-snippet__regexp&quot;&gt;/data/&lt;/span&gt;{runuser}/logs/other&amp;nbsp;-XX:+UseG1GC&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
   &lt;/section&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014638&quot; data-ratio=&quot;0.5726495726495726&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/f87fe847-d5a8-4609-b631-234fab58b8c7.png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;G1 新老年代的佔比是動態調整， 隨着運行時根據實際情況劃分空間。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;Java8 默認 ParallerGC 收集器初始內存劃分情況：&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014639&quot; data-ratio=&quot;0.5694591728525981&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/b3a135dc-2a00-4a54-acd4-c3600b573ab9.png&quot; data-type=&quot;png&quot; data-w=&quot;943&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;parallel GC 回收器默認堆 old 區與 young 區內存大小比例 2：1， 圖上數值差別不大。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;三、內存診斷實踐&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;3.1 內存快照生成&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;當發生線上應用告警，告警相關內存故障問題時， 應當如何進行故障排查呢？首先應用在發生內存溢出無法執行時，應 DUMP 當前內存快照，需要在 Java 程序執行啓動命令時添加上：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;-XX:+HeapDumpOnOutOfMemoryError&amp;nbsp;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;-XX:HeapDumpPath=${filePath} 參數&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&amp;nbsp;當發生時自動生成一份當前內存快照，方便與開發人員使用快照文件進行問題診斷分析。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;在 Java 應用運行時，想手動生成內存快照，可以使用 JDK 自帶幾個問題排查工具，可以使用 jmap 工具生成指定 PID 內存快照，不過需要耗費較長的一個時間，會暫停應用程序執行，使用 jcmd 工具可以快速的 DUMP 內存快照，因為在堆轉儲存文件過程中，jcmd 可以利用虛擬機中的一些優化技術，例如分代堆、增量式垃圾回收等技術，相比傳統的 jmap 效率高很多，一般來説在 DUMP 內存前會進行一次&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Full FC，可以指定屏蔽這次 Full GC，保留當前所有內存中的對象。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;除了自帶的內存診斷工具， 也可以使用 Arthas 診斷工具，提供了多個命令來幫助診斷內存問題，例如 dashboard（當前 Java 程序內存實時數據面板）、JVM（查看當前 JVM 信息，包括使用的 gc 收集器、內存分區分佈情況等信息）、heapdump（當前內存快照類似 jmap 命令的 heap dump）、memory（當前內存分區及佔用情況）、monitor（監控模式，可監控內存及查看對象佔用情況）profiler（火焰圖可以輸出多種火焰圖，內存分區佔用火焰圖）等相關內存命令。這些命令可以幫助獲取應用程序的內存快照、堆內存使用情況等信息，能快速定位內存問題。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;引用：&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farthas.aliyun.com%2Fdoc%2Fcommands.html&quot; textvalue=&quot;Arthas 命令列表&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Arthas 命令列表&lt;/a&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;3.2 dump 內存快照分析&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;（1）jhat 是 Java 開發工具包自帶的一款堆內存分析工具，它可以幫助解決 Java 應用程序的內存問題。Jhat 可以讀取 Java 應用程序生成的堆轉儲文件，並以 HTML 格式展示內存中的對象信息和引用關係，支持 OQL 查詢和靈活的過濾和排序功能。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;用例&amp;nbsp;&lt;span style=&quot;background-color: rgb(214, 214, 214);&quot;&gt; jhat E:\diydump\Java_pid2680.hprof&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014640&quot; data-ratio=&quot;0.597&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/ed38fad9-e21f-4c52-b7db-b83e26d1ef28.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;All classes including platform&lt;/strong&gt;：列舉應用程序中所有類的信息，並快速定位內存問題。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;Show all members of the rootset&lt;/strong&gt;：顯示堆內存中所有根對象的信息，包括系統對象、靜態對象、本地對象等。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;Show instance counts for all classes (including platform)&lt;/strong&gt;：顯示所有類的實例數量。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;Show heap histogram&lt;/strong&gt;：顯示程序堆內存的直方圖，可以知道每個類的實例數量和佔用內存大小等信息，快速知道內存泄漏原因。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;（2）jvisualvm 也是 Java 開發工具包裏自帶的一款圖形化工具，可以用於監控和診斷 Java 應用程序的性能問題。使用它可以實時查看 Java 應用程序的內存使用情況、CPU 使用情況、線程情況等，並可以進行內存分析、CPU 分析、線程分析等內容。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;以 Java_pid2680.hprof 為例，進行內存分析內存泄漏原因：&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014641&quot; data-ratio=&quot;0.4685185185185185&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/cecd7993-3d90-45ea-9aec-eb5bbc6a811b.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;（3）MAT 是基於 Eclipse 的內存分析工具，是一個快速、功能豐富的 Java 內存分析工具，能夠快速的分析出 dump 文件中各項結果，快速給出內存泄漏原因報告。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;還是以 Java_pid2680.hprof 文件進行分析，比原生的 jhat 方便很多，功能也比原生的更加豐富：&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014642&quot; data-ratio=&quot;0.5074074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/f7caef82-cb1c-4a39-9ee8-103c551796d8.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;MAT 的一些常用功能點介紹（如圖所示）：&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;Overview &lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;標籤內容有比較多塊內容，其中 details 末塊介紹總共使用內存大小，類的數量，實例的數量，類的加載器，以及實例的內存直方圖；&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;Biggest Objects by Retained Size&lt;/strong&gt;模塊，使用了餅狀圖列出了當前內存中佔用最大的幾個對象，按照百分比劃分，點擊不同的餅狀塊能夠看到具體對象及其對象屬性等信息；&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;actions&lt;/strong&gt;模塊，這裏擁有不同的分析功能，Histogram 生成視圖列出每個類所對應的對象個數以及佔用內存大小，Dominator Tree 生成視圖尋找出大對象，每個實例對象的內存佔比比重；&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;Reports&lt;/strong&gt;模塊是生成報告，其中 Leak Suspects 可以自動分析內存泄漏主要原因報告，可以通過報告準確定位泄漏原因或者可能造成泄漏的原因，並且可以定位到具體累積實例，線程 stack 等信息。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;例子中：leak Suspects 報告給出「0xfe3be480」 非常多內存， Gc root Thread 所引用，在發生 gc 時，不是可回收對象，無法回收內存，導致內存溢出。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014643&quot; data-ratio=&quot;0.4861111111111111&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/df138f30-3373-4dfb-a6d2-95dba48cdf83.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;四、總結&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;本文介紹了 Java 程序中的內存模型，內存模型劃分多份內存區域，不同區域的作用介紹及不同區域的線程之間的內存共享範圍，可以幫助開發人員更加理解 Java 中內存管理的機制和原理。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;堆是內存模型中最大的一塊內存區域，以堆的空間劃分詳細的介紹了內存分代，部分垃圾收集器即是物理分代和邏輯分代，G1 收集器則物理不分代邏輯保留了以前分代，講述了不同收集器的原理實現和優缺點，可以根據項目的業務屬性，機器配置等因素選擇最優的收集器，幫助程序使用最優的收集器可以使得程序的吞吐量和響應速度達到最佳狀態。還講述了不同的參數調優收集器，並且當發生了程序內存溢出崩潰，如何進行內存分析，介紹不同工具的使用，快速定位內存溢出的罪魁禍首，從而在代碼層面上根本解決這類問題。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;margin-top: 0.5em;margin-bottom: 0.5em;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;border-top: 1px dotted rgb(90, 98, 114);&quot;&gt; 
      &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;text-align: center;color: rgb(45, 66, 87);font-size: 11px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p&gt;END&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;margin-top: 0.5em;margin-bottom: 0.5em;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;border-top: 1px dotted rgb(90, 98, 114);&quot;&gt; 
      &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: left;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;&quot;&gt; 
    &lt;span style=&quot;display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);&quot; title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:234.title1&quot;&gt;&lt;p&gt;猜你喜歡&lt;/p&gt;&lt;/span&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;&quot;&gt; 
    &lt;section style=&quot;font-size: 14px;text-align: left;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;padding-left: 40px;list-style-position: outside;&quot;&gt; 
      &lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247498348%26idx%3D1%26sn%3Da070a524928c6d312a56ead073e14a7c%26chksm%3Debdb8afedcac03e89c1a233dc19e01b468331219eaad321cb6346c0f73a2c06135503e6a83a6%26scene%3D21%23wechat_redirect&quot; textvalue=&quot;vivo 統一接入網關 VUA 轉發性能優化實踐&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;vivo 統一接入網關 VUA 轉發性能優化實踐&lt;/a&gt;&lt;/p&gt;&lt;/li&gt; 
      &lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247498342%26idx%3D1%26sn%3Db314e59b249a74cd76464d16895d8696%26chksm%3Debdb8af4dcac03e2defb1d7339379dadf13f2597f924f5c974e1083c668c971016d199fb1d07%26scene%3D21%23wechat_redirect&quot; textvalue=&quot;Sharding-JDBC 源碼解析與 vivo 的定製開發&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Sharding-JDBC 源碼解析與 vivo 的定製開發&lt;/a&gt;&lt;/p&gt;&lt;/li&gt; 
      &lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247498320%26idx%3D1%26sn%3Dc0180b1567a8b362c3c23c51528dfb7d%26chksm%3Debdb8ac2dcac03d4a3113cf75191bbf134746649184986b161fc521f4e340e1753ad6afbf744%26scene%3D21%23wechat_redirect&quot; textvalue=&quot;vivo 在離線混部探索與實踐&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;vivo 在離線混部探索與實踐&lt;/a&gt;&lt;/p&gt;&lt;/li&gt; 
     &lt;/ul&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
 &lt;/section&gt; 
 &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt; 
  &lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo 互聯網技術&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互聯網技術乾貨與沙龍活動，推薦最新行業動態與熱門會議。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;&gt;&lt;/mp-common-profile&gt; 
 &lt;/section&gt; 
 &lt;p style=&quot;display: none;&quot;&gt; 
  &lt;mp-style-type data-value=&quot;3&quot;&gt;&lt;/mp-style-type&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color: #858585; font-size: 13px;&quot;&gt;本文分享自微信公眾號 - vivo 互聯網技術（vivoVMIC）。&lt;br&gt;如有侵權，請聯繫 support@oschina.cn 刪除。&lt;br&gt;本文參與「&lt;a href=&quot;https://www.oschina.net/sharing-plan&quot; target=&quot;_blank&quot;&gt;OSC 源創計劃&lt;/a&gt;」，歡迎正在閲讀的你也加入，一起分享。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://my.oschina.net/vivotech/blog/11048619</link>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/11048619</guid>
            <pubDate>Wed, 27 Mar 2024 01:51:40 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>大數據應用場景落地實踐</title>
            <description></description>
            <link>https://www.oschina.net/event/2331846</link>
            <guid isPermaLink="false">https://www.oschina.net/event/2331846</guid>
            <pubDate>Tue, 26 Mar 2024 09:29:17 GMT</pubDate>
        </item>
        <item>
            <title>mybatis-mp - 亮點八：mybatis-xml returnType 的 ORM 映射</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;strong&gt;mybatis-mp - 亮點八:&amp;nbsp; 可對 xml 實體類返回，進行自動映射：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;當你需要寫一個很複雜的 sql 時，你可能會選擇用 xml 去做例如：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;findUserList&quot; returnType=&quot;User&quot;&amp;gt;

&amp;nbsp; &amp;nbsp; &amp;nbsp; select id,user_name as userName,nick_name as nickName,password from user where xx and xx2 and xx3 ........

&amp;lt;/select&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style=&quot;color:#e74c3c&quot;&gt;如上：你可能需要自己，一個一個 as userName , as nickName 之類的，是不是很麻煩&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;現在好，只要接入 mybatis-mp；這些完全不用寫了，如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;findUserList&quot; returnType=&quot;User&quot;&amp;gt;

&amp;nbsp; &amp;nbsp; &amp;nbsp; select id,user_name,nick_name,password from user where xx and xx2 and xx3 ........

&amp;lt;/select&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;自動幫你進行了映射，而且不僅僅支持實體，還支持 VO；省去了很多麻煩步驟！&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284803</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284803</guid>
            <pubDate>Tue, 26 Mar 2024 06:44:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>Ubuntu LTS 支持延長至 12 年</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Canonical &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fubuntu.com%2F%2Fblog%2Fcanonical-expands-long-term-support-to-12-years-starting-with-ubuntu-14-04-lts&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;全面推出 Legacy Support —— 一個 Ubuntu Pro 插件，可將 Ubuntu LTS 版本的安全性和支持範圍擴大到 12 年。適用於 Ubuntu 14.04 LTS 及以上版本。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;312&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2a2eb37bed9123652265f19a8da71c4a8b3.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此前，Ubuntu 的 LTS 版本一般將獲得 5 年的安全更新、錯誤修復和精選應用程序更新。Ubuntu Pro 則會在此基礎上額外增加 5 年的安全保障，為現代的 LTS 版本提供長達十年的支持。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;通過此次推出的 Legacy Support 插件，Ubuntu Pro 用户將可以在原有的基礎上，額外再兩年的安全維護和支持。這意味着，Ubuntu 14.04 LTS 及以上版本的 LTS 從發佈之日起將可獲得長達 12 年的支持期。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Canonical 支持工程全球副總裁 Maximilian Morgan 稱，「我們很高興能為客户提供額外幾年的 Ubuntu LTS 版本安全維護和支持......通過 Legacy Support，我們使企業能夠滿懷信心地引導其運營需求和對開源的投資，確保他們的系統在未來許多年內保持可用、安全和支持。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;這意味着原定於今年 4 月結束支持的 Ubuntu 14.04 LTS &quot;Trusty Tahr&quot; 將推遲至 2026 年 4 月，從而為 IT 人員預留了更多的時間來計劃和準備升級到更新的版本。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284787/ubuntu-lts-12-years</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284787/ubuntu-lts-12-years</guid>
            <pubDate>Tue, 26 Mar 2024 06:21:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Ugly avatar —— 醜頭像生成器</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;Ugly avatar 是生成醜頭像的在線工具。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-c1df4ccc6fa20c1982e151f5404498a50a0.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

&lt;p&gt;體驗地址：&lt;a href=&quot;https://txstc55.github.io/ugly-avatar/&quot;&gt;https://txstc55.github.io/ugly-avatar/&lt;/a&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/ugly-avatar</link>
            <guid isPermaLink="false">https://www.oschina.net/p/ugly-avatar</guid>
            <pubDate>Tue, 26 Mar 2024 04:21:50 GMT</pubDate>
        </item>
        <item>
            <title>Windows 格式化對話框是一個使用了 30 年的「臨時解決方案」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;戴夫-普盧默（Dave Plummer）是微軟的資深工程師，曾創造了任務管理器、Windows 彈球、原生 ZIP 支持（微軟出錢買斷該功能後，他用這筆錢購買了一輛紅色克爾維特）等傳奇，近日他在自己的 X 賬户上分享了創建&quot;格式化&quot;對話框的故事——稱其是一個使用了長達 30 年的「臨時解決方案」。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-5518f52befb96158f97eb7d1b4e287baa1a.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fdavepl1968%2Fstatus%2F1772042158046146792&quot; target=&quot;_blank&quot;&gt;https://twitter.com/davepl1968/status/1772042158046146792&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;故事還要追溯到 1994 年，當時 Dave 和其他軟件工程師們正忙於將&quot;海量的代碼&quot;從 Windows 95 遷移到 Windows NT 系統上。由於後者引入了許多改動，格式化對話框的界面也亟待重新設計。&lt;/p&gt; 
&lt;p&gt;Dave 拿起紙筆，列出了一些必要的功能，並使用 VC++ 2.0 的資源編輯器快速搭建了一個簡單的縱向列表界面。選擇垂直佈局是為了讓用户可以按照大致正確的順序勾選所有選項。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-94c12885f8f91ab589c030879f7914d81f2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Dave 表示，&lt;strong&gt;這個設計的初衷並不是為了美觀，僅僅是為了在「更優雅的界面」到來之前先用着&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;然而讓人沒想到的是，這個「臨時解決方案」一用就是 30 年。即使是最新版本的 Windows 11 預覽版，在格式化對話框仍然維持着當年的樣式，沒有任何升級的跡象。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-db2b723d3944610ef606bc557efc549a365.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Dave 還提到，「30 年前我做的那個星期四上午做出來的臨時方案，現在還在使用！」他還感慨：「在開發軟件時，可要當心‘臨時’這兩個字眼兒啊！」&lt;/p&gt; 
&lt;p&gt;此外，Dave 當初還憑直覺決定了 cluster slack 大小的限制，這直接導致了 FAT 卷的格式化最大容量為 32GB。同樣，這也是一個當初的臨時決定，卻意外地變成了至今仍在使用的永久限制。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284757</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284757</guid>
            <pubDate>Tue, 26 Mar 2024 04:01:50 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>開源日報 | AI 手機需要新故事；做了十幾年的操作系統和 AI 應用，跨界到機器人領域；VitePress 1.0；蘋果曾試圖為安卓開發手錶</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;歡迎閲讀 OSCHINA 編輯部出品的開源日報，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#e67e22&quot;&gt;&lt;strong&gt;# 2024.3.25&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日要點&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;OpenSource Daily&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284627/vitepress-1-0-released&quot; target=&quot;_blank&quot;&gt;尤雨溪宣佈推出 VitePress 1.0&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;尤雨溪宣佈正式發佈 VitePress 1.0 版本，並聲稱其 「基於 Vite 和 Vue 構建，是 VuePress 的精神繼承者和現代替代品。」&lt;/p&gt; 
&lt;p&gt;VitePress 是一個靜態站點生成器 (SSG)，專為構建快速、以內容為中心的站點而設計。簡而言之，VitePress 獲取用 Markdown 編寫的內容，對其應用主題，並生成可以輕鬆部署到任何地方的靜態 HTML 頁面。&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284652/fydeos-18-released&quot; target=&quot;_blank&quot;&gt;FydeOS v18 發佈，控制中心重構，虛擬桌面、剪貼板、文件搜索全面升級&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;-虛擬桌面：改進了虛擬桌面功能，通過底部快捷按鈕實現工作空間快速切換，以提升任務管理效率。&lt;br&gt; -控制中心重構：採用最新的 Material Design 美學全面優化了控制中心界面和操作邏輯。&lt;br&gt; -剪切板升級：增強剪切板功能，支持快捷鍵「Windows 鍵 + V / Command + V」訪問歷史記錄，簡化內容管理。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-31e5336fef60aeba4e748aa77d18d5cb244.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日觀察&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-2a0ccdb00566a9d3ad038133136b3eee31f.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微信&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIyNDA0MjM4MA%3D%3D%26mid%3D2649518102%26idx%3D1%26sn%3Dea853ae3d1d4c6030b500ae21ab60820%26chksm%3Df00ddcf5c77a55e32cf5a221d62419c93280d09709c43ba15b6aa24c3575cf7390efeb8f3b8f&quot; target=&quot;_blank&quot;&gt;夜半談&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-1bf927795554e535d08fdbf09793ae8f502.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微博&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F2421203193%2FO69YioUgh&quot; target=&quot;_blank&quot;&gt;生活芯科技&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-b0e3bd1ad453972eab42ea2a8ada18f9ae2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微博&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1815369323%2FO6BYglY0I&quot; target=&quot;_blank&quot;&gt;喬忠良&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;今日推薦&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-3d80e5f9c5a5082466f21b598d417a6e509.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpassbolt%2Fpassbolt_api&quot; target=&quot;_blank&quot;&gt;https://github.com/passbolt/passbolt_api&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;事件點評&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-40301b39e04e7b4b0352352c9a25dc340a5.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;每日項目榜&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;每日 GitHub 精選&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-d0d1da6a4c6c9ec4dceb1e7f059577deb75.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;在線閲讀完整日報內容，訪問：&lt;/span&gt;&lt;/strong&gt;&lt;br&gt; &lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://report.oschina.net/api/files/jhim80u9qm1ofsw/ojkci7trx2o8oun/36_ai_ai_vite_press_1_0_BYIu9kQwRD.pdf&quot; target=&quot;_blank&quot;&gt;開源日報第 035 期：AI 手機需要新故事；做了十幾年的操作系統和 AI 應用，跨界到機器人領域；VitePress 1.0；蘋果曾試圖為安卓開發手錶&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/h4&gt; 
&lt;/blockquote&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;歡迎掃碼下載「開源中國 APP」&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;隨時在線閲讀完整日報內容 ↓&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7871d27245192b8ecfcd21043d309382749.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;889&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-842e51ced6d226559af1af95c8041338cb2.gif&quot; width=&quot;400&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284752</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284752</guid>
            <pubDate>Tue, 26 Mar 2024 03:38:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Redict：Redis 的一個獨立的 Copyleft 分支</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Redict 是由開發者 Drew DeVault 推出的一個&amp;nbsp;Redis OSS 7.2.4.2 的獨立、非商業性的分叉。基於 Redis OSS 的 BSD 3-Clause 源代碼，自此之後的所有更改均採用 Lesser&amp;nbsp;GNU General Public license（LGPL-3.0-only）。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;296&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-c9a0f9b14c09863d0ed266a9efd6915d926.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在許可證的選擇上，Drew DeVault 解釋稱，LGPL 是經過深思熟慮且平衡了多方面的考量之後的選擇，是&lt;span style=&quot;color:#000000&quot;&gt;最適合 Redict 的許可證&lt;/span&gt;。最重要的是，這是一個不可撤銷的承諾，即 Redict 將永遠是免費的。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;「這比 RedisLabs 聯合創始人、前首席執行官 Yiftach 在 2018 年做出的承諾要有力得多。通過使用 Copyleft 許可證，Redict 的所有更改都必須使用相同的 LGPL 自由軟件許可證發佈，從而保證軟件的修改版本將是免費的。」&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;此外，他保證 Redict 將不會使用任何形式的貢獻者許可協議。Redict 的版權由所有貢獻者共同擁有，Redict 許可證的變更將需要取得所有貢獻者的同意。從而使得 Redict 未來幾乎不可能出現類似 &lt;span style=&quot;color:#000000&quot;&gt;Redis&amp;nbsp;&lt;/span&gt;的許可證變更。&lt;/p&gt; 
&lt;p&gt;Drew DeVault 補充道，沒有選擇常用的&amp;nbsp;AGPL 或&amp;nbsp;EUPL 許可的原因在於，「我們希望讓用户儘可能輕鬆地遵守 Redict 許可證，而且我們認為沒有任何理由阻止雲廠商使用 Redict。」&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;選擇 LGPL 而不是 GPL，則是為了減少與 Redis 兼容模塊或 Lua 插件的集成會受到 GNU GPL 的「病毒式傳播」影響的擔憂。選擇 LGPL 既能保護 Redict 項目的未來，又能在這些問題之間取得最佳平衡。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;到目前為止，項目面向用户的變更包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;可執行文件已重命名為 redict-*，例如 redict-cli。&lt;/li&gt; 
 &lt;li&gt;Lua API 提供了與 Redis OSS API 兼容的「redict」 global，可通過「redis」 global 實現向後兼容。&lt;/li&gt; 
 &lt;li&gt;Module API symbols 已重命名，但是，Redict 保留了與 Redis OSS 模塊（最高版本 7.2.4）的 ABI 兼容性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Redict 旨在作為 Redis OSS 7.2.4 的直接替代品。接下來，Redict 的目的是繼續開發 Redis OSS 兼容軟件的自由軟件發行版，暫時只進行最小程度的破壞性更改。目前正在圍繞以下變更進行討論：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;利用這個機會刪除一些長期棄用的功能，例如「redis-trib」&lt;/li&gt; 
 &lt;li&gt;消除供應商依賴並轉向上遊 Lua、jemalloc&lt;/li&gt; 
 &lt;li&gt;減輕與下游的關聯性，刪除例如 systemd 或 upstart 服務&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;以及計劃分叉 Redict 的內部依賴項&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fredis%2Fhiredis&quot; target=&quot;_blank&quot;&gt;Hiredis&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;更多詳情可&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fredict.io%2Fposts%2F2024-03-22-redict-is-an-independent-fork%2F&quot; target=&quot;_blank&quot;&gt;查看官方公告&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;strong&gt;相關閲讀：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style=&quot;text-align:start&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/284082/redis-adopts-dual-source-available-licensing&quot; target=&quot;news&quot;&gt;Redis 不再「開源」，未來採用 SSPLv1 和 RSALv2 許可證&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284749/redict-independent-fork-redis</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284749/redict-independent-fork-redis</guid>
            <pubDate>Tue, 26 Mar 2024 03:28:35 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>工信部擬規範工業機器人行業管理</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;工業和信息化部裝備工業一司公開徵求對工業機器人行業規範條件及管理實施辦法（徵求意見稿）的意見，徵集截止日期為 2024 年 4 月 10 日。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「為落實《「十四五」機器人產業發展規劃》，進一步規範工業機器人行業管理，營造良好市場環境，我們對 2016 年以來發布的《工業機器人行業規範條件》和《工業機器人行業規範管理實施辦法》進行了修訂，形成了《工業機器人行業規範條件（2024 版）》（徵求意見稿）和《工業機器人行業規範管理實施辦法（2024 版）》（徵求意見稿），現向社會公開徵求意見。」&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height=&quot;332&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-0e0aa12963d2a68db6da214d7f97bc61c59.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;《工業機器人行業規範條件（2024 版）》（徵求意見稿）要求，依據國家法律法規設立，符合機器人產業發展政策要求，具有獨立法人資格，取得企業法人營業執照，且從事工業機器人相關業務時間不少於三年。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;同時，近三年，關鍵零部件製造企業營業收入年均不小於 3000 萬元；本體製造企業營業收入年均不小於 5000 萬元；集成應用企業營業收入年均不小於 1 億元。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;上年度營業收入小於 5000 萬元（含）的企業，近三年每年研發經費投入不低於營業收入的 5%；上年度營業收入在 5000 萬元至 2 億元（含）的企業，近三年每年研發經費投入不低於營業收入的 4%；上年度營業收入在 2 億元以上的企業，近三年每年研發經費投入不低於營業收入的 3%。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284737</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284737</guid>
            <pubDate>Tue, 26 Mar 2024 02:46:42 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>開源圖形編輯器 Inkscape 底層 UI 框架改用 GTK4</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;矢量圖形編輯器 Inkscape 開發分支的最新上游代碼已遷移至使用 GTK4，這是一次重大升級，同時也改進了架構，併為將來實現 GPU 加速做好了準備。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-8eae6c1e1874b541787e9278fd14b3a3d96.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmastodon.art%2F%40inkscape%2F112151266538190571&quot; target=&quot;_blank&quot;&gt;https://mastodon.art/@inkscape/112151266538190571&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Inkscape 通過其 Mastodon 賬户宣佈了向 GTK4 過渡的消息。由於各種問題，尤其是在 macOS 和 Windows 上的問題，下一個穩定版本（v1.4）仍將使用 GTK3。其開發團隊表示他們正在解決 Windows/MacOS 上的這些問題，希望 GTK4 版本的 Inkscape 在後續更新中有更好的表現。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-346fb9083f0607d9c44eb938ccec6b143cb.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284729/inkscape-switches-to-gtk4</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284729/inkscape-switches-to-gtk4</guid>
            <pubDate>Tue, 26 Mar 2024 02:16:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>nvitop —— GPU 進程管理的一站式解決方案</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;nvitop 是一種交互式 NVIDIA 設備和進程監控工具。它有一個豐富多彩的信息界面，可以不斷更新設備和進程的狀態。作為資源監控器，它包含許多功能和選項，例如樹視圖、環境變量查看、進程過濾、進程指標監控等。除此之外，該軟件包還為深度學習研究人員提供了 CUDA 設備選擇工具&lt;a href=&quot;https://github.com/XuehaiPan/nvitop#cuda-visible-devices-selection-tool&quot;&gt;&lt;code&gt;nvisel&lt;/code&gt;&lt;/a&gt;。它還提供方便的 API，允許開發人員編寫自己的監控工具。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;320&quot; src=&quot;https://static.oschina.net/uploads/space/2023/0322/154814_iQnD_4252687.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

&lt;p&gt;特性：&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;strong&gt;信息豐富且精美的輸出&lt;/strong&gt;：顯示比&lt;code&gt;nvidia-smi&lt;/code&gt;彩色精美方框繪圖更多的信息。&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;監控模式&lt;/strong&gt;：可以作為資源監控器運行，而不是隻打印一次結果。
	&lt;ul&gt;
		&lt;li&gt;條形圖和歷史圖&lt;/li&gt;
		&lt;li&gt;過程排序&lt;/li&gt;
		&lt;li&gt;過程過濾&lt;/li&gt;
		&lt;li&gt;通過擊鍵向進程發送信號&lt;/li&gt;
		&lt;li&gt;GPU 進程及其父進程的樹視圖屏幕&lt;/li&gt;
		&lt;li&gt;環境變量屏幕&lt;/li&gt;
		&lt;li&gt;幫助屏幕&lt;/li&gt;
		&lt;li&gt;鼠標支持&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;交互式&lt;/strong&gt;：在監控模式下響應用户輸入（來自鍵盤和/或鼠標）。（對比&lt;a href=&quot;https://github.com/wookayin/gpustat&quot;&gt;gpustat&lt;/a&gt;和&lt;a href=&quot;https://github.com/fbcotter/py3nvml&quot;&gt;py3nvml&lt;/a&gt;）&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;高效&lt;/strong&gt;：
	&lt;ul&gt;
		&lt;li&gt;&lt;a href=&quot;https://pypi.org/project/nvidia-ml-py&quot;&gt;直接使用 NVML Python 綁定&lt;/a&gt;查詢設備狀態，而不是解析&lt;code&gt;nvidia-smi&lt;/code&gt;的輸出（與&lt;a href=&quot;https://github.com/peci1/nvidia-htop&quot;&gt;nvidia-htop&lt;/a&gt;相比）&lt;/li&gt;
		&lt;li&gt;支持稀疏查詢並使用來自 cachetools 的 TTLCache 緩存結果（與&lt;a href=&quot;https://github.com/wookayin/gpustat&quot;&gt;gpustat&lt;/a&gt;相比）&lt;/li&gt;
		&lt;li&gt;使用 curses 庫顯示信息，而不是用 ANSI 轉義代碼打印（與&lt;a href=&quot;https://github.com/fbcotter/py3nvml&quot;&gt;py3nvml&lt;/a&gt;相比）&lt;/li&gt;
		&lt;li&gt;使用多線程異步收集信息並更快地響應用户輸入。（與&lt;a href=&quot;https://github.com/Syllo/nvtop&quot;&gt;nvtop&lt;/a&gt;相比）&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;便攜式&lt;/strong&gt;：適用於 Linux 和 Windows。
	&lt;ul&gt;
		&lt;li&gt;使用跨平台庫&amp;nbsp;&lt;a href=&quot;https://github.com/giampaolo/psutil&quot;&gt;psutil&lt;/a&gt;&amp;nbsp;獲取主機進程信息，而不是在子進程中調用&lt;code&gt;ps -p &amp;lt;pid&amp;gt;&lt;/code&gt;。（與&lt;a href=&quot;https://github.com/peci1/nvidia-htop&quot;&gt;nvidia-htop&lt;/a&gt;和&lt;a href=&quot;https://github.com/fbcotter/py3nvml&quot;&gt;py3nvml&lt;/a&gt;相比）&lt;/li&gt;
		&lt;li&gt;用純 Python 編寫，易於使用&lt;code&gt;pip&lt;/code&gt;安裝（與&lt;a href=&quot;https://github.com/Syllo/nvtop&quot;&gt;nvtop&lt;/a&gt;相比）&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;可集成&lt;/strong&gt;：易於集成到其他應用程序中，不僅僅是監控。（對比&lt;a href=&quot;https://github.com/peci1/nvidia-htop&quot;&gt;nvidia-htop&lt;/a&gt;和&lt;a href=&quot;https://github.com/Syllo/nvtop&quot;&gt;nvtop&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;281&quot; src=&quot;https://static.oschina.net/uploads/space/2023/0322/155406_yOXI_4252687.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/nvitop</link>
            <guid isPermaLink="false">https://www.oschina.net/p/nvitop</guid>
            <pubDate>Tue, 26 Mar 2024 02:10:00 GMT</pubDate>
        </item>
        <item>
            <title>每日一博 | 分佈式數據庫技術的演進和發展方向</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                    &lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=OGJkODIyMmU2YTFkZTIwYzMwNzU5NjZjZWRlM2M5OWQsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;這些年大家都在談分佈式數據庫，各大企業也紛紛開始做數據庫的分佈式改造。那麼，所謂的分佈式數據庫到底是什麼？採用什麼架構？優勢在哪？為什麼越來越多企業選擇它？分佈式數據庫技術會向什麼方向發展？帶着這些疑問，一探究竟吧！參與文末的話題互動，更有機會贏取精美獎品~&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;分佈式數據庫的架構演進&lt;/h1&gt; 
&lt;p&gt;隨着數據量的爆發增長，傳統集中式數據庫面臨極大的挑戰：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;性能瓶頸：&lt;/strong&gt;數據規模爆發增長，傳統集中式數據庫難以維持數據量大時的性能，而分佈式數據庫的性能可以水平擴展；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;缺失混合負載能力：&lt;/strong&gt;數據量爆發增長帶來對數據分析（OLAP）需求的增長。企業需要使用兩套系統分別支撐事務交易（OLTP）和數據分析（OLAP），不僅造成了大量的數據冗餘，同時增加了系統的複雜度和運維難度。而分佈式數據庫的混合負載能力可大幅度提升分析的時效性，減少數據冗餘，並大大提高靈活性；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;高昂成本：&lt;/strong&gt;集中式數據庫水平擴展難，可靠性需要付出高昂的成本。而分佈式數據庫的架構支持靈活擴展，實現高可用方案的成本較低。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;分佈式數據庫與單機數據庫的不同在於其可以將核心功能擴展到多台節點，甚至多個地域，包括事務管理、數據存儲和數據查詢等。從實現方式上看，分佈式數據庫主要有 3 種不同的技術路線：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1. 分佈式中間件 + 單機數據庫&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;這條路線本質上是分佈式系統由兩部分組成：&lt;/p&gt; 
&lt;p&gt;a) 上層是分佈式中間件：維護一套統一的分片規則，提供 SQL 解析，請求轉發和結果合併的能力。&lt;/p&gt; 
&lt;p&gt;b) 底層單機數據庫：開源 MySQL 或 PG 單機數據庫，提供數據存儲和執行能力。&lt;/p&gt; 
&lt;p&gt;這種方式主要使用比較成熟的內核來解決擴展性的問題，所以生態友好、成本較低，也比較容易實現。&lt;/p&gt; 
&lt;p&gt;不過，缺點也顯而易見。比如功能降級、在全局事務能力和高可用等方面存在短板，需要有針對性增強，導致整個方案的複雜度高、機器冗餘多。最重要的是，因為使用的是開源產品的內核，數據庫會始終受制於開源代碼修改、專利、發行方式等很多方面的風險，這種形式顯然無法滿足當前國內金融、政企客户的需求。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=YjFlYTkzMzMzNDQ5MTk4MjQ3ZmIzOGQ1MzYwMjA0YzMsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;strong&gt;2. 基於分佈式存儲的分佈式數據庫。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;這種形態基於分佈式存儲，再疊加數據庫能力。大部分公有云數據庫採用這條技術路線。華為雲 GaussDB(for MySQL) 就是這種形態的典型代表。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=NDIxMThjMTc3MWIwMWFiMTY3MDZhNTU0ZjU5ODI0ZTYsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;這條路線有限地解決了擴展性問題，數據一致性主要依賴分佈式存儲引擎。上層的計算節點無狀態，共享存儲提供跨節點讀寫。這種架構充分利用分佈式存儲提供的高級特性，更容易形成技術競爭力。但是這種架構的擴展性有限，尤其是寫節點。&lt;/p&gt; 
&lt;p&gt;另外，這種架構對底座（分佈式存儲）有比較重的依賴，線下實現的成本高。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3. 原生分佈式數據庫。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;這種形態是基於分佈式數據庫理論實現的分佈式數據庫。這條路線是根據分佈式一致性協議做底層設計。原生分佈式數據庫將分佈式存儲、事務和計算結合在一起，數據由系統自動打散並存儲多個副本，通過一致性協議保證多個副本和事務的一致性。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=ZjhiNTM5OGY0MzhiMTdiOTExNTQ2YTY5YTUzYmM4ZDgsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;這種形態更容易在數據庫本身所擅長的領域發揮優勢，比如説性能、複雜 SQL 處理能力、企業級能力。集羣的擴展和收縮對應用透明，按需擴展，支持大規模部署限制；數據一致性由事務層一致性協議保護，安全性更高；靈活部署，多活架構，對硬件的依賴低，可以通過普通服務器實現集羣和高可用。&lt;/p&gt; 
&lt;p&gt;因為金融政企客户在使用分佈式技術之前，往往已經有分庫分表、使用分佈式中間件產品的經驗，所以對原生分佈式架構的認可度更高，學習成本也相對較低，因此，這種形態也是國內當前被採用較多的一種。&lt;/p&gt; 
&lt;p&gt;華為雲 GaussDB 分佈式數據庫就是這種形態的典型代表。GaussDB 基於華為在數據庫領域 20 多年的戰略投入，已經在金融行業積累了非常豐富的實踐經驗，是企業數字化轉型、核心數據上雲、分佈式改造的信賴之選。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;原生分佈式數據庫的挑戰和關鍵技術&lt;/h1&gt; 
&lt;p&gt;原生分佈式數據庫基於分佈式數據庫理論，是一款對於用户應用透明的分佈式數據庫。不過，實現分佈式關係數據庫有幾個關鍵挑戰：&lt;/p&gt; 
&lt;p&gt;第一，安全可信。&lt;/p&gt; 
&lt;p&gt;分佈式、雲化環境的複雜性增加了安全風險，比如數據泄露和丟失的風險增加，身份認證和訪問控制以及數據傳輸、存儲安全的控制難度提升。&lt;/p&gt; 
&lt;p&gt;第二，事務系統的正確性及性能。&lt;/p&gt; 
&lt;p&gt;分佈式數據庫中經常有一次操作涉及多台數據庫的場景，需要一種方案來維護整個數據庫集羣事務的 ACID 特性，避免出現部分成功部分失敗等無法接受的情況。&lt;/p&gt; 
&lt;p&gt;另外，在大併發場景下事務管理器容易成為性能的單點瓶頸，比如獲取事務唯一標識、全局快照、頻繁交互導致大量的網絡通信和鎖等待等。&lt;/p&gt; 
&lt;p&gt;第三，分佈式查詢能力。&lt;/p&gt; 
&lt;p&gt;在分佈式系統中，需要在最短時間內獲取準確的查詢結果，提升查詢性能。&lt;/p&gt; 
&lt;p&gt;第四，高可用能力。&lt;/p&gt; 
&lt;p&gt;分佈式數據庫需要確保異常場景下（如：節點硬件故障或者 Bug 宕機等）數據庫系統的連續可用。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=MDc0NjM2NWQyZGI5YmI0ZjQwMzYzZDVjMzU2MzMyYmIsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;分佈式數據庫的挑戰和關鍵技術&lt;/p&gt; 
&lt;p&gt;GaussDB 分佈式數據庫研發了一系列高性能、高可用、安全特性迎接上述四大挑戰，下面挑選幾個有代表性的特性加以説明。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_3&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;全密態&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;傳統的加密方式在服務端加密，密鑰管理員是可以獲取的。而全密態數據庫的密鑰掌握在用户自己手上，數據庫管理員無法獲取，加解密過程僅在客户側完成，數據在存儲、傳輸、查詢整個生命週期過程中均以密文形態存在，避免管理員惡意獲取密鑰解密數據。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=NTliMTZjNGU0OWY0ZTVlMmZjNmYzYWNlY2MwYjgxMjAsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;全密態數據庫&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_4&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;分佈式事務 GTM-Lite&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;如下圖所示，GaussDB 沒有采用傳統的事務列表的管理方式，而是提供了一個 CSN（提交系列號），通過對比 CSN 的大小來實現事務可見性判斷。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=MGMwYjFhNjIzYzBjMTY2Y2U5NTZiOTVlOWIwM2NhYTAsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;GTM-Lite 技術示意&lt;/p&gt; 
&lt;p&gt;當事務開始時，根據事務隔離級別的不同，從 GTM-Lite 獲取一個 CSN 值，作為這個事務的查詢快照點（如果是可重複讀，只需要在事務開始時獲取一次 CSN 值，如果是讀已提交，每次 SELECT 時都需要重新取一次 CSN 值）。&lt;/p&gt; 
&lt;p&gt;當事務提交時，向 GTM-Lite 申請一個新的 CSN 值，作為這個事務提交 CSN 值，並記錄到事務提交記錄中。&lt;/p&gt; 
&lt;p&gt;GTM-Lite 技術通過 CSN 提交序列號進行可見性判斷，無需耗費大量計算資源來遍歷列表；無鎖化原子操作提供 CSN 序列號，無需鎖等待；節點間事務交互僅需要一個 CSN，網絡開銷跟事務規模無關。在保證事務全局強一致的同時，提供高性能的事務處理能力，避免了單 GTM 的性能瓶頸。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_5&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;分佈式查詢優化&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;1. 分佈式執行&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;GaussDB 是如何處理分佈式數據庫集羣中的業務應用 SQL 的呢？&lt;/p&gt; 
&lt;p&gt;1）業務應用的 SQL 會下發給 CN 節點；&lt;/p&gt; 
&lt;p&gt;2）CN 利用數據庫的優化器生成分佈式的執行計劃，每個 DN 會按照執行計劃的要求處理數據；&lt;/p&gt; 
&lt;p&gt;3）數據基於一致性 Hash 算法分佈在每個 DN，因此 DN 在處理數據的過程中，可能需要從其他 DN 獲取數據，GaussDB 提供三種 stream 流（廣播流 broadcast、聚合流 gather 和重分佈流 redistribute）實現數據在 DN 間的流動；&lt;/p&gt; 
&lt;p&gt;4）DN 將結果集返回給 CN 進行彙總；&lt;/p&gt; 
&lt;p&gt;5）CN 將彙總的結果返回給業務應用。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=YTk0NjQzMTk0OGUxOWMwYjNjMjA3NzI4ZmIxOWIyN2YsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;分佈式查詢示意&lt;/p&gt; 
&lt;p&gt;讓我們展開看一下節點間的數據交換。比如某條 SQL 的執行邏輯如下圖所示：&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=Y2U2NDcxODQ4YTAyMTJhMDBkYmMwMWU3NjhlMGZmMTcsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;SQL 執行邏輯&lt;/p&gt; 
&lt;p&gt;以兩個 DN 為例， 在執行過程中，DN 會按照 redistribute 鍵將數據發送到對應的節點。&lt;/p&gt; 
&lt;p&gt;Redistribute 算子接收到 C/D 兩表 join 的數據之後，根據重分佈鍵計算將數據發給 DN1 還是 DN2，Redistribute Collector 收集到重分佈之後的數據之後發給上層的 Join 算子再做 Join 計算。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=MWI5OWMzMTUzNjVlYzdjODRhYzkxYTg0N2U4N2MyYTUsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;CN、DN 間的數據流動&lt;/p&gt; 
&lt;p&gt;另外，GaussDB 的優化器會根據統計信息選取針對當前 SQL 性能最優的 Stream 流算子完成 CN、DN 間的數據流動。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2. 全並行架構&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;GaussDB 採用全並行架構，從 MPP 節點並行、SMP 線程並行、到 SIMD 指令並行，到 LLVM CodeGen 技術，全面挖掘系統計算資源的潛力，提升查詢性能。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=OTdjY2NjYjA2NjRhMDViODE3MzM1ZTY0M2FiYTM3MTEsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_6&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;高可用&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;1. GaussDB 重做日誌&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;重做日誌在如下場景可以發揮作用，提升系統的可用性&lt;/p&gt; 
&lt;p&gt;1）當數據庫發生故障，如宕機，可以通過重做日誌文件恢復數據。&lt;/p&gt; 
&lt;p&gt;2）HA 架構下，主備通過重做日誌文件進行數據同步。&lt;/p&gt; 
&lt;p&gt;3）備份恢復時，通過歸檔重做日誌文件實現 PITR。&lt;/p&gt; 
&lt;p&gt;GaussDB 使用 WAL (Write Ahead Log) 機制實現重做日誌，在提升可用性的同時兼顧性能，即在數據修改時遵循 no-force-at-commit 策略，在提交時並不強制寫。為了保證數據在數據庫發生故障時可以恢復，通過 Redo 機制，用連續的、順序的日誌條目的寫出將隨機的、分散的數據塊的寫出推延，這個推延使得數據的寫出可以獲得批量效應的性能提升。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2. 分佈式部署&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;GaussDB 支持多種高可用部署形態，保證系統的穩定性和可靠性。下面我們看兩個典型案例。&lt;/p&gt; 
&lt;p&gt;1）兩地三中心。&lt;/p&gt; 
&lt;p&gt;同城有兩個雙活數據中心，兩個數據中心同時承載業務，異地一個容災數據中心；同城可實現節點級、AZ 級、數據中心級等故障高可用，同時提供跨城的異地容災能力。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=ODU0Yzc1ZmUzNjliNTdmYzdmNTc3ODEwMmRjZDc3MjgsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;GaussDB 兩地三中心高可用部署&lt;/p&gt; 
&lt;p&gt;2）同城 3AZ 高可用+異地容災。&lt;/p&gt; 
&lt;p&gt;同城採用邏輯 3AZ、3 副本部署，異地採用單 AZ、3 副本部署，提供了同城抵禦節點級故障和 AZ 級故障的能力，跨城的 Region 級容災的能力。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=ZTNlZjJiNWNiNzg5Y2ZkMjVjMGVkMWY4OTBiM2Q4MWEsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;GaussDB 同城 3AZ 高可用+異地容災&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_7&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;分佈式數據庫技術的發展方向&lt;/h1&gt; 
&lt;p&gt;基於新需求、新場景、以及全池化架構、新網絡和大模型等新技術的出現，我們認為分佈式數據庫技術主要向以下六個方向發展。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=Mzc4MzRhNjFlYjE1YTI4ZWRmYjkzMTEyMTM5YTg4NGYsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;分佈式數據庫技術的發展方向&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_8&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;高可用能力的持續提升&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;高可用是目前大多數金融政企客户首要關注的問題，特別是對於多地、多中心容災有要求的客户。針對這樣的客户，華為雲 GaussDB 已經提供了多種解決方案，如支持同城雙活、異地容災、兩地三中心的解決方案，支持同城雙活強同步的解決方案，支持異步數據複製、多地多活的高可用解決方案。&lt;/p&gt; 
&lt;p&gt;面向未來，分佈式數據庫將具備真正全球部署能力的多活架構。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_9&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;軟硬件深度協同&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;硬件和軟件兩者之間相輔相成，互相促進。利用新型硬件（GPU、FPGA、高速網絡）和華為在芯片、服務器、存儲、網絡、操作系統、數據庫的全棧軟硬件能力，提升性能和高可用能力。&lt;/p&gt; 
&lt;p&gt;首先，數據庫的持久化邏輯，深度整合到了計算與存儲分離的技術底座中，分佈式數據庫可以獲得在容量、彈性、擴展性方面的巨大提升，同時能提供給客户一致的體驗。&lt;/p&gt; 
&lt;p&gt;其次，從計算節點卸載下推到存儲中，特別是對一些複雜的查詢處理，同時疊加並行處理能力，使得這些計算邏輯能充分利用下面整個存儲池的能力，同時最關鍵的是能做到對業務透明。&lt;/p&gt; 
&lt;p&gt;最後，就是高性能。高性能的實現除了 I/O 聚合之外，單條交易的本質就是網絡的時延和處理的時延。所以，網絡對於分佈式數據庫的時延（性能）影響是巨大的。&lt;/p&gt; 
&lt;p&gt;總而言之，軟硬協同帶給我們的不僅僅是性能擴展方面的優勢，更是可以通過軟硬協同打造真正企業級的可靠性。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_10&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;企業級混合負載 （HTAP）&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;近年來企業級混合負載（HTAP）的興起，旨在打破事務處理（TP）和分析（AP）之間的壁壘。分佈式數據庫都應具備混合負載能力，即在支持高併發、事務性請求的同時，對分析型的複雜查詢提供了良好的支持，從而大幅度降低成本，同時提高企業決策的效率。&lt;/p&gt; 
&lt;p&gt;HTAP 架構的核心技術：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第一，透明路由&lt;/strong&gt;。通過自動選擇行存引擎、列存引擎以及行列組合，提供查詢的準確性和實時性，增加客户的易用性，提升 HTAP 產品的商用價值。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第二，性能提升&lt;/strong&gt;。TP 要求的是低時延、高吞吐，而 AP 要求的是複雜查詢的能力。常規執行優化技術包括並行執行、編譯執行、向量化執行等，在這些技術的基礎上進一步加速複雜查詢，支撐企業級混合負載。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第三，數據新鮮度&lt;/strong&gt;。保證數據高新鮮度、高性能，保證 HTAP 架構能夠具備更多應對用户的能力。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第四，資源隔離&lt;/strong&gt;。用户對 TP 性能要求比較高，在引入實時 AP 的同時，不能影響 TP 的能力和性能，需要在資源隔離、數據新鮮度以及性能的提升方面做好權衡。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_11&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;雲原生多主&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;單一架構其實並不能解決今天行業碰到的所有問題，但云原生多主架構可以幫助解決兩類問題：&lt;/p&gt; 
&lt;p&gt;第一個，是高可用的問題，希望能基於多主架構，解決切換時業務中斷的問題。&lt;/p&gt; 
&lt;p&gt;第二個，是擴展性的問題，基於多主架構，融合軟硬協同的進展，真正能在計算節點以下，持續提升產品的性能和彈性。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_12&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;數據安全可信&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;當今世界，每個國家、組織和個人都在關注安全、合規和隱私的問題，幾年前數據無保護隨意獲取並使用的便利不再，這也促進了技術的進步和落地。未來，全行業都會面臨越來越嚴格的對於可信安全方面的要求。&lt;/p&gt; 
&lt;p&gt;全密態是華為雲數據庫為了提升隱私保護能力研製的一項關鍵技術，全密態支持數據在整個計算過程中同樣是以密文形式存在，實現了讓整個敏感數據在全生命週期當中都得到保護。因此，無論數據處於何種狀態，攻擊者都無法獲取到有效信息，從而保障了企業數據全生命週期的隱私安全。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_13&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;AI-Native&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;機器學習已被廣泛用於優化數據管理問題，如數據清理、數據分析、查詢重寫、數據庫診斷等。然而，傳統的機器學習算法無法解決泛化和推理問題。幸運的是，大模型（LLM）可以幫助解決這些限制，為智能化數據管理提供了很好的機會。&lt;/p&gt; 
&lt;p&gt;藉助 AI/LLM，未來分佈式數據庫將朝着全流程、全鏈路、高效易用的智能化數據庫的方向發展，在數據庫諮詢、開發、運維等關鍵階段，構建相應的自動化能力：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第一，諮詢階段，提供專家式輔助，制定精細化方案。&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;HLD 助手&lt;/strong&gt;，結合專家經驗，自動生成數據庫 HLD；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;DB 知識庫&lt;/strong&gt;，通過積累運維工單、答疑、文檔手冊等，形成數據庫行業知識庫；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;問答助手&lt;/strong&gt;，通過提供 ChatBot，實現交互式運維。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;第二，開發階段，提供開發輔助，提升 SQL 開發效率。&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;通過構建 NL2SQL 轉換能力，讓自然語言轉換為 SQL 語句；&lt;/li&gt; 
 &lt;li&gt;同時，增強的 SQL 轉換能力提升異構數據庫間的 SQL 語句轉換自動化率。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;第三，運維階段，實現預測性維護，提升系統可靠性。&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;智能巡檢&lt;/strong&gt;，可以構築 Schema/SQL、中間件/告警等全鏈路可觀測可跟蹤能力；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;智能故障處理&lt;/strong&gt;，通過全鏈路感知編排，提供精準分析，快速定位故障並給出建議；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;SQL 質量提升能力&lt;/strong&gt;，可以快速找出問題 SQL，診斷根因，提供全局分析。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;綜上，分佈式數據庫性能卓越，憑藉高可用、高可擴展性、高性價比等優勢，已經被對數據庫要求最嚴苛的金融行業所認可，並逐漸被應用在更廣闊的領域。不過，從總體發展狀態來看，目前還處於早期，但發展方向明朗，上升空間很大。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_14&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;參與有獎&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;GaussTech 技術專欄第一期&lt;/strong&gt;&lt;strong&gt;話題討論：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;對於分佈式數據庫的未來發展，你怎麼看？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;1.你認為分佈式是數據庫未來的發展趨勢嗎？&lt;/p&gt; 
&lt;p&gt;2.哪種架構會得到更多企業的青睞？&lt;/p&gt; 
&lt;p&gt;3.分佈式數據庫技術又會向什麼方向發展？&lt;/p&gt; 
&lt;p&gt;點擊&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fforum%2Fthread-02109146796596102026-1-1.html%3Futm_source%3Doschina%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;鏈接&lt;/a&gt;&lt;/strong&gt;，即可參與「&lt;strong&gt;GaussTech 技術專欄第一期」話題討論&lt;/strong&gt;，就有機會獲得 HUAWEI mini 藍牙音箱 _綺境森林、《華為數據之道》書籍、新貴族系列中性筆、平裝套芯筆記本、GaussDB 字母筆、炫彩馬卡龍指甲刀等好禮，快來參與吧！&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%3Futm_source%3Doschina%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;點擊關注，第一時間瞭解華為雲新鮮技術~&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://my.oschina.net/u/4526289/blog/11049010</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4526289/blog/11049010</guid>
            <pubDate>Tue, 26 Mar 2024 02:03:00 GMT</pubDate>
            <author>原創</author>
        </item>
    </channel>
</rss>