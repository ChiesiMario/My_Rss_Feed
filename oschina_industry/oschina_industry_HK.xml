<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-綜合資訊]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 28 Feb 2024 02:16:21 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[GreatSQL TPC-H 性能測試報告正式發佈！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img height="383" src="https://oscimg.oschina.net/oscnet/up-93f0563f25f5317db04df95a53c0bcc8c0f.png" width="900" referrerpolicy="no-referrer"></p><p style="text-align:center">GreatSQL TPC-H 性能測試報告 - （2024 年 2 月 28 日）</p><p>完整性能測試報告：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgreatsql.cn%2Fdocs%2F8032-25%2Fuser-manual%2F10-optimze%2F3-3-benchmark-greatsql-tpch-report.html" target="_blank">https://greatsql.cn/docs/8032-25/user-manual/10-optimze/3-3-benchmark-greatsql-tpch-report.html</a></p><h2>1、概述</h2><p>本次測試針對 GreatSQL 數據庫基於標準 TPC-H 場景的測試。</p><p>TPC-H（商業智能計算測試）是美國交易處理效能委員會（TPC，TransactionProcessing Performance Council）組織制定的用來模擬決策支持類應用的一個測試集。目前，學術界和工業界普遍採用 TPC-H 來評價決策支持技術方面應用的性能。這種商業測試可以全方位評測系統的整體商業計算綜合能力，對廠商的要求更高，同時也具有普遍的商業實用意義，目前在銀行信貸分析和信用卡分析、電信運營分析、税收分析、煙草行業決策分析中都有廣泛的應用，TPC-H 查詢包含八張數據表和 22 條複雜 SQL 查詢，大多數查詢包含多表聯接（JOIN）、子查詢和聚合查詢等。</p><p>GreatSQL 數據庫是一款<strong>開源免費</strong>數據庫，可在普通硬件上滿足金融級應用場景，具有<strong>高可用</strong>、<strong>高性能</strong>、<strong>高兼容</strong>、<strong>高安全</strong>等特性，可作為 MySQL 或 Percona Server for MySQL 的理想可選替換。</p><h2>2、測試環境</h2><table><tbody><tr><th>配置</th><th>備註</th></tr></tbody><tbody><tr><td>操作系統</td><td>OS：CentOS Linux release 7.9.2009 (Core)<br> 內核：3.10.0-1160.el7.x86_64</td></tr><tr><td>CPU</td><td>Intel(R) Xeon(R) Gold 6238 CPU @ 2.10GHz * 4</td></tr><tr><td>內存</td><td>251G</td></tr><tr><td>磁盤</td><td>INTEL SSDPE2KE032T8</td></tr><tr><td>數據庫</td><td>GreatSQL 8.0.32-25, Release 25, Revision 79f57097e3f</td></tr></tbody></table><p><strong>提示</strong>：在下面運行 TPC-H 測試時，設置了 Rapid 引擎最大可使用的內存及線程數。</p><pre><code class="language-sql">greatsql&gt; SET GLOBAL rapid_memory_limit = 68719476736;
greatsql&gt; SET GLOBAL rapid_worker_threads = 32;
</code></pre><h2>3、測試表結構和數據量</h2><p>各表數據量對比：</p><table><tbody><tr><th>表名</th><th>TPC-H SF100 數據量</th><th>TPC-H SF300 數據量</th><th>備註</th></tr></tbody><tbody><tr><td>region</td><td>5</td><td>5</td><td>地區信息</td></tr><tr><td>nation</td><td>25</td><td>25</td><td>國家表</td></tr><tr><td>supplier</td><td>1000000</td><td>3000000</td><td>供應商信息</td></tr><tr><td>part</td><td>20000000</td><td>60000000</td><td>零件表</td></tr><tr><td>customer</td><td>15000000</td><td>45000000</td><td>消費者表</td></tr><tr><td>partsupp</td><td>80000000</td><td>240000000</td><td>配件供應表</td></tr><tr><td>orders</td><td>150000000</td><td>450000000</td><td>訂單表</td></tr><tr><td>lineitem</td><td>600037902</td><td>1799989091</td><td>訂單明細表</td></tr></tbody></table><p>Rapid 引擎表空間壓縮率：</p><table><tbody><tr><th>庫名</th><th>InnoDB 表空間文件總大小</th><th>Rapid 引擎表空間總大小</th><th>壓縮率</th></tr></tbody><tbody><tr><td>TPC-H SF100</td><td>184570593436</td><td>28728373248</td><td>6.42</td></tr><tr><td>TPC-H SF300</td><td>591644573888</td><td>74334864443</td><td>7.96</td></tr></tbody></table><p>各表結構關係如下圖所示：</p><p><img height="720" src="https://oscimg.oschina.net/oscnet/up-1c9a6376e22d965db5c040dd053da59ae6a.png" width="756" referrerpolicy="no-referrer"></p><h2>4、測試結果</h2><p>GreatSQL 8.0.32-25 中，採用全新的 Rapid 存儲引擎，使得其在 TPC-H 性能測試中表現大大優於此前的其他版本，也大大優於 MySQL 社區版、Percona Server MySQL、MariaDB 等數據庫。</p><p>在 TPC-H SF100 場景下，運行完全部 22 個 TPC-H 查詢 SQL 總耗時為<strong>79.28 秒</strong>。在 TPC-H SF300 場景下，運行完全部 22 個 TPC-H 查詢 SQL 總耗時為<strong>386.195 秒</strong>。</p><p>每條 SQL 詳細耗時如下：</p><table><tbody><tr><th>TPC-H Query</th><th>GreatSQL TPC-H SF100（32C64G）耗時（秒）</th><th>GreatSQL TPC-H SF300（32C64G）耗時（秒）</th></tr></tbody><tbody><tr><td>Q1</td><td>1.184</td><td>3.537</td></tr><tr><td>Q2</td><td>0.924</td><td>3.865</td></tr><tr><td>Q3</td><td>1.324</td><td>4.167</td></tr><tr><td>Q4</td><td>3.678</td><td>22.712</td></tr><tr><td>Q5</td><td>1.287</td><td>4.119</td></tr><tr><td>Q6</td><td>0.344</td><td>0.959</td></tr><tr><td>Q7</td><td>5.48</td><td>50.217</td></tr><tr><td>Q8</td><td>1.13</td><td>3.534</td></tr><tr><td>Q9</td><td>7.311</td><td>31.872</td></tr><tr><td>Q10</td><td>2.885</td><td>15.301</td></tr><tr><td>Q11</td><td>0.477</td><td>0.921</td></tr><tr><td>Q12</td><td>0.799</td><td>2.294</td></tr><tr><td>Q13</td><td>3.758</td><td>10.997</td></tr><tr><td>Q14</td><td>0.966</td><td>2.471</td></tr><tr><td>Q15</td><td>2.831</td><td>11.898</td></tr><tr><td>Q16</td><td>1.194</td><td>3.487</td></tr><tr><td>Q17</td><td>8.537</td><td>27.523</td></tr><tr><td>Q18</td><td>13.007</td><td>108.237</td></tr><tr><td>Q19</td><td>1.892</td><td>4.046</td></tr><tr><td>Q20</td><td>4.21</td><td>10.668</td></tr><tr><td>Q21</td><td>11.965</td><td>60.084</td></tr><tr><td>Q22</td><td>2.513</td><td>3.286</td></tr><tr><td>總耗時</td><td><strong>77.696</strong></td><td><strong>386.195</strong></td></tr></tbody></table><p>GreatSQL SF100 vs SF300（32C64G）對比示意圖如下</p><p><img height="400" src="https://oscimg.oschina.net/oscnet/up-a576e5fe8987d0e3b32a49b4122e603c754.png" width="981" referrerpolicy="no-referrer"></p><h2>5、測試步驟</h2><h3>5.1 安裝 GreatSQL</h3><p>請參考 GreatSQL 手冊內容：<strong>安裝指南</strong> ➥https://greatsql.cn/docs/8032-25/user-manual/4-install-guide/0-install-guide.html，完成 GreatSQL 安裝。</p><h3>5.2 生成 TPC-H 測試數據</h3><p>請參考 GreatSQL 手冊內容：<strong>TPC-H 性能測試</strong> ➥https://greatsql.cn/docs/8032-25/user-manual/10-optimze/3-2-benchmark-tpch.html，完成 TPC-H 工具編譯安裝。</p><p>運行 TPC-H <code>dbgen</code> 工具，生成數據文件，一共會生成 8 個表對應的 tbl 數據文件，例如：</p><pre><code class="language-shell">$ ./dbgen -vf -s 100
...

$ ls -l *tbl
-rw-r--r-- 1 root root  2463490271 Sep 26 09:20 customer.tbl
-rw-r--r-- 1 root root 79579694556 Sep 26 09:20 lineitem.tbl
-rw-r--r-- 1 root root        2224 Sep 26 09:20 nation.tbl
-rw-r--r-- 1 root root 17793116301 Sep 26 09:20 orders.tbl
-rw-r--r-- 1 root root 12209211160 Sep 26 09:20 partsupp.tbl
-rw-r--r-- 1 root root  2453234158 Sep 26 09:20 part.tbl
-rw-r--r-- 1 root root         389 Sep 26 09:20 region.tbl
-rw-r--r-- 1 root root   142869803 Sep 26 09:20 supplier.tbl
</code></pre><p>也可以參考 <strong>duckdb_dbgen.py</strong> ➥ <a href="https://gitee.com/GreatSQL/GreatSQL-Doc/blob/master/tpch/3.0.1/duckdb_dbgen.py">https://gitee.com/GreatSQL/GreatSQL-Doc/blob/master/tpch/3.0.1/duckdb_dbgen.py</a> 腳本做法，利用 duckdb 並行生成測試數據。</p><h3>5.3 創建 TPC-H 測試數據庫表並導入數據</h3><p>參考 GreatSQL 社區提供的 TPC-H 數據庫表初始化腳本：<strong>tpch-create-table.sql</strong> ➥ <a href="https://gitee.com/GreatSQL/GreatSQL-Doc/blob/master/tpch/3.0.1/tpch-create-table.sql%EF%BC%8C%E5%AE%8C%E6%88%90TPC-H%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%88%9B%E5%BB%BA%E3%80%82">https://gitee.com/GreatSQL/GreatSQL-Doc/blob/master/tpch/3.0.1/tpch-create-table.sql，完成 TPC-H 測試數據庫表創建。</a></p><pre><code class="language-shell">$ mysql -f &lt; tpch-create-table.sql
$ mysqlshow tpch100
Database: tpch100
+----------+
|  Tables  |
+----------+
| customer |
| lineitem |
| nation   |
| orders   |
| part     |
| partsupp |
| region   |
| revenue0 |
| supplier |
+----------+
</code></pre><p>利用 GreatSQL 的 <strong>parallel load data 特性</strong> ➥ <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgreatsql.cn%2Fdocs%2F8032-25%2Fuser-manual%2F5-enhance%2F5-1-highperf-parallel-load.html" target="_blank">https://greatsql.cn/docs/8032-25/user-manual/5-enhance/5-1-highperf-parallel-load.html</a> 並行導入 TPC-H 測試數據。</p><p>需要先修改 GreatSQL 選項<code>secure_file_priv</code>設置，指向上述 workdir 所在目錄，重啓 GreatSQL 使之生效。</p><p>參考 GreatSQL 社區提供的併發導入腳本：<strong><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fload-data-parallel.sh" target="_blank">load-data-parallel.sh</a></strong> ➥ <a href="https://gitee.com/GreatSQL/GreatSQL-Doc/blob/master/tpch/3.0.1/load-data-parallel.sh%EF%BC%8C%E5%AE%8C%E6%88%90%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E3%80%82">https://gitee.com/GreatSQL/GreatSQL-Doc/blob/master/tpch/3.0.1/load-data-parallel.sh，完成數據導入。</a></p><p><strong>提示</strong>：運行 LOAD DATA 導入數據時，可能會在 <code>tmpdir</code> 產生臨時文件，因此要保證 <code>tmpdir</code> 有足夠的剩餘可用磁盤空間。</p><h3>5.4 確認 Rapid 引擎設置，並加載數據到 secondary engine</h3><p>數據導入完成後，在開始運行 TPC-H 測試前，需要先將測試數據加載到 secondary engine 引擎中。</p><p>先執行下面命令，動態修改 Rapid 引擎最大可使用內存，其餘相關選項均為默認值：</p><pre><code class="language-sql">greatsql&gt; SET GLOBAL rapid_memory_limit = 68719476736;
greatsql&gt; SET GLOBAL rapid_worker_threads = 32;
</code></pre><p>之後，執行以下命令加載測試數據到 secondary engine：</p><pre><code class="language-sql">greatsql&gt; alter table customer secondary_load;
alter table lineitem secondary_load;
alter table nation secondary_load;
alter table orders secondary_load;
alter table part secondary_load;
alter table partsupp secondary_load;
alter table region secondary_load;
alter table supplier secondary_load;
</code></pre><p>這個過程需要一定時間，請耐心等待。</p><h3>5.5 執行 TPC-H 測試</h3><p>參考 GreatSQL 社區提供的 TPC-H 性能測試腳本，完成測試，並記錄各個 SQL 的耗時。</p><p>該測試腳本大概工作模式如下：</p><ol><li><p>先執行 22 個查詢 SQL，進行數據預熱，每條 SQL 各執行 2 次。</p></li><li><p>再分別執行 22 個查詢 SQL，每個 SQL 各執行 3 次。</p></li><li><p>每次執行 SQL 都會記錄其起止時間，及其耗時，如下面例所示：</p></li></ol><pre><code class="language-shell">[2023-09-27 01:38:45] BEGIN RUN TPC-H Q1 1 times
[2023-09-27 01:38:46] TPC-H Q1 END, COST: 1.301s


[2023-09-27 01:38:46] BEGIN RUN TPC-H Q1 2 times
[2023-09-27 01:38:47] TPC-H Q1 END, COST: 0.787s
</code></pre><p>上述結果中的 COST: 1.301s ，即為本 SQL 的運行耗時：1.301 秒。</p><p>完整性能測試報告：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgreatsql.cn%2Fdocs%2F8032-25%2Fuser-manual%2F10-optimze%2F3-3-benchmark-greatsql-tpch-report.html" target="_blank">https://greatsql.cn/docs/8032-25/user-manual/10-optimze/3-3-benchmark-greatsql-tpch-report.html</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 28 Feb 2024 01:50:12 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280571</guid>
            <link>https://www.oschina.net/news/280571</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[馬斯克抱怨微軟 Windows 難用，V 神：加入 Linux！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>特斯拉 CEO 埃隆・馬斯克在社交平台説道，上週末他購買了一台新款的 Windows 11 筆記本電腦，卻發現必須創建微軟賬户 (MSA) 才能使用系統，這讓他感到非常憤怒，認為這變相地讓微軟的人工智能 (AI) 訪問了他的數據。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-e5e820c2d6e02c58e0b272f4e8447623295.png" referrerpolicy="no-referrer"><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2FVitalikButerin%2Fstatus%2F1762363524918227423" target="_blank">https://twitter.com/VitalikButerin/status/1762363524918227423</a></u></em></p></blockquote><p>對此，<span style="background-color:#ffffff; color:#333333">以太坊聯合創始人 Vitalik Buterin</span>&nbsp;建議馬斯克改用 Linux 桌面發行版。</p><p>X 上的一些用户稱讚 V 神推廣了開源軟件。但也有人指出，Linux 可能不是馬斯克的最佳選擇，因為他使用 PC 的主要目的是玩遊戲。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 09:59:34 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280524</guid>
            <link>https://www.oschina.net/news/280524</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GPL 抗辯成功——織夢 CMS「系列」版權糾紛迎來重大轉折]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><blockquote><p style="text-align:justify"><span style="color:#27ae60"><strong>摘要</strong></span></p><p style="text-align:justify"><span style="color:#4e5f70">原告：上海卓卓網絡科技有限公司（以下簡稱：卓卓公司）</span></p><p style="text-align:justify"><span style="color:#4e5f70">被告：****醫院</span></p><p style="text-align:justify"><span style="color:#4e5f70">事件：****醫院使用 DedeCMSV5.7-sp1 軟件開發網站，卓卓公司以擁有 DedeCMS Biz V1.0 以及後續多個版本的著作權為由，認為醫院侵犯了自己的著作權，要求***醫院賠償 5800 元的授權許可費和 8700 元的訴訟費用。</span></p><p style="text-align:justify"><span style="color:#4e5f70">判決：一審法院認為 DedeCMSV5.7-sp1 中包含 GPL 協議下開源的代碼，整體應遵守 GPL 協議，****醫院使用軟件不用支付授權費用，但仍需遵守署名權的要求。</span></p></blockquote><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span>持續近 3 年、涉及 300 萬用户的織夢 CMS 「系列」版權糾紛案在</span></span></span><span><span><span>近</span></span></span><span><span><span>日迎來第一份抗辯成功判決。上海卓卓網絡科技有限公司自 2021 年起，以「織夢商業網站內容管理系統【簡稱：DedeCMS Biz】V1.0」著作權方的身份，在全國各地起訴多個網站中含有 DedeCMS 相關代碼的公司，要求賠償。</span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span>2023 年 9 月 11 日，卓卓公司訴****醫院侵害計算機軟件著作權糾紛案件立案。2024 年 2 月 19 日，江蘇省無錫市中級人民法院</span></span></span><span><span><span>作出</span></span></span><span><span><span>一審判決書，認可了 GPL 的</span></span></span><span><span><span>「</span></span></span><span><span><span>傳染性</span></span></span><span><span><span>」</span></span></span><span><span><span>，涉案軟件（具體版本為 DedeCMSV5.7-sp1）整體按 GPL 對外許可，但要求使用者（被告）在網頁底部添加原告網址鏈接，不得侵犯原告的署名權。</span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span>一審判決書在判決書送達之日起十五日，當事人沒有提起上訴的，就會生效。據案件知情人士分析，卓卓公司肯定會上訴。</span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span>開源中國</span></span></span><span><span><span>從知情人處</span></span></span><span><span><span>獲取並查閲判決書。據判決書顯示，卓卓公司提出，卓卓通過受讓取得了 DedeCMS Biz V1.0 的軟件著作權，又在 DedeCMS Biz V1.0 版本的基礎上迭代出 DedeCMSV5.5、DedeCMSV5.6、DedeCMSV5.7 等版本。****醫院名下網站相關網頁相關源代碼與卓卓公司享有著作權的涉案軟件代碼相同，證據包括授權協議中的卓卓公司名稱、Powered By DedeCMS、織夢內容管理系統 DEDECMS 的 logo/mark 等等。但****醫院並未向卓卓公司購買正版涉案軟件，也從未獲得過卓卓公司商業使用授權許可。因此卓卓要求****醫院支付涉案軟件 DedeCMS 軟件的授權許可費 5800 元，以及卓卓公司為訴訟所指出的 8700 元費用，共計 14500 元。</span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span>而****醫院辯稱：卓卓雖然通過受取得 DedeCMS Biz V1.0 的軟件著作權，但沒有證據能夠證明卓卓公司是織夢內容管理系統 DedeCMS 軟件的著作權人。此外，DedeCMS 是一款以 GPL 協議對外許可發佈的開源軟件，DedeCMS 後續版本包括涉案權利軟件都是在 DedeCMSV3 版本基礎上迭代升級的，因此受 GPL 約束。根據 GPL 協議禁止添加商業使用的限制條款，也不允許著作權人就軟件本身收取授權許可費。</span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span>此外，圍繞案件，卓卓公司和****醫院還列舉了多項訴求與證據，詳情可查看一審判決書（尚未生效）。</span></span></span></span></span></span></p><div><blockquote><div><span style="color:#4e5f70">此份判決書由知情人提供並脱密：https://report.oschina.net/api/files/jhim80u9qm1ofsw/79ci47r1rrt9yqm/2023_02_482_cEvUNytTpS.pdf</span></div></blockquote></div><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span>法院總結此案件爭議焦點有兩個：</span></span></span></span></span></span></p><div><blockquote><div><span style="color:#4e5f70">綜合雙方的訴辯主張，並經雙方確認，本院對本案的爭議焦點歸納為：</span></div><div><span style="color:#4e5f70">一、涉案權利軟件的著作權人是否是卓卓公司；</span></div><div><span style="color:#4e5f70">二、****醫院是否有權依據 GPL 協議免費使用涉案權利軟件</span></div></blockquote></div><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span>針對第一點，法院認為：</span></span></span></span></span></span></p><blockquote><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span style="color:#4e5f70">涉案權利軟件的著作權人是卓卓公司。</span></p></blockquote><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span>針對第二點，法院認為：</span></span></span></span></span></span></p><blockquote><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span>&nbsp;</span><span><span><span><span style="color:#646a73">涉案軟件 DedeCMSV5.7-sp1&nbsp;是包含採用 GPLV2.0 及以後版本做為協議的 sphinxclient 的派生作品。……由此本案中卓卓公司將涉案軟件進行發佈代表卓卓公司已經接受 GPL 協議。</span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#646a73">……</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span style="color:#646a73">涉案軟件應當遵守 GPL 協議，卓卓公司在涉案軟件的許可協議中的「商業用途需獲得授權」的條款與 GPL 協議</span></span></span><span><span><span style="color:#646a73">相</span></span></span><span><span><span style="color:#646a73">牴觸，卓卓公司有義務按照 GPL 協議將涉案軟件整體授權給獲得許可的人，****醫院因 GPL 協議獲得了對涉案軟件使用的授權，並未侵犯卓卓公司的複製權，卓卓公司無權對此行為請求支付授權費用。</span></span></span></span></span><span>&nbsp;</span></p></blockquote><p><span>不過，法院認為****醫院需在網站註明來源是卓卓公司。</span></p><blockquote><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span>&nbsp;</span><span><span><span><span style="color:#646a73">卓卓公司在許可協議中載明用户應在使用涉案軟件建成網站的主頁標註網站鏈接 www.dedecms.com，該條款並不構成對下游接收者對軟件複製、分發、修改權利的限制，應當有效。</span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span style="color:#646a73">……</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span style="color:#646a73">GPL 協議作為許可協議有雙務性，被許可人在行使複製、發佈修改開源軟件的權利時，也需要按照協議要求承擔相應義務，****醫院使用涉案軟件 DedeCMS 建成了網站，但未在主頁標註卓卓公司創作印記或官網鏈接，違反了該附加條款，侵害了卓卓公司的署名權，損害了卓卓公司的身份權益。故卓卓公司請求****醫院賠償損失並賠禮道歉，具有事實和法律依據，本院予以支持。</span></span></span></span></span><span>&nbsp;</span></p></blockquote><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span>最終，法院判定由****醫院賠償卓卓公司經濟損失及合理維權開支共 800 元，並在判決生效之日起十日內在其公司網站主頁發佈為期三十日的賠禮道歉聲明。在關於賠償金額的表述中，法院的考量因素中還提到兩點值得關注：</span></span></span></span></span></span></p><blockquote><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span style="color:#4e5f70">第三，卓卓公司主張****醫院在內的用户需遵守涉案軟件的許可協議，但卓卓公司在使用他人代碼時卻未遵守他人軟件的 GPL 許可協議，其行為本身有違誠信原則，具有不正當性。卓卓公司自身對涉案軟件的著作權也存在管理不周的情況，軟件源代碼中記錄的版權信息、署名都未直接指向卓卓公司，源代碼中不同位置的許可協議條款存在不一致的情形。</span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span style="color:#4e5f70">第四，卓卓公司以涉案軟件為權利基礎，在全國法院提起大量侵害計算機軟件著作權糾紛案件，並因此獲得較大收益，該種維權模式既不利於有效打擊侵權源頭，又大量佔用解決糾紛的公共資源，不宜提倡和鼓勵。</span></p></blockquote><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span>此外，據企查查信息顯示，上海卓卓發起了多起侵害計算機軟件著作權糾紛訴訟，自 2 月 28 日-3 月 30 日將陸續有案件開庭。</span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><img height="522" src="https://static.oschina.net/uploads/space/2024/0227/170855_5DFc_4489239.png" width="600" referrerpolicy="no-referrer"></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span>開源中國將持續關注 DedeCMS 系列版權糾紛案件進展，本週內也將梳理此係列糾紛的時間線，歡迎知情者私信爆料。</span></span></span></span></span></span></p></div></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 09:10:34 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280518/gpl-dedecms</guid>
            <link>https://www.oschina.net/news/280518/gpl-dedecms</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[白宮敦促開發者改用內存安全的編程語言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">白宮國家網絡主任辦公室 (ONCD) <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.whitehouse.gov%2Foncd%2Fbriefing-room%2F2024%2F02%2F26%2Fpress-release-technical-report%2F" target="_blank">發佈</a>了一份報告，呼籲科技界主動減少網絡空間的攻擊面；通過改用 Rust 等內存安全編程語言，減少內存安全漏洞的數量來提高軟件安全性。同時鼓勵研究界解決軟件可測量性問題，以便開發出更好的測量網絡安全質量的診斷方法。</span></p><p><img height="390" src="https://oscimg.oschina.net/oscnet/up-7cb1183993aa2d8ce4f54a8bb5787fa09a7.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">ONCD 例舉了歷史上一些著名的網絡攻擊事件，包括：1988 年的 Morris 蠕蟲病毒、2003 年的 Slammer 蠕蟲病毒、2014 年的 Heartbleed 漏洞、2016 年的 Trident 漏洞、2023 年的 Blastpass 漏洞。並指出，所有這些問題的背後都有一個共同的根本原因，即內存安全漏洞。</span></p><p><span style="color:#000000">報告稱：「35 年來，三十五年來，內存安全漏洞一直困擾着數字生態系統，但情況本不必如此。消除整類軟件漏洞的挑戰是一個緊迫而複雜的問題。展望未來，必須採取新方法來減輕這種風險。」</span></p><p><span style="color:#000000">「減少內存安全漏洞的最高槓桿方法是保護網絡空間的構建模塊之一：編程語言。使用內存安全編程語言可以消除大多數內存安全錯誤。」</span></p><p><span style="color:#000000">在此之前，</span><span style="background-color:#ffffff"><span style="color:#000000">美國國家安全局 (NSA) 曾於 2022 年 11 月發佈了關於軟件開發人員如何防止軟件內存安全問題的</span><a href="https://www.oschina.net/news/217425/nsa-memory-safe-programming-language" target="_blank">指南。</a></span><span style="background-color:#ffffff; color:#000000">美國網絡安全與基礎設施安全局 (CISA)<span>&nbsp;</span></span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>也在 2023 年 12 月發佈了類似<a href="https://www.oschina.net/news/269933/cisa-the-case-for-memory-safe-roadmaps">報告</a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="color:#000000"><span style="background-color:#ffffff">，</span>要求過渡到內存安全編程語言，通過消除與內存相關的漏洞來減少軟件產品的攻擊面。</span></p><p><span style="color:#000000">ONCD 報告以美國總統拜登於 2023 年 3 月簽署的</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bleepingcomputer.com%2Fnews%2Fsecurity%2Fwhite-house-releases-new-us-national-cybersecurity-strategy%2F" target="_blank">國家網絡安全戰略</a><span style="color:#000000">為基礎，將網絡安全的責任從個人和小型企業轉移到技術公司和聯邦政府等更有能力管理不斷變化的威脅的大型組織身上。並在與整個聯邦政府的安全設計計劃和研發工作保持一致的同時更進一步，涵蓋了由 CISA、NSA、FBI 和 NIST 領導的計劃和研發工作。</span></p><p><span style="color:#000000">報告中有關內存安全的工作還補充了美國國會對此主題的興趣。此外，美國參議院國土安全和政府事務委員會主席 Gary Peters (D-MI) 和美國參議員 Ron Wyden (D-OR) 也向 ONCD 強調了他們在內存安全方面的立法努力。</span></p><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.whitehouse.gov%2Fwp-content%2Fuploads%2F2024%2F02%2FFinal-ONCD-Technical-Report.pdf" target="_blank">查看完整報告</a>。</span></p><p><strong><span style="color:#000000">相關閲讀：</span></strong></p><ul><li><a href="https://www.oschina.net/news/217425/nsa-memory-safe-programming-language" target="_blank">美國國家安全局建議從 C/C++ 切換到內存安全語言</a></li><li><a href="https://www.oschina.net/news/269933/cisa-the-case-for-memory-safe-roadmaps" target="_blank">美國 CISA 建議放棄 C/C++，消除內存安全漏洞</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 08:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280505/white-house-memory-safe-programming-languages</guid>
            <link>https://www.oschina.net/news/280505/white-house-memory-safe-programming-languages</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[南京大學將開通全國高校首家 AI 課程]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">南京大學正式發佈全國高校首家面向 3700 餘名新生開設的「1+X+Y」三層次的人工智能通識核心課總體方案。</span></p><p><span style="color:#000000">該方案包含 1 門必修的人工智能通識核心課，X 門人工智能素養課，Y 門各學科與人工智能深度融合的前沿拓展課。其中，1 門人工智能通識核心課面向對象為 2024 年起面向全體本科新生。</span></p><p><span style="color:#000000"><img height="256" src="https://oscimg.oschina.net/oscnet/up-c46928165fcc29d00ea987b62dd6db02a66.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">南京大學黨委書記、中國科學院院士譚鐵牛指出，當今世界，由人工智能引領的新一輪科技革命和產業變革方興未艾。在移動互聯網、大數據、超級計算、傳感網、腦科學等新理論新技術驅動下，人工智能已經對經濟發展、社會進步、全球治理等各方面產生重大而深遠的影響。只有緊跟時代步伐，把握時代脈搏，才能順勢而上，應勢而為，把創新主動權、發展主動權牢牢掌握在自己手中。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 08:03:42 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280497</guid>
            <link>https://www.oschina.net/news/280497</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[0201-0225 開放籤團隊工作日記]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0.0001pt; margin-right:0px"><span><span><span><span><span><span><span>2022 年底</span></span></span><span><span><span>團隊決定</span></span></span><span><span><span>以全新的產品運營和設計思路重回電子簽章行業，重新做</span></span></span><span><span><span>電子簽章</span></span></span><span><span><span>產品。至於當時如何離開電子簽章，又是如何回來的，具體原因等後面再敍。在這麼多年的創業的過程中，我們團隊經歷了從迷茫無助到方向堅定（我們認為的），從一點點構建基礎技術架構到基本成熟，有太多的不容易，每一個不容易都可以是個故事，具體的也在將來一一再敍，這次單説最近的一些工作感受和工作概況。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span><span><span>經過努力</span></span></span><span><span><span>，23 年底（12 月 15 日）</span></span></span><span><span><span>產品</span></span></span><span><span><span>上線</span></span></span><span><span><span>後</span></span></span><span><span><span>，我們深知自己在</span></span></span><span><span><span>市場競爭中與頭部企業仍存在功能層面的差距</span></span></span><span><span><span>，不敢妄想有什麼好的反饋和成果。但是首</span></span></span><span><span><span>月</span></span></span><span><span><span>便</span></span></span><span><span><span>迎來了</span></span></span><span><span><span>付費用户</span></span></span><span><span><span>（企業版）和近</span></span></span><span><span><span>百</span></span></span><span><span><span>個開源用户</span></span></span><span><span><span>，</span></span></span><span><span><span>這完全出乎我和同事的意料</span></span></span><span><span><span>。剛開始我們以為這些用户至少要在 3-5 個月內才能積累到。事實證明我們錯了，我們保守了，但是方向貌似對了（還需要更多的付出和積累）。在與客户溝通過程中，很快就收集到</span></span></span><span><span><span>首批客户集中提出</span></span></span><span><span><span>的眾多需求，主要體現在</span></span></span><span><span><span>移動端簽署、API 集成、</span></span></span><span><span><span>國產化</span></span></span><span><span><span>及優化交互體驗</span></span></span><span><span><span>四大方面。也有很多我們在設計過程中沒有考慮到的，沒有考慮到的方面對我們來説尤其珍貴，價值巨大。</span></span></span><span><span><span>所以</span></span></span><span><span><span>我們在年前</span></span></span><span><span><span>加快工作節奏，</span></span></span><span><span><span>年後規劃新年一季度目標。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span><span><span>首要任務是</span></span></span><span><span><span>移動端開發，並承諾於春節後第一週交付新功能。</span></span></span><span><span><span>這段時間的工作節奏是這樣的：</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span><span><span>1、</span></span></span><span><span><span>臨近春節</span></span></span><span><span><span>（</span></span></span><span><span><span>農曆 28 日</span></span></span><span><span><span>）</span></span></span><span><span><span>我們完成了功能開</span></span></span><span><span><span>發，勉強通過冒煙測試</span></span></span><span><span><span>。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span><span><span>2、</span></span></span><span><span><span>年後進行系統和功能測試時，</span></span></span><span><span><span>出乎意料的事情接踵而至</span></span></span><span><span><span>，</span></span></span><span><span><span>出現了</span></span></span><span><span><span>移動端鏈接邏輯</span></span></span><span><span><span>跳轉混亂</span></span></span><span><span><span>、文件簽署內存異常、</span></span></span><span><span><span>簽署</span></span></span><span><span><span>圖片丟失、簽署控件重複等</span></span></span><span><span><span>問題</span></span></span><span><span><span>。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span><span><span>3、</span></span></span><span><span><span>測試同學「大壯」在羣裏</span></span></span><span><span><span>發飆了，</span></span></span><span><span><span>講述上線風險和延期上線的請求</span></span></span><span><span><span>。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span><span><span>4、不動聲色的產品負責人老胡看到</span></span></span><span><span><span>請求</span></span></span><span><span><span>後</span></span></span><span><span><span>一直未回覆（他的性格很剛強，表面不説，內心很要強）</span></span></span><span><span><span>。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span><span><span>5、老胡</span></span></span><span><span><span>開始</span></span></span><span><span><span>着手</span></span></span><span><span><span>理清工作任務，</span></span></span><span><span><span>逐條分析 BUG，確定優先級。</span></span></span><span><span><span>···········（結果：原定計劃</span></span></span><span><span><span>（2 月 25 日）</span></span></span><span><span><span>未完成上線）只好協調大家</span></span></span><span><span><span>週六日</span></span></span><span><span><span>繼續</span></span></span><span><span><span>通宵奮戰</span></span></span><span><span><span>。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span><span><span>6、</span></span></span><span><span><span>直至</span></span></span><span><span><span>2 月 26 日</span></span></span><span><span><span>凌晨五點成功修復所有問題並上線新版本</span></span></span><span><span><span>。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span><span><span>這個過程真是酸爽，自從決定做開放籤以來，首先內心是非常欣慰的，工作狀態也超好，整個團隊也是熱情澎湃的，甚至自然而然的解決了一些團隊管理問題。</span></span></span><span><span><span>同樣的產品不同的公司，都是為了服務客户</span></span></span><span><span><span>和理想在</span></span></span><span><span><span>奮鬥</span></span></span><span><span><span>、在</span></span></span><span><span><span>熬夜，感謝</span></span></span><span><span><span>團</span></span></span><span><span><span>隊成員的努力付出</span></span></span><span><span><span>！加油！（會想盡一切辦法和努力給大家加雞腿，讓我們</span></span></span><span><span><span>的</span></span></span><span><span><span>產品更好</span></span></span><span><span><span>，</span></span></span><span><span><span>團隊更頑強</span></span></span><span><span><span>，客户更放心</span></span></span><span><span><span>........）</span></span></span><span><span><span>。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span><span><span>值得欣喜的是，按照約定我們成功完成版本更新</span></span></span><span><span><span>，</span></span></span><span><span><span>並與兩家新客户簽約。接下來，我們將採取敏捷迭代策略，小步快跑地滿足需求</span></span></span><span><span><span>。</span></span></span><span><span><span>同時大膽創新簽約場景模式，使更多企業在真實場景下實現高效合規</span></span></span><span><span><span>簽署，讓電子籤更簡單不是説説而已</span></span></span><span><span><span>。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:right"><span><span><span><span><span><span><span>2024 年 02 月 27 日</span></span></span></span></span></span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 07:32:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280492</guid>
            <link>https://www.oschina.net/news/280492</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Spring Boot 拒絕用 AI 為倉庫自動生成註釋]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">一名開發者近日在 Spring Boot 提交了一項 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-boot%2Fpull%2F39754%2F" target="_blank">PR</a>，旨在使用 AI 模型為整個 Spring Boot 代碼庫添加註釋：</span></p><blockquote><p><span style="color:#000000">此代碼變更為整個 Spring Boot 代碼庫添加了註釋。本 PR 的內容完全由自定義微調 AI 模型創建。</span></p><p><span style="color:#000000">我們正在對我們的工具進行大規模實驗，在數百萬行代碼上運行該工具，以識別任何 bug 或錯誤。在此代碼庫中運行時，該工具的編譯成功率高達 99.9%。</span></p><p><span style="color:#000000">我們可以選擇放棄這些代碼，或者將其發佈並作為一項貢獻。我們選擇了後者，並決定打開此 Pull Request。</span></p></blockquote><p><img height="280" src="https://oscimg.oschina.net/oscnet/up-c694ca89e5d80a24accaf670c4f099452bc.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000">但 Spring Boot 項目負責人 Phil Webb 對此進行了婉拒。並表示，相較自動生成，團隊成員更喜歡人工手動的方式；且自動生成這種無差別的方式，很可能給整個倉庫增添許多不必要的麻煩。</span></p><p><span style="color:#000000">「我認為您的工具對於正在學習代碼庫或需要某些部分的額外幫助的人來説可能非常有用。」</span></p><p>Reddit 上的一些討論也表達了對這一提議的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reddit.com%2Fr%2Fprogramming%2Fcomments%2F1b0n9kx%2Fai_added_comments_for_the_entire_code_base_of%2F" target="_blank">不看好</a>：</p><blockquote><p>「哇，這太可怕了。我真希望這只是個玩笑，提出要求的人只是在嘲笑這個想法。」</p><p>「如果這不是純粹為了吸引眼球，那麼我想公關背後的開發人員可以説是真的缺乏開發技能。」</p></blockquote><p>目前，相關 PR 已被關閉。&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 06:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280473/ai-comments-spring-boot</guid>
            <link>https://www.oschina.net/news/280473/ai-comments-spring-boot</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[開源日報 | 鴻蒙程序員平均月薪超 1 萬 8；中美 AI 差距有多大？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>歡迎閲讀 OSCHINA 編輯部出品的開源日報，每天更新一期。</p><h3><span style="color:#e67e22"><strong># 2024.2.26</strong></span></h3><h2><strong><span style="color:#16a085">今日要點</span></strong></h2><p><strong>OpenSource Daily</strong></p><h3><a href="https://www.oschina.net/news/280197/warp-for-linux" target="_blank">基於 Rust 開發的終端應用 Warp 發佈 Linux 版本</a></h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">Warp 是一個基於 Rust 開發的現代化終端應用，內置 AI 功能，支持 CPU 加速。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">此前 Warp 僅面向 Mac 平台提供，近日其開發團隊終於<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.warp.dev%2Fblog%2Fwarp-for-linux" target="_blank">發佈</a></u>了 Linux 版本，用户可在大多數主流 Linux 發行版上安裝 Warp，包括 Ubuntu、Fedora、Arch Linux 或 Red Hat。</p><h3><a href="https://www.oschina.net/news/280083/wubuntu-windows-ubuntu" target="_blank">Wubuntu：披着 Windows 11 外衣的 Ubuntu</a></h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong>Wubuntu，又稱 "Windows Ubuntu"</strong>，是基於 Ubuntu 開發的操作系統，其最具特色之處在於<strong>完全復刻了 Windows 的所有外觀和功能</strong>，而且運行時不需要具備 TPM、安全啓動或任何其他硬件要求。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span>此外，Wubuntu</span>&nbsp;通過集成 Wine 提供了與 Windows 應用的兼容性，開發者稱 Wubuntu 支持運行 Windows 的 .exe 和 .msi&nbsp;程序，以及支持 Android 應用。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b78011bce450db4cf20d1bb7cc559cd4cb6.png" referrerpolicy="no-referrer"></p><hr><h2><strong><span style="color:#16a085">今日觀察</span></strong></h2><p><img src="https://oscimg.oschina.net/oscnet/up-a5cb30243de8b0b91be1d481043c473ad9e.png" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#333333">- </span><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tmtpost.com%2F6949344.html" target="_blank">鈦媒體</a></em></u></p><hr><h2><span style="color:#16a085"><strong>今日推薦</strong></span></h2><p><img src="https://oscimg.oschina.net/oscnet/up-dd0b05ccdc75b8e461bccd191d8b02a887a.png" referrerpolicy="no-referrer"></p><hr><h2><span style="color:#16a085"><strong>開源之聲</strong></span></h2><p><img height="376" src="https://oscimg.oschina.net/oscnet/up-61ab492b02eb694af46583aa700ca993ddd.png" width="1104" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-393f28205ac4c95982b1545e5541957f5f9.png" referrerpolicy="no-referrer"></p><hr><h2><span style="color:#16a085"><strong>每日項目榜</strong></span></h2><p><strong><span style="background-color:#e67e22">每日 Gitee 精選</span></strong></p><p><img src="https://oscimg.oschina.net/oscnet/up-f0e8ff0ed6f05f1864bb5c951acca5d3893.png" referrerpolicy="no-referrer"></p><blockquote><h4><strong><span style="background-color:#e67e22">在線閲讀完整日報內容，訪問：</span></strong><br><u><em><strong><a href="https://report.oschina.net/api/files/jhim80u9qm1ofsw/6typ9w3u98f5mxn/16_1_8_2efTeNfFjN.pdf">開源日報第 016 期：鴻蒙程序員平均月薪超 1 萬 8；中美 AI 差距有多大？</a></strong></em></u></h4></blockquote><hr><p><strong>往期回顧</strong></p><ul><li><a href="https://report.oschina.net/api/files/jhim80u9qm1ofsw/92n4c9ryegpcq1z/015_sora_KcAkRNX93Y.pdf">開源日報第 015 期：為什麼擋不住英偉達；Sora 不靠蠻力</a></li><li><a href="https://report.oschina.net/api/files/jhim80u9qm1ofsw/s7n800w84o6guyv/014_kyezhNxOGD.pdf">開源日報第 014 期：目前的人工智能技術連貓的智能水平都沒達到</a></li><li><a href="https://oscimg.oschina.net/public_shard/%E5%BC%80%E6%BA%90%E6%97%A5%E6%8A%A5%E7%AC%AC013%E6%9C%9F%EF%BC%9A%E7%AD%89%E5%88%B0%20Sora%20%E5%BC%80%E6%BA%90%E4%BA%86%E7%AB%8B%E5%88%BB%E6%8E%A8%E5%87%BA%E5%B1%9E%E4%BA%8E%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B.pdf">開源日報第 013 期：等到 Sora 開源了立刻推出屬於我們自己的大模型</a></li><li><a href="https://oscimg.oschina.net/public_shard/%E5%BC%80%E6%BA%90%E6%97%A5%E6%8A%A5%E7%AC%AC012%E6%9C%9F%EF%BC%9ASora%20%E7%BB%99%E4%B8%AD%E5%9B%BD%20AI%20%E5%B8%A6%E6%9D%A5%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%8F%98%E5%8C%96%EF%BC%9BDart%203.3%20%E5%8F%91%E5%B8%83.pdf">開源日報第 012 期：Sora 給中國 AI 帶來的真實變化；Dart 3.3 發佈</a></li><li><a href="https://oscimg.oschina.net/public_shard/%E5%BC%80%E6%BA%90%E6%97%A5%E6%8A%A5%E7%AC%AC11%E6%9C%9F%EF%BC%9A%E7%9B%AE%E5%89%8D%E8%BF%98%E6%B2%A1%E6%9C%89%E2%80%9C%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%89%88Linux%E2%80%9D.pdf">開源日報第 011 期：目前還沒有「大模型版 Linux」</a></li><li><a href="https://oscimg.oschina.net/public_shard/%E5%BC%80%E6%BA%90%E6%97%A5%E6%8A%A5%E7%AC%AC010%E6%9C%9F%EF%BC%9ATauri%20v2%20%E6%94%AF%E6%8C%81%20Android%20%E5%92%8C%20iOS%EF%BC%8C%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%96%B0%E9%80%89%E6%8B%A9.pdf">開源日報第 010 期：Tauri v2 支持 Android 和 iOS，跨平台開發新選擇</a></li><li><a href="https://oscimg.oschina.net/public_shard/%E5%BC%80%E6%BA%90%E6%97%A5%E6%8A%A5009%E6%9C%9F%EF%BC%9AVue.js%E8%AF%9E%E7%94%9F10%E5%91%A8%E5%B9%B4%EF%BC%9B%E6%89%8E%E5%85%8B%E4%BC%AF%E6%A0%BC%E8%A7%A3%E9%87%8AMeta%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%80%E6%BA%90%E5%85%B6AI%E6%8A%80%E6%9C%AF.pdf">開源日報第 009 期：Vue.js 誕生 10 週年；扎克伯格解釋 Meta 為什麼要開源其 AI 技術</a></li><li><a href="https://www.oschina.net/news/277585">開源日報第 008 期：推動中國開源軟硬件發展的經驗與建議</a></li><li><a href="https://www.oschina.net/news/277415">開源日報第 007 期：「Linux 中國」 開源社區宣佈停止運營</a></li><li><a href="https://www.oschina.net/news/277214">開源日報第 006 期：選擇技術棧一定要選擇開源的</a></li><li><a href="http://www.oschina.net/news/277040">開源日報第 005 期：RISC-V 萬兆開源交換機發售；npm 存在大量武林外傳視頻</a></li><li><a href="https://www.oschina.net/news/276864">開源日報第 004 期：百度輸入法在候選詞區域植入廣告；大神用 Excel 構建 CPU</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 04:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280457</guid>
            <link>https://www.oschina.net/news/280457</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OSI 發佈報告，研究 BSL 這樣的「延遲開源發佈」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff">Open Source Initiative（OSI）近期發佈了一個報告《Delayed Open Source Publication:&nbsp;</span>A Survey of Historical and Current Practices<span style="background-color:#ffffff; color:#060607">》（</span>延遲開源發佈：歷史與當前實踐調研<span style="background-color:#ffffff; color:#060607">），作者是 Seth Schoen、James Vasile 和 Karl Fogel。</span></p><p>&nbsp;</p><p style="color:#060607; margin-left:0; margin-right:0; text-align:start">Delayed Open Source Publication，簡稱 DOSP，延遲開源發佈的意思，這份報告研究了它的歷史和現狀。報告核心要點：</p><p style="margin-left:0; margin-right:0"><strong>延遲開源發佈（DOSP）定義</strong>：DOSP 是指軟件最初在專有許可下發布，然後計劃性地在某個時間點將源代碼以開源許可的形式公開。</p><p style="margin-left:0; margin-right:0"><strong>歷史背景</strong>：DOSP 的做法可以追溯到 GNU 項目，並且一直延續至今。公司嘗試各種商業模式，以在有限時間內保持獨家權利，然後過渡到 OSI（開放源代碼倡議）批准的許可。</p><p style="margin-left:0; margin-right:0"><strong>策略類型</strong>：DOSP 分為三種類型：無條件計劃性重新許可、事件驅動的重新許可和有條件的重新許可。</p><p style="margin-left:0; margin-right:0"><strong>商業源許可（BUSL）</strong>：BUSL 是一種新興的 DOSP 許可方式，它要求在特定的「變更日期」後，軟件的許可將變為開源許可。這種做法在數據庫系統中尤為常見。（以往也叫 BSL）</p><p style="margin-left:0; margin-right:0">以下是當前知名的 16 個使用 BUSL 的項目，都是延遲幾年後轉型成開源協議：</p><p style="margin-left:0; margin-right:0"><img height="1588" src="https://static.oschina.net/uploads/space/2024/0227/115012_ybIG_3820517.png" width="1434" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>反競爭條款</strong>：一些 DOSP 許可中包含反競爭條款，旨在防止許可證持有者使用軟件提供與許可方直接競爭的服務。</p><p style="margin-left:0; margin-right:0"><strong>後果和影響</strong>：從開源許可轉變為 DOSP 許可的項目可能會受到批評，有時會導致用户轉向其他項目或維護競爭性的分支。</p><p style="margin-left:0; margin-right:0"><strong>未來研究問題</strong>：報告提出了一些未來研究的問題，包括 AGPL 與 DOSP 許可的比較、DOSP 對外部貢獻的影響、BUSL 額外使用授權的分類、以及在初始開源發佈後重新許可的策略。</p><p style="margin-left:0; margin-right:0"><strong>結論</strong>：DOSP 自開源運動早期以來一直在使用，公司通常利用它來保持商業優勢，同時儘可能保留開源的優勢。報告強調，DOSP 的實驗性和多樣性比預期的要多，且這種趨勢可能會繼續。</p><p>詳情可以查看<a href="https://apiv1.oschina.net/api/files/jhim80u9qm1ofsw/27nfbrttho0ynu9/delayed_open_source_publication_2FzjpHTElG.pdf?token=">報告原文</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 03:57:03 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280456/osi-delayed-open-source-publication-report</guid>
            <link>https://www.oschina.net/news/280456/osi-delayed-open-source-publication-report</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[終於，我們拿下了硅谷的那個 Linear]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img src="https://oscimg.oschina.net/oscnet/up-0963fd788787982101b5435a54ca146c2ab.png" alt="file" referrerpolicy="no-referrer"></p><p>就像設計領域的 Figma，文檔領域的 Notion，Linear 同樣在軟件開發管理領域推出了革命性的工具。而且以其名字 Linear Style 命名的設計風格，也成為了一股軟件設計潮流。</p><p><img src="https://oscimg.oschina.net/oscnet/up-19feb8c039e4eb58e00760e5e8abaeba7f9.png" alt="file" referrerpolicy="no-referrer"></p><p>Linear 於 2019 年在美國 🇺🇸 舊金山創立。目前服務的對象涵蓋了從新興初創到知名上市公司的廣泛範圍，其中包括 Vercel、Arc、Runway，Supercell 和 OpenSea 等知名企業。其產品因能顯著提升團隊生產力和協作效率而成為近幾年硅谷新興公司的首選。</p><p><img src="https://oscimg.oschina.net/oscnet/up-29fa5d140ca7408dad14b59ffc2cef3023a.png" alt="file" referrerpolicy="no-referrer"></p><p><strong>Linear 使用 Bytebase 管理其數據庫的全開發生命週期。收口員工查詢數據庫操作，通過 Bytebase API 將數據庫變更集成進現有 CI/CD 工作流。</strong></p><p>Linear 的員工統一在 SQL 編輯器查詢數據，通過權限管控、數據脱敏及行為審計，限制查詢範圍、監控行為並滿足合規需求。</p><p>通過 Bytebase API 將數據庫變更的審核部署集成進現有的代碼提交部署工作流中，觸發在 Bytebase 中建立工單，自動進行 SQL 預審核以減少人力降低錯誤可能性；根據變更的風險等級，通過自定義審批流確保相應的審批管理；並且，通過變更記錄的查詢功能，便於鎖定特定的變更，以利於後續的審計。此外，單點登錄 (SSO)，雙因子身份驗證 (2FA) 等功能進一步為賬户管理帶來了便利性和安全性保障。</p><p>未來 Linear 還將利用 Bytebase 的批量變更能力管理部署在不同地域的同構數據庫。</p><p><img src="https://oscimg.oschina.net/oscnet/up-07cce1911ea9af359d0b945ffb3b6a4eca4.png" alt="file" referrerpolicy="no-referrer"></p><p>對開發者工具極其挑剔的 Linear 最終選擇了 Bytebase。正如我們在 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI2MDY5OQ%3D%3D%26mid%3D2247483664%26idx%3D1%26sn%3Dbd6be60909c156c2d54687ad90ba4825%26chksm%3Dc25f3f24f528b63261d5d86fb9ddcad8f36826bdaa16fdb43da555d5457313c5036aa1665b78%26scene%3D21%23wechat_redirect" target="_blank">2021 年發佈 Bytebase</a> 時設想的那樣，<strong>Bytebase 會站上世界最高的舞台，成為現代軟件研發工具鏈上的核心一環</strong>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-551f266a1ef72674d8516e4795c1c18b9b4.png" alt="file" referrerpolicy="no-referrer"></p><hr><p>💡 更多資訊，請關注 Bytebase 公號：Bytebase</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 03:52:03 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6148470/blog/11044874</guid>
            <link>https://my.oschina.net/u/6148470/blog/11044874</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Ubuntu 工程師使用 Rust 為 Linux 開發內核調度程序]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Ubuntu 內核團隊工程師 Andrea Righi 使用&nbsp;Rust 編寫了一個 Linux 內核調度程序，並利用 eBPF 在運行時動態加載。Ubuntu 還沒有承諾將其作為發行版的一部分，Righi 也在博客表示這是一個實驗性內核項目，用於探索 Rust 在 Ubuntu 的應用，並談到了未來<strong>利用 Rust 和 eBPF 進行「微內核設計」</strong>的可能性。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-c0d741c436f514bc20978b2df98eb1e23a1.png" referrerpolicy="no-referrer"></p><p>Righi 在博客介紹稱，用 Rust 開發的內核調度程序 sched-ext 不僅為開發者提供了便利，還能讓用户也受益，比如可以根據用户的工作負載和其他特殊情況加載優化的調度程序。</p><p>博客文章最後寫道：</p><blockquote><p>「我們正朝着一種微內核設計邁進，它有可能為 Linux 認證鋪平道路：在上述情況下，如果用户空間調度程序崩潰，任務將無縫過渡到默認的內核調度程序，確保系統的持續可用性，而不會出現任何停機時間。</p><p>這表明，類似的方法也可用於其他子系統，從而使 Linux 內核能夠提供完全冗餘和崩潰安全的系統。」</p></blockquote><p>相關鏈接</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsched-ext%2Fscx%2Fpull%2F161" target="_blank">https://github.com/sched-ext/scx/pull/161</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fubuntu.com%2F%2Fblog%2Fcrafting-new-linux-schedulers-with-sched-ext-rust-and-ubuntu" target="_blank">https://ubuntu.com//blog/crafting-new-linux-schedulers-with-sched-ext-rust-and-ubuntu</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 03:25:03 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280450/ubuntu-rust-scheduler-micro</guid>
            <link>https://www.oschina.net/news/280450/ubuntu-rust-scheduler-micro</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Rebebuca —— 桌面端 ffmpeg 管理器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><ul style="list-style-type:square; margin-left:0; margin-right:0"><li><p>Rebebuca（發音：瑞貝不卡） 是一個使用 Rust 開發的桌面端 ffmpeg 管理器，在不卡系列中處於推流端的生態位（Monibuca 為服務端，Jessibuca 為播放端）。</p></li><li><p>Rebebuca 在不久的將來會支持管理 Monibuca&nbsp;進程。</p></li><li><p><strong style="color:black"><span style="color:#010101">Rebebuca&nbsp;</span>可以在 30 秒內完成創建、運行、管理你的 ffmpeg 命令</strong></p><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div class="ckeditor-html5-video" style="text-align:center"><video controls="controls" src="https://rebebuca.com/quick.mp4">&nbsp;</video></div></div><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0">&nbsp;</div><div style="margin-left:0; margin-right:0">&nbsp;</div></div></div></div></div></div></div></div></div></div></li><li><p>幫助我們更好的管理繁多複雜的 ffmpeg 參數和 ffmpeg 命令運行狀態</p></li></ul><h2 style="margin-left:30px; margin-right:30px; text-align:center"><span>功能特性</span></h2><ul style="list-style-type:square; margin-left:0; margin-right:0"><li><p>ffmpeg 命令全週期管理</p><ul style="list-style-type:circle; margin-left:0; margin-right:0"><li style="list-style-type:circle"><p>支持 ffmpeg 命令運行、停止、重啓等操作</p></li><li style="list-style-type:circle"><p>支持 ffmpeg 命令參數可視化配置、導入終端命令</p></li><li style="list-style-type:circle"><p>支持，按項目維度管理各種 ffmpeg 命令</p></li><li style="list-style-type:circle"><p>支持，數據導出</p></li></ul></li><li><p>列表+詳情交互模式</p></li><li><p>支持 ffmpeg 源切換、中英語言、深色淺色主題切換、窗口關閉方式選擇</p><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0">&nbsp;</div><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0"><div style="margin-left:0; margin-right:0; text-align:center"><div class="ckeditor-html5-video" style="text-align:center"><video controls="controls" src="https://rebebuca.com/quick.mp4">&nbsp;</video></div></div><div style="margin-left:0; margin-right:0">&nbsp;</div></div></div></div></div></div></div></div></div></div></li><li><p>支持軟件自動更新</p></li><li><p>支持 mac 和 window 平台</p></li><li><p>簡單好用、能力豐富、長期維護</p></li></ul><h2 style="margin-left:30px; margin-right:30px; text-align:center"><span>下載安裝</span></h2><ul style="list-style-type:square; margin-left:0; margin-right:0"><li><p>Windows：https://download.m7s.live/rb/Rebebuca_0.1.0_x64_en-US.msi</p></li><li><p>Mac：https://download.m7s.live/rb/Rebebuca_0.1.0_x64.dmg</p></li><li><p>Mac(arm64) ：https://download.m7s.live/rb/Rebebuca_0.1.0_aarch64.dmg</p></li></ul><h2 style="margin-left:30px; margin-right:30px; text-align:center"><span>官方地址</span></h2><ul style="list-style-type:square; margin-left:0; margin-right:0"><li><p>官方網站：https://rebebuca.com</p></li><li><p>github：https://github.com/rebebuca/rebebuca</p></li></ul></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 02:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/rebebuca</guid>
            <link>https://www.oschina.net/p/rebebuca</link>
        </item>
        <item>
            <title>
                <![CDATA[華為發佈首個 5.5G 智能核心網：計劃 2024 年商用]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在 MWC24 巴塞羅那期間，華為雲核心網產品線總裁高治國發布 5.5G 智能核心網解決方案。</p><p>據悉，2023 年新通話已在中國 31 省部署，可支撐 5000 萬用户，同時在歐洲、拉美、中東、亞太等多個區域得到了廣泛驗證，計劃 2024 年商用。高治國表示：「華為發佈的業界首個新通話-A 通過智能能力和 DC（Data Channel）交互能力升級，正式邁入多模態通信時代。」</p><p><img height="333" src="https://oscimg.oschina.net/oscnet/up-b019072789c268abb1883dc58f6487ea5eb.png" width="500" referrerpolicy="no-referrer"></p><p>5.5G 也就是 5G-A，全稱為 5G-Advanced，是 5G 的技術演進，具備更大帶寬、更廣連接、確定性時延等能力。作為 5G-A 的重要技術之一，三載波聚合（3CC）是 5G-A 的基礎體驗網，5G-A 三載波聚合可以通過三載波組網方案，結合確定性體驗保障等技術，進一步提升網絡質量與體驗。</p><p>華為倡導的 5.5G 時代，是包含 5.5G、F5.5G、Net5.5G 等全面演進升級的端到端解決方案，會帶來 10 倍的網絡性能提升，可實現下行萬兆、上行千兆的峯值能力。同時在時延、定位、可靠性方面也有了 10 倍的提升，還能實現毫秒級時延和低成本千億物聯。</p><p>在 2023 MWC 上海展會上， 華為董事、ICT 產品與解決方案總裁楊超斌曾宣佈，華為 2024 年將會推出面向商用的 5.5G 全套網絡設備。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 02:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280433</guid>
            <link>https://www.oschina.net/news/280433</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | Web 端彈幕庫 Fly Barrage]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content--fly-barrage" class="anchor" href="https://gitee.com/fei_fei27/fly-barrage#-fly-barrage"></a>✨ Fly Barrage</h1><p>Fully functional and powerful web-based barrage library</p><p>功能完善，強大的 web 端彈幕庫</p><h2><a id="user-content--rendering-effects" class="anchor" href="https://gitee.com/fei_fei27/fly-barrage#-rendering-effects"></a>🎥 Rendering effects</h2><p><img src="https://gitee.com/fei_fei27/fly-barrage/raw/master/public/imgs/0001.png" alt="渲染效果" referrerpolicy="no-referrer"></p><h2><a id="user-content--official-website" class="anchor" href="https://gitee.com/fei_fei27/fly-barrage#-official-website"></a>📝 Official Website</h2><p><a href="https://gitee.com/link?target=https%3A%2F%2Ffly-barrage.netlify.app%2F">https://fly-barrage.netlify.app/</a></p><h2><a id="user-content--install" class="anchor" href="https://gitee.com/fei_fei27/fly-barrage#-install"></a>📥 Install</h2><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">npm <span class="nb">install </span>fly-barrage</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content--usage" class="anchor" href="https://gitee.com/fei_fei27/fly-barrage#-usage"></a>🌍 Usage</h2><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c">&lt;!-- Taking Vue framework as an example, this library is not limited to specific frameworks. --&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;</span><span class="k">template</span><span class="nt">&gt;</span></span><span id="LC3" class="line"><span class="nt">&lt;div</span><span class="na">id=</span><span class="s">"container"</span><span class="nt">&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;video</span></span><span id="LC5" class="line"><span class="na">ref=</span><span class="s">"video"</span></span><span id="LC6" class="line"><span class="na">id=</span><span class="s">"video"</span></span><span id="LC7" class="line"><span class="na">controls</span></span><span id="LC8" class="line"><span class="na">autoplay</span></span><span id="LC9" class="line"><span class="na">src=</span><span class="s">"../src/assets/demo1.mp4"</span></span><span id="LC10" class="line"><span class="err">@</span><span class="na">play=</span><span class="s">"videoPlay"</span></span><span id="LC11" class="line"><span class="err">@</span><span class="na">pause=</span><span class="s">"videoPause"</span></span><span id="LC12" class="line"><span class="nt">&gt;&lt;/video&gt;</span></span><span id="LC13" class="line"><span class="nt">&lt;/div&gt;</span></span><span id="LC14" class="line"><span class="nt">&lt;/</span><span class="k">template</span><span class="nt">&gt;</span></span><span id="LC15" class="line"></span><span id="LC16" class="line"><span class="nt">&lt;</span><span class="k">script</span><span class="na">setup</span><span class="na">lang=</span><span class="s">"ts"</span><span class="nt">&gt;</span></span><span id="LC17" class="line"><span class="k">import</span><span class="nx">BarrageRenderer</span><span class="p">,</span><span class="p">{</span><span class="nx">BarrageOptions</span><span class="p">}</span><span class="k">from</span><span class="dl">'</span><span class="s1">fly-barrage</span><span class="dl">'</span><span class="p">;</span></span><span id="LC18" class="line"><span class="k">import</span><span class="p">{</span><span class="nx">onMounted</span><span class="p">,</span><span class="nx">ref</span><span class="p">}</span><span class="k">from</span><span class="dl">'</span><span class="s1">vue</span><span class="dl">'</span><span class="p">;</span></span><span id="LC19" class="line"></span><span id="LC20" class="line"><span class="kd">const</span><span class="nx">barrages</span><span class="p">:</span><span class="nx">BarrageOptions</span><span class="p">[]</span><span class="o">=</span><span class="p">[</span></span><span id="LC21" class="line"><span class="p">{</span></span><span id="LC22" class="line"><span class="dl">"</span><span class="s2">id</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">e55b45c9-7f9e-48c9-9bba-4d3b53441976</span><span class="dl">"</span><span class="p">,</span></span><span id="LC23" class="line"><span class="dl">"</span><span class="s2">barrageType</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">scroll</span><span class="dl">"</span><span class="p">,</span></span><span id="LC24" class="line"><span class="dl">"</span><span class="s2">time</span><span class="dl">"</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span></span><span id="LC25" class="line"><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">殘燈無焰影幢幢，此夕聞君謫九江。</span><span class="dl">"</span><span class="p">,</span></span><span id="LC26" class="line"><span class="dl">"</span><span class="s2">fontSize</span><span class="dl">"</span><span class="p">:</span><span class="mi">34</span><span class="p">,</span></span><span id="LC27" class="line"><span class="dl">"</span><span class="s2">lineHeight</span><span class="dl">"</span><span class="p">:</span><span class="mf">1.2</span><span class="p">,</span></span><span id="LC28" class="line"><span class="dl">"</span><span class="s2">color</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">#FFFF00</span><span class="dl">"</span><span class="p">,</span></span><span id="LC29" class="line"><span class="p">},</span></span><span id="LC30" class="line"><span class="p">];</span></span><span id="LC31" class="line"></span><span id="LC32" class="line"><span class="kd">const</span><span class="nx">barrageRenderer</span><span class="o">=</span><span class="nx">ref</span><span class="o">&lt;</span><span class="nx">BarrageRenderer</span><span class="o">&gt;</span><span class="p">();</span></span><span id="LC33" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">ref</span><span class="p">();</span></span><span id="LC34" class="line"></span><span id="LC35" class="line"><span class="nx">onMounted</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC36" class="line"><span class="nx">barrageRenderer</span><span class="p">.</span><span class="nx">value</span><span class="o">=</span><span class="k">new</span><span class="nx">BarrageRenderer</span><span class="p">({</span></span><span id="LC37" class="line"><span class="na">container</span><span class="p">:</span><span class="dl">'</span><span class="s1">container</span><span class="dl">'</span><span class="p">,</span></span><span id="LC38" class="line"><span class="na">video</span><span class="p">:</span><span class="nx">video</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span></span><span id="LC39" class="line"><span class="nx">barrages</span><span class="p">,</span></span><span id="LC40" class="line"><span class="p">});</span></span><span id="LC41" class="line"><span class="p">})</span></span><span id="LC42" class="line"></span><span id="LC43" class="line"><span class="kd">const</span><span class="nx">videoPlay</span><span class="o">=</span><span class="p">()</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC44" class="line"><span class="nx">barrageRenderer</span><span class="p">.</span><span class="nx">value</span><span class="p">?.</span><span class="nx">play</span><span class="p">();</span></span><span id="LC45" class="line"><span class="p">};</span></span><span id="LC46" class="line"></span><span id="LC47" class="line"><span class="kd">const</span><span class="nx">videoPause</span><span class="o">=</span><span class="p">()</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC48" class="line"><span class="nx">barrageRenderer</span><span class="p">.</span><span class="nx">value</span><span class="p">?.</span><span class="nx">pause</span><span class="p">();</span></span><span id="LC49" class="line"><span class="p">};</span></span><span id="LC50" class="line"><span class="nt">&lt;/</span><span class="k">script</span><span class="nt">&gt;</span></span><span id="LC51" class="line"></span><span id="LC52" class="line"><span class="nt">&lt;</span><span class="k">style</span><span class="nt">&gt;</span></span><span id="LC53" class="line"><span class="o">*</span><span class="p">{</span></span><span id="LC54" class="line"><span class="nl">padding</span><span class="p">:</span><span class="m">0</span><span class="p">;</span></span><span id="LC55" class="line"><span class="nl">margin</span><span class="p">:</span><span class="m">0</span><span class="p">;</span></span><span id="LC56" class="line"><span class="p">}</span></span><span id="LC57" class="line"></span><span id="LC58" class="line"><span class="nf">#container</span><span class="p">{</span></span><span id="LC59" class="line"><span class="nl">width</span><span class="p">:</span><span class="m">1000px</span><span class="p">;</span></span><span id="LC60" class="line"><span class="nl">height</span><span class="p">:</span><span class="m">700px</span><span class="p">;</span></span><span id="LC61" class="line"><span class="nl">margin</span><span class="p">:</span><span class="m">20px</span><span class="nb">auto</span><span class="m">0</span><span class="p">;</span></span><span id="LC62" class="line"><span class="p">}</span></span><span id="LC63" class="line"></span><span id="LC64" class="line"><span class="nf">#video</span><span class="p">{</span></span><span id="LC65" class="line"><span class="nl">width</span><span class="p">:</span><span class="m">100%</span><span class="p">;</span></span><span id="LC66" class="line"><span class="nl">height</span><span class="p">:</span><span class="m">100%</span><span class="p">;</span></span><span id="LC67" class="line"><span class="nl">background</span><span class="p">:</span><span class="no">black</span><span class="p">;</span></span><span id="LC68" class="line"><span class="p">}</span></span><span id="LC69" class="line"><span class="nt">&lt;/</span><span class="k">style</span><span class="nt">&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>For complete usage, please clone the project directly, install the dependencies, and then execute npm run dev to view the complete usage</p><p>Try to use a higher version of the node version, my local version is v18.19.0</p><h2><a id="user-content--license" class="anchor" href="https://gitee.com/fei_fei27/fly-barrage#-license"></a>🌲 License</h2><p><a href="https://gitee.com/fei_fei27/fly-barrage/blob/master/LICENSE">MIT License</a></p>]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 02:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/fei_fei27/fly-barrage</guid>
            <link>https://gitee.com/fei_fei27/fly-barrage</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 得物自研 API 網關實踐之路]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1>一、業務背景</h1><p style="color:#24292f; text-align:start">老網關使用 Spring Cloud Gateway （下稱 SCG）技術框架搭建，SCG 基於 webflux 編程範式，webflux 是一種響應式編程理念，響應式編程對於提升系統吞吐率和性能有很大幫助; webflux 的底層構建在 netty 之上性能表現優秀；SCG 屬於 spring 生態的產物，具備開箱即用的特點，以較低的使用成本助力得物早期的業務快速發展；但是隨着公司業務的快速發展，流量越來越大，網關迭代的業務邏輯越來越多，以及安全審計需求的不斷升級和穩定性需求的提高，SCG 在以下幾個方面逐步暴露了一系列的問題。</p><span id="OSC_h2_2"></span><h2>網絡安全</h2><p style="color:#24292f; text-align:start">從網絡安全角度來講，對公網暴露接口無疑是一件風險極高的事情，網關是對外網絡流量的重要橋樑，早期的接口暴露採用泛化路由的模式，即通過正則形式（ /api/v1/app/order/** ）的路由規則開放接口，單個應用服務往往只配置一個泛化路由，後續上線新接口時外部可以直接訪問；這帶來了極大的安全風險，很多時候業務開發的接口可能僅僅是內部調用，但是一不小心就被泛化路由開放到了公網，甚至很多時候沒人講得清楚某個服務具體有多少接口屬於對外，多少對內；另一方面從監控數據來看，黑產勢力也在不斷對我們的接口做滲透試探。</p><span id="OSC_h2_3"></span><h2>協同效率</h2><p style="color:#24292f; text-align:start">引入了接口註冊機制，所有對外暴露接口逐一註冊到網關，未註冊接口不可訪問，安全的問題得到了解決但同時帶來了性能問題，SCG 採用遍歷方式匹配路由規則，接口註冊模式推廣後路由接口註冊數量迅速提升到 3W+，路由匹配性能出現嚴重問題；泛化路由的時代，一個服務只有一個路由配置，變動頻率很低，配置工作由網關關開發人員負責，效率尚可，接口註冊模式將路由工作轉移到了業務開發同學的身上，這就得引入一套完整的路由審核流程，以提升協同效率；由於路由信息早期都存在配置中心，同時這麼大的數據量給配置中心也帶來極大的壓力和穩定性風險。</p><span id="OSC_h2_4"></span><h2>性能與維護成本</h2><p style="color:#24292f; text-align:start">業務迭代的不斷增多，也使得 API 網關堆積了很多的業務邏輯，這些業務邏輯分散在不同的 filter 中，為了降低開發成本，網關只有一套主線分支，不同集羣部署的代碼完全相同，但是不同集羣的業務屬性不同，所需要的 filter 邏輯是不一樣的；如內網網關集羣幾乎沒什麼業務邏輯，但是 App 集羣可能需要幾十個 filter 的邏輯協同工作；這樣的一套代碼對內網網關而言，存在着大量的性能浪費；如何平衡維護成本和運行效率是個需要思考的問題。</p><span id="OSC_h2_5"></span><h2>穩定性風險</h2><p style="color:#24292f; text-align:start">API 網關作為基礎服務，承載全站的流量出入，穩定性無疑是第一優先級，但其定位決定了絕不可能是一個簡單的代理層，在穩定運行的同時依然需要承接大量業務需求，例如 C 端用户登錄下線能力，App 強升能力，B 端場景下的鑑權能力等；很難想象較長一段時間以來，網關都保持着雙週一次的發版頻率；頻繁的發版也帶來了一些問題，實例啓動初期有很多資源需要初始化，此時承接的流量處理時間較長，存在着明顯的接口超時現象；早期的每次發版幾乎都會導致下游服務的接口短時間內超時率大幅提高，而且往往涉及多個服務一起出現類似情況；為此甚至拉了一個網關發版公告羣，提前置頂發版公告，讓業務同學和 NOC 有一個心裏預期；在發佈升級期間儘可能讓業務服務無感知這是個剛需。</p><span id="OSC_h2_6"></span><h2>定製能力</h2><p style="color:#24292f; text-align:start">流量灰度是網關最常見的功能之一，對於新版本迭代，業務服務的某個節點發布新版本後希望引入少部分流量試跑觀察，但很遺憾 SCG 原生並不支持，需要對負載均衡算法進行手動改寫才可以，此外基於流量特徵的定向節點路由也需要手動開發，在 SCG 中整個負載均衡算法屬於比較核心的模塊，不對外直接暴露，存在較高的改造成本。</p><p style="color:#24292f; text-align:start">B 端業務和 C 端業務存在着很大的不同，例如對接口的響應時間的忍受度是不一樣的，B 端場景下下載一個報表用户可以接受等待 10s 或者 1 分鐘，但是 C 端用户現在沒有這個耐心。作為代理層針對以上的場景，我們需要針對不同接口定製不同的超時時間，原生的 SCG 顯然也不支持。</p><p style="color:#24292f; text-align:start">諸如此類的定製需求還有很多，我們並不寄希望於開源產品能夠開箱即用滿足全部需求，但至少定製性拓展性足夠好。上手改造成本低。</p><span id="OSC_h1_7"></span><h1>二、技術痛點</h1><p style="color:#24292f; text-align:start">SCG 主要使用了 webflux 技術，webflux 的底層構建在 reactor-netty 之上，而 reactor-netty 構建於 netty 之上；SCG 能夠和 spring cloud 的技術棧的各組件，完美適配，做到開箱即用，以較低的使用成本助力得物早期的業務快速發展；但是使用 webflux 也是需要付出一定成本，首先它會額外增加編碼人員的心智負擔，需要理解流的概念和常用的操作函數，諸如 map, flatmap, defer 等等；其次異步非阻塞的編碼形式，充斥着大量的回調函數，會導致順序性業務邏輯被割裂開來，增加代碼閲讀理理解成本；此外經過多方面評估我們發現 SCG 存在以下缺點：</p><span id="OSC_h2_8"></span><h2>內存泄露問題</h2><p style="color:#24292f">SCG 存在較多的內存泄漏問題，排查困難，且官方遲遲未能修復，長期運行會導致服務觸發 OOM 並宕機；以下為 github 上 SCG 官方開源倉庫的待解決的內存泄漏問題，大約有 16 個之多。</p><p style="color:#24292f; text-align:center"><img alt="80.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/80.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:center">SCG 內存泄漏 BUG</p><p style="color:#24292f">下圖可以看到 SCG 在長期運行的過程中內存使用一直在增長，<strong>當增長到機器內存上限時當前節點將不可用，聯繫到網關單節點所承接的 QPS 在幾千，可想而知節點宕機帶來的危害有多大</strong>；一段時間以來我們需要對 SCG 網關做定期重啓。</p><p style="color:#24292f; text-align:center"><img alt="078.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/078.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:center">SCG 生產實例內存增長趨勢</p><span id="OSC_h2_9"></span><h2>響應式編程範式複雜</h2><p style="color:#24292f">基於 webflux 中的 flux 和 mono ，在對 request 和 response 信息讀取修改時，編碼複雜度高，代碼理解困難，下圖是對 body 信息進行修改時的代碼邏輯。</p><p style="color:#24292f; text-align:center"><img alt="607.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/607.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:center">對 requestBody 進行修改的方式</p><span id="OSC_h2_10"></span><h2>多層抽象的性能損耗</h2><p style="color:#24292f; text-align:start">儘管相比於傳統的阻塞式網關，SCG 的性能已經足夠優秀，但相比原生的 netty 仍然比較低下，SCG 依賴於 webflux 編程範式，webflux 構建於 reactor-netty 之上，reactor-netty 構建於 netty 之上，多層抽象存在較大的性能損耗。<span>&nbsp;</span></p><p style="color:#24292f; text-align:start"><img alt="106.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/106.jpeg" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:center">SCG 依賴層級</p><p style="color:#24292f">一般認為程序調用棧越深性能越差；下圖為只有一個 filter 的情況下的調用棧，可以看到存在大量的 webflux 中的 subscribe() 和 onNext() 方法調用,這些方法的執行不關聯任何業務邏輯，屬於純粹的框架運行層代碼，粗略估算下沒有引入任何邏輯的情況下 SCG 的調用棧深度在 90+ ，如果引入多個 filter 處理不同的業務邏輯，線程棧將進一步加深，<strong>當前網關的業務複雜度實際棧深度會達到 120 左右，也就是差不多有四分之三的非業務棧損耗，這個比例是有點誇張的。</strong></p><p style="color:#24292f; text-align:center"><img alt="205.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/205.png" referrerpolicy="no-referrer"><img alt="200.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/200.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:center">SCG filter 調用棧深度</p><span id="OSC_h2_11"></span><h2>路由能力不完善</h2><p style="color:#24292f">原生的的 SCG 並不支持動態路由管理，路由的配置信息通過大量的 KV 配置來做，平均一個路由配置需要三到四條 KV 配置信息來支撐，這些配置數據一般放在諸如 Apollo 或者 ark 這樣的配置中心，即使是添加了新的配置 SCG 並不能動態識別，需要引入動態刷新路由配置的能力。另一方面路由匹配算法通過遍歷所有的路由信息逐一匹配的模式，當接口級別的路由數量急劇膨脹時，性能是個嚴重問題。</p><p style="color:#24292f; text-align:center"><img alt="017.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/017.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:center">SCG 路由匹配算法為 On 時間複雜度</p><span id="OSC_h2_12"></span><h2>預熱時間長，冷啓動 RT 尖刺大</h2><p style="color:#24292f">SCG 中 LoadBalancerClient 會調用 choose 方法來選擇合適的 endpoint 作為本次 RPC 發起調用的真實地址，由於是懶加載，只有在有真實流量觸發時才會加載創建相關資源；在觸發底層的 NamedContextFactory#getContext 方法時存在一個全局鎖導致，woker 線程在該鎖上大量等待。</p><p style="color:#24292f; text-align:center"><img alt="769.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/769.png" referrerpolicy="no-referrer">NamedContextFactory#getContext 方法存在全局鎖</p><p style="color:#24292f; text-align:center"><img alt="209.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/209.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:center">SCG 發佈時超時報錯增多</p><span id="OSC_h2_13"></span><h2>定製性差，數據流控制耦合</h2><p style="color:#24292f">SCG 在開發運維過程中已經出現了較多的針對源碼改造的場景，如動態路由，路由匹配性能優化等；其設計理念老舊，控制流和數據流混合使用，架構不清晰，如對路由管理操作仍然耦合在 filter 中，即使引入 spring mvc 方式管理，依然綁定使用 webflux 編程範式，同時也無法做到控制流端口獨立，存在一定安全風險。</p><p style="color:#24292f; text-align:center"><img alt="9007.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/9007.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:center">filter 中對路由進行管理</p><span id="OSC_h1_14"></span><h1>三、方案調研</h1><span id="OSC_h2_15"></span><h2>理想中的網關</h2><p style="color:#24292f; text-align:start">綜合業務需求和技術痛點，我們發現<strong>理想型的網關</strong>應該是這個樣子的：</p><ul><li><p>支持海量接口註冊，並能夠在運行時支持動態添加修改路由信息，具備出色路由匹配性能</p></li><li><p>編程範式儘可能簡單，降低開發人員心智負擔，同時最好是開發人員較為熟悉的語言</p></li><li><p>性能足夠好，至少要等同於目前 SCG 的性能，RT99 線和 ART 較低</p></li><li><p>穩定性好，無內存泄漏，能夠長時間持續穩定運行，發佈升級期間要儘可能下游無感</p></li><li><p>拓展能力強，支持超時定製，多網絡協議支持，http，Dubbo 等，生態完善</p></li><li><p>架構設計清晰，數據流與控制流分離，集成 UI 控制面</p></li></ul><span id="OSC_h2_16"></span><h2>開源網關對比</h2><p style="color:#24292f; text-align:start">基於以上需求，我們對市面上的常見網關進行了調研，以下幾個開源方案對比。</p><p style="color:#24292f; text-align:start"><img alt="6078.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/6078.jpeg" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">結合當前團隊的技術棧，我們傾向於選擇 Java 技術棧的開源產品，唯一可選的只有 zuul2 ，但是 zuul2 路由註冊和穩定性方面也不能夠滿足我們的需求，也沒有實現數控分離的架構設計。因此唯有走上自研之路。</p><span id="OSC_h1_17"></span><h1>四、自研架構</h1><p style="color:#24292f; text-align:start">通常而言代理網關分為透明代理與非透明代理，其主要區別在於對於流量是否存在侵入性，這裏的侵入性主要是指對請求和響應數據的修改；顯然 API Gateway 的定位決定了必然會對流量進行數據調整，常見的調整主要有，添加或者修改 head 信息，加密或者解密 query params head ,以及 requestbody 或者 responseBody，可以説 http 請求的每一個部分數據都存在修改的可能性，這要求代理層必須要完全解析數據包信息，而非簡單的做一個路由器轉發功能。</p><p style="color:#24292f; text-align:start">傳統的服務器架構，以 reactor 架構為主。boss 線程和 worker 線程的明確分工，boss 線程負責連接建立創建；worker 線程負責已經建立的連接的讀寫事件監聽處理，同時會將部分複雜業務的處理放到獨立的線程池中，進而避免 worker 線程的執行時間過長影響對網絡事件處理的及時性；由於網關是 IO 密集型服務，相對來説計算內容較少，可以不必引入這樣的業務線程池；直接基於 netty 原生 reactor 架構實現。</p><span id="OSC_h2_18"></span><h2>Reactor 多線程架構</h2><p style="color:#24292f; text-align:start"><img alt="1009.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/1009.jpeg" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">為了只求極致性能和降低多線程編碼的數據競爭，單個請求從接收到轉發後端，再到接收後端服務響應，以及最終的回寫給 client 端，這一系列操作被設計為完全閉合在一個 workerEventLoop 線程中處理；這需要 worker 線程中執行的 IO 類型操作全部實現異步非阻塞化，確保 worker 線程的高速運轉；這樣的架構和 NGINX 很類似；我們稱之為 thread-per-core 模式。<img alt="1008.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/1008.jpeg" referrerpolicy="no-referrer"></p><span id="OSC_h2_19"></span><h2>API 網關組件架構</h2><p style="color:#24292f; text-align:start"><img alt="7008.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/7008.jpeg" referrerpolicy="no-referrer"></p><span id="OSC_h2_20"></span><h2>數據流控制流分離</h2><p style="color:#24292f; text-align:start">數據面板專注於流量代理，不處理任何 admin 類請求，控制流監聽獨立的端口，接收管理指令。</p><p style="color:#24292f; text-align:start"><img alt="6009.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/6009.jpeg" referrerpolicy="no-referrer"></p><span id="OSC_h1_21"></span><h1>五、核心設計</h1><span id="OSC_h2_22"></span><h2>請求上下文封裝</h2><p style="color:#24292f; text-align:start">新的 API 網關底層仍然基於 Netty，其自帶的 http 協議解析 handler 可以直接使用。基於 netty 框架的編程範式，需要在初始化時逐一註冊用到的 Handler。<span>&nbsp;</span></p><p style="color:#24292f; text-align:start"><img alt="10035.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/10035.jpeg" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:center">Client 到 Proxy 鏈路 Handler 執行順序</p><p style="color:#24292f; text-align:start">HttpServerCodec 負責 HTTP 請求的解析；對於體積較大的 Http 請求，客户端可能會拆成多個小的數據包進行發送，因此在服務端需要適當的封裝拼接，避免收到不完整的 http 請求；HttpObjectAggregator 負責整個請求的拼裝組合。</p><p style="color:#24292f; text-align:start">拿到 HTTP 請求的全部信息後在業務 handler 中進行處理；如果請求體積過大直接拋棄；使用 ServerWebExchange 對象封裝請求上下文信息，其中包含了 client2Proxy 的 channel, 以及負責處理該 channel 的 eventLoop 線程等信息，考慮到整個請求的處理過程中可能在不同階段傳遞一些拓展信息，引入了 getAttributes 方法，用於存儲需要傳遞的數據；此外 ServerWebExchange 接口的基本遵循了 SCG 的設計規範，保證了在遷移業務邏輯時的最小化改動；具體到實現類，可以參考如下代碼：</p><pre><code>@Getter
  public class DefaultServerWebExchange implements ServerWebExchange {
    private final Channel client2ProxyChannel;
    private final Channel proxy2ClientChannel;
    private final EventLoop executor;
    private ServerHttpRequest request;
    private ServerHttpResponse response;
    private final Map&lt;String, Object&gt; attributes;
 }
</code></pre><p style="text-align:center">DefaultServerWebExchange</p><p style="color:#24292f; text-align:start">Client2ProxyHttpHandler 作為核心的入口 handler 負責將接收到的 FullHttpRequest 進行封裝和構建 ServerWebExchange 對象，其核心邏輯如下。可以看到對於數據讀取封裝的邏輯較為簡單，並沒有植入常見的業務邏輯，封裝完對象後隨即調用 Request filter chain。</p><pre><code>@Override
protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest fullHttpRequest) {
    try {
        Channel client2ProxyChannel = ctx.channel();
        DefaultServerHttpRequest serverHttpRequest = new DefaultServerHttpRequest(fullHttpRequest, client2ProxyChannel);
        ServerWebExchange serverWebExchange = new DefaultServerWebExchange(client2ProxyChannel,(EventLoop) ctx.executor(), serverHttpRequest, null);
        // request filter chain
        this.requestFilterChain.filter(serverWebExchange);
    }catch (Throwable t){
        log.error("Exception caused before filters!\n {}",ExceptionUtils.getStackTrace(t));
        ByteBufHelper.safeRelease(fullHttpRequest);
        throw t;
    }
}
</code></pre><p style="text-align:center">Client2ProxyHttpHandler 精簡後的代碼</p><span id="OSC_h2_23"></span><h2>FilterChain 設計</h2><p style="color:#24292f; text-align:start">FilterChain 可以解決異步請求發送出去後，還沒收到響應，但是順序邏輯已經執行完成的尷尬；例如當我們在上文的。</p><p style="color:#24292f; text-align:start">channelRead0 方法中發起某個鑑權 RPC 調用時，出於性能考慮只能使用非阻塞的方式，按照 netty 的非阻塞編碼 API 最終要引入類似如下的 callback 機制，++在業務邏輯上在沒有收到 RPC 的響應之前該請求的處理應該「暫停」，等待收到響應時才能繼續後續的邏輯執行++; 也就是下面代碼中的下一步執行邏輯並不能執行，正確的做法是將 nextBiz() 方法包裹在 callBack() 方法內，由 callBack() 觸發後續邏輯的執行；這只是發起一次 RPC 調用的情況，在實際的的日常研發過程中存在着鑑權，風控，集羣限流（Redis）等多次 RPC 調用，這就導致這樣的非阻塞代碼編寫將異常複雜。</p><pre><code>ChannelFuture writeFuture = channel.writeAndFlush(asyncRequest.httpRequest);
    writeFuture.addListener(future -&gt; {
                if(future.isSuccess()) {
                   callBack();
                }
            }
    );
    nextBiz()；
</code></pre><p style="text-align:center">非阻塞調用下的業務邏輯編排</p><p style="color:#24292f; text-align:start">對於這樣的複雜場景，採用 filterChain 模式可以很好的解決；首先 RequestFilterChain().filter(serverWebExchange); 後不存在任何邏輯；發起請求時 ，當前 filter 執行結束，由於此時沒有調用 chain.filter(exchange); 所以不會繼續執行下一個 filter，發送請求到下游的邏輯也不會執行；當前請求的處理流程暫時中止，<strong>eventloop 線程將切換到其他請求的處理過程上；當收到 RPC 響應時，chain.filter(exchange) 被執行，之前中斷的流程被重新拉起。</strong></p><pre><code>public void filter(ServerWebExchange exchange) {
    if (this.index &lt; filters.size()) {
        GatewayFilter filter = filters.get(this.index);
        DefaultGatewayFilterChain chain = new DefaultGatewayFilterChain(this, this.index + 1);
        try {
            filter.filter(exchange, chain);
        }catch (Throwable e){
            log.error("Filter chain unhandle backward exception! Request path {}, FilterClass: {}, exception: {}", exchange.getRequest().getPath(),   filter.getClass(), ExceptionUtils.getFullStackTrace(e));
            ResponseDecorator.failResponse(exchange,500, "網關內部錯誤！filter chain exception！");
        }
    }
}
</code></pre><p style="text-align:center">基於 filterChain 的調用模式</p><p style="color:#24292f; text-align:start">對於 filter 的執行需要定義先後順序，這裏參考了 SCG 的方案，每個 filter 返回一個 order 值。不同的地方在於 DAG 的設計不允許 order 值重複，因為在 order 重複的情況下，很難界定到底哪個 Filter 先執行，存在模糊地帶，這不是我們期望看到的；DAG 中的 Filter 執行順序為 order 值從小到大，且不允許 order 值重複。為了易於理解，<strong>這裏將 Filter 拆分為了 requestFilter，和 responseFilter；分別代表請求的處理階段，和拿到下游響應階段，responseFilter 遵循同樣的邏輯執行順序與不可重複性。</strong></p><pre><code>public interface GatewayFilter extends Ordered {
    void filter(ServerWebExchange exchange, GatewayFilterChain chain);
}

public interface ResponseFilter extends GatewayFilter { }

public interface RequestFilter extends GatewayFilter { }
</code></pre><p style="text-align:center">filter 接口設計</p><span id="OSC_h2_24"></span><h2>路由管理與匹配</h2><p style="color:#24292f; text-align:start">以 SCG 網關註冊的路由數量為基準，網關節點的需要支撐的路由規則數量是上萬級別的，按照得物目前的業務量，上限不超過 5W，為了保證匹配性能，路由規則放在分佈式緩存中顯然是不合適的，需要保存在節點的內存中。類似於在 nginx 上配置上萬條 location 規則，手動維護難度可想而知，即使在配置中心管理起來也很麻煩，所以需要引入獨立路由管理模塊。<img alt="1090.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/1090.jpeg" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">在匹配的效率上也需要進一步優化，SCG 的路由匹配策略為普通的循環迭代逐一匹配，時間效率為 On，在路由規則膨脹到萬級別後，性能急劇拉胯，結合得物的接口規範，新網關採用 Hash 匹配模式，將匹配效率提升到 O1；hash 的 key 為接口的 path, 需要強調的是在同一個網關集羣中，path 是唯一的，這裏的 path 並不等價於業務服務的接口 path, 絕大多數時候存在一些剪裁，例如在業務服務的編寫的/order/detail 接口，在網關實際註冊的接口可能為/api/v1/app/order/detail；由於使用了 path 作為 key 進行 hash 匹配。常見的 restful 接口顯然是不支持的，確切的講基於 path 傳參數模式的接口均不支持；出於某些歷史原因，網關保留了類似 nginx 的前綴匹配的支持，但是這部分功能不對外開放。</p><pre><code>public class Route implements Ordered {
    private final String id;
    private final int skipCount;
    private final URI uri;
 }
</code></pre><p style="text-align:center">route 類設計</p><p style="color:#24292f; text-align:start">route 的 URI 字段中包含了，需要路由到的具體服務名，這裏也可以稱之為 host ，route 信息會暫存在 exchange 對象的 attributes 屬性中, 在後續的 loadbalance 階段 host 信息會被進一步替換為真實的 endpoint。</p><pre><code>private Route lookupRoute(ServerWebExchange exchange) {
    String path = exchange.getRequest().getPath();
    CachingRouteLocator locator = (CachingRouteLocator) routeLocator;
    Route exactRoute = pathRouteMap.getOrDefault(path, null);
    if (exactRoute != null) {
        exchange.getAttributes().put(DAGApplicationConfig.GATEWAY_ROUTE_CACHE, route);
        return exactRoute;
    }
}
</code></pre><p style="text-align:center">路由匹配邏輯</p><span id="OSC_h2_25"></span><h2>單線程閉環</h2><p style="color:#24292f; text-align:start">為了更好地利用 CPU，以及減少不必要的數據競爭，++將單個請求的處理全部閉合在一個線程當中++；這意味着這個請求的業務邏輯處理，RPC 調用，權限驗證，限流 token 獲取都將始終由某個固定線程處理。netty 中，網絡連接被抽象為 channel，channel 與 eventloop 線程的對應關係為 N 對 1，一個 channel 僅能被一個 eventloop 線程所處理，這在處理用户請求時沒有問題，但是在接收請求完畢向下遊轉發請求時，我們碰到了一些挑戰，下游的連接往往是連接池在管理，連接池的管理是另一組 eventLoop 線程在負責，++為了保持閉環需要將連接池的線程設定為處理當前請求的線程++，並且只能是這一個線程；這樣一來，默認狀態下啓動的 N 個線程（N 與機器核心數相同），分別需要管理一個連接池；thread-per-core 模式的性能已經在 nginx 開源組件上得到驗證。<img alt="659.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/659.jpeg" referrerpolicy="no-referrer"></p><span id="OSC_h2_26"></span><h2>連接管理優化</h2><p style="color:#24292f; text-align:start">為了滿足單線程閉環，需要將連接池的管理線程設置為當前的 eventloop 線程，最終我們通過 threadlocal 進行線程與連接池的綁定；通常情況下 netty 自帶的連接池 FixedChannelPool 可以滿足我們大部分場景下的需求，這樣的連接池也是適用於多線程的場景；由於新網關使用 thread-per-core 模式並將請求處理的全生命週期閉合在單個線程中，所有為了線程安全的額外操作不再必要且存在性能浪費；為此需要對原生連接池做一些優化, 連接的獲取和釋放簡化為對鏈表結構的簡單 getFirst , addLast。</p><p style="color:#24292f; text-align:start">對於 RPC 而言，無論是 HTTP，還是 Dubbo，Redis 等最終底層都需要用到 TCP 連接，將構建在 TCP 連接上的數據解析協議與連接剝離後，我們發現這種純粹的連接管理是可以複用的，對於連接池而言不需要知道具體連接的用途，只需要維持到特定 endpoint 的連接穩定即可，那麼這裏的 RPC 服務的連接仍然可以放入連接池中進行託管；最終的連接池設計架構圖。<img alt="1300.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/1300.jpeg" referrerpolicy="no-referrer"></p><span id="OSC_h2_27"></span><h2>AsyncClient 設計</h2><p style="color:#24292f; text-align:start">對於七層流量而言基本全部都是 Http 請求，同樣在 RPC 請求中 http 協議也佔了大多數，考慮到還會存在少量的 dubbo, Redis 等協議通信的場景。因此需要抽象出一套異步調用框架來支撐；這樣的框架需要具備超時管理，回調執行，錯誤輸出等功能，更重要的是具備協議無關性質， 為了更方便使用需要支持鏈式調用。</p><p style="color:#24292f; text-align:start">發起一次 RPC 調用通常可以分為以下幾步：</p><ol><li>獲取目標地址和使用的協議, 目標服務為集羣部署時，需要使用 loadbalance 模塊</li><li>封裝發送的請求，這樣的請求在應用層可以具體化為某個 Request 類，網絡層序列化為二進制數據流</li><li>出於性能考慮選擇非阻塞式發送，發送動作完成後開始計算超時</li><li>接收數據響應，由於採用非阻塞模式，這裏的發送線程並不會以 block 的方式等待數據</li><li>在超時時間內完成數據處理，或者觸發超時導致連接取消或者關閉<img alt="9006.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/9006.jpeg" referrerpolicy="no-referrer"></li></ol><p style="color:#24292f">AsyncClient 模塊內容並不複雜，AsyncClient 為抽象類不區分使用的網絡協議；ConnectionPool 作為連接的管理者被 client 所引用，<strong>獲取連接的 key 使用 protocol+ip+port 再適合不過</strong>；通常在某個具體的連接初始化階段就已經確定了該 channel 所使用的協議，因此初始化時會直接綁定協議 Handler；當協議為 HTTP 請求時，HttpClientCodec 為 HTTP 請求的編解碼 handler；也可以是構建在 TCP 協議上的 Dubbo, Mysql ,Redis 等協議的 handler。</p><p style="color:#24292f; text-align:start">首先對於一個請求的不同執行階段需要引入狀態定位，這裏引入了 STATE 枚舉：</p><pre><code>enum STATE{
        INIT,SENDING,SEND,SEND_SUCCESS,FAILED,TIMEOUT,RECEIVED
}
</code></pre><p style="color:#24292f; text-align:start">其次在執行過程中設計了 AsyncContext 作為信息存儲的載體，內部包含 request 和 response 信息，作用類似於上文提到的 ServerWebExchange；channel 資源從連接池中獲取，使用完成後需要自動放回。</p><pre><code>public class AsyncContext&lt;Req, Resp&gt; implements Cloneable{
    STATE state = STATE.INIT;
    final Channel usedChannel;
    final ChannelPool usedChannelPool;
    final EventExecutor executor;
    final AsyncClient&lt;Req, Resp&gt; agent;
    
    Req request;
    Resp response;
    
    ResponseCallback&lt;Resp&gt; responseCallback;
    ExceptionCallback exceptionCallback;
    
    int timeout;
    long deadline;
    long sendTimestamp;

    Promise&lt;Resp&gt; responsePromise;
}
</code></pre><p style="text-align:center">AsyncContext</p><p style="color:#24292f; text-align:start">AsyncClient 封裝了基本的網絡通信能力，不拘泥於某個固定的協議，可以是 Redis, http，Dubbo 等。當將數據寫出去之後，該 channel 的非阻塞調用立即結束，在沒有收到響應之前無法對 AsyncContext 封裝的數據做進一步處理，如何在收到數據時將接收到的響應和之前的請求管理起來這是需要面對的問題，channel 對象，的 attr 方法可以用於臨時綁定一些信息，以便於上下文切換時傳遞數據，可以在發送數據時將 AsyncContext 對象綁定到該 channel 的某個固定 key 上。當 channel 收到響應信息時，在相關的 AsyncClientHandler 裏面取出 AsyncContext。</p><pre><code>public abstract class AsyncClient&lt;Req, Resp&gt; implements Client {
    private static final int defaultTimeout = 5000;
    private final boolean doTryAgain = false;
    private final ChannelPoolManager channelPoolManager = ChannelPoolManager.getChannelPoolManager();
    protected static AttributeKey&lt;AsyncRequest&gt; ASYNC_REQUEST_KEY = AttributeKey.valueOf("ASYNC_REQUEST");

    public abstract ApplicationProtocol getProtocol();
    
    public AsyncContext&lt;Req, Resp&gt; newRequest(EventExecutor executor, String endpoint, Req request) {
        final ChannelPoolKey poolKey = genPoolKey(endpoint);
        ChannelPool usedChannelPool = channelPoolManager.acquireChannelPool(executor, poolKey);
        return new AsyncContext&lt;&gt;(this,executor,usedChannelPool,request, defaultTimeout, executor.newPromise());
    }

    public void submitSend(AsyncContext&lt;Req, Resp&gt; asyncContext){
        asyncContext.state = AsyncContext.STATE.SENDING;
        asyncContext.deadline = asyncContext.timeout + System.currentTimeMillis();   
        ReferenceCountUtil.retain(asyncContext.request);
        Future&lt;Resp&gt; responseFuture = trySend(asyncContext);
        responseFuture.addListener((GenericFutureListener&lt;Future&lt;Resp&gt;&gt;) future -&gt; {
            if(future.isSuccess()){
                ReferenceCountUtil.release(asyncContext.request);
                Resp response = future.getNow();
                asyncContext.responseCallback.callback(response);
            }
        });
    }
    /**
     * 嘗試從連接池中獲取連接併發送請求，若失敗返回錯誤
     */
    private Promise&lt;Resp&gt; trySend(AsyncContext&lt;Req, Resp&gt; asyncContext){
        Future&lt;Channel&gt; acquireFuture = asyncContext.usedChannelPool.acquire();
        asyncContext.responsePromise = asyncContext.executor.newPromise();
        acquireFuture.addListener(new GenericFutureListener&lt;Future&lt;Channel&gt;&gt;() {
                @Override
                public void operationComplete(Future&lt;Channel&gt; channelFuture) throws Exception {
                    sendNow(asyncContext,channelFuture);
                }
        });
        return asyncContext.responsePromise;
    }

    private void sendNow(AsyncContext&lt;Req, Resp&gt; asyncContext, Future&lt;Channel&gt; acquireFuture){
        boolean released = false;
        try {
            if (acquireFuture.isSuccess()) {
                NioSocketChannel channel = (NioSocketChannel) acquireFuture.getNow();
                released = true;
                assert channel.attr(ASYNC_REQUEST_KEY).get() == null;
                asyncContext.usedChannel = channel;
                asyncContext.state = AsyncContext.STATE.SEND;
                asyncContext.sendTimestamp = System.currentTimeMillis();
                channel.attr(ASYNC_REQUEST_KEY).set(asyncContext);
                ChannelFuture writeFuture = channel.writeAndFlush(asyncContext.request);
                channel.eventLoop().schedule(()-&gt; doTimeout(asyncContext), asyncContext.timeout, TimeUnit.MILLISECONDS);
            } else {
                asyncContext.responsePromise.setFailure(acquireFuture.cause());
            }
        } catch (Exception e){
            throw new Error("Unexpected Exception.............!");
        }finally {
            if(!released) {
                ReferenceCountUtil.safeRelease(asyncContext.request);
            }
        }
    }
}
</code></pre><p style="text-align:center">AsyncClient 核心源碼</p><pre><code>public class AsyncClientHandler extends SimpleChannelInboundHandler {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
        AsyncContext asyncContext = ctx.attr(AsyncClient.ASYNC_REQUEST_KEY).get();
        try {
            asyncContext.state = AsyncContext.STATE.RECEIVED;
            asyncContext.releaseChannel();
            asyncContext.responsePromise.setSuccess(msg);
        }catch (Throwable t){
            log.error("Exception raised when set Success callback. Exception \n: {}", ExceptionUtils.getFullStackTrace(t));
            ByteBufHelper.safeRelease(msg);
            throw t;
        }
    }
}
</code></pre><p style="text-align:center">AsyncClientHandler</p><p style="color:#24292f; text-align:start">通過上面幾個類的封裝得到了一個易用使用的 AsyncClient，下面的代碼為調用權限系統的案例：</p><pre><code>final FullHttpRequest httpRequest = HttpRequestUtil.getDefaultFullHttpRequest(newAuthReq, serviceInstance, "/auth/newCheckSls");
asyncClient.newRequest(exchange.getExecutor(), endPoint,httpRequest)
        .timeout(timeout)
        .onComplete(response -&gt; {
            String checkResultJson = response.content().toString(CharsetUtil.UTF_8);
            response.release();
            NewAuthResult result = Jsons.parse(checkResultJson,NewAuthResult.class);
            TokenResult tokenResult = this.buildTokenResult(result);
            String body = exchange.getAttribute(DAGApplicationConfig.REQUEST_BODY);

            if (tokenResult.getUserInfoResp() != null) {
                UserInfoResp userInfo = tokenResult.getUserInfoResp();
                headers.set("userid", userInfo.getUserid() == null ? "" : String.valueOf(userInfo.getUserid()));
                headers.set("username", StringUtils.isEmpty(userInfo.getUsername()) ? "" : userInfo.getUsername());
                headers.set("name", StringUtils.isEmpty(userInfo.getName()) ? "" : userInfo.getName());
                chain.filter(exchange);
            } else {
                log.error("{},heads: {},response: {}", path, headers, tokenResult);
                int code = tokenResult.getCode() != null ? tokenResult.getCode().intValue() : ResultCode.UNAUTHO.code;
                ResponseDecorator.failResponse(exchange, code, tokenResult.getMsg());
            }
        })
        .onError(throwable -&gt; {
            log.error("Request service {},occur an exception {}",endPoint, throwable);
            ResponseDecorator.failResponseWithStatus(exchange,HttpResponseStatus.INTERNAL_SERVER_ERROR,"AuthFilter 驗證失敗");
        })
        .sendRequest();
</code></pre><p style="text-align:center">asyncClient 的使用</p><span id="OSC_h2_28"></span><h2>請求超時管理</h2><p style="color:#24292f; text-align:start">一個請求的處理時間不能無限期拉長， 超過某個閾值的情況下 App 的頁面會被取消 ，長時間的加載卡頓不如快速報錯帶來的體驗良好；顯然網關需要針對接口做超時處理，尤其是在向後端服務發起請求的過程，通常我們會設置一個默認值，例如 3 秒鐘，超過這個時間網關會向請求端回寫 timeout 的失敗信息，由於網關下游接入的服務五花八門，可能是 RT 敏感型的 C 端業務，也可能是邏輯較重 B 端服務接口，甚至是存在大量計算的監控大盤接口。這就導致不同接口對超時時間的訴求不一樣，因此針對每個接口的超時時間設定應該被獨立出來，而不是統一配置成一個值。</p><pre><code>asyncClient.newRequest(exchange.getExecutor(), endPoint,httpRequest)
        .timeout(timeout)
        .onComplete(response -&gt; {
            String checkResultJson = response.content().toString(CharsetUtil.UTF_8);
            //..........
        })
        .onError(throwable -&gt; {
            log.error("Request service {},occur an exception {}",endPoint, throwable);
            ResponseDecorator.failResponseWithStatus(exchange,HttpResponseStatus.INTERNAL_SERVER_ERROR,"AuthFilter 驗證失敗");
        })
        .sendRequest();
</code></pre><p style="color:#24292f; text-align:start">asyncClient 的鏈式調用設計了 timeout 方法，用於傳遞超時時間，我們可以通過一個全局 Map 來配置這樣的信息。</p><p style="color:#24292f; text-align:start">Map&lt;String,Integer&gt; 其 key 為全路徑的 path 信息，V 為設定的超時時間，單位為 ms, 至於 Map 的信息在實際配置過程中如何承載，使用 ARK 配置或者 Mysql 都很容易實現。處於併發安全和性能的極致追求，超時事件的設定和調度最好能夠在與當前 channel 綁定的線程中執行，慶幸的是 EventLoop 線程自帶 schedule 方法。具體來看上文的 AsyncClient 的 56 行。schedule 方法內部以堆結構的方式實現了對超時時間進行管理，整體性能尚可。</p><span id="OSC_h2_29"></span><h2>堆外內存管理優化</h2><p style="color:#24292f; text-align:start">常見的堆外內存手動管理方式無非是引用計數，不同處理邏輯可能針對 RC (引用計數) 的值做調整，到某個環節的業務邏輯處理後已經不記得當前的引用計數值是多少了，甚至是前面的 RC 增加了，後面的 RC 忘記減少了；但換個思路，在數據回寫給客户端後我們肯定要把這個請求整個生命週期所申請的堆外內存全部釋放掉，堆外內存在回收的時候條件只有一個，就是 RC 值為 0 ，那麼在最終的 release 的時候，我們引入一個 safeRelase 的思路 , 如果當前的 RC&gt;0 就不停的 release ，直至為 0；因此只要把這樣的邏輯放在 netty 的最後一個 Handler 中即可保證內存得到有效釋放。</p><pre><code>public static void safeRelease(Object msg){
    if(msg instanceof ReferenceCounted){
        ReferenceCounted ref = (ReferenceCounted) msg;
        int refCount = ref.refCnt();
        for(int i=0; i&lt;refCount; i++){
            ref.release();
        }
    }
}
</code></pre><p style="text-align:center">safeRelease</p><span id="OSC_h2_30"></span><h2>響應時間尖刺優化</h2><p style="color:#24292f; text-align:start">由於 DAG 選擇了複用 spring 的 loadbalance 模塊，但這樣一來就會和 SCG 一樣存在啓動初期的響應時間尖刺問題；為此我們進一步分析 RibbonLoadBalancerClient 的構建過程，發現其用到了 NamedContextFactory，該類的 contexts 變量保存了每一個 serviceName 對應的一個獨立 context，這種使用模式帶來大量的性能浪費。</p><pre><code>public abstract class NamedContextFactory&lt;C extends NamedContextFactory.Specification&gt;implements DisposableBean, ApplicationContextAware {
    //1. contexts 保存 key -&gt; ApplicationContext 的 map
    private Map&lt;String, AnnotationConfigApplicationContext&gt; contexts = new ConcurrentHashMap&lt;&gt;();
    //........
}
</code></pre><p style="color:#24292f; text-align:start">在實際運行中 RibbonLoadBalancerClient 會調用 choose 方法來選擇合適的 endpoint 作為本次 RPC 發起調用的真實地址；choose 方法執行過程中會觸發 getLoadBalancer() 方法執行，可以看到該方法的可以按照傳入的 serviceId 獲取專屬於這個服務的 LoadBalancer，事實上這樣的設計有點多此一舉。大部分情況下，每個服務的負載均衡算法都一致的，完全可以複用一個 LoadBalancer 對象；該方法最終是從 spring 容器中獲取 LoadBalancer。</p><pre><code>class  RibbonLoadBalancerClient{
    //..........
    private SpringClientFactory clientFactory;
    
    @Override
    public ServiceInstance choose(String serviceId) {
       return choose(serviceId, null);
    }
    
    public ServiceInstance choose(String serviceId, Object hint) {
       Server server = getServer(getLoadBalancer(serviceId), hint);
       if (server == null) {
          return null;
       }
       return new RibbonServer(serviceId, server, isSecure(server, serviceId),
             serverIntrospector(serviceId).getMetadata(server));
    }
    
    protected ILoadBalancer getLoadBalancer(String serviceId) {
       return this.clientFactory.getLoadBalancer(serviceId);
    }
    //.........
}
</code></pre><p style="text-align:center">RibbonLoadBalancerClient</p><p style="color:#24292f; text-align:start"><strong>由於是懶加載，實際流量觸發下才會執行，因此第一次執行時，RibbonLoadBalancerClient 對象並不存在，需要初始化創建，創建時大量線程併發調用 SpringClientFactory#getContext 方法，鎖在同一個對象上，出現大量的 RT 尖刺。這也解釋了為什麼 SCG 網關在發佈期間會出現響應時間大幅度抖動的現象。</strong></p><pre><code>public class SpringClientFactory extends NamedContextFactory&lt;RibbonClientSpecification&gt;{
    //............    
    protected AnnotationConfigApplicationContext getContext(String name) {
       if (!this.contexts.containsKey(name)) {
          synchronized (this.contexts) {
             if (!this.contexts.containsKey(name)) {
                this.contexts.put(name, createContext(name));
             }
          }
       }
       return this.contexts.get(name);
    }
    //.........
}
</code></pre><p style="text-align:center">SpringClientFactory</p><p style="color:#24292f; text-align:start">在後期的壓測過程中，發現 DAG 的線程數量遠超預期，基於 thread-per-core 的架構模式下，過多的線程對性能損害比較大，尤其是當負載上升到較高水位時。上文提到<strong>默認情況下，每個服務都會創建獨立 loadBalanceClient , 而在其內部又會啓動獨立的線程去同步當前關聯的 serviceName 對應的可用 serverList</strong>,網關的特殊性導致需要接入的服務數量極為龐大，進而導致運行一段時間後 DAG 的線程數量急劇膨脹，對於同步 serverList 這樣的動作而言，完全可以採用非阻塞的方式從註冊中心拉取相關的 serverList , 這種模式下單線程足以滿足性能要求。</p><p style="color:#24292f; text-align:start"><img alt="1078.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/1078.jpeg" referrerpolicy="no-referrer"></p><p style="text-align:center">serverList 的更新前後架構對比</p><p style="color:#24292f; text-align:start">通過預先初始化的方式以及全局只使用 1 個 context 的方式，可以將這裏冷啓動尖刺消除，改造後的測試結果符合預期。<img alt="6034.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/6034.jpeg" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">通過進一步修改優化 spring loadbalance serverList 同步機制，降低 90% 線程數量的使用。</p><p style="color:#24292f; text-align:start"><img alt="879.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/879.png" referrerpolicy="no-referrer"></p><p style="text-align:center">優化前線程數量（725）</p><p style="color:#24292f; text-align:start"><img alt="779.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/779.png" referrerpolicy="no-referrer"></p><p style="text-align:center">優化後線程數量（72）</p><span id="OSC_h2_31"></span><h2>集羣限流改造優化</h2><p style="color:#24292f; text-align:start">首先來看 DAG 啓動後 sentinel 相關線程，類似的問題，線程數量非常多，需要針對性優化。<img alt="234.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/234.png" referrerpolicy="no-referrer"></p><p style="text-align:center">Sentinel 線程數</p><p style="color:#24292f; text-align:start">sentinel 線程分析優化：</p><p style="color:#24292f; text-align:start"><img alt="120.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/120.jpeg" referrerpolicy="no-referrer"><img alt="220.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/220.png" referrerpolicy="no-referrer"></p><p style="text-align:center">最終優化後的線程數量為 4 個</p><p style="color:#24292f; text-align:start">sentinel 原生限流源碼分析如下，進一步分析 SphU#entry 方法發現其底調用 FlowRuleCheck#passClusterCheck；<strong>在 passClusterCheck 方法中發現底層網絡 IO 調用為阻塞式</strong>，由於該方法的執行線程為 workerEventLoop，因此需要使用上文提到的 AsyncClient 進行優化。</p><pre><code>private void doSentinelFlowControl(ServerWebExchange exchange, GatewayFilterChain chain, String resource){
    Entry urlEntry = null;
    try {
        if (!StringUtil.isEmpty(resource)) {
            //1. 檢測是否限流
            urlEntry = SphU.entry(resource, ResourceTypeConstants.COMMON_WEB, EntryType.IN);
        }
       //2. 通過，走業務邏輯
        chain.filter(exchange);
    } catch (BlockException e) {
        //3. 攔截，直接返回 503
        ResponseDecorator.failResponseWithStatus(exchange, HttpResponseStatus.SERVICE_UNAVAILABLE, ResultCode.SERVICE_UNAVAILABLE.message);
    } catch (RuntimeException e2) {
        Tracer.traceEntry(e2, urlEntry);
        log.error(ExceptionUtils.getFullStackTrace(e2));
        ResponseDecorator.failResponseWithStatus(exchange, HttpResponseStatus.INTERNAL_SERVER_ERROR,HttpResponseStatus.INTERNAL_SERVER_ERROR.reasonPhrase());
    } finally {
        if (urlEntry != null) {
            urlEntry.exit();
        }
        ContextUtil.exit();
    }
}
</code></pre><p style="text-align:center">SentinelGatewayFilter（sentinel 適配 SCG 的邏輯）</p><pre><code>public class RedisTokenService implements InitializingBean {
    private final RedisAsyncClient client = new RedisAsyncClient();
    private final RedisChannelPoolKey connectionKey;
    
    public RedisTokenService(String host, int port, String password, int database, boolean ssl){
        connectionKey = new RedisChannelPoolKey(String host, int port, String password, int database, boolean ssl);
    }
    //請求 token
    public Future&lt;TokenResult&gt; asyncRequestToken(ClusterFlowRule rule){
        ....
        sendMessage(redisReqMsg,this.connectionKey)
    }
    
    private Future&lt;TokenResult&gt; sendMessage(RedisMessage requestMessage, EventExecutor executor, RedisChannelPoolKey poolKey){
        AsyncRequest&lt;RedisMessage,RedisMessage&gt; request = client.newRequest(executor, poolKey,requestMessage);
        DefaultPromise&lt;TokenResult&gt; tokenResultFuture = new DefaultPromise&lt;&gt;(request.getExecutor());

        request.timeout(timeout)
                .onComplete(response -&gt; {
                    ...
                    tokenResultFuture.setSuccess(response);
                })
                .onError(throwable -&gt; {
                    ...
                    tokenResultFuture.setFailure(throwable);
                }).sendRequest();

        return tokenResultFuture;
    }
}
</code></pre><p style="text-align:center">RedisTokenService</p><p style="color:#24292f; text-align:start">最終的限流 Filter 代碼如下：</p><pre><code>public class SentinelGatewayFilter implements RequestFilter {
    @Resource
    RedisTokenService tokenService;\
    
    @Override
    public void filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        //當前為 netty NioEventloop 線程
        ServerHttpRequest request = exchange.getRequest();
        String resource = request.getPath() != null ? request.getPath() : "";
  
        //判斷是否有集羣限流規則
        ClusterFlowRule rule = ClusterFlowManager.getClusterFlowRule(resource);
        if (rule != null) {
           //異步非阻塞請求 token
            tokenService.asyncRequestToken(rule,exchange.getExecutor())
                    .addListener(future -&gt; {
                        TokenResult tokenResult;
                        if (future.isSuccess()) {
                            tokenResult = (TokenResult) future.getNow();
                        } else {
                            tokenResult = RedisTokenService.FAIL;
                        }
                        if(tokenResult == RedisTokenService.FAIL || tokenResult == RedisTokenService.ERROR){
                            log.error("Request cluster token failed, will back to local flowRule check");
                        }
                        ClusterFlowManager.setTokenResult(rule.getRuleId(), tokenResult);
                        doSentinelFlowControl(exchange, chain, resource);
                    });
        } else {
            doSentinelFlowControl(exchange, chain, resource);
        }
    }
}
</code></pre><p style="text-align:center">改造後適配 DAG 的 SentinelGatewayFilter</p><span id="OSC_h1_32"></span><h1>六、壓測性能</h1><span id="OSC_h2_33"></span><h2>DAG 高壓表現</h2><p style="color:#24292f; text-align:start">wrk -t32 -c1000 -d60s -s param-delay1ms.lua --latency http://a.b.c.d:xxxxx</p><p style="color:#24292f; text-align:start">DAG 網關的 QPS、實時 RT、錯誤率、CPU、內存監控圖；<strong>在 CPU 佔用 80% 情況下，能夠支撐的 QPS 在 4.5W。</strong><img alt="657.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/657.png" referrerpolicy="no-referrer"></p><p style="text-align:center">DAG 網關的 QPS、RT 折線圖</p><p style="color:#24292f; text-align:start"><img alt="645.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/645.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>DAG 在 CPU 佔用 80% 情況下，能夠支撐的 QPS 在 4.5W，ART 19ms</strong></p><span id="OSC_h2_34"></span><h2>SCG 高壓表現</h2><p style="color:#24292f; text-align:start">wrk -t32 -c1000 -d60s -s param-delay1ms.lua --latency http://a.b.c.d:xxxxx</p><p style="color:#24292f; text-align:start">SCG 網關的 QPS、實時 RT、錯誤率、CPU、內存監控圖：<img alt="3410.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/3410.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">SCG 網關的 QPS、RT 折線圖：<img alt="1670.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/1670.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>SCG 在 CPU 佔用 95% 情況下，能夠支撐的 QPS 在 1.1W，ART 54.1ms</strong></p><span id="OSC_h2_35"></span><h2>DAG 低壓表現</h2><p style="color:#24292f; text-align:start">wrk -t5 -c20 -d120s -s param-delay1ms.lua --latency http://a.b.c.d:xxxxx</p><p style="color:#24292f; text-align:start">DAG 網關的 QPS、實時 RT、錯誤率、CPU、內存：<img alt="1354.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/1354.png" referrerpolicy="no-referrer"></p><p style="text-align:center">DAG 網關的 QPS、RT 折線圖：</p><p style="color:#24292f; text-align:start"><img alt="1·.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/1%C2%B7.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>DAG 在 QPS 1.1W 情況下，CPU 佔用 30%，ART 1.56ms</strong></p><span id="OSC_h2_36"></span><h2>數據對比</h2><p style="color:#24292f; text-align:start"><img alt="00.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/-00.jpeg" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>結論</strong></p><p style="color:#24292f; text-align:start">滿負載情況下，DAG 要比 SCG 的吞吐量高很多，QPS 幾乎是 4 倍，RT 反而消耗更低，SCG 在 CPU 被打滿後，RT 表現出現嚴重性能劣化。DAG 的吞吐控制和 SCG 一樣情況下，CPU 和 RT 損耗下降了更多。DAG 在最大壓力下，內存消耗比較高，達到了 75% 左右，不過到峯值後，就不再會有大幅變動了。對比壓測結果，結論令人欣喜，<strong>SCG 作為 Java 生態當前使用最廣泛的網關，其性能屬於一線水準，DAG 的性能達到其 4 倍以上也是遠超意料，這樣的結果給與研發同學極大的鼓舞。</strong></p><span id="OSC_h1_37"></span><h1>七、投產收益</h1><span id="OSC_h2_38"></span><h2>安全性提升</h2><p style="color:#24292f; text-align:start"><strong>完善的接口級路由管理</strong></p><p style="color:#24292f; text-align:start">基於接口註冊模式的全新路由上線，包含了接口註冊的申請人，申請時間，接口場景備註信息等，接口管理更加嚴謹規範；結合路由組功能可以方便的查詢當前服務的所有對外接口信息，某種程度上具備一定的 API 查詢管理能力；同時為了緩解用户需要檢索的接口太多的尷尬，引入了一鍵收藏功能，大部分時候用户只需要切換到已關注列表即可。</p><p style="color:#24292f; text-align:start"><img alt="·01.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/%C2%B701.png" referrerpolicy="no-referrer"></p><p style="text-align:center">註冊接口列表</p><p style="color:#24292f; text-align:start"><img alt="=0.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/=0.png" referrerpolicy="no-referrer"></p><p style="text-align:center">接口收藏</p><p style="color:#24292f; text-align:start"><strong>防滲透能力極大增強</strong></p><p style="color:#24292f; text-align:start">早期的泛化路由，給黑產的滲透帶來了極大的想象空間和安全隱患，甚至可以在外網直接訪問某些業務的配置信息。<img alt="701.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/701.jpeg" referrerpolicy="no-referrer"></p><p style="text-align:center">黑產接口滲透</p><p style="color:#24292f; text-align:start">接口註冊模式啓用後，所有未註冊的接口均無法訪問，防滲透能力提升一個台階，同時自動推送異常接口訪問信息。</p><p style="color:#24292f; text-align:start"><img alt="81.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/8-1.png" referrerpolicy="no-referrer"></p><p style="text-align:center">404 接口訪問異常推送</p><span id="OSC_h2_39"></span><h2>穩定性增強</h2><p style="color:#24292f; text-align:start"><strong>內存泄漏問題解決</strong></p><p style="color:#24292f; text-align:start">通過一系列手段改進優化和嚴格的測試，新網關的內存使用更加穩健，內存增長曲線直接拉平，徹底解決了泄漏問題。</p><p style="color:#24292f; text-align:start"><img alt="2300.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/2300.png" referrerpolicy="no-referrer"></p><p style="text-align:center">老網關內存增長趨勢</p><p style="color:#24292f; text-align:start"><img alt="789=.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/789=.png" referrerpolicy="no-referrer"></p><p style="text-align:center">新網關內存增長趨勢</p><p style="color:#24292f; text-align:start"><strong>響應時間尖刺消除</strong></p><p style="color:#24292f; text-align:start">通過預先初始化 &amp; context 共用等手段，去除了運行時併發創建多個 context 搶佔全局鎖的開銷，冷啓動 RT 尖刺降低 99% ；關於 spring load balance 模塊的更多優化細節可以參考這篇博客：Spring LoadBalance 存在問題與優化。</p><p style="color:#24292f; text-align:start"><strong>壓測數據對比</strong><img alt="1=.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/1-=.jpeg" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>實際生產監控</strong></p><p style="color:#24292f; text-align:start">趨勢圖上略有差異，但是從非 200 請求的絕對值上看，這種差異可以忽略, <strong>對比發佈期間和非發佈期間異常請求的數量，發現基本沒有區別，這代表着以往的發佈期間的響應時間尖刺基本消除，做到了發佈期間業務服務徹底無感知。</strong></p><p style="color:#24292f; text-align:start"><img alt="01.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/0-1.jpeg" referrerpolicy="no-referrer"></p><p style="text-align:center">1 月 4 日發佈期間各節點流量變化</p><p style="color:#24292f; text-align:start"><img alt="02.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/0-2.png" referrerpolicy="no-referrer"></p><p style="text-align:center">1 月 4 日異常請求狀態數量監控 (發佈期間)</p><p style="color:#24292f; text-align:start"><img alt="03.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/0-3.png" referrerpolicy="no-referrer"></p><p style="text-align:center">1 月 5 日異常請求狀態數量監控（無發佈）</p><span id="OSC_h2_40"></span><h2>降本增效</h2><p style="color:#24292f; text-align:start"><strong>資源佔用下降 50% +</strong></p><p style="color:#24292f; text-align:start"><img alt="04.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/0-4.png" referrerpolicy="no-referrer"></p><p style="text-align:center">SCG 平均 CPU 佔用</p><p style="color:#24292f; text-align:start"><img alt="05.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/0-5.png" referrerpolicy="no-referrer"></p><p style="text-align:center">DAG 資源佔用</p><p style="color:#24292f; text-align:start"><strong>JDK17 升級收益</strong></p><p style="color:#24292f">得益於 ZGC 的優秀算法，JVM17 在 GC 暫停時間上取得了出色的成果，網關作為延遲敏感型應用對 GC 的暫停時間尤為看重，為此我們組織升級了 JDK17 版本；下面為同等流量壓力情況下的配置不同 GC 的效果對比，<strong>可以看到 GC 的暫停時間從平均 70ms 降低到 1ms 內，RT99 線得到大幅度提升；吞吐量不再受流量波動而大幅度變化，性能表現更加穩定；同時網關的平均響應時間損耗降低 5%。</strong></p><p style="color:#24292f"><img alt="08.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/0-8.png" referrerpolicy="no-referrer"></p><p style="text-align:center">JDK8-G1 暫停時間表現</p><p style="color:#24292f; text-align:start"><img alt="09.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/09-.png" referrerpolicy="no-referrer"></p><p style="text-align:center">JDK17-ZGC 暫停時間表現</p><p style="color:#24292f; text-align:start">吞吐量方面，G1 伴隨流量的變化呈現出一定的波動趨勢，均線在 99.3% 左右。ZGC 的吞吐量則比較穩定，維持在無限接近 100% 的水平。</p><p style="color:#24292f; text-align:start"><img alt="9.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/9--.png" referrerpolicy="no-referrer"></p><p style="text-align:center">JDK8-G1 吞吐量</p><p style="color:#24292f; text-align:start"><img alt="1.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/--1.png" referrerpolicy="no-referrer"></p><p style="text-align:center">JDK17-ZGC 吞吐量</p><p style="color:#24292f; text-align:start">對於實際業務接口的影響，從下圖中可以看到平均響應時間有所下降，這裏的 RT 差值表示接口經過網關層的損耗時間；不同接口的 RT 差值損耗是不同的，這可能和請求響應體的大小，是否經過登錄驗證，風控驗證等業務邏輯有關。</p><p style="color:#24292f; text-align:start"><img alt="80.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/8-0.png" referrerpolicy="no-referrer"></p><p style="text-align:center">JDK17 與 JDK8 ART 對比</p><p style="color:#24292f; text-align:start">需要指出的是 ZGC 對於一般的 RT 敏感型應用有很大提升， 服務的 RT 99 線得到顯著改善。但是如果當前應用大量使用了堆外內存的方式，則提升相對較弱，如大量使用 netty 框架的應用, 因為這些應用的大部分數據都是通過手動釋放的方式進行管理。</p><span id="OSC_h1_41"></span><h1>八、思考總結</h1><span id="OSC_h2_42"></span><h2>架構演進</h2><p style="color:#24292f; text-align:start">API 網關的自研並非一蹴而就，而是經歷了多次業務迭代循序漸進的過程；從早期的泛化路由引發的安全問題處理，到後面的大量路由註冊，帶來的匹配性能下降 ，以及最終壓垮老網關最後一根稻草的內存泄漏問題；在不同階段需要使用不同的應對策略，早期業務快速迭代，大量的需求堆積，最快的時候一個功能點的改動需要三四天內上線 ，我們很難有足夠的精力去做一些深層次的改造，這個時候需求導向為優先，功能性建設完善優先，是一個快速奔跑的建設期；伴隨體量的增長安全和穩定性的重視程度逐步拔高，繼而推進了這些方面的大量建設；從拓展 SCG 的原有功能到改進框架源碼，以及最終的自研重寫，可以説新的 API 網關是一個業務推進而演化出來的產物，也只有這樣 」生長「 出來的架構產品才能更好的契合業務發展的需要。</p><span id="OSC_h2_43"></span><h2>技術思考</h2><p style="color:#24292f; text-align:start">開源的 API 網關有很多，但是自研的案例並不多，我們能夠參考的方案也很有限。除了幾個業界知名的產品外，很多開源的項目參考的價值並不大；從自研的目標來看，我們最基本的要求是性能和穩定性要優於現有的開源產品，至少 Java 的生態是這樣；這就要求架構設計和代碼質量上必須比現有的開源產品更加優秀，才有可能；為此我們深度借鑑了流量代理界的常青樹 Nginx，發現基於 Linux 多進程模型下的 OS，如果要發揮出最大效能，單 CPU 核心支撐單進程（線程）是效率最高的模式。可以將 OS 的進程調度開銷最小化同時將高速緩存 miss 降到最低，此外還要儘可能減少或者消除數據競爭，避免鎖等待和自旋帶來的性能浪費；DAG 的整個技術架構可以簡化的理解為引入了獨立控制流的多線程版的 Nginx。</p><p style="color:#24292f; text-align:start">中間件的研發創新存在着較高的難度和複雜性，更何況是在業務不斷推進中換引擎。在整個研發過程中，為了儘可能適配老的業務邏輯，對原有的業務邏輯的改動最小化，新網關對老網關的架構層接口做了全面適配；換句話説新引擎的對外暴露的核心接口與老網關保持一致，讓老的業務邏輯在 0 改動或者僅改動少量幾行代碼後就能在新網關上直接跑，能夠極大幅度降低我們的測試迴歸成本，因為這些代碼本身的邏輯正確性，已經在生產環境得到了大量驗證。這樣的適配器模式同樣適用於其他組件和業務開發。</p><p style="color:#24292f; text-align:start">作為底層基礎組件的開發人員，要對自己寫下的每一行代碼都有清晰的認識，不瞭解的地方一定要多翻資料，多讀源碼，模稜兩可的理解是絕對不夠的；常見的開源組件雖然説大部分代碼都是資深開發人員寫出來的，但是有程序員的地方就有 bug ，要帶着審慎眼光去看到這些組件，而不是一味地使用盲從，所謂盡信書不如無書；很多中間件的基本原理都是相通的，如常見 Raft 協議，基於 epoll 的 reactor 網絡架構，存儲領域的零拷貝技術，預寫日誌，常見的索引技術，hash 結構，B+樹，LSM 樹等等。一個成熟的中間件往往會涉及多個方向的技術內容。研發人員並不需要每一個組件都涉獵極深，也不現實，掌握常見的架構思路和技巧以及一些基本的技術點，做到對一兩個組件做到熟稔於心。思考和理解到位了，很容易觸類旁通。</p><span id="OSC_h2_44"></span><h2>穩定性把控</h2><p style="color:#24292f; text-align:start">自研基礎組件是一項浩大的工程，可以預見代碼量會極為龐大，如何有效管理新項目的代碼質量是個棘手的問題; 原有業務邏輯的改造也需要回歸測試；現實的情況是中間件團隊沒有專職的測試，質量保證完全依賴開發人員；這就對開發人員的代碼質量提出了極高的要求，一方面我們通過與老網關適配相同的代理引擎接口，降低遷移成本和業務邏輯出現 bug 的概率；另一方面還對編碼質量提出了高標準，平均每週兩到三次的 CodeReview；80% 的單元測試行覆蓋率要求。</p><p style="color:#24292f; text-align:start">網關作為流量入口，承接全司最高流量，對穩定性的要求極為苛刻。最理想的狀態是在業務服務沒有任何感知的情況下，我們將新網關逐步替換上去；為此我們對新網關上線的過程做了充分的準備，嚴格控制上線過程；具體來看整個上線流程分為以下幾個階段：</p><p style="color:#24292f; text-align:start"><strong>第一階段</strong></p><p style="color:#24292f; text-align:start">我們在壓測環境長時間高負載壓測，持續運行時間 24 小時以上，以檢測內存泄漏等穩定性問題。同時利用性能檢測工具抓取熱點火焰圖，做針對性優化。</p><p style="color:#24292f; text-align:start"><strong>第二階段</strong></p><p style="color:#24292f; text-align:start">發佈測試環境試跑，採用並行試跑的方式，新老網關同時對外提供服務（流量比例 1 ：1，初期新網關承接流量可能只有十分之一），一旦用户反饋的問題可能跟新網關有關，或者發現異常 case，立即關停新網關的流量。待查明原因並確認修復後，重新引流。</p><p style="color:#24292f; text-align:start"><strong>第三階段</strong></p><p style="color:#24292f; text-align:start">上線預發，小得物環境試跑，由於這些環境流量不大，依然可以並行長時間試跑，發現問題解決問題。</p><p style="color:#24292f; text-align:start"><strong>第四階段</strong></p><p style="color:#24292f; text-align:start">生產引流，單節點從萬分之一比例開始灰度，逐步引流放大，每個階段停留 24 小時以上，觀察修正後再放大，循環此過程；基於單節點承擔正常比例流量後，再次抓取火焰圖，基於真實流量場景下的性能熱點做針對性優化。</p><span id="OSC_h2_45"></span><h2>團隊成長</h2><p style="color:#24292f; text-align:start">回顧整個研發歷程我們在不間斷新業務承接的情況下，幾個月時間內完成開發和上線，從節奏上來講不可謂不快，研發同學的心態也經歷了一些變化。從一開始的質疑，認為大家以前從沒有做過的東西現在就這點人能搞的出來嗎？到中期的這個組件寫起來蠻有挑戰也很有意思！直到後期初版壓測數據出來後的驚訝。就項目結果而言，可以説收穫感滿滿，從後續的針對研發同學的 one one 溝通反饋來看，對於整個項目感觸最大的是技術上的提升很大，對高併發網絡編程領域的認知提升了一個檔次, 尤其是異步編程方面，技術信心增強很多；內部也組織了分享會，大家普遍很感興趣，收穫了較大的技術紅利。</p><p style="color:#24292f; text-align:start">*<strong>文/簌語</strong></p><p>本文屬得物技術原創，更多精彩文章請看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.dewu.com" target="_blank">得物技術官網</a></p><p>未經得物技術許可嚴禁轉載，否則依法追究法律責任！</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 02:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/11033092</guid>
            <link>https://my.oschina.net/u/5783135/blog/11033092</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微軟投資「歐洲版 OpenAI」 Mistral]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>微軟公司週一宣佈與法國大模型創業公司&nbsp;Mistral AI 建立新的合作伙伴關係，後者有 「歐洲版 OpenAI」 之稱。</p><p>微軟在一份聲明中表示將投資 20 億歐元幫助 Mistral AI 開啓「新的商業機會」，並向全球市場擴張，但沒有提供進一步的財務細節。</p><p>根據協議，Mistral 宣佈其最先進的大模型 Mistral Large 首次通過微軟的雲服務 Azure 提供——成為繼 OpenAI 之後第二家在微軟 Azure 雲計算平台上提供商業語言模型的公司。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-24b13d1f5c37e4bc325eac6c3bbdf3ab204.png" referrerpolicy="no-referrer"><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmistral.ai%2Fnews%2Fmistral-large%2F" target="_blank">https://mistral.ai/news/mistral-large/</a></em></u></p><p>微軟還將幫助這家初創公司獲得新客户，後者將推出其 ChatGpt 風格的多語言對話助手「Le Chat」（貓）。微軟總裁布拉德·史密斯（Brad Smith）週一表示，這筆交易是該公司支持歐洲技術的「重要」信號。</p><p>與此同時，有人發現 Mistral AI 修改了其網站內容，刪除了所有提及對開源社區義務的內容，所以有網友推測他們未來不太可能再發布任何開源模型。</p><p><img src="https://oscimg.oschina.net/oscnet/up-c96c457e5fd400acfcd37ead7a44f8b1528.png" referrerpolicy="no-referrer"></p><p>一位 X 用户發帖稱：「我不想説謊；我很遺憾 Mistral 沒有開源他們的任何模型。我以為他們是 OSS 團隊的。」另一位用户轉發了微軟 CEO 納德拉宣佈與 Mistral AI 合作的消息，並評論稱：「這可能是原因。」馬斯克則<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Felonmusk%2Fstatus%2F1762217391633952953" target="_blank">評論道</a>：「是微軟讓他們閉源的？」</p><p><img height="2051" src="https://oscimg.oschina.net/oscnet/up-6027c2509b672051b14eb678783045ad0e9.png" width="1287" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 27 Feb 2024 02:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280426</guid>
            <link>https://www.oschina.net/news/280426</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[中文 JDK21 API 網站上線，為 Java 開發者提供全新體驗！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#000000; margin-left:0; margin-right:0; text-align:left">Java Development Kit (JDK) 21 是 Java 平台的最新版本，為 Java 開發者提供了許多新特性和改進。為了更好地支持中文開發者，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcunzaima.cn" target="_blank">存在碼官網</a>在此自豪地宣佈推出最新的中文 JDK21 API 網站。</p><p>這個<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcunzaima.cn" target="_blank">存在碼</a>網站將成為中文 Java 開發者的首選資源，提供以下內容：</p><ol><li>中文 Java 教程：提供系統的 Java 編程教程，從 Java 基礎到高級特性，全面介紹 Java 編程的最佳實踐。</li><li>JavaFX 教程：提供 JavaFX 編程的詳細教程，介紹 JavaFX 的視圖和控制器、圖形和動畫、媒體和圖像等多個方面。</li><li>Orekit 教程：提供 Orekit 庫的詳細教程，介紹 Orekit 的軌道運動學和控制、姿態和姿態動力學、導航和定位等多個方面。</li><li>JDK21 API 文檔：提供 JDK21 中所有類和方法的詳細 API 文檔，包括類描述、方法簽名、參數和返回值等。</li><li>JDK21 工具的中文文檔：提供 JDK21 中所有工具的中文文檔，包括<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjava.cunzaima.cn%2Fjdk21%2Fdoc-zh%2Fspecs%2Fman%2Fjpackage.html" target="_blank">j</a>package、jwebserver、jlink、jmap 等。</li></ol><p style="color:#000000; margin-left:0; margin-right:0; text-align:left">我們相信，這個新的中文 JDK21 API 將會成為中文 Java 開發者的不可或缺的工具，為他們提供更加便捷和高效的 Java 開發體驗。歡迎訪問<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcunzaima.cn%2F" target="_blank">https://cunzaima.cn/</a>，並在評論區留下您的反饋和建議。</p><p style="color:#000000; margin-left:0; margin-right:0; text-align:left">感謝您的支持和關注！</p><p style="color:#000000; margin-left:0; margin-right:0; text-align:left"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcunzaima.cn%2F" target="_blank"><img height="100" src="https://oscimg.oschina.net/oscnet/up-3f77e9064178316e9c9acacd55ae6b89c0f.jpg" width="100" referrerpolicy="no-referrer"></a></p><p>網站內容截圖：</p><p><img height="887" src="https://oscimg.oschina.net/oscnet/up-b439f6c336100368058aa097a0cc2cc8b44.png" width="1166" referrerpolicy="no-referrer"></p><p><img height="887" src="https://oscimg.oschina.net/oscnet/up-e5afd9a524f3a61fbd854899739c3a190fb.png" width="1166" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 26 Feb 2024 14:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280393</guid>
            <link>https://www.oschina.net/news/280393</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[ONLYOFFICE 文檔獲得達夢數據兼容認證：如何將數據庫連接到編輯器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.onlyoffice.com%2Fzh%2Foffice-suite.aspx" target="_blank">ONLYOFFICE 文檔</a>獲得了與達夢數據庫的兼容證書。閲讀本文，瞭解如何將數據庫連接到 ONLYOFFICE 開源文檔編輯器。</p><p style="color:#333333; margin-left:0px; margin-right:0px; text-align:center"><img alt="ONLYOFFICE 文檔獲得達夢數據兼容認證：如何將數據庫連接到編輯器" src="https://static-blog.onlyoffice.com/wp-content/uploads/2024/02/22105702/onlyoffice-and-dameng-db.png" referrerpolicy="no-referrer"></p><h2><strong>關於達</strong><strong>夢</strong><strong>數據</strong></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">隨着數字經濟的快速發展，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.dameng.com%2F" target="_blank"><u>達夢</u></a>在數字化轉型解決方案方面積累了豐富的經驗，為客户提供各類數據庫軟件及集羣軟件、雲計算與大數據等一系列產品及服務。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">目前的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fen.dameng.com%2Fview%2F16.html" target="_blank"><u>DM8</u></a><span>&nbsp;</span>是新一代大型通用關係數據庫，完全支持 ANSI SQL 標準和主流編程語言接口/開發框架。該數據庫擁有行列融合存儲技術，兼容 OLAP 和 OLTP 系統，滿足 HTAP 混合應用場景。</p><h2><strong>兼容性</strong><strong>認證</strong></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">ONLYOFFICE 與武漢達蒙數據庫股份有限公司一起通過了相互測試。因此，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.onlyoffice.com%2Fzh%2Fdocs-enterprise.aspx%3Futm_source%3Dblog%26utm_medium%3Darticle%26utm_campaign%3Ddameng" target="_blank"><u>ONLYOFFICE<span>&nbsp;</span></u><u>文檔</u></a>被認證為與 DM8 兼容的穩定解決方案。</p><p style="text-align:center"><img alt="ONLYOFFICE Docs certified by Dameng: How to connect DB to the editors" src="https://static-blog.onlyoffice.com/wp-content/uploads/2024/02/22105811/dameng-certificate-714x1024.jpg" referrerpolicy="no-referrer"></p><h2><strong>如何將</strong><strong>達夢數據庫</strong><strong>連接到 ONLYOFFICE 文檔</strong></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">本指南建議先在一個單獨的分支裏開發實現一個測試 bench：<code>feature/damengdb-compose</code></p><pre><code class="language-javascript"><span>BUILD=&lt;build-number-</span><strong>from</strong><span>-develop&gt; docker compose up -d</span></code></pre><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">使用 Docker 安裝 ONLYOFFICE 文檔時，可以指定可用<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FONLYOFFICE%2FDocker-DocumentServer%3Ftab%3Dreadme-ov-file%23available-configuration-parameters" target="_blank"><u>變量</u></a><em>（DB_TYPE</em>、<em>DB_NAME</em>、<em>DB_HOST、DB_USER</em>、<em>DB_PWD、DB_PORT）</em><em>，</em>允許自定義數據庫連接。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">要連接達夢數據庫，需要將連接條件和參數添加到 ONLYOFFICE 文檔（文件服務器）映像的初始化入口點腳本中。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FONLYOFFICE%2FDocker-DocumentServer%2Fpull%2F712%2Ffiles%23diff-8303d91c24ab115773c468f37319449463b1e1ff312b4e560d14a7c16a1e4b25R377" target="_blank"><u>添加新的數據庫類型</u></a>：</p><pre><code class="language-javascript"><span style="color:#880000">"dameng"</span><span>)
</span><span>      DB_PORT=${</span><span>DB_PORT</span><span>:-</span><span style="color:#880000">"5236"</span><span>}
</span>      ;;</code></pre><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FONLYOFFICE%2FDocker-DocumentServer%2Fpull%2F712%2Ffiles%23diff-8303d91c24ab115773c468f37319449463b1e1ff312b4e560d14a7c16a1e4b25R423" target="_blank"><u>添加</u><u>遠程數據庫創建功能</u></a>：</p><pre><code class="language-javascript"><strong>create_dameng_tbl</strong><span>(</span><span>)</span><span> {
</span>  DM8_USER=SYSDBA
  DM8_PASS=SYSDBA001

<span>  (cd /opt/dmdbms/bin/ &amp;&amp; ./disql $DM8_USER/$DM8_PASS@$DB_HOST:$DB_PORT -e </span><span style="color:#880000">"create user "</span><span>onlyoffice</span><span style="color:#880000">" identified by "</span><span>onlyoffice</span><span style="color:#880000">" password_policy 0;"</span><span>)
</span>  # Create db on remote server
<span>  echo </span><span style="color:#880000">"EXIT"</span><span> | tee -a $APP_DIR/server/schema/dameng/createdb.sql
</span><span>  (cd /opt/dmdbms/bin/ &amp;&amp; ./disql $DM8_USER/$DM8_PASS@$DB_HOST:$DB_PORT \</span><span style="color:#880000">`$APP_DIR/server/schema/dameng/createdb.sql)
</span><span style="color:#880000">}</span></code></pre><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">將這些更改添加到入口腳本後，文檔服務器就可以初始化與數據庫的連接了。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">創建一個簡單的&nbsp;compose 文件，您可以在其中指定文檔服務器所需的變量：</p><ul><li><strong>DB_TYPE：</strong>&nbsp;達夢數據庫</li><li><strong>DB_HOST：</strong>compose 文件中數據庫服務的名稱（DNS 名稱）</li><li><strong>DB_NAME：</strong>要使用的數據庫的名稱。應在容器啓動時出現。</li><li><strong>DB_USER：</strong>用户名</li><li><strong>DB_PWD：</strong>用户密碼</li><li><strong>DB_PORT：</strong>帶數據庫的服務端口</li></ul><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">從<code>damengdb</code><span>&nbsp;</span>容器裝入二進制目錄，以便文件服務器容器可以訪問<code>disql</code><span>&nbsp;</span>實用程序。請參閲<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FONLYOFFICE%2FDocker-DocumentServer%2Fpull%2F712%2Ffiles%23diff-bc48fb274f9199eed1a1a0dabb00738c2c5dd87ab1c85fdb1feb15d22c83f66b" target="_blank"><u>docker-compose.yml</u></a>以瞭解更多信息。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><strong>運行<span>&nbsp;</span></strong><strong>stand</strong></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">要啓動這個 stand，請執行以下命令：</p><pre><code class="language-javascript"><span>git clone -b feature/damentdb-compose https:</span><span style="color:#888888">//github.com/ONLYOFFICE/Docker-DocumentServer.git</span><span></span>cd Docker-DocumentServer/tests/damengdb/
docker compose up –d</code></pre><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">注意：數據庫映像可在&nbsp;hub.docker 上獲得。為方便起見，我們上傳了&nbsp;v8.1.2.128&nbsp;映像：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhub.docker.com%2Fr%2Fdanilaworker%2Fdamengdb" target="_blank"><u>點擊此處查看</u></a>。</p><div><h3><strong>相關鏈接</strong></h3><p style="color:#333333; margin-left:0; margin-right:0"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.dameng.com%2F" target="_blank"><u>達</u><u>夢官方網站</u></a></p><p style="color:#333333; margin-left:0; margin-right:0"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.onlyoffice.com%2Fzh%2Fcertificates.aspx" target="_blank"><u>ONLYOFFICE 證書</u></a></p><p style="color:#333333; margin-left:0; margin-right:0"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.onlyoffice.com%2Fzh%2Fdownload-docs.aspx" target="_blank"><u>獲取 ONLYOFFICE 文檔</u></a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Mon, 26 Feb 2024 12:18:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280385</guid>
            <link>https://www.oschina.net/news/280385</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[鴻蒙程序員平均月薪超 1 萬 8]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>據智聯招聘數據顯示，春招鴻蒙崗位需求是去年近 3 倍。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-47729617a06471ca213c42bdadb7fd974ad.png" referrerpolicy="no-referrer"></p><p>本月初，華為 HarmonyOS 在新年賀詞中提到，基於開源鴻蒙開發的 HarmonyOS NEXT 鴻蒙星河版將在今年秋天正式和消費者見面，這也促使大量企業急需鴻蒙人才。</p><p>春節後開工第一週，鴻蒙相關職位數同比增長 163%，投遞人數同比增長 349%，同時，鴻蒙開發崗的招聘薪資，達到 18191 元/月，比總體開發崗的平均薪資（16617 元/月）高出 9%。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-bb038ad20fec544a0619fbde6c5f4049059.png" referrerpolicy="no-referrer"></p><p>來自：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1656737654%2FO2miyxjc4" target="_blank">現代快報</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 25 Feb 2024 10:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/280369</guid>
            <link>https://www.oschina.net/news/280369</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[糟糕，被 SimpleDateFormat 坑到啦！| 京東雲技術團隊]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h3_1"></span><h3><span><span><span>1. 問題背景</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>問題的背景是這樣的，在最近需求開發中遇到需要將給定</span></span></span><span><span><strong><span>目標數據</span></strong></span></span><span><span><span>通過某一固定的</span></span></span><span><span><strong><span>計量規則</span></strong></span></span><span><span><span>進行過濾並打標生成</span></span></span><span><span><strong><span>明細數據</span></strong></span></span><span><span><span>，其中發現存在一筆</span></span></span><span><span><strong><span>目標數據</span></strong></span></span><span><span><span>的時間在</span></span></span><span><span><strong><span>不符合</span></strong></span></span><span><span><span>現有</span></span></span><span><span><strong><span>日期規則</span></strong></span></span><span><span><span>的條件下，還是通過了規則引擎的匹配打標操作。故而需要對該</span></span></span><span><span><strong><span>錯誤匹配場景</span></strong></span></span><span><span><span>進行排查，</span></span></span><span><span><strong><span>定位</span></strong></span></span><span><span><span>其</span></span></span><span><span><strong><span>根本原因</span></strong></span></span><span><span><span>所在。</span></span></span></p><span id="OSC_h3_2"></span><h3><span><span><span>2. 排查思路</span></span></span></h3><span id="OSC_h4_3"></span><h4><span><span><span>2.1 數據定位</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>在開始排查問題之初，先假定現有的</span></span></span><span><span><strong><span>Aviator 規則引擎</span></strong></span></span><span><span><span>能夠對現有的數據進行正常的匹配打標，查詢在存在問題數據（圖中紅框所示）同一時刻進行規則匹配時的數據都有哪些。發現存在五筆數據在同一時刻進行規則匹配落庫。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-02-01-17-01Xmnw6twL44j44ufD6.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p>&nbsp;</p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>繼續查詢具體的</span></span></span><span><span><strong><span>匹配規則表達式</span></strong></span></span><span><span><span>，發現針對</span></span></span><span><span><strong><span>loanPayTime</span></strong></span></span><span><span><span>時間區間在</span></span></span><span><span><strong><span>[2022-07-16 00:00:00, 2023-05-11 23:59:59]</span></strong></span></span><span><span><span>的範圍內進行匹配，</span></span></span><span><span><strong><span>目標數據</span></strong></span></span><span><span><span>的時間為</span></span></span><span><span><strong><span>2023-09-19 11:27:29</span></strong></span></span><span><span><span>，理論上應該不會被匹配到。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-01-23-20-34VqCxKbos8IpYoic.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>但是觀測匹配打標的明細數據發現確實打標</span></span></span><span><span><strong><span>成功</span></strong></span></span><span><span><span>了（如紅框所示）。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-02-01-17-02wRWsgztvSkjaVTx.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>所以</span></span></span><span><span><strong><span>重新</span></strong></span></span><span><span><span>回到最初的和目標數據同時落庫的</span></span></span><span><span><strong><span>五筆數據</span></strong></span></span><span><span><span>發現，這五筆數據的</span></span></span><span><span><strong><span>loanPayTime</span></strong></span></span><span><span><span>時間確實在規則</span></span></span><span><span><strong><span>[2022-07-16 00:00:00, 2023-05-11 23:59:59]</span></strong></span></span><span><span><span>之內，所以在想</span></span></span><span><span><strong><span>有沒有可能</span></strong></span></span><span><span><span>是在目標數據匹配規則引擎</span></span></span><span><span><strong><span>前</span></strong></span></span><span><span><span>，其它的五筆數據中的其中一筆對該數據進行了</span></span></span><span><span><strong><span>修改</span></strong></span></span><span><span><span>導致</span></span></span><span><span><strong><span>誤匹配</span></strong></span></span><span><span><span>到了這個規則。順着這個思路，首先需要確認下 Aviator 規則引擎</span></span></span><span><span><strong><span>在併發場景下是否線程安全</span></strong></span></span><span><span><span>的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-02-01-17-04oLk40Ts40iXT140sSf.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h4_4"></span><h4><span><span><span>2.2 規則引擎</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>由於在需求中使用到用於給數據匹配打標的是</span></span></span><span><span><strong><span>Aviator 規則引擎</span></strong></span></span><span><span><span>，所以第一直覺是懷疑 Aviator 規則引擎在併發的場景中可能會存在</span></span></span><span><span><strong><span>線程不安全</span></strong></span></span><span><span><span>的情況。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-01-23-20-36NNJAleyXLMv67L7.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>首先簡單介紹下 Aviator 規則引擎是什麼，Aviator 是一個</span></span></span><span><span><strong><span>高性能</span></strong></span></span><span><span><span>的、</span></span></span><span><span><strong><span>輕量級</span></strong></span></span><span><span><span>的 java 語言實現的表達式求值引擎，主要用於各種表達式的動態求值，相較於其它的開源可用的規則引擎而言，Aviator 的設計目標是</span></span></span><span><span><code><span>輕量級</span></code></span></span><span><span><span>和</span></span></span><span><span><code><span>高性能</span></code></span></span><span><span><span> ，相比於 Groovy、JRuby 的笨重，Aviator 非常小，加上依賴包也才</span></span></span><span><span><strong><span>450</span></strong></span></span><span><span><span>K,不算依賴包的話只有</span></span></span><span><span><strong><span>70</span></strong></span></span><span><span><span>K；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>當然，Aviator 的語法是受限的，它不是一門完整的語言，而只是語言的一小部分集合。其次，Aviator 的實現思路與其他輕量級的求值器很不相同，其他求值器一般都是通過解釋的方式運行，而 Aviator 則是直接將表達式</span></span></span><span><span><code><span>編譯成 Java 字節碼</span></code></span></span><span><span><span>，交給 JVM 去執行。簡單來説，Aviator 的定位是介於 Groovy 這樣的重量級腳本語言和 IKExpression 這樣的輕量級表達式引擎之間。（具體 Aviator 的相關介紹不是本文的重點，具體可</span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F608829" target="_blank" rel="nofollow"><span><span><span>參見</span></span></span></a><span><span><span>）</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>通過查閲相關資料發現，Aviator 中的 AviatorEvaluator.execute() 方法本身是線程安全的，也就是説只要表達式執行邏輯和傳入的 env 是線程安全的，理論上是不會出現併發場景下線程不安全問題的。（</span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkillme2008%2Faviatorscript%2Fissues%2F91" target="_blank" rel="nofollow"><span><span><span>詳見</span></span></span></a><span><span><span>）</span></span></span></p><span id="OSC_h4_5"></span><h4><span><span><span>2.3 匹配規則引擎的 env</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-01-23-20-38QGCcHoTw0KIgKpf.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>通過前面 Aviator 的相關資料發現</span></span></span><span><span><strong><span>傳入的 env</span></strong></span></span><span><span><span>如果在多線程場景下不安全也會導致最終的結果是錯誤的，故而定位使用的 env 發現使用的是</span></span></span><span><span><strong><span>HashMap</span></strong></span></span><span><span><span>，該集合類確實是線程不安全的（具體可</span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.51cto.com%2Fknifeedge%2F5011416" target="_blank" rel="nofollow"><span><span><span>詳見</span></span></span></a><span><span><span>），但是線程不安全的前提是多個線程同時對其進行修改，定位代碼發現在每次調用方式時都會</span></span></span><span><span><strong><span>重新生成</span></strong></span></span><span><span><span>一個 HashMap，故而應該</span></span></span><span><span><strong><span>不會</span></strong></span></span><span><span><span>是由於這個線程不安全類導致的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-01-23-20-40XifGzYMnY6zLzQq.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>繼續定位發現，</span></span></span><span><span><strong><span>loanPayTime</span></strong></span></span><span><span><span>這個字段在進行 Aviator 規則引擎匹配前使用</span></span></span><span><span><strong><span>SimpleDateFormat</span></strong></span></span><span><span><span>進行了格式化，所以</span></span></span><span><span><strong><span>有可能</span></strong></span></span><span><span><span>是由於該類的</span></span></span><span><span><strong><span>線程不安全</span></strong></span></span><span><span><span>導致的</span></span></span><span><span><strong><span>數據錯亂</span></strong></span></span><span><span><span>問題，但是這個類應該只是對日期進行格式化處理，難不成還能影響最終的數據。帶着這個疑問查詢資料發現，emm 確實是線程不安全的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-01-23-20-40XFWp8NlBcdsIElo.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>好傢伙，</span></span></span><span><span><strong><span>嫌疑對象</span></strong></span></span><span><span><span>目前已經有了，現在就是尋找相關證據來</span></span></span><span><span><strong><span>佐證</span></strong></span></span><span><span><span>了。</span></span></span></p><span id="OSC_h3_6"></span><h3><span><span><span>3. SimpleDateFormat 還能線程不安全？</span></span></span></h3><span id="OSC_h4_7"></span><h4><span><span><span>3.1 先寫個 demo 試試</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>話不多説，直接去測試一下在</span></span></span><span><span><strong><span>併發場景</span></strong></span></span><span><span><span>下，SimpleDateFormat 類會不會對需要格式化的日期進行</span></span></span><span><span><strong><span>錯亂</span></strong></span></span><span><span><span>格式化。先模擬一個場景，對多線程併發場景下格式化日期，即在</span></span></span><span><span><strong><span>[0,9]</span></strong></span></span><span><span><span>的數據範圍內，在</span></span></span><span><span><strong><span>偶數</span></strong></span></span><span><span><span>情況下對 2024 年 1 月 23 日進行格式化，在</span></span></span><span><span><strong><span>奇數</span></strong></span></span><span><span><span>情況下對 2024 年 1 月 22 日進行格式化，然後觀測日誌打印效果。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.text.</span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.time.</span></span><span><span style="color:#dd4a68">Duration</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.time.</span></span><span><span style="color:#dd4a68">LocalDateTime</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.util.</span></span><span><span style="color:#dd4a68">Date</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.util.concurrent.</span></span><span><span style="color:#dd4a68">ExecutorService</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.util.concurrent.</span></span><span><span style="color:#dd4a68">Executors</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.util.concurrent.</span></span><span><span style="color:#dd4a68">TimeUnit</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">ThreadSafeDateFormatDemo</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span> dateFormat </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"yyyy-MM-dd HH:mm:ss"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">ExecutorService</span></span><span><span> executor </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">Executors</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">newFixedThreadPool</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">10</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#dd4a68">LocalDateTime</span></span><span><span> startDateTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">LocalDateTime</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">now</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#dd4a68">Date</span></span><span><span> date </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Date</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">for</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">int</span></span><span><span> i </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">0</span></span><span><span style="color:#999999">;</span></span><span><span> i </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&lt;</span></span><span><span></span></span><span><span style="color:#990055">1000</span></span><span><span style="color:#999999">;</span></span><span><span> i</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">++</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> finalI </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> i</span></span><span><span style="color:#999999">;</span></span><span><span>
            executor</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">submit</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">try</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>finalI </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">%</span></span><span><span></span></span><span><span style="color:#990055">2</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">==</span></span><span><span></span></span><span><span style="color:#990055">0</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> formattedDate </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> dateFormat</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">format</span></span><span><span style="color:#999999">(</span></span><span><span>date</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">//第一種</span></span><span><span></span></span><span><span style="color:#708090">//                        String formattedDate = DateUtil.formatDate(date);</span></span><span><span></span></span><span><span style="color:#708090">//第二種</span></span><span><span></span></span><span><span style="color:#708090">//                        String formattedDate = DateSyncUtil.formatDate(date);</span></span><span><span></span></span><span><span style="color:#708090">//第三種</span></span><span><span></span></span><span><span style="color:#708090">//                        String formattedDate = ThreadLocalDateUtil.formatDate(date);</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"線程 "</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span></span></span><span><span style="color:#dd4a68">Thread</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">currentThread</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">getName</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span></span></span><span><span style="color:#669900">" 時間為: "</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> formattedDate </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span></span></span><span><span style="color:#669900">" 偶數 i:"</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> finalI</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">else</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">Date</span></span><span><span> now </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Date</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>
                        now</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">setTime</span></span><span><span style="color:#999999">(</span></span><span><span>now</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">getTime</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-</span></span><span><span></span></span><span><span style="color:#dd4a68">TimeUnit</span></span><span><span style="color:#999999">.</span></span><span><span>MILLISECONDS</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">convert</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">TimeUnit</span></span><span><span style="color:#999999">.</span></span><span><span>DAYS</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> formattedDate </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> dateFormat</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">format</span></span><span><span style="color:#999999">(</span></span><span><span>now</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">//第一種</span></span><span><span></span></span><span><span style="color:#708090">//                        String formattedDate = DateUtil.formatDate(now);</span></span><span><span></span></span><span><span style="color:#708090">//第二種</span></span><span><span></span></span><span><span style="color:#708090">//                        String formattedDate = DateSyncUtil.formatDate(now);</span></span><span><span></span></span><span><span style="color:#708090">//第三種</span></span><span><span></span></span><span><span style="color:#708090">//                        String formattedDate = ThreadLocalDateUtil.formatDate(now);</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"線程 "</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span></span></span><span><span style="color:#dd4a68">Thread</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">currentThread</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">getName</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span></span></span><span><span style="color:#669900">" 時間為: "</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> formattedDate </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span></span></span><span><span style="color:#669900">" 奇數 i:"</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> finalI</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">catch</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Exception</span></span><span><span> e</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>err</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"線程 "</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span></span></span><span><span style="color:#dd4a68">Thread</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">currentThread</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">getName</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span></span></span><span><span style="color:#669900">" 出現了異常: "</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> e</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">getMessage</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span>

        executor</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">shutdown</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">try</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
            executor</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">awaitTermination</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">30</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">TimeUnit</span></span><span><span style="color:#999999">.</span></span><span><span>SECONDS</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">catch</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">InterruptedException</span></span><span><span> e</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
            e</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">printStackTrace</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#708090">// 計算總耗時</span></span><span><span></span></span><span><span style="color:#dd4a68">LocalDateTime</span></span><span><span> endDateTime </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">LocalDateTime</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">now</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#dd4a68">Duration</span></span><span><span> duration </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">Duration</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">between</span></span><span><span style="color:#999999">(</span></span><span><span>startDateTime</span></span><span><span style="color:#999999">,</span></span><span><span> endDateTime</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"所有任務執行完畢，總耗時: "</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> duration</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">toMillis</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span></span></span><span><span style="color:#669900">" 毫秒"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>具體 demo 代碼如上所示，執行結果如下，</span></span></span><span><span><strong><span>理論上來説</span></strong></span></span><span><span><span>應該是</span></span></span><span><span><strong><span>2024 年 1 月 23 日</span></strong></span></span><span><span><span>和</span></span></span><span><span><strong><span>2024 年 1 月 22 日</span></strong></span></span><span><span><span>打印日誌的次數各</span></span></span><span><span><strong><span>5</span></strong></span></span><span><span><span>次。實際結果發現在</span></span></span><span><span><strong><span>偶數的場景下</span></strong></span></span><span><span><span>仍然會出現打印格式化</span></span></span><span><span><strong><span>2024 年 1 月 22 日</span></strong></span></span><span><span><span>的場景。</span></span></span><span><span><strong><span>明顯</span></strong></span></span><span><span><span>出現了數據錯亂賦值的問題，所以到這裏大概可以</span></span></span><span><span><strong><span>基本確定</span></strong></span></span><span><span><span>就是 SimpleDateFormat 類</span></span></span><span><span><strong><span>在併發場景下線程不安全導致的</span></strong></span></span><span><span><span>。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-01-23-20-45kR19RdH8Q7I17dZ1.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h4_8"></span><h4><span><span><span>3.2 SimpleDateFormat 為什麼線程不安全？</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>查詢相關資料發現，從 SimpleDateFormat 類提供的接口來看，實在讓人看不出它與線程安全有什麼關係，進入 SimpleDateFormat 源碼發現類上面確實存在註釋提醒：意思就是， SimpleDateFormat 中的日期格式不是同步的。推薦（建議）為每個線程創建獨立的格式實例。如果多個線程同時訪問一個格式，則它必須保持外部同步。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-01-23-20-458aUeKXZwkvHOeut.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>繼續分析源碼發現，SimpleDateFormat 線程不安全的真正原因是繼承了</span></span></span><span><span><strong><span>DateFormat,</span></strong></span></span><span><span><span>在</span></span></span><span><span><strong><span>DateFormat</span></strong></span></span><span><span><span>中定義了一個</span></span></span><span><span><strong><span>protected</span></strong></span></span><span><span><span>屬性的 </span></span></span><span><span><strong><span>Calendar</span></strong></span></span><span><span><span>類的對象：calendar。由於 Calendar 類的概念複雜，牽扯到</span></span></span><span><span><strong><span>時區與本地化</span></strong></span></span><span><span><span>等等，jdk 的實現中使用了成員變量來傳遞參數，這就造成在多線程的時候會出現錯誤。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-01-23-20-467HfyoDMo1leYIUL.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>注意到在 format 方法中有一段如下代碼：</span></span></span></p><pre><code><span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">StringBuffer</span></span><span><span></span></span><span><span style="color:#dd4a68">format</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Date</span></span><span><span> date</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">StringBuffer</span></span><span><span> toAppendTo</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">FieldPosition</span></span><span><span> pos</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
        pos</span></span><span><span style="color:#999999">.</span></span><span><span>beginIndex </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> pos</span></span><span><span style="color:#999999">.</span></span><span><span>endIndex </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">0</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#dd4a68">format</span></span><span><span style="color:#999999">(</span></span><span><span>date</span></span><span><span style="color:#999999">,</span></span><span><span> toAppendTo</span></span><span><span style="color:#999999">,</span></span><span><span> pos</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">getFieldDelegate</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#708090">// Called from Format after creating a FieldDelegate</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#dd4a68">StringBuffer</span></span><span><span></span></span><span><span style="color:#dd4a68">format</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Date</span></span><span><span> date</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">StringBuffer</span></span><span><span> toAppendTo</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">FieldDelegate</span></span><span><span> delegate</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// Convert input date to time field list</span></span><span><span>
        calendar</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">setTime</span></span><span><span style="color:#999999">(</span></span><span><span>date</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">boolean</span></span><span><span> useDateFormatSymbols </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">useDateFormatSymbols</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">for</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">int</span></span><span><span> i </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">0</span></span><span><span style="color:#999999">;</span></span><span><span> i </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&lt;</span></span><span><span> compiledPattern</span></span><span><span style="color:#999999">.</span></span><span><span>length</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> tag </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> compiledPattern</span></span><span><span style="color:#999999">[</span></span><span><span>i</span></span><span><span style="color:#999999">]</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&gt;&gt;&gt;</span></span><span><span></span></span><span><span style="color:#990055">8</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> count </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> compiledPattern</span></span><span><span style="color:#999999">[</span></span><span><span>i</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">++</span></span><span><span style="color:#999999">]</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&amp;</span></span><span><span></span></span><span><span style="color:#990055">0xff</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>count </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">==</span></span><span><span></span></span><span><span style="color:#990055">255</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
                count </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> compiledPattern</span></span><span><span style="color:#999999">[</span></span><span><span>i</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">++</span></span><span><span style="color:#999999">]</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&lt;&lt;</span></span><span><span></span></span><span><span style="color:#990055">16</span></span><span><span style="color:#999999">;</span></span><span><span>
                count </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">|=</span></span><span><span> compiledPattern</span></span><span><span style="color:#999999">[</span></span><span><span>i</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">++</span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">switch</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>tag</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">case</span></span><span><span> TAG_QUOTE_ASCII_CHAR</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span>
                toAppendTo</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">append</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">char</span></span><span><span style="color:#999999">)</span></span><span><span>count</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">break</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">case</span></span><span><span> TAG_QUOTE_CHARS</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span>
                toAppendTo</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">append</span></span><span><span style="color:#999999">(</span></span><span><span>compiledPattern</span></span><span><span style="color:#999999">,</span></span><span><span> i</span></span><span><span style="color:#999999">,</span></span><span><span> count</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>
                i </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+=</span></span><span><span> count</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">break</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">default</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">:</span></span><span><span></span></span><span><span style="color:#dd4a68">subFormat</span></span><span><span style="color:#999999">(</span></span><span><span>tag</span></span><span><span style="color:#999999">,</span></span><span><span> count</span></span><span><span style="color:#999999">,</span></span><span><span> delegate</span></span><span><span style="color:#999999">,</span></span><span><span> toAppendTo</span></span><span><span style="color:#999999">,</span></span><span><span> useDateFormatSymbols</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">break</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> toAppendTo</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><strong><span>calendar.setTime(date)</span></strong></span></span><span><span><span>這條語句改變了 calendar，稍後，calendar 還會用到（在 subFormat 方法裏），而這就是引發問題的根源。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>想象一下，在一個多線程環境下，有兩個線程持有了同一個 SimpleDateFormat 的實例，分別調用 format 方法： 線程 1 調用 format 方法，改變了 calendar 這個字段。 中斷來了。 線程 2 開始執行，它也改變了 calendar。 又中斷了。 線程 1 回來了，此時，calendar 已然不是它所設的值，而是走上了線程 2 設計的道路。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>如果多個線程同時爭搶 calendar 對象，則會出現各種問題，</span></span></span><span><span><strong><span>時間不對</span></strong></span></span><span><span><span>，</span></span></span><span><span><strong><span>線程掛死</span></strong></span></span><span><span><span>等等。 分析一下 format 的實現，我們不難發現，用到成員變量 calendar，唯一的好處，就是在調用 subFormat 時，少了一個參數，卻帶來了這許多的問題。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>其實，只要在這裏用一個局部變量，一路傳遞下去，所有問題都將迎刃而解。 這個問題背後隱藏着一個更為重要的問題–</span></span></span><span><span><strong><span>無狀態</span></strong></span></span><span><span><span>：無狀態方法的好處之一，就是它在各種環境下，都可以安全的調用。衡量一個方法是否是有狀態的，就看它是否改動了其它的東西，比如全局變量，比如實例的字段。format 方法在運行過程中改動了 SimpleDateFormat 的 calendar 字段，所以，它是有狀態的。</span></span></span></p><span id="OSC_h3_9"></span><h3><span><span><span>4. 如何解決？</span></span></span></h3><span id="OSC_h4_10"></span><h4><span><span><span>4.1 每次在需要時新創建實例</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>在需要進行格式化日期的地方新建一個實例，不管什麼時候，將有線程安全問題的對象由共享變為局部私有都能避免多線程問題，不過也加重了創建對象的負擔。在一般情況下，這樣其實對性能影響比不是很明顯的。代碼示例如下。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.text.</span></span><span><span style="color:#dd4a68">ParseException</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.text.</span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.util.</span></span><span><span style="color:#dd4a68">Date</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">/**
 * @author 
 * @date 2024/1/23 20:04
 */</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">DateUtil</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span></span></span><span><span style="color:#dd4a68">formatDate</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Date</span></span><span><span> date</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">throws</span></span><span><span></span></span><span><span style="color:#dd4a68">ParseException</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span> sdf </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"yyyy-MM-dd HH:mm:ss"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> sdf</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">format</span></span><span><span style="color:#999999">(</span></span><span><span>date</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">Date</span></span><span><span></span></span><span><span style="color:#dd4a68">parse</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> strDate</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">throws</span></span><span><span></span></span><span><span style="color:#dd4a68">ParseException</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span> sdf </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"yyyy-MM-dd HH:mm:ss"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> sdf</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">parse</span></span><span><span style="color:#999999">(</span></span><span><span>strDate</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span>​</span></span></span></code></pre><span id="OSC_h4_11"></span><h4><span><span><span>4.2 同步 SimpleDateFormat 對象</span></span></span></h4><pre><code><span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.text.</span></span><span><span style="color:#dd4a68">ParseException</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.text.</span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.util.</span></span><span><span style="color:#dd4a68">Date</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">/**
 * @author 
 * @date 2024/1/23 20:04
 */</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">DateSyncUtil</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span> sdf </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"yyyy-MM-dd HH:mm:ss"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span></span></span><span><span style="color:#dd4a68">formatDate</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Date</span></span><span><span> date</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">throws</span></span><span><span></span></span><span><span style="color:#dd4a68">ParseException</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">synchronized</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>sdf</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> sdf</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">format</span></span><span><span style="color:#999999">(</span></span><span><span>date</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">Date</span></span><span><span></span></span><span><span style="color:#dd4a68">parse</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> strDate</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">throws</span></span><span><span></span></span><span><span style="color:#dd4a68">ParseException</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">synchronized</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>sdf</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> sdf</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">parse</span></span><span><span style="color:#999999">(</span></span><span><span>strDate</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h4_12"></span><h4><span><span><strong><span>説明：</span></strong></span></span><span><span><span>當線程較多時，當一個線程調用該方法時，其他想要調用此方法的線程就要 block，多線程併發量大的時候會對性能有一定的影響。</span></span></span></h4><span id="OSC_h4_13"></span><h4><span><span><span>4.3 ThreadLocal</span></span></span></h4><pre><code><span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.text.</span></span><span><span style="color:#dd4a68">DateFormat</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.text.</span></span><span><span style="color:#dd4a68">ParseException</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.text.</span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.util.</span></span><span><span style="color:#dd4a68">Date</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">ConcurrentDateUtil</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">ThreadLocal</span></span><span><span>&lt;DateFormat&gt;</span></span><span><span> threadLocal </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">ThreadLocal</span></span><span><span>&lt;DateFormat&gt;</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span>@Override</span></span><span><span></span></span><span><span style="color:#0077aa">protected</span></span><span><span></span></span><span><span style="color:#dd4a68">DateFormat</span></span><span><span></span></span><span><span style="color:#dd4a68">initialValue</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"yyyy-MM-dd HH:mm:ss"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">Date</span></span><span><span></span></span><span><span style="color:#dd4a68">parse</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> dateStr</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">throws</span></span><span><span></span></span><span><span style="color:#dd4a68">ParseException</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> threadLocal</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">get</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">parse</span></span><span><span style="color:#999999">(</span></span><span><span>dateStr</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span></span></span><span><span style="color:#dd4a68">format</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Date</span></span><span><span> date</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> threadLocal</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">get</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">format</span></span><span><span style="color:#999999">(</span></span><span><span>date</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><span>另一種寫法</span></span></span></p><pre><code><span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.text.</span></span><span><span style="color:#dd4a68">DateFormat</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.text.</span></span><span><span style="color:#dd4a68">ParseException</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.text.</span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>java.util.</span></span><span><span style="color:#dd4a68">Date</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">/**
 * @author 
 * @date 2024/1/23 15:44
 * @description 線程安全的日期處理類
 */</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">ThreadLocalDateUtil</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">/**
     * 日期格式
     */</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> date_format </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">"yyyy-MM-dd HH:mm:ss"</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">/**
     * 線程安全處理
     */</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">ThreadLocal</span></span><span><span>&lt;DateFormat&gt;</span></span><span><span> threadLocal </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">ThreadLocal</span></span><span><span>&lt;&gt;</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">/**
     * 線程安全處理
     */</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">DateFormat</span></span><span><span></span></span><span><span style="color:#dd4a68">getDateFormat</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">DateFormat</span></span><span><span> df </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> threadLocal</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">get</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>df </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">==</span></span><span><span></span></span><span><span style="color:#0077aa">null</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
            df </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">SimpleDateFormat</span></span><span><span style="color:#999999">(</span></span><span><span>date_format</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>
            threadLocal</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">set</span></span><span><span style="color:#999999">(</span></span><span><span>df</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> df</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#708090">/**
     * 線程安全處理日期格式化
     */</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span></span></span><span><span style="color:#dd4a68">formatDate</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Date</span></span><span><span> date</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#dd4a68">getDateFormat</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">format</span></span><span><span style="color:#999999">(</span></span><span><span>date</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#708090">/**
     * 線程安全處理日期解析
     */</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">Date</span></span><span><span></span></span><span><span style="color:#dd4a68">parse</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> strDate</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">throws</span></span><span><span></span></span><span><span style="color:#dd4a68">ParseException</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#dd4a68">getDateFormat</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">parse</span></span><span><span style="color:#999999">(</span></span><span><span>strDate</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:left"><span><span><strong><span>説明：</span></strong></span></span><span><span><span>使用 ThreadLocal, 也是將共享變量變為獨享，線程獨享肯定能比方法獨享在併發環境中能減少不少創建對象的開銷。如果對性能要求比較高的情況下，一般推薦使用這種方法</span></span></span></p><span id="OSC_h4_14"></span><h4><span><span><span>4.4 拋棄 JDK，使用其他類庫中的時間格式化類</span></span></span></h4><div><span>•</span><span><span><span><span>使用</span></span></span><span><span><strong><span>Apache commons</span></strong></span></span><span><span><span> 裏的</span></span></span><span><span><strong><span>FastDateFormat</span></strong></span></span><span><span><span>，宣稱是既快又線程安全的 SimpleDateFormat, 可惜它</span></span></span><span><span><strong><span>只能</span></strong></span></span><span><span><span>對日期進行 format, </span></span></span><span><span><strong><span>不能</span></strong></span></span><span><span><span>對日期串進行解析。</span></span></span></span></div><div><span>•</span><span><span><span><span>使用</span></span></span><span><span><strong><span>Joda-Time</span></strong></span></span><span><span><span>類庫來處理時間相關問題。</span></span></span></span></div><span id="OSC_h3_15"></span><h3><span><span><span>5. 性能比較</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>通過追加時間監控，將原有數據範圍擴充到</span></span></span><span><span><strong><span>[0,999]</span></strong></span></span><span><span><span>，線程池保留</span></span></span><span><span><strong><span>10</span></strong></span></span><span><span><span>個線程不變，觀察三種情況下性能情況。</span></span></span></p><div><span>•</span><span><span><span><span>第一種：耗時 40ms</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-01-23-20-50ClKey6zU1zuFpod.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><div><span>•</span><span><span><span><span>第二種：耗時 33ms</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-01-23-20-50smFz50TPZ7DlxqV42.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><div><span>•</span><span><span><span><span>第三種：耗時 30ms</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>﻿</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2024-01-23-20-50fvjvOXvwRBDEKsW.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>通過性能壓測發現</span></span></span><span><span><strong><span>4.3</span></strong></span></span><span><span><span>中的 ThreadLocal 性能最優，耗時 30ms，</span></span></span><span><span><strong><span>4.1</span></strong></span></span><span><span><span>每次新創建實例性能最差，需要耗時 40ms，當然了在極致的高併發場景下提升效果應該會更加明顯。性能問題不是本文探討的重點，在此不多做贅述。</span></span></span></p><span id="OSC_h3_16"></span><h3><span><span><span>6. 總結</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>以上就是針對本次問題排查的</span></span></span><span><span><strong><span>主要思路及流程</span></strong></span></span><span><span><span>，剛開始的排查思路也一直</span></span></span><span><span><strong><span>侷限於</span></strong></span></span><span><span><span>規則引擎的線程不安全或者是傳入的 env（由於使用的是 HashMap）線程不安全，還是受到</span></span></span><span><span><strong><span>組內大佬</span></strong></span></span><span><span><span>的啓發和幫助才進一步去分析</span></span></span><span><span><strong><span>SimpleDateFormat</span></strong></span></span><span><span><span>類可能會存在線程不安全。本次問題排查確實提供一個</span></span></span><span><span><strong><span>經驗</span></strong></span></span><span><span><span>，</span></span></span><span><span><strong><span>打破常規思路</span></strong></span></span><span><span><span>，比如</span></span></span><span><span><strong><span>SimpleDateFormat</span></strong></span></span><span><span><span>類看起來</span></span></span><span><span><strong><span>只是</span></strong></span></span><span><span><span>對日期進行格式化，</span></span></span><span><span><strong><span>很難</span></strong></span></span><span><span><span>和在併發場景下線程不安全會導致數據錯亂</span></span></span><span><span><strong><span>關聯起來</span></strong></span></span><span><span><span>。</span></span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">作者：京東科技，宋慧超</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">來源：京東雲開發者社區，轉載請註明來源</p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 18 Feb 2024 02:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/11043880</guid>
            <link>https://my.oschina.net/u/4090830/blog/11043880</link>
            <author>
                <![CDATA[京東雲開發者]]>
            </author>
        </item>
    </channel>
</rss>
