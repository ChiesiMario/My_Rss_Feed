<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 14 Nov 2023 09:58:07 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[2023 年收入最高的 10 种编程语言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在过去的一年时间里（2022 年 10 月 1 日到 2023 年 10 月 1 日） ，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Fblog%2Ftop-10-highest-paid-programming-languages%2F" target="_blank">DevJobsScanner</a> 分析了来自世界各地的超过 1000 万份开发工作机会，以了解市场以及最热门、薪酬最高的编程语言。值得注意的是，本项研究只关注了来自美国的职位。在总共 1000 万个开发工作岗位中，有 130 万个有工资。在这 130 万个职位中，有 23 万个职位属于编程语言类。在这 23 万个职位中，约有 8.6 万个职位来自美国。</p><h4><strong>10 - Java</strong></h4><p><img height="144" src="https://oscimg.oschina.net/oscnet/up-da0d9c70bef29cef379fa443218b09df6dd.png" width="300" referrerpolicy="no-referrer"></p><p>Java 位列第十。DevJobsScanner 指出，Java 的工作机会大多要求份非常丰富的经验，Spring 等 Java 框架也是该行业的高薪职位。Java 开发人员的平均年薪约为 11.8 万美元。</p><ul style="margin-left:0; margin-right:0"><li>平均工资：~$118k</li><li>薪资中位数：$117k</li><li>发现的工作数量（带薪水）：23K 个</li></ul><p>查看具体的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-java-jobs%2F" target="_blank">&nbsp;Java 职位</a>。</p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><strong><span style="color:#000000">9-Python</span></strong></h4><p><img height="91" src="https://oscimg.oschina.net/oscnet/up-9bb3fb64562542db24cf36832f6b43d5966.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Python 是当今最流行的语言之一，也是排名第九的高薪职位。Python 是一种 non-typed 的高级语言。它拥有全方位的实用工具，从脚本和工具到使用 Django 框架编写整个 Web 应用程序。该语言多被用于数据科学。</span></p><p><span style="color:#000000">调查结果显示，虽然 Python 开发人员的平均工资为每年 12.5 万美元，但有些薪资已经达到了每年 50 万美元。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工资：~$125K</span></li><li><span style="color:#000000">薪资中位数：$120k</span></li><li><span style="color:#000000">发现的工作数量（带薪水）：14K 个</span></li></ul><p>&nbsp;查看具体的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-java-jobs%2F" target="_blank">&nbsp;</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-python-jobs%2F" target="_blank">Python 职位</a>。</p><h4><strong>8 - Swift</strong></h4><p><img height="123" src="https://oscimg.oschina.net/oscnet/up-3a30ea9fb6d3c66be2a2ad231125f7a79ba.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Swift 是，苹果公司开发的一种现代通用语言。它有多种用途，但最常见、流行的用途是开发 iOS 和 Mac 应用程序。Swift 开发人员的平均年薪为 12.7 万美元。</span></p><ul style="margin-left:0; margin-right:0"><li>平均工资：~$127k</li><li>薪资中位数：$125k</li><li><span style="color:#000000">发现的工作数量（带薪水）</span>：174 个</li></ul><p>查看具体的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-swift-jobs%2F" target="_blank">Swift 职位</a>。</p><h4><strong>7 - Go</strong></h4><p><img height="120" src="https://oscimg.oschina.net/oscnet/up-963f146d826e179eefe3c93c441a54055da.png" width="300" referrerpolicy="no-referrer"></p><p>Go 语言由&nbsp;Google 团队成员于 2007 年推出，一直广受欢迎。它简单、易用，能快速完成任务。Go 深受 C 语言的影响，但在内存安全、垃圾收集和结构类型方面也有重大改进。</p><ul style="margin-left:0; margin-right:0"><li>平均工资：~$130k</li><li>薪资中位数：$128k</li><li><span style="color:#000000">发现的工作数量（带薪水）</span>：1.2K 个</li></ul><p>查看具体的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-go-jobs%2F" target="_blank">Go 职位</a>。</p><h4><strong>6 - Ruby</strong></h4><p><img height="128" src="https://oscimg.oschina.net/oscnet/up-21b412b86bcb795c62b42a25bdd199348fd.png" width="300" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">Ruby 语言已经流行多年并且现在仍然很流行。调查显示，Ruby 需求相当高，而且大部分都是高薪。</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">Ruby 主要流行于 Web 开发，与著名的 Ruby on Rails 框架结合使用。它也有一些其他的实用工具，从脚本和原型设计到游戏开发（使用 DragonRuby）。DevJobsScanner 认为，鉴于&nbsp;Ruby 的多样性，学习该语言永远不会是一个糟糕的选择；它也是一种高级语言，可以快速开发应用程序（类似于 Python）。</span></p><blockquote><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">Ruby 开发人员的工资中位数（13.6 万美元）超过了平均工资（13.2 万美元）。这表明对中级和高级 Ruby 专业人员的强劲需求，说明掌握 Ruby 方面的专业知识往往能带来高于平均水平的薪酬。</span></p></blockquote><ul style="margin-left:0; margin-right:0"><li>平均工资：~$132k</li><li>薪资中位数：$136k</li><li>找到的工作数量（带薪水）：3.4K 个</li></ul><p>&nbsp;查看具体的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-ruby-jobs%2F" target="_blank">Ruby 职位</a>。</p><h4><strong>5 - Scala</strong></h4><p><img height="146" src="https://oscimg.oschina.net/oscnet/up-551dddb9d865060c07593f99b8a5b10d1e9.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">排在前五位的是 Scala。Scala 是一种结合了面向对象和函数式编程的高级语言。它可以编译成 Java 字节码，并在 Java 虚拟机（JVM）上运行。它的设计初衷是为了解决 Java 所面临的一些"缺陷"和批评。它拥有一个强大的爱好者社区，以及良好的周边库，可以轻松上手。</span></p><p><span style="color:#000000">虽然 Scala 开发人员的平均年薪为 13.5 万美元，但有些职位的年薪最高可达约 40 万美元。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工资：~$135k</span></li><li><span style="color:#000000">薪资中位数：$130k</span></li><li><span style="color:#000000">找到的工作数量（带薪水）： 533 个</span></li></ul><p>查看具体的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-scala-jobs%2F" target="_blank">Scala 职位</a>。</p><h4><strong>4 - C/C++</strong></h4><p><img height="179" src="https://oscimg.oschina.net/oscnet/up-6e86e1cf5b0d7679b684b0158bb78cd21ed.png" width="200" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">C/C++ 稳居前 4 位，平均年薪约为 13.6 万美元。 C++ 在行业中的应用非常广泛，视频游戏、服务器、数据库、空间探测器等许多领域都可以找到 C++ 的身影。区块链生态系统中也大量使用 C++，比特币或 Solidity 智能合约语言均完全由 C++ 编写。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工资：~$136K</span></li><li><span style="color:#000000">薪资中位数：$125k</span></li><li><span style="color:#000000">找到的工作数量（带薪水）：3K 个</span></li></ul><p><span style="color:#000000">&nbsp;查看具体的</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-c%2B%2B-jobs%2F" target="_blank">&nbsp;C/C++ 职位</a>。</p><h4><strong>3-ABAP</strong></h4><p><img height="124" src="https://oscimg.oschina.net/oscnet/up-c183b86954e313b623cd8417d793c87f6ba.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">ABAP 是 2023 年企业资源规划 (ERP) 生态系统中最有价值的语言之一。ABAP 是 SAP 创建的一种高级编程语言，用于在 SAP 平台上开发应用程序。自 20 世纪 80 年代以来，它一直是 SAP 应用程序的支柱，允许自定义开发和修改 SAP 应用程序。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工资：~$137k</span></li><li><span style="color:#000000">薪资中位数：$134k</span></li><li><span style="color:#000000">找到的工作数量（带薪水）：134 个</span></li></ul><p>查看具体的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-abap-jobs%2F" target="_blank">ABAP 职位</a>。</p><h4><strong>2 - Rust</strong></h4><p><img height="141" src="https://oscimg.oschina.net/oscnet/up-d07474ac36e203ae14401437617eca9135b.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Rust 平均薪资约为 15.6 万美元，且该语言的薪资和受欢迎程度都在持续上升。Rust&nbsp;与 C++ 类似，但具有内存安全或安全并发等更高级的功能，使其成为高性能大型应用程序的完美选择。该语言最近在 web3/区块链领域颇受欢迎，例如 Solana 合约不是用 Solidity 制作的，而是采用的 Rust。</span></p><p><span style="color:#000000">虽然 Rust 开发人员的平均年薪为 15.6 万美元，但有些职位的年薪达到了 50 万美元。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工资：~$156k</span></li><li><span style="color:#000000">薪资中位数：$150k</span></li><li><span style="color:#000000">找到的工作数量（带薪水）：197 个</span></li></ul><p><span style="color:#000000">查看具体的&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-rust-jobs%2F" target="_blank">Rust 职位</a>。</p><h4><span style="color:#000000"><strong>1 - Solidity</strong></span></h4><p><img height="109" src="https://oscimg.oschina.net/oscnet/up-49425fe9eab67498220eef604ab1e04f8fe.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">位居 2023 年薪资排行榜首的是 Solidity，平均薪资为 18.8 万美元。这门以太坊背后的前团队发明的语言最近受到了广泛关注。相关职位的求职者人数少，从而使得薪酬直线上升。Solidity 是一种高级面向对象编程语言。它用于编写当今大多数区块链中运行的智能合约背后的逻辑。</span></p><p>&nbsp;</p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工资：~$188k</span></li><li><span style="color:#000000">薪资中位数：1$180k</span></li><li><span style="color:#000000">找到的工作数量（带薪水）：136 个</span></li></ul><p><span style="color:#000000">查看具体的&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-solidity-jobs%2F" target="_blank">Solidity 职位</a><span style="color:#000000">。</span></p><hr><p><strong>完整列表</strong></p><p><img height="657" src="https://oscimg.oschina.net/oscnet/up-9139be9626b0c984bca34d0c24578038302.png" width="500" referrerpolicy="no-referrer"></p><p><strong>薪资分布图</strong></p><p><img height="820" src="https://oscimg.oschina.net/oscnet/up-844c88902e330224b38a8a0448482adf31d.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Fblog%2Ftop-10-highest-paid-programming-languages%2F" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 08:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266426/top-10-highest-paid-programming-languages</guid>
            <link>https://www.oschina.net/news/266426/top-10-highest-paid-programming-languages</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[国内最大、性能媲美 GPT 3.5，元象开源 650 亿参数高性能大模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#1f2328; text-align:start"><strong>XVERSE-65B</strong><span>&nbsp;</span>是由深圳元象科技自主研发的支持多语言的大语言模型（Large Language Model），参数规模为 650 亿，本次开源的模型为底座模型<span>&nbsp;</span><strong>XVERSE-65B</strong>，主要特点如下：</p><ul><li><strong>模型结构</strong>：XVERSE-65B 使用主流 Decoder-only 的标准 Transformer 网络结构，支持 16K 的上下文长度（Context Length），能满足更长的多轮对话、知识问答与摘要等需求，模型应用场景更广泛。</li><li><strong>训练数据</strong>：构建了 2.6 万亿 token 的高质量、多样化的数据对模型进行充分训练，包含中、英、俄、西等 40 多种语言，通过精细化设置不同类型数据的采样比例，使得中英两种语言表现优异，也能兼顾其他语言效果。</li><li><strong>分词</strong>：基于 BPE（Byte-Pair Encoding）算法，使用上百 GB 语料训练了一个词表大小为 100,534 的分词器，能够同时支持多语言，而无需额外扩展词表。</li><li><strong>训练框架</strong>：训练中采用 FlashAttention2 加速计算，3D 并行基础上采用虚拟流水线（virtual pipeline）技术，降低较长流水线和 16k 上下文窗口产生的过高气泡率，在千卡集群的峰值算力利用率达到业界前列。同时通过集群基础设施运营、资源调度、训练框架和调度平台协同等持续优化，打造出高稳定、低中断、强容错的训练系统，将每周有效训练率提升至 98.6%。</li></ul><h4 style="margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000"><strong>评测结果</strong></span></h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000"><img height="454" src="https://oscimg.oschina.net/oscnet/up-2cd1eb2bb0579c1ae7d9b7cdba455e38df6.png" width="500" referrerpolicy="no-referrer">&nbsp;</span></p><h4 style="text-align:start"><strong>硬件需求</strong></h4><p style="color:#1f2328; text-align:start">下表列出了在 XVERSE-65B 上进行推理和微调所需要的硬件资源：</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#1f2328; display:block; font-family:-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Noto Sans&quot;,Helvetica,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; max-width:100%; orphans:2; overflow:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:max-content; word-spacing:0px"><thead><tr><th>&nbsp;</th><th>类型</th><th>方法</th><th>内存</th><th>GPU</th></tr></thead><tbody><tr><td style="border-style:solid; border-width:1px">XVERSE-65B</td><td style="border-style:solid; border-width:1px">训练</td><td style="border-style:solid; border-width:1px">LoRA with ZeRO-3</td><td style="border-style:solid; border-width:1px">1500GB</td><td style="border-style:solid; border-width:1px">8*A800 80G</td></tr><tr><td style="border-style:solid; border-width:1px">XVERSE-65B</td><td style="border-style:solid; border-width:1px">推理</td><td style="border-style:solid; border-width:1px">BF16/FP16</td><td style="border-style:solid; border-width:1px">500GB</td><td style="border-style:solid; border-width:1px">2*A800 80G</td></tr></tbody></table></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 08:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/xverse-65b</guid>
            <link>https://www.oschina.net/p/xverse-65b</link>
        </item>
        <item>
            <title>
                <![CDATA[开源模型 Zephyr-7B🪁发布 —— 跨越三大洲的合作]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p><span style="background-color:#ffffff; color:#333333">最近我们刚刚发布了新的开源模型 Zephry-7B🪁，</span><span style="background-color:#ffffff; color:#333333">这个模型的诞生离不开全球三大洲开源社区的协作 ❤️。</span></p><p><span style="background-color:#ffffff; color:#333333">我们的 CSO Thomas 录了一个视频介绍了它的起源故事。</span></p><p><img height="377" src="https://oscimg.oschina.net/oscnet/up-da1e6db4fb09e0c752bd317fe94e1e1d4a3.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#333333">✨ 就在几个月前，巴黎的一个新团队发布了他们首个模型: Mistral 7B，这个模型体积小巧但性能强劲，在基准测试中的表现超过了所有同类模型。而且这是个开源模型，这意味着大家都可以在此基础上进行开发。</span></p><p><span style="background-color:#ffffff; color:#333333">✨ 开发者 Lewis 在瑞士伯尔尼，Ed 在法国南部里昂，他们俩都是 Hugging Face H4 团队的一员。在 Hugging Face 举办的一次小聚中，他们边喝咖啡边讨论用斯坦福大学新发表的 DPO 方法对模型进行微调的可能性。于是大家决定用他们已经构建好的代码库来尝试一下💪</span></p><p><br><span style="background-color:#ffffff; color:#333333">✨接下来的一天，他们在 HF hub 上找到了一些公开的数据集，主要是由清华的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzk0NzM3OTc2Nw%3D%3D%26mid%3D2247487177%26idx%3D1%26sn%3Dcfbeb254d91501fdeadda5103f1d2279%26scene%3D21%23wechat_redirect" target="_blank">OpenBMB</a> 团队新近开源的两个大型、高质量的微调数据集: UltraFeedback 和 UltraChat 📊</span></p><p><br><span style="background-color:#ffffff; color:#333333">✨ 经过几轮训练实验，他们的想法得到了证实: 这个新模型非常强大，在伯克利和斯坦福的基准测试中是他们见过的最强模型。Clémentine 是 Hugging Face Open LLM Leaderboard 的领头人，她对模型的深入分析确认了其卓越性能。于是 H4 团队中另一位成员 Sasha Rush 教授迅速起草了一篇研究报告，将所有细节分享给整个社区 📰</span></p><p><br><span style="background-color:#ffffff; color:#333333">✨ 几天后，这个名为 Zephyr 的模型、研究论文以及所有细节都向世界公开了。不久之后，全球各地的公司开始应用这一模型。LlamaIndex，一个知名的数据框架和社区，分享了这个模型在实际用例基准测试中超乎预期的表现。与此同时，研究者和实践者们在 Hugging Face hub 上讨论着这篇论文和相关工作。</span></p><p>&nbsp;</p><p><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff; color:#333333">✨</span><span style="background-color:#ffffff; color:#333333"></span>很难相信，这一切的实现仅仅用了几周时间 🤯！这一切都得益于世界各地 (欧洲、加利福尼亚、中国) 对知识、模型、研究和数据集的开放，以及开源社区之间的相互协作 🤝</span></p><p><br><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff; color:#333333">✨</span><span style="background-color:#ffffff; color:#333333"></span>这样的故事在开源社区比比皆是，也正是这些人和事让开源社区始终保持不断创新的原动力 🔥</span></p><p><br><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff; color:#333333">✨ </span>齐心协力，我们可以一起创造出惊人的成果 ❤️</span></p><p>&nbsp;</p></div><p style="color:#858585">本文分享自微信公众号 - Hugging Face（gh_504339124f0f）。<br> 如有侵权，请联系 support@oschina.cn 删除。<br> 本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 06:32:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/HuggingFace/blog/10142118</guid>
            <link>https://my.oschina.net/HuggingFace/blog/10142118</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[🔥 周热点 | 阿里云严重故障；开源软件 OBS Studio 被卖 43 元；苹果回应 8GB 近似于其它系统的 16GB.....]]>
            </title>
            <description>
                <![CDATA[回顾一周热门资讯。2023.11.06-2023.11.12]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 03:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649093948&#38;idx=1&#38;sn=706606fa2f64f52b06fc8b4cee57747b&#38;chksm=880c4c2fbf7bc5397b5a8f8cf06c3879715d17a1760fae142652daea51d149d354fc1dcbc442&#38;token=293181062&#38;lang=zh_CN#rd</guid>
            <link>https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649093948&#38;idx=1&#38;sn=706606fa2f64f52b06fc8b4cee57747b&#38;chksm=880c4c2fbf7bc5397b5a8f8cf06c3879715d17a1760fae142652daea51d149d354fc1dcbc442&#38;token=293181062&#38;lang=zh_CN#rd</link>
        </item>
        <item>
            <title>
                <![CDATA[Google Play 收紧 Android 应用开发者规则]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">谷歌<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid-developers.googleblog.com%2F2023%2F11%2Fensuring-high-quality-apps-on-google-play.html" target="_blank">宣布</a>收紧在 Google Play 商店发布应用程序的 Android 开发者规则，引入了一些新的政策和计划，以提高整个平台的应用程序质量。</span></p><p><span style="color:#000000">公告指出，现在将要求拥有新创建的个人 Play Console 帐户的开发者在发布前，至少 2 周内与至少 20 人一起测试他们的应用程序。他们认为，此举将帮助开发人员提前发现问题获得用户反馈，预计该</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsupport.google.com%2Fgoogleplay%2Fandroid-developer%2Fanswer%2F14151465" target="_blank">要求</a><span style="color:#000000">将在「未来几天」出现在 Play 管理中心。</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">与此同时，</span>Google Play 的<span style="background-color:#ffffff">审核团队还将加强对应用程序的审核，预计整体应用程序审核时间表不会发生重大变化。</span></span><span style="color:#000000"><span style="background-color:#ffffff">但该公司</span>警告称，随着这些变化的推出，少数应用程序的审批时间可能会加长，<span style="background-color:#ffffff">例如为儿童设计的应用程序或请求某些设备权限的应用程序。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">「</span>我们的全球审核团队现在花更多时间评估新应用程序，以确保它们提供有价值的用户体验，不会通过应用程序或场外活动欺骗或欺诈用户，并遵守我们的政策。<span style="background-color:#ffffff">」</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">此前，谷歌方面曾宣布所有开发者在 Google Play 上发布应用程序前必须满足一系列扩展的验证要求，以打击恶意软件行为。时至今日，该公司还</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsupport.google.com%2Fgoogleplay%2Fandroid-developer%2Fanswer%2F14177239" target="_blank"><span style="color:#2980b9">分享</span></a><span style="color:#000000">了一些内容，指导帮助拥有现有帐户的开发者如何完成这些验证，以符合更新后的&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsupport.google.com%2Fgoogleplay%2Fandroid-developer%2Fanswer%2F10788890" target="_blank">Play 管理中心要求政策</a><span style="color:#000000">。</span></p><p><span style="color:#000000">开发者将可以自行选择完成账户验证的截止日期。截止日期以先到先得的方式提供，因此官方建议用户尽早进行选择，以确保能在合适的时间内完成验证。如果开发者没有在 2024 年 2 月 29 日之前选择截止日期，平台将自动为其指定一个截止日期。</span></p><p><span style="color:#000000"><img alt="" height="237" src="https://oscimg.oschina.net/oscnet/up-bdd9ea4f2ac3077b8a399d99314c569aae1.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">另一方面，公告表示，为了继续为用户提供优质内容，回报开发者在质量方面的投资，该公司<span style="background-color:#ffffff">已经开始：</span></span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">向用户提供有关应用程序是否在其设备（包括手机、大屏幕和可穿戴设备）上运行不佳的信息</span></li><li><span style="color:#000000">呈现更多高质量的本地和区域内容</span></li></ul><p><span style="color:#000000">并计划将从 2024 年开始添加一个标识官方应用程序的徽章标识，以帮助用户找到所需的应用程序。&nbsp;</span></p><p><span style="color:#000000">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid-developers.googleblog.com%2F2023%2F11%2Fensuring-high-quality-apps-on-google-play.html" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 03:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266381/google-play-tightens-up-rules-android-app-developers</guid>
            <link>https://www.oschina.net/news/266381/google-play-tightens-up-rules-android-app-developers</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[李开复旗下 AI 公司「零一万物」开源的 Yi 大模型照搬 Llama 架构]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>「</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.01.ai%2F">零一万物</a><span>」是创新工场董事长兼 CEO 李开复于今年创办的 AI 大模型创业公司。上周该公司<u><a href="https://www.oschina.net/news/265142/01-ai-valued-at-1b-open-source-yi-llm">宣布</a></u></span><strong>推出&nbsp;Yi-34B 和&nbsp;Yi-6B 两个开源大模型。</strong></p><p><img src="https://oscimg.oschina.net/oscnet/up-4ab5886e43554fd3233305e7c8264217507.png" referrerpolicy="no-referrer"></p><p>在公开的报道中，该公司称 Yi 系列大模型拥有全球大模型中最长的上下文窗口。其中 Yi-34B 在 Hugging Face 英文测试榜单中位列第一，在 C-Eval 中文能力排行榜中超越所有开源模型。</p><p>不过在&nbsp;Yi-34B 的 Hugging Face 主页上，有人指出<strong> Yi 完全使用了 Llama 的架构</strong>——前者只是对后者的两个张量 (Tensor) 名称进行了修改，具体为 input_layernorm 和 post_attention_layernorm。</p><blockquote><p>Llama 全称为 "Large Language Model Meta AI"，是 Meta 创建的大语言模型。今年 7 月，<u><a href="https://www.oschina.net/news/249944/meta-llama-2">Meta 发布了 Llama 2</a></u>，宣布完全开源，并可免费商用。</p><p><img src="https://static.oschina.net/uploads/space/2023/0719/103048_jW9B_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1114/111349_Novu_2720166.png" referrerpolicy="no-referrer"></p><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11" target="_blank">https://huggingface.co/01-ai/Yi-34B/discussions/11</a></u></em></p><p>AI 领域知名专家贾扬清昨晚也在个人朋友圈点评了此事——不过并没有指名道姓：</p><p><img src="https://static.oschina.net/uploads/space/2023/1114/111004_dOrQ_2720166.png" referrerpolicy="no-referrer"></p><blockquote><p>贾扬清是开源深度学习框架&nbsp;<span>Caffe 创始人、TensorFlow 作者之一、也是 PyTorch 1.0 的共同创始人。</span></p><p>今年 3 月，贾扬清从阿里离职后联合创立了一家新的 AI 公司 Lepton AI，旨在建立高效的 AI 应用平台。</p><p>Lepton AI 总部位于美国加利福尼亚州帕洛阿托，官网宣称可通过 Lepton AI 在几分钟内高效、大规模地运行 AI 应用。相比大模型，贾扬清团队更偏重 AI 能力的开发。</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 03:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266377</guid>
            <link>https://www.oschina.net/news/266377</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[指针「爆雷」导致公司损失上亿资金]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>1990 年 1 月 15 日，AT&amp;T 的新泽西运营中心检测到大范围的系统故障，网络显示屏上出现了大量红色警告。</p><p>尽管试图排除故障，但网络故障仍持续了 9 个小时，导致呼叫连接故障率达到 50%。</p><p><strong>AT&amp;T 因此损失了 6000 多万美元，6 万多名美国人的电话完全无法接通</strong>。</p><p>此外，500 个航班延误，8.5 万人受到影响。</p><p>按理说，AT&amp;T 的长途网络是高效率的典范，它利用先进的电子交换机和信号系统处理了全国大部分的电话。该系统通常能在几秒钟内完成电话路由选择。</p><p>然而，就在这一天，从纽约的一个交换机开始，整个网络出现了故障。这是由于最近一次更新中的一个软件错误造成的，该错误影响了网络中的 114 个交换机。当纽约的交换机复位并发出信号时，这个错误引发了多米诺骨牌效应，导致大范围的网络中断。</p><p><strong>有趣的是，这个软件并没有经过测试。由于代码改动较小，因此按照管理层的要求绕过了测试</strong>。</p><h3>问题所在</h3><p>追根溯源，原因在于网络交换机实施的软件更新中出现了编码错误。</p><p>该错误发生在一个 C 语言程序中，涉及嵌套条件语句中一个错位的中断语句，导致数据覆盖和系统重置。</p><p>伪代码</p><pre><code>1  while (ring receive buffer not empty 
          and side buffer not empty):

2    Initialize pointer to first message in side buffer
     or ring receive buffer

3    get copy of buffer

4    switch (message):

5       case (incoming_message):

6             if (sending switch is out of service):

7                 if (ring write buffer is empty):

8                     send "in service" to status map

9                 else:

10                    break // The error was here!

                  END IF

11           process incoming message, set up pointers to
             optional parameters

12           break
       END SWITCH


13   do optional parameter work</code></pre><h3>问题分析</h3><ul><li>如果环写入缓冲区不是空的，那么第 7 行的 `if` 语句就会被跳过，取而代之的是第 10 行的中断语句。</li><li>然而，为了使程序正常运行，本应执行第 11 行。</li><li>当中断语句被执行，而不是处理传入的信息并为可选参数设置指针时，数据（本应保留的指针）就会被覆盖</li><li>纠错软件识别出数据被覆盖，并启动关闭开关进行重置。由于网络中的所有交换机都使用了这种有缺陷的软件，导致了连锁重置反应，最终瘫痪了整个网络系统，使问题变得更加复杂。</li></ul><p>尽管进行了严格的测试，网络的设计也非常灵活，但一行代码还是导致了半个国家的主要通信线路瘫痪。</p><h3><strong>修复</strong></h3><p>工程师们花了 9 个小时才使 AT&amp;T 的系统完全恢复正常。他们主要是通过将交换机回滚到之前的代码工作版本来实现的。</p><p>实际上，软件工程师花了两周时间进行严格的代码阅读、测试和复制，才真正弄清了错误所在。</p><h3><strong>结论</strong></h3><p>对于 AT&amp;T 来说，不幸的是，这还不是他们 90 年代最大的系统崩溃。在这十年的后期，他们还遇到了更多的问题。</p><p>今天的公司拥有更好的流程，但即便如此，还是会有漏洞漏网。谷歌撰写了一篇关于网站可靠性工程 20 年的精彩回顾文章，其中对 2016 年 YouTube 的首次全球故障进行了反思。</p><p>对于公司来说，故障的规模是巨大的，每次故障都会给我们带来教训。然而，对于大多数公司来说，故障归根结底是人为错误和流程漏洞造成的。</p><p>原文：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fengineercodex.substack.com%2Fp%2Fhow-one-line-of-code-caused-a-60" target="_blank">https://engineercodex.substack.com/p/how-one-line-of-code-caused-a-60</a><br> 转自：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.jdon.com%2F69737.html" target="_blank">https://www.jdon.com/69737.htm</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 03:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266368/one-line-of-code-caused-a-60</guid>
            <link>https://www.oschina.net/news/266368/one-line-of-code-caused-a-60</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[游戏党福音！MakerFrame SIG 跨平台游戏引擎上线]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0px; margin-right:0px"><span><span style="color:#000000">近日，经 openKylin 社区技术委员会审议通过，</span><strong><span style="color:#000000">鹰歌框架引擎技术小组—MakerFrame SIG</span></strong><span style="color:#000000">正式成立。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">MakerFrame SIG 由</span><strong><span style="color:#000000">社区爱好者刘帅</span></strong><span style="color:#000000">发起成立，负责为 openKylin 社区开发简单高效的游戏框架引擎，致力于让专业人士和非专业人士都来开发跨平台的游戏和应用，大力促进 openKylin 社区游戏生态推广。</span></span></p><p style="margin-left:0; margin-right:0; text-align:center"><em><span><strong><span style="color:#ffae28">01</span></strong></span></em><span><strong><span style="color:#0b43d1">SIG 目标</span></strong></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">MakerFrame（鹰歌框架引擎）作为默认组件集成至 openKylin 社区版本中，让社区爱好者基于游戏引擎快捷的开发各种游戏，拓展社区游戏生态。</span></span></p><p style="margin-left:0; margin-right:0; text-align:center"><em><span><strong><span style="color:#ffae28">02</span></strong></span></em><span><strong><span style="color:#0b43d1">SIG 职责</span></strong></span></p><ul><li><span><span style="color:#000000">MakerFrame 游戏框架的开发维护和各平台适配；</span></span></li><li><span><span style="color:#000000">负责解答使用和开发过程中的技术问题。</span></span></li></ul><p style="margin-left:0; margin-right:0; text-align:center"><em><span><strong><span style="color:#ffae28">03</span></strong></span></em><span><strong><span style="color:#0b43d1">SIG 现阶段成果</span></strong></span></p><p style="margin-left:0; margin-right:0"><span><strong><span style="color:#0052ff">1、完成框架引擎的各平台适配。</span></strong></span></p><div><p style="text-align:center"><img alt="" height="746" src="https://oscimg.oschina.net/oscnet/up-df30540c26560597e288fdc15418de64b32.png" width="1366" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="margin-left:0; margin-right:0"><span><strong><span style="color:#000000">目前，MakerFrame 游戏框架已在 openKylin 社区开源，项目地址如下：</span></strong></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span><span style="color:#0052ff">https://gitee.com/openkylin/maker-frame</span></span></p><p style="margin-left:0; margin-right:0"><span><strong><span style="color:#0052ff">2、完成《侠道仙缘》游戏的开发和各平台适配。</span></strong></span></p><div><p style="text-align:center"><img alt="" height="745" src="https://oscimg.oschina.net/oscnet/up-c7c3e0bed2a046e5195847baed2814b8100.png" width="436" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="margin-left:0; margin-right:0"><span><strong><span style="color:#000000">目前，MakerFrame 框架引擎和《侠道仙缘》游戏已上架至 openKylin 软件商店，感兴趣的小伙伴赶快下载体验吧~</span></strong></span></p><p style="margin-left:0; margin-right:0; text-align:center"><em><span><strong><span style="color:#ffae28">04</span></strong></span></em><span><strong><span style="color:#0b43d1">欢迎加入 SIG</span></strong></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">欢迎所有对 openKylin 社区游戏开发感兴趣的社区爱好者加入我们！</span></span></p><ul><li><span><span style="color:#000000">邮件列表：</span></span></li><li><span><span style="color:#0052ff">markerframe@lists.openkylin.top</span></span></li><li><span><span style="color:#000000">SIG 主页：</span></span></li><li><span><span style="color:#0052ff">https://gitee.com/openkylin/community/tree/master/sig/MakerFrame</span></span></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:55:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266366</guid>
            <link>https://www.oschina.net/news/266366</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[信通院牵头的服务器无感知（Serverless）国际标准在 ITU 成功立项]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">国际电信联盟第十三研究组（简称 ITU-T SG13）于 2023 年 10 月 23 日-11 月 3 日在瑞士日内瓦召开全体会议，来自世界各国的百余名代表参加会议。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">会上，由中国信息通信研究院（简称「中国信通院」）牵头提出的 ITU-T Y.FaaS-reqts「Cloud computing - Functional requirements of function as a service（云计算-函数即服务功能要求）」国际标准成功立项，并计划于 2025 年正式发布。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">本国际标准依托中国信通院牵头制定的行业标准 YD/T 3764.9-2021《云计算服务客户信任体系能力要求，第 9 部分：函数即服务》提出。本标准计划给出函数即服务（FaaS）的清晰定义，界定 FaaS 与服务器无感知（Serverless）计算、云计算之间的关系，梳理 FaaS 与周边生态的交互关系，并详细列出 FaaS 的功能要求，同时将通过典型场景下 FaaS 的应用案例辅助验证本标准的适用性与准确性。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">FaaS 是 Serverless 计算最典型的形态，Serverless 体现了将基础设施资源抽象成按需使用的服务，用户只需关注应用逻辑，而无需管理复杂的基础设施运维工作的设计模式，被视作云计算的下一步。中国信通院在此领域深耕多年，目前已建立国内十分完善的 Serverless 标准与评估体系，涵盖 Serverless 计算、Serverless 工具、泛 Serverless 化服务等多个维度。未来，中国信通院将针对 Serverless 性能基准、Serverless BaaS 服务、典型 Serverless 应用场景解决方案等领域进一步开展深入研究。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266363</guid>
            <link>https://www.oschina.net/news/266363</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[英伟达发布 AI 芯片 H200]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>英伟达昨晚正式发布了 AI 芯片 H100 GPU 的后续产品<strong> HGX H200 GPU</strong>，可大幅提高大语言模型的能力。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b02e195462bf252f5b2f437a4a1ecdeca2d.png" referrerpolicy="no-referrer"></p><p>据悉，HGX H200 GPU 基于英伟达的「Hopper」架构，相比前代产品内存带宽增加了 1.4 倍，内存容量增加了 1.8 倍。H200 GPU 使用了 HBM3e 内存的芯片，能够以每秒 4.8 TB 的速度提供 141GB 的内存。</p><p>英伟达表示，H200 更大、更快的内存可加快生成式人工智能和大语言模型的速度，与 H100 GPU 相比，H200 在处理 Llama2 等大语言模型时可将推理速度提高 2 倍。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b6cc928aec01bd10e6b92f2644ee04f7881.png" referrerpolicy="no-referrer"></p><p>H200 还与已经支持 H100 的系统兼容。英伟达表示，客户在添加 H200 时不需要做任何改动。亚马逊、谷歌、微软和甲骨文的云计算部门将在明年率先使用到新的 GPU。</p><p>预计 H200 将于 2024 年第二季度上市，届时将与 AMD 的 MI300X GPU 展开竞争。与 H200 相似，AMD 的新芯片相比前代产品拥有更多内存，这对运行大型语言模型的推理计算有帮助。</p><p>据美国金融机构 Raymond James 透露，H100 芯片的成本仅为 3320 美元，但英伟达对其客户的批量价格却高达 2.5 万至 4 万美元。这使得 H100 的利润率可能高达 1000%，成为有史以来最赚钱的芯片之一。</p><p>在训练大型语言模型时，通常需要数千个 H100 集群协同工作，因此科技巨头、初创公司和政府机构都在争夺英伟达有限的芯片供应。</p><p>由于对其产品的需求看似无穷无尽，英伟达今年的销售额大幅增长，股价上涨了 230%，市值突破了 1.2 万亿美元大关。截至周一收盘，该股收涨 0.59%，报 486.2 美元。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:41:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266361</guid>
            <link>https://www.oschina.net/news/266361</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[TGFX —— 跨平台 2D 绘图引擎]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>TGFX (Tencent Graphics)&nbsp;是一个轻量级 2D 图形库，设计用于渲染文本、几何图形和图像。它提供高性能的 API，可在各种 GPU 硬件和软件平台上运行，包括 iOS、Android、macOS、Windows、Linux、Web 等。</p><p>TGFX 最初是作为 PAG 项目的核心组件创建的，从 4.0 版开始成为 libpag 库的默认图形引擎。它的主要目标是在保持更小二进制文件大小的同时，为 Skia 图形库提供令人信服的替代方案。随着时间的推移，它已被许多其他产品采用，如 Hippy、腾讯文档和各种视频编辑应用程序。</p><p style="margin-left:0px; margin-right:0px"><strong style="color:#1a1a1a">包体优化</strong></p><p style="color:#353535; margin-left:0; margin-right:0; text-align:start"><span>TGFX 最终以 400K 左右的大小覆盖了 Skia 近 2M 包体的绝大部分功能。核心优化策略主要有两点：</span></p><p><img height="231" src="https://static.oschina.net/uploads/space/2023/1108/105501_oKgt_4252687.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong style="color:#1a1a1a">调度优化</strong></p><p style="color:#353535; margin-left:0; margin-right:0; text-align:start"><span>TGFX 并不只是做 Skia 的简化，还把一些在业务上调用起来非常复杂的通用性流程进行了抽</span><span>象封装</span><span>：</span></p><p><img alt="" height="102" src="https://static.oschina.net/uploads/space/2023/1108/105526_HLW4_4252687.png" width="700" referrerpolicy="no-referrer"></p><p>在性能和架构方面，还做了这些额外的优化：</p><ul><li>默认开启了 HardwareBuffer 的支持，来全面加速纹理的提交，包括 Android 端。</li><li>暴露了引擎内部 Path 对应的 GPU 高速缓存，避免矢量绘制充分进行三角剖分操作。</li><li>GPU 对象支持在任意线程释放，等关联的上下文激活时才清理，避免随机 Crash 问题。</li><li>约束图片解码完会尽可能只缓存 GPU 的纹理部分，理论上全局可以降低一半的内存占用。</li><li>将绝大部分缓存都交给了上层业务精确管理，避免随机绘制的缓存持续占用额外的内存。</li><li>在全平台都实现了默认字体的读取能力，包括浏览器，避免下载上百兆 CJK 字体的压力。</li><li>增加了对各种硬解视频帧格式的直接绘制能力，可以一次性上屏无需通过 CPU 转换格式。</li><li>放弃了 SKSL 的统一 Shader 语言设计，更加符合原生接口调用习惯，既节省了包体，也减少了 GPU Program 的编译耗时。</li></ul></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/tgfx</guid>
            <link>https://www.oschina.net/p/tgfx</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 面向 AI 的下一代富文本编辑器 AiEditor]]>
            </title>
            <description>
                <![CDATA[<p><img src="https://gitee.com/aieditor-team/aieditor/raw/main/docs/assets/image/screenshot.png" alt="screenshot.png" referrerpolicy="no-referrer"></p><h1><a id="user-content-aieditor" class="anchor" href="https://gitee.com/aieditor-team/aieditor#aieditor"></a>AiEditor</h1><p>关于 AiEditor</p><blockquote><p>AiEditor 是一个面向 AI 的下一代富文本编辑器，她基于 Web Component，因此支持 Layui、Vue、React、Angular 等几乎任何前端框架。她适配了 PC Web 端和手机端，并提供了，亮色，和 暗色，两个主题。除此之外，她还提供了灵活的配置，开发者可以方便的使用其开发任何文字编辑的应用。</p></blockquote><h2><a id="user-content-在线演示" class="anchor" href="https://gitee.com/aieditor-team/aieditor#%E5%9C%A8%E7%BA%BF%E6%BC%94%E7%A4%BA"></a>在线演示</h2><p><a href="https://gitee.com/link?target=http%3A%2F%2Faieditor.jpress.cn">http://aieditor.jpress.cn</a></p><h2><a id="user-content-已完善" class="anchor" href="https://gitee.com/aieditor-team/aieditor#%E5%B7%B2%E5%AE%8C%E5%96%84"></a>已完善</h2><ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 基础：标题、正文、字体、字号、加粗、斜体、下划线、删除线、链接、行内代码、上标、下标、分割线、引用、打印</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 增强：撤回、重做、格式刷、橡皮擦、待办事项、字体颜色、背景颜色、Emoji 表情、对齐方式、行高、有（无）序列表、段落缩进、强制换行</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 附件：支持图片、视频、文件功能，支持选择上传、粘贴上传、拖拽上传、支持拖动调整大小...</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 代码：行内代码、代码块、代码语言选择</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 表格：左增右增、左减右减、上增下增、上减下减、合并单元格、解除合并</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> A I：AI 续写、AI 优化、AI 校对、AI 翻译、自定义 AI 菜单及其 Prompts</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 更多：亮色主题、暗色主题、手机版适配、全屏编辑、@某某某（提及）...</li></ul><h2><a id="user-content-待完善计划中" class="anchor" href="https://gitee.com/aieditor-team/aieditor#%E5%BE%85%E5%AE%8C%E5%96%84%E8%AE%A1%E5%88%92%E4%B8%AD"></a>待完善（计划中...）</h2><ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 国际化</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 团队协作</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 自动化测试</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> AI 插入图片</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> AI 图生图（AI 图片优化）</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> AI 一键排版</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 进一步强化增贴功能</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 上传视频自动获取缩略图</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> WORD 导入、导出</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> PDF 导出、PDF 预览</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 类腾讯文档 UI 风格</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 类 Notion 拖拽功能</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 更多的大模型对接：文心一言、ChatGPT</li></ul><h2><a id="user-content-构建运行" class="anchor" href="https://gitee.com/aieditor-team/aieditor#%E6%9E%84%E5%BB%BA%E8%BF%90%E8%A1%8C"></a>构建&amp;运行</h2><p><strong>构建</strong></p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">git clone https://gitee.com/aieditor-team/aieditor.git</span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="nb">cd </span>aieditor</span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="c"># 安装依赖</span></span><span id="LC6" class="line">npm <span class="nb">install</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p><strong>运行</strong></p><p>修改 <code>demos/main.ts</code> 下的内容为：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">new</span><span class="nx">AiEditor</span><span class="p">({</span></span><span id="LC2" class="line"><span class="na">element</span><span class="p">:</span><span class="dl">"</span><span class="s2">#aiEditor</span><span class="dl">"</span><span class="p">,</span></span><span id="LC3" class="line"><span class="na">placeholder</span><span class="p">:</span><span class="dl">"</span><span class="s2">点击输入内容...</span><span class="dl">"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="na">content</span><span class="p">:</span><span class="dl">'</span><span class="s1">AiEditor 是一个面向 AI 的开源富文本编辑器。输入，空格 + "/" 可以快速弹出 AI 菜单哦 </span><span class="dl">'</span><span class="p">,</span></span><span id="LC5" class="line"><span class="na">ai</span><span class="p">:</span><span class="p">{</span></span><span id="LC6" class="line"><span class="na">model</span><span class="p">:</span><span class="p">{</span></span><span id="LC7" class="line"><span class="na">xinghuo</span><span class="p">:</span><span class="p">{</span></span><span id="LC8" class="line"><span class="na">appId</span><span class="p">:</span><span class="dl">"</span><span class="s2">***</span><span class="dl">"</span><span class="p">,</span></span><span id="LC9" class="line"><span class="na">apiKey</span><span class="p">:</span><span class="dl">"</span><span class="s2">***</span><span class="dl">"</span><span class="p">,</span></span><span id="LC10" class="line"><span class="na">apiSecret</span><span class="p">:</span><span class="dl">"</span><span class="s2">***</span><span class="dl">"</span><span class="p">,</span></span><span id="LC11" class="line"><span class="p">}</span></span><span id="LC12" class="line"><span class="p">}</span></span><span id="LC13" class="line"><span class="p">}</span></span><span id="LC14" class="line"><span class="p">})</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>或者直接移除 AI 的配置，如下所示（移除后，则不能使用 AI 功能）：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">new</span><span class="nx">AiEditor</span><span class="p">({</span></span><span id="LC2" class="line"><span class="na">element</span><span class="p">:</span><span class="dl">"</span><span class="s2">#aiEditor</span><span class="dl">"</span><span class="p">,</span></span><span id="LC3" class="line"><span class="na">placeholder</span><span class="p">:</span><span class="dl">"</span><span class="s2">点击输入内容...</span><span class="dl">"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="na">content</span><span class="p">:</span><span class="dl">'</span><span class="s1">AiEditor 是一个面向 AI 的开源富文本编辑器。输入，空格 + "/" 可以快速弹出 AI 菜单哦 </span><span class="dl">'</span><span class="p">,</span></span><span id="LC5" class="line"><span class="p">})</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>然后再命令行下执行：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">npm run dev</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-ai-功能配置" class="anchor" href="https://gitee.com/aieditor-team/aieditor#ai-%E5%8A%9F%E8%83%BD%E9%85%8D%E7%BD%AE"></a>AI 功能配置</h2><ul><li>1、去科大讯飞注册账号 <a href="https://gitee.com/link?target=https%3A%2F%2Fxinghuo.xfyun.cn">https://xinghuo.xfyun.cn</a></li><li>2、在科大讯飞服务管理中（<a href="https://gitee.com/link?target=https%3A%2F%2Fconsole.xfyun.cn%2Fservices%2Fbm2">https://console.xfyun.cn/services/bm2</a> ） 获取 appId、apiKey、apiSecret。</li><li>3、在配置中添加科大讯飞星火大模型配置</li></ul><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">new</span><span class="nx">AiEditor</span><span class="p">({</span></span><span id="LC2" class="line"><span class="na">element</span><span class="p">:</span><span class="dl">"</span><span class="s2">#aiEditor</span><span class="dl">"</span><span class="p">,</span></span><span id="LC3" class="line"><span class="na">placeholder</span><span class="p">:</span><span class="dl">"</span><span class="s2">点击输入内容...</span><span class="dl">"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="na">content</span><span class="p">:</span><span class="dl">'</span><span class="s1">AiEditor 是一个面向 AI 的开源富文本编辑器。</span><span class="dl">'</span><span class="p">,</span></span><span id="LC5" class="line"><span class="na">ai</span><span class="p">:</span><span class="p">{</span></span><span id="LC6" class="line"><span class="na">model</span><span class="p">:</span><span class="p">{</span></span><span id="LC7" class="line"><span class="na">xinghuo</span><span class="p">:</span><span class="p">{</span></span><span id="LC8" class="line"><span class="na">appId</span><span class="p">:</span><span class="dl">"</span><span class="s2">***</span><span class="dl">"</span><span class="p">,</span></span><span id="LC9" class="line"><span class="na">apiKey</span><span class="p">:</span><span class="dl">"</span><span class="s2">***</span><span class="dl">"</span><span class="p">,</span></span><span id="LC10" class="line"><span class="na">apiSecret</span><span class="p">:</span><span class="dl">"</span><span class="s2">***</span><span class="dl">"</span><span class="p">,</span></span><span id="LC11" class="line"><span class="p">}</span></span><span id="LC12" class="line"><span class="p">}</span></span><span id="LC13" class="line"><span class="p">}</span></span><span id="LC14" class="line"><span class="p">})</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div>]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/aieditor-team/aieditor</guid>
            <link>https://gitee.com/aieditor-team/aieditor</link>
        </item>
        <item>
            <title>
                <![CDATA[Linux 基金会创建高性能软件基金会 (HPSF)]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Linux 基金会<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linuxfoundation.org%2Fpress%2Flinux-foundation-announces-intent-to-form-high-performance-software-foundation-hpsf" target="_blank">宣布</a>，他们正在组建<strong>高性能软件基金会</strong>(High Performance Software Foundation, HPSF)，以帮助推进高性能计算 (HPC) 核心开源项目的发展，包括 Spack, Kokkos, AMReX, VTK-m, HPCToolkit, E4S, Charliecloud, WarpX，以及其他面向 HPC 的项目。</p><p>部分国家实验室，知名科技公司如英特尔、英伟达和其他利益相关者已经参与其中（暂未发现 AMD 参与）。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1d45e285c4d0bd80c3829c1c4df3a8b4906.png" referrerpolicy="no-referrer"></p><p>HPSF 已制定了明确的目标：</p><ul><li>成为高性能软件生态系统中关键项目的中立家园；</li><li>在开源社区和组织中推广 HPSF 项目的使用；</li><li>提供透明的治理模式，让政府、行业和学术界的利益相关者共同管理生态系统；</li><li>提供清晰的路径来孵化和启动有前景的新项目；</li><li>通过提供 CI 和 turn-key 构建，确保 HPC 软件可访问且可靠；</li><li>通过与 CNCF 和 OpenSSF 合作，确保 HPC 软件安全并为上云做好准备；</li><li>赞助活动和培训，为 HPSF 生态系统中的软件培养一支多元化、熟练的劳动力队伍。</li></ul><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linuxfoundation.org%2Fpress%2Flinux-foundation-announces-intent-to-form-high-performance-software-foundation-hpsf" target="_blank">更多内容查看官方新闻稿</a></u>。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266356/lf-high-performance-software-foundation-hpsf</guid>
            <link>https://www.oschina.net/news/266356/lf-high-performance-software-foundation-hpsf</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | GPU 架构与计算入门指南]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p><img src="https://oscimg.oschina.net/oscnet/86cf28df-e180-4a38-9a4b-768dae1aa92b.jpg" referrerpolicy="no-referrer"></p><p><span><span>大多数工程师对 CPU 和顺序编程都十分熟悉，这是因为自从他们开始编写 CPU 代码以来，就与之密切接触。然而，对于 GPU 的内部工作原理及其独特之处，他们的了解则相对较少。过去十年，由于 GPU 在深度学习中得到广泛应用而变得极为重要。因此，每位软件工程师都有必要了解其基本工作原理。本文旨在为读者提供这方面的背景知识。</span></span></p><p>&nbsp;</p><p><span><span>本文作者为软件工程师 Abhinav Upadhyay，他在《大规模并行处理器编程》第四版（Hwu 等）的基础上编写了本文大部分内容，其中介绍了包括 GPU 体系结构和执行模型等内容。当然，文中 GPU 编程的基本概念和方法同样适用于其他供应商的产品。</span></span></p><p>&nbsp;</p><p style="text-align:left"><span><span>（本文由 OneFlow 编译发布，转载请联系授权。</span><span>原文：</span>https://codeconfessions.substack.com/p/gpu-computing）</span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><strong><span><span style="color:#3f3f3f"><strong><span>作者 | Abhinav Upadhyay</span></strong></span></span></strong></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><strong><span><span style="color:#3f3f3f"><strong><span>OneFlow 编译</span></strong></span></span></strong></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><strong><span><span style="color:#3f3f3f"><strong><span>翻译｜宛子琳、杨婷</span></strong></span></span></strong></span></span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><strong><span><span><strong><span style="color:#f6ab00">1</span></strong></span></span></strong></span></span></p><span id="OSC_h2_1"></span><h2 style="margin-left:8px; margin-right:8px; text-align:center">&nbsp;</h2><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><strong><span><span style="color:#1e2380"><strong><span style="color:#1e2380">比较 CPU 与 GPU</span></strong></span></span></strong></span></span></p><p><span style="color:#3f3f3f"><span><strong><span><span>&nbsp;</span></span></strong></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">首先，我们会比较 CPU 和 GPU，这能帮助我们更好地了解 GPU 的发展状况，但这应该作为一个独立的主题，因为我们难以在一节中涵盖其所有的内容。因此，我们将着重介绍一些关键点。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">CPU 和 GPU 的主要区别在于它们的设计目标。CPU 的设计初衷是执行顺序指令[1]。一直以来，为提高顺序执行性能，CPU 设计中引入了许多功能。其重点在于减少指令执行时延，使 CPU 能够尽可能快地执行一系列指令。这些功能包括指令流水线、乱序执行、预测执行和多级缓存等（此处仅列举部分）。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">而 GPU 则专为大规模并行和高吞吐量而设计，但这种设计导致了中等至高程度的指令时延。这一设计方向受其在视频游戏、图形处理、数值计算以及现如今的深度学习中的广泛应用所影响，所有这些应用都需要以极高的速度执行大量线性代数和数值计算，因此人们倾注了大量精力以提升这些设备的吞吐量。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">我们来思考一个具体的例子：由于指令时延较低，CPU 在执行两个数字相加的操作时比 GPU 更快。在按顺序执行多个这样的计算时，CPU 能够比 GPU 更快地完成。然而，当需要进行数百万甚至数十亿次这样的计算时，由于 GPU 具有强大的大规模并行能力，它将比 CPU 更快地完成这些计算任务。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">我们可以通过具体数据来进行说明。硬件在数值计算方面的性能以每秒浮点运算次数（FLOPS）来衡量。NVIDIA 的 Ampere A100 在 32 位精度下的吞吐量为 19.5 TFLOPS。相比之下，Intel 的 24 核处理器在 32 位精度下的吞吐量仅为 0.66 TFLOPS（2021 年）。同时，随时间推移，GPU 与 CPU 在吞吐量性能上的差距逐年扩大。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">下图对 CPU 和 GPU 的架构进行了比较。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><img height="auto" src="https://oscimg.oschina.net/oscnet/bdd6d31c-c5ec-4301-a326-11b2bdc1264b.png" width="auto" referrerpolicy="no-referrer"><span style="color:#888888"><em><span style="color:#888888">图 1：CPU 与 GPU 的芯片设计对比。引自《CUDA C++编程指南》（NVIDIA）</span></em></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">如图所示，CPU 在芯片领域中主要用于降低指令时延的功能，例如大型缓存、较少的算术逻辑单元（ALU）和更多的控制单元。与此相比，GPU 则利用大量的 ALU 来最大化计算能力和吞吐量，只使用极小的芯片面积用于缓存和控制单元，这些元件主要用于减少 CPU 时延。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><strong><span>时延容忍度<strong style="color:#3f3f3f"><span>和</span></strong>高吞吐量</span></strong></span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">或许你会好奇，GPU 如何能够容忍高时延并同时提供高性能呢？GPU 拥有大量线程和强大的计算能力，使这一点成为可能。即使单个指令具有高延迟，GPU 也会有效地调度线程运行，以便它们在任意时间点都能利用计算能力。例如，当某些线程正在等待指令结果时，GPU 将切换到运行其他非等待线程。这可确保 GPU 上的计算单元在所有时间点都以其最大容量运行，从而提供高吞吐量。稍后当我们讨论 kernel 如何在 GPU 上运行时，我们将对此有更清晰的了解。</span></span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span><span><strong><span style="color:#f6ab00">2</span></strong></span></span></span></span></p><span id="OSC_h2_2"></span><h2 style="margin-left:8px; margin-right:8px; text-align:center">&nbsp;</h2><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span><span style="color:#1e2380"><strong><span style="color:#1e2380">GPU 架构</span></strong></span></span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">我们已经了解到 GPU 有利于实现高吞吐量，但它们是通过怎样的架构来实现这一目标的呢？本节将对此展开探讨。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><strong><span>GPU 的计算架构</span></strong></span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">GPU 由一系列流式多处理器（SM）组成，其中每个 SM 又由多个流式处理器、核心或线程组成。例如，NVIDIA H100 GPU 具有 132 个 SM，每个 SM 拥有 64 个核心，总计核心高达 8448 个。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">每个 SM 都拥有一定数量的片上内存（on-chip memory），通常称为共享内存或临时存储器，这些共享内存被所有的核心所共享。同样，SM 上的控制单元资源也被所有的核心所共享。此外，每个 SM 都配备了基于硬件的线程调度器，用于执行线程。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">除此之外，每个 SM 还配备了几个功能单元或其他加速计算单元，例如张量核心（tensor core）或光线追踪单元（ray tracing unit），用于满足 GPU 所处理的工作负载的特定计算需求。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p><span style="color:#3f3f3f"><span><span><img height="auto" src="https://oscimg.oschina.net/oscnet/c25e87f8-efab-4e56-b903-e657474e8026.png" width="auto" referrerpolicy="no-referrer"></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p style="color:#494949; text-align:center"><span style="color:#3f3f3f"><span><span><span style="color:#888888"><em><span style="color:#888888">图 2：GPU 的计算架构</span></em></span></span></span></span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">接下来，让我们深入剖析 GPU 内存并了解其中的细节。</span></span></span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><strong><span>GPU 的内存架构</span></strong></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span>&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">GPU 具有多层不同类型的内存，每一层都有其特定用途。下图显示了 GPU 中一个 SM 的内存层次结构。</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p><span style="color:#3f3f3f"><span><img height="auto" src="https://oscimg.oschina.net/oscnet/94a4fe5d-80dd-4461-b5af-4587fd012f16.jpg" width="auto" referrerpolicy="no-referrer"></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span style="color:#888888"><em><span style="color:#888888">图 3：基于康奈尔大学虚拟工作坊（Virtual Workshop）的 GPU 内存架构</span></em></span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">让我们对其进行剖析：</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><ul style="margin-left:8px; margin-right:8px"><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><strong><span style="color:#3f3f3f">寄存器</span></strong><span style="color:#3f3f3f">：让我们从寄存器开始。GPU 中的每个 SM 都拥有大量寄存器。例如，NVIDIA 的 A100 和 H100 模型中，每个 SM 拥有 65536 个寄存器。这些寄存器在核心之间共享，并根据线程需求动态分配。在执行过程中，每个线程都被分配了私有寄存器，其他线程无法读取或写入这些寄存器。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><strong><span style="color:#3f3f3f">常量缓存</span></strong><span style="color:#3f3f3f">：接下来是芯片上的常量缓存。这些缓存用于缓存 SM 上执行的代码中使用的常量数据。为利用这些缓存，程序员需要在代码中明确将对象声明为常量，以便 GPU 可以将其缓存并保存在常量缓存中。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><strong><span style="color:#3f3f3f">共享内存</span></strong><span style="color:#3f3f3f">：每个 SM 还拥有一块共享内存或临时内存，它是一种小型、快速且低时延的片上可编程 SRAM 内存，供运行在 SM 上的线程块共享使用。共享内存的设计思路是，如果多个线程需要处理相同的数据，只需要其中一个线程从全局内存（global memory）加载，而其他线程将共享这一数据。合理使用共享内存可以减少从全局内存加载重复数据的操作，并提高内核执行性能。共享内存还可以用作线程块（block）内的线程之间的同步机制。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><strong><span style="color:#3f3f3f">L1 缓存</span></strong><span style="color:#3f3f3f">：每个 SM 还拥有一个 L1 缓存，它可以缓存从 L2 缓存中频繁访问的数据。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><strong><span style="color:#3f3f3f">L2 缓存</span></strong><span style="color:#3f3f3f">：所有 SM 都共享一个 L2 缓存，它用于缓存全局内存中被频繁访问的数据，以降低时延。需要注意的是，L1 和 L2 缓存对于 SM 来说是公开的，也就是说，SM 并不知道它是从 L1 还是 L2 中获取数据。SM 从全局内存中获取数据，这类似于 CPU 中 L1/L2/L3 缓存的工作方式。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><strong><span style="color:#3f3f3f">全局内存</span></strong><span style="color:#3f3f3f">：GPU 还拥有一个片外全局内存，它是一种容量大且带宽高的动态随机存取存储器（DRAM）。例如，NVIDIA H100 拥有 80 GB 高带宽内存（HBM），带宽达每秒 3000 GB。由于与 SM 相距较远，全局内存的时延相当高。然而，芯片上还有几个额外的存储层以及大量的计算单元有助于掩饰这种时延。</span></span></span></span></p></li></ul><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">现在我们已经了解 GPU 硬件的关键组成部分，接下来我们深入一步，了解执行代码时这些组件是如何发挥作用的。</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span><strong><span style="color:#f6ab00">3</span></strong></span></span></span></p><span id="OSC_h2_3"></span><h2 style="margin-left:8px; margin-right:8px; text-align:center">&nbsp;</h2><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span style="color:#1e2380"><strong><span style="color:#1e2380">了解 GPU 的执行模型</span></strong></span></span></span></p><p>&nbsp;</p><p style="color:#494949"><span style="color:#3f3f3f"><span>&nbsp;</span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">要理解 GPU 如何执行 kernel，我们首先需要了解什么是 kernel 及其配置。</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><strong><span>CUDA Kernel 与线程块简介</span></strong></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">CUDA 是 NVIDIA 提供的编程接口，用于编写运行在其 GPU 上的程序。在 CUDA 中，你会以类似于 C/C++函数的形式来表达想要在 GPU 上运行的计算，这个函数被称为 kernel。kernel 在并行中操作向量形式的数字，这些数字以函数参数的形式提供给它。一个简单的例子是执行向量加法的 kernel，即接受两个向量作为输入，逐元素相加，并将结果写入第三个向量。</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">要在 GPU 上执行 kernel，我们需要启用多个线程，这些线程总体上被称为一个网格（grid），但网格还具有更多的结构。一个网格由一个或多个线程块（有时简称为块）组成，而每个线程块又由一个或多个线程组成。</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">线程块和线程的数量取决于数据的大小和我们所需的并行度。例如，在向量相加的示例中，如果我们要对 256 维的向量进行相加运算，那么可以配置一个包含 256 个线程的单个线程块，这样每个线程就可以处理向量的一个元素。如果数据更大，GPU 上也许没有足够的线程可用，这时我们可能需要每个线程能够处理多个数据点。</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p><span style="color:#3f3f3f"><span><img height="auto" src="https://oscimg.oschina.net/oscnet/7e96e636-6948-48f2-adc5-bbc37c3a1f19.png" width="auto" referrerpolicy="no-referrer"></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span style="color:#888888"><em><span style="color:#888888">图 4：线程块网格。引自《CUDA C++编程指南》（NVIDIA）</span></em></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">编写一个 kernel 需要两步。第一步是运行在 CPU 上的主机代码，这部分代码用于加载数据，为 GPU 分配内存，并使用配置的线程网格启动 kernel；第二步是编写在 GPU 上执行的设备（GPU）代码。</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">对于向量加法示例，下图显示了主机代码。</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p><span style="color:#3f3f3f"><span><img height="auto" src="https://oscimg.oschina.net/oscnet/bc098e64-ceb7-4b8c-8e4b-607b56d471d4.jpg" width="auto" referrerpolicy="no-referrer"></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span style="color:#888888"><em><span style="color:#888888">图 5：CUDA kernel 的主机代码，用于将两个向量相加。</span></em></span></span></span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">下图为设备代码，它定义了实际的 kernel 函数。</span></span></span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p><span style="color:#3f3f3f"><span><img height="auto" src="https://oscimg.oschina.net/oscnet/1d2f6102-c267-4b78-ba9e-880c832009d1.jpg" width="auto" referrerpolicy="no-referrer"></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span style="color:#888888"><em><span style="color:#888888">图 6：包含向量相加 kernel 定义的设备代码。</span></em></span></span></span></p><blockquote><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">由于本文的重点不在于教授 CUDA，因此我们不会更深入地讨论此段代码。现在，让我们看看在 GPU 上执行 kernel 的具体步骤。</span></span></span></blockquote><p>&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span><strong><span style="color:#f6ab00">4</span></strong></span></span></span></p><span id="OSC_h2_4"></span><h2 style="margin-left:8px; margin-right:8px; text-align:center">&nbsp;</h2><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span style="color:#1e2380"><strong><span style="color:#1e2380">在 GPU 上执行 Kernel 的步骤</span></strong></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><strong style="color:#3f3f3f"><span>1. 将数据从主机复制到设备</span></strong></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span><span style="color:#3f3f3f">在调度执行 kernel 之前，必须将其所需的全部数据从主机（即 CPU）内存复制到 GPU 的全局内存（即设备内存）。</span><span style="color:#3f3f3f">尽管如此，在最新的 GPU 硬件中，我们还可以使用统一虚拟内存直接从主机内存中读取数据（可参阅论文《EMOGI: Efficient Memory-access for Out-of-memory Graph-traversal in GPUs》）。</span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><strong><span>2. SM 上线程块的调度</span></strong></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">当 GPU 的内存中拥有全部所需的数据后，它会将线程块分配给 SM。同一个块内的所有线程将同时由同一个 SM 进行处理。为此，GPU 必须在开始执行线程之前在 SM 上为这些线程预留资源。在实际操作中，可以将多个线程块分配给同一个 SM 以实现并行执行。</span></span></span></p><p style="color:#494949">&nbsp;</p><p><span style="color:#3f3f3f"><span><img height="auto" src="https://oscimg.oschina.net/oscnet/a5075db0-bd48-4627-a342-c93f06482fca.png" width="auto" referrerpolicy="no-referrer"></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span style="color:#888888"><em><span style="color:#888888">图 7：将线程块分配给 SM</span></em></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:center">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">由于 SM 的数量有限，而大型 kernel 可能包含大量线程块，因此并非所有线程块都可以立即分配执行。GPU 会维护一个待分配和执行的线程块列表，当有任何一个线程块执行完成时，GPU 会从该列表中选择一个线程块执行。</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><strong><span>3. 单指令多线程 (SIMT) 和</span></strong><strong><span>线程束（Warp）</span></strong></span></span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">众所周知，一个块（block）中的所有线程都会被分配到同一个 SM 上。但在此之后，线程还会进一步划分为大小为 32 的组（称为 warp[2]），并一起分配到一个称为处理块（processing block）的核心集合上进行执行。</span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">SM 通过获取并向所有线程发出相同的指令，以同时执行 warp 中的所有线程。然后这些线程将在数据的不同部分，同时执行该指令。在向量相加的示例中，一个 warp 中的所有线程可能都在执行相加指令，但它们会在向量的不同索引上进行操作。</span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">由于多个线程同时执行相同的指令，这种 warp 的执行模型也称为单指令多线程 （SIMT）。这类似于 CPU 中的单指令多数据（SIMD）指令。</span></span></span></p><blockquote><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">Volta 及其之后的新一代 GPU 引入了一种替代指令调度的机制，称为独立线程调度（Independent Thread Scheduling）。它允许线程之间完全并发，不受 warp 的限制。独立线程调度可以更好地利用执行资源，也可以作为线程之间的同步机制。本文不会涉及独立线程调度的相关内容，但你可以在 CUDA 编程指南中了解更多相关信息。</span></span></span></p></blockquote><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><strong><span style="color:#3f3f3f">4. Warp 调度和时延容忍度</span></strong></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">关于 warp 的运行原理，有一些值得讨论的有趣之处。</span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">即使 SM 内的所有处理块（核心组）都在处理 warp，但在任何给定时刻，只有其中少数块正在积极执行指令。因为 SM 中可用的执行单元数量是有限的。</span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">有些指令的执行时间较长，这会导致 warp 需要等待指令结果。在这种情况下，SM 会将处于等待状态的 warp 休眠，并执行另一个不需要等待任何结果的 warp。这使得 GPU 能够最大限度地利用所有可用计算资源，并提高吞吐量。</span></span></span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><blockquote><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">零计算开销调度：由于每个 warp 中的每个线程都有自己的一组寄存器，因此 SM 从执行一个 warp 切换到另一个 warp 时没有额外计算开销。</span></span></span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">与 CPU 上进程之间的上下文切换方式（context-switching）不同。如果一个进程需要等待一个长时间运行的操作，CPU 在此期间会在该核心上调度执行另一个进程。然而，在 C</span><span style="color:#3f3f3f">PU 中进行上下文切换的代价昂贵，这是因为 CPU 需要将寄存器状态保存到主内存中，并恢复另一个进程的状态。</span></span></span></p></blockquote><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><strong><span style="color:#3f3f3f">5. 将结果数据从设备复制到主机内存</span></strong></span></span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">最后，当 kernel 的所有线程都执行完毕后，最后一步就是将结果复制回主机内存。</span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">尽管我们涵盖了有关典型 kernel 执行的全部内容，但还有一点值得讨论：动态资源分区。</span></span></span></p><p style="margin-left:8px; margin-right:8px">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span><strong><span style="color:#f6ab00">5</span></strong></span></span></span></p><span id="OSC_h2_5"></span><h2 style="margin-left:8px; margin-right:8px; text-align:center">&nbsp;</h2><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span style="color:#1e2380"><strong><span style="color:#1e2380">资源划分和占用概念</span></strong></span></span></span></p><p><span style="color:#3f3f3f"><span><span style="color:#494949">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">我们通过一个称为「occupancy（占用率）」的指标来衡量 GPU 资源的利用率，它表示分配给 SM 的 warp 数量与 SM 所能支持的最大 warp 数量之间的比值。为实现最大吞吐量，我们希望拥有 100% 的占用率。然而，在实践中，由于各种约束条件，这并不容易实现。</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">为什么我们无法始终达到 100% 的占用率呢？SM 拥有一组固定的执行资源，包括寄存器、共享内存、线程块槽和线程槽。这些资源根据需求和 GPU 的限制在线程之间进行动态划分。例如，在 NVIDIA H100 上，每个 SM 可以处理 32 个线程块、64 个 warp（即 2048 个线程），每个线程块拥有 1024 个线程。如果我们启动一个包含 1024 个线程的网格，GPU 将把 2048 个可用线程槽划分为 2 个线程块。</span></span></span></span></span></p><blockquote><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">动态分区 vs 固定分区：动态分区能够更为有效地利用 GPU 的计算资源。相比之下，固定分区为每个线程块分配了固定数量的执行资源，这种方式并不总是最有效的。在某些情况下，固定分区可能会导致线程被分配多于其实际需求的资源，造成资源浪费和吞吐量降低。</span></span></span></p></blockquote><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">下面我们通过一个例子说明资源分配对 SM 占用率的影响。假设我们使用 32 个线程的线程块，并需要总共 2048 个线程，那么我们将需要 64 个这样的线程块。然而，每个 SM 一次只能处理 32 个线程块。因此，即使一个 SM 可以运行 2048 个线程，但它一次也只能同时运行 1024 个线程，占用率仅为 50%。</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">同样地，每个 SM 具有 65536 个寄存器。要同时执行 2048 个线程，每个线程最多有 32 个寄存器（65536/2048 =32）。如果一个 kernel 需要每个线程有 64 个寄存器，那么每个 SM 只能运行 1024 个线程，占用率同样为 50%。</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">占用率不足的挑战在于，可能无法提供足够的时延容忍度或所需的计算吞吐量，以达到硬件的最佳性能。</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">高效创建 GPU kernel 是一项复杂任务。我们必须合理分配资源，在保持高占用率的同时尽量降低时延。例如，拥有大量寄存器可以加快代码的运行速度，但可能会降低占用率，因此谨慎优化代码至关重要。</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span><strong><span style="color:#f6ab00">6</span></strong></span></span></span></p><span id="OSC_h2_6"></span><h2 style="margin-left:8px; margin-right:8px; text-align:center">&nbsp;</h2><p style="margin-left:8px; margin-right:8px; text-align:center"><span style="color:#3f3f3f"><span><span style="color:#1e2380"><strong><span style="color:#1e2380">总结</span></strong></span></span></span></p><p><span style="color:#3f3f3f"><span><span style="color:#494949">&nbsp;</span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">我理解众多的新术语和新概念可能令读者望而生畏，因此文章最后对要点进行了总结，以便快速回顾。</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><ul style="margin-left:8px; margin-right:8px"><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">GPU 由多个 SM 组成，每个 SM 又包含多个处理核心。</span></span></span></span></span></p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">GPU 上存在着一个片外全局内存，通常是高带宽内存（HBM）或动态随机存取内存（DRAM）。它与芯片上的 SM 相距较远，因此时延较高。</span></span></span></span></span></p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">GPU 中有两个级别的缓存：片外 L2 缓存和片上 L1 缓存。L1 和 L2 缓存的工作方式类似于 CPU 中的 L1/L2 缓存。</span></span></span></span></span></p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">每个 SM 上都有一小块可配置的共享内存。这块共享内存在处理核心之间共享。通常情况下，线程块内的线程会将一段数据加载到共享内存中，并在需要时重复使用，而不是每次再从全局内存中加载。</span></span></span></span></span></p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">每个 SM 都有大量寄存器，寄存器会根据线程需求进行划分。NVIDIA H100 每个 SM 有 65536 个寄存器。</span></span></span></span></span></p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">在 GPU 上执行 kernel 时，我们需要启动一个线程网格。网格由一个或多个线程块组成，而每个线程块又由一个或多个线程组成。</span></span></span></span></span></p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">根据资源可用性，GPU 会分配一个或多个线程块在 SM 上执行。同一个线程块中的所有线程都会被分配到同一个 SM 上执行。这样做的目的是为了充分利用数据的局部性（data locality），并实现线程之间的同步。</span></span></span></span></span></p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">被分配给 SM 的线程进一步分为大小为 32 的组，称为 warp。一个 warp 内的所有线程同时执行相同的指令，但在数据的不同部分上执行（SIMT）（尽管新一代 GPU 也支持独立的线程调度）。</span></span></span></span></span></p></li><li><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">GPU 根据每个线程的需求和 SM 的限制，在线程之间进行动态资源划分。程序员需要仔细优化代码，以确保在执行过程中达到最高的 SM 占用率。</span></span></span></span></span></p></li></ul><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">&nbsp;</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><strong><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">脚注</span></span></span></strong></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify">&nbsp;</p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">[1]没错，得益于超线程技术和多核处理器，CPU 也可以并行执行任务。但长期以来，大量工作都致力于提高顺序执行的性能。</span></span></span></span></span></p><p style="margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3f3f3f"><span><span style="color:#3f3f3f"><span><span style="color:#3f3f3f">[2]在当前一代的 NVIDIA GPU 中，warp 大小为 32。但在未来的硬件迭代中，这个大小可能会发生改变。</span></span></span></span></span></p><span id="OSC_h2_7"></span><h2 style="margin-left:8px; margin-right:8px">&nbsp;</h2><p style="text-align:left">&nbsp;</p><p style="text-align:left"><span style="color:#3f3f3f"><span><span style="background-color:#ffffff; color:#888888">其他人都在看</span></span></span></p><span id="OSC_h3_8"></span><h3>&nbsp;</h3><ul><li><p><span style="color:#3f3f3f"><span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODY2MTk3Nw%3D%3D%26mid%3D2247492657%26idx%3D1%26sn%3Da71795c583da44c805f79630f2ef635a%26chksm%3Dfe426a07c935e3112422680f4942c0b372c01db1e63e044010f03cd72689bce2563e8672136b%26scene%3D21%23wechat_redirect" target="_blank">开源语言大模型的正确姿势</a></span></span></p></li><li><p style="text-align:left"><span style="color:#3f3f3f"><span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODY2MTk3Nw%3D%3D%26mid%3D2247492610%26idx%3D1%26sn%3D9b92f3efa0d85cb1bb689efab362c3e8%26chksm%3Dfe426a34c935e32200b2d9cc84916eb980ba3c8ab1eceafa9834e38049e5243ca8aa77564a68%26scene%3D21%23wechat_redirect" target="_blank">为什么开源大模型终将胜出</a></span></span></p></li><li><p style="text-align:left"><span style="color:#3f3f3f"><span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODY2MTk3Nw%3D%3D%26mid%3D2247492849%26idx%3D1%26sn%3D51f53e04b4b97cd9dd38429784015c98%26chksm%3Dfe426ac7c935e3d1b5970441a68c53b6dae05792cd9a244ad8efb40ffc5ab4c60cdf3a7181b0%26scene%3D21%23wechat_redirect" target="_blank">LoRA 和 QLoRA 微调语言大模型</a></span></span></p></li><li><p style="text-align:left"><span style="color:#3f3f3f"><span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODY2MTk3Nw%3D%3D%26mid%3D2247492767%26idx%3D1%26sn%3Ded8acf6d7e9117b5ab3ea0de8e540460%26chksm%3Dfe426aa9c935e3bfb8b3e2ffc7cb6349f076f4f25d2fbe13b6e8e2c30ea010261c57f8d6cacb%26scene%3D21%23wechat_redirect" target="_blank">OpenAI 规模经济与第二护城河</a></span></span></p></li><li><p style="text-align:left"><span style="color:#3f3f3f"><span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODY2MTk3Nw%3D%3D%26mid%3D2247492787%26idx%3D1%26sn%3Dc5d16b72e94079bb20e9772cad81e703%26chksm%3Dfe426a85c935e393a9962ab763fc1f06ebaf1bd75331cc089ff61f8655c0e8ecbb8211264544%26scene%3D21%23wechat_redirect" target="_blank">全面对比 GPT-3.5 与 LLaMA 2 微调</a></span></span></p></li><li><p style="text-align:left"><span style="color:#3f3f3f"><span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODY2MTk3Nw%3D%3D%26mid%3D2247492811%26idx%3D1%26sn%3D916e330a2a4152dab3192635c3e475fa%26chksm%3Dfe426afdc935e3eb2f371ff5f56247c95800ce91a950a89bea871c26ddc4c3d13371acf03978%26scene%3D21%23wechat_redirect" target="_blank">语言大模型推理性能工程：最佳实践</a></span></span></p></li><li><p style="text-align:left"><span style="color:#3f3f3f"><span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODY2MTk3Nw%3D%3D%26mid%3D2247492618%26idx%3D1%26sn%3Da20f4828b9ab3e3cee3fedfd906e0eb2%26chksm%3Dfe426a3cc935e32a8312ce9efbb4f2640787508d3e811579bbffe918685cdb07a8bd8e3ffc4b%26scene%3D21%23wechat_redirect" target="_blank">LLVM 之父:我的 AI 基础设施软件构建理念</a></span></span></p></li></ul><span id="OSC_h3_9"></span><h3>&nbsp;</h3><p><strong><span style="color:#3f3f3f"><span><span>试用 OneFlow: <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fgithub.com%2FOneflow-Inc%2Foneflow%2F" target="_blank">github.com/Oneflow-Inc/oneflow/</a></span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fgithub.com%2FOneflow-Inc%2Foneflow%2F" target="_blank"></a></span></span></strong></p><p style="margin-left:8px; margin-right:8px"><span style="color:#3f3f3f"><span><img src="https://oscimg.oschina.net/oscnet/b316e9d8-4d68-4323-98d4-8e2e62cf5163.png" referrerpolicy="no-referrer"></span></span></p><p>&nbsp;</p></div><p style="color:#858585">本文分享自微信公众号 - OneFlow（OneFlowTechnology）。<br> 如有侵权，请联系 support@oschina.cn 删除。<br> 本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:29:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/oneflow/blog/10140417</guid>
            <link>https://my.oschina.net/oneflow/blog/10140417</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[华为与美团达成合作，正式启动鸿蒙原生应用开发]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>华为迎来又一个鸿蒙生态的重要合作伙伴，宣布与美团以 HarmonyOS 为基础进行产业创新、技术应用、商业发展等方面展开全面合作，全力支持美团启动开发鸿蒙原生应用工作。</p><p>自 9 月 25 日华为宣布全新 HarmonyOS NEXT 蓄势待发、鸿蒙原生应用全面启动以来，已有金融、旅行、社交等多个领域的企业和开发者陆续宣布加入鸿蒙生态。此次美团成为最新加速融入鸿蒙生态的行业头部伙伴，形成「鸿蒙千帆起」的景象。</p><p>周一，在北京举行的「鸿蒙原生应用开发启动仪式」上，华为终端云服务总裁朱勇刚表示：「很高兴美团成为鸿蒙生态重要的合作伙伴，鸿蒙正在致力于打造一个‘一切皆服务，万物可分享’的新生态。鸿蒙独有的分布式技术，以及一次开发、多端部署，能让美团的服务在手机、平板、车机等设备上无缝流转，为用户提供场景化、智慧化的「服务合时宜」新体验。未来华为希望与美团基于端到端的鸿蒙生态，持续源源不断地的创新，助力美团等互联网企业获取新流量和商机，创造更大的商业价值。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-36c3813f9e9377dea1c3a86232a7923485a.png" referrerpolicy="no-referrer"></p><p>作为扎根本地的中国科技零售企业，美团通过「零售+科技」的战略践行「帮大家吃得更好，生活更好」的公司使命。美团高级副总裁李树斌表示：「美团始终以客户为中心，不断加大在新技术上的研发投入，这与华为鸿蒙操作系统在前沿领先领域的探索努力不谋而合。我们希望与华为共同努力，在鸿蒙系统生态里为用户提供更好的服务和体验。」</p><p>作为鸿蒙生态社交领域的重要伙伴，美团与华为早有深厚的鸿蒙生态合作基础，此前美团就已基于鸿蒙系统特点和用户需求，有针对性地率先开发和适配了多项功能，包括上线华为手机桌面「万能卡片」元服务、Push Kit 实况窗功能等。</p><p>未来，华为将携手美团等更多合作伙伴，持续共同建设鸿蒙生态，依托于 HarmonyOS 原生应用在全场景多设备高效协同、原生智能、更强大的 AI 能力、更高的安全和隐私保护体验等独特的技术优势，展开全方位深层次的合作，为消费者带来更流畅、更智能、更安全的服务体验。</p><p>数据显示，截至今年 8 月份，鸿蒙生态设备数量超过 7 亿台，已有 220 万开发者投入到鸿蒙生态的开发，华为始终与伙伴共享鸿蒙生态新机遇，共创万物互联新未来。</p><p>延伸阅读</p><ul><li><a href="https://www.oschina.net/news/266107">多家互联网公司急招鸿蒙程序员</a></li><li><a href="https://www.oschina.net/news/265725">美团招兵买马，拟开发鸿蒙系统 App</a></li><li><a href="https://www.oschina.net/news/261747">深圳信息职业技术学院开设「开源鸿蒙班」</a></li><li><a href="https://www.oschina.net/news/252658">HarmonyOS NEXT：使用全自研内核</a></li><li><a href="https://www.oschina.net/news/252385/harmonyos-4">华为正式发布 HarmonyOS 4</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266352</guid>
            <link>https://www.oschina.net/news/266352</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Java 原生编译的 Solon 回忆录]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#24292e; text-align:start">最近和<code>@雨韵诗泽</code>、<code>@读钓</code>两个小伙伴一起（主要是他们两在出力），适配了<span>&nbsp;</span><strong>Solon Native</strong><span>&nbsp;</span>的第一个开源项目：<a href="https://gitee.com/dromara/neutrino-proxy">dromara/neutrino-proxy</a><span>&nbsp;</span>（里程碑案例啊！有点修行大成的味道了！）。总体来说：</p><ul><li>适配调整完后，代码变化不太大</li><li>整个过程是很麻烦的。因为 graalvm native image 社区版不能调试，只能不断试（发现缺什么，就补什么配置）</li></ul><h3>1、缘起</h3><p style="color:#24292e; text-align:start"><span style="background-color:#f1c40f">2021 年的深秋</span>，有个叫<span>&nbsp;</span><code>@馒头虫</code><span>&nbsp;</span>的男人。跑过来讲，他有个项目需求是（给一个美国大厂做的）：存放空间只有 100M，内存只有 100M，在硬件里运行一个管理界面系统。他研究了 spring native，因为它的基础就太大没过；研究了 go，做复杂的界面系统不好预期没过。所以选择尝试 solon。</p><p style="color:#24292e; text-align:start">于是他种下了一颗 solon native 的种子。开始浇水、施肥。前后一两个月的时间，真的也开花了（最后好像只有 53m 大小）。这 365 万字省去，他怎么不哭呢？</p><p style="color:#24292e; text-align:start">这个男人总结出了三条经验：</p><ul><li>所有的反射需要提前登记（放到特定的配置文件里），并通过配置获取反射导引（比如一个类有哪些字段，哪些方法）</li><li>所有的资源文件获取需要提前登记（放到特定的配置文件里）</li><li>所有的动态编译、类字节码，不能用</li></ul><p style="color:#24292e; text-align:start">说起来，<a href="https://gitee.com/noear/solon">Solon 框架</a><span>&nbsp;</span>真的是好啊（按那男人的讲法：小是真的小，快是真的快）：</p><ul><li>启动快 5 ～ 10 倍；</li><li>qps 高 2～ 3 倍；</li><li>运行时内存节省 1/3 ~ 1/2；</li><li>打包可以缩到 1/2 ~ 1/10；</li></ul><h3>2、认识 APT</h3><p style="color:#24292e; text-align:start">后面很长的时间，我没再碰它（主要是无知，无从下手。懵！）。偶然的一天，路过 mybatis-plus 4.x 项目仓库，看到 APT 这几个字眼。我对 java 确实是无知，百度后才知道神器 lombok 就是基于 APT 实现的。然后，我想起了那个男人总结的三条经验：</p><ul><li>所有的反射需要提前登记</li><li>所有的资源文件获取需要提前登记</li><li>所有的动态编译、类字节码，不能用</li></ul><p style="color:#24292e; text-align:start">是不是可以借助 APT，去提前生成类的代理代码，去完成资源文件、反射的登记？我估计是行的。</p><p style="color:#24292e; text-align:start"><span style="background-color:#f1c40f">2023 年的初春</span>，花了一周时间，把类的代理用 APT 在编译时生成了。开心是开心的。但是，怎样获取需要代理的类，成了一个不解的题。路很长。然后，暂时没有然后了！</p><h3>3、认识 AOT</h3><p style="color:#24292e; text-align:start">好多年前就听过 AOT，大概知道它是干嘛的。但是，还是一脸懵。</p><p style="color:#24292e; text-align:start"><span style="background-color:#f1c40f">2023 年的春后</span>，有个叫<span>&nbsp;</span><code>@李总</code><span>&nbsp;</span>的男人。他说，我有个项目想要用 solon 的原生编译，而且可以叫个人帮忙搞。最后出现的男人叫<span>&nbsp;</span><code>@读钓</code>，不知道是<span>&nbsp;</span><code>@李总</code><span>&nbsp;</span>忽悠过来的，还是我把他忽悠过来的（后来，据他说是自己跑来的）。他说，我们应该 A,B,C...这么这么搞！</p><p style="color:#24292e; text-align:start">还有个加强版的 AOT。原来如此，原来如此：</p><ul><li>在编译后 -&gt; 运行项目并获取运行中的信息 -&gt; 然后完成各种预编译和登记 -&gt; 再进行原生编译</li><li>一气呵成</li></ul><p style="color:#24292e; text-align:start">这个男人从春天搞到了夏天。成了！（当中略过 365 万字...），一直搞，不知道有没有洗过澡， 有没有换过衣服。</p><h3>4、我们发布第一个 Solon Native 版本</h3><p style="color:#24292e; text-align:start"><span style="background-color:#f1c40f">2023 年的夏天</span>，有个新男人来。说是要用 Solon Native。我心里其实没底，原生这东西太难用了。必须得忍住不哭才行。后来他招乎也没打，跑了。</p><p style="color:#24292e; text-align:start">真的是太难用了：</p><ul><li>目前没有哪个框架是开箱即用的（Spring Native 和 Quarkus 也一样）</li><li>框架不一定把生态内的所有包都适配好了</li><li>第三方的包，框架没法照顾到。只能自己试着做些补充登记（没法调试，只能尝试或实验）</li><li>随便升级某个第三方包，就可能不兼容了（需要重新适配）</li></ul><h3>5、你信轮回？</h3><p style="color:#24292e; text-align:start"><span style="background-color:#f1c40f">2023 年的深秋</span>，又是一个深秋。男人<span>&nbsp;</span><code>@雨韵诗泽</code>，说想把他的<span>&nbsp;</span><a href="https://gitee.com/dromara/neutrino-proxy">dromara/neutrino-proxy</a><span>&nbsp;</span>开源项目搞成原生编译的。我说，那得忍住不哭才行。他说，他不会哭（其实，他动得不多。哈哈）。<code>@读钓</code>又开始忙了。</p><p style="color:#24292e; text-align:start">说起来，<code>@读钓</code><span>&nbsp;</span>是从春天干到了秋天。终于成了：<a href="https://www.oschina.net/news/264550/solon-2-5-12-released">《Solon v2.5.12 发布，Java 原生编译再起》</a>。我们也是正经的支持 Java 原生编译的生态型框架了。且是，国产的。</p><p style="color:#24292e; text-align:start"><span style="background-color:#ffffff; color:#24292e">开源，让很多人的愿望和努力汇聚一处，也记录了共同的回忆。</span></p><p style="color:#24292e; text-align:start">人生路，且短且长，只怪情深缘浅，你信轮回？</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 01:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266350</guid>
            <link>https://www.oschina.net/news/266350</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[苹果将禁止「摇一摇」跳转广告]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tfcaijing.com%2Farticle%2Fpage%2F474a676e737050677a746a63653436332f646c3554773d3d" target="_blank">据时代财经报道</a></u>，互联网大厂内部人士常乐年称，11 月以来，苹果公司已通知国内多家头部 App 要求它们移除陀螺仪权限，摇一摇跳转广告被禁止。</p><p>据报道，11 月以来，苹果公司已通知在线视频软件、短视频软件、音频软件、邮箱软件等多种类型的 App，<strong>要求它们取消摇一摇跳转广告的功能</strong>。常乐年所在公司的 App 也在通知的范围内。他透露，接下来公司可能会发布新版本 App，在苹果的 App Store 上架，新版本将没有摇一摇跳转广告，具体发布时间还不确定。</p><p>另一位广告从业者也证实了这一消息，他的客户也是互联网大厂，旗下有行业头部 App。他说，收到通知的不只是头部 App，还有很多其他的 App，范围很广。</p><p>摇一摇功能调用的是陀螺仪权限，这是一种很早就有的功能，可以用来抢电视红包、识别歌曲等，但现在被用来做广告跳转，而有些手机没有陀螺仪权限开关，用户无法自行关闭。</p><p><img src="https://static.oschina.net/uploads/space/2023/1114/084659_fhVb_2720166.png" referrerpolicy="no-referrer"></p><p>一位手机大厂的工作人员说，这种跳转是 App 开发出来的商业模式，手机厂商很难做系统性的调整。</p><p>中国信息通信研究院此前联合华为、小米、OPPO、阿里巴巴等企业制定了团体标准 T / TAF 078.7—2022，于 2022 年 11 月由电信终端产业协会发布实施，该标准进一步细化了 App 信息窗口通过「摇一摇」等方式触发页面或跳转至第三方应用的相关参数，提出「摇一摇」动作的设备加速度应不小于 15m/s2，转动角度不小于 35°，操作时间不少于 3s 等系列参考数值。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 00:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266344</guid>
            <link>https://www.oschina.net/news/266344</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Kotlin 1.9.20 现已发布，KMP 进入稳定阶段]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       defaultNoSetting
            " id="js_content"><section style="font-size: 15px;box-sizing: border-box;font-style: normal;font-weight: 400;text-align: justify;margin-bottom: 0px;" data-mpa-powered-by="yiban.io"><section style="text-align: left;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="margin: 30px 0% 10px;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;background-color: rgb(237, 238, 242);align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="display: flex;width: 100%;flex-flow: column;box-sizing: border-box;" powered-by="xiumi.us"><section style="z-index: auto;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: flex;flex-flow: row;justify-content: flex-start;transform: translate3d(18px, 0px, 0px);-webkit-transform: translate3d(18px, 0px, 0px);-moz-transform: translate3d(18px, 0px, 0px);-o-transform: translate3d(18px, 0px, 0px);margin: -16px 0% 0px;box-sizing: border-box;"><section style="display: inline-block;vertical-align: top;width: 15%;flex: 0 0 auto;height: auto;align-self: flex-start;box-sizing: border-box;"><section style="text-align: center;margin: -16px 0px 0px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="1" data-s="300,640" src="https://oscimg.oschina.net/oscnet/857c41ff-cddd-4928-8250-1a8458f95df4.png" data-w="707" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: top;width: auto;flex: 0 0 auto;align-self: flex-start;min-width: 10%;max-width: 100%;height: auto;box-sizing: border-box;"><section style="transform: translate3d(5px, 0px, 0px);-webkit-transform: translate3d(5px, 0px, 0px);-moz-transform: translate3d(5px, 0px, 0px);-o-transform: translate3d(5px, 0px, 0px);box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;color: rgb(115, 119, 173);padding: 0px 7px;line-height: 1.2;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="box-sizing: border-box;"><strong style="box-sizing: border-box;">记得加关注， Kotlin 之路不迷路！</strong></span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;font-size: 12px;color: rgb(221, 18, 101);line-height: 1.2;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="box-sizing: border-box;">&nbsp; &nbsp; Kotlinlang.org</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section></section></section></section></section></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">Kotlin 1.9.20 版本已发布，适用于所有目标的<strong style="box-sizing: border-box;"> K2 编译器</strong>现已进入<strong style="box-sizing: border-box;">测试版</strong>阶段，<strong style="box-sizing: border-box;">Kotlin Multiplatform </strong>现已进入<strong style="box-sizing: border-box;">稳定阶段</strong><sup style="box-sizing: border-box;">1</sup>。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">以下是此版本的一些亮点：</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><ul class="list-paddingleft-1" style="list-style-type: disc;box-sizing: border-box;padding-left: 40px;list-style-position: outside;"><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">适用于所有目标的 K2 现已进入测试版阶段</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">稳定的 Kotlin Multiplatform</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">用于设置多平台项目的新默认层次结构模板</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Kotlin Multiplatform 中全面支持 Gradle 配置缓存</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Kotlin/Native 中默认启用自定义内存分配器</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Kotlin/Native 中垃圾回收器的性能改进</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Kotlin/Wasm 中的新目标和重命名目标，支持最新的 Wasm GC</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Kotlin/Wasm 的标准库中支持 WASI API</p></li></ul></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">有关完整的更改列表，请参阅&nbsp;<strong style="box-sizing: border-box;">Kotlin 1.9.20 最新变化</strong><sup style="font-size: 11px;box-sizing: border-box;">2</sup>或&nbsp;<strong style="box-sizing: border-box;">GitHub 上的版本说明</strong><sup style="font-size: 11px;box-sizing: border-box;">3</sup>。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="text-align: center;justify-content: center;display: flex;flex-flow: row;margin: 10px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 48px;align-self: center;flex: 0 0 auto;height: auto;box-sizing: border-box;"><section style="margin-top: 10px;margin-bottom: 10px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img data-ratio="1" data-s="300,640" data-w="500" src="https://oscimg.oschina.net/oscnet/6bfa4c27-1a25-41fd-9125-da620c956bf6.png" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: auto;align-self: center;flex: 100 100 0%;height: auto;padding: 0px 0px 0px 10px;box-sizing: border-box;"><section style="text-align: left;margin: 10px 0px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgb(42, 8, 69);font-size: 24px;line-height: 1.2;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">适用于所有目标的新 Kotlin K2 编译器已进入测试版阶段</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 2px 0px 8px;box-sizing: border-box;" powered-by="xiumi.us"><section style="background-color: rgb(120, 85, 245);height: 1px;box-sizing: border-box;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">JetBrains 的 Kotlin 团队正在继续稳定新 K2 编译器，这将带来重大性能改进，加快新语言功能的开发，统一 Kotlin 支持的所有平台，并为多平台项目提供更好的架构。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;"></strong></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">随着 1.9.20 版本的发布，新 K2 编译器已面向所有平台进入测试版阶段：JVM、Native、JS 和 Wasm。这意味着您现在可以在任何 Kotlin 项目中试用 K2。</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">Kotlin 团队通过成功编译数十个用户和内部项目，确保了新编译器的质量。大量用户也参与了稳定过程，在他们的项目中试用新 K2 编译器，并报告他们发现的任何问题。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">Kotlin 1.9.20 版本还在 kapt 编译器插件中引入了 K2 支持。</strong>&nbsp;现在，所有必要的 Kotlin 编译器插件都支持 K2。这些包括 kapt、serialization、AtomicFU、Lombok、SAM with receiver、all-open、no-arg、jvm-abi-gen、Android Lint 和 Jetpack Compose 编译器插件。支持 K2 的 Kotlin Symbol Processing (KSP) 将在 Kotlin 1.9.20 发布后一周内发布。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">如果您使用任何其他编译器插件，请查看相关文档以了解其是否与 K2 兼容。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">下一站是 Kotlin 2.0</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">Kotlin 的下一个主要版本是 2.0.0，新 K2 编译器将作为默认的稳定编译器面向所有目标提供。</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">为了尽快解决发现的任何问题，我们计划频繁发布一系列小型 Kotlin 2.0 稳定版本。这些版本将包括 Beta1、Beta2、Beta3、RC1 和 RC2。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">在 Kotlin 2.0.0-RC1 发布时，我们计划确保与其他版本 Kotlin 编译器编译的代码的二进制文件兼容性，并消除使用 K2 编译的二进制文件时的中毒现象。这样您就能够在生产环境中使用新的 K2 编译器。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">参与进来：立即塑造 Kotlin 2.0 并试用 K2 编译器</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">K2 编译器即将完成其稳定过程，并在 Kotlin 2.0 中默认启用。至关重要的是，我们呼吁尽可能多的开发者试用 K2 并报告任何潜在问题。&nbsp;</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">您的反馈将帮助我们解决任何问题，并确保 K2 即使在最复杂的场景中也能完美运行。只需使用 K2 对您的项目进行一次编译就可以为达到 Kotlin 2.0 里程碑做出显著贡献。<strong style="box-sizing: border-box;"> 立即试用 K2！</strong><sup style="box-sizing: border-box;">4</sup></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="text-align: center;justify-content: center;display: flex;flex-flow: row;margin: 10px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 48px;align-self: center;flex: 0 0 auto;height: auto;box-sizing: border-box;"><section style="margin-top: 10px;margin-bottom: 10px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img data-ratio="1" data-s="300,640" data-w="500" src="https://oscimg.oschina.net/oscnet/6bfa4c27-1a25-41fd-9125-da620c956bf6.png" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: auto;align-self: center;flex: 100 100 0%;height: auto;padding: 0px 0px 0px 10px;box-sizing: border-box;"><section style="text-align: left;margin: 10px 0px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgb(42, 8, 69);font-size: 24px;line-height: 1.2;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">如何安装 Kotlin 1.9.20</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 2px 0px 8px;box-sizing: border-box;" powered-by="xiumi.us"><section style="background-color: rgb(120, 85, 245);height: 1px;box-sizing: border-box;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">如果您已经在使用<strong style="box-sizing: border-box;">&nbsp;IntelliJ IDEA</strong><sup style="box-sizing: border-box;">5</sup>&nbsp;2023.1 或 2023.2，IDE 会自动建议将 Kotlin 更新到 1.9.20。您也可以按照<strong style="box-sizing: border-box;">这些说明</strong><sup style="box-sizing: border-box;">6</sup>手动更新。IntelliJ IDEA 2023.3 将包含 Kotlin 1.9.20 插件。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">对于 Android Studio Hedgehog (231) 和 Iguana (232)，Kotlin 1.9.20 插件将包含在即将推出的 Android Studio 更新中。如果需要命令行编译器，请从<strong style="box-sizing: border-box;">&nbsp;GitHub 版本页面</strong><sup style="box-sizing: border-box;">7</sup>下载。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">如果您遇到任何问题</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><ul class="list-paddingleft-1" style="list-style-type: disc;box-sizing: border-box;padding-left: 40px;list-style-position: outside;"><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">在&nbsp;<strong style="box-sizing: border-box;">Slack</strong><sup style="font-size: 11px;box-sizing: border-box;">8</sup>（<strong style="box-sizing: border-box;">获得邀请</strong><sup style="font-size: 11px;box-sizing: border-box;">9</sup>）上获取帮助。</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">向我们的问题跟踪器&nbsp;<strong style="box-sizing: border-box;">YouTrack</strong><sup style="box-sizing: border-box;">10</sup>&nbsp;报告问题。</p></li></ul><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="text-align: center;justify-content: center;display: flex;flex-flow: row;margin: 10px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 48px;align-self: center;flex: 0 0 auto;height: auto;box-sizing: border-box;"><section style="margin-top: 10px;margin-bottom: 10px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img data-ratio="1" data-s="300,640" data-w="500" src="https://oscimg.oschina.net/oscnet/6bfa4c27-1a25-41fd-9125-da620c956bf6.png" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: auto;align-self: center;flex: 100 100 0%;height: auto;padding: 0px 0px 0px 10px;box-sizing: border-box;"><section style="text-align: left;margin: 10px 0px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgb(42, 8, 69);font-size: 24px;line-height: 1.2;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">特别感谢我们的 EAP Champions 🥇👏</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 2px 0px 8px;box-sizing: border-box;" powered-by="xiumi.us"><section style="background-color: rgb(120, 85, 245);height: 1px;box-sizing: border-box;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">Zac Sweers、Alexander Nozik、Oleg Yukhnevich、Josh Friend、Łukasz Wasylkowski、Simon Marquis、Benoit ‘BoD’ Lubek、Yang、Rustam Musin、Russell Wolf、Jake Wharton、Rick Clephas、Artyom Shendrik、Johannes Svensson、Sterling Albury、David Lopez。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="text-align: center;justify-content: center;display: flex;flex-flow: row;margin: 10px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 48px;align-self: center;flex: 0 0 auto;height: auto;box-sizing: border-box;"><section style="margin-top: 10px;margin-bottom: 10px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img data-ratio="1" data-s="300,640" data-w="500" src="https://oscimg.oschina.net/oscnet/6bfa4c27-1a25-41fd-9125-da620c956bf6.png" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: auto;align-self: center;flex: 100 100 0%;height: auto;padding: 0px 0px 0px 10px;box-sizing: border-box;"><section style="text-align: left;margin: 10px 0px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgb(42, 8, 69);font-size: 24px;line-height: 1.2;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">更多文章和视频</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 2px 0px 8px;box-sizing: border-box;" powered-by="xiumi.us"><section style="background-color: rgb(120, 85, 245);height: 1px;box-sizing: border-box;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;box-sizing: border-box;"><ul class="list-paddingleft-1" style="list-style-type: disc;box-sizing: border-box;padding-left: 40px;list-style-position: outside;"><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">「Kotlin 1.9.20 最新变化」文档：</p><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="color: rgb(0, 86, 150);font-size: 14px;box-sizing: border-box;">https://kotlinlang.org/docs/whatsnew1920.html</span></p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Kotlin 1.9.20 最新变化 YouTube 视频：</p><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(0, 86, 150);box-sizing: border-box;">https://youtu.be/Ol_96CHKqg8</span><br style="box-sizing: border-box;"></p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">K2 编译器将在 Kotlin 2.0 中进入稳定状态：</p><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(0, 86, 150);box-sizing: border-box;">https://blog.jetbrains.com/zh-hans/kotlin/2023/02/k2-kotlin-2-0/</span></p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Kotlin Multiplatform 已经稳定并且可以投入生产环境：</p><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="color: rgb(0, 86, 150);font-size: 14px;box-sizing: border-box;">https://blog.jetbrains.com/kotlin/2023/11/kotlin-multiplatform-stable/</span></p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Kotlin EAP Champion：</p><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(0, 86, 150);box-sizing: border-box;">https://blog.jetbrains.com/kotlin/2022/11/eap-champions/</span><br style="box-sizing: border-box;"></p></li></ul></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin-top: 10px;margin-bottom: 10px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(120, 85, 245);padding: 10px;box-shadow: rgb(204, 204, 204) 0.2em 0.2em 0.3em;box-sizing: border-box;"><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">相关链接：</strong></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: left;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">1. Kotlin Multiplatform 现已进入稳定阶段：</span></p><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://blog.jetbrains.com/kotlin/2023/11/kotlin-multiplatform-stable/https://github.com/jetbrains/exposed</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: left;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">2. Kotlin 1.9.20 最新变化：&nbsp;</span></p><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">http://kotlinlang.org/docs/whatsnew1920.html</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">3. GitHub 上的版本说明：</span></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://github.com/JetBrains/kotlin/releases/tag/v1.9.20</span></p><p style="margin-bottom: 0px;font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;"><span style="font-size: 14px;">4. 立即试用 K2！：</span></p><p style="margin-bottom: 0px;font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;"><span style="font-size: 14px;color: rgb(51, 122, 183);">https://kotlinlang.org/docs/whatsnew1920.html</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">5. IntelliJ IDEA：</span></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://www.jetbrains.com.cn/idea/download/</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">6. 这些说明：</span></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://kotlinlang.org/docs/releases.html#update-to-a-new-release</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="text-align: left;white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">7. GitHub 版本页面:&nbsp;</span></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="color: rgb(51, 122, 183);font-size: 14px;text-align: left;box-sizing: border-box;">https://github.com/JetBrains/kotlin/releases/tag/v1.9.20</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="text-align: left;white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">8. Slack:&nbsp;</span></p><p style="text-align: left;white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">http://kotlinlang.slack.com/</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="text-align: left;white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">9. 获得邀请：</span></p><p style="text-align: left;white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://surveys.jetbrains.com/s3/kotlin-slack-sign-up</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="text-align: left;white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">10. YouTrack：</span></p><p style="text-align: left;white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://youtrack.jetbrains.com/issues/KT</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 10px 0px 0px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding: 0px 0px 0px 8px;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgb(125, 125, 125);font-size: 12px;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">本博文英文原作者：</p><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Andrey Polyakov</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section></section></section><section style="margin: 10px 0% 0px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;background-position: 97.529% 66.6681%;background-repeat: repeat;background-size: 171.01%;background-attachment: scroll;align-self: flex-start;flex: 0 0 auto;height: auto;background-image: url(&quot;https://oscimg.oschina.net/oscnet/0eddb263-e655-40fb-bb29-ad40b1263907.png&quot;);box-sizing: border-box;"><section style="text-align: justify;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;padding: 26px;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="margin: -9px 0px 7px;box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 16px;color: rgb(248, 248, 248);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">这就是 Kotlin 编程语言</strong></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">简洁、跨平台、且有趣！</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 0px;box-sizing: border-box;" powered-by="xiumi.us"><section class="mp_profile_iframe_wrp" style="box-sizing: border-box;"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-id="Mzg4MzkxMzg3MQ==" data-pluginname="mpprofile" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/y4ibuu6gd7d4NyzPduLLqtqddBasicL77gAgbLQD89CyYm1n7icODFhBr3xMoloOA7yicfjR8Bv0oaRP3CJuRLIO4Q/0?wx_fmt=png" data-nickname="Kotlin 开发者" data-alias="" data-signature="现代、简洁、安全的编程语言，由 JetBrains 打造。面向服务器、Android、Web 和原生平台，提供多种在平台间重用代码的方式以实现高效编程。官网：kotlinlang.org" data-from="0" data-is_biz_ban="0"></mp-common-profile></section></section><section style="text-align: center;margin: 7px 0px 0px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;width: 45%;height: auto;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.4119760479041916" data-s="300,640" src="https://oscimg.oschina.net/oscnet/3798f3e4-8493-496c-9edb-4fd1944d295e.png" data-w="835" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section></section></section></section></section></section><p style="display: none;margin-bottom: 0px;"><mp-style-type data-value="10000"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - JetBrains（JetBrainsChina）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 11:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5494143/blog/10142143</guid>
            <link>https://my.oschina.net/u/5494143/blog/10142143</link>
            <author>
                <![CDATA[JetBrains 中国]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[JDK11 升级 JDK17 最全实践干货来了 | 京东云技术团队]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331338" target="_blank">从数据到大模型应用，11 月 25 日，杭州源创会，共享开发小技巧 <img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><h1><strong>1、前言</strong></h1><p>上篇文章给大家带来了<a href="https://my.oschina.net/u/4090830/blog/10111749">JDK8 升级 JDK11 的最全实践，</a>相信大家阅读后已经对 JDK11 有了比较深入的了解。2021 年 9 月 14 日，Oracle 发布了可以长期支持的 JDK17 版本，那么从 JDK11 到 JDK17，到底带来了哪些特性呢？亚毫秒级的 ZGC 效果到底怎么样呢？值得我们升级吗？而且升级过程会遇到哪些问题呢？带着这些问题，本篇文章将带来完整的 JDK11 升级 JDK17 最全实践。</p><h1><strong>2、为什么升级 JDK17</strong></h1><p><strong>1）长期支持版本</strong></p><p>JDK17 是 Oracle 官方在 2021 年 9 月 14 日发布的一个长期支持（LTS）版本，意味着它将获得长期的更新和支持，有助于保持程序的稳定性和可靠性。</p><p><strong>2）性能提升</strong></p><p>更好的垃圾回收器。综合评估，从 Java 8 升级到 Java 11，**G1GC 平均速度提升 16.1%，ParallelGC 为 4.5%****，**从 Java 11 升级到 Java 17，<strong>G1GC 平均速度提升 8.66%，ParallelGC 为 6.54%</strong>（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.optaplanner.org%2Fblog%2F2021%2F09%2F15%2FHowMuchFasterIsJava17.html" target="_blank">基于 OptaPlanner 的用例基准测试表明）</a></p><p>最大的亮点是带来了<strong>稳定版的 ZGC 垃圾回收器，达到亚毫秒级停顿。</strong></p><p><strong>3）新语法和特性</strong></p><p>Switch 表达式简化、Text Blocks 文本块、instanceof 的模式匹配升级和 NullPointerException 提示信息改进等</p><p>4）<strong>支持最新的技术和框架</strong></p><p>Spring framework6 和 Spring Boot3 都默认使用 Java 17 作为最低版本</p><h1><strong>3、升级后压测效果</strong></h1><blockquote><p><strong>先给出结论：</strong></p><p>1、JDK17 相对于 JDK8 和 JDK11，<strong>所有垃圾回收器的性能都有很明显的提升，特别是稳定版的 ZGC 垃圾回收器</strong></p><p>2、<strong>不论任何机器配置下，都推荐使用 ZGC</strong>，ZGC 的停顿时间达到亚毫秒级，吞吐量也比较高</p></blockquote><p><strong>我在 JDOS 平台上选择了不同配置的机器（2C4G、4C8G、8C16G），并分别使用 JDK8、JDK11 和 JDK17 进行部署和压测。</strong></p><p>整个压测过程限时 60 分钟，用 180 个虚拟用户并发请求一个接口，每次接口请求都创建 512Kb 的数据。最终产出不同 GC 回收器的各项指标数据，来分析 GC 的性能提升效果。</p><p><strong>以下是压测的性能情况：</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-07-18-46yVgvcZ9YUGOrY9x.png" alt="" referrerpolicy="no-referrer"></p><h1><strong>4、OracleJDK 和 OpenJDK 的选择</strong></h1><p>2021 年 9 月，Oracle 宣布 JDK17 可以免费商用，直到下一个 LTS 版本之后继续提供整整一年，同时 Oracle 将继续按照自 Java 9 以来的相同版本和时间表提供 GPL 下的 Oracle OpenJDK 版本。</p><p>2023 年 9 月，OracleJDK 发布了新的 LTS 版本 JDK21，这就意味着从<strong>2024 年 9 月开始，在生产环境使用 OracleJDK17 将需要付费。</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-01-20-01PLCD1wvvcxLRLNv.png" alt="" referrerpolicy="no-referrer"></p><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.oracle.com%2Fhk%2Fjava%2Ftechnologies%2Fdownloads%2F%23java17" target="_blank">https://www.oracle.com/hk/java/technologies/downloads/#java17</a></p><p>OracleJDK 和 OpenJDK 这两个之间没有真正的技术差别，因为针对 Oracle JDK 构建过程是基于 OpenJDK 的。自从 JDK11 开始，OracleJDK 和 OpenJDK 在功能上基本相同，所以推荐使用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjdk.java.net%2Farchive%2F" target="_blank">OpenJDK17</a> 或其他开源的 JDK 版本，这些开源版本都是基于 OpenJDK 构建并提供长期支持的,比如：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fadoptopenjdk.net%2F" target="_blank">AdoptOpenJDK</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevelopers.redhat.com%2Fproducts%2Fopenjdk%2Foverview" target="_blank">RedHatOpenJDK。</a></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-02-11-19DsSkxKErEDeigz2.png" alt="" referrerpolicy="no-referrer"></p><p>官方参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.oracle.com%2Fjava%2Fpost%2Foracle-jdk-releases-for-java-11-and-later" target="_blank">https://blogs.oracle.com/java/post/oracle-jdk-releases-for-java-11-and-later</a></p><h1><strong>5、JDK11 到 JDK17 带来了哪些新特性</strong></h1><h3><strong>5.1、JVM 改进</strong></h3><p>1、ZGC 垃圾回收器从实验性功能更改为<strong>正式产品功能</strong>，从 JDK11 引入以来，经过持续的迭代升级，目前已经足够稳定。<strong>需要手动开启，开启方式：-XX:+UseZGC</strong></p><p>2、G1 垃圾回收器仍然作为默认垃圾回收器，进行改进升级，主要包括可中止的混合收集集合、NUMA 可识别内存分配等</p><p>3、JDK14 开始删除 CMS 垃圾回收器</p><p>4、JDK14 开始弃用 ParallelScavenge 和 SerialOld GC 的组合使用</p><p>5、JDK15 禁用偏向锁，默认禁用：-XX:+UseBiasedLocking</p><p>6、NullPointerException 提示信息改进</p><p>JDK14 以前的出现 NullPointerException 时，只能定位到所在异常行，无法定位具体是哪个变量。改进后的 NullPointerException，可以清晰描述具体变量，提升了空指针异常的可读性。</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-27-10-50TTuaDvegXKr9SAo.png" alt="" referrerpolicy="no-referrer"></p><h3><strong>5.2、新语法特性</strong></h3><h4><strong>5.2.1、Switch 表达式简化</strong></h4><p>switch 表达式带来了简化式的编码方式，提供了新的分支切换方式，即 -&gt; 符号，右则表达式方法体在执行完分支方法之后，自动结束 switch 分支，同时 -&gt; 右则方法块中可以是表达式、代码块或者是手动抛出的异常</p><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F361" target="_blank">https://openjdk.org/jeps/361</a></p><p><strong>传统写法</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-17-22rnaBICUHwCBlYZf.png" alt="" referrerpolicy="no-referrer"></p><p><strong>新写法</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-10-18Z48ZmbyE6jT10uWqP.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.2、Text Blocks 文本块</strong></h4><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F378" target="_blank">https://openjdk.org/jeps/378</a></p><p>通过编写 """，来减少转义字符和换行符，达到简化代码和提高代码可读性的目的</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-18-16tXnkRnYOGkQhTMS.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.3、Record 类型</strong></h4><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F395" target="_blank">https://openjdk.org/jeps/395</a></p><p>record 是 JDK 14 引入的关键字，用于声明不可变的数据类。它适用于存储纯粹的值类型数据，如接口传输数据、座标点和只读的日志记录。与 lombok 相比，record 简化了定义纯粹数据类型的过程。由于 record 类是不可变的，成员变量只能设置一次且无法更改，无需提供显式的 setter() 方法。</p><p><strong>1、定义 Point 类，使用关键字 record，未定义 get/set</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-25-19-50LjIj50MDXubzNv07.png" alt="" referrerpolicy="no-referrer"></p><p><strong>2、查看编译后的字节码文件</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-12-05MfRyF9o9FOD120oS.png" alt="" referrerpolicy="no-referrer"></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-12-077FA41CoAIm41MkgIY.png" alt="" referrerpolicy="no-referrer"></p><p><strong>3、使用 Point 类</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-12-11LdZCsODuD8JpjE0.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.4、instanceof 的模式匹配升级</strong></h4><ul><li>instanceof 类型判断再也不需要强制转换</li></ul><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F394" target="_blank">https://openjdk.org/jeps/394</a></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-25-18-20mhLGcH20q20N25D0a.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.5、密封的类和接口</strong></h4><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F409" target="_blank">https://openjdk.org/jeps/409</a></p><p>JDK15 开始，引入了 sealed 普通类或接口类，这些类只允许被指定的类或者 interface 进行扩展和实现。</p><p>使用修饰符 sealed，您可以将一个类声明为密封类。密封的类使用关键字 permits 列出可以直接扩展它的类。子类可以是最终的，非密封的或密封的</p><p>比较实用的一个特性，可以用来限制类的层次结构</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-19-23EeeAvjyEjufkdfY.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.6、其他优化和升级</strong></h4><p>感兴趣的同学，推荐阅读 OpenJDK 官方文档说明，从 JDK11 到 JDK17 的改动： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fprojects%2Fjdk%2F17%2Fjeps-since-jdk-11" target="_blank">https://openjdk.org/projects/jdk/17/jeps-since-jdk-11</a></p><h1><strong>6、升级步骤</strong></h1><h3><strong>6.1、JDK 选择</strong></h3><p>OpenJDK17 下载：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjdk.java.net%2Farchive%2F" target="_blank">https://jdk.java.net/archive/</a></p><p>行云镜像：jdt-base-tomcat/java-jdt-centos7.4-openjdk-17.0.2-tomcat8.0.53</p><h3><strong>6.2、pom 编译配置升级</strong></h3><p>maven 编译所需 JDK 升级至 17</p><pre><code>&lt;properties&gt;
    &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
&lt;/properties&gt;

</code></pre><h3><strong>6.3、SpringBoot 升级</strong></h3><p>SpringBoot 版本升级到<strong>2.7.15</strong>，Spring 版本升级为<strong>5.3.29</strong></p><p><strong>为什么不升级到 SpringBoot3？</strong></p><p>Spring Boot 3.0 最低要求 Java 17，SpringBoot3.0 带来了很多变化，和 SpringBoot2 差异较大。 考虑到公司很多中间件都是基于 SpringBoot2 构建的，所以此处推荐升级到 SpringBoot2 的最高版本 2.7.15。</p><p><strong>POM 升级</strong></p><pre><code>&lt;parent&gt;
 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
 &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
 &lt;version&gt;2.7.15&lt;/version&gt;
&lt;/parent&gt;

</code></pre><p>也可以通过设置 dependencyManagement 的方式：</p><pre><code>&lt;properties&gt;
    &lt;!-- 框架版本配置--&gt;
    &lt;springboot-version&gt;2.7.15&lt;/springboot-version&gt;
    &lt;springframework.version&gt;5.3.29&lt;/springframework.version&gt;
&lt;/properties&gt;  

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
            &lt;version&gt;${springboot-version}&lt;/version&gt;
            &lt;scope&gt;import&lt;/scope&gt;
            &lt;type&gt;pom&lt;/type&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;
            &lt;version&gt;${springframework.version}&lt;/version&gt;
            &lt;scope&gt;import&lt;/scope&gt;
            &lt;type&gt;pom&lt;/type&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

</code></pre><p>参考：</p><p>spring 升级指南： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-framework%2Fwiki%2FSpring-Framework-Versions" target="_blank">https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions</a></p><p>springboot 版本官网： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspring.io%2Fprojects%2Fspring-boot%23learn" target="_blank">https://spring.io/projects/spring-boot#learn</a></p><p><strong>循环依赖问题</strong></p><p>SpringBoot 升级到 2.7.15 后，如果应用中存在循环依赖的问题，启动时会报如下错误：</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-22-10-48Z10IRCapBcpKAVDi.png" alt="" referrerpolicy="no-referrer"></p><p><strong>原因</strong>：官方文档不鼓励循环依赖引用，默认情况下是禁止的</p><p><strong>解决方案：</strong></p><p>第一种：推荐更新应用中 bean 的依赖关系来解决</p><p>第二种：配置文件中加入以下配置，<strong>为了和旧版本保持一致，此配置推荐添加</strong></p><pre><code>#放开循环依赖
spring.main.allow-circular-references=true

</code></pre><h3><strong>6.4、常用中间件升级</strong></h3><h4><strong>6.4.1、Lombok 版本升级到 1.18.20 以上</strong></h4><pre><code>&lt;dependency&gt;
 &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
 &lt;artifactId&gt;lombok&lt;/artifactId&gt;
 &lt;version&gt;1.18.20&lt;/version&gt;
&lt;/dependency&gt;

</code></pre><p>如果不升级，编译时会报错如下：</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-13-20-01itBREuaDZdAzrpZ.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>6.4.2、swgger 问题，springfox3.0.0 和 springboot2.7 版本不兼容</strong></h4><p><strong>异常：</strong></p><pre><code>Failed to start bean 'documentationPluginsBootstrapper'; nested exception is java.lang.NullPointerException: 
Cannot invoke "org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.getPatterns()" because "this.condition" is null

</code></pre><p><strong>解决方案：</strong></p><pre><code>/**
 * 增加如下配置可解决 Spring Boot 2.7.15 与 Swagger 3.0.0 不兼容问题
 **/
@Bean
public BeanPostProcessor springfoxHandlerProviderBeanPostProcessor() {
return new BeanPostProcessor() {

@Override
 public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
if (bean instanceof WebMvcRequestHandlerProvider || bean instanceof WebFluxRequestHandlerProvider) {
                customizeSpringfoxHandlerMappings(getHandlerMappings(bean));
            }
return bean;
}

private &lt;T extends RequestMappingInfoHandlerMapping&gt; void customizeSpringfoxHandlerMappings(List&lt;T&gt; mappings) {
            List&lt;T&gt; copy = mappings.stream().filter(mapping -&gt; mapping.getPatternParser() == null).collect(Collectors.toList());
            mappings.clear();
            mappings.addAll(copy);
        }

@SuppressWarnings("unchecked")
private List&lt;RequestMappingInfoHandlerMapping&gt; getHandlerMappings(Object bean) {
try {
                Field field = ReflectionUtils.findField(bean.getClass(), "handlerMappings");
                field.setAccessible(true);
return (List&lt;RequestMappingInfoHandlerMapping&gt;) field.get(bean);
            } catch (IllegalArgumentException | IllegalAccessException e) {
throw new IllegalStateException(e);
            }
        }
    };
}

</code></pre><p>参考：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F950787" target="_blank">https://developer.aliyun.com/article/950787</a></p><h4><strong>6.4.3、AKS 升级（针对直接从 JDK8 升级的情况）</strong></h4><p><strong>异常</strong>：Causedby: java.lang.NoClassDefFoundError: javax/xml/bind/JAXBException</p><p><strong>原因</strong>：Java11 删除了 Java EE modules，其中就包括 java.xml.bind (JAXB)。</p><p><strong>解决方案：</strong></p><p>手动引入如下包即可</p><pre><code>&lt;!-- API, java.xml.bind module --&gt; 
&lt;dependency&gt;
      &lt;groupId&gt;jakarta.xml.bind&lt;/groupId&gt;
      &lt;artifactId&gt;jakarta.xml.bind-api&lt;/artifactId&gt;
      &lt;version&gt;2.3.2&lt;/version&gt;
&lt;/dependency&gt; 
&lt;!-- Runtime, com.sun.xml.bind module --&gt;
&lt;dependency&gt;
       &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
       &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
       &lt;version&gt;2.3.2&lt;/version&gt;
&lt;/dependency&gt;

</code></pre><h4><strong>6.4.4、Concrete 配置中心阻塞升级</strong></h4><p>使用 Concrete 时，启动时异常：</p><pre><code> Unable to make field private static final java.lang.reflect.Method jdk.proxy2.$Proxy97.m0 accessible: 
 module jdk.proxy2 does not "opens jdk.proxy2" to unnamed module @61d47554

</code></pre><p><strong>原因：</strong></p><p>分析下 Concrete 报错的原因，如下图，包内 com.wangyin.concrete.spring.ConcreteConfigProcessor#postProcessAfterInitialization（212 行）的实现逻辑</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-14-00LgxgUIrSYEUTxjm.png" alt="" referrerpolicy="no-referrer"></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-13-44BFAP7OjBiZqyaDb.png" alt="" referrerpolicy="no-referrer"></p><p><strong>解决方案：</strong></p><p>1、在 JVM 启动参数中设置--add-opens jdk.proxy2 来开启私有字段的访问，但因为动态代理生成的包名是随机不明确的，<strong>所以这种方案不可行</strong>。JDK 官方文档也明确表示不支持访问动态代理内部的随机字段。官方说明：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcr.openjdk.org%2F%7Emr%2Fjigsaw%2Fspec%2Fapi%2Fjava%2Flang%2Freflect%2FProxy.html" target="_blank">https://cr.openjdk.org/~mr/jigsaw/spec/api/java/lang/reflect/Proxy.html</a></p><p>2、代码修改，只需把 f.setAccessible(true) 移到 Modifier.isStatic(f.getModifiers()) 的判断下方即可。原因是方法 Modifier.isStatic(f.getModifiers()) 本来就要跳过静态字段，这样修改直接避免了访问。<strong>推动 concrete 团队修复问题或更换使用 Ducc 配置中心</strong></p><h3><strong>6.5、JVM 启动参数配置</strong></h3><h4><strong>6.5.1、开启 ZGC</strong></h4><p><strong>启动参数中配置：</strong>-XX:+UseZGC</p><p>移除-XX:ConcGCThreads，行云部署下 JVM 参数配置需要清除</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-17-15-14Lyy3vSkGQSvlvGe.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>6.5.2、不同中间件所需启动参数</strong></h4><p>升级 JDK17 后，项目启动时可能会遇到如下两种类型的异常：</p><p>1、cannot access class sun.util.calendar.ZoneInfo (in module java.base) because <strong>module java.base</strong> does not <strong>export sun.util.calendar</strong> to unnamed module @0x2611f533</p><p>2、Unable to make field final int java.math.BigInteger.signum accessible: <strong>module java.base</strong> does not "<strong>opens java.math</strong>" to unnamed module @525f1e4e</p><p><strong>异常原因：</strong></p><p>自从 JDK9 中引入了模块化功能后，再到 JDK17，对于包扫描和反射的权限控制更加的严格。常见的库比如（Spring）大量用到包扫描和反射，所以常出现此错误。</p><p><strong>解决方案：</strong></p><p>一个粗暴的解决办法是将没开放的 module 强制对外开放，即保持和 Java9 之前的版本一致。</p><ul><li>--add-exports 导出包，意味着其中的所有公共类型和成员都可以在编译和运行时访问。</li><li>--add-opens 打开包，意味着其中的所有类型和成员（不仅是公共类型）都可以在运行时访问。</li></ul><p>主要区别在于<code>--add-opens</code>允许「深度反射」，即非公共成员的访问，才可以调用<code>setAccessible(true)</code></p><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F44056405%2Fwhats-the-difference-between-add-exports-and-add-opens-in-java-9" target="_blank">https://stackoverflow.com/questions/44056405/whats-the-difference-between-add-exports-and-add-opens-in-java-9</a></p><p><strong>SGM 需要加入：</strong></p><pre><code>--add-opens java.management/java.lang.management=ALL-UNNAMED 
--add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED 
--add-opens java.management/sun.management=ALL-UNNAMED

</code></pre><p><strong>R2M 需要加入：</strong></p><pre><code>--add-opens java.base/java.time=ALL-UNNAMED

</code></pre><p><strong>Ducc 需要加入：</strong></p><pre><code>--add-opens java.base/java.util.concurrent=ALL-UNNAMED
--add-opens java.base/java.util.concurrent.locks=ALL-UNNAMED
--add-opens java.base/java.security=ALL-UNNAMED
--add-opens java.base/jdk.internal.loader=ALL-UNNAMED
--add-opens java.management/com.sun.jmx.mbeanserver=ALL-UNNAMED 
--add-opens java.base/java.net=ALL-UNNAMED 
--add-opens java.base/sun.nio.ch=ALL-UNNAMED 

</code></pre><p><strong>AKS 需要加入：</strong></p><pre><code>--add-exports java.base/sun.security.action=ALL-UNNAMED
--add-opens java.base/java.lang=ALL-UNNAMED
--add-opens java.base/java.math=ALL-UNNAMED
--add-opens java.base/java.util=ALL-UNNAMED
--add-opens java.base/sun.util.calendar=ALL-UNNAMED

</code></pre><h3><strong>6.6、启动后的验证</strong></h3><p>1.推荐先升级 JDK11，再到 JDK17，一边升级一边进行验证观察</p><p>2.观察日志是否有异常，特别是上面说到的启动时异常</p><p>3.观察监控类软件，比如 SGM、UMP 等监控是否正常</p><p>4.推荐逐步有序切量，并做好常态化压测，防止影响核心业务</p><p>5.升级完成后，<strong>最好能做个全流程的功能测试，防止功能异常</strong></p><h1><strong>7、总结</strong></h1><blockquote><p>1、升级后，除了可以使用新的语法特性，最大的亮点是可以使用亚毫秒级停顿的 GC 性能（至少百倍的 GC 性能提升），所以 <strong>强烈建议升级到 JDK17</strong></p><p>2、整个升级过程并不复杂，主要涉及到中间件版本的升级和启动参数的配置</p></blockquote><p>如果还停留在 JDK8，推荐先升级 JDK11，再到 JDK17，具体升级步骤先参考我的上篇文章「<a href="https://my.oschina.net/u/4090830/blog/10111749">JDK8 升级 JDK11 最全实践干货来了</a>」，再参考本章中的升级步骤。</p><p>希望以上分享可以给大家带来实际的帮助，升级过程中如果遇到问题，欢迎大家在评论区回复。</p><blockquote><p>作者：京东科技，曲振富</p><p>来源：京东云开发者社区，转载请注明来源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 01:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10142895</guid>
            <link>https://my.oschina.net/u/4090830/blog/10142895</link>
            <author>
                <![CDATA[京东云开发者]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[【店滴云】兼容手机端再深化更新，手机端体验更好]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:center">【店滴云】兼容手机端再深化更新，手机端体验更好</p><p><span style="background-color:#ffffff; color:#40485b">&nbsp; &nbsp; &nbsp; &nbsp; 店滴云，让经营场所，更智能。围绕茶室、酒店、健身房、公寓、出租房等经营性场所进行物联网改造。同时支持多种物联网通信协议，开放智能门锁，智能开关，智能手环的 sdk 供开发者使用。</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-fcd18117e2cca5d8d73ac6371a8729a52fa.png" referrerpolicy="no-referrer"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;作为国内一流的业务管理 saas 系统店滴云，我们秉承客户至上，体验至上的原则，每天坚持多次更新代码。我们包含了商机端，用户端 ，管理端。管理端可以满足多商户，集团化的业务，在权限管理方便更是适应了当前 vue 为主流的大前端开发环境。我们来看下我们的手机端 ：</p><p><img alt="" height="667" src="https://oscimg.oschina.net/oscnet/up-b76c0d4b1c10df35d7699c51e889dd2c8ee.jpg" width="374" referrerpolicy="no-referrer"><img alt="" height="660" src="https://oscimg.oschina.net/oscnet/up-841ec370324656e9f997b3160181571817d.jpg" width="367" referrerpolicy="no-referrer"><img alt="" height="665" src="https://oscimg.oschina.net/oscnet/up-13d3083cc95756bfa6bca8cb6ce89c3019c.jpg" width="368" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 12 Nov 2023 04:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266386/ddiot-updated</guid>
            <link>https://www.oschina.net/news/266386/ddiot-updated</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
