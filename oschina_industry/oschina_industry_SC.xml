<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 16 Nov 2023 17:01:00 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[ChatGPT 代码解释器存在巨大安全漏洞]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenAI 近日为 ChatGPT 推出了全新的代码解释器（Code Interpreter）工具，可以帮助程序员调试、完善代码编程工作。该工具可以利用 AI 来编写 Python 代码，所编写的代码甚至可以在沙盒中运行。</p><p>不过根据 Johann Rehberger 网络安全专家、Tom's Hardware 等多家国外媒体<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tomshardware.com%2Fnews%2Fchatgpt-code-interpreter-security-hole" target="_blank">报道</a></u>，由于该代码解释器工具可以处理任何电子表格文件，并能以图表的形式分析和呈现数据，<strong>黑客可以欺骗 ChatGPT 聊天机器人，让其执行来自第三方 URL 的指令</strong>。</p><p>Tom's Hardware 媒体复现了相关漏洞，创建虚假的环境变量文件，利用 ChatGPT 的功能处理此数据，然后将其发送到外部恶意站点。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1ca35470cf685c96d916ec4c8a97265c843.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-df3cfd0173073986a718e72cfaab32eb096.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-787cc41d51a67b812ef60dda6ed6532d570.png" referrerpolicy="no-referrer"></p><p>ChatGPT 可以响应 Linux 命令，可以访问相关信息和文件，黑客通过这种方式，可以在用户没有防备的情况下，访问相关的敏感数据。</p><p>目前需要订阅 ChatGPT Plus，才能访问该代码解释工具，但这个漏洞引发了网络安全专家的担忧。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266683/chatgpt-code-interpreter-security-hole</guid>
            <link>https://www.oschina.net/news/266683/chatgpt-code-interpreter-security-hole</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 基于 Kotlin 的 AndroidX 仿微信图片选择器 MXImagePicker]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-imagepicker" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#imagepicker"></a>ImagePicker</h1><h2><a id="user-content-介绍" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E4%BB%8B%E7%BB%8D"></a>介绍</h2><h2><a id="user-content-基于 kotlinandroidx 的仿微信图片选择器" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E5%9F%BA%E4%BA%8Ekotlinandroidx%E7%9A%84%E4%BB%BF%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9%E5%99%A8"></a>基于 Kotlin，AndroidX 的仿微信图片选择器
<a href="https://gitee.com/link?target=https%3A%2F%2Fjitpack.io%2F%23com.gitee.zhangmengxiong%2FMXImagePicker"><img src="https://jitpack.io/v/com.gitee.zhangmengxiong/MXImagePicker.svg" alt="" referrerpolicy="no-referrer"></a></h2><p>Gradle 引用</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="n">implementation</span><span class="s1">'com.gitee.zhangmengxiong:MXImagePicker:1.6.3'</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p><img src="https://gitee.com/zhangmengxiong/MXImagePicker/raw/master/imgs/screenshot1.png" alt="Image text" referrerpolicy="no-referrer"><img src="https://gitee.com/zhangmengxiong/MXImagePicker/raw/master/imgs/screenshot2.png" alt="Image text" referrerpolicy="no-referrer"><img src="https://gitee.com/zhangmengxiong/MXImagePicker/raw/master/imgs/screenshot3.png" alt="Image text" referrerpolicy="no-referrer"></p><h2><a id="user-content-使用方法" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"></a>使用方法</h2><h4><a id="user-content-第一步项目增加 androidx 库和 glide 图片加载库图片缩放库" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E7%AC%AC%E4%B8%80%E6%AD%A5%E9%A1%B9%E7%9B%AE%E5%A2%9E%E5%8A%A0androidx%E5%BA%93%E5%92%8Cglide%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE%E5%BA%93"></a>第一步：项目增加 Androidx 库和 Glide 图片加载库、图片缩放库</h4><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="n">implementation</span><span class="s2">"androidx.appcompat:appcompat:x.x.x"</span></span><span id="LC2" class="line"><span class="n">implementation</span><span class="s2">"androidx.recyclerview:recyclerview:x.x.x"</span></span><span id="LC3" class="line"><span class="n">implementation</span><span class="s2">"com.github.bumptech.glide:glide:x.x.x"</span></span><span id="LC4" class="line"><span class="n">implementation</span><span class="s2">"androidx.constraintlayout:constraintlayout:2.0.4"</span></span><span id="LC5" class="line"><span class="n">implementation</span><span class="s2">"com.github.chrisbanes:PhotoView:2.3.0"</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-第二步使用前需要修改 androidmanifestxml 配置添加相册存储权限" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%BD%BF%E7%94%A8%E5%89%8D%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9androidmanifestxml%E9%85%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C%E5%AD%98%E5%82%A8%E6%9D%83%E9%99%90"></a>第二步：使用前需要修改‘AndroidManifest.xml’配置：添加相册、存储权限</h4><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 如果 Android 版本 &lt; 33 需要以下权限：</span></span><span id="LC2" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">CAMERA</span></span><span id="LC3" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">READ_EXTERNAL_STORAGE</span></span><span id="LC4" class="line"><span class="c1">// 如果 Android 版本 &gt;= 33 需要以下权限：</span></span><span id="LC5" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">CAMERA</span></span><span id="LC6" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">READ_MEDIA_IMAGES</span></span><span id="LC7" class="line"><span class="nc">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="nc">READ_MEDIA_VIDEO</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">// targetSdkVersion &gt;= 29 的应用需要在 application 节点添加以下属性</span></span><span id="LC10" class="line"><span class="n">android</span><span class="p">:</span><span class="n">requestLegacyExternalStorage</span><span class="p">=</span><span class="s">"true"</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>注意：<code>没有权限进入选择页面会报错！</code></p><h4><a id="user-content-第三步启动选择页面" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E7%AC%AC%E4%B8%89%E6%AD%A5%E5%90%AF%E5%8A%A8%E9%80%89%E6%8B%A9%E9%A1%B5%E9%9D%A2"></a>第三步：启动选择页面</h4><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">val</span><span class="py">intent</span><span class="p">=</span><span class="nc">MXPickerBuilder</span><span class="p">().</span><span class="nf">setMaxSize</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nf">createIntent</span><span class="p">(</span><span class="k">this</span><span class="p">)</span></span><span id="LC2" class="line"><span class="nf">startActivityForResult</span><span class="p">(</span><span class="n">intent</span><span class="p">,</span><span class="mh">0x22</span><span class="p">)</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-预加载说明" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E9%A2%84%E5%8A%A0%E8%BD%BD%E8%AF%B4%E6%98%8E"></a>预加载说明</h5><p>预加载可以提前搜索本机图片/视频资源，减少首次进入选择页面时空白时间</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nc">MXImagePicker</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">application</span><span class="p">)</span></span><span id="LC2" class="line"><span class="nc">MXScanBiz</span><span class="p">.</span><span class="nf">scanAll</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="n">lifecycleScope</span><span class="p">)</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-mxpickerbuilder 参数说明" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#mxpickerbuilder%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"></a>MXPickerBuilder 参数说明</h5><ol><li><code>setMaxSize(size: Int)</code> 设置最大选择文件个数</li><li><code>setType(type: PickerType)</code> 设置类型
<ul><li>PickerType.Image = 图片</li><li>PickerType.Video = 视频</li><li>PickerType.ImageAndVideo = 图片 + 视频，混合选择</li></ul></li><li><code>setCameraEnable(enable: Boolean)</code> 设置是否启动拍摄功能，默认=true</li><li><code>setMaxVideoLength(length: Int)</code> 当类型=Video 时，可以选择视频最大时长限制，单位：秒，默认=-1 无限制</li><li><code>setMaxListSize(size: Int)</code> 最长列表加载长度，防止图片过多时产生 OOM -1=不限制，默认限制长度=1000 条</li></ol><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 在图片选择器 Activity 创建时会回调这个方法，一般会通过这个来改变导航栏、状态栏的 Theme,demo 中搭配`ImmersionBar`来实现沉浸式效果</span></span><span id="LC2" class="line"><span class="nc">MXImagePicker</span><span class="p">.</span><span class="nf">registerActivityCallback</span><span class="p">{</span><span class="n">activity</span><span class="p">-&gt;</span></span><span id="LC3" class="line"><span class="nc">ImmersionBar</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="n">activity</span><span class="p">)</span></span><span id="LC4" class="line"><span class="p">.</span><span class="nf">autoDarkModeEnable</span><span class="p">(</span><span class="k">true</span><span class="p">)</span></span><span id="LC5" class="line"><span class="p">.</span><span class="nf">statusBarColorInt</span><span class="p">(</span><span class="n">activity</span><span class="p">.</span><span class="n">resources</span><span class="p">.</span><span class="nf">getColor</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">picker_color_background</span><span class="p">))</span></span><span id="LC6" class="line"><span class="p">.</span><span class="nf">fitsSystemWindows</span><span class="p">(</span><span class="k">true</span><span class="p">)</span></span><span id="LC7" class="line"><span class="p">.</span><span class="nf">navigationBarColor</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">picker_color_background</span><span class="p">)</span></span><span id="LC8" class="line"><span class="p">.</span><span class="nf">init</span><span class="p">()</span></span><span id="LC9" class="line"><span class="p">}</span></span><span id="LC10" class="line"></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-页面颜色设置" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E9%A1%B5%E9%9D%A2%E9%A2%9C%E8%89%B2%E8%AE%BE%E7%BD%AE"></a>页面颜色设置</h5><p>将下面颜色值放如主项目的资源 xml 中，可以修改页面对应的颜色显示</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c">&lt;!--  页面背景色  --&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;color</span><span class="na">name=</span><span class="s">"mx_picker_color_background"</span><span class="nt">&gt;</span>#333333<span class="nt">&lt;/color&gt;</span></span><span id="LC3" class="line"></span><span id="LC4" class="line"><span class="c">&lt;!--  字体、icon 颜色  --&gt;</span></span><span id="LC5" class="line"><span class="nt">&lt;color</span><span class="na">name=</span><span class="s">"mx_picker_color_important"</span><span class="nt">&gt;</span>#F1F1F1<span class="nt">&lt;/color&gt;</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="c">&lt;!--  选中状态颜色  --&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;color</span><span class="na">name=</span><span class="s">"mx_picker_color_select"</span><span class="nt">&gt;</span>#03CE65<span class="nt">&lt;/color&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-多语言设置" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E7%BD%AE"></a>多语言设置</h5><p>将下面字符串定义放入对应的语言目录中，可以修改页面对应的文字提示</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_select"</span><span class="nt">&gt;</span>选择<span class="nt">&lt;/string&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_all"</span><span class="nt">&gt;</span>全部<span class="nt">&lt;/string&gt;</span></span><span id="LC3" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_image_limit_tip"</span><span class="nt">&gt;</span>您最多只能选择 %s 张图片！<span class="nt">&lt;/string&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_video_limit_tip"</span><span class="nt">&gt;</span>您最多只能选择 %s 个视频！<span class="nt">&lt;/string&gt;</span></span><span id="LC5" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_video_limit_length_tip"</span><span class="nt">&gt;</span>只能选择 %s 秒以内的视频<span class="nt">&lt;/string&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_need_permission_storage_camera"</span><span class="nt">&gt;</span>需要写入存储、相机权限<span class="nt">&lt;/string&gt;</span></span><span id="LC7" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_need_permission_storage"</span><span class="nt">&gt;</span>需要读取存储权限<span class="nt">&lt;/string&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_open_failed"</span><span class="nt">&gt;</span>打开失败！<span class="nt">&lt;/string&gt;</span></span><span id="LC9" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_preview"</span><span class="nt">&gt;</span>预览<span class="nt">&lt;/string&gt;</span></span><span id="LC10" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_not_compress"</span><span class="nt">&gt;</span>原图<span class="nt">&lt;/string&gt;</span></span><span id="LC11" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_take_pic"</span><span class="nt">&gt;</span>拍摄图片<span class="nt">&lt;/string&gt;</span></span><span id="LC12" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_take_video"</span><span class="nt">&gt;</span>拍摄视频<span class="nt">&lt;/string&gt;</span></span><span id="LC13" class="line"><span class="nt">&lt;string</span><span class="na">name=</span><span class="s">"mx_picker_string_show_list"</span><span class="nt">&gt;</span>图片查看<span class="nt">&lt;/string&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>dimens.xml 资源</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c">&lt;!--  顶部导航栏高度  --&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;dimen</span><span class="na">name=</span><span class="s">"mx_picker_bar_height"</span><span class="nt">&gt;</span>50dp<span class="nt">&lt;/dimen&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h5><a id="user-content-自定义图片加载器默认使用 glide" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%99%A8%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8glide"></a>自定义图片加载器（默认使用 Glide）</h5><p>通过继承实现接口<code>IImageLoader</code> ,并注册到服务<code>MXImagePicker</code>即可</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 数据对象</span></span><span id="LC2" class="line"><span class="kd">data class</span><span class="nc">MXItem</span><span class="p">(</span><span class="kd">val</span><span class="py">path</span><span class="p">:</span><span class="nc">String</span><span class="p">,</span><span class="kd">val</span><span class="py">time</span><span class="p">:</span><span class="nc">Long</span><span class="p">,</span><span class="kd">val</span><span class="py">type</span><span class="p">:</span><span class="nc">MXPickerType</span><span class="p">,</span><span class="kd">val</span><span class="py">duration</span><span class="p">:</span><span class="nc">Int</span><span class="p">=</span><span class="mi">0</span><span class="p">)</span></span><span id="LC3" class="line"></span><span id="LC4" class="line"><span class="c1">// 全局注册加载器，可以卸载 Application 里面，不影响启动速度</span></span><span id="LC5" class="line"><span class="nc">MXImagePicker</span><span class="p">.</span><span class="nf">registerImageLoader</span><span class="p">{</span><span class="n">activity</span><span class="p">,</span><span class="n">item</span><span class="p">,</span><span class="n">imageView</span><span class="p">-&gt;</span></span><span id="LC6" class="line"><span class="k">if</span><span class="p">(</span><span class="nc">File</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">path</span><span class="p">).</span><span class="nf">exists</span><span class="p">())</span><span class="p">{</span></span><span id="LC7" class="line"><span class="nc">Glide</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="n">activity</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="nc">File</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">path</span><span class="p">))</span></span><span id="LC8" class="line"><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">mx_icon_picker_image_place_holder</span><span class="p">).</span><span class="nf">into</span><span class="p">(</span><span class="n">imageView</span><span class="p">)</span></span><span id="LC9" class="line"><span class="p">}</span><span class="k">else</span><span class="k">if</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">startsWith</span><span class="p">(</span><span class="s">"http"</span><span class="p">))</span><span class="p">{</span></span><span id="LC10" class="line"><span class="nc">Glide</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="n">activity</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">path</span><span class="p">)</span></span><span id="LC11" class="line"><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">mx_icon_picker_image_place_holder</span><span class="p">).</span><span class="nf">into</span><span class="p">(</span><span class="n">imageView</span><span class="p">)</span></span><span id="LC12" class="line"><span class="p">}</span><span class="k">else</span><span class="p">{</span></span><span id="LC13" class="line"><span class="nc">Glide</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="n">activity</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">uri</span><span class="p">)</span></span><span id="LC14" class="line"><span class="p">.</span><span class="nf">placeholder</span><span class="p">(</span><span class="nc">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">mx_icon_picker_image_place_holder</span><span class="p">).</span><span class="nf">into</span><span class="p">(</span><span class="n">imageView</span><span class="p">)</span></span><span id="LC15" class="line"><span class="p">}</span></span><span id="LC16" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-第四步获取返回结果" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E7%AC%AC%E5%9B%9B%E6%AD%A5%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"></a>第四步：获取返回结果</h4><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">override</span><span class="k">fun</span><span class="nf">onActivityResult</span><span class="p">(</span><span class="n">requestCode</span><span class="p">:</span><span class="nc">Int</span><span class="p">,</span><span class="n">resultCode</span><span class="p">:</span><span class="nc">Int</span><span class="p">,</span><span class="n">data</span><span class="p">:</span><span class="nc">Intent</span><span class="p">?)</span><span class="p">{</span></span><span id="LC2" class="line"><span class="k">super</span><span class="p">.</span><span class="nf">onActivityResult</span><span class="p">(</span><span class="n">requestCode</span><span class="p">,</span><span class="n">resultCode</span><span class="p">,</span><span class="n">data</span><span class="p">)</span></span><span id="LC3" class="line"><span class="k">if</span><span class="p">(</span><span class="n">resultCode</span><span class="p">==</span><span class="nc">RESULT_OK</span><span class="p">&amp;&amp;</span><span class="n">requestCode</span><span class="p">==</span><span class="mh">0x22</span><span class="p">)</span><span class="p">{</span></span><span id="LC4" class="line"><span class="kd">val</span><span class="py">paths</span><span class="p">=</span><span class="nc">MXPickerBuilder</span><span class="p">.</span><span class="nf">getPickerResult</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">?:</span><span class="k">return</span><span class="c1">//返回 List&lt;String&gt;类型数据</span></span><span id="LC5" class="line"><span class="nf">println</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span></span><span id="LC6" class="line"><span class="p">}</span></span><span id="LC7" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-调取摄像头单独拍摄照片" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E8%B0%83%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4%E5%8D%95%E7%8B%AC%E6%8B%8D%E6%91%84%E7%85%A7%E7%89%87"></a>调取摄像头单独拍摄照片</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">val</span><span class="py">builder</span><span class="p">=</span><span class="nc">MXCaptureBuilder</span><span class="p">().</span><span class="nf">setType</span><span class="p">(</span><span class="nc">MXPickerType</span><span class="p">.</span><span class="nc">Image</span><span class="p">)</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="nf">startActivityForResult</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="nf">createIntent</span><span class="p">(</span><span class="k">this</span><span class="p">),</span><span class="mh">0x11</span><span class="p">)</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="c1">// 在 onActivityResult 获取结果</span></span><span id="LC6" class="line"><span class="kd">val</span><span class="py">file</span><span class="p">=</span><span class="n">builder</span><span class="p">.</span><span class="nf">getCaptureFile</span><span class="p">()</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-调取摄像头单独拍摄视频" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E8%B0%83%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4%E5%8D%95%E7%8B%AC%E6%8B%8D%E6%91%84%E8%A7%86%E9%A2%91"></a>调取摄像头单独拍摄视频</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">val</span><span class="py">builder</span><span class="p">=</span><span class="nc">MXCaptureBuilder</span><span class="p">().</span><span class="nf">setType</span><span class="p">(</span><span class="nc">MXPickerType</span><span class="p">.</span><span class="nc">Video</span><span class="p">).</span><span class="nf">setMaxVideoLength</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span></span><span id="LC2" class="line"><span class="nf">startActivityForResult</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="nf">createIntent</span><span class="p">(</span><span class="k">this</span><span class="p">),</span><span class="mh">0x11</span><span class="p">)</span></span><span id="LC3" class="line"></span><span id="LC4" class="line"><span class="c1">// 在 onActivityResult 获取结果</span></span><span id="LC5" class="line"><span class="kd">val</span><span class="py">file</span><span class="p">=</span><span class="n">builder</span><span class="p">.</span><span class="nf">getCaptureFile</span><span class="p">()</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-图片查看器" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8"></a>图片查看器</h3><p><img src="https://gitee.com/zhangmengxiong/MXImagePicker/raw/master/imgs/screenshot3.png" alt="Image text" referrerpolicy="no-referrer"></p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nc">MXImgShowActivity</span><span class="p">.</span><span class="k">open</span><span class="p">(</span></span><span id="LC2" class="line"><span class="k">this</span><span class="p">,</span><span class="nf">arrayListOf</span><span class="p">(</span></span><span id="LC3" class="line"><span class="s">"http://videos.jzvd.org/v/饺子主动.jpg"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="s">"http://videos.jzvd.org/v/饺子运动.jpg"</span></span><span id="LC5" class="line"><span class="p">),</span><span class="s">"图片详情"</span></span><span id="LC6" class="line"><span class="p">)</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-单张图片压缩" class="anchor" href="https://gitee.com/zhangmengxiong/MXImagePicker#%E5%8D%95%E5%BC%A0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9"></a>单张图片压缩</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">val</span><span class="py">file</span><span class="p">=</span><span class="nc">File</span><span class="p">(</span><span class="s">".../xx.png"</span><span class="p">)</span></span><span id="LC2" class="line"><span class="kd">val</span><span class="py">scaleImg</span><span class="p">=</span><span class="nc">MXImageCompress</span><span class="p">.</span><span class="nf">from</span><span class="p">(</span><span class="n">context</span><span class="p">)</span></span><span id="LC3" class="line"><span class="p">.</span><span class="nf">setCacheDir</span><span class="p">(</span><span class="n">applicationContext</span><span class="p">.</span><span class="n">cacheDir</span><span class="p">)</span><span class="c1">// 缓存目录</span></span><span id="LC4" class="line"><span class="p">.</span><span class="nf">setSupportAlpha</span><span class="p">(</span><span class="k">true</span><span class="p">)</span><span class="c1">// 支持透明通道 (’.png‘格式) 默认=’.jpg‘格式</span></span><span id="LC5" class="line"><span class="p">.</span><span class="nf">setTargetFileSize</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="c1">// 设置压缩文件大小目标值，单位：Kb 默认=0 自然压缩</span></span><span id="LC6" class="line"><span class="p">.</span><span class="nf">setTargetPixel</span><span class="p">(</span><span class="mi">2400</span><span class="p">)</span><span class="c1">// 设置压缩文件宽或高目标值，单位：像素</span></span><span id="LC7" class="line"><span class="p">.</span><span class="nf">compress</span><span class="p">(</span><span class="n">file</span><span class="p">)</span></span><span id="LC8" class="line"></span></pre><div class="markdown-code-block-copy-btn"></div></div></div>]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 02:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/zhangmengxiong/MXImagePicker</guid>
            <link>https://gitee.com/zhangmengxiong/MXImagePicker</link>
        </item>
        <item>
            <title>
                <![CDATA[微软推出全新「Windows App」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">微软在&nbsp;Ignite 2023 上宣布推出一款适用于 iOS、iPadOS、Web 和 Windows 的全新「Windows App」，目前正以预览版形式提供。</span></p><p><span style="color:#000000">用户可以通过该 APP 连接 Windows 365、Azure 虚拟桌面、Microsoft Dev Box 或个人远程桌面 PC。在手机或 iPad 上，用户无需下载或安装任何内容即可启动 Windows 环境。</span></p><p><span style="color:#000000"><img alt="" height="309" src="https://oscimg.oschina.net/oscnet/up-6de517b3878e038efe903ec950a3f14d987.webp" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">新的 Windows APP 带来了多项新功能：如支持多显示器、自定义显示分辨率、动态显示缩放、网络摄像头、音频和打印机的设备重定向等。用户可以固定最喜欢的应用程序，以便快速访问，还可以在不同账户之间轻松切换。</span></p><p><span style="color:#000000">虽然微软官方表示该应用程序仅上架 iOS、Windows、macOS 以及网页端，但提供的屏幕截图显示 Android&nbsp;平板上也能运行该应用。或许 Android 版本将会在不久的未来推出。</span></p><p><span style="color:#000000">不过，该 Windows APP 仅面向微软企业用户提供，个人账户无法访问相关服务。但有迹象表明，微软计划通过 Windows 365 为普通消费者提供云 PC。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 09:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266787/microsoft-windows-app-launched-run-cloud-pc</guid>
            <link>https://www.oschina.net/news/266787/microsoft-windows-app-launched-run-cloud-pc</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[ClickHouse 联合创始人、前 Google 副总裁 Yury 到访杭州玖章算术公司，双方建立生态合作]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span><span style="color:#000000">10 月 31 日，ClickHouse 联合创始人 Yury 到访未来科技城，与玖章算术创始人叶正盛和国际总经理 Ni Demai 展开沟通与推进合作。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-3abad57e89ff8fcc5278d96ff167a2bf87d.jpg" width="1707" referrerpolicy="no-referrer"></p><p style="color:#999999; margin-left:0; margin-right:0; text-align:center">图片备注：Ni Demai(左),Yury(中),叶正盛 (右)</p></div><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">ClickHouse 是深受开发者青睐的实时分析型数据库，成立 2 年就发展成为基础软件领域的独角兽，玖章算术核心产品 NineData 则是中国数据库工具领域的佼佼者。通过本次沟通，</span><span style="color:#f04142">ClickHouse 将继续增加其在生态能力上的投入，引入玖章算术成为 ClickHouse 全球正式合作伙伴</span><span style="color:#000000">，NineData 将提供数据复制、SQL 开发等能力，帮助开发者更加便捷、稳定地使用 ClickHouse。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">ClickHouse 中国区负责人王楠（Tracy）、玖章算术首席产品经理蔡冬者参与了本次会议，双方深度交流了 NineData 帮助 ClikHouse 完成数据复制的实践场景，将在 ClickHouse 中国社区发展深度合作。</span></span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="1659" src="https://oscimg.oschina.net/oscnet/up-29fbbc98347ec5e04fcc19c903bdcbea0d0.jpg" width="2091" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">Yury 作为 ClickHouse 的联合创始人、产品和工程总裁，是前谷歌、Netflix 的副总裁。<span style="color:#f04142">本次代表 ClickHouse 与玖章算术 CEO 叶正盛进行沟通，旨在加强两家公司之间的合作，增强 ClickHouse 的生态能力建设，帮助开发者更好地使用 ClickHouse。</span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="1080" src="https://oscimg.oschina.net/oscnet/up-d6908642b538092775611c1383c849b5928.jpg" width="2301" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">叶正盛是玖章算术创始人，在数据库生态工具产品里有 20 年经验，是国内把数据库生态工具体系做成专业产品的第一人。后续，</span><span style="color:#f04142">NineData 将快速支持 ClickHouse 最新版本，适配 ClickHouse Cloud，同时会更大力度投入中国 ClickHouse 社区建设。</span></span></p><div><p style="text-align:center"><img alt="" height="1080" src="https://oscimg.oschina.net/oscnet/up-e0d4a2d815c5fc2bf9daf62ae54c45c901c.jpg" width="2301" referrerpolicy="no-referrer"></p><p style="color:#999999; margin-left:0; margin-right:0; text-align:center">玖章算术创始人叶正盛（中）</p></div><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">NineData 提供企业级 SQL 开发能力，包括数据库堡垒机、生产变更服务，以及细粒度权限管控、审计、敏感数据脱敏处理等功能。并集成了大模型 AI 技术，提供智能 SQL 编写、SQL 优化和数据库专业知识问答，能够帮助客户提高 DBA 与技术团队及 ISV 伙伴的合作效率。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">NineData 的数据复制能力可应用于多种场景，包括在线数据库到数据仓库实时同步、数据库国产化替换、数据上云、数据容灾等，支持 1000 公里数据实时同步，复制性能超过 10 万 TPS，领先于市场主流产品。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">NineData 的创始团队由阿里云、华为、IBM 等公司资深数据库专家组成。NineData 支持 MySQL、Oracle、PostgreSQL、ClickHouse、Redis、MongoDB、Doris 等 60 种主流数据源。</span></span></p><div><p style="text-align:center"><img alt="" height="1332" src="https://oscimg.oschina.net/oscnet/up-7e72cd287ff75493e4b1730da64f74e22f5.png" width="2878" referrerpolicy="no-referrer"></p><p style="color:#999999; margin-left:0; margin-right:0; text-align:center">NineData 支持 60 种主流数据源</p></div><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">目前，NineData 已经为上万开发者提供服务，在中国移动、沃尔沃、绿城集团等大型企业上线，与华为云、阿里云、腾讯云、百度云、移动云、AWS、Apache Doris、SelectDB 等平台建立了紧密合作关系。NineData 的目标是让企业各个数据源之间的数据自由流动，让数据管理与研发流程更安全、更高效。</span></span></p><p style="margin-left:0px; margin-right:0px"><span><strong><span style="color:#000000">结束语：</span></strong><span style="color:#000000"><span>&nbsp;</span>ClickHouse 与玖章算术 NineData 的合作将促进其生态系统的发展，NineData 将更好地支持 ClickHouse 数据库复制、SQL 开发等。这一合作将为中国的 ClickHouse 社区带来更多支持和创新，进一步推动社区发展，帮助开发者更好的使用 ClickHouse，发掘数据价值，推进企业业务发展。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 09:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266785</guid>
            <link>https://www.oschina.net/news/266785</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GitHub 报告：TypeScript 取代 Java 成为第三受欢迎语言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">GitHub 发布了 2023 年度&nbsp;Octoverse 开源状态报告。主要研究了围绕 AI、云和 Git 的开源活动如何改变开发人员体验，以及如何在开发者和企业中产生越来越大的影响。</span></p><p><span style="color:#000000">报告发现了三大趋势：</span></p><ul><li><span style="color:#000000"><strong>开发人员正在大量使用生成式 AI 进行构建。</strong>越来越多的开发人员尝试使用 OpenAI 和其他 AI 公司的基础模型，开源生成式 AI 项目甚至在 2023 年进入了按贡献者数量排名的十大最受欢迎的开源项目。几乎所有开发人员 (92%) 都在使用或尝试借助 AI 编码工具。</span></li><li><span style="color:#000000"><strong>开发人员正在大规模运行云原生应用程序。</strong>使用基于 Git 的基础设施即代码 (IaC) 工作流的声明式语言越来越多，云部署的标准化程度更高，开发人员使用 Dockerfile 和容器、IaC 以及其他云原生技术的速度也急剧加快。</span></li><li><span style="color:#000000"><strong>2023 年 first-time 开源贡献者数量最多。</strong>其中，有商业支持的开源项目依旧最受贡献者欢迎。但生成式 AI 项目在今年进入了 first-time 贡献者最受欢迎的的十大项目之列。GitHub 上的私人项目显着增长，同比增长 38%，占 GitHub 上所有活动的 80% 以上。</span></li></ul><p><span style="color:#000000"><strong>全球开发者社区</strong>继续增长。美国拥有 2020 万开发者，开发者人数在去年增长了 21%，仍然是全球最大的开发者社区。亚太地区、非洲、南美洲和欧洲的开发者社区规模逐年扩大，其中印度、巴西和日本处于领先地位。</span></p><p><span style="color:#000000">预计到 2027 年，印度将取代美国成为 GitHub 上最大的开发者社区。新加坡今年是亚太地区开发者人数增长最快的国家，并且是开发者占总人口的比例最高的第地区（全球范围内）。报告指出，由于日本在技术和初创企业方面的进一步投资，明年日本的开发者将有持续增长。</span></p><p><img alt="" height="281" src="https://oscimg.oschina.net/oscnet/up-ac720a0e760e91cc5b2eb3fbe5912621880.webp" width="500" referrerpolicy="no-referrer"></p><p><img height="356" src="https://oscimg.oschina.net/oscnet/up-80f62228356fcbdefb478e041a0eac39e37.png" width="400" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><strong>生成式 AI </strong>在 2023 年经历了爆发式增长，仅半年内涌现出的生成式 AI 项目数量就已达到了 2022 年全年的两倍之多。开发人员也开始更多地尝试使用 AI 模型。前几年，开发人员常使用 tensorflow/tensorflow、pytorch/pytorch 等机器学习库构建项目；现在则更多尝试使用 AI 模型和 LLM（如 ChatGPT API）。</span></p><p><img height="270" src="https://oscimg.oschina.net/oscnet/up-7496f60e2ee0f94240f5faf6341e5262a5b.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">报告分析了 GitHub 上排名前 20 位的开源生成式 AI 项目，发现其中一些顶级项目都是由个人所有。生成式 AI 项目中的个人贡献者正在全球范围内大幅飙升，同比增长幅度达到了 148%，而生成式 AI 项目总数也同比增长 248%。</span></p><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">美国、印度和日本在开发者社区中处于领先地位，</span><span style="background-color:#ffffff; color:#24292f">香港特别行政区</span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">、英国和巴西紧随其后。</span></p><p><img height="257" src="https://oscimg.oschina.net/oscnet/up-24b4f2b8554174e97591f4e9b11183c4b8e.png" width="500" referrerpolicy="no-referrer"></p><p><strong style="color:rgba(0, 0, 0, 0.9)">最流行的编程语言</strong></p><p><img height="144" src="https://oscimg.oschina.net/oscnet/up-3a0a14c95ce1e310f742e6ce36ad9af9795.png" width="500" referrerpolicy="no-referrer"></p><p>报告指出，<span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">自 2019 年云原生开发大规模增长以来，IaC 在开源领域持续增长。2023 年，Shell 和 Hashicorp 配置语言（HCL）再次成为开源项目中的顶级语言，</span><span style="background-color:#ffffff; color:#24292f">HCL 采用率同比增长 36%；「表明运维和 IaC 工作在开源领域越来越受到重视」。</span></p><p><img height="263" src="https://oscimg.oschina.net/oscnet/up-72dde2bf24c363d79ba454d8df65c964a2b.png" width="500" referrerpolicy="no-referrer"></p><ul style="list-style-type:disc; margin-left:0; margin-right:0"><li><span style="color:#000000">JavaScript 仍然是 GitHub 上最常用的语言，其次是 Python。</span></li><li><span style="color:#000000">TypeScript 越来越受欢迎，<span style="background-color:#ffffff">首次取代 Java 成为 GitHub 上 OSS 项目中第三大最受欢迎的语言，其用户群增长了 37%。</span></span></li><li><span style="color:#000000">用于数据分析和操作的流行语言和框架明显增加。T-SQL 和 TeX 等古老的语言在 2023 年均有所增长，凸显了数据科学家、数学家和分析师越来越多地使用开源平台和工具。「<span style="background-color:#ffffff">编程语言不再仅仅局限于传统软件开发领域</span>」。</span></li><li><span style="color:#000000"><span style="background-color:#ffffff">在 GitHub 上一些较新的项目中，Kotlin、Rust、Go 和 Lua 的采用出现了较大的增长。「Rust 和 Lua 都以内存安全和高效著称，而且都可用于系统和嵌入式系统编程，这也是它们增长的原因。而 Go 最近的增长则是由 Kubernetes 和 Prometheus 等云原生项目的推动。」</span></span></li></ul><p><img height="262" src="https://oscimg.oschina.net/oscnet/up-58e41eb95e2505a64d2a2a8a7b46fdf4ee6.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">其他一些发现还包括：</span></span></p><ul><li><span style="color:#000000"><span style="background-color:#ffffff">与 2022 年相比，2023 年开源代码开发人员合并的针对易受攻击软件包的自动 Dependabot 拉取请求增加了 60%</span></span></li><li><span style="color:#000000"><span style="background-color:#ffffff">2023 年，</span><span style="background-color:#ffffff">开发者</span><span style="background-color:#ffffff">为 GitHub 上的开源项目做出了 3.01 亿次贡献，这些项目既有像 Mastodon 这样的热门项目，也有像 Stable Diffusion 和 LangChain 这样的生成式 AI 项目。</span></span></li><li><span style="color:#000000"><span style="background-color:#ffffff">2023 年有 430 万个存储库使用了 Docker。Linux 发行版 NixOS/nixpkgs 在过去两年中一直位居开源项目贡献者榜首。</span></span></li></ul><p><span style="background-color:#ffffff; color:#333333">更多详情可</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.blog%2F2023-11-08-the-state-of-open-source-and-ai%2F" target="_blank">查看完整报告</a><span style="background-color:#ffffff; color:#333333">。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 07:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266757/2023-state-of-the-octoverse</guid>
            <link>https://www.oschina.net/news/266757/2023-state-of-the-octoverse</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[李开复再回应争议：受益于开源也贡献开源]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>针对旗下「零一万物」 开源的 Yi 大模型近日被质疑照搬 Llama 架构，只对两个张量（Tensor）名称做了修改的风波，李开复在朋友圈<span style="color:#030303">转发了「</span><a href="https://www.oschina.net/news/266597" target="news">零一万物对 Yi-34B 训练过程的说明</a><span style="color:#030303">」文章，并配文</span>回应称：</p><blockquote><p><span style="color:#030303">零一万物 Yi-34B 模型训练的说明也回应这两天大家对于模型架构的探讨。全球大模型架构一路从 GPT2--&gt;Gopher--&gt;Chinchilla--&gt;Llama2-&gt;Yi，行业逐渐形成大模型的通用标准（就像做一个手机 app 开发者不会去自创 iOS、Android 以外的全新基础架构）。01.AI 起步受益于开源，也贡献开源，从社区中虚心学习，我们会持续进步。</span></p></blockquote><p><img height="290" src="https://static.oschina.net/uploads/space/2023/1116/141708_SLoh_4252687.png" width="300" referrerpolicy="no-referrer"></p><p><strong>相关阅读：</strong></p><ul><li><a href="https://www.oschina.net/news/266377">李开复旗下 AI 公司 「零一万物」 开源的 Yi 大模型照搬 Llama 架构</a></li><li><a href="https://www.oschina.net/news/266525">「零一万物」 回应 Yi 开源大模型 「套壳」 Llama</a></li><li><p style="margin-left:0px; margin-right:0px; text-align:start"><a href="https://www.oschina.net/news/266597" target="_blank">零一万物对 Yi-34B 训练过程的说明</a></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 06:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266727</guid>
            <link>https://www.oschina.net/news/266727</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[.NET 8.0 中有哪些新的变化？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong>1 性能提升</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fperformance-improvements-in-aspnet-core-8%2F" target="_blank">.NET 8 在整个</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fdotnet-8-performance-improvements-in-dotnet-maui%2F" target="_blank">堆栈</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fthis-arm64-performance-in-dotnet-8%2F" target="_blank">中</a>带来了数千项性能<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fperformance-improvements-in-net-8%2F" target="_blank">改进</a> 。默认情况下会启用一种名为动态配置文件引导优化 (PGO) 的新代码生成器，它可以根据实际使用情况优化代码，并且可以将应用程序的性能提高高达 20%。现在支持的 AVX-512 指令集能够对 512 位数据向量执行并行操作，这意味着可以在更短的时间内处理更多的数据。原始类型（数字及其他类型）现在实现了新的可格式化和可解析接口，这使它们能够直接格式化和解析为 UTF-8，而无需任何转码开销。 <img src="https://img-blog.csdnimg.cn/img_convert/b91071a2632a5da242e53238fb844e52.png" alt="" referrerpolicy="no-referrer"></p><p><strong>2.NET Aspire</strong></p><p>.NET Aspire 是一个用于使用 .NET 构建弹性、可观察和可配置的云原生应用程序的堆栈。它包括一组针对云原生而增强的精选组件，默认情况下包括遥测、弹性、配置和运行状况检查。结合复杂而简单的本地开发人员体验，.NET Aspire 可以在第 1 天和第 100 天轻松发现、获取和配置云原生应用程序的基本依赖项。</p><p>点击这里查看.NET Aspire 的预览版本。 <img src="https://img-blog.csdnimg.cn/img_convert/ba664a021af354f1fc46c013578b8946.png" alt="" referrerpolicy="no-referrer"></p><p><strong>3.NET 8 容器增强功能 – 更安全、更紧凑、更高效</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fsecuring-containers-with-rootless%2F" target="_blank">使用 .NET 比以往更轻松、更安全地使用容器</a>打包应用程序。每个 .NET 映像都包含一个非 root 用户，从而通过单行配置启用更安全的容器。.NET SDK 工具无需 Dockerfile 即可发布容器映像，并且默认情况下是非 root 的。由于 .NET 基础映像更小，因此可以更快地部署容器化应用程序 - 包括我们映像的新实验变体，这些变体可为本机 AOT 提供真正最小的应用程序大小。选择使用新的 Chiseled Ubuntu 映像变体进行更多安全强化，以进一步减少攻击面。使用 Dockerfile 或 SDK 工具，为任何架构构建应用程序和容器映像。 <img src="https://img-blog.csdnimg.cn/img_convert/16b65a6962356cd1e24f164cf66ead3c.png" alt="" referrerpolicy="no-referrer"></p><p><strong>4 原生 AoT – 迈向更高密度可持续计算的旅程</strong></p><p>无需等待 JIT（即时）编译器在运行时编译代码。无需部署 JIT 编译器和 IL 代码。AOT 应用程序仅部署应用程序所需的代码。应用程序现在可以在不允许使用 JIT 编译器的受限环境中运行。 <img src="https://img-blog.csdnimg.cn/img_convert/5037b084ad2c4e26f6696f6c7b74712a.png" alt="" referrerpolicy="no-referrer"></p><p><strong>5 人工智能 – 将 AI 融入您的 .NET 应用程序</strong></p><p>生成式人工智能和大型语言模型正在改变人工智能领域，使开发人员能够在其应用程序中创建独特的人工智能体验。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgist.github.com%2FLadyNaggaga%2F5b0a708f2b945f5c8ca8ade4974665ff" target="_blank">.NET 8 可以</a>通过 .NET SDK 中一流的开箱即用 AI 功能以及与多种工具的无缝集成来轻松利用 AI。</p><p>.NET 8 为该，库带来了多项增强功能，以提高其与生成式 AI 工作负载的兼容性，例如集成 Tensor Primitives。随着人工智能应用程序的兴起，新的工具和 SDK 出现了。我们与众多内部和外部合作伙伴合作，例如 Azure OpenAI、Azure Cognitive Search、Milvus、Qdrant 和 Microsoft Teams，以确保 .NET 开发人员可以通过各自的 SDK 轻松访问各种 AI 模型、服务和平台。此外，开源语义内核 SDK 简化了这些 AI 组件与新的和现有应用程序的集成，以帮助您提供创新的用户体验。System.Numerics</p><p>现在提供各种示例和参考模板，展示模式和实践，以便开发人员轻松入门：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdotnet%2FeShop" target="_blank">客户聊天机器人</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAzure-Samples%2Fazure-search-openai-demo-csharp" target="_blank">检索增强生成</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fdemystifying-retrieval-augmented-generation-with-dotnet%2F" target="_blank">使用 Azure AI 服务开发应用程序</a><img src="https://img-blog.csdnimg.cn/img_convert/892b90ec5d84e0bf792f8dba707dce58.png" alt="" referrerpolicy="no-referrer"></li></ul><p><strong>6Blazor – 使用 .NET 构建全栈 Web 应用程序</strong></p><p>.NET 8 中的 Blazor 可以同时使用服务器和客户端来处理您的所有 Web UI 需求。这是全栈 Web UI！通过专注于优化页面加载时间、可扩展性和提升用户体验的多项新增强功能，开发人员现在可以在同一应用程序中使用 Blazor Server 和 Blazor WebAssembly，在运行时自动将用户从服务器转移到客户端。得益于新的基于「Jiterpreter」的运行时和新的内置组件，您的 .NET 代码在 WebAssembly 上的运行速度显着加快。作为增强.NET 8 中整体身份验证、授权和身份管理的一部分，Blazor 现在支持生成完整的基于 Blazor 的身份 UI。 <img src="https://img-blog.csdnimg.cn/img_convert/f0563b1ef218bb7b09130df55e5de700.png" alt="" referrerpolicy="no-referrer"></p><p><strong>7.NET MAUI – 提升性能、可靠性和开发人员体验</strong></p><p>.NET MAUI 提供单一项目系统和单一代码库来构建 WinUI、Mac Catalyst、iOS 和 Android 应用程序。本机 AOT（实验性）现在支持针对类似 iOS 的平台。适用于 .NET MAUI 的新 Visual Studio Code 扩展为您提供了开发跨平台 .NET 移动和桌面应用程序所需的工具。现在支持 Xcode 15 和 Android API 34，允许您瞄准最新版本的 iOS 和 Android。在性能、控件和 UI 元素以及特定于平台的行为方面进行了大量的质量改进，例如桌面交互添加了更好的点击处理、键盘侦听器等。 <img src="https://img-blog.csdnimg.cn/img_convert/130807a5e11b784d65aa556290afda0d.png" alt="" referrerpolicy="no-referrer"></p><p><strong>8 C# 12 功能 – 简化语法以提高开发人员的工作效率</strong></p><p>C# 12 让您的编码体验更加高效和愉快。现在，您可以使用简单而优雅的语法在任何类和结构中创建主构造函数。不再需要样板代码来初始化您的字段和属性。使用简洁且富有表现力的语法创建数组、跨度和其他集合类型时会感到高兴。对 lambda 表达式中的参数使用新的默认值。不再需要重载或空检查来处理可选参数。您甚至可以使用 usingalias 指令为任何类型添加别名，而不仅仅是命名类型！</p><p><strong>8.1 集合表达式</strong></p><p>在 C# 12 之前，创建集合需要针对不同场景使用不同的语法。初始化所需的与 or 不同的语法。以下是创建集合的几种方法：List&lt;int&gt;int[]Span&lt;int&gt;</p><pre><code class="language-C#">int[] x1 = new int[] { 1, 2, 3, 4 };
int[] x2 = Array.Empty&lt;int&gt;();
WriteByteArray(new[] { (byte)1, (byte)2, (byte)3 });
List&lt;int&gt; x4 = new() { 1, 2, 3, 4 };
Span&lt;DateTime&gt; dates = stackalloc DateTime[] { GetDate(0), GetDate(1) };
WriteByteSpan(stackalloc[] { (byte)1, (byte)2, (byte)3 });
</code></pre><p><strong>8.2 任何类或结构上的主构造函数</strong></p><p>C# 12 扩展了主构造函数以适用于所有类和结构，而不仅仅是记录。主构造函数允许在声明类时定义构造函数参数：</p><pre><code class="language-C#">public class BankAccount(string accountID, string owner)
{
    public string AccountID { get; } = accountID;
    public string Owner { get; } = owner;

    public override string ToString() =&gt; $"Account ID: {AccountID}, Owner: {Owner}";
}
</code></pre><p>主构造函数参数最常见的用途是：</p><ul><li>作为 base() 构造函数调用的参数。</li><li>初始化成员字段或属性。</li><li>在实例成员中引用构造函数参数。</li><li>删除依赖注入中的样板。</li></ul><p><strong>8.3 别名任意类型</strong></p><p>别名类型是从代码中删除复杂类型签名的便捷方法。using 从 C# 12 开始，其他类型在别名指令中有效。例如，这些别名在早期版本的 C# 中无效：</p><pre><code class="language-C#">using intArray = int[]; // Array types.
using Point = (int x, int y);  // Tuple type
using unsafe ArrayPtr = int*;  // Pointer type (requires "unsafe")
</code></pre><p><strong>8.4 默认 lambda 参数</strong></p><p>从 C# 12 开始，您可以在 lambda 表达式中声明默认参数：</p><pre><code class="language-C#">var IncrementBy = (int source, int increment = 1) =&gt; source + increment;

Console.WriteLine(IncrementBy(5)); // 6
Console.WriteLine(IncrementBy(5, 2)); // 7
</code></pre><p><strong>8.5 内联数组</strong></p><p>运行时团队和其他库作者使用内联数组来提高应用的性能。 内联数组使开发人员能够创建固定大小的 struct 类型数组。 具有内联缓冲区的结构应提供类似于不安全的固定大小缓冲区的性能特征。 你可能不会声明自己的内联数组，但当它们从运行时 API 作为 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.span-1" target="_blank">System.Span&lt;T&gt;</a> 或 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.readonlyspan-1" target="_blank">System.ReadOnlySpan&lt;T&gt;</a> 对象公开时，你将透明地使用这些数组。</p><pre><code class="language-C#">[System.Runtime.CompilerServices.InlineArray(10)]
public struct Buffer
{
    private int _element0;
}
</code></pre><p>它们的用法与任何其他数组类似：</p><pre><code class="language-C#">var buffer = new Buffer();
for (int i = 0; i &lt; 10; i++)
{
    buffer[i] = i;
}

foreach (var i in buffer)
{
    Console.WriteLine(i);
}
</code></pre><p>区别在于编译器可以利用有关内联数组的已知信息。 你可能会像使用任何其他数组一样使用内联数组。 有关如何声明内联数组的详细信息，请参阅有关 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fcsharp%2Flanguage-reference%2Fbuiltin-types%2Fstruct%23inline-arrays" target="_blank">struct</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fcsharp%2Flanguage-reference%2Fbuiltin-types%2Fstruct%23inline-arrays" target="_blank">类型</a>的语言参考。</p><p><strong>9.反射改进</strong></p><p>.NET 5 中引入了函数指针，但当时未添加对反射的相应支持。 对函数指针使用 typeof 或反射时（例如分别使用 typeof(delegate*&lt;void&gt;()) 或 FieldInfo.FieldType），返回了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.intptr" target="_blank">IntPtr</a>。 从 .NET 8 开始，将改为返回 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.type" target="_blank">System.Type</a> 对象。 此类型提供对函数指针元数据的访问，包括调用约定、返回类型和参数。</p><p>新功能目前仅在 CoreCLR 运行时和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.reflection.metadataloadcontext" target="_blank">MetadataLoadContext</a> 中实现。已将新的 API 添加到 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.type" target="_blank">System.Type</a>（例如 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.type.isfunctionpointer%23system-type-isfunctionpointer" target="_blank">IsFunctionPointer</a>）以及 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.reflection.propertyinfo" target="_blank">System.Reflection.PropertyInfo</a>、System.Reflection.FieldInfo 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.reflection.parameterinfo" target="_blank">System.Reflection.ParameterInfo</a>。 以下代码演示如何使用一些新 API 进行反射。</p><pre><code class="language-C#">// Sample class that contains a function pointer field.
public unsafe class UClass
{
    public delegate* unmanaged[Cdecl, SuppressGCTransition]&lt;in int, void&gt; _fp;
}

// ...

FieldInfo fieldInfo = typeof(UClass).GetField(nameof(UClass._fp));

// Obtain the function pointer type from a field.
Type fpType = fieldInfo.FieldType;

// New methods to determine if a type is a function pointer.
Console.WriteLine($"IsFunctionPointer: {fpType.IsFunctionPointer}");
Console.WriteLine($"IsUnmanagedFunctionPointer: {fpType.IsUnmanagedFunctionPointer}");

// New methods to obtain the return and parameter types.
Console.WriteLine($"Return type: {fpType.GetFunctionPointerReturnType()}");

foreach (Type parameterType in fpType.GetFunctionPointerParameterTypes())
{
    Console.WriteLine($"Parameter type: {parameterType}");
}

// Access to custom modifiers and calling conventions requires a "modified type".
Type modifiedType = fieldInfo.GetModifiedFieldType();

// A modified type forwards most members to its underlying type.
Type normalType = modifiedType.UnderlyingSystemType;

// New method to obtain the calling conventions.
foreach (Type callConv in modifiedType.GetFunctionPointerCallingConventions())
{
    Console.WriteLine($"Calling convention: {callConv}");
}

// New method to obtain the custom modifiers.
foreach (Type modreq in modifiedType.GetFunctionPointerParameterTypes()[0].GetRequiredCustomModifiers())
{
    Console.WriteLine($"Required modifier for first parameter: {modreq}");
}
</code></pre><p>输出：</p><pre><code class="language-C#">IsFunctionPointer: True
IsUnmanagedFunctionPointer: True
Return type: System.Void
Parameter type: System.Int32&amp;
Calling convention: System.Runtime.CompilerServices.CallConvSuppressGCTransition
Calling convention: System.Runtime.CompilerServices.CallConvCdecl
Required modifier for first parameter: System.Runtime.InteropServices.InAttribute
</code></pre><p><strong>10.配置绑定源生成器</strong></p><p>.NET 8 引入了一个源生成器，用于在 ASP.NET Core 中提供 AOT 和适合剪裁的配置。 该生成器是现有的基于反射的实现的替代方法。</p><p>源生成器探测 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fmicrosoft.extensions.options.configureoptions-1.configure%23microsoft-extensions-options-configureoptions-1-configure%28-0%29" target="_blank">Configure(TOptions)</a>、Bind 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fmicrosoft.extensions.configuration.configurationbinder.get" target="_blank">Get</a> 调用来从中检索类型信息。 在项目中启用生成器后，编译器将隐式选择生成的方法，而非预先存在的基于反射的框架实现。</p><p>无需更改源代码即可使用生成器。 AOT Web 应用中默认启用该生成器。 对于其他项目类型，源生成器默认关闭，但你可通过在项目文件中将 EnableConfigurationBindingGenerator 属性设置为 true 来选择使用它：</p><pre><code class="language-XML">&lt;PropertyGroup&gt;
    &lt;EnableConfigurationBindingGenerator&gt;true&lt;/EnableConfigurationBindingGenerator&gt;
&lt;/PropertyGroup&gt;
</code></pre><p>以下代码演示了调用绑定器的示例：</p><pre><code class="language-C#">using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

WebApplicationBuilder builder = WebApplication.CreateBuilder(args);
IConfigurationSection section = builder.Configuration.GetSection("MyOptions");

// !! Configure call - to be replaced with source-gen'd implementation
builder.Services.Configure&lt;MyOptions&gt;(section);

// !! Get call - to be replaced with source-gen'd implementation
MyOptions options0 = section.Get&lt;MyOptions&gt;();

// !! Bind call - to be replaced with source-gen'd implementation
MyOptions options1 = new MyOptions();
section.Bind(options1);

WebApplication app = builder.Build();
app.MapGet("/", () =&gt; "Hello World!");
app.Run();

public class MyOptions
{
    public int A { get; set; }
    public string S { get; set; }
    public byte[] Data { get; set; }
    public Dictionary&lt;string, string&gt; Values { get; set; }
    public List&lt;MyClass&gt; Values2 { get; set; }
}

public class MyClass
{
    public int SomethingElse { get; set; }
}
</code></pre><p><strong>11.针对 Android 应用的 AOT 编译</strong></p><p>为了减小应用大小，面向 Android 的 .NET 和 .NET MAUI 应用在发布模式下构建时使用分析的预先 (AOT) 编译模式。 与常规 AOT 编译相比，分析的 AOT 编译所影响的方法更少。 .NET 8 引入了 &lt;AndroidStripILAfterAOT&gt; 属性，你可使用它进一步对 Android 应用进行 AOT 编译，从而更进一步减少应用大小。</p><pre><code class="language-XML">&lt;PropertyGroup&gt;
  &lt;AndroidStripILAfterAOT&gt;true&lt;/AndroidStripILAfterAOT&gt;
&lt;/PropertyGroup&gt;
</code></pre><p>默认情况下，将 AndroidStripILAfterAOT 设置为 true 会替代默认的 AndroidEnableProfiledAot 设置，从而允许剪裁已 AOT 编译的（几乎）所有方法。 还可通过将两个属性都显式设置为 true 来结合使用分析的 AOT 和 IL 条带化：</p><pre><code class="language-XML">&lt;PropertyGroup&gt;
  &lt;AndroidStripILAfterAOT&gt;true&lt;/AndroidStripILAfterAOT&gt;
  &lt;AndroidEnableProfiledAot&gt;true&lt;/AndroidEnableProfiledAot&gt;
&lt;/PropertyGroup&gt;
</code></pre><p><strong>12.代码分析</strong></p><p>.NET 8 包括几个新的代码分析器和修复程序，可帮助验证是否正确且高效地使用 .NET 库 API。 下表总结了新的分析器。</p><table><thead><tr><th>规则 ID</th><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>CA1856</td><td>性能</td><td>未在参数上正确应用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.diagnostics.codeanalysis.constantexpectedattribute" target="_blank">ConstantExpectedAttribute</a> 属性时触发。</td></tr><tr><td>CA1857</td><td>性能</td><td>当参数使用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.diagnostics.codeanalysis.constantexpectedattribute" target="_blank">ConstantExpectedAttribute</a> 添加批注但提供的参数不是常量时触发。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1858" target="_blank">CA1858</a></td><td>性能</td><td>若要确定字符串是否以给定前缀开头，最好调用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.string.startswith" target="_blank">String.StartsWith</a>，而不是调用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.string.indexof" target="_blank">String.IndexOf</a>，然后将结果与零进行比较。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1859" target="_blank">CA1859</a></td><td>性能</td><td>此规则建议尽可能将特定局部变量、字段、属性、方法参数和方法返回类型从接口或抽象类型升级到具体类型。 使用具体类型可生成更高质量的代码。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1860" target="_blank">CA1860</a></td><td>性能</td><td>若要确定集合类型是否具有任何元素，最好使用 Length、Count 或 IsEmpty，而不是调用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.linq.enumerable.any" target="_blank">Enumerable.Any</a>。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1861" target="_blank">CA1861</a></td><td>性能</td><td>重复调用时，不会重复使用作为参数传递的常量数组，这意味着每次都会创建一个新数组。 若要提高性能，请考虑将数组提取到静态只读字段。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1865-ca1867" target="_blank">CA1865-CA1867</a></td><td>性能</td><td>对於单字符串，char 重载的性能更好。</td></tr><tr><td>CA2021</td><td>可靠性</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.linq.enumerable.cast%23system-linq-enumerable-cast-1%28system-collections-ienumerable%29" target="_blank">Enumerable.Cast(IEnumerable)</a> 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.linq.enumerable.oftype%23system-linq-enumerable-oftype-1%28system-collections-ienumerable%29" target="_blank">Enumerable.OfType(IEnumerable)</a> 需要兼容的类型才能正常运行。 泛型类型不支持扩大转换和用户定义的转换。</td></tr><tr><td>CA1510-CA1513</td><td>可维护性</td><td>在构造新的异常实例方面，引发帮助程序比 if 块更简单、更高效。 这四个分析器是为以下例外情况创建的：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.argumentnullexception" target="_blank">ArgumentNullException</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.argumentexception" target="_blank">ArgumentException</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.argumentoutofrangeexception" target="_blank">ArgumentOutOfRangeException</a> 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.objectdisposedexception" target="_blank">ObjectDisposedException</a>。</td></tr></tbody></table><p><strong>13.Core .NET 库</strong></p><p><strong>13.1 时间抽象</strong></p><p>新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.timeprovider" target="_blank">TimeProvider</a> 类和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.itimer" target="_blank">ITimer</a> 接口添加了时间抽象功能，让你可以在测试方案中模拟时间。 此外，还可以使用时间抽象，通过 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.tasks.task.delay" target="_blank">Task.Delay</a> 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.tasks.task.waitasync" target="_blank">Task.WaitAsync</a> 来模拟依赖于时间进度的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.tasks.task" target="_blank">Task</a> 操作。 时间抽象支持以下基本时间操作：</p><ul><li>检索本地和 UTC 时间</li><li>获取用于测量性能的时间戳</li><li>创建计时器</li></ul><p>以下代码片段演示了一些使用情况示例。</p><pre><code class="language-C#">// Get system time.
DateTimeOffset utcNow = TimeProvider.System.GetUtcNow();
DateTimeOffset localNow = TimeProvider.System.GetLocalNow();

// Create a time provider that works with a
// time zone that's different than the local time zone.
private class ZonedTimeProvider : TimeProvider
{
    private TimeZoneInfo _zoneInfo;

    public ZonedTimeProvider(TimeZoneInfo zoneInfo) : base()
    {
        _zoneInfo = zoneInfo ?? TimeZoneInfo.Local;
    }

    public override TimeZoneInfo LocalTimeZone =&gt; _zoneInfo;

    public static TimeProvider FromLocalTimeZone(TimeZoneInfo zoneInfo) =&gt;
        new ZonedTimeProvider(zoneInfo);
}

// Create a timer using a time provider.
ITimer timer = timeProvider.CreateTimer(callBack, state, delay, Timeout.InfiniteTimeSpan);

// Measure a period using the system time provider.
long providerTimestamp1 = TimeProvider.System.GetTimestamp();
long providerTimestamp2 = TimeProvider.System.GetTimestamp();

var period = GetElapsedTime(providerTimestamp1, providerTimestamp2);
</code></pre><p><strong>13.2UTF8 改进</strong></p><p>如果要启用将类型的类似字符串的表示形式写出到目标范围，请在类型上实现新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.iutf8spanformattable" target="_blank">IUtf8SpanFormattable</a> 接口。 此新接口与 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.ispanformattable" target="_blank">ISpanFormattable</a> 密切相关，但面向 UTF8 和 Span&lt;byte&gt;，而不是 UTF16 和 Span&lt;char&gt;。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.iutf8spanformattable" target="_blank">IUtf8SpanFormattable</a> 已在所有基元类型（以及其他）上实现，无论是面向 string、Span&lt;char&gt; 还是 Span&lt;byte&gt;，其共享逻辑完全一致。 它完全支持所有格式（包括新的「B」二进制说明符）和所有区域性。 这意味着现在可以从 Byte、Complex、Char、DateOnly、DateTime、DateTimeOffset、Decimal、Double、Guid、Half、IPAddress、IPNetwork、Int16、Int32、Int64、Int128、IntPtr、NFloat、SByte、Single、Rune、TimeOnly、TimeSpan、UInt16、UInt32、UInt64、UInt128、UIntPtr 和 Version 直接格式化为 UTF8。</p><p>新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.text.unicode.utf8.trywrite" target="_blank">Utf8.TryWrite</a> 方法向现有 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.memoryextensions.trywrite" target="_blank">MemoryExtensions.TryWrite</a> 方法（基于 UTF16）提供基于 UTF8 的对应方法。 可以使用内插字符串语法将复杂表达式直接格式化为 UTF8 字节范围，例如：</p><pre><code class="language-C#">static bool FormatHexVersion(
    short major,
    short minor,
    short build,
    short revision,
    Span&lt;byte&gt; utf8Bytes,
    out int bytesWritten) =&gt;
    Utf8.TryWrite(
        utf8Bytes,
        CultureInfo.InvariantCulture,
        $"{major:X4}.{minor:X4}.{build:X4}.{revision:X4}",
        out bytesWritten);
</code></pre><p><strong>13.3 加密</strong></p><p>.NET 8 添加了对 SHA-3 哈希基元的支持。 （目前，具有 OpenSSL 1.1.1 或更高版本和 Windows 11 Build 25324 或更高版本的 Linux 支持 SHA-3。）可在其中使用 SHA-2 的 API 现在提供对 SHA-3 的补充。 对于哈希，这包括 SHA3_256、SHA3_384 和 SHA3_512；对于 HMAC，这包括 HMACSHA3_256、HMACSHA3_384 和 HMACSHA3_512；对于其中可配置算法的哈希，这包括 HashAlgorithmName.SHA3_256、HashAlgorithmName.SHA3_384 和 HashAlgorithmName.SHA3_512；对于 RSA OAEP 加密，这包括 RSAEncryptionPadding.OaepSHA3_256、RSAEncryptionPadding.OaepSHA3_384 和 RSAEncryptionPadding.OaepSHA3_512。</p><p>以下示例演示如何使用 API（包括 SHA3_256.IsSupported 属性）来确定平台是否支持 SHA-3。</p><pre><code class="language-C#">// Hashing example
if (SHA3_256.IsSupported)
{
    byte[] hash = SHA3_256.HashData(dataToHash);
}
else
{
    // ...
}

// Signing example
if (SHA3_256.IsSupported)
{
     using ECDsa ec = ECDsa.Create(ECCurve.NamedCurves.nistP256);
     byte[] signature = ec.SignData(dataToBeSigned, HashAlgorithmName.SHA3_256);
}
else
{
    // ...
}
</code></pre><p><strong>13.4 基于流的 ZipFile 方法</strong></p><p>.NET 8 包含 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.io.compression.zipfile.createfromdirectory" target="_blank">ZipFile.CreateFromDirectory</a> 的新重载，通过它可以收集目录中包含的所有文件并压缩这些文件，然后将生成的 zip 文件存储到提供的流中。 同样，通过新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.io.compression.zipfile.extracttodirectory" target="_blank">ZipFile.ExtractToDirectory</a> 重载，可提供包含压缩文件的流，并将其内容提取到文件系统中。 下面是新的重载：</p><pre><code class="language-C#">namespace System.IO.Compression;

public static partial class ZipFile
{
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination);
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, CompressionLevel compressionLevel, bool includeBaseDirectory);
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, CompressionLevel compressionLevel, bool includeBaseDirectory, Encoding? entryNameEncoding);

    public static void ExtractToDirectory(Stream source, string destinationDirectoryName) { }
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, bool overwriteFiles) { }
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, Encoding? entryNameEncoding) { }
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, Encoding? entryNameEncoding, bool overwriteFiles) { }
}
</code></pre><p>参考资料：</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fcore%2Fwhats-new%2Fdotnet-8%23networking" target="_blank">https://learn.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-8#networking</a></p><p><strong>扩展链接：</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fblogs%2Fexcel-io-spreadjs-blazor" target="_blank">如何使用 Blazor 框架在前端浏览器中导入/导出 Excel XLSX</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fblogs%2Fcreate-flow-chart-dotnet" target="_blank">如何在.NET 电子表格应用程序中创建流程图</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fblogs%2Fsjs-realtime-data-refresh-part1" target="_blank">如何将实时数据显示在前端电子表格中</a></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 06:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/powertoolsteam/blog/10143465</guid>
            <link>https://my.oschina.net/powertoolsteam/blog/10143465</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米推出 Xiaomi Vela 快应用开发工具：Aiot-IDE]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米在今天举办的《2023&nbsp;小米 IoT 生态伙伴大会》上<a href="https://www.oschina.net/news/266688/xiaomi-vela-opensource">宣布</a>全面开源&nbsp;Xiaomi Vela。</p><p><img alt="" height="667" src="https://oscimg.oschina.net/oscnet/up-2e4d78299513d8dd8e48dd44f9f1c80cbea.png" width="500" referrerpolicy="no-referrer"></p><blockquote><p>Xiaomi Vela 是小米基于开源实时操作系统&nbsp;<strong><a href="https://www.oschina.net/p/nuttx">NuttX</a></strong>&nbsp;打造的物联网嵌入式软件平台，Vela 在各种物联网硬件平台上提供统一的软件服务，支持丰富的组件和易用的框架，打通碎片化的物联网应用场景。</p></blockquote><p>随 Xiaomi Vela 一同发布的还有 Aiot-IDE，官方称这是用于开发<strong> Xiaomi Vela 快应用</strong>的工具。据介绍，在小米智能穿戴 (Wearable) 设备上进行应用开发，此类应用统称为 <strong>Xiaomi Vela 快应用</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8c26527175a6a981cbd609b6b5fa67209b5.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-642ef5598b7a4dfdf8d448948a0b32a4fbc.png" referrerpolicy="no-referrer"></p><p>官方称 Aiot-IDE 基于 VS Code 进行开发，此外快应用的开发也类似网页开发。感兴趣可以下载安装体验：</p><ul><li><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fiot.mi.com%2Fvela%2Fquickapp%2Fzh%2Fcontent%2Fguide%2Fstart%2Fuse-ide.html" target="_blank">Aiot-IDE 下载地址</a></u>（该&nbsp;IDE 只支持在<code>Ubuntu 20.04</code>下进行 vela 项目的开发）</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 06:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266723</guid>
            <link>https://www.oschina.net/news/266723</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[开源中国将在年末推出大模型托管平台，大量人才招募中]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">Gitee 正在招募大量人才，欢迎加入。</span></span></p><p><img alt="" height="1348" src="https://static.oschina.net/uploads/space/2023/1116/151453_9FSP_3820517.jpg" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">开源中国于 2023 年 6 月完成了&nbsp;</span><strong><span style="background-color:#ffffff">7.75 亿元&nbsp;</span></strong></span><span style="color:#000000">B+ 轮战略融资</span><span style="color:#000000">，公司创始团队重新成为实际控制人，经此股份重组企业成为完全中立平台。目前，开源中国员工共计 300 余人，其中研发团队占比 85% 以上。</span></p><p><span style="color:#000000"><strong><span style="background-color:#ffffff">开源中国将在年末推出大模型托管平台</span></strong><span style="background-color:#ffffff">，在 AI 时代为广大开发者和企业提供更高质量的服务。从软件应用到 AI 时代，开源中国将坚持帮助国内开发者和企业共同发展，创造健康的生态环境。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Gitee 是开源中国旗下，国内第一大企业级研发效能平台和全球第二大开源代码托管平台。经过 10 年发展，Gitee 已经拥有超过 1100 万开发者，托管超过 2500 万个代码仓库，服务 26 万家企业（含 1200 家中大型私有化部署企业）和 2000 多所高校，为他们提供优质的 DevOps 产品服务。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 03:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266707/gitee-hiring</guid>
            <link>https://www.oschina.net/news/266707/gitee-hiring</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[金山办公 WPS AI 开启公测]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>金山办公<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FcSKhX3tqmZgdw7EfTid_TA" target="_blank">宣布</a>旗下只能办公助手 WPS AI 开启公测，即日起面向全体用户陆续开放体验。WPS AI 是一款生成式人工智能应用，具备了大语言模型能力。它提供起草、改写、总结、润色等功能，可以提高办公创作效率。</p><p>用户可前往 <strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fai.wps.cn%2F" target="_blank">WPS AI 官网</a></strong>申请权益，并下载最新版 WPS PC 客户端限时体验文字/智能文档、表格/智能表格、PPT 演示组件的 AI 能力，安卓、iOS 和 Mac 端预计将于 11 月底陆续开放。</p><p><img alt="" height="376" src="https://oscimg.oschina.net/oscnet/up-9b4717aaa45d58081e02785ba28fc5dda23.png" width="300" referrerpolicy="no-referrer"></p><p><img alt="" height="354" src="https://oscimg.oschina.net/oscnet/up-fa29542a7d817329492fdc62024e16f7025.png" width="300" referrerpolicy="no-referrer"></p><p><img alt="" height="379" src="https://oscimg.oschina.net/oscnet/up-f98e75322933cd6c5d3e5239be36401148e.png" width="300" referrerpolicy="no-referrer"></p><p>更多详细功能介绍可查看 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhome.wps.cn%2Ftopic%2F10254" target="_blank">WPS AI 能力介绍（11 月最新版）</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 03:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266706</guid>
            <link>https://www.oschina.net/news/266706</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微软将 Bing Chat 更名为 Copilot in Bing]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">在 Ignite 2023 大会上，微软宣布将今年早些时候在 Bing 上推出的 AI 聊天机器人 Bing Chat 更名为 Copilot in Bing。与此同时，Bing Chat 的高端企业版（之前称为 Bing Chat Enterprise）也已更名为 Copilot。</span></p><p><span style="color:#000000">目前该公司现在约有十几种产品共享 Copilot 品牌，微软方面表示，此次改名并不是为了造成混淆。其通信总监 Caitlin Roulston 解释称，「将 Bing Chat Enterprise 更名为 Copilot 反映了我们为消费者和商业客户打造统一的 Copilot 体验的愿景。」</span></p><p><span style="color:#000000">科技媒体 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2023%2F11%2F15%2Fbing-chat-is-now-copilot%2F" target="_blank">TechCrunch</a> 认为，虽然 Roulston 的言论有一定的道理。但也不排除是因为 Bing Chat 并没有给 Bing 带来多大的推动，所以微软希望将这项技术与推出它的搜索引擎剥离开来的原因。StatCounter 8 月份的一份报告指出，在 Bing Chat 推出六个月后，Bing 未能从 Google 手中夺取任何市场份额；不过微软方面对这一调查结果提出异议。</span></p><p><img height="279" src="https://oscimg.oschina.net/oscnet/up-3a23b972d5c87805c49dd110d3b0bb06145.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">除了改名之外，从 12 月 1 日起，使用企业账户（准确地说，是 Microsoft Entra ID）登录 Bing 的用户在 Bing 中使用 Copilot 时，将享受"商业数据保护"的好处。Roulston 称，这意味着用户的数据不会被保存、不会被用于训练人工智能模型，且微软也无法访问这些数据。</span></p><p><span style="color:#000000">「Copilot 将于 12 月 1 日更新商业条款和条件，以反映它是微软的通用产品。作为其中的一部分，它将继承微软在线服务的通用许可条款……随着时间的推移，微软将免费向更多的 Entra ID 用户提供具有商业数据保护功能的 Copilot。」</span></p><p><span style="color:#000000">除了 Copilot.Microsoft.com 和 Bing 之外，现在还可以在 Windows 中访问 Copilot，并在 Microsoft 的一系列企业订阅计划（Microsoft 365 E、E5、Business Premium 和 Business Standard）中提供，无需额外付费。Copilot 将从 12 月 1 日起包含在 Microsoft 365 F3 中。对于所有其他客户，它将以每月 5 美元的价格提供服务。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 03:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266700/bing-chat-rename-copilot</guid>
            <link>https://www.oschina.net/news/266700/bing-chat-rename-copilot</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[阿里云 11.12 故障原因曝光：访问密钥服务 (Access Key) 异常]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>针对阿里云 11.12 的重大服务故障， 该公司发给客户的一份「官方故障报告」昨天在网上被广泛流传。</span></p><blockquote><p><span>事件回顾：</span><u><a href="https://www.oschina.net/news/266144">阿里云严重故障，全线产品受影响（已恢复）</a></u></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-12e038da50562b9fb7806fac53534a272ac.png" referrerpolicy="no-referrer"></p><hr><p style="margin-left:0; margin-right:0"><strong><span>影响范围</span></strong></p><p><span style="color:#021eaa"><strong><span style="color:#021eaa">1、OSS、OTS、SLS、MNS 等产品的部分服务受到影响，大部分产品如 ECS、RDS、网络等运行不受影响。</span></strong></span></p><p><span style="color:#0052ff"><strong><span>2、云产品控制枱、管控 API 等功能受到影响。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span>时间</span></strong></p><p><span style="color:#0052ff"><strong><span>2023 年 11 月 12 日 17:39～19.20，</span></strong></span><span style="color:#021eaa"><strong><span>故障时间为 1 小时 41 分。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span style="color:rgba(0, 0, 0, 0.9)">问题概况</span></strong></p><p><span style="color:#0052ff"><strong><span>2023 年 11 月 12 日 17:39 起，阿里云云产品控制枱访问及管控 API 调用出现异常、部分云产品服务访问异常，工程师排查故障原因与访问密钥服务 (AK) 异常有关。工程师修订白名单版本后，采取分批重启 AK 服务的措施，于 18:35 开始陆续恢复，19:20 绝大部分 Region 产品控制枱和管控 API 恢复。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span style="color:rgba(0, 0, 0, 0.9)">处理过程</span></strong></p><p><span>17:39：阿里云云产品控制枱访问及管控 API 调用出现异常。</span></p><p><span>17:50：工程师确认故障是 AK 服务异常导致，影响云产品控制枱、管控 API 调<span>用异常，以及依赖 AK 服务的云产品服务运行异常。</span></span></p><p><span>18:01：工程师定位到根因。</span></p><p><span>18:07：开始执行恢复措施，包括修订白名单版本、重启 AK 服务。</span></p><p><span>18:35：杭州等 Region 开始恢复正常。</span></p><p><span>19:20：绝大部分 Region 的云产品控制枱和管控 API 调用恢复正常。</span></p><p style="margin-left:0; margin-right:0"><strong><span>原因</span></strong></p><p><span style="color:#021eaa"><strong><span>访问密钥服务 (AK）在读取白名单数据时出现读取异常，因处理读取异常的代码存在逻辑缺陷，生成了一份不完整白名单，导致不在此白名单中的有效请求失败，影响云产品控制枱及管控 API 服务出现异常，同时部分依赖 AK 服务的产品因不完整的白名单出现部分服务运行异常。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span>改进措施</span></strong></p><p><span>1、增加 AK 服务白名单生成结果的校验及告警拦截能力。</span></p><p><span>2、增加 AK 服务白名单更新的灰度验证逻辑，提前发现异常。</span></p><p><span>3、增加 AK 服务白名单的快速恢复能力。</span></p><p><span>4、加强云产品侧的联动恢复能力。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 03:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266694</guid>
            <link>https://www.oschina.net/news/266694</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米官宣 Xiaomi Vela 全面开源，底层内核为 NuttX]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米澎湃 OS 刚刚在微博<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F1786860821%2FNsNK2mfse%3Fpagetype%3Dprofilefeed" target="_blank">宣布</a></u>，Xiaomi Vela 采用 Apache 2.0 License 面向全球软硬件开发者正式开源。</p><blockquote><p><img height="1352" src="https://static.oschina.net/uploads/space/2023/1116/102959_ekSh_2720166.png" width="2000" referrerpolicy="no-referrer"></p></blockquote><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fiot.mi.com%2Fvela" target="_blank">根据官网的介绍</a></u>，Xiaomi Vela 是小米基于开源实时操作系统<strong><u><a href="https://www.oschina.net/p/nuttx">NuttX</a></u></strong>打造的物联网嵌入式软件平台，Vela 在各种物联网硬件平台上提供统一的软件服务，支持丰富的组件和易用的框架，打通碎片化的物联网应用场景。‘Vela’ 一词源自拉丁语中船帆的含义，也是南方星空中最亮的星座之一。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2e4d78299513d8dd8e48dd44f9f1c80cbea.png" referrerpolicy="no-referrer"></p><p><strong>Xiaomi Vela 主要特性</strong></p><ul><li>高效性能：Vela 基于 NuttX 内核，具有高实时性、低功耗、低延迟等特点，适用于各种资源受限的嵌入式设备。</li><li>丰富组件：Vela 提供了多种常用的组件，如网络、音频、视频、图形、安全等，方便开发者快速构建应用。</li><li>易用框架：Vela 提供了一套统一的应用框架，支持 Lua、JavaScript 等脚本语言开发应用，并提供了丰富的 API 和文档。</li><li>万物互联：Vela 支持多种通信协议和标准，如 WiFi、BLE、Zigbee、MQTT 等，并提供了小米妙享技术，实现设备之间的无缝连接和协同。</li></ul><p><strong>Xiaomi Vela 系统架构如下</strong></p><p><img src="https://oscimg.oschina.net/oscnet/up-9bc7edd16b77b3d0ef73407769d0dc0b404.png" referrerpolicy="no-referrer"></p><ul><li><strong>底层 NuttX 内核</strong>：提供最基本的任务调度、跨进程间通信、文件系统等基础 OS 功能，同时也提供简洁高效的设备驱动、轻量级的 TCP/IP 协议栈和电源管理等组件。</li><li><strong>应用框架</strong>：分为上下两层，下层是为扩展系统服务而提供的通用应用框架，上层是针对不同的物联网应用而开发的定制应用框架，例如多媒体应用框架和传感应用框架，提供 Cloud SDK 可以方便开发者更快速的接入小米云服务。</li><li><strong>开发者工具</strong>：除了常见的 Logger 和 Debugger 工具，Xiaomi Vela 还提供 Emulator 工具来帮助开发者提升调试效率，使用 Emulator，开发者可以利用 PC 端丰富的调试工具和调试信息，降低嵌入式系统开发和调试的难度。</li></ul><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fiot.mi.com%2Fvela%2Fdetail.html" target="_blank">点此查看更多细节</a></u>。</p><hr><p>延伸阅读</p><ul><li><a href="https://www.oschina.net/news/263025" target="_blank">雷军公布小米澎湃 OS 完整系统架构，称底层全部重构</a></li><li><a href="https://www.oschina.net/news/263645" target="_blank">小米澎湃 OS 正式发布，Xiaomi Vela 将开源</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 02:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266688/xiaomi-vela-opensource</guid>
            <link>https://www.oschina.net/news/266688/xiaomi-vela-opensource</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Socket.D —— 基于语义消息流的网络协议]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">Socket.D&nbsp;是一个基于连接的、可扩展的、消息驱动的传输协议。具有异步，自动分片，背压流控，双向通讯，多路复用，断线重连，支持签权，基于主题消息等特性。</p><ul><li>具有语言无关性的二进制通信协议（支持 tcp, ws, udp）</li><li>异步非阻塞消息驱动通信</li><li>可以进行流量控制、自动连接恢复</li><li>支持双向通信（如：单链接双向 RPC 接口调用）</li><li>更加适合分布式通信场景</li><li>支持 ssl，支持国密 ssl</li><li>消息有由元信息和数据组成，通过元信息实现可扩展性</li><li>接口简单</li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">开发时，主要交互只有 2 接口对象（更多可见：<a href="https://gitee.com/noear/socketd/blob/main/API.md">API.md</a><span>&nbsp;</span>）：</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#40485b; display:block; font-family:-apple-system,&quot;system-ui&quot;,&quot;Segoe UI&quot;,Helvetica,Arial,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;,&quot;Liberation Sans&quot;,&quot;PingFang SC&quot;,&quot;Microsoft YaHei&quot;,&quot;Hiragino Sans GB&quot;,&quot;Wenquanyi Micro Hei&quot;,&quot;WenQuanYi Zen Hei&quot;,&quot;ST Heiti&quot;,SimHei,SimSun,&quot;WenQuanYi Zen Hei Sharp&quot;,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:left; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:835px; word-break:initial; word-spacing:0px"><thead><tr><th>接口</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">listener</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">监听器</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">（可双向互听）</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">会话</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">（可双向互发）</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::send</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">发送</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::sendAndRequest</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">发送并请求</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">要求一次答复</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::sendAndSubscribe</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">发送并订阅</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答复结束之前，不限答复次数</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::reply</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答复</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::replyEnd</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答复结束</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr></tbody></table><h3 style="margin-left:0; margin-right:0; text-align:left">适用场景：</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">可用于 MSG、RPC、IM、MQ，等一些的场景开发，可替代 http, websocket, grpc 等一些协议。比如移动设备与服务器的连接，比如一些微服务场景等等。</p></div>
                                                                ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/socketd</guid>
            <link>https://www.oschina.net/p/socketd</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 百度搜索智能化算力调控分配方法]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img src="https://oscimg.oschina.net/oscnet/up-24c7ae180da549d2d3ab12f4b6a9d4899ff.png" alt="" referrerpolicy="no-referrer"></p><p>作者 | 泰来</p><blockquote><p>导读</p><p>随着近年深度学习技术的发展，搜索算法复杂度不断上升，算力供给需求出现了爆发式的增长。伴随着 AI 技术逐步走到深水区，算法红利在逐步消失，边际效应日益显著，算力效能的提升尤为重要，同时随着宏观经济影响，大规模的算力需求供给也遭遇到了瓶颈。同时随着流量、时间或系统故障时带来的容量变化，总算力约束也在时刻改变，周期性的出现波峰、波谷，以及会因为流量突增、网络抖动等原因导致系统出现稳定性问题。</p><p>在此背景下，需要一种更加智能化、个性化的算力调控分配方法，不断提高系统的自适应性，使得在给定资源上限的情况下，最大化资源投入的性价，同时在故障时刻发生时自适应的调整算力分配，降低系统负载。</p></blockquote><blockquote><p><em>全文 4328 字，预计阅读时间 11 分钟。</em></p></blockquote><h1><strong>01 问题与挑战</strong></h1><p>互联网行业十余年的蓬勃发展及硬件性能的持续攀升，使得 Ranking 相关算法进入到了深度学习时代，模型、技术创新层出不穷。但随着技术逐步进入到深水区，在同样的算力需求下对效果的增长边际已经非常明显。</p><p>同时伴随当前宏观经济影响，大规模算力的需求供给也持续遭遇瓶颈，如何在有限的算力资源内不断创造出更大的效果价值是一项非常有挑战性的工作。</p><p><img src="https://oscimg.oschina.net/oscnet/up-630522985830d91e7f1357f55777b530f87.png" alt="图片" referrerpolicy="no-referrer"></p><p>为此我们不断探索根据流量价值及系统状态自适应的进行算力分配，使得总体投入产出比不断提升。</p><p><img src="https://oscimg.oschina.net/oscnet/up-a64376c135fecc2ffcb80b1ecc848497a0b.png" alt="图片" referrerpolicy="no-referrer"></p><h1><strong>02 整体思路</strong></h1><p>目前搜索系统流转过程中调控手段彼此相互之间是独立的，调控的算子的输入输出没有全局视角，调控算子彼此割裂、联动和管理是比较困难的，且调控手段大多基于静态阈值配置。但我们认为系统中请求经过每层的调控算子是有状态的，理想的级联系统中每种调控算子应该是全局可见的，需要从全局的视角更好的审视业务系统，站在更高的维度去看算力调控分配这项工作。</p><p>我们在微观和宏观两方案开展了相关调控工作：</p><p><strong>1.微观</strong>：忽略系统容量状态，在当前时刻下根据流量产生的价值来动态的分配算力，使得在给定算力总约束下获得全局最优。</p><p><img src="https://oscimg.oschina.net/oscnet/up-98985f8b2a15f8558c83df58a4ebe18715d.png" alt="图片" referrerpolicy="no-referrer"></p><p><strong>2.宏观</strong>：随着流量、时间或系统故障时带来的容量变化，总算力约束在不断改变，需要在给定的资源及响应时间限制下，计算出在当前限制条件下的最优分配方式。动态的调整系统核心阶段的计算强度，合理调控峰值算力。并基于搜索系统的实时状态反馈，自动的调节系统的安全状态。使搜索系统能够在速度、资源、效果、稳定性等多个维度上进行自适应的调控。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1e6e541b843bafcd142fbd5bd3d69ef3dba.png" alt="图片" referrerpolicy="no-referrer"></p><h2><strong>2.1 问题建模</strong></h2><p><strong>变量说明：</strong></p><p>第 i 条流量\(r_i\)。</p><p>流量 i 在阶段 j 的具体信息，例如队列长度，模型选型等，可以用表示，其中的 alpha beta gamma 都可以根据经验进行设定并用实验来验证。</p><p>\(Q_(i,j) = [α*queue_length, β*cpu_usage, γ*gpu_uasage]\)</p><p>流量在第 j 阶段的折扣因子\(Y_i\)。</p><p>第 i 条流量的价值\(O_i=Y(r_i,Q_(i,1),Q_(i,2),…,Q_(i,N) )\)</p><p><img src="https://oscimg.oschina.net/oscnet/up-7c9ce2b9226f138fc1dd8bbc65e9ea1234b.png" alt="图片" referrerpolicy="no-referrer"></p><p>目标：通过调控流量在各个阶段的信息例如队列长度、模型选型等，从而调节折扣因子，最终实现流量价值最大化，假设 M 条流量经过 N 个阶段表达如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-de28539ee4bac5fbd6df6f7e3f1317cb2fd.png" alt="图片" referrerpolicy="no-referrer"></p><p>C1 成本约束，对于任意一个阶段，都必须小于等于其成本；</p><p>C2 时间约束，对于任意一个请求流量，在 N 个阶段的耗时综合都必须小于等于规定的耗时；</p><p>C3 辅助约束，对于任意一个请求任意一个阶段都必须有大于等于 0 的值。</p><p>对于一个实时的搜索系统来说，在线进行上述的优化并不太实际也会带来比较多的困难。为了简化分析和提高系统的鲁棒性，我们将上述 N 个阶段拆封成 N 个子问题，这样方便对各个阶段进行监控和可靠的干预，提高系统的鲁棒性，例如当系统出现巨大的变化时，可以随时动态调整各个阶段的参数。简化问题求解，将 C1、C2 约束进行一定的拆分。</p><p><img src="https://oscimg.oschina.net/oscnet/up-f6430b5dc5daf55c8c881024c8212a8e1b4.png" alt="图片" referrerpolicy="no-referrer"></p><p>具体来说，对于阶段 j，流量的价值最大化，我们可以看作是上述的一个子问题。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6946e0b198d88545b3f7e182609a5ae6124.png" alt="图片" referrerpolicy="no-referrer"></p><p>假设\(Y_j （r_i,Q_(i,j)）\) 是单调递增的，但其对\(Q_(i,j)\) 的导数是单调递减的，也就是其价值会随着配置资源的增加而越来越缓慢的增加。</p><h2><strong>2.2 示例说明</strong></h2><p><strong>示例：用相关性精排阶段的弹性候选集进行举例</strong></p><p>假设将流量 i 细化成第 i 条 Query，j 阶段则为具体筛选阶段，增加一个维度 k 表示 URL 级别的参数和特征信息。在正排候选集筛选阶段 k 信息表示为多个特征的分数信息，authority_feature【权威性特征】、click_feature【点击特征】...correlation_feature【相关性特征】。</p><p>则在正排候选集筛选阶段请求 i 的第 k 条 url 的信息可以表示为：</p><p><img src="https://oscimg.oschina.net/oscnet/up-0d31f093be129945380d88fc27f864dce80.png" alt="图片" referrerpolicy="no-referrer"></p><p>流量 i 在弹性候选集下的折扣因子，可以看作是 1 - 删掉 URL 数量在原本可出现在最终排序的 Top40 的概率，假如候选集合中完全没有删除的 URL 则无折扣损失，若是候选集合中删除了 URL，但对最终 Top40 的召回无影响，也可以看作是对总价值无折扣影响。</p><p><img src="https://oscimg.oschina.net/oscnet/up-c740c592761c36f2c38a784c92ba5018ff8.png" alt="图片" referrerpolicy="no-referrer"></p><p>具体来说，针对第 i 条 query 的 k 条 url 的具体信息，我们采用多个维度的特征进行考量。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1d1ec5ab10bfc446a85c856a1d408835f4c.png" alt="图片" referrerpolicy="no-referrer"></p><p>其中</p><p><img src="https://oscimg.oschina.net/oscnet/up-c45ba9cae44e13b3fb3f8f399a3e20c6626.png" alt="图片" referrerpolicy="no-referrer"></p><p>如果是 0 表示丢弃，1 表示留下第 k 条 url，希腊字母表示的是采取的阈值标准，例如评分位于后 x%。如果一个 url 的所有特征贡献度排名都处于分布的末尾，则会将该 url 从候选集中剔除。</p><p><img src="https://oscimg.oschina.net/oscnet/up-50089654880969967f46124956cfddd37f6.png" alt="图片" referrerpolicy="no-referrer"></p><h1><strong>03 关键技术</strong></h1><p>过去传统的调控方式下，既不知道上游阶段做过哪些调控动作，也不知道在自己的阶段上做的调控动作，下游是如何反馈的，只能追求自己的局部最优。而我们认为在搜索这种分层的级联系统下，越往下流转看到的特征和信号越多，调控动作应该随着流转过程发生状态转变，不应该是静态的。我们创新的采用弹性级联调控框架将调控手段进行组合，追求全局的最优解，从全链路上提升算力投入产出的性价比。</p><p><img src="https://oscimg.oschina.net/oscnet/up-58fe63995a5a07653dc25586db731a312e6.png" alt="图片" referrerpolicy="no-referrer"></p><p>具体做法，我们构建的弹性级联框架包含四个部分：</p><p><strong>1、调控算子集合</strong>，将调控动作按照 Query 级别、URL 级别、Feature 级别进行划分，调控算子拥有相同基类，接口规范统一；</p><p><strong>2、计算中心</strong>，负责实时计算各种调控动作所需的各类信号、以及流量价值的判断、容量信号的获取等；</p><p><strong>3、参数集合</strong>，经过计算中心产出的特征和信号，固化超参数，使得模块内超参数全局可见，跨模块之间按照规定协议统一进行交互；</p><p><strong>4、调控决策器</strong>，主要负责根据参数集合，确定各个阶段的调控档位设置并调用算子集合里的算子进行执行，每个调控阶段包含控制流（Control Level）和反馈流（FeedbackLevel），控制流能结合当前阶段看到的特征和信号给出它下游其他阶段的调控档位，反馈流是当前阶段参考其他阶段给出的调控档位建议和当前阶段看到的特征和信号确定实际执行的调控档位。通过这种方式，每个调控阶段既能看到到其他阶段实际执行的调控状态，同时也能根据它们对当前阶段的指导建议进行综合判断，最终在全链路上获取全局最优解。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3d45fec8e8b0e24a58b2e608cce248a3628.png" alt="图片" referrerpolicy="no-referrer"></p><p>如上图左侧可以看到整个弹性级联框架的组成部分，右侧是举例正排阶段的弹性候选集的实际计算过程，将各种维度的特征通过计算中心生成价值参数，用于调控决策器进行决策，然后给出实际的正排计算集合。我们不仅建立控制反馈流级联自适应调控系统，而且还提供了一个全局视角的弹性算力分配控制中心。弹性算力系统主要通过对集群各种维度指标的获取、策略分析及周期性执行最适合当前机器负载状态的策略组合参数来实现其核心弹性算力分配决策。</p><p>根据当前搜索系统，当前智能弹性调参把系统定义和描述为下面 4 种状态：系统异常状态，负载峰值状态，弹性过渡状态，负载低谷状态，根据不同的系统状态，执行当前状态的策略集合，从而使资源使用率及业务收益效果最优。具体方案见下图：</p><p><img src="https://oscimg.oschina.net/oscnet/up-34531ef341d0092f4c8826b061a4c72cb68.png" alt="图片" referrerpolicy="no-referrer"></p><p>主要包含流程如下：</p><p><strong>信息采集</strong>：自动化的周期性采集业务日志（流量 pv，流量分类，流量质量）和机器状态（CPU/MEM 使用率）等信息。对于这些信息进行深入挖掘分析，主要从以下几个时间维度进行采集：</p><p>1、峰值时间段模块状态信号；</p><p>2、前 n 个采集周期模块状态信号；</p><p>3、前一天同时刻前 n 个采集周期模块状态信号；</p><p>4、前一周同时刻前 n 个采集周期模块状态信号。</p><p>系统状态预估:&nbsp;对各种维度信息采集，之后通过人工规则，在线策略，离线预估等手段评估系统当前状态，把目前系统划分为系统异常状态，系统负载峰值状态，系统负载低谷状态，系统负载过渡状态。下面是系统状态定义规则，及状态转移图：</p><p><strong>系统异常状态</strong>：系统发生故障，例如系统可用性 SLA，CPU 负载率，结果空值率等不符合预期。</p><p><strong>系统负载峰值状态</strong>：系统请求数，CPU 负载率等系统容量指标大于指定阈值。</p><p><strong>系统负载低谷状态</strong>：系统请求数，CPU 负载率等系统容量指标小于指定阈值。</p><p><strong>系统负载过渡状态</strong>：负载峰值和低谷之间的过渡状态。</p><p><img src="https://oscimg.oschina.net/oscnet/up-8a94ecc0c3d4bfc093470cc02d2f1a4dff4.png" alt="图片" referrerpolicy="no-referrer"></p><p><strong>档位判断</strong>：根据系统状态抽象成便于系统决策的系统档位，及每个档位内需要关注的系统问题。</p><p><strong>1、异常档位</strong>：如何快速服务降级，保证保证系统质量。</p><p><strong>2、峰值档位</strong>：需要关注系统的稳定性和响应时间，以确保系统在高负载下依然能够稳定运行。</p><p><strong>3、低谷档位</strong>：可以考虑优化系统资源的分配，提升资源的投入产出比。在探测到系统出现异常故障状态时。</p><p><strong>4、过渡档位</strong>：一种中间状态，它的主要作用是在系统从低负载状态过渡到高负载状态，或从高负载状态过渡到低负载状态时，提供一个缓冲阶段，以避免系统状态的突然跳变。过渡档位不进行策略的调整，而是保持系统在一个相对稳定的状态。这样做的目的是为了避免频繁的策略调整带来的系统震动，保证系统的稳定性。</p><p><strong>方案决策执行：</strong></p><p>降级档位主要应对系统异常或重大风险，其对应的策略包括关闭被动触发流量，以及降低召回集合，降低复杂模型计算等策，通过这种方式降低系统的负载，保证核心业务的正常运行。低谷档位对应的是弹性策略集，这些策略主要目的是在低谷期加强复杂策略的计算，提升搜索效果。而在峰值档位，我们主要采用削峰策略，包括减少被动触发流量，以确保系统在高负载下依然能够稳定运行。</p><p><strong>示例：视频搜索弹性扩触发：</strong></p><p>在系统资源容量低谷阶段，根据指标采集数据计算当前系统容量资源冗余情况，基于冗余资源进行扩触发比例计算，通过弹性算力决策模块下发触发信号，利用闲时资源扩大流量的触发面。</p><h1><strong>04 总结与展望</strong></h1><p>通过基于弹性级联框架的调控方式，提升了分层系统的效益比，对于每个用户请求实施精细化、差异化的调控组合，在算力效能提升上取得了不错的成绩。</p><p>算力分配是架构研究的核心问题之一，未来会在以下两个方面持续开展系统性工作：</p><p>1、结合 AI 大模型的推理能力在调控组合上可以做到更加精细化，在算力效能的提升上会带来更大的挖掘空间；</p><p>2、通过自适应的宏观调控给系统稳定性带来了柔性降级能力，后续会在这个方向上持续深耕，不断提升系统自动化的处置能力。</p><p>——END——</p><p><strong>推荐阅读</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247573568%26idx%3D1%26sn%3D393c3af07b86b342aba082cb42ae6594%26chksm%3Dc03f903cf748192a906d259791b7a49b4a34742a656379482051df9c8c0411af15290af1b2b6%26scene%3D21%23wechat_redirect" target="_blank">UBC SDK 日志级别重复率优化实践</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247573374%26idx%3D1%26sn%3D9d9d6dd9fa1476416facc30344724b0f%26chksm%3Dc03fef02f7486614370c5f861cf8139e7f37c35e856eda45b4cf1c7269ae82fbe315e1750254%26scene%3D21%23wechat_redirect" target="_blank">百度搜索深度学习模型业务及优化实践</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247573218%26idx%3D1%26sn%3De5082b7c4b4c14ed9365c18ac74bc8b2%26chksm%3Dc03fee9ef7486788a9ddac5e35cd9c4e1c7bd001b533ca57b9835af04560f09a0ae95ef058c7%26scene%3D21%23wechat_redirect" target="_blank">文生图大型实践：揭秘百度搜索 AIGC 绘画工具的背后故事！</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247572968%26idx%3D1%26sn%3D6895f4d29410e3a2fc2a9884df0a078a%26chksm%3Dc03fed94f7486482f93bbdbce036341e82f50a4822eb3d91ffbd76ca018d47fe35a9f77bdd99%26scene%3D21%23wechat_redirect" target="_blank">大模型在代码缺陷检测领域的应用实践</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247572835%26idx%3D1%26sn%3D7d08b04901206d41bf39c8b07087b391%26chksm%3Dc03fed1ff74864095e11f2f4eb75b15c4abbef06649c719201f782f1f3a653cd22e9fd7f5dac%26scene%3D21%23wechat_redirect" target="_blank">通过 Python 脚本支持 OC 代码重构实践（二）：数据项提供模块接入数据通路的代码生成</a></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 13 Nov 2023 02:16:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/10143329</guid>
            <link>https://my.oschina.net/u/4939618/blog/10143329</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[向开源作者提问「项目还活着吗」非常粗鲁且无礼]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>最近几个月，开源 AI 项目的创始人 Max Woolf 经历了一场关于自己的工作的 「存在危机」。</p><p>他表示自己对 AI 的负面抵制情绪日益强烈，以及 AI 行业进展神速，Max 发现自己无法跟上进度，陷入了对开源工作的质疑。在此期间，他暂停了 GitHub 上自己开源项目的开发，其中包括 ChatGPT 的 Python 接口 simpleaichat。</p><p><img src="https://static.oschina.net/uploads/space/2023/1115/190841_hkBi_2720166.png" referrerpolicy="no-referrer"></p><p><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fminimaxir%2Fsimpleaichat" target="_blank">https://github.com/minimaxir/simpleaichat</a></u></em></p><p>简单来说，Max 压力太大，需要休息一段时间。按理来说，他的代码不应该有问题，因为项目本身设计就考虑到了他可能暂停开发的情况。</p><p>然而当 Max 想重操旧业时，却在自己项目的 GitHub 上收到了质疑开发是否已经停止的问题。尽管没有任何证据表明代码出问题，但项目 Stars 数高达 3k 的 simpleaichat 还是收到了 「这个项目被放弃了吗」 的问题。</p><p><img height="302" src="https://static.oschina.net/uploads/space/2023/1115/190713_TFZG_2720166.png" width="1454" referrerpolicy="no-referrer"></p><p>这让 Max 感到既震惊又气愤。他认为，这种质疑开发者的行为是在施加不必要的压力，也显得无礼。</p><p>事实上，开源项目从来没有 「必须持续开发」 的硬性规定。大多数开源许可协议都明确写明软件 「按原样」 提供，不承诺后续维护。但部分社区成员似乎默认开源项目有更新的义务，这让 Max 和其他开源开发者感到困扰。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9f8029289e5c8978243bb08f62b2b0a4dcf.png" referrerpolicy="no-referrer"></p><p>他认为，开源的最大优势是可以随时分叉。如果有开发者认为某项目 「死了」, 大可以复制代码自行维护。但是有些人却以 「分叉」 来威胁原作者，这让原作者不堪重负。</p><p>AI 行业进展迅速，也加重了这一问题。受 ChatGPT 热潮影响，部分 AI 新创通过风险投资大规模运营，让人产生开源 AI 必须 「快速迭代」 的误解。</p><p>Max 表示，这种对开源项目 「活跃度」 的不合理期待，已经成为阻止他继续开源工作的主要障碍。他正在考虑通过创业来全职维护自己的项目，但前景未卜。</p><p>他认为，质疑开源项目是否 「死了」 的问题本身，不可能让开发者产生继续工作的动力。开源社区如果不能保持友善，只会让更多优秀项目消失。</p><p>原文：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fminimaxir.com%2F2023%2F11%2Fopen-source-dead-github%2F" target="_blank">https://minimaxir.com/2023/11/open-source-dead-github/</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 12 Nov 2023 10:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266608/open-source-dead-github</guid>
            <link>https://www.oschina.net/news/266608/open-source-dead-github</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[零一万物对 Yi-34B 训练过程的说明]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>事件背景：</p><ul><li><a href="https://www.oschina.net/news/266377">李开复旗下 AI 公司「零一万物」开源的 Yi 大模型照搬 Llama 架构</a></li><li><a href="https://www.oschina.net/news/266525">「零一万物」 回应 Yi 开源大模型「套壳」 Llama</a></li></ul><hr><p>零一万物今天正式发文回应 Yi 开源大模型引起的争议：</p><blockquote><p>就零一万物的观察和分析，大模型社区在技术架构方面现在是一个处于接近往通用化逐步收拢的阶段，基本上国际主流大模型都是基于<strong>Transformer</strong>的架构，做 attention，activation，normalization，positional embedding 等部分的改动，LLaMA、Chinchilla、Gopher 等模型的架构和 GPT 架构大同小异，全球开源社区基于主流架构的模型变化非常之多，生态呈现欣欣向荣，国内已发布的开源模型也绝大多数采用渐成行业标准的 GPT/LLaMA 的架构。然而，大模型持续发展与寻求突破口的<strong>核心点不仅在于架构，而是在于训练得到的参数</strong>。</p><p>模型训练过程好比做一道菜，架构只是决定了做菜的原材料和大致步骤，这在大多数人的认知中也逐步形成共识。<strong>要训练出好的模型，还需要更好的「原材料」（数据）和对每一个步骤细节的把控（训练方法和具体参数）</strong>。由于大模型技术发展还在非常初期，从技术观点来说，行业共识是与主流模型保持一致的模型结构，更有利于整体的适配与未来的迭代。</p><p>零一万物在训练模型过程中，沿用了 GPT/LLaMA 的基本架构，由于 LLaMA 社区的开源贡献，让零一万物可以快速起步。零一万物<strong>从零开始训练</strong>了 Yi-34B 和 Yi-6B 模型，并根据实际的训练框架重新实现了训练代码，用自建的数据管线构建了高质量配比的训练数据集（从 3PB 原始数据精选到 3T token 高质量数据）。除此以外，在 Infra 部分进行算法、硬件、软件联合端到端优化，实现训练效率倍级提升和极强的容错能力等原创性突破。<strong>这些科学训模的系统性工作，往往比起基本模型结构能起到巨大的作用跟价值。</strong></p><p>零一万物团队在训练前的实验中，尝试了不同的数据配比科学地选取了最优的数据配比方案，投注大部分精力调整训练方法、数据配比、数据工程、细节参数、baby sitting（训练过程监测）技巧等。这一系列超越模型架构之外，研究与工程并进且具有前沿突破性的研发任务，才是真正属于模型训练内核<strong>最为关键、能够形成大模型技术护城河 know-how 积累</strong>。在模型训练同时，零一万物也针对模型结构中的若干关键节点进行了大量的实验和对比验证。举例来说，我们实验了 Group Query Attention（GQA）、Multi-Head Attention（MHA）、Vanilla Attention 并选择了 GQA，实验了 Pre-Norm 和 Post-Norm 在不同网络宽度和深度上的变化，并选择了 Pre-Norm，使用了 RoPE ABF 作为 positional embedding 等。也正是在这些实验与探索过程中，为了执行对比实验的需要，模型对部分推理参数进行了重新命名。</p><p>在零一万物初次开源过程中，我们发现用和开源社区普遍使用的 LLaMA 架构会对开发者更为友好，对于沿用 LLaMA 部分推理代码经实验更名后的疏忽，原始出发点是为了充分测试模型，并非刻意隐瞒来源。<strong>零一万物对此提出说明，并表达诚挚的歉意</strong>，我们正在各开源平台重新提交模型及代码并补充 LLaMA 协议副本的流程中，承诺尽速完成各开源社区的版本更新。</p><p>我们非常感谢社区的反馈，零一万物在开源社区刚刚起步，希望和大家携手共创社区繁荣，在近期发布 Chat Model 之后，我们将择期发布技术报告，Yi Open-source 会尽最大努力虚心学习，持续进步。</p><p><em>开源社区讨论参考：</em><br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">https://huggingface.co/01-ai/Yi-34B/discussions/11#6553145873a5a6f938658491</a></p></blockquote><p>创新工场 CMO 在转发上文的朋友圈中表示：「沿用行业演进渐成通用、生态拥抱的基础架构就成了「套模、山寨」？（就像手机 app 开发者都得益于 iOS、Android 的共通架构）。零一万物会持续从社区中虚心学习，持续进步。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-76f874328ebdab1a891bfc44ea094f539e4.png" referrerpolicy="no-referrer"></p><p>原文：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FaDclX74mPPtjQvco3GYmZQ" target="_blank">https://mp.weixin.qq.com/s/aDclX74mPPtjQvco3GYmZQ</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 12 Nov 2023 09:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266597</guid>
            <link>https://www.oschina.net/news/266597</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[CodeFuse 开源 ModelCache 大模型语义缓存]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p style="margin-left:0; margin-right:0"><img alt="" src="https://img.alicdn.com/imgextra/i2/O1CN01Moy0hq1P2Cgi8LERe_!!6000000001782-2-tps-900-383.png" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span>CodeFuse 开源火热进行中！本次开源的是 ModelCache 大模型语义缓存，可大幅降低大模型应用的推理成本，提升用户体验。</span></p><p style="margin-left:0; margin-right:0"><span>CodeFuse-ModelCache 项目地址：</span></p><p style="margin-left:0; margin-right:0"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-ModelCache" target="_blank" rel="nofollow"><span>https://github.com/codefuse-ai/CodeFuse-ModelCache</span></a></p><span id="OSC_h2_1"></span><h2><strong><span style="color:#000000">0 背景</span></strong></h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">在 LLM 技术浪潮席卷全球的背景下，大型模型快速增长的参数规模，对部署所需的推理资源带来了极大的挑战。为了提高大型模型的推理性能和效率，我们尝试从缓存角度解决当前大模型规模化服务部署的困境。类似传统应用，大模型的用户访问同样具有时间和空间的局部性（例如：热门话题相关内容，热门 GitHub repo）。如果有了缓存层，在遇到相似请求时，就无需调用大模型服务，直接从缓存的数据中返回已有的结果给用户，会大幅降低推理成本，提升用户体验。</span></p><span id="OSC_h2_2"></span><h2><span style="color:#333333">1 大模型缓存的意义</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">当前大模型服务面临一下三个挑战：</span></p><ol><li><span style="color:#333333">成本高：大模型参数量千亿级别，单实例就需要多张 A10 卡，规模化部署成本高昂。因此，当前大模型服务基本按照处理的 token 数量计费，导致用户侧使用成本也居高不下。</span></li><li><span style="color:#333333">速度慢：大型模型的推理速度也是一个关键问题。在许多实时应用中，如对话系统、业务助手，响应时间要求非常高，通常在毫秒级别。然而，大型模型的推理速度往往较慢，在秒级，导致无法实时返回结果，用户体验下降。</span></li><li><span style="color:#333333">稳定性无保障：由於单实例部署成本高昂，当前大模型服务接受到大流量请求时，通过限流的方式，防止服务不可用。</span></li></ol><span id="OSC_h2_3"></span><h2><span>2 方案调研</span></h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">我们对开源方案 GPTCache 进行了调研，其是致力于构建用于存储 LLM 响应的语义缓存的项目，该项目提供了语义相似度匹配框架，并提供了相对完善的功能模块和接口。具有以下优点：<span>&nbsp;</span></span></p><ul><li><span style="color:#333333">项目的活跃性，它不断引入新功能，使得我们能够紧跟最新的发展动态。<span>&nbsp;</span></span></li><li><span style="color:#333333">具备开放的功能模块，可以进行调整和优化，这为业务的扩展提供了便利。</span></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#333333">GPTCache 的整体架构如图 1 所示：</span></p><p style="margin-left:0; margin-right:0; text-align:left"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/275821/1699497539548-420014c2-90f5-45dc-929f-15a2e3d32ebf.png" width="642" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:center"><span style="color:#333333">图 1. GPTCache 架构</span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">但是，GPTCache 在落地应用上仍存在诸多不足，包括：</span></p><ol><li><span style="color:#333333">架构上将大模型调用和数据回写对用户进行了黑盒处理，使得大模型产品在流式输出、安全审核、问题排查等方面变的复杂。</span></li><li><span style="color:#333333">默认采用 faiss 和 sqlite 作为存储，不能进行分布式部署，尤其是在关系型数据库方面，SqlAlchemy 框架无法支持蚂蚁的 OceanBase。</span></li><li><span style="color:#333333">数据和资源隔离上，无法处理多模型多版本场景。</span></li><li><span style="color:#333333">不支持多轮会话，尤其是当模型有 system 指令时，无法很好兼容。更多待改进功能会在 3.3 部分会做详细介绍。</span></li></ol><span id="OSC_h2_4"></span><h2><span>3 ModelCache 建设</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">针对上述问题，我们基于 GPTCache 进行了二次开发，构建蚂蚁内部缓存产品 ModelCache，整体架构见图 2，接下来会详细介绍我们的工作，包括：3.1 整体架构；3.2 功能升级。在功能升级部分，会详细介绍 ModelCache 中新增的功能点。</span></p><span id="OSC_h3_5"></span><h3><span>3.1 整体架构</span></h3><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/305114/1699892547016-2e6263cc-8940-4c43-bffb-5bbd06c57998.png" width="941.818161404823" referrerpolicy="no-referrer"></p><p style="margin-left:16em; margin-right:0"><span>图 2. ModelCache 架构及上下游</span></p><span id="OSC_h4_6"></span><h4><span style="color:#000000">3.1.1 技术架构</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在初始架构中，将大模型调用和数据回写对用户进行了黑盒处理。然而，这种架构导致问题排查繁琐，以及流式输出和数据安全审核等方面难以满足企业级要求。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">因此，我们对架构进行了重新调整，ModelCache 采用了轻量化的接入方式，不打扰大模型产品的功能实现。我们设计 ModelCache 为类 redis 结构，提供了开放式的数据查询、数据回写、数据管理等 API，同时解</span><span style="color:#000000">耦</span><span style="color:#333333">了大模型调用，可作为一个独立模块嵌入到大模型产品。通过 ModelCache，产品侧能够更加灵活地管理和使用大模型，提高系统的可维护性和可扩展性。</span></p><span id="OSC_h4_7"></span><h4><span style="color:#000000">3.1.2 核心模块</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在 ModelCache 中，包含了一系列核心模块，包括 adapter、embedding、</span><span style="color:inherit">rank</span><span style="color:#333333">和 data_manager 等，具体功能如下：</span></p><ol><li><span>adapter 模块：其主要功能是处理各种任务的业务逻辑，并且能够将 embedding、</span><span style="color:inherit">rank</span><span>、data_manager 等模块串联起来。</span></li><li><span style="color:inherit">embedding 模块：该模块主要负责将文本转换为语义向量表示，它将用户的查询转换为向量形式，并用于后续的召回或存储操作。</span></li><li><span style="color:inherit">rank 模块：用于对召回的向量进行相似度排序和评估，可根据 L2 距离、余弦相似度或者评估模型，对两个向量进行相似度评分，并进行排序。</span></li><li><span style="color:inherit">data_manager 模块：该模块主要用于管理数据库，包括向量数据库和关系型数据库，它负责数据的存储、查询、更新和删除等操作。</span></li></ol><ol><li><ol><li><span style="color:inherit">向量数据库（Milvus）：</span><span style="color:#333333">Milvus 作为一个高性能、可扩展、多功能的向量数据库，适用于多种需要向量检索的应用场景。</span></li><li><span style="color:#333333">关系型数据库（OceanBase）：我们采用蚂蚁的 OceanBase 数据库，存储用户 query、LLM 相应、模型版本等信息。</span></li></ol></li></ol><span id="OSC_h4_8"></span><h4><span>3.1.3 功能对比</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">功能方面，为了解决 huggingface 网络问题并提升推理速度，增加了 embedding 本地推理能力。鉴于 SqlAlchemy 框架存在一些限制，我们对关系数据库交互模块进行了重写，以更灵活地实现数据库操作。在实践中，大型模型产品需要与多个用户和多个模型对接，因此在 ModelCache 中增加了对多租户的支持，同时也初步兼容了系统指令和多轮会话。更详细的功能对比请参见表 1。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333"><img alt="" src="https://img.alicdn.com/imgextra/i4/O1CN01P0Zr401heMlvow7LH_!!6000000004302-0-tps-716-788.jpg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0; text-align:center"><span>表 1. ModelCache 与 GPTCache 功能点对比</span></p><span id="OSC_h3_9"></span><h3><span>3.2 功能升级</span></h3><p style="margin-left:0; margin-right:0"><span style="color:inherit">为了将 Cache 产品应用于企业级用户，并实现真正的落地效果，我们对其功能进行了大量迭代升级，核心功能如图 3 所示。</span></p><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/2756586/1693799564935-9cb1f565-58a4-4f83-af78-54aaace84668.png" width="657" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:center"><span>图 3. ModelCache 核心功能</span></p><span id="OSC_h4_10"></span><h4><span>3.2.1 数据管理</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">Cache 需要确保过时或不必要的数据不会在缓存中累积，缓存管理是 Cache 中关键的一环，为此，我们实现了两个重要的功能：</span></p><ul><li><span>一键清空能力：</span><span style="color:#333333">ModelCache 中提供了数据移除接口，使用户能够一键清空其缓存。这项功能确保当模型版本或者参数发生变更时，前期版本的数据不会对线上的回答造成干扰。</span></li><li><span>缓存淘汰策略：</span><span style="color:#333333">ModelCache 支持可定制化的缓存淘汰策略，使用户能够根据自身需求来定制缓存。</span></li></ul><span id="OSC_h4_11"></span><h4><span>3.2.2 数据隔离</span></h4><p style="margin-left:0; margin-right:0"><span>在实际应用中，数据隔离是一个重要的功能，为了满足不同场景的需求，ModelCache 实现了多种数据隔离功能，包括：</span></p><ul><li><span>环境隔离： 支持在不同环境中进行数据隔离，包括 DEV、预发和线上环境。这些环境可能存在模型版本和参数上的差异，因此确保了数据在不同环境中的独立性。</span></li><li><span>模型隔离： 支持模型级别的隔离，使用向量数据库表和 OB 表字段实现独立存储。通过这种方式，不同模型之间的数据可以得到有效的隔离，确保数据的安全性和完整性。</span></li></ul><span id="OSC_h4_12"></span><h4><span>3.2.3 数据回流</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">数据回流功能具有知识持久化的能力，能够确保系统重要数据得到有效地保存和持续使用，从而支持系统的长期发展。为此，Cache 中提供了数据回流功能，使得系统中的数据能够得到有效的持久化，这项功能采用异步方式进行，尽可能减少对系统性能的影响。</span></p><span id="OSC_h4_13"></span><h4><span>3.2.4 system 指令及多轮对话支持</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在 ModelCache 中，提供了 system 指令和多轮对话支持，以满足用户的需求。具体如下：</span></p><ul><li><span style="color:#333333">system 指令支持： ModelCache 中支持 system 指令，尤其是后续用户可以自定义 system 指令的情况下，会区分不同 system 指令下对话的语义相似性，保持 Cache 的稳定性，未来，我们还计划将 system 指令与会话进行分离，以进一步提升系统的灵活性和可扩展性。</span></li><li><span style="color:#333333">多轮对话能力： ModelCache 还支持多轮对话，即能够匹配连续对话的语义相似性。</span></li></ul><span id="OSC_h4_14"></span><h4><span>3.2.5 可迁移性</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">ModelCache 具有出色的可迁移性，能够适应不同的场景，OceanBase 可以无缝迁移至 mysql 等产品，Milvus 也是一种可快速部署的数据库服务，所以无论是专有云还是公有云都能够快速应对，并提供高质量的服务。这种可迁移性意味着，ModelCache 可以为用户提供更加灵活和可扩展的部署方案，以满足不同的需求和场景。</span></p><span id="OSC_h4_15"></span><h4><span>3.2.6 Embedding 能力</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在当前的 cache 中，用户可使用中文通用 embedding 模型（text2vec-base-chinese）。我们也支持大模型 embedding 层的嵌入能力，这使得 embedding 能够更好地适应模型本身的语义，但仅使用大模型的 embedding 层，演变成了词袋模型，无法获取各个 token 的权重。为此，我们在训练 SGPT（GPT Sentence Embeddings<span>&nbsp;</span></span><span>for Semantic<span>&nbsp;</span></span><span style="color:#333333">Search），以更好的支持 ModelCache。</span></p><span id="OSC_h2_16"></span><h2>&nbsp;</h2><span id="OSC_h2_17"></span><h2><span>4 效果统计</span></h2><span id="OSC_h4_18"></span><h4><span>4.1 效率统计</span></h4><p style="margin-left:0; margin-right:0"><span>依据蚂蚁内部大模型产品的 GOC 日志信息，统计了缓存命中时长和直接调用模型时长，因为产品端采用了流式输出，时间上会有一定的增加。经过实际系统统计，命中缓存可以将平均耗时降低 10 倍，整体有效提速率可达 14.5%。有效提速率的定义参见下面公式：</span></p><p style="margin-left:0; margin-right:0"><span><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/ba80167f7563caedd5661a48c7813188.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">根据回流数据（排除流式输出的延迟），对缓存的耗时进行了评估，缓存未命中的耗时已经控制在数百毫秒量级，我们仍在持续进行查询耗时的优化。</span></p><span id="OSC_h4_19"></span><h4><span>4.2 embedding 模型的持续优化</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在缓存场景中，我们发现仅仅评估语义相似性是不够的，核心目标应该是判断 query 对应的大型模型输出是否一致（query 的语义相似不等价于大型模型的回复一致）。例如下面的 query，一词之差，但生成的结果是完全不同的</span></p><ul><li><ul><li><span style="color:#333333">query: 从 1 遍历到 1000，找出所有能被 13 和 23 整除的数字，用 Python 实现</span></li><li><span style="color:#333333">query: 从 1 遍历到 1000，找出所有能被 13 和 23 整除的数字，用 Java 实现</span></li></ul></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#333333">我们调研了 SentenceTransformer 领域的诸多模型，但都无法满足缓存场景的需求。因此训练了一个面向企业级应用的 embedding 模型，并希望在此基础上进一步提升语义相似度评估的准确性，以提高缓存的准确率。</span></p><span id="OSC_h2_20"></span><h2><span>5 未来展望</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">未来，我们旨在提供性能更强、精度更高的解决方案，以满足 LLM Cache 场景下的需求。将不断地进行研究和优化，以确保 Cache 系统能够在实际应用中取得最佳的性能和准确性</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">在性能方面，将通过深入优化各个环节，包括算法、数据和计算资源，以实现更快的召回时间，目标是将整体处理时间压缩到 300 毫秒以内，以提供更快捷高效的用户体验。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">在精度方面，将注重语义模型的建设，通过深入研究和改进语义表示技术，致力于提升模型对复杂语义的准确理解能力，从而更精准地匹配用户的 query。此外，还会对相似度评估模块进行优化，以进一步提升召回率。我们将综合考虑多种评估指标，如准确度、召回率和 F1 分数，以确保模型在各个方面都取得显著的提升。</span></p><span id="OSC_h2_21"></span><h2>&nbsp;</h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">想了解更多 CodeFuse 详情，点击进入</span><span style="color:#000000">CodeFuse 官网：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcodefuse.alipay.com%2F" target="_blank" rel="nofollow">https://codefuse.alipay.com</a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Sun, 12 Nov 2023 08:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6942768/blog/10143074</guid>
            <link>https://my.oschina.net/u/6942768/blog/10143074</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Seata 进入 Apache 孵化器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#191919">Apache 基金会邮件列表<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fincubator.apache.org%2Fprojects%2Fseata.html" target="_blank">显示</a>，2023 年 10 月 29 日，分布式事务开源项目 Seata 正式通过 Apache 基金会的投票决议，正式成为 Apache 孵化器项目。</span></p><p><span style="background-color:#ffffff; color:#191919">Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</span></p><p><img height="243" src="https://oscimg.oschina.net/oscnet/up-d0f430ca0d175df97cdbcae3599abb935b9.png" width="700" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">2019 年 1 月，阿里巴巴中间件团队发起了开源项目<span>&nbsp;</span><a href="https://www.oschina.net/p/fescar" target="_blank">Fescar</a>（Fast &amp; EaSy Commit And Rollback），和社区一起共建开源分布式事务解决方案。Fescar 的愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong>Fescar 开源后，蚂蚁金服加入 Fescar 社区参与共建，并在 Fescar 0.4.0 版本中贡献了 TCC 模式。</strong></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">为了打造更中立、更开放、生态更加丰富的分布式事务开源社区，经过社区核心成员的投票，大家决定对 Fescar&nbsp;进行品牌升级，并更名为<span>&nbsp;</span><strong>Seata</strong>，意为：<strong>Simple Extensible Autonomous Transaction Architecture</strong>，是一套一站式分布式事务解决方案。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 12 Nov 2023 08:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266588/seata-apache-incubator</guid>
            <link>https://www.oschina.net/news/266588/seata-apache-incubator</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux 内核中 Rust 的最新状态]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">在近日举行的 Linux Plumbers Conference 上，Linux 和 Rust 开发人员 Miguel Ojeda 向 Linux 内核开发人员介绍了有关 Linux 内核中 Rust 的最新情况。简而言之，Rust Linux 正在不断走向成熟，并得到了思科、三星和 Canonical 等开发者和供应商的大力支持。</span></p><p><span style="color:#000000">目前，一些发行版已经张开双臂拥抱 Rust。例如，Ubuntu 已经提供了「构建和测试树外内核模块所需的所有必要工具链和内核要求」。</span></p><p><span style="color:#000000">三大 Linux Rust 工具链也正在形成。一个是 rustc 的 GCC codegen，该工具链无需修改源代码即可编译并启动主线 Rust 和 Linux。</span></p><p><span style="color:#000000">另一个是 GCC Front-End for Rust，它可以由现有的 rustc 前端加载，但受益于 GCC 的优化；不过该项目仍处于 alpha 阶段。还有一个是 Coccinelle for Rust；Coccinelle 是一个用于制作大规模 Linux 内核 C 源代码的工具，而 Coccinelle for Rust 正试图将这一功能引入 Rust 代码库。</span></p><p><span style="color:#000000">一些开发者还在尝试使用 Rust 编写驱动程序。至于一些使 Rust 与 Linux 完全集成所需的日常工作，均可以在&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frust-for-linux.com%2F" target="_blank">Rust for Linux</a> 这一官方网站查询更多详情。</span></p><p><img height="222" src="https://oscimg.oschina.net/oscnet/up-331334d8e76a3e1efb2f883a44a9c3d254b.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">开发了两年之久的原始 rust 代码分支已经退役；代码还在，但已被冻结和归档。今后，rust-next 分支将包含新的 Rust 特性，并在 Linux 内核的下一个合并窗口中提交。而这个分支，顾名思义就是 Linux Next 的一部分。</span></p><p><span style="color:#000000">Rust-fixes 分支则包含 Linux 内核当前周期的 Rust 修复。还有一个用于集成的实验分支 Rust-dev ，是一个"look good enough"的补丁队列。</span></p><p><span style="color:#000000">理所当然的是，前进之路并非一帆风顺。Rust on Linux 的开发人员在过程中发现了一些问题：例如，当两个或多个线程等待另一个线程结束时，死锁在 Rust 中是安全的，因为它们不会导致未定义的行为，但它们在 Linux 内核中却不安全。目前开发人员正在努力解决这个问题。</span></p><p><span style="color:#000000">另一方面，开发人员还在担心如何处理 Rust 版本的问题。因为最新版本的 Rust Linux 兼容一些不稳定的功能，所以他们无法保证较新的 Rust 版本能在 Linux 中运行。Linux Rust 程序员现下正在跟踪最新版本的 Rust 编译器。</span></p><p><span style="color:#000000">与此相关的一个问题是，大众对将 Rust 支持反向移植到的 Linux 的 LTS 版本（特别是 5.15 和 6.1）中越来越感兴趣。但 Linux 通常不允许将 Rust 移植到 LTS Linux 中。因此，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zdnet.com%2Farticle%2Frust-in-linux-where-we-are-and-where-were-going-next%2F" target="_blank">ZDNet</a> 指出，如果你真的非常想要在旧版的 LTS 内核中获得功能齐全的 Rust 支持，那么你就需要以某种方式支付费用。</span></p><p><span style="color:#000000">总的来说，Rust 无疑正在成为 Linux 开发的重要语言。但在这一进程中无疑还有许多挑战需要克服，正如 Ojeda&nbsp;所述，虽然「核心团队随着新成员的加入而成长」，但前进之路上仍有很多工作要完成。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 12 Nov 2023 08:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266584/rust-in-linux</guid>
            <link>https://www.oschina.net/news/266584/rust-in-linux</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
