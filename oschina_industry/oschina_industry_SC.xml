<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 13 Dec 2023 06:06:02 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Wi-Fi 7 将于 2024 年初全面登场，速度比 Wi-Fi 6 提升 5 倍]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#262626">WiFi 联盟<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wi-fi.org%2Fdiscover-wi-fi%2Fwi-fi-certified-7" target="_blank">宣布</a></u>将在明年 1 月 9 日至 12 日参加 CES 2024，并确认基于 IEEE 802.11be 的 Wi-Fi CERTIFIED 7 认证标准将于第一季度末之前正式推出。</span>与目前的 Wi-Fi 6 标准相比，该标准有望提供千兆位速度和其他改进。</p><p><img src="https://oscimg.oschina.net/oscnet/up-bf8bb1d4062d6abcdd5bde367ecbe4cc108.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0cc0e98c02c1b0b058bc6ac02b0b37ea771.png" referrerpolicy="no-referrer"></p><p>英特尔（Intel）和博通（Broadcom）去年展示的 Wi-Fi 7（也称 802.11be）速度高达 5 Gbps，大大超过了 Wi-Fi 6 的典型最高速度约 1.7 Gbps。<strong>Wi-Fi 7 允许在 2.4GHz、5GHz 和 6GHz 频率之间无缝切换</strong>，兼容设备可同时使用这些频率，从而实现了这一目标。</p><p>此外，6GHz 频谱可提供 320MHz 的超宽信道，吞吐量比 Wi-Fi 6 翻了一番，这是速度提升的关键因素。通过从 1024 QAM 升级到 4K QAM，新标准还将传输速率提高了 20%。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-68acdc34185024028d7aabf4f9b688fd47e.png" referrerpolicy="no-referrer"></p><p>Wi-Fi 7 连接也有望比以前的规格更加稳定。多链路操作可智能平衡流量，使网络能有效容纳更多设备。联盟表示，新标准将非常适合增强现实和虚拟现实应用。美国联邦通信委员会（FCC）最近初步批准了 6GHz 频谱上的超高速 Wi-Fi 关联，这是使 VR 和 AR 设备能够利用 Wi-Fi 7 的重要一步。</p><p>2024 年的推出日期与英特尔 2022 年的预测基本吻合。该公司计划从明年开始推出支持 Wi-Fi 7 的个人电脑，并于 2025 年在市场上普及。高通公司也对 Wi-Fi 7 持乐观态度，并将其与 5G 一起纳入了 FastConnect 计划。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 05:55:55 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270823/wi-fi-certified-7</guid>
            <link>https://www.oschina.net/news/270823/wi-fi-certified-7</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Log4Shell 两周年，仍有不少项目使用包含漏洞的版本]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Log4Shell 是 Log4j 2.0（Log4J2）的一个 0day 远程代码执行漏洞，被定性为「过去十年来最大、最关键的漏洞」，最早由阿里巴巴集团于 2021 年 11 月 24 日发现并报告给 Apache 软件基金会。</p><p>尽管已经过去了两年，<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.veracode.com%2Fblog%2Fresearch%2Fstate-log4j-vulnerabilities-how-much-did-log4shell-change" target="_blank">但根据安全公司 Veracode 的报告</a></u></strong>，该漏洞的影响仍然存在。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-73861b3642e119baf3ccca3f3a037679b4f.png" referrerpolicy="no-referrer"></p><p>Veracode 分析了 2023 年 8 月 15 日至 11 月 15 日期间 90 天内的软件扫描数据，针对 3,866 个组织运行 Log4j 版本 1.1 至 3.0.0-alpha1 的 38,278 个独特应用程序。</p><p>在 Log4j 1.1 到 3.0.0-alpha1 版本中，有超过三分之一的应用程序使用了存在漏洞的 Log4j 版本。具体来说：</p><ul><li>2.8% 的应用程序仍在使用 Log4j2 2.0-beta9 到 2.15.0 之间的版本，这些版本存在 Log4Shell 漏洞。</li><li>另外 3.8% 的应用程序使用的是 Log4j2 2.17.0 版本，虽然该版本已修复了 Log4Shell 漏洞，但仍然存在 CVE-2021-44832 漏洞，这是一个高危的远程代码执行漏洞。</li><li>还有 32% 的应用程序使用的是 Log4j2 1.2.x 版本，这个版本在 2015 年 8 月已经停止维护，但在 2022 年 1 月 ASF 宣布了三个影响该版本的关键漏洞。</li></ul><p>这些数据表明，尽管各方对 Log4Shell 漏洞进行了大规模的修复工作，但仍然存在许多应用程序使用了存在漏洞的 Log4j 版本。</p><p>Veracode 的研究还发现，许多开发者在将第三方库引入到代码后从未更新过这些库。这也解释了为什么有如此大比例的应用程序在运行已经停止维护的 Log4j 版本。</p><p>此外，研究还发现，一旦开发者通过扫描发现了漏洞，他们通常会相对迅速地进行修复。但是，一些外部因素会拖慢开发人员的修复速度，例如缺乏信息或资源。</p><hr><p>延伸阅读</p><ul><li><a href="https://www.oschina.net/news/173273/log4j-maintainer-response" target="_blank">Log4j 维护者：为向后兼容没移除导致漏洞的旧功能</a></li><li><a href="https://www.oschina.net/news/174752/impact-of-apache-log4j" target="_blank">Apache Log4j 漏洞的影响规模</a></li><li><a href="https://www.oschina.net/news/203874/log4j-the-pain-just-keeps-going-and-going" target="_blank">「核弹级」 Log4j 漏洞仍普遍存在，并造成持续影响</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 03:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270803/state-log4j-vulnerabilities-2023</guid>
            <link>https://www.oschina.net/news/270803/state-log4j-vulnerabilities-2023</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Windows 11 记事本的底部状态栏将显示「字符数统计」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Windows 11 内置的文本编辑器「记事本」添加了一项重要功能：在底部状态栏显示<strong>字符数统计</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-876aae8d39e39c30417766c1912f6ab4e65.png" referrerpolicy="no-referrer"></p><p>该功能会显示使用者输入的<strong>字符总数</strong>，包括字母、数字、符号、空格、标点符号等。「字符统计」与「字数统计」不一样，字数统计仅计算文档中的单词总数，有人会觉得它比字符数统计更有用。</p><p>根据微软的<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ghacks.net%2F2023%2F12%2F08%2Fwindows-11s-notepad-is-getting-a-character-count-on-the-status-bar%2F" target="_blank">公告</a></u>，记事本中的字符数统计有两种工作方式。默认情况下，文本编辑器将在窗口底部的状态栏上显示文档的字符数。如果使用者在文档中选择了文本，记事本将分别显示所选文本的字符数和文档的总计数。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270799/windows-11s-notepad-character-count-on-the-status-bar</guid>
            <link>https://www.oschina.net/news/270799/windows-11s-notepad-character-count-on-the-status-bar</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[国产数据库的出现和消失，都不是技术问题]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><blockquote><p>最近，关于数据库国产化替代的话题甚是热门。OSCHINA 开源中国特别邀请了<strong>欧冶云商股份有限公司数据库首席薛晓刚</strong>就这一话题发表看法。</p></blockquote><span id="OSC_h2_1"></span><h2><span style="color:#2980b9">为什么要替代 Oracle?</span></h2><p>去 IOE 的背景，要从阿里巴巴去 IOE 谈起，I 是 IBM 小型机大型机，O 是 Oracle 数据库，E 是 EMC 存储。这几个搭配起来使得阿里轻松走过了最初的技术发展阶段。这个配置组合也是当年这条街最靓的仔。这个穿搭在大型银行和运营商中也很常见。这种组合的好处是就稳定，而且非常稳定。<strong>缺点可能只有一个，就是贵。</strong></p><p>随着阿里业务的增加，阿里人考虑继续这样使用的成本很高。再加上阿里开始了云计算的规划，所以提出了去 IOE 的口号。这个在其他互联网公司是不可能有的。因为其他互联网公司一开始就没有 IOE 所以不需要去。只有阿里一开始的架构是这样的。所以只有阿里提出了。</p><p>阿里做阿里云，希望用户上云。上云的核心就是数据上云。数据上云后存在哪里？自然是数据库中，如果用的数据库是 Oracle 的，那么可能要分给 Oracle 利润（要采购许可）。所以阿里打算用 MySQL 以及后来自研替代 Oracle。</p><p>从最开始的去 IOE，直到现在还经常看到各种大会上提到去 O，这用了十几年，去掉了 I 和 E。有些企业完成了去 O，而有些企业还在使用 O。</p><p><strong>那么为什么只提去 O，那不用去 DB2 和 SQLServer 吗？本质上也要去的。</strong>只是其他的数据库不如 Oracle 的使用广泛，例如现在使用和维护 DB2 的人是很少了。之所以没人提去 DB2，是因为从总体来说 DB2，已经被去掉了。所以狭义去 O 是去掉 Oracle 数据库，而广义的去 O 其实可以扩大为去 M（美国化）。</p><p>在今天不少人观点认为用 MySQL 去替代 Oracle 是无意义的。因为 MySQL 和 Oracle 同属于甲骨文公司。甚至在有的场合中还会提到要去掉 MySQL。</p><span id="OSC_h2_2"></span><h2><span style="color:#2980b9">当前数据库国产化进程情况如何?</span></h2><p>当前在信创和安可这些趋势下，国产数据库如雨后春笋般出现。在国内某权威数据库排行榜上，已经有 280 多个数据库了。实际上的数字可能比这个还要多一点。</p><p>在一些政府、金融、运营商行业都有一些国产化替换。这些替换其实不仅仅是数据库了，还包括服务器、CPU、操作系统等等。从宣传上看有些是全栈替换，有些是部分替换。也还有一些公司或者企业没有替换。然而这些都是国产厂商的宣传，至于实际的替换情况只有用户自己知道。而即使替换的用户也没有进行相关的宣传，这就使得整个情况非常的模糊。不过这个过程还在继续，还是会有一些系统从 Oracle、DB2、SQLServer 等数据库切换到国产化上来的。只是现在不确定因素太多了。</p><p>今年年初，TiDB、TDengine、TDSQL、OceanBase 四位数据库界掌门人在一场直播中大致达成一致，三年后在中国健康运营的数据库不超过 20 家。所谓健康运营是，企业能有正常营收，员工发薪正常。目前国产数据库有 280 多个产品，有的一个公司有几个产品。即使这样也是有绝大部分产品或者公司会因为无法盈利而退出舞台。用户现在也意识到了这一点，也在等情况明朗后再去选择。没有企业愿意看到花了很大代价切换的数据库无人维护了，不得不继续再次替换。</p><p>国产数据库有完全自研的，例如达梦、OceanBase 等，也有一些是基于 MySQL 做改造的，还有一些事基于 PostgreSQL 改造的，还有购买外国源码然后进行修改的。</p><span id="OSC_h2_3"></span><h2><span style="color:#2980b9">替代 Oracle 的难点在哪里?</span></h2><p>技术上，Oracle 确实领先，在数据库领域是一个标杆一样的存在。即使我们国产数据库的头部企业都认为自己和 Oracle 有较大的差距，作为学习者不断地在向 Oracle 学习。</p><p>Oracle 领先的其实不仅仅是技术，还有设计理念和前瞻性。2020 年信通院发布的白皮书中写了数据库的未来几大趋势，而在那时候这几个趋势当时 Oracle 已经部分实现和深度实现了。其实 Oracle 产品线很多，不仅仅是数据库。其中间件、硬件、操作系统等等是全方面的输出。</p><p><strong>具体到几个方面：</strong></p><p><strong>兼容性</strong><strong>。</strong>对于替换国产数据库，兼容性是一件绕不开的话题，特别是对于存量系统来说，大多数重要系统是运行在 Oracle 数据库上的，那么对于 Oracle 的<strong>基本</strong><strong>SQL</strong><strong>语法、</strong><strong>PL</strong><strong>/SQL、存储过程、触发器等</strong>的兼容性肯定是十分重要的，毕竟这涉及代码变更的问题。如果在国产数据库替换过程中出现业务适配新数据库代码变更量太大、数据库功能缺失需要业务侧代码补充、适配分布式数据库过程中对数据库设计和业务逻辑变更等现象的话，开发层面对国产数据库的抵触会非常大。</p><p><strong>性能。</strong>性能和硬件以及优化器都有很大的关系。优化器这方面目前没有能超过 Oracle 优化器的。因为这些底层都是数学算法。2021 年信通院发布的数据库发展白皮书显示，我国数据库企业针对数据库领域的平均专利数量（含国内外专利）为 38 个，最高为 500 个左右规模，数量为 0 的企业个数是 19 个，占比 24%。拥有专利数 0-4 个的企业占比最高为 51%，专利数 5-10 个的企业次之，占比 14%，专利数 21-50 个的企业数量排名第三，占比 12%。从企业专利数量上看，Oracle 以 1.4 万个全球领先，SAP 居次席。</p><p><strong>稳定性。</strong>Oracle 的稳定性还是毋庸置疑的，这也就是为什么在过去那么多年中，其一直占据着领导地位，以及使用如此广泛。企业负责人都不希望看到自己的数据库经常出问题，每次数据库的问题都可能导致故障，从而影响到在线业务。不仅仅要面对直接和间接的经济损失，还有问责的压力。</p><p>Oracle 等国外数据库有足够的全球市场，专心在技术上投入做数据库，而国产数据库厂商只能在国内有限的数据库市场内卷，需要投入大量的内卷、恶性竞争和关系处理上，无法专心把全部精力放在做数据库上。甚至还是为了如何生存而谋划。</p><p>国产数据库的出现并不是技术问题，而是其他因素。</p><p>数据库领域的人都知道，在信创活动结束之后就没有替换动力了。而最终国内市场无法容得下几百家供应商，所以大部分国产数据库的消失也不是技术问题。</p><span id="OSC_h2_4"></span><h2><span style="color:#2980b9"><strong>有哪些能够替代 Oracle 的国产数据库？</strong></span></h2><p>这个替代要讲清楚是怎么替代？如果说就是把系统关停，然后把数据导过来，然后再修改数据库的连接字符串就可以和之前一样正常使用而且稳定的。目前没见过也没听说过。</p><p>如果说换了一个国产数据库，然后把链接这个数据库的所有业务系统的软件代码进行修改（这个修改可能是 30-100%），即软件重写适配数据库或者部分需求和功能放弃，那么这样的替换还是有一些的。OceanBase、TiDB、TDSQL 等都有在不同程度上有，具体的都是应实际情况而定。</p><p>这些替换的优势，可能在于满足了政治要求。</p><p><strong>这些替换的劣势，有多方面：</strong></p><p>由于同等硬件下不如 Oracle 的性能，所以增加硬件导致成本的上升。或者分布式数据库的硬件就是比集中式硬件的多导致的硬件成本上升。</p><p>由于数据库特性和功能的缺失，所以应用程序需要改造的成本上升。这部分可能占替换总成本的 60%-80%。因为这是调动大量应用开发人员重写适配的过程。</p><p>由于稳定性上不如 Oracle，所以需要增加大量运维人员，导致运维的成本上升。</p><p>由于部分国产数据库需要许可才可以运行，所以增加了大量的许可费用。相比较之前很少采购 Oracle 许可或者甚至不采购许可来说，这部分采购费用占比很大。</p><p>以上这些成本可能会是使用 Oracle 数据库的数倍甚至几十倍甚至上百倍。而很多计算中都忽略了第二和第三项的成本。</p><span id="OSC_h2_5"></span><h2><span style="color:#2980b9">现有国产数据库跟 Oracle 相比，有多大的差距?</span></h2><p>从技术上来说，我们和 Oracle 相比有代差。</p><p>可能不同的人有不同的见解。我个人感觉有以下多方面的差距（但是不限于此）：</p><p><strong>数据库的</strong><strong>优化器</strong><strong>上：</strong>有人说为什么 Oracle 快，你可能不知道多少满头白发的数学教授在那里研究着这些。有人说：你别逼我，逼急了我什么都做的出来。」 「是吗？，那你把这道数学题给做做？」 人被逼急了还真不是什么都做的出来，起码数学就不是。各种复杂查询的核心是优化器和统计信息。而这全部都是数学问题。没有在数学上的基础投入是无法在这个领域攻坚克难的。</p><p><strong>体系架构上：</strong>如今越来越多的国产数据库考虑 RAC 架构。在经历了互联网的分布式数据库的洗礼后，越来越多的用户觉得集中式更加适合自己。所以才有了各种国产数据库厂商开始实现 RAC 的计划，达梦、优炫等。即使分布式数据库厂商在研发过程中发现 Oracle 的各种体系设计，没有一个是多余的，都是设计极其精妙的。而这些很多设计都是 30 年前甚至更早就已经设计到位的。</p><p><strong>与</strong><strong>操作系统</strong><strong>的融合上：</strong>数据库是运行在操作系统之上的，如何与 CPU 打交道？SQL 调用指令集的多少都是有讲究的。甚至有些操作是绕过操作系统直接操作的。这些都是需要深耕操作系统才能解决的。</p><p><strong>与硬件的融合上：</strong>数据库必然要和存储设备打交道。数据库的优化几乎等同于 IO 优化。所以 Oracle 直接做出来自己的存储。这些存储上都是带有 CPU 的，更好的存储和读取数据上发挥了很大的作用。做数据库是从上至下的深入解决。</p><p><strong>趋势把握上：</strong>数据库的多模和超融合这些都是 Oracle 在引领着数据库技术的前进方向。我们定义为趋势的，Oracle 基本都是已经实现的。而很多理念从设计到实现需要 8-10 年的过程。</p><span id="OSC_h2_6"></span><h2><span style="color:#2980b9"><strong>国产数据库未来要怎么走?</strong></span></h2><p>我个人角度认为，应该静下心来踏实的做技术。</p><p>最好是没有政治因素的干扰去市场上竞争，避免大跃进式的百家齐放，而是规范市场，让国内外数据库厂商同台竞争。用户结合自己的预算进行抉择，是选择廉价的还是性价比高的，让一切回归到技术本身来。而不能用政策限制其他产品进入，只能强制使用国产。这样会导致自我封闭和外部的排斥。既然我们用政策限制其他人，那么对等的就会出现别人限制我们。从而更加无法走出去。</p><p>如果真正能走出去，在国外用得起来，那么就是国产数据库的成功。中国的高铁就是因为走出去了才成为了中国的一张名片。</p><blockquote><p><strong>作者简介：</strong></p><p>薛晓刚，现任欧冶云商股份有限公司数据库首席。曾服务于政府、公安、交通、安防行业，从事过大型项目管理，设计和运维多个单表 100 亿，单机 100TB 的数据库。目前负责高可用、业务连续性和高并发数据架构设计和运维管理。</p><p>Oracle ACE-Pro（Oracle 和 MySQL 方向），Oracle OCP/MySQL OCP 及 OCP 讲师。PostgreSQL 的 PGCE 和 PCP 认证，PostgreSQL ACE Partner。墨天轮 MVP，TiDB MVA，ITPUB 论坛内存数据库版主、核心专家、金牌顾问，墨天轮社区特聘金牌讲师，机械工业出版社专家委员会委员。</p><p><img height="483" src="https://oscimg.oschina.net/oscnet/up-db67ea17186e0146cd30e998dbd09b31b55.png" width="500" referrerpolicy="no-referrer"></p><p><strong>联系作者：</strong></p><p><img height="249" src="https://oscimg.oschina.net/oscnet/up-783ed80bb94f3f8e33fb256e9e56a3413e6.png" width="500" referrerpolicy="no-referrer"></p></blockquote><p>&nbsp;</p></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 03:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/3859945/blog/10321019</guid>
            <link>https://my.oschina.net/u/3859945/blog/10321019</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[FFmpeg CLI 支持多线程 —— 数十年来「最复杂的重构」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>FFmpeg CLI 近日迎来重大改进 —— 合并了<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fffmpeg.org%2Fpipermail%2Fffmpeg-devel%2F2023-November%2F316552.html" target="_blank">多线程转码管道</a></u>&nbsp;</strong>(multi-threaded transcoding pipelines)，预计在明年发布的&nbsp;FFmpeg 7.0 中提供。</p><p><img src="https://oscimg.oschina.net/oscnet/up-69e8f13ce3a5ed36727e8f9c13a6d4cf9a0.png" referrerpolicy="no-referrer"></p><p>来源：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fffmpeg.org%2Findex.html%23cli_threading" target="_blank">https://ffmpeg.org/index.html#cli_threading</a></em></u></p><p>其开发团队表示，这项工作是「数十年来 FFmpeg CLI 最复杂的重构之一」，主要内容包括添加了线程感知的转码调度基础设施、将编码任务移动到独立线程，以及各种其他底层更改。这意味着 FFmpeg 现在可以实现并行处理任务，这将提高吞吐量和 CPU 利用率，降低延迟。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0f082465774090329fe668d4160939f9c33.png" referrerpolicy="no-referrer"></p><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fup.khirnov.net%2F7m.pdf" target="_blank">https://up.khirnov.net/7m.pdf</a></u></em></p><p>据介绍，这次更新并不是针对编解码器本身进行多线程处理，因为现代编解码器通常已经支持多线程处理。相反，FFmpeg 决定并行化的是 ffmpeg 本身，包括过滤器等。这意味着 FFmpeg CLI 现在可以更高效地处理视频转码任务。</p><p>Hacker News 上有开发者提出了一些关于视频编码的<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D38613219" target="_blank">想法</a></u>，例如将关键帧分段独立处理，以实现更好的多核性能。这种方法可以在一定程度上提高编码效率，但也需要考虑内存和编码逻辑的复杂性。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:29:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270790/ffmpeg-cli-multi-threading-merged</guid>
            <link>https://www.oschina.net/news/270790/ffmpeg-cli-multi-threading-merged</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[开源之夏 2023 圆满落幕，共同点亮开源新星]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#494949">1</span></span></span><span><span><span style="color:#494949">2</span></span></span><span><span><span style="color:#494949">月</span></span></span><span><span><span style="color:#494949">8</span></span></span><span><span><span style="color:#494949">日，随着年度优秀学生名单的公示，开源之夏 2</span></span></span><span><span><span style="color:#494949">023</span></span></span><span><span><span style="color:#494949">圆满落幕。从 3 月到 1</span></span></span><span><span><span style="color:#494949">2</span></span></span><span><span><span style="color:#494949">月，伴随着四季推进，开源之夏 2</span></span></span><span><span><span style="color:#494949">023</span></span></span><span><span><span style="color:#494949">见证了数百位高校开发者如星星之火闪烁在众多开源项目中以及他们在漫长开源之旅中留下的足迹，也见证了更多优秀的开源贡献者和开源项目的应运而生。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#494949">开源之夏&nbsp;2023&nbsp;由中国科学院软件研究所与&nbsp;openEuler&nbsp;社区联合主办，</span></span></span><span><span><span style="color:#494949">中科南京软件技术研究院承办，旨在</span></span></span><span><span><span style="color:#494949">鼓励在校学生积极参与开源软件的开发维护，促进优秀开源软件社区的蓬勃发展，助力开源软件供应链建设，让开源的力量薪火相传</span></span></span><span><span><span style="color:#494949">，是中国科学院软件研究所「开源软件供应链点亮计划」指导下的重点年度活动。</span></span></span><span><span><span style="color:#494949">本届</span></span></span><span><span><span style="color:#494949">开源之夏</span></span></span><span><span><span style="color:#494949">联合</span></span></span><span><span><span style="color:#494949">1</span></span></span><span><span><span style="color:#494949">33</span></span></span><span><span><span style="color:#494949">家国内外活跃的开源社区，</span></span></span><span><span><span style="color:#494949">针对其重要开源软件的开发与维护任务，面向全球高校学生发布项目 593 个</span></span></span><span><span><span style="color:#494949">，</span></span></span><span><span><span style="color:#494949">覆盖操作系统、人工智能、大数据、web、内核与编译器、分布式、云原生、RISC-V 等热门技术方向。</span></span></span><span><span><span style="color:#494949">时至第四届，</span></span></span><span><span><span style="color:#494949">开源之夏吸引了</span></span></span><span><span><span style="color:#494949">越来越多遍布国内外</span></span></span><span><span><span style="color:#494949">的年轻开发者参与开源社区、贡献开源。2023</span></span></span><span><span><span style="color:#494949">年，来自海内外 5</span></span></span><span><span><span style="color:#494949">92</span></span></span><span><span><span style="color:#494949">所高校的 3</span></span></span><span><span><span style="color:#494949">000</span></span></span><span><span><span style="color:#494949">多位学生参与开源之夏，</span></span></span><span><span><span style="color:#494949">504&nbsp;名学生</span></span></span><span><span><span style="color:#494949">成功</span></span></span><span><span><span style="color:#494949">中选，开启开源之旅。历经&nbsp;3&nbsp;个月的项目开发时间，最终，418&nbsp;份项目成果通过结项考核，累计产出并合并 1236 个 PR，成果陆续纳入社区主线并上线发布</span></span></span><span><span><span style="color:#494949">，随着版本更新在华为、阿里、字节、京东、腾讯、网易等企业落地应用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#494949">为了鼓励同学们，</span></span></span><span><span><span style="color:#494949">经开源社区和导师推荐，本年度</span></span></span><span><span><span style="color:#494949">组委会</span></span></span><span><span><span style="color:#494949">继续</span></span></span><span><span><span style="color:#494949">从&nbsp;4&nbsp;个方向评选出具有代表性的&nbsp;20&nbsp;位优秀学生。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p><strong><span><span><span style="color:#494949">最佳质量奖为项目角度的评选奖项，侧重项目完成质量、代码的可读性、文档的完整度使得项目具有可延续性。</span></span></span></strong></p></li><li><p><strong><span><span><span style="color:#494949">突出贡献奖为社区角度的评选奖项，侧重学生对社区的贡献度、完成项目对社区的重要性等。</span></span></span></strong></p></li><li><p><strong><span><span><span style="color:#494949">最快进步奖为学生角度的评选奖项，侧重学生参与活动的进步程度和快速学习能力。</span></span></span></strong></p></li><li><p><strong><span><span><span style="color:#494949">最具潜力奖为开源角度的评选奖项，侧重学生展现出未来持续贡献开源的潜力和意愿。</span></span></span></strong></p></li></ul><p>&nbsp;</p><p><img alt="" height="539" src="https://oscimg.oschina.net/oscnet/up-76644ac7087ce5b6c9b434dfb2567ba28a3.png" width="1252" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><img alt="" height="517" src="https://oscimg.oschina.net/oscnet/up-53e663e573fe0f8ad1bd9fae6d3e99e51f5.png" width="1216" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><img alt="" height="496" src="https://oscimg.oschina.net/oscnet/up-5f9ee24a1414766db22103aff87af28ef7b.png" width="1235" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#494949">一年活动的结束并不意味着开源参与的结束</span></span></span><span><span><span style="color:#494949">，大批新生的开源力量</span></span></span><span><span><span style="color:#494949">不断涌现并持续贡献</span></span></span><span><span><span style="color:#494949">。</span></span></span><span><span><span style="color:#494949">开源之夏 2</span></span></span><span><span><span style="color:#494949">023 调研结果显示，结项后继续留在开源社区参与开发贡献的学生</span></span></span><span><span><span style="color:#494949">高达 8</span></span></span><span><span><span style="color:#494949">0%</span></span></span><span><span><span style="color:#494949">。</span></span></span><span><span><span style="color:#494949">这些高校开发者在已有项目成果的基础上不断扩展贡献范围，有效保证</span></span></span><span><span><span style="color:#494949">了</span></span></span><span><span><span style="color:#494949">相关成果的连续性与维护性，并</span></span></span><span><span><span style="color:#494949">逐渐</span></span></span><span><span><span style="color:#494949">成长为开源项目的核心开发者。</span></span></span><span><span><span style="color:#494949">学生在开源之夏参与高质量工业化的开源项目实践，了解最前沿的技术趋势，与社区导师、资深开发者建立联系，获取更多的实践经验，为自己的职业发展打下坚实基础。同时开源社区也在活动中发掘、培养优秀开发者，完善社区建设，助力开源生态繁荣发展。让我们共同期待未来星光熠熠的开源之天空！</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:27:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270788</guid>
            <link>https://www.oschina.net/news/270788</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[院士领衔，Linux 操作系统多语言支撑技术研讨会在成都成功举行！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>2023 年 12 月 10 日，由西藏大学、内蒙古大学、青海师范大学、四川大学、电子科技大学、国防科技大学、麒麟软件有限公司、成都联图科技有限公司等单位联合举办，openKylin 社区承办的《Linux 操作系统多语言支撑技术研讨会》在成都召开！本次会议由中国工程院院士、openKylin 社区咨询委员会委员尼玛扎西教授担任主席，openKylin 社区秘书长余杰研究员担任主持。参会专家围绕 Linux 操作系统的多语言支持现状、不足和未来规划等进行深入探讨，并研讨操作系统如何助力国家更好地实现一带一路战略。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:center"><img alt="" height="517" src="https://oscimg.oschina.net/oscnet/up-7d7650099c002fecddf0ea48dc0d0aeae2f.jpg" width="853" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>首先，openKylin 社区技术委员会委员李剑峰就 openKylin 操作系统多语言版本情况向与会专家进行汇报，介绍了多语言操作系统的发布情况、版本特性、平台架构以及未来规划。未来，openKylin 操作系统将继续扩展多语言支持，包括外语拓展、少数民族语言扩展，进一步优化多语言框架，研制国内领先、国际先进的多语言支撑平台，提升我国信息领域技术核心竞争力。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>随后，参会专家围绕当前 Linux 操作系统多语言版本进行了发言。他们主要表示了要完善操作系统生态的必要性，包括办公软件的完善，集成当前主流的智能 AI 框架和大语言模型，以掌握 AI 操作系统的话语权。此外，他们还提出了进一步优化翻译平台和翻译机制的建议，并强调加强推广多语言操作系统版本的重要性。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>最后，尼玛扎西院士就本次会议进行总结发言。他强调，提高我国基础软件竞争力需采取有效策略，充分利用丰富的语言文字资源，积极响应国家需求，开发实用、好用的多语言操作系统，推动我国科技创新和发展。</span><span>我国 Linux 操作系统要扎根中国、</span><span>扬帆出海！</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:center"><img alt="" height="855" src="https://oscimg.oschina.net/oscnet/up-b67751709c8cc8e9f16b3e4e388f03eaff0.jpg" width="1280" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:18:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270783</guid>
            <link>https://www.oschina.net/news/270783</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[HyperDX —— 开发者友好的 Datadog 替代品]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>HyperDX&nbsp;是<span style="background-color:#ffffff; color:#1f2328">一个</span>基于云的生产监控和调试工具<span style="background-color:#ffffff; color:#1f2328">，统一会话重放、日志、指标、跟踪和错误。</span>通过将日志、指标、跟踪、异常和会话重播集中并关联到一处，帮助工程师更快地找出生产中断的原因。Datadog 和 New Relic 的开源且开发人员友好的替代方案。</p><ul><li>端到端关联，只需点击几下即可从浏览器会话重放到日志和跟踪</li><li>由 Clickhouse 提供支持的极快性能</li><li>直观的全文搜索和属性搜索语法（例如<code>level:err</code>）</li><li>自动对数十亿个事件中的事件模式进行聚类</li><li>仪表板高基数事件，无需复杂的查询语言</li><li>只需点击几下即可设置警报</li><li>自动解析 JSON/结构化日志</li><li>OpenTelemetry native</li></ul><p><img height="702" src="https://static.oschina.net/uploads/space/2023/0920/163847_4VuB_4252687.png" width="1220" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/hyperdx</guid>
            <link>https://www.oschina.net/p/hyperdx</link>
        </item>
        <item>
            <title>
                <![CDATA[小米回应余承东「龙骨转轴」抄袭华为言论]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>「小米公司发言人」官方微博近日发布声明，就余承东所述「龙骨转轴」抄袭华为言论做出澄清称：</p><blockquote><p>近日，余承东先生无端针对我司龙骨转轴技术发布不实言论，与事实严重不符。我们请余承东先生遵循「科学与严谨」的基本规则，请勿再抹黑同行、误导公众。</p></blockquote><p>声明指出，无论是设计思路还是机械结构，小米自研的龙骨转轴与余承东所宣称的所谓双旋水滴较链都完全不同。</p><p>且龙骨转轴于 2020 年 9 月 18 日申请专利，并于 2021 年 1 月 5 日获得专利授权，在 2023 年 8 月于 XiaomiMIXFold 了上首发应用。双旋水滴较链则于 2019 年 12 月 13 日申请的专利，2021 年 6 月 18 日才公开。「由此可知，余承东先生的言论，完全不符合事实。」</p><p><img alt="" height="1349" src="https://oscimg.oschina.net/oscnet/up-31b05e591ed808bedd4150f1214bc51f38d.jpg" width="500" referrerpolicy="no-referrer"></p><p>专利图：</p><p><img alt="" height="368" src="https://static.oschina.net/uploads/space/2023/1213/100457_fh3o_4252687.jpg" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270776</guid>
            <link>https://www.oschina.net/news/270776</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 物联网智能网关系统，物联大师]]>
            </title>
            <description>
                <![CDATA[<h1><a id="物联大师" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E7%89%A9%E8%81%94%E5%A4%A7%E5%B8%88"></a>物联大师</h1><p><strong>注意，[V3.0]版本与<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Ftree%2Fv2">V2.0</a>
和<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Ftree%2Fv1">V1.0</a>有较大差异，不可以直接升级！！！</strong></p><h3><a id="说明文档--演示 demo-账号密码-admin-123456" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3--%E6%BC%94%E7%A4%BAdemo-%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81-admin-123456"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fiot-master.com%2Fmanual">说明文档</a><a href="https://gitee.com/link?target=http%3A%2F%2Fdemo.iot-master.com%3A8080%2F">演示 demo</a> 账号密码 admin 123456</h3><p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Factions%2Fworkflows%2Fgo.yml"><img src="https://github.com/zgwit/iot-master/actions/workflows/go.yml/badge.svg" alt="Go" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Factions%2Fworkflows%2Fcodeql-analysis.yml"><img src="https://github.com/zgwit/iot-master/actions/workflows/codeql-analysis.yml/badge.svg" alt="Go" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fcodecov.io%2Fgh%2Fzgwit%2Fiot-master"><img src="https://codecov.io/gh/zgwit/iot-master/branch/main/graph/badge.svg?token=AK5TD8KQ5C" alt="codecov" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fpkg.go.dev%2Fgithub.com%2Fzgwit%2Fiot-master"><img src="https://pkg.go.dev/badge/github.com/zgwit/iot-master.svg" alt="Go Reference" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgoreportcard.com%2Freport%2Fgithub.com%2Fzgwit%2Fiot-master"><img src="https://goreportcard.com/badge/github.com/zgwit/iot-master" alt="Go Report Card" referrerpolicy="no-referrer"></a></p><p>物联大师是<a href="https://gitee.com/link?target=https%3A%2F%2Flabs.zgwit.com">无锡真格智能科技有限公司</a>
推出的开源且免费的物联网操作系统，内置 MQTT、TCP Server/Client、UDP Server/Client、串口等接入服务，
系统集成标准 Modbus，水务（SL651、SZY206），电力（DL/T645、IEC101、102、103、104、61850）以及一些主流 PLC 协议，
系统可以通过插件支持数据采集、公式计算、定时控制、异常报警、自动控制策略、流量监控、远程调试、Web 组态等功能，
适用于大部分物联网或工业互联网应用场景。
系统采用 Golang 编程实现，支持多种操作系统和 CPU 架构，可以运行在智能网关上，也可以安装在现场的电脑或工控机上，还能部署到云端服务器。</p><p>项目摒弃复杂的平台架构思维，远离微服务，从真实需求出发，注重用户体验，做到简捷而不简单，真正解决物联网缺乏灵魂的问题。</p><p>我们的宗旨是：<strong>让物联网实施变成一件简单的事情!!!</strong></p><h2><a id="项目的优势" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BC%98%E5%8A%BF"></a>项目的优势</h2><ul><li>开源免费，商业应用也不限制</li><li>单一程序文件，不需要配置运行环境，不依赖第三方服务，放服务器上就能跑</li><li>极小内存占用，对于一百节点以内的物联网项目，只需要几十兆内存足够了，<del>比起隔壁 Java 动辄大几百兆内存简直太省了</del></li><li>支持工控机和智能网关，边缘计算也没问题</li><li>支持大屏展示，Web 组态，3D 数据孪生 <del>毕竟很多物联网项目都是面子工程</del></li><li>在线产品库、模板库、组件库，小白也能分分钟搞得有模有样【还在努力建设中】</li></ul><h2><a id="项目示例" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E9%A1%B9%E7%9B%AE%E7%A4%BA%E4%BE%8B"></a>项目示例</h2><p><img src="https://iot-master.com/web1.jpg" alt="web" referrerpolicy="no-referrer"><img src="https://iot-master.com/hmi-editor.png" alt="scada" referrerpolicy="no-referrer"></p><h2><a id="咨询服务" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E5%92%A8%E8%AF%A2%E6%9C%8D%E5%8A%A1"></a>咨询服务</h2><p><strong>本公司目前提供免费的物联网方案咨询服务，结合我们十多年的行业经验，给您提供最好的建议，请联系 15161515197（微信同号）</strong></p><blockquote><p>PS. 提供此服务的主要目的是让用户少走弯路，为物联网行业的健康发展尽绵薄之力。
总结一下常见的弯路：</p><ol><li>前期使用某个物联网云平台，后期没办法继续，二次开发受限</li><li>花了几千元买了工业网关，用着一百元 DTU 的功能</li><li>找多个外包公司，低价拿单，结果做出屎一样的东西</li><li>盲目使用开源项目，最终被开源项目所累</li><li>硬件选型失败，效果差强人意</li><li>自身技术人员能力有限，架构设计有问题</li><li>不支持高并发量，市场爆发了，平台反而跟不上</li><li>等等</li></ol></blockquote><h2><a id="联系方式" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F"></a>联系方式</h2><ul><li>邮箱：<a href="mailto:jason@zgwit.com">jason@zgwit.com</a></li><li>手机：<a>15161515197</a>(微信同号)</li></ul><table><thead><tr><th>技术交流群</th><th>微信</th></tr></thead><tbody><tr><td><img src="https://iot-master.com/tech.png" alt="微信群" referrerpolicy="no-referrer"></td><td><img src="https://iot-master.com/jason.jpg" alt="微信" referrerpolicy="no-referrer"></td></tr></tbody></table><h2><a id="开源协议" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE"></a>开源协议</h2><p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Fblob%2Fmain%2FLICENSE">GPL v3</a></p><p>补充：任何组织或个人都可以免费使用或做二次开发，但不得用于商业售卖，如有需求请联系我们。</p><h3><a id="官方插件" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E5%AE%98%E6%96%B9%E6%8F%92%E4%BB%B6"></a>官方插件</h3><p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Forgs%2Fiot-master-contrib%2Frepositories">插件库</a></p><table><thead><tr><th>插件</th><th>完成</th><th>正式版</th></tr></thead><tbody><tr><td>历史统计【内置】</td><td>✅</td><td>⬜</td></tr><tr><td>异常报警【内置】</td><td>✅</td><td>⬜</td></tr><tr><td>Influxdb 时序数据库</td><td>✅</td><td>⬜</td></tr><tr><td>Modbus 通讯协议</td><td>✅</td><td>⬜</td></tr><tr><td>WebRTC 接入摄像头</td><td>✅</td><td>⬜</td></tr><tr><td>Web 组态</td><td>✅</td><td>⬜</td></tr><tr><td>3D 数据孪生</td><td>⬜</td><td>⬜</td></tr><tr><td>阿里云通知</td><td>✅</td><td>⬜</td></tr><tr><td>DLT645-2007，电力规约</td><td>⬜</td><td>⬜</td></tr><tr><td>西门子 PLC，S7 系统，PPI，MPI，FetchWrite</td><td>✅</td><td>⬜</td></tr><tr><td>三菱 PLC</td><td>✅</td><td>⬜</td></tr><tr><td>欧姆龙 PLC，Hostlink，Fins</td><td>✅</td><td>⬜</td></tr><tr><td>TDEngine</td><td>⬜</td><td>⬜</td></tr><tr><td>OpenTSDB</td><td>⬜</td><td>⬜</td></tr><tr><td>流式计算</td><td>⬜</td><td>⬜</td></tr><tr><td>报表引擎</td><td>⬜</td><td>⬜</td></tr></tbody></table>]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 01:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/zgwit_labs/iot-master</guid>
            <link>https://gitee.com/zgwit_labs/iot-master</link>
        </item>
        <item>
            <title>
                <![CDATA[AutoMQ 社区双周精选第二期（11.20-12.01）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>本期概要</h2><p>在开源的第二个双周里，作为一个成长中的开源项目，AutoMQ 做了很多的优化和重构，以下是相关重点动态的总结。<br> AutoMQ Kafka：写链路耗时优化、快慢读隔离、Spot 实例强制回收容灾。<br> AutoMQ RocketMQ：历史数据冷读优化、LogCache 读写耗时优化、发布 v0.0.3-alpha 版本、发布 Helm Chart、发布文档站。</p><h2>AutoMQ Kafka 精选动态</h2><h3>写链路耗时优化</h3><p>原来所有的写入和回调都会放到一个单线程线程池去进行处理来确保数据安全，该方式存在线程上下文切换通信、单线程处理排队两个问题。本次优化将写入流程中的数据结构改造成线程并发安全模式，使得不同 stream 之间可以并发进行写入，AutoMQ Kafka 客户端平均写入耗时<strong>下降 0.3ms</strong>。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F728" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/728</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F729" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/729</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F743" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/743</a></p><h3>快慢读隔离</h3><p>隔离从 Cache 读取的快读和从 S3 的读取的慢读，避免慢读占满快读的线程池影响快读。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-kafka%2Fpull%2F472" target="_blank">https://github.com/AutoMQ/automq-for-kafka/pull/472</a></p><p><strong>Spot 实例强制回收容灾</strong></p><p>在上期精选中提及进度的 Spot 实例强制回收容灾已经完成。Spot（竞价实例）相比按需实例可以便宜至多 90 %，但问题是它可能不经通知就强制回收。该特性支持 Spot 实例强制回收的情况下，仍旧可以将数据卷挂载到存活的机器，进行<strong>秒级容灾恢复</strong>。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-kafka%2Fissues%2F447" target="_blank">https://github.com/AutoMQ/automq-for-kafka/issues/447</a></p><h2>AutoMQ RocketMQ 精选动态</h2><h3>Stream 模块性能优化</h3><h4>历史数据冷读优化</h4><p>历史数据追赶读优化，Fetch 请求（50MB &amp; 50 stream）冷读穿透到 S3 场景，单次 Fetch 耗时从 4s 优化到 100ms。即使是完全穿透冷读，S3 读取吞吐效率也是很高的。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F766" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/766</a></p><h4>LogCache 读写耗时优化</h4><p>增加上次 Cache 读取位点记录，避免每次从 LogCache 读取数据都需要二分查找定位，10W 个消息下 10W 次查询时间从 71s 优化到 86ms。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F731" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/731</a> 通过读写锁，将 LogCache 升级成线程并发安全的数据结构，提升 LogCache 读取并发效率。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F701" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/701</a></p><h3>发布 v0.0.3-alpha 版本</h3><p>这个版本包含了以下功能和优化： 1）稳定性与性能提升：修复了潜在的 OOM 问题以及提升 stream 模块性能，详见 Changelog：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fcompare%2Fv0.0.2-alpha...v0.0.3-alpha" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/compare/v0.0.2-alpha...v0.0.3-alpha</a> 2）工程化建设：引入 Nightly build 和&nbsp;E2E test CI <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhub.docker.com%2Fr%2Fautomqinc%2Fautomq-for-rocketmq%2Ftags" target="_blank">https://hub.docker.com/r/automqinc/automq-for-rocketmq/tags</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Factions%2Fworkflows%2Fbuild-ci.yml" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/actions/workflows/build-ci.yml</a> 3）可观测性提升：为 stream 模块引入 Metrics；为 Proxy、Store 模块引入 Trace <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F766" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/766</a></p><h3>发布 Helm Chart</h3><p>现在可以使用 Helm Chart 快速在 Kubernetes 中创建 AutoMQ RocketMQ 集群。</p><pre><code class="language-cs">$ helm repo add automq https://charts.automq.com
$ helm search repo automq                                                                                                                                                            
NAME                            CHART VERSION   APP VERSION     DESCRIPTION                                                                                                           
automq/automq-for-rocketmq      0.0.4           v0.0.3-alpha    A Helm chart for automq-for-rocketmq
</code></pre><p>部署该 Chart 会创建一个 AutoMQ RocketMQ Broker 以及依赖的 MySQL 与 Minio 组件。后续会陆续加入可选的可观测性依赖组件。</p><h3>发布文档站</h3><p>介绍了 AutoMQ RocketMQ 基本使用方式，包含：本地构建、使用 docker compose 部署、在 Kubernetes 上部署。以及使用 CLI 运维集群模式，管理 Topic 等资源。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.automq.com%2Fzh%2Fdocs%2Fautomq-rocketmq%2FRmuXwhb5Xi9zjCkrInRcCz0UnTe" target="_blank">https://docs.automq.com/zh/docs/automq-rocketmq/RmuXwhb5Xi9zjCkrInRcCz0UnTe</a></p><h2>More Things</h2><p>与小红书的同学共创对象存储跨地域容灾方案 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-kafka%2Fissues%2F477" target="_blank">https://github.com/AutoMQ/automq-for-kafka/issues/477</a></p><p>以上是第二期《双周精选》的内容，欢迎关注我们的公众号，我们会定期更新 AutoMQ 社区的进展。同时，也诚邀各位开源爱好者持续关注我们社区，跟我们一起构建云原生消息中间件！</p><p><strong>END</strong></p><h3>关于我们</h3><p>AutoMQ 是一家专业的消息队列和流存储软件服务供应商。AutoMQ 开源的 AutoMQ Kafka 和 AutoMQ RocketMQ 基于云对 Apache Kafka、Apache RocketMQ 消息引擎进行重新设计与实现，在充分利用云上的竞价实例、对象存储等服务的基础上，兑现了云设施的规模化红利，带来了下一代更稳定、高效的消息引擎。此外，AutoMQ 推出的 RocketMQ Copilot 专家系统也重新定义了 RocketMQ 消息运维的新范式，赋能消息运维人员更好的管理消息集群。&nbsp;</p><p>🌟&nbsp;GitHub 地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ" target="_blank">https://github.com/AutoMQ</a></p><p>💻&nbsp;官网：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.automq.com" target="_blank">https://www.automq.com</a></p><p>👀&nbsp;B 站：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspace.bilibili.com%2F3546572478482870" target="_blank">AutoMQ 官方账号</a></p><p>🔍&nbsp;视频号：AutoMQ&nbsp;</p><p><strong>👉 扫二维码</strong>加入我们的社区群</p><p><img src="https://oscimg.oschina.net/oscnet/up-c4c6b2be9441c750e268dd2d48294131af7.png" alt="" referrerpolicy="no-referrer"></p><p>关注我们，一起学习更多云原生干货</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 01:46:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6990971/blog/10320900</guid>
            <link>https://my.oschina.net/u/6990971/blog/10320900</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[云原生周刊：Kubernetes v1.29 新特性一览]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>开源项目推荐</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwerf%2Fkubedog" title="kubedog" target="_blank">kubedog</a></h3><p>Kubedog 是一个用于在 CI/CD 部署管道中监视和跟踪 Kubernetes 资源的库。</p><p>这个库被用于 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwerf%2Fwerf" title="werf CI/CD" target="_blank">werf CI/CD</a> 工具中，在部署过程中跟踪资源。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frunwhen-contrib%2Frunwhen-local" title="RunWhen Local" target="_blank">RunWhen Local</a></h3><p>runwhen-local 是一个工具，用于在本地环境中运行 runwhen 脚本。runwhen 是一个灵活的任务调度工具，可以根据条件和时间表来执行任务。通过 runwhen-local，开发者可以在本地测试和调试 runwhen 脚本，以确保其正确运行。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubewharf%2Fkubegateway" title="KubeGateway" target="_blank">KubeGateway</a></h3><p>kube-gateway 是字节跳动内部管理海量 kubernetes 集群的最佳实践。 它是为 kube-apiserver 的 HTTP2 流量专门设计并定制的七层负载均衡代理。 目标是为海量的大规模 kubernetes 集群（千级 node 以上）提供灵活的稳定的流量治理方案。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fflannel-io%2Fflannel" title="flannel" target="_blank">flannel</a></h3><p>Flannel 是为 Kubernetes 设计的一种简单且易于配置的第三层网络结构的解决方案。</p><h2>文章推荐</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmoelove.info%2F2023%2F12%2F10%2FKubernetes-v1.29-%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7%25E4%25B8%2580%25E8%25A7%2588%2F" target="_blank">Kubernetes v1.29 新特性一览</a></h3><p>这篇文章介绍了 Kubernetes v1.29 版本的新特性。该版本包含了 49 个主要的更新，其中有 19 个增强功能进入 Alpha 阶段，19 个升级到 Beta 阶段，还有 11 个升级到稳定版。</p><p>文章重点介绍了两个重要的特性：基于 CEL 的 CRD 规则校验和为动态和静态分配预留 NodePort 端口范围。基于 CEL 的 CRD 规则校验是一种在 CRD 声明中编写校验规则的方式，简化了开发和维护成本。而为动态和静态分配预留 NodePort 端口范围的特性解决了在创建 NodePort 时可能产生的端口冲突问题。总体而言，Kubernetes v1.29 版本的新特性为用户提供了更好的功能扩展和更可靠的输入校验。</p><h3>[Kubernetes：Pod 和 WorkerNodes – 控制 Pod 在节点上的放置</h3><p>](<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frtfm.co.ua%2Fen%2Fkubernetes-pods-and-workernodes-control-the-placement-of-the-pods-on-the-nodes%2F" target="_blank">https://rtfm.co.ua/en/kubernetes-pods-and-workernodes-control-the-placement-of-the-pods-on-the-nodes/</a>)</p><p>这篇文章介绍了在 Kubernetes 中如何控制 Pods 在 WorkerNodes 上的部署位置。它提供了四种主要的方法来实现这种控制：</p><ul><li>配置节点</li><li>Taints 和 Tolerations</li><li>配置 Pod 本身</li><li>Pod 亲和性和反亲和性</li></ul><p>此外，文章还提到了 Pod 拓扑分布约束（Pod Topology Spread Constraints），即根据失败域（regions、可用区或节点）的规则来放置 Pod。</p><p>文章还提供了一些使用 kubectl explain 命令来查看相关参数和资源文档的技巧。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmedium.com%2F%40geoffrey.muselli%2Fargocd-multi-tenancy-strategy-94d72183c94" title="ArgoCD：多租户策略" target="_blank">ArgoCD：多租户策略</a></h3><p>这篇文章介绍了使用 ArgoCD 实现多租户策略的方法。在使用 ArgoCD 时，通常会允许所有用户自由操作，直到进入生产环境后才意识到某个人通过删除应用程序而删除了命名空间或 CRD。为了解决这个问题，需要使用访问控制和多租户策略。文章详细介绍了如何利用 ArgoCD 的原生功能实现多租户策略，并提供了一个示例来演示如何在大型组织中使用企业敏捷框架（例如 SAFe）来实施。文章还讨论了 ArgoCD 中的 AppProject、RBAC 和命名空间等概念，以及如何配置和使用它们来实现多租户策略。最后，文章提供了一个具体的示例，展示了如何根据团队和项目的需求来配置 AppProject 和 RBAC。</p><h2>云原生动态</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io%2Fblog%2F2023%2F12%2F05%2Fkyverno-completes-third-party-security-audit%2F" title="Kyverno 完成第三方安全审计" target="_blank">Kyverno 完成第三方安全审计</a></h3><p>Kyverno 项目宣布完成了第三方安全审计。该审计是由 Ada Logics 与 Kyverno 维护人员、开源技术改进基金合作进行，由 CNCF 资助。</p><p>该安全审计是一个全面的安全审计，有以下四个目标：</p><ul><li>为 Kyverno 定义一个正式的威胁模型。</li><li>对代码进行手动安全漏洞审计。</li><li>根据威胁模型评估 Kyverno 的模糊测试套件。</li><li>针对 SLSA 评估 Kyverno 的供应链风险。</li></ul><blockquote><p>本文由博客一文多发平台 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenwrite.cn%3Ffrom%3Darticle_bottom" target="_blank">OpenWrite</a> 发布！</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 11:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4197945/blog/10320847</guid>
            <link>https://my.oschina.net/u/4197945/blog/10320847</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[.NET 8 极致性能优化 - Reflection（反射）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><strong><span style="color:#3c70c6">前言</span></strong></span></h1><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>反射一直是性能的瓶颈，所以无论哪个.NET 版本反射的优化必然少不了。主要是集中在两个方面优化，分配和缓存。.NET8 自然也不例外。本篇看下。</span></p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">原文:<u><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5NDYwNjU4MA%3D%3D%26mid%3D2247485722%26idx%3D1%26sn%3Da126d8687afbc4b980533ec7fd239026%26chksm%3Dc01c4481f76bcd97a92c031859b0327a4460f7b4c73dad11cb0f45fa9c283954e5c95f442eec%26token%3D322944710%26lang%3Dzh_CN%23rd" rel="nofollow" target="_blank">.NET8 极致性能优化 Reflection</a></strong></u></p><span id="OSC_h1_2"></span><h1><span><strong><span style="color:#3c70c6">概述</span></strong></span></h1><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>比如针对 GetCustomAttributes 通过反射获取属性的优化，以下例子</span></p><pre><code><span><em>// dotnet run -c Release -f net7.0 --filter "*" --runtimes net7.0 net8.0</em></span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">Tests</span></span></code><code><span>{</span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">object</span>[] <span style="color:#dd1144">GetCustomAttributes</span>()</span> =&gt; <span style="color:#ca7d37">typeof</span>(C).GetCustomAttributes(<span style="color:#ca7d37">typeof</span>(MyAttribute), inherit: <span style="color:#0e9ce5">true</span>);</span></code><code><span>    [<span style="color:#afafaf">My(Value1 = 1, Value2 = 2)</span>]</span></code><code><span><span style="color:#ca7d37">class</span><span style="color:#dd1144">C</span> { }</span></code><code><span>    [<span style="color:#afafaf">AttributeUsage(AttributeTargets.All)</span>]</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">MyAttribute</span> : <span style="color:#dd1144">Attribute</span></span></code><code><span>    {</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">int</span> Value1 { <span style="color:#ca7d37">get</span>; <span style="color:#ca7d37">set</span>; }</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">int</span> Value2 { <span style="color:#ca7d37">get</span>; <span style="color:#ca7d37">set</span>; }</span></code><code><span>    }</span></code><code><span>}</span></code></pre><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>.NET7 和.NET8 明显的差异，它主要是优化了</span><span>避免分配一个 object[1]数组来设置属性的值</span></p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,BlinkMacSystemFont,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:17px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:676.989px; word-spacing:0px"><tbody><tr><th>方法</th><th>运行时</th><th>平均值</th><th>比率</th><th>分配</th><th>分配比率</th></tr></tbody><tbody><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">GetCustomAttributes</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1,287.1 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">296 B</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">GetCustomAttributes</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">994.0 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.77</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">232 B</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.78</td></tr></tbody></table><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">其它的比如减少反射堆栈中的分配，比如通过更自由的 spans。改进了 Type 上的泛型处理，从而提升各种与泛型相关的成员性能，比如 GetGenericTypeDefinition，它的结果现在被缓存在了 Type 对象上​​​​​​​</p><pre><code><span><em>// dotnet run -c Release -f net7.0 --filter "*" --runtimes net7.0 net8.0</em></span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">Tests</span></span></code><code><span>{</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span> Type _type = <span style="color:#ca7d37">typeof</span>(List&lt;<span style="color:#ca7d37">int</span>&gt;);</span></code><code><span>&nbsp;&nbsp;&nbsp;&nbsp;<span><span style="color:#ca7d37">public</span>&nbsp;Type&nbsp;<span style="color:#dd1144">GetGenericTypeDefinition</span>()</span>&nbsp;=&gt;&nbsp;_type.GetGenericTypeDefinition();</span></code><code><span>}</span></code></pre><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>.NET7 和.NET8 如下</span></p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,BlinkMacSystemFont,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:17px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:676.989px; word-spacing:0px"><tbody><tr><th>方法</th><th>运行时</th><th>平均值</th><th>比</th></tr></tbody><tbody><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">GetGenericTypeDefinition</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">47.426 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">GetGenericTypeDefinition</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">3.289 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.07</td></tr></tbody></table><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span><span style="background-color:#ffffff">这</span>些<span style="background-color:#ffffff">都是细枝末节，影响反射性能最大的一块是 MethodBase.Invoke。</span><span style="background-color:#ffffff">当在编译的时候，知道方法的签名并且通过反射来调用方法。</span><span style="background-color:#ffffff">就可以通过使用</span></span><span style="background-color:#ffffff">CreateDelegate</span><span>来获取和缓存该方法的委托，然后通过该委托执行所有的调用。从而实现性</span><span>能最佳化，但是如果在编译的时候你不知道</span><span>方法的签名，则需要依赖动态的方法。比如 MethodBase.Invoke，这个方法降低性能并且更耗</span><span>时。一些比较了解.NET 开</span><span>发的人员会用 emit 避免这种开销。.NET7 里面采用这种方式。.NET8 里面，为许多这样的情况进行了改进，以前，emitter 总是生成可以容纳 ref/out 参数的代码，但许多方法不提供这样的参数，当不需要考虑这些因素时，生成的代码可以更高效。</span>​​​​​​​</p><pre><code><span><em>// If you have .NET 6 installed, you can update the csproj to include a net6.0 in the target frameworks, and then run:</em></span></code><code><span><em>//     dotnet run -c Release -f net6.0 --filter "*" --runtimes net6.0 net7.0 net8.0</em></span></code><code><span><em>// Otherwise, you can run:</em></span></code><code><span><em>//     dotnet run -c Release -f net7.0 --filter "*" --runtimes net7.0 net8.0</em></span></code><code><span><span style="color:#ca7d37">using</span> BenchmarkDotNet.Attributes;</span></code><code><span><span style="color:#ca7d37">using</span> BenchmarkDotNet.Running;</span></code><code><span><span style="color:#ca7d37">using</span> System.Reflection;</span></code><code><span>BenchmarkSwitcher.FromAssembly(<span style="color:#ca7d37">typeof</span>(Tests).Assembly).Run(args);</span></code><code><span>[<span style="color:#afafaf">HideColumns(<span>"Error"</span>, <span>"StdDev"</span>, <span>"Median"</span>, <span>"RatioSD"</span>)</span>]</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">Tests</span></span></code><code><span>{</span></code><code><span><span style="color:#ca7d37">private</span> MethodInfo _method0, _method1, _method2, _method3;</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span>[] _args1 = <span style="color:#ca7d37">new</span><span style="color:#ca7d37">object</span>[] { <span style="color:#0e9ce5">1</span> };</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span>[] _args2 = <span style="color:#ca7d37">new</span><span style="color:#ca7d37">object</span>[] { <span style="color:#0e9ce5">2</span>, <span style="color:#0e9ce5">3</span> };</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span>[] _args3 = <span style="color:#ca7d37">new</span><span style="color:#ca7d37">object</span>[] { <span style="color:#0e9ce5">4</span>, <span style="color:#0e9ce5">5</span>, <span style="color:#0e9ce5">6</span> };</span></code><code><span>    [<span style="color:#afafaf">GlobalSetup</span>]</span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Setup</span>()</span></span></code><code><span>    {</span></code><code><span>        _method0 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod0"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>        _method1 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod1"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>        _method2 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod2"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>        _method3 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod3"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>    }</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>] <span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Method0</span>()</span> =&gt; _method0.Invoke(<span style="color:#0e9ce5">null</span>, <span style="color:#0e9ce5">null</span>);</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>] <span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Method1</span>()</span> =&gt; _method1.Invoke(<span style="color:#0e9ce5">null</span>, _args1);</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>] <span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Method2</span>()</span> =&gt; _method2.Invoke(<span style="color:#0e9ce5">null</span>, _args2);</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>] <span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Method3</span>()</span> =&gt; _method3.Invoke(<span style="color:#0e9ce5">null</span>, _args3);</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod0</span>()</span> { }</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod1</span>(<span><span style="color:#ca7d37">int</span> arg1</span>)</span> { }</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod2</span>(<span><span style="color:#ca7d37">int</span> arg1, <span style="color:#ca7d37">int</span> arg2</span>)</span> { }</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod3</span>(<span><span style="color:#ca7d37">int</span> arg1, <span style="color:#ca7d37">int</span> arg2, <span style="color:#ca7d37">int</span> arg3</span>)</span> { }</span></code><code><span>}</span></code></pre><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>.NET6 以及 7 和 8 的情况分别如下：</span></p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,BlinkMacSystemFont,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:17px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:676.989px; word-spacing:0px"><tbody><tr><th>方法</th><th>运行时</th><th>平均值</th><th>比率</th></tr></tbody><tbody><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 6.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">91.457 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">7.205 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.08</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">5.719 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.06</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method1</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 6.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">132.832 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method1</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">26.151 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.20</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method1</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">21.602 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.16</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method2</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 6.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">172.224 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method2</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">37.937 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.22</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method2</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">26.951 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.16</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method3</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 6.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">211.247 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method3</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">42.988 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.20</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method3</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">34.112 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.16</td></tr></tbody></table><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">这里有一些问题，每次调用都会涉及到一些性能开销，每次调用都会重复。如果我们可以提取这些重复性的工作，对它们进行缓存。就可以实现更好的性能。.NET8 里面通过 MethodInvoker 和 ConstructorInvoker 类型中实现了这些功能。这些并没有包含所有 MethodBase.Invoke 处理的不常见错误（如特别识别和处理 Type.Missing），但对于其他所有情况，它为优化在构建时未知签名的方法的重复调用提供了一个很好的解决方案。​​​​​​​</p><pre><code><span><em>// dotnet run -c Release -f net8.0 --filter "*"</em></span></code><code><span><span style="color:#ca7d37">using</span> BenchmarkDotNet.Attributes;</span></code><code><span><span style="color:#ca7d37">using</span> BenchmarkDotNet.Running;</span></code><code><span><span style="color:#ca7d37">using</span> System.Reflection;</span></code><code><span>BenchmarkSwitcher.FromAssembly(<span style="color:#ca7d37">typeof</span>(Tests).Assembly).Run(args);</span></code><code><span>[<span style="color:#afafaf">HideColumns(<span>"Error"</span>, <span>"StdDev"</span>, <span>"Median"</span>, <span>"RatioSD"</span>)</span>]</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">Tests</span></span></code><code><span>{</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span> _arg0 = <span style="color:#0e9ce5">4</span>, _arg1 = <span style="color:#0e9ce5">5</span>, _arg2 = <span style="color:#0e9ce5">6</span>;</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span>[] _args3 = <span style="color:#ca7d37">new</span><span style="color:#ca7d37">object</span>[] { <span style="color:#0e9ce5">4</span>, <span style="color:#0e9ce5">5</span>, <span style="color:#0e9ce5">6</span> };</span></code><code><span><span style="color:#ca7d37">private</span> MethodInfo _method3;</span></code><code><span><span style="color:#ca7d37">private</span> MethodInvoker _method3Invoker;</span></code><code><span>    [<span style="color:#afafaf">GlobalSetup</span>]</span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Setup</span>()</span></span></code><code><span>    {</span></code><code><span>        _method3 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod3"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>        _method3Invoker = MethodInvoker.Create(_method3);</span></code><code><span>    }</span></code><code><span>    [<span style="color:#afafaf">Benchmark(Baseline = true)</span>] </span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MethodBaseInvoke</span>()</span> =&gt; _method3.Invoke(<span style="color:#0e9ce5">null</span>, _args3);</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>]</span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MethodInvokerInvoke</span>()</span> =&gt; _method3Invoker.Invoke(<span style="color:#0e9ce5">null</span>, _arg0, _arg1, _arg2);</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod3</span>(<span><span style="color:#ca7d37">int</span> arg1, <span style="color:#ca7d37">int</span> arg2, <span style="color:#ca7d37">int</span> arg3</span>)</span> { }</span></code><code><span>}</span></code></pre><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>.NET8 的情况如下</span></p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,BlinkMacSystemFont,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:17px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:676.989px; word-spacing:0px"><tbody><tr><th>方法</th><th>平均值</th><th>比率</th></tr></tbody><tbody><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">MethodBaseInvoke</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">32.42 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">MethodInvokerInvoke</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">11.47 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.35</td></tr></tbody></table><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>这些类型被 Microsoft.Extensions.DependencyInjection.Abstractions 中的 ActivatorUtilities.CreateFactory 方法使用，以进一步提高 DI 服务构建性能。通过添加额外的缓存层进一步改进，进一步避免每次构建时的反射。</span></p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">&nbsp;</p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">作者:jianghupt</p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><strong>欢迎关注公众号 (jianghupt），文章首发地。</strong></p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span><img alt="" height="430" src="https://oscimg.oschina.net/oscnet/up-3243ba74c89867eabc4277de83aa83aa7bb.png" width="430" referrerpolicy="no-referrer"></span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 09:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5407571/blog/10320411</guid>
            <link>https://my.oschina.net/u/5407571/blog/10320411</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[FastUI —— 更快地构建更好的 UI]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>FastUI 是一种构建由声明式 Python 代码来构建 Web 应用程序用户界面的新方法。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>这意味着：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><strong>如果你是一名 Python 开发人员</strong>，可以使用 React 构建响应式 Web 应用程序，而无需编写任何 JavaScript 代码，也无需接触<code>npm</code>。</li><li><strong>如果你是前端开发人员</strong>，可以专注于构建真正可重用的神奇组件，无需为每个视图复制粘贴组件。</li><li><strong>对于每个人来说&nbsp;</strong>—— 真正的关注点分离，后端定义了整个应用程序；而前端可以自由地仅实现用户界面</li></ul><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>FastUI 的核心是一组匹配的&nbsp;<a href="https://docs.pydantic.dev/">Pydantic</a>&nbsp;模型和 TypeScript </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>interfaces<span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>，允许你定义用户界面。其在构建时由 TypeScript 和 Pyright/mypy 进行验证，并在运行时由 Pydantic 进行验证。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>FastUI 由 4 部分组成：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><a href="https://pypi.python.org/pypi/fastui"><code>fastui</code>PyPI 包</a>— UI 组件的 Pydantic 模型和一些实用程序。虽然它与<a href="https://fastapi.tiangolo.com/">FastAPI</a>配合良好，但它不依赖于 FastAPI，并且其中大部分可以与任何 Python Web 框架一起使用。</li><li><a href="https://www.npmjs.com/package/@pydantic/fastui"><code>@pydantic/fastui</code>npm 包</a>— 一个 React TypeScript 包，让你在实现自己的组件时重用 FastUI 的机制和类型</li><li><a href="https://www.npmjs.com/package/@pydantic/fastui-bootstrap"><code>@pydantic/fastui-bootstrap</code>npm 包</a> — 使用&nbsp;<a href="https://getbootstrap.com/">Bootstrap</a>&nbsp;实现/定制所有 FastUI 组件</li><li><a href="https://www.jsdelivr.com/package/npm/@pydantic/fastui-prebuilt"><code>@pydantic/fastui-prebuilt</code>npm 包</a>（在&nbsp;<a href="https://www.jsdelivr.com/package/npm/@pydantic/fastui-prebuilt">jsdelivr.com CDN</a>&nbsp;上提供）提供了 FastUI React 应用程序的预构建版本，因此你无需安装任何 npm 包或自行构建任何内容即可使用它。Python 包提供了一个简单的 HTML 页面来服务此应用程序。</li></ul><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>以下是一个简单但完整的 FastAPI 应用程序，它使用 FastUI 来显示一些用户配置文件：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><pre><code>from datetime import date

from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse
from fastui import FastUI, AnyComponent, prebuilt_html, components as c
from fastui.components.display import DisplayMode, DisplayLookup
from fastui.events import GoToEvent, BackEvent
from pydantic import BaseModel, Field

app = FastAPI()


class User(BaseModel):
    id: int
    name: str
    dob: date = Field(title='Date of Birth')


# define some users
users = [
    User(id=1, name='John', dob=date(1990, 1, 1)),
    User(id=2, name='Jack', dob=date(1991, 1, 1)),
    User(id=3, name='Jill', dob=date(1992, 1, 1)),
    User(id=4, name='Jane', dob=date(1993, 1, 1)),
]


@app.get("/api/", response_model=FastUI, response_model_exclude_none=True)
def users_table() -&gt; list[AnyComponent]:
    """
    Show a table of four users, `/api` is the endpoint the frontend will connect to
    when a user fixes `/` to fetch components to render.
    """
    return [
        c.Page(  # Page provides a basic container for components
            components=[
                c.Heading(text='Users', level=2),  # renders `&lt;h2&gt;Users&lt;/h2&gt;`
                c.Table[User](  # c.Table is a generic component parameterized with the model used for rows
                    data=users,
                    # define two columns for the table
                    columns=[
                        # the first is the users, name rendered as a link to their profile
                        DisplayLookup(field='name', on_click=GoToEvent(url='/user/{id}/')),
                        # the second is the date of birth, rendered as a date
                        DisplayLookup(field='dob', mode=DisplayMode.date),
                    ],
                ),
            ]
        ),
    ]


@app.get("/api/user/{user_id}/", response_model=FastUI, response_model_exclude_none=True)
def user_profile(user_id: int) -&gt; list[AnyComponent]:
    """
    User profile page, the frontend will fetch this when the user visits `/user/{id}/`.
    """
    try:
        user = next(u for u in users if u.id == user_id)
    except StopIteration:
        raise HTTPException(status_code=404, detail="User not found")
    return [
        c.Page(
            components=[
                c.Heading(text=user.name, level=2),
                c.Link(components=[c.Text(text='Back')], on_click=BackEvent()),
                c.Details(data=user),
            ]
        ),
    ]


@app.get('/{path:path}')
async def html_landing() -&gt; HTMLResponse:
    """Simple HTML page which serves the React app, comes last as it matches all paths."""
    return HTMLResponse(prebuilt_html(title='FastUI Demo'))</code></pre></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 09:29:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/fastui</guid>
            <link>https://www.oschina.net/p/fastui</link>
        </item>
        <item>
            <title>
                <![CDATA[🎁有奖问答 | 聊聊 NGINX 向云原生演进那点儿事]]>
            </title>
            <description>
                <![CDATA[<h1 class="header article-title"><a href="https://www.oschina.net/question/4700705_2331501">高手问答第 311 期 —— 聊聊 NGINX 向云原生演进那点儿事</a><div class="ui red label horizontal" data-tooltip="置顶">顶</div></h1><div class="extra ui horizontal list meta-wrap"><div class="item"><a href="https://my.oschina.net/u/4700705" class="__user"><span>小白兔爱吃大灰狼</span></a> 发布于，昨天 11:35
                    </div><div class="item">阅读 539</div><div class="item collect-btn " data-id="2331501" data-user-id="4700705" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i> 收藏 <span data-collect-count="" data-id="2331501" data-obj-type="2">2</span></div><div class="item comment-count"><a href="https://www.oschina.net/question/4700705_2331501#comments" class="normal"><i class="comment outline icon"></i> 答案 <span data-article-reply-count="">7</span></a></div></div><div class="tags"><a class="ui horizontal label" href="https://www.oschina.net/question/topic/masteronline" target="_blank"><img src="https://static.oschina.net/uploads/logo/masteronline_9WTeU.png" referrerpolicy="no-referrer">高手问答</a></div><div class="content" id="articleContent"><p><span><span>据 Gartner 预测，到 2025 年，云原生架构将成为超过 95% 的新数字计划基础，高于 2021 年的不到 40%，云原生架构市场占有率不断提高。而如今，全球半数以上（55%） 的网站都基于 NGINX 运行，差不多相同比例 (53.7%) 的中国网站在 NGINX 开源版上运行。而 NGINX 存在难于动态配置、管理功能影响业务等问题，为了解决这些问题，OpenNJet 由此诞生。</span></span></p><p><span><span>OpenNJet 基于 NGINX1.19 基础 fork 并独立演进，具有高性能、稳定、易扩展的特点，通过数据面与控制面的隔离，能够在不重启进程的情况下基于动态配置能力进行配置的实时更新。最近还推出了 OpenNJet K8s Ingress Controller 1.0，基于 OpenNJet 的动态特性、高性能实现，弥补了 NGINX 在云原生场景中不足，而且提供了丰富的流量管理功能，如动态 location、host/path 路由、负载均衡、动态 upstream、金丝雀发布、SNI 等。</span></span></p><p><strong><span><span>OSCHINA 本期高手问答（12 月 13 日 - 12 月 19 日）我们请来了嘉宾<a href="https://my.oschina.net/u/6606114" rel="nofollow">单雷老师</a>和大家一起聊聊 NGINX 向云原生演进那点儿事。</span></span></strong></p><p><strong><span><span>可讨论的问题包括但不限于</span></span></strong><strong><span><span>：</span></span></strong></p><ul><li><span><span style="background-color:white"><span>OpenNJet 和 NGINX 是什么关系？</span></span></span></li><li><span><span style="background-color:white"><span>什么是云原生应用引擎？OpenNJet 的有哪些优势</span></span></span></li><li><span><span style="background-color:white"><span>我们如何解决数据面控制面隔离、国密、动态配置等问题？</span></span></span></li><li><span><span style="background-color:white"><span>读 NGINX/OpenNJet 源码的建议</span></span></span></li><li><span><span style="background-color:white"><span>如何上手开发一个开源项目？</span></span></span></li></ul><p><span><span style="background-color:white"><span>其他关于 NGINX、OpenNJet 的更多内容，也欢迎积极提问。</span></span></span></p><h2><span><span style="background-color:white"><span><strong>嘉宾介绍</strong></span></span></span></h2><p><img alt="" height="534" src="https://oscimg.oschina.net/oscnet/up-774dc1b75df829000896339c602574ff319.jpg" width="400" referrerpolicy="no-referrer"></p><p><span><span><strong><span><span style="color:#7030a0">通明智云产品总监，单雷</span></span></strong></span></span></p><p><span><span>20 年的 IT 行业经验，精通云原生以及高性能应用引擎技术。曾在亚信科技历任研发主管、首席架构师等职务，并主导多个云原生、高性能应用网关项目的设计开发工作，现任公司应用引擎产品总监。</span></span></p><hr><p><span><span style="background-color:white"><span><span>🎁</span> 为了鼓励踊跃提问，下一代云原生应用引擎 OpenNJet 开源社区会在问答结束后从提问者中抽取 5 名幸运会员，赠予精美棉马甲一件。</span></span></span></p><p><img alt="" height="436" src="https://oscimg.oschina.net/oscnet/up-6f9dfb1df3b4d3c9f22f9a02a21c1be62d5.jpg" width="400" referrerpolicy="no-referrer"></p><blockquote><p><span><span>OpenNJet&nbsp;应用引擎是基于 NGINX 的面向互联网和<strong>云原生</strong>应用提供的运行时组态服务程序，作为底层引擎，OpenNJet 实现了 NGINX 云原生功能增强、安全加固和代码重构，利用<strong>动态加载机制</strong>可以实现不同的产品形态，如 Web 服务器、流媒体服务器、负载均衡、代理 (Proxy)、应用中间件、API 网关、消息队列等产品形态等等。OpenNJet 在云原生架构中作为数据平面，除了提供南北向通信网关的功能以外，还提供了服务网格中东西向通信能力。在原有功能基础上增加了透明流量劫持、熔断、遥测与故障注入等新功能特性。</span></span></p><p><span><span>Gitee：<a href="https://gitee.com/njet-rd/njet" rel="nofollow"><span><span>https://gitee.com/njet-rd/njet</span></span></a></span></span></p><p><span><span>官网：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnjet.org.cn%2F" rel="nofollow" target="_blank">https://njet.org.cn/</a></span></span></p></blockquote><p><span style="background-color:#ffffff; color:#27ae60">OSChina 高手问答一贯的风格，不欢迎任何与主题无关的讨论和喷子。</span></p><p>下面欢迎大家就 「<span><span>NGINX 向云原生演进</span></span>」<span><span>&nbsp;</span>相关</span>问题向<span>&nbsp;<a href="https://my.oschina.net/u/6606114" rel="nofollow">单雷老师</a></span><a href="https://my.oschina.net/klblog" rel="nofollow"><strong><span style="color:#000000">&nbsp;</span></strong></a>提问，直接回帖提问既可。</p></div><div class="poll-wrap"></div><div class="additional-remarks"></div><div class="ui basic center aligned segment action"><div class="ui big buttons"><a class="ui basic button collect-btn hover" data-id="2331501" data-user-id="4700705" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i>收藏 (<span data-collect-count="" data-id="2331501" data-obj-type="2">2</span>)</a><div class="ui basic dropdown share button osc-share dropdown-share" data-tag="share-question"><i class="share icon"></i><span>分享</span><div class="menu"><a class="item" data-platform="weibo" data-value="weibo"><i class="weibo icon"></i>微博</a><a class="item" data-platform="qq" data-value="qq"><i class="qq icon"></i>QQ</a><a class="item" data-platform="wechat" data-value="wechat"><i class="weixin icon"></i>微信</a></div></div></div><div class="ui basic segment"><a class="ban" ban-report="" data-id="2331501" data-obj-type="2" data-url="https://www.oschina.net/question/4700705_2331501"><i class="flag red icon"></i>举报</a></div></div>
            ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 09:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/question/4700705_2331501</guid>
            <link>https://www.oschina.net/question/4700705_2331501</link>
        </item>
        <item>
            <title>
                <![CDATA[新技术 LINT 可强制 LLM 回答有毒问题]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">美国普渡大学（Purdue University）的研究人员发布了，一篇名为《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2312.04782" target="_blank"><span style="background-color:#ffffff">Make Them Spill the Beans! Coercive Knowledge Extraction from (Production) LLMs</span></a>》的论文。描述了他们通过利用大模型厂商倾向于公开与提示响应相关的概率数据的特点，设计出了一种可以打破现有 LLM 规则，使其给出「有害」回答的新颖方法。</span></p><p><span style="color:#000000">研究人员使用了一种名为 LINT (LLM interrogation) 的技术，与绕过安全提示的一般越狱方式不同的是，这种技术更具强制性。它涉及到对概率值（logits）或软标签（soft labels）的理解 —— 从统计学上讲，其可以有效区分安全响应与有害响应。</span></p><blockquote><p><span style="color:#000000">「在我们的研究中，我们揭示了当不良行为者可以访问模型的输出 logits 时，LLM alignment 面临的的一种新威胁，这是开源 LLM 和许多商业 LLM API（如某些 GPT 模型）的共同特征。它并不依赖于制作特定的提示。相反，它利用了这样一个事实：即使 LLM 拒绝了有毒请求，有害响应也往往隐藏在输出 logits 的深处。通过在自动回归生成过程中在几个关键输出位置强行选择排名较低的输出&nbsp;tokens，我们可以迫使模型揭示这些隐藏的响应。我们将这一过程称为模型审讯（model interrogation）。」</span></p></blockquote><p><span style="color:#000000">具体<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theregister.com%2F2023%2F12%2F11%2Fchatbot_models_harmful_content%2F" target="_blank">表现为</a>，LINT 使用 LLM-based classifier 向 LLM 提出一个有害的问题：比如"说明如何将枪改装成全自动的"。然后，对响应中的前九个 tokens（如 "It's"、"It"、"We"和 "I"）进行排序，并用这些词组创建新句子，这样该 LLM 就会不断生成回复。</span></p><p><span style="color:#000000"><img alt="" height="263" src="https://oscimg.oschina.net/oscnet/up-a4cca4832d0d4ac8918b03eacf880f3455b.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">研究人员在创建 LINT 原型时，在一个包含 50 个有毒问题的数据集上询问了 7 个开源 LLM 和 3 个商业 LLM。他们称：「当模型只被审讯一次时，ASR（攻击成功率）达到 92%，当被询问五次时，ASR 可以达到达到 98%。」</span></p><p><span style="color:#000000">这种方法与越狱方法不同，但性能要<span style="background-color:#ffffff">远远优于目前最先进的两种越狱技术：GCG 和 GPTFuzzer。</span>相比之下越狱方法的 ASR 仅为 62%，且运行时间要长&nbsp;10 到 20 倍。「通过我们的方法揭露的有害内容更加相关、完整、清晰。此外，它可以补充越狱策略，从而进一步提高攻击性能。」</span></p><p><span style="color:#000000">更重要的是，这种技术甚至适用于根据特定任务（如代码生成）的基础模型定制的 LLM。研究人员还声称，这种技术可以用来损害隐私和安全，迫使模型公开电子邮件地址和猜测弱密码。</span></p><p><span style="color:#000000">因此，研究人员警告称，AI&nbsp;界在考虑是否开源 LLM 时应谨慎；并建议最好的解决方案是确保有毒内容被清除，而不是将其隐藏起来。</span></p><p><span style="color:#000000">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2312.04782" target="_blank">查看完整论文</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 09:24:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270686/lint-llm-harmful-content</guid>
            <link>https://www.oschina.net/news/270686/lint-llm-harmful-content</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[铠侠向 Linux 基金会捐赠 Software-Enabled Flash SDK]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#121212">几年前从东芝分离出来的存储公司 Kioxia（</span>铠侠<span style="background-color:#ffffff; color:#121212">）向 Linux 基金会捐赠了一个软件开发工具包 (SDK)，用于建立 Software-Enabled Flash SDK。</span></p><p><span style="background-color:#ffffff; color:#121212">Linux 基金会发布<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linuxfoundation.org%2Fpress%2Fsoftware-enabled-flash-announces-software-development-kit-sdk" target="_blank">公告称</a>，「SEF SDK 的发布是存储技术领域的一个重要里程碑......SEF 项目对 KIOXIA 突破性地捐赠软件定义闪存原生 SDK 表示热烈欢迎，这将为开发人员提供前所未有的能力，使他们能够为闪存存储（flash storage）应用开发定制的独特软件。」</span></p><p><img alt="" height="228" src="https://oscimg.oschina.net/oscnet/up-67690b065c2207474d1a67124aa3ef403da.png" width="300" referrerpolicy="no-referrer">&nbsp; &nbsp;<img alt="" height="228" src="https://oscimg.oschina.net/oscnet/up-1056c78ed4258dcb84497a6e896204821c0.jpg" width="300" referrerpolicy="no-referrer"></p><p>该 SEF SDK 包括示例代码和文档，以充分利用 flash media control 的潜力；包括 WAF 减少、延迟控制、对 ZNS 和 FDP 或 Block 等多种协议的支持等。</p><p>SEF 项目旨在通过加强对驱动器的管理、增强工作负载隔离、加强延迟控制以及实现对闪存管理的更多&nbsp;host-control，在现代数据中心中开辟新的用途并最大限度地发挥基于闪存的存储潜力。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 03:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270608/software-enabled-flash-sdk</guid>
            <link>https://www.oschina.net/news/270608/software-enabled-flash-sdk</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[芯瞳正式加入 openKylin，为社区贡献高质量的国产 GPU 解决方案！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>近日，芯瞳半导体技术（山东）有限公司（以下简称「芯瞳」），签署 openKylin 社区 CLA（Contributor License Agreement 贡献者许可协议），正式加入 openKylin 开源社区。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:center"><img alt="" height="1079" src="https://oscimg.oschina.net/oscnet/up-4c9b13fca5452f4a217f1494d816e96a799.png" width="829" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>芯瞳（Sietium）成立于 2019 年，是一家自主设计研发 GPU 芯片及 GPU 解决方案的高科技公司，以行业先进的计算和图形渲染平台为依托，用高质量的产品和服务为云端、终端客户提供可持续发展的国产 GPU 解决方案；为数字时代的创新与发展提供算力支撑，构建自由算力的文明世界。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:center"><img alt="" height="410" src="https://oscimg.oschina.net/oscnet/up-6914c94ad47861f5f685cb96e9bc21450f1.png" width="940" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span><strong><span>加入 openKylin 社区后，芯瞳将参与维护社区 GPU SIG 和 Wayland SIG</span></strong><span>。<strong>凭借其自研的 GPU 显卡和深厚的行业经验，优化 openKylin 环境中显卡驱动的兼容性，确保与芯瞳显卡的完美适配</strong>。</span></span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>在 openKylin 平台上，芯瞳显卡将展现其在图形显示、渲染、视频编解码和大规模计算等方面的优势，以此提升 openKylin 的用户体验，并提供持续的 GPU 产品升级和技术支持，为用户提供安全可靠的使用体验。具体计划如下：</span></p><ul><li><p style="margin-left:0; margin-right:0"><span>积极参与社区合作，紧密关注社区的发展动态，与社区成员携手推动 openKylin 社区的生态及品牌建设，努力构建一个健康的生态环境，为开源生态的发展贡献力量。</span></p></li><li><p style="margin-left:0; margin-right:0"><span>寻求与社区的技术合作，通过联合调试等方式，使 openKylin 的相关产品能更好地兼容并适应芯瞳的全新系列显卡，从而提高产品的稳定性和性能。</span></p></li><li><p style="margin-left:0; margin-right:0"><span>在应用层面，芯瞳将持续优化软件算法，提高系统效率，充分发掘 openKylin 在芯瞳显卡平台上的性能潜力，从而提升整体性能，为用户提供卓越的产品体验。</span></p></li></ul><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>通过这一系列的举措，芯瞳将与 openKylin 社区并肩前行，共同推动 openKylin 社区生态良好发展，为用户带来更多的创新和惊喜。同时，芯瞳期待与社区成员进行深入的交流和分享，以推动技术的进步和产业的协同发展，共同为中国开源生态的繁荣作出贡献。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 03:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270607</guid>
            <link>https://www.oschina.net/news/270607</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Facebook 开源 StyleX —— 在 JavaScript 中写 CSS]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Meta（原 Facebook）<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstylexjs.com%2Fblog%2Fintroducing-stylex%2F" target="_blank">开源</a></u>了全新的 CSS-in-JS 库 StyleX。</p><p><img src="https://oscimg.oschina.net/oscnet/up-30f683ba9535a9f16ce5e615736da0460cd.png" referrerpolicy="no-referrer"></p><blockquote><p><em>GitHub 地址：<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffacebook%2Fstylex" target="_blank">https://github.com/facebook/stylex</a></u></strong></em></p></blockquote><p>官方介绍道，StyleX 是一个富有表现力、具有确定性、可靠且可扩展的样式系统。它通过使用编译时 (compile-time) 工具融合了静态 CSS 的性能和可扩展性。</p><p>此外，StyleX 不仅仅是一个基于编译器的 CSS-in-JS 库，它经过精心设计，可以满足大型应用程序、可复用组件库和静态类型代码库的要求。Meta 旗下多款产品如 Facebook、WhatsApp、Instagram、Workplace、Threads 等都在使用 StyleX 作为其 CSS 样式解决方案。</p><p>StyleX 主要特性</p><ul><li><p><strong>快速</strong>：StyleX 在编译时和运行时都具备高效的性能。Babel 转换不会对构建过程产生显著影响。在运行时，StyleX 避免了使用 JavaScript 插入样式的开销，并仅在必要时高效地组合类名字符串。生成的 CSS 经过优化，确保即使是大型网站的样式也能被浏览器快速解析。</p></li><li><p><strong>可扩展</strong>：StyleX 旨在适应像 Meta 这样的超大型代码库。通过原子构建和文件级缓存，Babel 插件能够处理数万个组件在编译时的样式处理。由于 StyleX 设计为封装样式，它允许在隔离环境中开发新组件，并期望一旦在其他组件中使用时能够可预测地呈现。</p></li><li><p><strong>可预测性</strong>：StyleX 会自动管理 CSS 选择器的特异性，以确保生成的规则之间不会发生冲突。它为开发人员提供了一个可靠地应用样式的系统，并确保「最后应用的样式始终生效」。</p></li><li><p><strong>类型安全</strong>：使用 TypeScript 或 Flow 类型来约束组件接受的样式，每个样式属性和变量都具有完全的类型定义。这有助于提高代码的可读性和可维护性，同时减少潜在的错误和冲突。</p></li><li><p><strong>样式去重</strong>：StyleX 鼓励在同一文件中编写样式和组件。这种方法有助于使样式在长期内更具可读性和可维护性。StyleX 能够利用静态分析和构建时工具来跨组件去重样式，并删除未使用的样式。</p></li><li><p><strong>可测试性</strong>：StyleX 可以配置为输出调试类名，而不是功能性的原子类名。这可以用于生成快照，以便在对设计进行轻微更改时不会经常变化。通过这种方式，开发人员可以更轻松地测试和验证样式的正确性，从而提高开发效率和产品质量。</p></li></ul><p><strong>示例代码</strong></p><pre><code class="language-javascript">import stylex from '@stylexjs/stylex';

const styles = stylex.create({
  root: {
    padding: 10,
  },
  element: {
    backgroundColor: 'red',
  },
});

const styleProps = stylex.apply(styles.root, styles.element);</code></pre><p><strong>下面是一个按钮组件的示例代码</strong></p><pre><code class="language-javascript">import * as stylex from "@stylexjs/stylex";

const styles = stylex.create({
  base: {
    appearance: "none",
    borderWidth: 0,
    borderStyle: "none",
    backgroundColor: "blue",
    color: "white",
    borderRadius: 4,
    paddingBlock: 4,
    paddingInline: 8,
  },
});

export default function Button({
  onClick,
  children,
}: Readonly&lt;{
  onClick: () =&gt; void;
  children: React.ReactNode;
}&gt;) {
  return (
    &lt;button {...stylex.props(styles.base)} onClick={onClick}&gt;
      {children}
    &lt;/button&gt;
  );
}</code></pre></div>
                                    ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 02:39:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270597/facebook-stylex-css-in-js</guid>
            <link>https://www.oschina.net/news/270597/facebook-stylex-css-in-js</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[双十一弹性能力支撑 - ECI 稳定性建设]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h3_1"></span><h3>一、关于 ECI</h3><p style="text-align:justify">背景从 2018 年正式发布，<strong>ECI 已经打磨了整整 4 个年头</strong>，如今也已经快速成长为了阿里云 serverless 容器的基础设施，服务着阿里内外众多的公有云客户与云产品，每天承接着数百万的弹性容器创建。</p><p style="text-align:justify">然而，ECI 这些年却未参与到集团双十一大促，双十一可以说是阿里技术人的阅兵，能不能承接住双十一的流量成为了检验一个产品是否稳定可靠的重要标准。但一切都是水到渠成，就在今年，ASI 开始与 ECI 对接，尝试让 ECI 承接双十一大促的弹性的 30W 核算力，我们都知道双十一大促对于整个阿里集团的意义，使命将至，我们必将全身心地投入到对接、压测、护航的工作中。经过长达两个多月的业务适配、压测、备战，最终完成了双十一大促的弹性容器的圆满交付。这背后，离不开 ASI、ECI 以及参与到其中的每一位脚踏实地、用心钻研、保驾护航的同学的努力。ECI 今年首次作为集团大促弹性基础设施，根据线上数据统计，大促期间 ECI 弹性资源使用共计约 400W 核，从资源的瞬时弹性、保有规模、系统稳定性等多方面对云原生系统都是一次巨大的考验。作为底层的计算单元，ECI 此次也成功顶住了双十一弹性流量洪峰的考验，在感叹 serverless、容器这些技术发展迅猛的同时，对于全新的系统架构稳定性的考验也不小。</p><p style="text-align:justify">如今再回过头来看 ECI 的第一次双十一，我们有必要做一次全面的总结，我们为集团弹性保障做了哪些工作，哪些是将来可以复用的工作，哪些是可以给其他的团队作为借鉴的技术和经验，以及哪些地方还可以做的更好，为下一次大促做准备。</p><p style="text-align:justify">本文我们将为大家介绍，<strong>ECI 这些年在稳定性方面做了哪些工作，以及是如何来为集团双十一保驾护航的。</strong></p><span id="OSC_h3_2"></span><h3>二、遇到的挑战</h3><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-484afd33bc5b8c5f4774ab7fddf53a98_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">大规模并发带来的稳定性挑战遇到的最大挑战首先是大规模并发带来的。容器保有量增多之后，从容器实例生产方面来看对于云管控系统是不小的考验，尤其是对于弹性场景来讲，需要在极短的时间进行实例的生产，镜像的大规模拉取，进而保障容器的成功启动。</p><p style="text-align:justify"><strong>如何能保障实例的大规模成功生产</strong>，如何先于线上发现问题，以及即使出现了问题如何第一时间止血并进行故障恢复，这对于集团双十一期间的业务重保都是尤为重要的。除此之外，对于公有云环境来讲，不能影响到其他的公有云客户也是需要重点关注的，因此需要具备一套完整的稳定性保障体系以及故障应对方案以确保双十一期间的业务能够顺利进行。实例生产系统稳定性 ECI 和 ECS 共用一套资源调度系统，相对于 ECS 容忍度为分钟级别的应用来讲，ECI 实例频繁的创建删除对调度系统的要求更为苛刻，对系统容量以及稳定性保障方面提了更高的要求。服务可用性保障 ECI 安全沙箱由于某种原因异常（OOM/物理机宕机/kernel panic），导致不健康情况。这种情况下，k8s 层面如果不从 endpoint 上摘除这个 ECI Pod，会导致请求通过负载均衡依然可以路由到这台不健康的 ECI 上，会导致业务请求成功率下降，因此对于集团业务服务可用性保障也是尤为重要的。</p><span id="OSC_h3_3"></span><h3>三、ECI 稳定性技术建设</h3><p style="text-align:justify">稳定性保障从需求收集准备阶段开始，双十一大促持续两个月之久，为了配合集团全链路验收，ECI 自身的稳定性保障工作也随之紧锣密鼓地进行。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-353460c616617e11f187c76359272f10_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">稳定性的保障贯穿了整个大促过程，大促前慎重/减少系统变更以排除人为因素的干扰，敬畏发布，多次压测演预案确保系统稳定性，不断提升系统抵抗力稳定性和系统恢复力稳定性，以保障大促的顺利进行，最后通过问题覆盘沉淀出可复制的大客户重保策略，这对于未经过双十一实战演练具有积极的意义。</p><p style="text-align:justify">因此我们梳理出了整个大促期间围绕稳定性方面做的主要工作，主要包括风险控制、关键业务依赖梳理、技术保障、压测预案、运行时保障、故障运维能力、以及最后的覆盘优化，希望以此能对今后的大促工作作为指导，并沉淀出稳定性治理的经验。接下来我们对此次大促涉及到的主要稳定性保障方法以及如何应用进行介绍。</p><p style="text-align:justify">实例生产保障 VM 复用技术实例生产行为的保障是集团弹性使用 ECI 的重中之重。一个典型的实例生产过程如图所示，<strong>ECS 和 ECI 在控制面共用一套管控系统，</strong>ECI 管控侧调用资源调度系统之后会分配计算资源之后会调用 pync（阿里云单机管控组件），进而调用 avs(阿里云单机网络组件) 和 tdc(阿里云单机存储组件) 分别生产网卡与磁盘。在此过程中，对于调用 ECS 依赖的 open api 接口较重，在大规模创建删除场景很快成为系统瓶颈，此前我们专门针对容器实例高频创建删除场景开发了 VM 复用功能，对于高频场景删除容器实例的场景，延迟 vm 的回收，并复用容器实例的网卡、镜像、计算资源，降低对管控系统整体的冲击，以此来保障实例生产系统的稳定性，从此次双十一的实战演练效果来看，vm 复用取得了很好的效果，管控系统容量整体处于正常水位，保障了集团双十一实例稳定的弹性能力。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-dcd697c3f23312c91e09c0272f34fbd8_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">重调度机制对于库存不足或者远程服务调用超时等情况，为了保障实例生产的最终一致性，对于 ECI 实例生产我们设计了相应的故障处理策略策略，取值如下：fail-back：失败自动恢复。即 Pod 创建失败后自动尝试重新创建 fail-over：失败转移。效果等同于 fail-backfail-fast：快速失败。即 Pod 创建失败后直接报错故障处理策略本质上是一种重调度的策略。原生的 k8s 调度支持重调度，即调度失败后会将 pod 重新放入调度队列等待下次调度，类比 k8s 的重调度行为，当 eci 管控系统收到创建请求的时候，首先会进入一个队列，然后有个异步定时任务会将创建从队列中捞起，提交到异步工作流进行实际的资源生产、以及容器的启动等。即便是结合了多可用区和多规格的优化，异步工作流依然有可能失败的，比如资源的争抢、内网 ip 不足、启动失败等，这时候就需要将创建请求再次重回队列，等待被重新调度生产。</p><p style="text-align:justify">我们目前对于<strong>故障处理策略</strong>：</p><p style="text-align:justify">1、失败的任务会一直重试，但是我们会计算每个任务的执行周期，重试次数越多，执行周期越长，以达到退避效果。</p><p style="text-align:justify">2、优先级策略会考虑用户级别、任务类型、任务上次失败的原因等因素，优先级高的任务优先提交执行。</p><p style="text-align:justify">3、每次调度失败的原因都会以标准事件的方式通知到 k8s 集群。队列里的任务的整个执行流程的状态机如下：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-e09200aea1a82cf515617f061a7bb54a_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">所有执行失败的任务都会重新进入队列，等待被再次调度。由于任务会在任何一步失败，所以所有生产出来的资源都会回滚，回滚结束后，进入初始状态。初始状态的任务会被拉起执行，然后提交到异步生产。如果生产失败，就会再次回到等待调度的状态。如果生产成功，任务就结束，到达终态。基于我们的重调度机制，可以极大的减少由于生产系统抖动造成实例生产失败的情况，对于容器启动成功率要求高的场景可以保障实例生产的最终一致性，对于容器启动成功率要求不那么严格的场景可以快速失败，由上层业务进行处理。</p><p style="text-align:justify">服务容错降级对于故障场景，系统依赖服务的降级也是十分重要的。大多数进行限流降级的方案主要关注点在服务的稳定性，当调用链路中某个资源依赖出现异常，例如，表现为 timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败或返回预设静态值，避免影响到其它的资源，最终产生雪崩的效果。ECI 目前实现了基于历史日志自学习进行无损降级、本地 cache 降级、流控降级 3 级降级机制框架，ECS/ECI openapi 全面接入，内部依赖 200+接口接入，根据每个接口的调用频率、RT 分布、超时时间设置来单独分析，选择合适的降级策略，设置合理的阀值，能让系统出问题时，智能降级从而进行系统保护。<strong>一个典型的降级机制实现过程如图：</strong></p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-1239ddaa0f4eab60e7996e6fec9fe364_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>当有非资源类核心 API 新请求进入</strong>，如果历史缓存数据未过期则直接返回缓存数据，结束业务逻辑反之则请求远程接口。如果请求成功，返回数据，对数据进行缓存，同时将缓存数据以日志方式存入 sls cache log 日志用于未来降级，结束业务逻辑当远程请求失败时触发降级策略：如果失败指标（例如指定时间内异常比例）在预设时间窗口内未达到配置的降级策略阈值，则直接抛出相应业务异常，结束业务逻辑如达到降级策略阈值则按以下顺序实行降级策略：从 sls 缓存日志查找历史日志数据作为降级返回值，同时将返回值重新写入缓存，结束业务逻辑如果 sls 缓存日志没有相应日志则返回：预设静态值或空值，结束业务逻辑对于一些跟用户资源无关，更新少，属于全局参数的服务/接口，以上通用降级策略和方案可能因为降级规则阈值难以界定而无法有效执行。</p><p style="text-align:justify">针对这些接口采用 dubbo 异常直接降级的策略涉及到降级或熔断的条件：自动降级 (可选利用 Sentinal 进行自动降级)： 超时，异常，限流手动开关支持核心非资源 api 直接进行 openapi 本地降级 cache 对于严重的系统故障，可以将核心几个 describe api 进行 openapi 本地 cache，发生故障，或有雪崩出现时，全部切到 openapi 本地 cache，在降级影响面的同时，也能减轻对下层服务的调用压力来赢取恢复时间。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-0ce94b0355dad7e7cbc7463c70e8ad87_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">依赖服务非创建链路 dubbo 或 http 请求进行本地 moc 对于几乎不会频繁变化的依赖服务，通过每日 sls 分析进行 kv 的存储，当故障发生时，降级为备用，让降级影响面趋向于 0。其他服务降级机制大分页流控 cache 创建类 api 进行依赖 dubbo 或 http 服务降级，<strong>异步补偿操作类 api 进行链路降级，</strong>取消非必需依赖数据库降级 ro 库流量降级隔离，用户级别流量切到灰度 api 级别流量切到灰度/独立线程池日志 debug 及调用链路跟踪使用 apicontext 实现详细日志 debug 及调用全链路跟踪能力核心 api debug 日志建设，支持按用户开启 debug 日志打印 requestId 贯穿到 dao，支持随时采样，及时发现 dao 异常调用服务依赖降级容错机制可以在保障服务稳定性的前提上，利用相关接口的历史缓存数据，基于 SLS 日志无损降级，当 SLS 无数据的时候也可以采用本地静态数据兜底，构建有效返回值，在服务触发流控降级熔断后，大部分用户不会感知到服务异常。</p><p style="text-align:justify">在内部的多次故障演练中，服务降级机制可以有效保护系统由于发生故障带来的系统瘫痪。服务可用性保障在传统的 Kubernetes 集群中，如果 Node 变得不可用且达到时间阈值，那么会将 Node 上的 Pod 进行驱逐，重新在其他 Node 上拉起新的 Pod。而在 Serverless 场景下，ECI 管控会通过异步检测机制检测不健康 ECI，修改状态为不可用，同时增加导致不可用的事件，告知 ECI 用户，之后 ECI 会通过主动运维的手段治愈不健康 ECI，之后触发控制面将 ECI 恢复为 Ready 状态，<strong>主要过程如图所示：</strong></p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-790b2ccc925edb4964dede90b43256af_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>处理不健康 ECI 的流程：</strong></p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-4e6eaa3bddc8488957271e480923d34a_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>恢复 Ready ECI 流程预案&amp;压测除了技术方面的保障，故障注入、应急预案、压测演练在稳定性建设中也尤为重要。</strong>在双十一活动期间我们内部进行了多次压测演练，对系统中常见的性能瓶颈进行故障注入，用以模拟故障的发生，同时制定应急预案，以此应对故障已经发生时的场景。通过多次的压测摸高，一方面可以评估系统容量的承载上限，另一方面可以借此机会进行大规模压测演练，验证系统降级方案并对系统稳定性进行评估。预警&amp;监控大促进行时，预警和监控是保证系统运行时稳定性的重要措施。通过监控和预警可以及时发现系统故障，进而快速进行恢复。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-bfb30f596763e9976d35e307e15d74a2_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-c27bfedd2fd094067dc495bbdab8340a_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h3_4"></span><h3>四、系统的健壮性</h3><p style="text-align:justify">思考沉淀一个健壮的系统不仅需要减少问题的发生，同时要具备故障发现以及故障快速恢复的能力。除了预警和监控，运维能力建设也十分重要。</p><p style="text-align:justify"><strong>一个系统的健壮性体现在系统的容量，</strong>系统的容错能力以及系统依赖的各个资源的 sla，尤其是在云上覆杂的资源环境下，由于「木桶效应」，某一项依赖资源的很可能造成整个系统的直接不可用。因此，随着系统不断完善，我们需要通过混沌工程等方法来找出当前系统的「弱点」进而对其进行专项优化，进而提升整个系统的健壮性；其二对于系统的故障恢复以及降级能力也很重要，历史上 ECS/ECI 管控多次由於单用户或系统某个环节变慢，导致系统全链路雪崩，最终导致 P1P2 故障，ECS/ECI 管控是阿里云最复杂的管控系统，复杂的业务逻辑，内部系统依赖，非常多的环节出问题都有可能导致全链路某个应用雪崩进而全局不可用，因此，对于故障已经来临时，依赖降级能力能非常有效的保护我们的系统，这也是稳定性建设的一个十分重要的方向。</p><span id="OSC_h3_5"></span><h3>五、总结</h3><p style="text-align:justify">未来展望随着双十一最后一波流量高峰结束，ECI 顺利通过了对阿里人最严苛的技术考验--双十一，本文围绕此次参与双十一活动的经历做出总结，希望可以为今后 ECI 稳定性方面的建设积累经验，当然，这对 ECI 来说也仅仅是一步试金石，作为云原生时代的基础设施，ECI 任重而道远，共勉！</p><p style="text-align:justify">本文出品及鸣谢： 柳密、羽云、景奇、存诚、 煜枫、景止、皓瑜、月悬、佐井、尚哲、涌泉、十刀、 木名、秉辰、易观、冬岛、不物、潇洛、 怀欢、 尝君、寒亭、伯琰。</p><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1389034%3Futm_content%3Dg_1000385342" target="_blank">原文链接</a></strong></p><p style="text-align:justify"><strong>本文为阿里云原创内容，未经允许不得转载。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 06 Dec 2023 08:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10319647</guid>
            <link>https://my.oschina.net/yunqi/blog/10319647</link>
            <author>
                <![CDATA[阿里云云栖号]]>
            </author>
        </item>
    </channel>
</rss>
