<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 01 Nov 2023 12:38:57 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[优惠券 10 几万元，中国首款商用可重构 5G 频射收发芯片上架淘宝]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>近日，国资委淘宝店铺「国资小新」上架了一款售价为 999999 元的硬核商品 ——</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0c0dfda1faab2057d6c1cd71a911022e482.png" referrerpolicy="no-referrer"></p><p>根据商品图介绍，该款芯片名为「破风 8676」，是「中国首款商用可重构 5G 频射收发芯片」，定价 999999 元人民币。这款芯片因独特的用途和「硬核」的定价被网友戏称为「双十一」期间最「硬核」的国货。</p><p>报道称，该芯片由中国移动研究院自主研发。产品介绍信息显示，「破风 8676」可重构 5G 射频收发芯片支持 1.7GHZ~6GHz 频段范围，能够适配全球主流 4/5G 频段、WiFi 及国内车联网频段：支持 2 个射频通道，通道带宽 200MHz；集成 DPD （数字预失真） 、CFR （削峰） 、高阶 FIR （有限长单位冲激响应）滤波等功能。</p><p>公开信息显示，上架这款芯片的店铺「国资小新」由国务院国有资产监督管理委员会下属机构负责运营。该账号店铺内还上架了由中国航发研制的「太行 110」重型燃气轮机、由中国铁建研制的全球最大竖井掘进机、航空工业集团研制直-20 直升机以及中核集团建设的全球首个陆上小型模块化反应堆等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d3dff2bf8551179267c8ac2ee3cc6613cf1.png" referrerpolicy="no-referrer"></p><p>和「破风 8676」一样，店铺将上述产品均定价为 999999 元，并提示消费者该商品「仅展示可加购勿拍」。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 07:41:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264470</guid>
            <link>https://www.oschina.net/news/264470</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[openKylin Wine 助手正式上线，公测活动开启]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span>为提供用户更好的 Windows 应用程序安装和使用体验，openKylin 社区 CompatWinApp SIG 组基于 Wine 开源软件设计了一款<strong>集软件展示、下载、安装、管理等功能于一体</strong>的桌面软件—<strong><span style="color:#0052ff">openKylin Wine 助手</span></strong>！</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">现邀请所有社区用户参与本次公测活动，参与就有机会获得社区定制奖品哦～</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#0b43d1">openKylin Wine 助手介绍</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>openKylin Wine 助手基于 Wine 提供的 Windows 应用运行环境，为用户提供软件展示、下载、安装、管理等功能，可以让用户在 openKylin 系统上方便地下载、安装和使用 Windows 应用程序。其主界面如下图所示：</span></p><div><p style="text-align:center"><img alt="" height="1080" src="https://oscimg.oschina.net/oscnet/up-3473471a2b0b0cd75b757a441c879110017.png" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><ul><li><span>openKylin Wine 助手首先从应用配置仓库和依赖配置仓库下载配置文件。随后，将应用程序展示在窗口中，当用户点击应用程序后面的安装按钮，openKylin Wine 助手就会根据配置信息下载相应用的应用程序和依赖，并最终调用 Wine 进行安装。</span></li><li><span>安装后，应用程序后面的按钮会变成启动按钮，点击启动按钮后，openKylin Wine 助手会调用 Wine 启动该应用。完整过程如下图所示：</span></li></ul><div><p style="text-align:center"><img alt="" height="550" src="https://oscimg.oschina.net/oscnet/up-82094adb9094dfb452b1626fee75d859371.jpg" width="948" referrerpolicy="no-referrer"></p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#0b43d1">公测活动介绍</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#79d7ff">活动时间</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#333333"><span style="background-color:#fffbf2">2023 年 10 月 31 日—2023 年 11 月 30 日</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#79d7ff">参与方式</span></span></strong></span></p><h1>1.下载安装 openKylin Wine 助手</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>目前，CompatWinApp SIG 组已发布 X86 平台的 openKylin Wine 助手，下载体验地址如下：</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#0052ff">https://gitee.com/openkylin/compat-winapp/releases/tag/1.0.2-beta.20230928</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><em><span><span style="color:#ce2a1b">备注：安装说明见压缩包里的 readme 文件</span></span></em></p><h1>2.签署 CLA，参与公测</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>参与公测的用户请在 openKylin 系统上安装使用 openKylin Wine 助手，将使用过程中遇到的 bug 问题或优化建议以 issue 方式提交到如下地址：</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#0052ff">https://gitee.com/openkylin/win-program/issues</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><em><span><span style="color:#ce2a1b">注意：在参与公测前，请大家签署 openKylin 社区贡献者许可协议，如若未签署，则参与成绩无效。CLA 签署网址：</span></span></em><br><span><span style="color:#0052ff"><span>https://cla.openkylin.top/</span></span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#79d7ff">奖品设置</span></span></strong></span></p><p style="margin-left:0px; margin-right:0px; text-align:justify">CompatWinApp SIG 组会统计活动期间所有在仓库反馈的问题和需求建议，根据每个问题和需求的重要程度进行打分，分数总和越高排名越靠前。截至 2023 年 11 月 30 日，积分排名前 10 的小伙伴可获得 openKylin 纪念品礼包一份（polo 衫+笔本套装），评选结果将由社区在 7 个工作日内公布至 openKylin 论坛。</p><div><p style="text-align:center"><img alt="" height="410" src="https://oscimg.oschina.net/oscnet/up-b5c4b5d8b275e4d43d5af75c36e3b105e17.png" width="940" referrerpolicy="no-referrer"></p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#79d7ff">评分规则</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>由 CompatWinApp SIG 组分别从<strong>需求、问题、清晰度</strong>三个维度进行评分。</span></p><ul><li><span><strong>需求</strong>：对需求进行评级，分别为高、中、低三个等级，高等级 3 分，中等级 2 分，低等级 1 分。</span></li><li><span><strong>问题</strong>：对于遇到的问题或者 bug 进行评级，分别为严重、主要、次要、不重要四个等级，对应的分数分别为 3 分、2 分、1 分、0.5 分。</span></li><li><span><strong>清晰度</strong>：对需求和 bug 的清晰度进行评级，分为高中低三个等级，高清晰度会在其原分数上+0.2 分，中清晰度不做分数调整，低清晰度会在其原分数基础上-0.2 分。</span></li></ul><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:center"><span><strong><span style="color:#000000">还在等什么，赶快行动起来吧~</span></strong></span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 02:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264400</guid>
            <link>https://www.oschina.net/news/264400</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[深圳一公司奖励程序员「黄金键帽」，价值近 2 万元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 10 月 24 日，被众多科技公司和业内人士称为「程序员节」。当天，深圳一公司奖励员工「<strong>黄金键帽</strong>」。</p><blockquote><p><img height="1658" src="https://static.oschina.net/uploads/space/2023/1031/185140_pBn0_2720166.png" width="1176" referrerpolicy="no-referrer"></p></blockquote><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F5558240479%2FNpm9Lffdj%3Fpagetype%3Dprofilefeed" target="_blank">据称</a></u>这款空格键键帽是 40g 黄金，价值近 2 万元。</p><p><img src="https://static.oschina.net/uploads/space/2023/1031/185850_Wq96_2720166.png" referrerpolicy="no-referrer"></p><p><em>△「黄金 C 键」是该公司去年的奖励</em></p><p>获得奖励程序员根据代码行数排名和部门推举共同选出，最具分量的「黄金空格键」奖励给有效代码量最多的程序员。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 10:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264307</guid>
            <link>https://www.oschina.net/news/264307</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[客服发送一条消息背后的技术和思考]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h1>一、引言</h1><p>在企业客服场景中，客服发送一条消息的背后，需要考虑网络通信、前端展示、后端存储以及安全性等多个方面的技术支持，单从前端层面来说，就需要考虑到消息的显示、状态更新、稳定传输以及极限操作消息不卡顿等场景，随着 IM 系统的不断更新迭代，已经实现了从外采到自研再到一站式全场景工作台的搭建，我们能够很明显地感知到客服对于 IM 的体验要求越来越高了，因此客服发送一条消息背后所涉及的技术和思考也越来越重要。本文将探秘客服发送一条消息背后的技术和思考，帮助大家了解如何在 IM 聊天场景中提供高效、安全、可靠和良好的用户体验。</p><h1>二、IM 聊天消息的重要性</h1><p>IM 聊天消息是客服和用户之间最快速、最直观、最高效的双向沟通方式之一。IM 聊天的重要性体现在以下几个方面：</p><ul><li>即时响应：及时地解答用户咨询的问题，更快捷的服务用户，提高用户满意度。</li><li>个性化互动：可以根据用户的需求快速做出个性化回应，从而更好地满足用户需求。</li><li>数据处理和分析：通过对 IM 聊天消息的处理分析，可以洞察用户需求、用户行为，帮助改进服务质量。</li></ul><p>综上，IM 聊天消息的重要性在于提高用户满意度、提高客服作业效率，这也意味着 IM 消息的可靠、高效、安全尤为重要，接下来本文就从前端视角对客服发送一条消息背后的技术和思考进行详细的讲述。</p><h1>三、客服 IM 消息发展历程</h1><p>以下是客服 IM 消息发展的历程，列举的都是核心技术专项的里程碑节点。 <img src="https://oscimg.oschina.net/oscnet/up-584d1aa46f5bc07e2c715235ac116ca64f0.jpg" alt="" referrerpolicy="no-referrer"></p><p>在这个过程中，我们积累了一定的经验和技能，同时也遇到了各种各样的问题和挑战。比如：消息丢失、消息发送失败、消息重复、消息乱序等等方面的问题，针对这些问题我们也都通过技术专项的方式去逐个解决并达到了预期效果，我们相信，随着技术的不断发展和创新，我们可以更好地提供更加高效便捷的服务。</p><h1>四、技术和思考的细节</h1><p>站在用户/客服角度，发送消息不就是输入消息后点击回车键或点击发送按钮就完成了吗，看似非常简单，但是从开始输入消息到对方收到消息这个过程实际上有非常强大的技术在高效、稳定支撑。我们客服 IM 消息链路会涉及到三个核心端口，发出方、IM 网关以及接收方。以下将以客服发送一条消息到 IM 网关这个过程简单描述一下涉及到的技术点，反之用户侧发送消息也是类似的。 <img src="https://oscimg.oschina.net/oscnet/up-b5cfea2555b27d0ea3e3bd134cd0efa18fe.jpg" alt="" referrerpolicy="no-referrer"></p><p>从上述流程图中可以看到一条消息的旅程还是非常丰富的，当然其中有一些细节点还没有完全列举出来，例如：IM 网关的超时重推机制、前端的异常处理 (网络异常、超时异常、重试无果等)。我们可以很清晰地看到当客服开始输入消息的时候就开始进行通知对方正常输入，触发消息发送后需要进行消息体的创建、排序、去重检测、网络检测、聊天列表渲染、推入超时重试队列、放入消息拦截器中统一进行消息格式转化并发送，到这里只仅仅是完成了前端层面的发送工作而已，此时消息是否发送成功还是未知的，还需要监听消息的发送结果，如果在一定时间未收到响应结果会进行第二次消息的重发，直到发送成功或到达最大重试次数就表示该消息的生命周期结束。一旦收到消息的响应结果就会对消息的状态进行更新 (此时消息已完成了排序，不需要进行二次排序)，至此第一个环节就完成了处理，IM 网关到客户端也会有类似的处理过程。</p><p>纵观整个消息发送以及接收链路，任何一个环节出现问题都会导致消息发送出现问题，就需要非常稳定可靠的技术手段进行保障，主要从以下几个方面讲解一下。</p><h2>消息的可靠性传递</h2><p>消息的可靠性传递确保了消息收发双方信息的一致性。这也是我们为什么把消息可靠性传递放在第一个进行讲解。我们试想一下这样一个场景，经常有消息丢失，客服频繁反馈，每次都要投入研发资源去排查问题，这还是次要的，有可能因为消息的丢失导致用户体验的急剧下降，这就得不偿失了。所有消息的可靠性传递是非常有必要的，而且也是必须的。那么何为可靠性传递？至少要满足 3 个方面：</p><h3>1.1 消息的实时性</h3><p>我们使用 IM 最重要的一方面就是希望对方能够实时接收到我们发送的消息并能够给予回复，这对于提升用户体验尤为重要。如果不在乎实时性我们完全可以使用其他方式，例如邮件、写信甚至飞鸽传书…</p><p>一条消息发送给 IM 网关，网关大致需要经历以下 5 个环节的处理：</p><ul><li>验证消息：敏感词验证、风控送审 (同步审核)</li><li>消息的存储：排序、去重验证等</li><li>给发送消息方回复一个 ACK 响应 (成功、失败)</li><li>把消息发送给接收方，如果存在多端登录的场景，还需要保障消息多端同步</li><li>超时重试、处理接收方返回的 ACK 等</li></ul><p>从消息的实时性的来说，没有绝对的实时，只能尽量优化。核心的处理逻辑都在 IM 网关，无论是前端还是客户端，处理过程都是非常快的，都在毫秒级别。我们 IM 网关是 Go 语言开发的，并发处理的能力也是非常高的，所以整个闭合链路的耗时还是非常低的。 <img src="https://oscimg.oschina.net/oscnet/up-5099c14837901bd35052c87dcaa6bdc2893.jpg" alt="" referrerpolicy="no-referrer"></p><h3>1.2 消息的可靠性</h3><p>众所周知，TCP 本身就是具有可靠性的，但是它只能保障传输层可靠，而应用层之间的可靠性并不能保证，我们后续会有针对性的专项文章进行发表，本次就不再赘述。</p><p>那我们该如何保障应用之间的可靠性呢? 可靠性的保障就是让发送方知道接收方接收到了消息，这样就表示消息成功传递了。我们再回头看一下上面讲述消息丢失的场景，消息丢失的问题也是我们在 IM 消息研发过程中遇到的一个让人头疼的问题，排查一个问题需要投入的技术资源是非常巨大的，需要涉及到 H5、IM 网关、服务端以及客户端，对于用户以及客服的使用体验是非常差的。很简单的一个场景，用户发了消息，客服没有收到，没有回复用户，用户以为客服故意不回复，会影响到用户的满意度。</p><p>那这个问题该如何解决呢？大家可以看下<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkxNTE3ODU0NA%3D%3D%26mid%3D2247489429%26idx%3D1%26sn%3D0f7c0c2062c56abe6fb69944b6d48fa3%26chksm%3Dc16242caf615cbdc799cb6a073946a42bc4932dc9695e1f9b80f6afc0c8c1b768745614bb88f%26scene%3D21%23wechat_redirect" target="_blank">得物客服 IM 消息通信 SDK 自研之路</a>，其中有讲解过，核心是参考 TCP 协议的 ACK 机制，实现一套基于业务层的 ACK 协议。这里特别的要注意的是针对批量消息 (客服刷新会话、新会话进线等场景)，我们采用的是批量 ACK 机制，如果每一个消息都回复 ACK，成本会比较高。我们当初是通过一个 IM 架构升级技术专项协同各端完成了 IM 整体消息触达实现 0 丢失，保证触达，满足 At least once（通过数据埋点验证后得到 100% 的触达率）。上线后该场景符合预期效果，相应的问题排查投入也减少了至少 70%+。</p><h3>1.3 消息的有序性</h3><p>在开发 IM 过程中有这样一个非常常见的场景，用户问 A 问题后又问题了 B 问题，在客服侧 B 问题排到 A 问题的前面，导致客服的回复也出现了错乱。当然这只是 IM 消息乱序的一种场景而已。诸如此类的还有很多。消息乱序产生的原因有很多，例如发送文件后再立即发送消息，文件需要前端先上传到 OSS 获取到 URL 后再发送给用户，上传文件这个过程，用户以及客服都是可以发送消息的，这种场景处理不好就极易出现消息乱序。</p><p>不做 IM 是真不会想到客服操作的效率会有多高，之前在处理消息乱序问题的时候有遇到客服连续发送了 2 条消息，间隔只有 300 毫秒，这种高频密集的操作场景在客服的工作场景下是持续性的。</p><p>看似一个乱序问题，不考虑清楚用户群体、极限场景、临界值等都不会彻底解决掉这个问题。</p><p>再说回我们客服 IM，我们是如何处理消息排序的呢？在整个开发过程也是比较曲折的，最终是以 IM 网关维护的 Seq 为准，然后返回到发送方，发送再根据消息序号进行排序，确保发送方和接收方消息的排序是一致的。前端处理的流程如下： <img src="https://oscimg.oschina.net/oscnet/up-f6983e465f7b364799f924e55d8345ea887.jpg" alt="" referrerpolicy="no-referrer"></p><h3>1.4 消息的幂等性</h3><p>说到消息的幂等性，我们要思考一个问题，为什么会收到多条 (&gt;1) 相同的消息呢？肯定是发送方重复发送导致的，那在什么场景下会重复发送？前面刚讲过应用层的 ACK 机制，如果没有收到对方的 ACK，会在超时时间到达后继续重复发送直到最大重试次数。参考下面的截图会更容易理解，只是模拟消息重试，真实场景中执行频次肯定要比这个时间更久一些。 <img src="https://oscimg.oschina.net/oscnet/up-9fbc97a0f4430757c05319b8fe94d293131.jpg" alt="" referrerpolicy="no-referrer"></p><p>既然要保证消息的可靠性，消息的重复就是无法避免的。就有可能出现消息幂等性问题。那怎么解决呢？我们是利用消息的 Message ID 做去重的，这里会涉及到一个性能问题，排序、去重以及风控信息验证等都需要一定的计算成本，如何保证处理过程系统不卡顿是一个核心问题。想要了解我们客服 IM 是如何做的，请继续向下看。</p><h2>消息处理的卡顿优化策略</h2><p>我们来想一下为什么会出现卡顿？什么样的场景才能够被视为卡顿呢？我们一般都会说是因为在 16ms 内无法完成渲染导致的。那么为什么需要在 16ms 内完成呢？这里我们就要了解一下刷新率（RefreshRate）与帧率（FrameRate）。</p><ul><li><strong>刷新率</strong>指的是屏幕每秒刷新的次数，是针对硬件而言的。浏览器刷新率都在 60Hz（屏幕每秒钟刷新 60 次）。</li><li><strong>帧率</strong>是每秒绘制的帧数，是针对软件而言的。通常只要帧率与刷新率保持一致，我们看到的画面就是流畅的。所以帧率在 60FPS 时我们就不会感觉到卡。</li></ul><p>如果帧率为每秒钟 60 帧，而屏幕刷新率为 30Hz，那么就会出现屏幕上半部分还停留在上一帧的画面，屏幕的下半部分渲染出来的就是下一帧的画面，这种情况被称为画面撕裂。相反，如果帧率为每秒钟 30 帧，屏幕刷新率为 60Hz，那么就会出现相连两帧显示的是同一画面，这就出现了卡顿。所以单方面的提升帧率或者刷新率是没有意义的，需要两者同时进行提升。浏览器都采用的 60Hz 的刷新率，为了使帧率也能达到 60FPS，那么就要求在 16.67ms 内要完成一帧的绘制（1000ms/60Frame = 16.666ms / Frame)。</p><p>IM 消息处理中出现卡顿的情况非常常见，到一定的量级都是一个很难避免的问题，对比我们经常使用电脑，打开多个浏览器页签，稍微时间长点不关机重启，也会感觉到卡顿，但对于 IM 消息处理还是有很多方式进行优化的，<strong>主要涉及以下几方面的优化策略：</strong></p><h3>2.1 异步处理</h3><p>众所周知 JS 是单线程的，所以采用异步处理机制可以将优先级低的任务推入异步任务队列，让出主线程给优先级高的任务。比如：客服在输入完消息后需要立即显示的聊天页面，如果存在短暂的不显示，会被认为是系统卡顿了，所以发送消息的优先级是高于接收消息的。我们对各场景任务优先级做了区分，低优先级的任务都通过异步的方式进行处理。</p><h3>2.2 分段加载</h3><p>这里主要针对聊天消息列表，对于大量消息的会话处理，只渲染可视区域的消息降低浏览器的负担，提升响应速度。列表优化的方案有很多。如下：</p><p><strong>方案 1：</strong> 使用定时器 setTimeout 来实现分批渲染，这种方式我们一般不推荐，因为在 setTimeout 中对 DOM 进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就可能导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素，从而导致丢帧现象。</p><p><strong>方案 2：</strong> 采用 requestAnimationFrame，相比之下，requestAnimationFrame 的优势还是非常明显的，主要体现在<strong>以下几个方面：</strong></p><ul><li>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，再一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。</li><li>在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量。</li><li>requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。</li><li>与 setTimeout 相比，requestAnimationFrame 最大的优势是<strong>由系统来决定回调函数的执行时机。</strong></li><li>requestAnimationFrame 的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。</li></ul><p><strong>方案 3：</strong> 采用 IntersectionObserver，IntersectionObserver 接口 (从属于 Intersection Observer API) 为开发者提供了一种可以异步监听目标元素与其祖先或视窗 (viewport) 交叉状态的手段。祖先元素与视窗 (viewport) 被称为根 (root)。 <img src="https://oscimg.oschina.net/oscnet/up-d965531bd2f894fbcbc70fdb8be422da791.jpg" alt="" referrerpolicy="no-referrer"></p><p>可以看到，交叉了就是说明当前元素在视窗里，当前就是可见的了。是代替监听滚动加载的不错方案。</p><p>当然还有其他方案，还是要根据实际的业务场景选择合适的方案，IM 消息分段加载的难点在于消息的不定高 (多种不同类型的消息)，计算成本还是有一些昂贵的。所以优化还是要验证一下临界值的，有时候优化不一定会有效。</p><h3>2.3 消息遍历</h3><p>上面我们讲到消息排序、去重以及消息状态更新等等，多个会话大量的聊天消息，如果处理不当，卡顿是必现的，可以先看一下我们优化之前的处理流程，采用的是第三方的 SDK，一堆 for 循环，消息量大一些基本卡住没反应了。 <img src="https://oscimg.oschina.net/oscnet/up-3fed2d242eb5a6037ecf275fd18b342189f.jpg" alt="" referrerpolicy="no-referrer"></p><p>那我们是如何处理这个问题的呢？基于现有的业务场景重写三方 SDK，将会话维护成独立的实例，核心算法就是采用二分法。感兴趣的同学可以看之前的这篇文章&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkxNTE3ODU0NA%3D%3D%26mid%3D2247489429%26idx%3D1%26sn%3D0f7c0c2062c56abe6fb69944b6d48fa3%26scene%3D21%23wechat_redirect" target="_blank">得物客服 IM 消息通信 SDK 自研之路</a>，讲述得比较详细。重写了 IM SDK 之后，客服再也没有反馈过聊天相关的卡顿，聊天首响提升了 20%，成果还是比较显著的。</p><h2>消息安全方面的考虑</h2><p>在 IM 系统中，消息的安全性是非常重要，开发同学需要具备较强的安全意识，将安全融入到开发流程中，增强系统的安全性和健壮性。消息安全性方面的事情我们做了很多，这里也不再详细讲解了。</p><h2>消息发送和接收的延迟</h2><p>消息发送和接收的延迟直接影响用户的使用体验和沟通效率，在上面我们已经分析过一条消息的旅程，出现延迟的原因也比较好分析，主要有以下 4 点：</p><ul><li><strong>网络延迟：</strong> IM 消息的发送和接收是以长链接的方式进行网络传输的，而网络传输过程中会产生一定的延迟。如果网络延迟高，就会导致消息发送和接收较慢。</li><li><strong>系统负载：</strong> 客服在一对多的情况下，多个用户同时在线，系统需要处理大量的消息和请求，导致系统响应速度较慢，这会对客服的体验造成影响。</li><li><strong>前端延迟：</strong> 需要经过本地消息队列、缓存等处理，可能导致消息的延迟。</li><li><strong>消息编码和解码：</strong> 部分消息需要对数据进行编码和解码，也会消耗一定的时间，从而导致延迟。</li></ul><p>既然能分析出原因，我们就能对症下药，可以通过一些优化策略来降低发送和接收的延迟，目前规划从<strong>以下 2 个方面来进行优化：</strong></p><ul><li><p><strong>前端方面：</strong> 延迟主要在消息的处理和编解码方面，目前我们 IM 消息的数据格式是 JSON，存在序列化和反序列化的过程，这里我们会采用 ProtoBuf 替换 JSON，目前已完成了相关技术调研和测试验证。我们简单来看一下 ProtoBuf(Protocol Buffers) 和 JSON 处理耗时的对比：</p><p>编码时间：ProtoBuf 的编码时间比 JSON 快得多，因为 ProtoBuf 的编码是二进制的，不需要进行编码转换以及无需进行冗余类型的转换。相对而言，JSON 的编码时间较慢。</p><p>解码时间：相比编码，ProtoBuf 的解码效率要稍微低一些。但是，由于 ProtoBuf 的优势在数据量大、结构复杂的情况下更为明显，对于小型数据解码时，两者的效率差异可能不太明显。</p></li><li><p><strong>网络延迟：</strong> 网络延迟我们很难控制，但是可以通过降低消息传输体积进行相关优化，刚讲了 Protobuf 替换 JSON，Protobuf 是二进制格式，比 JSON 格式更加紧凑，能够使数据包大小大幅度减小，在网络传输中能够减少带宽占用和流量费用。在 IM 系统中，由于用户数量庞大，消息发送频繁，在数据占用和网络带宽方面是一个巨大的问题，使用 ProtoBuf 能够显著地减少网络带宽消耗，提高系统的性能。还有一方面就是消息压缩，但是压缩的深度和压缩算法需要慎重选择、验证。</p></li></ul><p>所以使用 ProtoBuf 格式代替 JSON 格式基本可以解掉一大半延迟问题，也是接下来 IM 优化的一个方向。</p><h2>坐席体验和交互的考虑</h2><p>说到坐席体验和交互方面，我们还是积累了不少经验的，不仅仅是 IM，体验和交互是所有产品都无法绕开的一个话题，自从做 IM 以来，体验可谓是鞭策我们不断前进的动力，卡顿是一直环绕在我耳边的一个话题。客服理解的卡顿和我们正常理解的卡顿还是有点不一样的，前期我们也以为是系统卡住导致无法使用了，类似掉帧的场景，实际却不是，接口请求慢了、有错误的 Tip 提示、页面切换有短暂空白显示、输入消息回车后消息未立刻显示到聊天页面、图片上传的 Loading 提示等等，都会被归为卡顿。针对这些方面我们也是不断的进行职场调研、数据分析、优化，客服的满意度提升到了 18%。可能在大家看来做了这么久提升 18% 并不是一个比较好的数据，但是针对客服域，提升 18% 也是一个相对比较难逾越的数据了。主要的原因在 2 个方面：第一个方面是很多客服都是 3 个月以内入职的，对于我们做的一些功能优化对比体验是无法感知或缺少功能使用对比的；第二个方面是很多一线客服都来自一线大厂的客服服务团队。其实反过来想一下，这也是一种正向的驱动，至少我们每次调研都能收集到新的反馈，同更加成熟、优秀产品的体验差距。</p><p>体验不是一蹴而就的，不要想着一下子就做到位，一个优秀的用户体验和交互设计需要始终与用户需求和反馈相结合，并不断改进和完善。在实际设计和开发过程中，需要进行不断的测试和优化，以确保系统的质量和可接受性。同时，需要与用户进行积极的沟通和反馈，以便更好地理解用户需求和意见，这一点我们之前是做的不够好的，尤其是新版本的推广，系统的易用性并未达到客服的期望，也是我们后期需要持续改进的一个方面。</p><p>体验是以绝大数用户需求为核心的，不能仅仅为了一小部分用户而去牺牲其他用户的使用体验，尤其不能因为某一个用户的反馈意见而做出过多的改变或者牺牲其他用户的利益。体验优化过程的不妥协也是非常重要的策略，在体验优化过程中，必须保持理性和客观，根据用户调研和数据分析进行合理的权衡和决策，以实现最佳的用户体验。</p><p>一些小细节的优化也可以起到事半功倍的效果，在 IM 系统中，一些细节的优化包括：及时的消息提示、清晰的消息展示、精确的消息发送时间等等。这些小细节的优化可以直接提高客服的使用效率和体验，从而提高客服满意度。IM 的体验优化我们会一直做下去，有志者事竟成。</p><h1>五、后续规划</h1><p>上述技术和思考的细节中有讲到消息的可靠性传递、卡顿优化处理、安全性、效率以及体验等，接下来的一段时间我们还是以这几个方面为主线进行，持续优化、完善 IM 相关能力。主要考虑以下几个方面的规划：</p><ul><li><strong>体验优化：</strong> 体验是我们一如既往要做的事情，会持续挖掘视觉、交互等层面的优化点，从细节入手，比如：颜色搭配，按键选择等，提供良好的坐席体验。</li><li><strong>ProtoBuf 替换 JSON：</strong> 降低消息编码时间、提升解码效率、减少数据包体积、减少网络带宽消耗，提高系统的性能。</li><li><strong>消息压缩：</strong> 尤其是针对历史消息、批量消息，使用压缩技术，可以有效的减少数据包的体积。</li><li><strong>功能扩展：</strong> 持续完善机器人消息类型，尤其是针对售前导购、坐席辅助。逐步支持消息引用、标记等功能。</li><li><strong>多语言能力支持：</strong> 虽然目前还没有接入国际化业务，但在设计层面还是要具备快速扩展的能力。</li></ul><p>上述几个方面我们会优先去做重要且紧急的技术改造，并不会一味的创新、优化，还是会以业务为主，紧紧围绕业务和坐席体验展开。</p><h1>六、总结</h1><p>客服发送一条消息在 IM 应用中看似简单，背后需要考虑的技术细节点是很多的。首先，这需要考虑到消息的发送机制和可靠性。即使是一条简单的消息，也需要经过一系列的加密、编码、传输、安全合规等等处理才能被成功接收。</p><p>最重要的是要考虑到数据实时性的问题，各种极限场景下的操作，客服发送的消息需要被及时展示到聊天页并传输给用户，客服同学在一对多的场景下工作，需要确保各会话消息不会出现不一致 (丢失、重复)，还有消息拦截和异常情况等问题。</p><p>因此，客服发送一条消息不仅需要技术能力和数据处理能力，还需要思考坐席体验和数据实时性等方面的问题。开发过程中需要细致入微地处理各种问题并持续优化，从而为客服提供一个稳定、流畅、安全、友好的 IM 应用。</p><p>参考文章：</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkxNTE3ODU0NA%3D%3D%26mid%3D2247489429%26idx%3D1%26sn%3D0f7c0c2062c56abe6fb69944b6d48fa3%26scene%3D21%23wechat_redirect" target="_blank">得物客服 IM 消息通信 SDK 自研之路</a></p><p>*文 / WWQ</p><p>本文属得物技术原创，更多精彩文章请看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.dewu.com" target="_blank">得物技术官网</a></p><p>未经得物技术许可严禁转载，否则依法追究法律责任！</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 10:41:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/10140300</guid>
            <link>https://my.oschina.net/u/5783135/blog/10140300</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[前三季度互联网企业利润总额同比增 18.2%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年前三季度互联网和相关服务业运行情况现已公布。前三季度，互联网业务收入增速小幅提升，利润总额较快增长，研发经费持续下滑。</p><h4 style="margin-left:0px; margin-right:0px"><strong>一，总体运行情况</strong></h4><p><strong>互联网业务收入增速小幅提升。</strong>前三季度，我国规模以上互联网和相关服务企业 1（以下简称互联网企业）完成互联网业务收入 10294 亿元，同比增长 3.4%。</p><p><img height="241" src="https://oscimg.oschina.net/oscnet/up-505b65f84338dd716295e76b74112009b70.png" width="500" referrerpolicy="no-referrer"></p><p><strong>利润总额较快增长。</strong>前三季度，我国规模以上互联网企业营业成本同比增长 7%，增速较上半年回落 0.4 个百分点。实现利润总额 959.3 亿元，同比增长 18.2%。</p><p><img height="239" src="https://oscimg.oschina.net/oscnet/up-54642fdf1ae20d26f1bc9494e46da1f4440.png" width="500" referrerpolicy="no-referrer"></p><p><strong>研发经费持续下滑。</strong>前三季度，我国规模以上互联网企业共投入研发经费 495.9 亿元，同比下降 6.1%。</p><p><img height="246" src="https://oscimg.oschina.net/oscnet/up-d14b35b6a1179d07e10ffc542ff0150925e.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px"><strong>二，分领域运行情况</strong></h4><p style="margin-left:0; margin-right:0"><strong>（一）信息服务领域企业收入小幅回落。</strong>前三季度，以信息服务为主的企业（包括新闻资讯、搜索、社交、游戏、音乐视频等）互联网业务收入同比下降 2.7%。</p><p><strong>（二）生活服务领域企业收入较快增长。</strong>前三季度，以提供生活服务为主的平台企业（包括本地生活、租车约车、旅游出行、金融服务、汽车、房屋住宅等）互联网业务收入同比增长 9.8%。</p><p><strong>（三）网络销售领域企业收入增速持续提升。</strong>前三季度，主要提供网络销售服务的企业（包括大宗商品、农副产品、综合电商、医疗用品、快递等）互联网业务收入同比增长 47.3%。</p><h4 style="margin-left:0px; margin-right:0px"><strong>三，分地区运行情况</strong></h4><p><strong>东部地区互联网业务收入保持平稳增速。</strong>前三季度，东部地区完成互联网业务收入 9613 亿元，同比增长 4.5%，增速较上半年提升 0.7 个百分点，占全国互联网业务收入的比重为 93.4%。中部地区完成互联网业务收入 329.5 亿元，同比下降 9.7%，降幅较上半年扩大 2.2 个百分点。西部地区完成互联网业务收入 325 亿元，同比下降 7.5%，降幅较上半年收窄 3.2 个百分点。东北地区完成互联网业务收入 26.5 亿元，同比下降 33.3%，降幅较上半年收窄 6.4 个百分点。</p><p><img height="239" src="https://oscimg.oschina.net/oscnet/up-7b7896fe852aa2c94820a864e846f80cae2.png" width="500" referrerpolicy="no-referrer"></p><p><strong>长三角地区互联网业务收入实现较快增长。</strong>前三季度，京津冀地区完成互联网业务收入 3948 亿元，同比增长 2.9%，增速较上半年回落 0.3 个百分点，占全国互联网业务收入的比重为 38.4%。长三角地区完成互联网业务收入 4225 亿元，同比增长 13.1%，增速较上半年提升 3.5 个百分点。</p><p><img height="300" src="https://oscimg.oschina.net/oscnet/up-f6cddc5c38e933857b00b43bd049054bd02.png" width="500" referrerpolicy="no-referrer"></p><p><strong>半数地区互联网业务增速实现正增长。</strong>前三季度，互联网业务累计收入居前 5 名的北京（增长 0.7%）、上海（增长 17.7%）、浙江（增长 5.1%）、广东（下降 7.4%）和天津（增长 22.3%）共完成业务收入 9077 亿元，同比增长 5.5%，占全国比重达 88.2%。全国互联网业务增速实现正增长的省（区、市）有 15 个。</p><p><img height="243" src="https://oscimg.oschina.net/oscnet/up-d691bf5c06989113a27d8f6cf4a88d4ab6e.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px"><strong>四，我国移动应用程序（APP）发展情况</strong></h4><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">根据全国 APP 技术检测平台统计，截至 9 月底，我国国内市场上监测到活跃的 APP 数量 2 为 261 万款（包括安卓和苹果商店）。移动应用开发者数量为 84 万，其中安卓开发者为 26 万，苹果开发者为 58 万。9 月份，安卓应用商店在架应用累计下载量 542 亿次。</p><p><span style="color:#888888">附注：</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#888888">1.规模以上互联网和相关服务企业口径由上年互联网和相关服务收入 500 万元以上调整为 2000 万元及以上，文中所有同比增速均按可比口径计算。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#888888">2.活跃的移动应用程序数量是指报告期内我国市场上经过用户主动下载安装的第三方移动应用的总个数，其中安卓应用数的计算方法是根据智能手机记录的已安装移动应用去重后获得。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 10:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264303</guid>
            <link>https://www.oschina.net/news/264303</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[公益组织请愿微软延长 Windows 10 支持]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">美国公共利益研究组织 (PIRG) 近日向微软 CEO 萨蒂亚·纳德拉 (Satya Nadella) 发起一项<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpirg.org%2Ftake-action%2Ftell-microsoft-dont-leave-millions-of-computers-behind%2F" target="_blank">请愿</a>，呼吁该公司重新考虑在 2025 年 10 月终止 Windows 10 支持的举措。</span></p><p><span style="color:#000000">该组织认为，<span style="background-color:#ffffff">在目前使用 </span>Windows 10&nbsp;<span style="background-color:#ffffff">的 10 亿台设备中，有超过 4 亿台设备不满足&nbsp;</span>Windows 11&nbsp;<span style="background-color:#ffffff">系统的升级要求。</span>Windows 10 生命周期的结束将意味着它们会失去微软的支持，从而走向报废<span style="background-color:#ffffff">；由此产生的巨量电子垃圾，也</span>与该公司在环保方面的立场相悖。</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">「微软需要重新考虑这一决定，继续为数亿无法升级电脑的用户提供安全更新，这既是为了他们的经济利益，也是为了保护环境。」</span></span></p><p><span style="color:#000000">请愿书内容如下：</span></p><blockquote><p><span style="color:#000000">尊敬的微软首席执行官萨蒂亚·纳德拉，</span></p><p><span style="color:#000000">不要让数亿台电脑报废。微软决定终止对 Windows 10 的支持可能会导致垃圾电脑数量出现有史以来最大的增幅，并使微软无法实现其可持续发展目标。新版操作系统对硬件的严格要求可能导致 40% 的在用电脑被抛弃。</span></p><p><span style="color:#000000">微软决定停止为医院、企业和家庭中数亿台功能正常的电脑提供支持，这对那些希望自己的昂贵设备能够经久耐用的客户来说，是一个不公平的交易。</span></p><p><span style="color:#000000">所有软件都会有停止支持的时候，但如果会对我们的环境造成严重的负面影响，我们就不应该接受。</span></p></blockquote><p><img alt="" height="375" src="https://oscimg.oschina.net/oscnet/up-b960c9a173a51ef51f32995e73b51017405.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">微软尚未发布有关 Windows 10 支持终止的公开声明，但外界猜测其可能复制 Windows 7 支持到期时的做法；允许<span style="background-color:#ffffff">专业版和企业版</span>有偿延长支持最长三年，但家庭版除外。</span></p><p><span style="color:#000000">PIRG 的 Designed to Last 活动总监 Lucas Rockett Gutterman <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpirg.org%2Fmedia-center%2F20000-call-on-microsoft-to-save-400-million-pcs%2F" target="_blank">指出</a>，微软过去曾扩展过对旧操作系统的支持。譬如 Windows XP 用户就收到了长达 13 年的安全更新，当其支持结束时，仍然可以在全球 30% 的计算机上运行。<span style="background-color:#ffffff">Windows 10 发布</span>后&nbsp;，在很大程度上是「向后兼容」的，这意味着当微软终止对其现有 Windows 系统的支持时，大多数旧计算机都能够运行新操作系统。</span></p><p><span style="color:#000000">「考虑到微软过去的这些行为，该公司强行过渡到 Windows 11 实在令人吃惊。这不仅对消费者不利，也对地球不利，因为这些过时的电脑将增加我们日益堆积的有毒电子垃圾。」</span></p><p><span style="color:#000000">也有人<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theregister.com%2F2023%2F10%2F27%2Fmicrosoft_petitioned_to_keep_windows%2F" target="_blank">提出</a>了或许可以转用其他操作系统的想法。对此，Gutterman 则解释称，虽然开源社区一直都有在努力支持被其他厂商放弃的硬件，<span style="background-color:#ffffff">但对于学校和医院等依赖仅适用于 Windows 的软件的机构来说，这种转变更为复杂。</span></span></p><p><span style="color:#000000">「<span style="background-color:#ffffff">对于微软来说，推动这些机构处置和更换那些功能正常、且仍在帮助学生和患者的个人电脑是没有意义的。最简单的解决方案就是微软扩展支持。</span>」</span></p><p><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpirg.org%2Ftake-action%2Ftell-microsoft-dont-leave-millions-of-computers-behind%2F" target="_blank">请愿书地址</a></strong></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 09:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264497/pigc-microsoft-extends-windows-10-support</guid>
            <link>https://www.oschina.net/news/264497/pigc-microsoft-extends-windows-10-support</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[项目捐给了开源基金会，作者手上还剩了什么？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#3498db"><strong>原标题：Apache 软件基金会项目孵化过程中知识产权转移的讨论</strong></span></p><ul><li><p>作者：张伟玲，谭中意</p></li><li><p>审核：姜宁，张亮</p></li></ul><p style="margin-left:0px; margin-right:0px; text-align:start">作者简介：</p><p style="color:#333333; text-align:start"><em>张伟玲，多年大型互联网知识产权法律经验，擅长商标、开源、著作权等知识产权法律领域的合规制度建设、 培训和诉讼支持，在互联网信息网络传播/合规/品牌等领域有丰富实战经验。</em></p></blockquote><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>讨论背景：</strong></p><p style="color:#333333; text-align:start">自 2002 年 Apache Software Foundation（<strong>ASF</strong>）开始孵化项目以来，ASF 至今已经毕业了 200 多个顶级项目。在这些项目中，无论是个人捐赠还是企业捐赠的，都必须严格遵守其孵化流程和政策要求。尤其是近几年来，越来越多的国人发起的开源项目进入 Apache 基金会孵化，并有不断的项目毕业，Apache 开源基金会在国内的影响力越来越大。而它作为一个国际范围内 host 项目最多的开源基金会，它的各种政策和流程也越来越为更多人熟悉。</p><p style="color:#333333; text-align:start"><img src="https://alc-beijing.github.io/alc-site/images/apache_incubator_IP_policy/apache_incubator_ip_1.png" referrerpolicy="no-referrer"></p><p style="color:#333333; text-align:start">而其中最重要的一个流程—项目孵化，在知识产权方面也有很独特的政策。那么，作为项目所有者的您，在面对这些政策和可能会遇到各种文件时，是否有过困惑「我签署了什么？项目的知识产权还是我的吗？或者说我还剩些什么权利呢？…」，为了解决这些困惑，本文会对您可能遇到的问题进行初步讨论分析，当然本人是从公开发表的资料和文档，并结合亲身经历的项目捐献和孵化过程中总结，也有些认识不到位的地方，请多多讨论，有问题可跟本人微信号<strong>weiweizhang0410</strong>讨论，thanks。</p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>先说结论：</strong></p><p style="color:#333333; text-align:start">总的来说，捐献项目给 Apache 基金会，Apache 基金会需要您的「版权授权 + 专利授权 + 商标转让」。</p><p style="color:#333333; text-align:start">知识产权即人们常说的 IP（Intellectual Property）,跟开源软件相关的主要有如下三项：版权（即 Copyright），专利（即 Patent），商标（即 Trademark ）。根据 Apache 基金会的 IP 政策，个人或者公司捐献项目给它，该项目的专利和版权必须授权给它，商标必须要转让给它。</p><p style="color:#333333; text-align:start">即它既要商标的所有权（owner），又要专利的使用授权，还要版权的使用授权。</p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>具体解释：</strong></p><p style="color:#333333; text-align:start">开源项目要进入 Apache 基金会进行孵化，原有版权所有人必须要签署如下两个文件，一个是 SGA（Software Grant Agreement），另外一个是 CCLA/ICLA（公司或者个人贡献协议 ICLA: Individual Contributor License Agreement，CCLA: Corporate Contributor License Agreement）。我们一起来看看这两个文件的内容。</p><p style="color:#333333; text-align:start">先看看 SGA（Software Grant Agreement），以下是协议原文信息：<img src="https://alc-beijing.github.io/alc-site/images/apache_incubator_IP_policy/apache_incubator_IP_2.png" referrerpolicy="no-referrer"></p><p style="color:#333333; text-align:start">下面我们来仔细看下这篇文档的重点部分。</p><p style="color:#333333; text-align:start"><em>「WHEREAS, Licensor owns or has sufficient rights to contribute the software source code and other related intellectual property as itemized on Exhibit A (「Software」) under the terms of this agreement to the Foundation for use within Foundation software development projects (「Projects」).</em></p><p style="color:#333333; text-align:start">首先，实务操作中需要签署人必须有足够的授权来贡献代码和相关的 IP。默认规则下该签署人至少是该公司高级总监以上的职位。</p><p style="color:#333333; text-align:start">然后看关键的部分：<span>&nbsp;</span><em><strong>「Subject to the terms and conditions of this License, Licensor hereby grants to the Foundation:</strong></em></p><p style="color:#333333; text-align:start"><em><strong>a) a non-exclusive, worldwide, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, distribute and sublicense, internally and externally, the Software and such derivative works, in source code and object code form; and</strong></em></p><p style="color:#333333; text-align:start"><em><strong>b) a non-exclusive, worldwide, royalty-free, irrevocable patent license under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Software in source code and object code form. 「Licensed Patents」 mean patent claims owned by Licensor which are necessarily infringed by the use or sale of the Software alone.</strong></em></p><p style="color:#333333; text-align:start"><strong>许可人授予基金会如下权利:</strong></p><ul><li><p>a） 以源代码和目标代码的形式在全球范围内复制、准备衍生作品、公开展示、公开表演、分发和再授权软件及其衍生作品的非排他性、免版税、不可撤销的版权许可；以及，</p></li><li><p>b） 非排他性的、全球范围内的、免版税的、不可撤销的专利许可证，根据许可专利以源代码和目标代码的形式获得、使用、销售、许诺销售、进口和以其他方式转让该软件。」</p></li></ul><p style="color:#333333; text-align:start">我们再看下 CCLA（Corporate Contributor License Agreement），原文相对较长，截取原文知识产权重点部分：</p><p style="color:#333333; text-align:start"><img src="https://alc-beijing.github.io/alc-site/images/apache_incubator_IP_policy/apache_incubator_IP_3.png" referrerpolicy="no-referrer"><img src="https://alc-beijing.github.io/alc-site/images/apache_incubator_IP_policy/apache_incubator_ip_4.png" referrerpolicy="no-referrer"></p><p style="color:#333333; text-align:start"><strong>简单摘要如下：</strong></p><p style="color:#333333; text-align:start"><em>「感谢您对 Apache 软件基金会（「基金会」）的关注。为了阐明由任何个人或实体提供的贡献所授予的知识产权许可，基金会须具有由每个贡献者签署的「贡献者许可协议」（CLA），以表明同意以下许可条款。该许可证是为了保护您作为贡献者，以及保护基金会及其用户；它不会改变您将自己的贡献用于任何其他目的的权利。</em><span>&nbsp;</span>。。。。</p><p style="color:#333333; text-align:start">2.授予版权许可。在遵守本协议前提下，授予接收者永久的，全球的，非独占的，免费的，免版税，不可撤销的版权许可，以复制、公开展示、公开表演，再许可、分发您的作品以及此类的衍生作品。</p><p style="color:#333333; text-align:start">3.授予专利许可。在遵守本协议前提下，授予接收者永久的，全球的，非独占的，免费的，免版税，不可撤销的专利许可（本节所述除外）获得、使用，销售，许诺销售，进口和以其他方式转让作品。。。</p><p style="color:#333333; text-align:start">综上所述，作为项目协议来说，这份两份许可是较简短的，但是从其内容来看却已经足以明晰 ASF 的需求和项目所有者的义务： 项目所有者作为软件权利人，需要授予 ASF 两项权利，即：版权和专利权。 也就是说在这个阶段，ASF 所需要的是您的版权和专利的授权，是在全球范围的 ASF 可以免费复制、分发、再授权等的权利。</p><p style="color:#333333; text-align:start">根据 ASF 孵化政策，项目毕业前需转让项目商标，该审核一般由 ASF 品牌管理负责部门进行审批，在该阶段审批，一般是出于若毕业后再更名，会需要来自技术团队的大量支持，因此，从 ASF 角度会要求尽早提起商标的转让审核。</p><p style="color:#333333; text-align:start">经过上述初步分析来看，无论是签署的协议文件，还是孵化过程中的商标转让义务，ASF 未要求项目所有者对于版权和专利的所有权的转让，作为项目所有者需要承担的义务主要为：版权授权 + 专利授权 + 商标转让。</p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>发版说明：</strong></p><p style="color:#333333; text-align:start">可能有的同学要问，既然捐献过程中没有发生版权的转移，但是为什么 Apache 毕业项目的 Copyright Owner 都是 Apache Foundation 呢，例如看 apache kafka（这是 linkedin 捐献给 Apache 基金会的项目），每个源码文件的 license header 都指向 Notice 文件。https://github.com/apache/kafka/blob/trunk/NOTICE</p><pre><code>Apache Kafka
Copyright 2020 The Apache Software Foundation.

This product includes software developed at
The Apache Software Foundation (https://www.apache.org/).
</code></pre><p style="color:#333333; text-align:start">再看 apache beam 项目（这是 google 捐献给 apache 基金会的项目），每个源码文件的 license header 都指向 notice 文件，<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fbeam%2Fblob%2Fmaster%2FNOTICE" rel="nofollow" target="_blank">https://github.com/apache/beam/blob/master/NOTICE</a><span>&nbsp;</span>文件内容如下：</p><pre><code>Apache Beam
Copyright 2016-2018 The Apache Software Foundation

This product includes software developed at
The Apache Software Foundation (http://www.apache.org/).
</code></pre><p style="color:#333333; text-align:start">那是因为按照 Apache 基金会发版的要求，每个项目在发布软件版本的时候，是需要把源码中的每个文件的头部都加上 Apache 基金会指定的 License Header，而这个 License Header 的内容统一指向该项目的 NOTICE 文件。（当然如果包含了其他第三方开源代码，需要按照该开源项目许可证的要求，在 Header 上保留源作者的版权申明的，详见 https://www.apache.org/legal/src-headers.html#3party。）</p><pre><code>/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0

 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
</code></pre><p style="color:#333333; text-align:start">而该 NOTICE 文件一般内容都是指明当前的 Copyright Owner 是 Apache 基金会。但是在该 NOTICE 文件中，是可以保留一些之前版本的 Copyright Owner 的声明的。 例如 Netbeans 这个项目，它最早的 Owner 是 Sun Microsystem，之后 Sun 被 Oracle 收购后，Copyright Owner 变成 Oracle，而之后 Oracle 把这个项目捐献给 Apache 基金会。为了保护各个 Owner 的知识产权，把各个时期的 Copyright Owner 都列了出来，所以现在的内容 https://github.com/apache/netbeans/blob/master/NOTICE 如下：</p><pre><code>Apache Netbeans
Copyright 2017-2020 The Apache Software Foundation

This product includes software developed at
The Apache Software Foundation (http://www.apache.org/).

The code is based on NetBeans, that has been kindly donated to the Apache
Software Foundation by Oracle.

The code was Copyright 1997-2016 Oracle and/or its affiliates.  The Initial
Developer of the Original Software was Sun Microsystems, Inc. Portions
Copyright 1997-2006 Sun Microsystems, Inc.
</code></pre><p style="color:#333333; text-align:start">从上面的文件中能看出，该文件的 Copyright 按照时间列出了前后几个，1997-2006 为 Sun Microsystems，1997-2016 为 Oracle，2017-2020 为 Apache foundation。</p><p style="color:#333333; text-align:start">我们追溯 ASF 在 2004 年的董事会记录，发现，上述操作是基金会为了解决「用户在向 ASF 提供授权时，ASF 文件中版权声明却归他人持有人时的不一致情况」，根据董事会方案： 「版权者的首选处理方式是删除此类声明，或将其放在单独的位置归档，以包含在每个项目的 COPYRIGHT 文件中，或在贡献中包含基金会的书面许可，以进行通知的删除或重新安置；被许可给 ASF 的文件应有版权声明，并进行适当修改，以反映贡献年份和原始发行的任何后续年份。」</p><p style="color:#333333; text-align:start">因此，作为项目所有人的版权信息，有的会在 NOTICE 部分予以体现。但是 Apache 的发版和毕业政策都会约定最新版本的 Copyright Owner 声明是 Apache 基金会，虽然可以保留之前版本的 Copyright 说明。只有统一被授权方均为 Apache 基金会，该软件的用户基于对 Apache 基金会的品牌和信心，才会持续在该项目上进行投入，不担心出现该软件的主导公司未来的某一天把该软件闭源的情况。因为即使出现该软件主导方不再继续投入，或者另起炉灶的情况，Apache 的知识产权制度保证了还有社区的其他人在继续维护。而该软件最新版本的 Copyright Owner 是 Apache 基金会，则在法律上减少了该社区在继续维护上的知识产权纠纷。</p><p style="color:#333333; text-align:start">这是 Apache 开源基金会精心的知识产权政策的设计，为了保证它旗下的项目是一个可信赖的产品，因为知识产权问题已经理清，持续维护的问题也已经解决，所以 Apache 的项目才会如此受到欢迎，所以才会有更多的公司或者个人把项目捐献给 Apache 基金会。</p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>总结：</strong></p><p style="color:#333333; text-align:start">综合上面的说明来看，当有新的项目需要经 ASF 孵化毕业，作为项目所有人需要承担的义务主要在于版权授权、专利授权和商标转让，版权原始权利并未转让，因此，在项目的实际操作中请记得根据 ASF 的官方格式保留自己的权利声明。 本文主要是基于实践操作和 ASF 官方规定作出的一些讨论，在您具体项目确定孵化或捐赠之前，请一定与您的律师进行个案的综合评估以保障您的权益哦。当然也欢迎微信联系跟本人共同沟通讨论。</p><p style="margin-left:0px; margin-right:0px; text-align:start">参考资料：</p><ul><li><p>ASF Contributor agreement<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.apache.org%2Flicenses%2Fcontributor-agreements.html" rel="nofollow" target="_blank">http://www.apache.org/licenses/contributor-agreements.html</a></p></li><li><p>ASF SGA template<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.apache.org%2Flicenses%2Fsoftware-grant-template.pdf" rel="nofollow" target="_blank">http://www.apache.org/licenses/software-grant-template.pdf</a></p></li><li><p>ASF CCLA<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.apache.org%2Flicenses%2Fcla-corporate.pdf" rel="nofollow" target="_blank">http://www.apache.org/licenses/cla-corporate.pdf</a></p></li><li><p>Apache 文件头说明<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.apache.org%2Flegal%2Fsrc-headers.html" rel="nofollow" target="_blank">https://www.apache.org/legal/src-headers.html</a></p></li><li><p>ASF 2004 Board meeting 记录<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.apache.org%2Ffoundation%2Frecords%2Fminutes%2F2004%2Fboard_minutes_2004_11_14.txt" rel="nofollow" target="_blank">https://www.apache.org/foundation/records/minutes/2004/board_minutes_2004_11_14.txt</a></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 09:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/oscpyaqxylk/blog/10140275</guid>
            <link>https://my.oschina.net/oscpyaqxylk/blog/10140275</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[深秋，寒露：是时候和 Zadig 说再见了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank"><img alt="" src="https://oscimg.oschina.net/oscnet/up-672c752071cec6bcdf28b3468d5bde60d1a.png" referrerpolicy="no-referrer"></a></p><div><div style="text-align:center"><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank">阅读原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig">Zadig 在 Gitee</a></p><p><strong>推荐阅读：</strong><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490415%26idx%3D1%26sn%3D1914c7fd25aac5d33b98663571bbb744%26chksm%3Dcfb457cff8c3ded9c02809aad88012fa802eac55222eebe70b8c637ca2c86a101045aa81e73a%26scene%3D21%23wechat_redirect" target="_blank">是时候和 Jenkins 说再见了</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank">Zadig vs. Jenkins 详细比对：时代的选择与开发者之选</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247489682%26idx%3D1%26sn%3Df4ac5ceb38547542061477a45d8dc86d%26chksm%3Dcfb45432f8c3dd24b727e0fb6db276b2d63b2751933e63a25b00b9d9fac2dd68efbd2cbd3863%26scene%3D21%23wechat_redirect" target="_blank">平台工程和 AI 时代的新 10 亿开发者</a></p></div><div style="text-align:center">
   2023 年 11 月 1 日 
 </div><div style="text-align:center">
   秋风起，露成霜，正是一年最美时 
 </div><div style="text-align:center">
   Zadig 团队踏入了 
 </div><div style="text-align:center">
   创业的第五个年头 
 </div><div style="text-align:center">
   开源的第 888 天 
 </div><div style="text-align:center">
   然而今天 
 </div><div style="text-align:center">
   我们要向 Zadig 
 </div><div style="text-align:center">
   说再见了 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   深秋外象趋冷 
 </div><div style="text-align:center">
   实则万物蛰伏 
 </div><div style="text-align:center">
   在孕育着新的生机 
 </div><div style="text-align:center">
   今天，我们向 Zadig 1.0 告别 
 </div><div style="text-align:center"><span style="color:#fd2968"><strong>迎来全新的 Zadig 2.0!</strong></span></div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   回顾开源的这两年多时间里 
 </div><div style="text-align:center">
   Zadig 1.0 已完成了 2 万 6 千多次的企业下载 
 </div><div style="text-align:center">
   发布了 21 个开源版本，10 个企业版本 
 </div><div style="text-align:center">
   在 2 千多家企业和团队深度使用 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   我们创作了 157 篇原创技术和产品文章 
 </div><div style="text-align:center">
   制作了 52 个独创的短视频 
 </div><div style="text-align:center">
   与 100 多位国内外商业、技术和产品领域的同仁伙伴建立了深厚的链接 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   今天，Zadig 已不再是婴儿 
 </div><div style="text-align:center">
   是一个坚定自信的少年 
 </div><div style="text-align:center">
   走进数千家企业和团队的日常工作中 
 </div><div style="text-align:center">
   让他们的工作更加高效愉悦 
 </div><div style="text-align:center">
   这段旅程，Zadig 背后的团队和社区一起 
 </div><div style="text-align:center">
   合作共创 
 </div><div style="text-align:center">
   品味挫折 
 </div><div style="text-align:center">
   分享喜悦 
 </div><div style="text-align:center">
   追逐自由 
 </div></div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-fbb18b0ecc053068d166ea1f637149f273f.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-e94bae5f521bce7e3f5326d76218df7912c.png" referrerpolicy="no-referrer"></p><div><div style="text-align:center">
   今天，2023 年 11 月 1 日 
 </div><div style="text-align:center">
   我们团队决定再度迈出一大步 
 </div><div style="text-align:center">
   正式宣布： 
 </div><div style="text-align:center">
   开源 Zadig 与，企业版 ZadigX 产品合并！ 
 </div><div style="text-align:center">
   并全面启用企业版功能，提供一键试用 
 </div><div style="text-align:center">
   与此同时，我们做出了重大的决定 
 </div><div style="text-align:center">
   全部开放服务端源代码 
 </div><div style="text-align:center">
   接下来我们还将发布崭新的文档站 
 </div><div style="text-align:center">
   并推出更加易用的新手在线教程 
 </div></div><span id="OSC_h1_1"></span><h1><span style="color:#fd2968"><em><strong>01</strong></em><strong>为何做出这一选择？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-e6678f7e349d8523888cb8b7d3e0659b69a.png" referrerpolicy="no-referrer"></strong></p><div><div style="text-align:center">
   首先，我们希望通过更开放的方式 
 </div><div style="text-align:center">
   为这个不平凡的时代注入信心 
 </div><div style="text-align:center">
   在过去的三年中，我们共同经历了许多挑战 
 </div><div style="text-align:center">
   包括疫情、经济动荡，资本衰退、互联网红利时代的结束，AI 时代的到来 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   其次，我们希望通过这次开放性尝试，带给每位 IT 从业者更多力量！ 
 </div><div style="text-align:center">
   开源 2 年半以来，社区里的每个人，不论是 80 后、90 后还是 00 后 
 </div><div style="text-align:center">
   都经历了前所未有的技术和经济周期 
 </div><div style="text-align:center">
   似乎没有人准备好，但这些挑战都如期而至： 
 </div><div style="text-align:center">
   互联网大规模的裁员和失业潮影响了我们每个人和每个家庭 
 </div><div style="text-align:center">
   「IT 行业的未来在哪里？ 
 </div><div style="text-align:center">
   IT 人的未来在何方？ 
 </div><div style="text-align:center">
   什么是时代需要的创新？ 
 </div><div style="text-align:center">
   什么是适合中国特色的 IT 创新之路？ 
 </div><div style="text-align:center">
   如何用技术让这个世界更美好？」 
 </div></div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-7643c8b8c38bf97523b3e001c3806795bac.png" referrerpolicy="no-referrer"></p><p>作为 Zadig 的创始人，我会经常思考这些问题。显然并没有标准答案，有一点可以肯定：真正的创新是思想的进步和对他人带来的积极影响。其实，开源代码从来不是核心资产，我们希望用更开放的心态，和社区、用户、客户的小伙伴们更为紧密的配合，找到最佳的姿势帮助到最需要的人，与同行者一起面对每一次成长和变化，直面每一次恐惧和不安。</p><p>同时，通过这次版本发布和源码开放，我们希望能够让更多的开发者看到 Zadig 的企业级全部功能，为希望成为客户的用户提供更为简单的升级方式，从根本上提供更多安全感。通过新版本 Zadig，企业客户可以一键输入试用授权，快速实验 Zadig 专业版能力，企业客户更放心地尝试新技术和新产品，助力各个行业、产业 IT 的数字化升级。</p><p>作为软件交付和研发链路中重要的连接者，我们希望通过这次 Zadig V2.0.0 的开源和版本发布，与同行的基础软件开发者们一起尝试新模式，为建立新的开源商业秩序开一个头。</p><span id="OSC_h1_2"></span><h1><span style="color:#fd2968"><em>02&nbsp;&nbsp;</em><strong>Zadig 产品具体有哪些变化？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-a6a559045246e08f1857b0e8666bab21df8.png" referrerpolicy="no-referrer"></strong></p><p>从源代码层面上，本次产品合并以开源 Zadig v1.18.0（最新版） 为基础，合并了原 ZadigX v1.8.0（即企业版）全部新功能代码，统称为 Zadig，产品版本正式定义为 Zadig v2.0.0，同时服务端代码在 GitHub 上全部开源，产品功能差异通过授权区分基础版和专业版。</p><p>对于已经在大规模使用 Zadig 的小伙伴，如果期待了解和亲自体验专业版功能，可以在平滑升级后免费激活并体验专业版功能长达 30 天，到期后专业版产生的数据不删除，原有基础版功能仍可正常使用。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-d6ad9eba6f9b41f1d391901be2fd3ae39c0.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_3"></span><h1><span style="color:#fd2968"><em>03&nbsp;&nbsp;</em><strong>对现有用户有哪些影响？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-91c5dba9d5f03113d993ebe2fa94c7638cd.png" referrerpolicy="no-referrer"></strong></p><p>对于社区开源用户而言，将在原有开源基础功能上进一步获得更多企业级功能，包括环境管理睡眠进一步做资源成本的削减，同时支持服务级测试管理、自定义工作流也一次性开放了大量企业内置最佳实践模板。同时 Zadig v2.0.0 在过去 V1.x 架构的基础上架构的基础上改进了易用性和性能，优化了安全细节，显著提高了工作流并行和复杂场景的执行效率，效率提升高达 50%，Zadig 的资源运行成本也降低了近 30%。在之后迭代中，用户也将持续获得产品底层能力的可靠性，这些更新将帮助到更多企业，提升开发测试阶段的云原生持续交付能力，为开发者提供更出色的体验。</p><p>对于企业客户，我们用 ZadigX 品牌代表包含企业级功能和专业服务的解决方案，"X"代表为企业客户提供更高质量的服务和保障，根据企业的具体难点和需求，接下来我们会面向企业推出一系列 DevOps 专家培训、DevOps 效能提升、云原生转型、IT 数字化升级等企业级解决方案。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-8c8a7c1737a91a1e0f819e9dcb9a3c82b9c.png" referrerpolicy="no-referrer"></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-5b2c672b70e514e6133d7b885270d5fc71c.png" referrerpolicy="no-referrer"></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank">阅读原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig">Zadig 在 Gitee</a></p><p><strong>推荐阅读</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490415%26idx%3D1%26sn%3D1914c7fd25aac5d33b98663571bbb744%26chksm%3Dcfb457cff8c3ded9c02809aad88012fa802eac55222eebe70b8c637ca2c86a101045aa81e73a%26scene%3D21%23wechat_redirect" target="_blank">是时候和 Jenkins 说再见了</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank">Zadig vs. Jenkins 详细比对：时代的选择与开发者之选</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247489682%26idx%3D1%26sn%3Df4ac5ceb38547542061477a45d8dc86d%26chksm%3Dcfb45432f8c3dd24b727e0fb6db276b2d63b2751933e63a25b00b9d9fac2dd68efbd2cbd3863%26scene%3D21%23wechat_redirect" target="_blank">平台工程和 AI 时代的新 10 亿开发者</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 07:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/koderover/blog/10140233</guid>
            <link>https://my.oschina.net/koderover/blog/10140233</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[阿里云推出 AI 编码助手：通义灵码]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">阿里云推出了一款基于通义大模型的智能编码辅助工具 —— <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftongyi.aliyun.com%2Flingma%2F" target="_blank">通义灵码</a>，提供行级/函数级实时续写、自然语言生成代码、单元测试生成、代码注释生成、代码解释、研发智能问答、异常报错排查等能力，并针对阿里云 SDK/OpenAPI 的使用场景调优，助力开发者高效、流畅的编码。</span></p><p><span style="color:#000000">根据官网介绍，通义灵码兼容 Visual Studio Code、JetBrains IDEs 等主流 IDE；且支持 Java、Python、Go、C/C++、JavaScript、TypeScript、PHP、Ruby、Rust、Scala 等主流编程语言。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>核心场景</strong></span></h4><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代码智能生成</strong></span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000">经过海量优秀开源代码数据训练，可根据当前代码文件及跨文件的上下文，为你生成行级/函数级代码、单元测试、代码注释等。沉浸式编码心流，秒级生成速度，让你更专注在技术设计，高质高效地完成编码工作。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>研发智能问答</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">基于海量研发文档、产品文档、通用研发知识、阿里云的云服务文档和 SDK/OpenAPI 文档等进行问答训练，为你答疑解惑，助你轻松解决研发问题。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>产品优势</strong></span></h4><ul style="margin-left:0; margin-right:0"><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>跨文件感知让代码生成更贴合业务场景：</strong>客户端和模型层同步优化针对代码跨文件上下文感知能力，生成代码更加贴合当前代码库的业务场景。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>阿里云服务使用场景友好：</strong>专门针对阿里云的云服务使用、SDK/OpenAPI 的使用等场景调优，编码时能够更加便捷地使用阿里云服务；在对阿里云使用有疑问时，智能编码助手的回答也将更加有效。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>适配多 IDE 的原生设计，符合开发者使用习惯：</strong>适配 IDE 原生主题、交互模式，让开发者感受到 IDE 原生的视觉和交互体验，更符合开发者使用习惯。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>研发问答、文档/代码搜索能力，打造沉浸式编码：</strong>无需切换工具，IDE 客户端内即可满足开发者编码场景中的技术资料检索、技术难题解答的诉求，打造开发者沉浸式编码体验。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>双模引擎，自由切换：</strong>支持极速本地模型、云端大模型两种代码补全模型，支持一键切换，满足不同网络环境、不同补全强度的场景诉求。</span></p></li></ul><h2 style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>功能介绍</strong></span></h2><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>行级/函数级实时续写</strong></span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000">根据当前语法和跨文件的代码上下文，实时生成行、函数建议代码。</span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000"><img alt="" height="182" src="https://oscimg.oschina.net/oscnet/up-145ecbcb5413f83c4f6512faeb7572d39ba.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>自然语言生成代码</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">通过自然语言描述你想要的功能，可直接在编辑器区生成代码，编码心流不间断。</span></p><p><span style="color:#000000"><img alt="" height="186" src="https://oscimg.oschina.net/oscnet/up-515b87e9afaf2bfb1f9200538f114663d20.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>单元测试生成</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">支持根据 JUnit、Mockito、Spring Test、unit test、pytest 等框架生成单元测试。</span></p><p><span style="color:#000000"><img alt="" height="198" src="https://oscimg.oschina.net/oscnet/up-6512237992e15393d3abbc2c8e3c77d4063.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代码注释生成</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">一键生成方法注释及行间注释，节省你写代码注释的时间，并能够有效提升代码可读性。</span></p><p><span style="color:#000000"><img alt="" height="192" src="https://oscimg.oschina.net/oscnet/up-bd96048c8e3e6d01aa66c1136d8ca7ff355.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代码解释</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">支持 30 多种语言的识别，选中代码后可自动识别编程语言并生成代码解释。跨越语言的边界，让你阅读代码更高效。</span></p><p><span style="color:#000000"><img alt="" height="154" src="https://oscimg.oschina.net/oscnet/up-615f625c27c7e8afe87ad83e1e7df085c76.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>研发领域自由问答</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">遇到编码疑问、技术难题时，一键唤起通义灵码，无需离开 IDE 客户端，即可快速获得答案和解决思路。聚焦研发领域知识的问答，帮助开发者快速解决问题。</span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><img alt="" height="214" src="https://oscimg.oschina.net/oscnet/up-70413ee56236fdc009f429692be9593d05b.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>异常报错智能排查（Java）</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">当运行出现异常报错时，一键启动报错排查的智能答疑，可结合运行代码、异常堆栈等报错上下文，快速给出排查思路或修复建议代码。</span></p><p><span style="color:#000000"><img alt="" height="309" src="https://oscimg.oschina.net/oscnet/up-87d6c9327ffeb245c28f22c1c979fae8172.png" width="500" referrerpolicy="no-referrer"></span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>支持 IDE 及操作系统</strong></span></h4><ul style="margin-left:0; margin-right:0"><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">Windows 7 及以上、macOS、Linux</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">JetBrains IDEs （IntelliJ IDEA、PyCharm、GoLand、WebStorm 等）2020.3 及以上</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">Visual Studio Code 1.75.1 及以上</span></p></li></ul><p><span style="color:#000000">目前，通义灵码已面向所有开发者开放公测，各大 IDE 插件市场均已上线。</span></p><p><span style="color:#000000">更多详情<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftongyi.aliyun.com%2Flingma%2F" target="_blank">可查看官网</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264459</guid>
            <link>https://www.oschina.net/news/264459</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 开源蓝心大模型-7B：70 亿参数、适合中国开发者]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在 2023 vivo 开发者大会上，vivo 宣布开源 70 亿参数级的蓝心大模型-7B，以及对应的微调框架。据称是行业首家开源大模型的手机厂商。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-27161d355f59c839fc4c9b6bb433e37dff3.png" referrerpolicy="no-referrer"></p><p>vivo 介绍道，他们提供<strong>蓝心大模型开发套件 BlueKit</strong>，让开发者不必考虑使用成本，专注于创新产品体验。此外，vivo 还推出蓝心开发者激励计划，<strong>提供一亿元资源支持，包含技术、运营、品牌三大方面。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-93548b2298b63f816adaa7f7c40b07b00f0.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0c711a4b9bd565a2eb78daee566e4475c80.png" referrerpolicy="no-referrer"></p><hr><p>蓝心大模型-7B 是 vivo 自研通用大模型矩阵中的其中一款。</p><p><img height="646" src="https://static.oschina.net/uploads/space/2023/1101/143959_y0Ws_2720166.png" width="1834" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1101/144435_2CXR_2720166.png" referrerpolicy="no-referrer"></p><p>整体如下：</p><ul><li><p>1B：端侧大模型</p></li><li><p>7B：端云两用模型（开源）</p></li><li><p>70B：云端主力模型</p></li><li><p>130B：云端大模型</p></li><li><p>175B：云端大模型</p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264455</guid>
            <link>https://www.oschina.net/news/264455</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 发布自研操作系统蓝河 (BlueOS)，系统框架采用 Rust 编写]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 vivo 开发者大会今天正式开始。大会上，vivo 发布了自研操作系统<strong>蓝河 (BlueOS)</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-15a70d97c2f8f3654e7d6f94c8c92df5505.png" referrerpolicy="no-referrer"></p><p>vivo 称「蓝河操作系统」是面向通用人工智能时代的自研智慧操作系统 —— 底层接入了 AI 大模型，支持基于自然交互方式的应用开发。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135537_Q43j_2720166.png" referrerpolicy="no-referrer"></p><p>vivo 还表示，蓝河操作系统<strong>采用 Rust 编写「系统框架」</strong>——从源头避免了内存使用不当引起的安全漏洞。据称是行业首家<strong>。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f21c3eb7d2568b66e3cebdf8f628b9bb78b.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135659_sEFQ_2720166.png" referrerpolicy="no-referrer"></p><p>运行要求方面，在低至 200Mhz 主频 32MB 内存，高至 4GHz 主频 24GB 内存的各种设备上，蓝河都能流畅运行。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/142454_nhO4_2720166.png" referrerpolicy="no-referrer"></p><p>据了解，蓝河操作系统目前不会在 vivo 手机上提供，首款搭载蓝河操作系统的 vivo 设备是 vivo Watch3 智能手表。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b5c944705e833222c61dc1c96c7713648ca.png" referrerpolicy="no-referrer"></p><p>此外，<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1668726803%2FNqydVxKTF%3Frefer_flag%3D1001030103_" target="_blank">据称蓝河操作系统是基于 Linux/RTOS 的自研架构</a></u>，因此不兼容 Android 应用。不过它兼容 hapjs，以获得更好的生态支持。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/152743_iniv_2720166.png" referrerpolicy="no-referrer"></p><blockquote><p>hapjs 项目是由开放原子开源基金会孵化及运营的开源项目，<strong>是快应用标准的开源实现</strong>，是基于智能硬件平台的轻型应用形态，由多智能硬件厂商组成的快应用联盟联合制定标准共同驱动。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1ed767bef366be3bde87f6dbd714fdbd581.png" referrerpolicy="no-referrer"></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264444</guid>
            <link>https://www.oschina.net/news/264444</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[macOS Sonoma 黑屏 bug，影响 Asahi Linux]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Asahi Linux 发布了一篇文档，说明了近期 macOS 黑屏情况。</p><blockquote><p><span style="color:#333333">Asahi Linux 项目致力于将 Linux 操作系统移植到苹果的 Apple Silicon Macs 系列电脑设备上。</span></p><ul><li><a href="https://www.oschina.net/news/125751/asahi-linux-set-up" target="_blank">可移植苹果 M1 的 Asahi Linux 项目正式启</a></li></ul></blockquote><p>Asahi 解释，macOS Sonoma 和 macOS Ventura 13.6 在其升级和启动过程中发布了多个严重的错误。这些错误结合在一起，可以创建出一种情况，即无论使用何种电源按钮按压组合，机器总是启动到黑屏。这使用户陷入困境，唯一的解决方案就是使用 DFU 恢复。</p><p>在某些设置和特定型号下，这种情况可能会发生，即多个 macOS 版本并行安装（一个 Sonoma，一个更早的版本）。由于 Asahi Linux 的行为就像是 macOS 12.3/12.4/13.5（取决于型号和安装时间），所以 macOS Sonoma 和 Asahi Linux 的双启动安装会产生相同的问题。对于 macOS 13.6，这种情况甚至不需要双启动系统，只要作为唯一安装的操作系统就可以触发。</p><p>目前 Asahi Linux 安装程序已经更新，现在它可以在启动时自动进行完整性检查并诊断系统。要运行它，请将此命令粘贴到 macOS 的终端中：</p><p style="text-align:start"><code>curl https://alx.sh | sh</code></p><p style="text-align:start">进入主菜单，用户可以退出安装程序，而不对系统做任何更改。</p><p style="text-align:start">Asahi Linux 具体说明了 macOS 启动失败的原因：</p><ul><li><p>macOS Sonoma 的升级使用先前安装的版本作为系统恢复。这在某种程度上是有道理的，但并未考虑到旧版 RecoveryOS 与新固件之间的向后兼容性问题。如果这种不匹配导致 recoveryOS 无法启动，那么系统恢复将无法使用。</p></li><li><p>对于 14 英寸和 16 英寸的型号：一旦系统固件更新到 macOS Sonoma 版本，如果显示器的刷新率设置为非 ProMotion，则该系统将无法正确地启动旧版本的 macOS 安装程序和 Asahi Linux。这包括当这些系统被设置为默认启动操作系统时的恢复模式，以及至少在下一次操作系统升级之前的系统恢复。</p></li></ul><p>影响设备、系统：</p><ul><li><p>配备 ProMotion 显示屏的 MacBook Pro 型号（14 英寸和 16 英寸）受到黑屏启动错误的影响。</p></li><li><p>macOS Sonoma 14.0+（截至 2023 年 10 月 31 日尚未修复）</p></li><li><p>macOS Ventura 13.6+ (使用 14.0 固件)</p></li><li><p>可能受影响：macOS Monterey 12.7（未经确认）</p></li></ul><p><strong>如果还没升级到 Sonoma，Asahi Linux&nbsp;<span style="background-color:#ffffff; color:#1f2328">建议等到苹果解决这些问题后再进行升级。</span></strong></p><p>更多细节查看 Asahi 发布的说明：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAsahiLinux%2Fdocs%2Fwiki%2FmacOS-Sonoma-Boot-Failures" target="_blank">https://github.com/AsahiLinux/docs/wiki/macOS-Sonoma-Boot-Failures</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 04:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264432/macos-sonoma-boot-failures</guid>
            <link>https://www.oschina.net/news/264432/macos-sonoma-boot-failures</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微信 iOS 版「史诗级」更新：「发送」按钮独立]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>微信 iOS 版昨天发布了 8.0.43 更新，更新日志一如既往地是「修复了一些已知问题」。</p><blockquote><p><img height="780" src="https://static.oschina.net/uploads/space/2023/1101/121221_VGwW_2720166.png" width="1810" referrerpolicy="no-referrer"></p></blockquote><p>不过热心网友发现的一项重要变化冲上了微博热搜：<span style="color:#e67e22"><strong>#微信新增独立发送按钮#</strong></span>。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-12f6e066aebe74a1bd7440aa69ef266c4b9.png" referrerpolicy="no-referrer"></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-877e90cea0d617b8694aa9a040acdc2080e.png" referrerpolicy="no-referrer"></p><p>没错，微信 for iOS 8.0.43 新增了「使用独立的发送按钮」开关。开启后，iOS 自带输入法的「发送」按键变成「换行」按键，而输入框右侧增加了独立的「发送」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-410e4a667b0d00dcd7c363e6c756adad620.png" referrerpolicy="no-referrer"></p><p>对使用 iOS 自带输入法用户来说，这属实是「史诗级」更新。</p><p>毕竟此前在输入文字的时候如果想换行，需要在输入框轻点或者长按呼出换行开关。现在「换行」和「发送」终于都有了独立按键，感谢 Allen Zhang : )</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 04:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264431</guid>
            <link>https://www.oschina.net/news/264431</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[运营商在光猫内置反诈插件？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>网友发帖称，自己的同事参加某运营商<strong>加 1 元提速 2000m 送 fttr 1+2 活动</strong>后，由于活动要求 45 天内保持在线并且要使用路由模式，这名同事就按照要求使用路由模式。</p><blockquote><p>FTTR (Fiber to The Remote)，是指光纤敷设到远端节点，为光纤接入的基本技术方式。</p></blockquote><p>然后他发现自建的科学上网功能出现不能连接的情况，并且访问&nbsp; xenyth.net 网站时直接跳转到了反诈页面，几分钟之后接到反诈热线打来的电话，询问他有没有访问一个叫做 xenyth.net 的诈骗网站。工作人员告诉他这是一个网购诈骗网站，付款后不会发货，要求不再访问，如有需要可以安排民警上门。</p><p><span style="background-color:#ffffff; color:#000000">后面这名同事搞到超级密码后进入光猫，发现：</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9b10cd4d0019c4015f48be3f0d542493520.png" referrerpolicy="no-referrer"></p><p>最后附上卸载插件方法：</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/113529_5FaL_2720166.png" referrerpolicy="no-referrer"></p><p><em>via&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.v2ex.com%2Ft%2F986550" target="_blank">https://www.v2ex.com/t/986550</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264421</guid>
            <link>https://www.oschina.net/news/264421</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[四维纵横完成超亿元 B 轮融资]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">新一代超融合数据库厂商四维纵横<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fq_l-0lQ_GJxLTEXTjF30ag" target="_blank">宣布</a>完成了上亿元人民币的 B 轮融资，本轮融资由用友、顺义产业基金领投，广州同创基金跟投。该公司表示，</span><span style="background-color:#ffffff">此次募集资金将会主要用于研发核心技术，建设商业生态链等方面。</span></span></p><p><span style="color:#000000"><img height="251" src="https://oscimg.oschina.net/oscnet/up-ecefb2dbc5ddf668afa56fccacfa3960e27.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">四维纵横是一家成立于 2020 年的数据库公司，以超融合数据库 YMatrix 为企业提供集「分析、事务、时序」为一体的企业级数据库产品服务。目前，四维纵横，以 YMatrix 为核心，自研了全栈向量化执行器、分布式数据库灾备、MARS3 存储引擎、MatrixShift 迁移工具、MatrixGate 高性能写入组件、MatrixUI 图形化界面等一系列商业化套件。</span></p><p><span style="color:#000000"><img height="345" src="https://oscimg.oschina.net/oscnet/up-c609ba963a02c51a5f6c10587fc68105704.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">当前，YMatrix 已经被应用到证券、通信、银行、保险、智能制造、车联网等多个行业领域中，服务的客户包括浪潮、中兴、理想汽车、宁德时代、三一重工等多个头部企业。</span></span></p><p><span style="color:#000000">公告指出，在本轮融资之后，四维纵横将会以目前 YMatrix 产品技术能力为根基，以超融合理念为发展方向，继续拓展新的应用领域，将 YMatrix 超融合数据库产品应用于更多的场景中。另外，四维纵横将进一步加快并夯实技术团队的人员建设和技术基础，为全球用户提供更加全面的超融合解决方案。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264414</guid>
            <link>https://www.oschina.net/news/264414</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度上线「文心一言」会员，开通可解锁文心大模型 4.0]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>百度大模型文心一言现已上线会员模式，开通后可解锁文心大模型 4.0。</p><p><strong>目前文心一言基础版功能依旧免费开放使用</strong>，可以满足用户的日常需求，如交互对话、问答等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-523eef7bc90f0772422e76d8d238e5a06f5.png" referrerpolicy="no-referrer"></p><p>据介绍，文心一言会员单月购买价格为 59.9 元，<strong>连续包月价格为 49.9 元</strong>（次月以 49.9 元 / 月自动续费，可随时取消）。此外，百度还推出了文心一言 + 文心一格（白银）的联合会员，价格为 99 元 / 月。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2e89f249c9e05e483bc3e37a5c145a0001d.png" referrerpolicy="no-referrer"></p><p><strong>文心一言会员权益：</strong></p><ul><li><p>模型能力：文心大模型 4.0</p></li><li><p>图片生成：文生图能力全面升级</p></li><li><p>插件权益 （网页端）：高阶插件</p></li><li><p>灵感值 （App 端）：单月赠送 600 灵感值</p></li></ul><p><strong>文心一格会员权益：</strong></p><ul><li><p>极速生成多尺寸高清图像</p></li><li><p>创作海报和艺术字</p></li><li><p>白银会员权益：AI 编辑改图修图</p></li></ul><hr><p><u><a href="https://www.oschina.net/news/262086">文心大模型 4.0 于上个月正式亮相</a></u>，李彦宏表示，<strong>这是迄今为止最强大的文心大模型</strong>，实现了基础模型的全面升级，在理解、生成、逻辑和记忆能力上都有着明显提升，综合水平「与 GPT-4 相比毫不逊色」。</p><p><img alt="up-cb21975862a8f7b014aeea47cbab52da1df.png" src="https://oscimg.oschina.net/oscnet/up-cb21975862a8f7b014aeea47cbab52da1df.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264412</guid>
            <link>https://www.oschina.net/news/264412</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenSign —— 开源 PDF 电子签名解决方案]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenSign 是一个开源文档电子签名解决方案，旨在为 DocuSign、PandaDoc、SignNow、Adobe Sign、Smartwaiver、SignRequest、HelloSign 和 Zoho Sign 等商业平台提供安全、可靠且免费的替代方案。</p><p>特性：</p><ul><li><strong>安全签名</strong>：利用最先进的加密算法来确保文档的安全性和完整性。</li><li><strong>用户友好的界面</strong>：设计时考虑到可用性，使技术和非技术用户都能轻松使用。</li><li><strong>多平台支持</strong>：兼容各种浏览器和设备。</li><li><strong>邀请和协作用户</strong>：将团队中的多人带入签名流程，所有这些都在你自己的基础设施内进行。</li><li><strong>安全</strong>：允许使用「OpenSigDrive」轻松、安全和无缝地组织文档。</li><li><strong>审计跟踪</strong>：保留与文档签名过程相关的所有活动的详细日志，包括 IP 地址和访问时间。</li><li><strong>完成证书</strong>：所有参与者签署文件后立即生成安全完成证书。</li><li><strong>API 支持</strong>：提供强大的 API，用于集成到其他软件和服务中。</li></ul><p><img alt="" height="293" src="https://static.oschina.net/uploads/space/2023/1031/154224_RLJo_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="298" src="https://static.oschina.net/uploads/space/2023/1031/154242_mhWv_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="307" src="https://static.oschina.net/uploads/space/2023/1031/154356_RuMR_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/opensign</guid>
            <link>https://www.oschina.net/p/opensign</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 一站式分布式任务调度系统 Hodor]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-hodorscheduler" class="anchor" href="https://gitee.com/dromara/hodor#hodorscheduler"></a>HodorScheduler</h1><h2><a id="user-content-介绍" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BB%8B%E7%BB%8D"></a>介绍</h2><p>Hodor 是一个专注于<strong>任务调度</strong>以及<strong>任务编排</strong>的<strong>一站式</strong>分布式任务调度系统。</p><p>通过提供任务编程 API 和接口协议， 方便支持用户使用不同的编程语言实现任务执行以及自定义任务类型的扩展，以满足各种业务场景下的任务执行。</p><p>支持多种接入方式，支持 Java SDK 包方式、Java Agent 独立进程方式接入，以及兼容 XXLJob 框架、Spring Task 框架任务无缝接入。</p><p>多语言执行器实现，计划支持 Go 或者 Rust 语言执行器（正在设计与开发中）的接入，满足在资源有限的执行器节点执行，比如物联网场景下面的定时任务执行。</p><p>支持丰富的任务类型，除了支持普通的 Java、脚本任务的执行，也支持了大数据任务 Hadoop、Spark、Flink、Kettle 等主流任务的执行，满足用户的不同场景。</p><h2><a id="user-content-主要特性" class="anchor" href="https://gitee.com/dromara/hodor#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"></a>主要特性</h2><ol><li>支持 Cron、FixedRate、FixedDelay、OnceTime 方式配置定时任务，可以方便地实现各种定时任务需求。</li><li>支持 DAG 方式进行任务编排，使得任务之间的关系更加清晰，同时提高了系统的可扩展性和灵活性。</li><li>支持 Java 任务和大数据任务调度，兼容 XXLJob、SpringTask 调度任务，满足不同场景下的任务调度需求。</li><li>支持可扩展执行器，用户可以根据自己的需求自定义实现任务类型，从而更好地适应不同的业务场景。</li><li>支持任务静态分片、动态分片、广播、WorkFlow 等多种任务执行模式。</li><li>支持任务自动创建与手动创建以及批量创建等方式，任务的暂停、恢复、Kill 等动作，以及实时日志查看等。</li><li>基于 CopySet 算法实现任务副本分配，提高了任务的可靠性和容错性，从而保障了任务的高可用性。</li></ol><p>详细文档请查阅：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor">https://www.yuque.com/tomgs/hodor</a></p><h2><a id="user-content-架构设计" class="anchor" href="https://gitee.com/dromara/hodor#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"></a>架构设计</h2><p><img src="https://gitee.com/dromara/hodor/raw/master/docs/assets/img/hodor%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="hodor 架构设计图" referrerpolicy="no-referrer"></p><h2><a id="user-content-快速开始" class="anchor" href="https://gitee.com/dromara/hodor#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"></a>快速开始</h2><p>项目结构：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">hodor-scheduler</span><span id="LC2" class="line">├─docs                                          # 文档存放位置</span><span id="LC3" class="line">├─hodor-actuator                                # hodor 任务执行器</span><span id="LC4" class="line">│  ├─hodor-actuator-api                         # 执行器扩展接口</span><span id="LC5" class="line">│  ├─hodor-actuator-java                        # jar 包方式任务执行器</span><span id="LC6" class="line">│  ├─hodor-actuator-agent                       # 独立进程方式任务执行器</span><span id="LC7" class="line">│  ├─hodor-actuator-xxljob                      # 支持 xxl-job 执行器</span><span id="LC8" class="line">│  └─hodor-actuator-springtask                  # 支持 spring task 执行器</span><span id="LC9" class="line">├─hodor-admin                                   # hodor 管理控制枱（TODO）</span><span id="LC10" class="line">├─hodor-client                                  # 提供与 hodor server 的交互 sdk</span><span id="LC11" class="line">├─hodor-common                                  # hodor 公共依赖</span><span id="LC12" class="line">├─hodor-core                                    # hodor 核心业务</span><span id="LC13" class="line">├─hodor-examples                                # hodor 测试用例</span><span id="LC14" class="line">├─hodor-cache                                   # hodor 扩展</span><span id="LC15" class="line">│  ├─hodor-cache-local                          # 基于本地内存的缓存</span><span id="LC16" class="line">│  ├─hodor-cache-embedded                       # 基于 embedded 的分布式缓存</span><span id="LC17" class="line">│  └─hodor-cache-redis                          # 基于 redis 的分布式缓存</span><span id="LC18" class="line">├─hodor-model                                   # hodor 公共数据模型</span><span id="LC19" class="line">├─hodor-storage                                 # hodor storage 模块</span><span id="LC20" class="line">├─hodor-register                                # hodor 注册中心</span><span id="LC21" class="line">│  ├─hodor-register-api</span><span id="LC22" class="line">│  ├─hodor-register-embedded                    # 基于 Raft 实现注册中心</span><span id="LC23" class="line">│  └─hodor-register-zookeeper                   # 基于 zk 实现注册中心</span><span id="LC24" class="line">├─hodor-remoting                                # hodor 通信框架</span><span id="LC25" class="line">│  ├─hodor-remoting-api</span><span id="LC26" class="line">│  └─hodor-remoting-netty</span><span id="LC27" class="line">├─hodor-scheduler                               # hodor 调度核心</span><span id="LC28" class="line">│  ├─hodor-scheduler-api</span><span id="LC29" class="line">│  └─hodor-scheduler-quartz</span><span id="LC30" class="line">└─hodor-server                                  # hodor 入口</span><span id="LC31" class="line"></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-本地源码运行方式" class="anchor" href="https://gitee.com/dromara/hodor#%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"></a>本地源码运行方式</h2><ol><li>在 mysql 下执行 docs 目录下面的 hodor_ddl.sql。</li><li>在项目根目录下通过 mvn package -DskipTests=true 命令编译整个项目，因为涉及到一些代码的自动生成。</li><li>进入到 hodor-server，启动 HodorServer 调度器。</li><li>进入到 examples 下面的 hodor-actuator-java-example，启动 java 任务执行器程序</li><li>java 执行器启动完成后会自动将任务注册到调度器里面来</li></ol><h2><a id="user-content-任务使用说明" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"></a>任务使用说明</h2><p>详细参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fiqrsqxh2i2qt5ixi">执行器操作指南</a></p><h3><a id="user-content-java 任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#java%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>java 任务接入 demo</h3><p>详细 demo 代码参考 <em>hodor-examples/hodor-actuator-java-example</em> 模块</p><blockquote><p>普通 java 任务</p></blockquote><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">group</span><span class="o">=</span><span class="s">"testGroup"</span><span class="o">,</span><span class="n">jobName</span><span class="o">=</span><span class="s">"test1"</span><span class="o">,</span><span class="n">cron</span><span class="o">=</span><span class="s">"0/30 * * * * ?"</span><span class="o">)</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="nc">String</span><span class="nf">test1</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC3" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [testGroup#test1] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC4" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC5" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job test1"</span><span class="o">);</span></span><span id="LC6" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"job argument: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getJobParameter</span><span class="o">());</span></span><span id="LC7" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executing......"</span><span class="o">);</span></span><span id="LC8" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executed"</span><span class="o">);</span></span><span id="LC9" class="line"><span class="k">return</span><span class="s">"a=123"</span><span class="o">;</span></span><span id="LC10" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><blockquote><p>动态分片任务</p></blockquote><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 任务动态切分</span></span><span id="LC2" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"splitStage"</span><span class="o">)</span></span><span id="LC3" class="line"><span class="kd">public</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">ShardData</span><span class="o">&gt;</span><span class="nf">split</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC4" class="line"><span class="nc">ShardData</span><span class="n">shardData</span><span class="o">=</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">id</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">params</span><span class="o">(</span><span class="s">"hello"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span></span><span id="LC5" class="line"><span class="nc">ShardData</span><span class="n">shardData1</span><span class="o">=</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">id</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">params</span><span class="o">(</span><span class="s">"world"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span></span><span id="LC6" class="line"><span class="k">return</span><span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">shardData</span><span class="o">,</span><span class="n">shardData1</span><span class="o">);</span></span><span id="LC7" class="line"><span class="o">}</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">// 任务并行执行</span></span><span id="LC10" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"parallelJob"</span><span class="o">)</span></span><span id="LC11" class="line"><span class="kd">public</span><span class="nc">String</span><span class="nf">parallelJob</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC12" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [parallelJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC13" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC14" class="line"><span class="kd">final</span><span class="nc">ShardData</span><span class="n">parentJobData</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobData</span><span class="o">(</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></span><span id="LC15" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job parallelJob, parentJobData: {}"</span><span class="o">,</span><span class="n">parentJobData</span><span class="o">);</span></span><span id="LC16" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job parallelJob, parentJobData: {}"</span><span class="o">,</span><span class="n">parentJobData</span><span class="o">);</span></span><span id="LC17" class="line"><span class="k">return</span><span class="s">"a=123"</span><span class="o">;</span></span><span id="LC18" class="line"><span class="o">}</span></span><span id="LC19" class="line"></span><span id="LC20" class="line"><span class="c1">// 任务汇总执行</span></span><span id="LC21" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"reduceJob2"</span><span class="o">)</span></span><span id="LC22" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">reduceJob</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC23" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC24" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC25" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"job argument: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getJobParameter</span><span class="o">());</span></span><span id="LC26" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executed"</span><span class="o">);</span></span><span id="LC27" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC28" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, results {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobExecuteResults</span><span class="o">()</span></span><span id="LC29" class="line"><span class="o">);</span></span><span id="LC30" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, statues {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobExecuteStatuses</span><span class="o">());</span></span><span id="LC31" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-xxljob 任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#xxljob%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>xxljob 任务接入 demo</h3><p>详细 demo 代码参考 <em>hodor-examples/hodor-actuator-xxljob-example</em> 模块</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="cm">/**</span></span><span id="LC2" class="line"><span class="cm"> * 1、简单任务示例（Bean 模式）</span></span><span id="LC3" class="line"><span class="cm"> */</span></span><span id="LC4" class="line"><span class="nd">@XxlJob</span><span class="o">(</span><span class="s">"demoJobHandler"</span><span class="o">)</span></span><span id="LC5" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">demoJobHandler</span><span class="o">()</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC6" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"XXL-JOB, Hello World."</span><span class="o">);</span></span><span id="LC7" class="line"></span><span id="LC8" class="line"><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"beat at:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span></span><span id="LC10" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC11" class="line"><span class="o">}</span></span><span id="LC12" class="line"><span class="c1">// default success</span></span><span id="LC13" class="line"><span class="o">}</span></span><span id="LC14" class="line"></span><span id="LC15" class="line"><span class="cm">/**</span></span><span id="LC16" class="line"><span class="cm"> * 2、分片广播任务</span></span><span id="LC17" class="line"><span class="cm"> */</span></span><span id="LC18" class="line"><span class="nd">@XxlJob</span><span class="o">(</span><span class="s">"shardingJobHandler"</span><span class="o">)</span></span><span id="LC19" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">shardingJobHandler</span><span class="o">()</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC20" class="line"><span class="c1">// 分片参数</span></span><span id="LC21" class="line"><span class="kt">int</span><span class="n">shardIndex</span><span class="o">=</span><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">getShardIndex</span><span class="o">();</span></span><span id="LC22" class="line"><span class="kt">int</span><span class="n">shardTotal</span><span class="o">=</span><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">getShardTotal</span><span class="o">();</span></span><span id="LC23" class="line"></span><span id="LC24" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"分片参数：当前分片序号 = {}, 总分片数 = {}"</span><span class="o">,</span><span class="n">shardIndex</span><span class="o">,</span><span class="n">shardTotal</span><span class="o">);</span></span><span id="LC25" class="line"></span><span id="LC26" class="line"><span class="c1">// 业务逻辑</span></span><span id="LC27" class="line"><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">shardTotal</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span><span class="o">{</span></span><span id="LC28" class="line"><span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="n">shardIndex</span><span class="o">)</span><span class="o">{</span></span><span id="LC29" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"第 {} 片, 命中分片开始处理"</span><span class="o">,</span><span class="n">i</span><span class="o">);</span></span><span id="LC30" class="line"><span class="o">}</span><span class="k">else</span><span class="o">{</span></span><span id="LC31" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"第 {} 片, 忽略"</span><span class="o">,</span><span class="n">i</span><span class="o">);</span></span><span id="LC32" class="line"><span class="o">}</span></span><span id="LC33" class="line"><span class="o">}</span></span><span id="LC34" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-spring-task 任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#spring-task%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>spring task 任务接入 demo</h3><p>详细 demo 代码参考 <em>hodor-examples/hodor-actuator-springtask-example</em> 模块</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedRate</span><span class="o">=</span><span class="mi">3000</span><span class="o">)</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task1</span><span class="o">()</span><span class="kd">throws</span><span class="nc">InterruptedException</span><span class="o">{</span></span><span id="LC3" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC4" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行 fixedRate 任务的时间："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC5" class="line"><span class="o">}</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedDelay</span><span class="o">=</span><span class="mi">4000</span><span class="o">)</span></span><span id="LC8" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task2</span><span class="o">()</span><span class="kd">throws</span><span class="nc">InterruptedException</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC10" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行 fixedDelay 任务的时间："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC11" class="line"><span class="o">}</span></span><span id="LC12" class="line"></span><span id="LC13" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">cron</span><span class="o">=</span><span class="s">"0/5 * * * * ?"</span><span class="o">)</span></span><span id="LC14" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task3</span><span class="o">()</span><span class="o">{</span></span><span id="LC15" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行 cron 任务的时间："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC16" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-agent-方式任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#agent-%E6%96%B9%E5%BC%8F%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>agent 方式任务接入 demo</h3><p>详细参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fiqrsqxh2i2qt5ixi">执行器操作指南</a> 中的 agent 方式的使用。</p><h2><a id="user-content-hodor 打包部署说明" class="anchor" href="https://gitee.com/dromara/hodor#hodor%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%AF%B4%E6%98%8E"></a>hodor 打包部署说明</h2><p>详细参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fgiukp9y4plqb55ng">安装部署操作指南</a></p><h2><a id="user-content-交流学习" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BA%A4%E6%B5%81%E5%AD%A6%E4%B9%A0"></a>交流学习</h2><p>目前，Hodor 仍处于建设的过程中，团队成员只能抽出空闲时间投入其中，主要精力还是放在日常工作中。
如果有兴趣的同学想要参与 Hodor 的实现或者一起学习，欢迎通过微信联系我们，我们非常欢迎新的成员加入！</p><p>Hodor 的未来发展方向包括以下几个方面：</p><ol><li>前端界面和控制枱开发，为用户提供更加友好、直观的任务管理界面。</li><li>执行器开发工作，包括执行编程框架和大数据任务执行器的优化，以提高系统的性能和稳定性。</li><li>通信协议改造，计划将目前自定义的协议改造为 grpc 的方式，以提高系统的可扩展性和兼容性。</li><li>优化 CopySet 算法的实现，以支持机架感知，更好地分配任务副本。</li><li>开发多语言执行器，主要放在 go 和 rust 语言，以满足用户不同的需求和偏好。</li></ol><p>Wechat：(备注：Hodor)</p><p><img src="https://gitee.com/dromara/hodor/raw/master/docs/assets/img/wechat.png" alt="image-20220529141555032" referrerpolicy="no-referrer"></p>]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/dromara/hodor</guid>
            <link>https://gitee.com/dromara/hodor</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | Dubbo 路由及负载均衡性能优化]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="font-size: 15px;"><section style="text-align: right;margin-top: 10px;margin-bottom: -25px;" powered-by="xiumi.us"><section style="display: inline-block;width: 35px;height: 35px;vertical-align: top;overflow: hidden;border-width: 1px;border-radius: 100%;border-style: solid;border-color: transparent;background-color: rgb(255, 255, 255);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section><section style="text-align: center;font-size: 14px;" powered-by="xiumi.us"><p><span style="color: rgb(0, 82, 255);"><span style="color: rgb(0, 82, 255);letter-spacing: 0.578px;text-align: center;text-wrap: wrap;font-size: 14px;">揭秘 vivo 互联网海量服务的研发之路&nbsp;</span><span style="color: rgb(0, 82, 255);text-align: center;text-wrap: wrap;font-size: 14px;letter-spacing: 0.034em;">报名中👇</span></span></p></section><section style="text-align: center;margin-top: 0.5em;margin-bottom: 0.5em;padding-left: 0.5em;padding-right: 0.5em;" powered-by="xiumi.us"><section style="border-width: 5px;border-style: solid;border-color: rgb(255, 255, 255);display: inline-block;line-height: 0;box-shadow: rgb(102, 102, 102) 0.2em 0.2em 0.5em;width: 70%;height: auto;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D2%26sn%3D949ce368a94c5950749a74fec56b98fb%26chksm%3Debdb8632dcac0f24fbac44050c9605d521f9728517b311f54639e1ab3bc0422ce95391b09636%26scene%3D21%23wechat_redirect" textvalue="你已选中了添加链接的内容" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="1"><span class="js_jump_icon h5_image_link"><img class="rich_pages wxw-img" data-cropselx1="0" data-cropselx2="384" data-cropsely1="0" data-cropsely2="384" data-ratio="0.21944444444444444" data-s="300,640" src="https://oscimg.oschina.net/oscnet/92614968-2ae5-4624-9416-5e3659137ef6.png" data-type="jpeg" data-w="1080" style="vertical-align: middle;width: 578px;height: 127px;" referrerpolicy="no-referrer"></span></a></section><span style="font-size: 14px;letter-spacing: 0.034em;text-align: justify;"></span></section></section><section style="font-size: 15px;line-height: 1.6;"><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">作者：vivo 互联网中间件团队- Wang Xiaochuang</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: left;" powered-by="xiumi.us"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);"><p style="text-wrap: wrap;">本文主要介绍在 vivo 内部针对 Dubbo 路由模块及负载均衡的一些优化手段，主要是异步化+缓存，可减少在 RPC 调用过程中路由及负载均衡的 CPU 消耗，极大提升调用效率。</p></section></section><section style="margin-right: 0%;margin-bottom: -5px;margin-left: 0%;text-align: right;line-height: 1;font-size: 5px;transform: translate3d(5px, 0px, 0px);" powered-by="xiumi.us"><section style="width: 0px;display: inline-block;vertical-align: top;border-bottom: 0.6em solid rgb(160, 160, 160);border-right: 0.6em solid rgb(160, 160, 160);border-top: 0.6em solid transparent !important;border-left: 0.6em solid transparent !important;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>一、概要</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">vivo 内部 Java 技术栈业务使用的是 Apache Dubbo 框架，基于开源社区 2.7.x 版本定制化开发。在海量微服务集群的业务实践中，我们发现 Dubbo 有一些性能瓶颈的问题会极大影响业务逻辑的执行效率，尤其是在集群规模数量较大时 (提供方数量&gt;100)，路由及负载均衡方面有着较大的 CPU 消耗，从采集的火焰图分析高达 30%。为此我们针对 vivo 内部常用路由策略及负载均衡进行相关优化，并取得了较好的效果。接下来主要跟大家分析一下相关问题产生的根源，以及我们采用怎样的方式来解决这些问题。（当前 vivo 内部使用的 Dubbo 的主流版本是基于 2.7.x 进行相关定制化开发。）</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>二、背景知识</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.1 Dubbo 客户端调用流程</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1.&nbsp;相关术语介绍</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.35069075451647186" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bac7b7d2-f9db-4eb0-9f3d-5900e79ab3fe.png" data-type="png" data-w="941" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;主要流程</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">客户端通过本地代理 Proxy 调用 ClusterInvoker，ClusterInvoker 从服务目录 Directory 获取服务列表后经过路由链获取新的服务列表、负载均衡从路由后的服务列表中根据不同的负载均衡策略选取一个远端 Invoker 后再发起远程 RPC 调用。</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.562962962962963" data-s="300,640" src="https://oscimg.oschina.net/oscnet/c2e7d8db-665a-4a4f-b704-246b9544a375.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.2 Dubbo 路由机制</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Dubbo 的路由机制实际是基于简单的责任链模式实现，同时 Router 继承了 Comparable 接口，自定义的路由可以设置不同的优先级进而定制化责任链上 Router 的顺序。基于责任链模式可以支持多种路由策略串行执行如就近路由+标签路由，或条件路由+就近路由等，且路由的配置支持基于接口级的配置也支持基于应用级的配置。常见的路由方式主要有：就近路由，条件路由，标签路由等。具体的执行过程如下图所示：</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.0143112701252237" data-s="300,640" src="https://oscimg.oschina.net/oscnet/de6310ef-9be0-491d-8451-14b01a37e125.png" data-type="png" data-w="559" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 核心类</strong></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">Dubbo 路由的核心类主要有：<strong>RouterChain、RouterFactory 与 Router 。</strong></p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">（1）RouterChain</p><p style="text-wrap: wrap;">RouterChain 是路由链的入口，其核心字段有<br></p></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><strong>invokers（List&lt;invoker&gt; 类型）</strong></p><p>初始服务列表由服务目录 Directory 设置，当前 RouterChain 要过滤的 Invoker 集合<br></p></li><li><p><strong>builtinRouters（List 类型）</strong></p><p>当前 RouterChain 包含的自动激活的 Router 集合<br></p></li><li><p><strong>routers（List 类型）</strong></p><p>包括所有要使用的路由由 builtinRouters 加上通过 addRouters() 方法添加的 Router 对象</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">RouterChain 核心逻辑</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">class</span><span class="code-snippet__title">RouterChain</span>&lt;<span class="code-snippet__title">T</span>&gt; </span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 注册中心最后一次推送的服务列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers = Collections.emptyList();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 所有路由,包括原生 Dubbo 基于注册中心的路由规则如「route://」 urls .</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> volatile <span class="code-snippet__keyword">List</span>&lt;Router&gt; routers = Collections.emptyList();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 初始化自动激活的路由</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span><span class="code-snippet__keyword">List</span>&lt;Router&gt; builtinRouters = Collections.emptyList();</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> RouterChain(URL url) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//通过 ExtensionLoader 加载可自动激活的 RouterFactory</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;RouterFactory&gt; extensionFactories = ExtensionLoader.getExtensionLoader(RouterFactory.class)</span></code><code><span class="code-snippet_outer">                .getActivateExtension(url, ROUTER_KEY);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 由工厂类生成自动激活的路由策略</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Router&gt; routers = extensionFactories.stream()</span></code><code><span class="code-snippet_outer">                .map(factory -&gt; factory.getRouter(url))</span></code><code><span class="code-snippet_outer">                .collect(Collectors.toList());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        initWithRouters(routers);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 添加额外路由</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> void addRouters(<span class="code-snippet__keyword">List</span>&lt;Router&gt; routers) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Router&gt; newRouters = <span class="code-snippet__keyword">new</span> ArrayList&lt;&gt;();</span></code><code><span class="code-snippet_outer">        newRouters.addAll(builtinRouters);</span></code><code><span class="code-snippet_outer">        newRouters.addAll(routers);</span></code><code><span class="code-snippet_outer">        Collections.sort(newRouters, comparator);</span></code><code><span class="code-snippet_outer">        this.routers = newRouters;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; route(URL url, Invocation invocation) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; finalInvokers = invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 遍历全部的 Router 对象，执行路由规则</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (Router router : routers) {</span></code><code><span class="code-snippet_outer">            finalInvokers = router.route(finalInvokers, url, invocation);</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> finalInvokers;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）RouterFactory 为 Router 的工厂类</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">RouterFactory 接口定义</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@SPI</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">RouterFactory</span></span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Adaptive</span>(<span class="code-snippet__string">"protocol"</span>)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__function">Router <span class="code-snippet__title">getRouter</span><span class="code-snippet__params">(URL url)</span></span>;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（3）Router</p><p style="text-wrap: wrap;" powered-by="xiumi.us">Router 是真正的路由实现策略，由 RouterChain 进行调用，同时 Router 继承了 Compareable 接口，可以根据业务逻辑设置不同的优先级。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">Router 主要接口定义</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">Router</span><span class="code-snippet__keyword">extends</span><span class="code-snippet__title">Comparable</span>&lt;<span class="code-snippet__title">Router</span>&gt; </span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     *</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers   带过滤实例列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> url        消费方 url</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invocation 会话信息</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span> routed invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@throws</span> RpcException</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer">    &lt;T&gt; <span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; route(<span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 当注册中心的服务列表发现变化，或有动态配置变更会触发实例信息的变化</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 当时 2.7.x 的 Dubbo 并没有真正使用这个方法，可基于此方法进行路由缓存</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers invoker list</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;      invoker's type</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">default</span> &lt;T&gt; void notify(<span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;同机房优先路由的实现</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="letter-spacing: 0.034em;">为方便大家了解路由的实现，给大家展示一下就近路由的核心代码逻辑</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL consumerUrl, Invocation invocation) throws RpcException {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (!<span class="code-snippet__keyword">this</span>.enabled) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取本地机房信息</span></span></code><code><span class="code-snippet_outer">        String local = getSystemProperty(LOC);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers == <span class="code-snippet__literal">null</span> || invokers.size() == <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">        List&lt;Invoker&lt;T&gt;&gt; result = new ArrayList&lt;Invoker&lt;T&gt;&gt;();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (Invoker invoker: invokers) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取与本地机房一致的 invoker 并加入列表中</span></span></code><code><span class="code-snippet_outer">            String invokerLoc = getProperty(invoker, invocation, LOC);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (local.equals(invokerLoc)) {</span></code><code><span class="code-snippet_outer">                result.add(invoker);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (result.size() &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (fallback){</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 开启服务降级，available.ratio = 当前机房可用服务节点数量 ／ 集群可用服务节点数量</span></span></code><code><span class="code-snippet_outer">                int curAvailableRatio = (int) Math.floor(result.size() * <span class="code-snippet__number">100.0</span>d / invokers.size());</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (curAvailableRatio &lt;= availableRatio) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (force) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.3 Dubbo 负载均衡</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Dubbo 的负载均衡实现比较简单基本都是继承抽象类进行实现，主要作用就是根据具体的策略在路由之后的服务列表中筛选一个实例进行远程 RPC 调用，默认的负载均衡策略是随机。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">整体类图如下所示：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.2824074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/22c30ee5-d60d-45b1-a737-bbf064f7c1cc.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">LoadBalance 接口定义</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@SPI</span>(RandomLoadBalance.NAME)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">LoadBalance</span></span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 从服务列表中筛选一个.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     *</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers   invokers.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> url        refer url</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invocation invocation.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span> selected invoker.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Adaptive</span>(<span class="code-snippet__string">"loadbalance"</span>)</span></code><code><span class="code-snippet_outer">    &lt;T&gt; <span class="code-snippet__function">Invoker&lt;T&gt; <span class="code-snippet__title">select</span><span class="code-snippet__params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span><span class="code-snippet__keyword">throws</span> RpcException</span>;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">随机负载均衡核心代码解析</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 预热过程权重计算</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">static</span><span class="code-snippet__keyword">int</span><span class="code-snippet__title">calculateWarmupWeight</span>(<span class="code-snippet__params"><span class="code-snippet__keyword">int</span> uptime, <span class="code-snippet__keyword">int</span> warmup, <span class="code-snippet__keyword">int</span> weight</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> ww = (<span class="code-snippet__keyword">int</span>) (uptime / ((<span class="code-snippet__keyword">float</span>) warmup / weight));</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> ww &lt; <span class="code-snippet__number">1</span> ? <span class="code-snippet__number">1</span> : (Math.min(ww, weight));</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">int</span><span class="code-snippet__title">getWeight</span>(<span class="code-snippet__params">Invoker&lt;?&gt; invoker, Invocation invocation</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> weight;</span></code><code><span class="code-snippet_outer">       URL url = invoker.getUrl();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 多注册中心场景下的，注册中心权重获取</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">           weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">       } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer">           weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (weight &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取实例启动时间</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">long</span> timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, <span class="code-snippet__number">0L</span>);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (timestamp &gt; <span class="code-snippet__number">0L</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">long</span> uptime = System.currentTimeMillis() - timestamp;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (uptime &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span><span class="code-snippet__number">1</span>;</span></code><code><span class="code-snippet_outer">                   }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取预热时间</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (uptime &gt; <span class="code-snippet__number">0</span> &amp;&amp; uptime &lt; warmup) {</span></code><code><span class="code-snippet_outer">                       weight = calculateWarmupWeight((<span class="code-snippet__keyword">int</span>)uptime, warmup, weight);</span></code><code><span class="code-snippet_outer">                   }</span></code><code><span class="code-snippet_outer">               }</span></code><code><span class="code-snippet_outer">           }</span></code><code><span class="code-snippet_outer">       }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> Math.max(weight, <span class="code-snippet__number">0</span>);</span></code><code><span class="code-snippet_outer">   }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">@Override</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">protected</span> &lt;T&gt; <span class="code-snippet__function">Invoker&lt;T&gt; <span class="code-snippet__title">doSelect</span>(<span class="code-snippet__params">List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Number of invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> length = invokers.size();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Every invoker has the same weight?</span></span></code><code><span class="code-snippet_outer">        boolean sameWeight = <span class="code-snippet__literal">true</span>;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// the weight of every invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span>[] weights = <span class="code-snippet__keyword">new</span><span class="code-snippet__keyword">int</span>[length];</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// the first invoker's weight</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> firstWeight = getWeight(invokers.<span class="code-snippet__keyword">get</span>(<span class="code-snippet__number">0</span>), invocation);</span></code><code><span class="code-snippet_outer">        weights[<span class="code-snippet__number">0</span>] = firstWeight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// The sum of weights</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> totalWeight = firstWeight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = <span class="code-snippet__number">1</span>; i &lt; length; i++) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> weight = getWeight(invokers.<span class="code-snippet__keyword">get</span>(i), invocation);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// save for later use</span></span></code><code><span class="code-snippet_outer">            weights[i] = weight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Sum</span></span></code><code><span class="code-snippet_outer">            totalWeight += weight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) {</span></code><code><span class="code-snippet_outer">                sameWeight = <span class="code-snippet__literal">false</span>;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (totalWeight &gt; <span class="code-snippet__number">0</span> &amp;&amp; !sameWeight) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on totalWeight.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Return a invoker based on the random value.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = <span class="code-snippet__number">0</span>; i &lt; length; i++) {</span></code><code><span class="code-snippet_outer">                offset -= weights[i];</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (offset &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers.<span class="code-snippet__keyword">get</span>(i);</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers.<span class="code-snippet__keyword">get</span>(ThreadLocalRandom.current().nextInt(length));</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>预热解释</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">预热是为了让刚启动的实例流量缓慢增加,因为实例刚启动时各种资源可能还没建立连接，相关代码可能还是处于解释执行，仍未变为 JIT 执行，此时业务逻辑较慢，不应该加载过大的流量，否则有可能造成较多的超时。Dubbo 默认预热时间为 10 分钟，新部署的实例的流量会在预热时间段内层线性增长，最终与其他实例保持一致。Dubbo 预热机制的实现就是通过控制权重来实现。如默认权重 100，预热时间 10 分钟，则第一分钟权重为 10，第二分钟为 20，以此类推。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体预热效果图如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.45765765765765765" data-s="300,640" src="https://oscimg.oschina.net/oscnet/752bc3b5-e121-4de3-b41b-022860b2700e.png" data-type="png" data-w="555" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>三、问题分析</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">使用 Dubbo 的业务方反馈，他们通过火焰图分析发现 Dubbo 的负载均衡模块+路由模块占用 CPU 超过了 30%，框架层面的使用率严重影响了业务逻辑的执行效率急需进行优化。通过火焰图分析，具体占比如下图，其中该机器在业务忙时的 CPU 使用率在 60% 左右，闲时在 30% 左右。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.30970873786407765" data-s="300,640" src="https://oscimg.oschina.net/oscnet/81ae8f99-a18c-4416-8f9a-b6c012a14476.png" data-type="png" data-w="1030" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通过火焰图分析，负载均衡主要的消耗是在 getWeight 方法。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.1388888888888889" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b1d57058-f760-43c5-83bc-166c07ca9d81.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">路由的主要消耗是在 route 方法：</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">同机房优先路由</p><p style="text-wrap: wrap;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.11296296296296296" data-s="300,640" src="https://oscimg.oschina.net/oscnet/fee26d17-6eb3-4103-b12d-cc8975696932.png" data-type="png" data-w="1080" style="font-size: 15px;letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" referrerpolicy="no-referrer"></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">接口级标签路由+应用级标签路由</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.14907407407407408" data-s="300,640" src="https://oscimg.oschina.net/oscnet/11c33b76-0ae1-45fe-aeef-a05793340801.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">这些方法都有一个特点，那就是遍历执行。如负载均衡，针对每一个 invoker 都需要通过 getWeight 方法进行权重的计算；就近路由的 router 方法对于每一个 invoker 都需要通过 url 获取及机房信息进行匹配计算。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">我们分析一下 getWeight 及 router 时间复杂度，发现是 O(n) 的时间复杂度，而且路由是由路由链组成的，每次每个 Router 的 route 方法调用逻辑都会遍历实例列表，那么当实例列表数量过大时，每次匹配的计算的逻辑过大，那么就会造成大量的计算成本，导致占用大量 cpu，同时也导致路由负载均衡效率低下。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">综上所述，罪恶的的根源就是遍历导致的，当服务提供方数量越多，影响越大。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>四、优化方案</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">知道了问题所在，我们来分析一下是否有优化空间。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.1 路由优化</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 优化一：关闭无效路由</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通过火焰图分析，我们发现有部分业务即使完全不使用应用级的标签路由，原生的 TagRouter 也存在遍历逻辑，原因是为了支持静态的标签路由，其实这部分的开销也不少，那对于根本不会使用应用级标签路由的可以手动进行关闭。关闭方式如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">客户端统一关闭<br></p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js"><code><span class="code-snippet_outer">dubbo.consumer.router=-tag</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">服务级别关闭</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">注解方式：</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@DubboReference(parameters = {<span class="code-snippet__meta-string">"router"</span>,<span class="code-snippet__meta-string">"-tag"</span>})</span></span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">xml 方式：</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer">&lt;dubbo:reference id=<span class="code-snippet__string">"demoService"</span> check=<span class="code-snippet__string">"false"</span><span class="code-snippet__keyword">interface</span>=<span class="code-snippet__string">"com.dubbo.study.n.api.DemoService"</span> router=<span class="code-snippet__string">"-tag"</span> /&gt;</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2. 优化二：提前计算路由结果并进行缓存</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">每次路由目前都是进行实时计算，但是在大多数情况下，我们的实例列表是稳定不变的，只有在发布窗口或配置变更窗口内实例列表才会发生变更，那我们是否可以考虑缓存呢。如就近路由，可以以机房为 key 进行机房实例的全量缓存。针对接口级标签路由可以缓存不同标签值指定的实例信息。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">我们知道路由的执行过程是责任链模式，每一个 Router 的实例列表入参实际上是一个 Router 的结果，可参考公式：target = rn(…r3(r2(r1(src))))。那么所有的路由可以基于注册中心推送的原始服务列表进行路由计算并缓存，然后不同的路由结果相互取交集就能得到最终的结果，当实例信息发生变更时，缓存失效并重新计算。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>3. 缓存更新时机</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">当注册中心或者动态配置有变更时，相关通知会给到服务目录 Directory,Directory 收到通知后会重新创建服务列表，并把服务列表同步到路由链 RouterChain，RouterChain 再按顺序通知其链上的 Router,各个 Router 再进行缓存清除并重新进行路由结果的计算及进行缓存。相关时序图如下所示：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.42962962962962964" data-s="300,640" src="https://oscimg.oschina.net/oscnet/e8b71fb8-8926-40de-abe8-147ba10fa2ea.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>4. 具体路由流程</strong></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">进入具体路由方法时，先判断是否存在缓存的路由值，且缓存值的 epoch 必须与上一个路由的 epoch 需一致，此时缓存才生效，然后缓存值与上个 Router 的结果取交集。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">如果不存在缓存或 epoch 不一致则重新进行实时的路由计算。</p><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.7803921568627451" data-s="300,640" src="https://oscimg.oschina.net/oscnet/024bfb79-3f68-4ca5-bf7f-bfd337d6c3d0.jpg" data-type="jpeg" data-w="1020" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us">引入 epoch 的原因主要是保证各个路由策略缓存信息的一致性，保证所有的缓存计算都是基于同一份原始数据。当实例信息发生变更时，epoch 会自动进行更新。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>5. BitMap 引入</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">上文我们说到，不同的路由策略之间的结果是取交集的，然后最终的结果才送入负载均衡流程。那如何在缓存的同时，加快交集的计算呢。答案就是基于位图：BitMap。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">BitMap 的基本原理就是用一个 bit 位来存放某种状态，适用于大规模数据的查找及位运算操作。如在路由场景，先基于全量的推送数据进行计算缓存。如果某个实例被路由选中，则其值为 1，若两个路由的结果要取交集，那直接对 BitMap 进行"&amp;"运行即可。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">全量缓存示意图：</p><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.4935185185185185" data-s="300,640" src="https://oscimg.oschina.net/oscnet/5fc6e016-b880-40ce-9d59-390fe111bfa8.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us">路由交集计算示步骤：</p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">按照路由链依次计算，</p><p style="text-wrap: wrap;">tagRouter-&gt;vivoTag-&gt;vivoNearestRouter</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（1）tagRouter 计算逻辑：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>按照 Invocation 计算出目标的 Tag,假设是 tag1</p></li><li><p>然后从缓存 Cache 根据 key:tag1,取出对应的 targetAddrPool</p></li><li><p>将原始传入的 addrPool</p><p>与 targetAddrPool</p><p>得到结果 resultAddrPool</p></li><li><p>将 resultAddrPool 传入 vivoTagRouter</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）vivoTag 计算逻辑：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>按照 Invocation 计算出目标的 Tag,假设是 tabB</p></li><li><p>然后从缓存 Cache 根据 key:tag1，取出对应的 targetAddrPool</p></li><li><p>将上一次传入的 addrPool</p><p>与 targetAddrPool</p><p>得到结果 resultAddrPooll</p></li><li><p>将 resultAddrPool 传入</p><p>vivoNearestRouter</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">（3）vivoNearestRouter 计算逻辑</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>从环境变量取出当前机房，假设是 bj01</p></li><li><p>然后从缓存 Cache 根据 key:bj01，取出对应的 targetAddrPool</p></li><li><p>将上一次传入的 addrPool</p><p>与 targetAddrPool</p><p>取出 resultAddrPool</p></li><li><p>将上一次传入的 addrPool</p><p>与 targetAddrPool</p><p>得到结果 resultAddrPool</p></li><li><p>将 resultAddrPool 为最终路由结果，传递给 LoadBalance</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6907407407407408" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bfad5e5c-e485-4ab8-8b25-208b5ca92c3d.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>6. 基于缓存的同机房优先路由源码解析</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">缓存刷新</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * Notify router chain of the initial addresses from registry at the first time.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * Notify whenever addresses in registry change.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">public</span><span class="code-snippet__keyword">void</span><span class="code-snippet__title">setInvokers</span>(<span class="code-snippet__params">List&lt;Invoker&lt;T&gt;&gt; invokers</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 创建带 epoch 的 BitList</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">this</span>.invokers = <span class="code-snippet__keyword">new</span> BitList&lt;Invoker&lt;T&gt;&gt;(invokers == <span class="code-snippet__literal">null</span> ? Collections.emptyList() : invokers,createBitListEpoch());</span></code><code><span class="code-snippet_outer">        routers.forEach(router -&gt; router.notify(<span class="code-snippet__keyword">this</span>.invokers));</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">同机房优先路由源码解读</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL consumerUrl, Invocation invocation) throws RpcException {</span></code><code><span class="code-snippet_outer">        …………<span class="code-snippet__comment">//省略非核心代码</span></span></code><code><span class="code-snippet_outer">        BitList&lt;Invoker&lt;T&gt;&gt; bitList = (BitList&lt;Invoker&lt;T&gt;&gt;) invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//获取路由结果</span></span></code><code><span class="code-snippet_outer">        BitList&lt;Invoker&lt;T&gt;&gt; result = getNearestInvokersWithCache(bitList);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (result.size() &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (fallback) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 开启服务降级，available.ratio = 当前机房可用服务节点数量 ／ 集群可用服务节点数量</span></span></code><code><span class="code-snippet_outer">                int curAvailableRatio = (int) Math.floor(result.size() * <span class="code-snippet__number">100.0</span>d / invokers.size());</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (curAvailableRatio &lt;= availableRatio) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (force) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }   </span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 获取缓存列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span></span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> &lt;T&gt; BitList&lt;Invoker&lt;T&gt;&gt; getNearestInvokersWithCache(BitList&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer">        ValueWrapper valueWrapper = getCache(getSystemProperty(LOC));</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 是否存在缓存</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (valueWrapper != <span class="code-snippet__literal">null</span>) {</span></code><code><span class="code-snippet_outer">            BitList&lt;Invoker&lt;T&gt;&gt; invokerBitList = (BitList&lt;Invoker&lt;T&gt;&gt;) valueWrapper.<span class="code-snippet__keyword">get</span>();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 缓存的 epoch 与源列表是否一致</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers.isSameEpoch(invokerBitList)) {</span></code><code><span class="code-snippet_outer">                BitList&lt;Invoker&lt;T&gt;&gt; tmp = invokers.clone();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 结果取交集</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> tmp.and(invokerBitList);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 缓存不存在，实时计算放回</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> getNearestInvokers(invokers);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 新服务列表通知</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Override</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; void notify(List&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer">        clear();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers != <span class="code-snippet__literal">null</span> &amp;&amp; invokers instanceof BitList) {</span></code><code><span class="code-snippet_outer">            BitList&lt;Invoker&lt;T&gt;&gt; bitList = (BitList&lt;Invoker&lt;T&gt;&gt;) invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 设置最后一次更新的服务列表</span></span></code><code><span class="code-snippet_outer">            lastNotify = bitList.clone();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (!CollectionUtils.isEmpty(invokers) &amp;&amp; <span class="code-snippet__keyword">this</span>.enabled) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取机房相同的服务列表并进行缓存</span></span></code><code><span class="code-snippet_outer">                setCache(getSystemProperty(LOC), getNearestInvokers(lastNotify));</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.2 负载均衡优化</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1.&nbsp;优化一</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">针对 getWeight 方法，我们发现有部分业务逻辑较为消耗 cpu,但是在大多数场景下业务方并不会使用到，于是进行优化。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">getWeight 方法优化</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="javascript"><code><span class="code-snippet_outer">优化前：</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//这里主要要用多注册中心场景下，注册中心权重的获取，绝大多数情况下并不会有这个逻辑</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">           weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">       }  </span></code><code><span class="code-snippet_outer">优化后：</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invoker <span class="code-snippet__keyword">instanceof</span> ClusterInvoker &amp;&amp; UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">            weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">   }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;优化二</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">遍历是罪恶的源泉，而实例的数量决定这罪恶的深浅，我们有什么办法减少负载均衡过程中的遍历呢。一是根据 group 及 version 划分不同的集群，但是这需要涉及到业务方代码或配置层面的改动，会带来额外的成本。所以我们放弃了。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">二是没有什么是加一层解决不了的问题，为了尽量减少进入负载均衡的节点数量，考虑新增一个垫底的路由策略，在走完所有的路由策略后，若节点数量&gt;自定义数量后，进行虚拟分组，虚拟分组的策略也可进行自定义，然后随机筛选一组进入负载均衡。此时进入负载均衡的实例数量就会有倍数的下降。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">需要注意的是分组路由必须保证是在路由链的最后一环，否则会导致其他路由计算错误。</p></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.37984496124031" data-s="300,640" src="https://oscimg.oschina.net/oscnet/9ad0f113-9f91-4397-9e60-71b4b03e349f.png" data-type="png" data-w="645" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">分组路由示意</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * </span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers 待分组实例列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> groupNum 分组数量</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span></span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; doGroup(List&lt;Invoker&lt;T&gt;&gt; invokers, <span class="code-snippet__keyword">int</span> groupNum) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> listLength = invokers.size() / groupNum;</span></code><code><span class="code-snippet_outer">        List&lt;Invoker&lt;T&gt;&gt; result = <span class="code-snippet__keyword">new</span> ArrayList&lt;&gt;(listLength);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> random = ThreadLocalRandom.current().nextInt(groupNum);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = random; i &lt; invokers.size(); i = i + groupNum) {</span></code><code><span class="code-snippet_outer">            result.add(invokers.get(i));</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>五、优化效果</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">针对优化前和优化后，我们编写 Demo 工程分别压测了不配置路由/配置就近+标签路由场景。Provider 节点梯度设置 100/500/1000/2000/5000，TPS 在 1000 左右，记录了主机的 cpu 等性能指标，并打印火焰图。发现，配置路由后，采用相同并发，优化后的版本 tps 明显高于优化前版本，且新版本相较于没有配置路由时 tps 显著提高，下游节点数大于 2000 时，tps 提升达到 100% 以上，下游节点数越多，AvgCpu 优化效果越明显，并且路由及负载均衡 CPU 占比明显更低，详细数据可见下表：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.5994694960212201" data-s="300,640" src="https://oscimg.oschina.net/oscnet/1321713f-e488-4248-8ead-3e1db6f52543.png" data-type="png" data-w="754" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.7027777777777777" data-s="300,640" src="https://oscimg.oschina.net/oscnet/be116887-8e9c-4e6f-ba48-b83efffe2464.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">备注：-tag，表示显式禁用原生 Dubbo 应用级标签路由。该路由默认开启。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>六、总结</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">经过我们关闭不必要的路由逻辑、对路由缓存+异步化计算、新增分组路由等优化后，Dubbo 在负载均衡及路由模块整体的性能有了显著的提升，为业务方节省了不少 CPU 资源。在正常业务场景下当提供方数量达到 2000 及以上时，tps 提升可达 100% 以上，消费方平均 CPU 使用率下降约 27%，且提供方数量越多优化效果越明显。但是我们也发现当前的随机负载均衡依然还是会消耗一定的 CPU 资源，且只能保证流量是均衡的。当前我们的应用基本部署在虚拟机及容器上。这两者均存在超卖的状况，且同等配置的宿主机性能存在较大差异等问题。最终会导致部分请求超时、无法最大化利用提供方的资源。我们下一步将会引入 Dubbo 3.2 的自适应负载均衡并进行调优减少其 CPU 使用率波动较大的问题，其次我们自身也扩展了基于 CPU 负载均衡的单一因子算法，最终实现不同性能的机器 CPU 负载趋于均衡，最大程度发挥集群整体的性能。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="color: rgb(65, 95, 255);" powered-by="xiumi.us"><p style="text-wrap: wrap;">参考资料：</p></section><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;" powered-by="xiumi.us"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Fload-balance%2F" textvalue="Dubbo 负载均衡" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 负载均衡</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Ftraffic%2F" textvalue="Dubbo 流量管控" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 流量管控</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU4NzU0MDIzOQ%3D%3D%26mid%3D2247511003%26idx%3D3%26sn%3Defdf3f42790b74226b2ed45b701a6749%26scene%3D21%23wechat_redirect" textvalue="Dubbo 3 StateRouter：下一代微服务高效流量路由" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 3 StateRouter：下一代微服务高效流量路由</span></a></p></li></ol><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;"><section style="text-align: center;color: rgb(45, 66, 87);font-size: 11px;" powered-by="xiumi.us"><p>END</p></section></section><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: left;" powered-by="xiumi.us"><section style="padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;"><span style="display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);" title="" opera-tn-ra-cell="_$.pages:0.layers:0.comps:159.title1"><p>猜你喜欢</p></span></section><section style="border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;"><section style="font-size: 14px;text-align: left;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497343%26idx%3D1%26sn%3D959b66ceb9a8c2fe060b6981b41a807e%26chksm%3Debdb86eddcac0ffb229636ec51ec94433af75c7bc58aaa5ae52b4a2bf6a2d6d2ab11583b3174%26scene%3D21%23wechat_redirect" textvalue="记一次 Redis Cluster Pipeline 导致的死锁问题" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">记一次 Redis Cluster Pipeline 导致的死锁问题</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D1%26sn%3D5795a683e52f70384a13b34aa3daf731%26chksm%3Debdb8632dcac0f2468a461db09d8de6219af346e51436b91e6c946ee8b37e6ae8175b2f5d55e%26scene%3D21%23wechat_redirect" textvalue="深入理解 Netty FastThreadLocal" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">深入理解 Netty FastThreadLocal</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497336%26idx%3D1%26sn%3D777059b19e224f1a4fbb1550ad1de7e8%26chksm%3Debdb86eadcac0ffc78dc019c5685ad137fdddd6572238525d707152c102790f82917a473d52a%26scene%3D21%23wechat_redirect" textvalue="MySQL 到 TiDB：Hive Metastore 横向扩展之路" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">MySQL 到 TiDB：Hive Metastore 横向扩展之路</a></p></li></ul></section></section></section></section><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互联网技术" data-alias="vivoVMIC" data-signature="分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10136865</guid>
            <link>https://my.oschina.net/vivotech/blog/10136865</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌开放 .ing 顶级域名注册]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Google <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.google%2Fproducts%2Fregistry%2Fintroducing-the-ing-top-level-domain%2F" target="_blank">宣布开放 .ing 顶级域名注册</a></u>，即日起用户可通过<strong>支付额外费用（费率随时间推移降低）的方式抢先注册</strong>，抢先体验期 (EAP) 截至 12 月 5 日。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1101/104932_JmaT_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>Google 表示借助该域名企业可以注册一些非常有趣的域名，比如在线设计和绘图平台 Canva 注册的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdesign.ing%2F" target="_blank">design.ing</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdraw.ing%2F" target="_blank">draw.ing</a>、Adobe Acrobat 注册的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fedit.ing%2F" target="_blank">edit.ing</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsign.ing%2F" target="_blank">signing</a>&nbsp;等。</p><p>.ing 域名注册地址：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fget.ing%2F" target="_blank">https://get.ing/</a></u></p><p><img height="1676" src="https://static.oschina.net/uploads/space/2023/1101/105256_D6p3_2720166.png" width="3310" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264406/the-ing-top-level-domain</guid>
            <link>https://www.oschina.net/news/264406/the-ing-top-level-domain</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
