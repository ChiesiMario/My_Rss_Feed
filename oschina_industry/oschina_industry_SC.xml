<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 02 Feb 2024 07:30:54 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[基于 Netty 开发轻量级 RPC 框架]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>笔者在开发基于客户端/服务端模式通信的插件的时候，需要用到轻量级最小包依赖的 RPC 框架，而市面上的 RPC 框架份量过于庞大，最终打包下来都是几十兆甚至上百兆，而这里面大多数功能我都用不上，于是思来想去我决定写一款属于自己的轻量级 RPC 框架，简单易用快速接入。</p></blockquote><span id="OSC_h2_1"></span><h2>关于技术选型</h2><span id="OSC_h3_2"></span><h3>协议序列化/反序列化</h3><p>网络通信基于 TCP/IP 为基础自定义应用层协议，常见的序列化/反序列化工具有 java 原生序列化，json,kryo,protobuf,fst,hessian 等。</p><p>在不考虑跨语言的情况下，从序列化时长/序列化大小/易用性/扩展性这几方面考虑，综合性比较强的是 kryo，但是 kryo 只支持 java 版本不能跨语言 (据说能跨语言但是非常复杂，相当于不能跨语言了)，protobuf 是性能最强的且支持跨语言，但是需要事先基于 proto 生成一个类，这会导致所有序列化和反序列化的时候只能用 proto 定义的类型。</p><p>最终选择 kryo 和 protobuf 两种序列化工具，使用的时候可选序列化类型，前者序列化几乎不受限制，后者支持跨语言，但是必须事先生成 proto 类型的类并使用其作为序列化工具。</p><span id="OSC_h3_3"></span><h3>通信框架使用</h3><p>高性能异步非阻塞框架非 Netty 不可了，客户端和服务端基于 Netty 开发可事半功倍。</p><p>但是基于 Netty 再加上 zk 连接和各种工具打包完都需要 20M 左右，所以除了 client 和 server 端外，再开发一个 client-mini 模块，这个模块是 client 端基于 nio 开发的，性能虽然不如 netty 但是没有任何依赖，打包下来仅 20kb。</p><span id="OSC_h3_4"></span><h3>服务注册和发现</h3><p>注册中心选择 zookeeper 作为服务注册和服务发现，当然如果只用单点模式的话其实是不需要注册中心的，所以 zookeeper 是可选组件。</p><span id="OSC_h2_5"></span><h2>开发 RPC 框架</h2><p>好了，有了上述这些技术就可以步入 RPC 框架的开发了，我这里分为了以下模块：</p><ul><li>base : 基础公共模块</li><li>protocol : 协议层，包含应用层通信协议，以及序列化/反序列化，支持 kryo 和 protobuf</li><li>registry : 注册模块，基于 zookeeper 作为注册中心，包含注册服务和服务发现</li><li>server : 服务端</li><li>client : 客户端</li><li>client-mini : 不依赖任何包的客户端，基于 NIO</li></ul><span id="OSC_h3_6"></span><h3>应用层协议</h3><p>首先设计通信协议层，一个 rpc 框架通信的每一次请求主要包含服务名 (serviceName)，函数名 (methodName)，参数类型 (paramTypes) 和参数 (params) 等字段，当然再加上请求唯一 id: traceId</p><pre><code class="language-java">@ShadowEntity  
public class ShadowRPCRequest {  

    @ShadowField(1)  
    private String traceId;  

    @ShadowField(2)  
    private String serviceName;  

    @ShadowField(3)  
    private String methodName;  

    @ShadowField(4)  
    private Class&lt;?&gt;[] paramTypes;  

    @ShadowField(5)  
    private Object[] params;
}

</code></pre><p>上述 ShadowRPCRequest 是基于 kryo 序列化方式进行的一个定义，适合于客户端和服务端都是 java，如果要跨语言，则需要使用 protobuf，protobuf 首先定义一个 request.proto</p><pre><code class="language-proto">syntax = "proto3";  
  
  
package com.liubs.shadowrpc.protocol.entity;  
option java_outer_classname="ShadowRPCRequestProto";  
  
message ShadowRPCRequest {  
    string traceId = 1;  
    string serviceName = 2;  
    string methodName = 3;  
    repeated string paramTypes = 4; //参数类名  
    repeated bytes params = 5; //bytes 类型充当参数  
}

</code></pre><p>由于要跨语言，所以参数用 bytes 的集合类型，反序列化时需要二次解压缩成具体的类型，但是即便是这样仍然比 kryo 要快。</p><p>同理，与 ShadowRPCRequest 对应的消息体是响应 ShadowRPCResponse</p><pre><code class="language-java">@ShadowEntity  
public class ShadowRPCResponse {  
 
    @ShadowField(1)  
    private String traceId;  

    @ShadowField(2)  
    private int code;  

    @ShadowField(3)  
    private String errorMsg;  

    @ShadowField(4)  
    private Object result;
}

</code></pre><p>然后就是基于 kryo 和 protobuf 的序列化和反序列化了，kryo 有很多种序列化策略，考虑到函数参数需要支持增减字段，所以 kryo 使用 TaggedField 策略，上面的@ShadowField 注解是我进行的一些简单的封装，每次新增字段的时候需要加上注解即可，而 protobuf 天生就支持参数增减字段。</p><p>kryo 的序列化和反序列化如下：</p><pre><code class="language-java">public class KryoSerializer implements ISerializer {  
  
    private static ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; {  
        Kryo kryo = new Kryo();  

        kryo.setDefaultSerializer(new KryoFieldSerializerFactory());  

        kryo.setReferences(false);  
        kryo.setRegistrationRequired(false); //不需要提前注册  

        //注册一定会用到的，序列化可以省点空间  
        kryo.register(Class.class);  
        kryo.register(Class[].class);  
        kryo.register(Object[].class);  
        kryo.register(ShadowRPCRequest.class);  
        kryo.register(ShadowRPCResponse.class);  

        return kryo;  
    });  
  
  
  
    @Override  
    public byte[] serialize(Object object) {  

        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();  
        Output output = new Output(byteArrayOutputStream);  
        kryoThreadLocal.get().writeObject(output, object);  
        output.close();  
        return byteArrayOutputStream.toByteArray();  
    }  
  
    @Override  
    public &lt;T&gt; T deserialize(byte[] array, Class&lt;T&gt; clazz) {  

        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(array);  
        Input input = new Input(byteArrayInputStream);  
        T object = kryoThreadLocal.get().readObject(input, clazz);  
        input.close();  
        return object;  
    }  
}

</code></pre><p>protobuf 的序列化和反序列化则是通过调用生成的 proto 类来实现序列化和反序列化的，</p><p>序列化：</p><pre><code class="language-java">@Override  
public byte[] serialize(Object object) {  
    if (object instanceof MessageLite) {  
    return ((MessageLite) object).toByteArray();  
    }  
    if (object instanceof MessageLite.Builder) {  
    return (((MessageLite.Builder) object).build().toByteArray());  
    }  

    return new byte[0];  
}

</code></pre><p>反序列化:</p><pre><code class="language-java">
public &lt;T&gt; T deserialize(MessageLite messageLite,byte[] array, Class&lt;T&gt; clazz) {  
    return messageLite.getDefaultInstanceForType().getParserForType().parseFrom(array, 0, array.length);
}

</code></pre><span id="OSC_h3_7"></span><h3>消息的粘包/拆包和半包处理</h3><p>TCP/IP 是面向流的协议，操作系统底层其实并不关心我们自定义的应用层协议包是否完整，在高并发情况下，我们一次性发送多个包会被写入到一个流中，就是所谓的「粘包」，而接收方则需要根据收到的流进行拆分得到具体的包，称为「拆包」，</p><p><img height="183" src="https://oscimg.oschina.net/oscnet/up-f2a9582fee1ea86078a7229ef8328328729.png" width="600" referrerpolicy="no-referrer"></p><p>比如上面的 A,B,C,D,E,F 是一次性发送的包，但是在发送 D 的时候超过了发送缓冲区被拆分成了 D1 和 D2，而接收方从缓冲区读取到 A,B,C,D1 的时候完全不知所措，我们需要处理每个包的边界，并且还需要将第一次包中的 D1 和第二次包中的 D2 进行合并成 D 形成一个完整的包 D。</p><p>业界最常用的方案是，发送方在写入缓冲区字节流的时候，先写入消息的长度，再写入消息字节，而接收方则先读取长度 n，再读取 n 个字节，如果字节数不到 n，则重制 position，等下一次读取消息的时候再读取完整 n 个长度的字节流形成一个消息包。</p><p>写入字节流代码：</p><pre><code class="language-java">int dataLength = data.length;  
out.writeInt(dataLength); // 先写入消息长度  
out.writeBytes(data); // 写入序列化后的数据

</code></pre><p>而接收方，用 netty 现成的 LengthFieldBasedFrameDecoder 即可</p><pre><code class="language-java">pipeline.addLast(new LengthFieldBasedFrameDecoder(globalConfig.getMaxFrameLength(),  
0, 4, 0, 4));

</code></pre><p>这里的 4 表示 4 个字节 (int 类型)，它会先读取 4 个字节，再读取字节流，根据长度拆分不同的」Frame「，即我们需要的消息包。</p><span id="OSC_h3_8"></span><h3>Netty 构建通信框架</h3><p>针对 Netty 构建通信网络初始化，最终目标是实现客户端发送一个 ShadowRPCRequest 消息就能调用服务并返回给客户端 ShadowRPCResponse 消息</p><pre><code class="language-java">NioEventLoopGroup bossGroup = new NioEventLoopGroup();  
NioEventLoopGroup workerGroup = new NioEventLoopGroup();
ServerBootstrap bootstrap = new ServerBootstrap();  
bootstrap.group(bossGroup, workerGroup)  
.channel(NioServerSocketChannel.class)  
.childHandler(new ShadowChannelInitializer(serverConfig))  
.option(ChannelOption.SO_BACKLOG, 128)  
.childOption(ChannelOption.SO_KEEPALIVE, true);  
  
channelFuture = bootstrap.bind(port).sync();

</code></pre><p>childHandler 里面使用 ShadowChannelInitializer 作为每个连接的处理</p><pre><code class="language-java">public class ShadowChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; {  
  
    private ServerConfig serverConfig;  

    public ShadowChannelInitializer(ServerConfig serverConfig) {  
    this.serverConfig = serverConfig;  
    }  

    @Override  
    protected void initChannel(SocketChannel ch) throws Exception {  
    ChannelPipeline pipeline = ch.pipeline();  

    //qps 请求量统计  
    if(serverConfig.isQpsStat()) {  
    pipeline.addLast(new QpsStatHandler());  
    }  

    //处理帧边界，解决拆包和粘包问题  
    pipeline.addLast(new LengthFieldBasedFrameDecoder(serverConfig.getMaxFrameLength(),  
    0, 4, 0, 4));  

    //消息序列化和反序列化  
    pipeline.addLast(new MessageHandler());  

    //服务处理  
    pipeline.addLast(new ServerHandler());  
    }  
}

</code></pre><p>紧接着就是对接收到客户端的 ShadowRPCRequest 消息的处理，ShadowRPCRequest 里面包含了服务名，函数名以及参数，考虑到也有可能是 protobuf 类型 ShadowRPCRequestProto，这里统一转换成抽象层的 model: RequestModel，字段和 ShadowRPCRequest 都差不多，然后找到对应的服务触发逻辑和响应 ServerHandler</p><pre><code class="language-java">public class ServerHandler extends ChannelInboundHandlerAdapter {  
  
    @Override  
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {  

    // 打印验证影响速度，压测时去掉  
    //logger.info("Server received: " + msg);  

    IModelParser modelParser = serializeModule.getSerializer().getModelParser();  

    RequestModel requestModel = modelParser.fromRequest(msg);  

    executorService.execute(()-&gt;{  
    try {  

        ServiceLookUp serviceLookUp = new ServiceLookUp();  
        serviceLookUp.setServiceName(requestModel.getServiceName());  
        serviceLookUp.setMethodName(requestModel.getMethodName());  
        serviceLookUp.setParamTypes(requestModel.getParamTypes());  
        ServiceTarget targetRPC = serverModule.getRPC(serviceLookUp);  

        Object result = targetRPC.invoke(requestModel.getParams());  

        ResponseModel responseModel = new ResponseModel();  
        responseModel.setTraceId(requestModel.getTraceId());  
        responseModel.setCode(ResponseCode.SUCCESS.getCode());  
        responseModel.setResult(result);  

        // 响应客户端  
        ctx.writeAndFlush(modelParser.toResponse(responseModel));  
        } catch (Exception e) {  
        e.printStackTrace();  
    }  

    });  

    }  
  
}

</code></pre><p>至于根据 RequestModel 是如何找到对应的服务的，就需要在服务端启动的时候扫描所有的服务缓存到 serverModule 里面了，这样就能通过 serverModule 获取到 targetRPC</p><pre><code class="language-java">@ShadowModule  
public class ServerModule implements IModule {  
    private static final Logger logger = LoggerFactory.getLogger(ServerModule.class);  

    @ModuleInject  
    private SerializeModule serializeModule;  

    private ServerConfig serverConfig;  

    //所有服务  
    private Map&lt;ServiceLookUp,ServiceTarget&gt; allRPC = new ConcurrentHashMap&lt;&gt;();  

    public void init(ServerConfig serverConfig,List&lt;String&gt; packages) {  
        this.serverConfig = serverConfig;  
        //初始化服务  
        List&lt;ShadowServiceHolder&lt;ShadowService&gt;&gt; shadowServices = new ArrayList&lt;&gt;();  

        for(String packageName : packages) {  
        try {  
        shadowServices.addAll(AnnotationScanner.scanAnnotations(packageName, ShadowService.class));  
        } catch (IOException e) {  
        logger.error("scanService err",e);  
        }  
        }  

        for(ShadowServiceHolder&lt;ShadowService&gt; ShadowServiceHolder : shadowServices) {  
        ShadowService serviceAnnotation = ShadowServiceHolder.getAnnotation();  
        Class&lt;?&gt; serviceClass = ShadowServiceHolder.getClassz();  
        try {  
        Object o = serviceClass.newInstance();  


        for(Method method : serviceClass.getMethods()) {  

        if(Modifier.isStatic(method.getModifiers()) || !Modifier.isPublic(method.getModifiers())){  
        continue;  
        }  

        ServiceLookUp serviceLookUp = new ServiceLookUp();  
        serviceLookUp.setServiceName(serviceAnnotation.serviceName());  
        serviceLookUp.setMethodName(method.getName());  
        serviceLookUp.setParamTypes(method.getParameterTypes());  

        ServiceTarget serviceTarget = new ServiceTarget();  
        serviceTarget.setTargetObj(o);  
        serviceTarget.setMethod(method);  
        addRPCInterface(serviceLookUp,serviceTarget);  
        }  

        } catch (InstantiationException | IllegalAccessException e) {  
        throw new RuntimeException(e);  
        }  
        }  
    }  

    public void addRPCInterface(ServiceLookUp lookUp,ServiceTarget obj) {  
        allRPC.put(lookUp,obj);  
    }  

    public ServiceTarget getRPC(ServiceLookUp lookUp) {  
        return allRPC.get(lookUp);  
    }  
  
  
  
}

</code></pre><span id="OSC_h3_9"></span><h3>客户端调用远程 rpc 服务</h3><p>刚才我们把服务端接收 ShadowRPCRequest 消息并触发逻辑返回 ShadowRPCResponse 消息实现了，而在客户端，我们只持有服务端的一个接口，要通过这个接口创建一个远程服务调用，来实现 rpc 调用，我们最终要实现的效果是这样的</p><pre><code class="language-java">IHello helloService = shadowClient.createRemoteProxy(IHello.class,"shadowrpc://DefaultGroup/helloservice");  
  
System.out.println("发送 hello 消息");  
String helloResponse = helloService.hello("Tom");  
System.out.println("hello 服务端响应:"+helloResponse);

</code></pre><p>IHello 是一个接口，没有任何实现类，实现类在服务端，而客户端我们通过创建一个远程代理的方式就能实现调用接口即发送 ShadowRPCRequest 消息到远程服务器。</p><p>我们这里使用动态代理，基于接口创建一个远程对象</p><pre><code class="language-java">public static &lt;T&gt; T create(IConnection connection, Class&lt;T&gt; serviceStub, final String service) {  
  
    String[] serviceArr = service.replace("shadowrpc://","").split("/");  
    if(serviceArr.length &lt; 2) {  
    throw new IllegalArgumentException("service 参数不符合规范");  
    }  
    String group = serviceArr[0];  
    String serviceName = serviceArr[1];  

    return (T)Proxy.newProxyInstance(  
        serviceStub.getClassLoader(),  
        new Class&lt;?&gt;[]{serviceStub},  
        new RemoteHandler(connection,serviceStub,group,serviceName)  
    );  
}

</code></pre><p>RemoteHandler 中实现代理对象的逻辑，发送消息到远程服务器</p><pre><code class="language-java">public class RemoteHandler implements InvocationHandler {  
private static final Logger logger = LoggerFactory.getLogger(RemoteHandler.class);  
  
/**  
* 如果不使用注册中心，则必须有 ShadowClient  
*/  
private IConnection clientConnection;  
  
/**  
* 远程接口 stub  
*/  
private Class&lt;?&gt; serviceStub;  
  
  
/**  
* 集群  
*/  
private String group;  
  
/**  
* 服务名  
*/  
private String serviceName;  
  
  
private SerializeModule serializeModule = ModulePool.getModule(SerializeModule.class);  
  
public RemoteHandler(IConnection client, Class&lt;?&gt; serviceStub, String group,String serviceName) {  
    this.clientConnection = client;  
    this.serviceStub = serviceStub;  
    this.group = group;  
    this.serviceName = serviceName;  
}  
  
@Override  
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  
  
    try{  
        RequestModel requestModel = new RequestModel();  
        String traceId = UUID.randomUUID().toString();  
        requestModel.setTraceId(traceId);  
        requestModel.setServiceName(serviceName);  
        requestModel.setMethodName(method.getName());  
        requestModel.setParamTypes(method.getParameterTypes());  
        requestModel.setParams(args);  

        IModelParser modelParser = serializeModule.getSerializer().getModelParser();  
        Future&lt;?&gt; future = ReceiveHolder.getInstance().initFuture(traceId);  

        Channel channel = clientConnection.getChannel(group);  

        if(!channel.isOpen()) {  
        logger.error("服务器已关闭,发送消息抛弃...");  
        return null;  
        }  

        try{  
        channel.writeAndFlush(modelParser.toRequest(requestModel)).sync();  
        }catch (Exception e) {  
        logger.error("发送请求{}失败",traceId);  
        return null;  
        }  

        ResponseModel responseModel = (ResponseModel)future.get(3, TimeUnit.SECONDS);  
        if(responseModel != null) {  
        return responseModel.getResult();  
        }else {  
        ReceiveHolder.getInstance().deleteWait(traceId);  
        logger.error("超时请求,抛弃消息{}",traceId);  
        return null;  
        }  

    }catch (Throwable e) {  
    logger.error("invoke err",e);  
    }  

    return null;  
    }  
}

</code></pre><span id="OSC_h3_10"></span><h3>服务注册与发现</h3><p>上面实现的客户端和服务端是单节点通信的，要实现服务注册与发现，需要注册中心 Registry，服务端向注册中心注册服务，客户端订阅服务节点的变化，获取到服务节点列表后负载均衡 rpc 调用服务节点的机器。</p><p><img height="426" src="https://oscimg.oschina.net/oscnet/up-a708679e97a8b88ed64a0ec96095d73c4aa.png" width="796" referrerpolicy="no-referrer"></p><p>服务端在启动的时候注册服务到 zookeeper</p><pre><code class="language-java">serviceRegistry.registerServer(new ServerNode(group,IPUtil.getLocalIp(),port));

public void registerServer(ServerNode serverNode) {  
    try {  
    String path = ServiceRegistryPath.getServerNodePath(serverNode.getGroup(),  
    ServiceRegistryPath.uniqueKey(serverNode.getIp(),serverNode.getPort()));  
    this.zkNodePath = zooKeeperClient.create(path, serverNode.toBytes());  
    } catch (Exception e) {  
    e.printStackTrace();  
    }  
}

</code></pre><p>即在服务启动的时候创建节点 /shadowrpc/services/group/node1，这个 node1 的值就是 ip+port，而在服务关闭的时候删除这个节点</p><pre><code class="language-java">zooKeeperClient.delete(zkNodePath);

</code></pre><p>客户端就可以获取 zk 下/shadowrpc/services/group 目录下的所有节点，监听目录变化，动态维护服务端的列表</p><pre><code class="language-java">ServiceDiscovery serviceDiscovery = new ServiceDiscovery(ZK_URL);

//监听增量变化事件  
//初始化状态会同步 SERVER_ADDED 事件，所以不用获取全量  
serviceDiscovery.watchService(group, (changeType, serverNode) -&gt; {  
    if(changeType == ServerChangeType.SERVER_ADDED) {  
        System.out.println("Child added: " + serverNode);  

        ShadowClient shadowClient = new ShadowClient(serverNode.getIp(),serverNode.getPort(),eventLoopGroup);  
        shadowClient.init();  
        finalShadowClients.add(shadowClient);  
    }else if(changeType == ServerChangeType.SERVER_REMOVED){  
        System.out.println("Child removed: " + serverNode);  

        Iterator&lt;ShadowClient&gt; iterator = finalShadowClients.iterator();  
        while(iterator.hasNext()) {  
            ShadowClient shadowClient1 = iterator.next();  
            if(serverNode.getIp().equals(shadowClient1.getRemoteIp()) &amp;&amp; serverNode.getPort() == shadowClient1.getRemotePort()) {  
                shadowClient1.close();  
                iterator.remove();  
            }  
        }  
    }
});

</code></pre><p>然后维护这个 List&lt;ShadowClient&gt;表示所有服务器列表的连接的增加和删除，最后负载均衡从这个 List 里面获取连接源发送消息到远程即可。</p><pre><code class="language-java">    int nextBalance = pollingBalance.getNextBalance();  
    shadowClientGroup.getShadowClients(group).get(nextBalance).writeAndFlush(message).sync();

</code></pre><span id="OSC_h3_11"></span><h3>精简版 Client</h3><p>刚才的 Client 和 Server 都是使用 Netty 作为异步非阻塞框架搭建的，有的时候对性能要求不高但是对最终的包大小有要求的时候 (比如开发 IDEA 插件最好是 kb 级别的)，我们这里基于 NIO 来的 Reactor 模式来搭建一套简单版的 rpc client。</p><p>我们还是参考上面的 client，想服务端发送 Request 消息，下面是对 NIO 的一个简单封装 NIOClient</p><pre><code class="language-java">public void connect() throws IOException, ConnectTimeoutException {  
    socketChannel = SocketChannel.open();  
    socketChannel.configureBlocking(false);  
    selector = Selector.open();  
    socketChannel.register(selector, SelectionKey.OP_CONNECT);  

    socketChannel.connect(new InetSocketAddress(host, port));  
    isRunning = true;  

    //reactor 模式  
    this.nioReactor = new NIOReactor(this);  
    nioReactor.start();  

    //等待连接完成  
    try{  
    waitConnection.get(nioConfig.getConnectTimeout(), TimeUnit.MILLISECONDS);  
    } catch (InterruptedException | ExecutionException | TimeoutException e) {  
    isRunning = false;  
    throw new ConnectTimeoutException(String.format("连接服务器%s:%d 超时",host,port));  
    }  
}
    
public MessageSendFuture sendMessage(byte[] bytes) {  
    if(null == bytes || bytes.length == 0) {  
    return null;  
    }  

    ByteBuffer writeBuffer = ByteBuffer.allocate(4 + bytes.length); // 4 bytes for length field  
    writeBuffer.putInt(bytes.length); // Write length of the message  
    writeBuffer.put(bytes); // Write message itself  
    writeBuffer.flip();  

    // Add to write queue  
    MessageSendFuture future = new MessageSendFuture(writeBuffer);  
    writeQueue.add(future);  

    // Change interest to OP_WRITE  
    SelectionKey key = socketChannel.keyFor(selector);  
    if(!key.isValid()) {  
    return null;  
    }  
    key.interestOps(SelectionKey.OP_WRITE);  
    selector.wakeup();  

    return future;  
}

</code></pre><p>这里写入消息 sendMessage 的时候，也是先写入长度 4 字节 bytes.length，再写入 bytes。</p><p>下面是基于 Reactor 模式实现对连接消息，读写消息的统一处理</p><pre><code class="language-java">while (nioClient.isRunning()) {  
    try {  
    if (selector.select() &gt; 0) {  
    processSelectedKeys();  
    }  
    } catch (IOException e) {  
    logger.error("selector err",e);  
    }  
}
    
private void processSelectedKeys() throws IOException {  
    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();  
    Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();  

    while (nioClient.isRunning() &amp;&amp; iter.hasNext()) {  
    SelectionKey key = iter.next();  

    if (key.isConnectable()) {  
    handleConnect(key);  
    }  
    if (key.isWritable()) {  
    handleWrite(key);  
    }  
    if (key.isReadable()) {  
    handleRead(key);  
    }  
    iter.remove();  
    }  
}  

</code></pre><p>而对读消息的拆包和半包处理原理也是和上面一样的，也是读取长度 4 字节，再读取对应长度的字节，如果不够重置 ByteBuffer 的 position 用于下次读取,这里是一个精简版本</p><pre><code class="language-java">private void handleRead(SelectionKey key) {  
  
    ByteBuffer buffer = readByteBuffer;  

    int numRead = 0;  
    try {  
        numRead = socketChannel.read(buffer);  
    } catch (IOException e) {  
        handleClose(key);  
        return;  
    }  

    if (numRead &gt; 0) {  
        buffer.flip(); // 切换到读模式  
        // 处理缓冲区中的所有数据  
        while (buffer.remaining() &gt; 4) { // 确保有足够的数据读取长度字段  
            buffer.mark();  
            int length = buffer.getInt();  
            //System.out.printf("read length=%d,remain=%d\n",length,buffer.remaining());  

            if (length &lt;= buffer.remaining()) {  
            byte[] data = new byte[length];  
                buffer.get(data);  
                nioClient.getReceiveMessageCallBack().handleMessage(data);  
            } else {  
                // 数据长度不足以构成一个完整的消息，重置并退出循环  
                buffer.reset();  
                break;  
            }  
        }  

        if (buffer.hasRemaining()) {  
            buffer.compact(); // 移动未处理数据到缓冲区开始位置  
        } else {  
            buffer.clear(); // 如果没有剩余数据，清空缓冲区  
        }  

        lastActiveTime = System.currentTimeMillis();  

    } else if (numRead &lt; 0) {  
        //接收到-1 表示服务器关闭  
        handleClose(key);  
    }  
}

</code></pre><span id="OSC_h2_12"></span><h2>RPC 框架的使用</h2><p>经过上述酣畅淋漓的 rpc 框架搭建，基本五脏俱全的 rpc 框架 ShadowRPC 就搭建完成了，下面是一些服务例子。</p><span id="OSC_h3_13"></span><h3>定义实体类</h3><pre><code class="language-java">@ShadowEntity
public class MyMessage {
    @ShadowField(1)
    private String content;

    @ShadowField(2)
    private int num;
}

</code></pre><p>如果是 protobuf 方式，可定义描述文件</p><pre><code class="language-proto">message MyMessage {
    string content = 1;
    int32 num = 2;
}

</code></pre><p>然后直接用 maven 插件 protobuf-maven-plugin 生成实体</p><span id="OSC_h3_14"></span><h3>编写接口和服务类</h3><pre><code class="language-java">@ShadowInterface
public interface IHello {
    String hello(String msg);
    MyMessage say(MyMessage message);
}

</code></pre><p>protobuf 方式的接口需要保证参数和返回类型都是 protobuf 定义的类型</p><pre><code class="language-java">@ShadowInterface
public interface IHelloProto {
    MyMessageProto.MyMessage say(MyMessageProto.MyMessage message);
}

</code></pre><p>然后编写服务实现类</p><pre><code class="language-java">@ShadowService(serviceName = "helloservice")
public class HelloService implements IHello {
    @Override
    public String hello(String msg) {
        return "Hello,"+msg;
    }
    @Override
    public MyMessage say(MyMessage message) {
        MyMessage message1 = new MyMessage();
        message1.setContent("hello received "+"("+message.getContent()+")");
        message1.setNum(message.getNum()+1);
        return message1;
    }
}

</code></pre><span id="OSC_h3_15"></span><h3>指定序列化类型和端口，启动服务端</h3><p>单点启动模式如下:</p><pre><code class="language-java">ServerConfig serverConfig = new ServerConfig();
        serverConfig.setQpsStat(true); //统计 qps
        serverConfig.setPort(2023);

ServerBuilder.newBuilder()
        .serverConfig(serverConfig)
        .addPackage("rpctest.hello")
        .build()
        .start(); 

</code></pre><p>使用 zk 作为集群模式启动</p><pre><code class="language-java">String ZK_URL = "localhost:2181";
ServerConfig serverConfig = new ServerConfig();
serverConfig.setGroup("DefaultGroup");
serverConfig.setPort(2023);
serverConfig.setRegistryUrl(ZK_URL);
serverConfig.setQpsStat(true); //统计 qps
serverConfig.setSerializer(SerializerEnum.KRYO.name());
ServerBuilder.newBuilder()
                .serverConfig(serverConfig)
                .addPackage("rpctest.hello")
                .build()
                .start();

</code></pre><span id="OSC_h3_16"></span><h3>客户端调用 rpc 服务</h3><pre><code class="language-java">ModulePool.getModule(ClientModule.class).init(new ClientConfig());

ShadowClient shadowClient = new ShadowClient("127.0.0.1",2023);
shadowClient.init();

IHello helloService = shadowClient.createRemoteProxy(IHello.class,"shadowrpc://DefaultGroup/helloservice");

logger.info("发送 hello 消息");
String helloResponse = helloService.hello("Tom");
logger.info("hello 服务端响应:"+helloResponse);

MyMessage message = new MyMessage();
message.setNum(100);
message.setContent("Hello, Server!");

System.out.printf("发送请求 : %s\n",message);
MyMessage response = helloService.say(message);
System.out.printf("接收服务端消息 : %s\n",response);    

</code></pre><p>使用 zk 作为服务发现负载均衡调用各个服务器</p><pre><code class="language-java">ClientConfig config = new ClientConfig();
config.setSerializer(SerializerStrategy.KRYO.name());
ModulePool.getModule(ClientModule.class).init(config);
String ZK_URL="localhost:2181";
ShadowClientGroup shadowClientGroup = new ShadowClientGroup(ZK_URL);
shadowClientGroup.init();

IHello helloService = shadowClientGroup.createRemoteProxy(IHello.class, "shadowrpc://DefaultGroup/helloservice");
List&lt;ShadowClient&gt; shadowClientList = shadowClientGroup.getShadowClients("DefaultGroup");

System.out.println("所有服务器: "+shadowClientList.stream().map(c-&gt; c.getRemoteIp()+":"+c.getRemotePort()).collect(Collectors.toList()));

for(int i = 0 ;i&lt;shadowClientList.size() * 5; i++) {
    String hello = helloService.hello(i + "");
    System.out.println(hello);
}

</code></pre><span id="OSC_h2_17"></span><h2>性能测试</h2><p>目前 Mac 笔记本 16G 4 核测试的 rpc 调用 hello 逻辑，如果使用 kryo 序列化/反序列化，100w 个请求耗时 27 秒，平均 QPS 为 3.7w，如果使用 protobuf 序列化/反序列化耗时 25 秒, 平均 QPS 为 4w，如果用 M1 芯片的 Mac，平均 QPS 可以达到 7W+，最高 QPS 可以达到 10w+。</p><span id="OSC_h2_18"></span><h2>源码</h2><p>篇幅有限，介绍的时候不够完整有些遗漏，所有源码见: <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FLiubsyy%2FShadowRPC" target="_blank">https://github.com/Liubsyy/ShadowRPC</a><br> 目前仅供学习交流使用，后续我将逐步打磨此 rpc 框架达到企业级水准。</p><blockquote><p>本 RPC 框架使用的方案和技术栈都是业界通用，项目中部分源码如有雷同纯属巧合。</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Fri, 02 Feb 2024 07:11:01 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/3276866/blog/10993751</guid>
            <link>https://my.oschina.net/u/3276866/blog/10993751</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[VS Code 1.86 会导致远程开发功能无法使用]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Visual Studio Code 今日发布的最新版 <u><a href="https://www.oschina.net/news/277414/vs-code-1-86-released">1.86</a></u><span>&nbsp;引入一项严重的破坏性变化，其</span>远程开发服务器工具链<span>最低环境要求的&nbsp;</span>glibc 版本提升为 2.28。</p><p>由于&nbsp;Ubuntu 18.04 LTS 使用 glibc 2.27，因此有开发者发现自己升级到 VS Code 新版本后，使用 Remote SSH 无法连接到远程机器。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-7159057b7f201b731192ad420804af1891b.png" referrerpolicy="no-referrer"></p><p><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fv2ex.com%2Ft%2F1013590" target="_blank">https://v2ex.com/t/1013590</a></em></u></p></blockquote><p>对于该问题，目前的解决方案有两种：</p><ul><li><strong>根据对应的发行版，升级至 Ubuntu 20.04 LTS、Debian 10 或 RHEL 8</strong></li><li><strong>降级到 VS Code 1.85</strong></li></ul><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-cd7781af0c011f485dda9a5d8b8df221d79.png" referrerpolicy="no-referrer"></p></blockquote><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Fremote%2Ffaq%23_can-i-run-vs-code-server-on-older-linux-distributions" target="_blank">详情查看官方 FAQ</a></u>。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 02 Feb 2024 06:23:21 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277439/vscode-1-86-drops-ubuntu-18-04</guid>
            <link>https://www.oschina.net/news/277439/vscode-1-86-drops-ubuntu-18-04</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[CPU vs GPU：不仅仅是一字之差]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>当今科学技术的飞速发展，社会已经迈入了信息时代的智能化阶段。人脸识别、智能客服、个性化推荐等应用已经深入到日常生活的各个方面。这些看得见的应用背后，是看不见的算力在默默地支撑着。在满足这些高算力需求的过程中，CPU 和 GPU 作为计算机的核心组件发挥着重要的承载作用。那么，CPU 和 GPU 到底是什么？它们又有什么区别？</p><p>随着数据成为五大生产要素之一，算力的作用变得愈发重要。算力即计算能力（Computing Power），更具体来说，<strong>算力是指数据中心的服务器通过对数据进行处理后实现结果输出的一种能力。</strong></p><p>算力的概念起源于计算机的发明初期。最早的计算机是由机械装置完成计算任务，而算力指的就是这些机械装置的计算能力。随后，半导体技术的出现和发展，集成电路问世，开启了芯片时代。计算机在芯片的加持下，功能越来越强大，体积也越来越小，最终诞生了个人计算机（PC），成为人类最重要的算力工具。</p><p>而后人工智能和大数据技术的迅猛发展也带动了算力需求的飞速增长。无论是训练复杂的神经网络模型，还是进行大规模数据分析和处理，算力都扮演着至关重要的角色。如今，<strong>芯片已经成为算力的主要载体</strong>。当我们谈论算力时，实际上是在讨论 CPU 和 GPU 等芯片的计算能力。在计算机科学领域，CPU 和 GPU 作为计算机的核心组件，虽然名字只有「一字之差」，但其结构和功能却大不相同。</p><span id="OSC_h1_1"></span><h1><strong>1 CPU vs GPU: 概念</strong></h1><p><strong>CPU（Central Processing Unit），即中央处理器</strong>，是电脑、手机等众多电子产品的「心脏」。在我们日常生活的诸多场景中，如观看视频、玩游戏、聊天互动等，<strong>CPU 发挥着统一指挥和调度的关键作用</strong>。它主要负责执行程序指令、进行算术和逻辑运算以及控制和协调计算机各个部件。</p><p>为了满足处理各种不同数据的强大通用性能，CPU 的内部结构设计非常复杂。CPU 由多个核心组成，每个核心又包含算术逻辑单元、控制单元和高速缓存等组件，并且可以独立地执行任务。至今为止，所有的 CPU 都遵循冯·诺依曼体系结构的基本工作流程：取指令，指令译码，执行指令，数据回写，然后再取下一个指令、译码、执行、回写，重复进行直到程序结束。通过这种工作流程，CPU 能够有效地执行程序，并控制整个系统的运行。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-10e85bcb595265cd760feadac4d6ff9b532.png" referrerpolicy="no-referrer"></p><p style="text-align:center">CPU 工作流程</p><p>然而，随着计算机的普及，人们对图形显示的要求不断提高，例如在进行复杂的三维建模时，需要处理大量的图形数据以呈现逼真的效果；在玩大型游戏时，要求系统能够处理高分辨率的画面和复杂的游戏场景。尽管 CPU 内部采用了各种方法来加速指令执行，但随着任务的增多，CPU 的性能显得有些力不从心。</p><p>面对这个问题，能否考虑增加更多的 CPU 来解决呢？这固然是一种思路，但这涉及到相当高的成本，并且堆叠数量也不能保证完全解决计算能力不足的问题。这时候聪明的开发者就提出了一个更巧妙的解决方案：既然 CPU 的计算能力有限，为什么不将计算单元堆叠在同一块芯片上，让它们处理大量运算的任务呢？于是，GPU 诞生了。</p><p><strong>GPU（Graphics Processing Unit），即图形处理器，</strong> 顾名思义，一种专门用来处理图形和图像计算的处理器。<strong>GPU 最初是为图形渲染和显示而设计的，用于加速计算机中图像的处理</strong>，例如在视频游戏、电影渲染、图形设计等方面。它只有少量的控制单元和缓存单元，绝大部分的空间用来堆放运算单元，主要负责完成许多计算密集型任务。</p><span id="OSC_h1_2"></span><h1><strong>2 CPU vs GPU: 「差」在哪里？</strong></h1><p>通过引入 GPU，计算机系统可以充分利用其强大的并行计算能力，加速图形和图像相关的计算任务。CPU 负责逻辑任务，而 GPU 来处理大量简单重复的计算任务，这种不同类型的任务分配给不同类型的处理器的模式，大大提高了系统性能。那么，CPU 和 GPU 到底「差」在哪里呢？</p><p><strong>2.1 架构组成</strong></p><p>CPU 和 GPU 之间存在显著差异，是因为它们各自针对不同的目标和需求来设计，具体体现在：</p><ul><li><p>CPU 需要有强大的通用性，以处理各种不同类型的数据，同时需要进行逻辑判断，包括大量的分支跳转和中断处理，这导致内部结构异常复杂。</p></li><li><p>GPU 主要面向类型高度统一、相互无依赖的大规模数据，并在纯净的计算环境中执行，因此不需要处理复杂的逻辑操作。</p></li></ul><p>这就导致了 CPU 和 GPU 呈现出非常不同的架构：</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-8aa6a52075b93619752a89167782aee5119.png" referrerpolicy="no-referrer"></p><p style="text-align:center">CPU 基本架构</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-c3ccf2310c31a2e6354388180ec4615ba97.png" referrerpolicy="no-referrer"></p><p style="text-align:center">GPU 基本架构</p><p>CPU 拥有较大的缓存单元以及复杂的逻辑控制单元，相比之下计算能力只是 CPU 很小的一部分。而 GPU 则拥有数量众多的计算单元和超长的流水线，但只有非常简单的逻辑控制以及较小的缓存单元。</p><p><strong>2.2 设计理念</strong></p><p>CPU 和 GPU 的设计理念也截然不同。首先，<strong>CPU 是基于低延迟（Low Latency）设计的</strong>：</p><ul><li><p><strong>强大的运算单元：</strong> CPU 拥有数量较少但是单个计算性能更强的运算单元，可以减少操作延时，更快地响应。</p></li><li><p><strong>大容量缓存：</strong> 将一部分数据存储到高速缓存当中，使得高延迟的内存访问转换为低延迟的缓存访问。</p></li><li><p><strong>复杂的控制单元：</strong> 分支预测（Branch Prediction）机制可以降低分支延时；数据转发（Data Forwarding）机制降低数据延时。</p></li></ul><p>而&nbsp;<strong>GPU 则是基于高通量（High Throughput）设计的</strong>：</p><ul><li><p><strong>精简的运算单元：</strong> GPU 拥有大量的运算单元，虽然单个单元的性能比不上 CPU，但可以支持非常多的线程（Thread）从而达到非常大的吞吐量。</p></li><li><p><strong>小容量缓存：</strong> 与 CPU 不同，GPU 缓存的目的并不是用来存储后面需要访问的数据，而是为线程提供服务，如果有很多线程需要访问同一个相同的数据，缓存会合并这些访问，然后再去访问内存。</p></li><li><p><strong>简单的控制单元：</strong> GPU 的控制单元没有分支预测和数据转发机制。</p></li></ul><p>总的来说，CPU 拥有数量相对少（一般不超过两位数）但能力更强的核心，能够更快地处理单个任务，因而它尤其适合处理串行任务和逻辑控制等类型的工作。相比之下，GPU 拥有成百上千核，虽然每个核心运算能力较低，但可以将复杂任务分解成非常多的子任务再并行处理。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-9572c4d616cb11ca84427a84df0d2e95c1d.png" referrerpolicy="no-referrer"></p><p style="text-align:center">串行处理过程</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-d325166b8458a82bfd616ed21119309a3aa.png" referrerpolicy="no-referrer"></p><p style="text-align:center">并行处理过程</p><p><strong>2.3 适用场景</strong></p><p>CPU 与 GPU 二者的设计目的并不一样，因而适用的场景也截然不同。<strong>CPU 更擅长一次处理一项任务，而 GPU 则可以同时处理多项任务。</strong></p><p>用一个形象的比喻来解释。CPU 就像是一架高速飞机，而 GPU 则相当于一队货柜船。它们的任务是将大量货物从 A 位置迅速运送到 B 位置。虽然 CPU（飞机）速度非常快，但每次只能携带少量的货物，需要多次往返才能完成任务。相比之下，GPU（货柜船）虽然单次执行速度相对较慢，但通过协同工作，每艘都能同时携带一部分货物，最终以集体的力量高效完成运输任务。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-b63aae29f97580397fb69a6ed0ae951f0e5.png" referrerpolicy="no-referrer"></p><p style="text-align:center">CPU 与 GPU 处理任务对比</p><p>因此，虽然 CPU 单次执行任务的时间更快，但是在需要大量重复工作负载时，GPU 优势就越显著。而当遇到前后计算步骤严密关联的计算场景，这些任务涉及到「流」的问题，必须先计算完第一步，再去计算第二步。或是需要进行大量逻辑判断和复杂计算的任务，比如运行操作系统、处理日常办公任务、进行单线程编程等。这种时候，使用 GPU 的效率反而没有 CPU 高。</p><p>综上所述，CPU 是个集各种运算能力的大成者。它的优点在于调度、管理、协调能力强，并且可以做复杂的逻辑运算，但由于运算单元和内核较少，只适合做相对少量的运算。GPU 无法单独工作，它相当于一大群接受 CPU 调度的流水线员工，适合做大量的简单运算。<strong>CPU 和 GPU 在功能上各有所长，互补不足，通过相互配合使用，实现最佳的计算性能</strong>。</p><p>因此，虽然 CPU 单次执行任务的时间更快，但是在需要大量重复工作负载时，GPU 优势就越显著。而当遇到前后计算步骤严密关联的计算场景，这些任务涉及到「流」的问题，必须先计算完第一步，再去计算第二步。或是需要进行大量逻辑判断和复杂计算的任务，比如运行操作系统、处理日常办公任务、进行单线程编程等。这种时候，使用 GPU 的效率反而没有 CPU 高。</p><p>综上所述，CPU 是个集各种运算能力的大成者。它的优点在于调度、管理、协调能力强，并且可以做复杂的逻辑运算，但由于运算单元和内核较少，只适合做相对少量的运算。GPU 无法单独工作，它相当于一大群接受 CPU 调度的流水线员工，适合做大量的简单运算。<strong>CPU 和 GPU 在功能上各有所长，互补不足，通过相互配合使用，实现最佳的计算性能</strong>。</p><span id="OSC_h1_3"></span><h1><strong>3 CPU vs GPU: 演进与发展</strong></h1><p>技术的不断更新推动着计算机领域的快速发展，而在这个不断演进的过程中，CPU 和 GPU 也在持续发展。在过去的几十年里它们在各自的领域取得了显著的突破，为计算机应用提供了更高的性能和效率。这不仅推动了数字化时代信息技术的发展，也为各个领域带来了新的可能性。</p><p><strong>3.1 扬长避短，稳步前进</strong></p><p>CPU 拥有强大的指令处理和计算能力（这里强大的计算能力是指 CPU 可以胜任更复杂的计算任务），通常用于处理计算机的核心工作，包括解释计算机指令和处理计算机软件中的数据。例如我们在使用个人计算机时，用户和各种软件会不断地产生指令流，CPU 要完成的一个重要工作就是负责处理这些指令，保证它们按照规定的顺序执行。此外，CPU 还要负责处理计算机软件所产生的类型多样且逻辑复杂的数据。</p><p>距离第一块 CPU 4004 的诞生已经过去了五十多年，尽管与早期相比，CPU 在物理形态、设计制造和具体任务的执行上有了极大的发展，但是其基本的操作原理一直没有改变。换句话来说 <strong>，CPU 的功能和使用场景并没有发生较大的改变，无非是在能耗、性能以及可靠性上面不断地优化。</strong></p><p><strong>3.2 GPU 加速应用遍地开花</strong></p><p>3.2.1 从 GPU 到 GPGPU</p><p>GPU 的概念在 1999 年 NVIDIA 公司发布 GeForce 256 时被首次提出， 在早期，GPU 主要用于 3D 图形渲染。但与 CPU 不同，随着 GPU 的功能和运算能力越来越强大，开发者开始探索除了图形处理之外，GPU 还能做什么？</p><p>在 2003 年，NVIDIA 推出新产品 GeForce 8800 GTX 时，首次提出了 GPGPU（General-purpose computing on Graphics Processing Unit）的概念，即通用图形处理器，意指利用 GPU 的计算能力，在非图形处理领域进行更通用、更广泛的计算。</p><p>到了 2007 年，NVIDIA 进一步提出了名为 CUDA（Compute Unified Device Architecture，计算统一设备架构）的全新技术，利用该技术可以通过 NVIDIA 的 GPU 进行图像处理之外的计算任务，它揭开了 GPU 计算革命序幕。随后，AMD 也推出了类似的技术：OpenCL（Open Computing Language）。OpenCL 是一个开放的、跨平台的并行计算框架，允许开发人员在不同的硬件平台（CPU、GPU、FPAG 等）上进行开发。</p><p>自此以后，<strong>GPU 不再以图形的 3D 加速为唯一目的，而是能够广泛应用于各领域的通用计算加速，尤其是科学计算、大数据分析以及人工智能等领域。</strong></p><p>3.2.2 大模型与向量数据库</p><p>当今互联网世界所需的计算能力远远超出任何人的想象，并且只会随着人工智能的兴起而增加。以如今爆火的生成式 AI ChatGPT 为代表，大小为 175B 的 GPT-3 使用了 1024 张 A100 GPU 训练了约 34 天，随着参数数量的增加，往后 AI 需要的算力资源更是天文数字。</p><p>大模型同样引发了数据库领域的革命，此前不温不火的向量数据库搭上了这辆顺风车，一举成为 AI 时代的新宠。在 2023 英伟达 GTC AI 开发者大会中，NVIDIA CEO 黄仁勋首次提及向量数据库，并强调<strong>对于构建专有大模型的组织而言，向量数据库至关重要。</strong></p><p>对于 AI 来说，向量是它理解世界的通用数据形式，不管是图片、视频、音频，都可以通过转换成向量来让 AI 识别，<strong>向量数据库作为专门对向量进行检索和存储的工具，能为大模型的应用落地解决诸如「没有长期记忆」、「幻觉」、「知识更新不及时」等问题。</strong></p><p>但是，向量数据库本身的性能也是一个问题，说到底与大模型的结合只是其应用的一部分，它本质上还是一个数据搜索和分析的工具，如果性能满足不了用户需求，同样也会被淘汰。于是乎，开发者们又想起了 GPU。</p><p>在向量数据库中，最核心的功能在于向量相似性搜索，即在一个海量的数据中找到和某个向量最相似的向量，它的计算量十分庞大，而这恰好是 GPU 所擅长的，<strong>利用 GPU 的并行计算能力可以加速向量相似性搜索，显著提高查询速度，降低延迟。</strong></p><span id="OSC_h1_4"></span><h1><strong>4 云原生向量数据库 PieCloudVector 支持 GPU 加速</strong></h1><p>拓数派大模型数据计算系统 πDataCS 三大数据计算引擎之一：<a href="https://my.oschina.net/u/5944765/blog/10321799" rel="nofollow"><em>向量数据库 PieCloudVector</em></a>，是大模型时代的分析型数据库升维，目标是助力多模态大模型 AI 应用，进一步实现海量向量数据存储与高效查询。PieCloudVector 支持和配合大模型的 Embeddings，帮助基础模型在场景 AI 的快速适配和二次开发，是大模型必备应用。</p><p><strong>PieCloudVector 充分利用现代化硬件能力，支持 GPU 加速功能。</strong> 这一特性让 PieCloudVector 能够利用 GPU 的并行计算能力来加速向量计算和数据处理任务，显著缩短任务的执行时间，提高计算效率，帮助用户更高效地进行数据计算。特别是在需要处理大规模数据集或进行复杂的数值运算时，GPU 加速可以大幅提升计算性能。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 02 Feb 2024 05:49:21 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5944765/blog/11020020</guid>
            <link>https://my.oschina.net/u/5944765/blog/11020020</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[社区月报丨 2024 年 1 月，多款应用迎更新，还有 deepin Meetup 的初次相见和久别重逢！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>内容来源：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fdeepin-community-monthly-report-2024-01%2F" target="_blank">deepin 社区</a></p><hr><h1><strong>deepin（深度）社区 1 月总览</strong></h1><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">2024 年 1 月，有<strong>975</strong>位小伙伴加入了 deepin 开源社区大家庭，目前共有论坛伙伴<strong>151,007</strong>位；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 1 月，2024 年第一场 deepin Meetup 在北京正式举办，同时 deepin（深度）社区举办的龙年春节壁纸大赛也完美落下帷幕；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">1 月 deepin SIG 组共提交 PR 1116 个 ，提交 Issues 294 个，当前共有 SIG 组 40 个。</p><h1><strong>社区产品</strong></h1><h2><strong>深度之家</strong></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">2024 年 1 月，深度之家共收到用户需求反馈及 bug166 条：</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">当中 bug 反馈 126 个，需求反馈 40 个，已修复/确认 16 个，包括用户反馈的【玲珑卸载应用命令，第一次执行会报错，再执行一次才能卸载成功】、【微信更新后登陆不了】等问题；</p><h2><strong>SIG 组 1 月进展</strong></h2><ol><li><strong>DDE SIG:</strong></li></ol><ul><li>DDE-launchpad 脱离技术预览阶段，DDE-shell、Treeland、DDM 进入技术预览阶段</li></ul><ol><li><strong>dde-port SIG:</strong></li></ol><ul><li>持续推进 DDE 在各个发行版的移植</li><li>BigLinux 发行版下的 DDE v23 初步支持</li></ul><ol><li><strong>deepin-sysdev-team：</strong></li></ol><ul><li>持续进行系统仓库的打包与维护工作</li></ul><ol><li><strong>deepin-cicd-team:</strong></li></ol><ul><li>持续完善自动化流水线的智能程度</li></ul><ol><li><strong>deepin-ThemeDesign：</strong></li></ol><ul><li>已开始制作 deepin 适用壁纸，并向应用商店投递中</li></ul><h1><strong>应用商店</strong></h1><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><img alt="" src="https://bbs.deepin.org/uploader/f/TQNIvpoxovcuW4fP.png?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE3MDY3ODA2OTEsImZpbGVHVUlEIjoiOE5rNk13Nk1EV0ZHendxTCIsImlhdCI6MTcwNjc4MDA5MSwidXNlcklkIjoxMDMxM30.ArE7u7SqsjnfBy4BwVNK3_zpcWgZNnqqlvwLaBhFwsI" referrerpolicy="no-referrer">应用上新 100 款 ：上新应用中，99 款应用同步上新至 deepin V23，99 款应用为 Linux 应用，1 款 Wine 应用；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">上新应用中包括中望 3D 2024、OpenTrace 等多款主流应用；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">应用更新 124 款 ：更新应用中，80 款应用同步在 deepin V23 中更新。其中 113 款为 Linux 应用，Android 应用 7 款，Wine 应用 4 款；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">1 月更新的应用当中包括 QQ、墨刀、有道云笔记等主流应用。</p><h1><strong>deepin 论坛</strong></h1><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">1 月 deepin 论坛共发布了<strong>8803</strong>帖子；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">共发布主题帖<strong>1092</strong>个；</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">超过 900 + 新朋友加入到 deepin 论坛。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">当中，最受论坛用户欢迎的帖子 top5 为：</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><strong>1.</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.deepin.org%2Fpost%2F267681" target="_blank">关于 deepin-V23 beta3 新版本的体验，及个人看法</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><strong>2</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.deepin.org%2Fpost%2F267289" target="_blank">.大家对文件管理器有什么不满吗？</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><strong>3.</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.deepin.org%2Fpost%2F267297" target="_blank">V23 任务栏改进建议，集中反馈贴！</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><strong>4.</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.deepin.org%2Fpost%2F267665" target="_blank">真的不要再高仿了，越来越刷新对国产自主能力的认知！</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><strong>5.</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.deepin.org%2Fpost%2F267231" target="_blank">揭秘 deepin V23 Beta3！deepin Meetup · 2024 北京，出发！</a></p><h1><strong>社区活动</strong></h1><h2><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fwelcome-to-whlug%2F" target="_blank"><strong>【WHLUG】</strong></a></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">2024 年 1 月 20 日下午，由 deepin（深度）社区联合 Linux 中国、龙蜥社区（OpenAnolis）、华中科技大学网络空间安全学院开源俱乐部一起举办的 Linux 爱好者线下沙龙活动（WHLUG）在武汉未来科技城成功举办。沙龙邀请了武汉地区的 Linux 爱好者，共同探讨玲珑、容器技术、Linux 内核、开源参与、高性能网络等话题，现场气氛热烈。</p><p style="color:#333333; margin-left:0px; margin-right:0px; text-align:center"><img alt="image.png" src="https://storage.deepin.org/thread/202402010937419026_image.png" referrerpolicy="no-referrer"></p><h2><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fdeepin-meetup%2F" target="_blank"><strong>deepin Meetup（北京站）</strong></a></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">2024 年 1 月 27 日，deepin Meetup（北京站）成功举办，40 余名用户参与。本次活动带大家回顾 deepin（深度）社区的发展历史，展示了社区部分明星产品及技术成果，并提前揭秘了 deepin V23 Beta3 的部分新增功能，如启动器重构、UOS AI 预装、新增低电阈值设置功能、支持了 Steam 原生应用的安装等。各位 deepiner 线下相聚，昔日网友揭开神秘面纱，共同探讨最新产品进展、分享使用心得、实操经验，大家也对 deepin 未来发展提出了诸多宝贵意见，现场氛围热烈。</p><p style="color:#333333; margin-left:0px; margin-right:0px; text-align:center"><img alt="image.png" src="https://storage.deepin.org/thread/202402010938049219_image.png" referrerpolicy="no-referrer"></p><h2><strong>deepin（深度）社区春节壁纸大赛</strong></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">在 2024 年春节来临之际，国产操作系统「统信 UOS」及 deepin（深度）社区联合举办全新一期壁纸创作大赛，面向所有对电脑操作系统个性美化感兴趣的设计师，征集壁纸作品，展示心中的独特的「中国龙年」。活动已圆满结束，总计收到有效作品数 90 份（156 张图片），通过社区投递系统上架壁纸作品包共计 75 个，参赛人数 23 人（其中 4 位设计师、2 位老师、8 位学生），大众评委环节评分 300 次，参与人数 148 人。目前所有成功投稿的作品都已上架应用商店，可在应用商店中搜索【龙年壁纸】，安装使用。</p><p style="color:#333333; margin-left:0px; margin-right:0px; text-align:center"><img alt="image.png" src="https://storage.deepin.org/thread/202402010938569200_image.png" referrerpolicy="no-referrer"></p><p style="text-align:center">参赛作品：古韵新绎，「龙」光焕发</p><p style="text-align:center">设计师：MC 李狗蛋</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">&nbsp;</p><h1><strong>社区鸣谢</strong></h1><h2><strong>【论坛最活跃小伙伴】</strong></h2><ul><li>阿尼樱奈奈</li><li>buyike</li><li>晚秋（lateautumn）</li></ul><h2><strong>【内测最活跃小伙伴】</strong></h2><ul><li>烟霞志</li><li>e*t@gmail.c<strong>o</strong>m**</li><li>jiutian123</li></ul><h2><strong>【PR 贡献最活跃小伙伴】</strong></h2><ul><li>Zeno-sole</li><li>UTsweetyfish</li><li>Decodetalkers</li><li>xzl01</li><li>18202781743</li><li>liyigang1</li><li>tsic404</li></ul><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>每个贡献者都对深度开源社区的发展产生了巨大的影响，欢迎与我们同心协力，扬起 deepin 的桅杆！</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 02 Feb 2024 05:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277431</guid>
            <link>https://www.oschina.net/news/277431</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Socket.D 协议的开发缘由]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h3>为什么搞个新协议？</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">2021 年时，想为<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsolon.noear.org%2F" target="_blank">Solon 生态</a><span>&nbsp;</span>提供一种 MVC 体验的 Socket 和 WebSocket 开发方式。这个想法，要求消息「能路由」、「有元信息」、「可建立关联性」。于是就开发了 Socket.D 早期版本（算是草案版）。经过两年的实践，其重新定义为：</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">是想要有一种更简单、更通用的通讯方式。简单，且便适用任何场景和平台（想是这么想的啊）。而这，便以 Socket.D 协议作为载体。一个简单的、规范的，面向未来的网络应用协议。</p><h3>为什么不凑合用别人的呢?</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">前人，总有不如意啊。而后人总是站在前人的成果上，吸取优点避开缺点。</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#24292e; display:block; font-family:-apple-system,&quot;system-ui&quot;,&quot;Segoe UI&quot;,Helvetica,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:870px; word-spacing:0px"><tbody><tr><th>协议</th><th>不称心的地方</th></tr></tbody><tbody><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">http</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">单向通讯；只能同步响应</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">websocket</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">没有应用语义，只有框架；需要二次定制</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">rsocket</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">纯响应式接口太复杂；没有事件；元信息为二进制，无法固定标准。不通用</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">socket.io</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">没有流；没有元信息</td></tr></tbody></table><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Socket.D 具备它们的优点，又美好的避开了缺点。是，更具普世性的通用协议。</p><h3>为什么不基于别人的呢?</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Socket.D 作为网络应用协议，原则上可支持任意传输协议。目前适配有<span>&nbsp;</span><code>TCP</code>、<code>UDP</code><span>&nbsp;</span>之类的基础传输协议；也适配有<span>&nbsp;</span><code>WebSocket</code>、<code>KCP</code><span>&nbsp;</span>之类有加工过的传输协议。未来还可能适配别的传输协议。</p><h3>为什么要基于事件消息驱动？</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">网络通信是异步的，消息驱动可建立起单个连接上的多路消息流，从而实现多路复用，一个连接同时多请求多响应。而基于事件，是让消息可路由，可分类处理。这个就像<span>&nbsp;</span><code>mq</code><span>&nbsp;</span>协议的 topic。</p><h3>为什么要元信息？</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><code>http</code><span>&nbsp;</span>协议，就是因为有元信息（它叫头信息），玩出了各种花！有了元信息，就可以为数据进行语义标注。就可以实现各种扩展的场景应用！</p><h3>为什么要流？</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">连接上传输的数据即为流。协议通过流标识（sid），为传输来回的相关数据建立起关联性。Socket.D 基于流而行成的接口交互模型：</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#24292e; display:block; font-family:-apple-system,&quot;system-ui&quot;,&quot;Segoe UI&quot;,Helvetica,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:870px; word-spacing:0px"><tbody><tr><th>接口</th><th>描述</th><th>说明</th></tr></tbody><tbody><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">send</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">发送</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">相当于 Qos0</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">sendAndRequest</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">发送并请求。要求一个答复</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">相当于 Qos1</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">sendAndSubscribe</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">发送并订阅。可接收零个或多个答复消息</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">reply</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答复</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">replyEnd</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答复结束</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr></tbody></table><h3>为什么是这样的接口交互？</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">首先 http 的接口交互是最经典。Socket.D 算是对它的学习、补充和扩展。因为我们是消息驱动的嘛，大家都是讲发消息、发消息。所以用 send 开头：</p><h4>a) send 发送</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">发完后，不需要答复。它是能带来性能提升的，不仅是跳过了答复而节省网络使用，而且不需要等待响应或也不需要建立消息的流关联。是 http 请求/响应模式的补充。</p><h4>b) sendAndRequest 发送并请求。要求一个答复</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">http 经典的请求/响应模式。不管在什么时候都非常有用，必须支持</p><h4>c) sendAndSubscribe 发送并订阅。可接收多个答复消息</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">也是 http 请求/响应模式，的扩展，它允许多个答复消息被流回。可以看作是「collection」的响应，但不是将所有数据作为单个答复返回，而是将每个元素按顺序返回。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">适用的场景可能是：</p><ul><li>获取视频列表</li><li>获取目录中的产品</li><li>逐行检索文件</li></ul><h4>d) reply 答复</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">配合 sendAndRequest，sendAndSubscribe 答复消息</p><h4>e) replyEnd 答复结束</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">配合 sendAndSubscribe 答复消息，并告知答复结束了。</p><h3>为什么规划了多平台多语言？</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">大型分布式系统通常由不同的团队使用各种技术和编程语言以模块化的方式实现。这些模块需要可靠地通信，支持快速、独立的进化。在分布式系统中，模块间有效且可扩展的通信是一个关键问题。它会显著影响用户体验的延迟以及构建和运行系统所需的资源量。</p><p style="color:#24292e; margin-left:0px; margin-right:0px; text-align:start">Socket.D 这么好的协议，必须争取让所有的平台和语言都能用上。参与这种问题的解决。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 02 Feb 2024 04:41:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277424</guid>
            <link>https://www.oschina.net/news/277424</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[开源日报：「Linux 中国」 开源社区宣布停止运营；小红书开源「InstantID」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>欢迎阅读 OSCHINA 编辑部出品的开源日报，每天更新一期。</p><p><strong># 2024.2.1</strong></p><h2><span><span><span style="color:#000000"><span><span><span style="color:#00b050">今日要点</span></span></span></span></span></span></h2><p style="text-align:justify"><strong>OpenSource Daily</strong></p><h3><u><a href="https://www.oschina.net/news/277235/java-proposal-scrap-sunmiscunsafe-memory-access" target="_blank">Java 提案计划弃用 sun.misc.Unsafe 中的内存访问</a></u></h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">OpenJDK 社区中一个名为 「<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F8323072" target="_blank">Deprecate Memory-Access Methods in sun.misc.Unsafe for Removal</a>」 的 JEP 草案提出，建议弃用 sun.misc.Unsafe 中的内存访问方法，以便在未来的 Java 版本中将其进行删除。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">sun.misc.Unsafe 类于 2002 年引入，是 JDK 中 Java 类执行低级操作的一种方法，距今已有 20 多年的历史。在该类的 87 个方法中，有 79 个用于内存访问。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img height="281" src="https://oscimg.oschina.net/oscnet/up-e6847ab49a09af3d783ef2fd5ae0f2b4b87.png" width="500" referrerpolicy="no-referrer"></p><p>提案的目标包括为在未来的 JDK 版本中移除 sun.misc.Unsafe 中的内存访问方法做好准备，以及帮助开发人员了解他们的应用程序何时直接或间接依赖 sun.misc.Unsafe 中的内存访问方法。但它并不旨在完全删除 sun.misc.Unsafe 类，因为该类中的少量方法不用于内存访问，所以将会保持不被弃用；它们的废弃和移除将单独进行。</p><h3><u><a href="https://www.oschina.net/news/277253" target="_blank">字节跳动 2 个云原生开源项目进入 CNCF 云原生全景图</a></u></h3><p style="color:#222222; margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3e3e3e"><span>近日，字节跳动 2 个云原生开源项目<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzk0NDMzNjkxNw%3D%3D%26mid%3D2247484922%26idx%3D1%26sn%3Dfb8922282b6215f28f69a3d9e23fa855%26chksm%3Dc3277c80f450f596fa53c910a75c38e3c22ff864782ec626a0a9842be736dd8ea006d0f2f6b8%26scene%3D21%23wechat_redirect" target="_blank"><strong>Katalyst</strong></a></span><span>&nbsp;</span><span style="color:#3e3e3e"><span>和<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzk0NDMzNjkxNw%3D%3D%26mid%3D2247485243%26idx%3D1%26sn%3D5f39a6597498268c6c965554b12a6849%26chksm%3Dc3277e41f450f75780babf0767f45ea712c1cf59f8b9c7f6d2b48809bb4158648d7c357a76a6%26scene%3D21%23wechat_redirect" target="_blank"><strong>KubeAdmiral</strong></a></span><span style="color:#3e3e3e">&nbsp;陆续进入&nbsp;CNCF 云原生全景图，均被收录在<span>&nbsp;</span></span><span style="color:#0080ff"><em>Orchestration &amp; Management - Scheduling &amp; Orchestration</em></span><span style="color:#3e3e3e"><span>&nbsp;</span>分类下，成为 CNCF 官方认可生态构建工具中的一部分。</span></p><p style="color:#222222; margin-left:8px; margin-right:8px; text-align:justify"><img src="https://oscimg.oschina.net/oscnet/up-88b912acd053b7736fa52b640c7290716a9.png" referrerpolicy="no-referrer"></p><h3><u><a href="https://www.oschina.net/news/277277" target="_blank">「Linux 中国」 开源社区宣布停止运营</a></u></h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="background-color:#ffffff; color:#000000">「Linux 中国」 微信公众号于今日发文<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F5a9zTiMn4hwOR5JU3kPzvw" target="_blank">宣布</a>，从即日起，「Linux 中国」 这个社区，包括它的主网（</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flinux.cn%2F%C2%A0" target="_blank">https://linux.cn/&nbsp;</a><span style="background-color:#ffffff; color:#000000"><span>&nbsp;</span>）、公众号、视频号，以及下属的《硬核观察》栏目，将无限期停止更新和运营。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img src="https://oscimg.oschina.net/oscnet/up-6e3343217de4d5b35d0b43dfd79e9b69d6d.png" referrerpolicy="no-referrer"></p><hr><h2><strong><span><span><span style="color:#000000"><span><span><span style="color:#00b050">今日观察</span></span></span></span></span></span></strong></h2><p><img src="https://oscimg.oschina.net/oscnet/up-5f39b0daf9aacc34cdab04840e2ca4a55c5.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-c29ed5dd0eff8177570b890725186aed794.png" referrerpolicy="no-referrer"></p><hr><h2><strong><span><span><span style="color:#000000"><span><span><span style="color:#00b050">媒体观点</span></span></span></span></span></span></strong></h2><p><img src="https://oscimg.oschina.net/oscnet/up-2ee8125c079733587845fab4edba43ee6a3.png" referrerpolicy="no-referrer"></p><hr><h2><strong><span><span><span style="color:#000000"><span><span><span style="color:#00b050">每日项目榜</span></span></span></span></span></span></strong></h2><p>GitHub 榜单：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-99809320420fb783478a0b3f9f2c96a3f5f.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-4080a984211606c0eef9d3c0508f6e5cba9.png" referrerpolicy="no-referrer"></p><blockquote><h4>在线阅读完整日报内容，访问：<strong><u><a href="https://oscimg.oschina.net/public_shard/%E5%BC%80%E6%BA%90%E6%97%A5%E6%8A%A5%E7%AC%AC007%E6%9C%9F.pdf" target="_blank">开源日报第 007 期：「Linux 中国」 开源社区宣布停止运营</a></u></strong></h4></blockquote><hr><p><strong>往期回顾</strong></p><ul><li><u><a href="https://oscimg.oschina.net/public_shard/%E5%BC%80%E6%BA%90%E6%97%A5%E6%8A%A5%E7%AC%AC006%E6%9C%9F%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8A%80%E6%9C%AF%E6%A0%88%E4%B8%80%E5%AE%9A%E8%A6%81%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E7%9A%84.pdf" target="_blank">开源日报第 006 期：选择技术栈一定要选择开源的</a></u></li><li><a href="http://www.oschina.net/news/277040"><u>开源日报第 005 期：RISC-V 万兆开源交换机发售；npm 存在大量武林外传视频</u></a></li><li><u><a href="https://www.oschina.net/news/276864" target="news">开源日报第 004 期：百度输入法在候选词区域植入广告；大神用 Excel 构建 CPU</a></u></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Fri, 02 Feb 2024 03:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277415</guid>
            <link>https://www.oschina.net/news/277415</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[面壁智能发布端侧大模型「面壁 MiniCPM」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2 月 1 日，面壁智能举办新品发布会，推出了最新的旗舰级多模态大模型「<strong>面壁 MiniCPM</strong>」，参数规模为 20 亿，使用了 1TB 精选数据进行训练。</p><p><img src="https://oscimg.oschina.net/oscnet/up-5755b77c7f59968d93c86bee2afb4c33560.png" referrerpolicy="no-referrer"></p><p>面壁智能 CEO 李大海在发布会上表示，MiniCPM-2B 在多项主流评测榜单、中英文平均成绩均超越了开源的 Mistral-7B，英文榜单的平均分甚至超越了 Falcon-40B、MPT-30B 等百亿参数模型。</p><p><img src="https://oscimg.oschina.net/oscnet/up-12e488c7802d900b054d84644fcf4e6bd60.jpg" referrerpolicy="no-referrer"></p><p>所谓「端侧大模型」，即模型服务部署在手机、电脑、IoT 设备等本地终端，直接由终端芯片完成推理过程，无需联网。作为一款端侧大模型，MiniCPM 声称「<em>跑通国际主流手机品牌与终端 CPU 芯片，老手机也无压力</em>」，但从吞吐量来看，实际表现或许有待提升。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b925911ce8d8133307958365ac3898b7f95.jpg" referrerpolicy="no-referrer"></p><p><strong>开源地址（内含技术报告）</strong>：</p><ul><li>MiniCPM GitHub：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FOpenBMB%2FMiniCPM" target="_blank">https://github.com/OpenBMB/MiniCPM</a></li><li>OmniLMM GitHub：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FOpenBMB%2FOmniLMM" target="_blank">https://github.com/OpenBMB/OmniLMM</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Fri, 02 Feb 2024 02:58:16 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277407</guid>
            <link>https://www.oschina.net/news/277407</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[AI2 开源新 LLM，重新定义 open AI]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">艾伦人工智能研究所（Allen Institute for AI，简称 AI2）<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.allenai.org%2Fhello-olmo-a-truly-open-llm-43f7e7359222" target="_blank">宣布</a>推出一个名为 OLMo 7B 的新大语言模型，并开源发布了预训练数据和训练代码。OLMo 7B 被描述为「一个真正开放的、最先进的大型语言模型」。</span></p><p><span style="color:#000000">AI2 是由已故的微软公司联合创始人保罗-艾伦（Paul Allen）于 2014 年在西雅图创办的一家非营利组织。该组织表示，他们开源 OLMo 模型旨在让 AI 研究社区充分了解最先进的大语言模型（LLM），从而推动自然语言处理的发展，并以科学的方式正视现有 LLM 存在的问题。</span></p><p><span style="color:#000000">「通过向公众完全开放 OLMo 及其训练数据，AI2 在协作构建世界上最好的开放语言模型方面迈出了一大步。」</span></p><p><img height="282" src="https://oscimg.oschina.net/oscnet/up-5f4ac19f48b404e2adf9eed484a4a22035d.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">OLMo 框架具有一套完全开放的 AI 开发工具，包括：</span></p><ul><li><span style="color:#000000">完整的预训练数据：该模型建立在 AI2 的 Dolma 语料库上，该语料库具有三万亿个用于语言模型预训练的 token 开放语料，包括生成训练数据的代码。</span></li><li><span style="color:#000000">训练代码和模型权重： OLMo 框架包括 7B 规模的四个模型变体的完整模型权重，每个模型至少训练有 2T token。提供了推理代码、训练指标和训练日志。</span></li><li><span style="color:#000000">评估：开发中使用的评估套件已发布，每个模型包含 500 多个 checkpoints，来自训练过程中的每 1000 个步骤，以及 Catwalk 项目下的评估代码。</span></li></ul><p><span style="color:#000000">在接下来的几个月中，AI2 计划继续迭代 OLMo，并将不同的模型大小、模式、数据集和功能引入 OLMo 系列。</span></p><p><span style="color:#000000">OLMo 项目负责人、AI2 NLP 研究高级主管、华盛顿大学艾伦学院教授 Noah Smith 表示:</span></p><blockquote><p><span style="color:#000000">「有了 OLMo，open 就是真正意味上的'open'，AI 研究界的每个人都可以访问模型创建的各个方面，包括训练代码、评估方法、数据等。AI 曾经是一个以活跃的研究社区为中心的开放领域，但随着模型的发展、成本的增加以及开始转化为商业产品，AI 工作开始闭门造车。我们希望通过 OLMo 扭转这一趋势，让研究界能够团结起来，以科学的方式更好地理解和使用语言模型，从而开发出更负责任的 AI 技术，造福于每个人。」</span></p></blockquote><p>更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.allenai.org%2Fhello-olmo-a-truly-open-llm-43f7e7359222" target="_blank">查看官方博客</a>。&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 02 Feb 2024 02:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277402/allenai-olmo-truly-open-llm</guid>
            <link>https://www.oschina.net/news/277402/allenai-olmo-truly-open-llm</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[天津大学发布中国首个脑机接口开源软件平台 MetaBCI 研究成果]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>近日，天津大学神经工程团队在数学与计算生物学领域 SCI 一区 TOP 期刊《Computers in Biology and Medicine》上发表论文，介绍了中国首个脑机接口开源软件平台 MetaBCI 的技术架构与实现方法。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-56d4176a2f8c23763ae4c465838482839ef.png" referrerpolicy="no-referrer"></p><p><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sciencedirect.com%2Fscience%2Farticle%2Fpii%2FS0010482523012714%3Fvia%253Dihub" target="_blank">https://www.sciencedirect.com/science/article/pii/S0010482523012714?via%3Dihub</a></em></u></p></blockquote><p>据介绍，MetaBCI 针对 BCI 领域数据分布散乱、算法复现困难、在线系统效率低的问题，规范了 BCI 数据结构与预处理流程、开发了通用的算法框架、利用了双进程和双线程提高在线实时效率，有助于降低构建脑-机接口系统的技术门槛，减少研发成本，促进转化落地。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6ec72a4b9fc60b7b8c54167afe9992a913c.png" referrerpolicy="no-referrer"></p><p>MetaBCI 由离线分析模块 Brainda、刺激呈现模块 Brainstim 和在线数据流模块 Brainflow 三大部分构成，提供了面向 BCI 软件层面全链条开发的解决方案。</p><ul><li>面向离线分析需求，Brainda 统一了现有公开数据集接口，优化了脑电数据读取、处理流程，复现多种主要 BCI 数据分析及解码算法，以此提高研究者的算法开发效率；</li><li>面向刺激呈现需求，Brainstim 提供了简洁高效的范式设计模块，可快速创建脑机接口范式刺激界面；</li><li>面向在线开发需求，Brainflow 利用双线程、双进程编程方法实现了实时高速的数据读取、数据处理、结果反馈等功能，帮助开发者轻松搭建脑机接口在线实验系统。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-8f4d4e3e7fbcc8a74be3635f43436fba05b.png" referrerpolicy="no-referrer"></p><p>当前，MetaBCI 平台包含软件代码共 386 个类和函数，完成技术说明手册 5 万多字，同步更新英文 API 网页（metabci.readthedocs.io/），平台共兼容 17 种 BCI 公开数据集，涵盖 16 种数据分析方法和 55 种脑机解码模型。</p><p>相较于现有的脑机接口软件工具包，MetaBCI 基于开源语言 Python 编写，并且能够涵盖脑机接口全链条功能。MetaBCI 完全打通了脑机接口软硬件开发与设计链路，可为脑机接口在科学研究、医疗康复、娱乐生活、特种控制等领域的应用提供重要支撑，持续推动新一代脑机智能快速发展。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b420b14a768151e8cb1615d426c11e3d30c.png" referrerpolicy="no-referrer"></p><p>MetaBCI 软件代码开源链接：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FTBC-TJU%2FMetaBCI" target="_blank">https://github.com/TBC-TJU/MetaBCI</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 02 Feb 2024 02:25:53 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277399</guid>
            <link>https://www.oschina.net/news/277399</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[大模型评测体系「司南」 (OpenCompass2.0) 发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>上海人工智能实验室科学家团队正式发布了大模型开源开放评测体系「司南」 (OpenCompass2.0)，用于为大语言模型、多模态模型等提供一站式评测服务。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-347708a4c8c2193cfa064cf35e0129504a2.png" referrerpolicy="no-referrer"></p><p><strong>司南 OpenCompass2.0 评测体系官网：</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopencompass.org.cn%2F" target="_blank">https://opencompass.org.cn/</a><br><strong>GitHub 主页：</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopen-compass%2FOpenCompass%2F" target="_blank">https://github.com/open-compass/OpenCompass/</a></p></blockquote><p>据介绍，「司南」全面量化模型在<strong>知识、语言、理解、推理和考试</strong>等五大能力维度的表现，评测榜单涉及的大语言模型和多模态大模型超过 150 个，客观中立地为大模型技术的创新提供坚实的技术支撑。截至目前，已有包括 Meta、阿里巴巴、腾讯、百度等 30 余家国内外企业和科研机构采用「司南」助力开展技术研发。</p><p>OpenCompass2.0 对过去一年来主流开源模型和商业 API 模型进行了全面评测，分析结果显示，GPT-4 Turbo 在各项评测中均获最佳表现，智谱清言 GLM-4、阿里巴巴 Qwen-Max、百度文心一言 4.0 紧随其后；大语言模型整体能力仍有较大提升空间，复杂推理相关能力仍是短板；中文场景下国内的模型更具优势，与此同时，开源模型进步很快，以较小的体量达到较高性能水平，表现出较大的发展潜力。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ba58dc3914ae82f80ebe074e7041caaf88f.png" referrerpolicy="no-referrer"></p><p>完整榜单：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frank.opencompass.org.cn%2Fhome" target="_blank">https://rank.opencompass.org.cn/home</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 02 Feb 2024 02:08:53 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277396</guid>
            <link>https://www.oschina.net/news/277396</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[2024 最新一期中国数据库流行榜公布：阿里云 PolarDB 登顶]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2 月 1 日，数据库社区「墨天轮」公布了 2024 年最新一期中国数据库流行度排行榜，<span style="color:#f39c12">阿里云瑶池旗下的自研云原生数据库 PolarDB 夺冠，并刷新榜单总分纪录</span>。墨天轮评价称，<strong>因云而生的 PolarDB 数据库以客户需求为导向，并在业界开创性地落地「<span style="color:#f39c12"><strong><strong>三层解耦</strong></strong></span>」架构、多主多写、HTAP、Serverless、集中与分布式一体化等一系列业内领先的前沿技术，为用户提供了灵活、可靠的数据库服务，解决了众多业务问题。</strong></p><p>据了解，目前 PolarDB 已被 <span style="color:#f39c12"><strong>10000 家企业级用户</strong></span>采用，广泛落地于政务、金融、电信、物流、互联网等领域的核心业务系统。</p><p>墨天轮是中国知名数据库技术社区，其发起的中国数据库流行度排行榜，依据搜索引擎数据、核心案例数、资质数量、专利数、论文数等标准，对 <span style="color:#f39c12"><strong>290</strong></span> 个最主流的国产数据库进行综合评比。该榜单反映的是数据库产品在市场中的活跃度，被誉为中国版的「DB-Engines 排名榜」。</p><p>在 2024 年 2 月的排行榜中，PolarDB 以 <span style="color:#f39c12"><strong>856.07 分</strong></span>刷新榜单记录，排名第一，OceanBase、TiDB、OpenGauss、人大金仓分列 2~5 名。</p><p>诞生于 2017 年的 PolarDB 是中国首款自研云原生数据库，采用存储计算分离、软硬一体化设计。在弹性场景下，PolarDB 成本仅为传统商业数据库的 1/10，并于首批通过 2023 年国产数据库安全可靠测评。2024 年 1 月，在首届 PolarDB 开发者大会上，PolarDB「<strong><strong>三<span style="color:#f39c12">层分离</span></strong></strong>」<strong>新版本发布，<span style="color:#f39c12">可节省 50% 数据库成本</span></strong>、基于智能决策实现<span style="color:#f39c12"><strong>查询性能 10 倍提升</strong></span>。</p><p>近年来，国产数据库广受市场青睐，PolarDB&nbsp;<span style="color:#f39c12"><strong>3 年增速超 400%</strong></span>，服务于<strong>自然人税收管理系统、全国 60% 的省级医保信息平台等机构，以及中国联通、友邦保险、海底捞、米哈游</strong>等知名企业。</p><p>PolarDB 还是数据库开源的重要推动者。目前 PolarDB 已正式开源近 3 年，建立了 15 个 SIG 组，吸引 3 万+开发者和社区用户，以及<strong>韵达、网易数帆、龙蜥等 60 多家生态伙伴</strong>。PolarDB 开源数据库工作室已在 10+所高校挂牌成立，与<strong>武汉大学、华东师范大学</strong>联合开展教学课程、智慧问答助手等多个项目。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 01 Feb 2024 09:39:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277303</guid>
            <link>https://www.oschina.net/news/277303</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[「Linux 中国」 开源社区宣布停止运营]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">「Linux 中国」微信公众号于今日发文<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F5a9zTiMn4hwOR5JU3kPzvw" target="_blank">宣布</a>，从即日起，「Linux 中国」 这个社区，包括它的主网（</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flinux.cn%2F%C2%A0" target="_blank">https://linux.cn/&nbsp;</a><span style="color:#000000"> ）、公众号、视频号，以及下属的《硬核观察》栏目，将无限期停止更新和运营。</span></p><p><span style="color:#000000">主理人「硬核老王」在公告中透露，停止运营的原因其实很平常，大抵包括以下几个方面：</span></p><blockquote><p><strong><span style="color:#000000">「Linux 中国」 已经完成了其历史使命</span></strong></p><p><span style="color:#000000">最初，我们的愿望是想把 「Linux 中国」 建设成一个传播开源技术的公益型社区。但是经过十几年的发展，目前开源文化和 Linux 相关的开源技术已经得到了广泛传播（在这期间，我们或许也做了一些小小的贡献）。因此，继续运营所能起到的作用并没有那么大了。</span></p><p><span style="color:#000000">出于偶然原因，「Linux 中国」 其实并未按照我们的最初设想发展，这么多年下来，真正坚持下来的项目也就是一个翻译团队 LCTT，翻译了数千篇文章，引导数百人参与了开源贡献。然而，近年来，随着计算机翻译技术的进步，尤其是 ChatGPT 的出现，翻译工作的必要性大为降低。自去年以来，我一直使用 ChatGPT 来翻译一些文章，尽管还需要一至两次校对，但基本没什么大问题。所以，LCTT 的存在也显得不那么重要了。</span></p><p><span style="color:#000000">事实上，LCTT 已经陷入了一种半死亡状态，数百名贡献者基本上都处于休眠了状态，甚至由于技术原因，连自动化选题工作都难以维持。唯一能持续翻译的，除了我，就是我们的首席译者 geekpi 了。从这个角度来看，这已经不再是一个社区化的翻译组织了。</span></p><p><strong><span style="color:#000000">最初的方向选择和理想主义无法避免的结果</span></strong></p><p><span style="color:#000000">2003 年，在创立 「Linux 中国」 之前，我还创立过另外一个叫做 「炎黄角马（CNGNU）」 的开源技术社区。但后来因为我创业失败，这个社区就关闭了。随后，我的弟弟王兴江利用我手中闲置的域名 </span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Flinux.cnlinux.cn" target="_blank"><span style="color:#000000">linux.cnlinux.cn</span></a><span style="color:#000000"> 建立了一个新的网站，我们给它起了一个狂妄的名字 「Linux 中国」 —— 实际上，需要澄清的是，我们和 Linux 的官方机构没有任何关联，也不代表 Linux 官方。</span></p><p><span style="color:#000000">建立这个网站（社区）的初衷是为了传播知识和文化，并没有考虑过未来的盈利模式，这也导致我们后来排斥将社区变成一个商业网站，去做一些培训、会议之类的商业活动。</span></p><p><span style="color:#000000">但这带来了巨大的资金压力，尤其是在托管服务器价格高昂的那段时期。幸运的是，我们得到了七牛云在 CDN 方面的赞助、阿里云在 PR 方面的投放，让我们得以发展。当然，还有一些其它的广告主和朋友的赞助，稍后容我一一致谢。</span></p><p><span style="color:#000000">2015 年，我离开了中国电信，成为了一名自由人，没有人再给我发工资了。这些年，「Linux 中国」 有一些收入，主要是为广告商撰写和发布的一些文章，但是收入不太稳定。而在众所周知的那三年里，收入状况甚至更惨淡。说实话，过去几年，我大致处于一种个人经济上的慢性失血状态。</span></p><p><span style="color:#000000">所以，现在，当整体经济不佳时，压力更大。</span></p><p><strong><span style="color:#000000">个人疲惫和人生的交叉路口</span></strong></p><p><span style="color:#000000">近些年，「Linux 中国」 越来越像是一个 「个人」 网站，几乎所有的流程都需要我亲自来完成。「Linux 中国」 的公众号自从开设的第一天起，就没有任何一天停止过更新 —— 无论是年三十还是我的身体抱恙，无论是在出差路上还是带家人出游。这两年，我又开始了《硬核观察》栏目，这需要我每天花费数小时采编、录制和发布视频，如今也有了 1263 期，从未停歇。</span></p><p><span style="color:#000000">累吗？累，但更累的是，没有尽头的累。</span></p><p><span style="color:#000000">我今年正好五十岁了，对我来说，这个年龄是我需要重新定位人生的一个标志点。当我三十岁时，我颇有一种 「顿觉昨日非」 的感觉，从此改变了人生轨迹；当我四十岁时，经历了父亲去世、稍后几年弟弟及其他亲人陆续去世的打击；今年，我再次站在人生的交叉口，我想我应该有所改变了。</span></p><p><span style="color:#000000">幸运的是，我一直非常担心的身体健康，目前还算还没有出现大问题。前段时间去做了好几年没敢做的体检，基本上没太大的问题。</span></p></blockquote><p><span style="color:#000000">硬核老王透露，他在作出这一决定前曾反复思考过，但始终没有找到合适托付 「Linux 中国」 的人或机构。</span></p><p><span style="color:#000000">「一个不盈利、持续亏损的社区，很难找到能保持其独立性和原则的托付人。我也不愿意将 「Linux 中国」 所有的资产都卖给商业机构。有人曾经愿意出高价买我们的域名，但是，他们出的价远远买不起我为此出售良心和名誉的代价。总的来说，就是因为这些大大小小的原因，我做出了艰难的决定，结束这些年的坚持。对不起了，大家。」</span></p><p><span style="color:#000000">除了对支持者们表达歉意以及感谢外，硬核老王表示，在这篇告别信发出后，除非有特殊情况，他将停止在 「Linux 中国」 的主网、公众号、视频号、B 站等所有渠道的内容发布。</span></p><p style="color:#000000; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">并在春节期间将 「Linux 中国」 所有发布的文章都打包成一份电子书，供大家收藏留用。主网和公众号也都会保持相当长的时间的访问，只是可能不会再更新了。</span></p><p style="color:#000000; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">此外，他个人则计划在今年躺平几个月，然后准备一个人出门走走，或许是自驾，或许是摩旅，去寻找一下人生的意义。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 01 Feb 2024 07:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277277</guid>
            <link>https://www.oschina.net/news/277277</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux 基金会与 Lottie 合作，规范化文件格式]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Linux 基金会<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linuxfoundation.org%2Fpress%2Fannouncing-lottie-animation-community" target="_blank">宣布</a>成立&nbsp;Lottie Animation Community (LAC)，致力于将 Lottie 文件格式打造成为一种高效、可扩展、跨平台的动画矢量图形技术和开放文件格式。</span></p><blockquote><p><span style="color:#000000">Lottie 是一种基于 JSON 格式的开源矢量图形动画文件格式。它由 Hernan Torrisi 于 2015 年首次创建，是一种用于从 Adobe After Effects 导出和播放动画的导出格式。Lottie 近年来受到了广泛关注，已成为一种非常流行的动画格式；用于网络、移动应用程序和其他系统，拥有多个独立的渲染器实现和创建支持。</span></p><p><span style="color:#000000">Lottie 动画通常使用 Adobe After Effects 制作，可包含复杂的动画、动态图形和交互元素。动画制作完成后，可将其导出为 Lottie JSON 文件。该 JSON 文件包含重新创建动画所需的所有信息，包括关键帧、缓和曲线和图层信息。</span></p></blockquote><p><img height="309" src="https://oscimg.oschina.net/oscnet/up-be795c59c10636046c1f194ef42d588857f.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Linux 基金会认为，Lottie 的演变和流行促使需要正式的格式规范和民主变革机制，以帮助该格式的开发者和消费者确保 Lottie 使用的不同平台上的可靠性能和兼容性。LAC 就是为了顺应这一需求而成立。</span></p><p><span style="color:#000000">LAC 旨在将成为一个新的格式规范机构。现任 LAC 指导委员会成员包括 Hernan Torrisi、Gabriel Peal、Salih Abdul-Karim、 Google、LottieFiles 和 Airbnb。</span></p><p><span style="color:#000000">LAC 将作为一个项目在 Joint Development Foundation 的管理下运作，确保标准化工作以开放、协作的方式进行。同时保持透明度，确保社区中的每个人都能参与 Lottie 文件格式的开发和完善。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 01 Feb 2024 07:24:23 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277274/lottie-animation-community</guid>
            <link>https://www.oschina.net/news/277274/lottie-animation-community</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Kurator V0.6.0：实现应用全流程生命周期管理]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>本文分享自华为云社区《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fforum%2Fthread-0271141912138799003-1-1.html%3Futm_source%3Doschina%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent" target="_blank" rel="nofollow">Kurator V0.6.0：实现应用全流程生命周期管理</a>》，作者：云容器大未来。</p><p>Kurator 是华为云开源的面向分布式云原生环境的一站式解决方案。它利用 Karmada 作为多集群编排基础，内置集成了 Istio、Prometheus、Thanos、Volcano、KubeEdge、Argo 等主流云原生技术。基于此，Kurator 构建了包括集群舰队管理、集群生命周期管理、统一应用分发、流量治理、监控和策略管理在内的分布式云平台管理能力。</p><p><strong>在最新 0.6.0 版本中，Kurator 为云原生应用增加了 CI/CD 流水线设置与管理功能，简化流水线创建。此外，强化了 0.4.0 版本发布的统一应用分发功能，可以在部署新应用时设置金丝雀（灰度）发布、A/B 测试、蓝绿发布三种渐进式发布策略。</strong>新增的流水线特性和渐进式发布功能与统一分发能力结合，实现基于代码仓库的 GitOps 工作流。这有助于快速构建分布式云原生平台，简化应用开发与发布流程。Kurator CI/CD 的结构图如下所示：</p><p><img src="https://bbs-img.huaweicloud.com/blogs/img/20240129/1706529011645122301.png" referrerpolicy="no-referrer"></p><p>用户更新代码仓库后，触发 Kurator 流水线，完成代码拉取、检查、编译并构建镜像。其后，用户更新应用部署模板，例如更改应用配置中的镜像信息。Kurator Application Controller 侦测到配置更新，将自动触发已应用的渐进式发布策略，实现应用的自动发布。如此一来，整个软件研发生命周期以代码为中心，实现开发至发布完整流程的自动化，简化运维、部署工作。</p><span id="OSC_h1_1"></span><h1>流水线</h1><p>CI/CD 流水线实现源码到发布的自动化过程，包括源码管理、检查、测试等阶段。但由于每个阶段技术需求不同，导致流水线配置和管理难度大。Kurator 参考开源项目 Tekton，通过预定义常用任务模版的方式简化流水线创建操作。用户只需指定任务名称和代码仓库访问凭证即可创建流水线，使用门槛低。对熟悉流水线的高级用户，Kurator 也支持自定义任务。用户可以根据自己需求定制任务内容，满足个性化场景。通过预置任务模板和自定义任务的能力，Kurator 大幅简化了流水线配置和管理的难度。</p><p><img src="https://bbs-img.huaweicloud.com/blogs/img/20240129/1706529025172859223.png" referrerpolicy="no-referrer"></p><p>从图中可以看出，在使用流水线时，Kurator 完成了大部分工作。用户只需配置运行环境，选择任务模板即可完成流水线创建，大大减少学习成本。特别是与传统 Tekton 相比，Kurator 提供了预定义任务模板，用户只关注任务内容而不再处理具体实现，实现了流水线使用的极致简化。</p><p>除了简化流水线的创建操作外，Kurator 还考虑到了软件供应链安全，可以在流水线构建镜像时自动为其添加数字签名和源头证明，以防范假冒镜像，保证镜像源头可靠，保证在镜像制作方面的安全性。软件供应链安全指的是保护软件从开发到部署的整个生命周期过程中的安全性。软件供应链安全可以提高软件安全性能和用户信任度，预防恶意代码渗透。签名和证明添加后，镜像将自动上传至仓库。在镜像仓库中可以直接查看镜像签名和证明的详细情况，如图所示。</p><p><img src="https://bbs-img.huaweicloud.com/blogs/img/20240129/1706529042004882142.png" referrerpolicy="no-referrer">用户可以用签名过程生成的公钥验证镜像签名和源头。这样在生产中,生产者仅需公布签名公钥，就能让用户验证数字签名和来源证明。接下来将展示一个在 Kurator 中创建一个流水线的示例：</p><p><img src="https://bbs-img.huaweicloud.com/blogs/img/20240129/1706529059510694415.png" referrerpolicy="no-referrer"></p><p>在流水线定义 spec.tasks 中指定任务名称，即可选择 Kurator 内置的常用任务模板。目前内置的常用任务模板包括:</p><table border="1" cellspacing="0" style="border-collapse:collapse; border-spacing:0px; border:1px solid #f6f6f6; box-sizing:border-box; font-size:0.8em; max-width:100%; overflow:auto"><tbody><tr><td><p>&nbsp;</p><p>名称</p><p>&nbsp;</p></td><td>任务目标</td></tr><tr><td>git-clone</td><td>拉取源码</td></tr><tr><td>go-test</td><td>运行 go 代码单元测试 <p>&nbsp;</p></td></tr><tr><td>go-lint</td><td>go 源码静态检查</td></tr><tr><td>build-and-push-image</td><td>编译，构建镜像并上传</td></tr></tbody></table><p>此外，通过 customTask 定义可以发布自定义任务。通过指定 image、command 和 args,实现定制任务需求，如上述示例中自定义任务完成的工作就是打印 README.md。</p><p>更多的示例和细节，请参考: https://kurator.dev/docs/pipeline/</p><span id="OSC_h1_2"></span><h1>渐进式发布</h1><p>金丝雀发布、A/B 测试和蓝绿发布都是主流的应用发布策略，可有效减少上线风险。Kurator 0.6.0 在原统一应用分发基础上，增加渐进式发布功能。现在应用可以指定三种渐进式发布策略中的一种策略。同时，可以将具备发布能力的统一分发，与 CI/CD 流水线结合起来，实现基于代码仓库的 GitOps 工作流。</p><span id="OSC_h2_3"></span><h2>金丝雀发布</h2><p>金丝雀部署是一种渐进式发布策略。先向少数用户发布新的软件版本进行测试，根据测试结果，决定是否向更多用户推出新版本。旨在最大限度地减少新版本上线后对用户的影响，是一种更安全、更可靠的软件发布策略。参阅以下的操作示例，了解如何使用 Kurator 配置金丝雀发布。</p><p><img src="https://bbs-img.huaweicloud.com/blogs/img/20240129/1706529079804747862.png" referrerpolicy="no-referrer"></p><p>通过配置 rollout 中的 workload 字段，可以将金丝雀发布的目标设置为 webapp 命名空间下名为 backend 的应用。发布目标除了支持 deployment 应用之外，还支持 daemonSet 应用。流量分析使用 Kurator 内置的请求成功率（request-sueccess-rate）和平均访问时延（request-duration）两个指标作为衡量新版本是否健康的标准。其中通过 thresholdRange 指定阈值。示例中要求请求成功率<span style="background-color:#ffffff; color:#222222">达</span><strong>99%</strong>，平均访问时延小于 500ms，新版本的服务才会被认定为健康。rolloutPolicy.canaryStrategy 配置了每次测试成功后，下次流量递增的比例和最终允许测试版本流量占比的最大值，从而实现渐进式发布新版本。示例中每次递增<span>&nbsp;</span><strong>10%</strong><span>&nbsp;</span>的流量流向新版本，最多为 50%。也可以设置 maxWeight 为 55，这样在最后一次测试的时候，只会新增<span>&nbsp;</span><strong>5%<span>&nbsp;</span></strong>的流量流向新版本。除了这些配置之外，Kurator 还可以设定完成验证之后，流量以什么样的比例逐步流向新版本。</p><p>更多细节请参考: https://kurator.dev/docs/fleet-manager/rollout/canary/</p><span id="OSC_h2_4"></span><h2>A/B 测试</h2><p>A/B 测试为效果测试，是验证应用两版本表现的测试方法。它通过将用户分到不同组，每个组体验不同版本，然后分析每个组用户在使用过程中的各项指标，选择效果较好的版本。A/B 测试也可以先让部分用户试用新版本，收集真实环境下的用户反馈，再决定是否上线新版本。了解如何在 Kurator 配置应用的 A/B 测试，请参考下方操作示例。</p><p><strong><img src="https://bbs-img.huaweicloud.com/blogs/img/20240129/1706529101336764346.png" referrerpolicy="no-referrer"></strong></p><p>和金丝雀发布类似，由 workload 指定 A/B 测试的目标。通过 metric 指定测试的指标。A/B 测试和金丝雀发布不同的点在于需要配置 match 中的匹配规则，实现流量分组。上述 match 配置是只有 http 请求头满足使用 FireFox 浏览器或请求的 cookie 中包含 「type=insider」 的情况下，请求才会被转发到新版本。通过对不同请求头的处理达到对用户分组的效果，对不同的版本进行效果测试。除了匹配请求头之外，还能匹配 URI、端口号等。</p><p>更多细节请参考: https://kurator.dev/docs/fleet-manager/rollout/abtest/</p><span id="OSC_h2_5"></span><h2>蓝绿发布</h2><p>蓝绿发布是一种渐进零停机发布方法。它将生产环境分为两个独立运行的蓝绿环境,蓝环境承载当前实际流量，绿环境预部署新版本。新版本通过测试后,只需切换流量到绿环境，就能实现零停机升级。蓝环境备用支持回滚。通过实时扩容，可近乎零停机完成迭代交付，提高发布效率和用户体验。了解如何在 Kurator 配置蓝绿发布的操作示例，请参考下方。</p><p><img src="https://bbs-img.huaweicloud.com/blogs/img/20240129/1706529124611169009.png" referrerpolicy="no-referrer"></p><p>蓝绿发布需要配置目标应用、测试指标、迭代次数和容许测试失败的次数，其中测试的迭代次数由 analysisTimes 指定，容许测试失败的次数由 checkFailedTimes 指定，除此之外无需配置别的规则。因为蓝绿发布在测试新版本的时候是将全局流量转发到绿环境中进行测试，没有金丝雀发布的渐进式流量递增和 A/B 测试的对用户分组的需求。</p><p>更多细节请参: https://kurator.dev/docs/fleet-manager/rollout/blue-green/</p><span id="OSC_h1_6"></span><h1>未来展望</h1><p>综上所述，通过 CI/CD 流水线和渐进式发布功能，Kurator 实现了从源码到发布的完整流水线自动化，真正提升了开发效率和运维能力，实现开发、配置和发布的应用全流程生命周期管理。此外还大幅简化了采用 CI/CD 流水线和渐进式发布的门槛。随着 Kurator 的不断迭代升级，我们还将继续为流水线添加更多的预定义任务模板，为渐进式发布提供更多的测试指标。欢迎大家试用 Kurator 并提出宝贵的意见与需求。Kurator 的门户为：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkurator-dev%2Fkurator" rel="nofollow" target="_blank">https://github.com/kurator-dev/kurator</a></p><p>随着功能的逐渐完善，Kurator 将成为用户快速立体掌握云原生技术体系、高效运行分布式应用的强大工具。</p><span id="OSC_h3_7"></span><h3>参考链接</h3><p>Kurator 项目地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkurator-dev%2Fkurator" rel="nofollow" target="_blank">https://github.com/kurator-dev/kurator</a></p><p>CI/CD 流水线：https://kurator.dev/docs/pipeline/</p><p>软件供应链安全：https://kurator.dev/docs/pipeline/chain-security/</p><p>渐进式发布：https://kurator.dev/docs/fleet-manager/rollout/</p><p>金丝雀发布：https://kurator.dev/docs/fleet-manager/rollout/canary/</p><p>A/B 测试：https://kurator.dev/docs/fleet-manager/rollout/abtest/</p><p>蓝绿发布：https://kurator.dev/docs/fleet-manager/rollout/blue-green/</p><p>&nbsp;</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%3Futm_source%3Doschina%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent" rel="nofollow" target="_blank"><strong>点击关注，第一时间了解华为云新鲜技术~</strong></a></p><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 01 Feb 2024 05:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4526289/blog/11009306</guid>
            <link>https://my.oschina.net/u/4526289/blog/11009306</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[新增 2 开源项目进入 CNCF 云原生全景图]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3e3e3e"><span>近日，字节跳动 2 个云原生开源项目<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzk0NDMzNjkxNw%3D%3D%26mid%3D2247484922%26idx%3D1%26sn%3Dfb8922282b6215f28f69a3d9e23fa855%26chksm%3Dc3277c80f450f596fa53c910a75c38e3c22ff864782ec626a0a9842be736dd8ea006d0f2f6b8%26scene%3D21%23wechat_redirect" target="_blank"><strong>Katalyst</strong></a></span><span>&nbsp;</span><span style="color:#3e3e3e"><span>和<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzk0NDMzNjkxNw%3D%3D%26mid%3D2247485243%26idx%3D1%26sn%3D5f39a6597498268c6c965554b12a6849%26chksm%3Dc3277e41f450f75780babf0767f45ea712c1cf59f8b9c7f6d2b48809bb4158648d7c357a76a6%26scene%3D21%23wechat_redirect" target="_blank"><strong>KubeAdmiral</strong></a></span><span style="color:#3e3e3e">&nbsp;陆续进入&nbsp;CNCF 云原生全景图，均被收录在<span>&nbsp;</span></span><span style="color:#0080ff"><em>Orchestration &amp; Management - Scheduling &amp; Orchestration</em></span><span style="color:#3e3e3e"><span>&nbsp;</span>分类下，成为 CNCF 官方认可生态构建工具中的一部分。</span></p><blockquote><p style="color:var(--weui-FG-1); margin-left:0; margin-right:0; text-align:left"><span><span style="color:var(--weui-FG-1)">Katalsyt｜</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flandscape.cncf.io%2F%3Fitem%3Dorchestration-management--scheduling-orchestration--katalyst" target="_blank"><u>https://landscape.cncf.io/?item=orchestration-management--scheduling-orchestration--katalyst</u></a></span></p><p style="color:var(--weui-FG-1); margin-left:0; margin-right:0; text-align:left"><span><span style="color:var(--weui-FG-1)">KubeAdmiral｜</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flandscape.cncf.io%2F%3Fitem%3Dorchestration-management--scheduling-orchestration--kubeadmiral" target="_blank"><u>https://landscape.cncf.io/?item=orchestration-management--scheduling-orchestration--kubeadmiral</u></a></span></p></blockquote><p><img height="433" src="https://oscimg.oschina.net/oscnet/up-88b912acd053b7736fa52b640c7290716a9.png" width="1080" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><strong><span>CNCF Landscape</span></strong></p><p style="color:#222222; margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3e3e3e">CNCF 全景图（Cloud Native Computing Foundation Landscape）是一个展示云原生技术和解决方案的可视化图表。它由 CNCF（Cloud Native Computing Foundation，云原生计算基金会）维护和更新，旨在为用户提供一个全面的视图，帮助云原生用户了解云原生生态系统中的各种工具、框架、平台和服务。</span></p><p><span style="color:#3e3e3e">通过查看 CNCF 全景图，用户可以了解到云原生技术的发展趋势和最新动态，同时也可以找到适合自己的工具和框架，以构建高效、可扩展和安全的云原生应用程序。</span></p><p>&nbsp;</p><p><strong><span>关于 Katalyst</span></strong></p><blockquote><p style="color:var(--weui-FG-1); margin-left:0; margin-right:0; text-align:left"><span style="color:var(--weui-FG-1)">GitHub｜</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fgithub.com%2Fkubewharf%2Fkatalyst-core" target="_blank"><u>github.com/kubewharf/katalyst-core</u></a></p></blockquote><p style="color:#222222; margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3e3e3e">Katalyst 是字节跳动对多年大规模业务云原生化场景中资源管理能力的抽象和总结，这是一套在云原生场景下通过在离线业务混合部署技术及精细化资源管理手段，提升资源管理效率和降低资源使用成本的系统。</span></p><p style="color:#222222; margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3e3e3e">体验<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzk0NDMzNjkxNw%3D%3D%26mid%3D2247486313%26idx%3D1%26sn%3D486c5af4eb15b0158d0e46b2990e67de%26chksm%3Dc3277213f450fb05208e88613bea393a875569b9c4dc024a281257c12a8249a36aea248a111a%26scene%3D21%23wechat_redirect" target="_blank">Katalyst 最新版本</a>潮汐混部和资源超分能力：</span></p><ul><li><p style="color:#222222; margin-left:8px; margin-right:8px; text-align:left"><span style="color:#3e3e3e">潮汐混部：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgokatalyst.io%2Fdocs%2Fuser-guide%2Ftidal-colocation%2F" target="_blank"><u>https://gokatalyst.io/docs/user-guide/tidal-colocation/</u></a></p></li><li><p style="color:#222222; margin-left:8px; margin-right:8px; text-align:left"><span style="color:#3e3e3e">资源超分：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgokatalyst.io%2Fdocs%2Fuser-guide%2Fresource-overcommitment%2F" target="_blank"><u>https://gokatalyst.io/docs/user-guide/resource-overcommitment/</u></a></p></li></ul><p><span style="color:#3e3e3e">面对云原生业务常见的资源浪费场景，除了采用 Katalyst 目前已经实现的在离线常态混部、潮汐混部、资源超分等能力外，还有基于 AI 算法预测能力精细化控制工作负载副本数的智能 HPA；以及基于预测算法推荐更符合实际业务需求的 Request 配置，防止资源过度占用的规格推荐等解决方案，企业可以结合具体的业务场景进行选择或搭配使用。</span></p><p>&nbsp;</p><p><strong><span>关于 KubeAdmiral</span></strong></p><blockquote><p style="color:var(--weui-FG-1); margin-left:0; margin-right:0; text-align:left"><span style="color:var(--weui-FG-1)">GitHub｜</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fgithub.com%2Fkubewharf%2Fkubeadmiral" target="_blank"><u>github.com/kubewharf/kubeadmiral</u></a></p></blockquote><p style="color:#222222; margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3e3e3e">KubeAdmiral 基于 Kubernetes Federation v2 迭代演进而来，可以帮助用户轻松管理多个 Kubernetes 集群，并通过统一的接口和资源池将工作负载传播到成员集群。凭借其丰富且可扩展的调度和分发框架，KubeAdmiral 支持一系列的用户场景。KubeAdmiral 简化了多集群管理，支持动态副本分配、跨集群容灾、自动传播依赖等功能。</span></p><p style="color:#222222; margin-left:8px; margin-right:8px; text-align:justify"><span style="color:#3e3e3e">2023 年 10 月，火山引擎基于 KubeAdmiral 打造的<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzk0NDMzNjkxNw%3D%3D%26mid%3D2247485882%26idx%3D1%26sn%3Dd4902025804c1042c3bee536b8f154f5%26chksm%3Dc32770c0f450f9d6eba745c178d69802b60e908d95c5bef078dfadf07d2a55bdc1c6bebb9a1f%26scene%3D21%23wechat_redirect" target="_blank">分布式云原生平台 DCP</a><span>&nbsp;</span>正式公测。DCP 是面向多云多 Kubernetes 集群场景的企业级云原生统一管理平台，提供多云集群统一管理与运维、应用跨集群分发、统一流量管控等能力，为用户打造无处不在的云原生一致体验。</span></p><p><span style="color:#3e3e3e">如需开源交流，添加字节跳动云原生小助手，加入云原生社群。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 01 Feb 2024 05:29:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277253</guid>
            <link>https://www.oschina.net/news/277253</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Java 提案计划弃用 sun.misc.Unsafe 中的内存访问]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">OpenJDK 社区中一个名为「<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F8323072" target="_blank">Deprecate Memory-Access Methods in sun.misc.Unsafe for Removal</a>」的 JEP 草案提出，建议弃用 sun.misc.Unsafe 中的内存访问方法，以便在未来的 Java 版本中将其进行删除。</span></p><p><span style="color:#000000">sun.misc.Unsafe 类于 2002 年引入，是 JDK 中 Java 类执行低级操作的一种方法，距今已有 20 多年的历史。在该类的 87 个方法中，有 79 个用于内存访问。</span></p><p><img height="281" src="https://oscimg.oschina.net/oscnet/up-e6847ab49a09af3d783ef2fd5ae0f2b4b87.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">该提案指出，自 JDK 9（用于访问堆内内存）和 JDK 22（用于访问堆外内存）以来，这些不受支持的方法已经有了受支持的替代方法。因此强烈建议库开发人员从 sun.misc.Unsafe 迁移到受支持的替代方法，以便应用程序能够顺利迁移到现代 JDK。</span></p><p><span style="color:#000000">提案的目标包括为在未来的 JDK 版本中移除 sun.misc.Unsafe 中的内存访问方法做好准备，以及帮助开发人员了解他们的应用程序何时直接或间接依赖 sun.misc.Unsafe 中的内存访问方法。但它并不旨在完全删除 sun.misc.Unsafe 类，因为该类中的少量方法不用于内存访问，所以将会保持不被弃用；它们的废弃和移除将单独进行。</span></p><p><span style="color:#000000">提案并未明确提及将具体在哪个 Java 版本废弃这些方法。但 JDK 22 计划于 3 月份发布，其功能集已被冻结；因此计划于 9 月份发布的 JDK 23 可能将是其目标。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 01 Feb 2024 03:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277235/java-proposal-scrap-sunmiscunsafe-memory-access</guid>
            <link>https://www.oschina.net/news/277235/java-proposal-scrap-sunmiscunsafe-memory-access</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Lepton Search —— 对话式 AI 搜索工具]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Lepton Search 是用 500 行 Python 代码构建的对话式 AI 搜索工具。该项目的后端是 Mixtral-8x7b 模型，托管在 Lepton AI，输出速度能达到每秒大约 200 个 token，搜索引擎采用了 Bing 的搜索 API。</p><p><img src="https://oscimg.oschina.net/oscnet/up-653f2a2bd37324fb0d75d8ceb45ba2c5187.png" referrerpolicy="no-referrer"></p><p><strong>特性</strong></p><ul><li>内置 LLM 支持</li><li>内置搜索引擎支持</li><li>可定制 UI</li><li>可共享的缓存搜索结果</li></ul><p>&nbsp;</p></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 01 Feb 2024 03:17:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/search-with-lepton</guid>
            <link>https://www.oschina.net/p/search-with-lepton</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 开发 Java 应用时如何用好 Log]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;visibility: visible;" data-mpa-powered-by="yiban.io"><img class="rich_pages wxw-img __bg_gif" data-backh="96" data-backw="578" data-cropselx1="0" data-cropselx2="578" data-cropsely1="0" data-cropsely2="96" data-imgfileid="503043467" data-ratio="0.16666666666666666" data-type="gif" data-w="636" src="https://oscimg.oschina.net/oscnet/86315af4-1081-4bac-801d-3b24be03a16d.gif" style="outline: 0px;letter-spacing: 0.544px;font-size: var(--articleFontsize);border-radius: 8px;text-align: justify;width: 100%;visibility: visible !important;background-size: 16px !important;height: auto;" referrerpolicy="no-referrer"><br style="outline: 0px;visibility: visible;"></section><section data-mpa-template="t" data-mpa-template-id="502" data-mpa-category="模板" style="outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);visibility: visible;"><section data-mpa-category="模板" data-mid="" style="padding-right: 1px;padding-left: 1px;outline: 0px;width: 677px;display: flex;justify-content: flex-start;align-items: center;flex-direction: column;visibility: visible;"><section data-mid="" style="outline: 0px;letter-spacing: 0.544px;width: 675px;display: grid;grid-template-columns: 26px auto;visibility: visible;"><section data-mid="" style="outline: 0px;width: 26px;height: 14px;display: flex;justify-content: center;align-items: center;align-self: center;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section><section data-mid="" style="padding-left: 7px;outline: 0px;display: flex;justify-content: flex-start;align-items: center;visibility: visible;"><section data-mid="" style="margin-right: 7px;outline: 0px;text-align: left;visibility: visible;"><p data-mid="" style="outline: 0px;width: 0px;font-size: 14px;font-family: PingFangSC-Semibold, &quot;PingFang SC&quot;;font-weight: bold;color: rgb(58, 92, 244);line-height: 20px;visibility: visible;"><br style="outline: 0px;visibility: visible;"></p></section><section data-mid="" style="margin-bottom: 4px;outline: 0px;width: 635px;height: 1px;border-top: 1px solid rgb(58, 92, 244);align-self: flex-end;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section></section></section><section data-mid="" style="padding: 7px 14px 9px 19px;outline: 0px;width: 675px;text-align: left;border-bottom: 1px solid rgb(58, 92, 244);visibility: visible;"><p style="outline: 0px;min-height: 24px;letter-spacing: 0.578px;text-align: justify;visibility: visible;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);text-align: left;text-indent: 2em;font-size: 15px;letter-spacing: 1px;">本篇文章，主要介绍应用如何正确使用日志系统，帮助用户从依赖、输出、清理、问题排查、报警等各方面全面掌握。</span></p></section></section></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;line-height: 1.75em;visibility: visible;"><br></section><section style="margin-bottom: 0px;outline: 0px;box-sizing: inherit;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgba(25, 26, 31, 0.9);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 16px;text-align: center;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503043463" data-ratio="0.3161764705882353" data-s="300,640" data-type="png" data-w="408" src="https://oscimg.oschina.net/oscnet/cabc16ce-7fe8-42cf-aa27-c0c990e211f3.png" style="outline: 0px;color: rgb(34, 34, 34);font-family: system-ui, -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;visibility: visible !important;width: 113px !important;" referrerpolicy="no-referrer"></span></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(34, 34, 34);text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;color: rgb(3, 69, 255);font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;visibility: visible;">日志相关的包的种类及使用</span></section><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><ne-clipboard data="%7B%22type%22%3A%22fragment%22%2C%22name%22%3A%22%23fragment%22%2C%22children%22%3A%5B%7B%22type%22%3A%22element%22%2C%22id%22%3A%22UiUKr%22%2C%22name%22%3A%22h2%22%2C%22attrs%22%3A%7B%7D%2C%22children%22%3A%5B%7B%22type%22%3A%22text%22%2C%22id%22%3A%22u57ca2a4a%22%2C%22name%22%3A%22%23text%22%2C%22attrs%22%3A%7B%22color%22%3A%22rgb(0%2C%200%2C%200)%22%7D%2C%22data%22%3A%22%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%22%7D%5D%7D%5D%2C%22attrs%22%3A%7B%7D%7D" source="https%3A%2F%2Faliyuque.antfin.com%2Fwien.wuh%2Fdoc%2Fctdtsgv6r0esyll2%3FsingleDoc%23"><br></ne-clipboard></p><span id="OSC_h4_1"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;text-wrap: wrap;outline: 0px;letter-spacing: 0.544px;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;text-align: justify;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">日志系统与日志框架</span></strong></span></h4><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><br></p><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="color: rgb(0, 0, 0);font-family: &quot;zh quote&quot;, &quot;Helvetica Neue&quot;, -apple-system, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, STHeiti, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;;text-align: left;text-indent: 32px;white-space: break-spaces;background-color: rgb(255, 255, 255);font-size: 15px;letter-spacing: 1px;">每个应用为了方便排查问题都要输出日志，大家经常使用：log4j、logback 等。我们先搞明白日志系统的整套体系是如何运作的。</span></section><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_2"></span><h3 style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">日志系统</span></h3></li></ul><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">直接负责打印输出日志，提供完整的日志输出能力：</span></section><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">JUL</span></section></li><ul ne-level="1" class="list-paddingleft-1" style="padding-left: 23px;list-style-position: initial;list-style-image: initial;"><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">java.util.logging.*，java 自带的日志系统简称 JUL。目前除了 Java 自身代码很少被生态系统类库使用。</span></section></li></ul><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">Log4j</span></section></li><ul ne-level="1" class="list-paddingleft-1" style="padding-left: 23px;list-style-position: initial;list-style-image: initial;"><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="font-size: 15px;letter-spacing: 1px;">https://logging.apache.org/</span><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">，目前已经发展到 2.x 版本（2.x 版本有超越 logback 的趋势），早期的 1.x 版本非常成功。开创日志系统模型（Logger\Appender\Level 等概念）并被各种日志框架采用，且一直沿用至今</span></section></li><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">log4j 可直接使用，也可配合日志框架一起使用</span></section></li></ul><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">Logback</span></section></li></ol><ul class="list-paddingleft-1" style="padding-left: 23px;list-style: none;"><ul ne-level="1" class="list-paddingleft-1" style="padding-left: 23px;list-style-position: initial;list-style-image: initial;"><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="font-size: 15px;letter-spacing: 1px;">http://logback.qos.ch/</span><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">，Log4j 作者的另一个作品，（比 Log4j1.x 新，Log4j2.x 旧）吸取多年经验教训重新设计的一套日志系统，使用更方便、功能更强、性能更好。</span></section></li><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">logback 不能单独使用，需配置日志框架 SLF4J 一起使用</span></section></li></ul></ul><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><br></section><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><ne-clipboard source="https%3A%2F%2Faliyuque.antfin.com%2Fwien.wuh%2Fdoc%2Fctdtsgv6r0esyll2%3FsingleDoc%23"></ne-clipboard></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_3"></span><h3 style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">日志框架</span></h3></li></ul><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">为了克服各种日志系统标准混乱，诞生了日志框架，日志框架不提供日志输出的功能，它定义标准，提供标准接口 API，日志框架+日志系统=输出日志。</span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">写代码过程中使用日志框架的好处：编码的时候调用日志框架 API，部署的时候可根据不同的环境在多种日志系统中随意切换。</span></section><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">JCL</span></section></li><ul ne-level="1" class="list-paddingleft-1" style="padding-left: 23px;list-style-position: initial;list-style-image: initial;"><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="font-size: 15px;letter-spacing: 1px;">https://commons.apache.org/proper/commons-logging/</span><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">，前几年最流行的日志框架，由 Apache 社区维护，大量的老牌知名框架版本都在使用，比如 Spring（甚至新版本依然在使用）。</span></section></li></ul><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">SLF4J</span></section></li></ol><ul class="list-paddingleft-1" style="padding-left: 23px;list-style: none;"><ul ne-level="1" class="list-paddingleft-1" style="padding-left: 23px;list-style-position: initial;list-style-image: initial;"><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="font-size: 15px;letter-spacing: 1px;">https://www.slf4j.org/</span><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">，Log4j 作者推出，这几年最流行的日志框架，特别是配合 Logback 使用。 </span></section></li><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">当然也可以配合 log4j 使用</span></section></li></ul></ul><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">目前在 Java 生态趋势主要是使用：SLF4J+Logback 组合。</span></section><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><br></p><span id="OSC_h4_4"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;text-align: justify;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">如何正确组合使用日志系统和日志框架</span></strong></span></h4><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"></h4><section style="margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">上一节我们介绍了日志框架和日志系统，因为存在多套，所以：如何在系统中正确使用是我们的重点。</span></p><p style="min-height: 24px;text-align: left;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_5"></span><h3 style="min-height: 24px;text-align: left;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">日志系统之间互斥</span></h3></li></ul><section style="margin-bottom: 8px;line-height: 1.75em;margin-top: 8px;"><br></section><section style="margin-bottom: 8px;line-height: 1.75em;margin-top: 8px;text-align: center;"><span style="box-sizing: inherit;color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503043462" data-ratio="0.7355704697986577" src="https://oscimg.oschina.net/oscnet/c9170f55-7f05-40d9-a26f-b71453fc1e8d.png" data-type="png" data-w="745" referrerpolicy="no-referrer"></span></section><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">日志框架：JCL 和 JCL-over-SLF4J 桥接包直接互斥</span><br></section></li><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">日志系统：logback 和 slf4j-log4j12 互斥，不能共存</span></section></li></ol><section style="min-height: 24px;text-align: left;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="min-height: 24px;text-align: left;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">我们大概可枚举出如下几种组合：</span></section><table width="641"><tbody><tr style="height: 33px;"><td width="130" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">类型</span></p></td><td width="511" style="min-height: 24px;text-align: left;border-color: rgb(217, 217, 217);height: 33px;"><p style="min-height: 24px;text-align: left;border-color: rgb(217, 217, 217);height: 33px;"><span style="color: rgb(0, 0, 0);font-size: 15px;">说明</span></p></td></tr><tr style="height: 33px;"><td width="130" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">slf4j+logback</span></p></td><td width="511" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">目前最主流的玩法，除了依赖 slf4j、logback，还需要考虑把二方库和三方库内部使用的 jcl 和 log4j 桥接到 slf4j 上来，并避免依赖反桥接的包</span></p></td></tr><tr style="height: 33px;"><td width="130" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">slf4j+log4j</span></p></td><td width="511" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">不推荐。需要把 slf4j 桥接到 log4j，并把 jul 桥接到 slf4j</span></p></td></tr><tr style="height: 33px;"><td width="130" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">jcl+log4j</span></p></td><td width="511" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">不推荐。这需要你直接使用 jcl 接口来编码，并把把 slf4j 桥接到 log4j</span></p></td></tr><tr style="height: 33px;"><td width="130" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">log4j</span></p></td><td width="511" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">不推荐。直接依赖日志系统</span></p></td></tr></tbody></table><p style="min-height: 24px;text-align: justify;margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_6"></span><h3 style="min-height: 24px;text-align: justify;margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">slf4j+logback 组合</span></h3></li></ul><p style="margin-bottom: 8px;text-align: justify;margin-top: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;text-align: justify;margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">下面列出一个正确的 slf4j+logback 依赖，这个环节很重要，很多应用因为依赖搞不清楚经常出现日志丢失问题：</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="xml"><code><span class="code-snippet_outer">&lt;properties&gt;</span></code><code><span class="code-snippet_outer">  &lt;slf4j.version&gt;${xxxx}&lt;/slf4j.version&gt;</span></code><code><span class="code-snippet_outer">  &lt;logback.version&gt;${yyyyy}&lt;/logback.version&gt;</span></code><code><span class="code-snippet_outer">&lt;/properties&gt;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">&lt;dependencyManagement&gt;</span></code><code><span class="code-snippet_outer">  &lt;dependencies&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;999-not-exist&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;com.alibaba.external&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;jakarta.commons.logging&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;999-not-exist&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;999-not-exist&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">        &lt;groupId&gt;com.alibaba.external&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">        &lt;artifactId&gt;org.slf4j.slf4j-log4j12&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">        &lt;version&gt;999-not-exist&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;999-not-exist&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;999-not-exist&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">        &lt;groupId&gt;com.alibaba.external&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">        &lt;artifactId&gt;org.slf4j.slf4j-simple&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">        &lt;version&gt;999-not-exist&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;log4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;999-not-exist&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;${slf4j.version}&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;slf4j-ext&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;${slf4j.version}&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;${slf4j.version}&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;${slf4j.version}&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;${slf4j.version}&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;${logback.version}&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">      &lt;version&gt;${logback.version}&lt;/version&gt;</span></code><code><span class="code-snippet_outer">    &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">  &lt;/dependencies&gt;</span></code><code><span class="code-snippet_outer">&lt;/dependencyManagement&gt;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">&lt;dependencies&gt;</span></code><code><span class="code-snippet_outer">  &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">  &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">  &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">    &lt;artifactId&gt;slf4j-ext&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">  &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">  &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">    &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">  &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">  &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">    &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">  &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">  &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">    &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">  &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">  &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">    &lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">  &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">  &lt;dependency&gt;</span></code><code><span class="code-snippet_outer">    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span></code><code><span class="code-snippet_outer">    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span></code><code><span class="code-snippet_outer">  &lt;/dependency&gt;</span></code><code><span class="code-snippet_outer">&lt;/dependencies&gt;</span></code></pre></section><p style="min-height: 24px;text-align: justify;margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><ne-clipboard source="https%3A%2F%2Faliyuque.antfin.com%2Fwien.wuh%2Fdoc%2Fctdtsgv6r0esyll2%3FsingleDoc%23"><br></ne-clipboard></span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">先将依赖全部写在&lt;dependencyManagement&gt;节点中，这样可影响间接依赖，如果只当初的使用 dependencies 节点，只会应用直接依赖</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">使用 999-not-exist 这样的版本：欺骗 maven，直接依赖一个空包占位，这样 Maven 就不会再去依赖相同座标的真实依赖，间接起到排包的作用</span></p></li></ol><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;"><br></span></section><span id="OSC_h4_7"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;text-wrap: wrap;outline: 0px;letter-spacing: 0.544px;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;text-align: justify;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">logback 配置</span></strong></span></h4><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_8"></span><h3 style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">文件名和位置</span></h3></li></ul><section style="min-height: 24px;text-align: left;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><table width="873"><tbody><tr style="height: 33px;"><td width="227" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">应用类型</span></p></td><td width="166" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">文件名</span></p></td><td width="230" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">文件配置（启动模块）</span></p></td><td width="250" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">说明</span></p></td></tr><tr style="height: 33px;"><td width="227" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">spring-boot</span></p></td><td width="166" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">logback-spring.xml</span></p></td><td width="230" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">src/main/resources/</span></p></td><td width="250" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">支持从 spring-boot 配置文件中直接读取 property</span></p></td></tr><tr style="height: 33px;"><td width="227" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">普通 java 应用</span></p></td><td width="166" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">logback.xml</span></p></td><td width="230" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">src/main/resources/</span></p></td><td width="250" style="border-color: rgb(217, 217, 217);"><br></td></tr><tr style="height: 33px;"><td width="227" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">WAR 应用</span></p></td><td width="166" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">logback.xml</span></p></td><td width="230" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">src/main/webapp/WEB-INF/</span></p></td><td width="250" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">需要依赖 slf4j-ext，然后在 web.xml 里使用监听器挂载这个文件</span></p><p style="min-height: 24px;text-align: left;"><img data-imgfileid="503043469" data-ratio="0.17224287484510534" src="https://oscimg.oschina.net/oscnet/f50acf96-72cd-4627-bcc5-a1741d7beea4.png" data-type="png" data-w="807" width="807" referrerpolicy="no-referrer"></p></td></tr><tr style="height: 33px;"><td width="227" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">单元测试和集成测试</span></p></td><td width="166" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">logback-test.xml</span></p></td><td width="230" style="border-color: rgb(217, 217, 217);"><p style="min-height: 24px;text-align: left;"><span style="color: rgb(0, 0, 0);font-size: 15px;">src/test/resources/</span></p></td><td width="250" style="border-color: rgb(217, 217, 217);"><br></td></tr></tbody></table><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_9"></span><h3 style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: justify;"><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;color: rgb(0, 17, 255);">配置样例</span></h3></li></ul><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="xml"><code><span class="code-snippet_outer">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></code><code><span class="code-snippet_outer">&lt;configuration&gt;</span></code><code><span class="code-snippet_outer">  &lt;property name="APP_NAME" value="demo1" /&gt;</span></code><code><span class="code-snippet_outer">  &lt;property name="LOG_PATH" value="${user.home}/${APP_NAME}/logs" /&gt;</span></code><code><span class="code-snippet_outer">  &lt;property name="LOG_FILE" value="${LOG_PATH}/application.log" /&gt;</span></code><code><span class="code-snippet_outer">  &lt;property name="LOG.PATTERN" value="%d %-5level %X{EAGLEEYE_TRACE_ID}  %logger{5}[%L] - %msg%n"/&gt;</span></code><code><span class="code-snippet_outer">  &lt;property name="LOG.CHARSET" value="UTF-8"/&gt;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">  &lt;appender name="APPLICATION"</span></code><code><span class="code-snippet_outer">    class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;</span></code><code><span class="code-snippet_outer">    &lt;file&gt;${LOG_FILE}&lt;/file&gt;</span></code><code><span class="code-snippet_outer">    &lt;encoder&gt;</span></code><code><span class="code-snippet_outer">      &lt;pattern&gt;${LOG.PATTERN}&lt;/pattern&gt;</span></code><code><span class="code-snippet_outer">      &lt;charset&gt;${LOG.CHARSET}&lt;/charset&gt;</span></code><code><span class="code-snippet_outer">    &lt;/encoder&gt;</span></code><code><span class="code-snippet_outer">    &lt;rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"&gt;</span></code><code><span class="code-snippet_outer">      &lt;fileNamePattern&gt;${LOG_FILE}.%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;</span></code><code><span class="code-snippet_outer">      &lt;maxHistory&gt;7&lt;/maxHistory&gt;</span></code><code><span class="code-snippet_outer">      &lt;maxFileSize&gt;50MB&lt;/maxFileSize&gt;</span></code><code><span class="code-snippet_outer">      &lt;totalSizeCap&gt;20GB&lt;/totalSizeCap&gt;</span></code><code><span class="code-snippet_outer">    &lt;/rollingPolicy&gt;</span></code><code><span class="code-snippet_outer">  &lt;/appender&gt;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">  &lt;logger name="org.springframework" additivity="false"&gt;</span></code><code><span class="code-snippet_outer">    &lt;level value="error"/&gt;</span></code><code><span class="code-snippet_outer">    &lt;appender-ref ref="APPLICATION"/&gt;</span></code><code><span class="code-snippet_outer">  &lt;/logger&gt;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">  &lt;logger name="com.ibatis" additivity="false"&gt;</span></code><code><span class="code-snippet_outer">    &lt;level value="error"/&gt;</span></code><code><span class="code-snippet_outer">    &lt;appender-ref ref="APPLICATION"/&gt;</span></code><code><span class="code-snippet_outer">  &lt;/logger&gt;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">  &lt;logger name="org.mybatis" additivity="false"&gt;</span></code><code><span class="code-snippet_outer">    &lt;level value="error"/&gt;</span></code><code><span class="code-snippet_outer">    &lt;appender-ref ref="APPLICATION"/&gt;</span></code><code><span class="code-snippet_outer">  &lt;/logger&gt;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">  &lt;logger name="java.sql" additivity="false"&gt;</span></code><code><span class="code-snippet_outer">    &lt;level value="error"/&gt;</span></code><code><span class="code-snippet_outer">    &lt;appender-ref ref="APPLICATION"/&gt;</span></code><code><span class="code-snippet_outer">  &lt;/logger&gt;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">  &lt;logger name="sqlMonitor" additivity="false"&gt;</span></code><code><span class="code-snippet_outer">    &lt;level value="error"/&gt;</span></code><code><span class="code-snippet_outer">    &lt;appender-ref ref="APPLICATION"/&gt;</span></code><code><span class="code-snippet_outer">  &lt;/logger&gt;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">  &lt;logger name="com.taobao" additivity="false"&gt;</span></code><code><span class="code-snippet_outer">    &lt;level value="error"/&gt;</span></code><code><span class="code-snippet_outer">    &lt;appender-ref ref="APPLICATION"/&gt;</span></code><code><span class="code-snippet_outer">  &lt;/logger&gt;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">  &lt;logger name="com.alibaba" additivity="false"&gt;</span></code><code><span class="code-snippet_outer">    &lt;level value="error"/&gt;</span></code><code><span class="code-snippet_outer">    &lt;appender-ref ref="APPLICATION"/&gt;</span></code><code><span class="code-snippet_outer">  &lt;/logger&gt;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">  &lt;logger name="com.alibaba.example.demo" additivity="false"&gt;</span></code><code><span class="code-snippet_outer">    &lt;level value="info"/&gt;</span></code><code><span class="code-snippet_outer">    &lt;appender-ref ref="APPLICATION"/&gt;</span></code><code><span class="code-snippet_outer">  &lt;/logger&gt;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">  &lt;root level="error"&gt;</span></code><code><span class="code-snippet_outer">    &lt;appender-ref ref="APPLICATION" /&gt;</span></code><code><span class="code-snippet_outer">  &lt;/root&gt;</span></code><code><span class="code-snippet_outer">&lt;/configuration&gt;</span></code></pre></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">使用 SizeAndTimeBasedRollingPolicy 使日志可以根据大小和日期进行滚动</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">日志编码请使用 UTF-8</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">请正确使用日志级别，不要统统输出 error</span></p></li></ol><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_10"></span><h3 style="margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;color: rgb(0, 17, 255);">日志级别根据不同环境可配</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><br></span></section><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><section style="margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">如果是 Pandora-boot 或 spring-boot 可以直接在配置里使用 property 读取 application.properties，application.properties 在不同环境下使用-Dspring.profiles.active 进行切换</span></section></li><li><section style="margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">普通应用和 WAR 应用：请使用 autoconfig-maven-plugin 插件</span></section></li></ol><p style="margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><section style="margin-bottom: 0px;outline: 0px;box-sizing: inherit;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgba(25, 26, 31, 0.9);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 16px;text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;font-size: 15px;letter-spacing: 1px;visibility: visible;"><img class="rich_pages wxw-img" data-imgfileid="503043470" data-ratio="0.3056872037914692" data-s="300,640" src="https://oscimg.oschina.net/oscnet/d505aed3-373e-4e4c-9bdf-c54a4361a176.png" data-type="png" data-w="422" style="outline: 0px;color: rgb(34, 34, 34);font-family: system-ui, -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;visibility: visible !important;width: 117px !important;" referrerpolicy="no-referrer"></span></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(34, 34, 34);text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;visibility: visible;color: rgb(0, 17, 255);">一些实用的日志技巧</span></section><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;text-wrap: wrap;outline: 0px;letter-spacing: 0.544px;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><br></h4><span id="OSC_h4_11"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;text-wrap: wrap;outline: 0px;letter-spacing: 0.544px;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">动态修改日志级别</span></strong></span></h4><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">场景：应用在运行中，默认日志配置的打印级别是 error，但是我现在想针对某个包或者某个类输出下 info 日志。</span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">使用 Arthas：https://arthas.aliyun.com/doc/logger.html，该工具提供了动态修改日志的能力。</span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><br></span></p><span id="OSC_h4_12"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;text-wrap: wrap;outline: 0px;letter-spacing: 0.544px;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">追加业务信息到日志中，并格式化输出：追加 MDC 信息，方便排查问题</span></strong></span></h4><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">这是日志系统的一个扩容能力，可以把一些额外的信息输出到日志里，只需要在 MDC 上下文中写入 kv，https://logback.qos.ch/manual/mdc.html</span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">例如：</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer">public static void main(String[] args) {</span></code><code><span class="code-snippet_outer">    //代码里使用 MDC.put 写入 key 为 traceId 的值</span></code><code><span class="code-snippet_outer">    //在 logback.xml 里就可以使用%X{traceId}进行输出</span></code><code><span class="code-snippet_outer">    MDC.put("traceId", UUID.randomUUID().toString().replace("-", ""));</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><img class="rich_pages wxw-img" data-backh="161" data-backw="578" data-imgfileid="503043471" data-ratio="0.27870370370370373" src="https://oscimg.oschina.net/oscnet/3c0552bd-d751-47e9-8cab-83c2b8ae17ff.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></span></p><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(0, 0, 0);font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><br></span></strong></span></section><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(0, 0, 0);font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><ne-clipboard source="https%3A%2F%2Faliyuque.antfin.com%2Fwien.wuh%2Fdoc%2Fctdtsgv6r0esyll2%3FsingleDoc%23"></ne-clipboard></span></strong></span></section><span id="OSC_h4_13"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;text-wrap: wrap;outline: 0px;letter-spacing: 0.544px;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">配置定时日志磁盘占用清理</span></strong></span></h4><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">一定要配置合理的日志清理策略，避免磁盘被打爆，可借助日志框架自身能力，或借助可用的日志清理系统（如果有）</span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">在 logback.xml 配置中，可通过配置带有清理作用的 rollingPolicy 来完成日志定时清理和滚动，例如：SizeAndTimeBasedRollingPolicy</span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><br></span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;text-align: center;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><img class="rich_pages wxw-img" data-backh="102" data-backw="578" data-imgfileid="503043472" data-ratio="0.17696629213483145" src="https://oscimg.oschina.net/oscnet/c3b9e350-4cbb-45ca-aca4-6eb411ca0024.png" data-type="png" data-w="712" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></span></p><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><ne-clipboard data="%7B%22type%22%3A%22fragment%22%2C%22name%22%3A%22%23fragment%22%2C%22children%22%3A%5B%7B%22type%22%3A%22element%22%2C%22id%22%3A%22u87788482%22%2C%22name%22%3A%22p%22%2C%22attrs%22%3A%7B%7D%2C%22children%22%3A%5B%7B%22type%22%3A%22text%22%2C%22id%22%3A%22u6f1d679a%22%2C%22name%22%3A%22%23text%22%2C%22attrs%22%3A%7B%7D%2C%22data%22%3A%22%E8%BF%99%E6%AE%B5%E9%85%8D%E7%BD%AE%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%EF%BC%9A%E6%9C%80%E5%A4%9A%E4%BF%9D%E7%95%997%E5%A4%A9%EF%BC%8C%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E6%9C%80%E5%A4%A750MB%EF%BC%8C%E8%AF%A5%E6%97%A5%E5%BF%97%EF%BC%88%E5%8C%85%E6%8B%AC%E6%BB%9A%E5%8A%A8%E7%9A%84%EF%BC%89%E6%9C%80%E5%A4%A7%E5%8F%AA%E8%83%BD%E4%BF%9D%E5%AD%9820GB%22%7D%5D%7D%5D%2C%22attrs%22%3A%7B%7D%7D" source="https%3A%2F%2Faliyuque.antfin.com%2Fwien.wuh%2Fdoc%2Fctdtsgv6r0esyll2%3FsingleDoc%23"></ne-clipboard></section><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">这段配置的含义是：最多保留 7 天，单个文件最大 50MB，该日志（包括滚动的）最大只能保存 20GB。</span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><span id="OSC_h4_14"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 8px;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">不要封装一个日志 Util，而应该直接使用日志框架进行输出</span></strong></span></h4><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">反例：LogUtil.log("通过封装的日志工具打印日志");</span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">正例：log.info("直接使用日志框架的 api 进行日志输出");</span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">理由：在日志输出的时候，日志系统会打印日志产生的原始位置：比如哪个包的哪个类，以及第几行（如果配置了[%L]），如果你使用 LogUtil 等自己封装的工具，所有的日志输出打印的位置都是 LogUtil 的，这样不便于做日志问题定位</span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><br></span></p><p style="outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-align: center;text-wrap: wrap;visibility: visible;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);margin-top: 0px;margin-bottom: 0px;line-height: normal;"><img class="rich_pages wxw-img" data-imgfileid="503043473" data-ratio="0.3056872037914692" data-s="300,640" src="https://oscimg.oschina.net/oscnet/4d8c460d-e798-4e4f-a210-dc88203b75da.png" data-type="png" data-w="422" style="outline: 0px;letter-spacing: 0.544px;font-size: 14px;visibility: visible !important;width: 117px !important;" referrerpolicy="no-referrer"></p><p style="outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-align: center;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(100, 99, 99);font-size: 15px;margin-top: 0px;margin-bottom: 0px;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;color: rgb(0, 17, 255);letter-spacing: 1px;">系统日志打不出来或者丢日志排查思路</span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 1px;"></span><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">目前没有现成的工具帮你一键做好这个事情，下面给出一个排查思路</span></p><ol class="list-paddingleft-1" style="padding-left: 23px;"><li style="font-size: 15px;letter-spacing: 1px;"><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">先明确该系统到底使用的是什么日志框架+日志系统组合，这个很重要，必须搞清是何种组合才可有针对性的处理后续步骤</span></p></li><li style="font-size: 15px;letter-spacing: 1px;"><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">如果是 slf4j+logback 组合，则可根据第一章列出的 maven 依赖进行排包处理，优先保证依赖的包没有错误，90% 的情况下都是包依赖混乱导致的日志丢失</span></p></li><li style="font-size: 15px;letter-spacing: 1px;"><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">排查自己的 logback 配置文件是否放在正确的路径下、文件名是否正确，配置文件位置不对也会导致日志输出的不对甚至丢失</span></p></li><li style="font-size: 15px;letter-spacing: 1px;"><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">检查 logback 配置文件内部每个<span style="font-size: 15px;color: rgb(8, 8, 8);background-color: rgb(255, 255, 255);">logger 及其 level 配置是否正确，避免自己期望打印 info，却配置了 error</span></span></p></li></ol><section style="margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><br></span></section><section style="margin-bottom: 0px;outline: 0px;color: rgb(34, 34, 34);font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;text-align: center;line-height: normal;"><img class="rich_pages wxw-img" data-imgfileid="503043474" data-ratio="0.328125" data-s="300,640" src="https://oscimg.oschina.net/oscnet/41904b3a-eab4-4322-962a-be059bc4bfe2.png" data-type="png" data-w="256" style="outline: 0px;letter-spacing: 0.544px;font-size: 16px;visibility: visible !important;width: 122px !important;" referrerpolicy="no-referrer"></section><section style="margin-bottom: 0px;outline: 0px;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;color: rgb(100, 99, 99);text-align: center;line-height: normal;"><span style="outline: 0px;color: rgb(0, 17, 255);font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;">总结</span></section><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><ne-clipboard source="https%3A%2F%2Faliyuque.antfin.com%2Fwien.wuh%2Fdoc%2Fctdtsgv6r0esyll2%3FsingleDoc%23"></ne-clipboard></section><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">日志系统的正确使用，对于应用的日常维护和问题排查尤为重要，所谓：工欲善其事，必先利其器。本篇文章重点讲解了日志系统的结构和包如何正确依赖，这是很多同学最容易犯的错误，需要格外注意并认真阅读，只有正确理解其中的含义才可以更好的使用日志系统，在日常使用中大家要不断总结经验。</span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><br></span></p><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">最后希望文章提供的内容能够在日常开发和维护中为大家提供到切实的帮助。</span></p><section style="margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><p style="margin-bottom: 0px;outline: 0px;text-wrap: wrap;background-color: rgb(255, 255, 255);font-size: 11pt;font-family: DengXian;color: rgb(0, 0, 0);letter-spacing: normal;text-align: center;line-height: normal;"><img class="rich_pages wxw-img" data-imgfileid="503043475" data-ratio="0.328125" data-s="300,640" src="https://oscimg.oschina.net/oscnet/5b5ef821-c6ac-468b-8ebb-15a9d4bb271e.png" data-type="png" data-w="256" style="outline: 0px;font-size: 14.6667px;text-align: center;text-wrap: wrap;color: rgb(34, 34, 34);font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;visibility: visible !important;width: 133px !important;" referrerpolicy="no-referrer"></p><p style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);line-height: 1.75em;text-align: center;"><span style="outline: 0px;box-sizing: inherit;color: rgb(0, 17, 255);font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;">团队介绍</span></p><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="box-sizing: inherit;color: rgb(0, 0, 0);font-size: 15px;letter-spacing: 1px;">物流技术团队是服务淘天物流部及零售行业的产技团队，一直深耕在物流及供应链的数字化协同与运营领域：为零售业务提供灵活多样的经营模式管理方案及可以快速适配市场变化的经营策略数宇化管理工具；为商家提供高效低成本的物流及供应链解决方案，加快资金效率，提升协同效率；为消费者提供即时便捷的购物体验。</span></section><p><br></p><section data-role="outer" label="Powered by 135editor.com" style="margin-bottom: 0px;outline: 0px;letter-spacing: 0.544px;visibility: visible;"><section style="margin-top: 5px;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;font-size: 16px;word-break: break-all;color: rgb(0, 0, 0);font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;text-align: center;line-height: 1.75em;"><span style="outline: 0px;color: rgb(0, 17, 255);"><strong style="outline: 0px;">¤</strong></span><span style="outline: 0px;"><strong style="outline: 0px;">&nbsp;拓展阅读&nbsp;</strong></span><span style="outline: 0px;color: rgb(0, 17, 255);"><strong style="outline: 0px;">¤</strong></span></section><section style="margin-top: 5px;margin-bottom: 5px;outline: 0px;letter-spacing: 0.544px;font-size: 16px;word-break: break-all;color: rgb(0, 0, 0);font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;text-align: center;line-height: 1.75em;"><br style="outline: 0px;"></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;min-height: 24px;clear: both;visibility: visible;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D2565944923443904512%23wechat_redirect" textvalue="3DXR 技术" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">3DXR 技术</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1533906991218294785%23wechat_redirect" textvalue="终端技术" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">终端技术</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1592015847500414978%23wechat_redirect" textvalue="音视频技术" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">音视频技术</a></section><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;visibility: visible;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1539610690070642689%23wechat_redirect" textvalue="服务端技术" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">服务端技术</a><span style="outline: 0px;letter-spacing: 0.544px;">&nbsp;|&nbsp;</span><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D2565883875634397185%23wechat_redirect" textvalue="技术质量" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">技术质量</a>&nbsp;|&nbsp;<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1522425612282494977%23wechat_redirect" textvalue="数据算法" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">数据算法</a></p><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;visibility: visible;"><br style="outline: 0px;"></p><section class="mp_profile_iframe_wrp" style="margin-bottom: 24px;outline: 0px;"><mp-common-profile class="custom_select_card mp_profile_iframe js_wx_tap_highlight" data-pluginname="mpprofile" data-id="MzAxNDEwNjk5OQ==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/33P2FdAnju8t5nZGhAatCrc4e2iaDfAaoInribRKxc7MOqdTGygfcLqSDxhj0trCHVEh94Sjl7zuWYzwouYtJ0VQ/300?wx_fmt=png&amp;wxfrom=19" data-nickname="大淘宝技术" data-alias="AlibabaMTT" data-signature="大淘宝技术官方账号" data-from="2" data-index="0" data-origin_num="690" data-isban="0" data-biz_account_status="0" data-weui-theme="light" data-is_biz_ban="0"></mp-common-profile></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - 大淘宝技术（AlibabaMTT）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 01 Feb 2024 03:15:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4662964/blog/10946665</guid>
            <link>https://my.oschina.net/u/4662964/blog/10946665</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[网易首款鸿蒙原生游戏《倩女幽魂》手游完成开发，商业化版本已就绪]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">在 2023 年 12 月 15 日，网易游戏正式宣布启动基于 HarmonyOS NEXT 鸿蒙原生应用开发。目前，作为网易首款鸿蒙原生游戏，《倩女幽魂》不但完成了鸿蒙原生应用开发，且商业化版本已就绪。</span></p><p><img height="332" src="https://oscimg.oschina.net/oscnet/up-3f58a6b7c512c796452e424815d7ea46203.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">在华为游戏中心和网易中台的深度合作下，基于 HarmonyOS SDK 在应用框架层面覆盖 ArkTS、进程间通讯、数据管理等方面的底层基础能力，《倩女幽魂》鸿蒙原生应用的开发得以更加简单和高效。同时，《倩女幽魂》开发团队快速完成了账号登录、消息推送以及应用内支付等一系列 HarmonyOS SDK 应用服务领域的集成，充分利用能力下沉 OS 底层的优势，快速完成基础服务的开发上线，为商业化版本上线做好充足准备。</span></p><p><span style="color:#000000">《倩女幽魂》鸿蒙原生应用商业化版本的就绪，也意味着由网易中台提供的账号登录、消息推送及应用内支付等 UniSDK 核心部分已支持 HarmonyOS，不但有助于网易游戏更高效地完成更多鸿蒙原生游戏开发与最终上架，更是鸿蒙生态游戏建设前进的重要一步。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">早在华为开发者大会上，网易雷火事业群技术副总裁卢小军宣布，在网易游戏和华为游戏中心联合调优下，《倩女幽魂》已率先完成在主体渲染和逻辑打通，基于 HarmonyOS 及其方舟图形引擎，双方不但仅花费三周时间就完成了完整游戏逻辑的移植工作，而且整体渲染性能实现明显提升，画面更清晰、柔和，此外，还完成了帧数提升的同时降低功耗的性能调优，游戏画面单帧的功耗下降了 13%。给用户带来更畅快持久的游戏体验。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">公告称，本次《倩女幽魂》鸿蒙原生应用商业化版本的就绪，可以看出网易与华为游戏中心在技术应用和商业化层面更深入的鸿蒙生态合作，将进一步丰富鸿蒙生态下的游戏品类与内容，也将通过鸿蒙为游戏精品化发展和长线运营注入新活力，带给用户更沉浸和多元的游戏体验。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 01 Feb 2024 03:13:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277223</guid>
            <link>https://www.oschina.net/news/277223</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[开源日报：IntelliJ 负责人成为 JetBrains 新任 CEO，技术栈一定要选择开源的]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">欢迎阅读 OSCHINA 编辑部出品的开源日报，每天更新一期。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong># 2024.1.31&nbsp;</strong></p><h2 style="margin-left:0; margin-right:0; text-align:left"><span><span><span style="color:#000000"><span><span><span style="color:#00b050">今日要点</span></span></span></span></span></span></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify"><strong>OpenSource Daily</strong></p><h3 style="margin-left:0; margin-right:0; text-align:left"><u><a href="https://www.oschina.net/news/277037/urllib3-works-in-the-browser" target="news">Python HTTP 库 urllib3 支持直接在浏览器运行</a></u></h3><p><span style="background-color:#ffffff; color:#333333">Python HTTP 库 urllib3 最新版本 2.2.0 新增了一项重磅特性 ——<span>&nbsp;</span></span><strong style="color:#333333">可直接在浏览器运行</strong><span style="background-color:#ffffff; color:#333333">。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Furllib3.readthedocs.io%2Fen%2Fstable%2Freference%2Fcontrib%2Femscripten.html" target="_blank">根据介绍</a>，从 2.2.0 开始，urllib3 支持在 Pyodide 运行时中使用<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFetch_API" target="_blank">JavaScript fetch API</a>，或者在 fetch API 不可用时（例如当跨源隔离未激活时）返回<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest" target="_blank">XMLHttpRequest</a>。这意味着开发者可以使用该库直接从浏览器发出 HTTP 请求。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">由于 urllib3 的 Emscripten 支持与 API 兼容，这意味着依赖于 urllib3 的库现在也可以在 Emscripten 和 Pyodide 环境中使用。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img height="185" src="https://oscimg.oschina.net/oscnet/up-7e0846ecd450824c3e2a7cea0f00651c22c.png" width="500" referrerpolicy="no-referrer"></p><h3 style="margin-left:0; margin-right:0; text-align:left"><u><a href="https://www.oschina.net/news/277020" target="_blank">Opera 将推出全球首款非 WebKit 内核的 iOS 浏览器</a></u></h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">昆仑万维旗下海外信息分发与元宇宙平台 Opera 近日宣布，将为欧洲的 iPhone 和 iPad 用户带来一款基于自研引擎的全新 AI 浏览器 「Opera One」。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">Opera 计划于 3 月份首次亮相这款新浏览器，届时 DMA（欧洲数字市场法案）将生效。由于这些变化仅在欧盟实施，Opera 强烈鼓励苹果将这些增强功能推广至全球 iOS 用户。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">为了遵守 DMA，苹果决定允许开发者提交非基于 WebKit 的浏览器，包括 Web 浏览器应用和在 iOS 应用中显示网页的应用内浏览器。Opera 表示，这些变化将使他们有机会为 iPhone 用户提供 Safari 之外的人工智能浏览器。</p><h3 style="margin-left:0; margin-right:0; text-align:left"><u><a href="https://www.oschina.net/news/277057/jetbrains-ceo-transition" target="_blank">IntelliJ 负责人 Kirill Skrygan 成为 JetBrains 新任 CEO</a></u></h3><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="background-color:#ffffff; color:#333333">JetBrains 公司正式对外宣布了最新人事任命：原负责领导 IntelliJ 部门的 Kirill Skrygan&nbsp;将于 2024 年 2 月 1 日起担任首席执行官。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">JetBrains 在公告写道：「在我们迈向人工智能发挥变革作用的新时代之际，公司已经建立了一个良好的底层基础，并且可以在此基础上继续推动公司向前发展。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">作为新阶段的一部分，Kirill Skrygan 自 2010 年加入 JetBrains，并在过去几年里一直领导 IntelliJ 部门，他将于 2024 年 2 月 1 日担任首席执行官一职。」</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img height="330" src="https://oscimg.oschina.net/oscnet/up-3943b858bab2621d791912e56f8421bca6a.png" width="500" referrerpolicy="no-referrer"></p><hr><h2 style="margin-left:0; margin-right:0; text-align:left"><strong><span><span><span style="color:#000000"><span><span><span style="color:#00b050">用户观点</span></span></span></span></span></span></strong></h2><p><img height="268" src="https://oscimg.oschina.net/oscnet/up-49e5260aa056b39c3b23ab565653c575979.png" width="500" referrerpolicy="no-referrer"></p><hr><h3 style="margin-left:0; margin-right:0; text-align:left"><strong><span><span><span style="color:#000000"><span><span><span style="color:#00b050">媒体观点</span></span></span></span></span></span></strong></h3><h3 style="margin-left:0; margin-right:0; text-align:left"><img height="347" src="https://oscimg.oschina.net/oscnet/up-821e56c877d00d921add32f98bb57e78fa2.png" width="500" referrerpolicy="no-referrer"></h3><hr><h2 style="margin-left:0; margin-right:0; text-align:left"><strong><span><span><span style="color:#000000"><span><span><span style="color:#00b050">每日项目榜</span></span></span></span></span></span></strong></h2><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">GitHub 榜单：</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img height="312" src="https://oscimg.oschina.net/oscnet/up-10344e3be6272f1f3919d9779566cb59e8b.png" width="300" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img height="370" src="https://oscimg.oschina.net/oscnet/up-0c63d879e7c4cb3446298dd6574d33f490b.png" width="300" referrerpolicy="no-referrer"></p><blockquote><h4 style="margin-left:0; margin-right:0">在线阅读完整日报内容，访问：<strong><u><a href="https://oscimg.oschina.net/public_shard/%E5%BC%80%E6%BA%90%E6%97%A5%E6%8A%A5%E7%AC%AC006%E6%9C%9F%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8A%80%E6%9C%AF%E6%A0%88%E4%B8%80%E5%AE%9A%E8%A6%81%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E7%9A%84.pdf" target="_blank">开源日报第 006 期：选择技术栈一定要选择开源的</a></u></strong></h4></blockquote><hr><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong>往期回顾</strong></p><ul style="list-style-type:disc; margin-left:0; margin-right:0"><li><a href="http://www.oschina.net/news/277040"><u>开源日报第 005 期：RISC-V 万兆开源交换机发售；npm 存在大量武林外传视频</u></a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 01 Feb 2024 02:39:29 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/277214</guid>
            <link>https://www.oschina.net/news/277214</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
