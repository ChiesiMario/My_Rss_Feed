<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Sun, 14 Jan 2024 23:23:45 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[2024 技术招聘状况：AI 工具被视为作弊，Python 需求最大]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">技术招聘平台 CoderPad 最新发布了一份「<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcoderpad.io%2Fsurvey-reports%2Fcoderpad-and-codingame-state-of-tech-hiring-2024%2F" target="_blank">State of Tech Hiring 2024</a>」报告，基于来自 149 个不同国家/地区的 13,000 多名开发者、以及 143 个国家/地区约 5500 名 HR 人员的反馈。研究了开发人员对工作的期望和需求、技术招聘流程的演变以及 2024 年开发人员招聘优先事项和潜在障碍。</span></p><p><span style="color:#000000">报告指出，70% 的开发人员认为 AI 将有助于减少他们的工作量，并列举了一些好处：代码辅助、学习和教程、自动完成/代码生成以及文档和 API 支持等。ChatGPT 是最常用的 AI 工具，其他的还包括 Copilot、Bard、Bing AI 等。60% 的开发人员希望在工作中更多地使用 AI。</span></p><p><span style="color:#000000">但也有 33% 的受访开发人员表示在工作中不使用任何 AI 工具：其中 29% 是因为本人不信任该技术，28% 的是因为雇主反对；四分之一的开发人员认为 AI 不可靠或效率低下。43% 的受访者表示对 AI 所带来的影响持乐观态度；23% 的人持怀疑态度，还有 6% 甚至担心这项技术会影响其职业或工作前景。</span></p><p><span style="color:#000000">值得一提的是，尽管有 67% 的开发者和 38% 的 HR 表示已经在工作中使用了 AI 工具，但对于招聘过程中 AI 工具的使用却还存在一些争议。近四分之一（23%）的 HR 认为面试者使用 AI 工具属于作弊。只有 8% 的公司鼓励在招聘过程中使用 AI，48% 的受访者表示它的可接受性取决于使用情况。</span></p><p><span style="color:#000000">只有 19% 的开发人员会在招聘过程中公开使用 AI，还有三分之一的开发人员认为在面试或技术测试中使用 AI 工具是一种作弊行为。</span></p><p><span style="color:#000000">在被问及知名度以及招聘中需求最高的<strong>编程语言</strong>时，排名前十的分别是：Python、JavaScript、Java、C#、SQL、C++、TypeScript、HTML CSS、PHP、C。知名度和需求最高的框架则是 React 和 Node.js。</span></p><p><img height="1112" src="https://oscimg.oschina.net/oscnet/up-159c837d701bf90f73a6c17dbfc39c4cf78.png" width="500" referrerpolicy="no-referrer"></p><p>其他的一些发现还包括：</p><ul><li><span style="color:#000000">36% 的开发人员表示对承担管理职责不感兴趣。</span></li><li><span style="color:#000000">开发人员还希望有机会在工作中磨练自己的技术技能，其中最想学习的三项技能分别是 Web 开发、机器学习/深度学习和游戏开发。</span></li><li><span style="color:#000000">全栈、后端和前端开发人员仍然是需求最大的岗位。此外，还有 21% 的组织希望在 2024 年聘请 ML/AI 专家，去年的这一比例为 18%。</span></li><li><span style="color:#000000">开发人员对工作安全的担忧与日俱增，21% 的人表示，与一年前相比，他们的工作安全感降低了（去年为 17%）。37% 的人表示在过去 12 个月中没有明显变化，32% 的人表示感觉更有安全感。</span></li><li><span style="color:#000000">近一半的开发人员考虑在未来 12 个月内离职。</span></li></ul><p><span style="color:#000000">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcoderpad.io%2Fsurvey-reports%2Fcoderpad-and-codingame-state-of-tech-hiring-2024%2F" target="_blank">查看完整报告</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 14 Jan 2024 03:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275663/state-of-tech-hiring-2024</guid>
            <link>https://www.oschina.net/news/275663/state-of-tech-hiring-2024</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Git 开发人员讨论引入 Rust 的可能性]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Git 开发人员正讨论在其代码库中使用 Rust 编程语言，以补充现有的 C 和 Python 语言的想法。</p><blockquote><p>去年年底的假期我花了一些时间思考如何将 Rust 引入 Git 项目。</p><p>将 Rust 引入 Linux 内核的工作正在紧锣密鼓地进行中（见 [1]、[2]）。在他们既定的目标中，我认为有几个这可能与 Git 项目潜在相关：</p><ul><li>降低内存安全错误、数据争用、内存泄漏等风险。 得益于该语言的安全保证。</li><li>在 Rust 中重构或引入新代码时更容易（假设几乎不使用语言的「不安全」功能）。</li><li>通过使用更现代的语言，为 Git 做贡献变得更容易，也更容易为更多程序员所使用。</li></ul><p>鉴于这些优势的诱惑力，我认为至少值得考虑和讨论如何让 Rust 进入 Junio 的树中。</p></blockquote><p><img height="296" src="https://oscimg.oschina.net/oscnet/up-89b0fcaa21f05d837885d3b9e645f5dcb9c.png" width="300" referrerpolicy="no-referrer"></p><p>然而，虽然 Rust 的内存安全特性对许多人来说是个利好，但 Git 开发者的反应却好坏参半。部分<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FGCC-Rust-Developer-Discussion" target="_blank">原因是</a> Git 广泛应用于多种不同的平台和 CPU 架构。目前，使用 Rust 几乎必须使用基于 LLVM 的 rustc 编译器。虽然 GCC 编译器等正在努力添加可用的 Rust 支持，但目前这些替代方案还没有投入生产。因此，如果 Rust 代码被强制使用，Git 的使用可能会受到限制，否则他们可能不得不在初期将基于 Rust 的 Git 功能作为可选项。&nbsp;</p><p>更多详情可以通过此<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Fgit%2FCALNs47s3tUQoOD4ejdoTn6y12ywjL0j5hWU-fUnBLe_o3vV5SQ%40mail.gmail.com%2FT%2F" target="_blank">邮件列表线程</a>进行了解。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 14 Jan 2024 03:18:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275659/git-rust-discussion</guid>
            <link>https://www.oschina.net/news/275659/git-rust-discussion</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Motūrus OS —— 适用于 x64 虚拟机的 Rust 优先操作系统]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Motūrus 项目为云构建了一个简单、快速、安全的操作系统（Motūrus OS）。</p><p>更具体地说，Motūrus OS（有时也称作 Motor OS）是一种新的操作系统，针对基于虚拟机的工作负载，如网络服务、"无服务器"、边缘缓存等。</p><p>Motūrus OS 是基于 Rust 的微内核操作系统，专门针对虚拟化工作负载。它目前支持基于 x64 KVM 的虚拟机，可在 Qemu 或 Cloud Hypervisor 中运行。</p><p><img alt="" height="559" src="https://static.oschina.net/uploads/space/2024/0108/153945_gPrH_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Sun, 14 Jan 2024 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/motor-os</guid>
            <link>https://www.oschina.net/p/motor-os</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 捕获数据更改 (CDC) 平台 Debezium]]>
            </title>
            <description>
                <![CDATA[<p><a href="https://gitee.com/link?target=http%3A%2F%2Fwww.apache.org%2Flicenses%2FLICENSE-2.0.html"><img src="http://img.shields.io/:license-apache%202.0-brightgreen.svg" alt="License" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=http%3A%2F%2Fsearch.maven.org%2F%23search%257Cga%257C1%257Cg%253A%2522io.debezium%2522"><img src="https://maven-badges.herokuapp.com/maven-central/io.debezium/debezium-parent/badge.svg" alt="Maven Central" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdebezium.zulipchat.com%2F%23narrow%2Fstream%2F302529-users"><img src="https://img.shields.io/badge/chat-users-brightgreen.svg" alt="User chat" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdebezium.zulipchat.com%2F%23narrow%2Fstream%2F302533-dev"><img src="https://img.shields.io/badge/chat-devs-brightgreen.svg" alt="Developer chat" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgroups.google.com%2Fforum%2F%23%21forum%2Fdebezium"><img src="https://img.shields.io/:mailing%20list-debezium-brightgreen.svg" alt="Google Group" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=http%3A%2F%2Fstackoverflow.com%2Fquestions%2Ftagged%2Fdebezium"><img src="http://img.shields.io/:stack%20overflow-debezium-brightgreen.svg" alt="Stack Overflow" referrerpolicy="no-referrer"></a></p><p>Copyright Debezium Authors.
Licensed under the <a href="https://gitee.com/link?target=http%3A%2F%2Fwww.apache.org%2Flicenses%2FLICENSE-2.0">Apache License, Version 2.0</a>.
The Antlr grammars within the debezium-ddl-parser module are licensed under the <a href="https://gitee.com/link?target=https%3A%2F%2Fopensource.org%2Flicenses%2FMIT">MIT License</a>.</p><p>中文 | <a href="https://gitee.com/opengauss/debezium/blob/master/README.md">English</a> | <a href="https://gitee.com/opengauss/debezium/blob/master/README_JA.md">Japanese</a></p><h1><a id="user-content-debezium-简介" class="anchor" href="https://gitee.com/opengauss/debezium#debezium-%E7%AE%80%E4%BB%8B"></a>Debezium 简介</h1><p>Debezium 是一个开源项目，为捕获数据更改 (change data capture,CDC) 提供了一个低延迟的流式处理平台。你可以安装并且配置 Debezium 去监控你的数据库，然后你的应用就可以消费对数据库的每一个行级别 (row-level) 的更改。只有已提交的更改才是可见的，所以你的应用不用担心事务 (transaction) 或者更改被回滚 (roll back)。Debezium 为所有的数据库更改事件提供了一个统一的模型，所以你的应用不用担心每一种数据库管理系统的错综复杂性。另外，由于 Debezium 用持久化的、有副本备份的日志来记录数据库数据变化的历史，因此，你的应用可以随时停止再重启，而不会错过它停止运行时发生的事件，保证了所有的事件都能被正确地、完全地处理掉。</p><p>监控数据库，并且在数据变动的时候获得通知一直是很复杂的事情。关系型数据库的触发器可以做到，但是只对特定的数据库有效，而且通常只能更新数据库内的状态 (无法和外部的进程通信)。一些数据库提供了监控数据变动的 API 或者框架，但是没有一个标准，每种数据库的实现方式都是不同的，并且需要大量特定的知识和理解特定的代码才能运用。确保以相同的顺序查看和处理所有更改，同时最小化影响数据库仍然非常具有挑战性。</p><p>Debezium 提供了模块为你做这些复杂的工作。一些模块是通用的，并且能够适用多种数据库管理系统，但在功能和性能方面仍有一些限制。另一些模块是为特定的数据库管理系统定制的，所以他们通常可以更多地利用数据库系统本身的特性来提供更多功能。</p><h2><a id="user-content-debezium 基础架构" class="anchor" href="https://gitee.com/opengauss/debezium#debezium%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"></a>Debezium 基础架构</h2><p>Debezium 是一个捕获数据更改 (CDC) 平台，并且利用 Kafka 和 Kafka Connect 实现了自己的持久性、可靠性和容错性。每一个部署在 Kafka Connect 分布式的、可扩展的、容错性的服务中的 connector 监控一个上游数据库服务器，捕获所有的数据库更改，然后记录到一个或者多个 Kafka topic(通常一个数据库表对应一个 kafka topic)。Kafka 确保所有这些数据更改事件都能够多副本并且总体上有序 (Kafka 只能保证一个 topic 的单个分区内有序)，这样，更多的客户端可以独立消费同样的数据更改事件而对上游数据库系统造成的影响降到很小 (如果 N 个应用都直接去监控数据库更改，对数据库的压力为 N，而用 debezium 汇报数据库更改事件到 kafka，所有的应用都去消费 kafka 中的消息，可以把对数据库的压力降到 1)。另外，客户端可以随时停止消费，然后重启，从上次停止消费的地方接着消费。每个客户端可以自行决定他们是否需要 exactly-once 或者 at-least-once 消息交付语义保证，并且所有的数据库或者表的更改事件是按照上游数据库发生的顺序被交付的。</p><p>对于不需要或者不想要这种容错级别、性能、可扩展性、可靠性的应用，他们可以使用内嵌的 Debezium connector 引擎来直接在应用内部运行 connector。这种应用仍需要消费数据库更改事件，但更希望 connector 直接传递给它，而不是持久化到 Kafka 里。</p><h2><a id="user-content-常见使用场景" class="anchor" href="https://gitee.com/opengauss/debezium#%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"></a>常见使用场景</h2><p>Debezium 有很多非常有价值的使用场景，我们在这儿仅仅列出几个更常见的使用场景。</p><h3><a id="user-content-缓存失效 cache-invalidation" class="anchor" href="https://gitee.com/opengauss/debezium#%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88cache-invalidation"></a>缓存失效 (Cache invalidation)</h3><p>在缓存中缓存的条目 (entry) 在源头被更改或者被删除的时候立即让缓存中的条目失效。如果缓存在一个独立的进程中运行 (例如 Redis，Memcache，Infinispan 或者其他的)，那么简单的缓存失效逻辑可以放在独立的进程或服务中，从而简化主应用的逻辑。在一些场景中，缓存失效逻辑可以更复杂一点，让它利用更改事件中的更新数据去更新缓存中受影响的条目。</p><h3><a id="user-content-简化单体应用 simplifying-monolithic-applications" class="anchor" href="https://gitee.com/opengauss/debezium#%E7%AE%80%E5%8C%96%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8simplifying-monolithic-applications"></a>简化单体应用 (Simplifying monolithic applications)</h3><p>许多应用更新数据库，然后在数据库中的更改被提交后，做一些额外的工作：更新搜索索引，更新缓存，发送通知，运行业务逻辑，等等。这种情况通常称为双写 (dual-writes)，因为应用没有在一个事务内写多个系统。这样不仅应用逻辑复杂难以维护，而且双写容易丢失数据或者在一些系统更新成功而另一些系统没有更新成功的时候造成不同系统之间的状态不一致。使用捕获更改数据技术 (change data capture,CDC)，在源数据库的数据更改提交后，这些额外的工作可以被放在独立的线程或者进程 (服务) 中完成。这种实现方式的容错性更好，不会丢失事件，容易扩展，并且更容易支持升级。</p><h3><a id="user-content-共享数据库 sharing-databases" class="anchor" href="https://gitee.com/opengauss/debezium#%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%BA%93sharing-databases"></a>共享数据库 (Sharing databases)</h3><p>当多个应用共用同一个数据库的时候，一个应用提交的更改通常要被另一个应用感知到。一种实现方式是使用消息总线，尽管非事务性 (non-transactional) 的消息总线总会受上面提到的双写 (dual-writes) 影响。但是，另一种实现方式，即 Debezium，变得很直接：每个应用可以直接监控数据库的更改，并且响应更改。</p><h3><a id="user-content-数据集成 data-integration" class="anchor" href="https://gitee.com/opengauss/debezium#%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90data-integration"></a>数据集成 (Data integration)</h3><p>数据通常被存储在多个地方，尤其是当数据被用于不同的目的的时候，会有不同的形式。保持多系统的同步是很有挑战性的，但是可以通过使用 Debezium 加上简单的事件处理逻辑来实现简单的 ETL 类型的解决方案。</p><h3><a id="user-content-命令查询职责分离 cqrs" class="anchor" href="https://gitee.com/opengauss/debezium#%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BBcqrs"></a>命令查询职责分离 (CQRS)</h3><p>在命令查询职责分离 <a href="https://gitee.com/link?target=http%3A%2F%2Fmartinfowler.com%2Fbliki%2FCQRS.html">Command Query Responsibility Separation (CQRS)</a> 架构模式中，更新数据使用了一种数据模型，读数据使用了一种或者多种数据模型。由于数据更改被记录在更新侧 (update-side)，这些更改将被处理以更新各种读展示。所以 CQRS 应用通常更复杂，尤其是他们需要保证可靠性和全序 (totally-ordered) 处理。Debezium 和 CDC 可以使这种方式更可行：写操作被正常记录，但是 Debezium 捕获数据更改，并且持久化到全序流里，然后供那些需要异步更新只读视图的服务消费。写侧 (write-side) 表可以表示面向领域的实体 (domain-oriented entities)，或者当 CQRS 和 <a href="https://gitee.com/link?target=http%3A%2F%2Fmartinfowler.com%2FeaaDev%2FEventSourcing.html">Event Sourcing</a> 结合的时候，写侧表仅仅用做追加操作命令事件的日志。</p><h2><a id="user-content-building-debezium" class="anchor" href="https://gitee.com/opengauss/debezium#building-debezium"></a>Building Debezium</h2><p>使用 Debezium 代码库并在本地配置它需要以下软件：</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgit-scm.com">Git</a> 2.2.1 or later</li><li>JDK 11 or later, e.g. <a href="https://gitee.com/link?target=http%3A%2F%2Fopenjdk.java.net%2Fprojects%2Fjdk%2F">OpenJDK</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fmaven.apache.org%2Findex.html">Apache Maven</a> 3.6.3 or later</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fdocs.docker.com%2Fengine%2Finstall%2F">Docker Engine</a> or <a href="https://gitee.com/link?target=https%3A%2F%2Fdocs.docker.com%2Fdesktop%2F">Docker Desktop</a> 1.9 or later</li></ul><p>有关平台上的安装说明，请参阅上面的链接。您可以通过以下指令查看安装版本</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ git --version</span><span id="LC2" class="line">$ javac -version</span><span id="LC3" class="line">$ mvn -version</span><span id="LC4" class="line">$ docker --version</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-为什么选用-docker" class="anchor" href="https://gitee.com/opengauss/debezium#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E7%94%A8-docker"></a>为什么选用 Docker?</h3><p>许多开源软件项目使用 Git、Java 和 Maven，但需要 Docker 的情况不太常见。Debezium 被设计用来与许多外部系统进行通信，比如各种数据库和服务，我们的集成测试验证了 Debezium 成功地做到了这一点。但 Debezium 的构建系统使用 Docker 自动下载或创建必要的映像，并为每个系统启动容器，而不是期望您在本地安装所有这些软件系统。然后，集成测试可以使用这些服务并验证 Debezium 的行为是否符合预期，当集成测试完成时，Debezium 将自动停止它启动的所有容器.</p><p>Debezium 还有一些不是用 Java 编写的模块，因此它们必须在目标操作系统上使用。Docker 让我们的构建使用目标操作系统的映像和所有必要的开发工具来完成。</p><p>使用 Docker 有几个优点：</p><ol><li>不需要在本地计算机上安装、配置和运行每个所依赖的外部服务的特定版本，也不必在本地网络上访问它们。即使配置了，Debezium 也不会用到它们。</li><li>我们可以测试外部服务的多个版本。每个模块可以启动它需要的任何容器，因此不同的模块可以轻松地使用不同版本的服务。</li><li>每个人都可以在本地运行完整的构建。 不必依赖远程持续集成服务器在设置了所有必需服务的环境中运行构建。</li><li>所有构建都是一致的。当多个开发人员各自构建相同的代码库时，他们应该看到完全相同的结果——只要他们使用相同或等效的 JDK、Maven 和 Docker 版本。这是因为容器将在相同的操作系统上运行相同版本的服务。另外，所有的测试都是为了连接到运行在容器中的系统而设计的，因此没有人需要修改连接属性或特定于其本地环境的自定义配置。</li><li>不需要清理服务, 即使这些服务在本地修改和存储数据. Docker <em>images</em> 被缓存, 所以 reusing 服务可以快速的启动容器并保持一致性, 但是 Docker <em>containers</em> 永远不会被重用：它们总是在原始的初始状态下启动，在关闭时被丢弃。集成测试依赖于容器，因此清理是自动处理的</li></ol><h3><a id="user-content-配置 docker 环境" class="anchor" href="https://gitee.com/opengauss/debezium#%E9%85%8D%E7%BD%AEdocker%E7%8E%AF%E5%A2%83"></a>配置 Docker 环境</h3><p>Docker Maven 插件通过检查以下环境变量来解析 Docker 主机：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">export DOCKER_HOST=tcp://10.1.2.2:2376</span><span id="LC2" class="line">export DOCKER_CERT_PATH=/path/to/cdk/.vagrant/machines/default/virtualbox/.docker</span><span id="LC3" class="line">export DOCKER_TLS_VERIFY=1</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>Docker 类似的容器可以自动配置这些参数。</p><h3><a id="user-content-项目编译" class="anchor" href="https://gitee.com/opengauss/debezium#%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91"></a>项目编译</h3><p>首先从 Git 存储库获取代码：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ git clone https://github.com/debezium/debezium.git</span><span id="LC2" class="line">$ cd debezium</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>用 maven 构建项目
$ mvn clean install</p><p>为不同的 dbms 使用不同的容器构建。请注意，如果 Docker 未运行或未配置，则可能会出现一个神秘的错误——如果是这种情况，请始终验证 Docker 是否正在运行，也许可以使用 Docker ps 列出正在运行的容器。</p><h3><a id="user-content-本地没有 docker" class="anchor" href="https://gitee.com/opengauss/debezium#%E6%9C%AC%E5%9C%B0%E6%B2%A1%E6%9C%89docker"></a>本地没有 Docker?</h3><p>您可以使用以下命令跳过集成测试和 docker 来构建项目：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ mvn clean install -DskipITs</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-使用 wal2json 或-pgoutput-logical-decoding-plug-ins-运行 postgres-connector 的测试" class="anchor" href="https://gitee.com/opengauss/debezium#%E4%BD%BF%E7%94%A8wal2json%E6%88%96-pgoutput-logical-decoding-plug-ins-%E8%BF%90%E8%A1%8Cpostgres-connector%E7%9A%84%E6%B5%8B%E8%AF%95"></a>使用 wal2json 或 pgoutput logical decoding plug-ins 运行 Postgres connector 的测试</h3><p>Postgres 连接器支持三个逻辑解码插件，用于从 DB 服务器到连接器的流式更改：decoderbufs（默认）、wal2json 和 pgoutput。要使用 wal2json 运行 PG connector 的集成测试，请启用「wal2json decoder」构建配置文件：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ mvn clean install -pl :debezium-connector-postgres -Pwal2json-decoder</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>要使用 pgoutput 运行 PG connector 的集成测试，请启用「pgoutput decoder」和「postgres-10」构建配置文件：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ mvn clean install -pl :debezium-connector-postgres -Ppgoutput-decoder,postgres-10</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>在使用 wal2json 插件时，一些测试目前无法通过。</p><p>查找对<code>io.debezium.connector.postgresql.DecoderDifferences</code>中定义的类型的引用以找到这些测试。</p><h3><a id="user-content-对外部数据库运行 postgres 连接器的测试-例如 amazon-rds" class="anchor" href="https://gitee.com/opengauss/debezium#%E5%AF%B9%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E8%A1%8Cpostgres%E8%BF%9E%E6%8E%A5%E5%99%A8%E7%9A%84%E6%B5%8B%E8%AF%95-%E4%BE%8B%E5%A6%82amazon-rds"></a>对外部数据库运行 Postgres 连接器的测试, 例如：Amazon RDS</h3><p>如果您要针对非 RDS 集群进行测试，请注意须是超级用户，不仅要具有复制权限，而且还要有登录 pg_hba.conf 中所有数据库的权限。它还要求目标服务器上必须有 <em>postgis</em> 包，才能通过某些测试。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ mvn clean install -pl debezium-connector-postgres -Pwal2json-decoder \</span><span id="LC2" class="line">     -Ddocker.skip.build=true -Ddocker.skip.run=true -Dpostgres.host=&lt;your PG host&gt; \</span><span id="LC3" class="line">     -Dpostgres.user=&lt;your user&gt; -Dpostgres.password=&lt;your password&gt; \</span><span id="LC4" class="line">     -Ddebezium.test.records.waittime=10</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>根据需要调整超时值。</p><p>有关在 RDS 上设置要测试的数据库的详细信息，请参阅 <a href="https://gitee.com/opengauss/debezium/blob/master/debezium-connector-postgres/RDS.md">PostgreSQL on Amazon RDS</a></p><h2><a id="user-content-贡献源码 contributing" class="anchor" href="https://gitee.com/opengauss/debezium#%E8%B4%A1%E7%8C%AE%E6%BA%90%E7%A0%81contributing"></a>贡献源码 (Contributing)</h2><p>Debezium 社区欢迎任何愿意以任何方式提供帮助的人，无论是报告问题、帮助文档，还是提供代码更改以修复错误、添加测试或实现新功能。有关详细信息，请参阅本<a href="https://gitee.com/opengauss/debezium/blob/master/CONTRIBUTE.md">文档</a>。</p>]]>
            </description>
            <pubDate>Sun, 14 Jan 2024 02:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/opengauss/debezium</guid>
            <link>https://gitee.com/opengauss/debezium</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 得物 SRE 视角下的蓝绿发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1>一、前言</h1><p style="color:#24292f; text-align:start">发布变更是影响稳定性的一个重大因素，为了发布异常时能快速回滚，增加发布期间的稳定性，也为了解决多服务部署时互相依赖而导致的发布时间增长等问题，得物在今年引入一种新的发布模式--蓝绿发布。这种发布模式带来了稳定性和效率的提升，这里我们以 SRE 的视角来解读下得物的蓝绿发布。</p><span id="OSC_h1_2"></span><h1>二、常见的发布形式有哪些？分别有什么优势？</h1><span id="OSC_h2_3"></span><h2>全量发布</h2><p style="color:#24292f; text-align:start">全量发布是早期企业进行系统升级的一种方式，因为早期的服务大多为大型机，单实例程序为主。并没有形成当下流行的微服务架构，因此当发布时往往需要停机发布。生产环境禁止使用这种方式进行部署！</p><span id="OSC_h2_4"></span><h2>滚动发布</h2><p style="color:#24292f; text-align:start">滚动发布顾名思义，假如生产中 16 台机器，我们可以分成 4 批。每批 4 台机器，每批机器执行更新，从版本 V1 更新为 V2，更新后重新将其投入使用，连续不断的更新其他机器，直到集群中所有的实例都更新为版本 B 后，结束发布。</p><p style="color:#24292f; text-align:start">这种方式的好处就是更新过程体验影响少，费用开销也少，发布期间无需额外新增机器。但是缺点也同样明显，一旦开始发布后，回滚时长很久，在多个有关联的服务部署时，需要上游服务完全发布后，才能发布下游服务，整体发布时间也很长。</p><p style="color:#24292f; text-align:start"><strong>滚动发布流程演示：</strong></p><p style="color:#24292f; text-align:start"><img alt="640.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/640.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><img alt="2.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/2.png" referrerpolicy="no-referrer"></p><span id="OSC_h2_5"></span><h2>蓝绿发布</h2><p style="color:#24292f; text-align:start">通常意义上的蓝绿发布一般是将服务分为两组，蓝组和绿组，正常运转的情况下每组承载 50% 的流量。当准备发布服务时, 将蓝组流量设置为 0%，将绿组空闲出来，将服务部署到绿组的机器，然后利用 SLB 将流量切换到绿组的机器，让绿组来运行业务，没问题的话流量全部导向绿组，把蓝组也进行服务更新。</p><p style="color:#24292f; text-align:start">传统意义上的蓝绿发布优点在于发布策略简单，对于用户几乎无感知，可以实现平滑过度，在发布期间发现问题后也可以快速的回滚。而缺点则是通常需要准备正常业务使资源俩倍以上的服务器，需要投入较大的资源成本。</p><p style="color:#24292f; text-align:start"><strong>蓝绿发布流程演示：</strong></p><p style="color:#24292f; text-align:start">切除绿集群流量：</p><p style="color:#24292f; text-align:start"><img alt="12.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/12.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">当 A 组升级完毕，负载均衡重新接入 A 组，再把 B 组从负载列表中摘除，进行新版本的部署，A 组重新提供服务。</p><p style="color:#24292f; text-align:start"><img alt="13.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/13.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">最后，B 组也升级完成，负载均衡重新接入 B 组，此时，AB 组版本都已经升级完成，并且都对外提供服务。</p><span id="OSC_h2_6"></span><h2>灰度发布</h2><p style="color:#24292f; text-align:start">灰度发布，也被叫作金丝雀发布。与蓝绿部署、红黑部署不同的是，<strong>灰度发布属于增量发布方法</strong>。也就是说，服务升级的过程中，新旧版本会同时为用户提供服务。</p><p style="color:#24292f; text-align:start">灰度发布的具体流程是这样的：在集群的一小部分机器上部署新版本，给一部分用户使用，以测试新版本的功能和性能；确认没有问题之后，再对整个集群进行升级。简单地说，灰度发布就是把部署好的服务分批次、逐步暴露给越来越多的用户，直到最终完全上线。</p><p style="color:#24292f; text-align:start"><img alt="23.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/23.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">之所以叫作<strong>灰度发布</strong>，是因为它介于黑与白之间，并不是版本之间的直接切换，而是一个平滑过渡的过程。</p><p style="color:#24292f; text-align:start">AB Test 就是一种灰度发布方式，让一部分用户继续用 A，一部分用户开始用 B，如果用户对 B 没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B 上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现并调整问题，以保证其影响度，而我们平常所说的金丝雀部署也就是灰度发布的一种方式。</p><p style="color:#24292f; text-align:start">之所以又被叫作金丝雀发布，是因为金丝雀对瓦斯极其敏感，17 世纪时英国矿井工人会携带金丝雀下井，以便及时发现危险。这就与灰色发布过程中，先发布给一部分用户来测试相似，因而得名。</p><p style="color:#24292f; text-align:start"><img alt="0.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/0.jpeg" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">对于灰度发布来说，它的优点在于<span>&nbsp;</span><strong>如果前期出问题影响范围很小，相对用户体验也少；可以做到及时发现、及时调整问题，影响范围可控。</strong><span>&nbsp;</span>但是采取这种模式对自动化以及运维监控能力的要求非常高。</p><span id="OSC_h1_7"></span><h1>三、得物的蓝绿布是如何实现的？</h1><p style="color:#24292f; text-align:start">前面讲了「what」，我们现在来说下「how」。</p><p style="color:#24292f; text-align:start">在平时，我们也会保留蓝绿两个集群，在发布时，引入灰度的流量平滑过度，帮助我们完成整个发布过程，下面以 SRE 的视角大致讲一下蓝绿发布的架构与流程。</p><span id="OSC_h2_8"></span><h2>蓝绿发布的流程</h2><p style="color:#24292f; text-align:start">在这种架构下，整体的发布流程如下：</p><ul><li><strong>日常流量</strong></li></ul><p style="color:#24292f; text-align:start">在未发布时，我们接入蓝绿发布的服务是平均分成蓝绿俩个集群的。平时通过网关均匀切分流量，平均每个集群 50% 的流量。</p><p style="color:#24292f; text-align:start"><img alt="9.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/9.png" referrerpolicy="no-referrer"></p><ul><li><strong>开始发布</strong></li></ul><p style="color:#24292f; text-align:start">当进行蓝绿发布时，我们将需要发布的应用创建在一个通道中 (这里先说下只有一个通道部署的情况)。</p><p style="color:#24292f; text-align:start"><img alt="09.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/09.png" referrerpolicy="no-referrer"></p><ul><li><strong>蓝集群 (右侧) 摘流</strong></li></ul><p style="color:#24292f; text-align:start">此时所有流量将只访问绿集群，如下图所示，当蓝集群摘流完成后, 此时集群没有任何流量，即可进行部署。</p><p style="color:#24292f; text-align:start"><img alt="8.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/8.png" referrerpolicy="no-referrer"></p><ul><li><strong>蓝集群 (右侧) 引流</strong></li></ul><p style="color:#24292f; text-align:start">当蓝集群发布完成后，我们需要对蓝集群发布后的服务进行确认。在确认部署成功后，则梯度的将流量引入更新后代码的蓝集群 (右侧)，最开始我们会切 1% 的流量，切流量后，我们可以在线上观察蓝服务的流量、错误率等。以此观测发布的版本是否有异常。之后，我们逐渐将流量切回 50%。注意，需要确保相关缺陷都在该环节暴露出来，因为这个环节另一半老版本的、稳定的代码还在 Standby，可以随时操作流量比例，进行流量迁移。</p><p style="color:#24292f; text-align:start"><img alt="7.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/7.jpeg" referrerpolicy="no-referrer"></p><blockquote><p>发布过程中，蓝、绿节点间流量不会互窜 (对比上图，蓝绿集群间斜向箭头没有了)。 此阶段需要注意 MQ 流量，因为 MQ 当前无法按比例进行切分，因此一旦开始切流，则 MQ 流量会恢复为 50%/50%。</p></blockquote><ul><li><strong>绿集群 (左侧) 摘流</strong></li></ul><p style="color:#24292f; text-align:start">通过扩大流量比例，流量全部切到蓝集群，这个阶段流量已全部切到新代码，可以让测试同学介入进行新功能验证以及回归测试。</p><p style="color:#24292f; text-align:start">在这个阶段只要绿集群还没发布，发现问题，仍然可以全部切回老代码！</p><p style="color:#24292f; text-align:start">当测试验证完成后，即可进行绿集群发布。发布后则不可以回切了！就算要代码回滚，也得等本次发布结束后,再单独对服务进行回滚。</p><p style="color:#24292f; text-align:start"><img alt="67.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/67.png" referrerpolicy="no-referrer"></p><ul><li><strong>绿集群 (左侧) 引流</strong></li></ul><p style="color:#24292f; text-align:start">在发布后则开始进入绿集群引流了，此时可以快速引流，因为已经没有可以回滚的、稳定版本的代码了。同样，还在发布阶段，及时流量均衡，也不会出现互相交叉的流量。</p><p style="color:#24292f; text-align:start"><img alt="34.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/34.png" referrerpolicy="no-referrer"></p><ul><li><strong>发布完成</strong></li></ul><p style="color:#24292f; text-align:start">发布完成后，则去除通道，蓝绿集群可以继续进行交互。</p><p style="color:#24292f; text-align:start"><img alt="32.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/32.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">如上图所示，使用以上发布流程具备以下好处：</p><ul><li><p>整个发布过程是以蓝、绿<strong>集群维度</strong>并行调度、实施的，通过发布平台统一操作，摘流，无需各业务域各自处理。</p></li><li><p>通过请求蓝绿粘性，让下游应用的新老版本代码可以同时存在，无需阻塞等待下游应用全部升级到新代码，解除了批次依赖。</p></li><li><p>发布过程中有灵活的流量控制能力，可以按 1%、50% 等阶梯流量验证应用。</p></li><li><p>上述发布流程，可以同时并存若干个，摘流、引流动作互不影响<span>&nbsp;</span><strong>(多发布通道)</strong>。</p></li></ul><span id="OSC_h2_9"></span><h2>蓝绿发布的架构</h2><ol><li><strong>应用架构 [1]</strong></li></ol><p style="color:#24292f; text-align:start"><img alt="45.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/45.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>1.1 流量规则 SDK</strong></p><p style="color:#24292f; text-align:start">在所有需要接入蓝绿发布的程序中，首先需要升级流量规则 SDK，流量规则 SDK 是应用蓝绿发布能力的代码底座，向中间件组件如 RPC、MQ、JOB 提供了主动查询流量规则和被动接受流量规则变更事件的能力，各中间件组件响应流量规则进行合适的动作，实现各类型流量的动态摘流、动态引流。</p><p style="color:#24292f; text-align:start"><strong>1.2 核心能力</strong></p><ul><li><p>依赖配置中心做持久化存储与事件推送。</p></li><li><p>所有配置读取都是内存操作，只会在启动时读取一次配置中心的配置，后续配置变更都依赖于配置中心的事件推送。</p></li><li><p>提供了如下的能力：</p><ul><li><p>当前应用所在的发布通道，是否在蓝绿发布中。</p></li><li><p>指定应用所在的发布通道，是否在蓝绿发布中。</p></li><li><p>蓝色流量百分比，范围[0, 100]。</p></li></ul></li><li><p>提供了如下的事件推送：</p><ul><li><p>发布开始事件 onStart。</p></li><li><p>发布结束事件 onFinish。</p></li><li><p>切流事件 onFlowChange，切流事件又细分了以下几个事件。</p></li><li><p>切流事件，蓝色流量标占比为 100，绿色流量标占比为 0，onEnterAllBlue。</p></li><li><p>切流事件，蓝色流量标占比从 100 改为非 100，绿色流量标占比从 0 改为非 0，onExitAllBlue。</p></li><li><p>切流事件，蓝色标流量占比为 0，绿色流量标占比为 100，onEnterAllGreen。</p></li><li><p>切流事件，蓝色标流量占比从 0 改为非 0，绿色流量标占比从 100 改为非 100，onExitAllGreen。</p></li></ul></li></ul><ol><li><strong>流量控制</strong></li></ol><p style="color:#24292f; text-align:start">得物目前的流量分为内部流量及外部流量，大部分流量情况如下：</p><ul><li><p>外部流量</p><ul><li><p>通过各类 Gateway 请求</p></li><li><p>通过 k8s Ingress 请求 (暂不支持蓝绿发布)</p></li></ul></li><li><p>内部流量</p><ul><li><p>通过 Gateway 互联</p></li><li><p>通过 Dubbo/Feign RPC 协议互联</p></li><li><p>通过 MQ 异步请求</p></li><li><p>通过 kafka 异步请求 (暂不支持)</p></li><li><p>JOB 类任务发起的流量</p></li><li><p>通过 k8s SVC 请求 (暂不支持蓝绿发布)</p></li></ul></li></ul><p style="color:#24292f; text-align:start">其中 Gateway 也是通过 Dubbo 或者 Feign 请求下游服务，因此也可统一为 RPC 类型，所以得物目前的流量主要包含 RPC、MQ、JOB 三种。</p><p style="color:#24292f; text-align:start"><strong>2.1 RPC</strong></p><p style="color:#24292f; text-align:start">我们 RPC 流量核心主要依赖注册中心，通过 Dubbo 的负载均衡策略进行调整。</p><p style="color:#24292f; text-align:start"><img alt="02.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/02.png" referrerpolicy="no-referrer"></p><ul><li><strong>如何实现 RPC 流量比例控制</strong></li></ul><p style="color:#24292f; text-align:start">RPC 场景下应用的流量比例控制，取决于它的上游应用按照流量规则比例向其发起调用。核心是上游应用感知到下游应用实例权重。</p><p style="color:#24292f; text-align:start"><strong>当前应用通过流量规则 SDK 监听到所在通道的流量规则变更时，修改注册中心上的实例权重。</strong></p><p style="color:#24292f; text-align:start"><strong>上游应用通过注册中心透明的感知下游应用的实例权重，通过加权负载均衡策略实现流量比例控制。</strong></p><p style="color:#24292f; text-align:start">Dubbo 原生的各类负载均衡策略都支持加权，也就是即便上游没有升级蓝绿依赖，下游应用依然可以通过蓝绿实例权重控制自己蓝绿集群被调用的比例。</p><p style="color:#24292f; text-align:start">Feign 原生是不支持的，Fusion 框架重写了负载均衡策略。</p><ul><li><strong>如何控制流量比例</strong></li></ul><p style="color:#24292f; text-align:start">蓝色流量比例 Rate，蓝色集群实例权重 WB，绿色集群实例权重 WG。</p><p style="color:#24292f; text-align:start">假设 Rate 从 1 调整到 99，一共有 4 个节点。</p><p style="color:#24292f; text-align:start">调整前 WB=1，WG=99，调整后 WB=99，WG=1，可能出现以下情况：</p><p style="color:#24292f; text-align:start"><img alt="03.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/03.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">-流量规则变更时，只让蓝或绿某一个集群修改自己的权重。</p><p style="color:#24292f; text-align:start">权重值是相对的，只需要保证蓝、绿集群节点权重相对值服从流量比例即可，无需同时修改蓝绿集群所有节点的权重。实例权重初始值设为 100，修改权重时，尽可能保证一半集群实例权重保持 100 不变，只修改另一侧被调整的集群实例的权重。</p><p style="color:#24292f; text-align:start">规则如下：</p><p style="color:#24292f; text-align:start">蓝色流量比例 Rate，公式：W/(100+W) = Rate/100。</p><p>Rate = 50，蓝色集群实例权重=100，绿色集群实例权重=100。</p><p>Rate &lt; 50，蓝色集群实例权重=100 * Rate / (100-Rate)，绿色集群实例权重=100。</p><p>Rate &gt; 50，蓝色集群实例权重=100，绿色集群实例权重=100 * Rate1 / (100-Rate1)，其中 Rate1=100 - Rate。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;<strong>只有一个颜色的集群时，忽略权重。</strong></p><ul><li><p><strong>如何实现完全摘流</strong></p></li></ul><p style="color:#24292f; text-align:start">Dubbo 框架内置的所有负载均衡策略都会识别下游实例的权重进行加权筛选节点，无需上游升级依赖，下游应用实例权重置 0 后即可实现摘流。</p><p style="color:#24292f; text-align:start">Feign 框架默认不识别实例权重，不进行加权负载均衡，为了避免蓝绿发布项目落地时推动发布链路上下游应用升级的困难，应用摘流时，会将自身注册的所有<strong>Feign 服务反注册</strong>，以保证 Feign 流量能被彻底摘流。</p><ul><li><strong>如何实现请求链路蓝绿粘性 (一蓝到底或一绿到底)</strong></li></ul><p style="color:#24292f; text-align:start">蓝绿子集群的代码是不一样的，按我们制定的发布流程，蓝集群是新代码，绿集群是老代码，如果不能固定请求链路的颜色，实现请求过程一蓝到底或者一绿到底，那么可能会出现上游新代码调用到下游老代码，出现代码不兼容的异常。</p><p style="color:#24292f; text-align:start"><strong>将 RPC 请求第一次进入每个通道时的蓝绿决策结果以 KV 形式 Append 到分布式 Trace 的 baggage 中，全链路透传、隔离、复用。</strong></p><p style="color:#24292f; text-align:start">如果 Trace 中有蓝绿决策结果，则按照蓝绿决策结果筛选节点；</p><p style="color:#24292f; text-align:start">否则按照流量比例筛选节点，并将决策结果（节点集群颜色）Append 到 Trace。</p><p style="color:#24292f; text-align:start"><strong>baggage-key: x-deploy-channel-type。 baggage-value：key=通道标识，value=蓝集群或绿集群标识，多个通道以&amp;分割。</strong><img alt="55.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/55.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>2.2 MQ(RocketMQ)</strong></p><p style="color:#24292f; text-align:start">核心是通过多消费组实现 MQ 流量隔离和控制。业务上创建的一个业务消费组，会在 MQ SDK 层面透明的创建 2 个衍生的颜色消费组。</p><p style="color:#24292f; text-align:start">发送消息时，会在消息头上携带当前节点蓝绿标。3 个消费组收到消息时，根据消息颜色和消费组颜色做颜色请和判断，互斥的消费同一个 TOPIC 上的所有消息。</p><ul><li><p><strong>非摘流状态</strong><img alt="00.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/00.png" referrerpolicy="no-referrer"></p></li><li><p><strong>摘流状态</strong></p></li></ul><p style="color:#24292f; text-align:start">应用感知到通道内蓝集群摘流时，蓝集群节点关闭消费组、绿集群节点启动三种颜色消费组。此时，MQ 流量完全由绿集群接管。</p><p style="color:#24292f; text-align:start"><img alt="24.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/24.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">通道内绿集群摘流时同理。</p><ul><li><p><strong>过程详解</strong></p><ul><li><p>原本一个消费组，拆分成三个消费组。</p></li><li><p>原始消费组 origin-consumer 用于消费无（蓝绿）标识的流量。</p></li><li><p>蓝色消费组 blue-consumer 用于消费「蓝色」标识流量。</p></li><li><p>绿色消费组 green-consumer 用于消费「绿色」标识流量。</p></li></ul></li></ul><p style="color:#24292f; text-align:start"><img alt="98.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/98.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><strong>2.3 JOB(elasticjob)</strong><img alt="76.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/76.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">elasticjob 在运行时会在业务应用集群内利用 ZK 协调产生一个 Master 节点，由 Master 节点来按负载均衡策略将任务分配到各个执行器节点上。这个任务分配关系一经分配就会固定并在后续复用，除非是有应用进程上下线、JOB 分片数有变更。</p><p style="color:#24292f; text-align:start">改造 elasticjob 客户端适配流量规则 SDK，正在蓝绿发布的应用，在感知到有集群已经摘流时，会修改 ZK 上的状态标识，将上述记录的分配关系失效。</p><p style="color:#24292f; text-align:start">失效后，后续 JOB 执行时，会根据流量规则重新进行任务分配，避让已经摘流的节点，以保证已经摘流的节点上不会有 JOB 执行。</p><ul><li><strong>过程详解</strong></li></ul><p style="color:#24292f; text-align:start"><img alt="65.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/65.png" referrerpolicy="no-referrer"></p><span id="OSC_h2_10"></span><h2>蓝绿接入注意事项</h2><p style="color:#24292f; text-align:start">因当前技术限制, 服务接入蓝绿需要注意以下事项：</p><ul><li><p><strong>流量无法摘除的服务暂时无法接入</strong></p><ul><li><p>未通过网关进入服务流量：例如，通过域名 SLB 进入服务、通过 Ingress 进入服务的流量无法摘除。</p></li><li><p>消费 Kafka 的流量无法摘除：由于应用使用的原生 kafka 客户端并全面铺开、无法对切入提供支持。</p></li><li><p>未使用统一框架/注册中心：未使用统一框架和注册中心的 Java 应用、以及非 Java 类应用当前不支持蓝绿发布。</p></li></ul></li><li><p><strong>使用特别提醒</strong></p><ul><li><p>消费消息需幂等：使用消息中间件必须做幂等，这是基本要求，在消费组启停管控中可能产生重复消息。</p></li><li><p>消费组线程数量：由于会有三个消费组、消费线程也会增加两倍，有业务影响时需调低线程数。</p></li><li><p>需要好流量评估：蓝绿发布需一半节点承接线上流量、在应用升级蓝绿集群时做好确认。</p></li><li><p>升级到特定版本：使用蓝绿发布需要应用升级到框架指定版本，详见接入指南。</p></li><li><p>Feign/HTTP 流量：针对使用框架 Feign 的 HTTP 流量，需上下游应用全部升级后方可使用。</p></li><li><p>使用 Dubbo 流量：使用框架 Dubbo 的服务只需要自身服务升级版本即可、无需上下游升级。</p></li></ul></li></ul><span id="OSC_h1_11"></span><h1>四、得物 SRE 团队对蓝绿发布的相关支持</h1><span id="OSC_h2_12"></span><h2>容器集群针对蓝绿的改造</h2><p style="color:#24292f; text-align:start">我们容器的 workload 使用的 OpenKruise 来进行管理。在进行蓝绿发布之前，我们使用的单个 clonesets 进行控制。</p><p style="color:#24292f; text-align:start">以下图所示，为我们一个测试非蓝绿集群，这里就是使用单个 cloneset 进行控制的单实例。</p><p style="color:#24292f; text-align:start"><img alt="41.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/41.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">在进行蓝绿改造后，我们将 workload 分为蓝绿两个 clonesets，通过这样，我们可以实现蓝绿发布时候的单边实例发布。同时在我们管理平台界面，任是单个集群界面， 以此来实现单集群下，蓝绿集群的拆分。</p><p style="color:#24292f; text-align:start"><img alt="80.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/80.png" referrerpolicy="no-referrer"></p><span id="OSC_h2_13"></span><h2>蓝绿发布扩容资源优化</h2><p style="color:#24292f; text-align:start">前面就说过，蓝绿发布的一大缺点是通常需要准备平常流量 2 倍的资源，以应对蓝绿发布期间的流量。我们在加入蓝绿发布集群时，也尽量会提醒需要增加资源以应对蓝绿发布。但如果毫无规划的进行扩容，则会带来以下几个问题，比如长期保留扩容资源，则会带来成本的答复增长，而临时的扩容，则代表着对人力的消耗增加，而且临时的扩容也增长了对资源池管理的难度。可能在用户扩容时，出现资源池不足的情况。</p><p style="color:#24292f; text-align:start">为了应对这个问题，我们针对蓝绿发布进行了优化。首先是在发布流程中加入了扩缩容的环节。让平台自动帮助进行服务的扩缩容。其次，在容器层面，我们利用云服务商的弹性实例功能，来弥补常规资源池不足的情况，通过基于 Virtual Kubelet 技术接入到 k8s 中，<strong>支持秒级启动，按量计费，可快速完成扩缩容，满足业务的实时响应需求。</strong></p><p style="color:#24292f; text-align:start">注意: 在应用加入发布通道时，因蓝绿发布会导致流量减半，请务必对核心服务进行扩容<span>&nbsp;</span><strong>(SRE 建议扩容 30% 以上)。</strong></p><p style="color:#24292f; text-align:start"><img alt="08.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/08.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><img alt="06.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/06.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start"><img alt="021.jpeg" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/021.jpeg" referrerpolicy="no-referrer"></p><span id="OSC_h2_14"></span><h2>发布监控</h2><p style="color:#24292f; text-align:start">加入灰度的蓝绿发布，因为涉及流量切换过程，因此对监控要求非常高，需要及时观测整个通道中的服务状态，而历史中单应用的监控页面无法满足发布 owner 有效观测。因此，针对这个问题，我们专门设计了通道级的蓝绿发布大盘，有效的观测流量分布情况，服务的请求情况等。通过该大盘，发布 owner 能有效掌握本次发布情况，决定是否继续进行切流。</p><p style="color:#24292f; text-align:start"><img alt="043.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/043.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_15"></span><h1>五、蓝绿发布期间可能出现的问题及应急响应策略</h1><span id="OSC_h2_16"></span><h2>资源不足导致的服务异常</h2><ol><li><strong>发布前扩容</strong></li></ol><p style="color:#24292f; text-align:start">根据蓝绿发布原理可知，我们在发布时，只有 50% 的实例来支撑原先 100% 的流量， 因此务必在蓝绿发布前勾选发布前临时扩容。扩容量需要评估以下几个数据：</p><ul><li>服务 CPU 水位情况</li></ul><p style="color:#24292f; text-align:start">根据历史经验，如日常水位 99 值在 20% 以内的服务，无需进行临时扩容，而 99 值在 20%-30 以内的服务，建议扩容 20% 左右。而 99 值在 30-40% 之间的服务，应当扩容 30% 以上。同时也要考虑发布当天的流量情况。</p><p style="color:#24292f; text-align:start">比如我们在七夕大促期间的发布，因大促流量过高，我们许多服务在蓝绿发布时扩容达到了 50% 以上的情况，通过此方式，保证在切流期间，服务也能正常。</p><p style="color:#24292f; text-align:start">因为我们的服务大多以 JAVA 为主，内存大多用固定方式分配给了 JVM 堆，因此内存不是一个核心的参考指标。</p><ul><li>服务线程使用情况</li></ul><p style="color:#24292f; text-align:start">除了服务 CPU 外，服务线程也是一个核心参考指标，特别是 Dubbo 线程池以及 DB/Redis 的线程池。比如原先 Dubbo 线程池，max 为 200,10 个实例的服务，当日常 QPS 大于 1000 的时候，在蓝绿发布时就需要扩容了，否则实例数少了一半，意味着可用线程也少了一半，这个时候就会出现线程拒绝异常了。</p><ol><li><strong>发布期间的资源不足</strong></li></ol><p style="color:#24292f; text-align:start">有些时候，我们评估不足会导致在开始发布后因为资源不足导致的错误率上升，此时需要我们紧急处理，但为了发布期间的稳定性，一旦我们开启了蓝绿通道，就不允许进行集群的扩容了。此时需要 SRE 接入在后台进行处理，处理逻辑如下：</p><ul><li><p>确认待扩容集群未处于发布状态。</p></li><li><p>手动修改蓝/绿单边集群 cloneset 的 replicas 数据。</p></li><li><p>待发布完毕后，手动还原该 cloneset 的 replicas 数据。</p></li></ul><p style="color:#24292f; text-align:start"><strong>因该操作非标准操作，且存在风险，请尽量不要使用以上方式进行。</strong></p><span id="OSC_h2_17"></span><h2>发布中出现流量不均衡的情况</h2><p style="color:#24292f; text-align:start">之前的一次测试中，我们在引流后出现了服务流量不均衡的问题，当时因为 Fusion 框架升级了 Dubbo 异步的改造中存在逻辑缺陷，导致流量无法均衡分布。之后，通过回退 Fusion 框架版本后问题恢复。</p><p style="color:#24292f; text-align:start"><img alt="77.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/77.png" referrerpolicy="no-referrer"></p><p style="color:#24292f; text-align:start">这是个比较危险的情况，某些节点会在发布时承担日常 400% 的流量，很容易造成服务雪崩。因此，在蓝绿发布中，负责人和 SRE 要加强服务的监控和关注力度，及时发现流量不均衡的情况并介入。</p><span id="OSC_h2_18"></span><h2>发布中出现流量互窜的情况</h2><p style="color:#24292f; text-align:start">流量互窜的问题会有许多种情况：有因为切流前的 JOB 持续运行，导致双边集群依旧有流量；有的因为链路中间节点没有升级蓝绿能力，导致流量错位；有的因为 MQ 请求下游导致的流量错位。这里不针对问题进行一一分析，问题的解决仅能依靠框架的升级，这里仅说下问题的影响和排查方法。</p><p style="color:#24292f; text-align:start">在蓝绿发布时，原先我们的预计是老代码连老代码，新代码连新代码，但出现异常请求时，可能出现新代码连老代码，或者老代码连下游新代码的情况，这个时候就会出现因为依赖不匹配，导致的服务异常。<img alt="243.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/243.png" referrerpolicy="no-referrer">要发现此类问题，我们首先要知道，在这种情况下，大多会出现单边集群错误率上升。通过我们的监控页面，我们能很好的发现单边错误率上升的情况。此时，我们就能根据这些错误的情况，在天眼的调用链分析中，查看错误的具体情况。此时需要我们判断链路里是否有出现流量异常的情况，查看节点的 Host name，可以判断是蓝或者绿集群节点。<img alt="123.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/123.png" referrerpolicy="no-referrer"><img alt="60.png" src="https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10569101/60.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_19"></span><h1>六、历史总结及展望未来</h1><span id="OSC_h2_20"></span><h2>蓝绿发布的效果</h2><p style="color:#24292f; text-align:start">自从交易域进行蓝绿发布以来，平均大版本的发布时效较之前得到了较大的提升，同时近期大版本已没有出现故障事件，在升级蓝绿发布后，我们可以提前在切流阶段发现问题，并快速回切进行修复，避免了故障带入生产。因此，现在蓝绿发布相比过去滚动部署，在效率和稳定性上均大有提升。</p><span id="OSC_h2_21"></span><h2>未来展望</h2><p style="color:#24292f; text-align:start">目前我们核心服务都已切换至蓝绿集群，这种为我们的多活打下了优势，已经天然具备了多活的条件。因此，未来我们可以通过这种架构来部署我们的多活，这样，当任何单机房出现异常后，能够快速切换到另外一个机房，我们的抗风险能力也会有巨大的提升。</p><p style="color:#24292f; text-align:start"><strong>参考引用:</strong><span>&nbsp;</span>[1] 特别鸣谢，本节蓝绿发布架构及原理部分引用了得物中间件平台 「羊羽」同学的文章。</p><p style="color:#24292f; text-align:start"><strong>文/latte</strong></p><p style="color:#24292f; text-align:start">&nbsp;</p><p style="color:#252933; text-align:start">本文属得物技术原创，更多精彩文章请看：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.dewu.com" rel="nofollow" target="_blank">得物技术官网</a></p><p style="color:#252933; text-align:start">未经得物技术许可严禁转载，否则依法追究法律责任！</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 14 Jan 2024 02:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/10773874</guid>
            <link>https://my.oschina.net/u/5783135/blog/10773874</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linus「温馨提示」：Intel Xe 驱动代码严重缺乏测试]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Linux 6.8 的 </span><span style="color:#121212">Direct Rendering Manager (DRM)&nbsp;</span><span style="color:#000000">内核图形/显示驱动程序更新包括新的英特尔"Xe"DRM 和 PowerVR Imagination 驱动程序、实验形式的 AMD 色彩管理属性、Raspberry Pi 5 图形支持等。</span></p><p><span style="color:#000000">但 Linus Torvalds 最近在合并相关</span><span style="color:#333333">代码</span><span style="color:#000000">时却发现，一些新提交的 Intel Xe 驱动程序代码"严重缺乏"测试。对此，他在内核邮件列表中<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Fdri-devel%2FCAHk-%3DwgPJttFz8yrdpPTN-ypMmDXHOKw9yi1nZSEq%2B7%2BtGftZA%40mail.gmail.com%2F" target="_blank">表达</a>了自己的不满：</span></p><blockquote><p><span style="color:#000000">你的测试严重不足。甚至无法构建，原因似乎在于该&nbsp;commit b49e894c3fd8 ("drm/i915: Replace custom intel runtime_pm tracker with ref_tracker library")&nbsp;将"intel_wakeref_t"类型从"deep_stack_handle_t"改为了"unsigned long"......</span></p><p><span style="color:#000000">真令人不悦。我已经修复了那个损坏的 Xe compat 头文件并完成了构建，但这绝对不是事情的本来应该有的样子。我怎么会遇到这种情况？竟然会没有进行任何构建测试。</span></p><p><span style="color:#000000">为什么 %^!@$% 头文件会包含 C 文件？无论如何，这个错误都不应该发生。</span></p></blockquote><p><img height="281" src="https://oscimg.oschina.net/oscnet/up-7e522381a922470c222f72c566df84b3bea.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">与以前的一些「火爆」回复相比，Linus 这次的措辞可以说是算的上温和，并且也提出了一些合理的问题。事实上，在 2023 年底的&nbsp;Linux 基金会的日本开源峰会上，Linus 就<a href="https://www.oschina.net/news/269762/linus-torvalds-linux-future-ai">表示</a>自己已经收敛了脾气，在吸取了一些教训之后不会再 「对一些公司竖中指」。</span></p><p><span style="color:#000000">但也正如 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FTorvalds-Unhappy-Linux-6.8-DRM" target="_blank">Phoronix</a> 所言，无论如何 Linus 已经将新代码合并到 Linux 6.8 中。希望这只是&nbsp;Intel Xe 驱动程序的一个 one-off issue，而没有更大的代码质量问题。</span></p><p><span style="color:#000000">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Fdri-devel%2FCAHk-%3DwgPJttFz8yrdpPTN-ypMmDXHOKw9yi1nZSEq%2B7%2BtGftZA%40mail.gmail.com%2F" target="_blank">查看邮件列表</a>。</span></p><p><strong><span style="color:#000000">相关阅读：</span></strong></p><ul><li><a href="https://www.oschina.net/news/269762/linus-torvalds-linux-future-ai" target="news">Linus Torvalds 收敛脾气，谈内核社区「老龄化」问题</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Sat, 13 Jan 2024 04:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275552/linus-torvalds-intel-xe-drive-code-linux-6-8</guid>
            <link>https://www.oschina.net/news/275552/linus-torvalds-intel-xe-drive-code-linux-6-8</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[三部门：到 2025 年初步形成支撑区块链发展标准体系]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>工业和信息化部、中央网络安全和信息化委员会办公室、国家标准化管理委员会印发《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fzwgk%2Fzcwj%2Fwjfb%2Ftz%2Fart%2F2024%2Fart_c82be443223e4a5aa9cee2c435112e00.html" target="_blank">区块链和分布式记账技术标准体系建设指南</a>》(下称《指南》)。</p><p>其中提出，区块链和分布式记账技术 (以下简称「区块链」) 是新一代信息技术的重要组成部分，是分布式网络、加密技术、智能合约等多种技术集成的新型数据库软件。区块链技术具有数据透明、不易篡改、可追溯等特性，有望解决网络空间的信任和安全问题，推动互联网从传递信息向传递价值变革，将成为推动元宇宙、Web3.0 等未来产业快速发展的重要数字基础设施。</p><p><img height="316" src="https://oscimg.oschina.net/oscnet/up-380ad5c9a1d0ae2453b5bdb61fc89ff89ca.png" width="700" referrerpolicy="no-referrer"></p><p>《指南》提出建设目标：</p><p>到 2025 年，初步形成支撑区块链发展的标准体系。建立标准体系建设和标准研制的总体规则，重点面向基础共性、应用和服务等标准化领域，制定 30 项以上区块链相关标准，基本满足我国区块链标准化需求。</p><p>到 2027 年，全面形成支撑区块链发展的标准体系。制定 50 项以上区块链相关标准，持续推动区块链基础共性、关键应用示范、安全保障等标准研制。适度超前布局一批支撑未来产业发展需要的关键应用标准，有效指导我国区块链技术和产业发展，提升技术与应用服务水平。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 13 Jan 2024 03:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275546</guid>
            <link>https://www.oschina.net/news/275546</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenVoice —— 多功能即时语音克隆]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">OpenVoice，这是一种多功能的即时语音克隆方法，只需要参考说话者的一个简短的音频剪辑即可复制他们的声音并生成多种语言的语音。</span></p><p><span style="color:#000000">除了复制参考说话者的音色之外，OpenVoice 还可以对语音风格进行精细控制，包括情感、口音、节奏、停顿和语调。OpenVoice 还可以针对海量说话人训练集中未包含的语言实现零样本跨语言语音克隆。OpenVoice 的计算效率也很高，其成本比性能较差的商用 API 低数十倍。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong><span style="background-color:oklch(1 0 0)">准确的音色克隆</span></strong></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:oklch(1 0 0)">OpenVoice 可以准确克隆参考音色并生成多种语言和口音的语音。</span></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong><span style="color:#000000"><span style="background-color:oklch(1 0 0)">灵活的语音风格控制</span></span></strong></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:oklch(1 0 0)">OpenVoice 可以对语音风格（例如情感和口音）以及其他风格参数（包括节奏、停顿和语调）进行精细控制。</span></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong><span style="background-color:oklch(1 0 0)">零样本跨语言语音克隆</span></strong></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:oklch(1 0 0)">参考语音和生成的语音可以是海量说话人多语言数据集之外的任何语言。</span></span></p></div>
                                                                ]]>
            </description>
            <pubDate>Sat, 13 Jan 2024 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/openvoice</guid>
            <link>https://www.oschina.net/p/openvoice</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | Windows 和 iOS 设备间文件传输 AirDropPlus]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-airdrop-plus" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#airdrop-plus"></a>AirDrop Plus</h1><p>用于 iOS 设备和 Windows 电脑之间进行文件传输，基于 HTTP，需要配合快捷指令使用</p><h1><a id="user-content-依赖" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E4%BE%9D%E8%B5%96"></a>依赖</h1><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">python==3.10.6</span><span id="LC2" class="line">flask==3.0.0</span><span id="LC3" class="line">win10toast==0.9</span><span id="LC4" class="line">psutil==5.9.6</span><span id="LC5" class="line">pyinstaller==6.2.0</span><span id="LC6" class="line">windows_toasts==1.0.1</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h1><a id="user-content-打包" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E6%89%93%E5%8C%85"></a>打包</h1><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">pyinstaller <span class="nt">--add-data</span><span class="s1">'config;config'</span><span class="nt">-w</span> AirDropPlus.py</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h1><a id="user-content-使用" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E4%BD%BF%E7%94%A8"></a>使用</h1><ol><li>Windows 端安装 bonjour，这样可以通过 「设备名.local」 访问到 Windows，而不需要通过 IP 地址。
 <div><img src="https://gitee.com/yeytytytytyytyt/air-drop-plus/raw/master/pic/windows_device_name.png" alt="Image" referrerpolicy="no-referrer"></div></li><li>修改配置文件 config.ini，设置文件保存路径和密钥</li><li>手机端下载快捷指令
<ul><li>文件：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.icloud.com%2Fshortcuts%2Fdbbc2d75a611471babbe69e128db6702">https://www.icloud.com/shortcuts/dbbc2d75a611471babbe69e128db6702</a></li><li>剪贴板：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.icloud.com%2Fshortcuts%2F8b0a81ddf004422fbbb8fc8099546811">https://www.icloud.com/shortcuts/8b0a81ddf004422fbbb8fc8099546811</a></li></ul></li><li>设置快捷指令的主机为 Windows 的设备名 (不是用户名).local，设置快捷指令的密钥和 config.ini 中的密钥相同
 <div><img src="https://gitee.com/yeytytytytyytyt/air-drop-plus/raw/master/pic/shortcut_conf.png" alt="Image" referrerpolicy="no-referrer"></div></li><li>发送文件时在文件分享菜单执行 AirDrop Plus 快捷指令。接收文件时，直接执行 AirDrop Plus 快捷指令
 <div><img src="https://gitee.com/yeytytytytyytyt/air-drop-plus/raw/master/pic/send_file.png" alt="Image" referrerpolicy="no-referrer"><img src="https://gitee.com/yeytytytytyytyt/air-drop-plus/raw/master/pic/receive_file.png" alt="Image" referrerpolicy="no-referrer"></div></li><li>同步剪贴板直接执行快捷指令，点击发送或者接收!
 <div><img src="https://gitee.com/yeytytytytyytyt/air-drop-plus/raw/master/pic/sync_clipboard.png" alt="Image" referrerpolicy="no-referrer"></div></li><li>Windows 端退出在任务管理器中退出
 <div><img src="https://gitee.com/yeytytytytyytyt/air-drop-plus/raw/master/pic/exit.png" alt="Image" referrerpolicy="no-referrer"></div></li></ol><h1><a id="user-content-api" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#api"></a>API</h1><h2><a id="user-content-请求头参数" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%8F%82%E6%95%B0"></a>请求头参数</h2><table><thead><tr><th>参数名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>ShortcutVersion</td><td>String</td><td>快捷指令的版本，需要和 config.ini 中的 version 一致</td></tr><tr><td>Authorization</td><td>String</td><td>密钥，需要和 config.ini 中的 key 一致</td></tr></tbody></table><h2><a id="user-content-文件发送" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E6%96%87%E4%BB%B6%E5%8F%91%E9%80%81"></a>文件发送</h2><blockquote><p>移动端发送一个文件到 PC</p></blockquote><h3><a id="user-content-请求" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82"></a>请求</h3><h4><a id="user-content-请求方式" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"></a>请求方式</h4><ul><li>HTTP 方法: POST</li><li>URL: /file/send</li></ul><h4><a id="user-content-请求参数" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"></a>请求参数</h4><ul><li>发送格式: 表单</li></ul><table><thead><tr><th>参数名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>file</td><td>File</td><td>要发送的文件</td></tr><tr><td>filename</td><td>String</td><td>发送的文件名</td></tr><tr><td>notify_content</td><td>String</td><td>让 PC 端通知显示的内容<br>如果是发送单个文件：这里填写的就是 filename 的内容<br>如果是发送 n 个文件：前 n-1 个的 notify_content 为空，第 n 个的 notify_content 包含 n 个文件的 filename，使用\n 分隔</td></tr></tbody></table><h3><a id="user-content-返回" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%BF%94%E5%9B%9E"></a>返回</h3><ul><li>返回类型: JSON</li><li>返回内容:
<div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="p">{</span></span><span id="LC2" class="line"><span class="w"></span><span class="nl">"success"</span><span class="p">:</span><span class="w"></span><span class="kc">true</span><span class="p">,</span></span><span id="LC3" class="line"><span class="w"></span><span class="nl">"msg"</span><span class="p">:</span><span class="w"></span><span class="s2">"发送成功"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="w"></span><span class="nl">"data"</span><span class="p">:</span><span class="w"></span><span class="kc">null</span></span><span id="LC5" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div></li></ul><h2><a id="user-content-文件发送列表" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E6%96%87%E4%BB%B6%E5%8F%91%E9%80%81%E5%88%97%E8%A1%A8"></a>文件发送列表</h2><blockquote><p>移动端发送文件列表到 PC（通知 PC 接下来要发送哪些文件）</p></blockquote><h3><a id="user-content-请求-1" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82-1"></a>请求</h3><h4><a id="user-content-请求方式-1" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F-1"></a>请求方式</h4><ul><li>HTTP 方法: POST</li><li>URL: /file/send/list</li></ul><h4><a id="user-content-请求参数-1" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-1"></a>请求参数</h4><ul><li>发送格式: 表单</li></ul><table><thead><tr><th>参数名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>file_list</td><td>String</td><td>要发送的文件列表，文件之间用\n 分隔，如：aaa.jpg\nbbb.png</td></tr></tbody></table><h3><a id="user-content-返回-1" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%BF%94%E5%9B%9E-1"></a>返回</h3><ul><li>返回类型: JSON</li><li>返回内容:
<div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="p">{</span></span><span id="LC2" class="line"><span class="w"></span><span class="nl">"success"</span><span class="p">:</span><span class="w"></span><span class="kc">true</span><span class="p">,</span></span><span id="LC3" class="line"><span class="w"></span><span class="nl">"msg"</span><span class="p">:</span><span class="w"></span><span class="s2">"发送成功"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="w"></span><span class="nl">"data"</span><span class="p">:</span><span class="w"></span><span class="kc">null</span></span><span id="LC5" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div></li></ul><h2><a id="user-content-文件接收列表" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E6%96%87%E4%BB%B6%E6%8E%A5%E6%94%B6%E5%88%97%E8%A1%A8"></a>文件接收列表</h2><blockquote><p>获取 PC 复制的文件的文件地址列表</p></blockquote><h3><a id="user-content-请求-2" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82-2"></a>请求</h3><h4><a id="user-content-请求方式-2" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F-2"></a>请求方式</h4><ul><li>HTTP 方法: GET</li><li>URL: /file/receive/list</li></ul><h4><a id="user-content-请求参数-2" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-2"></a>请求参数</h4><ul><li>无</li></ul><h3><a id="user-content-返回-2" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%BF%94%E5%9B%9E-2"></a>返回</h3><ul><li>返回类型: JSON</li><li>返回内容:
<div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="p">{</span></span><span id="LC2" class="line"><span class="w"></span><span class="nl">"success"</span><span class="p">:</span><span class="w"></span><span class="kc">true</span><span class="p">,</span></span><span id="LC3" class="line"><span class="w"></span><span class="nl">"msg"</span><span class="p">:</span><span class="w"></span><span class="s2">""</span><span class="p">,</span></span><span id="LC4" class="line"><span class="w"></span><span class="nl">"data"</span><span class="p">:</span><span class="w"></span><span class="p">[</span><span class="s2">"c:/xx/xx/aa.txt"</span><span class="p">,</span><span class="w"></span><span class="s2">"c:/xx/xx/bb.txt"</span><span class="p">]</span></span><span id="LC5" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div></li></ul><h2><a id="user-content-文件接收" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E6%96%87%E4%BB%B6%E6%8E%A5%E6%94%B6"></a>文件接收</h2><blockquote><p>移动端接收 PC 上的文件</p></blockquote><h3><a id="user-content-请求-3" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82-3"></a>请求</h3><h4><a id="user-content-请求方式-3" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F-3"></a>请求方式</h4><ul><li>HTTP 方法: POST</li><li>URL: /file/receive</li></ul><h4><a id="user-content-请求参数-3" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-3"></a>请求参数</h4><ul><li>发送格式: 表单</li></ul><table><thead><tr><th>参数名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>path</td><td>String</td><td>要接收的文件的路径</td></tr></tbody></table><h3><a id="user-content-返回-3" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%BF%94%E5%9B%9E-3"></a>返回</h3><ul><li>返回类型: 文件</li><li>返回内容: 文件</li></ul><h2><a id="user-content-剪贴板发送" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E5%89%AA%E8%B4%B4%E6%9D%BF%E5%8F%91%E9%80%81"></a>剪贴板发送</h2><blockquote><p>把移动端的剪贴板发送到 PC 的剪贴板</p></blockquote><h3><a id="user-content-请求-4" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82-4"></a>请求</h3><h4><a id="user-content-请求方式-4" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F-4"></a>请求方式</h4><ul><li>HTTP 方法: POST</li><li>URL: /clipboard/send</li></ul><h4><a id="user-content-请求参数-4" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-4"></a>请求参数</h4><ul><li>发送格式: 表单</li></ul><table><thead><tr><th>参数名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>clipboard</td><td>String</td><td>移动端剪贴板内容</td></tr></tbody></table><h3><a id="user-content-返回-4" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%BF%94%E5%9B%9E-4"></a>返回</h3><ul><li>返回类型: JSON</li><li>返回内容:
<div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="p">{</span></span><span id="LC2" class="line"><span class="w"></span><span class="nl">"success"</span><span class="p">:</span><span class="w"></span><span class="kc">true</span><span class="p">,</span></span><span id="LC3" class="line"><span class="w"></span><span class="nl">"msg"</span><span class="p">:</span><span class="w"></span><span class="s2">"发送成功"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="w"></span><span class="nl">"data"</span><span class="p">:</span><span class="w"></span><span class="kc">null</span></span><span id="LC5" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div></li></ul><h2><a id="user-content-剪贴板接收" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E5%89%AA%E8%B4%B4%E6%9D%BF%E6%8E%A5%E6%94%B6"></a>剪贴板接收</h2><blockquote><p>把 PC 端的剪贴板发送到移动端的剪贴板</p></blockquote><h3><a id="user-content-请求-5" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82-5"></a>请求</h3><h4><a id="user-content-请求方式-5" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F-5"></a>请求方式</h4><ul><li>HTTP 方法: GET</li><li>URL: /clipboard/receive</li></ul><h4><a id="user-content-请求参数-5" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-5"></a>请求参数</h4><ul><li>无</li></ul><h3><a id="user-content-返回-5" class="anchor" href="https://gitee.com/yeytytytytyytyt/air-drop-plus#%E8%BF%94%E5%9B%9E-5"></a>返回</h3><ul><li>返回类型: JSON</li><li>返回内容:
<div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="p">{</span></span><span id="LC2" class="line"><span class="w"></span><span class="nl">"success"</span><span class="p">:</span><span class="w"></span><span class="kc">true</span><span class="p">,</span></span><span id="LC3" class="line"><span class="w"></span><span class="nl">"msg"</span><span class="p">:</span><span class="w"></span><span class="s2">""</span><span class="p">,</span></span><span id="LC4" class="line"><span class="w"></span><span class="nl">"data"</span><span class="p">:</span><span class="w"></span><span class="s2">"PC 端剪贴板的内容"</span></span><span id="LC5" class="line"><span class="p">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div></li></ul>]]>
            </description>
            <pubDate>Sat, 13 Jan 2024 02:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/yeytytytytyytyt/air-drop-plus</guid>
            <link>https://gitee.com/yeytytytytyytyt/air-drop-plus</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 开发同学的 「做事情」&「想事情」&「谈事情」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:justify">回看在阿里的这几年，乃至追溯到整个毕业后的工作过程，作为一名后端偏向业务向的一线开发，我一直在想，抛开技术栈和方案经验等这些具体的细致内容之外，究竟有什么东西是能够迁移到更多场景乃至生活上的体悟，思索良久，大抵可以此概述。</p><span id="OSC_h3_1"></span><h3>总会走的「路」</h3><p style="text-align:justify">想来，除少数天才外，所有人走进职场的开头，都是从模仿开始的。这一点在工程领域尤甚，跟着前辈、师兄、领导，学习怎么使用开发工具、生产环境，怎么去受理需求，怎么去按照既定的设计实施，最后开发测试完成上线，即便是之后换了新的工作环境，这些流程大致还是需要重走一遍的，当然，这一点我们的术语也称其为「落地」（不排除落地中也包含着文化同化的部分）。</p><p style="text-align:justify">随着在一个领域里了解的越来越多，或者是在一个课题中越做越深、越做越细之后，慢慢的会对现状产生怀疑、产生不满，觉得现有的东西不够完美，还能有进步空间，就开始想办法去找新路子、做优化、搞设计，目标是突破现状得到更好的结果。直到某一个领域完全符合了自己的想法（当然不排除也会走向自我和解），也能预见在未来的一段时间内能够 cover 掉大多数的变化的时候，就会尝试跳出边界外，再去找一个相关的领域或者干脆找一个完全新的领域去从头开始。</p><p style="text-align:justify">对于一个技术人而言，这种从 0 到 1 再到 100 的过程，真的是会令人上瘾的，毕竟与此相比，在别人成熟的东西上继续添砖加瓦所带来的成就感和获得感会少的多，<strong>技术是需要技术热情推动的</strong>，所以也就不奇怪为什么很多团队乃至公司在接手现成项目产品的时候，都会选择技术重构、架构升级等，当然最主要的方面还是为了解决技术旧债和统一建设思路的问题，不过，谁敢说这里面完全不存在哪怕一点点私心其实是为了这点子热情呢（手动挽尊~狗头）。</p><span id="OSC_h3_2"></span><h3>理出来的「核」</h3><p style="text-align:justify">无论是刚开始上手的初期，亦或是逐渐轻车熟路的中期，还是历经数次大促不断打磨过的后期，一名开发同学在不同历史阶段做的事情虽然会千差万别，但毕竟还是同一个工种的事情，说的笼统一点无外乎需求、设计和开发，总会存在一些不变的道理。</p><p style="text-align:justify">很多事情，无论具体的细节随着时间怎么变，都会有存在一条很难直接言明的<strong>框架和脉络</strong>，内涵于这件事情的本质属性，让人即便遇到了一件看似新鲜的工作内容，在了解了变化后还是会说一句「嗨，什么嘛，不还是一回事」。然而，对所见事务按「相似性」进行归纳，是人类天生的一种学习能力，归纳法是人类认世界最简单的实践根本，人类大多数智慧都发生在生活和经历中，是从具体生产、生活事例中归纳出来的通用性的结论，工作基本也是一样，即所谓工作经验。同意了这个观点，再看看遇到新项目、新需求、新题目的时候，我们大多数时候的做法，还是先想想自己是不是曾经做过类似的事情，然后再去问问做过类似事情的人，以及来 ATA 上查查有没有类似的项目分享学习经验。说白了，只要是能描述清晰的问题，最终结论都是可解的，所有的不可解都是衡量代价后产生的问题。</p><p style="text-align:justify">直到现在，我还是在说具体的事或者同类的事，那么现在跳出这个思考边界，回到框架和脉络这种本质属性上。开发同学最喜欢做的事情之一就是抽象、封装，那么把这种好习惯用在写代码之外，就以开发工作而言，乃至工作而言，这事儿有没有什么东西，是这个领域解题思路的「核」？</p><p style="text-align:justify">在我看来，工作上的事，无非三个方面：<strong>做事情、想事情、谈事情</strong>。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-ec80deb479d41d17354f46f007c00e97_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">做事情与想事情比较好理解，为什么我会单独列出来谈事情，下文细聊，不过三者倒也真的算是相辅相成，只做不想谓之码农，只想不做谓之吹牛，至于只谈不想也不做算什么，那不就是个传声筒呗，算什么开发呢。</p><span id="OSC_h3_3"></span><h3>做事情</h3><p style="text-align:justify">「结果利他，过程利己。」</p><p style="text-align:justify">开发都要做些什么事情，一言以蔽之「实现需求」，实现了能发布上线，做出来的东西得好使，这才是硬道理。工程一事，不只是软件工程，都是结果论调，没做出来东西或者东西不好使，只流于表面夸赞思路超前、架构先进，然后讲出来一套一套，这都是花架子，经不住推敲和敲打，常以此自省。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-b926ba0e453fd0026cd6d86eb651d96c_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">开发完整一些的流程，从收到需求开始，历经分析、设计、实施、实现、验证直到最终交付。但在上述流程之前，有一个易被忽略的环节，是需求调研的过程，目的是为了搞明白这需求是咋来的；而在流程之后，还有一个被忽略的环节，就是总结，这个总结不是为了理清项目成果，而是想清楚除了项目拿了结果，自己从中收获了什么。</p><p style="text-align:justify">大家都是老司机，标准流程怎么干不说了，仅仅聊些小体悟：</p><span id="OSC_h4_4"></span><h4><br><strong>调研</strong></h4><p style="text-align:justify">调研这件事，我一开始是走偏了的，曾经我试图去自己走一走从用户诉求到产品需求的转换过程，但开发毕竟不是产品，虽然坊间经常说「人人都是产品经理」，但是不可否认的是，产品需要一定的思维和经验，如果这过程这么容易，那么就不需要设置单独的岗位来做这件事了，专业的事还是需要专业的人来干。那如果不去关注这个转换过程，开发同学还关心调研这事干嘛，等着看 PRD 不就行了？行是行，但是不好。</p><p style="text-align:justify">不知道大家有没有这样一种经历，辛辛苦苦做出来的东西，结果业务方拿到了以后说这个跟他们想的差的比较远，然后产技会劝说先试着用用看，结果用过一段时间就反馈说东西不行用着别扭，渐渐就不用了，长时间后产品落入了不再维护的境地里。可这事，也不能总怪产品同学写 PRD 不认真，也不能总怪技术同学做的不行，每一个个体由于自身的经验和思考方式的不同，对待同一个场景的理解是不同的，PRD 能清晰的描述逻辑，但是未必能描述初衷，尽管 PRD 的第一小节永远都是项目背景，别人嚼碎的东西咬着是不太费劲，但是就不知道一开始吃的是个啥了。</p><p style="text-align:justify">所以说，开发关注的调研是什么呢？这个核，大概率就是那个初衷，甭管产品写了啥，先去听听业务当初为啥跟你提起这件事、遇到了什么问题，为啥必须系统化的去解决，是因为搞不定、还是费人力、还是为了玩出个花活，有了自己的认知，回头再看看产品同学帮忙嚼碎后写出的 PRD，是不是把这个初衷不小心自己给咽下去了（别细想，怪恶心~），这样的 PRD 评审才有意义。</p><span id="OSC_h4_5"></span><h4><strong>设计</strong></h4><p style="text-align:justify">每个开发都有做架构师的梦想，这没毛病。一开始就是老老实实顺序写，后来就总想着封装、抽象、控制反转多玩点设计模式的花活，再后来就不满足于此了，甭管啥需求，开发过程不沉淀出个框架、工具来就不行，这过程只要是追求成长的开发同学都会经历，可这事吧，不怕不去干，就怕干的太过了，过犹不及。</p><p style="text-align:justify">所以怕的不是不设计，怕的是过度设计。</p><p style="text-align:justify">我超级喜欢辉子老师的<strong>CLED</strong>的概念，但是一度没有把这几种概念之间的边界搞清楚，想来也有不少相同经历的同学，为了追求无比闪耀的<strong>Configuration</strong>而做了一堆配置化的组件、工具、平台，动不动就上升到表达式的层面，尝试把所有的业务逻辑以表达式的方式进行表述，然后就导致在工程代码内完全看不懂这个系统到底处理了什么业务逻辑，一扒代码才发现这些逻辑都落在数据库或者 Diamond 里变成片段化的<strong>QLExpress</strong>或者<strong>SPEL</strong>了，再加上没有图形化的用于表述逻辑的配套设施，业务逻辑碎了一地。</p><p style="text-align:justify">回到设计的初衷，设计是为了解决问题存在的，不是为了单纯的秀，<strong>简单即好，适度设计</strong>。</p><span id="OSC_h4_6"></span><h4><strong>实施</strong></h4><p style="text-align:justify">骄傲是工程师的天性，具体一点，都会有一点设计洁癖和代码洁癖，但是随着工作的进行，总得慢慢的学会认识到一个道理：<strong>不是所有的事都能靠自己一个人搞定</strong>。所以上图流程里的实施和实现的区别，想说的也是这一点，实现是自己做的过程，实施是与别人与团队一起做的过程，配合与协同，转变思路是第一位的，这是起点。</p><p style="text-align:justify">那么一开始怎么做好配合呢，尤其是跟不熟悉的开发同学，在不熟悉做事风格的时候，怎么来沟通防止彼此掣肘？一个比较好的解题思路就是设定好领域边界，类比<strong>DDD</strong>里的概念，大家共识上下文，但是彼此靠边界做隔离，这里的边界的表现形式具体到过程里可以是接口范式、可以是排期设定、可以业务逻辑，然后剩下的，因为相信，所以看见就好。</p><p style="text-align:justify">然后协同的问题就在于又怕太相信到完全看不见，「这事反正有人负责了，过程做到什么程度无所谓了，反正最后能交付就好」，这种想法是非常危险的，过程要看得见，不要成了盲人，大家定一些关键节点的同步周期，合理控制下风险即可，当然也有频繁到每日发日报同步项目进度的，大项目人多沟通不便时这么搞比较好，但是人数少周期短的协作项目这样反而就会很占开发时间，还是老话，什么事都要讲究个适度。</p><span id="OSC_h4_7"></span><h4><strong>总结</strong></h4><p style="text-align:justify">这里想谈的总结不是那种项目战报，而是那种给自己看的<strong>真总结</strong>。</p><p style="text-align:justify">需求项目做了一年又一年，除了产品本身外，有没有给自己留下点能称得上「<strong>持续发展</strong>」的东西？很多时候，连续时段的忙碌，就把总结与回顾的过程忽略掉了，交付完拍拍屁股进入下一个，偶尔想想得失，也是很碎片的一些想法观点。其实细想想，这些细碎的东西整理整理就是所谓的<strong>产品观、架构风格、方法论</strong>，或者这些东西才是要比项目的结果对个人的发展来说，重要得多的东西。</p><p style="text-align:justify">另外这些事光想可不行，零散细碎不成系统的东西是不易被记忆的，需要整理、需要写下来。开发同学大多数不愿意在文字上下功夫（Me too），但是多尝试几次就会发现，每次写完总有一种醍醐灌顶、焕然一新的快感，也能在文字书写的过程中重新审视自己的观点，修正、优化、升华，反复捶打，终是精髓。当然每一件事都总结也不现实，没那么多时间，活还是要干的，阶段性的进行，加上定期的回顾，培养<strong>自身发展的节奏感就好</strong>。</p><p style="text-align:justify">对于一个技术开发人员来说，成长总在反复的经历每一个需求的过程中不断打磨，回到写在做事情开头的一句话上：「<strong>结果利他，过程利己</strong>」，结果当然重要，拿人钱财替人消灾，拿了薪水就要给出工作的结果，但是对于长线的发展而言，结果只是短暂的喜悦，而过程的体悟才是最该留在手里的东西，这玩意才是实实在在能够带着陪伴一生的东西。开发同学总爱说沉淀，这沉淀也得分两方面，看的见的沉淀是留在工程里的框架、工具，看不见的沉淀都在自己的脑子里，说白了如果干了一件事，没去细想或者想了一圈自己没思考到什么体悟，那么这事基本等于白干，所以对过程的思考这事要重视起来，好的善于做事情的人是耐得住寂寞的，也知道做的每一件事里自己在表面的需求达成过程中还需要追求什么沉淀，<strong>借事成己，才能不断到达新的高度</strong>。</p><span id="OSC_h3_8"></span><h3>想事情</h3><p style="text-align:justify">「难的不是想解法，难的是想问题。」</p><p style="text-align:justify">开发同学的工程师特性是善于做事情的，但是进到做事情里面去很容易，跳出来却很难。</p><span id="OSC_h4_9"></span><h4><strong>自驱</strong></h4><p style="text-align:justify">跟一个开发同学说，来设计一个用于某项功能的组件、中间件，大部分同学还是很容想到解法去做到的，但是跳出这件事本身，由开发同学自己去发现当前系统架构中应该构建一个具备某项能力的通用部分，而又不陷入「<strong>过度设计，空造轮子</strong>」的泥潭，确实是需要一定的时间、项目、知识、经验的积累，看看周围师兄前辈的那种游刃有余感，<strong>不要慌、不要急、多发掘、多观摩、多尝试</strong>，其他的也不用再唠叨，「馒头会有的，面包会有的，经验也会有的」，这件事迟早会做的到并且慢慢老道愈发醇熟。这个过程就是技术层面，开始想问题的过程，换个常听的词就是<strong>技术自驱</strong>。</p><p style="text-align:justify">但是在另外一个方面，跳出技术实现这件事，一个开发同学需不需要对业务有一定的提问能力？私以为还是要的。</p><p style="text-align:justify">首先，对应到前文说的调研过程里的初衷二字，要想理解业务同学初衷，前提是得懂业务才行，这里的懂不单单是指能听得懂，要想理解初衷，还需要能对现有存在的问题具备「<strong>同理心</strong>」，就是能确真理解业务提的这个问题的<strong>意义乃至情绪在哪</strong>。</p><p style="text-align:justify">其次，在此基础上，换个自己的视角去看到业务这些事情还有什么问题，说通俗点就是「<strong>眼里得有活儿</strong>」，业务同学是业务的专家但不是开发，很难具备开发思维，或许很多时候甚至都不会想到某些日常工作<strong>可以应用化</strong>或者<strong>需要应用化</strong>，习惯了模式再加上做的熟练，业务同学都会有自己日常处理事情的 SOP，很多事可能用个 Excel 就把数据都处理了，也就不会想还要什么系统，这些事情放在天生爱偷懒的工程师眼里，标准的流程和重复的工作应该让机器来干，就会有一个系统的雏形出现了，这样做出来的东西又有受众、又能释放人力、又能完成经验的传递（<strong>标准化的系统会降低同类工作领域内熟练者和非熟练者之间的差距</strong>），实在的很，如果看到业务同学之前总用手动的扳手拧螺丝，那我们就来尝试造一把电动的。</p><p style="text-align:justify">升华点，再来想想终极的问题，那些业务同学告诉你现在他们做不到的事情，是不是技术能做到？很多事做不到，仅仅是因为只有一个理想化的思路，然而非人力不可为，但是，系统的出现或许就能解决的掉。当然要做到这一点，没有长久的业务知识积累和自身对行业的理解是做不到的，也还有很长的路要走，但是要培养开始这样思考的意识，想得多了总会有的，再换个常听的词就是<strong>技术赋能</strong>。</p><span id="OSC_h4_10"></span><h4><strong>审视</strong></h4><p style="text-align:justify">一开始做事情，在面对需求的时候，很容易就开始直接思考能不能做以及怎么做的问题，但在此之前，其实还缺了问问题的过程，问什么？问那些做事情以外的内容，不敢说自己的问题有多全面，但我更习惯将整个过程称之为审视，我经常问的两个问题，一个是为什么要做，二是为什么要我来做，<strong>一问价值，二问站位</strong>。</p><p style="text-align:justify">在价值的问题上，区别于调研阶段的明确初衷以外，是要搞清楚这个事是不是个伪命题，以及这事这么干了能不能获得解决问题目标方向上的最大收获。其实，关于怎么评估价值，不同的场景千千万，难的不是<strong>如何定义价值</strong>，而是想到<strong>要先去定义价值</strong>，要明白俯首为牛的努力不完全可取。一件事情看不到价值就去做是去做苦功夫，<strong>但是苦劳不一定就是功劳，功劳更不一定有用</strong>，尽管很多事情在一开始的时候看不到结局，但是总会存在一个可以明确的初衷以及最初的判断，不可能凭借一句「我觉得行，我觉得有搞头」就扎进去做事情的，现在只有自己一个人的时候，可能只是浪费了时间，如果将来有了团队有了伙伴，这种模糊甚至于不过脑子的鲁莽会导致整个团队创造不出应有的价值，苦哈哈忙了一年没个好收成。</p><p style="text-align:justify">在站位的问题上，很多时候我们问的出对价值的拷问，但是却问不出站位的问题，站位和补位是有明显差别的，<strong>如果一件事情谁都能做，那为什么不是别人来做</strong>，难道仅因为跟我好说话就由我来做？其实并不尽然，一件事需要我做，总有需要我做以及适合我做且能做好的理由，哪怕仅仅是现阶段的，但这却是自身能区别于他人的理由，而这种区别也会体现在最终做事达成的结果上，每一个结果加上这个结果历经的过程都会带上非常浓重的个人或者团队色彩，而这个色彩的积累又会成为一个人或者一个团队区别于其他人或者其他团队独树一帜的东西。</p><p style="text-align:justify">提问和思考总是同步的，把思路开放到编码以外的事情上，看到事情会变得更加丰满，回过头来，再来思考什么是想事情，大概就是对于现有的内容要分析透彻，找到切入点和站位以及在结果表象下的内在价值；对于未来的问题，找到问题发生的可能寻找机会，找到个人和团队适合的发力点和着手点（抓手~）积极布局。</p><span id="OSC_h3_11"></span><h3>谈事情</h3><p style="text-align:justify">「凡人之所在，皆为江湖。」</p><p style="text-align:justify">更何况是我们这个号称江湖的江湖？</p><p style="text-align:justify">其实在此前，我会认为做事情和想事情才是重中之重最核心的内容，对于谈事情并不关注，工程师嘛，不爱整这些虚头巴脑的东西（技术牛逼，天下第一），但是时间长了就发现，很多事情没做成或者没做好，不是硬件能力不行，明明所有的情景看上去都没那么难也想的到明确解法，但是就是不成事。大家不妨回忆下跨领域查线上问题的时候，是不是总有这样一种感觉，明明问题的追查线路明确的很，就是你推他推，或者查着查着不知道在哪就没下文了，到最后拖个两三天甚至一周的时间才找到问题的原因，烂尾的也有不少。经历这种事多了，慢慢开始对一句至理名言产生了认同的情绪：</p><p style="text-align:justify">「所有问题，最终都是人的问题。」</p><p style="text-align:justify">常在管理层的分享中听到一个观点说：「<strong>管理就是用人成事</strong>」，说到底还是这个观点的延伸，给每一件事放到一个合适的位置上，找一堆合适的人，这件事就成了。但是人和人之间又不会像系统与系统间或者应用与应用间靠 MetaQ、HSF 就连起来了，还是得回到交流与沟通这些看似琐碎的事情上。</p><p style="text-align:justify">同时，每个人走到后面，总会有自己要做事找资源或者成为 PM 的时候，对于开发这个领域而言，机器硬件上的事都有的商量，但是找人一起来共同做一件事的时候却可能比要机器都难，总说开发资源，说到底不还是人。</p><p style="text-align:justify">只要是人，就要用人的方式来解决，「江湖不是打打杀杀，江湖是人情世故」。</p><span id="OSC_h4_12"></span><h4><strong>张嘴</strong></h4><p style="text-align:justify">回头看，能围着一件事稳稳当当的做，真的很可以称之为一种幸福，不需要跟任何人扯皮、只用做好自己的事，对于一名开发工程师而言是做舒服的状态。可是，就我的感受而言，当我慢慢走到前台需要用自己的嘴表达想法、推动进展的时候，才发觉这件事情或许会成为我乃至大多数工程师往前再走一步最致命的阻碍，张不开嘴，张嘴以后也不知道从何说起。</p><p style="text-align:justify">很多事情想明白需要做，也设计好了大概的执行思路，关键的问题在于，但凡有大作用的项目都需要有很多人参与，怎么让别人参与进来，让他人接受，给他人阐述清楚能够进场的位置并能共分成果却成了这件事能否做下去的关键。说句不太上台面的话，有没有人像我刚来的时候好奇过这样一个问题，为啥这个环境里再难的事，只要找一位「老阿里」出面，就能解决？按照我粗浅的认识不外乎两个原因：老师傅们能找到更多的资源，多到可能原来都不是干这一摊事情的人都能拉进来一起共担风雨；老师傅们也深切知道别人到底想听到什么、关注什么、担心什么、分享什么，能把这事的前因后果、核心价值、风险回报讲得明明白白，说服他人一起<strong>共同富裕</strong>。然后长此以往，老师傅们渐渐建立起了个人的品牌效应，大家慢慢就发现跟老师傅们合作有章法、效率高、有结果、不白干、为人靠谱、值得信赖，如果下次还遇到老师傅攒局就值得一起搞，那可不就能达到振臂一呼，勇往无前的效果？从这一点来看一句说「<strong>资源的本质就是人情</strong>」，也没什么太偏颇的。</p><p style="text-align:justify">除了谈资源外，与业务同学，需要理解需求的远景，再来谈定当前的近景，理想和规划总是宏大，但是怎么落到这一次的交付上；与产品同学，需要明确最终的产品设计方案与业务初衷是否有出入，迭代的分割与逐步推进节奏是否合理，找到一个既具备可行性又足以满足阶段性验证的体量范围，避免一上来大动干戈；与团队内的技术伙伴，对于一大包的需求要素和工时，怎么设定领域边界，让大家都能够更专注于自己的内容去一起把事情做出来；与兄弟团队的合作，怎么商榷交互的边界，团队与团队在某个具体问题上的划分点在哪里，才能既不冲突又无盲区。</p><p style="text-align:justify">相较于事情本身外，谈事情看似杂乱无章，但是开始尝试起来一但时间久了，也会形成自己的谈事情风格和方法论，这种东西大部分<strong>只可意会不可言传</strong>，重要的是<strong>要张嘴的意识</strong>，具体到场景和每个人的性格上，话术思路也不尽相同，或许有些事情别人谈不妥，但是你就能有谈妥的方案，最终也会沉淀为自身区别于他人的亮点，能说会道用的恰到好处了就不是贬义。</p><span id="OSC_h4_13"></span><h4><strong>闭嘴</strong></h4><p style="text-align:justify">张嘴好理解，但是闭嘴是什么呢？</p><p style="text-align:justify"><strong>该聆听的时候要闭嘴。</strong>一旦开始尝试谈事情，开始主导一些事情，这个过程在一段时间内容易上瘾，慢慢就会变得无论什么时候都想谈，有点打开了新世界大门的新奇感。但是，这个时候就需要警惕了，如果开了一场会议，完事以后脑海里只有自己的声音，就需要反思是不是自己开始听不进去事情了，是否忽略了合作人的观点，尽管基层的开发工作没那么官僚，但是还是要避免一言堂的出现。要明白，<strong>啥都管就是啥都不管</strong>，人的精力有限，不可能每一件事都关注到，总要学着放手与放弃的，学着去交出主动权，多去听别人有什么想法，想怎么搞，<strong>只要还在一张桌子上，说话叫谈，听话也叫谈，张嘴用嘴，闭嘴用耳。</strong></p><p style="text-align:justify"><strong>有情绪的时候要闭嘴。</strong>谈事情的时候切记不要带着怨气和敌意，很多人在谈判的桌子上总强调气场，这点没错，但是气场不是声音大、不是嗓子粗、不是拍桌子。不知道诸位有没有遇到的这样的场子，开会谈边界谈需求的时候，聊着聊着就吵起来了，吵的飞起来，到最后彼此针对的不是这件事，就是针对这个人，「针对」已经不是找关键点了，而是真成了拿针对戳着，会议冗长没准都开过吃饭的时间点，然后会议结束后也没个结论，不仅浪费时间也浪费心情，有这个时间多去食堂干碗饭不比什么都强。己所不欲勿施于人，大家都是来工作的，开会就是开会，谈事情就是事情，没必要争个谁把谁喷赢了，事情能办成就行，再说一句，低头不见抬头见的，总这么呛着跟别人谈事情，谁愿意跟你谈呢。善待周围的同事吧，他们是伙伴，是战友，很多事情都有的谈，无论是工作还是生活上的事都可以聊一聊，互相学习下经验，<strong>都是生来第一次做人，谁又敢说比别人活的通透，即便退隐江湖了，也不一定相忘于江湖。</strong></p><p style="text-align:justify">回到「谈事情」这三个字上，这里更想说的是一种意识，一种跳出事情、视人为人的意识，作为开发同学，学着认可说话是编码以外的软实力，慢慢的把自己的思路和做事方式转变起来，把仅以用什么样的代码来解决问题的观点转变下，也开始想想是否可用人来解决问题，不仅仅是团队需要管理，人际关系也是。</p><span id="OSC_h3_14"></span><h3>在最后的「结」</h3><p style="text-align:justify">想法浅薄，行文拙劣，粗陋之谈，个人观点。</p><p style="text-align:justify">若有帮助，荣幸万分，如觉无意，笑谈也罢。</p><p style="text-align:justify">当然还是希望能与感兴趣的同学多多交流~「永无止境，诸君共勉。」</p><p style="text-align:justify">作者｜向知</p><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1403806%3Futm_content%3Dg_1000387262" target="_blank">原文链接</a></strong></p><p style="text-align:justify"><strong>本文为阿里云原创内容，未经允许不得转载。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 13 Jan 2024 02:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10576005</guid>
            <link>https://my.oschina.net/yunqi/blog/10576005</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[罗永浩细红线公司转做大模型？内部人士：不实，仍专注 AR 研发]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>搜狐科技今天下午报道，罗永浩的细红线 AR 业务软硬件研发放缓、AR 相关业务裁员，或将转向大模型行业。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-31b283e926e185d438709c4c767920d8593.png" referrerpolicy="no-referrer"></p><p>有行业高管向搜狐科技透露，罗永浩已不再做 AR 硬件，可能打算去做大模型，「他就是投机分子。」 一位被裁员的细红线员工告诉搜狐科技，元旦前细红线的 AR 业务确实有一轮裁员，且并非首轮裁员。该员工透露，「自研引擎方向不做了，设备这块儿也不急了。」</p><p>据悉，细红线的引擎和 XR 应用研发正式编 12 人，研发 10 人左右，整体裁了一半的人。据企查查显示，细红线科技人员规模不足 50 人，2022 年参保人数 35 人。该员工透露，公司给到的裁员解释就一句话「这块儿不做了」，入职不到半年的员工赔偿方案也给了 N+1。该员工表示，入行后他的感知是，「该行业是长期积累才能出成果的，基本是长期烧钱投入。」他对裁员表示理解。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffinance.sina.com.cn%2Ftech%2Fshenji%2F2024-01-12%2Fdoc-inachcsx4929830.shtml" target="_blank">新浪科技进行了后续跟踪报道</a></u>，针对媒体报道「罗永浩的细红线公司业务从 AR 转型大模型」一事，该公司人士称，报道不实，罗永浩仍专注于 AR 软硬件。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e250506e141bb2f5d72156e7043145e092d.png" referrerpolicy="no-referrer"></p><p>一个月前，罗永浩在直播时谈及了其创业项目细红线的进展。他表示，已经埋头研发了一年，故意没有声音。</p><p>此前，罗永浩曾表示，绝对相信 AR 会是下一代计算平台，尤其是现在的 AR 在全球都没有一个成功的品牌和标杆。他想在 AR 时代抢先做出一个像 2007 年的 iPhone + iOS 一样的东西，成为下一个平台上类似苹果一样的公司。「这是最后一次机会，相信一定会给这个世界留下一些东西。」</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 10:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275479</guid>
            <link>https://www.oschina.net/news/275479</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[中电金信加入 openKylin，携手推动金融应用生态建设]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span><span style="color:#000000">近日，中电金信软件有限公司（以下简称「中电金信」）签署了 openKylin 社区 CLA（Contributor License Agreement 贡献者许可协议），正式加入 openKylin 开源社区。</span></span></p><div><p style="text-align:center"><img alt="" height="1079" src="https://oscimg.oschina.net/oscnet/up-0405c82222935966a1c10f116c1852f2647.png" width="829" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">中电金信，中国电子旗下成员企业，通过持续研发创新，参与国家重大工程，依托行业场景，构建金融级数字底座，打造全栈全域解决方案，提供领先的咨询、软件产品及开发、质量安全保障及运营服务，为金融等重点行业数字化转型及安全发展提供强大动能，并以中国数字化转型最佳实践服务全球。</span></span></p><div><p style="text-align:center"><img alt="" height="410" src="https://oscimg.oschina.net/oscnet/up-efb7554bb3a11fbb0bfbd65ba61da97d2ba.png" width="940" referrerpolicy="no-referrer"></p></div><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span><span style="color:#000000">加入 openKylin 社区后，中电金信将利用自身在金融行业里的优势资源，依托 openKylin 社区开展金融应用生态汇聚平台建设与推广，从而完善 openKylin 开源操作系统在金融领域的应用生态。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 09:06:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275465</guid>
            <link>https://www.oschina.net/news/275465</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[盘点 2023 「很刑」的 IT 民生事件：视频软件白嫖带宽、程序员改 ETC 余额……]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>关注 IT 相关民生事件，以老百姓的眼睛看 IT 圈，和开发者零距离接触。回顾一下 2023 年那些很刑的 IT 民生事件。</p><hr><h4><a href="https://www.oschina.net/news/248591">爱奇艺客户端「白嫖」电视机带宽，后台满速上传</a></h4><p>一网友发帖称，自己的电视机在息屏休眠状态时，居然持续保持着 1-5M/s 的上传速度，直至断掉电源才停止上传。</p><p>而这台新买的电视机上安装的 APP 只有爱奇艺。在他强制关闭爱奇艺 APP 后，电视机的上传速度马上变为零。</p><p>对此，爱奇艺客服给出的回应是，这是加速手段，对使用没有影响，并提供了关闭 HCDN 开关的操作。HCDN (Hybrid CDN) 是爱奇艺技术团队研发的大规模混合架构在线视频数据分发技术。</p><p>有网友指出，这是爱奇艺客户端将电视机当成了自己的 PCDN 服务器，因此会在后台持续执行上传任务。这种白嫖电费、流量、存储空间的操作，爱奇艺要给用户打钱才对。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a9c6a586c98baf79a09b17e5874bea9908e.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/247736">人大毕业生盗取全校学生信息建颜值打分网站，</a><a href="https://www.oschina.net/news/247736">结局很「刑」</a></h4><p>中国人民大学一名硕士毕业生涉嫌在校期间非法获取全校学生的个人信息， 并利用这些信息制作了一个给学生颜值打分的网站。</p><p>针对 「中国人民大学部分学生信息被非法获取」 的情况，海淀警方接到报警，后立即开展调查。 经查，嫌疑人马某某（男，25 岁，该校毕业生）涉嫌非法获取该校部分学生，个人信息等违法犯罪行为，后被海淀公安分局依法刑事拘留。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9c5534c3ac21396855978eba5ff4ec4956f.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/247569">员工盗用公司游戏源代码「换皮」上线，半年盈利 1.5 亿</a></h4><p>上海一游戏公司三名员工利用职务之便，在从原公司离职前盗取了公司开发的手游源代码；并将该手游的源代码提供给了另一家网络公司，对方进行简单「换皮」之后就开始上线经营。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-23335c46b5ab4511525521a720cc3f319ce.jpg" referrerpolicy="no-referrer"></p><p>为了成功上线，离职员工还套用了原公司的《计算机软件著作权登记证》和《网络游戏出版核发单》。警方鉴定发现，两款游戏在服务器数据表和服务器战斗服上的相似度达到 100%，服务器游戏服和客户端相似度也在 90% 左右。</p><p>据统计，自盗版游戏上线半年以来，盈利超过 1. 5 亿，盗取源代码的三名员工分得利润超过 1500 万。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/259325">罚款 200 元，没收 100 多万</a></h4><p>2023 年 9 月，一微博博主发文称自己 「翻墙访问国际互联网打工被处罚百万」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-4c9d4c52a10a1b05cf39730b000daa514e2.png" referrerpolicy="no-referrer"></p><p>根据这名博主提供的资料，在 2019 年 9 月份至 2022 年 11 月期间，他在家中擅自使用非法信道进行国际联网，为境外公司提供网络顾问服务，违法所得共计人民币 1058000 余元。</p><p>根据《中华人民共和国计算机信息网络国际联网管理暂行规定》第六条和第十四条、《中华人民共和国计算机信息网络国际联网管理暂行规定实施办法》第七条和第二十二条第一款之规定，这名博主受到了行政处罚，并处罚款贰佰元整，没收违法所得一百零五万八千元。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/267760">程序员篡改 ETC 余额，一年私吞 260 余万元</a></h4><p>2023 年 9 月，上海警方接到某科技公司员工张女士报案称，其公司发现计算机系统被他人篡改数据，导致公司账户钱款损失。民警对公司后台电子数据出现的异常账户进行提取，搜证中发现，操作者很有可能是管理网站后台系统的员工，监守自盗的可能性较大。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/1123/140254_7G6Y_2720166.png" referrerpolicy="no-referrer"></p><p>民警随即展开工作，最终嫌疑人曹某迫于压力主动投案自首。曹某是该公司的软件工程师，他坦白称，去年 8 月发现公司网站后台的漏洞，用母亲和朋友身份证注册了两个 ETC 账户。一年内两个账户分别从公司提取来了 230 余万元和 36 万元，总计 260 余万元。最终曹某因涉嫌盗窃罪被依法刑事拘留。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/question/4518173_2330072">知名主播售卖基于开源软件的解决方案，收费 2 万</a></h4><p>B 站 50 万粉丝 up 主通过另一名知名主播购买基于开源软件的导播台方案：将手机摄像头画面推流到 PC，再通过 OBS 推流，使用了 Zerotier + 芯象。共计支付 2 万。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2b14fad8ac6829292d6a10e158067f840bc.png" referrerpolicy="no-referrer"></p><p>网友称这名 up 主喜提超级憨憨大冤种奖。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/258135">网易伏羲回应员工「因 BUG 被 HR 威胁」离世</a></h4><p>2023 年 9 月，网传消息称，网易伏羲团队员工因工作原因在出租屋自杀离世；并表示，该员工曾 「因 BUG 被 HR 威胁」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-c6939d41a10f9b07824a2c51be44ec3f285.png" referrerpolicy="no-referrer"></p><p>9 月 14 日，网易伏羲针对此事发布内部信公布事发经过，称员工存在抑郁倾向，HRBP 在了解到情况后为其安排了休假。并表示经过调查还原和分析，暂未发现 「HR 威胁」 相关动机和证据。</p><p>与此同时，该公司还公布了一系列后续关怀方案。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/251050">新型 Apple ID 诈骗：开启双重认证仍被钓鱼</a></h4><p>2023 年 7 月，V2EX 有网友发帖详细描述了一个新的诈骗过程：在 Apple ID 开通双重认证的情况下，被高仿的李鬼 App 诱骗出密码，并被添加信任号码、家庭共享，再通过家庭共享成员完成消费。但整个过程中，原设备并未出现新设备登录时需要的双重认证验证码，也就是说双重验证并未起作用。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ea62ba234788657a2c24a9dc589879e9f59.png" referrerpolicy="no-referrer"></p><p>根据博主 @BugOS 技术组，的测试，受信设备中的应用拉起隐藏 WebView 访问 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fappleid.apple.com" target="_blank">appleid.apple.com</a> 无需双重验证，这一重大漏洞使得用户扫个脸即可登录。该 App 又用假的对话框骗取密码，然后将诈骗者的手机号加入双重认证的信任号码，直接远程抹掉设备，使用户无法接收扣款信息，并进行盗刷。</p><p>并表示，当 iPhone 上出现输入 Apple ID 密码的窗口时，按 Home 键或上划手势尝试退出一下，能退出的都是在诈骗。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/258341">1400 多万部老年手机被植入木马，「自动订购」 增值业务</a></h4><p>四川省攀枝花市公安机关网安部门在 2023 年成功侦破一起非法控制计算机信息系统案。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/0916/113005_rqI2_2720166.png" referrerpolicy="no-referrer"></p><p>经警方调查，犯罪嫌疑人与老年手机方案商、生产商勾结，在老年机生产环节中植入木马程序，在手机使用者不知情的情况下，后台订购 SP 增值业务，并与 SP 商分成获利（SP 即 Service Provider，服务提供商）。</p><p>2023 年 2 月，公安机关对该案开展集中收网，专案民警分别赶赴广东、北京、海南、湖南等地共抓获嫌疑人 29 名，冻结涉案资金 6000 余万元。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/260711">苹果 App Store 免费榜第一是黄色软件</a></h4><p>苹果 App Store 被发现存在一个伪装成学习软件的黄色软件，并且冲上了「免费 App」排行榜第一名。该软件的年龄分级为 4 岁以上，但是会引导用户进入赌博和其他黄色网站。有网友下载了这款软件，想要学习英语字母，结果却发现是一个色情视频软件。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-69f6205b4eceb10672c0a3cff67e4f52d48.png" referrerpolicy="no-referrer"></p><p>事件被曝光后，苹果客服虽然进行了回应，但直到当天下午仍未下架软件。甚至排行榜更新后，App Store 免费榜第一、二名再次出现黄色软件。</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/261799">国美 App 抽奖页面弹窗辱骂其创始人</a></h4><p>2023 年 10 月，在国美 iOS 和 Android App 的 「幸运大转盘」 抽奖页面出现了一个弹窗，里面包含辱骂国美电器董事长黄秀虹、创始人黄光裕的内容，以及指控国美 「拖欠工资」「拖欠货款」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-5d1b6e65dedc28ef9f0bf144a3378dd109b.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/265338">继 VS Code 后，开源直播推流软件 OBS Studio 被卖 43 元</a></h4><p>百度搜索 "obs"，前几条基本都是广告。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9f209a6215794edd03066f3bc45f8b963b6.png" referrerpolicy="no-referrer"></p><p><img alt="up-aff319a90e79bfd09a3e9087d4164b93866.png" src="https://oscimg.oschina.net/oscnet/up-aff319a90e79bfd09a3e9087d4164b93866.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/267276">运营商神操作：后台断网、停用宽带账号，强迫用户更换光猫</a></h4><p>河南周口联通为了强迫用户更换光猫，公司在后台停掉用户的宽带账号，导致用户无法上网，然后让工程师上门 「维修」， 谎称光猫损坏，需要花 299 元换新。更换完后，联通再在后台恢复用户的网络。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/1120/163843_Utox_2720166.png" referrerpolicy="no-referrer"></p><p>联通公司不仅对老用户进行这种强制更换光猫的行为，还会在给新用户装机的时候，故意使用破旧光猫，也就是之前强迫用户换新留下的，而再过一段时间之后，又会告诉用户使用的是旧光猫无法匹配，必须换新。联通公司还会故意关掉用户的短信服务，在后台增加增值业务，之后再把短信功能打开，以此牟利。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-6bca55961849d5db6bafd2b8cf31a04abc6.png" referrerpolicy="no-referrer"></p><p>这种强制更换光猫的行为并非新鲜事。早在 2022 年上半年，就有不少用户投诉联通公司，以宽带升级为由强制用户更换光猫，否则就无法上网。其中有的投诉明确是河南联通公司，有的则未明确具体地区。</p><hr><p>其他年度盘点：</p><ul><li><u><strong><a href="https://www.oschina.net/news/273501">B 站崩了两次、腾讯「3.29」一级事故……盘点 2023 十大宕机事故「冥场面」</a></strong></u></li><li><u><strong><a href="https://www.oschina.net/news/273843">MySQL 5.7、魔趣、李跳跳……盘点 2023 「停更」的项目和网站</a></strong></u></li><li><u><strong><a href="https://www.oschina.net/news/274330">.NET 8、Mojo🔥、Bun 1.0……最硬核极客的年度发版汇总</a></strong></u></li></ul><p>更多年度重磅事件回顾，<em><u><strong><span style="background-color:#e67e22">查看</span><a href="https://talk.gitee.com/report/china-open-source-2023-annual-report.pdf?fr=1024eye_news0112" target="_blank"><span style="background-color:#e67e22">《2023 中国开源开发者报告》</span></a></strong></u></em>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-d61e19776f176f066edf96c9d335883b471.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-ea5bc926c05237a7f7970438f10c5a0e3d2.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 07:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275447</guid>
            <link>https://www.oschina.net/news/275447</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linus 在 Linux 6.8 内核发现性能倒退问题]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Linus Torvalds 在内核邮件列表<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Flkml%2FCAHk-%3DwgWcYX2oXKtgvNN2LLDXP7kXkbo-xTfumEjmPbjSer2RQ%40mail.gmail.com%2F" target="_blank">指出</a></u>，他最近在合并 Linux 6.8 内核代码的时候发现性能下降——具体表现是构建时间异常的久。</p><p>Linus 表示，以编译构建空内核 (empty kernel build) 版本为例，创建时间从 22 秒变成了 44 秒，这也让编译构建完整内核的速度大大降低。Linus 称导致性能衰退的代码就出现在这些等待合并的 Pull 代码中，所以他不得不还原某些东西 —— 这让 Linux 6.8 内核的合并窗口期非常痛苦。&nbsp;</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-a76bd7e29f257c823ca9c6578aa7e8efd5d.png" referrerpolicy="no-referrer"></p></blockquote><p>Linus 继续<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Flkml%2FZTz9RpZxfxysYCmt%40gmail.com%2FT%2F%23t" target="_blank">写道</a></u>：</p><blockquote><p>如果没猜错的话，第一个错误提交是 9c0b4bb7f6303c9c4e2e34984c46f5a86478f84d，但为了干净地恢复，我必须对所有代码都进行恢复。</p><p>这是在 32 核（64 线程）AMD Ryzen Threadripper 3970X 上实现的。</p><p>我将暂时把该还原保留在我的私有测试树中（这样我就又有了一台能正常工作的机器），但除非有人能快速解决这个问题，否则我会将其从主分支中移除。</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 07:24:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275438/linux-6-8-sched-regression</guid>
            <link>https://www.oschina.net/news/275438/linux-6-8-sched-regression</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[中国电信星辰 AI 大模型开源]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>中国电信宣布将自研星辰 AI 大型模型全面开源，公开其底层代码、算法逻辑及其预制的各种基础大模型、开发模块、训练工具等核心产品能力。</p><p>用户既可以直接调用大模型，也可以根据自身业务需求对大模型进行微调或个性化设置，或者加载自己的知识库或数据，从而调整出更符合自身业务需求、更加个性化的理想结果。</p><p>根据介绍，由中国电信完全自主研发的国内领先星辰系列大模型，构建了语义、语音、视觉及多模态大模型完备的基础框架。其中语义大模型于 11 月份发布千亿参数版本，在大模型知名榜单 CSL 排名第五、GAOKAO 排名第七、AGIEval 排名第八。</p><p>视觉大模型赋能 100+城市治理下游任务，算法日均调用量达 3.3 亿次；多模态大模型聚焦图文生成和图文理解能力，采集超过 12 亿的风格数据，文图检索精度达到 SOTA，支持 20+风格生成。</p><p>语音大模型可实现高精度多方言的语音识别以及多语种、多风格、多音色的语音合成。与此同时，中国电信星辰系列大模型在覆盖视觉、语义、语音等多模态领域的 20 项国内外权威竞赛中斩获多项大奖，充分展现了国资央企在人工智能领域的自研实力和决心。</p><p>2023 年 11 月，中国电信宣布成立了中电信人工智能科技有限公司，专注于 AI 核心技术的研发。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 05:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275416</guid>
            <link>https://www.oschina.net/news/275416</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[新一代通信协议 - Socket.D]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h3>一、简介</h3><p style="color:#24292e; text-align:start">Socket.D 是一种二进制字节流传输协议，位于 OSI 模型中的 5~6 层，底层可以依赖 TCP、UDP、KCP、WebSocket 等传输层协议。由 Noear 开发。支持异步流处理。其开发背后的动机是用开销更少的协议取代超文本传输协议 (HTTP)，HTTP 协议对于许多任务 (如微服务通信) 来说效率低下。</p><h3>二、设计目标</h3><ul><li>协议接口丰富，包括 Send, SendAsRequest, SendAndSubscribe，Reply，ReplyEnd</li><li>支持应用层流量控制</li><li>支持单连接双向、多次复用</li><li>支持断连后自动重连</li><li>可以更好的使用 WebSocket 协议</li></ul><h3>三、消息驱动</h3><p style="color:#24292e; text-align:start">网络通信是异步的，Socket.D 协议包含这一点，并将所有通信建模为在单个网络连接（TCP）上的、多路复用的消息流，在等待响应时从不同步阻塞。</p><p style="color:#24292e; text-align:start">响应式宣言指出：</p><pre><code class="language-    ">反应式系统依赖异步的消息传递，从而确保了松耦合、隔离、位置透明的组件之间有着明确边界。 这一边界还提供了将失败作为消息委托出去的手段。 使用显式的消息传递，可以通过在系统中塑造并监视消息流队列， 并在必要时应用回压， 从而实现负载管理、 弹性以及流量控制。 使用位置透明的消息传递作为通信的手段， 使得跨集群或者在单个主机中使用相同的结构成分和语义来管理失败成为了可能。 非阻塞的通信使得接收者可以只在活动时才消耗资源， 从而减少系统开销。
</code></pre><p style="color:#24292e; text-align:start">此外，HTTP/2 FAQ 很好地解释了在持久连接上采用多路复用的面向消息的协议的动机：</p><ul><li>HTTP/1.x 有一个叫做 「head-of-line blocking（队头阻塞）」 的问题，在这种情况下，即在一个连接上一次只能有一个未完成请求。</li><li><p>HTTP/1.1 试图通过流水线（Pipelining）来解决这个问题，但它并没有完全解决这个问题 (大的或慢的响应仍然会阻塞后面的其他响应)。此外，人们发现流水线很难部署，因为许多代理和服务器不能正确地处理它。 在 HTTP/1 中使用并发连接和域名分片来缓解 HOL 问题</p></li><li><p>并发连接，浏览器针对每个源（域名）可以打开 4-8 个 TCP 连接，提升并发度。</p></li><li>域名分片，浏览器和 HTTP/1 限制了并发连接的数量，那么就把多个域名指向一台服务器，从而提升连接数量。 这迫使客户端使用一些启发式方法（通常是猜测）来确定什么请求在什么时候放在与源站的哪个连接上；由于加载一个页面的次数通常是可用连接数量的 10 倍或者更多。这会导致被阻塞的请求「瀑布式」的增长，从而严重的影响性能。</li></ul><p style="color:#24292e; text-align:start">多路复用通过允许多个请求和响应消息在一个连接上同时传输来解决这些问题；甚至可以将一条消息的部分与另一条消息的部分混合在一起。</p><p style="color:#24292e; text-align:start">使用 HTTP/1，浏览器为每个源打开 4-8 个连接，由于许多站点使用多个源，这可能意味着打开单个页面要加载 30 多个 TCP 连接。</p><p style="color:#24292e; text-align:start">一个应用程序同时打开如此多的连接，打破了 TCP 所建立的许多假设；由于每个连接都会在响应中传输大量的数据，因此 TCP 缓冲区很大可能会溢出，从而导致拥塞事件和超时重传。</p><p style="color:#24292e; text-align:start">一个应用程序同时打开如此多的连接，此外，使用如此多的连接不公平地垄断了网络资源，「窃取」了其他性能更好的应用程序（如 VoIP）的资源。</p><h3>四、协议交互模型</h3><p style="color:#24292e; text-align:start">不合适的协议会增加系统开发的成本。它可能是一个不匹配的抽象，但是我们必须将系统设计强加到他允许的交互模型中。这迫使开发人员花费额外的时间来解决它的缺点，以处理错误并获得可接受的性能。在多语言环境中，这个问题被放大了，因为不同的语言将使用不同的方法来解决这个问题，这需要团队之间的额外协调。到目前为止，通信协议事实上的标准是 HTTP，它只支持请求/响应的交互模式。在某些情况下，这可能不是最理想通信模型。</p><ul><li>Send（只管发送，不要结果）</li></ul><p style="color:#24292e; text-align:start">发完就不管是请求/响应的优化，在不需要响应时很有用。它允许显着的性能优化，不仅仅是通过跳过响应来节省网络使用，而且还可以减少客户端和服务器的处理时间，因为客户端不需要记录和等待请求关联的响应和取消请求。</p><p style="color:#24292e; text-align:start">此交互模型对于支持有损的用例非常有用，例如非关键事件日志记录、或者设备信息上报。</p><p style="color:#24292e; text-align:start">像这样使用：</p><pre><code class="language-java">clientSession.send(<span style="color:#50a14f">"/demo"</span>, entity);
</code></pre><ul><li>SendAsRquest（发送一个请求，并要求一个响应）</li></ul><p style="color:#24292e; text-align:start">仍然支持标准请求/响应语义，并且仍有望代表 Socket.D 连接上的大多数请求。这些请求/响应交互可以被认为是优化的「只有 1 个响应的流」，并且是在单个连接上多路复用的异步消息。</p><p style="color:#24292e; text-align:start">消费者「等待」响应消息，所以它看起来像一个典型的请求/响应，但它从不同步阻塞。</p><p style="color:#24292e; text-align:start">就像 http 一样使用：</p><pre><code class="language-java"><em>//同步等待</em><span style="color:#986801">let</span><span style="color:#986801">response</span><span>=</span> clientSession.sendAndRequest(<span style="color:#50a14f">"/demo"</span>, entity).await();

<em>//异步回调</em>
clientSession.sendAndRequest(<span style="color:#50a14f">"/demo"</span>, entity).thenReply(response =&gt; {

});
</code></pre><ul><li>SendAndSubscribe（发送一个订阅，可以接收多个答复）</li></ul><p style="color:#24292e; text-align:start">从一个请求一个响应那儿延伸出来的是多个响应，它允许多条消息流回。将此视为「集合」或「列表」响应，但不是将所有数据作为单个响应返回，而是按顺序流回每个元素。</p><p style="color:#24292e; text-align:start">用例可能包括以下内容：获取视频列表，在目录中获取产品，逐行检索文件。</p><p style="color:#24292e; text-align:start">可能有点像 mq，还可能通过 range 指定数据区间（或者不指定）：</p><pre><code class="language-java"><em>//异步回调</em>
clientSession.sendAndSubscribe(<span style="color:#50a14f">"/demo"</span>, entity.range(<span style="color:#986801">0</span>,<span style="color:#986801">5</span>)).thenReply(reply =&gt; {
      <span style="color:#a626a4">if</span>(reply.isEnd()){
          <em>//如果需要识别最后一个？</em>
      }<span style="color:#a626a4">else</span>{
          <em>//</em>
      }
});
</code></pre><h3>五、协议形式</h3><ul><li>连接上传输的数据可称之为流，每个消息都会有一个 sid（流 Id）</li><li>流（Stream）由帧（Frame）组成</li><li>帧（Frame）包含了流 Id（Sid）、事件（Event）、元数据字符串（MetaString）及数据（Data）</li></ul><p style="color:#24292e; text-align:start">帧码结构为：</p><pre><code class="language-css"><span style="color:#986801">[len:int]</span><span style="color:#986801">[flag:int]</span><span style="color:#986801">[sid:str(&lt;64)]</span><span style="color:#986801">[\n]</span><span style="color:#986801">[event:str(&lt;512)]</span><span style="color:#986801">[\n]</span><span style="color:#986801">[metaString:str(&lt;4k)]</span><span style="color:#986801">[\n]</span><span style="color:#986801">[data:byte(&lt;16m)]</span></code></pre><p style="color:#24292e; text-align:start">Socket.D 是一个二进制协议，也就是说在一个 Socket.D 连接上传输的消息体对数据格式没有任何要求，应用程序可以为所欲为的压缩数据量的大小。</p><p style="color:#24292e; text-align:start">这样的二进制协议通常来说能给性能带来极大的提升，但是产生的代价是，网络中间件也会因为无法解读消息体中的数据，丧失了在对具体应用流量进行监控，日志和路由的能力。Socket.D 通过把每个消息体分成 metaString 和 data 的方式，在保证高效传输的前提下，提供了暴露少量元数据给网络中间件的能力。</p><ul><li>data 一般作为应用本身需要传递的业务数据，采取自定义的高效序列化方式，且对网络基础设施不可见。</li><li>metaString 采用标准的 urlQueryString 格式。在分布式传输的过程中，这些中间件可以按需求对 metaString 进行读写，然后监控应用健康状况或者调整路由。</li></ul><h3>Socket.D 有哪些适用的场景？</h3><ul><li>移动设备与服务器的连接</li><li>数据双向传输，且支持流量控制。</li><li>支持连接修复，比如手机进地铁之后，网络断开一段时间，其他协议需要重新建立连接，Socket.D 会自动修复连接。</li><li>微服务场景</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 04:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275396</guid>
            <link>https://www.oschina.net/news/275396</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[RustRover 中最常见的 Rust 编译器错误（上）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><p style="text-align: center;" data-mpa-powered-by="yiban.io"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100021881" data-ratio="0.1836734693877551" src="https://oscimg.oschina.net/oscnet/d9b44586-4a1a-4d06-b939-38535ee2708a.gif" data-type="gif" data-w="637" style="display: inline;" referrerpolicy="no-referrer"></p><section style="font-size: 15px;color: rgb(33, 33, 33);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">Rust 编译器相当挑剔， 如果它对输入的源代码不满意，可能会发出 400 多种不同的错误（而且每个月都在增加！）。有些错误极其罕见，另一些则每天都困绕着 Rust 开发者。在这个博文系列中，我们将介绍开发者在 RustRover（JetBrains 推出的专属 Rust IDE）中遇到的最常见 Rust 编译器错误消息，并说明如何避免这些错误。首先，我们来看一下「最常见错误」实际上指的是什么。</p><span id="OSC_h2_1"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">从 RustRover 的使用数据中识别最常见的错误</span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">任何 RustRover 用户都可以选择向 JetBrains <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.jetbrains.com.cn%2Fhelp%2Fidea%2Fsettings-usage-statistics.html" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">发送其匿名使用数据</a>。通过分析这些数据，我们可以观察各种用户模式并深入探究如何改进 IDE。当然，我们非常重视您的隐私，因此 IDE 收集的信息非常有限。例如，数据中的任何内容都无法追溯到用户。但匿名数据仍然可以告诉我们 IDE 的一般使用情况，例如最常生成的错误消息类型。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">当选择加入的用户通过 IDE 启动 Cargo Build 命令（例如，通过触发需要构建项目的运行配置）并且 Rust 编译器发出错误时，我们就会记录<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror_codes%2Ferror-index.html" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">错误代码</a>。这不包括用户编写代码时出现的<em style="font-size: inherit;color: inherit;line-height: inherit;">所有</em>代码问题，仅包括在用户构建项目后仍然存在的问题。中间错误通常可以通过 IDE 的检查和快速修复处理。用户向我们发送的使用数据越多、使用 RustRover 的频率越高，我们就越能了解他们的体验，也就越能改进 IDE 的代码辅助功能。因此，感谢所有加入的用户通过其使用数据帮助我们改进 RustRover！</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">我们从运行 RustRover 的用户处收集错误代码，并根据遇到错误的用户数量对其排名。本系列的这一部分将讨论第 10 到 6 名最常见错误，下一部分将揭示前 5 名最常见错误。我们将研究这些错误背后的原因，探索简单示例，并探讨潜在修正方式。</p><span id="OSC_h2_2"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">常见错误 #10：E0412<em style="font-size: inherit;color: inherit;line-height: inherit;">（使用的类型名称不在作用域内）</em></span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">Rust 在类型声明点和类型名称用法之间保持严格区分。每个类型名称（包括泛型类型）都必须在某处声明，并且在其使用作用域内可用。如果编译器遇到类型名称用法但没有关于其声明点的任何信息，则会发出 E0412。大约 12% 的 RustRover 用户遇到过此错误。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">假设您输入了 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">i42</code> 而不是 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">i32</code>， RustRover 会发现问题并高亮显示未知类型名称。编译器提供了更多详细信息并建议修正，点击编译器输出中的 <em style="font-size: inherit;color: inherit;line-height: inherit;">Apply fix</em>（应用修正）按钮即可轻松应用：</p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-imgfileid="100021882" data-ratio="0.562962962962963" src="https://oscimg.oschina.net/oscnet/b1e477d9-a790-4641-ae7b-73db95282f28.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption></figure></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">其他导致 E0412 的情况包括：</p><ul style="font-size: inherit;color: inherit;line-height: inherit;padding-left: 32px;" class="list-paddingleft-1"><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">忘记声明类型。</span></p></li><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">将类型导入到当前作用域。</span></p></li><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">引入泛型类型名称而使编译器无法访问类型。</span></p></li></ul><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">要修正这一问题，可以提供类型声明（声明结构或正确引入泛型类型名称）或将类型引入作用域（通过 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">use</code> 子句）。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror_codes%2FE0412.html" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">官方 E0412 错误说明</a>给出了此错误的更多示例。</p><span id="OSC_h2_3"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">常见错误 #9：E0061（<em style="font-size: inherit;color: inherit;line-height: inherit;">调用函数时传递的实参数量无效</em>）</span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">虽然 RustRover 可以感知到这个错误并提供一系列修正，但 13% 的 RustRover 用户会在构建项目之前忽略这个错误。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">错误本身不需要过多解释：我们有一个函数，要么在当前作用域中声明，要么从其他地方导入，而调用点给出的实参太少或太多。我们来看一个示例，并比较 RustRover 的建议和 Rust 编译器的建议：</p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-imgfileid="100021892" data-ratio="0.562962962962963" src="https://oscimg.oschina.net/oscnet/a3e4b8f4-6b6a-4f1f-aa79-cfbb6ef242ba.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption></figure></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">这个示例展示了一个<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fadventofcode.com%2F" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">常见场景</a>：打开文件。如果我们习惯了使用其他编程语言编码，就可能提供第二个实参，忘记在 Rust 中这个方法只需要一个实参。RustRover 和 Rust 编译器都建议移除第二个实参。很好，我们不需要构建项目就可以从 IDE 获得实用建议。注意代码中的红色波浪线，它们通常都有意义！</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">如果调用的函数是在我们自己的代码中定义的，情况就更有趣了。假设我们继续添加到相同的代码示例：</p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-imgfileid="100021883" data-ratio="0.562962962962963" src="https://oscimg.oschina.net/oscnet/42fae6ba-c908-48d3-a891-c9bfceb1a339.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption></figure></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">在这种情况下，RustRover 建议向函数添加形参作为第一个替代方案，这应该没有问题。但 Rust 编译器则坚持将其移除。这种差异有其原因。编译器的工作是确保程序正确，为此，最简单的方式就是消除调用点的额外实参。然而，IDE 的作用是让您更接近您想要达成的目标。如果您是为自己的函数输入了这个实参，那么您很有可能是有意为之，因此 RustRover 会尝试帮助您完成工作。</p><span id="OSC_h2_4"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">常见错误 #8：E0282（<em style="font-size: inherit;color: inherit;line-height: inherit;">编译器无法推断类型并要求类型注解</em>）</span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">有时编译器会不知所措，无法确定变量所需的类型，只能建议手动添加类型注解。如果您遇到过这个错误，您并不孤单，13.5% 的 RustRover 用户也遇到过。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">E0282 这样的错误主要源于泛型性。许多库函数都采用泛型类型形参，但编译器必须将这些形参实例化为具体类型，因而陷入困惑。请查看以下示例：</p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-imgfileid="100021884" data-ratio="0.562962962962963" src="https://oscimg.oschina.net/oscnet/978d3023-c1c4-4b46-83fc-18c4a6b2dc55.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption></figure></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">我们想要将字符串中的数字收集到容器中。然而，编译器不能确定它们是什么类型的数字或什么类型的容器。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">编译器建议首先指定容器类型。但是，如果应用此修正，我们将再次遇到相同类型的错误，涉及 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">str::parse</code>。<code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">collect</code> 和 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">parse</code> 都是泛型方法，但编译器需要知道确切类型才能编译使用它们的代码。请注意，RustRover 没有高亮显示错误，因为我们仍在完善其类型检查功能。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">可以通过多种方式修正这个问题，因为不止一个地方可以添加类型注解。我们可以指定 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">numbers</code> 向量的具体类型：</p><section style="font-size: 15px;color: rgb(33, 33, 33);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><pre style="font-size: inherit;color: inherit;line-height: inherit;"><code style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;padding: 0.5em;background: rgb(43, 43, 43);color: rgb(186, 186, 186);overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;display: -webkit-box !important;"><span style="font-size: inherit;line-height: inherit;color: rgb(224, 196, 108);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;numbers:&nbsp;Vec&nbsp;=&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(106, 135, 89);overflow-wrap: inherit !important;word-break: inherit !important;">"1&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;3"</span></code></pre></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">或者我们可以在调用 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">collect</code> 时提及相同的类型：</p><section style="font-size: 15px;color: rgb(33, 33, 33);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><pre style="font-size: inherit;color: inherit;line-height: inherit;"><code style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;padding: 0.5em;background: rgb(43, 43, 43);color: rgb(186, 186, 186);overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;display: -webkit-box !important;">&nbsp;&nbsp;&nbsp;.collect::&lt;Vec&gt;();</code></pre></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">最后，我们可以在不同的地方提及不同的类型：</p><section style="font-size: 15px;color: rgb(33, 33, 33);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><pre style="font-size: inherit;color: inherit;line-height: inherit;"><code style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;padding: 0.5em;background: rgb(43, 43, 43);color: rgb(186, 186, 186);overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;display: -webkit-box !important;">let&nbsp;numbers&nbsp;=&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(106, 135, 89);overflow-wrap: inherit !important;word-break: inherit !important;">"1&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;3"</span><br>&nbsp;&nbsp;&nbsp;.split_whitespace()<br>&nbsp;&nbsp;&nbsp;.map(str::parse::)<br>&nbsp;&nbsp;&nbsp;.map(Result::unwrap)<br>&nbsp;&nbsp;&nbsp;.collect::&lt;Vec&gt;();</code></pre></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">这个错误很容易修正，指定需要的类型即可。</p><span id="OSC_h2_5"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">常见错误 #7：E0432（<em style="font-size: inherit;color: inherit;line-height: inherit;">import 未解析</em>）</span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">RustRover 提供了大量自动补全功能。例如，我们首先在代码中引入正则表达式：</p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-imgfileid="100021891" data-ratio="0.26296296296296295" src="https://oscimg.oschina.net/oscnet/991479fb-fa12-44ad-a42a-ed6fe504fef6.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption></figure></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">如果选择第一个建议，除了补全本身，还会发生两件事：</p><ul style="font-size: inherit;color: inherit;line-height: inherit;padding-left: 32px;" class="list-paddingleft-1"><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p>对 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">regex</code> crate 的依赖将添加到您的<kbd style="font-size: inherit;color: inherit;line-height: inherit;">Cargo.toml</kbd>中。</p></li><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">use regex::Regex;</code> 子句将添加到文件顶部。</p></li></ul><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">添加这样的 use 子句时，import 会自动正确写入。但有时您需要手动编写 import，这时就可能出现 E0432 错误。15.5% 的 RustRover 用户会不时遇到这种情况，最有可能是因为他们拼错了 crate 或模块名称，尝试导入不存在的内容，或者从某处复制粘贴后将错误的 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">use</code> 子句带入代码。第一个建议始终是检查依赖项和名称。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">有时 RustRover 可以帮助防止此错误。如果知道我们尝试导入的 crate，它可以在您从外部源粘贴代码时建议添加依赖项，或者通过以下快速修复提供支持：</p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-imgfileid="100021890" data-ratio="0.21388888888888888" src="https://oscimg.oschina.net/oscnet/b8d64c46-9612-4d85-8b3a-246fb1c68af8.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;" title="" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"></figcaption></figure></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">将相应依赖项添加到<kbd style="font-size: inherit;color: inherit;line-height: inherit;">Cargo.toml</kbd>可以立即修正此错误。在 crate 可用后，对 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">use</code> 子句中的其他路径组件使用自动补全能够避免出现更多名称问题。另请注意，某些名称的可用性可能取决于 crate 的启用功能。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">super</code> 或 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">crate</code> 这样的特殊路径名称也可能存在问题，特别是在不同的 Rust 版本中要以不同的方式处理。请参阅<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror_codes%2FE0432.html" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">官方说明</a>了解详情。</p><span id="OSC_h2_6"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">常见错误 #6：E0382（<em style="font-size: inherit;color: inherit;line-height: inherit;">内容移动到其他位置后变量才被使用</em>）</span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">接下来是所有权问题， 17% 的 RustRover 用户遇到过这个错误。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror_codes%2FE0382.html" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">官方说明</a>相当详细，并提供了许多示例。可惜，RustRover 在这里没有太大帮助。如果禁用<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.jetbrains.com.cn%2Fhelp%2Frust%2Frust-external-linters.html" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">外部 linter</a>，RustRover 的内部机制不会发现以下代码有任何问题：</p><section style="font-size: 15px;color: rgb(33, 33, 33);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><pre style="font-size: inherit;color: inherit;line-height: inherit;"><code style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;padding: 0.5em;background: rgb(43, 43, 43);color: rgb(186, 186, 186);overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;display: -webkit-box !important;"><span style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">fn&nbsp;<span style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">main</span>(<span style="font-size: inherit;line-height: inherit;color: rgb(185, 185, 185);overflow-wrap: inherit !important;word-break: inherit !important;"></span>)&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(203, 120, 50);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;vec&nbsp;=&nbsp;vec![<span style="font-size: inherit;line-height: inherit;color: rgb(104, 150, 186);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>,&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(104, 150, 186);overflow-wrap: inherit !important;word-break: inherit !important;">2</span>,&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(104, 150, 186);overflow-wrap: inherit !important;word-break: inherit !important;">3</span>,&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(104, 150, 186);overflow-wrap: inherit !important;word-break: inherit !important;">4</span>,&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(104, 150, 186);overflow-wrap: inherit !important;word-break: inherit !important;">5</span>];<br>&nbsp;&nbsp;&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(203, 120, 50);overflow-wrap: inherit !important;word-break: inherit !important;">let</span>&nbsp;mut&nbsp;sum&nbsp;=&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(104, 150, 186);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>;<br>&nbsp;&nbsp;&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(203, 120, 50);overflow-wrap: inherit !important;word-break: inherit !important;">for</span>&nbsp;v&nbsp;<span style="font-size: inherit;line-height: inherit;color: rgb(203, 120, 50);overflow-wrap: inherit !important;word-break: inherit !important;">in</span>&nbsp;vec&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;v;<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;println!(<span style="font-size: inherit;line-height: inherit;color: rgb(106, 135, 89);overflow-wrap: inherit !important;word-break: inherit !important;">"Sum&nbsp;of&nbsp;{vec:?}&nbsp;elements&nbsp;is&nbsp;{sum}"</span>);<br>}</code></pre></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">这段看似无辜的代码在其他几种编程语言中完全合法。我们有一个向量，想要计算其元素的总和。例如，假设我们使用 C 语言，不知道迭代器的函数式编程技巧，我们需要编写传统的 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">for</code> 循环。完成所有求和后，我们就可以输出向量和计算结果。右侧?</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">在 Rust 中不行，因为它有所有权规则。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">问题在于，<code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">for</code> 循环中的数据源扩展到具有整个向量的所有权的 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">into_iter()</code> 调用。因此，尝试访问 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">println!</code> 中向量的元素时，编译器会表示它已被移动。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">修正很简单，并且由编译器建议：迭代 <code style="font-size: inherit;line-height: inherit;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;color: rgb(0, 0, 0);background: rgb(248, 248, 248);">&amp;vec</code>，避免将其<em style="font-size: inherit;color: inherit;line-height: inherit;">移入</em>循环，而应改为<em style="font-size: inherit;color: inherit;line-height: inherit;">借用</em>。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">一般来说，建议始终跟踪值所有权。移动值和借用值是 Rust 的基本概念， 理解它们是每个学习者的首要任务。</p><span id="OSC_h2_7"></span><h2 style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-weight: bold;font-size: 1.4em;"><span style="font-size: inherit;line-height: inherit;color: rgb(255, 104, 39);">更新一览</span></h2><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">在博文系列的第一部分中，我们根据 RustRover 中的使用数据定义了最常见的 Rust 编译器错误，并讨论了第 10 到第 6 名的错误。在下一部分中，我们将探索最常见的 5 个错误，并尝试回答每个 Rust 开发者都会考虑的问题：「Rust 的哪一部分最麻烦？」</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><br></p></section><section style="font-size: 16px;"><section style="transform: perspective(0px);transform-style: flat;" powered-by="xiumi.us"><section style="margin-top: 10px;text-align: right;justify-content: flex-end;display: flex;flex-flow: row;transform: rotateY(180deg);"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="transform: perspective(0px);transform-style: flat;" powered-by="xiumi.us"><section style="transform: rotateY(180deg);"><section style="color: rgb(125, 125, 125);font-size: 13px;"><p><strong>本博文英文原作者：</strong><strong>Vitaly Bragilevsky</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></section></section></section></section><section style="" powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="text-align: center;justify-content: center;display: flex;flex-flow: row;margin-top: 10px;margin-bottom: 20px;" powered-by="xiumi.us"><section style="display: inline-block;width: auto;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 1px;min-width: 5%;height: auto;box-shadow: rgb(255, 92, 0) 6px 6px 0px 0px;padding: 8px;"><section style="text-align: left;" powered-by="xiumi.us"><section style="text-align: justify;font-size: 17px;color: rgb(255, 92, 0);"><p style="text-wrap: wrap;"><strong>RustRover 相关阅读</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></section></section><a title="https://mp.weixin.qq.com/s?__biz=MzkwNDI5NzUyMQ==&amp;mid=2247503998&amp;idx=1&amp;sn=c80abda34362d92eb4077c7176fbf9c7&amp;chksm=c08bbd20f7fc34367671f223323fdcad7d4a69e299793bab51144717a9a3902159a5a51a4227&amp;token=702672088&amp;lang=zh_CN&amp;scene=21#wechat_redirect" formlinkparm="[{&quot;href&quot;:&quot;https://mp.weixin.qq.com/s?__biz=MzkwNDI5NzUyMQ==&amp;mid=2247503998&amp;idx=1&amp;sn=c80abda34362d92eb4077c7176fbf9c7&amp;chksm=c08bbd20f7fc34367671f223323fdcad7d4a69e299793bab51144717a9a3902159a5a51a4227&amp;token=702672088&amp;lang=zh_CN&amp;scene=21#wechat_redirect&quot;}]" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247503998%26idx%3D1%26sn%3Dc80abda34362d92eb4077c7176fbf9c7%26chksm%3Dc08bbd20f7fc34367671f223323fdcad7d4a69e299793bab51144717a9a3902159a5a51a4227%26token%3D702672088%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank" rel="noopener noreferrer" powered-by="xiumi.us" data-linktype="1"><section style="text-align: center;margin-top: 10px;margin-bottom: 10px;line-height: 0;"><section style="vertical-align: middle;display: inline-block;line-height: 0;border-style: outset;border-width: 0px;border-radius: 5px;overflow: hidden;box-shadow: rgb(0, 0, 0) 2px 2px 8px -3px;"><span class="js_jump_icon h5_image_link"><img class="rich_pages wxw-img" data-imgfileid="100021874" data-ratio="0.30277777777777776" data-s="300,640" src="https://oscimg.oschina.net/oscnet/97597ad8-c6b4-4ed0-9171-1519b6d10c34.png" data-type="png" data-w="1080" style="vertical-align: middle;width: 100%;display: inline;" referrerpolicy="no-referrer"></span></section></section></a><section style="margin-top: 10px;margin-bottom: 10px;" powered-by="xiumi.us"><section style="box-shadow: rgb(170, 170, 170) 0px 0px 10px inset;border-color: rgb(192, 200, 209);padding: 10px 18px;border-width: 1px;border-style: solid;background-color: rgb(240, 244, 255);border-radius: 5px;overflow: hidden;"><section style="margin: 10px 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 38px;flex: 0 0 auto;height: auto;align-self: center;"><section style="text-align: center;margin-top: 10px;margin-bottom: 10px;line-height: 0;" powered-by="xiumi.us"><section style="vertical-align: middle;display: inline-block;line-height: 0;width: 38px;height: auto;"><img data-imgfileid="100021893" data-ratio="1" data-s="300,640" src="https://oscimg.oschina.net/oscnet/3f016ec1-7ae6-4aa8-8bef-098c5a2090e4.png" data-type="png" data-w="256" style="vertical-align: middle;width: 100%;display: inline;" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: auto;min-width: 10%;flex: 0 0 auto;height: auto;align-self: center;margin-left: 10px;border-bottom: 3px solid rgb(0, 0, 0);border-bottom-right-radius: 0px;"><section style="" powered-by="xiumi.us"><section style="font-size: 19px;color: rgb(0, 0, 0);"><p style="text-wrap: wrap;"><strong>关于 RustRover</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></section></section><section style="" powered-by="xiumi.us"><section style="color: rgb(0, 0, 0);font-size: 15px;"><p style="text-wrap: wrap;"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247487178%26idx%3D2%26sn%3D6d95e4b411feb60da6108d3aee21d77d%26scene%3D21%23wechat_redirect" target="_blank" data-linktype="2"></a>RustRover 是 JetBrains 在 2023 年推出的面向 Rust 开发者的全新 IDE，正处于公开预览阶段，供大众免费使用体验。</p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><a title="https://www.jetbrains.com.cn/rust/" formlinkparm="[{&quot;href&quot;:&quot;https://www.jetbrains.com.cn/rust/&quot;}]" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.jetbrains.com.cn%2Frust%2F" target="_blank" rel="noopener noreferrer" powered-by="xiumi.us" data-linktype="2"><section style="text-align: center;margin-top: 15px;margin-bottom: 7.5px;"><section style="display: inline-block;border-radius: 5px;line-height: 2.3;background-color: rgb(255, 92, 0);font-size: 15px;color: rgb(240, 244, 255);width: 100%;"><p><strong>进一步了解 RustRover</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></a></section></section><section style="text-align: center;margin-top: 10px;margin-bottom: 10px;line-height: 0;" powered-by="xiumi.us"><section style="vertical-align: middle;display: inline-block;line-height: 0;box-shadow: rgb(125, 125, 125) 1px 1px 5px;"><img class="rich_pages wxw-img" data-imgfileid="100021880" data-ratio="0.5" data-s="300,640" src="https://oscimg.oschina.net/oscnet/0c16c138-101f-4fff-ae5f-55ba5a107279.png" data-type="png" data-w="1080" style="vertical-align: middle;width: 100%;display: inline;" referrerpolicy="no-referrer"></section></section><section style="" powered-by="xiumi.us"><section style="font-size: 13px;color: rgb(125, 125, 125);"><p style="text-wrap: wrap;"><strong>⏬ 戳「阅读原文」了解更多信息</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - JetBrains（JetBrainsChina）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 03:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5494143/blog/10773826</guid>
            <link>https://my.oschina.net/u/5494143/blog/10773826</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Bytebase 2.13.1 - 支持 Apache Doris]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>🚀 新功能</h2><ul><li>支持 Apache Doris。</li><li>支持在对 MySQL 执行 DML 之前备份数据。</li><li>支持实例的最大连接数，用以控制每个实例的并发任务数量。</li><li>支持对导出数据的压缩和加密。</li></ul><h2>🔔 重大变更</h2><ul><li>Bytebase API 的更改：重命名了预定义角色。如果您在使用这些角色，请更新您的代码： 
  <ul><li>工作区级别：OWNER 更改为 workspaceAdmin，DBA 更改为 workspaceDBA，DEVELOPER 更改为 workspaceMember。</li><li>项目级别：OWNER 更改为 projectOwner，DEVELOPER 更改为 projectDeveloper，QUERIER 更改为 projectQuerier，EXPORTER 更改为 projectExporter，VIEWER 更改为 projectViewer，RELEASER 更改为 projectReleaser。</li></ul></li></ul><h2>🎄改进</h2><ul><li>支持在 Schema 编辑器中编辑索引。</li><li>在 SQL 编辑器中，按项目和数据库分组工作表。</li><li>支持在环境发布策略中选择自定义项目角色。</li></ul><h2>🎠 社区</h2><p>视频：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1dN4y1i7sq%2F" target="_blank">为什么商业基础软件要开源？</a></p><h2>📕 安装及升级</h2><p>参考<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbytebase%2Fbytebase%23installation" target="_blank">升级指南</a>。如果从之前版本升级，获取新版本后，重新启动升级即可。</p><hr><p>💡 更多资讯，请关注 Bytebase 公号：Bytebase</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 03:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6148470/blog/10773851</guid>
            <link>https://my.oschina.net/u/6148470/blog/10773851</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[荣耀回应「任意门」抄袭锤子争议]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在罗永浩<a href="https://www.oschina.net/news/275229/magicos-8-one-step">喊话</a>称 「荣耀任意门」 抄袭锤子开源软件一步 (One Step) 后，荣耀公司发布声明回应外界质疑称，MagicOS 8.0 中的任意门功能完全是公司自主独立研发的成果。</p><p>荣耀强调，这一功能的开发过程中，公司研发团队付出了大量的心血和努力，进行了深入的市场调研和用户需求分析，以及无数次的试验和优化。公司一直致力于技术创新和自主研发，尊重并保护知识产权，不会进行任何形式的抄袭行为。</p><p>针对与锤子手机 One Step 功能的相似之处，荣耀解释称，虽然两者在功能上有一定的相似性，但在实现方式、技术细节和用户体验等方面存在显著的差异。任意门功能是基于公司自身的技术积累和用户需求进行开发的，旨在为用户提供更加便捷、高效的操作体验。</p><p>同时，荣耀也承认罗永浩作为一位资深科技人，其对于智能手机行业的洞察和构思具有超前性，对于荣耀等后辈企业的发展有着重要的启示作用。对于此次争议给新系统发布带来的影响，该公司表示将积极面对并妥善处理。</p><p>荣耀研发负责人邓斌在接受采访时也回应道，「任意门」是荣耀独立研发的基于意图识别的交互逻辑，在那个时代是完全没有的。</p><p>他解释说，「任意门」与「一步」的核心区别在于，「任意门」所呈现的入口不是预先设定好的 icon，而是通过识别用户的意图后，动态智能地呈现真正具备智慧逻辑的东西。</p><p><img height="400" src="https://oscimg.oschina.net/oscnet/up-3dcf7c5dee29adad3776ba3384a41f9f88a.png" width="300" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 03:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275383</guid>
            <link>https://www.oschina.net/news/275383</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[幻方量化开源国内首个 MoE 大模型：DeepSeekMoE]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>幻方量化旗下组织深度求索发布了国内首个开源 MoE 大模型 —— <strong>DeepSeekMoE</strong>，全新架构，免费商用。</p><blockquote><p>今年 4 月，幻方量化<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FUOMZmEXNY--fzK-KioGZLQ" target="_blank">发布公告称</a>，公司将集中资源和力量，全力投身到服务于全人类共同利益的人工智能技术之中，成立新的独立研究组织，探索 AGI 的本质。幻方将这个新组织命名为「<strong>深度求索 (DeepSeek)</strong>」。</p></blockquote><p>DeepSeekMoE 的模型、代码、论文均已同步发布。</p><ul><li>模型下载：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fdeepseek-ai" target="_blank">https://huggingface.co/deepseek-ai</a></li><li>微调代码：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdeepseek-ai%2FDeepSeek-MoE" target="_blank">https://github.com/deepseek-ai/DeepSeek-MoE</a></li><li>技术报告：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdeepseek-ai%2FDeepSeek-MoE%2Fblob%2Fmain%2FDeepSeekMoE.pdf" target="_blank">https://github.com/deepseek-ai/DeepSeek-MoE/blob/main/DeepSeekMoE.pdf</a></li></ul><p>据介绍，DeepSeekMoE 的多尺度（2B-&gt;16B-&gt;145B）模型效果均领先：</p><ul><li>DeepSeekMoE-2B 可接近 MoE 模型的理论上限&nbsp;2B Dense 模型性能（即相同 Attention/FFN 参数配比的 2B Dense 模型），仅用了 17.5% 计算量</li><li>DeepSeekMoE-16B 性能比肩 LLaMA2 7B 的同时，仅用了 40% 计算量，也是本次主力开源模型，40G 显存可单卡部署</li><li>DeepSeekMoE-145B 上的早期实验进一步证明该 MoE 架构明显领先于 Google 的 MoE 架构 GShard，仅用 28.5%（甚至 18.2%）计算量即可匹配 67B Dense 模型的性能</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-ee5cc82817997477bc2758618cd51ea5ea5.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-d2bf70acad5d73ee4a448bac405e672196c.png" referrerpolicy="no-referrer"></p><p>混合专家模型 (Mixed Expert Models，简称 MoEs)&nbsp;是用于提高大语言模型效率和准确度的技术。这种方法的核心是将复杂任务划分为更小、更易管理的子任务，每个子任务由专门的小型模型或 「专家」 负责，然后根据输入数据的特性选择性地激活这些 「专家」。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span>MoE 核心组成：</span></p><ol><li><p style="margin-left:0; margin-right:0"><span><strong>专家 (Experts)</strong>：</span><span style="background-color:#ffffff; color:#0f1419">训练有素的小型神经网络，擅长特定领域。</span><span>每个专家通常专注于处理一种特定类型的数据或任务。专家的设计可以是多种形式，如完全连接的网络、卷积网络等。</span></p></li><li><p style="margin-left:0; margin-right:0"><span><strong>门控机制 (Gating Mechanism)</strong>：</span><span style="background-color:#ffffff; color:#0f1419">MoE 架构决策者，</span><span>这是一个智能路由系统，负责决定哪些专家应该被激活来处理当前的输入数据。门控机制基于输入数据的特性，动态地将数据分配给不同的专家。</span></p></li></ol><p>官方称 DeepSeekMoE 是自研的全新 MoE 框架，主要包含两大创新：</p><ul><li><strong><strong><strong>细粒度专家</strong></strong>划分</strong>：不同于传统 MoE 直接从与标准 FFN 大小相同的 N 个专家里选择激活 K 个专家（如 Mistral 7B<em>8 采取 8 个专家选 2 专家），</em>DeepSeekMoE<em>把 N 个专家粒度划分更细，在保证激活参数量<strong>不变</strong></em>的情况下，从 mN 个专家中选择激活 mK 个专家（如 DeepSeekMoE 16B 采取 64 个专家选 8 个专家），如此可以更加灵活地组合多个专家</li><li><strong><strong><strong>共享</strong></strong>专家分离</strong>：DeepSeekMoE 把激活专家区分为共享专家（Shared Expert）和独立路由专家（Routed Expert），此举有利于将共享和通用的知识压缩进公共参数，减少独立路由专家参数之间的知识冗余</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-3e3ad6f23bc6e17ac352dab0861fd3328d9.png" referrerpolicy="no-referrer"></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FT9-EGxYuHcGQgXArLXGbgg" target="_blank">点此查看详情</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 12 Jan 2024 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275378</guid>
            <link>https://www.oschina.net/news/275378</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
