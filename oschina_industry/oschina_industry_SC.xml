<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 30 Oct 2023 10:33:20 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[昆仑万维开源「天工」Skywork-13B 系列大模型，0 门槛商用]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="color:#000000">昆仑万维宣布开源百亿级大语言模型「天工」Skywork-13B 系列，并配套开源了 600GB、150B Tokens 的超大高质量开源中文数据集。昆仑万维「天工」Skywork-13B 系列目前包括 130 亿参数的两大模型：Skywork-13B-Base 模型、Skywork-13B-Math 模型。</span></p><p><span style="color:#000000">除模型开源外，Skywork-13B 系列大模型还将开源 600GB、150B Tokens 的高质量中文语料数据集 Skypile/Chinese-Web-Text-150B。公告称，这是目前最大的开源中文数据集之一。同时，昆仑万维「天工」Skywork-13B 系列大模型即将全面开放商用；开发者无需申请，即可商用。</span></p><p><span style="background-color:#ffffff; color:#000000">「此次 Skywork-13B 系列大模型将全面开放商用许可，用户在下载模型并同意并遵守《Skywork 模型社区许可协议》后，无需再次申请授权即可将大模型进行商业用途。希望用户能够更便捷地探索 Skywork-13B 系列大模型技术能力，探索在不同场景下的商业化应用。」</span></p><p><strong><span style="color:#000000">Skywork-13B-Base 模型</span></strong></p><blockquote><p><span style="color:#000000">Skywork-13B-Base 模型是 Skywork-13B 的基础模型，其经由 3.2 万亿个多语言高质量数据训练，在 CEVAL、CMMLU、MMLUGSM8K 等评测与基准测试上都展现了同等规模模型的最佳效果。</span></p></blockquote><p><strong><span style="color:#000000">Skywork-13B-Math 模型</span></strong>&nbsp;</p><blockquote><p><span style="color:#000000">Skywork-13B-Math 模型经过专门的数学能力强化训练，在 GSM8K 等数据集上取得了同等规模模型的最佳效果。&nbsp;</span></p></blockquote><p><strong><span style="color:#000000">Skypile/Chinese-Web-Text-150B 数据集</span></strong>&nbsp;</p><blockquote><p><span style="color:#000000">该数据集是根据昆仑天工团队方面经过精心过滤的数据处理流程从中文网页中筛选出的高质量数据。本次开源的数据集大小约为 600GB，总 token 数量约为 150B，目前开源最大的中文数据集之一。</span></p></blockquote><p>一些评测结果如下所示：</p><p><img height="232" src="https://oscimg.oschina.net/oscnet/up-1db28014754e9cdff9ea99cd4870f7d3ee1.png" width="500" referrerpolicy="no-referrer">&nbsp;</p><p><img height="267" src="https://oscimg.oschina.net/oscnet/up-091dc8c601db00caf525c2b1517e82fda18.png" width="500" referrerpolicy="no-referrer"></p><p>更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FQTe6pILo6jehgC7fiZBmmQ" target="_blank">查看官方公告</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 09:50:14 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264137</guid>
            <link>https://www.oschina.net/news/264137</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[为什么好好的一个开源项目，商业化却往往扑街？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><div><p>数字化产品如何做商业化？为什么有些开源项目这么优秀，商业化却老是扑街？第四期《开源漫谈》，我们邀请了<strong>王晔倞（头哥）</strong>和<strong>厉启鹏（寈峰）</strong>，一起来聊聊，<strong>开源项目的商业化变现，到底该怎么做？</strong></p><ul><li><p><strong>王晔倞（头哥）</strong>，「头哥侃码」主理人，专注分享技术、创业与产品创新等主题内容。</p></li><li><p><strong>厉启鹏（寈峰）</strong>，现为 vanus.ai CEO，曾就职于阿里云，Apache RocketMQ PMC ，长期专注于 AI 基础设施软件及中间件。</p></li></ul><p>&nbsp;</p><p><strong>头哥：</strong>技术，和一坨代码，和一个好的产品，中间没有直接的关系，只有间接的关系。所以你会发现很多人，他开源做得很好，但商业化做得很差。反过来有的人他商业化做得很好，但社区不会做。现在的 AI 类产品、大模型产品、开源产品，其实都是数字化产品。那么第一个问题来了：</p><p><strong>数字化产品如何实现商业化？中间有什么样的途径吗？</strong></p><p>&nbsp;</p><p><strong>厉启鹏：</strong>我先分享一下开源产品吧。一般来说，我们会先把产品在 Github 上开源，吸引一些人气。这样一来可以找到最初的用户，（毕竟开源是一种很好的推广方式），二来可以通过开源快速地打磨这个产品，在开发者们的帮助下让产品快速迭代，迅速成熟。第二步就是商业化了，在国内的话，像我们做基础设施类的，一般都是以 license 的方式去售卖，或者去拿一些大项目。我们之前服务过大客户，像银行、Saas 公司等等。除此之外，还有一种方式就是提供 Saas 服务，我们会先把产品托管到公有云上去，这样用户在使用产品的时候就不需要自己去部署、自己去运维，需要的时候开箱即用即可。</p><p>不过，不同的项目，它的形态和在商业化的时候需要考虑的东西是不一样的。举个例子，我们现在 vanus 产品的用户有国内的也有国外的，但以我们的经验来说，不同点在于：在国内，提供软件服务的公司，很难避免去做私有化的交付方式。在中国现在的环境下去运营一个纯产品类的公司还是蛮难的。我自己在甲方待过，也在乙方待过，我的感受就是：在中国的软件市场里边，甲方是非常强势的，软件用户的边界感也比较差，如果买了你的产品，就会希望你给他解决所有的问题，无论是软件的问题还是周边的问题，你都要给他解决。现在连我们国内用户做招聘，都要问我们给建议，我还帮我的甲方去面试过（笑~）</p><p>不过话说回来，这种方式还是有它的好处的。首先呢你会跟客户建立一个很强的连接，因为你服务时间长所以他会很信任你，很多东西都给到你，可能你会更容易拿到单子。像中国政企的一些客户，他们的项目都是一年到三年的，这对你的企业来讲，可能毛利不是特别高，但是会让你有持续的现金流输入，对整个企业的发展都有好处。</p><p>当然，这种方式的弊端也很明显。像我现在的产品服务了几十个客户，每个客户都有一个代码分支，每个客户手里的都不一样，这对于我们产品的维护、运维的压力就蛮大的。你会发现，一个软件公司到后期会越做越大，这不是说产品或生意越做越大，而是人员越来越多了，尤其是实施侧的人员、维护的人员，越来越多。这样下来，整体的毛利就会比较低，产品本身也比较割裂，最后可能形成了好几个产品而不是一个产品了。这也算是个有趣的中国特色吧。</p><p>从市场来看，中国纯产品型的软件公司还是比较少的，更多的是项目型的公司。但海外就不一样，就我们接触的经验而言，海外的客户他的边界感非常强，续费率又高，这就很有利于你费心思去打磨自己的产品。不过这种方式也有弊端，那就是他不愿意跟你建立太多的连接。我们之前想做个用户访谈，想问问产品的使用体验，看看你还有哪些场景是我们的产品可以满足的，但就遇到了困难。他可能会觉得，这个产品我用着没事，我也付钱了，你干嘛老找我？</p><p>哈哈，总之，这个市场的差别就非常明显。我个人觉得这两种形态都是比较典型的，也各有利弊，如果要做一个创业项目的话，还要结合具体的产品、不同的团队风格，甚至是创始人的风格，来做选择。</p><p>&nbsp;</p><p><strong>头哥：</strong>刚刚启鹏说的，我真是感同身受啊。我分享一下我的经验吧，我工作比较早，2001 年开始接触 Java，2004 年开始接触 IOE 架构，上海有个电视购物叫东方购物就是我们做的。七八年前，中国是没有基础软件厂商的，更早一点，十五年前，你说要找数据库，那只能想到 Oracle，这是一方面；另一方面，以神州数码为代表的基于标准厂商上面的第三方服务公司大行其道，我们的甲方之所以这么强势，就是被这些人给哄出来的。</p><p>当年我在东方购物的时候，我们一开始买了 Oracle 原厂的服务，Oracle 的工程师来这里支持，1 天 8 小时就要给 1 万块钱，加班另算。你想想 04 年 1 天 1 万是什么水平？后面我们把原厂的服务包给神州数码，服务非常好，价格还只要一半，加班不要钱。就这样，甲方慢慢地就被捧出来了。如果你不能全包，那我就不选你。反正我只是花钱解决问题，却还要我分清问题分开花钱，那我为什么不选一个全包的呢？我自己要是运维这么强还用找你吗？</p><p>所以，现在的甲方都很喜欢把项目总包给阿里云、华为云，这些云厂商都有行业解决方案架构师，他们做的都是解决方案，下面的产品都是模糊的，能用就行。内卷就是这么出来的。不过话说回来，市场没有好坏，关键是你要去适应它，而不是从自己的技术经验出发来判定这个市场好不好，这个思维要不得。</p><p>&nbsp;</p><p><strong>厉启鹏：</strong>是的，你在不同的市场做，就是要尊重不同市场的规则。像国内就是用这种方式去驱动产业的发展的。你也很难用好坏来评判一个市场。我上个月去考察了日本的市场，发现日本市场特别难进入，当时同行有个公司，花了一年的时间，才从日本市场拿了一个 80 万的单子。因为它那里有 POC 、安全认证等等的审核，门槛比较高。但是呢，一旦你吃下这个市场，你就可以一直吃下去，因为他们很少会主动更换供应商。所以，这也是日本市场的一个特点，我们要是想做的话也一样要尊重它的规则，国内国外都一样。</p><p>&nbsp;</p><p><strong>头哥：</strong>说得很好。刚刚启鹏也提到了一个点，就是国内的集成商比较厉害，<strong>很多甲方也会把你当外包看待，压根不管你的产品标不标准，还提一堆有关无关的需求，每个项目按人头算钱，对于这种现象，你怎么看呢？</strong></p><p>&nbsp;</p><p><strong>厉启鹏：</strong>我个人感觉，在国内做项目，要是想做得比较大，那对于这个项目负责人的要求还蛮高的，负责人他可能需要考虑很多方面。我见过一种情况就是，因为一个项目孵化了一个产品，通过这个产品打下了一个行业。之前有个做监控的公司就是这样，刚开始的时候是从建行做起来，后来把产品完善之后推到了浦发等等别的银行去了。那我觉得这种类型还是蛮有价值的，因为你解决的这个问题是一些通用的问题，你把它抽象成了产品，实现了规模化。</p><p>当然，更多的是头哥你说的那种，根本不管你产品如何是不是要做商业化，他只想解决他的问题。当然，这也没有问题，毕竟人家是甲方，出了钱的嘛。对于这种情况，可能这个项目负责人就要考虑下投入的问题，或者是怎么投入这个项目。一种是直接让自己的研发上，all in 到这个项目里边，还有一种方式是去找一些合作伙伴一起把这个项目拿下。甚至很多公司可能会先临时找些外包，因为你如果只要人头，那我就只给你人头，然后我只赚人头的钱。但有的公司呢可能会说对不起这人头钱我不赚，这个项目我不做了。</p><p>我觉得还是要想清楚吧，因为你要是没想清楚的话，可能会对公司的影响比较大，它会冲击你整个研发体系，甚至会影响整个产品的正常迭代。所以去做项目的时候一定要想清楚，你要做什么样的项目，你要服务什么样的用户，你要以什么样的方式去服务他。这个用户画像一定要清楚，不然就会把你的节奏带乱。</p><p>&nbsp;</p><p><strong>头哥：还有一个问题，作为我们这种普通的技术人，如何把我们手上的技术变现呢？</strong></p><p>&nbsp;</p><p><strong>厉启鹏：</strong>加入一家大公司，我觉得可能是一个比较好的方式。因为我自己的体会就是这样的，当时我在阿里做社区，看到不少小伙伴当时还在一家小公司，但是他在我们这个社区里边比较活跃，贡献了很多代码，这给他的经验、经历做了很大的加持，后来他们就都跳槽到大公司去了。从 ROI 的角度，或者从收益的角度来看，这是一个收益很高的事情，通过在知名项目做贡献，提升自己的技术和影响力，从而提升自己的职业生涯，我觉得这是最直接的一种方式。</p><p>第二种方式我也见过好多，就是技术经验丰富之后，去做咨询，或者是指导别人写代码，出书，出课程，做培训等等，也都做得挺不错的。</p><p>最后一种就是创业了，不过如果纯技术人想要创业的话，我建议你可以先加入一家创业公司，如果你能适应的话。假如公司靠谱，那之后它发达了你也就财富自由了。加入一家创业公司工作跟在大公司做一个具体细分的工作差异肯定非常大，在创业公司，假如说要做一辆劳斯莱斯，说不定得先从一辆自行车做起，然后做一辆电动车，再做一辆奥拓，再到宝马，最后才到劳斯莱斯，他是这么一个过程。绝对不是说我给你几年时间，让你做一辆劳斯莱斯，那样公司在市场上很难活下去的。但是在这种逐渐发展的过程中，对于一个技术人的技术视野，甚至商业的视野都会打开很多。我也见过很多这种人，之前是纯做技术的，加入这家创业公司之后，可能刚开始是做技术，后来他可能要做产品经理，再后来他可能是负责整个的售前，这对他个人能力就会有非常大的提升。</p><p>当然，选择也跟年龄段有关系。比如说工作五年以前的，我觉得还是可以去大厂看一看，体验一下。但是如果工作 5 年到 10 年甚至更久的时间了，我觉得加入一家创业公司还是一个不错的选择。但是，如果你说你要作为一个合伙人甚至是创始人去创办一家商业公司，那说实话我个人不是特别推荐。因为如果你是作为合伙人的身份的话，你会发现到后面你首先关注的不是技术了，而是用户，是融资，是市场，你要花很大的精力去做这些事情，可能有些人不一定喜欢。可能你后面做着做着发现自己成了一个销售，当然不是说销售不好，但他可能之前不喜欢，但是后边需要他做这个工作。所以第二个要考虑的就是，这是不是你能力范围内的事情，有些人他快速成长，快速改变，他的适应力非常强，那就没有问题。</p><p>&nbsp;</p><p><strong>头哥：最后一个问题，作为一个优秀的开源项目，如果想尝试商业化，有哪些方式呢？</strong></p><p>&nbsp;</p><p><strong>厉启鹏：</strong>如果是大厂想通过开源实现商业化的话，现在最典型的路径就是捐到基金会去，然后再通过运营社区的方式去获客。这种方式尤其适合基础软件，如果是一个特别垂类的软件倒不一定合适了。个人更赞同的一种方式是通过开源树立一个标杆，获得某些标杆企业的开发者的认可，这时候你再去复制可能就会非常快。比方说我这个软件，如果大厂采用了，那下面的二三线厂商可能也会跟进。影响力打出去了之后，再寻求付费可能就会容易一点了。</p><p>但是在当下，2023 年，这个节点，你建立一个项目去创业，那是比较难的。第一，开源商业化的路径比较长，你得先有项目，然后通过运营社区把这个影响力做起来，再出商业版去变现，那可能意味着这家创业公司要一年两年甚至三年没有收入，或者养活不了自己。在目前的这种就业环境包括投融资环境下，你能不能活两三年，这是一个非常大的问题，很多人撑不住的。</p><p>还有就是，以我自己的感受来讲，很多用户他只用开源版本，他从来就没有想过要用你的商业版，或者你出了商业版之后他就直接走了，这种就很难转化。有些开源公司做商业化成功了，并不是因为转化了开源用户为商业化用户，而是因为这个项目影响力起来之后，影响了那些不使用开源项目的用户，从而实现了商业化。这属于间接影响，你不好量化，从顶上来看的话，你都不好去制定一个考核机制，让大家知道哪些事有价值和引导他们做事。所以我觉得，如果是 Saas 的话，会比开源更能解决你打磨产品的问题，因为上面有数据，他们用了多少你看得到。</p><p>最后，我觉得开源最大的价值就是标准化，比如 Conflict ，它是构建大数据平台的一个标准，不管用它的开源还是买它的商业版，只要构建大数据平台都会想到它。其次就是开源有助于国际化，给了中国的企业出海或者是服务海外客户的一个机会，这是本土闭源的软件公司很难做到的。我一度认为开源加上云，是一个蛮好的方式，能够助力中国的软件企业成为一个服务全球的企业。以前没有云，想服务海外客户还得建本地团队，现在托 AWS 就可以了，大大节省了成本。</p><p>当然，开源好处多多，明天也很美好，现在的挑战就是看你能不能活到明天了。（笑~）</p><p>&nbsp;</p><p>本期直播回放如下，大家快扫码查看吧~</p><p><img height="355" src="https://oscimg.oschina.net/oscnet/up-41198acd2e49349768fe28449ea945e7227.png" width="385" referrerpolicy="no-referrer"></p></div></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 09:35:14 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6852546/blog/10139809</guid>
            <link>https://my.oschina.net/u/6852546/blog/10139809</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌承诺 20 亿美元投资 OpenAI 对手 Anthropic]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="color:#000000">谷歌发言人日前表示，该公司已同意向 OpenAI 的强力竞争对手 Anthropic 投资最多 20 亿美元。目前已预先投资了 5 亿美元，随着时间的推移将再追加 15 亿美元。</span></p><p><span style="color:#000000">Anthropic 成立于 2021 年，是一家由前 OpenAI 团队成员创立的人工智能初创公司。其在 ChatGPT 发布两个月后，就推出了 GPT-4 的重要竞品 Claude，并在 7 月初推出了升级版的 Claude 2。在今年上半年，Anthropic 的估值已达到了约 41 亿美元。</span></p><p><img height="277" src="https://oscimg.oschina.net/oscnet/up-cdc73121940d2bf6a2632504928ecf5790a.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Anthropic 的一份<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2023%2F04%2F06%2Fanthropics-5b-4-year-plan-to-take-on-openai%2F" target="_blank">内部文件透露</a>，该公司计划筹集 50 亿美元或更多以直接与 OpenAI 较量。并预计花费 10 亿美元，在 2024 年底推出自己的新一代大语言模型「Claude-Next」。</span></p><p><span style="color:#000000">Anthropic 首席执行官兼联合创始人 Dario Amodei 曾在上个月的一次谈话中称，「我们只成立了两年半多一点……在这段时间里，我们已经筹集了 15 亿美元，这是一个很大的数字。我们的团队规模相较来说要小得多，但我们已经成功地保持了自己的地位。我们真正做到了少花钱多办事，我认为很快我们就能用更多的资源做更多的事。」</span></p><p><span style="color:#000000">而除谷歌外，Anthropic 还获得了 Salesforce 和 Zoom 的融资。亚马逊也已经向 Anthropic 投资了 12.5 亿美元；并在 9 月份承诺，后续计划共向 Anthropic 投资高达 40 亿美元。</span></p><p><strong><span style="color:#000000">相关阅读：</span></strong></p><ul><li><a href="https://www.oschina.net/news/232921/claude-ai" target="_blank">Anthropic 推出 「更理性的 Claude」，正面硬刚 ChatGPT</a></li><li><p style="margin-left:0px; margin-right:0px; text-align:start"><a href="https://www.oschina.net/news/263552/frontier-model-forum-ai-safety" target="_blank">OpenAI、谷歌微软等设立 1000 万美元 AI 安全基金</a></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 08:56:02 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264126/google-invest-2-billion-anthropic</guid>
            <link>https://www.oschina.net/news/264126/google-invest-2-billion-anthropic</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[MetaGPT 实现多智能体通信，智能体也能轻松狼人杀]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><h1>概述</h1><p>狼人杀游戏是一种受欢迎的多人沟通策略游戏。在 Xu 等人所作的 《Exploring Large Language Models for Communication Games: An Empirical Study on Werewolf》（以下简称「论文」）为题的论文中，展示了大型语言模型（LLM）在游戏中的潜力。考虑到 MetaGPT 作为一个智能体框架，我们提出了这个挑战：我们能否使用 MetaGPT 来快速复制生动的游戏体验？我们非常高兴地宣布，我们成功完成了这个挑战。</p><p>遵循论文的思路，我们成功地通过 MetaGPT 实现了狼人杀游戏智能体的开发。我们展示了以下内容：</p><ol><li>当需要构建多智能体文本游戏，其中智能体之间需要进行精细化沟通时，MetaGPT 框架是极佳选择。</li><li>MetaGPT 提供了直观和自然的抽象，当恰当地使用时，有助于将强大的功能集成到智能体中，如反思、经验学习等。</li><li>在初步实验中，通过调整反思和经验学习机制，我们观察到了智能体性能的明显提高。</li></ol><p>有关更多详细信息，将在本文中剩下部分进行探讨。完整的代码可在<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgeekan%2FMetaGPT%2Ftree%2Fwerewolf_game" target="_blank">MetaGPT 代码库</a>上获得。有关运行代码的指南，请参阅「代码运行指南」部分。关于 MetaGPT 的总体介绍，请参阅我们的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2308.00352" target="_blank">论文</a>。</p><h1>演示</h1><h2>狼人杀智能体游玩演示</h2><p>在深入实现细节探讨之前，让我们先看一下智能体在狼人杀游戏中的精彩瞬间。我们在<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwerewolf.deepwisdom.ai%2F" target="_blank">网页</a>上展示了 5 个具有代表性的游戏过程，并提供完整的 30 个运行的转录，供您探索和娱乐！</p><p>友情提示：</p><ul><li>关于这个游戏的完整介绍可以在论文中找到。游戏的设置是两个村民，一个预言家，一个女巫，一个守衞和两个狼人。我们采用了游戏社区中更为常见的规则，即当狼人屠边时（消除了所有特殊角色或所有村民），狼人就获胜。</li><li>为了促进更加精彩的游戏效果，我们在狼人智能体游玩之前引入相关策略，以此来引导他们积极地模仿特殊角色。</li><li>当然为了实验的简易化的进行：当两个狼人在晚上瞄准两个不同的玩家时，目标默认为第二个选择。</li><li>我们使用 GPT-4 进行游戏运行。</li></ul><h2>智能体的精彩瞬间</h2><p>我们观察到了各种情况，其中我们的智能体表现出逻辑甚至战略行为。以下是一些精彩瞬间：</p><h3>合作 / 共谋</h3><p>Player5（守衞）推理出预言家，分析出当晚选择守衞预言家可以最大化价值，因此守衞了 Player6。</p><p><img alt="" height="580" src="https://oscimg.oschina.net/oscnet/up-b5c5420da74986208482aa943dfb4e9edae.png" width="800" referrerpolicy="no-referrer"></p><p>Player1（狼人）控告 Player2 时，Player5（狼人）果断进行了支持。</p><p><img alt="" height="369" src="https://oscimg.oschina.net/oscnet/up-10bd3f15226c0a7313c90b0442eb76537c1.png" width="800" referrerpolicy="no-referrer"></p><h2>对抗</h2><p>当 Player1（狼人）悍跳预言家时，真正的预言家 Player4 站出来反对狼人。</p><p><img alt="" height="515" src="https://oscimg.oschina.net/oscnet/up-b96b60fe0d3de2d712af304587a84838f61.png" width="800" referrerpolicy="no-referrer"></p><h2>卖队友</h2><p>当大多数玩家对 Player3（狼人）产生怀疑时，Player6（狼人）仔细权衡了利弊，决定开始卖队友。</p><p><img alt="" height="324" src="https://oscimg.oschina.net/oscnet/up-2fd8b8dfc02bdafdc3106c485b83b6bdd22.png" width="800" referrerpolicy="no-referrer"></p><h2>观望</h2><p>当 Player2（狼人）声称自己是预言家时，Player6（村民）从过去的经验中吸取了教训，保留了自己的判断，要求在采取立场之前进行更多的观察。</p><p><img alt="" height="509" src="https://oscimg.oschina.net/oscnet/up-86bc6d3fa8dcc23a474a833b5e7b47a313e.png" width="800" referrerpolicy="no-referrer"></p><p>Player5（女巫）通过分析选择留药。</p><p><img alt="" height="413" src="https://oscimg.oschina.net/oscnet/up-272b1ba2775ddb394a1a2837d4623c7ee6c.png" width="800" referrerpolicy="no-referrer"></p><h2>复杂推理</h2><p>基于先前对 Player2 是狼人的判断，Player6（村民）分析了票面等盘面情况，清楚地区分了 Player3（狼人）和其他玩家。</p><p><img alt="" height="548" src="https://oscimg.oschina.net/oscnet/up-ccaaf1318b54858160f79c4021a2b2bd6fb.png" width="800" referrerpolicy="no-referrer"></p><p>Player6（预言家）准确地通过反思辨别了每个玩家的角色，并由于其对经过验证的村民的敌意检测到了狼人。</p><p><img alt="" height="559" src="https://oscimg.oschina.net/oscnet/up-a5cded422bedf58bedab8bde0924bf33dda.png" width="800" referrerpolicy="no-referrer"></p><h1>实施方案</h1><h2>多智能体通信</h2><p>实现狼人游戏的一个重要元素在于促进智能体之间的精确、细粒度的通信。让我们考虑三种类型的消息：</p><ol><li>从主持人发送给预言家的私聊中，通知预言家或其他有关特定玩家的身份（一对一）。</li><li>从一名狼人发送的私聊中，通知狼人伙伴和主持人所选择的袭击目标（一对多）。</li><li>从主持人发出的公开消息，指示所有玩家醒来（一对所有）。</li></ol><p>MetaGPT 支持所有三种通信，这要归功于关键的抽象概念：<code>Environment</code>（环境）和 <code>Message</code>（消息），以及 agent’s（智能体角色）通过 <code>_publish</code>（发布）和 <code>_observe</code>（观察）两个函数来作为处理消息的方法。每当一个 agents 发布一个 <code>Message</code>，它都会将 <code>Message</code><code>_publish</code> 到 <code>Environment</code> 中。反过来，接收 <code>Message</code> 的 agents 会从 <code>Environment</code> 中_observe <code>Message</code>。而我们需要做的就是填充 <code>Message</code> 属性，如 send_to 和 restricted_to，包括预期的接收者（agents）。然后 MetaGPT 会处理剩下的工作。</p><p>综合考虑，我们建立了一个复杂的智能体之间<strong>通信拓扑结构</strong>。有关详细的实施信息，请随时查看我们的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgeekan%2FMetaGPT%2Ftree%2Fwerewolf_game" target="_blank">代码</a>。我们正在积极努力完善这一机制，并将很快发布一个全面的指南。</p><p><img alt="" height="500" src="https://oscimg.oschina.net/oscnet/up-b7bf83b4832178c7cdbb4e5b0a39824e732.png" width="800" referrerpolicy="no-referrer"></p><h2>智能体能力</h2><p>在论文中，生成最终响应需要多个组件（下图）。在这一部分，我们展示了从智能体的角度出发，构建包含所有这些组件的高效智能体是非常直接和简单的。</p><p><img alt="" height="1378" src="https://oscimg.oschina.net/oscnet/up-b6d94f144c2238dbb480dcb2f9c5f90a25b.png" width="800" referrerpolicy="no-referrer"></p><p>我们采用的方法是利用 MetaGPT 的 <code>Role</code>抽象来定义一个智能体，然后为其配备适当的 <code>Action</code>（动作）。我们定义 <code>Speak</code>和 <code>NighttimeWhisper</code> 作为返回响应的最终 <code>Action</code>（动作）。关于每个准备组件发送到最终响应生成方式，如论文中所概述，请参见下表了解各自的实现。</p><p><img alt="" height="247" src="https://oscimg.oschina.net/oscnet/up-a191e5e9247b78baf9ce767ec61e7442877.png" width="1120" referrerpolicy="no-referrer"></p><p>我们将所有这些 <code>Action</code>（行动） 组合在 <code>Role</code>’s（智能体角色） 的 <code>_observe</code>（观察）、 <code>_think</code>（思考） 和 <code>_act</code>（行动） 中，从而形成了一个清晰的智能体思考和行动流程（下图）。此外，流程中的每个步骤都被模块化，意味着在其他游戏中更容易重用。<strong>通过这种方式，我们构建了一个拥有各种能力的智能体，能够进行复杂的推理和言辞表达。</strong></p><p><strong><img alt="" height="1130" src="https://oscimg.oschina.net/oscnet/up-f465474544ce499d9f77b8b677866113ec7.png" width="800" referrerpolicy="no-referrer"></strong></p><h1>关于新方法的实验</h1><p>在遵循论文的主要程序的同时，我们基于试错的方式修改了反思和经验学习组件的内部工作方式。我们修订后的方法是：</p><ol><li>让智能体展示它游戏过程中反思的状态，并以结构化的方式用语言进行总结。</li><li>记录一个包含四个元素的元组（反思，静态动作指令，来自反思和指令的动作，游戏的最终结果），作为一种经验，并积累成一个经验池。</li><li>当智能体下次遇到相似的情况时，提供相关的过去经验。这里的相似性是根据反思嵌入的语义接近度来定义的。通过回顾类似的经验，智能体如果在过去因为某些操作失败了，将会改变他们的操作；如果成功了，将会增强他们对这一步操作的信心。</li></ol><p>在实践中，我们发现这种方法相当有效。遵循论文的实验设置，我们进行了 30 轮的实验。在前 10 轮中，村民方没有过去的经验；在第 11 轮到第 20 轮中，村民方可以接触到前 10 轮的经验；在第 21 轮到第 30 轮中，村民方可以接触到前 20 轮的经验。当然，本次实验中，我们停止了狼人获得经验的能力，以此更好地来观察村民方的结果。</p><p>下面是性能提升的图表。随着经验的积累，村民方对抗狼人的胜率逐渐增加。我们还检查了村民在识别狼人方面的平均投票准确率。上升的趋势表明，当村民拥有经验时，他们的判断更为准确，从而证实了他们提高的胜率不仅仅是偶然事件的结果。此外，由于投票准确率还取决于投票的难度，因此我们还评估了在一个固定情景下的准确率：在一组 6 名幸存玩家中识别 2 名狼人，这通常是在投票的第一天面临的情况。这一趋势与平均投票准确率的趋势相吻合。</p><p><img alt="" height="358" src="https://oscimg.oschina.net/oscnet/up-8ffd401a7790a720a5fbaea0c72ad900e50.png" width="565" referrerpolicy="no-referrer"></p><h1>代码运行指南</h1><pre><code class="language-python">python examples/werewolf_game/start_game.py # use default arguments</code></pre><pre><code class="language-python">python examples/werewolf_game/start_game.py \\\\
    --use_reflection True \\\\
    --use_experience False \\\\
    --use_memory_selection False \\\\
    --new_experience_version "01-10" \\\\
    --add_human False

# use_reflection: switch to False to disable reflection, this can reduce token costs 
# use_experience: switch to True to supply agents with experience, this requires recording experiences first
# use_memory_selection: switch to True to select only recent and informative messages from memory
# new_experience_version: specify a version to record the current run as experience 
# add_human: switch to True to participate in the game</code></pre><p>我们建议使用 GPT-4 运行代码。平均而言，如果不使用反思，每次运行大约需要 1.5 美元，如果使用反思，则需要 4 美元，如果使用反思和经验学习，则需要 7 美元。</p><h1>致谢</h1><p>这是由来自 MetaGPT 社区的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmannaandpoem" target="_blank">mannaandpoem</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdavidlee21" target="_blank">davidlee21</a>和<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fariafyy" target="_blank">ariayyy</a>作为核心贡献者合作努力的成果。当然，我们还要十分感谢<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2F1766left" target="_blank">Elfe</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fchaleeluo" target="_blank">chaleeluo</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkevin-meng" target="_blank">kevin-meng</a>和<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Flinkedin.com%2Fin%2Fshutian-xiao-b29649241" target="_blank">Shutian</a>也提供了宝贵的见解。我们对他们的奉献心存感激。我们热烈邀请更多社区成员加入并为我们的 MetaGPT 项目做出贡献！</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 07:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264108</guid>
            <link>https://www.oschina.net/news/264108</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百川智能发布 Baichuan2-192K 大模型，上下文窗口全球最长]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>10 月 30 日，百川智能发布<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FlAJh6qGG27u_qCl0kI-0lA" target="_blank">Baichuan2-192K 大模型</a></u>，其上下文窗口长度高达 192K，是目前全球最长的上下文窗口。</p><blockquote><p>上下文窗口长度是大模型的核心技术之一，通过更大的上下文窗口，模型能够结合更多上下文内容获得更丰富的语义信息，更好的捕捉上下文的相关性、消除歧义，进而更加准确、流畅的生成内容，提升模型能力。</p></blockquote><p>据介绍，<strong>Baichuan2-192K 能够处理约 35 万个汉字</strong>，是目前支持长上下文窗口最优秀大模型 Claude2（支持 100K 上下文窗口，实测约 8 万字）的 4.4 倍，更是 GPT-4（支持 32K 上下文窗口，实测约 2.5 万字）的 14 倍。Baichuan2-192K 不仅在上下文窗口长度上超越 Claude2，在长窗口文本生成质量、长上下文理解以及长文本问答、摘要等方面的表现也全面领先 Claude2。</p><p><img height="708" src="https://static.oschina.net/uploads/space/2023/1030/143754_9Lc3_2720166.png" width="1280" referrerpolicy="no-referrer"></p><p>Baichuan2-192K 在 Dureader、NarrativeQA、LSHT、TriviaQA 等 10 项中英文长文本问答、摘要的评测集上表现优异，有 7 项取得 SOTA，显著超过其他长窗口模型。</p><p><img src="https://static.oschina.net/uploads/space/2023/1030/143926_8N50_2720166.png" referrerpolicy="no-referrer"></p><p>此外，LongEval 的评测结果显示，在窗口长度超过 100K 后 Baichuan2-192K 依然能够保持非常强劲的性能，而其他开源或者商用模型在窗口长度增长后效果都出现了近乎直线下降的情况。Claude2 也不例外，在窗口长度超过 80K 后整体效果下降非常严重。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e09d70b43d3d3782cda3982ae4d742587e1.png" referrerpolicy="no-referrer"></p><p>今年 9 月 25 日，百川智能已开放了 Baichuan2 的 API 接口，正式进军企业级市场，开启商业化进程。<strong>此次 Baichuan2-192K 将以 API 调用和私有化部署的方式提供给企业用户</strong>，目前百川智能已经启动 Baichuan2-192K 的 API 内测，开放给法律、媒体、金融等行业的核心合作伙伴。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 06:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264086</guid>
            <link>https://www.oschina.net/news/264086</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[华为申请注册「遥遥领先」商标]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>近日，华为技术有限公司申请注册「遥遥领先」商标，国际分类为运输工具、科学仪器，当前商标状态为等待实质审查。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2632d0767a23ab6a185920e5193ba46340f.png" referrerpolicy="no-referrer"></p><p>最近因华为 Mate60 系列手机发售，「遥遥领先」成为网络热词。</p><p>「遥遥领先」一词最先是出现在华为手机 Mate40 的发布会上，余承东在介绍手机的处理器、屏幕、电池、充电、摄像头、音质等状况时，曾经说了 14 次「遥遥领先」。去年的 Mate50 发布，全球首发了衞星通信功能，余承东再次提及「遥遥领先」，并称其为捅破天的技术，又将「遥遥领先」的热度推高。</p><p>随后，华为的粉丝也经常在华为发布会上喊「遥遥领先」为华为加油。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-c2112b8f18f699b1b8299410458e1811c69.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 06:06:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264078</guid>
            <link>https://www.oschina.net/news/264078</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[📙《高并发的哲学原理》纸质版书稿完全开源，共 16 万多字]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><img alt="" height="600" src="https://oscimg.oschina.net/oscnet/up-1fb8b3621b91010af5c26e565583383ab83.png" width="1762" referrerpolicy="no-referrer"></p><p><strong>阅读地址：</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpphc.lvwenhan.com" target="_blank">https://pphc.lvwenhan.com</a></p><p style="color:#24292f; text-align:start"><strong>pdf 下载链接在网站右上角。</strong></p><h3>写作目标</h3><p style="color:#2c3e50; text-align:start">本书的目标是在作者有限的认知范围内，讨论一下高并发问题背后隐藏的一个哲学原理——找出单点，进行拆分。</p><h3>内容梗概</h3><p style="color:#2c3e50; text-align:start">我们将从动静分离讲起，一步步深入 Apache、Nginx、epoll、虚拟机、k8s、异步非阻塞、协程、应用网关、L4/L7 负载均衡器、路由器 (网关)、交换机、LVS、软件定义网络 (SDN)、Keepalived、DPDK、ECMP、全冗余架构、用户态网卡、集中式存储、分布式存储、PCIe 5.0、全村的希望 CXL、InnoDB 三级索引、内存缓存、KV 数据库、列存储、内存数据库、Shared-Nothing、计算存储分离、Paxos、微服务架构、削峰、基于地理位置拆分、高可用等等等等。并最终基于地球和人类社会的基本属性，设计出可以服务地球全体人类的高并发架构。</p><p style="color:#2c3e50; text-align:start"><br> 全书共 167674 字。</p><h3>读者评价</h3><blockquote><p>会上一谈到架构和 I/O，我都想到你的文章。主讲解答清楚和没解答清楚的，都没你的文章清楚。</p><p>—— 秋收，于 RubyConf 2023</p></blockquote><hr><blockquote><p>像看小说一样把文章都看完了，全程无尿点，作者的脑袋是在哪里开过光，知识储备竟如此扎实</p><p>—— 观东山</p></blockquote><hr><blockquote><p>非常棒的技术分享！深入浅出，娓娓道来，让我想起了那本 csapp。</p><p>—— drhrchen</p></blockquote><hr><blockquote><p>写得真好，膜拜！作者愿意出书吗，一定买！</p><p>—— bean</p></blockquote><hr><blockquote><p>拜读了！应该算是架构顶级总结！！</p><p>—— 雨山前</p></blockquote><hr><blockquote><p>看完了，博主好厉害，学习到了各种骚技巧，和知识，膜拜</p><p>—— evanxian</p></blockquote><hr><blockquote><p>写的太好了，不仅充满了理工科的严谨较真，也充满了文科的浪漫</p><p>—— 一秒</p></blockquote><hr><blockquote><p>写得很好，视角也是我喜欢的，站在地球表面，述事宏大，思维自信。</p><p>—— 纳秒时光</p></blockquote><hr><blockquote><p>全部看完，博主太强了，很受启发</p><p>—— Bruce</p></blockquote><hr><blockquote><p>棒</p><p>—— JuniaWonter</p></blockquote><h2>作者信息</h2><h3>吕文翰</h3><ol><li>GitHub：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjohnlui" target="_blank">johnlui</a></li><li>职位：住范儿创始成员，CTO，监事</li></ol><h4>高并发系统处理经验</h4><ol><li>2017 年维护的单体 CMS 系统顶住了每日两百万 PV 的压力</li><li>2020 年优化一个单机 PHP 商城顶住了 QPS 1000+ 的压力</li><li>2021 年设计的分布式电商秒杀系统在实际业务中跑到了最高一分钟 GMV 500 万，QPS 10000+</li></ol><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3e128c2c71f79a9f5c551fa204024a7d6d1.jpg" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>&nbsp;</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-c1a9c97d554a8c227a53037467944206a7c.jpg" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ce3364f3899525cd6ffc33de9d05faf6e73.jpg" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-03c79aa58b98f1f7f757bc4647cc40a81b0.jpg" referrerpolicy="no-referrer"></p><p><img alt="" height="1818" src="https://oscimg.oschina.net/oscnet/up-bbca5aa6d8d33372882757c429ad5a13815.jpg" width="3320" referrerpolicy="no-referrer"></p><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 05:27:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264073</guid>
            <link>https://www.oschina.net/news/264073</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Windows 11 已原生支持 11 种文件存档格式，包括 7-Zip 和 RAR]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="color:#000000">在今年 5 月份，微软方面曾<a href="https://www.oschina.net/news/242230/windows-11-supports-rar">宣布</a>将在&nbsp;<span style="background-color:#ffffff">Windows 11 系统中原生增加对 RAR、7-Zip 等压缩文件格式的解压支持。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">时至今日，该公司已通过本月的可选&nbsp;KB5031455&nbsp;预览累积更新添加了对 11 种新文件存档格式的支持，Windows 11 22H2 现在原生支持近十几种附加存档格式。</span></span><span style="color:#000000"><span style="background-color:#ffffff">Windows 11 中支持的存档类型的更新列表现在添加了：.rar、.7z、.tar、.tar.gz、.tar.bz2、.tar.zst、.tar.xz、.tgz、.tbz2、.tzst、和 .txz。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">不过目前还不支持密码加密文件，微软<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bleepingcomputer.com%2Fnews%2Fmicrosoft%2Fwindows-11-adds-support-for-11-file-archives-including-7-zip-and-rar%2F" target="_blank">发言人</a>也没有透露更多的相关信息；其后续可能还将添加对&nbsp;LZH、LZH 和 XAR 等其他格式的支持。</span></span></p><p><span style="color:#000000">「我们使用 </span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flibarchive%2Flibarchive" target="_blank">libarchive</a><span style="color:#000000"> 开源项目添加了对其他存档格式的原生支持，包括 tar、7-Zip、RAR、gz 和许多其他格式。现在，你可以在 Windows 上的压缩过程中获得更高的存档功能性能。」</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">libarchive 是一个开源的 C 库，旨在为各种不同的压缩格式提供读取和写入支持。它支持许多常见的压缩格式，并提供了许多高级功能，例如加密、数字签名、多卷支持等。libarchive 的主要优点是它的跨平台支持，它可以在各种操作系统上运行，包括 Linux、Windows、macOS 等。它还提供了多种语言的绑定，如 Python、Ruby、Perl 等，使得开发人员可以方便地在自己喜欢的编程语言中使用它。</span></p><p><span style="color:#000000">由于 KB5031455 是一个可选更新，Windows 用户必须手动安装。这项新功能还将通过计划在 11 月份的"</span>Patch Tuesday<span style="color:#000000">"发布的累积更新向所有 Windows 11 用户推出。</span></p><p><img height="271" src="https://oscimg.oschina.net/oscnet/up-2a02652354dae96fd940ccc4d707d65e355.png" width="500" referrerpolicy="no-referrer"></p><p><strong>延伸阅读：</strong></p><ul><li><a href="https://www.oschina.net/news/242230/windows-11-supports-rar" target="_blank">Windows 将原生支持解压 RAR 和 7Z</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264054/windows-11-support-11-file-archives-7-zip-rar</guid>
            <link>https://www.oschina.net/news/264054/windows-11-support-11-file-archives-7-zip-rar</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[🎊OpenTiny Vue 3.11.0 发布：增加富文本、ColorPicker 等 4 个新组件，迎来了贡献者大爆发！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p>你好，我是 Kagol。</p><p>非常高兴跟大家宣布，2023 年 10 月 24 日，OpenTiny Vue 发布了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Freleases%2Ftag%2Fv3.11.0" target="_blank">v3.11.0</a> 🎉。</p><p>OpenTiny 每次大版本发布，都会给大家带来一些实用的新特性，8.14 我们发布了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Freleases%2Ftag%2Fv3.10.0" target="_blank">v3.10.0</a> 版本，增加了 4 个新组件，组件 Demo 支持在 Options 和 Composition api 之间切换。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7268207722239148044" target="_blank">🎉OpenTiny Vue 3.10.0 版本发布：组件 Demo 支持 Composition 写法，新增 4 个新组件</a></p><p>本次 3.11.0 版本主要增加以下新组件：</p><ul><li>RichTextEditor 富文本编辑器组件 - by <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCaesar-ch" target="_blank">Caesar-ch</a></li><li>ColorPicker 颜色选择器组件 - by <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FGaoNeng-wWw" target="_blank">GaoNeng-wWw</a></li><li>CalendarView 日历视图组件 - by <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkagol" target="_blank">kagol</a></li><li>Divider 分割线组件 - by <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvaebe" target="_blank">vaebe</a></li></ul><p>本次版本共有 23 位贡献者参与开发，其中有 14 位是新贡献者，欢迎新朋友们👏</p><p>以下是新贡献者：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjack-zishan" target="_blank">@jack-zishan</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F392" target="_blank">#392</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FLinboLen" target="_blank">@LinboLen</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F478" target="_blank">#478</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvaebe" target="_blank">@vaebe</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F471" target="_blank">#471</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fallenli178" target="_blank">@allenli178</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F488" target="_blank">#488</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FBinks123" target="_blank">@Binks123</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F500" target="_blank">#500</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fyoyo201626" target="_blank">@yoyo201626</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F513" target="_blank">#513</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwkif" target="_blank">@wkif</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F512" target="_blank">#512</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fchenguang1994" target="_blank">@chenguang1994</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F518" target="_blank">#518</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FZuowendong" target="_blank">@Zuowendong</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F503" target="_blank">#503</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgweesin" target="_blank">@gweesin</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F554" target="_blank">#554</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fshonen7" target="_blank">@shonen7</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F567" target="_blank">#567</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxlearns" target="_blank">@xlearns</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F574" target="_blank">#574</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fianxinnew" target="_blank">@ianxinnew</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F617" target="_blank">#617</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FXppp0217" target="_blank">@Xppp0217</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F610" target="_blank">#610</a></li></ul><p>也感谢老朋友们对 OpenTiny 的辛苦付出！</p><p>尤其感谢 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpe-3" target="_blank">pe-3</a> / <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCaesar-ch" target="_blank">Caesar-ch</a> / <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FGaoNeng-wWw" target="_blank">GaoNeng-wWw</a> / <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvaebe" target="_blank">vaebe</a> / <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FBinks123" target="_blank">Binks123</a>。</p><p>大家可以更新 <code>@opentiny/vue@3.11.0</code> 进行体验！</p><h2>RichTextEditor 富文本编辑器</h2><p>该组件由 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCaesar-ch" target="_blank">Caesar-ch</a> 同学贡献🎉</p><p>富文本编辑器虽然不是高频组件，但在特定的领域，比如需求管理、内容编辑、文章创作等，几乎是必备组件之一。</p><p>为了满足这些业务的需求，我们推出了 RichTextEditor 富文本组件，目前只是初版，只包含以下基础功能：</p><ul><li>加粗、斜体、下划线、删除线</li><li>引用</li><li>行内代码、代码块</li><li>有序列表、无序列表、任务列表</li><li>上标、下标</li><li>撤销、重做</li><li>左对齐、右对齐、居中对齐</li><li>段落、H1-H6 标题</li><li>字号、行间距</li><li>高亮、文本颜色、背景色</li><li>清除格式</li><li>超链接</li><li>上传图片</li><li>插入/编辑表格</li></ul><p>后续将不断进行丰富，欢迎朋友们一起参与共建。</p><p>使用起来非常简单：</p><pre><code class="language-html">&lt;template&gt;
  &lt;tiny-rich-text-editor&gt;&lt;/tiny-rich-text-editor&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { RichTextEditor as TinyRichTextEditor } from '@opentiny/vue'
&lt;/script&gt;
</code></pre><p>以下是效果图：</p><p><img src="https://oscimg.oschina.net/oscnet/up-47bf70d440b55b03b73cadece12c578c878.png" alt="" referrerpolicy="no-referrer"></p><p>可以通过 custom-toolbar 配置工具栏：</p><pre><code class="language-html">&lt;template&gt;
  &lt;tiny-rich-text-editor :customToolBar="customToolBar"&gt;&lt;/tiny-rich-text-editor&gt;
&lt;/template&gt;

&lt;script setup lang="jsx"&gt;
import { ref } from 'vue'
import { RichTextEditor as TinyRichTextEditor } from '@opentiny/vue'

const customToolBar = ref(['bold', 'italic'])
&lt;/script&gt;
</code></pre><p>效果如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-1147fffec6379d22695d67e56fba4664680.png" alt="" referrerpolicy="no-referrer"></p><p>更多功能等你来体验！</p><h2>ColorPicker 颜色选择器</h2><p><code>ColorPicker</code> 颜色选择组件用于在应用程序和界面中让用户选择颜色。它是一个交互式的元素，通常由一个色彩光谱、色相环和颜色值输入框组成，用户可以通过这些元素来选择所需的颜色。ColorPicker 的主要功能是让用户能够精确地选择特定的颜色，以便在应用程序的各种元素中使用。</p><p>该组件是由 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FGaoNeng-wWw" target="_blank">GaoNeng</a> 同学贡献的🎉，他还写了一篇 ColorPicker 组件开发全流程的总结文章。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7273039565904805943" target="_blank">GaoNeng：我是如何为 OpenTiny 贡献新组件的？</a></p><p>ColorPicker 使用方式很简单：</p><pre><code class="language-html">&lt;template&gt;
  &lt;tiny-color-picker v-model="color" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from 'vue'
import { ColorPicker as TinyColorPicker } from '@opentiny/vue'
const color = ref('#66ccff')
&lt;/script&gt;
</code></pre><p>效果如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-b057da8b3789c696e4d08173ef282701c0f.png" alt="" referrerpolicy="no-referrer"></p><p>该组件功能非常强大，除了在色板中选择颜色之外，还支持：</p><ul><li>透明度调节</li><li>预定义颜色</li><li>颜色历史</li><li>颜色选择面板单独使用</li></ul><p>更多功能等你来体验！</p><p>透明度调节：</p><p><img src="https://oscimg.oschina.net/oscnet/up-c350aad80432e9ca114193691533a44c539.png" alt="" referrerpolicy="no-referrer"></p><p>预定义颜色：</p><p><img src="https://oscimg.oschina.net/oscnet/up-4e263213bfaa04d89cd65b26d6cc28e4f47.png" alt="" referrerpolicy="no-referrer"></p><p>颜色历史：</p><p><img src="https://oscimg.oschina.net/oscnet/up-84717f04236162824c078dd4b52e6d4c956.png" alt="" referrerpolicy="no-referrer"></p><p>颜色面板单独使用：</p><p><img src="https://oscimg.oschina.net/oscnet/up-538fd1ef71f738381ec1b57677217a37339.png" alt="" referrerpolicy="no-referrer"></p><h2>CalendarView 日历视图</h2><p>大家都知道 DatePicker 日期选择器，这个组件通过一个日期表格来选择一个日期，日期表格的放大版本就是日历表格，我们来看下对比图。</p><p>DatePicker 日期表格：</p><p><img src="https://oscimg.oschina.net/oscnet/up-9c75f49c4563c1c34d33d83efa3bba203e5.png" alt="" referrerpolicy="no-referrer"></p><p>CalendarView 日历表格：</p><p><img src="https://oscimg.oschina.net/oscnet/up-c3f1e361478ec9c16b89e8e5651e097945f.png" alt="" referrerpolicy="no-referrer"></p><p>欢迎体验！</p><h2>Divider 分割线</h2><p>该组件由 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvaebe" target="_blank">vaebe</a> 同学贡献🎉</p><p>分割线相对比较简单，目前主要支持：</p><ul><li>横向和竖向分割线</li><li>添加分割线文案、调整文案位置</li><li>自定义分割线样式</li></ul><p>效果如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-1660ecf8650d5f1824c8afd9a48cf9374cb.png" alt="" referrerpolicy="no-referrer"></p><p>欢迎体验！</p><h2>关于 OpenTiny</h2><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">OpenTiny</a> 是一套企业级 Web 前端开发解决方案，提供跨端、跨框架的 UI 组件库，适配 PC 端 / 移动端等多端，支持 Vue2 / Vue3 / Angular 多技术栈，拥有灵活扩展的低代码引擎，包含主题配置系统 / 中后台模板 / CLI 命令行等丰富的效率提升工具，可帮助开发者高效开发 Web 应用。</p><p><img src="https://oscimg.oschina.net/oscnet/up-668bb932353df7dbf97bc64795d640c6a25.png" alt="" referrerpolicy="no-referrer"></p><p>核心亮点：</p><ol><li><code>跨端跨框架</code>：使用 Renderless 无渲染组件设计架构，实现了一套代码同时支持 Vue2 / Vue3，PC / Mobile 端，并支持函数级别的逻辑定制和全模板替换，灵活性好、二次开发能力强。</li><li><code>组件丰富</code>：PC 端有 100+组件，移动端有 30+组件，包含高频组件 Table、Tree、Select 等，内置虚拟滚动，保证大数据场景下的流畅体验，除了业界常见组件之外，我们还提供了一些独有的特色组件，如：Split 面板分割器、IpAddress IP 地址输入框、Calendar 日历、Crop 图片裁切等。</li><li><code>低代码引擎</code>：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine" target="_blank">TinyEngine</a> 低代码引擎使能开发者定制低代码平台。它是低代码平台的底座，提供可视化搭建页面等基础能力，既可以通过线上搭配组合，也可以通过下载源码进行二次开发，实时定制出自己的低代码平台。适用于多场景的低代码平台开发，如：资源编排、服务端渲染、模型驱动、移动端、大屏端、页面编排等。</li><li><code>配置式组件</code>：组件支持模板式和配置式两种使用方式，适合低代码平台，目前团队已经将 OpenTiny 集成到内部的低代码平台，针对低码平台做了大量优化</li><li><code>周边生态齐全</code>：提供了基于 Angular + TypeScript 的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-ng%2Foverview" target="_blank">TinyNG</a> 组件库，提供包含 10+ 实用功能、20+ 典型页面的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Fpro" target="_blank">TinyPro</a> 中后台模板，提供覆盖前端开发全流程的 TinyCLI 工程化工具，提供强大的在线主题配置平台 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Fdesigntheme%2Fhome" target="_blank">TinyTheme</a></li></ol><hr><p>欢迎加入 OpenTiny 开源社区。</p><p>添加微信小助手：opentiny-official，一起参与共建！</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">OpenTiny</a> 官网：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">https://opentiny.design/</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue" target="_blank">Vue 组件库</a>：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue" target="_blank">https://opentiny.design/tiny-vue</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine" target="_blank">低代码引擎</a>：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine" target="_blank">https://opentiny.design/tiny-engine</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-ng" target="_blank">Angular 组件库</a>：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-ng" target="_blank">https://opentiny.design/tiny-ng</a></p><p>OpenTiny 代码仓库：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">https://github.com/opentiny/</a> （欢迎 Star ⭐）</p><p>往期文章推荐</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7291598231954653240" target="_blank">OpenTiny Vue 支持 Vue2.7 啦！</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7280006603637751865" target="_blank">🖖少年，该升级 Vue3 了！</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7273039565904805943" target="_blank">✨GaoNeng：我是如何为 OpenTiny 贡献新组件的？</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7262349502920523833" target="_blank">✨xiaoy：但因热爱，愿迎万难，OpenTiny 社区增加一枚前端程序媛贡献者</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7255239937170161723" target="_blank">✨贡献者招募：前端 Vuer，请收好这份《Vue 组件单元测试》宝典，给自己多一些安全感</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7258319655285571644" target="_blank">🎉OpenTiny 前端组件库正式开源啦！面向未来，为开发者而生</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7252198762624548924" title="从自研走向开源的 TinyVue 组件库" target="_blank">🎉从自研走向开源的 TinyVue 组件库</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7218926523252260923" target="_blank">🌈一个 OpenTiny，Vue2 Vue3 都支持！</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7224756843711758393" target="_blank">🌈如何启动我的第一次开源贡献</a>（如果你之前没有参加过开源贡献，请阅读这篇文章）</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4863191/blog/10128241</guid>
            <link>https://my.oschina.net/u/4863191/blog/10128241</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[官宣｜Apache Flink 1.18 发布公告]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p style="color:#24292e; margin-left:0px; margin-right:0px; text-align:start"><img alt="" height="383" src="https://oscimg.oschina.net/oscnet/up-3eb9414c54625e015117d61b4b0b2397619.png" width="685" referrerpolicy="no-referrer"></p><p style="color:#24292e; margin-left:0px; margin-right:0px; text-align:start">Apache Flink PMC 已正式发布 Apache Flink 1.18.0 版本。与往常一样，这是一个充实的版本，包含了广泛的改进和新功能。总共有 174 人为此版本做出了贡献，完成了 18 个 FLIPs 和 700 多个问题。感谢各位贡献者的支持！</p><span id="OSC_h2_1"></span><h2>迈向 Streaming Lakehouse</h2><span id="OSC_h3_2"></span><h3>Flink SQL 提升</h3><span id="OSC_h4_3"></span><h4>Flink SQL Gateway 的 JDBC Driver</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Flink 1.18 版本提供了 Flink SQL Gateway 的 JDBC Driver。因此，您现在可以使用支持 JDBC 的任何 SQL 客户端通过 Flink SQL 与您的表进行交互。以下是使用<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjulianhyde.github.io%2Fsqlline%2Fmanual.html" rel="nofollow" target="_blank">SQLLine</a><span>&nbsp;</span>的示例。</p><pre><code>sqlline version 1.12.0
sqlline&gt; !connect jdbc:flink://localhost:8083
Enter username for jdbc:flink://localhost:8083:
Enter password for jdbc:flink://localhost:8083:
0: jdbc:flink://localhost:8083&gt; CREATE TABLE T(
<span style="color:#4078f2">. </span>.)&gt;      a INT,
<span style="color:#4078f2">. </span>.)&gt;      b VARCHAR(10)
<span style="color:#4078f2">. </span>.)&gt;  ) WITH (
<span style="color:#4078f2">. </span>.)&gt;      <em>'connector'</em> = <em>'filesystem'</em>,
<span style="color:#4078f2">. </span>.)&gt;      <em>'path'</em> = <em>'file:///tmp/T.csv'</em>,
<span style="color:#4078f2">. </span>.)&gt;      <em>'format'</em> = <em>'csv'</em><span style="color:#4078f2">. </span>.)&gt;  );
No rows affected (0.122 seconds)
<span style="color:#e45649">0: jdbc:flink://localhost:8083&gt; INSERT INTO T VALUES (1, 'Hi'), (2, 'Hello');
+----------------------------------+</span><span style="color:#e45649">|              job id              |
+----------------------------------+</span><span style="color:#e45649">| fbade1ab4450fc57ebd5269fdf60dcfd |
+----------------------------------+</span>
1 row selected (1.282 seconds)
<span style="color:#e45649">0: jdbc:flink://localhost:8083&gt; SELECT * FROM T;
+---+-------+</span><span style="color:#e45649">| a |   b   |
+---+-------+</span>
| 1 | Hi    |
<span style="color:#e45649">| 2 | Hello |
+---+-------+</span>
2 rows selected (1.955 seconds)
0: jdbc:flink://localhost:8083&gt;
</code></pre><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fjdbcdriver%2F" rel="nofollow" target="_blank">文档</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-293%253A%2BIntroduce%2BFlink%2BJdbc%2BDriver%2BFor%2BSql%2BGateway" rel="nofollow" target="_blank">FLIP-293: Introduce Flink Jdbc Driver For Sql Gateway</a></li></ul><span id="OSC_h4_4"></span><h4>Flink 连接器的存储过程（Stored Procedure）支持</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">存储过程（Stored Procedure）在传统数据库中一直是不可或缺的工具，它提供了一种方便的方式来封装用于数据操作和任务管理的复杂逻辑。存储过程还提供了增强性能的潜力，因为它们可以直接在外部数据库中触发数据操作的处理。其他流行的数据系统如 Trino 和 Iceberg 将常见的维护任务自动化并简化为一小组存储过程，从而大大减轻了用户的管理负担。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">本次更新主要针对 Flink 连接器的开发人员，他们现在可以通过 Catalog 接口预定义自定义存储过程到连接器中。对用户的主要好处是，以前需要编写自定义 Flink 代码来实现的连接器特定任务现在可以用封装化、标准化和潜在优化底层操作的简单调用来替代。用户可以使用熟悉的 CALL 语法执行存储过程，并使用 SHOW PROCEDURES 查看连接器的可用存储过程。连接器内的存储过程提高了 Flink 的 SQL 和 Table API 的可扩展性，为用户提供更顺畅的数据访问和管理能力。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">用户可以使用 Call 语句来直接调用 catalog 内置的存储过程（注：catalog 内置的存储过程请参考对应 catalog 的文档）。比如可以通过如下 Call 语句对 Paimon 表进行 compact 操作：</p><pre><code><span style="color:#a626a4">CREATE</span><span style="color:#a626a4">TABLE</span><span style="color:#50a14f">`paimon`</span>.<span style="color:#50a14f">`default`</span>.<span style="color:#50a14f">`T`</span> ( 
 <span style="color:#a626a4">id</span><span style="color:#c18401">BIGINT</span> PRIMARY <span style="color:#a626a4">KEY</span><span style="color:#a626a4">NOT</span><span style="color:#a626a4">ENFORCED</span>,  
 dt <span style="color:#a626a4">STRING</span>, <em>-- format 'yyyy-MM-dd'  </em>
 v <span style="color:#a626a4">STRING</span>
);

<em>-- use catalog before call </em>
proceduresUSE CATALOG `paimon`;

<em>-- compact the whole table using call statement</em><span style="color:#a626a4">CALL</span> sys.compact(<span style="color:#50a14f">'default.T'</span>);
</code></pre><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fprocedures%2F" rel="nofollow" target="_blank">文档</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-311%253A%2BSupport%2BCall%2BStored%2BProcedure" rel="nofollow" target="_blank">FLIP-311: Support Call Stored Procedure</a></li></ul><span id="OSC_h4_5"></span><h4>DDL 支持扩展</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">从 1.18 版本开始，Flink 支持以下功能：</p><ul><li>REPLACE TABLE AS SELECT</li><li>CREATE OR REPLACE TABLE AS SELECT</li></ul><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">这两个命令以及之前支持的 CREATE TABLE AS 现在都支持原子性，前提是底层连接器也支持。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">此外，Apache Flink 现在支持在批处理模式下执行 TRUNCATE TABLE。与以前一样，底层连接器需要实现并提供此功能。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">最后，我们还实现了通过以下方式支持添加、删除和列出分区：</p><ul><li>ALTER TABLE ADD PARTITION</li><li>ALTER TABLE DROP PARTITION</li><li>SHOW PARTITIONS</li></ul><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fsql%2Ftruncate%2F" rel="nofollow" target="_blank">TRUNCATE 文档</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fsql%2Fcreate%2F%23create-or-replace-table" rel="nofollow" target="_blank">CREATE OR REPLACE 文档</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fsql%2Falter%2F%23alter-table" rel="nofollow" target="_blank">ALTER TABLE 文档</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-302%253A%2BSupport%2BTRUNCATE%2BTABLE%2Bstatement%2Bin%2Bbatch%2Bmode" rel="nofollow" target="_blank">FLIP-302: Support TRUNCATE TABLE statement in batch mode</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-303%253A%2BSupport%2BREPLACE%2BTABLE%2BAS%2BSELECT%2Bstatement" rel="nofollow" target="_blank">FLIP-303: Support REPLACE TABLE AS SELECT statement</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-305%253A%2BSupport%2Batomic%2Bfor%2BCREATE%2BTABLE%2BAS%2BSELECT%2528CTAS" rel="nofollow" target="_blank">FLIP-305: Support atomic for CREATE TABLE AS SELECT(CTAS) statement</a>+statement)</li></ul><span id="OSC_h4_6"></span><h4>时间旅行（Time Traveling）</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Flink 支持时间旅行（time travel） SQL 语法，用于查询历史版本的数据。用户可以指定一个时间点，来检索表在该时间点的数据和架构。借助时间旅行功能，用户可以轻松分析和比较数据的历史版本。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">例如，用户可以通过如下的语句查询一张表指定时间点的数据；</p><pre><code><em>-- 查询表 `paimon_tb` 在 2022 年 11 月 11 日的数据</em><span style="color:#a626a4">SELECT</span> * <span style="color:#a626a4">FROM</span> paimon_tb <span style="color:#a626a4">FOR</span> SYSTEM_TIME <span style="color:#a626a4">AS</span><span style="color:#a626a4">OF</span><span style="color:#986801">TIMESTAMP</span><span style="color:#50a14f">'2022-11-11 00:00:00'</span>；
</code></pre><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fsql%2Fqueries%2Ftime-travel%2F" rel="nofollow" target="_blank">文档</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-308%253A%2BSupport%2BTime%2BTravel" rel="nofollow" target="_blank">FLIP-308: Support Time Travel</a></li></ul><span id="OSC_h3_7"></span><h3>流处理提升</h3><span id="OSC_h4_8"></span><h4>Table API &amp; SQL 支持算子级别状态保留时间（TTL）</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">从 Flink 1.18 版本开始，Table API 和 SQL 用户可以为有状态的算子单独设置状态保留时间 (TTL)。在像流 regular join 这样的场景中，用户现在可以为左侧和右侧流设置不同的 TTL。在以前的版本中，状态保留时间只能在 pipeline 级别使用配置项 table.exec.state.ttl 进行控制。引入算子级别的状态保留后，用户现在可以根据其具体需求优化资源使用。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fconcepts%2Foverview%2F%23configure-operator-level-state-ttl" rel="nofollow" target="_blank">文档</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-292%253A%2BEnhance%2BCOMPILED%2BPLAN%2Bto%2Bsupport%2Boperator-level%2Bstate%2BTTL%2Bconfiguration" rel="nofollow" target="_blank">FLIP-292: Enhance COMPILED PLAN to support operator-level state TTL configuration</a></li></ul><span id="OSC_h4_9"></span><h4>SQL 的水印对齐（Watermark Alignment）和空闲检测（Idleness Detection）</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">现在，您可以使用 SQL Hint 配置<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Fdatastream%2Fevent-time%2Fgenerating_watermarks%2F%23watermark-alignment" rel="nofollow" target="_blank">水印对齐</a>和<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Fdatastream%2Fevent-time%2Fgenerating_watermarks%2F%23dealing-with-idle-sources" rel="nofollow" target="_blank">数据源空闲超时</a>。之前这些功能仅在 DataStream API 中可用。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fsql%2Fqueries%2Fhints%2F" rel="nofollow" target="_blank">文档</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-296%253A%2BExtend%2Bwatermark-related%2Bfeatures%2Bfor%2BSQL" rel="nofollow" target="_blank">FLIP-296：Extend watermark-related features for SQL</a></li></ul><span id="OSC_h3_10"></span><h3>批处理提升</h3><span id="OSC_h4_11"></span><h4>Hybrid Shuffle 支持远程存储</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Hybrid Shuffle 支持将 Shuffle 数据存储在远程存储中。可以使用配置项 taskmanager.network.hybrid-shuffle.remote.path 配置远程存储路径。Hybrid Shuffle 通过将内存用量与并行度解耦，减少了网络内存的使用，提高了稳定性和易用性。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fops%2Fbatch%2Fbatch_shuffle%2F%23hybrid-shuffle" rel="nofollow" target="_blank">文档</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-301%253A%2BHybrid%2BShuffle%2Bsupports%2BRemote%2BStorage" rel="nofollow" target="_blank">FLIP-301: Hybrid Shuffle supports Remote Storage</a></li></ul><span id="OSC_h4_12"></span><h4>性能提升与 TPC-DS 基准测试</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">在之前的版本中，社区投入了大量精力来改进 Flink 的批处理性能，产生了显著的改进。在这个发布周期中，社区的贡献者继续付出了重大努力，进一步改进了 Flink 的批处理性能。</p><p>Flink SQL 的运行时过滤（Runtime Filter）</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">运行时过滤（Runtime Filter）是用于优化 join 性能的常见方法。它旨在动态生成某些 join 查询的运行时过滤条件，以减少扫描或 Shuffle 的数据量，避免不必要的 I/O 和网络传输，从而加速查询。我们在 Flink 1.18 版本引入了运行时过滤，并通过 TPC-DS 基准测试验证了其有效性，观察到启用此功能后，某些查询的速度提高了 3 倍。</p><p>Flink SQL 算子的融合代码生成（Operator Fusion Codegen）</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">算子融合代码生成（Operator Fusion Codegen）通过将算子 DAG 融合成一个经过优化的单算子，消除了虚函数调用，利用 CPU 寄存器进行中间数据操作，并减少指令缓存不命中的情况，从而提高了查询的执行性能。作为一项技术优化，我们通过 TPC-DS 验证了其有效性，部分批处理算子（Calc、HashAgg 和 HashJoin）在 1.18 版本中完成了融合代码生成支持，很多查询性能显著提高。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">请注意，上述两个功能默认情况下处于关闭状态。可以通过使用 table.optimizer.runtime-filter.enabled 和 table.exec.operator-fusion-codegen.enabled 两个配置项来启用它们。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">自 Flink 1.16 以来，Apache Flink 社区一直在通过 TPC-DS 基准测试框架持续跟踪其批处理引擎的性能。在 Flink 1.17 版本中经过重大改进（动态 join 重排序、动态 local aggregation）后，前面描述的两项改进（算子融合、运行时过滤）在分区表 10T 数据集上，与 Flink 1.17 相比性能提高了 14%，与 Flink 1.16 相比性能提高了 54%。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><img alt="1" src="https://oscimg.oschina.net/oscnet/up-7127b4e54a13b1ffae35dd7df454a629f62.png" referrerpolicy="no-referrer"></p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-324%253A%2BIntroduce%2BRuntime%2BFilter%2Bfor%2BFlink%2BBatch%2BJobs" rel="nofollow" target="_blank">FLIP-324: Introduce Runtime Filter for Flink Batch Jobs</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-315%2BSupport%2BOperator%2BFusion%2BCodegen%2Bfor%2BFlink%2BSQL" rel="nofollow" target="_blank">FLIP-315: Support Operator Fusion Codegen for Flink SQL</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fververica%2Fflink-sql-benchmark" rel="nofollow" target="_blank">Benchmarking 代码仓库</a></li></ul><span id="OSC_h2_13"></span><h2>迈向云原生弹性化</h2><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">弹性化（Elasticity）描述了系统在不中断的情况下适应工作负载变化的能力，理想情况下是以自动方式进行。这是云原生系统的一个定义特征，对于长时间运行的流处理工作负载尤为重要。因此，弹性性能的改进是 Apache Flink 社区不断投入的领域。最近的提议包括 Kubernetes<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-kubernetes-operator-docs-release-1.6%2Fdocs%2Fcustom-resource%2Fautoscaler%2F" rel="nofollow" target="_blank">自动缩放器（Autoscaler）</a>、对性能调整的众多改进，以及<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdeployment%2Felastic_scaling%2F%23adaptive-scheduler" rel="nofollow" target="_blank">自适应调度器（Adaptive Scheduler）</a>。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">自 Flink 1.15 版本首次引入以来，自适应调度器构成了完全弹性 Apache Flink 部署的核心。在其核心功能中，它允许作业在运行时更改其资源要求和并行度。此外，它还根据集群中可用的资源进行自适应调整，只有当集群能够满足作业的最低所需资源时才会重新调整。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">在 Flink 1.18 版本之前，自适应调度器主要用于<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdeployment%2Felastic_scaling%2F%23reactive-mode" rel="nofollow" target="_blank">响应模式（Reactive Mode）</a>，根据设计，单个作业始终会使用集群中的所有可用资源。请参阅这篇<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fflink.apache.org%2F2021%2F05%2F06%2Fscaling-flink-automatically-with-reactive-mode%2F" rel="nofollow" target="_blank">博客文章</a>，了解如何使用 Kubernetes 上的水平 Pod 自动缩放器自动缩放 Flink 作业。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">在 Flink 1.18 版本中，自适应调度器变得更加强大和更广泛适用，并正在成为 Apache Flink 流处理任务的默认调度器。</p><span id="OSC_h3_14"></span><h3>通过 REST API 控制动态细粒度扩缩容</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">尽管自适应调度器具有在运行时更改作业资源需求的能力，但此功能之前一直未开放给用户，自 Flink 1.18 起，在作业运行时，您可以通过 Flink Web UI 和 REST API 更改作业的任何 task 的并行度。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">实现细节上，Apache Flink 在获得新并行度所需的资源后会立即执行扩缩容操作。扩缩容操作不基于 savepoint，而是基于普通的定期 checkpoint，这意味着它不会引入额外的 snapshot。对于状态规模较小的作业，重新调整操作几乎立即发生，且中断时间非常短。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">与 Apache Flink Web UI 的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fops%2Fmonitoring%2Fback_pressure%2F" rel="nofollow" target="_blank">反压监控</a>相结合，现在更容易找到并维护使每个任务高效运行、无反压的并行度。</p><ul><li>如果一个任务非常繁忙（红色），您可以增加并行度。</li><li>如果一个任务大部分时间处于空闲状态（蓝色），您可以减少并行度。</li></ul><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><img alt="2" src="https://oscimg.oschina.net/oscnet/up-8e76119ef7de7e31d5444226a93ec6a24b0.png" referrerpolicy="no-referrer"></p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-291%253A%2BExternalized%2BDeclarative%2BResource%2BManagement" rel="nofollow" target="_blank">FLIP-291: Externalized Declarative Resource Management</a></li></ul><span id="OSC_h3_15"></span><h3>更快地 RocksDB 扩缩容</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">使用 RocksDB 状态后端和增量 checkpoint 的扩缩容时间在第 99 百分位数（99th percentile）上提高了约 30%。我们提升了并行下载的能力，从只并行下载状态句柄（state handle），扩展到并行下载文件。此外，我们关闭了用于扩缩容的临时 RocksDB 实例在批量插入时的写前日志（write-ahead-logging）。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><img alt="3" src="https://oscimg.oschina.net/oscnet/up-5ed594259e7e1a0189a021388cb95a0fd42.png" referrerpolicy="no-referrer"></p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-32326" rel="nofollow" target="_blank">FLINK-32326</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-32345" rel="nofollow" target="_blank">FLINK-32345</a></li></ul><span id="OSC_h2_16"></span><h2>Java 17 支持</h2><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Java 17 于 2021 年发布，是 Java 的最新长期支持（LTS）版本，将于 2029 年终止支持。从 Flink 1.18 版本开始，您现在可以在 Java 17 上运行 Apache Flink。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhub.docker.com%2F_%2Fflink" rel="nofollow" target="_blank">官方 Docker 仓库</a>目前已包含基于 Java 17 的镜像:</p><pre><code>docker pull flink:<span style="color:#986801">1.18</span><span style="color:#986801">.0</span>-java17
</code></pre><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">如果您的集群运行在 Java 17 上，您的用户程序中也可以使用 Java 17 的功能，并将其编译为 Java 17 版本。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdeployment%2Fjava_compatibility%2F" rel="nofollow" target="_blank">文档</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-15736" rel="nofollow" target="_blank">FLINK-15736</a></li></ul><span id="OSC_h2_17"></span><h2>其他改进</h2><span id="OSC_h3_18"></span><h3>生产可用的水印对齐（Watermark Alignment）功能</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">自 Flink 1.16 和 Flink 1.17 版本以来以 Beta 形式支持的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Fdatastream%2Fevent-time%2Fgenerating_watermarks%2F%23watermark-alignment" rel="nofollow" target="_blank">水印对齐</a>已在实际环境中经过大规模的充分测试。在此期间，社区已经收集并解决了发现的错误和性能问题。随着这些问题的解决，我们推荐水印对齐功能供一般使用。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-32548" rel="nofollow" target="_blank">FLINK-32548</a></li></ul><span id="OSC_h3_19"></span><h3>可插拔式故障处理</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Apache Flink 作为许多公司流处理平台的基础，也是许多商业流处理服务的基础。因此，能够轻松集成到内部和供应商平台更广泛生态系统中的能力变得越来越重要。Catalog 修改监听器和可插拔式故障处理程序属于这一类改进。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdeployment%2Fadvanced%2Ffailure_enrichers%2F" rel="nofollow" target="_blank">文档</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-304%253A%2BPluggable%2BFailure%2BEnrichers" rel="nofollow" target="_blank">FLIP-304: Pluggable Failure Enrichers</a></li></ul><span id="OSC_h3_20"></span><h3>SQL 客户端的改进</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">在 1.18 版本中，SQL 客户端进行了一系列的易用性改进：</p><ul><li>客户端更加多彩，可开启 SQL 语法突出显示和切换 7 种不同配色方案。</li><li>更容易编辑和预览大查询。</li><li>可随时关闭和打开行号。</li></ul><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-189%253A%2BSQL%2BClient%2BUsability%2BImprovements" rel="nofollow" target="_blank">FLIP-189: SQL Client Usability Improvements</a></li></ul><span id="OSC_h3_21"></span><h3>Apache Pekko 代替 Akka</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">一年前，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fflink.apache.org%2F2022%2F09%2F08%2Fregarding-akkas-licensing-change%2F" rel="nofollow" target="_blank">Lightbend 宣布</a>将 Akka 未来版本（2.7+）的许可证从 Apache 2.0 更改为 BSL，Apache Flink 使用的 Akka 2.6 版本将在 2023 年 9 月之前接收安全更新和关键错误修复。因此在 Flink 1.18 版本，我们决定从 Akka 切换到<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpekko.apache.org%2F" rel="nofollow" target="_blank">Apache Pekko</a>(Incubating)。Apache Pekko (Incubating) 基于 Akka 项目采用商业源代码许可证之前的 Akka 2.6.x。Pekko 最近发布了 Apache Pekko 1.0.1-incubating，我们即刻在 Flink 1.18 中进行使用。虽然我们的中期计划是完全放弃对 Akka 或 Pekko 的依赖（参见<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-29281" rel="nofollow" target="_blank">FLINK-29281</a>），但切换到 Pekko 提供了一个良好的短期解决方案，并确保了 Apache Pekko 和 Apache Flink 社区能够处理整个软件供应链中的关键错误修复和安全漏洞。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-32468" rel="nofollow" target="_blank">FLINK-32468</a></li></ul><span id="OSC_h3_22"></span><h3>Calcite 升级</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">在 Apache Flink 1.18 中，Apache Calcite 逐渐从 1.29 版本升级到 1.32 版本。版本升级的带来的好处包括错误修复、更智能的优化器和性能改进。在解析器级别，它现在允许使用括号将 join 操作分组成树状结构（SQL-92）。例如 SELECT * FROM a JOIN (b JOIN c ON b.x = c.x) ON a.y = c.y，请参阅<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FCALCITE-35" rel="nofollow" target="_blank">CALCITE-35</a>。此外，升级到 Calcite 1.31+ 解锁了通过表值函数支持会话窗口（Session Windows via Table-Valued Functions，参见<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FCALCITE-4865" rel="nofollow" target="_blank">CALCITE-4865</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-24024" rel="nofollow" target="_blank">FLINK-24024</a>），并弃用旧的分组窗口聚合（Group Window Aggregations）。由于<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FCALCITE-4861" rel="nofollow" target="_blank">CALCITE-4861</a>，Flink 的强制类型转换行为略有改变。一些边界情况现在可能会有不同的行为：例如，从 FLOAT/DOUBLE 9234567891.12 到 INT/BIGINT 的强制类型转换会产生 Java 的溢出行为。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-27998" rel="nofollow" target="_blank">FLINK-27998</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-28744" rel="nofollow" target="_blank">FLINK-28744</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-29319" rel="nofollow" target="_blank">FLINK-29319</a></li></ul><span id="OSC_h2_23"></span><h2>重要 API 弃用</h2><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">为了为明年发布的 Flink 2.0 版本做准备，社区已经决定正式弃用多个接近生命周期结束的 API。</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fflink%2Fblob%2Fmaster%2Fflink-streaming-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fflink%2Fstreaming%2Fapi%2Ffunctions%2Fsource%2FSourceFunction.java" rel="nofollow" target="_blank">SourceFunction</a>现在已经弃用。如果您仍在使用基于 SourceFunction 构建的连接器，请将其迁移到<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fflink%2Fblob%2Fmaster%2Fflink-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fflink%2Fapi%2Fconnector%2Fsource%2FSource.java" rel="nofollow" target="_blank">Source</a>。SinkFunction 目前尚未正式弃用，但它也即将接近生命周期结束，将被 SinkV2 所取代。</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-release-1.17%2Fdocs%2Fdev%2Fdatastream%2Ffault-tolerance%2Fqueryable_state%2F" rel="nofollow" target="_blank">Queryable State</a>现已弃用，将在 Flink 2.0 中移除。</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-release-1.17%2Fdocs%2Fdev%2Fdataset%2Foverview%2F" rel="nofollow" target="_blank">DataSet API</a>现已弃用。建议用户迁移到<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Fdatastream%2Fexecution_mode%2F" rel="nofollow" target="_blank">执行模式</a>设置为 BATCH 的 DataStream API。</li></ul><span id="OSC_h2_24"></span><h2>升级注意事项</h2><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Flink 社区尽力确保无缝升级。然而，某些变更可能需要用户在升级到 1.18 版本时对程序的某些部分进行调整。请参考<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-release-1.18%2Frelease-notes%2Fflink-1.18%2F" rel="nofollow" target="_blank">发行说明</a>，以获取升级过程中需要进行的调整和要检查的问题的综合列表。</p><span id="OSC_h2_25"></span><h2>贡献者列表</h2><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Apache Flink 社区向所有为这个版本的实现做出贡献的贡献者表示感谢：</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Aitozi, Akinfolami Akin-Alamu, Alain Brown, Aleksandr Pilipenko, Alexander Fedulov, Anton Kalashnikov, Archit Goyal, Bangui Dunn, Benchao Li, BoYiZhang, Chesnay Schepler, Chris Nauroth, Colten Pilgreen, Danny Cranmer, David Christle, David Moravek, Dawid Wysakowicz, Deepyaman Datta, Dian Fu, Dian Qi, Dong Lin, Eric Xiao, Etienne Chauchot, Feng Jin, Ferenc Csaky, Fruzsina Nagy, Gabor Somogyi, Gunnar Morling, Gyula Fora, HaiYang Chen, Hang Ruan, Hangxiang Yu, Hanyu Zheng, Hong Liang Teoh, Hongshun Wang, Huston, Jacky Lau, James Hughes, Jane Chan, Jark Wu, Jayadeep Jayaraman, Jia Liu, JiangXin, Joao Boto, Junrui Lee, Juntao Hu, K.I. (Dennis) Jung, Kaiqi Dong, L, Leomax_Sun, Leonard Xu, Licho, Lijie Wang, Liu Jiangang, Lyn Zhang, Maomao Min, Martijn Visser, Marton Balassi, Mason Chen, Matthew de Detrich, Matthias Pohl, Min, Mingliang Liu, Mohsen Rezaei, Mrart, Mulavar, Nicholas Jiang, Nicolas Fraison, Noah, Panagiotis Garefalakis, Patrick Lucas, Paul Lin, Peter Vary, Piotr Nowojski, Qingsheng Ren, Ran Tao, Rich Bowen, Robert Metzger, Roc Marshal, Roman Khachatryan, Ron, Rui Fan, Ryan Skraba, Samrat002, Sergey Nuyanzin, Sergio Morales, Shammon FY, ShammonFY, Shengkai, Shuiqiang Chen, Stefan Richter, Tartarus0zm, Timo Walther, Tzu-Li (Gordon) Tai, Venkata krishnan Sowrirajan, Wang FeiFan, Weihua Hu, Weijie Guo, Wencong Liu, Xiaogang Zhou, Xintong Song, XuShuai, Yanfei Lei, Yu Chen, Yubin Li, Yun Gao, Yun Tang, Yuxin Tan, Zakelly, Zhanghao Chen, ZhengYiWeng, Zhu Zhu, archzi, baiwuchang, cailiuyang, chenyuzhi, darenwkt, dongwoo kim, eason.qin, felixzh, fengli, frankeshi, fredia, godfrey he, haishui, hehuiyuan, huangxingbo, jiangxin, jiaoqingbo, jinfeng, jingge, kevin.cyj, kristoffSC, leixin, leiyanfei, liming.1018, lincoln lee, lincoln.lil, liujiangang, liuyongvs, luoyuxia, maigeiye, mas-chen, novakov-alexey, oleksandr.nitavskyi, pegasas, sammieliu, shammon, shammon FY, shuiqiangchen, slfan1989, sunxia, tison, tsreaper, wangfeifan, wangkang, whjshj, wuqqq, xiangyu0xf, xincheng.ljr, xmzhou, xuyu, xzw, yuanweining, yuchengxin, yunfengzhou-hub, yunhong, yuxia Luo, yuxiqian, zekai-li, zhangmang, zhengyunhong.zyh, zzzzzzzs, 沈嘉琦</p><hr><span id="OSC_h3_26"></span><h3>更多内容</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:center"><img height="910" src="https://oscimg.oschina.net/oscnet/up-43d076aa116b5d091e0d5fd64fd6cd97364.png" width="2584" referrerpolicy="no-referrer"></p><hr><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>活动推荐</strong></p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">阿里云基于 Apache Flink 构建的企业级产品-实时计算 Flink 版现开启活动：<br> 0 元试用<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffree.aliyun.com%2F%3FpipCode%3Dsc" rel="nofollow" target="_blank">实时计算 Flink 版</a>（5000CU*小时，3 个月内）<br> 了解活动详情：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffree.aliyun.com%2F%3FpipCode%3Dsc" rel="nofollow" target="_blank">https://free.aliyun.com/?pipCode=sc</a></p><p style="color:#24292e; margin-left:0px; margin-right:0px; text-align:start"><img height="1280" src="https://oscimg.oschina.net/oscnet/up-f29f46119d7714c79fd0f7baf4854c960f4.png" width="2578" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:29:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/2828172/blog/10136976</guid>
            <link>https://my.oschina.net/u/2828172/blog/10136976</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Fleet 中的 Kotlin 支持：探索 JetBrains 的新 IDE]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><div class="rich_media_content js_underline_content
                       defaultNoSetting
            " id="js_content"><section style="font-size: 15px;line-height: 1.6;letter-spacing: 0px;padding-right: 5px;padding-left: 0px;color: rgb(0, 0, 0);box-sizing: border-box;font-style: normal;font-weight: 400;text-align: justify;margin-bottom: 0px;" data-mpa-powered-by="yiban.io"><section style="text-align: left;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="margin: 30px 0% 10px;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;background-color: rgb(237, 238, 242);align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="display: flex;width: 100%;flex-flow: column;box-sizing: border-box;" powered-by="xiumi.us"><section style="z-index: auto;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: flex;flex-flow: row;justify-content: flex-start;transform: translate3d(18px, 0px, 0px);-webkit-transform: translate3d(18px, 0px, 0px);-moz-transform: translate3d(18px, 0px, 0px);-o-transform: translate3d(18px, 0px, 0px);margin: -16px 0% 0px;box-sizing: border-box;"><section style="display: inline-block;vertical-align: top;width: 15%;flex: 0 0 auto;height: auto;align-self: flex-start;box-sizing: border-box;"><section style="text-align: center;margin: -16px 0px 0px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="1" data-s="300,640" src="https://oscimg.oschina.net/oscnet/d7d41ee0-255e-45b1-b525-8f3fc5d21f72.png" data-w="707" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: top;width: auto;flex: 0 0 auto;align-self: flex-start;min-width: 10%;max-width: 100%;height: auto;box-sizing: border-box;"><section style="transform: translate3d(5px, 0px, 0px);-webkit-transform: translate3d(5px, 0px, 0px);-moz-transform: translate3d(5px, 0px, 0px);-o-transform: translate3d(5px, 0px, 0px);box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;color: rgb(115, 119, 173);padding: 0px 7px;line-height: 1.2;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="box-sizing: border-box;"><strong style="box-sizing: border-box;">记得加关注， Kotlin 之路不迷路！</strong></span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;font-size: 12px;line-height: 1.2;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="color: transparent;background-image: linear-gradient(to right, rgb(36, 113, 228), rgb(250, 40, 88));display: inline-block;-webkit-background-clip: text;box-sizing: border-box;">&nbsp; &nbsp; Kotlinlang.org</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section></section></section></section></section></section></section></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247486951%26idx%3D1%26sn%3Dd1bf11e8ae42331d24bc993bc2a91213%26chksm%3Dc08860b9f7ffe9af87765cb145573b765ef3543c80b72c924f6282e99b96acb04775667ad84f%26scene%3D21%23wechat_redirect" textvalue="JetBrains Fleet" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2"><strong style="box-sizing: border-box;">JetBrains Fleet</strong></a>&nbsp;是一款轻量型代码编辑器和 IDE，使用 IntelliJ 代码处理引擎。该产品目前处于<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247491483%26idx%3D1%26sn%3D7ef92a11da98c89c18feb4d97185a872%26chksm%3Dc08872c5f7fffbd3da3621d9e6311bdca0e9abc325fdc537af83f282e9ee9107b62892a05c29%26scene%3D21%23wechat_redirect" textvalue="公开预览版" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2"><strong style="box-sizing: border-box;">公开预览版</strong></a>阶段，供公众试用。</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">目前，Fleet 允许您使用 Python、TypeScript / JavaScript、Go、Java、PHP、C# 以及 Kotlin 等流行语言进行开发。<strong>Kotlin 支持是最先进的支持之一，因为 Fleet 主要使用 Kotlin 开发而成，JetBrains 团队也使用 Fleet 开发 Fleet。</strong>您可以查看<strong style="box-sizing: border-box;">完整的 Fleet 功能矩阵</strong><sup style="box-sizing: border-box;">1</sup>，了解该产品已经支持哪些语言和技术以及哪些仍在开发。借助即将推出的插件，Fleet 也将尽快支持更多语言和技术。</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">在这篇博文中，我们想详细介绍 Fleet 公开预览版中 Kotlin 支持的当前状态，包括适用于 Kotlin 项目的 IDE 功能的概述。</p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="text-align: center;justify-content: center;display: flex;flex-flow: row;margin: 10px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 48px;align-self: center;flex: 0 0 auto;height: auto;box-sizing: border-box;"><section style="margin-top: 10px;margin-bottom: 10px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;width: 80%;height: auto;box-sizing: border-box;"><img data-s="300,640" src="https://oscimg.oschina.net/oscnet/bbc93270-e7bd-4cc9-9e15-fdbbd532751e.png" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" data-ratio="1" data-w="500" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: auto;align-self: center;flex: 100 100 0%;height: auto;padding: 0px 0px 0px 10px;box-sizing: border-box;"><section style="text-align: left;margin: 10px 0px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgb(42, 8, 69);font-size: 22px;line-height: 1.2;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">为什么选择 Fleet？</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 2px 0px 8px;box-sizing: border-box;" powered-by="xiumi.us"><section style="background-color: rgb(120, 85, 245);height: 1px;box-sizing: border-box;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Fleet 基于我们多年的 IDE 开发经验从头开始构建而成。它结合了轻量型文本编辑器的简单和速度，还有智能开发环境的变革能力。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><strong>Fleet 并不是为了取代或复制 JetBrains 的现有 IDE 而设计。</strong>Fleet 背后的主要理念是为开发者提供智能、多语言工具和工作流的新体验，例如分布式协作开发，以及生成式 AI 编码。JetBrains 在开发 Fleet 的同时也在继续开发现有 IDE。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="text-align: center;justify-content: center;display: flex;flex-flow: row;margin: 10px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 48px;align-self: center;flex: 0 0 auto;height: auto;box-sizing: border-box;"><section style="margin-top: 10px;margin-bottom: 10px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;width: 80%;height: auto;box-sizing: border-box;"><img data-s="300,640" src="https://oscimg.oschina.net/oscnet/bbc93270-e7bd-4cc9-9e15-fdbbd532751e.png" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" data-ratio="1" data-w="500" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: auto;align-self: center;flex: 100 100 0%;height: auto;padding: 0px 0px 0px 10px;box-sizing: border-box;"><section style="text-align: left;margin: 10px 0px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgb(42, 8, 69);font-size: 22px;line-height: 1.2;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;"><span style="letter-spacing: 0px;box-sizing: border-box;">Fleet Smart Mode（智能模式）</span><span style="text-align: unset;letter-spacing: 0px;box-sizing: border-box;">下</span><span style="text-align: unset;letter-spacing: 0px;box-sizing: border-box;">适用于 Kotlin 的功能</span></strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 2px 0px 8px;box-sizing: border-box;" powered-by="xiumi.us"><section style="background-color: rgb(120, 85, 245);height: 1px;box-sizing: border-box;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Fleet 开箱即支持 Kotlin，这就使得该语言的使用不仅高效简单，并且令人愉悦。它为 Kotlin 开发者提供了简化的体验。需要快速深入项目、分析其结构，以及立即进行有针对性的编辑时，您可以使用 Fleet 作为编辑器。但是，如果需要更强大的功能，它可以转换为全功能 IDE。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">如果您想在 Kotlin 中启用代码智能功能，则应打开<strong style="box-sizing: border-box;">&nbsp;Smart Mode（智能模式）</strong><sup style="font-size: 11px;box-sizing: border-box;">2</sup>。这些额外功能有助于避免错误，同时更快、更高效地编写代码。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.4266666666666667" data-s="300,640" src="https://oscimg.oschina.net/oscnet/1023290c-073e-42fe-9a58-15d488de05f9.gif" data-w="600" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">启用 Smart Mode（智能模式）后，即可使用 IntelliJ IDEA 用户熟悉和喜爱的代码编辑功能，包括：</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><ul class="list-paddingleft-1" style="list-style-type: disc;box-sizing: border-box;padding-left: 40px;list-style-position: outside;"><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">代码补全</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">代码操作</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">类型信息和形参信息</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">实时模板</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">代码生成</p></li></ul></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">我们来仔细看看这些功能以及它们将如何简化您的编码方式。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 18px;color: rgb(120, 85, 245);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">代码补全</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">当您输入时，Fleet 会根据各种因素，例如可用的代码智能服务、项目结构、环绕代码和符号可见性，提供代码补全建议。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;">补全建议可以自动显示，也可以通过按&nbsp;<em style="box-sizing: border-box;">Ctrl+空格键</em>手动激活。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.37222222222222223" data-s="300,640" src="https://oscimg.oschina.net/oscnet/0b462a95-7426-4984-a63f-16a07f581f31.png" data-w="1080" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 18px;color: rgb(120, 85, 245);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">代码操作</strong></p></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">借助持续代码质量分析，您可以做出明智的决策并提高编码效率。Fleet 建议的操作根据您所处的特定上下文量身定制。这些建议涵盖从纠正错误到重构文本光标处的代码等一系列操作。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.48333333333333334" data-s="300,640" src="https://oscimg.oschina.net/oscnet/d5158516-45c3-43db-8e8c-a1bc57c46a7e.gif" data-w="600" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">您可以按&nbsp;<em style="box-sizing: border-box;">Opt+Enter</em>&nbsp;(macOS) 或<em style="box-sizing: border-box;">&nbsp;Alt+Enter</em>（Windows 和 Linux）检查文本光标处的可用操作。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">决定待使用的操作后，您可以立即应用，也可以使用快捷键预览结果：macOS 为<em style="box-sizing: border-box;">&nbsp;Cmd+P</em>，Windows 和 Linux 为&nbsp;<em style="box-sizing: border-box;">Ctrl+P</em>。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.48333333333333334" data-s="300,640" src="https://oscimg.oschina.net/oscnet/45604de1-3484-4b1a-9827-d5a13a82a473.gif" data-w="600" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 18px;color: rgb(120, 85, 245);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">类型信息</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">如果您不确定当前正在处理的类型，可以按&nbsp;<em style="box-sizing: border-box;">Cmd+Shift+T</em>&nbsp;(macOS) 或&nbsp;<em style="box-sizing: border-box;">Ctrl+Shift+T</em>（Windows 和 Linux）轻松查找。&nbsp;</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">这将提示 Fleet 显示有关符号或表达式的静态类型的详细信息。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.19189765458422176" data-s="300,640" src="https://oscimg.oschina.net/oscnet/0d0a5755-3ac2-4ce7-b2c3-ea0ab4c220ce.png" data-w="938" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 18px;color: rgb(120, 85, 245);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">形参信息</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">您是否使用具有大量重载的方法，或者需要快速找到必要形参？按<em style="box-sizing: border-box;">&nbsp;Cmd+I</em>&nbsp;(macOS) 或<em style="box-sizing: border-box;">&nbsp;Ctrl+I</em>（Windows 和 Linux）即可浏览可用选项。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.29814814814814816" data-s="300,640" src="https://oscimg.oschina.net/oscnet/5cefda5a-ccd1-4b0f-b0d2-09ed6d57832c.png" data-w="1080" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 18px;color: rgb(120, 85, 245);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">实时模板</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Fleet 提供了一组 Kotlin 实时模板，您可以在代码中插入常见结构，如循环、条件、声明或打印语句。与 IntelliJ IDEA 不同，Fleet 不允许创建新模板。不过，您可以在 Kotlin 代码中使用大量预制模板。Fleet 文档包含<strong style="box-sizing: border-box;"><span style="color: rgb(62, 62, 62);box-sizing: border-box;">实时模板的完整列表</span></strong><sup style="font-size: 11px;box-sizing: border-box;">3</sup>。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.4666666666666667" data-s="300,640" src="https://oscimg.oschina.net/oscnet/8019dfa0-efe9-4f73-9736-a48bdea35fcb.gif" data-w="600" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 18px;color: rgb(120, 85, 245);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">代码生成</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">在您开始输入特定方法或语句时，Fleet 会根据上下文和现有代码建议可能的补全选项。选择一个建议即可立即生成所需代码。您可以利用代码补全重写超类成员，例如 equals()、hashcode() 和其他方法。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.16018518518518518" data-s="300,640" src="https://oscimg.oschina.net/oscnet/4746b9c4-2243-447d-8f04-f5ab67797838.png" data-w="1080" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">使用代码生成，您可以节省时间，并确保代码遵循正确的语法和结构，因为 Fleet 可以帮助您生成必要的代码段。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="text-align: center;justify-content: center;display: flex;flex-flow: row;margin: 10px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 48px;align-self: center;flex: 0 0 auto;height: auto;box-sizing: border-box;"><section style="margin-top: 10px;margin-bottom: 10px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;width: 80%;height: auto;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="1" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bbc93270-e7bd-4cc9-9e15-fdbbd532751e.png" data-w="500" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: auto;align-self: center;flex: 100 100 0%;height: auto;padding: 0px 0px 0px 10px;box-sizing: border-box;"><section style="text-align: left;margin: 10px 0px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgb(42, 8, 69);font-size: 22px;line-height: 1.2;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">试用 Fleet 并分享您的体验</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 2px 0px 8px;box-sizing: border-box;" powered-by="xiumi.us"><section style="background-color: rgb(120, 85, 245);height: 1px;box-sizing: border-box;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">Fleet 是一款多语言代码编辑器和 IDE，支持 Kotlin 等多种语言。您可以将 Fleet 视为一种多用途工具，并期望特定类型的项目后续获得专属支持。</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">如果您有兴趣并且发现了新工具的好用途，我们邀请您亲自上手探索 Fleet 功能！</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">下载并开始使用 Fleet 的最简单方式是使用免费的&nbsp;<strong style="box-sizing: border-box;">JetBrains Toolbox App</strong><sup style="font-size: 11px;box-sizing: border-box;">4</sup>。</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">您也可以观看这个简短的 Fleet 概览视频帮助您入门，以及参阅<strong style="box-sizing: border-box;">文档</strong><sup style="font-size: 11px;box-sizing: border-box;">5</sup>获取进一步指导。</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><section class="channels_iframe_wrp"><mp-common-videosnap class="js_uneditable custom_select_card channels_iframe videosnap_video_iframe" data-pluginname="mpvideosnap" data-url="https://findermp.video.qq.com/251/20304/stodownload?encfilekey=S7s6ianIic0ia4PicKJSfB8EjyjpQibPUAXol1WXnS32s8hOA3RTibrGzhjvMNxgtTBicialbyyKKxIjbZuq53dZyNBldvbjgu2glJgFfqWrbIwNzKRlAJIATvqafA&amp;adaptivelytrans=0&amp;bizid=1023&amp;dotrans=0&amp;hy=SH&amp;idx=1&amp;m=&amp;scene=0&amp;token=x5Y29zUxcibBibbOsfyoFM1Xgzc7qHewxsqpBicZS8u7qJReXaGvg1gvG6bn1QtfmUk6th1DKGulh4" data-headimgurl="http://wx.qlogo.cn/finderhead/0nn3FBrD9a1RrlqKFBkoafxwpIL3ud40TkWcw5qOoYibKzYxvDA2hew/0" data-username="v2_060000231003b20faec8c4e48811c7dccb00ec34b077f60e877e2e3d611e57ac6b6b589aa577@finder" data-nickname="JetBrains" data-desc="#Fleet 是我们全新的分布式多语言编辑器和 #IDE，正面向所有人开放公共预览。它基于我们在后端的 IntelliJ 平台，并采用全新的用户界面和分布式架构从头开始构建。要了解更多详情，请至 Fleet 产品页面：https://www.jetbrains.com.cn/fleet @JetBrains " data-nonceid="2085350396973162235" data-type="video" data-mediatype="    " data-authiconurl="https://dldir1v6.qq.com/weixin/checkresupdate/icons_filled_channels_authentication_enterprise_a2658032368245639e666fb11533a600.png" data-from="new" data-width="1920" data-height="1080" data-id="export/UzFfAgtgekIEAQAAAAAA_38x2YoPwwAAAAstQy6ubaLX4KHWvLEZgBPEt4JIOlEYX5aCzNPgMItlLEUdCyfEPAQ6EF-gJfP5" data-isdisabled="0" data-errortips=""></mp-common-videosnap></section><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">Fleet 仍处于预览版阶段，正在积极开发中。您的反馈和意见将帮助 JetBrains 团队稳定和改进产品。如果遇到问题，请向此<strong style="box-sizing: border-box;">问题跟踪器</strong><sup style="font-size: 11px;box-sizing: border-box;">6</sup>提交报告。您也可以发送电子邮件至&nbsp;<span style="color: rgb(51, 122, 183);box-sizing: border-box;">fleet-support@jetbrains.com</span>&nbsp;与我们联系。</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">敬请期待更多公告！</p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="text-align: left;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="margin: 10px 0% 8px;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding: 0px 0px 0px 8px;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;font-size: 12px;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">本博文英文原作者：</strong></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">Daria Voronina</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(120, 85, 245);padding: 10px;box-shadow: rgb(204, 204, 204) 0.2em 0.2em 0.3em;box-sizing: border-box;"><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">相关链接：</strong></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: left;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">1. 完整的 Fleet 功能矩阵：</span></p><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://docs.google.com/spreadsheets/u/1/d/e/2PACX-1vTWt9RlJPfIJwD5H7Gsqbu9xHTd-K1oj_zCpP6YIQq8xvjARDYqC6OnVIVt5WPi2-B-vWHZw5qMnhvx/pubhtml</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: left;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">2. Smart Mode（智能模式）：&nbsp;</span></p><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://www.jetbrains.com.cn/en-us/help/fleet/smart-mode.html</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">3. 实时模板的完整列表：</span></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://www.jetbrains.com.cn/help/fleet/live-templates-list-kotlin.html</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">4. JetBrains Toolbox App：</span></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://www.jetbrains.com.cn/fleet/download/</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">5. 文档：</span></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://www.jetbrains.com.cn/help/fleet/getting-started.html</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="text-align: left;white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">6. 问题跟踪器:&nbsp;</span></p><p style="text-align: left;white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://youtrack.jetbrains.com/issues/FL</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section></section></section><section style="margin: 10px 0% 0px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;background-position: 97.529% 66.6681%;background-repeat: repeat;background-size: 171.01%;background-attachment: scroll;align-self: flex-start;flex: 0 0 auto;height: auto;background-image: url(&quot;https://oscimg.oschina.net/oscnet/6a0c66f8-0a97-4863-a1b7-e027000fd10f.png&quot;);box-sizing: border-box;"><section style="text-align: justify;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;padding: 26px;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="margin: -9px 0px 7px;box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 16px;color: rgb(248, 248, 248);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">这就是 Kotlin 编程语言</strong></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">简洁、跨平台、且有趣！</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 0px;box-sizing: border-box;" powered-by="xiumi.us"><section class="mp_profile_iframe_wrp" style="box-sizing: border-box;"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-id="Mzg4MzkxMzg3MQ==" data-pluginname="mpprofile" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/y4ibuu6gd7d4NyzPduLLqtqddBasicL77gAgbLQD89CyYm1n7icODFhBr3xMoloOA7yicfjR8Bv0oaRP3CJuRLIO4Q/0?wx_fmt=png" data-nickname="Kotlin 开发者" data-alias="" data-signature="现代、简洁、安全的编程语言，由 JetBrains 打造。面向服务器、Android、Web 和原生平台，提供多种在平台间重用代码的方式以实现高效编程。官网：kotlinlang.org" data-from="0" data-is_biz_ban="0"></mp-common-profile></section></section><section style="text-align: center;margin: 7px 0px 0px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;width: 45%;height: auto;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.4119760479041916" data-s="300,640" src="https://oscimg.oschina.net/oscnet/3fb2fe5a-fbfb-4b28-b55d-9c8dcfa3db81.png" data-w="835" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section></section></section></section></section></section><p style="display: none;margin-bottom: 0px;"><mp-style-type data-value="10000"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - JetBrains（JetBrainsChina）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:27:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5494143/blog/10136803</guid>
            <link>https://my.oschina.net/u/5494143/blog/10136803</link>
            <author>
                <![CDATA[JetBrains 中国]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[B 站：全年「AIGC」相关视频播放量 90 亿]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="color:#000000">哔哩哔哩 (B 站) 日前在其首届「bilibili 超级科学晚」会上，发布了一个「五大科学焦点榜单」—— AIGC、室温超导、脑机接口、黑洞、可控核聚变入选。</span></p><p><span style="color:#000000">并公布数据称，过去一年有 2.43 亿用户在 B 站进行学习，是中国在校大学生人数的 5.5 倍。B 站泛知识内容消费人群中，有 72% 为 00 后。</span></p><p><span style="color:#000000">科学和知识品类占 B 站用户搜索排名第 2 位，相关内容播放量占 B 站 41%，00 后正在成为科学内容消费主力。全年「AIGC」相关视频播放量 90 亿，播放时长达 140 亿分钟。全站 UP 主围绕 ChatGPT、文心一言、盘古气象等多个大模型发布动向，共投稿 330 万支视频，是无可争议的 2023 年热度最高科学技术领域。</span></p><p><span style="color:#000000">截至目前，B 站累计入驻知识类 UP 主 300 余万人。</span></p><p><span style="color:#000000"><img alt="" height="1596" src="https://oscimg.oschina.net/oscnet/up-8324fab9d8b85f93db34425ec9fc991cf4b.jpg" width="350" referrerpolicy="no-referrer"></span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264039</guid>
            <link>https://www.oschina.net/news/264039</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[jQuery 4.0 开发进度：已完成 99%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>根据 jQuery 的 GitHub 里程碑状态，其 4.0.0 版本的开发进度已完成 99%。</p><p><img height="1018" src="https://static.oschina.net/uploads/space/2023/1030/105430_Ecrh_2720166.png" width="2170" referrerpolicy="no-referrer"></p><p><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjquery%2Fjquery%2Fmilestone%2F7" target="_blank">https://github.com/jquery/jquery/milestone/7</a></u></em></p><p>可以看到，目前待处理的 issue 仅剩一个，其内容是升级与 ESLint 相关的软件包，以及修复 linting 错误。已经处理完毕的 issue 共计 163 个，内容包括核心变更、构建变更、与 Ajax 相关的改动等，详情查看&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjquery%2Fjquery%2Fmilestone%2F7%3Fclosed%3D1" target="_blank">https://github.com/jquery/jquery/milestone/7?closed=1</a></u>。</p><p><img src="https://static.oschina.net/uploads/space/2023/1030/111012_2yQh_2720166.png" referrerpolicy="no-referrer"></p><blockquote><p>jQuery 是一个快速、小型且功能丰富的 JavaScript 库。通过易于使用的 API（可在多种浏览器中使用），使 HTML 文档的遍历和操作、事件处理、动画和 Ajax 等操作变得更加简单。结合了多功能性和可扩展性，jQuery 改变了数百万人编写 JavaScript 的方式。</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:10:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264038/jquery-4-0-milestone-99-percent-complete</guid>
            <link>https://www.oschina.net/news/264038/jquery-4-0-milestone-99-percent-complete</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[KubeSphere 社区双周报 | KubeKey 支持 Web UI]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p>KubeSphere 社区双周报主要整理展示新增的贡献者名单和证书、新增的讲师证书以及两周内提交过 commit 的贡献者，并对近期重要的 PR 进行解析，同时还包含了线上/线下活动和布道推广等一系列社区动态。</p><p>本次双周报涵盖时间为：2023.10.13-2023.10.26。</p><h2>贡献者名单</h2><p><img src="https://oscimg.oschina.net/oscnet/up-1a76ec80c43e7bcb348d4c83f3acd397fe2.gif" alt="" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-a1db65d7a7a9dd815a333a3f0f7cac20dde.png" alt="" referrerpolicy="no-referrer"></p><h2>新晋 KubeSphere Contributor</h2><p>两周内共有 7 位新晋 KubeSphere Contributor，包括在社区分享最佳实践经验的小伙伴，感谢各位对 KubeSphere 社区的贡献！</p><table><thead><tr><th>GitHub ID</th><th>证书</th></tr></thead><tbody><tr><td>Hanmo123</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-Hanmo123.png" target="_blank">下载证书</a></td></tr><tr><td>JoeDerby</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-JoeDerby.png" target="_blank">下载证书</a></td></tr><tr><td>SongJXin</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-SongJXin.png" target="_blank">下载证书</a></td></tr><tr><td>gunine</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-gunine.png" target="_blank">下载证书</a></td></tr><tr><td>jongwooo</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-jongwooo.png" target="_blank">下载证书</a></td></tr><tr><td>studyingwang23</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-studyingwang23.png" target="_blank">下载证书</a></td></tr><tr><td>Leirong Luo</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-luoleirong.png" target="_blank">下载证书</a></td></tr></tbody></table><h2>近期更新</h2><h3>KubeSphere</h3><h4>1. 修复 K8s 1.26+ 环境中网管地址未正确展示的问题</h4><p>相关 PR：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubesphere%2Fkubesphere%2Fpull%2F5950" target="_blank">https://github.com/kubesphere/kubesphere/pull/5950</a></p><p>贡献者：hongzhouzi</p><h4>2. 修复应用更新时间不正确的问题</h4><p>相关 PR：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubesphere%2Fkubesphere%2Fpull%2F5948" target="_blank">https://github.com/kubesphere/kubesphere/pull/5948</a></p><p>贡献者：king-119</p><h4>3. 镜像 tag 列表默认按名称排序</h4><p>相关 PR：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubesphere%2Fkubesphere%2Fpull%2F5957" target="_blank">https://github.com/kubesphere/kubesphere/pull/5957</a></p><p>贡献者：zhou1203</p><h3>KubeKey</h3><h4>1. 支持 Web UI</h4><p>相关 PR：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubesphere%2Fkubekey%2Fpull%2F2007" target="_blank">https://github.com/kubesphere/kubekey/pull/2007</a></p><p>贡献者：shijilin0116</p><h2>社区动态</h2><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NTU0MzEyMg%3D%3D%26mid%3D2247526348%26idx%3D1%26sn%3Dbc88cb295e3d769a8bf7f2f94b17dab7%26chksm%3Dcfa57e71f8d2f7670a55352fd93aafb57f990c2ab407e0996c63888aeb085aa765d61507e31c%26token%3D1638355988%26lang%3Dzh_CN%23rd" target="_blank">ARM 版 openEuler 22.03 部署 KubeSphere v3.4.0 不完全指南</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NTU0MzEyMg%3D%3D%26mid%3D2247526431%26idx%3D1%26sn%3D035ab125b4109ab78c685b5eba12ab4d%26chksm%3Dcfa571a2f8d2f8b435a22c90e1fec21e4ebd58270e9e2ddd1d292faf77ce79c06026b2402bf0%26token%3D1638355988%26lang%3Dzh_CN%23rd" target="_blank">11 月 4 日成都站 Meetup 分享内容详情曝光！</a></li></ul><blockquote><p>本文由博客一文多发平台 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenwrite.cn%3Ffrom%3Darticle_bottom" target="_blank">OpenWrite</a> 发布！</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4197945/blog/10138824</guid>
            <link>https://my.oschina.net/u/4197945/blog/10138824</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Vercel 发布免费开源字体 Geist]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>Vercel 公司发布了一款免费开源字体 ——<strong>「<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvercel.com%2Ffont" target="_blank">Geist</a>」</strong>，称专门面向设计师和开发者而设计。</p><blockquote><p><em>开源地址：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvercel%2Fgeist-font" target="_blank">https://github.com/vercel/geist-font</a></u><br> 下载地址：</em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvercel%2Fgeist-font%2Freleases%2Ftag%2F1.0.0" target="_blank">https://github.com/vercel/geist-font/releases/tag/1.0.0</a></u></p></blockquote><p>Geist 字体由 Vercel 与 Basement Studio 联手打造，包含<strong> Geist Sans 和 Geist Mono</strong>，分别对应的是<strong>无衬线字体</strong>和<strong>等宽字体</strong>。</p><p>根据官方的介绍，Geist Sans 作为无衬线字体，其设计理念是易读和简洁。它是一种现代的几何字体，基于经典的瑞士字体设计原则打造，被设计用于标题、徽标、海报和其他大尺寸显示屏。</p><p>Geist Mono 则是 Geist Sans 的完美搭档。作为等宽字体，它被设计用于代码编辑器、图表、终端和其他以文本为基础的代码界面。目前提供的版本优先考虑可读性，并支持无缝集成到编码环境中。</p><h4><strong>Geist 字体预览效果</strong></h4><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e79e19a1fd7bb59d7c6f9780a4b6b40cefd.png" referrerpolicy="no-referrer"></p><p>此外，Geist 受到以下字体的影响和启发：Inter、Univers、SF Mono、SF Pro、Suisse International、ABC Diatype Mono 和 ABC Diatype。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 02:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264031/vercel-geist-font</guid>
            <link>https://www.oschina.net/news/264031/vercel-geist-font</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Weaviate —— 开源向量数据库]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="project_detail_above_text_link_1" data-tracepid="project_detail_above_text_link"><a style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代 <img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p><span><span><span>Weaviate 是一个开源向量数据库，</span></span></span><span style="background-color:#ffffff; color:#1f2328">具有强大、可扩展、云原生且快速的特点。</span><span><span><span>可存储对象和向量，允许将向量搜索与结构化过滤与云原生数据库的容错性和可扩展性相结合，所有这些都可以通过 GraphQL、REST 和各种语言客户端进行访问。</span></span></span></p><p><span style="color:#000000">允许你存储来自你最喜欢的 ML 模型的数据对象和向量嵌入，并无缝扩展到数十亿个数据对象。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><strong>简而言之</strong>：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>Weaviate 是一个开源<a href="https://weaviate.io/blog/what-is-a-vector-database" target="_blank">向量数据库</a>。</li><li><a href="https://weaviate.io/developers/weaviate/concepts/vector-index">Weaviate 允许你通过使用向量索引</a>来根据数据对象的语义属性来存储和检索数据对象。</li><li>Weaviate 可以独立使用<span style="background-color:#ffffff; color:#000000">&nbsp;(aka<span>&nbsp;</span></span>bring your vectors<span style="background-color:#ffffff; color:#000000">)<span>&nbsp;</span></span>，也可以与各种可以为您进行向量化并扩展核心功能的<a href="https://weaviate.io/developers/weaviate/modules">模块一起使用。</a></li><li>Weaviate 具有<a href="https://weaviate.io/developers/weaviate/api/graphql">GraphQL-API</a>，可轻松访问你的数据。</li><li>Weaviate 速度很快（查看<a href="https://weaviate.io/developers/weaviate/benchmarks">开源基准测试</a>）。</li></ul><p>Weaviate 是一个低延迟向量数据库，对不同媒体类型（文本、图像等）提供开箱即用的支持。它提供语义搜索、问答提取、分类、可定制模型 (PyTorch/TensorFlow/Keras) 等。Weaviate 以 Go 语言从头开始构建，同时存储对象和向量，从而将向量搜索与结构化过滤和云原生数据库的容错性结合起来。所有这些都可以通过 GraphQL、REST 和各种客户端编程语言进行访问。</p><p style="margin-left:0px; margin-right:0px; text-align:start"><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Weaviate 可以轻松使用最先进的 AI 模型，同时提供专用向量数据库的可扩展性、易用性、安全性和成本效益。最为显着地：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>快速查询</strong><br>
Weaviate 通常在不到 100 毫秒的时间内对数百万个对象执行最近邻 (NN) 搜索。<a href="https://weaviate.io/developers/weaviate/benchmarks">可以在我们的基准</a>页面上找到更多信息。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>使用 Wea​​viate 模块摄取任何媒体类型</strong><br>
使用最先进的 AI 模型推理（例如 Transformer）在搜索和查询时访问数据（文本、图像等），让 Weaviate 管理数据矢量化过程为你 - 或提供你自己的向量。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>组合向量和标量搜索</strong><br>
Weaviate 可以进行高效的组合向量和标量搜索。例如，「过去 7 天内发表的与 COVID-19 大流行相关的文章」。Weaviate 存储对象和向量，并确保两者的检索始终高效。不需要第三方对象存储。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>实时且持久的</strong><br>
Weaviate 让你可以搜索数据，即使当前正在导入或更新数据。此外，每次写入都会写入预写日志 (WAL)，以便立即持久写入 - 即使发生崩溃也是如此。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>水平可扩展性</strong></span></span></span></span><br><span style="background-color:#ffffff; color:#000000">Scale</span>&nbsp;<span><span><span><span>Weaviate 满足你的确切需求，例如最大摄取量、最大可能的数据集大小、每秒最大查询数等。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>高可用性</strong><br>
已列入<a href="https://weaviate.io/developers/weaviate/roadmap">路线图</a>，并计划于今年晚些时候发布。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>成本效益</strong><br>
非常大的数据集不需要完全保存在 Weaviate 的内存中。同时，可以利用可用内存来提高查询速度。这样可以有意识地进行速度/成本权衡，以适应每个用例。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>对象之间的类似图形的连接</strong><br>
以类似图形的方式在对象之间建立任意连接，以类似于数据点之间的真实连接。使用 GraphQL 遍历这些连接。</span></span></span></span></p></li></ul></div>
                                                                ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 02:32:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/weaviate</guid>
            <link>https://www.oschina.net/p/weaviate</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 基于 LLM 大语言模型的知识库问答系统 FastGPT]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-fastgpt" class="anchor" href="https://gitee.com/xindian/FastGPT#fastgpt"></a>FastGPT</h1><p>FastGPT 是一个基于 LLM 大语言模型的知识库问答系统，提供开箱即用的数据处理、模型调用等能力。同时可以通过 Flow 可视化进行工作流编排，从而实现复杂的问答场景！</p><h2><a id="user-content--在线体验" class="anchor" href="https://gitee.com/xindian/FastGPT#-%E5%9C%A8%E7%BA%BF%E4%BD%93%E9%AA%8C"></a>🛸 在线体验</h2><p>🎉 <a href="https://gitee.com/link?target=https%3A%2F%2Ffastgpt.run%2F">fastgpt.run</a>（服务器在新加坡，部分地区可能无法直连）</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="https://gitee.com/xindian/FastGPT/raw/dev4/.github/imgs/intro1.png" alt="Demo" referrerpolicy="no-referrer"></td><td><img src="https://gitee.com/xindian/FastGPT/raw/dev4/.github/imgs/intro2.png" alt="Demo" referrerpolicy="no-referrer"></td></tr><tr><td><img src="https://gitee.com/xindian/FastGPT/raw/dev4/.github/imgs/intro3.png" alt="Demo" referrerpolicy="no-referrer"></td><td><img src="https://gitee.com/xindian/FastGPT/raw/dev4/.github/imgs/intro4.png" alt="Demo" referrerpolicy="no-referrer"></td></tr></tbody></table><h2><a id="user-content--开发" class="anchor" href="https://gitee.com/xindian/FastGPT#-%E5%BC%80%E5%8F%91"></a>👨‍💻 开发</h2><p>项目技术栈: NextJs + TS + ChakraUI + Mongo + Postgres（Vector 插件）<br><a href="https://gitee.com/xindian/FastGPT/blob/dev4/docSite/i18n/zh-Hans/docusaurus-plugin-content-docs/current/quick-start/dev.md">本地开发 Quick Start</a></p><h2><a id="user-content--部署" class="anchor" href="https://gitee.com/xindian/FastGPT#-%E9%83%A8%E7%BD%B2"></a>🚀 部署</h2><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fsealos.io%2Fdocs%2Fexamples%2Fai-applications%2Finstall-fastgpt-on-desktop">官方推荐 Sealos 部署</a> 无需服务器，代理和域名，高可用。</li><li><a href="https://gitee.com/xindian/FastGPT/blob/dev4/docSite/i18n/zh-Hans/docusaurus-plugin-content-docs/current/deploy/docker.md">docker-compose 部署</a> 单机版。</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1tV4y1y7Mj%2F%3Fvd_source%3D92041a1a395f852f9d89158eaa3f61b4">由社区贡献的宝塔部署和本地运行教程</a> 单机版。</li></ul><h2><a id="user-content--roadmap" class="anchor" href="https://gitee.com/xindian/FastGPT#-roadmap"></a><img class="emoji" alt=":point_right:" style="vertical-align: middle" src="https://cn-assets.gitee.com/assets/emoji/point_right-8d392cf32998e3bca12bb7b4ee10dae0.png" width="14" height="14" referrerpolicy="no-referrer"> RoadMap</h2><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fkjqvjse66l.feishu.cn%2Fdocx%2FRVUxdqE2WolDYyxEKATcM0XXnte">FastGpt RoadMap</a></li></ul><h2><a id="user-content-️-交流群" class="anchor" href="https://gitee.com/xindian/FastGPT#%EF%B8%8F-%E4%BA%A4%E6%B5%81%E7%BE%A4"></a>🏘️ 交流群</h2><p>添加 wx 进入：<br><img src="https://otnvvf-imgs.oss.laf.run/wx300.jpg" alt="Demo" referrerpolicy="no-referrer"></p><h2><a id="user-content-powered-by" class="anchor" href="https://gitee.com/xindian/FastGPT#powered-by"></a>Powered by</h2><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmsgbyte%2Ftushan">TuShan: 5 分钟搭建后台管理系统</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Flabring%2Flaf">Laf: 3 分钟快速接入三方应用</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Flabring%2Fsealos">Sealos: 快速部署集群应用</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fsongquanpeng%2Fone-api">One API: 令牌管理 &amp; 二次分发，支持 Azure</a></li></ul><h2><a id="user-content--其他" class="anchor" href="https://gitee.com/xindian/FastGPT#-%E5%85%B6%E4%BB%96"></a>👀 其他</h2><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fkjqvjse66l.feishu.cn%2Fdocx%2FHtrgdT0pkonP4kxGx8qcu6XDnGh">FastGpt 常见问题</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1jo4y147fT%2F">docker 部署教程视频</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1xh4y1t7fy%2F">公众号接入视频教程</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1Wo4y1p7i1%2F">FastGpt 知识库演示</a></li></ul><h2><a id="user-content-第三方生态" class="anchor" href="https://gitee.com/xindian/FastGPT#%E7%AC%AC%E4%B8%89%E6%96%B9%E7%94%9F%E6%80%81"></a>第三方生态</h2><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fluolin-ai%2FFastGPT-Enterprise-WeChatbot">luolinAI: 企微机器人，开箱即用</a></li></ul><h2><a id="user-content--star-history" class="anchor" href="https://gitee.com/xindian/FastGPT#-star-history"></a>🌟 Star History</h2><p><a href="https://gitee.com/link?target=https%3A%2F%2Fstar-history.com%2F%23labring%2FFastGPT%26Date"><img src="https://api.star-history.com/svg?repos=labring/FastGPT&amp;type=Date" alt="Star History Chart" referrerpolicy="no-referrer"></a></p>]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 02:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/xindian/FastGPT</guid>
            <link>https://gitee.com/xindian/FastGPT</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 智能问答技术在百度搜索中的应用]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p><img src="https://oscimg.oschina.net/oscnet/up-7e074847d19344a1cd39fd61d566f8ba83b.png" alt="" referrerpolicy="no-referrer"></p><p>作者 | Xiaodong</p><blockquote><p>导读</p><p>本文主要介绍了智能问答技术在百度搜索中的应用。包括机器问答的发展历程、生成式问答、百度搜索智能问答应用。欢迎大家加入百度搜索团队，共同探索智能问答技术的发展方向，文末有简历投递方式。</p></blockquote><blockquote><p><em>全文 6474 字，预计阅读时间 17 分钟。</em></p></blockquote><h1><strong>01 什么是机器问答</strong></h1><p>机器问答，就是让计算机软件系统自动回答人类提出的描述性问题。例如问：「王小丫的主持的节目叫什么」，我们可以在百度搜索框里输入任意用自然语言描述的问题，并在搜索的首位结果中可以直接得相关答案，如下图所示：</p><p><img src="https://oscimg.oschina.net/oscnet/up-963d02166a9d2429174f6b8653991ec8f94.png" alt="图片" referrerpolicy="no-referrer"></p><p>区别于传统搜索引擎根据多个关键词反馈检索的网页链接，机器问答根据自然语言描述的问题直接获取答案，可以极大地提高大家获取信息的效率。机器问答在生活中无处不在，经统计，有约 40% 的搜索需求、约 30% 的对话需求都跟机器问答相关。</p><p>那么，百度搜索的机器问答应用现状如何？目前首条结果可以直接满足大部分的问答需求，并且，在百度搜索中，不限定用户问题领域，是一个开放式的问答系统，可以询问任何信息。</p><h2><strong>1.1 机器问答的发展历程</strong></h2><p>机器问答的发展历程如下，与机器学习发展相吻合。</p><p><img src="https://oscimg.oschina.net/oscnet/up-9a139b0eb31cf87b33168f4ad87086aa2cd.png" alt="图片" referrerpolicy="no-referrer"></p><p><strong>从模型方法的发展上看：</strong></p><p>2013 年以前，大家主要做一些特征工程相关工作，即给定一个问题和一些候选答案，设计多种字面匹配特征，并计算问题与答案之间词的匹配度，例如 BM25 等算法。</p><p>2014~2015 年，随着深度学习的发展，大家会使用神经网络来计算问题和答案间表示的语义距离，例如 CNN、RNN 等。</p><p>2016~2017 年，大家会使用 Attention 网络结构设计各类模型结构，进一步刻画问题和答案间的深层语义匹配关系。</p><p>2018~2021 年，研究主要集中在训练模型上，会使用一些更大、效果更好的预训练模型来完成复杂的问答匹配任务。</p><p>自 2022 年开始，大家更多关注生成模型的应用。</p><p><strong>从数据集的发展上看：</strong></p><p>2013 年，MCTest 出现，以选择题和完形填空形式为主。</p><p>2016 年，SQuAD 诞生，这是第一个大型阅读理解数据信息，会根据用户问题从提供的一篇文章中进行答案抽取。</p><p>2017 年，百度发布了 DuReader 数据集，这是首个中文的阅读理解的数据集。</p><p>2018 年，HotputQA 等发布，更加深入研究了多跳推理、常识推理等复杂的问答场景。</p><h2><strong>1.2 机器问答建模</strong></h2><p>目前的主流范式：Retriever + Reader</p><p>Retriever = 基于 query 查询候选。即给定一个 query，获得该 query 的相关候选，可能是网页、视频、表格、知识图谱等。</p><p>Reader = 从给定候选中获取答案信息。即在给定候选的基础上，结合 query 进一步进行答案抽取。</p><p>百度搜索就是一个非常强的一个 Retriever ，它可以提供相关候选查询，所以我们的研究工作更多集中在 Reader 上，即基于搜索结果如何更好地完成答案抽取。</p><p><img src="https://oscimg.oschina.net/oscnet/up-d2ba5b11127a99934c18d5825cba6ab00b1.png" alt="图片" referrerpolicy="no-referrer"></p><p>早期的 Reader，主要基于传统的特征工程方法，是一个很复杂的系统化 pipeline 流程：先分析 query 获得期望的答案类型、实体信息、问题类型等，并根据这些信息从候选库里检索若干候选，并设计复杂的匹配特征来计算 query 和候选的相关性打分，并设计排序函数进行排序，得到排序最高的答案，过程如下图。</p><p><img src="https://oscimg.oschina.net/oscnet/up-74c5ecc4978e073d0b1799f4735a3b37278.png" alt="图片" referrerpolicy="no-referrer"></p><p>这个流程是管道串联的，每一步都存在误差的积累，整个训练流程也不可整体迭代，维护成本较高。后来，大家希望找到一种更加端到端的方法来解决以上问题，机器阅读理解（Machine Reading Comprehension，MRC）被提出出来。</p><p>MRC 的任务的定义是：输入 Question+Document，直接用一个模型替代复杂流程，输出 Answer。早期的 MRC 工作会设计一些比较复杂的网络结构，来对问题和答案之间的关系进行建模。一个比较经典的方法是 BiDAF，它的输入层是对整个 document 和 query 分别映射到 enbedding 表示上，各自通过 LSTM 等网络来学习问题和文档上下文的表示，之后通过 Attention 交互层，采用双向注意力对 query 和 document 的关系进行建模，在此基础上再通过 LSTM 网络获取更丰富的上下文表示，最终输出层预测每个位置作为答案开始和终止的概率，概率最高的片段被抽取作为答案。</p><p><img src="https://oscimg.oschina.net/oscnet/up-c79c34662eb1f0af4c7b094a66cf7656acb.png" alt="图片" referrerpolicy="no-referrer"></p><p>早期的模型结构设计呈现百花齐放的状态，以期更好解决问题和答案的建模。</p><p>后来，预训练模型逐渐发展起来，大家意识到，复杂的模型结构设计并不太必要，transformer 就是目前为止最好的模型结构，这样可以释放更多研究精力到预训练工作中，更多关注预训练的任务设计、 loss 函数、预训练的数据等。</p><p>在这种情况下，产生了多种预训练模型，比如说最早的 BERT 和百度的<a href="https://www.oschina.net/action/visit/ad?id=1191" title="ERNIE">ERNIE</a>等，这些预训练模型会使 MRC 更加简单，大家会把 query 和 document 整体作为一个序列进行输入，query 和 document 之间可以用一些特殊符号进行分割。经过预训练模型的语义表示建模，最后依旧预测答案开始和结束的位置并进行抽取。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b91feb0c3746117307b1b707dbc9b2341c0.png" alt="图片" referrerpolicy="no-referrer"></p><h1><strong>02 生成式问答</strong></h1><p>近期生成式技术的发展非常火热，也有非常多的工作发表。</p><p>早期一个比较有代表性的生成式 Reader，是 2017 年的 S-NET，它是针对 MS-MARCO 数据集专门设计的，该数据集的特点是答案来自多篇文章并且与原文中词汇不一定相同。</p><p>针对这样的任务，很自然的想法是用生成的方式来解决这个问题。它设计了一套两阶段的流程，第一阶段是答案抽取模型，跟我们上面介绍的模型非常一致，并额外引入了 passage 排序任务对候选文章进行相关性排序。第二阶段是生成模型，输入得到抽取结果，生成答案的总结，如下图所示。</p><p><img src="https://oscimg.oschina.net/oscnet/up-eac42697ab12c4dd61e9625a1bbf3ab4bcf.png" alt="图片" referrerpolicy="no-referrer"></p><p>可以看出，早期的这些工作跟我们现在所使用的生成式问答流程非常相似，我们还会加一个检索模块，就是我们刚才最早提到的 Retriever，然后就是候选抽取、排序、生成。但是，这个工作还是依赖于额外信息来做参考总结。大家会想，是不是可以有一个生成模型，直接生成答案，而不依赖于我们输入额外的信息知识？</p><p>2019 年的 T5 模型首先解决了这个问题，当时它是采用了一种「预训练+迁移学习」的思路，将不同 NLP 任务统一到生成范式下，来统一完成问答、机器翻译、情感分析、对话等一系列任务，且通过百亿参数量的大模型（在当时算是比较大的规模）中存储的知识直接回答问题。它也验证了不同生成模型的结构，包括 Encoder-Decoder 方式的、Decoder-only 的和混合式的。</p><p>但是，T5 这类模型虽然可以完成一些简单问答，但还不足以达到可直接使用的商用状态，它的参数量及训练方式还存在改进空间，对于一些通用问题也不能直接取得非常好的效果。直到 ChatGPT 的出现，它会采用更大的参数规模（千亿级），并有更强的人类回复对齐能力，去理解用户指令，从而完成更加复杂的问答。可以说，ChatGPT 是已达商用级别的对话和问答产品。</p><h1><strong>03 百度搜索的智能问答应用</strong></h1><p>百度搜索的问答场景是丰富多样的。答案抽取方式也有多种，比如说我们可以从百科或者网页通过信息抽取的方式得到一些知识图谱，在知识图谱上来进行答案提取；更通用的方式是从网页文本中，通过阅读理解直接抽取答案；还可以通过对一些半结构化的数据，比如表格，来进一步的提取信息，并组织成更结构化的方式展现。不止是文本，也包括对视频内容的理解和抽取。</p><p><img src="https://oscimg.oschina.net/oscnet/up-4f1d8cf290673670a6b13f27ff8f32c76f0.png" alt="图片" referrerpolicy="no-referrer"></p><p>面临着这样一个丰富多样的问答场景，我们会有哪些挑战呢？</p><p><strong>挑战 1</strong>：机器问答面临复杂语义理解、推理、上下文建模难点？</p><p><strong>挑战 2</strong>：面对搜索的高流量和机器问答对复杂模型的需求，如何实现快速响应？</p><p><strong>挑战 3</strong>：开放领域的搜索场景下网页数据非常复杂，答案质量参差不齐（错误、片面），如何提供正确且高质量的答案？</p><p>、</p><h2><strong>3.1 解决复杂语义理解、推理、上下文建模难点</strong></h2><p>比如最开始的这个例子，如下图所示，答案中提到一个「她」，就需要做指代消解、对上下文的理解，并且上下文篇幅可能很长，通过深层次的理解才能知道所需的是一个答题节目，而不是其他节目。这个问题的解决依赖一些很复杂的模型。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b0523ebaa060da3070ea6a4d3811d62d1bd.png" alt="图片" referrerpolicy="no-referrer"></p><p>我们采用的解决方案是「大模型+预训练」。</p><p>在预训练中，我们会使用非常丰富的数据，包括几个阶段：</p><ul><li><p>首先，用 T 级别通用文本进行 Pretrain 学习基础语言模型；</p></li><li><p>并且，使用百 G 级业务日志进行 Post-pretrain 实现领域和目标迁移；</p></li><li><p>此外，进行细致的数据挖掘，通过 G 级人工标注数据进行 Finetune 拟合业务效果；</p></li><li><p>最后，通过远程监督数据增强、标注数据质量识别、薄弱数据自动挖掘和定向标注、用户行为指引，实现数据和模型的闭环反馈。</p></li></ul><p>而在大模型方面：</p><ul><li><p>使用百亿级参数量模型，提升知识记忆和语言理解能力</p></li><li><p>通过长序列建模，充分理解上下文</p></li></ul><p>例如，我们正在使用的一个模型，我们称之为 DocMRC 模型，它模拟人做阅读理解答题，阅读整个文章，逻辑如下图所示。</p><p><img src="https://oscimg.oschina.net/oscnet/up-efaa14b51d1240a2fed3ef2c93b114b90d9.png" alt="图片" referrerpolicy="no-referrer"></p><p>输入层支持长序列建模，将整个 doc segment sents 进行切分；特别的是，我们在每句话前插入 token 表示，CLS 用来汇聚每个句子的表示，整体输入浅层词级模型结构来学习局部表示；基于这个表示经过层次化结构学习深层上下文关系；最后输出 CLS 特殊 token 表示标注，输出答案。</p><p>输出层会有两种输出：一种是针对问题输出偏摘要等多句话答案介绍，会使用句子层的输出，然后做序列标注的输出；另一种是强调答案中的关键内容，可能是几个实体，会将 token 表示做序列标注预测。</p><h2><strong>3.2 提升整体模型的速度，实现快速响应</strong></h2><p>搜索每天的用户流量非常大，前面也提到，我们需要用到较大或较复杂模型，整个模型的耗时以及资源消耗也是非常大的。那么，有没有其他方式来提升整体模型的速度，实现快速响应及资源平衡？</p><p>刚才介绍的层次化的建模，对模型结构的优化，是一种解决方案。</p><p>另外有一种通用的方式：知识蒸馏，知识蒸馏是将大模型的知识提炼给单个小模型，在效果接近的情况下提升推理速度。这里我们采用了一种「多 teacher 多阶段蒸馏」模式。</p><p>针对问答的业务场景，我们会训练多个不同的 teacher，通过不同 teacher 的集成来提升学习目标的上限。然后对于多个 teacher 蒸馏，一种基线方案是将每个 teacher 的打分或 loss 加权直接做平均，让 student 拟合，但是我们认为这种方式可能并不能确保达到非常极致的效果。我们期望根据不同样本动态做出选择（因为不同 teacher 的侧重有差异），设计了一种多阶段蒸馏的模式，并在其中根据数据动态选择 teacher，如下图所示。</p><p><strong>第一阶段</strong>，Teacher 模型训练，训练多 teacher 提升学习上限；</p><p><strong>第二阶段</strong>，无监督蒸馏，无标数据很难判断 teacher 的好坏，所以采用 teacher 间投票的方式，依据梯度方向动态选择 teacher，剔除可能的噪声 teacher；</p><p><strong>第三阶段</strong>，有监督蒸馏，依据标注样本对 teacher 动态赋权。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1d06f3320489bb36099a988b3c28560be5c.png" alt="图片" referrerpolicy="no-referrer"></p><p>通过这样一种多阶段多 teacher 蒸馏的方式，我们最终得到一个效果非常好的 student 模型，甚至超过单个大模型效果。</p><h2><strong>3.3 如何提供正确且高质量的答案</strong></h2><p>搜索场景的问答数据非常复杂，答案质量也参差不齐，很多网页中可能存在一些错误信息或片面介绍，如何提供正确且高质量的答案是我们面临的第三个挑战。</p><p>如下图所示，是搜索中场景的复杂答案的例子。左侧是冗长答案，用户无法快速抓住重点，这种情况下需要一种方式进行总结，用户才能快速理解的答案关键信息，提升满足效率。抽取式答案提取方式已经无法满足，我们需要用生成技术对答案进行深层次压缩总结。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3b0cb10d8ed43151c7cfb9dba4b1f9792a7.png" alt="图片" referrerpolicy="no-referrer"></p><p>另外，对於单篇文章中提取的答案可能不够全面，我们需要从多篇网页中做答案总结，也需要生成模型，如下图所示。我们从多篇文章中总结答案，并在答案中标注来源，用户可以清晰看到答案出处。</p><p><img src="https://oscimg.oschina.net/oscnet/up-743951b5f984c8a0ac47dc29838f43e96c9.png" alt="图片" referrerpolicy="no-referrer"></p><p>综上，如果要生成全面、高效、正确的答案，就需要有一个更好的生成模型。目前的大语言模型非常多，但怎样的大语言模型才能完成搜索场景的问答任务呢？</p><h1><strong>04 检索增强生成</strong></h1><p>目前大语言模型直接做问答还有几个问题：</p><p><strong>第一</strong>，大预言模型难以记住所有知识，对于一些偏长尾知识可能有错误或者不知道的情况；</p><p><strong>第二</strong>，大语言模型的知识容易过时、更新困难，对于新知识无法及时感知；</p><p><strong>第三</strong>，大语言模型的输出难以验证，目前用户的信赖感较差，我们无法完全信赖生成模型直接生成的答案。</p><p><strong>所以在这种情况下，大家希望能有一些方式来进行一些辅助的答案验证。</strong></p><h2><strong>4.1 检索增强生成流程</strong></h2><p>针对搜索问答场景，我们设计了检索增强生成方案，已在百度搜索落地。检索增强生成是基于搜索引擎补充相关信息，可有效缓解大模型幻觉，来提升答案的正确性、时效性以及可信度。整体流程分为几个阶段：</p><p>1、文档检索阶段，会检索得到多种参考来源；</p><p>2、答案抽取阶段，会把文章抽取关键信息，减轻生成模型负担；</p><p>3、prompt 组成阶段，会根据获取的参考来源来回答问题，并提供具体要求，比如说在答案内容中序号标注来源；</p><p>4、答案生成阶段，将 prompt 输入生成大模型中，最终得到搜索结果。</p><p><img src="https://oscimg.oschina.net/oscnet/up-4433c15aa52ec41c714f2962fbc7f36d8bf.png" alt="图片" referrerpolicy="no-referrer"></p><p>如上图所示，可以看到右侧答案是总结了多篇文章的一个结果，并且也会在其中标注上参考来源，这就是我们期望给用户提供的答案。</p><h2><strong>4.2 生成大模型训练流程</strong></h2><p>我们生成大模型的训练流程分为四个阶段，如下图所示，前两个阶段跟目前主流的生成大模型训练比较接近，后两个阶段我们做了检索增强生成问答场景下的特殊适配。</p><p><img src="https://oscimg.oschina.net/oscnet/up-2d170b5a9d03db57ccca02b3f9648bfe4a9.png" alt="图片" referrerpolicy="no-referrer"></p><p><strong>第一阶段</strong>，通用预训练，我们会有一些通用的网页语料以及垂类语料，比如书籍、表格、对话等，来获得通用的预训练基础模型；</p><p><strong>第二阶段</strong>，进行指令微调，我会提供一些通用的指令，使得模型拥有理解指令的能力；</p><p><strong>第三阶段</strong>，标注业务指令，并用其做具体的微调，使其能理解搜索场景下的多结果组织的问答场景；</p><p><strong>第四阶段</strong>，基于用户行为反馈做细致微调，以及通过强化学习等方式，提高生成答案的质量。</p><h2><strong>4.3 通过指令拆解，学习复杂指令</strong></h2><p>搜索的业务场景指令非常复杂，我们会提出非常具体的要求，并提供参考来源。那么如何让生成模型来理解这种复杂的指令？一种解决方案是标注很多这类复杂指令，并输入到生成模型中，但这种方式并不一定是最佳的。如果模型学习这类指令偏多了，反而无法达到更好泛化效果，造成模型效果下降。有没有其他的方式？</p><p><strong>这里，我们借鉴推理链（CoT）的思想，提出通过指令拆解的方式，学习检索生成场景下复杂指令。</strong></p><p>上述复杂指令通常可以通过三步简单步骤完成：</p><p>第一步，选择能用来回答问题的搜索结果；</p><p>第二步，根据选择的搜索结果进行答案的组织和生成；</p><p>第三步，用编号的形式，加上参考来源。</p><p>可以看出，对于很复杂的指令，我们可以通过多步拆解变成多个简单指令，我们会让模型先去学习并理解简单指令，之后可能不用太多复杂指令的数据，就能使模型在复杂指令上的表现达到一个非常好的水平。</p><h2><strong>4.4 推理加速及降低资源消耗</strong></h2><p>对于一些判别式模型，可以用蒸馏或一些其他的技术来做。但对于生成模型来说，模型尺寸小了对效果的影响较大，蒸馏并不特别适用，需要有一些其他的加速手段。近期业内有很多相关的工作研究，例如 Inference with Reference，就是针对检索增强生成的业务场景，通过检测固定 prefix，从参考中复制固定长度文本作为候选序列，验证如与模型输出一致则实现并行解码多步，如下图所示。</p><p><img src="https://oscimg.oschina.net/oscnet/up-78ee3ddc4ee98c5d2055bc1c54dc1d0b8d1.png" alt="图片" referrerpolicy="no-referrer"></p><p>另外也有一些更加通用的生成加速的手段，例如可以用小模型快速生成多步，把小模型的预测结果直接输入大模型，大模型验证是否解码一致，类似前一个工作也可以实现加速，但要求是尽量使我们的小模型和大模型效果接近，预测准确的概率会更大，加速比就会更大。</p><p>最后我给大家留一个问题，大家可以想一想： <strong>「下一代的搜索引擎会是什么样子？」</strong> 很期待你的回答，也欢迎与我们一起探讨。</p><p><a href="https://www.oschina.net/action/GoToLink?url=mailto%3A%E4%BA%A4%E6%B5%81%26%E7%AE%80%E5%8E%86%E6%8A%95%E9%80%92%E9%82%AE%E7%AE%B1%EF%BC%9Asti01%40baidu.com" target="_blank">交流&amp;简历投递邮箱：sti01@baidu.com</a></p><p>——END——</p><p><strong>推荐阅读</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247572187%26idx%3D1%26sn%3De62d1cf576fcc45232b67028321a9dd0%26chksm%3Dc03feaa7f74863b11423311a7158d1ae375b5fded421b83756d0af9cbb4db6d5dfc034ac1be4%26scene%3D21%23wechat_redirect" target="_blank">通过 Python 脚本支持 OC 代码重构实践（一）：模块调用关系分析</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247571891%26idx%3D1%26sn%3De5ab3e3ad26b8e92b5387e5905d17805%26chksm%3Dc03fe9cff74860d911187fc6e1b70da54e5c9b05453ef602576d2efc03d95b6fda158003ada7%26scene%3D21%23wechat_redirect" target="_blank">CVPR2023 优秀论文 | AIGC 伪造图像鉴别算法泛化性缺失问题分析</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247571772%26idx%3D1%26sn%3D3f9c022e989d2e8e2f7af2e6c7f7db76%26chksm%3Dc03fe940f7486056ca76cb5e0d6e1175d25ec77186ed8f7f26887ae5cb8d24c750acfafdaadb%26scene%3D21%23wechat_redirect" target="_blank">一文搞定专属码的设计与开发</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247571660%26idx%3D1%26sn%3D867bb1f6c7e9cb68da34a95923a06a5e%26chksm%3Dc03fe8b0f74861a6972c085bcabc20b71647b02a4b312980722ad37ac843f519432393f6b657%26scene%3D21%23wechat_redirect" target="_blank">AI 原生应用速通指南</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247571596%26idx%3D1%26sn%3Dcc698b9be371c3d0316236551cf73a9d%26chksm%3Dc03fe8f0f74861e6e27850cbee6bad70d2e88f1e9fcaf474db0736232108a8a743d0223fdf40%26scene%3D21%23wechat_redirect" target="_blank">代码理解技术应用实践介绍</a></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/10123217</guid>
            <link>https://my.oschina.net/u/4939618/blog/10123217</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[网易云课堂 Service Worker 运用与实践]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p><img src="https://oscimg.oschina.net/oscnet/up-ac820c57f42ee1b582f9a6e7a1787375e7a.png" alt="" referrerpolicy="no-referrer"></p><h1>前言</h1><p>本文首先会简单介绍下前端的常见缓存方式，再引入 Service Worker 的概念，针对其原理和如何运用进行介绍。然后基于 google 推出的第三方库 Workbox，在产品中进行运用实践，并对其原理进行简要剖析。</p><blockquote><p>作者：刘放</p></blockquote><blockquote><p>编辑：Ein</p></blockquote><h1>前端缓存简介</h1><p>先简单介绍一下现有的前端缓存技术方案，主要分为 http 缓存和浏览器缓存。</p><h2>http 缓存</h2><p>http 缓存都是第二次请求时开始的，这也是个老生常谈的话题了。无非也是那几个 http 头的问题：</p><h3>Expires</h3><p>HTTP1.0 的内容，服务器使用 Expires 头来告诉 Web 客户端它可以使用当前副本，直到指定的时间为止。</p><h3>Cache-Control</h3><p>HTTP1.1 引入了 Cathe-Control，它使用 max-age 指定资源被缓存多久，主要是解决了 Expires 一个重大的缺陷，就是它设置的是一个固定的时间点，客户端时间和服务端时间可能有误差。 所以一般会把两个头都带上，这种缓存称为强缓存，表现形式为： <img src="https://oscimg.oschina.net/oscnet/up-5d55a7877b12164c2b7f2fe4e870e072dc2.png" alt="" referrerpolicy="no-referrer"></p><h3>Last-Modified / If-Modified-Since</h3><p>Last-Modified 是服务器告诉浏览器该资源的最后修改时间，If-Modified-Since 是请求头带上的，上次服务器给自己的该资源的最后修改时间。然后服务器拿去对比。</p><p>若资源的最后修改时间大于 If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码 200；</p><p>若资源的最后修改时间小于或等于 If-Modified-Since，说明资源无新修改，则响应 HTTP 304，告知浏览器继续使用当前版本。</p><h3>Etag / If-None-Match</h3><p>前面提到由文件的修改时间来判断文件是否改动，还是会带来一定的误差，比如注释等无关紧要的修改等。所以推出了新的方式。</p><p>Etag 是由服务端特定算法生成的该文件的唯一标识，而请求头把返回的 Etag 值通过 If-None-Match 再带给服务端，服务端通过比对从而决定是否响应新内容。这也是 304 缓存。</p><h2>浏览器缓存</h2><h3>Storage</h3><p>简单的缓存方式有 cookie，localStorage 和 sessionStorage。这里就不详细介绍他们的区别了，这里说下通过 localStorage 来缓存静态资源的优化方案。 localStorage 通常有 5MB 的存储空间，我们以微信文章页为例。 查看请求发现，基本没有 js 和 css 的请求，因为它把全部的不需要改动的资源都放到了 localStorage 中： <img src="https://oscimg.oschina.net/oscnet/up-aa2899a96564193e2509884484b4f1eb12b.png" alt="" referrerpolicy="no-referrer"> 所以微信的文章页加载非常的快。</p><h3>前端数据库</h3><p>前端数据库有 WebSql 和 IndexDB，其中 WebSql 被规范废弃，他们都有大约 50MB 的最大容量，可以理解为 localStorage 的加强版。</p><h3>应用缓存</h3><p>应用缓存主要是通过 manifest 文件来注册被缓存的静态资源，已经被废弃，因为他的设计有些不合理的地方，他在缓存静态文件的同时，也会默认缓存 html 文件。这导致页面的更新只能通过 manifest 文件中的版本号来决定。所以，应用缓存只适合那种常年不变化的静态网站。如此的不方便，也是被废弃的重要原因。</p><p>PWA 也运用了该文件，不同于 manifest 简单的将文件通过是否缓存进行分类，PWA 用 manifest 构建了自己的 APP 骨架，并运用 Servie Worker 来控制缓存，这也是今天的主角。</p><h1>Service Worker</h1><p>Service Worker 本质上也是浏览器缓存资源用的，只不过他不仅仅是 Cache，也是通过 worker 的方式来进一步优化。 他基于 h5 的 web worker，所以绝对不会阻碍当前 js 线程的执行，sw 最重要的工作原理就是：</p><p>1、后台线程：独立于当前网页线程；</p><p>2、网络代理：在网页发起请求时代理，来缓存文件。</p><h2>兼容性</h2><p><img src="https://oscimg.oschina.net/oscnet/up-c50376e8514a0eda4c04fcf7bf1af3f24aa.png" alt="" referrerpolicy="no-referrer"> 可以看到，基本上新版浏览器还是兼容滴。之前是只有 chrome 和 firefox 支持，现在微软和苹果也相继支持了。</p><h2>成熟程度</h2><p>判断一个技术是否值得尝试，肯定要考虑下它的成熟程度，否则过一段时间又和应用缓存一样被规范抛弃就尴尬了。 所以这里我列举了几个使用 Service Worker 的页面：</p><ul><li>淘宝</li><li>网易新闻</li><li>考拉</li></ul><p>所以说还是可以尝试下的。</p><h2>调试方法</h2><p>一个网站是否启用 Service Worker，可以通过开发者工具中的 Application 来查看：</p><p><img src="https://oscimg.oschina.net/oscnet/up-b631c480eabb3662b08968b60c0466ceefd.png" alt="" referrerpolicy="no-referrer"></p><p>被 Service Worker 缓存的文件，可以在 Network 中看到 Size 项为 from Service Worker：</p><p><img src="https://oscimg.oschina.net/oscnet/up-a94d21f7c7ca175656166c4224fae4ba3c9.png" alt="" referrerpolicy="no-referrer"></p><p>也可以在 Application 的 Cache Storage 中查看缓存的具体内容：</p><p><img src="https://oscimg.oschina.net/oscnet/up-7db236cf39ff32cf4e8f86a591a08431b07.png" alt="" referrerpolicy="no-referrer"></p><p>如果是具体的断点调试，需要使用对应的线程，不再是 main 线程了，这也是 webworker 的通用调试方法：</p><p><img src="https://oscimg.oschina.net/oscnet/up-72a1c5ec7411b0e92530a737fe53db2b158.png" alt="" referrerpolicy="no-referrer"></p><h2>使用条件</h2><p>sw 是基于 HTTPS 的，因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。如果是本地调试的话，localhost 是可以的。 而我们刚好全站强制 https 化，所以正好可以使用。</p><h2>生命周期</h2><p>大概可以用如下图片来解释：</p><p><img src="https://oscimg.oschina.net/oscnet/up-385c15f6dc80d598f67579d5c0308bb98e5.png" alt="" referrerpolicy="no-referrer"></p><h3>注册</h3><p>要使用 Service Worker，首先需要注册一个 sw，通知浏览器为该页面分配一块内存，然后 sw 就会进入安装阶段。 一个简单的注册方式：</p><pre><code>(function() {
    if('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js');
    }
})()
</code></pre><p>当然也可以考虑全面点，参考网易新闻的注册方式：</p><pre><code>"serviceWorker" in navigator &amp;&amp; window.addEventListener("load",
    function() {
        var e = location.pathname.match(/\/news\/[a-z]{1,}\//)[0] + "article-sw.js?v=08494f887a520e6455fa";
        navigator.serviceWorker.register(e).then(function(n) {
            n.onupdatefound = function() {
                var e = n.installing;
                e.onstatechange = function() {
                    switch (e.state) {
                        case "installed":
                            navigator.serviceWorker.controller ? console.log("New or updated content is available.") : console.log("Content is now available offline!");
                            break;
                        case "redundant":
                            console.error("The installing service worker became redundant.")
                    }
                }
            }
        }).
        catch(function(e) {
            console.error("Error during service worker registration:", e)
        })
    })
</code></pre><p>前面提到过，由于 sw 会监听和代理所有的请求，所以 sw 的作用域就显得额外的重要了，比如说我们只想监听我们专题页的所有请求，就在注册时指定路径：</p><pre><code>navigator.serviceWorker.register('/topics/sw.js');
</code></pre><p>这样就只会对 topics/下面的路径进行优化。</p><h3>installing</h3><p>我们注册后，浏览器就会开始安装 sw，可以通过事件监听：</p><pre><code>//service worker 安装成功后开始缓存所需的资源
var CACHE_PREFIX = 'cms-sw-cache';
var CACHE_VERSION = '0.0.20';
var CACHE_NAME = CACHE_PREFIX+'-'+CACHE_VERSION;
var allAssets = [
    './main.css'
];
self.addEventListener('install', function(event) {

    //调试时跳过等待过程
    self.skipWaiting();


    // Perform install steps
    //首先 event.waitUntil 你可以理解为 new Promise，
    //它接受的实际参数只能是一个 promise，因为,caches 和 cache.addAll 返回的都是 Promise，
    //这里就是一个串行的异步加载，当所有加载都成功时，那么 SW 就可以下一步。
    //另外，event.waitUntil 还有另外一个重要好处，它可以用来延长一个事件作用的时间，
    //这里特别针对于我们 SW 来说，比如我们使用 caches.open 是用来打开指定的缓存，但开启的时候，
    //并不是一下就能调用成功，也有可能有一定延迟，由于系统会随时睡眠 SW，所以，为了防止执行中断，
    //就需要使用 event.waitUntil 进行捕获。另外，event.waitUntil 会监听所有的异步 promise
    //如果其中一个 promise 是 reject 状态，那么该次 event 是失败的。这就导致，我们的 SW 开启失败。
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(function(cache) {
                console.log('[SW]: Opened cache');
                return cache.addAll(allAssets);
            })
    );

});
</code></pre><p>安装时，sw 就开始缓存文件了，会检查所有文件的缓存状态，如果都已经缓存了，则安装成功，进入下一阶段。</p><h3>activated</h3><p>如果是第一次加载 sw，在安装后，会直接进入 activated 阶段，而如果 sw 进行更新，情况就会显得复杂一些。流程如下：</p><p>首先老的 sw 为 A，新的 sw 版本为 B。 B 进入 install 阶段，而 A 还处于工作状态，所以 B 进入 waiting 阶段。只有等到 A 被 terminated 后，B 才能正常替换 A 的工作。</p><p><img src="https://oscimg.oschina.net/oscnet/up-5d04b8ca78c8e2f2bc8f02e992c6a540426.png" alt="" referrerpolicy="no-referrer"></p><p>这个 terminated 的时机有如下几种方式：</p><p>1、关闭浏览器一段时间；</p><p>2、手动清除 Service Worker；</p><p>3、在 sw 安装时直接跳过 waiting 阶段</p><pre><code>//service worker 安装成功后开始缓存所需的资源
self.addEventListener('install', function(event) {
    //跳过等待过程
    self.skipWaiting();
});
</code></pre><p>然后就进入了 activated 阶段，激活 sw 工作。</p><p>activated 阶段可以做很多有意义的事情，比如更新存储在 Cache 中的 key 和 value：</p><pre><code>var CACHE_PREFIX = 'cms-sw-cache';
var CACHE_VERSION = '0.0.20';
/**
 * 找出对应的其他 key 并进行删除操作
 * @returns {*}
 */
function deleteOldCaches() {
    return caches.keys().then(function (keys) {
        var all = keys.map(function (key) {
            if (key.indexOf(CACHE_PREFIX) !== -1 &amp;&amp; key.indexOf(CACHE_VERSION) === -1){
                console.log('[SW]: Delete cache:' + key);
                return caches.delete(key);
            }
        });
        return Promise.all(all);
    });
}
//sw 激活阶段,说明上一 sw 已失效
self.addEventListener('activate', function(event) {


    event.waitUntil(
        // 遍历 caches 里所有缓存的 keys 值
        caches.keys().then(deleteOldCaches)
    );
});
</code></pre><h3>idle</h3><p>这个空闲状态一般是不可见的，这种一般说明 sw 的事情都处理完毕了，然后处于闲置状态了。</p><p>浏览器会周期性的轮询，去释放处于 idle 的 sw 占用的资源。</p><h3>fetch</h3><p>该阶段是 sw 最为关键的一个阶段，用于拦截代理所有指定的请求，并进行对应的操作。</p><p>所有的缓存部分，都是在该阶段，这里举一个简单的例子：</p><pre><code>//监听浏览器的所有 fetch 请求，对已经缓存的资源使用本地缓存回复
self.addEventListener('fetch', function(event) {
    event.respondWith(
        caches.match(event.request)
            .then(function(response) {
                //该 fetch 请求已经缓存
                if (response) {
                    return response;
                }
                return fetch(event.request);
                }
            )
    );
});
</code></pre><p>生命周期大概讲清楚了，我们就以一个具体的例子来说明下原生的 serviceworker 是如何在生产环境中使用的吧。</p><h2>举个栗子</h2><p>我们可以以网易新闻的 wap 页为例,其针对不怎么变化的静态资源开启了 sw 缓存，具体的 sw.js 逻辑和解读如下：</p><pre><code>'use strict';
//需要缓存的资源列表
var precacheConfig = [
    ["https://static.ws.126.net/163/wap/f2e/milk_index/bg_img_sm_minfy.png",
        "c4f55f5a9784ed2093009dadf1e954f9"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/change.png",
        "9af1b102ef784b8ff08567ba25f31d95"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/icon-download.png",
        "1c02c724381d77a1a19ca18925e9b30c"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/icon-login-dark.png",
        "b59ba5abe97ff29855dfa4bd3a7a9f35"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/icon-refresh.png",
        "a5b1084e41939885969a13f8dbc88abd"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/icon-video-play.png",
        "065ff496d7d36345196d254aff027240"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/icon.ico",
        "a14e5365cc2b27ec57e1ab7866c6a228"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/iconfont_1.eot",
        "e4d2788fef09eb0630d66cc7e6b1ab79"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/iconfont_1.svg",
        "d9e57c341608fddd7c140570167bdabb"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/iconfont_1.ttf",
        "f422407038a3180bb3ce941a4a52bfa2"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/iconfont_1.woff",
        "ead2bef59378b00425779c4ca558d9bd"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/index.5cdf03e8.js",
        "6262ac947d12a7b0baf32be79e273083"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/index.bc729f8a.css",
        "58e54a2c735f72a24715af7dab757739"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/logo-app-bohe.png",
        "ac5116d8f5fcb3e7c49e962c54ff9766"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/logo-app-mail.png",
        "a12bbfaeee7fbf025d5ee85634fca1eb"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/logo-app-manhua.png",
        "b8905b119cf19a43caa2d8a0120bdd06"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/logo-app-open.png",
        "b7cc76ba7874b2132f407049d3e4e6e6"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/logo-app-read.png",
        "e6e9c8bc72f857960822df13141cbbfd"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/logo-site.png",
        "2b0d728b46518870a7e2fe424e9c0085"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/version_no_pic.png",
        "aef80885188e9d763282735e53b25c0e"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/version_pc.png",
        "42f3cc914eab7be4258fac3a4889d41d"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/version_standard.png",
        "573408fa002e58c347041e9f41a5cd0d"]
];
var cacheName = 'sw-precache-v3-new-wap-index-' + (self.registration ? self.registration.scope : '');

var ignoreUrlParametersMatching = [/^utm_/];

var addDirectoryIndex = function(originalUrl, index) {
    var url = new URL(originalUrl);
    if (url.pathname.slice(-1) === '/') {
        url.pathname += index;
    }
    return url.toString();
};
var cleanResponse = function(originalResponse) {
    // If this is not a redirected response, then we don't have to do anything.
    if (!originalResponse.redirected) {
        return Promise.resolve(originalResponse);
    }
    // Firefox 50 and below doesn't support the Response.body stream, so we may
    // need to read the entire body to memory as a Blob.
    var bodyPromise = 'body' in originalResponse ?
        Promise.resolve(originalResponse.body) :
        originalResponse.blob();
    return bodyPromise.then(function(body) {
        // new Response() is happy when passed either a stream or a Blob.
        return new Response(body, {
            headers: originalResponse.headers,
            status: originalResponse.status,
            statusText: originalResponse.statusText
        });
    });
};
var createCacheKey = function(originalUrl, paramName, paramValue,
                              dontCacheBustUrlsMatching) {
    // Create a new URL object to avoid modifying originalUrl.
    var url = new URL(originalUrl);
    // If dontCacheBustUrlsMatching is not set, or if we don't have a match,
    // then add in the extra cache-busting URL parameter.
    if (!dontCacheBustUrlsMatching ||
        !(url.pathname.match(dontCacheBustUrlsMatching))) {
        url.search += (url.search ? '&amp;' : '') +
            encodeURIComponent(paramName) + '=' + encodeURIComponent(paramValue);
    }
    return url.toString();
};
var isPathWhitelisted = function(whitelist, absoluteUrlString) {
    // If the whitelist is empty, then consider all URLs to be whitelisted.
    if (whitelist.length === 0) {
        return true;
    }
    // Otherwise compare each path regex to the path of the URL passed in.
    var path = (new URL(absoluteUrlString)).pathname;
    return whitelist.some(function(whitelistedPathRegex) {
        return path.match(whitelistedPathRegex);
    });
};
var stripIgnoredUrlParameters = function(originalUrl,
                                         ignoreUrlParametersMatching) {
    var url = new URL(originalUrl);
    // Remove the hash; see https://github.com/GoogleChrome/sw-precache/issues/290
    url.hash = '';
    url.search = url.search.slice(1) // Exclude initial '?'
        .split('&amp;') // Split into an array of 'key=value' strings
        .map(function(kv) {
            return kv.split('='); // Split each 'key=value' string into a [key, value] array
        })
        .filter(function(kv) {
            return ignoreUrlParametersMatching.every(function(ignoredRegex) {
                return !ignoredRegex.test(kv[0]); // Return true iff the key doesn't match any of the regexes.
            });
        })
        .map(function(kv) {
            return kv.join('='); // Join each [key, value] array into a 'key=value' string
        })
        .join('&amp;'); // Join the array of 'key=value' strings into a string with '&amp;' in between each
    return url.toString();
};

var hashParamName = '_sw-precache';
//定义需要缓存的 url 列表
var urlsToCacheKeys = new Map(
    precacheConfig.map(function(item) {
        var relativeUrl = item[0];
        var hash = item[1];
        var absoluteUrl = new URL(relativeUrl, self.location);
        var cacheKey = createCacheKey(absoluteUrl, hashParamName, hash, false);
        return [absoluteUrl.toString(), cacheKey];
    })
);
//把 cache 中的 url 提取出来,进行去重操作
function setOfCachedUrls(cache) {
    return cache.keys().then(function(requests) {
        //提取 url
        return requests.map(function(request) {
            return request.url;
        });
    }).then(function(urls) {
        //去重
        return new Set(urls);
    });
}
//sw 安装阶段
self.addEventListener('install', function(event) {
    event.waitUntil(
        //首先尝试取出存在客户端 cache 中的数据
        caches.open(cacheName).then(function(cache) {
            return setOfCachedUrls(cache).then(function(cachedUrls) {
                return Promise.all(
                    Array.from(urlsToCacheKeys.values()).map(function(cacheKey) {
                        //如果需要缓存的 url 不在当前 cache 中,则添加到 cache
                        if (!cachedUrls.has(cacheKey)) {
                            //设置 same-origin 是为了兼容旧版本 safari 中其默认值不为 same-origin,
                            //只有当 URL 与响应脚本同源才发送 cookies、 HTTP Basic authentication 等验证信息
                            var request = new Request(cacheKey, {credentials: 'same-origin'});
                            return fetch(request).then(function(response) {
                                //通过 fetch api 请求资源
                                if (!response.ok) {
                                    throw new Error('Request for ' + cacheKey + ' returned a ' +
                                        'response with status ' + response.status);
                                }
                                return cleanResponse(response).then(function(responseToCache) {
                                    //并设置到当前 cache 中
                                    return cache.put(cacheKey, responseToCache);
                                });
                            });
                        }
                    })
                );
            });
        }).then(function() {

            //强制跳过等待阶段,进入激活阶段
            return self.skipWaiting();

        })
    );
});
self.addEventListener('activate', function(event) {
    //清除 cache 中原来老的一批相同 key 的数据
    var setOfExpectedUrls = new Set(urlsToCacheKeys.values());
    event.waitUntil(
        caches.open(cacheName).then(function(cache) {
            return cache.keys().then(function(existingRequests) {
                return Promise.all(
                    existingRequests.map(function(existingRequest) {
                        if (!setOfExpectedUrls.has(existingRequest.url)) {
                            //cache 中删除指定对象
                            return cache.delete(existingRequest);
                        }
                    })
                );
            });
        }).then(function() {
            //self 相当于 webworker 线程的当前作用域
            //当一个 service worker 被初始注册时，页面在下次加载之前不会使用它。 claim() 方法会立即控制这些页面
            //从而更新客户端上的 serviceworker
            return self.clients.claim();

        })
    );
});

self.addEventListener('fetch', function(event) {
    if (event.request.method === 'GET') {
        // 标识位,用来判断是否需要缓存
        var shouldRespond;
        // 对 url 进行一些处理,移除一些不必要的参数
        var url = stripIgnoredUrlParameters(event.request.url, ignoreUrlParametersMatching);
        // 如果该 url 不是我们想要缓存的 url,置为 false
        shouldRespond = urlsToCacheKeys.has(url);
        // 如果 shouldRespond 未 false,再次验证
        var directoryIndex = 'index.html';
        if (!shouldRespond &amp;&amp; directoryIndex) {
            url = addDirectoryIndex(url, directoryIndex);
            shouldRespond = urlsToCacheKeys.has(url);
        }
        // 再次验证,判断其是否是一个 navigation 类型的请求
        var navigateFallback = '';
        if (!shouldRespond &amp;&amp;
            navigateFallback &amp;&amp;
            (event.request.mode === 'navigate') &amp;&amp;
            isPathWhitelisted([], event.request.url)) {
            url = new URL(navigateFallback, self.location).toString();
            shouldRespond = urlsToCacheKeys.has(url);
        }
        // 如果标识位为 true
        if (shouldRespond) {
            event.respondWith(
                caches.open(cacheName).then(function(cache) {
                    //去缓存 cache 中找对应的 url 的值
                    return cache.match(urlsToCacheKeys.get(url)).then(function(response) {
                        //如果找到了,就返回 value
                        if (response) {
                            return response;
                        }
                        throw Error('The cached response that was expected is missing.');
                    });
                }).catch(function(e) {
                    // 如果没找到则请求该资源
                    console.warn('Couldn\'t serve response for "%s" from cache: %O', event.request.url, e);
                    return fetch(event.request);
                })
            );
        }
    }
});
</code></pre><p>这里的策略大概就是优先在 Cache 中寻找资源，如果找不到再请求资源。可以看出，为了实现一个较为简单的缓存，还是比较复杂和繁琐的，所以很多工具就应运而生了。</p><h1>Workbox</h1><p>由于直接写原生的 sw.js，比较繁琐和复杂，所以一些工具就出现了，而 Workbox 是其中的佼佼者，由 google 团队推出。</p><h2>简介</h2><p>在 Workbox 之前，GoogleChrome 团队较早时间推出过 sw-precache 和 sw-toolbox 库，但是在 GoogleChrome 工程师们看来，workbox 才是真正能方便统一的处理离线能力的更完美的方案，所以停止了对 sw-precache 和 sw-toolbox 的维护。</p><h2>使用者</h2><p>有很多团队也是启用该工具来实现 serviceworker 的缓存，比如说：</p><ul><li>淘宝首页</li><li>网易新闻 wap 文章页</li><li>百度的 Lavas</li></ul><h2>基本配置</h2><p>首先，需要在项目的 sw.js 文件中，引入 Workbox 的官方 js，这里用了我们自己的静态资源：</p><pre><code>importScripts(
    "https://edu-cms.nosdn.127.net/topics/js/workbox_9cc4c3d662a4266fe6691d0d5d83f4dc.js"
);
</code></pre><p>其中 importScripts 是 webworker 中加载 js 的方式。</p><p>引入 Workbox 后，全局会挂载一个 Workbox 对象</p><pre><code>if (workbox) {
    console.log('workbox 加载成功');
} else {
    console.log('workbox 加载失败');
}
</code></pre><p>然后需要在使用其他的 api 前，提前使用配置</p><pre><code>//关闭控制枱中的输出
workbox.setConfig({ debug: false });
</code></pre><p>也可以统一指定存储时 Cache 的名称：</p><pre><code>//设置缓存 cachestorage 的名称
workbox.core.setCacheNameDetails({
    prefix:'edu-cms',
    suffix:'v1'
});
</code></pre><h2>precache</h2><p>Workbox 的缓存分为两种，一种的 precache，一种的 runtimecache。</p><p>precache 对应的是在 installing 阶段进行读取缓存的操作。它让开发人员可以确定缓存文件的时间和长度，以及在不进入网络的情况下将其提供给浏览器，这意味着它可以用于创建 Web 离线工作的应用。</p><h3>工作原理</h3><p>首次加载 Web 应用程序时，Workbox 会下载指定的资源，并存储具体内容和相关修订的信息在 indexedDB 中。</p><p>当资源内容和 sw.js 更新后，Workbox 会去比对资源，然后将新的资源存入 Cache，并修改 indexedDB 中的版本信息。</p><p>我们举一个例子：</p><pre><code>workbox.precaching.precacheAndRoute([
    './main.css'
]);
</code></pre><p><img src="https://oscimg.oschina.net/oscnet/up-d8a79ba50b83bfbc538b960e07f0c707b17.png" alt="" referrerpolicy="no-referrer"></p><p>indexedDB 中会保存其相关信息</p><p><img src="https://oscimg.oschina.net/oscnet/up-b9f1c514f24a2b5121771fa9b59fb0cc82b.png" alt="" referrerpolicy="no-referrer"></p><p>这个时候我们把 main.css 的内容改变后，再刷新页面，会发现除非强制刷新，否则 Workbox 还是会读取 Cache 中存在的老的 main.css 内容。</p><p>即使我们把 main.css 从服务器上删除，也不会对页面造成影响。</p><p>所以这种方式的缓存都需要配置一个版本号。在修改 sw.js 时，对应的版本也需要变更。</p><h3>使用实践</h3><p>当然了，一般我们的一些不经常变的资源，都会使用 cdn，所以这里自然就需要支持域外资源了，配置方式如下：</p><pre><code>var fileList = [
    {
        url:'https://edu-cms.nosdn.127.net/topics/js/cms_specialWebCommon_js_f26c710bd7cd055a64b67456192ed32a.js'
    },
    {
        url:'https://static.ws.126.net/163/frontend/share/css/article.207ac19ad70fd0e54d4a.css'
    }
];


//precache 适用于支持跨域的 cdn 和域内静态资源
workbox.precaching.suppressWarnings();
workbox.precaching.precacheAndRoute(fileList, {
    "ignoreUrlParametersMatching": [/./]
});
</code></pre><p>这里需要对应的资源配置跨域允许头，否则是不能正常加载的。且文件都要以版本文件名的方式，来确保修改后 Cache 和 indexDB 会得到更新。</p><p>理解了原理和实践后，说明这种方式适合于上线后就不会经常变动的静态资源。</p><h2>runtimecache</h2><p>运行时缓存是在 install 之后，activated 和 fetch 阶段做的事情。</p><p>既然在 fetch 阶段发送，那么 runtimecache 往往应对着各种类型的资源，对于不同类型的资源往往也有不同的缓存策略。</p><h3>缓存策略</h3><p>Workbox 提供的缓存策划有以下几种，通过不同的配置可以针对自己的业务达到不同的效果：</p><h3>Stale While Revalidate</h3><p>这种策略的意思是当请求的路由有对应的 Cache 缓存结果就直接返回，</p><p>在返回 Cache 缓存结果的同时会在后台发起网络请求拿到请求结果并更新 Cache 缓存，如果本来就没有 Cache 缓存的话，直接就发起网络请求并返回结果，这对用户来说是一种非常安全的策略，能保证用户最快速的拿到请求的结果。</p><p>但是也有一定的缺点，就是还是会有网络请求占用了用户的网络带宽。可以像如下的方式使用 State While Revalidate 策略：</p><pre><code>workbox.routing.registerRoute(
    new RegExp('https://edu-cms\.nosdn\.127\.net/topics/'),
    workbox.strategies.staleWhileRevalidate({
        //cache 名称
        cacheName: 'lf-sw:static',
        plugins: [
            new workbox.expiration.Plugin({
                //cache 最大数量
                maxEntries: 30
            })
        ]
    })
);
</code></pre><h3>Network First</h3><p>这种策略就是当请求路由是被匹配的，就采用网络优先的策略，也就是优先尝试拿到网络请求的返回结果，如果拿到网络请求的结果，就将结果返回给客户端并且写入 Cache 缓存。</p><p>如果网络请求失败，那最后被缓存的 Cache 缓存结果就会被返回到客户端，这种策略一般适用于返回结果不太固定或对实时性有要求的请求，为网络请求失败进行兜底。可以像如下方式使用 Network First 策略：</p><pre><code>//自定义要缓存的 html 列表
var cacheList = [
    '/Hexo/public/demo/PWADemo/workbox/index.html'
];
workbox.routing.registerRoute(
    //自定义过滤方法
    function(event) {
        // 需要缓存的 HTML 路径列表
        if (event.url.host === 'localhost:63342') {
            if (~cacheList.indexOf(event.url.pathname)) return true;
            else return false;
        } else {
            return false;
        }
    },
    workbox.strategies.networkFirst({
        cacheName: 'lf-sw:html',
        plugins: [
            new workbox.expiration.Plugin({
                maxEntries: 10
            })
        ]
    })
);
</code></pre><h3>Cache First</h3><p>这个策略的意思就是当匹配到请求之后直接从 Cache 缓存中取得结果，如果 Cache 缓存中没有结果，那就会发起网络请求，拿到网络请求结果并将结果更新至 Cache 缓存，并将结果返回给客户端。这种策略比较适合结果不怎么变动且对实时性要求不高的请求。可以像如下方式使用 Cache First 策略：</p><pre><code>workbox.routing.registerRoute(
    new RegExp('https://edu-image\.nosdn\.127\.net/'),
    workbox.strategies.cacheFirst({
        cacheName: 'lf-sw:img',
        plugins: [
            //如果要拿到域外的资源，必须配置
            //因为跨域使用 fetch 配置了
            //mode: 'no-cors',所以 status 返回值为 0，故而需要兼容
            new workbox.cacheableResponse.Plugin({
                statuses: [0, 200]
            }),
            new workbox.expiration.Plugin({
                maxEntries: 40,
                //缓存的时间
                maxAgeSeconds: 12 * 60 * 60
            })
        ]
    })
);
</code></pre><h3>Network Only</h3><p>比较直接的策略，直接强制使用正常的网络请求，并将结果返回给客户端，这种策略比较适合对实时性要求非常高的请求。</p><h3>Cache Only</h3><p>这个策略也比较直接，直接使用 Cache 缓存的结果，并将结果返回给客户端，这种策略比较适合一上线就不会变的静态资源请求。</p><h2>举个栗子</h2><p>又到了举个栗子的阶段了，这次我们用淘宝好了，看看他们是如何通过 Workbox 来配置 Service Worker 的：</p><pre><code>//首先是异常处理
self.addEventListener('error', function(e) {
  self.clients.matchAll()
    .then(function (clients) {
      if (clients &amp;&amp; clients.length) {
        clients[0].postMessage({ 
          type: 'ERROR',
          msg: e.message || null,
          stack: e.error ? e.error.stack : null
        });
      }
    });
});

self.addEventListener('unhandledrejection', function(e) {
  self.clients.matchAll()
    .then(function (clients) {
      if (clients &amp;&amp; clients.length) {
        clients[0].postMessage({
          type: 'REJECTION',
          msg: e.reason ? e.reason.message : null,
          stack: e.reason ? e.reason.stack : null
        });
      }
    });
})
//然后引入 workbox
importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js');
workbox.setConfig({
  debug: false,
  modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/'
});
//直接激活跳过等待阶段
workbox.skipWaiting();
workbox.clientsClaim();
//定义要缓存的 html
var cacheList = [
  '/',
  '/tbhome/home-2017',
  '/tbhome/page/market-list'
];
//html 采用 networkFirst 策略，支持离线也能大体访问
workbox.routing.registerRoute(
  function(event) {
    // 需要缓存的 HTML 路径列表
    if (event.url.host === 'www.taobao.com') {
      if (~cacheList.indexOf(event.url.pathname)) return true;
      else return false;
    } else {
      return false;
    }
  },
  workbox.strategies.networkFirst({
    cacheName: 'tbh:html',
    plugins: [
      new workbox.expiration.Plugin({
        maxEntries: 10
      })
    ]
  })
);
//静态资源采用 staleWhileRevalidate 策略，安全可靠
workbox.routing.registerRoute(
  new RegExp('https://g\.alicdn\.com/'),
  workbox.strategies.staleWhileRevalidate({
    cacheName: 'tbh:static',
    plugins: [
      new workbox.expiration.Plugin({
        maxEntries: 20
      })
    ]
  })
);
//图片采用 cacheFirst 策略，提升速度
workbox.routing.registerRoute(
  new RegExp('https://img\.alicdn\.com/'),
  workbox.strategies.cacheFirst({
    cacheName: 'tbh:img',
    plugins: [
      new workbox.cacheableResponse.Plugin({
        statuses: [0, 200]
      }),
      new workbox.expiration.Plugin({
        maxEntries: 20,
        maxAgeSeconds: 12 * 60 * 60
      })
    ]
  })
);

workbox.routing.registerRoute(
  new RegExp('https://gtms01\.alicdn\.com/'),
  workbox.strategies.cacheFirst({
    cacheName: 'tbh:img',
    plugins: [
      new workbox.cacheableResponse.Plugin({
        statuses: [0, 200]
      }),
      new workbox.expiration.Plugin({
        maxEntries: 30,
        maxAgeSeconds: 12 * 60 * 60
      })
    ]
  })
);
</code></pre><p>可以看出，使用 Workbox 比起直接手撸来，要快很多，也明确很多。</p><h2>原理</h2><p>目前分析 Service Worker 和 Workbox 的文章不少，但是介绍 Workbox 原理的文章却不多。这里简单介绍下 Workbox 这个工具库的原理。</p><p>首先将几个我们产品用到的模块图奉上：</p><p><img src="https://oscimg.oschina.net/oscnet/up-b22e014db049eea325d28de53c9b6b9cd76.png" alt="" referrerpolicy="no-referrer"></p><p>简单提几个 Workbox 源码的亮点。</p><h3>通过 Proxy 按需依赖</h3><p>熟悉了 Workbox 后会得知，它是有很多个子模块的，各个子模块再通过用到的时候按需 importScript 到线程中。 <img src="https://oscimg.oschina.net/oscnet/up-12e98258edc4bd13e5ad48a74c9835ede68.png" alt="" referrerpolicy="no-referrer"></p><p>做到按需依赖的原理就是通过 Proxy 对全局对象 Workbox 进行代理：</p><pre><code>new Proxy(this, {
  get(t, s) {
    //如果 workbox 对象上不存在指定对象，就依赖注入该对象对应的脚本
    if (t[s]) return t[s];
    const o = e[s];
    return o &amp;&amp; t.loadModule(`workbox-${o}`), t[s];
  }
})
</code></pre><p>如果找不到对应模块，则通过 importScripts 主动加载：</p><pre><code>/**
 * 加载前端模块
 * @param {Strnig} t 
 */
loadModule(t) {
  const e = this.o(t);
  try {
    importScripts(e), (this.s = !0);
  } catch (s) {
    throw (console.error(`Unable to import module '${t}' from '${e}'.`), s);
  }
}
</code></pre><h3>通过 freeze 冻结对外暴露 api</h3><p>Workbox.core 模块中提供了几个核心操作模块，如封装了 indexedDB 操作的 DBWrapper、对 Cache Storage 进行读取的 Cache Wrapper，以及发送请求的 fetchWrapper 和日志管理的 logger 等等。</p><p>为了防止外部对内部模块暴露出去的 api 进行修改，导致出现不可预估的错误，内部模块可以通过 Object.freeze 将 api 进行冻结保护：</p><pre><code>var _private = /*#__PURE__*/Object.freeze({
    DBWrapper: DBWrapper,
    WorkboxError: WorkboxError,
    assert: finalAssertExports,
    cacheNames: cacheNames,
    cacheWrapper: cacheWrapper,
    fetchWrapper: fetchWrapper,
    getFriendlyURL: getFriendlyURL,
    logger: defaultExport
  });
</code></pre><h1>总结</h1><p>通过对 Service Worker 的理解和 Workbox 的应用，可以进一步提升产品的性能和弱网情况下的体验。有兴趣的同学也可以对 Workbox 的源码细细评读，其中还有很多不错的设计模式和编程风格值得学习。</p><p><img src="https://oscimg.oschina.net/oscnet/up-a546d4d52ff6cdf625f4d4a4890fd454bec.png" alt="" referrerpolicy="no-referrer"></p><p><strong>-END-</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 28 Oct 2023 10:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/youdaotech/blog/5054309</guid>
            <link>https://my.oschina.net/youdaotech/blog/5054309</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Wasmer 开源 WinterJS：Rust 编写的 Service Worker]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 请你来轰趴啦！1028 苏州源创会，一起寻宝 AI 时代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>Wasmer 团队开源了一款用 Rust 编写的<strong> JavaScript Service Worker：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwasmer.io%2Fposts%2Fannouncing-winterjs-service-workers" target="_blank">WinterJS</a></u></strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-6382fe02fb5cbb80e1cb6951156b73e1143.png" referrerpolicy="no-referrer"></p><p><em>WinterJS 开源地址：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwasmerio%2Fwinterjs" target="_blank">https://github.com/wasmerio/winterjs</a></u></em></p><p>据介绍，WinterJS 使用 SpiderMonkey 运行时执行 JavaScript（与 Firefox 使用的运行时相同），并遵循 WinterCG 规范，目的是最大限度地兼容 Cloudflare Workers、Deno Deploy 和 Vercel 等其他服务（因此命名为 WinterJS）。</p><p>WinterJS 除了速度极快，还能通过 WASIX <strong>编译成 WebAssembly</strong>，因此完全支持在 Wasmer 上运行。</p><ul><li><strong>使用示例</strong></li></ul><p><strong>创建<code>serviceworker.js</code>文件，并返回 "hello world"</strong></p><pre><code class="language-javascript">$ wasmer run wasmer/winterjs --net --mapdir /app:. /app/serviceworker.js</code></pre><pre><code class="language-javascript">addEventListener('fetch', (req) =&gt; {
  req.respondWith(`hello world from ${req.request.url.href}`);
});</code></pre><blockquote><p>Wasmer 是支持 WASI 和 Emscripten 的通用 WebAssembly 运行时，提供基于 WebAssembly 的超轻量级容器，专注于支持在任何平台上运行 WASM 代码：从桌面端到云端、以及 IoT 设备，并且能嵌入在任何编程语言中。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/0627/173716_02s8_2720166.png" referrerpolicy="no-referrer"></p><p>Wasmer 凭借其多样化的支持和专注于从通用桌面应用程序到 「便携式 ML/AI 应用程序」 的领域，目前仍然是领先的 WASM 运行时之一。</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Sat, 28 Oct 2023 10:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/263968/winterjs-service-workers</guid>
            <link>https://www.oschina.net/news/263968/winterjs-service-workers</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
