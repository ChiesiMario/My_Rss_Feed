<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 01 Nov 2023 06:30:55 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[vivo 发布自研操作系统蓝河 (BlueOS)，系统框架采用 Rust 编写]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 vivo 开发者大会今天正式开始。大会上，vivo 发布了自研操作系统<strong>蓝河 (BlueOS)</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-15a70d97c2f8f3654e7d6f94c8c92df5505.png" referrerpolicy="no-referrer"></p><p>vivo 称「蓝河操作系统」是面向通用人工智能时代的自研智慧操作系统 —— 底层接入了 AI 大模型，支持基于自然交互方式的应用开发。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135537_Q43j_2720166.png" referrerpolicy="no-referrer"></p><p>vivo 还表示，蓝河操作系统<strong>采用 Rust 编写「系统框架」</strong>——从源头避免了内存使用不当引起的安全漏洞。据称是行业首家<strong>。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f21c3eb7d2568b66e3cebdf8f628b9bb78b.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135659_sEFQ_2720166.png" referrerpolicy="no-referrer"></p><p>运行要求方面，在低至 200Mhz 主频 32MB 内存，高至 4GHz 主频 24GB 内存的各种设备上，蓝河都能流畅运行。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/142454_nhO4_2720166.png" referrerpolicy="no-referrer"></p><p>据了解，蓝河操作系统目前不会在 vivo 手机上提供，首款搭载蓝河操作系统的 vivo 设备是 vivo Watch3 智能手表。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b5c944705e833222c61dc1c96c7713648ca.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 06:02:32 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264444</guid>
            <link>https://www.oschina.net/news/264444</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[macOS Sonoma 黑屏 bug，影响 Asahi Linux]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Asahi Linux 发布了一篇文档，说明了近期 macOS 黑屏情况。</p><blockquote><p><span style="color:#333333">Asahi Linux 项目致力于将 Linux 操作系统移植到苹果的 Apple Silicon Macs 系列电脑设备上。</span></p><ul><li><a href="https://www.oschina.net/news/125751/asahi-linux-set-up" target="_blank">可移植苹果 M1 的 Asahi Linux 项目正式启</a></li></ul></blockquote><p>Asahi 解释，macOS Sonoma 和 macOS Ventura 13.6 在其升级和启动过程中发布了多个严重的错误。这些错误结合在一起，可以创建出一种情况，即无论使用何种电源按钮按压组合，机器总是启动到黑屏。这使用户陷入困境，唯一的解决方案就是使用 DFU 恢复。</p><p>在某些设置和特定型号下，这种情况可能会发生，即多个 macOS 版本并行安装（一个 Sonoma，一个更早的版本）。由于 Asahi Linux 的行为就像是 macOS 12.3/12.4/13.5（取决于型号和安装时间），所以 macOS Sonoma 和 Asahi Linux 的双启动安装会产生相同的问题。对于 macOS 13.6，这种情况甚至不需要双启动系统，只要作为唯一安装的操作系统就可以触发。</p><p>目前 Asahi Linux 安装程序已经更新，现在它可以在启动时自动进行完整性检查并诊断系统。要运行它，请将此命令粘贴到 macOS 的终端中：</p><p style="text-align:start"><code>curl https://alx.sh | sh</code></p><p style="text-align:start">进入主菜单，用户可以退出安装程序，而不对系统做任何更改。</p><p style="text-align:start">Asahi Linux 具体说明了 macOS 启动失败的原因：</p><ul><li><p>macOS Sonoma 的升级使用先前安装的版本作为系统恢复。这在某种程度上是有道理的，但并未考虑到旧版 RecoveryOS 与新固件之间的向后兼容性问题。如果这种不匹配导致 recoveryOS 无法启动，那么系统恢复将无法使用。</p></li><li><p>对于 14 英寸和 16 英寸的型号：一旦系统固件更新到 macOS Sonoma 版本，如果显示器的刷新率设置为非 ProMotion，则该系统将无法正确地启动旧版本的 macOS 安装程序和 Asahi Linux。这包括当这些系统被设置为默认启动操作系统时的恢复模式，以及至少在下一次操作系统升级之前的系统恢复。</p></li></ul><p>影响设备、系统：</p><ul><li><p>配备 ProMotion 显示屏的 MacBook Pro 型号（14 英寸和 16 英寸）受到黑屏启动错误的影响。</p></li><li><p>macOS Sonoma 14.0+（截至 2023 年 10 月 31 日尚未修复）</p></li><li><p>macOS Ventura 13.6+ (使用 14.0 固件)</p></li><li><p>可能受影响：macOS Monterey 12.7（未经确认）</p></li></ul><p><strong>如果还没升级到 Sonoma，Asahi Linux&nbsp;<span style="background-color:#ffffff; color:#1f2328">建议等到苹果解决这些问题后再进行升级。</span></strong></p><p>更多细节查看 Asahi 发布的说明：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAsahiLinux%2Fdocs%2Fwiki%2FmacOS-Sonoma-Boot-Failures" target="_blank">https://github.com/AsahiLinux/docs/wiki/macOS-Sonoma-Boot-Failures</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 04:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264432/macos-sonoma-boot-failures</guid>
            <link>https://www.oschina.net/news/264432/macos-sonoma-boot-failures</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微信 iOS 版「史诗级」更新：「发送」按钮独立]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>微信 iOS 版昨天发布了 8.0.43 更新，更新日志一如既往地是「修复了一些已知问题」。</p><blockquote><p><img height="780" src="https://static.oschina.net/uploads/space/2023/1101/121221_VGwW_2720166.png" width="1810" referrerpolicy="no-referrer"></p></blockquote><p>不过热心网友发现的一项重要变化冲上了微博热搜：<span style="color:#e67e22"><strong>#微信新增独立发送按钮#</strong></span>。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-12f6e066aebe74a1bd7440aa69ef266c4b9.png" referrerpolicy="no-referrer"></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-877e90cea0d617b8694aa9a040acdc2080e.png" referrerpolicy="no-referrer"></p><p>没错，微信 for iOS 8.0.43 新增了「使用独立的发送按钮」开关。开启后，iOS 自带输入法的「发送」按键变成「换行」按键，而输入框右侧增加了独立的「发送」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-410e4a667b0d00dcd7c363e6c756adad620.png" referrerpolicy="no-referrer"></p><p>对使用 iOS 自带输入法用户来说，这属实是「史诗级」更新。</p><p>毕竟此前在输入文字的时候如果想换行，需要在输入框轻点或者长按呼出换行开关。现在「换行」和「发送」终于都有了独立按键，感谢 Allen Zhang : )</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 04:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264431</guid>
            <link>https://www.oschina.net/news/264431</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[运营商在光猫内置反诈插件？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>网友发帖称，自己的同事参加某运营商<strong>加 1 元提速 2000m 送 fttr 1+2 活动</strong>后，由于活动要求 45 天内保持在线并且要使用路由模式，这名同事就按照要求使用路由模式。</p><blockquote><p>FTTR (Fiber to The Remote)，是指光纤敷设到远端节点，为光纤接入的基本技术方式。</p></blockquote><p>然后他发现自建的科学上网功能出现不能连接的情况，并且访问&nbsp; xenyth.net 网站时直接跳转到了反诈页面，几分钟之后接到反诈热线打来的电话，询问他有没有访问一个叫做 xenyth.net 的诈骗网站。工作人员告诉他这是一个网购诈骗网站，付款后不会发货，要求不再访问，如有需要可以安排民警上门。</p><p><span style="background-color:#ffffff; color:#000000">后面这名同事搞到超级密码后进入光猫，发现：</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9b10cd4d0019c4015f48be3f0d542493520.png" referrerpolicy="no-referrer"></p><p>最后附上卸载插件方法：</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/113529_5FaL_2720166.png" referrerpolicy="no-referrer"></p><p><em>via&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.v2ex.com%2Ft%2F986550" target="_blank">https://www.v2ex.com/t/986550</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 03:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264421</guid>
            <link>https://www.oschina.net/news/264421</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[四维纵横完成超亿元 B 轮融资]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">新一代超融合数据库厂商四维纵横<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fq_l-0lQ_GJxLTEXTjF30ag" target="_blank">宣布</a>完成了上亿元人民币的 B 轮融资，本轮融资由用友、顺义产业基金领投，广州同创基金跟投。该公司表示，</span><span style="background-color:#ffffff">此次募集资金将会主要用于研发核心技术，建设商业生态链等方面。</span></span></p><p><span style="color:#000000"><img height="251" src="https://oscimg.oschina.net/oscnet/up-ecefb2dbc5ddf668afa56fccacfa3960e27.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">四维纵横是一家成立于 2020 年的数据库公司，以超融合数据库 YMatrix 为企业提供集「分析、事务、时序」为一体的企业级数据库产品服务。目前，四维纵横，以 YMatrix 为核心，自研了全栈向量化执行器、分布式数据库灾备、MARS3 存储引擎、MatrixShift 迁移工具、MatrixGate 高性能写入组件、MatrixUI 图形化界面等一系列商业化套件。</span></p><p><span style="color:#000000"><img height="345" src="https://oscimg.oschina.net/oscnet/up-c609ba963a02c51a5f6c10587fc68105704.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">当前，YMatrix 已经被应用到证券、通信、银行、保险、智能制造、车联网等多个行业领域中，服务的客户包括浪潮、中兴、理想汽车、宁德时代、三一重工等多个头部企业。</span></span></p><p><span style="color:#000000">公告指出，在本轮融资之后，四维纵横将会以目前 YMatrix 产品技术能力为根基，以超融合理念为发展方向，继续拓展新的应用领域，将 YMatrix 超融合数据库产品应用于更多的场景中。另外，四维纵横将进一步加快并夯实技术团队的人员建设和技术基础，为全球用户提供更加全面的超融合解决方案。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264414</guid>
            <link>https://www.oschina.net/news/264414</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度上线「文心一言」会员，开通可解锁文心大模型 4.0]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>百度大模型文心一言现已上线会员模式，开通后可解锁文心大模型 4.0。</p><p><strong>目前文心一言基础版功能依旧免费开放使用</strong>，可以满足用户的日常需求，如交互对话、问答等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-523eef7bc90f0772422e76d8d238e5a06f5.png" referrerpolicy="no-referrer"></p><p>据介绍，文心一言会员单月购买价格为 59.9 元，<strong>连续包月价格为 49.9 元</strong>（次月以 49.9 元 / 月自动续费，可随时取消）。此外，百度还推出了文心一言 + 文心一格（白银）的联合会员，价格为 99 元 / 月。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2e89f249c9e05e483bc3e37a5c145a0001d.png" referrerpolicy="no-referrer"></p><p><strong>文心一言会员权益：</strong></p><ul><li><p>模型能力：文心大模型 4.0</p></li><li><p>图片生成：文生图能力全面升级</p></li><li><p>插件权益 （网页端）：高阶插件</p></li><li><p>灵感值 （App 端）：单月赠送 600 灵感值</p></li></ul><p><strong>文心一格会员权益：</strong></p><ul><li><p>极速生成多尺寸高清图像</p></li><li><p>创作海报和艺术字</p></li><li><p>白银会员权益：AI 编辑改图修图</p></li></ul><hr><p><u><a href="https://www.oschina.net/news/262086">文心大模型 4.0 于上个月正式亮相</a></u>，李彦宏表示，<strong>这是迄今为止最强大的文心大模型</strong>，实现了基础模型的全面升级，在理解、生成、逻辑和记忆能力上都有着明显提升，综合水平「与 GPT-4 相比毫不逊色」。</p><p><img alt="up-cb21975862a8f7b014aeea47cbab52da1df.png" src="https://oscimg.oschina.net/oscnet/up-cb21975862a8f7b014aeea47cbab52da1df.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264412</guid>
            <link>https://www.oschina.net/news/264412</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenSign —— 开源 PDF 电子签名解决方案]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenSign 是一个开源文档电子签名解决方案，旨在为 DocuSign、PandaDoc、SignNow、Adobe Sign、Smartwaiver、SignRequest、HelloSign 和 Zoho Sign 等商业平台提供安全、可靠且免费的替代方案。</p><p>特性：</p><ul><li><strong>安全签名</strong>：利用最先进的加密算法来确保文档的安全性和完整性。</li><li><strong>用户友好的界面</strong>：设计时考虑到可用性，使技术和非技术用户都能轻松使用。</li><li><strong>多平台支持</strong>：兼容各种浏览器和设备。</li><li><strong>邀请和协作用户</strong>：将团队中的多人带入签名流程，所有这些都在你自己的基础设施内进行。</li><li><strong>安全</strong>：允许使用「OpenSigDrive」轻松、安全和无缝地组织文档。</li><li><strong>审计跟踪</strong>：保留与文档签名过程相关的所有活动的详细日志，包括 IP 地址和访问时间。</li><li><strong>完成证书</strong>：所有参与者签署文件后立即生成安全完成证书。</li><li><strong>API 支持</strong>：提供强大的 API，用于集成到其他软件和服务中。</li></ul><p><img alt="" height="293" src="https://static.oschina.net/uploads/space/2023/1031/154224_RLJo_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="298" src="https://static.oschina.net/uploads/space/2023/1031/154242_mhWv_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="307" src="https://static.oschina.net/uploads/space/2023/1031/154356_RuMR_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 03:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/opensign</guid>
            <link>https://www.oschina.net/p/opensign</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 一站式分布式任务调度系统 Hodor]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-hodorscheduler" class="anchor" href="https://gitee.com/dromara/hodor#hodorscheduler"></a>HodorScheduler</h1><h2><a id="user-content-介绍" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BB%8B%E7%BB%8D"></a>介绍</h2><p>Hodor 是一个专注于<strong>任务调度</strong>以及<strong>任务编排</strong>的<strong>一站式</strong>分布式任务调度系统。</p><p>通过提供任务编程 API 和接口协议， 方便支持用户使用不同的编程语言实现任务执行以及自定义任务类型的扩展，以满足各种业务场景下的任务执行。</p><p>支持多种接入方式，支持 Java SDK 包方式、Java Agent 独立进程方式接入，以及兼容 XXLJob 框架、Spring Task 框架任务无缝接入。</p><p>多语言执行器实现，计划支持 Go 或者 Rust 语言执行器（正在设计与开发中）的接入，满足在资源有限的执行器节点执行，比如物联网场景下面的定时任务执行。</p><p>支持丰富的任务类型，除了支持普通的 Java、脚本任务的执行，也支持了大数据任务 Hadoop、Spark、Flink、Kettle 等主流任务的执行，满足用户的不同场景。</p><h2><a id="user-content-主要特性" class="anchor" href="https://gitee.com/dromara/hodor#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"></a>主要特性</h2><ol><li>支持 Cron、FixedRate、FixedDelay、OnceTime 方式配置定时任务，可以方便地实现各种定时任务需求。</li><li>支持 DAG 方式进行任务编排，使得任务之间的关系更加清晰，同时提高了系统的可扩展性和灵活性。</li><li>支持 Java 任务和大数据任务调度，兼容 XXLJob、SpringTask 调度任务，满足不同场景下的任务调度需求。</li><li>支持可扩展执行器，用户可以根据自己的需求自定义实现任务类型，从而更好地适应不同的业务场景。</li><li>支持任务静态分片、动态分片、广播、WorkFlow 等多种任务执行模式。</li><li>支持任务自动创建与手动创建以及批量创建等方式，任务的暂停、恢复、Kill 等动作，以及实时日志查看等。</li><li>基于 CopySet 算法实现任务副本分配，提高了任务的可靠性和容错性，从而保障了任务的高可用性。</li></ol><p>详细文档请查阅：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor">https://www.yuque.com/tomgs/hodor</a></p><h2><a id="user-content-架构设计" class="anchor" href="https://gitee.com/dromara/hodor#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"></a>架构设计</h2><p><img src="https://gitee.com/dromara/hodor/raw/master/docs/assets/img/hodor%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="hodor 架构设计图" referrerpolicy="no-referrer"></p><h2><a id="user-content-快速开始" class="anchor" href="https://gitee.com/dromara/hodor#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"></a>快速开始</h2><p>项目结构：</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">hodor-scheduler</span><span id="LC2" class="line">├─docs                                          # 文档存放位置</span><span id="LC3" class="line">├─hodor-actuator                                # hodor 任务执行器</span><span id="LC4" class="line">│  ├─hodor-actuator-api                         # 执行器扩展接口</span><span id="LC5" class="line">│  ├─hodor-actuator-java                        # jar 包方式任务执行器</span><span id="LC6" class="line">│  ├─hodor-actuator-agent                       # 独立进程方式任务执行器</span><span id="LC7" class="line">│  ├─hodor-actuator-xxljob                      # 支持 xxl-job 执行器</span><span id="LC8" class="line">│  └─hodor-actuator-springtask                  # 支持 spring task 执行器</span><span id="LC9" class="line">├─hodor-admin                                   # hodor 管理控制枱（TODO）</span><span id="LC10" class="line">├─hodor-client                                  # 提供与 hodor server 的交互 sdk</span><span id="LC11" class="line">├─hodor-common                                  # hodor 公共依赖</span><span id="LC12" class="line">├─hodor-core                                    # hodor 核心业务</span><span id="LC13" class="line">├─hodor-examples                                # hodor 测试用例</span><span id="LC14" class="line">├─hodor-cache                                   # hodor 扩展</span><span id="LC15" class="line">│  ├─hodor-cache-local                          # 基于本地内存的缓存</span><span id="LC16" class="line">│  ├─hodor-cache-embedded                       # 基于 embedded 的分布式缓存</span><span id="LC17" class="line">│  └─hodor-cache-redis                          # 基于 redis 的分布式缓存</span><span id="LC18" class="line">├─hodor-model                                   # hodor 公共数据模型</span><span id="LC19" class="line">├─hodor-storage                                 # hodor storage 模块</span><span id="LC20" class="line">├─hodor-register                                # hodor 注册中心</span><span id="LC21" class="line">│  ├─hodor-register-api</span><span id="LC22" class="line">│  ├─hodor-register-embedded                    # 基于 Raft 实现注册中心</span><span id="LC23" class="line">│  └─hodor-register-zookeeper                   # 基于 zk 实现注册中心</span><span id="LC24" class="line">├─hodor-remoting                                # hodor 通信框架</span><span id="LC25" class="line">│  ├─hodor-remoting-api</span><span id="LC26" class="line">│  └─hodor-remoting-netty</span><span id="LC27" class="line">├─hodor-scheduler                               # hodor 调度核心</span><span id="LC28" class="line">│  ├─hodor-scheduler-api</span><span id="LC29" class="line">│  └─hodor-scheduler-quartz</span><span id="LC30" class="line">└─hodor-server                                  # hodor 入口</span><span id="LC31" class="line"></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-本地源码运行方式" class="anchor" href="https://gitee.com/dromara/hodor#%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"></a>本地源码运行方式</h2><ol><li>在 mysql 下执行 docs 目录下面的 hodor_ddl.sql。</li><li>在项目根目录下通过 mvn package -DskipTests=true 命令编译整个项目，因为涉及到一些代码的自动生成。</li><li>进入到 hodor-server，启动 HodorServer 调度器。</li><li>进入到 examples 下面的 hodor-actuator-java-example，启动 java 任务执行器程序</li><li>java 执行器启动完成后会自动将任务注册到调度器里面来</li></ol><h2><a id="user-content-任务使用说明" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"></a>任务使用说明</h2><p>详细参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fiqrsqxh2i2qt5ixi">执行器操作指南</a></p><h3><a id="user-content-java 任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#java%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>java 任务接入 demo</h3><p>详细 demo 代码参考 <em>hodor-examples/hodor-actuator-java-example</em> 模块</p><blockquote><p>普通 java 任务</p></blockquote><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">group</span><span class="o">=</span><span class="s">"testGroup"</span><span class="o">,</span><span class="n">jobName</span><span class="o">=</span><span class="s">"test1"</span><span class="o">,</span><span class="n">cron</span><span class="o">=</span><span class="s">"0/30 * * * * ?"</span><span class="o">)</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="nc">String</span><span class="nf">test1</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC3" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [testGroup#test1] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC4" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC5" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job test1"</span><span class="o">);</span></span><span id="LC6" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"job argument: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getJobParameter</span><span class="o">());</span></span><span id="LC7" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executing......"</span><span class="o">);</span></span><span id="LC8" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executed"</span><span class="o">);</span></span><span id="LC9" class="line"><span class="k">return</span><span class="s">"a=123"</span><span class="o">;</span></span><span id="LC10" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><blockquote><p>动态分片任务</p></blockquote><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 任务动态切分</span></span><span id="LC2" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"splitStage"</span><span class="o">)</span></span><span id="LC3" class="line"><span class="kd">public</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">ShardData</span><span class="o">&gt;</span><span class="nf">split</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC4" class="line"><span class="nc">ShardData</span><span class="n">shardData</span><span class="o">=</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">id</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">params</span><span class="o">(</span><span class="s">"hello"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span></span><span id="LC5" class="line"><span class="nc">ShardData</span><span class="n">shardData1</span><span class="o">=</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">id</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">params</span><span class="o">(</span><span class="s">"world"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span></span><span id="LC6" class="line"><span class="k">return</span><span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">shardData</span><span class="o">,</span><span class="n">shardData1</span><span class="o">);</span></span><span id="LC7" class="line"><span class="o">}</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">// 任务并行执行</span></span><span id="LC10" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"parallelJob"</span><span class="o">)</span></span><span id="LC11" class="line"><span class="kd">public</span><span class="nc">String</span><span class="nf">parallelJob</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC12" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [parallelJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC13" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC14" class="line"><span class="kd">final</span><span class="nc">ShardData</span><span class="n">parentJobData</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobData</span><span class="o">(</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></span><span id="LC15" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job parallelJob, parentJobData: {}"</span><span class="o">,</span><span class="n">parentJobData</span><span class="o">);</span></span><span id="LC16" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job parallelJob, parentJobData: {}"</span><span class="o">,</span><span class="n">parentJobData</span><span class="o">);</span></span><span id="LC17" class="line"><span class="k">return</span><span class="s">"a=123"</span><span class="o">;</span></span><span id="LC18" class="line"><span class="o">}</span></span><span id="LC19" class="line"></span><span id="LC20" class="line"><span class="c1">// 任务汇总执行</span></span><span id="LC21" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"reduceJob2"</span><span class="o">)</span></span><span id="LC22" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">reduceJob</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC23" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC24" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC25" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"job argument: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getJobParameter</span><span class="o">());</span></span><span id="LC26" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executed"</span><span class="o">);</span></span><span id="LC27" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC28" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, results {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobExecuteResults</span><span class="o">()</span></span><span id="LC29" class="line"><span class="o">);</span></span><span id="LC30" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, statues {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobExecuteStatuses</span><span class="o">());</span></span><span id="LC31" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-xxljob 任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#xxljob%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>xxljob 任务接入 demo</h3><p>详细 demo 代码参考 <em>hodor-examples/hodor-actuator-xxljob-example</em> 模块</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="cm">/**</span></span><span id="LC2" class="line"><span class="cm"> * 1、简单任务示例（Bean 模式）</span></span><span id="LC3" class="line"><span class="cm"> */</span></span><span id="LC4" class="line"><span class="nd">@XxlJob</span><span class="o">(</span><span class="s">"demoJobHandler"</span><span class="o">)</span></span><span id="LC5" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">demoJobHandler</span><span class="o">()</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC6" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"XXL-JOB, Hello World."</span><span class="o">);</span></span><span id="LC7" class="line"></span><span id="LC8" class="line"><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"beat at:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span></span><span id="LC10" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC11" class="line"><span class="o">}</span></span><span id="LC12" class="line"><span class="c1">// default success</span></span><span id="LC13" class="line"><span class="o">}</span></span><span id="LC14" class="line"></span><span id="LC15" class="line"><span class="cm">/**</span></span><span id="LC16" class="line"><span class="cm"> * 2、分片广播任务</span></span><span id="LC17" class="line"><span class="cm"> */</span></span><span id="LC18" class="line"><span class="nd">@XxlJob</span><span class="o">(</span><span class="s">"shardingJobHandler"</span><span class="o">)</span></span><span id="LC19" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">shardingJobHandler</span><span class="o">()</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC20" class="line"><span class="c1">// 分片参数</span></span><span id="LC21" class="line"><span class="kt">int</span><span class="n">shardIndex</span><span class="o">=</span><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">getShardIndex</span><span class="o">();</span></span><span id="LC22" class="line"><span class="kt">int</span><span class="n">shardTotal</span><span class="o">=</span><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">getShardTotal</span><span class="o">();</span></span><span id="LC23" class="line"></span><span id="LC24" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"分片参数：当前分片序号 = {}, 总分片数 = {}"</span><span class="o">,</span><span class="n">shardIndex</span><span class="o">,</span><span class="n">shardTotal</span><span class="o">);</span></span><span id="LC25" class="line"></span><span id="LC26" class="line"><span class="c1">// 业务逻辑</span></span><span id="LC27" class="line"><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">shardTotal</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span><span class="o">{</span></span><span id="LC28" class="line"><span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="n">shardIndex</span><span class="o">)</span><span class="o">{</span></span><span id="LC29" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"第 {} 片, 命中分片开始处理"</span><span class="o">,</span><span class="n">i</span><span class="o">);</span></span><span id="LC30" class="line"><span class="o">}</span><span class="k">else</span><span class="o">{</span></span><span id="LC31" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"第 {} 片, 忽略"</span><span class="o">,</span><span class="n">i</span><span class="o">);</span></span><span id="LC32" class="line"><span class="o">}</span></span><span id="LC33" class="line"><span class="o">}</span></span><span id="LC34" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-spring-task 任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#spring-task%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>spring task 任务接入 demo</h3><p>详细 demo 代码参考 <em>hodor-examples/hodor-actuator-springtask-example</em> 模块</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedRate</span><span class="o">=</span><span class="mi">3000</span><span class="o">)</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task1</span><span class="o">()</span><span class="kd">throws</span><span class="nc">InterruptedException</span><span class="o">{</span></span><span id="LC3" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC4" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行 fixedRate 任务的时间："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC5" class="line"><span class="o">}</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedDelay</span><span class="o">=</span><span class="mi">4000</span><span class="o">)</span></span><span id="LC8" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task2</span><span class="o">()</span><span class="kd">throws</span><span class="nc">InterruptedException</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC10" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行 fixedDelay 任务的时间："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC11" class="line"><span class="o">}</span></span><span id="LC12" class="line"></span><span id="LC13" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">cron</span><span class="o">=</span><span class="s">"0/5 * * * * ?"</span><span class="o">)</span></span><span id="LC14" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task3</span><span class="o">()</span><span class="o">{</span></span><span id="LC15" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行 cron 任务的时间："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC16" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-agent-方式任务接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#agent-%E6%96%B9%E5%BC%8F%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>agent 方式任务接入 demo</h3><p>详细参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fiqrsqxh2i2qt5ixi">执行器操作指南</a> 中的 agent 方式的使用。</p><h2><a id="user-content-hodor 打包部署说明" class="anchor" href="https://gitee.com/dromara/hodor#hodor%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%AF%B4%E6%98%8E"></a>hodor 打包部署说明</h2><p>详细参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fgiukp9y4plqb55ng">安装部署操作指南</a></p><h2><a id="user-content-交流学习" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BA%A4%E6%B5%81%E5%AD%A6%E4%B9%A0"></a>交流学习</h2><p>目前，Hodor 仍处于建设的过程中，团队成员只能抽出空闲时间投入其中，主要精力还是放在日常工作中。
如果有兴趣的同学想要参与 Hodor 的实现或者一起学习，欢迎通过微信联系我们，我们非常欢迎新的成员加入！</p><p>Hodor 的未来发展方向包括以下几个方面：</p><ol><li>前端界面和控制枱开发，为用户提供更加友好、直观的任务管理界面。</li><li>执行器开发工作，包括执行编程框架和大数据任务执行器的优化，以提高系统的性能和稳定性。</li><li>通信协议改造，计划将目前自定义的协议改造为 grpc 的方式，以提高系统的可扩展性和兼容性。</li><li>优化 CopySet 算法的实现，以支持机架感知，更好地分配任务副本。</li><li>开发多语言执行器，主要放在 go 和 rust 语言，以满足用户不同的需求和偏好。</li></ol><p>Wechat：(备注：Hodor)</p><p><img src="https://gitee.com/dromara/hodor/raw/master/docs/assets/img/wechat.png" alt="image-20220529141555032" referrerpolicy="no-referrer"></p>]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/dromara/hodor</guid>
            <link>https://gitee.com/dromara/hodor</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | Dubbo 路由及负载均衡性能优化]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="font-size: 15px;"><section style="text-align: right;margin-top: 10px;margin-bottom: -25px;" powered-by="xiumi.us"><section style="display: inline-block;width: 35px;height: 35px;vertical-align: top;overflow: hidden;border-width: 1px;border-radius: 100%;border-style: solid;border-color: transparent;background-color: rgb(255, 255, 255);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section><section style="text-align: center;font-size: 14px;" powered-by="xiumi.us"><p><span style="color: rgb(0, 82, 255);"><span style="color: rgb(0, 82, 255);letter-spacing: 0.578px;text-align: center;text-wrap: wrap;font-size: 14px;">揭秘 vivo 互联网海量服务的研发之路&nbsp;</span><span style="color: rgb(0, 82, 255);text-align: center;text-wrap: wrap;font-size: 14px;letter-spacing: 0.034em;">报名中👇</span></span></p></section><section style="text-align: center;margin-top: 0.5em;margin-bottom: 0.5em;padding-left: 0.5em;padding-right: 0.5em;" powered-by="xiumi.us"><section style="border-width: 5px;border-style: solid;border-color: rgb(255, 255, 255);display: inline-block;line-height: 0;box-shadow: rgb(102, 102, 102) 0.2em 0.2em 0.5em;width: 70%;height: auto;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D2%26sn%3D949ce368a94c5950749a74fec56b98fb%26chksm%3Debdb8632dcac0f24fbac44050c9605d521f9728517b311f54639e1ab3bc0422ce95391b09636%26scene%3D21%23wechat_redirect" textvalue="你已选中了添加链接的内容" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="1"><span class="js_jump_icon h5_image_link"><img class="rich_pages wxw-img" data-cropselx1="0" data-cropselx2="384" data-cropsely1="0" data-cropsely2="384" data-ratio="0.21944444444444444" data-s="300,640" src="https://oscimg.oschina.net/oscnet/92614968-2ae5-4624-9416-5e3659137ef6.png" data-type="jpeg" data-w="1080" style="vertical-align: middle;width: 578px;height: 127px;" referrerpolicy="no-referrer"></span></a></section><span style="font-size: 14px;letter-spacing: 0.034em;text-align: justify;"></span></section></section><section style="font-size: 15px;line-height: 1.6;"><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">作者：vivo 互联网中间件团队- Wang Xiaochuang</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: left;" powered-by="xiumi.us"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);"><p style="text-wrap: wrap;">本文主要介绍在 vivo 内部针对 Dubbo 路由模块及负载均衡的一些优化手段，主要是异步化+缓存，可减少在 RPC 调用过程中路由及负载均衡的 CPU 消耗，极大提升调用效率。</p></section></section><section style="margin-right: 0%;margin-bottom: -5px;margin-left: 0%;text-align: right;line-height: 1;font-size: 5px;transform: translate3d(5px, 0px, 0px);" powered-by="xiumi.us"><section style="width: 0px;display: inline-block;vertical-align: top;border-bottom: 0.6em solid rgb(160, 160, 160);border-right: 0.6em solid rgb(160, 160, 160);border-top: 0.6em solid transparent !important;border-left: 0.6em solid transparent !important;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>一、概要</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">vivo 内部 Java 技术栈业务使用的是 Apache Dubbo 框架，基于开源社区 2.7.x 版本定制化开发。在海量微服务集群的业务实践中，我们发现 Dubbo 有一些性能瓶颈的问题会极大影响业务逻辑的执行效率，尤其是在集群规模数量较大时 (提供方数量&gt;100)，路由及负载均衡方面有着较大的 CPU 消耗，从采集的火焰图分析高达 30%。为此我们针对 vivo 内部常用路由策略及负载均衡进行相关优化，并取得了较好的效果。接下来主要跟大家分析一下相关问题产生的根源，以及我们采用怎样的方式来解决这些问题。（当前 vivo 内部使用的 Dubbo 的主流版本是基于 2.7.x 进行相关定制化开发。）</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>二、背景知识</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.1 Dubbo 客户端调用流程</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1.&nbsp;相关术语介绍</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.35069075451647186" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bac7b7d2-f9db-4eb0-9f3d-5900e79ab3fe.png" data-type="png" data-w="941" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;主要流程</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">客户端通过本地代理 Proxy 调用 ClusterInvoker，ClusterInvoker 从服务目录 Directory 获取服务列表后经过路由链获取新的服务列表、负载均衡从路由后的服务列表中根据不同的负载均衡策略选取一个远端 Invoker 后再发起远程 RPC 调用。</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.562962962962963" data-s="300,640" src="https://oscimg.oschina.net/oscnet/c2e7d8db-665a-4a4f-b704-246b9544a375.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.2 Dubbo 路由机制</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Dubbo 的路由机制实际是基于简单的责任链模式实现，同时 Router 继承了 Comparable 接口，自定义的路由可以设置不同的优先级进而定制化责任链上 Router 的顺序。基于责任链模式可以支持多种路由策略串行执行如就近路由+标签路由，或条件路由+就近路由等，且路由的配置支持基于接口级的配置也支持基于应用级的配置。常见的路由方式主要有：就近路由，条件路由，标签路由等。具体的执行过程如下图所示：</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.0143112701252237" data-s="300,640" src="https://oscimg.oschina.net/oscnet/de6310ef-9be0-491d-8451-14b01a37e125.png" data-type="png" data-w="559" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 核心类</strong></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">Dubbo 路由的核心类主要有：<strong>RouterChain、RouterFactory 与 Router 。</strong></p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">（1）RouterChain</p><p style="text-wrap: wrap;">RouterChain 是路由链的入口，其核心字段有<br></p></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><strong>invokers（List&lt;invoker&gt; 类型）</strong></p><p>初始服务列表由服务目录 Directory 设置，当前 RouterChain 要过滤的 Invoker 集合<br></p></li><li><p><strong>builtinRouters（List 类型）</strong></p><p>当前 RouterChain 包含的自动激活的 Router 集合<br></p></li><li><p><strong>routers（List 类型）</strong></p><p>包括所有要使用的路由由 builtinRouters 加上通过 addRouters() 方法添加的 Router 对象</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">RouterChain 核心逻辑</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">class</span><span class="code-snippet__title">RouterChain</span>&lt;<span class="code-snippet__title">T</span>&gt; </span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 注册中心最后一次推送的服务列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers = Collections.emptyList();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 所有路由,包括原生 Dubbo 基于注册中心的路由规则如「route://」 urls .</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> volatile <span class="code-snippet__keyword">List</span>&lt;Router&gt; routers = Collections.emptyList();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 初始化自动激活的路由</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span><span class="code-snippet__keyword">List</span>&lt;Router&gt; builtinRouters = Collections.emptyList();</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> RouterChain(URL url) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//通过 ExtensionLoader 加载可自动激活的 RouterFactory</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;RouterFactory&gt; extensionFactories = ExtensionLoader.getExtensionLoader(RouterFactory.class)</span></code><code><span class="code-snippet_outer">                .getActivateExtension(url, ROUTER_KEY);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 由工厂类生成自动激活的路由策略</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Router&gt; routers = extensionFactories.stream()</span></code><code><span class="code-snippet_outer">                .map(factory -&gt; factory.getRouter(url))</span></code><code><span class="code-snippet_outer">                .collect(Collectors.toList());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        initWithRouters(routers);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 添加额外路由</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> void addRouters(<span class="code-snippet__keyword">List</span>&lt;Router&gt; routers) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Router&gt; newRouters = <span class="code-snippet__keyword">new</span> ArrayList&lt;&gt;();</span></code><code><span class="code-snippet_outer">        newRouters.addAll(builtinRouters);</span></code><code><span class="code-snippet_outer">        newRouters.addAll(routers);</span></code><code><span class="code-snippet_outer">        Collections.sort(newRouters, comparator);</span></code><code><span class="code-snippet_outer">        this.routers = newRouters;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; route(URL url, Invocation invocation) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; finalInvokers = invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 遍历全部的 Router 对象，执行路由规则</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (Router router : routers) {</span></code><code><span class="code-snippet_outer">            finalInvokers = router.route(finalInvokers, url, invocation);</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> finalInvokers;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）RouterFactory 为 Router 的工厂类</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">RouterFactory 接口定义</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@SPI</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">RouterFactory</span></span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Adaptive</span>(<span class="code-snippet__string">"protocol"</span>)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__function">Router <span class="code-snippet__title">getRouter</span><span class="code-snippet__params">(URL url)</span></span>;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（3）Router</p><p style="text-wrap: wrap;" powered-by="xiumi.us">Router 是真正的路由实现策略，由 RouterChain 进行调用，同时 Router 继承了 Compareable 接口，可以根据业务逻辑设置不同的优先级。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">Router 主要接口定义</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">Router</span><span class="code-snippet__keyword">extends</span><span class="code-snippet__title">Comparable</span>&lt;<span class="code-snippet__title">Router</span>&gt; </span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     *</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers   带过滤实例列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> url        消费方 url</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invocation 会话信息</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span> routed invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@throws</span> RpcException</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer">    &lt;T&gt; <span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; route(<span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 当注册中心的服务列表发现变化，或有动态配置变更会触发实例信息的变化</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 当时 2.7.x 的 Dubbo 并没有真正使用这个方法，可基于此方法进行路由缓存</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers invoker list</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;      invoker's type</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">default</span> &lt;T&gt; void notify(<span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;同机房优先路由的实现</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="letter-spacing: 0.034em;">为方便大家了解路由的实现，给大家展示一下就近路由的核心代码逻辑</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL consumerUrl, Invocation invocation) throws RpcException {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (!<span class="code-snippet__keyword">this</span>.enabled) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取本地机房信息</span></span></code><code><span class="code-snippet_outer">        String local = getSystemProperty(LOC);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers == <span class="code-snippet__literal">null</span> || invokers.size() == <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">        List&lt;Invoker&lt;T&gt;&gt; result = new ArrayList&lt;Invoker&lt;T&gt;&gt;();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (Invoker invoker: invokers) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取与本地机房一致的 invoker 并加入列表中</span></span></code><code><span class="code-snippet_outer">            String invokerLoc = getProperty(invoker, invocation, LOC);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (local.equals(invokerLoc)) {</span></code><code><span class="code-snippet_outer">                result.add(invoker);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (result.size() &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (fallback){</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 开启服务降级，available.ratio = 当前机房可用服务节点数量 ／ 集群可用服务节点数量</span></span></code><code><span class="code-snippet_outer">                int curAvailableRatio = (int) Math.floor(result.size() * <span class="code-snippet__number">100.0</span>d / invokers.size());</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (curAvailableRatio &lt;= availableRatio) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (force) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.3 Dubbo 负载均衡</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Dubbo 的负载均衡实现比较简单基本都是继承抽象类进行实现，主要作用就是根据具体的策略在路由之后的服务列表中筛选一个实例进行远程 RPC 调用，默认的负载均衡策略是随机。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">整体类图如下所示：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.2824074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/22c30ee5-d60d-45b1-a737-bbf064f7c1cc.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">LoadBalance 接口定义</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@SPI</span>(RandomLoadBalance.NAME)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">LoadBalance</span></span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 从服务列表中筛选一个.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     *</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers   invokers.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> url        refer url</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invocation invocation.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span> selected invoker.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Adaptive</span>(<span class="code-snippet__string">"loadbalance"</span>)</span></code><code><span class="code-snippet_outer">    &lt;T&gt; <span class="code-snippet__function">Invoker&lt;T&gt; <span class="code-snippet__title">select</span><span class="code-snippet__params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span><span class="code-snippet__keyword">throws</span> RpcException</span>;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">随机负载均衡核心代码解析</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 预热过程权重计算</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">static</span><span class="code-snippet__keyword">int</span><span class="code-snippet__title">calculateWarmupWeight</span>(<span class="code-snippet__params"><span class="code-snippet__keyword">int</span> uptime, <span class="code-snippet__keyword">int</span> warmup, <span class="code-snippet__keyword">int</span> weight</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> ww = (<span class="code-snippet__keyword">int</span>) (uptime / ((<span class="code-snippet__keyword">float</span>) warmup / weight));</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> ww &lt; <span class="code-snippet__number">1</span> ? <span class="code-snippet__number">1</span> : (Math.min(ww, weight));</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">int</span><span class="code-snippet__title">getWeight</span>(<span class="code-snippet__params">Invoker&lt;?&gt; invoker, Invocation invocation</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> weight;</span></code><code><span class="code-snippet_outer">       URL url = invoker.getUrl();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 多注册中心场景下的，注册中心权重获取</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">           weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">       } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer">           weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (weight &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取实例启动时间</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">long</span> timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, <span class="code-snippet__number">0L</span>);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (timestamp &gt; <span class="code-snippet__number">0L</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">long</span> uptime = System.currentTimeMillis() - timestamp;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (uptime &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span><span class="code-snippet__number">1</span>;</span></code><code><span class="code-snippet_outer">                   }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取预热时间</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (uptime &gt; <span class="code-snippet__number">0</span> &amp;&amp; uptime &lt; warmup) {</span></code><code><span class="code-snippet_outer">                       weight = calculateWarmupWeight((<span class="code-snippet__keyword">int</span>)uptime, warmup, weight);</span></code><code><span class="code-snippet_outer">                   }</span></code><code><span class="code-snippet_outer">               }</span></code><code><span class="code-snippet_outer">           }</span></code><code><span class="code-snippet_outer">       }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> Math.max(weight, <span class="code-snippet__number">0</span>);</span></code><code><span class="code-snippet_outer">   }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">@Override</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">protected</span> &lt;T&gt; <span class="code-snippet__function">Invoker&lt;T&gt; <span class="code-snippet__title">doSelect</span>(<span class="code-snippet__params">List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Number of invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> length = invokers.size();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Every invoker has the same weight?</span></span></code><code><span class="code-snippet_outer">        boolean sameWeight = <span class="code-snippet__literal">true</span>;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// the weight of every invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span>[] weights = <span class="code-snippet__keyword">new</span><span class="code-snippet__keyword">int</span>[length];</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// the first invoker's weight</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> firstWeight = getWeight(invokers.<span class="code-snippet__keyword">get</span>(<span class="code-snippet__number">0</span>), invocation);</span></code><code><span class="code-snippet_outer">        weights[<span class="code-snippet__number">0</span>] = firstWeight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// The sum of weights</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> totalWeight = firstWeight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = <span class="code-snippet__number">1</span>; i &lt; length; i++) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> weight = getWeight(invokers.<span class="code-snippet__keyword">get</span>(i), invocation);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// save for later use</span></span></code><code><span class="code-snippet_outer">            weights[i] = weight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Sum</span></span></code><code><span class="code-snippet_outer">            totalWeight += weight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) {</span></code><code><span class="code-snippet_outer">                sameWeight = <span class="code-snippet__literal">false</span>;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (totalWeight &gt; <span class="code-snippet__number">0</span> &amp;&amp; !sameWeight) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on totalWeight.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Return a invoker based on the random value.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = <span class="code-snippet__number">0</span>; i &lt; length; i++) {</span></code><code><span class="code-snippet_outer">                offset -= weights[i];</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (offset &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers.<span class="code-snippet__keyword">get</span>(i);</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers.<span class="code-snippet__keyword">get</span>(ThreadLocalRandom.current().nextInt(length));</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>预热解释</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">预热是为了让刚启动的实例流量缓慢增加,因为实例刚启动时各种资源可能还没建立连接，相关代码可能还是处于解释执行，仍未变为 JIT 执行，此时业务逻辑较慢，不应该加载过大的流量，否则有可能造成较多的超时。Dubbo 默认预热时间为 10 分钟，新部署的实例的流量会在预热时间段内层线性增长，最终与其他实例保持一致。Dubbo 预热机制的实现就是通过控制权重来实现。如默认权重 100，预热时间 10 分钟，则第一分钟权重为 10，第二分钟为 20，以此类推。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体预热效果图如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.45765765765765765" data-s="300,640" src="https://oscimg.oschina.net/oscnet/752bc3b5-e121-4de3-b41b-022860b2700e.png" data-type="png" data-w="555" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>三、问题分析</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">使用 Dubbo 的业务方反馈，他们通过火焰图分析发现 Dubbo 的负载均衡模块+路由模块占用 CPU 超过了 30%，框架层面的使用率严重影响了业务逻辑的执行效率急需进行优化。通过火焰图分析，具体占比如下图，其中该机器在业务忙时的 CPU 使用率在 60% 左右，闲时在 30% 左右。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.30970873786407765" data-s="300,640" src="https://oscimg.oschina.net/oscnet/81ae8f99-a18c-4416-8f9a-b6c012a14476.png" data-type="png" data-w="1030" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通过火焰图分析，负载均衡主要的消耗是在 getWeight 方法。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.1388888888888889" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b1d57058-f760-43c5-83bc-166c07ca9d81.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">路由的主要消耗是在 route 方法：</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">同机房优先路由</p><p style="text-wrap: wrap;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.11296296296296296" data-s="300,640" src="https://oscimg.oschina.net/oscnet/fee26d17-6eb3-4103-b12d-cc8975696932.png" data-type="png" data-w="1080" style="font-size: 15px;letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" referrerpolicy="no-referrer"></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">接口级标签路由+应用级标签路由</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.14907407407407408" data-s="300,640" src="https://oscimg.oschina.net/oscnet/11c33b76-0ae1-45fe-aeef-a05793340801.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">这些方法都有一个特点，那就是遍历执行。如负载均衡，针对每一个 invoker 都需要通过 getWeight 方法进行权重的计算；就近路由的 router 方法对于每一个 invoker 都需要通过 url 获取及机房信息进行匹配计算。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">我们分析一下 getWeight 及 router 时间复杂度，发现是 O(n) 的时间复杂度，而且路由是由路由链组成的，每次每个 Router 的 route 方法调用逻辑都会遍历实例列表，那么当实例列表数量过大时，每次匹配的计算的逻辑过大，那么就会造成大量的计算成本，导致占用大量 cpu，同时也导致路由负载均衡效率低下。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">综上所述，罪恶的的根源就是遍历导致的，当服务提供方数量越多，影响越大。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>四、优化方案</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">知道了问题所在，我们来分析一下是否有优化空间。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.1 路由优化</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 优化一：关闭无效路由</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通过火焰图分析，我们发现有部分业务即使完全不使用应用级的标签路由，原生的 TagRouter 也存在遍历逻辑，原因是为了支持静态的标签路由，其实这部分的开销也不少，那对于根本不会使用应用级标签路由的可以手动进行关闭。关闭方式如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">客户端统一关闭<br></p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js"><code><span class="code-snippet_outer">dubbo.consumer.router=-tag</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">服务级别关闭</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">注解方式：</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@DubboReference(parameters = {<span class="code-snippet__meta-string">"router"</span>,<span class="code-snippet__meta-string">"-tag"</span>})</span></span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">xml 方式：</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer">&lt;dubbo:reference id=<span class="code-snippet__string">"demoService"</span> check=<span class="code-snippet__string">"false"</span><span class="code-snippet__keyword">interface</span>=<span class="code-snippet__string">"com.dubbo.study.n.api.DemoService"</span> router=<span class="code-snippet__string">"-tag"</span> /&gt;</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2. 优化二：提前计算路由结果并进行缓存</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">每次路由目前都是进行实时计算，但是在大多数情况下，我们的实例列表是稳定不变的，只有在发布窗口或配置变更窗口内实例列表才会发生变更，那我们是否可以考虑缓存呢。如就近路由，可以以机房为 key 进行机房实例的全量缓存。针对接口级标签路由可以缓存不同标签值指定的实例信息。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">我们知道路由的执行过程是责任链模式，每一个 Router 的实例列表入参实际上是一个 Router 的结果，可参考公式：target = rn(…r3(r2(r1(src))))。那么所有的路由可以基于注册中心推送的原始服务列表进行路由计算并缓存，然后不同的路由结果相互取交集就能得到最终的结果，当实例信息发生变更时，缓存失效并重新计算。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>3. 缓存更新时机</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">当注册中心或者动态配置有变更时，相关通知会给到服务目录 Directory,Directory 收到通知后会重新创建服务列表，并把服务列表同步到路由链 RouterChain，RouterChain 再按顺序通知其链上的 Router,各个 Router 再进行缓存清除并重新进行路由结果的计算及进行缓存。相关时序图如下所示：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.42962962962962964" data-s="300,640" src="https://oscimg.oschina.net/oscnet/e8b71fb8-8926-40de-abe8-147ba10fa2ea.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>4. 具体路由流程</strong></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">进入具体路由方法时，先判断是否存在缓存的路由值，且缓存值的 epoch 必须与上一个路由的 epoch 需一致，此时缓存才生效，然后缓存值与上个 Router 的结果取交集。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">如果不存在缓存或 epoch 不一致则重新进行实时的路由计算。</p><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.7803921568627451" data-s="300,640" src="https://oscimg.oschina.net/oscnet/024bfb79-3f68-4ca5-bf7f-bfd337d6c3d0.jpg" data-type="jpeg" data-w="1020" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us">引入 epoch 的原因主要是保证各个路由策略缓存信息的一致性，保证所有的缓存计算都是基于同一份原始数据。当实例信息发生变更时，epoch 会自动进行更新。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>5. BitMap 引入</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">上文我们说到，不同的路由策略之间的结果是取交集的，然后最终的结果才送入负载均衡流程。那如何在缓存的同时，加快交集的计算呢。答案就是基于位图：BitMap。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">BitMap 的基本原理就是用一个 bit 位来存放某种状态，适用于大规模数据的查找及位运算操作。如在路由场景，先基于全量的推送数据进行计算缓存。如果某个实例被路由选中，则其值为 1，若两个路由的结果要取交集，那直接对 BitMap 进行"&amp;"运行即可。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">全量缓存示意图：</p><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.4935185185185185" data-s="300,640" src="https://oscimg.oschina.net/oscnet/5fc6e016-b880-40ce-9d59-390fe111bfa8.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us">路由交集计算示步骤：</p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">按照路由链依次计算，</p><p style="text-wrap: wrap;">tagRouter-&gt;vivoTag-&gt;vivoNearestRouter</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（1）tagRouter 计算逻辑：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>按照 Invocation 计算出目标的 Tag,假设是 tag1</p></li><li><p>然后从缓存 Cache 根据 key:tag1,取出对应的 targetAddrPool</p></li><li><p>将原始传入的 addrPool</p><p>与 targetAddrPool</p><p>得到结果 resultAddrPool</p></li><li><p>将 resultAddrPool 传入 vivoTagRouter</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）vivoTag 计算逻辑：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>按照 Invocation 计算出目标的 Tag,假设是 tabB</p></li><li><p>然后从缓存 Cache 根据 key:tag1，取出对应的 targetAddrPool</p></li><li><p>将上一次传入的 addrPool</p><p>与 targetAddrPool</p><p>得到结果 resultAddrPooll</p></li><li><p>将 resultAddrPool 传入</p><p>vivoNearestRouter</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">（3）vivoNearestRouter 计算逻辑</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>从环境变量取出当前机房，假设是 bj01</p></li><li><p>然后从缓存 Cache 根据 key:bj01，取出对应的 targetAddrPool</p></li><li><p>将上一次传入的 addrPool</p><p>与 targetAddrPool</p><p>取出 resultAddrPool</p></li><li><p>将上一次传入的 addrPool</p><p>与 targetAddrPool</p><p>得到结果 resultAddrPool</p></li><li><p>将 resultAddrPool 为最终路由结果，传递给 LoadBalance</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6907407407407408" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bfad5e5c-e485-4ab8-8b25-208b5ca92c3d.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>6. 基于缓存的同机房优先路由源码解析</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">缓存刷新</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * Notify router chain of the initial addresses from registry at the first time.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * Notify whenever addresses in registry change.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">public</span><span class="code-snippet__keyword">void</span><span class="code-snippet__title">setInvokers</span>(<span class="code-snippet__params">List&lt;Invoker&lt;T&gt;&gt; invokers</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 创建带 epoch 的 BitList</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">this</span>.invokers = <span class="code-snippet__keyword">new</span> BitList&lt;Invoker&lt;T&gt;&gt;(invokers == <span class="code-snippet__literal">null</span> ? Collections.emptyList() : invokers,createBitListEpoch());</span></code><code><span class="code-snippet_outer">        routers.forEach(router -&gt; router.notify(<span class="code-snippet__keyword">this</span>.invokers));</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">同机房优先路由源码解读</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL consumerUrl, Invocation invocation) throws RpcException {</span></code><code><span class="code-snippet_outer">        …………<span class="code-snippet__comment">//省略非核心代码</span></span></code><code><span class="code-snippet_outer">        BitList&lt;Invoker&lt;T&gt;&gt; bitList = (BitList&lt;Invoker&lt;T&gt;&gt;) invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//获取路由结果</span></span></code><code><span class="code-snippet_outer">        BitList&lt;Invoker&lt;T&gt;&gt; result = getNearestInvokersWithCache(bitList);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (result.size() &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (fallback) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 开启服务降级，available.ratio = 当前机房可用服务节点数量 ／ 集群可用服务节点数量</span></span></code><code><span class="code-snippet_outer">                int curAvailableRatio = (int) Math.floor(result.size() * <span class="code-snippet__number">100.0</span>d / invokers.size());</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (curAvailableRatio &lt;= availableRatio) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (force) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }   </span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 获取缓存列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span></span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> &lt;T&gt; BitList&lt;Invoker&lt;T&gt;&gt; getNearestInvokersWithCache(BitList&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer">        ValueWrapper valueWrapper = getCache(getSystemProperty(LOC));</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 是否存在缓存</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (valueWrapper != <span class="code-snippet__literal">null</span>) {</span></code><code><span class="code-snippet_outer">            BitList&lt;Invoker&lt;T&gt;&gt; invokerBitList = (BitList&lt;Invoker&lt;T&gt;&gt;) valueWrapper.<span class="code-snippet__keyword">get</span>();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 缓存的 epoch 与源列表是否一致</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers.isSameEpoch(invokerBitList)) {</span></code><code><span class="code-snippet_outer">                BitList&lt;Invoker&lt;T&gt;&gt; tmp = invokers.clone();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 结果取交集</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> tmp.and(invokerBitList);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 缓存不存在，实时计算放回</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> getNearestInvokers(invokers);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 新服务列表通知</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Override</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; void notify(List&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer">        clear();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers != <span class="code-snippet__literal">null</span> &amp;&amp; invokers instanceof BitList) {</span></code><code><span class="code-snippet_outer">            BitList&lt;Invoker&lt;T&gt;&gt; bitList = (BitList&lt;Invoker&lt;T&gt;&gt;) invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 设置最后一次更新的服务列表</span></span></code><code><span class="code-snippet_outer">            lastNotify = bitList.clone();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (!CollectionUtils.isEmpty(invokers) &amp;&amp; <span class="code-snippet__keyword">this</span>.enabled) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 获取机房相同的服务列表并进行缓存</span></span></code><code><span class="code-snippet_outer">                setCache(getSystemProperty(LOC), getNearestInvokers(lastNotify));</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.2 负载均衡优化</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1.&nbsp;优化一</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">针对 getWeight 方法，我们发现有部分业务逻辑较为消耗 cpu,但是在大多数场景下业务方并不会使用到，于是进行优化。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">getWeight 方法优化</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="javascript"><code><span class="code-snippet_outer">优化前：</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//这里主要要用多注册中心场景下，注册中心权重的获取，绝大多数情况下并不会有这个逻辑</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">           weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">       }  </span></code><code><span class="code-snippet_outer">优化后：</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invoker <span class="code-snippet__keyword">instanceof</span> ClusterInvoker &amp;&amp; UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">            weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">   }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;优化二</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">遍历是罪恶的源泉，而实例的数量决定这罪恶的深浅，我们有什么办法减少负载均衡过程中的遍历呢。一是根据 group 及 version 划分不同的集群，但是这需要涉及到业务方代码或配置层面的改动，会带来额外的成本。所以我们放弃了。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">二是没有什么是加一层解决不了的问题，为了尽量减少进入负载均衡的节点数量，考虑新增一个垫底的路由策略，在走完所有的路由策略后，若节点数量&gt;自定义数量后，进行虚拟分组，虚拟分组的策略也可进行自定义，然后随机筛选一组进入负载均衡。此时进入负载均衡的实例数量就会有倍数的下降。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">需要注意的是分组路由必须保证是在路由链的最后一环，否则会导致其他路由计算错误。</p></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.37984496124031" data-s="300,640" src="https://oscimg.oschina.net/oscnet/9ad0f113-9f91-4397-9e60-71b4b03e349f.png" data-type="png" data-w="645" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">分组路由示意</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * </span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers 待分组实例列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> groupNum 分组数量</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span></span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; doGroup(List&lt;Invoker&lt;T&gt;&gt; invokers, <span class="code-snippet__keyword">int</span> groupNum) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> listLength = invokers.size() / groupNum;</span></code><code><span class="code-snippet_outer">        List&lt;Invoker&lt;T&gt;&gt; result = <span class="code-snippet__keyword">new</span> ArrayList&lt;&gt;(listLength);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> random = ThreadLocalRandom.current().nextInt(groupNum);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = random; i &lt; invokers.size(); i = i + groupNum) {</span></code><code><span class="code-snippet_outer">            result.add(invokers.get(i));</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>五、优化效果</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">针对优化前和优化后，我们编写 Demo 工程分别压测了不配置路由/配置就近+标签路由场景。Provider 节点梯度设置 100/500/1000/2000/5000，TPS 在 1000 左右，记录了主机的 cpu 等性能指标，并打印火焰图。发现，配置路由后，采用相同并发，优化后的版本 tps 明显高于优化前版本，且新版本相较于没有配置路由时 tps 显著提高，下游节点数大于 2000 时，tps 提升达到 100% 以上，下游节点数越多，AvgCpu 优化效果越明显，并且路由及负载均衡 CPU 占比明显更低，详细数据可见下表：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.5994694960212201" data-s="300,640" src="https://oscimg.oschina.net/oscnet/1321713f-e488-4248-8ead-3e1db6f52543.png" data-type="png" data-w="754" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.7027777777777777" data-s="300,640" src="https://oscimg.oschina.net/oscnet/be116887-8e9c-4e6f-ba48-b83efffe2464.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">备注：-tag，表示显式禁用原生 Dubbo 应用级标签路由。该路由默认开启。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>六、总结</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">经过我们关闭不必要的路由逻辑、对路由缓存+异步化计算、新增分组路由等优化后，Dubbo 在负载均衡及路由模块整体的性能有了显著的提升，为业务方节省了不少 CPU 资源。在正常业务场景下当提供方数量达到 2000 及以上时，tps 提升可达 100% 以上，消费方平均 CPU 使用率下降约 27%，且提供方数量越多优化效果越明显。但是我们也发现当前的随机负载均衡依然还是会消耗一定的 CPU 资源，且只能保证流量是均衡的。当前我们的应用基本部署在虚拟机及容器上。这两者均存在超卖的状况，且同等配置的宿主机性能存在较大差异等问题。最终会导致部分请求超时、无法最大化利用提供方的资源。我们下一步将会引入 Dubbo 3.2 的自适应负载均衡并进行调优减少其 CPU 使用率波动较大的问题，其次我们自身也扩展了基于 CPU 负载均衡的单一因子算法，最终实现不同性能的机器 CPU 负载趋于均衡，最大程度发挥集群整体的性能。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="color: rgb(65, 95, 255);" powered-by="xiumi.us"><p style="text-wrap: wrap;">参考资料：</p></section><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;" powered-by="xiumi.us"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Fload-balance%2F" textvalue="Dubbo 负载均衡" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 负载均衡</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Ftraffic%2F" textvalue="Dubbo 流量管控" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 流量管控</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU4NzU0MDIzOQ%3D%3D%26mid%3D2247511003%26idx%3D3%26sn%3Defdf3f42790b74226b2ed45b701a6749%26scene%3D21%23wechat_redirect" textvalue="Dubbo 3 StateRouter：下一代微服务高效流量路由" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 3 StateRouter：下一代微服务高效流量路由</span></a></p></li></ol><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;"><section style="text-align: center;color: rgb(45, 66, 87);font-size: 11px;" powered-by="xiumi.us"><p>END</p></section></section><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: left;" powered-by="xiumi.us"><section style="padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;"><span style="display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);" title="" opera-tn-ra-cell="_$.pages:0.layers:0.comps:159.title1"><p>猜你喜欢</p></span></section><section style="border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;"><section style="font-size: 14px;text-align: left;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497343%26idx%3D1%26sn%3D959b66ceb9a8c2fe060b6981b41a807e%26chksm%3Debdb86eddcac0ffb229636ec51ec94433af75c7bc58aaa5ae52b4a2bf6a2d6d2ab11583b3174%26scene%3D21%23wechat_redirect" textvalue="记一次 Redis Cluster Pipeline 导致的死锁问题" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">记一次 Redis Cluster Pipeline 导致的死锁问题</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D1%26sn%3D5795a683e52f70384a13b34aa3daf731%26chksm%3Debdb8632dcac0f2468a461db09d8de6219af346e51436b91e6c946ee8b37e6ae8175b2f5d55e%26scene%3D21%23wechat_redirect" textvalue="深入理解 Netty FastThreadLocal" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">深入理解 Netty FastThreadLocal</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497336%26idx%3D1%26sn%3D777059b19e224f1a4fbb1550ad1de7e8%26chksm%3Debdb86eadcac0ffc78dc019c5685ad137fdddd6572238525d707152c102790f82917a473d52a%26scene%3D21%23wechat_redirect" textvalue="MySQL 到 TiDB：Hive Metastore 横向扩展之路" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">MySQL 到 TiDB：Hive Metastore 横向扩展之路</a></p></li></ul></section></section></section></section><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互联网技术" data-alias="vivoVMIC" data-signature="分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 02:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10136865</guid>
            <link>https://my.oschina.net/vivotech/blog/10136865</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌开放 .ing 顶级域名注册]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Google <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.google%2Fproducts%2Fregistry%2Fintroducing-the-ing-top-level-domain%2F" target="_blank">宣布开放 .ing 顶级域名注册</a></u>，即日起用户可通过<strong>支付额外费用（费率随时间推移降低）的方式抢先注册</strong>，抢先体验期 (EAP) 截至 12 月 5 日。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1101/104932_JmaT_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>Google 表示借助该域名企业可以注册一些非常有趣的域名，比如在线设计和绘图平台 Canva 注册的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdesign.ing%2F" target="_blank">design.ing</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdraw.ing%2F" target="_blank">draw.ing</a>、Adobe Acrobat 注册的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fedit.ing%2F" target="_blank">edit.ing</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsign.ing%2F" target="_blank">signing</a>&nbsp;等。</p><p>.ing 域名注册地址：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fget.ing%2F" target="_blank">https://get.ing/</a></u></p><p><img height="1676" src="https://static.oschina.net/uploads/space/2023/1101/105256_D6p3_2720166.png" width="3310" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 02:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264406/the-ing-top-level-domain</guid>
            <link>https://www.oschina.net/news/264406/the-ing-top-level-domain</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[深圳一公司奖励程序员「黄金键帽」，价值近 2 万元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 10 月 24 日，被众多科技公司和业内人士称为「程序员节」。当天，深圳一公司奖励员工「<strong>黄金键帽</strong>」。</p><blockquote><p><img height="1658" src="https://static.oschina.net/uploads/space/2023/1031/185140_pBn0_2720166.png" width="1176" referrerpolicy="no-referrer"></p></blockquote><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F5558240479%2FNpm9Lffdj%3Fpagetype%3Dprofilefeed" target="_blank">据称</a></u>这款空格键键帽是 40g 黄金，价值近 2 万元。</p><p><img src="https://static.oschina.net/uploads/space/2023/1031/185850_Wq96_2720166.png" referrerpolicy="no-referrer"></p><p><em>△「黄金 C 键」是该公司去年的奖励</em></p><p>获得奖励程序员根据代码行数排名和部门推举共同选出，最具分量的「黄金空格键」奖励给有效代码量最多的程序员。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 10:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264307</guid>
            <link>https://www.oschina.net/news/264307</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[前三季度互联网企业利润总额同比增 18.2%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年前三季度互联网和相关服务业运行情况现已公布。前三季度，互联网业务收入增速小幅提升，利润总额较快增长，研发经费持续下滑。</p><h4 style="margin-left:0px; margin-right:0px"><strong>一，总体运行情况</strong></h4><p><strong>互联网业务收入增速小幅提升。</strong>前三季度，我国规模以上互联网和相关服务企业 1（以下简称互联网企业）完成互联网业务收入 10294 亿元，同比增长 3.4%。</p><p><img height="241" src="https://oscimg.oschina.net/oscnet/up-505b65f84338dd716295e76b74112009b70.png" width="500" referrerpolicy="no-referrer"></p><p><strong>利润总额较快增长。</strong>前三季度，我国规模以上互联网企业营业成本同比增长 7%，增速较上半年回落 0.4 个百分点。实现利润总额 959.3 亿元，同比增长 18.2%。</p><p><img height="239" src="https://oscimg.oschina.net/oscnet/up-54642fdf1ae20d26f1bc9494e46da1f4440.png" width="500" referrerpolicy="no-referrer"></p><p><strong>研发经费持续下滑。</strong>前三季度，我国规模以上互联网企业共投入研发经费 495.9 亿元，同比下降 6.1%。</p><p><img height="246" src="https://oscimg.oschina.net/oscnet/up-d14b35b6a1179d07e10ffc542ff0150925e.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px"><strong>二，分领域运行情况</strong></h4><p style="margin-left:0; margin-right:0"><strong>（一）信息服务领域企业收入小幅回落。</strong>前三季度，以信息服务为主的企业（包括新闻资讯、搜索、社交、游戏、音乐视频等）互联网业务收入同比下降 2.7%。</p><p><strong>（二）生活服务领域企业收入较快增长。</strong>前三季度，以提供生活服务为主的平台企业（包括本地生活、租车约车、旅游出行、金融服务、汽车、房屋住宅等）互联网业务收入同比增长 9.8%。</p><p><strong>（三）网络销售领域企业收入增速持续提升。</strong>前三季度，主要提供网络销售服务的企业（包括大宗商品、农副产品、综合电商、医疗用品、快递等）互联网业务收入同比增长 47.3%。</p><h4 style="margin-left:0px; margin-right:0px"><strong>三，分地区运行情况</strong></h4><p><strong>东部地区互联网业务收入保持平稳增速。</strong>前三季度，东部地区完成互联网业务收入 9613 亿元，同比增长 4.5%，增速较上半年提升 0.7 个百分点，占全国互联网业务收入的比重为 93.4%。中部地区完成互联网业务收入 329.5 亿元，同比下降 9.7%，降幅较上半年扩大 2.2 个百分点。西部地区完成互联网业务收入 325 亿元，同比下降 7.5%，降幅较上半年收窄 3.2 个百分点。东北地区完成互联网业务收入 26.5 亿元，同比下降 33.3%，降幅较上半年收窄 6.4 个百分点。</p><p><img height="239" src="https://oscimg.oschina.net/oscnet/up-7b7896fe852aa2c94820a864e846f80cae2.png" width="500" referrerpolicy="no-referrer"></p><p><strong>长三角地区互联网业务收入实现较快增长。</strong>前三季度，京津冀地区完成互联网业务收入 3948 亿元，同比增长 2.9%，增速较上半年回落 0.3 个百分点，占全国互联网业务收入的比重为 38.4%。长三角地区完成互联网业务收入 4225 亿元，同比增长 13.1%，增速较上半年提升 3.5 个百分点。</p><p><img height="300" src="https://oscimg.oschina.net/oscnet/up-f6cddc5c38e933857b00b43bd049054bd02.png" width="500" referrerpolicy="no-referrer"></p><p><strong>半数地区互联网业务增速实现正增长。</strong>前三季度，互联网业务累计收入居前 5 名的北京（增长 0.7%）、上海（增长 17.7%）、浙江（增长 5.1%）、广东（下降 7.4%）和天津（增长 22.3%）共完成业务收入 9077 亿元，同比增长 5.5%，占全国比重达 88.2%。全国互联网业务增速实现正增长的省（区、市）有 15 个。</p><p><img height="243" src="https://oscimg.oschina.net/oscnet/up-d691bf5c06989113a27d8f6cf4a88d4ab6e.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px"><strong>四，我国移动应用程序（APP）发展情况</strong></h4><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">根据全国 APP 技术检测平台统计，截至 9 月底，我国国内市场上监测到活跃的 APP 数量 2 为 261 万款（包括安卓和苹果商店）。移动应用开发者数量为 84 万，其中安卓开发者为 26 万，苹果开发者为 58 万。9 月份，安卓应用商店在架应用累计下载量 542 亿次。</p><p><span style="color:#888888">附注：</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#888888">1.规模以上互联网和相关服务企业口径由上年互联网和相关服务收入 500 万元以上调整为 2000 万元及以上，文中所有同比增速均按可比口径计算。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#888888">2.活跃的移动应用程序数量是指报告期内我国市场上经过用户主动下载安装的第三方移动应用的总个数，其中安卓应用数的计算方法是根据智能手机记录的已安装移动应用去重后获得。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 10:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264303</guid>
            <link>https://www.oschina.net/news/264303</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[阿里云人工智能 + 大数据平台升级发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>大模型和 MaaS 概念的出现，定义了以模型为中心的一整套 AI 开发新范式，而这背后日益增长的巨大算力需求，对 AI 工程底座提出了新的挑战。今天，大模型时代下的人工智能+大数据平台，需要具备计算效率、开发效率、处理效率为一体的高效能力，才能保障服务 AI 时代下的业务创新。10 月 31 日，2023 云栖大会上，阿里云副总裁、阿里云计算平台事业部负责人汪军华宣布<strong>阿里云人工智能+大数据平台升级发布，以服务大模型时代下各行各业的业务创新</strong>。</p><h2>高性能的 AI 基础设施，让计算效率达到极致</h2><p>根据 OpenAI 测算，全球用于头部 AI 模型训练的算力需求以每年 10 倍的速度增长，计算需求处于持续爆发中。汪军华介绍，PAI 灵骏智算集群在网络、存储、调度上做了深度优化，采用 HPN 7.0 新一代 AI 集群网络架构，存储计算分离架构，<strong>支持高达 10 万卡量级的集群可扩展规模，让超大规模集群像 1 台计算机般运转</strong>。</p><p>软硬一体的智算服务 PAI 灵骏，为大规模深度学习训练场景提供稳定和高效的支撑，大模型训练任务线性加速比可达到 96%，大模型训练资源可节省超 50%。在稳定性保障方面，PAI 灵骏智算服务配置了弹性容错训练框架 AIMaster 和 EasyCkpt 模型自动保存与恢复能力，可让千卡规模任务稳定运行 3 周以上。</p><p>面向大模型的推理服务场景，PAI 体系化地整合模型系统联合优化、运行时优化、LLM 领域优化等能力，可将大语言模型推理吞吐提升 3.5 倍，大幅降低推理时延。单卡推理可支持的最大上下文长度达 280K，超长的上下文推理将进一步推动 LLM 涌现。</p><h2>多形态、更灵活的 AI 开发模式，支撑多样化需求</h2><p>随着需求的不断涌现，AI 开发者和 AI 开发需求越发细分。<strong>人工智能平台 PAI 4.0 发布，全面降低大模型 AI 开发门槛，提供完善的需求支撑，提升开发效率</strong>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3b95e15dfa6b87444fc3e282b13714f002c.jpg" alt="" referrerpolicy="no-referrer"></p><p>不论是需要定义模型结构和开发流程的深度学习开发者群体，还是有海量大规模计算任务的群体，亦或是需要高效快速串联起训练推理任务的业务算法群体，都可以通过 PAI 来实现研发，包含各类热门的计算框架、开源模型和开发场景，一站式地完成开发部署。</p><p>PAI 灵积为广大开发者提供了通过云上 API 服务，可以用于应用模型开发和开发好的模型调用，允许开发者将大模型能力迅速集成到自己的业务和应用中，在 PAI-灵积平台上，开发者不仅可以找到通义系列大模型（包括通义千问，通义万相等等），也可以找到来自业界最优秀的头部大模型，包括 ChatGLM，百川，Stable Diffusion 等。</p><p>汪军华宣布，今天这些模型都<strong>通过 PAI 灵积上统一的 API 和 SDK 对广大开发者开放</strong>，开发者只需要几行代码，就能迅速把这些不同类别的大模型的能力，集成到自己的应用中去。</p><h2>高效的数据服务提升大模型效果，大数据和 AI 更深融合</h2><p>在机器学习开发过程中，80% 的研发时间有用于数据准备，数据质量决定着大模型的效果，数据处理分析的重要性更加凸显。大数据作为 AI 基础设施的一部分，阿里云提供了从数据积累、清洗、建模、计算到服务的全套产品化方案，来节省 AI 开发过程中数据准备的时间。</p><p>同时，大数据和 AI 进行了更深度的融合。阿里云自研大数据处理平台 MaxCompute 全面升级 DataFrame 能力，<strong>发布分布式计算框架 MaxFrame，100% 兼容 Pandas 等数据处理接口</strong>，一行代码即可将原生 Pandas 自动转为 MaxFrame 分布式计算，打通数据管理、大规模数据分析、处理到 ML 开发全流程，打破大数据及 AI 开发使用边界，大大提高开发效率。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1b1ceca672616e6e79a2adf7ef338570215.jpg" alt="" referrerpolicy="no-referrer"></p><p>大模型驱动的 AI 时代，AI 场景对数据时效性的要求也越来越高，Flink+Paimon 新一代实时湖仓方案，为用户提供一站式数据入湖、实时加工和探查分析能力，拓展 Flink 在数据湖场景的实时计算能力，同时加速 AI 应用。</p><p>全托管向量检索服务 DashVector 正式发布，基于阿里云自研 8 年的高性能向量检索内核 Proxima，提供具备水平拓展能力的云原生、全托管的向量检索服务。Hologres、OpenSearch、Elasticsearch 分别升级了向量能力，满足不同场景下性能的提升。全新发布 DataWorks Copilot，将大数据平台的一站式统一元数据、统一调度、统一数据集成、统一数据建模与 AI 大模型能力全面结合， 将 AI 与业务充分融合，创造新价值。</p><p>在面向大模型时代整体大数据 AI 产品能力升级后，汪军华宣布<strong>大数据 AI 产品全面完成 Serverless 化</strong>，致力于给客户提供开箱即用、按需付费的高性价比产品。作为大模型时代 AI 的基础设施，阿里云人工智能+大数据平台将坚定、持续的投入研发资源，服务各行各业的业务创新。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 09:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5583868/blog/10140082</guid>
            <link>https://my.oschina.net/u/5583868/blog/10140082</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[飞致云开源社区 10 月动态报告]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#000000; text-align:start"><span><span style="color:#000000">自 2023 年 6 月起，中国领先的开源软件公司 FIT2CLOUD 飞致云以月度为单位发布《飞致云开源社区月度动态报告》，旨在向广大社区用户同步飞致云旗下系列开源软件的发展情况，以及当月主要的产品新版本发布、社区运营成果等相关信息。</span></span></p><p style="color:#000000; text-align:start"><span><strong><span style="color:#00355d">飞致云开源大屏（2023 年 10 月）</span></strong></span></p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-a09815ae51a7ff491a27bae6b2bf1cdf0c7.png" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:start"><span>▲图 1 飞致云开源大屏（2023.10.31 12:00）</span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">2023 年 10 月飞致云开源软件运营数据概览（统计时间为 2023.10.1～2023.10.31）：</span></span></p><p style="color:#000000; text-align:start"><img alt="" height="782" src="https://oscimg.oschina.net/oscnet/up-04d7820369e349de560cad38d0758a8c526.png" width="1388" referrerpolicy="no-referrer"></p><p style="color:#000000"><strong><span style="color:#3370ff">2023 年 10 月产品发布事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 开源建站工具</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 10 日，Halo 开源建站工具正式发布 v2.10.0 版本。在这个版本中，Halo 主要支持了消息通知、内置应用市场等功能，并且完成了其他 30 多项功能优化和问题修复。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 1Panel 开源面板</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 16 日，现代化、开源的 Linux 服务器运维管理面板 1Panel 正式发布 v1.7.0 版本。</p><p style="color:#000000; text-align:start">在这个版本中，1Panel 新增 Node.js 运行环境；新增系统缓存清理功能；应用安装时支持选择远程数据库。此外，我们进行了 40 多项功能更新和问题修复。1Panel 应用商店新增了 2 款应用，并且更新了 25 款应用。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ JumpServer 开源堡垒机</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 23 日，JumpServer 开源堡垒机正式发布 v3.8.0 版本。</p><p style="color:#000000; text-align:start">在这一版本中，JumpServer 在「用户登录」和「资产登录」这两个权限控制功能中，新增「通知」动作。目前其支持的动作包括拒绝、接受、审批以及通知四种动作，方便了管理员针对不同的用户及资产使用需求进行配置。同时，在使用 KoKo 组件连接字符集类型的资产时，JumpServer 支持持久化主题配置，解决了用户需要经常手动修改主题的问题。</p><p style="color:#000000; text-align:start">作业中心方面，用户执行命令时支持自定义执行目录，方便用户在合适的上下文环境中执行命令。另外，在使用 Web GUI 方式连接数据库时，用户可以对查询集进行保存操作，JumpServer 会对查询集以「CSV」格式下载后提供给用户。</p><p style="color:#000000; text-align:start">X-Pack 增强包方面，JumpServer v3.8.0 版本支持纳管 DB2 数据库（IBM 旗下关系型数据库），方便管理员对此类数据库进行纳管，以满足用户在数据库纳管方面的多样化需求。在之前的版本中，JumpServer 支持在页面上简单对接无认证类型的短信网关。在新版本中，JumpServer 支持用户通过编写自定义短信文件的方式，与用户的短信网关环境进行交互，从而实现发送短信验证的功能。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ MeterSphere 开源持续测试平台</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 30 日，MeterSphere 一站式开源持续测试平台正式发布 v2.10.8 LTS 版本。自 2023 年 5 月发布 v2.10 LTS 版本后，MeterSphere 开源项目组坚持发布小版本，持续进行问题的修复更新，并针对部分功能进行优化。</p><p style="color:#000000; text-align:start">本次发布的 MeterSphere v2.10.8 LTS 版本在性能测试模块对压测报告进行功能增强，同时测试执行机新增运行状态和 CPU 监控。</p><p style="color:#000000"><strong><span style="color:#3370ff">其他重要事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ FIT2CLOUD 飞致云九周年</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 21 日，FIT2CLOUD 飞致云度过了九周岁生日。新的一年，飞致云的口号是「只争朝夕，成为三高」。感谢每一位用户、客户、合作伙伴、员工、股东，我们将加速成长，为数字经济时代创造好软件。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 飞致云及其旗下 1Panel 进入 2023 年第三季度最具成长性开源初创榜单</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 26 日，知名风险投资机构 Runa Capital 发布了 2023 年第三季度 ROSS 指数（Runa Open Source Startup Index）。ROSS 指数按季度汇总并公布在代码托管平台 GitHub 上年化增长率（AGR）排名前二十位的开源初创公司和开源项目。</p><p style="color:#000000; text-align:start">在这份名为《Top trending early-stage open-source startups by GitHub star growth in Q3 2023》的榜单中，FIT2CLOUD 飞致云及其旗下的 1Panel 开源面板项目入选。这也是 FIT2CLOUD 飞致云及其旗下开源项目连续第二个季度进入 ROSS 指数相关榜单。</p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-4e76c989b3aaeb4b049167ebe4867d1f213.png" referrerpolicy="no-referrer"></p><p style="color:#000000">▲图 2 《Top trending early-stage open-source startups by GitHub star growth in Q3 2023》榜单</p><p style="color:#000000; text-align:start"><span><strong><span style="color:#00355d">关于飞致云开源大屏</span></strong></span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">飞致云开源大屏（</span></span><em><span><span style="color:#000000">https://bi.fit2cloud.com/link/6CgpMHrT</span></span></em><span><span style="color:#000000">）</span><span style="color:#3e3e3e">是 FIT2CLOUD 飞致云为展示其旗下开源软件的社区运营情况制作的数据仪表板。该大屏使用 DataEase 开源数据可视化分析平台制作，实时呈现飞致云开源社区近 30 日内的动态信息。</span></span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">广大社区用户可以通过该大屏了解飞致云旗下开源项目的 GitHub Star、Fork、Issue、贡献者等指标的数量信息，以及近 30 日内新增的 Star、Fork、下载、Issue、PR 数量等，同时该大屏还展示了飞致云旗下开源项目的 Issue 趋势、Commit 趋势、PR 趋势、Issue 生命周期等。</span></span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">除了展示所有项目的汇总信息外，该大屏还支持用户分类别查看 JumpServer、DataEase、MeterSphere、Halo、1Panel、CloudExplorer Lite 六个开源项目的独立运营数据。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 08:53:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4736111/blog/10140016</guid>
            <link>https://my.oschina.net/u/4736111/blog/10140016</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[从 0 到 1 入门用户画像掌握大数据技术]]>
            </title>
            <description>
                <![CDATA[<h1 class="header article-title"><a href="https://www.oschina.net/question/4855753_2331281">高手问答第 308 期 ——从 0 到 1 入门用户画像掌握大数据技术</a><div class="ui red label horizontal" data-tooltip="置顶">顶</div></h1><div class="extra ui horizontal list meta-wrap"><div class="item"><a href="https://my.oschina.net/u/4855753" class="__user"><span>OSC 哒哒</span></a><span class="org-label org-label--simple primary" data-tooltip="认证官方账号"><i class="oicon oicon-org"></i></span> 发布于，昨天 12:14
                    </div><div class="item">阅读 1K+</div><div class="item collect-btn " data-id="2331281" data-user-id="4855753" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i> 收藏 <span data-collect-count="" data-id="2331281" data-obj-type="2">5</span></div><div class="item comment-count"><a href="https://www.oschina.net/question/4855753_2331281#comments" class="normal"><i class="comment outline icon"></i> 答案 <span data-article-reply-count="">2</span></a></div></div><div class="tags"><a class="ui horizontal label" href="https://www.oschina.net/question/topic/masteronline" target="_blank"><img src="https://static.oschina.net/uploads/logo/masteronline_9WTeU.png" referrerpolicy="no-referrer">高手问答</a></div><div class="content" id="articleContent"><div><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>市面上不少公司都在做用户画像的相关工作，无论是电商行业、金融行业、视频行业等等，都有这样的产品。那到底怎么去定义用户画像呢？</span></span></span></span></span></span></span></span></span></span></span></div><div>
  &nbsp; 
</div><div><strong>OSCHINA 本期高手问答 (10 月 31 日 - 11 月 6 日) 我们请来</strong><strong>了嘉宾&nbsp;</strong><strong><span style="color:#000000"><a href="https://my.oschina.net/u/4294800" rel="nofollow">诸葛子房</a>老师&nbsp;</span></strong><strong>来和大家一起探讨关于从 0 到 1 入门用户画像掌握大数据技术的问题。</strong></div><div>
  &nbsp; 
</div><div><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>可讨论的问题包括但不限于：</span></span></span></span></span></span></span></span></span></span></span></p><ul><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>想入门用户画像需要掌握哪些技术栈？</span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>没有企业的大量用户或者行为数据，普通用户该如何真实地模拟企业级的画像项目？</span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>程序员如何入门大数据？</span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>大数据</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>行业都有哪些职位，以及在公司中发挥的作用如何</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>？</span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>大数据行业未来的发展如何，以 ChatGPT&nbsp;为代表的 AI 浪潮是否会让大数据行业走向</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>没落</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>？</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>有其他相关问题，也欢迎大家积极提问！</span></span></span></span></span></span></span></span></span></span></span></p><hr><h2>嘉宾介绍</h2><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>段小秋，网名：诸葛子房，先后就职于京东和 BAT，在大数据领域有多年工作经验，也是多个 Apache&nbsp;项目的贡献者。蓝桥杯蓝桥云课《用户画像案例精讲》专栏作者，也是开源项目 DataCompare&nbsp;作者。</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>微信</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>：zhugezifang001，欢迎交流沟通。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>个人</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>主页：</span></span></span></span></span></span></span></span><a href="https://gitee.com/ZhuGeZiFang" rel="nofollow"><span><span><span><u><span style="color:#1e6fff"><span><span>https://gitee.com/ZhuGeZiFang</span></span></span></u></span></span></span></a></span></span></span></p><p><img height="639" src="https://oscimg.oschina.net/oscnet/up-5e58f5cf142af8e6ec1a3b8c3dc1cef16ec.png" width="500" referrerpolicy="no-referrer"></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>为了鼓励踊跃提问，会在问答结束后从提问者中抽取&nbsp;5&nbsp;名幸运会员赠予《</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>用户画像案例精讲》专栏电子版！</span></span></span></span></span></span></span></span></span></span></span></p><p><img height="516" src="https://oscimg.oschina.net/oscnet/up-71771b786f7cc1bd0161793b6af70daf066.png" width="310" referrerpolicy="no-referrer"></p><p><img height="574" src="https://oscimg.oschina.net/oscnet/up-c2d9d9ce8dd66a412d3ef791ee45548dc45.png" width="311" referrerpolicy="no-referrer"></p></div><div><div><hr><h4><span><span><span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>用户</span></span></span></span></strong></span></span></span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>画像概念</span></span></span></span></strong></span></span></span></span></span></span></h4><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>用户画像，即：用标签的方式去描述一个人或者一台手机、一台电脑，有些公司称之为」用户画像「，有一些公司称之为」用户特征「，其实是一个意思。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>举个简单的例子：</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>袁小青，性别：女，年龄：22 岁，职业：时尚编辑，爱好：音乐、拍照，居住地：北京，消费情况：年薪 10w，喜欢的 app：抖音</span></span></span></span></span></span></span></span></span></span></span></p><p><img height="310" src="https://oscimg.oschina.net/oscnet/up-d3e2ad6f2150ece5dd0882380562cb797a7.png" width="488" referrerpolicy="no-referrer"></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>因此我们概念中描述的用户画像，其实是用标签的方式对于一个用户、一个账号、一部手机进行描述。</span></span></span></span></span></span></span></span></span></span></span></p><p><img height="368" src="https://oscimg.oschina.net/oscnet/up-adc4c1c21829279233af14e8d74631dfab4.png" width="400" referrerpolicy="no-referrer"></p><h4><span><span><span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>用户画像常见标签</span></span></span></span></strong></span></span></span></span></span></span></h4><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>既然上面讲到了对于用户进行标签化，那究竟要给用户打哪些标签呢？如何对标签进行分类呢？</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>用户</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>画像核心标签以及其分类：</span></span></span></span></span></span></span></span></span></span></span></p><p><img height="589" src="https://oscimg.oschina.net/oscnet/up-9efa6c4c17cb0bd2647c8d303db9def85cc.png" width="868" referrerpolicy="no-referrer"></p><h4><span><span><span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>用户画像的作用</span></span></span></span></strong></span></span></span></span></span></span></h4><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>1. 个性化推荐</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>在使用一些社区产品、电商产品、短视频 app、音乐 app 的时候，经常会遇到推荐的场景，根据不同的人推荐不同的内容或者商品。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>这其实是用户画像其中的一个应用，根据用户查询用户的标签数据，来进行推荐用户感兴趣的内容</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>2. 营销圈选 (短信营销、PUSH 营销)</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>相信不少用户收到过类似的营销短信，或者一些 app&nbsp;弹窗，这个也是用户画像常见的应用场景</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>3. 策略引擎</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>根据用户的标签展示不同页面，比如说：北京地区的用户能才能领取北京的优惠券，以及只有高消费值的用户才有淘宝上奢侈品 Luxury 入口的界面。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>4. 算法模型</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>算法模型的训练，比如说：推荐模型、广告模型，需要用到画像数据来优化推荐模型。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>5. 画像报告</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>不少商业公司会出一些行业报告，比如说下图的小红书、锁屏 app&nbsp;的行业画像报告；还有我们经常看到的一些个人年度榜单。</span></span></span></span></span></span></span></span></span></span></span></p><h4><span><span><span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>大数据技术在用户画像中的实际应用</span></span></span></span></strong></span></span></span></span></span></span></h4><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>由于</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>画像涉及到的一些行为数据，包括用户购物行为、观影行为，一些较为大型一些的公司数据日均都涉及 PB，因此需要处理的数据量非常大。在其中就会用到一些大数据的处理和存储技术，比如说：Hadoop、Spark、Hbase&nbsp;等等。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>同时随着业务发展，一些广告和推荐场景对于实时需求也更加明显，所以实时数据处理领域，Flink、Kafka 等实时相关技术领域也越来越重要了。</span></span></span></span></span></span></span></span></span></span></span></p><hr><div><p><span style="background-color:#ffffff; color:#27ae60">OSChina 高手问答一贯的风格，不欢迎任何与主题无关的讨论和喷子。</span></p><p>下面欢迎大家就<span>用户画像和大数据技术相关</span>问题向&nbsp;<strong><span style="color:#000000"><a href="https://my.oschina.net/u/4294800" rel="nofollow">诸葛子房</a></span></strong><span style="color:#000000">老师</span><strong><span style="color:#000000">&nbsp;</span></strong>提问，直接回帖提问既可。</p></div></div></div></div><div class="poll-wrap"></div><div class="additional-remarks"></div><div class="ui basic center aligned segment action"><div class="ui big buttons"><a class="ui basic button collect-btn hover" data-id="2331281" data-user-id="4855753" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i>收藏 (<span data-collect-count="" data-id="2331281" data-obj-type="2">5</span>)</a><div class="ui basic dropdown share button osc-share dropdown-share" data-tag="share-question"><i class="share icon"></i><span>分享</span><div class="menu"><a class="item" data-platform="weibo" data-value="weibo"><i class="weibo icon"></i>微博</a><a class="item" data-platform="qq" data-value="qq"><i class="qq icon"></i>QQ</a><a class="item" data-platform="wechat" data-value="wechat"><i class="weixin icon"></i>微信</a></div></div></div><div class="ui basic segment"><a class="ban" ban-report="" data-id="2331281" data-obj-type="2" data-url="https://www.oschina.net/question/4855753_2331281"><i class="flag red icon"></i>举报</a></div></div>
            ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 08:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/question/4855753_2331281</guid>
            <link>https://www.oschina.net/question/4855753_2331281</link>
        </item>
        <item>
            <title>
                <![CDATA[周热点 | jQuery 4.0 开发进度已完成 99%；小米澎湃 OS 发布，底层全部重构；Windows CE 彻底退役]]>
            </title>
            <description>
                <![CDATA[回顾一周热门资讯。2023.10.23-2023.10.30]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 08:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649093911&#38;idx=1&#38;sn=38b44f9a65152bbed03e505898027c84&#38;chksm=880c4c04bf7bc5125fe5e1f37886dd58c9c3f9f4b518505968df48e895efa0321de097a67ea3&#38;token=1144339677&#38;lang=zh_CN#rd</guid>
            <link>https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649093911&#38;idx=1&#38;sn=38b44f9a65152bbed03e505898027c84&#38;chksm=880c4c04bf7bc5125fe5e1f37886dd58c9c3f9f4b518505968df48e895efa0321de097a67ea3&#38;token=1144339677&#38;lang=zh_CN#rd</link>
        </item>
        <item>
            <title>
                <![CDATA[openKylin Wine 助手正式上线，公测活动开启]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span>为提供用户更好的 Windows 应用程序安装和使用体验，openKylin 社区 CompatWinApp SIG 组基于 Wine 开源软件设计了一款<strong>集软件展示、下载、安装、管理等功能于一体</strong>的桌面软件—<strong><span style="color:#0052ff">openKylin Wine 助手</span></strong>！</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">现邀请所有社区用户参与本次公测活动，参与就有机会获得社区定制奖品哦～</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#0b43d1">openKylin Wine 助手介绍</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>openKylin Wine 助手基于 Wine 提供的 Windows 应用运行环境，为用户提供软件展示、下载、安装、管理等功能，可以让用户在 openKylin 系统上方便地下载、安装和使用 Windows 应用程序。其主界面如下图所示：</span></p><div><p style="text-align:center"><img alt="" height="1080" src="https://oscimg.oschina.net/oscnet/up-3473471a2b0b0cd75b757a441c879110017.png" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><ul><li><span>openKylin Wine 助手首先从应用配置仓库和依赖配置仓库下载配置文件。随后，将应用程序展示在窗口中，当用户点击应用程序后面的安装按钮，openKylin Wine 助手就会根据配置信息下载相应用的应用程序和依赖，并最终调用 Wine 进行安装。</span></li><li><span>安装后，应用程序后面的按钮会变成启动按钮，点击启动按钮后，openKylin Wine 助手会调用 Wine 启动该应用。完整过程如下图所示：</span></li></ul><div><p style="text-align:center"><img alt="" height="550" src="https://oscimg.oschina.net/oscnet/up-82094adb9094dfb452b1626fee75d859371.jpg" width="948" referrerpolicy="no-referrer"></p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#0b43d1">公测活动介绍</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#79d7ff">活动时间</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#333333"><span style="background-color:#fffbf2">2023 年 10 月 31 日—2023 年 11 月 30 日</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#79d7ff">参与方式</span></span></strong></span></p><h1>1.下载安装 openKylin Wine 助手</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>目前，CompatWinApp SIG 组已发布 X86 平台的 openKylin Wine 助手，下载体验地址如下：</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#0052ff">https://gitee.com/openkylin/compat-winapp/releases/tag/1.0.2-beta.20230928</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><em><span><span style="color:#ce2a1b">备注：安装说明见压缩包里的 readme 文件</span></span></em></p><h1>2.签署 CLA，参与公测</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>参与公测的用户请在 openKylin 系统上安装使用 openKylin Wine 助手，将使用过程中遇到的 bug 问题或优化建议以 issue 方式提交到如下地址：</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#0052ff">https://gitee.com/openkylin/win-program/issues</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><em><span><span style="color:#ce2a1b">注意：在参与公测前，请大家签署 openKylin 社区贡献者许可协议，如若未签署，则参与成绩无效。CLA 签署网址：</span></span></em><br><span><span style="color:#0052ff"><span>https://cla.openkylin.top/</span></span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#79d7ff">奖品设置</span></span></strong></span></p><p style="margin-left:0px; margin-right:0px; text-align:justify">CompatWinApp SIG 组会统计活动期间所有在仓库反馈的问题和需求建议，根据每个问题和需求的重要程度进行打分，分数总和越高排名越靠前。截至 2023 年 11 月 30 日，积分排名前 10 的小伙伴可获得 openKylin 纪念品礼包一份（polo 衫+笔本套装），评选结果将由社区在 7 个工作日内公布至 openKylin 论坛。</p><div><p style="text-align:center"><img alt="" height="410" src="https://oscimg.oschina.net/oscnet/up-b5c4b5d8b275e4d43d5af75c36e3b105e17.png" width="940" referrerpolicy="no-referrer"></p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#79d7ff">评分规则</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>由 CompatWinApp SIG 组分别从<strong>需求、问题、清晰度</strong>三个维度进行评分。</span></p><ul><li><span><strong>需求</strong>：对需求进行评级，分别为高、中、低三个等级，高等级 3 分，中等级 2 分，低等级 1 分。</span></li><li><span><strong>问题</strong>：对于遇到的问题或者 bug 进行评级，分别为严重、主要、次要、不重要四个等级，对应的分数分别为 3 分、2 分、1 分、0.5 分。</span></li><li><span><strong>清晰度</strong>：对需求和 bug 的清晰度进行评级，分为高中低三个等级，高清晰度会在其原分数上+0.2 分，中清晰度不做分数调整，低清晰度会在其原分数基础上-0.2 分。</span></li></ul><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:center"><span><strong><span style="color:#000000">还在等什么，赶快行动起来吧~</span></strong></span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264400</guid>
            <link>https://www.oschina.net/news/264400</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[通义千问 APP 上线，通义千问 720 亿参数模型下月开源]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#222222">在 10 月 31 日 2023 云栖大会现场，作为通义大模型基础模型的<strong>通义千问 2.0 千亿参数模型</strong>正式发布。</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-605363e0734cb16cbc76823df487f560abb.png" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#222222">据介绍，通义千问 2.0 模型参数达到千亿级别，不管是在阅读理解还是逻辑思维、数据等方面，都有大幅度提升，能够全面达到国际先进水平。</span></p><p><span style="background-color:#ffffff; color:#222222">与此同时，通义千问 App 也随之发布（仅 Android 版本）</span><span style="background-color:#ffffff; color:#222222">，用户开始可以下载相关 APP 进行体验。</span></p><p><img src="https://static.oschina.net/uploads/space/2023/1031/154720_kKia_2720166.png" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#222222">阿里云 CTO 周靖人宣布，<strong>将在 11 月开源通义千问 720 亿参数模型</strong>，继续支持全球开发者开展模型和应用创新。</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-959b92e9bef8a1dd269d943b3c6d2a9171f.png" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#222222">阿里云是国内最早开源自研大模型的头部科技企业，已先后开源通义千问 70 亿参数模型 Qwen7B 和 140 亿参数模型 Qwen14B，模型累计下载量超过 100 万。</span></p><ul><li><a href="https://www.oschina.net/news/259447" target="_blank">阿里云开源通义千问 14B 大模型</a></li><li><a href="https://www.oschina.net/news/252324" target="_blank">阿里云开源通义千问 7B 大模型：免费、可商用</a></li></ul><p><span style="background-color:#ffffff; color:#222222">据称通义千问 72B 将成为参数规模最大的中国开源大模型。目前国内外开源社区已经产生 50 多款基于通义千问开源模型训练的新模型和新应用，涵盖医疗、法律、机器人等众多领域。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 07:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264277</guid>
            <link>https://www.oschina.net/news/264277</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[夸克「色色」，被罚 50 万]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.cac.gov.cn%2F2023-10%2F30%2Fc_1700323940777319.htm" target="_blank">据中国网信网消息</a></u>，近日，针对「夸克」平台和「网易 CC」直播平台破坏网络生态问题，国家网信办指导广东省网信办依法约谈相关平台负责人，对「夸克」平台实施 50 万元罚款处罚，责令「网易 CC」暂停「舞蹈」版块信息更新 7 日，同时责令 2 家平台立即全面深入整改，严肃处理相关责任人。</p><p><img height="1606" src="https://static.oschina.net/uploads/space/2023/1031/152055_3Pp5_2720166.png" width="2450" referrerpolicy="no-referrer"></p><p>经查，「夸克」平台未遵守相关管理要求，搜索结果呈现大量淫秽色情信息，并向用户推荐色情低俗关键词，违反《网络安全法》《网络信息内容生态治理规定》《互联网信息搜索服务管理规定》等有关规定，在平台信息内容安全审核管理方面存在严重漏洞，破坏网络生态，情节特别严重。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-da0eb9315b86d1c0f8e3e8f3bb08dbcc71e.png" referrerpolicy="no-referrer"></p><p><span style="color:#000000">夸克搜索<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffinance.sina.com.cn%2Ftech%2F2023-10-30%2Fdoc-imzswzyh8439300.shtml" target="_blank">回应新浪科技表示</a></u>：</span></p><blockquote><p>「对此，我们高度重视、诚恳接受、坚决执行，目前已经严格按照要求全面落实整改，封禁相关违规内容。为了进一步加强合规体系建设，我们成立了专项工作小组，升级针对不良信息的识别能力和处理速度，积极开展专项整治行动，通过人工和技术的双重巡查模式，对有害信息进行严厉打击，绝不姑息。」</p></blockquote><ul><li><em>相关阅读：<a href="https://www.oschina.net/news/258071">被罚 100 万，腾讯 QQ 回应</a></em></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 07:24:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264273</guid>
            <link>https://www.oschina.net/news/264273</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[「IDE 启动画面是如何诞生的？」 | JetBrains AI 图形发展史]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="font-size: 15px;color: rgb(33, 33, 33);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;" data-mpa-powered-by="yiban.io"><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-ratio="0.1836734693877551" src="https://oscimg.oschina.net/oscnet/5b3e75ef-637e-4138-802f-b70a25faddbf.gif" data-type="gif" data-w="637" style="height: auto !important;" referrerpolicy="no-referrer"></p><section style="font-size: 15px;"><section style="margin-top: 10px;margin-bottom: 10px;" powered-by="xiumi.us"><section style="padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;"><span style="display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;text-shadow: rgb(204, 204, 204) 4px 3px;color: rgb(115, 119, 173);" title="" opera-tn-ra-cell="_$.pages:0.layers:0.comps:0.title1"><p><strong>引入</strong></p></span></section><section style="border-width: 1px;border-style: solid;border-color: rgb(228, 228, 228);margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(255, 255, 255);text-align: center;"><section style="" powered-by="xiumi.us"><section style="text-align: justify;"><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffeatures%2Fcodespaces" target="_blank" data-linktype="2"></a><span style="font-size: 14px;">上周的<a localeditorid="c26mgf2mlo83sjrzls" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247504179%26idx%3D1%26sn%3Df1a1d015021163bf11ff593327aa7801%26scene%3D21%23wechat_redirect" textvalue="「1024 特别企划」" target="_blank" data-linktype="2"><strong>「1024 特别企划」</strong></a>推送中，我们分享了一套由 JetBrains 使用 AI 生成式技术创作的壁纸屏保。其实，JetBrains 在 AI 艺术方面的探索已经持续多年。大家熟悉的 IDE 启动画面正是这部分工作的结晶。今天的文章，我们就从技术层面揭示 JetBrains 团队是如何使用 AI 技术创造出 IDE 的启动画面和其衍生桌面艺术的。</span></p><p><span style="font-size: 14px;"><br></span></p><p><span style="font-size: 14px;">如果你还想探索和下载更多设计作品，不妨去看看我们的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode2art.jetbrains.com%2F" target="_blank" data-linktype="2"><strong>Code2Art</strong></a>&nbsp;主题页面！</span></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></section></section></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><br></p><section style="font-size: 15px;"><section style="margin-right: 0%;margin-left: 0%;text-align: left;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: top;padding-right: 10px;padding-left: 10px;background-color: rgb(88, 88, 88);"><section style="display: inline-block;vertical-align: middle;"><section style="display: inline-block;vertical-align: middle;color: rgb(255, 255, 255);padding-right: 2px;font-size: 18px;"><p><strong>在 JetBrains 生成图稿</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="display: inline-block;vertical-align: middle;width: 0.8em;height: 0.8em;border-top: 0.2em solid rgb(255, 255, 255);border-right: 0.2em solid rgb(255, 255, 255);transform: rotate(45deg);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">JetBrains 不断完善用作网站元素和发布图形的图稿的创建方式。我们的使命是将平面设计师从日常任务中解放出来，让他们能够专注于自己的核心能力 – <strong>创造力</strong>。JetBrains 用于生成图稿的内部工具的历史大约开始于十年前。起初，我们主要使用基于 WebGL 的工具，这些工具可以在浏览器中实时随机生成所有内容（<strong style="font-size: inherit;color: inherit;line-height: inherit;"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcai.jetbrains.com%2F" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">此处</a></strong><span style="font-size: inherit;color: inherit;line-height: inherit;">提供了交互式归档）。下面的图像就是用这种方式创建的。<br></span></p><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-ratio="0.625" data-s="300,640" src="https://oscimg.oschina.net/oscnet/9abf4da9-b96d-4b1d-8cca-d2b2fe7b5200.png" data-type="png" data-w="960" style="height: auto !important;" referrerpolicy="no-referrer"></p><br><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.625" src="https://oscimg.oschina.net/oscnet/15dcfa47-4f1e-4950-8520-099eaf167d2c.png" data-type="png" data-w="1000" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="PyCharm Professional 2019.3 splash screen" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     使用 WebGL 创建的启动画面 
   </figcaption></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">2020 年，我们发布了第一款<strong style="font-size: inherit;color: inherit;line-height: inherit;"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.jetbrains.com%2Fblog%2F2020%2F09%2F29%2Fintelligent-code-art%2F" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">基于深度神经网络的工具</a></strong><span style="font-size: inherit;color: inherit;line-height: inherit;">。自那时起，所有内容都在 K8s GPU 集群中使用适用于本地和远程开发的 PyCharm 和 Datalore 生成。浏览器仅用于输入输出。通过这种基于神经网络的方式，我们实现了更高程度的个性化，这让我们能够迎合设计师的需求，并且我们一直在努力改进。</span></p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: inherit;color: inherit;line-height: inherit;">以下图片使用组合模式生成网络（CPPN，上图）和 Stable Diffusion（SD，下图）制作而成。<strong>本文将介绍这两种方式的技术细节，以及我们如何结合这两种方式来创造更精彩的设计。</strong><br></span></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.562962962962963" src="https://oscimg.oschina.net/oscnet/92e23890-fbdd-4e0f-aa8c-6dd34aaf01f6.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="PyCharm desktop art" referrerpolicy="no-referrer"></figure><br><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.562962962962963" src="https://oscimg.oschina.net/oscnet/2be787a6-91d8-47c7-9c9f-f7fdbfe18af3.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="RubyMine desktop art" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     使用神经网络生成的启动画面 
   </figcaption></figure><figure style="font-size: inherit;color: inherit;line-height: inherit;"><br></figure><figure style="font-size: inherit;color: inherit;line-height: inherit;"><br></figure><section style="font-size: 15px;"><section style="margin-right: 0%;margin-left: 0%;text-align: left;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: top;padding-right: 10px;padding-left: 10px;background-color: rgb(88, 88, 88);"><section style="display: inline-block;vertical-align: middle;"><section style="display: inline-block;vertical-align: middle;color: rgb(255, 255, 255);padding-right: 2px;font-size: 18px;"><p><strong>CPPN：概述</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="display: inline-block;vertical-align: middle;width: 0.8em;height: 0.8em;border-top: 0.2em solid rgb(255, 255, 255);border-right: 0.2em solid rgb(255, 255, 255);transform: rotate(45deg);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">CPPN（Compositional pattern-producing network 的缩写）&nbsp;是最简单的生成网络之一。它们只是简单地将像素座标 (x, y) 映射到图像颜色 (r, g, b)。CPPN 通常使用特定的图像或图像集进行训练。不过，我们发现，当初始化正确执行时，随机初始化的 CPPN 会生成漂亮的抽象图案。<br></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.20092592592592592" src="https://oscimg.oschina.net/oscnet/669d4106-85b9-43ea-b092-9ee4701beaf9.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="CPPN 架构" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     CPPN 架构：像素座标为输入，RGB 值为输出。 
   </figcaption></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">利用早期内部版本生成器的使用数据，我们改进了算法以提高视觉质量。除此之外，我们还通过引入多个虚拟参数略微扩展了 CPPN 的经典架构。因此，现在我们的 CPPN 会将 (x, y, a, b, c, f) 映射到 (r, g, b)。这个简单的更改允许我们引入一种易于使用（但有些不可预测）的方法来更改图像，如下所示。<br></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.8740740740740741" src="https://oscimg.oschina.net/oscnet/ccb31379-5cbe-42a5-913c-6d1445aa4388.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="CPPN 的虚拟参数" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     通过更新虚拟参数 (a)，我们对图片进行了略微更改。 
   </figcaption></figure><p style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-family: sans-serif;font-size: 14px;"><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">这些虚拟参数不一定是常量。</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">例如，我们可以将每个像素的虚拟参数 f 的值映射到此像素到图像</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">中心的距离。</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">这一技巧使我们能够确保图像呈现圆形。</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">或者我们可以将 f 映射到像素座标的绝对值之和，这将产生菱形图案。</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">这就是数学与艺术的真正结合！</span></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.8194444444444444" src="https://oscimg.oschina.net/oscnet/5b0d9403-e33c-4907-a069-119b14edd26a.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="CPPN 的虚拟参数，第二个示例" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     不同的函数 f(x,y) 会产生不同的图像图案 
   </figcaption></figure><p style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-family: sans-serif;font-size: 14px;"><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">为了确保我们随机初始化的 CPPN 始终产生漂亮的设计，我们训练了一个推荐系统来预测给定的参数集是否会生成具有一定美感的图像。</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">我们根据内部测试期间收到的用户反馈来训练我们的算法。</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">下图显示了随机初始化的 CPPN 创建的两个图像示例以及它们对应的「美感」分数。</span></p><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-ratio="0.825" data-s="300,640" src="https://oscimg.oschina.net/oscnet/75019655-6d4c-4c32-90aa-22bf15b1f01d.png" data-type="png" data-w="1080" style="height: auto !important;" referrerpolicy="no-referrer"></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     预测 CPPN 图像的「美感」分数 
   </figcaption><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"><br></figcaption><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"><br></figcaption></figure><section style="font-size: 15px;"><section style="margin-right: 0%;margin-left: 0%;text-align: left;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: top;padding-right: 10px;padding-left: 10px;background-color: rgb(88, 88, 88);"><section style="display: inline-block;vertical-align: middle;"><section style="display: inline-block;vertical-align: middle;color: rgb(255, 255, 255);padding-right: 2px;font-size: 18px;"><p><strong>CPPN：动画</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="display: inline-block;vertical-align: middle;width: 0.8em;height: 0.8em;border-top: 0.2em solid rgb(255, 255, 255);border-right: 0.2em solid rgb(255, 255, 255);transform: rotate(45deg);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">当我们的 CPPN 生成的图稿被转换成视频图形时，它们真正变得栩栩如生。通过将虚拟参数 (a, b, c) 映射到任何闭合的参数曲线（在同一点开始和结束的曲线），我们可以创建任何所需长度的无缝循环动画！<br></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.5731481481481482" src="https://oscimg.oschina.net/oscnet/a692b7b7-aac4-4471-a169-e1dad58339f9.png" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="CPPN 动画视频的示例帧" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     CPPN 动画视频的示例帧 
   </figcaption></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">曲线函数的选择至关重要。在平面圆上对虚拟参数添加动画是最简单的方式。不过，它有一个缺点：当参数的符号发生变化（例如，从 0.01 变成 -0.01），而它具有较低的一阶导数值（在圆形轨迹的情况下为零）时，生成的动画通常会抖动。为了解决这个问题，我们使用<strong style="font-size: inherit;color: inherit;line-height: inherit;"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FLemniscate_of_Bernoulli" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">伯努利双纽线</a></strong><span style="font-size: inherit;color: inherit;line-height: inherit;">来确保虚拟参数的符号永远不会改变（见下图）。这解决了动画抖动的问题，但也带来了一个新问题。对于大多数动画帧，其中一个参数仅以增量方式更新，这使动画看起来过于简单。我们通过切换到随机样条函数解决了这个问题。我们使用的轨迹越复杂，动画看起来就越丰富！<br></span></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.6675925925925926" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="Examples of CPPN curve functions" src="https://oscimg.oschina.net/oscnet/a939b9c2-0634-4135-85fd-eac8b32ff401.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     CPPN 曲线函数示例 
   </figcaption><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"><br></figcaption><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"><br></figcaption></figure><section style="font-size: 15px;"><section style="margin-right: 0%;margin-left: 0%;text-align: left;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: top;padding-right: 10px;padding-left: 10px;background-color: rgb(88, 88, 88);"><section style="display: inline-block;vertical-align: middle;"><section style="display: inline-block;vertical-align: middle;color: rgb(255, 255, 255);padding-right: 2px;font-size: 18px;"><p><strong>CPPN：色彩校正</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="display: inline-block;vertical-align: middle;width: 0.8em;height: 0.8em;border-top: 0.2em solid rgb(255, 255, 255);border-right: 0.2em solid rgb(255, 255, 255);transform: rotate(45deg);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">还有一个更重要的细节：色彩校正。我们的 CPPN（以及由此产生的图像）是随机生成的，但我们需要确保每个图像都使用我们的品牌颜色。我们尝试了几种不同的方式来实现这一目标。第一次迭代（<strong style="font-size: inherit;color: inherit;line-height: inherit;"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.jetbrains.com%2Fblog%2F2020%2F09%2F29%2Fintelligent-code-art%2F" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">在 2020 版本中使用</a></strong><span style="font-size: inherit;color: inherit;line-height: inherit;">）依赖于浏览器中的 SVG 重新着色（使用 feColorMatrix 和 feComponentTransfer）。这种方式速度很快，因为重新着色在浏览器中进行，我们可以更新调色板，而无需在服务器端重新呈现图像。不过，实现起来却很棘手，因为有些调色板对于 feColorMatrix 和 feComponentTransfer 来说太过复杂，而且通常不可靠。经过大量实验后，我们发现最终的颜色会因浏览器和操作系统而异。以下是我们在 2020 年初进行的实验的一个示例。左边是在 macOS 上通过使用 Safari 的设置由早期版本生成器生成的背景的屏幕截图，右边是在 Ubuntu Linux 上通过使用 Google Chrome 的设置由生成器生成的相同背景的屏幕截图。请注意细微的亮度差异。我们应用的后期处理效果越多，亮度差异就越明显。<br></span></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.5165289256198347" data-type="png" data-w="726" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="An example of brightness discrepancies" src="https://oscimg.oschina.net/oscnet/edbab4b1-2a6d-4f69-b8ec-6bd40136ae39.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     亮度差异示例 
   </figcaption></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">另一个示例是 <strong style="font-size: inherit;color: inherit;line-height: inherit;"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FSVG%2FElement%2FfeComponentTransfer" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">MDN 的 feComponentTransfer 示例</a></strong><span style="font-size: inherit;color: inherit;line-height: inherit;">。这一次，两个图像都在同一台机器上使用 Ubuntu Linux 和 Google Chrome 制作，但在左侧的屏幕截图中，硬件加速被禁用。存在明显的色彩差异，尤其是在表查找示例之间。因此，尽管速度非常快，但这种色彩校正的方式非常不一致。<br></span></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.8" data-type="png" data-w="750" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="An example of color discrepancies" src="https://oscimg.oschina.net/oscnet/e696d864-b3ed-4d90-811c-009334f2319a.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     色彩差异的示例 
   </figcaption></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">我们目前的方式（从 2021 年开始使用）更直接。我们以 32 位灰度来呈现源图像，这意味着我们的 CPPN 只返回单个明亮度值，而不是 RGB。然后，我们将每个像素映射到具有预计算理想 RGB 值的查找表。这种方式速度较慢，但会产生像素级精确的结果。<br></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="1.1944444444444444" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="使用灰度图像进行色彩校正的示例" src="https://oscimg.oschina.net/oscnet/40ec3320-9630-4424-b88c-dbc273b14278.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     使用灰度图像进行色彩校正的示例 
   </figcaption><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"><br></figcaption></figure><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.8398148148148148" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="2020.1 启动画面" src="https://oscimg.oschina.net/oscnet/2c768d79-1c08-4f58-bbfb-f5448e74a775.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     使用 SVG 重新着色的 2020.1 启动画面 
   </figcaption></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">将我们目前的色彩校正方式与带有虚拟参数和样条动画的 CPPN 一起使用时，就会得到类似下面的视频！</p><section><iframe class="video_iframe rich_pages" data-vidtype="2" data-mpvid="wxv_3172052699912110088" data-cover="http%3A%2F%2Fmmbiz.qpic.cn%2Fmmbiz_jpg%2FsGKiaGPagC784HZUFFJWbriaCHrYrLWicAC99RzLeibzv3BaO2udebTZI1n2nxRibB4BkUxmSsMd8cSbWd6WsicpV3Fw%2F0%3Fwx_fmt%3Djpeg" allowfullscreen="" frameborder="0" data-ratio="1.7777777777777777" data-w="1920" style="border-radius: 4px;" data-src="https://mp.weixin.qq.com/mp/readtemplate?t=pages/video_player_tmpl&amp;action=mpvideo&amp;auto=0&amp;vid=wxv_3172052699912110088" referrerpolicy="no-referrer"></iframe></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">CPPN 的另一个显著特性是，得益于其简单的架构，可以轻松地将其计算图转换为 GLSL 代码。在动画视频就绪之后，我们可以将其导出为 WebGL 片段着色器，然后直接在浏览器中运行。这种方式的结果的一个示例是 <strong style="font-size: inherit;color: inherit;line-height: inherit;"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.jetbrains.com.cn%2Fqodana%2F" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">Qodana 的着陆页</a></strong><span style="font-size: inherit;color: inherit;line-height: inherit;">。</span></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">点击<strong style="font-size: inherit;color: inherit;line-height: inherit;"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgradient-public.labs.jb.gg%2F" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">此处</a></strong><span style="font-size: inherit;color: inherit;line-height: inherit;">查看我们基于 CPPN 的生成器。</span></p></li><li><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><span style="font-size: inherit;color: inherit;line-height: inherit;">要深入了解 CPPN，请查看我们包含代码示例的<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdatalore.jetbrains.com%2Freport%2Fstatic%2F2jrFAfMBVhUsYW8njXgysC%2F9OuleGiEVhxqGen1GS9cjN" textvalue="公共 Datalore Notebook" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><strong>公共 Datalore Notebook</strong></a>。</span></p></li></ul><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;"><br></p><section style="font-size: 15px;"><section style="margin-right: 0%;margin-left: 0%;text-align: left;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: top;padding-right: 10px;padding-left: 10px;background-color: rgb(88, 88, 88);"><section style="display: inline-block;vertical-align: middle;"><section style="display: inline-block;vertical-align: middle;color: rgb(255, 255, 255);padding-right: 2px;font-size: 18px;"><p><strong>驾驭 Stable Diffusion</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="display: inline-block;vertical-align: middle;width: 0.8em;height: 0.8em;border-top: 0.2em solid rgb(255, 255, 255);border-right: 0.2em solid rgb(255, 255, 255);transform: rotate(45deg);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">Stable Diffusion 提供了高水平的广泛应用和视觉保真度，这使其成为我们图稿生成器的完美支柱。为了使 Stable Diffusion 适合用作发布图形源，我们必须遵守以下标准：</p><ul style="font-size: inherit;color: inherit;line-height: inherit;padding-left: 32px;" class="list-paddingleft-1"><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">图像应遵循品牌调色板。</span></p></li><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">不允许出现伪影或瑕疵（如坏像素）。</span></p></li><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">应该易于使用某种特定风格（抽象平滑线条）。</span></p></li><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">应该需要很少或不需要提示，这意味着它应该提供易于访问且直观的控制。</span></p></li></ul><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">虽然始终存在改进的空间，但我们已经满足了所有上述要求。最新的图像已<strong style="font-size: inherit;color: inherit;line-height: inherit;"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode2art.jetbrains.com%2F" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">公开</a></strong><span style="font-size: inherit;color: inherit;line-height: inherit;">，所有技术细节如下。<br></span></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.9824074074074074" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="2023.1 splash screens" src="https://oscimg.oschina.net/oscnet/852190b3-f71c-466b-8bec-07665f2b6a37.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     使用 Stable Diffusion 创建的 2023.1 启动画面 
   </figcaption></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">为了产生始终符合我们所有标准的结果，我们使用设计师提供的各种参考资料对 Stable Diffusion 进行了微调。下面是一些根据不同风格生成的图像示例。<br></p><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-ratio="0.46944444444444444" data-s="300,640" data-type="png" data-w="1080" style="height: auto !important;" src="https://oscimg.oschina.net/oscnet/b744869f-22b3-4f5e-9f06-1e4850cdc202.png" referrerpolicy="no-referrer"></p><br><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.4638888888888889" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="通过微调 Stable Diffusion 获得的实验风格" src="https://oscimg.oschina.net/oscnet/5cdb078f-6c1d-4c8f-86d1-129e40d6a820.png" referrerpolicy="no-referrer"></figure><br><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.3509259259259259" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="通过微调 Stable Diffusion 获得的实验风格" src="https://oscimg.oschina.net/oscnet/035c9f63-9df7-4751-8e0d-15963ef8614e.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     通过微调 Stable Diffusion 获得的实验风格 
   </figcaption></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">在深入研究微调过程的技术细节之前，我们先来看看 Stable Diffusion 的内部原理。它在本质上由三部分组成：CLIP 文本编码器（用于将文本编码成多模态嵌入向量空间的微型 Transformer 模型），将图像压缩到隐空间以及从隐空间解压缩的变分自动编码器，以及降噪 UNet。<br></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.6397748592870544" data-type="png" data-w="1066" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="Stable Diffusion 的架构" src="https://oscimg.oschina.net/oscnet/dfaa53b8-d074-4766-9a9d-3c7f30d75e3a.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     Stable Diffusion 的架构（图像来源： 
    <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.philschmid.de%2Fstable-diffusion-inference-endpoints" textvalue="‍philschmid.de/stable-diffusion-inference-endpoints" linktype="text" imgurl="" tab="outerlink" data-linktype="2">philschmid.de/stable-diffusion-inference-endpoints</a>） 
   </figcaption></figure><p style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-family: sans-serif;font-size: 14px;"><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">生成过程大致如下：</span><br></p><ol style="font-size: inherit;color: inherit;line-height: inherit;padding-left: 32px;" class="list-paddingleft-1"><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">我们将提示文本编码成一个嵌入向量，即一个 77×768 浮点数组。</span></p></li><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">我们随机生成图像的隐式表示，它可以是纯高斯噪声或初始图像的带噪表示。</span></p></li><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">我们以给定的步数，将编码的隐图像和编码的文本反复传递给降噪 UNet。</span></p></li><li style="font-size: inherit;color: inherit;line-height: inherit;margin-bottom: 0.5em;"><p><span style="font-size: inherit;color: inherit;line-height: inherit;">在对隐图像降噪后，我们将其传递给解码器，从而将其解压缩为标准的 RGB 图像。</span></p></li></ol><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.5231481481481481" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="降噪过程" src="https://oscimg.oschina.net/oscnet/01beaca1-6d92-4f4d-95d0-7d44d4c42451.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     降噪过程（图像来源： 
    <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjalammar.github.io%2Fillustrated-stable-diffusion%2F" textvalue="jalammar.github.io/illustrated-stable-diffusion/" linktype="text" imgurl="" tab="outerlink" data-linktype="2">jalammar.github.io/illustrated-stable-diffusion/</a>） 
   </figcaption></figure><p style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-family: sans-serif;font-size: 14px;"><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">对我们来说至关重要的是，Stable Diffusion 的好处在于，可以用很少的数据对其进行微调，并获得很好的结果！</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">作为「副作用」，数据高效的微调方法在计算上也是高效的，这使它变得更好。</span></p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">最直接的微调方式是文本反转 (p-tuning)。我们会冻结所有权重，例如 UNet、VAE 和文本编码器（这意味着我们不会在训练期间更新它们），并且只为文本编码器的每个嵌入向量训练一个新词。因为我们每个嵌入向量只训练一个新词，只有 768 个可训练参数！<br></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.5638888888888889" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="文本嵌入和反转过程概述" src="https://oscimg.oschina.net/oscnet/7251b2c3-39c3-4bde-8ba9-f8f7852433b2.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     文本嵌入和反转过程概述（&nbsp;图像来源： 
    <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftextual-inversion.github.io%2F" textvalue="textual-inversion.github.io/" linktype="text" imgurl="" tab="outerlink" data-linktype="2">textual-inversion.github.io/</a>） 
   </figcaption></figure><p style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-family: sans-serif;font-size: 14px;"><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">这些自定义嵌入向量是可组合的，这意味着我们最多可以在单个提示中使用 77 个嵌入向量。</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">最重要的是，它们很容易训练，在单张 RTX 4090 上需要大约 2 个小时。</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">以下是训练过程的示例。</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">用于生成以下两个图像的提示均为「digital art in the style of 」，其中「」是我们正在训练的新词嵌入向量。</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">随着执行的训练步骤的增多，图像会发生演变，新的视觉风格会变得越来越明显。</span></p><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-ratio="1" data-s="300,640" data-type="png" data-w="1080" style="height: auto !important;" src="https://oscimg.oschina.net/oscnet/2c191bf3-e18e-4db0-bd26-e4082f6c6ba3.png" referrerpolicy="no-referrer"></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     使用文本反转经过 500 和 3000 个训练步骤后生成的图像 
   </figcaption></figure><p style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-family: sans-serif;font-size: 14px;"><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">另一种热门且高效的微调方法是低秩自适应（Low-Rank Adaptation，简称 LoRA）。LoRA 的关键思想类似于文本反转，只是这次除了冻结权重之外，我们还通过在 UNet 内的注意力层中添加小的适配器层来引入新权重。</span></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.7553606237816765" data-type="png" data-w="1026" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="一个 Transformer 层内的 LoRA 方法示意图" src="https://oscimg.oschina.net/oscnet/bcb475a0-a79b-4448-9d7a-13b165607f8b.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     一个 Transformer 层内的 LoRA 方法示意图（图像来源： 
    <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fadapterhub.ml%2Fblog%2F2022%2F09%2Fupdates-in-adapter-transformers-v3-1%2F" textvalue="adapterhub.ml/blog/2022/09/updates-in-adapter-transformers-v3-1/" linktype="text" imgurl="" tab="outerlink" data-linktype="2">adapterhub.ml/blog/2022/09/updates-in-adapter-transformers-v3-1/</a>） 
   </figcaption></figure><p style="color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;font-family: sans-serif;font-size: 14px;"><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">与文本反转相比，这种方式可以从微调数据中捕获更复杂的图案（例如，「AI 肖像」应用会使用用户的面孔训练适配器层），但它使用的资</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">源略多，最重要的是，多个 LoRA 无法组合。</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">在我们的具体用例中，我们发现 LoRA 在使用 Stable Diffusion XL 时最有效。</span><span style="color: inherit;font-size: inherit;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0px;">相比之下，在早期版本的 Stable Diffusion（1.4、1.5 或 2.1）中，文本反转可以实现更广泛的应用。</span></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="1.4083333333333334" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="使用 LoRA 经过 200 和 1000 个训练步骤后生成的图像" src="https://oscimg.oschina.net/oscnet/da82c791-8e96-45e2-ae64-ab8b4fbc1bfe.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     使用 LoRA 经过 200 和 1000 个训练步骤后生成的图像 
   </figcaption><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"><span style="font-size: 18px;"></span><br></figcaption><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;"><br></figcaption></figure><section style="font-size: 15px;"><section style="margin-right: 0%;margin-left: 0%;text-align: left;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: top;padding-right: 10px;padding-left: 10px;background-color: rgb(88, 88, 88);"><section style="display: inline-block;vertical-align: middle;"><section style="display: inline-block;vertical-align: middle;color: rgb(255, 255, 255);padding-right: 2px;font-size: 18px;"><p><strong>结合 Stable Diffusion&nbsp;</strong></p><p><strong>和 CPPN 的优点</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="display: inline-block;vertical-align: middle;width: 0.8em;height: 0.8em;border-top: 0.2em solid rgb(255, 255, 255);border-right: 0.2em solid rgb(255, 255, 255);transform: rotate(45deg);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">我们使用 Stable Diffusion 的标准之一是需要确保生成的图像遵循某个特定品牌的调色板，这正是 CPPN 的用武之地！在使用 Stable Diffusion 生成图像之前，我们使用自己的梯度生成器（如上所述）利用 CPPN 生成图像，以像素级精度应用所需的颜色，然后使用 VAE 对其进行编码并使用高斯噪声进行混合。UNet 使用生成的隐图像作为其起点，从而保留原始色彩和构图。<br></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.4787037037037037" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="CPPN → Stable Diffusion 流水线" src="https://oscimg.oschina.net/oscnet/2d5e74a9-8daf-431f-864a-4a63891961b6.png" referrerpolicy="no-referrer"></figure><br><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.4703703703703704" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="CPPN → Stable Diffusion 流水线" src="https://oscimg.oschina.net/oscnet/93e7736b-b1bb-4784-b5d4-6d1036613054.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     CPPN → Stable Diffusion 流水线 
   </figcaption></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">在 CPPN 图像就绪后，我们也可以直接在浏览器中对其进行编辑，以实现我们所能想象的任何形状和设计！<br></p><figure style="font-size: inherit;color: inherit;line-height: inherit;"><img class="rich_pages wxw-img" data-ratio="0.26851851851851855" data-type="png" data-w="1080" style="font-size: inherit;color: inherit;line-height: inherit;display: block;margin-right: auto;margin-left: auto;height: auto !important;" title="具有手动编辑 CPPN 图像的 CPPN → Stable Diffusion 流水线" src="https://oscimg.oschina.net/oscnet/3e03e2c5-1894-41c9-b628-feffef64bd97.png" referrerpolicy="no-referrer"><figcaption style="line-height: inherit;margin-top: 10px;text-align: center;color: rgb(153, 153, 153);font-size: 0.7em;">
     具有手动编辑 CPPN 图像的 CPPN → Stable Diffusion 流水线 
   </figcaption></figure><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">最后，使用我们的「CPPN → Stable Diffusion」流水线生成多个图像后，我们就可以用这些图像来训练另一个 CPPN，并将它们转换为动画，如上面的 <em style="font-size: inherit;color: inherit;line-height: inherit;">CPPN：动画</em>部分所述！这里有一些示例 <strong style="font-size: inherit;color: inherit;line-height: inherit;"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.shadertoy.com%2Fview%2FDsBSW3" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">GLSL 代码</a>。</strong><span style="font-size: inherit;color: inherit;line-height: inherit;"></span></p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">JetBrains 对 AI 赋能图形的探索和实现是一次冒险。多年来，我们的工具不断发展和成熟，从最初使用基于 WebGL 的随机生成方式，到目前使用 CPPN 和 Stable Diffusion 生成时尚且个性化的设计。展望未来，我们期待更高水平的自定义和广泛应用，我们对这些技术将在图形生成领域释放的潜力感到兴奋。</p><p style="font-size: inherit;color: inherit;line-height: inherit;margin-top: 1.5em;margin-bottom: 1.5em;">我们希望这篇关于我们的 AI 图稿发展历程的深入介绍对您有所启发！我们诚邀您探索我们提供的示例（包括我们的<strong style="font-size: inherit;color: inherit;line-height: inherit;"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcai.jetbrains.com%2F" target="_blank" rel="noopener" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" data-linktype="2">交互式归档</a></strong><span style="font-size: inherit;color: inherit;line-height: inherit;">）并在文章留言区或发送电子邮件至 <a href="https://www.oschina.net/action/GoToLink?url=mailto%3Acai%40jetbrains.com" style="font-size: inherit;line-height: inherit;color: rgb(30, 107, 184);" target="_blank">cai@jetbrains.com</a> 来分享您的反馈。请告诉我们您未来希望从计算艺术团队看到什么样的主题！</span></p></section><section style="font-size: 16px;"><section style="transform: perspective(0px);transform-style: flat;" powered-by="xiumi.us"><section style="margin-top: 10px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;transform: rotateY(180deg);"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="transform: perspective(0px);transform-style: flat;" powered-by="xiumi.us"><section style="transform: rotateY(180deg);"><section style="color: rgb(125, 125, 125);font-size: 13px;text-align: right;"><p>本博文英文原作者：</p><p>Vladimir Sotnikov, Olga Andreevskikh</p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></section></section></section></section><section style="" powered-by="xiumi.us"><p><br></p><p><br></p><section style="font-size: 15px;"><section style="text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;"><section style="justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;"><section style="display: flex;flex-flow: row;text-align: center;justify-content: center;margin-right: 0%;margin-left: 0%;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 43%;flex: 0 0 auto;align-self: center;height: auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="background-color: rgb(0, 0, 0);height: 1px;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: middle;width: 14.0003%;flex: 0 0 auto;height: auto;line-height: 0;align-self: center;"><section style="margin-top: 10px;margin-bottom: 10px;line-height: 0;" powered-by="xiumi.us"><section style="vertical-align: middle;display: inline-block;line-height: 0;box-shadow: rgba(255, 255, 255, 0.1) 0px 0px 5px;"><img class="rich_pages wxw-img" data-ratio="1" data-s="300,640" data-type="png" data-w="420" style="vertical-align: middle;width: 100%;height: auto !important;" src="https://oscimg.oschina.net/oscnet/f8105502-1c42-4b88-83a3-ddc47473d4fa.png" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: 43%;flex: 0 0 auto;align-self: center;height: auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="background-color: rgb(0, 0, 0);height: 1px;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;"><section style="justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;"><section style="margin-top: 10px;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;padding-right: 15px;padding-left: 15px;align-self: flex-start;flex: 0 0 auto;background-color: rgb(88, 88, 88);"><section style="justify-content: flex-start;margin-top: 10px;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: top;width: auto;min-width: 10%;flex: 0 0 auto;height: auto;align-self: flex-start;"><section style="margin-top: 3px;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: bottom;width: 33.33%;align-self: flex-end;flex: 0 0 auto;"><section style="" powered-by="xiumi.us"><section style="display: inline-block;width: 0px;height: 0px;vertical-align: top;overflow: hidden;border-style: solid;border-width: 6px 0px 6px 10px;border-color: rgba(255, 255, 255, 0) rgba(255, 255, 255, 0) rgba(255, 255, 255, 0) rgb(255, 255, 255);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: bottom;width: 33.33%;align-self: flex-end;flex: 0 0 auto;"><section style="" powered-by="xiumi.us"><section style="display: inline-block;width: 0px;height: 0px;vertical-align: top;overflow: hidden;border-style: solid;border-width: 6px 0px 6px 10px;border-color: rgba(255, 255, 255, 0) rgba(255, 255, 255, 0) rgba(255, 255, 255, 0) rgb(255, 255, 255);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: bottom;width: 33.33%;margin-top: 3px;align-self: flex-end;flex: 0 0 auto;"><section style="" powered-by="xiumi.us"><section style="display: inline-block;width: 0px;height: 0px;vertical-align: top;overflow: hidden;border-style: solid;border-width: 6px 0px 6px 10px;border-color: rgba(255, 255, 255, 0) rgba(255, 255, 255, 0) rgba(255, 255, 255, 0) rgb(255, 255, 255);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section></section><section style="display: inline-block;vertical-align: top;width: auto;min-width: 10%;flex: 0 0 auto;height: auto;margin-left: 10px;align-self: flex-start;"><section style="" powered-by="xiumi.us"><section style="color: rgb(255, 255, 255);text-align: justify;"><p><strong>更多阅读推荐</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></section></section></section></section><section style="margin-bottom: 10px;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-style: solid;border-width: 1px;border-color: rgb(88, 88, 88);align-self: flex-start;flex: 0 0 auto;padding: 27px 7px;"><section style="" powered-by="xiumi.us"><section style="text-align: center;color: rgb(0, 0, 0);"><p><strong>新发布</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="" powered-by="xiumi.us"><section style="text-align: center;font-size: 12px;color: rgb(0, 0, 0);"><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247502861%26idx%3D1%26sn%3D62792d48fecdd57819d1237e73dff1b3%26chksm%3Dc08ba153f7fc28458201afc3ced4c0f11045f731ec8fee1e94961a3708a20e50690942745bb6%26token%3D1396192698%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank" data-linktype="2">JetBrains 全系列 IDE 2023.2 更新概览</a><br></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247503998%26idx%3D1%26sn%3Dc80abda34362d92eb4077c7176fbf9c7%26chksm%3Dc08bbd20f7fc34367671f223323fdcad7d4a69e299793bab51144717a9a3902159a5a51a4227%26token%3D1790117445%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank" data-linktype="2">RustRover: JetBrains 出品的独立 Rust IDE</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247492468%26idx%3D1%26sn%3D872a6fc5a40d41828299c69e20f57a56%26scene%3D21%23wechat_redirect" target="_blank" data-linktype="2">JetBrains Aqua: 测试自动化 IDE</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247489349%26idx%3D1%26sn%3D1dcec5e6b810512a8c23fa52db285c06%26chksm%3Dc0887a1bf7fff30d8221cd92764618ec5262ac9a549c7173340bc754f1abecc83a0dc51e2ec8%26scene%3D21%23wechat_redirect" target="_blank" data-linktype="2">JetBrains Qodana:&nbsp;代码质量平台</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247491483%26idx%3D1%26sn%3D7ef92a11da98c89c18feb4d97185a872%26scene%3D21%23wechat_redirect" target="_blank" data-linktype="2">Fleet 公共预览版</a></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="" powered-by="xiumi.us"><section style="text-align: justify;"><p><br></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="" powered-by="xiumi.us"><section style="color: rgb(0, 0, 0);text-align: center;"><p><strong>调研报告</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="" powered-by="xiumi.us"><section style="text-align: center;font-size: 12px;"><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247494786%26idx%3D2%26sn%3Ddb281bdfcbcac3be0c040f978f8da428%26chksm%3Dc08b81dcf7fc08cadd185937e84851eb06fefeb712c3fc3d0545623eba2b061fc878f9ea7f30%26token%3D1929533000%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank" data-linktype="2">2022 开发人员生态系统现状</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247489234%26idx%3D1%26sn%3Db6b7aaffebc6bdf85dfd2d8bd6dbd3ea%26chksm%3Dc0887b8cf7fff29ab0ca8e0a297f5f66d6ce4e3f11ed1c28c2c2d7853f2966ec36281bee5c60%26scene%3D21%23wechat_redirect" target="_blank" data-linktype="2">Python 开发者年度调查</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247487607%26idx%3D1%26sn%3Dba4827cc6fa8965420c22a649a39ce83%26chksm%3Dc0887d29f7fff43f55c492ae88e279c77d14a7323f814fcc3a7961b6e4298dfec33494ce0788%26scene%3D21%23wechat_redirect" target="_blank" data-linktype="2">代码审查工具报告</a></p><p><span style="letter-spacing: 0px;"><br></span></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="" powered-by="xiumi.us"><section style="text-align: justify;"><p style="text-align: center;text-wrap: wrap;"><strong>IDE 使用技巧</strong><br></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="" powered-by="xiumi.us"><section style="text-align: center;"><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247494974%26idx%3D1%26sn%3D3108e1d2c43978d81371296ad91d68d6%26chksm%3Dc08b8060f7fc09768a9b31bdcd1be4418e54f80ff76914524a4cface46e0d981b827db16ac92%26token%3D441435331%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank" data-linktype="2"><span style="font-size: 12px;">10 个热门 IDE 主题推荐</span></a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247500429%26idx%3D1%26sn%3Da0d1d597f6365c3558f0196f67f923bc%26chksm%3Dc08bafd3f7fc26c51a13b598413bb17cece97c2582b93a2902671a2dc231241cf5acf61d29f1%26token%3D443990964%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank" data-linktype="2"><span style="font-size: 12px;">IDE 中的「快速功能」</span></a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247492832%26idx%3D1%26sn%3Db07d1ac0f9d7fa9b7e5e291991a52acd%26chksm%3Dc08b89bef7fc00a8d9ac8f79bb75c384c7b488efbd03f045b6f198ce72a02aec2e994a202f53%26token%3D1396192698%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank" style="font-size: 12px;" data-linktype="2">最被低估的快捷键</a></p></section></section></section></section></section></section></section></section></section></section></section></section></section><grazie-editor-wrapper></grazie-editor-wrapper></section><section style="text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;"><section style="text-align: center;margin-top: 10px;margin-bottom: 10px;line-height: 0;" powered-by="xiumi.us"><section style="vertical-align: middle;display: inline-block;line-height: 0;"><img class="rich_pages wxw-img" data-ratio="0.5" data-s="300,640" data-type="png" data-w="1080" style="vertical-align: middle;width: 100%;height: auto !important;" src="https://oscimg.oschina.net/oscnet/4677158d-9778-44bd-b61a-ab3c44c4d071.png" referrerpolicy="no-referrer"></section></section><section style="" powered-by="xiumi.us"><section style="font-size: 13px;color: rgb(125, 125, 125);text-align: justify;"><p><strong>⏬ 戳「阅读原文」了解更多</strong></p></section><grazie-editor-wrapper></grazie-editor-wrapper></section></section></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - JetBrains（JetBrainsChina）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 06:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5494143/blog/10139905</guid>
            <link>https://my.oschina.net/u/5494143/blog/10139905</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
    </channel>
</rss>
