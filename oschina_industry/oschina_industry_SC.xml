<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Sat, 09 Dec 2023 10:00:12 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[systemd 新组件 systemd-bsod — 为 Linux 引入「蓝屏」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>systemd 255 近日<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsystemd%2Fsystemd%2Freleases%2Ftag%2Fv255" target="_blank">发布了稳定版</a></u>，其新增的"<strong>systemd-bsod</strong>"实验性组件让人眼前一亮——没错，正是大名鼎鼎的「蓝屏死机」（Blue Screen of Death，简称 BSOD）。</p><p>BSOD 是微软 Windows 操作系统在无法从一个系统错误中恢复过来时，为保护电脑数据文件不被破坏而强制显示的屏幕图像。Windows 的蓝屏死机提示已成为标志性画面，大部分是系统崩溃的现象。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-51d3ac36bc416abe53fe1c0517c774a1824.png" referrerpolicy="no-referrer"></p><p><em>上图是 Windows 10 的蓝屏死机画面（版本 1607-21H2），它包含了一个悲伤的颜文字和一个用于快速排查错误的二维码</em>。</p><p>简而言之，BSOD 就是用于展示错误信息的诊断工具。虽然大家讨厌看到蓝屏界面，但这不意味着 BSOD 本身是一个坏方案。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d1cfdcf33e390c881d32ad1ef5146419e5e.png" referrerpolicy="no-referrer"></p><p>根据&nbsp;systemd 更新日志的介绍，当日志级别设置为"<strong>LOG_EMERG</strong>"时，如果 Linux 系统出现引导错误，新组件"systemd-bsod"会全屏显示报错信息（即 BSOD）。和 Windows 的 BSOD 类似，它也会生成二维码，以便用户通过手机获取启动失败报错的更多信息。</p><p>"systemd-bsod" 属于&nbsp;<span>Outreachy 项目的一部分，该项目是为开发开源工具的人员提供实习机会的组织。</span></p><p>systemd-bsod 目前处于实验性阶段，GitHub 上的更新日志也指出它仍会有改动。但不管怎样，不少主流 Linux 发行版如 Ubuntu、Fedora、Debian 和 Red Hat 都采用了 systemd。所以 2024 年，相信不少 Linux 发行版都会引入「蓝屏」。</p><p>对了，systemd 创始人兼首席开发者 Lennart Poettering 去年<u><a href="https://www.oschina.net/news/202119/systemd-creator-microsoft" target="_blank">被微软从 Red Hat 挖走</a></u>&nbsp;—— 继续专注于开发 systemd。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 09 Dec 2023 05:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270207/systemd-255-bsod</guid>
            <link>https://www.oschina.net/news/270207/systemd-255-bsod</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[雷军 30 年前写的论文：《计算机病毒判定专家系统原理与设计》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>雷军 1992 年发表的《计算机病毒判定专家系统原理与设计》论文在网上曝光，引发热议。</p><p>这份论文详细地描述了计算机病毒判定专家系统的原理与具体设计方法，一定程度上解决了流行病毒的判定问题。论文结语写道：<strong>研制解决流行病毒判定问题的专家系统，在目前具有相当大的使用价值。本文介绍的这种智能判定方法大大优于传统的检测方法，具有准确率高，适用性广的有点，还可以不断发展和扩充。关于这种方法，目前国内外文献上尚未提及。（参考文献略）</strong></p><p>附论文原文：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-00e57539a1c6a07aa17cb70f341f3f2d3c1.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-9babb896439e0b4a049532c7537dba1318f.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-c000968b49128269073f6f38373e6162709.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-a14bb1726495836bf7d6d463cbbefdb16a1.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-63cb2ee41ae8f0981dc0a88d94251dd61fb.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-d7986af830afb49d055c14584452431d642.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-dea1bb17744fa373895687fd84a7d5520ab.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-b68d4f4408348e18bba5c70dd2006a1a855.png" referrerpolicy="no-referrer"></p><p>来源：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F5714719345%2FNvR23gzWc%3Fpagetype%3Dviewer" target="_blank">https://weibo.com/5714719345/NvR23gzWc?pagetype=viewer</a></em></u></p><p>华为消费者 BG 战略 Marketing 部副总裁李昌竹转发了该论文的微博，<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1402329495%2FNwbO90AHM%3Fpagetype%3Dprofilefeed" target="_blank">并说道</a></u>：<strong>「技术创新和前沿探索都是值得尊敬和学习的。」</strong></p><p><img src="https://oscimg.oschina.net/oscnet/up-4cbc7936df3d1ad8b4a787215eb1fbea304.png" referrerpolicy="no-referrer"></p><p>1992 年，雷军还与求伯君合著了《深入 DOS 编程》一书。在接下来的两年里，雷军涉猎广泛，写过加密软件、杀毒软件、财务软件、CAD 软件、中文系统以及各种实用小工具等。</p><p><img src="https://oscimg.oschina.net/oscnet/up-389de1159783b7b408cade4d27be661e412.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-d80cc19de34a8b5e73cfe14690d437a0a70.png" referrerpolicy="no-referrer"></p><p>公开资料显示，1987 年，雷军毕业于原沔阳中学（现湖北省仙桃中学），同年考上了武汉大学计算机系。</p><p>1992 年初，雷军加盟金山公司。先后出任金山公司北京开发部经理、珠海公司副总经理、北京金山软件公司总经理等职务。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 09 Dec 2023 03:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270190</guid>
            <link>https://www.oschina.net/news/270190</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[大家好，我龙博，我们做了个很酷的开源工具]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Hello ，大家好，我是龙博，目前担任 ILLA Cloud 的 CEO 。 创业之前在字节跳动和快手写代码，一直以来都是一个热爱技术的小伙伴！</p><h2>介绍一下我们产品</h2><p>ILLA Cloud 是一个非常好用的开源低代码工具，我们已经完整的迭代两年了。</p><p>传送门：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Filla.cloud" target="_blank">https://illa.cloud</a></p><p>Github: <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fillacloud%2Filla-builder" target="_blank">https://github.com/illacloud/illa-builder</a></p><p>我们的 star 都是我们用户一个一个点上去的，我们没有进行任何的操作行为，所以 star 并没有那么多，还在冲击 1w ，希望大家多给我们点赞～</p><p>我们是一个开箱即用的低代码工具，希望大家能使用一下去解决公司里面搭建内部系统的问题，专注各种管理后台，也就是大家无法购买到的系统，只能通过传统前端方式构建，大家都知道没有前端喜欢写后台，^_^</p><p>使用我们可以构建出来相对比较美观的各种内部工具，保证大家的 App ，Web 网站有一个好用的管理后台工具。</p><p><img src="https://cdn.illacloud.com/illa-blog/Discussion/Frame%2033402x.png" alt="低代码" referrerpolicy="no-referrer"></p><p>我们也有很多用户在使用我们的产品搭建属于自己公司的内部 AI 工具，比如使用 Agent 去做邮件生成，使用低代码工具搭建属于自己的 Stable Diffusion 面板。</p><p><img src="https://cdn.illacloud.com/illa-blog/Discussion/discussion2.png" alt="AI" referrerpolicy="no-referrer"></p><p>我们在过去的大量工作里面支持了大量的集成能力，主流的数据库和接口都支持了。我们还同 Hugging Face 达成了官方的合作，保证每一个用户都可以快速的访问 Hugging Face 中的模型从而让自己构建出来的产品有大量开箱即用的 AI 能力</p><h2>关于我们公司</h2><p>我们是 2022 年元旦之后开始创立的，目前这个产品已经完整迭代两年了，才敢宣传一下，我们相信这里的小伙伴对产品都有极高的追求滴！</p><p>我们产品在创立初期也获得了高领资本，源码资本，奇绩创坛的融资，所以大家不用担心我们的生存问题。感谢国内顶级的资本对开源事业的支持，我们相信开源可以让产品更加的茁壮成长。</p><p>主要是真心邀请大家一起构建我们的产品，我们相信中国的开发者是全世界最优秀的一群人（数据上看也确实是），我们作为一家服务开发者的公司非常荣幸可以让大家来用一用我们的产品。</p><h2>最后</h2><p>如果你对我们产品感兴趣，欢迎找我聊聊，我的 v：owen_longbo</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 10:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/xlyg/blog/10320194</guid>
            <link>https://my.oschina.net/xlyg/blog/10320194</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[商汤科技发布 AI 编程助手「代码小浣熊 Raccoon」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>商汤科技宣布，基于商汤自研大语言模型的智能编程助手 —— 代码小浣熊 Raccoon (<strong>R</strong>accoon is<strong>A</strong>nother&nbsp;<strong>C</strong>ode&nbsp;<strong>CO</strong>-pil<strong>O</strong>t&nbsp;<strong>N</strong>avigator) 已开放公测。</p><p>代码小浣熊 Raccoon 支持 Python、Java、JavaScript、C++、Go、SQL 等 30+ 主流编程语言和 VS Code、IntelliJ IDEA 等主流 IDE。主要特性如下：</p><ul><li><p>代码编写建议覆盖 30 多种主流编程语言，依据上下文，自动生成代码。</p></li><li><p>开放对话功能，理解用户的自然语言需求描述。</p></li><li><p>预设基于注释生成代码、跨编程语言翻译、单元测试用例生成、代码修正、代码重构、技术领域知识问答等功能。</p></li><li><p>支持用户自定义需求：包括需求文档生成、代码生成注释、代码的解释文档生成、技术文档生成等开放式能力。</p></li></ul><blockquote><p><strong>体验地址：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.sensetime.com" target="_blank">https://code.sensetime.com</a></u></em><br> 使用文档</strong>：<strong><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.sensetime.com%2Fdocs" target="_blank">https://code.sensetime.com/docs</a></em></u></strong></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2c679cff58be01097976aee3c1003e89b3a.png" referrerpolicy="no-referrer"></p><p><img height="722" src="https://oscimg.oschina.net/oscnet/up-21140dc87019c7b03213e62078c9e35292d.png" width="2398" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-fa0feda14f70e8765c400cbbda8eb386722.png" referrerpolicy="no-referrer"></p><p>代码小浣熊由商汤自研大语言模型提供支持，覆盖软件需求分析、架构设计、代码编写、软件测试等环节，满足用户代码编写、数据分析、编程学习等各类需求。在实际应用中，可帮助开发者提升编程效率超 50%。</p><p>在最新权威代码生成测试集 HumanEval 的测试中，该模型精度表现惊艳，一次通过率甚至达到惊人的 71%，已经大幅超越 GPT-3.5。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 07:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270111</guid>
            <link>https://www.oschina.net/news/270111</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[虚拟机成为 Android 的核心结构]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>安卓虚拟化框架（AVF）将出现在即将推出的部分安卓 14 设备上。AVF 于 Android 13 首次在 Pixel 设备上推出，为开发特权应用程序的平台开发人员提供了新的功能。</p><p>有了 AVF，我们将更广泛地支持安卓的虚拟化。虚拟化被广泛应用和部署，以隔离工作负载和操作系统。它可以有效地扩展基础设施、测试环境、兼容传统软件、创建虚拟桌面等。</p><p style="text-align:start">有了 AVF，虚拟机就成了安卓操作系统的核心结构，类似于安卓利用 Linux 进程的方式。开发人员可以灵活选择虚拟机的隔离级别：</p><ul><li><p>单向隔离：安卓（主机）可以控制和检查虚拟机的内容。这些虚拟机最常用于沙箱和隔离，使多个操作系统能在同一台机器/设备上运行，由一个操作系统主机（Android）控制和监视所有其他操作系统。</p></li></ul><ul><li><p>双向隔离（隔离虚拟机）：Android（主机）和虚拟机（客户机）完全相互隔离。处理或存储敏感数据的开发人员可能会受益于隔离虚拟机。隔离虚拟机具有双向屏障，主机（Android）和虚拟机都无法访问对方，除非通过明确商定的通信渠道。这有两个主要特性：</p></li></ul><blockquote><blockquote><ol><li><p>主机（Android）无法访问虚拟机内的工作负载和数据（保密）。</p></li><li><p>即使 Android 一直到（包括）主机内核都受到攻击，隔离的虚拟机也不会受到攻击。</p></li></ol></blockquote></blockquote><h3 style="text-align:start"><strong>AVF 的意义</strong></h3><h4 style="text-align:start"><strong>隔离</strong></h4><p style="text-align:start">有了隔离虚拟机，开发人员现在有了 Trustzone 之外的另一种选择，可用于需要在不升级权限的情况下与 Android 隔离的用例。</p><h4 style="text-align:start"><strong>便携性</strong></h4><p style="text-align:start">虚拟机及其内部运行的应用程序的可移植性远高于可信 applets。例如，带有 Linux 应用程序有效载荷的基于 Linux 的虚拟机可以在所有支持 AVF 的设备上运行。这意味着开发人员只需构建一次应用程序，就可以将其部署到任何地方。与移植到 Trustzone 操作系统相比，虚拟机还能无缝、轻松地移植基于 Linux 的现有应用程序。</p><h4 style="text-align:start"><strong>性能</strong></h4><p style="text-align:start">AVF 设计轻巧、高效、灵活。虚拟机可以：</p><ul><li><p>根据开发者的需要，小到一个 C 语言程序，大到整个操作系统；</p></li><li><p>做到持续性或间歇性；</p></li><li><p>根据整个系统的健康状况增加或缩小内存；</p></li><li><p>遵循 Android 的调度程序提示和低内存警告。</p></li></ul><h4 style="text-align:start"><strong>可扩展性</strong></h4><p style="text-align:start">AVF 在设计时考虑到了开发人员的需求。虚拟机可以定制，以满足特定用例的需求。只要符合 AVF 规定的某些启动和通信协议，开发人员就可以部署任何虚拟机有效载荷。</p><p style="text-align:start">除了将虚拟化的强大功能引入安卓系统，实现虚拟桌面、沙箱、AVF 使用隔离虚拟机的所有可能性外，还能使以下常见的安卓使用场景（以及更多使用场景）受益：</p><ul><li><p>生物识别：通过在隔离的虚拟机中部署生物识别可信 applets，开发人员将获得隔离保证、生物识别算法所需的更多计算能力、与 Trustzone 操作系统无关的轻松更新能力以及更简化的部署。</p></li></ul><ul><li><p>DRM：Widevine 可在安卓设备上实现流式 DRM。一旦部署在隔离的虚拟机中，无论安卓设备上部署的各种 Trustzone 操作系统的细节如何，Widevine 的更新在这些设备上都会变得更加容易。</p></li></ul><h3 style="text-align:start"><strong>AVF 使用</strong></h3><p style="text-align:start">AVF 提供了简单的应用程序接口，用于查询设备创建虚拟机的能力及其支持的类型，以及从创建虚拟机的应用程序和服务与这些虚拟机建立安全的通信渠道。</p><p style="text-align:start">例如，检查 AVF API 的可用性，以及隔离虚拟机和常规虚拟机的可用性：</p><pre><code>VirtualMachineManager manager =
     (VirtualMachineManager)context.
          getSystemService(VirtualMachineManager.class);
if (manager == null) {
    // AVF not supported
} else {
    int capabilities = manager.getCapabilities();
    if ((capabilities &amp; CAPABILITY_PROTECTED_VM) != 0) {
        // protected VM is supported
    }
    if ((capabilities &amp; CAPABILITY_NON_PROTECTED_VM) != 0) {
        // non protected VM is supported
    }
}
</code></pre><p style="text-align:start">有关 AVF 及其 API 的其他文档，请<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fvirtualization" target="_blank">点击此处查看</a>。</p><h3 style="text-align:start"><strong>AVF 组件</strong></h3><p><img align="left" alt="AVF Component architecture" height="219" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjqoflrFdKllbCL-ksao2ozMc0Vwp3eAXNadr58iaiCyd4noAKVuwaetGcVVoU1s1s_g3FA94wCHv_wg8AYbnczEY518U98tUwpYqkyLM-H2IbKpJcNY55xg6yCw5KO2Nk5HW2uAxAGNBXVdDVm8dNdG4das2y7RBWaQCWleykRilaLbd0sfFnb0JOXgC0/s1600/image1.png" width="453" referrerpolicy="no-referrer"></p><p>AVF 由框架 API、<strong>Hypervisor </strong>和虚拟机管理器组成。<strong>Hypervisor </strong>确保虚拟机（包括 Android）相互隔离，就像 Linux 内核对进程的隔离一样。不过，与 Linux 内核相比，AVF <strong>Hypervisor</strong>（pKVM）的代码量要小得多（约 50 倍）。</p><h4 style="text-align:start"><strong>Hypervisor (</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fvirtualization%2Farchitecture%23hypervisor" target="_blank"><strong>pKVM</strong></a><strong>)&nbsp;</strong></h4><p style="text-align:start"><strong>Hypervisor </strong>侧重于开源可用性、安全性、虚拟机的设备分配以及虚拟机之间的隔离安全。它的攻击面较小，符合较高的安全保证级别。受保护的 KVM <strong>Hypervisor</strong>（pKVM）完全支持 AVF API 和功能。</p><p style="text-align:start">pKVM 构建在 Linux 中基于内核的虚拟机（KVM）这一行业标准之上。这意味着所有依赖基于 KVM 的虚拟机的现有操作系统和工作负载都能通过 pKVM 在安卓设备上无缝运行。</p><h4 style="text-align:start"><strong>虚拟机管理器 (</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fexternal%2Fcrosvm%2F" target="_blank"><strong>crosvm</strong></a><strong>)</strong></h4><p style="text-align:start">crosvm 是基于 Rust 的虚拟机管理器（VMM），是 <strong>Hypervisor </strong>与 AVF 框架之间的桥梁。它负责创建、管理和销毁虚拟机。此外，它还提供了一个跨多个 <strong>Hypervisor </strong>实现的抽象层。</p><h4 style="text-align:start"><strong>隔离虚拟机</strong></h4><p style="text-align:start">隔离的虚拟机对 Android 来说是不可见的，即在 Android 中运行的任何进程都无法检查、查看或篡改此类虚拟机的内容。这一保证由 <strong>Hypervisor </strong>提供。</p><h4 style="text-align:start"><strong>虚拟机</strong></h4><p style="text-align:start">虚拟机与隔离的虚拟机相同，只是拥有正确权限的 Android 进程可以访问虚拟机。</p><h4 style="text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fvirtualization%2Fmicrodroid" target="_blank"><strong>Microdroid</strong></a></h4><p style="text-align:start">Microdroid 是一个经过精简的 Android 操作系统软件包，可作为启动虚拟机（VM）的模板。它为开发人员在虚拟机中构建和运行工作负载提供了熟悉的环境。Microdroid 使用熟悉的 Android 工具和库，如 Bionic、Binder IPC 和 keystore 支持。</p><h4 style="text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fvirtualization%2Fvirtualization-service" target="_blank"><strong>虚拟化服务</strong></a></h4><p style="text-align:start">VirtualizationService 管理所有客户虚拟机（无论是否隔离）。它主要通过管理 crosvm 实例来实现。它还公开了 AIDL API，系统服务或特权应用程序可使用该 API 启动、监控和停止虚拟机。</p><h4 style="text-align:start"><strong>RpcBinder</strong></h4><p style="text-align:start">RpcBinder 是为 Android 界面定义语言（AIDL）开发的全新后端。RpcBinder 可使用现有的 binder 线协议与虚拟机进行通信。这意味着：</p><ol><li><p>开发人员可以使用他们已经熟悉的语言和基础架构（AIDL）编写虚拟机接口。</p></li><li><p>只需继续使用现有的 AIDL 接口，即使绑定端点转移到虚拟机中也是如此。</p></li></ol><h3 style="text-align:start"><strong>Android 14 有哪些新功能？</strong></h3><p style="text-align:start">安卓 14 不仅使 AVF 可以在更多设备上使用，还提供了一个新的工具包，使用户可以使用 AVF 及其组件构建更多内容：</p><ul><li><p><strong>用于 AVF 的安卓系统应用程序接口</strong>&nbsp;</p></li></ul><blockquote><p>特权应用程序现在可以使用虚拟机来执行需要隔离的关键工作负载；</p></blockquote><ul><li><p><strong>Hypervisor DevEx 工具包</strong>&nbsp;</p></li></ul><blockquote><p>添加了跟踪功能、改进的可调试性和监控功能，以提供洞察力并协助平台开发人员在隔离虚拟机内进行开发；</p></blockquote><ul><li><p><strong>Hypervisor 供应商模块</strong></p></li></ul><blockquote><p>通过供应商模块扩展，我们的合作伙伴可以定制谷歌的 pKVM，以满足他们的特定需求，实现差异化；</p></blockquote><ul><li><p><strong>改善系统健康</strong>&nbsp;</p></li></ul><blockquote><p>安卓 14 中，基于 microdroid 的虚拟机启动速度比安卓 13 快 2 倍，而内存使用量却只有安卓 13 的一半。</p></blockquote><p>AVF 框架的其它部分可让 Android 服务和应用程序轻松使用虚拟化。例如，使用 AIDL 作为传输层抽象虚拟机之间的通信，管理虚拟机生命周期或虚拟机的创建方式。</p><blockquote><p>原文链接：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid-developers.googleblog.com%2F2023%2F12%2Fvirtual-machines-as-core-android-primitive.html" target="_blank">https://android-developers.googleblog.com/2023/12/virtual-machines-as-core-android-primitive.html</a></p><p><em>Posted by Sandeep Patil – Principal Software Engineer, and Irene Ang – Product Manager</em></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270066/virtual-machines-as-core-android-primitive</guid>
            <link>https://www.oschina.net/news/270066/virtual-machines-as-core-android-primitive</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenTiny Vue 3.12.0 发布：文档大优化！增加水印和二维码两个新组件🎈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>你好，我是 Kagol。</p><p>非常高兴跟大家宣布，2023 年 11 月 30 日，OpenTiny Vue 发布了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Freleases%2Ftag%2Fv3.12.0" target="_blank">v3.12.0</a> 🎉。</p><p>OpenTiny 每次大版本发布，都会给大家带来一些实用的新特性，10.24 我们发布了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Freleases%2Ftag%2Fv3.11.0" target="_blank">v3.11.0</a> 版本，增加了富文本、ColorPicker 等 4 个新组件，该版本共有 23 位贡献者参与。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7293122369610940452" target="_blank">🎊OpenTiny Vue 3.11.0 发布：增加富文本、ColorPicker 等 4 个新组件，迎来了贡献者大爆发！</a></p><p>本次 3.12.0 版本主要有以下更新：</p><ul><li>全面优化 54 个高频组件的 Demo / API 文档，让文档更加清晰易懂、符合预期</li><li>Watermark 水印组件</li><li>QrCode 二维码组件</li></ul><p>本次版本共有 21 位贡献者参与开发，其中有 8 位是新贡献者，欢迎新朋友们👏</p><p>以下是新贡献者：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffanbingbing16" target="_blank">@fanbingbing16</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F686" target="_blank">#686</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdyh333" target="_blank">@dyh333</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F667" target="_blank">#667</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbetavs" target="_blank">@betavs</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F719" target="_blank">#719</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbetterdancing" target="_blank">@betterdancing</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F742" target="_blank">#742</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FDavid-TechNomad" target="_blank">@David-TechNomad</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F772" target="_blank">#772</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ffalcon-jin" target="_blank">@falcon-jin</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F844" target="_blank">#844</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwuyiping0628" target="_blank">@wuyiping0628</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F944" target="_blank">#944</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FJames-9696" target="_blank">@James-9696</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F970" target="_blank">#970</a></li></ul><p>也感谢老朋友们对 OpenTiny 的辛苦付出！</p><p>大家可以更新 <code>@opentiny/vue@3.12.0</code> 进行体验！</p><h2>组件文档优化</h2><p>为了提升开发者阅读文档的体验，从 9 月份至今，我们花了整整三个月时间对 54 个高频组件的 demo / api 文档进行全面的优化。</p><p>希望你能喜欢这波优化，如果你在使用过程中，发现有描述不清楚、不合理、不美观之处，也希望你能给我们提交&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fissues" target="_blank">Issue</a>&nbsp;进行反馈。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7309352577146126373" target="_blank">🎉开发者的福音：TinyVue 组件库文档大优化！类型更详细，描述更清晰！</a></p><h2>Watermark 水印</h2><p>水印组件用于保护文档的版权，防止文档被非法复制或盗用，常见的使用场景有：</p><ul><li>在公司内部文档中添加水印，以防止机密信息泄露</li><li>在商业合同或法律文件中添加水印，以保护文件的真实性和完整性</li><li>在电子书籍或其他数字内容中添加水印，以防止盗版和非法传播</li><li>在社交媒体发布图片时添加水印，以保护自己的版权</li></ul><p>Watermark 使用方式很简单，只需要用水印组件包裹要添加水印的内容即可。</p><pre><code class="language-html">&lt;template&gt;
  &lt;tiny-watermark v-bind="params"&gt;
    &lt;div style="height: 500px"&gt;&lt;/div&gt;
  &lt;/tiny-watermark&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { reactive } from 'vue'
import { Watermark as TinyWatermark } from '@opentiny/vue'

const params = reactive({
  content: ['I ❤️ TinyVue', 'TinyVue is 👍'],
})
&lt;/script&gt;
</code></pre><p>效果如下： <img src="https://oscimg.oschina.net/oscnet/up-562c09e08e9917cda421a6a2587e3ea3c93.png" alt="" referrerpolicy="no-referrer"></p><p>其中水印内容可以支持调整宽高、旋转角度、字体、间距等，并且支持图片水印。</p><p>图片水印效果：</p><p><img src="https://oscimg.oschina.net/oscnet/up-fd8835c16270be5786afdb4a6e2c654618c.png" alt="" referrerpolicy="no-referrer"></p><p>水印组件链接：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue%2Fzh-CN%2Fos-theme%2Fcomponents%2Fwatermark" target="_blank">https://opentiny.design/tiny-vue/zh-CN/os-theme/components/watermark</a></p><p>欢迎体验！</p><h2>QrCode 二维码</h2><p>二维码组件的使用场景非常丰富：</p><ul><li>线下演讲时，可以在 PPT 放个人微信的二维码，方便听众用手机扫码获得讲师的联系方式，进行进一步的沟通</li><li>商家可以在产品上印制二维码，用户通过扫描二维码来获取产品信息或说明书</li><li>用户通过扫描二维码来登录网站或应用，提高登录的安全性和便捷性</li></ul><p>QrCode 使用方式也很简单，只需要传入链接地址即可。</p><pre><code class="language-html">&lt;template&gt;
  &lt;tiny-qr-code v-bind="params"&gt;&lt;/tiny-qr-code&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { QrCode as TinyQrCode } from '@opentiny/vue'

const params = {
  value: 'https://opentiny.design/tiny-vue'
}
&lt;/script&gt;
</code></pre><p>效果如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-6cd3890d8cffa77d3bdc957eba9a64ebdf0.png" alt="" referrerpolicy="no-referrer"></p><p>可以尝试扫描上面的二维码，将会进入 TinyVue 官网。</p><p>二维码的大小、颜色、背景、间距等都支持配置，同时也支持自定义图片。</p><p>自定义图片的二维码效果：</p><p><img src="https://oscimg.oschina.net/oscnet/up-1c1ee113e783fece7810d1d2f23432dc9fd.png" alt="" referrerpolicy="no-referrer"></p><p>二维码组件链接：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue%2Fzh-CN%2Fos-theme%2Fcomponents%2Fqr-code" target="_blank">https://opentiny.design/tiny-vue/zh-CN/os-theme/components/qr-code</a></p><p>欢迎体验！</p><hr><p>欢迎加入 OpenTiny 开源社区。</p><p>添加微信小助手：opentiny-official，一起参与共建！</p><p>开源不易，请给&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">TinyVue</a>&nbsp;点个 Star ⭐ 鼓励下，感谢你对我们 OpenTiny 的大力支持！</p><p>源码：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">https://github.com/opentiny/tiny-vue</a></p><p><img src="https://oscimg.oschina.net/oscnet/up-8eccff9b756a679b6502e7d270961b07240.png" alt="" referrerpolicy="no-referrer"></p><h2>联系我们</h2><p>GitHub：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">https://github.com/opentiny/tiny-vue</a>（欢迎 Star ⭐）</p><p>官网：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue" target="_blank">https://opentiny.design/tiny-vue</a></p><p>B 站：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspace.bilibili.com%2F15284299" target="_blank">https://space.bilibili.com/15284299</a></p><p>公众号：OpenTiny</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4863191/blog/10320008</guid>
            <link>https://my.oschina.net/u/4863191/blog/10320008</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[2023 年，再来聊聊：微服务、中台？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>阿里巴巴市值被拼多多反超后，互联网上出现了各种对比和分析两家公司的文章，基本都是围绕组织架构、商业模式、企业愿景等宏观方面展开。</p><p>片刻之间，阿里此前的各种「战略」似乎都成了「昏招」。这不，曾经他们引以为豪的「中台」也被拿出来批判了。</p><p><img src="https://static.oschina.net/uploads/space/2023/1208/115007_40xS_2720166.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1208/115136_JIEp_2720166.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-3b2b9bdc8dc5a4b3e10ffbfff09cc03a74d.png" referrerpolicy="no-referrer"></p><blockquote><p>阿里巴巴是中国第一个明确提出「中台战略」的企业。在 2015 年年中的时候，马云参观了芬兰游戏公司 Supercell。这家公司的员工人数非常少，还不到 200 人，但是一年的利润高达 15 亿美金。虽然开发了像《部落冲突》这样的知名游戏，但这家公司开发游戏的团队规模都很小，只有六七个人而已。</p><p>这么小规模的团队，怎么做成了这么大的业务呢？其中一个原因是他们把游戏开发过程中，要用的一些通用的游戏素材和算法整理出来，把这些作为工具提供给所有的小团队。</p><p>同一套工具，可以支持好几个小团队研发游戏。这种管理方式，就是一个「中台」的模型。</p><p>参观完之后，马云非常受启发，不久后阿里集团就正式提出了「<strong>大中台、小前台」</strong>的中台战略，通过将原本分散到各个业务的支持部门，比如技术部门、数据部门集中到一起。</p><p>这样，原本分散的支持部门聚合在一起后可以进行快速的服务迭代，更高效地支撑前线，大幅降低支持部门的重复投资建设。从此中台渐入中国企业家的视野。</p></blockquote><hr><p>说到中台，必然离不开「微服务」——这也是前几年非常火热的技术概念，但现在已经没什么话题度了。所以 2023 年，大家对微服务、中台有什么切身感受吗，一起来聊聊。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:47:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270064</guid>
            <link>https://www.oschina.net/news/270064</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米澎湃 OS 首批正式版开始陆续推送]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>小米澎湃 OS 官方微博发布动态称，小米澎湃 OS 第一批正式版正在逐步推送中。</span></p><p><span>5 款机型已于 12 月 7 日起开始陆续推送，分别为 Xiaomi 13 Pro、Xiaomi 13、Redmi K60 Pro、Redmi K60、Xiaomi Pad 6 Max 14。更多机型即将陆续推送。</span></p><p><span>Xiaomi MIX Fold 3、Xiaomi MIX Fold 2、Xiaomi Pad 6 Pro、Xiaomi Pad 6 则预计于 2024 年 1 月开始陆续推送。</span></p><p><img height="667" src="https://oscimg.oschina.net/oscnet/up-b95d11366413ac08d4ed48c93d084478d52.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:32:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270061</guid>
            <link>https://www.oschina.net/news/270061</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[中国信通院发布《区块链白皮书（2023 年）》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">2023 年 12 月 7 日，中国信息通信研究院（简称「中国信通院」）在「2023 年 Web3.0 创新大赛暨颁奖典礼」上<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F6_R6Mvw1xEPoTaTRoInFfQ" target="_blank">发布</a>了《区块链白皮书（2023 年）》并对白皮书进行了深度解读。</span></p><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">白皮书在之前基础上，重点融入了「2023 年区块链生态及产业发展情况调研」相关结果分析，并系统梳理了 2023 年国内外区块链技术、应用创新热点，以及产业生态发展新动态，特别是在全球 Web3.0 快速推进、数据要素价值加快释放的背景下，展望我国区块链技术应用和产业发展新趋势。</span></p><h4 style="margin-left:0px; margin-right:0px"><strong>白皮书核心观点</strong></h4><p style="margin-left:0; margin-right:0"><strong>1. 区块链技术面向高扩展、高性能和高安全持续演进。</strong>当前，区块链技术沿公有链和联盟链两大技术路线分别演进，公有链聚焦高性能、高扩展性和高安全性强化技术创新，联盟链则面向自主化、广域化、规模化应用实现持续优化。当前融合二者优势的开放联盟链也迎来快速发展，有望成为 Web3.0 时代数据价值释放和协作共享的技术底座。</p><p style="margin-left:0; margin-right:0"><strong>2. 区块链技术与公共服务、实体经济等领域深度融合。</strong>全球区块链应用范围从金融领域逐步向外延展，在实体经济、政务服务、公共服务、数字原生等领域加速落地，场景创新、模式创新层出不穷，行业生态逐步完善。此外，数字资产应用拓展了要素的发展边界，数字身份已成为数字世界的重要入口，区块链通过独特的机制正在成为促进数据要素供给流通与价值释放的重要基础设施，为构建 Web3.0 应用生态提供有力支撑。</p><p style="margin-left:0; margin-right:0"><strong>3. 多国政府积极布局 Web3.0 产业发展。</strong>全球多个国家和地区政府正在积极布局 Web3.0 发展，着力提升区块链治理及监管能力，沿不同路径持续推进区块链基础设施建设。我国区块链产业布局更加全面、协作更加紧密，标准体系日益完善，区块链基础设施建设初见成效，国产自主生态正稳步发展壮大。</p><p style="margin-left:0; margin-right:0"><strong>4. 全球加快优化区块链监管治理体系。</strong>全球范围内多个国家和地区正加快推动区块链监管治理体系优化，探索基于区块链的 Web3.0、数字资产等发展路径。我国地方政府积极开展相关布局，以政策扶持、机制创新等方式促进产业发展与监管合规同步推进，为数字经济发展提供新路径和新模式</p><p style="margin-left:0; margin-right:0"><img height="278" src="https://oscimg.oschina.net/oscnet/up-4dcdb04a180dee8c68991d52429f2a6c2cf.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="303" src="https://oscimg.oschina.net/oscnet/up-cc6a0478e95ab4852645905ddfd7661997b.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="309" src="https://oscimg.oschina.net/oscnet/up-e9d6c8a146fce01dab3e8838032809ad6f1.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="304" src="https://oscimg.oschina.net/oscnet/up-fc41d1b4f65c0ba86ad662b7019a04e50d2.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="307" src="https://oscimg.oschina.net/oscnet/up-e3b923b9f287991de935689803c56da9f6a.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="309" src="https://oscimg.oschina.net/oscnet/up-2862283eaefbd74a141207fba2634893f29.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="304" src="https://oscimg.oschina.net/oscnet/up-85f57208cc7017a701696280ab3e56b201a.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="311" src="https://oscimg.oschina.net/oscnet/up-264fed980163542fda3951f73cfafa9c9ef.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="311" src="https://oscimg.oschina.net/oscnet/up-22eb41296a9f9d624589657f9570e1a3818.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="306" src="https://oscimg.oschina.net/oscnet/up-5aec9e8e8721925137d746e323b3a4b472e.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="310" src="https://oscimg.oschina.net/oscnet/up-354bc09172ab7fb04087f99b2d259a2737c.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="313" src="https://oscimg.oschina.net/oscnet/up-d1edf6f022b4fb437c2d1ec45461338d608.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="303" src="https://oscimg.oschina.net/oscnet/up-9afaffbca935ed920989d45296f9ef7df9d.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="301" src="https://oscimg.oschina.net/oscnet/up-5d0ebfdcc4b0800d3d6aef007e153610e30.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="310" src="https://oscimg.oschina.net/oscnet/up-ef45c8ef4adcf6de0893a2b7c1585484e5e.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="310" src="https://oscimg.oschina.net/oscnet/up-7112a4582a8090126bac3344cffcd931c4b.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="306" src="https://oscimg.oschina.net/oscnet/up-4d508541738c8fc65a2f367dfeb655bda8b.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="311" src="https://oscimg.oschina.net/oscnet/up-a8bb5722b74ee290874eb54b2373cb00ff6.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><img height="306" src="https://oscimg.oschina.net/oscnet/up-50cbdf8186a0c4335d77afaa69acda349e2.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270058</guid>
            <link>https://www.oschina.net/news/270058</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度 Comate 荣获「2023 AIIA 人工智能十大先锋应用案例」奖]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>12 月 7-8 日，中国人工智能产业发展联盟（AIIA）第十次全体会议暨 2023 年通用人工智能创新发展论坛在重庆召开。</span>大会围绕软件工程、基础平台、科学智能、具身智能等技术创新，数据、开源开放、安全治理等产业关键要素，以及金融、汽车等重点行业应用等人工智能最新热点展开。</p><p><span>作为大会重磅环节，从今年 10 月起，AIIA 启动</span><strong>「2023 人工智能十大先锋应用案例征集」活动</strong><span>，旨在甄选具有高价值、标杆性、真落地的行业典型应用实践，打造 AI 界「奥斯卡」。经过为期 2 个月的征集评审，从百余项入围案例中，</span><strong>百度智能代码助手 Comate 脱颖而出，斩获「2023AIIA 人工智能十大先锋应用案例」奖，也是本次十大先锋应用案例奖中的唯一软件工程领域 AI 应用</strong><span><strong>。</strong></span></p><p><img height="846" src="https://static.oschina.net/uploads/space/2023/1208/110825_3Ktq_3820517.png" width="1269" referrerpolicy="no-referrer"></p><p><strong>（现场颁奖）</strong></p><p>从在百度内部全面落地应用，到面向企业开发者发布「国内首个商用全场景智能编程助手」，再到 SaaS 版全面开放，百度 Comate 厚积薄发，持续引领 AI 原生研发新范式。</p><p>目前，百度 Comate 已覆盖 100+种编程语言，支持 10+种主流 IDE，覆盖编程前、后、移动端，支持软硬件不同开发场景，为研发全生命周期提供全场景智能辅助，大幅提升研发效率的同时，也提升了工程师的工作幸福感。</p><p><img height="716" src="https://static.oschina.net/uploads/space/2023/1208/110838_ghZG_3820517.png" width="1268" referrerpolicy="no-referrer"></p><p><span>在技术创新优势上，依赖文心大模型、飞桨深度学习平台以及百度多年积累的技术经验，Comate 智能代码助手具备</span><strong>模型训练、推理加速、工程实践和安全保障四重技术创新</strong><span>，并在</span><strong>代码续写、代码解释、NL2Code、Code Debug 等能力上领先行业与竞品</strong><span>。</span></p><p><img height="712" src="https://static.oschina.net/uploads/space/2023/1208/110849_LSh5_3820517.png" width="1267" referrerpolicy="no-referrer"></p><p>在应用实效上，基于模型层多种能力，百度 Comate 具有优秀的代码推荐、单测生成、自然语言代码生成和代码修复等能力；并通过开放 SaaS 版和私有化部署能力，满足个人用户、中小企业和大型企业的不同需求。在百度内部，通过 Comate 生成代码占比 20%，整体采纳率达 40%；SaaS 版开箱即用，注册企业累计 4000+；涵盖金融、汽车、互联网、高端制造等在内的数十家大型企业已与 Comate 达成私有化部署合作。</p><p><img height="1842" src="https://static.oschina.net/uploads/space/2023/1208/192440_aMPH_3820517.png" width="3260" referrerpolicy="no-referrer"></p><p>未来，百度 Comate 还将持续强化产品能力建设，坚守安全性的同时增强开放性，为企业和个人用户提供更智能、更高效、更便捷的代码辅助服务，助力研发效率持续提升，加速产业创新落地。</p><p>马上申请免费试用，还有超多限时福利！</p><p><img height="533" src="https://static.oschina.net/uploads/space/2023/1208/110911_Fwzq_3820517.png" width="300" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:10:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270054/comate-aiia-2023-news</guid>
            <link>https://www.oschina.net/news/270054/comate-aiia-2023-news</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[网信办发布《网络安全事件报告管理办法（征求意见稿）》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>国家互联网信息办公室就《网络安全事件报告管理办法（征求意见稿）》公开征求意见。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-c1eb5e22a141f8e4fc99760bb45a85f397d.png" referrerpolicy="no-referrer"></p><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.cac.gov.cn%2F2023-12%2F08%2Fc_1703609634347501.htm" target="_blank">http://www.cac.gov.cn/2023-12/08/c_1703609634347501.htm</a></u></em></p></blockquote><p>征求意见稿提出，运营者在发生网络安全事件时，应当及时启动应急预案进行处置。按照《网络安全事件分级指南》，<strong>属于较大、重大或特别重大网络安全事件的，应当于 1 小时内进行报告</strong>。</p><p>其中，<strong>网络和系统归属中央和国家机关各部门及其管理的企事业单位的，运营者应当向本部门网信工作机构报告</strong>。属于重大、特别重大网络安全事件的，各部门网信工作机构在收到报告后应当于 1 小时内向国家网信部门报告。</p><p><strong>网络和系统为关键信息基础设施的，运营者应当向保护工作部门、公安机关报告</strong>。属于重大、特别重大网络安全事件的，保护工作部门在收到报告后，应当于 1 小时内向国家网信部门、国务院公安部门报告。</p><p><strong>其他网络和系统运营者应当向属地网信部门报告</strong>。属于重大、特别重大网络安全事件的，属地网信部门在收到报告后，应当于 1 小时内逐级向上级网信部门报告。</p><p>有行业主管监管部门的，<strong>运营者还应当按照行业主管监管部门要求报告</strong>。</p><p>运营者应当按照《网络安全事件信息报告表》报告事件，至少包括下列内容：</p><ul><li><p><strong>事发单位名称及发生事件的设施、系统、平台的基本情况</strong>；</p></li><li><p><strong>事件发现或发生时间、地点、事件类型、已造成的影响和危害，已采取的措施及效果</strong>。对勒索软件攻击事件，还应当包括要求支付赎金的金额、方式、日期等；</p></li><li><p>事态发展趋势及可能进一步造成的影响和危害；</p></li><li><p>初步分析的事件原因；</p></li><li><p>进一步调查分析所需的线索，包括可能的攻击者信息、攻击路径、存在的漏洞等；</p></li><li><p>拟进一步采取的应对措施以及请求支援事项；</p></li><li><p>事件现场的保护情况；</p></li><li><p>其他应当报告的情况。</p></li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-c423dc28f0c5f4929c6ec12f752d357f88f.png" referrerpolicy="no-referrer"></p><p>当事件处置结束后，运营者应当于 5 个工作日内对事件原因、应急处置措施、危害、责任处理、整改情况、教训等进行全面分析总结，形成报告按照原渠道上报。</p><hr><p>附网络安全事件分级指南：</p><p><img height="1406" src="https://oscimg.oschina.net/oscnet/up-3bd9fcd558b1e34d9278bc32bdf7f4a8048.png" width="1030" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-b5c16894520b3208bea288209ff7de41132.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-66e96efeef0f4b5e2538e297a57ab5d40a8.png" referrerpolicy="no-referrer"></p><p><img height="1486" src="https://oscimg.oschina.net/oscnet/up-79b90dfeb4395d333078f97cdaff1a28129.png" width="936" referrerpolicy="no-referrer"></p><p><img height="1488" src="https://oscimg.oschina.net/oscnet/up-77f78a766c7e070b24b239150c9ec5de38f.png" width="934" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-dd98b736f8b6a5c76679267826d5058dada.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270052</guid>
            <link>https://www.oschina.net/news/270052</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[支付宝启动鸿蒙原生应用开发]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>支付宝与华为终端宣布合作，基于 HarmonyOS NEXT 启动支付宝鸿蒙原生应用开发。</p><p><img alt="" height="326" src="https://oscimg.oschina.net/oscnet/up-a9aa0abdc54a1c436a2c973752477f7b5a2.webp" width="500" referrerpolicy="no-referrer"></p><p>支付宝事业群总裁倪行军表示，双方的合作将进一步满足用户在不同终端、不同场景下享受智慧生活服务的需求；同时，华为在支付宝小程序领域的数字化布局也有利于提升商家在两个生态中的经营效率。</p><p><span style="background-color:#ffffff; color:#2b2b2b">支付宝目前服务商家已达 8000 万。通过支付宝 App，有近 400 万个商家机构小程序，扫码点单、生活缴费等超过 1000 项生活服务。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 02:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270047</guid>
            <link>https://www.oschina.net/news/270047</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米发布《小米澎湃 OS 技术白皮书》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米正式发布《小米澎湃 OS 技术白皮书》（下简称《白皮书》）。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-7edcacdddcb86895ce723541906e9102497.png" referrerpolicy="no-referrer"></p><p><strong><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcdn-file.hyperos.mi.com%2Fhyperos-file%2F%25E5%25B0%258F%25E7%25B1%25B3%25E6%25BE%258E%25E6%25B9%2583OS%25E6%258A%2580%25E6%259C%25AF%25E7%2599%25BD%25E7%259A%25AE%25E4%25B9%25A6V1.0.pdf" target="_blank">小米澎湃 OS 技术白皮书 V1.0</a></em></u></strong></p></blockquote><p>根据《白皮书》介绍，小米澎湃 OS 是一个为下一代的计算与多种设备生态设计的系统。</p><p><span style="background-color:rgba(255, 255, 255, 0.65); color:#151631">《白皮书》</span>对小米澎湃 OS 系统架构进行了详细介绍、包括对各个子系统的架构以及关键技术的阐述，以及开发团队对各个子系统的设计思路。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1dff4e9939fb63c6ac59b0c14f3aa700571.png" referrerpolicy="no-referrer"></p><p>小米表示：「希望通过分享这些技术成果和见解，激发更多的创意和合作，推动整个行业的进步，共同构建「人车家全生态」的未来。」</p><p>小米 CEO 雷军在《白皮书》的序言中说道，2016 年，小米就开始研发跨端应用框架。2019 年，开始并行研发纯自研通用系统 Mina OS，并在部分产品上小规模量产验证，同时在实验室中也成功在手机上跑通，其中部分技术成果也已融入小米澎湃 OS。2021 年，小米开启了车机 OS 的研发。2022 年初，小米决定统一 MIUI、Vela、Mina、车机 OS 四个系统的软件架构。自此，小米的操作系统底层合并完成。</p><blockquote><p><img height="1690" src="https://oscimg.oschina.net/oscnet/up-2b2e2aa832685a84d24571029ea1b7cccf2.png" width="1760" referrerpolicy="no-referrer"></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 02:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270045</guid>
            <link>https://www.oschina.net/news/270045</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux 内核源代码官网 git.kernel.org 原生支持深色模式]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Linux 内核开发者收到了一份提前的圣诞礼物 ——&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgit.kernel.org%2F" target="_blank">git.kernel.org</a>&nbsp;Web 界面已原生支持深色模式。对于开发者来说，深色模模式可以增强浏览官方 Linux 内核 Git 仓库，以及其他开发分支的查看体验。</p><p><img src="https://oscimg.oschina.net/oscnet/up-7e14e90ceb4a018a01f4aebacdc75e3f470.png" referrerpolicy="no-referrer"></p><p>从提交记录可以看到，几个月前就已经有补丁将 CSS 暗模式支持添加到 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fgit.kernel.org" target="_blank">git.kernel.org</a> cgit Web 界面，现在终于上线了。</p><p><img src="https://oscimg.oschina.net/oscnet/up-514a596f11bc68a1ff4ba9c95167bba29c7.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 02:17:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270043</guid>
            <link>https://www.oschina.net/news/270043</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 前后端分离的全栈开源项目 AirPower]]>
            </title>
            <description>
                <![CDATA[<p align="center"><img width="300" src="https://gitee.com/air-power/AirPower4T/raw/web/assets/img/airpower.png" referrerpolicy="no-referrer"></p><p align="center"><img src="https://svg.hamm.cn/?key=Lang&amp;value=TypeScript&amp;bg=green" referrerpolicy="no-referrer"><img src="https://svg.hamm.cn/?key=Base&amp;value=Vue3" referrerpolicy="no-referrer"><img src="https://svg.hamm.cn/?key=Build&amp;value=Vite" referrerpolicy="no-referrer"><img src="https://svg.hamm.cn/?key=UI&amp;value=ElementPlus" referrerpolicy="no-referrer"></p><p><a href="https://gitee.com/air-power/AirPower4T">Gitee</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FHammCn%2FAirPower4T">Github</a> / <a href="https://gitee.com/air-power/AirPower4T/blob/web/CHANGELOG.md">CHANGELOG</a></p><h2><a id="user-content--这是个什么项目" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E8%BF%99%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%A1%B9%E7%9B%AE"></a>📖 这是个什么项目</h2><blockquote><p>你当前查看的是 <code>web</code> 分支，我们也同时提供了 <code>wechat</code>、<code>uniapp</code> 等分支：） 你可以先阅读 <a href="https://gitee.com/link?target=https%3A%2F%2Fjuejin.cn%2Fpost%2F7273290114921889807">掘金专栏</a> 的一些文章，也可以体验 <a href="https://gitee.com/link?target=https%3A%2F%2Fservice.hamm.cn">线上示例 DEMO</a>，如果你喜欢这个项目，欢迎给我们大大的 ⭐️⭐️⭐️</p></blockquote><p>为了满足前端开发标准化、工程化、系统化等等需求，我们设计并开发了一个开发组件库和常用类库和方法库的集合基础脚手架，其中包含了一些页面通用的布局、常用的弹窗和交互、提示信息以及网络请求，强类型面向对象的约束规范等，以满足日常开发的快捷、稳健、标准化等要求。</p><p><strong>AirPower</strong> 是一个基于 <code>Vue3</code><code>TypeScript</code><code>Element Plus</code><code>Vite</code> 的开发基础库，使用 <strong>装饰器</strong>、<strong>面向对象</strong>、<strong>Hook</strong> 等前端开发方式。</p><h2><a id="user-content--为何起名 airpower" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E4%B8%BA%E4%BD%95%E8%B5%B7%E5%90%8Dairpower"></a>🎈 为何起名<strong>AirPower</strong></h2><p>早期是子仓库方式的设计, 这个依赖库跟宿主项目在一起, 所以为了排前面, 选择使用<strong>A</strong>开头的单词, 后来想起 <strong>Apple</strong> 家难产了的一个产品的名称, <strong>AirPower</strong>, 作者是 Apple 十年老粉, 那就顺便致敬下 <strong>Apple</strong>.</p><h2><a id="user-content--有哪些功能设计" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1"></a>🎉 有哪些功能 (设计)</h2><ol><li><strong>Model</strong> / <strong>Entity</strong> 所有的数据交互都以数据模型实例的方式进行, 不再直接使用 JSON.</li><li><strong>Service</strong> 使用服务类对所有的网络请求进行抽象, 通过继承方式实现相似代码的复用</li><li><strong>Component</strong> 提供了很多后台管理系统常用的组件和一些反馈组件</li><li><strong>Hook</strong> 提供了与 Service 交互的一些通用的交互 Hooks</li><li><strong>Enum</strong> 提供了很多很多很多的枚举</li><li><strong>Decorator</strong> 提供了很多很多很多的装饰器</li><li>提供了类似 <strong>Java</strong> BeanCopy 相关的数据转换方式, 提供了完整的面向对象实现</li><li>......</li></ol><h2><a id="user-content--代码风格展示" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%B1%95%E7%A4%BA"></a>💻 代码风格展示</h2><p><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/1.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/2.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/3.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/4.png" referrerpolicy="no-referrer"></p><h2><a id="user-content--如何使用初始化" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96"></a>🔑 如何使用 (初始化)?</h2><p>你可以通过我们提供的 <code>AirPower 宿主仓库</code> 项目来完成 <strong>AirPower</strong> 宿主项目的初始化:</p><p>AirPowerWebStarter via <a href="https://gitee.com/air-power/AirPowerWebStarter/blob/main/README.md">Gitee</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FHammCn%2FAirPowerWebStarter%2Fblob%2Fmain%2FREADME.md">Github</a></p><h2><a id="user-content--我们的建议" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E6%88%91%E4%BB%AC%E7%9A%84%E5%BB%BA%E8%AE%AE"></a>🛎 我们的建议</h2><p>我们提供的 <strong>AirPower 宿主仓库</strong> 里面提供了一些 <code>ESlint 规则</code><code>路由配置</code><code>环境变量配置</code><code>tsconfig</code><code>vite.config</code>, 以及很多的 <strong>demo</strong> 代码, 你可以进行参考。</p><p>如果你有什么疑问或者问题，你也可以加入开发者交流 QQ 群 (<code>555156313</code>) 进行咨询，当然，我们更建议你发起 <a href="https://gitee.com/air-power/AirPower4T/issues/new">Gitee issue</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FHammCn%2FAirPower4T%2Fissues%2Fnew">Github issue</a></p><h2><a id="user-content--enjoy-it" class="anchor" href="https://gitee.com/air-power/AirPower4T#-enjoy-it"></a>⏰ Enjoy it</h2><p>好了, 那么接下来你可以愉快的开发了, 如果你有什么建议或者意见, 可以在本仓库中提交你的 <strong>issues</strong>, 你可以为这个依赖库进行 <strong>添砖加瓦</strong>!</p><blockquote><p>☕️Java: 加瓦? 什么 Java?</p></blockquote><h2><a id="user-content--来点图示例" class="anchor" href="https://gitee.com/air-power/AirPower4T#-%E6%9D%A5%E7%82%B9%E5%9B%BE%E7%A4%BA%E4%BE%8B"></a>📷 来点*图 (示例)</h2><p><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/5.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/6.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/7.png" referrerpolicy="no-referrer"><img width="24%" src="https://gitee.com/air-power/AirPower4T/raw/web/docs/img/8.png" referrerpolicy="no-referrer"></p>]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 10:39:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/air-power/AirPower4T</guid>
            <link>https://gitee.com/air-power/AirPower4T</link>
        </item>
        <item>
            <title>
                <![CDATA[周星驰 Web3 团队下个月上线独立 App]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>12 月 7 日，新浪科技报道称，周星驰 Web3 团队透露，周星驰旗下 Web3 初创公司 Moonbox&nbsp;最早将于明年 1 月份完成上线 Moonbox App，届时 App 将免费向用户开放。</p><p>目前，App 研发工作已经基本完成，Moonbox 团队在 NFT 玩法上下了很多功夫，已设计出基于 AI 和 NFT 聊天的互动玩法，「周星驰将以 Moonbox First Creator 身份与大家见面」。</p><p>与此同时，周星驰参与创作的 NobodyNFT 新品，也将随之发售，用户可以通过 App 和每个 Nobody NFT 角色聊天互动以了解人物性格、爱好、背景故事。</p><p>据悉，2023 年 8 月，周星驰曾公开宣布入局 Web3+AI，并第一时间与 OKX 进行互动。周星驰当时在 INS 发文称，「感恩找到一班志同道合的 Web3 伙伴，正在研究 Web3+AI 项目，希望做个我的 AI 代替我。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1fa24c9504d7b6c03e1cf018b165b6154e6.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 09:06:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269952</guid>
            <link>https://www.oschina.net/news/269952</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[新概念「防御性编程」：让自己稳拿铁饭碗]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img height="559" src="https://static.oschina.net/uploads/space/2023/1207/164342_Cpqj_3820517.png" width="400" referrerpolicy="no-referrer"></p><p>&nbsp;</p><blockquote><p>译者：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FcoderLMN" target="_blank"><span style="color:#3498db"><span style="background-color:#fdfdfd">/coderLMN</span></span></a></p><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>翻译链接：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcoderlmn.github.io%2FfrontEndCourse%2Funmaintainable.html" target="_blank">https://coderlmn.github.io/frontEndCourse/unmaintainable.html</a></p></blockquote><hr><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>让自己稳拿铁饭碗 ;-)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><p><strong>-- Roedy Green</strong><br><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>（老码农翻译，略有删节）</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br> &nbsp;</p><hr><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>简介</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>永远不要（把自己遇到的问题）归因于（他人的）恶意，这恰恰说明了（你自己的）无能。&nbsp;</em>-- 拿破仑</p></blockquote><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>为了造福大众，在 Java 编程领域创造就业机会，兄弟我在此传授大师们的秘籍。这些大师写的代码极其难以维护，后继者就是想对它做最简单的修改都需要花上数年时间。而且，如果你能对照秘籍潜心修炼，你甚至可以给自己弄个铁饭碗，因为除了你之外，没人能维护你写的代码。再而且，如果你能练就秘籍中的<strong>全部</strong>招式，那么连你自己都无法维护你的代码了！</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>你不想练功过度走火入魔吧。那就不要让你的代码<strong>一眼看去</strong>就完全无法维护，只要它<strong>实质上是</strong>那样就行了。否则，你的代码就有被重写或重构的风险！</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>总体原则</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>Quidquid latine dictum sit, altum sonatur.</em><br> (随便用拉丁文写点啥都会显得高大上。)</p></blockquote><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>想挫败维护代码的程序员，你必须先明白他的思维方式。他接手了你的庞大程序，没有时间把它全部读一遍，更别说理解它了。他无非是想快速找到修改代码的位置、改代码、编译，然后就能交差，并希望他的修改不会出现意外的副作用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>他查看你的代码不过是管中窥豹，一次只能看到一小段而已。你要确保他永远看不到全貌。要尽量和让他难以找到他想找的代码。但更重要的是，要让他不能有把握<strong>忽略</strong>任何东西。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>程序员都被编程惯例洗脑了，还为此自鸣得意。每一次你处心积虑地违背编程惯例，都会迫使他必须用放大镜去仔细阅读你的每一行代码。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>你可能会觉得每个语言特性都可以用来让代码难以维护，其实不然。你必须精心地误用它们才行。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>命名</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>"当我使用一个单词的时候" Humpty Dumpty 曾经用一种轻蔑的口气说, "它就是我想表达的意思，不多也不少。「</em><br> - Lewis Carroll -- 《爱丽丝魔镜之旅》， 第 6 章</p></blockquote><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>编写无法维护代码的技巧的重中之重是变量和方法命名的艺术。如何命名是和编译器无关的。这就让你有巨大的自由度去利用它们迷惑维护代码的程序员。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>妙用&nbsp;宝宝起名大全</h4><p>买本宝宝起名大全，你就永远不缺变量名了。比如&nbsp;<span style="color:#000099"><span>Fred</span></span>&nbsp;就是个好名字，而且键盘输入它也省事。如果你就想找一些容易输入的变量名，可以试试&nbsp;<span style="color:#000099"><span>adsf</span></span>&nbsp;或者&nbsp;<span style="color:#000099"><span>aoeu</span></span>之类。</p><h4>单字母变量名</h4><p>如果你给变量起名为 a,b,c，用简单的文本编辑器就没法搜索它们的引用。而且，没人能猜到它们的含义。</p><h4>创造性的拼写错误</h4><p>如果你必须使用描述性的变量和函数名，那就把它们都拼错。还可以把某些函数和变量名拼错，再把其他的拼对 (例如 SetPintleOpening 和 SetPintalClosing) ，我们就能有效地将 grep 或 IDE 搜索技术玩弄于股掌之上。这招超级管用。还可以混淆不同语言（比如<em>colour</em>&nbsp;-- 英国英语，和&nbsp;<em>color</em>&nbsp;-- 美国英语)。</p><h4>抽象</h4><p>在命名函数和变量的时候，充分利用抽象单词，例如&nbsp;<em>it</em>,&nbsp;<em>everything</em>,&nbsp;<em>data</em>,&nbsp;<em>handle</em>,&nbsp;<em>stuff</em>,&nbsp;<em>do</em>,&nbsp;<em>routine</em>,&nbsp;<em>perform</em>&nbsp;和数字，例如 e.g.&nbsp;<span style="color:#000099"><span>routineX48</span></span>,&nbsp;<span style="color:#000099"><span>PerformDataFunction</span></span>,&nbsp;<span style="color:#000099"><span>DoIt</span></span>,&nbsp;<span style="color:#000099"><span>HandleStuff</span></span>&nbsp;还有&nbsp;<span style="color:#000099"><span>do_args_method</span></span>。</p><h4>首字母大写的缩写</h4><p>用首字母大写缩写（比如 GNU 代表 GNU's Not Unix) 使代码简洁难懂。真正的汉子 (无论男女) 从来不说明这种缩写的含义，他们生下来就懂。</p><h4>辞典大轮换</h4><p>为了打破沉闷的编程气氛，你可以用一本辞典来查找尽量多的同义词。例如&nbsp;<em>display</em>,&nbsp;<em>show</em>,&nbsp;<em>present</em>。在注释里含糊其辞地暗示这些命名之间有细微的差别，其实根本没有。不过，如果有两个命名相似的函数真的有重大差别，那倒是一定要确保它们用相同的单词来命名 (例如，对于 "写入文件", "在纸上书写" 和 "屏幕显示" 都用&nbsp;<em>print</em>&nbsp;来命名)。 在任何情况下都不要屈服于编写明确的项目词汇表这种无理要求。你可以辩解说，这种要求是一种不专业的行为，它违反了结构化设计的<em>信息隐藏原则</em>。</p><h4>首字母大写</h4><p>随机地把单词中间某个音节的首字母大写。例如&nbsp;<span style="color:#000099"><span>ComputeReSult()</span></span>。</p><h4>重用命名</h4><p>在语言规则允许的地方，尽量把类、构造器、方法、成员变量、参数和局部变量都命名成一样。更高级的技巧是在{}块中重用局部变量。这样做的目的是迫使维护代码的程序员认真检查每个示例的范围。特别是在 Java 代码中，可以把普通方法伪装成构造器。</p><h4>使用非英语字母</h4><p>在命名中偷偷使用不易察觉的非英语字母，例如看上去没啥不对是吧？嘿嘿嘿...这里的第二个 ínt 的&nbsp;<strong>í</strong>&nbsp;实际上是东北欧字母，并不是英语中的 i 。在简单的文本编辑器里，想看出这一点点区别几乎是不可能的。</p><h4>巧妙利用编译器对于命名长度的限制</h4><p>如果编译器只区分命名的前几位，比如前 8 位，那么就把后面的字母写得不一样。比如，其实是同一个变量，有时候写成&nbsp;<em>var_unit_update()</em>&nbsp;，有时候又写成&nbsp;<em>var_unit_setup()</em>，看起来是两个不同的函数调用。而在编译的时候，它们其实是同一个变量&nbsp;<em>var_unit</em>。</p><h4>下划线，一位真正的朋友</h4><p>可以拿 _ 和 __ 作为标示符。</p><h4>混合多语言</h4><p>随机地混用两种语言（人类语言或计算机语言都行）。如果老板要求使用他指定的语言，你就告诉他你用自己的语言更有利于组织你的思路，万一这招不管用，就去控诉这是语言歧视，并威胁起诉老板要求巨额精神损失赔偿。</p><h4>扩展 ASCII 字符</h4><p>扩展 ASCII 字符用于变量命名是完全合法的，包括 ß, Ð, 和 ñ 等。在简单的文本编辑器里，除了拷贝/粘贴，基本上没法输入。</p><h4>其他语言的命名</h4><p>使用外语字典作为变量名的来源。例如，可以用德语单词&nbsp;<em>punkt</em>&nbsp;代替&nbsp;<em>point</em>。除非维护代码的程序员也像你一样熟练掌握了德语. 不然他就只能尽情地在代码中享受异域风情了。</p><h4>数学命名</h4><p>用数学操作符的单词来命名变量。例如：</p><p>openParen<span>&nbsp;</span><strong>=</strong><span>&nbsp;</span>(slash<span>&nbsp;</span><strong>+</strong><span>&nbsp;</span>asterix)<span>&nbsp;</span><strong>/</strong><span>&nbsp;</span>equals;<br> (左圆括号 = (斜杠 + 星号)/等号;)</p><h4>令人眩晕的命名</h4><p>用带有完全不相关的感情色彩的单词来命名变量。例如：这一招可以让阅读代码的人陷入迷惑之中，因为他们在试图想清楚这些命名的逻辑时，会不自觉地联系到不同的感情场景里而无法自拔。</p><p>marypoppins<span>&nbsp;</span><strong>=</strong><span>&nbsp;</span>(superman<span>&nbsp;</span><strong>+</strong><span>&nbsp;</span>starship)<span>&nbsp;</span><strong>/</strong><span>&nbsp;</span>god;<br> (欢乐满人间 = (超人 + 星河战队)/上帝;)</p><h4>何时使用 i</h4><p>永远不要把&nbsp;<span style="color:#000099"><span>i</span></span>&nbsp;用作最内层的循环变量。 用什么命名都行，就是别用<span style="color:#000099"><span>i</span></span>。把&nbsp;<span style="color:#000099"><span>i</span></span>&nbsp;用在其他地方就随便了，用作非整数变量尤其好。</p><h4>惯例 -- 明修栈道，暗度陈仓</h4><p>忽视&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fjava.sun.com%2Fdocs%2Fcodeconv%2F" target="_blank">Java 编码惯例</a>，Sun 就是这样做的。幸运的是，你违反了它编译器也不会打小报告。这一招的目的是搞出一些在某些特殊情况下有细微差别的名字来。如果你被强迫遵循驼峰法命名，你还是可以在某些模棱两可的情况下颠覆它。例如，<em>input<strong>F</strong>ile<strong>n</strong>ame</em>&nbsp;和&nbsp;<em>input<strong>f</strong>ile<strong>N</strong>ame</em>&nbsp;两个命名都可以合法使用。在此基础上自己发明一套复杂到变态的命名惯例，然后就可以痛扁其他人，说他们违反了惯例。</p><h4>小写的 l 看上去很像数字 1</h4><p>用小写字母 l 标识 long 常数。例如 10l 更容易被误认为是 101 而不是 10L 。 禁用所有能让人准确区分 uvw wW gq9 2z 5s il17|!j oO08 `'" ;,. m nn rn {[()]} 的字体。要做个有创造力的人。</p><h4>把全局命名重用为私有</h4><p>在 A 模块里声明一个全局数组，然后在 B 模块的头文件里在声明一个同名的私有数组，这样看起来你在 B 模块里引用的是那个全局数组，其实却不是。不要在注释里提到这个重复的情况。</p><h4>误导性的命名</h4><p>让每个方法都和它的名字蕴含的功能有一些差异。例如，一个叫&nbsp;<span style="color:#000099"><span>isValid(x)</span></span>的方法在判断完参数 x 的合法性之后，还顺带着把它转换成二进制并保存到数据库里。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>伪装</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>当一个 bug 需要越长的时间才会暴露，它就越难被发现。</em><br> - Roedy Green（本文作者）</p></blockquote><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>编写无法维护代码的另一大秘诀就是伪装的艺术，即隐藏它或者让它看起来像其他东西。很多招式有赖于这样一个事实：编译器比肉眼或文本编辑器更有分辨能力。下面是一些伪装的最佳招式。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>把代码伪装成注释，反之亦然</h4><p>下面包括了一些被注释掉的代码，但是一眼看去却像是正常代码。 如果不是用绿色标出来，你能注意到这三行代码被注释掉了么？</p><pre><code>for(j=0; j&lt;array_len; j+ =8)
    {
    total += array[j+0 ];
    total += array[j+1 ];
    total += array[j+2 ]; /* Main body of
    total += array[j+3]; * loop is unrolled
    total += array[j+4]; * for greater speed.
    total += array[j+5]; */
    total += array[j+6 ];
    total += array[j+7 ];
    }</code></pre><h4>用连接符隐藏变量</h4><p>对于下面的定义</p><p>#define local_var xy_z</p><p>可以把 "xy_z" 打散到两行里：</p><p>#define local_var xy\<br> _z // local_var OK</p><p>这样全局搜索 xy_z 的操作在这个文件里就一无所获了。 对于 C 预处理器来说，第一行最后的 "\" 表示继续拼接下一行的内容。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>文档</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><em>任何傻瓜都能说真话，而要把谎编圆则需要相当的智慧。</em><br> - Samuel Butler (1835 - 1902)
</blockquote><p style="text-align:start">&nbsp;</p><blockquote><em>不正确的文档往往比没有文档还糟糕。</em><br> - Bertrand Meyer
</blockquote><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>既然计算机是忽略注释和文档的，你就可以在里边堂而皇之地编织弥天大谎，让可怜的维护代码的程序员彻底迷失。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>在注释中撒谎</h4><p>实际上你不需要主动地撒谎，只要没有及时保持注释和代码更新的一致性就可以了。</p><h4>只记录显而易见的东西</h4><p>往代码里掺进去类似于&nbsp;<span style="color:green">/* 给 i 加 1 */</span>&nbsp;这样的注释，但是永远不要记录包或者方法的整体设计这样的干货。 &nbsp;</p><h4>记录 How 而不是 Why</h4><p>只解释一个程序功能的细节，而不是它要完成的任务是什么。这样的话，如果出现了一个 bug，修复者就搞不清这里的代码应有的功能。</p><h4>该写的别写</h4><p>比如你在开发一套航班预定系统，那就要精心设计，让它在增加另一个航空公司的时候至少有 25 处代码需要修改。永远不要在文档里说明要修改的位置。后来的开发人员要想修改你的代码门都没有，除非他们能把每一行代码都读懂。</p><h4>计量单位</h4><p>永远不要在文档中说明任何变量、输入、输出或参数的计量单位，如英尺、米、加仑等。计量单位对数豆子不是太重要，但在工程领域就相当重要了。同理，永远不要说明任何转换常量的计量单位，或者是它的取值如何获得。要想让代码更乱的话，你还可以在注释里写上错误的计量单位，这是赤裸裸的欺骗，但是非常有效。如果你想做一个恶贯满盈的人，不妨自己发明一套计量单位，用自己或某个小人物的名字命名这套计量单位，但不要给出定义。万一有人挑刺儿，你就告诉他们，你这么做是为了把浮点数运算凑成整数运算而进行的转换。 &nbsp;</p><h4>坑</h4><p>永远不要记录代码中的坑。如果你怀疑某个类里可能有 bug，天知地知你知就好。如果你想到了重构或重写代码的思路，看在老天爷的份上，千万别写出来。切记电影《小鹿斑比》里那句台词&nbsp;<em>"如果你不能说好听的话，那就什么也不要说。"</em>。万一这段代码的原作者看到你的注释怎么办？万一老板看到了怎么办？万一客户看到了怎么办？搞不好最后你自己被解雇了。一句」这里需要修改「的匿名注释就好多了，尤其是当看不清这句注释指的是哪里需要修改的情况下。切记难得糊涂四个字，这样大家都不会感觉受到了批评。 &nbsp;</p><h4>说明变量</h4><p><strong>永远不要</strong>&nbsp;对变量声明加注释。有关变量使用的方式、边界值、合法值、小数点后的位数、计量单位、显示格式、数据录入规则等等，后继者完全可以自己从程序代码中去理解和整理嘛。如果老板强迫你写注释，就把方法体代码混进去，但绝对不要对变量声明写注释，即使是临时变量！</p><h4>在注释里挑拨离间</h4><p>为了阻挠任何雇佣外部维护承包商的倾向，可以在代码中散布针对其他同行软件公司的攻击和抹黑，特别是可能接替你工作的其中任何一家。例如：</p><p><span style="color:green">/* 优化后的内层循环<br> 这套技巧对于 SSI 软件服务公司的那帮蠢材来说太高深了，他们只会<br> 用 &lt;math.h&gt; 里的笨例程，消耗 50 倍的内存和处理时间。<br> */</span><br> class&nbsp;<strong>clever_SSInc</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;{<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;..</strong>&nbsp;<strong>.</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;}</p><p><span>可能的话，除了注释之外，这些攻击抹黑的内容也要掺到代码里的重要部分，这样如果管理层想清理掉这些攻击性的言论然后发给外部承包商去维护，就会破坏代码结构。</span></p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>程序设计</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><em>编写无法维护代码的基本规则就是：在尽可能多的地方，以尽可能多的方式表述每一个事实。</em><br> - Roedy Green
</blockquote><p style="text-align:start">编写可维护代码的关键因素是只在一个地方表述应用里的一个事实。如果你的想法变了，你也只在一个地方修改，这样就能保证整个程序正常工作。所以，编写无法维护代码的关键因素就是反复地表述同一个事实，在尽可能多的地方，以尽可能多的方式进行。令人高兴的是，像 Java 这样的语言让编写这种无法维护代码变得非常容易。例如，改变一个被引用很多的变量的类型几乎是不可能的，因为所有造型和转换功能都会出错，而且关联的临时变量的类型也不合适了。而且，如果变量值要在屏幕上显示，那么所有相关的显示和数据录入代码都必须一一找到并手工进行修改。类似的还有很多，比如由 C 和 Java 组成的 Algol 语言系列，Abundance 甚至 Smalltalk 对于数组等结构的处理，都是大有可为的。</p><h4>Java 造型</h4><p>Java 的造型机制是上帝的礼物。你可以问心无愧地使用它，因为 Java 语言本身就需要它。每次你从一个 Collection 里获取一个对象，你都必须把它造型为原始类型。这样这个变量的类型就必须在无数地方表述。如果后来类型变了，所有的造型都要修改才能匹配。如果倒霉的维护代码的程序员没有找全（或者修改太多），编译器能不能检测到也不好说。类似的，如果变量类型从<span style="color:#000099"><span>short</span></span>&nbsp;变成&nbsp;<span style="color:#000099"><span>int</span></span>，所有匹配的造型也都要从<span style="color:#000099"><span>(short)</span></span>&nbsp;改成&nbsp;<span style="color:#000099"><span>(int)</span></span>。</p><h4>利用 Java 的冗余</h4><p>Java 要求你给每个变量的类型写两次表述。 Java 程序员已经习惯了这种冗余，他们不会注意到你的两次表述有细微的差别，例如</p><p>Bubbleg<em>u</em>m<span>&nbsp;</span><strong>b</strong><span>&nbsp;</span><strong>=</strong><span>&nbsp;</span>new Bubbleg<em>o</em>m();</p><p>不幸的是 ++ 操作符的盛行让下面这种伪冗余代码得手的难度变大了：</p><p>swim<em>m</em>er<span>&nbsp;</span><strong>=</strong><span>&nbsp;</span>swim<em>n</em>er<span>&nbsp;</span><strong>+</strong><span>&nbsp;</span>1;</p><h4>永远不做校验</h4><p>永远不要对输入数据做任何的正确性或差异性检查。这样能表现你对公司设备的绝对信任，以及你是一位信任所有项目伙伴和系统管理员的团队合作者。总是返回合理的值，即使数据输入有问题或者错误。 &nbsp;</p><h4>有礼貌，无断言</h4><p>避免使用 assert() 机制，因为它可能把三天的 debug 盛宴变成 10 分钟的快餐。</p><h4>避免封装</h4><p>为了提高效率，不要使用封装。方法的调用者需要所有能得到的外部信息，以便了解方法的内部是如何工作的。 &nbsp;</p><h4>复制粘贴修改</h4><p>以效率的名义，使用，复制+粘贴+修改。这样比写成小型可复用模块效率高得多。在用代码行数衡量你的进度的小作坊里，这招尤其管用。</p><h4>使用静态数组</h4><p>如果一个库里的模块需要一个数组来存放图片，就定义一个静态数组。没人会有比 512 X 512 更大的图片，所以固定大小的数组就可以了。为了最佳精度，就把它定义成 double 类型的数组。 &nbsp;</p><h4>傻瓜接口</h4><p>编写一个名为 "WrittenByMe" 之类的空接口，然后让你的所有类都实现它。然后给所有你用到的 Java 内置类编写包装类。这里的思想是确保你程序里的每个对象都实现这个接口。最后，编写所有的方法，让它们的参数和返回类型都是这个 WrittenByMe。这样就几乎不可能搞清楚某个方法的功能是什么，并且所有类型都需要好玩的造型方法。更出格的玩法是，让每个团队成员编写它们自己的接口 (例如 WrittenByJoe)，程序员用到的任何类都要实现他自己的接口。这样你就可以在大量无意义接口中随便找一个来引用对象了。</p><h4>巨型监听器</h4><p>永远不要为每个组件创建分开的监听器。对所有按钮总是用同一个监听器，只要用大量的 if...else 来判断是哪一个按钮被点击就行了。 &nbsp;</p><h4>好事成堆 TM</h4><p>狂野地使用封装和 OO 思想。例如，这段很可能看起来不怎么好笑。别担心，只是时候未到而已。</p><p>myPanel<strong>.</strong>add( getMyButton<strong>(</strong><strong>)</strong>&nbsp;);<br> private JButton&nbsp;<strong>getMyButton</strong>()</p><p>&nbsp;&nbsp;&nbsp;&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;return myButton;<br> &nbsp;&nbsp;&nbsp;&nbsp;}</p><h4>友好的朋友</h4><p>在 C++ 里尽量多使用 friend 声明。再把创建类的指针传递给已创建类。现在你不用浪费时间去考虑接口了。另外，你应该用上关键字<em>private</em>&nbsp;和&nbsp;<em>protected</em>&nbsp;来表明你的类封装得很好。</p><h4>使用三维数组</h4><p>大量使用它们。用扭曲的方式在数组之间移动数据，比如，用 arrayA 里的行去填充 arrayB 的列。这么做的时候，不管三七二十一再加上 1 的偏移值，这样很灵。让维护代码的程序员抓狂去吧。 &nbsp;</p><h4>混合与匹配</h4><p>存取方法和公共变量神马的都要给他用上。这样的话，你无需调用存取器的开销就可以修改一个对象的变量，还能宣称这个类是个"Java Bean"。对于那些试图添加日志函数来找出改变值的源头的维护代码的程序员，用这一招来迷惑他尤其有效。 &nbsp;</p><h4>没有秘密!</h4><p>把每个方法和变量都声明为 public。毕竟某个人某天可能会需要用到它。一旦方法被声明为 public 了，就很难缩回去。对不？这样任何它覆盖到的代码都很难修改了。它还有个令人愉快的副作用，就是让你看不清类的作用是什么。如果老板质问你是不是疯了，你就告诉他你遵循的是经典的透明接口原则。</p><h4>全堆一块</h4><p>把你所有的没用的和过时的方法和变量都留在代码里。毕竟说起来，既然你在 1976 年用过一次，谁知道你啥时候会需要再用到呢？当然程序是改了，但它也可能会改回来嘛，你"不想要重新发明轮子"（领导们都会喜欢这样的口气）。如果你还原封不动地留着这些方法和变量的注释，而且注释写得又高深莫测，甭管维护代码的是谁，恐怕都不敢对它轻举妄动。</p><h4>就是 Final</h4><p>把你所有的叶子类都声明为 final。毕竟说起来，你在项目里的活儿都干完了，显然不会有其他人会通过扩展你的类来改进你的代码。这种情况甚至可能有安全漏洞。 java.lang.String 被定义成 final 也许就是这个原因吧？如果项目组其他程序员有意见，告诉他们这样做能够提高运行速度。</p><h4>避免布局</h4><p>永远不要用到布局。当维护代码的程序员想增加一个字段，他必须手工调整屏幕上显示所有内容的绝对座标值。如果老板强迫你使用布局，那就写一个巨型的 GridBagLayout 并在里面用绝对座标进行硬编码。</p><h4>全局变量，怎么强调都不过分</h4><p>如果上帝不愿意我们使用全局变量，他就不会发明出这个东西。不要让上帝失望，尽量多使用全局变量。每个函数最起码都要使用和设置其中的两个，即使没有理由也要这么做。毕竟，任何优秀的维护代码的程序员都会很快搞清楚这是一种侦探工作测试，有利于让他们从笨蛋中脱颖而出。 &nbsp;</p><h4>再一次说说全局变量</h4><p>全局变量让你可以省去在函数里描述参数的麻烦。充分利用这一点。在全局变量中选那么几个来表示对其他全局变量进行操作的类型。</p><h4>局部变量</h4><p>永远不要用局部变量。在你感觉想要用的时候，把它改成一个实例或者静态变量，并无私地和其他方法分享它。这样做的好处是，你以后在其他方法里写类似声明的时候会节省时间。C++程序员可以百尺竿头更进一步，把所有变量都弄成全局的。</p><h4>配置文件</h4><p>配置文件通常是以，关键字 = 值，的形式出现。在加载时这些值被放入 Java 变量中。最明显的迷惑技术就是把有细微差别的名字用于关键字和 Java 变量.甚至可以在配置文件里定义运行时根本不会改变的常量。参数文件变量和简单变量比，维护它的代码量起码是后者的 5 倍。</p><h4>子类</h4><p>对于编写无法维护代码的任务来说，面向对象编程的思想简直是天赐之宝。如果你有一个类，里边有 10 个属性（成员/方法），可以考虑写一个基类，里面只有一个属性，然后产生 9 层的子类，每层增加一个属性。等你访问到最终的子类时，你才能得到全部 10 个属性。如果可能，把每个类的声明都放在不同的文件里。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>编码迷局</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><h4>迷惑 C</h4><p>从互联网上的各种混乱 C 语言竞赛中学习，追随大师们的脚步。</p><h4>追求极致</h4><p>总是追求用最迷惑的方式来做普通的任务。例如，要用数组来把整数转换为相应的字符串，可以这么做：</p><p>char *p;<br> switch (n)<br> {<br> case 1:<br> &nbsp;&nbsp;&nbsp;&nbsp;p = "one";<br> &nbsp;&nbsp;&nbsp;&nbsp;if (0)<br> case 2:<br> &nbsp;&nbsp;&nbsp;&nbsp;p = "two";<br> &nbsp;&nbsp;&nbsp;&nbsp;if (0)<br> case 3:<br> &nbsp;&nbsp;&nbsp;&nbsp;p = "three";<br> &nbsp;&nbsp;&nbsp;&nbsp;printf("%s", p);<br> &nbsp;&nbsp;&nbsp;&nbsp;break;<br> }</p><h4>一致性的小淘气</h4><p>当你需要一个字符常量的时候，可以用多种不同格式： ' ', 32, 0x20, 040。在 C 或 Java 里 10 和 010 是不同的数（0 开头的表示 16 进制），你也可以充分利用这个特性。</p><h4>造型</h4><p>把所有数据都以 void * 形式传递，然后再造型为合适的结构。不用结构而是通过位移字节数来造型也很好玩。</p><h4>嵌套 Switch</h4><p>Switch 里边还有 Switch，这种嵌套方式是人类大脑难以破解的。 &nbsp;</p><h4>利用隐式转化</h4><p>牢记编程语言中所有的隐式转化细节。充分利用它们。数组的索引要用浮点变量，循环计数器用字符，对数字执行字符串函数调用。不管怎么说，所有这些操作都是合法的，它们无非是让源代码更简洁而已。任何尝试理解它们的维护者都会对你感激不尽，因为他们必须阅读和学习整个关于隐式数据类型转化的章节，而这个章节很可能是他们来维护你的代码之前完全忽略了的。</p><h4>分号!</h4><p>在所有语法允许的地方都加上分号，例如：</p><p>if(a);<br> else;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;<strong>d</strong>;<br> &nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;<strong>=</strong>&nbsp;c;<br> &nbsp;&nbsp;&nbsp;&nbsp;}<br> &nbsp;&nbsp;&nbsp;&nbsp;;</p><h4>使用八进制数</h4><p>把八进制数混到十进制数列表里，就像这样：</p><p>array&nbsp;<strong>=</strong>&nbsp;new int&nbsp;<strong>[</strong><strong>]</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;{<br> &nbsp;&nbsp;&nbsp;&nbsp;111<strong>,</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;120<strong>,</strong><br><span style="color:red">&nbsp;&nbsp;&nbsp;&nbsp;013</span><strong>,</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;121<strong>,</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;};</p><h4>嵌套</h4><p>尽可能深地嵌套。优秀的程序员能在一行代码里写 10 层 ()，在一个方法里写 20 层{}。 &nbsp;</p><h4>C 数组</h4><p>C 编译器会把&nbsp;<span style="color:#000099"><span>myArray[i]</span></span>&nbsp;转换成&nbsp;<span style="color:#000099"><span>*(myArray + i)</span></span>，它等同于&nbsp;<span style="color:#000099"><span>*(i + myArray)</span></span>&nbsp;也等同于&nbsp;<span style="color:#000099"><span>i[myArray]</span></span>。 高手都知道怎么用好这个招。可以用下面的函数来产生索引，这样就把代码搞乱了：</p><p><span style="color:#000099"><span>int myfunc(int q, int p) { return p%q; }<br> ...<br> myfunc(6291, 8)[Array];</span></span></p><p>遗憾的是，这一招只能在本地 C 类里用，Java 还不行。</p><h4>放长线钓大鱼</h4><p>一行代码里堆的东西越多越好。这样可以省下临时变量的开销，去掉换行和空格还可以缩短源文件大小。记住，要去掉运算符两边的空格。优秀的程序员总是能突破某些编辑器对于 255 个字符行宽的限制。</p><h4>异常</h4><p>我这里要向你传授一个编程中鲜为人知的秘诀。异常是个讨厌的东西。良好的代码永远不会出错，所以异常实际上是不必要的。不要把时间浪费在这上面。子类异常是给那些知道自己代码会出错的低能儿用的。在整个应用里，你只用在 main() 里放一个 try/catch，里边直接调用 System.exit() 就行了。在每个方法头要贴上标准的抛出集合定义，到底会不会抛出异常你就不用管了。 &nbsp;</p><h4>使用异常的时机</h4><p>在非异常条件下才要使用异常。比如终止循环就可以用&nbsp;<span style="color:#000099"><span>ArrayIndexOutOfBoundsException</span></span>。还可以从异常里的方法返回标准的结果。 &nbsp;</p><h4>狂热奔放地使用线程</h4><p>如题。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>测试</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>在程序里留些 bug，让后继的维护代码的程序员能做点有意思的事。精心设计的 bug 是无迹可寻的，而且谁也不知道它啥时候会冒出来。要做到这一点，最简单的办法的就是不要测试代码。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>永不测试</h4><p>永远不要测试负责处理错误、当机或操作系故障的任何代码。反正这些代码永远也不会执行，只会拖累你的测试。还有，你怎么可能测试处理磁盘错误、文件读取错误、操作系统崩溃这些类型的事件呢？为啥你要用特别不稳定的计算机或者用测试脚手架来模拟这样的环境？现代化的硬件永远不会崩溃，谁还愿意写一些仅仅用于测试的代码？这一点也不好玩。如果用户抱怨，你就怪到操作系统或者硬件头上。他们永远不会知道真相的。</p><h4>永远不要做性能测试</h4><p>嘿，如果软件运行不够快，只要告诉客户买个更快的机器就行了。如果你真的做了性能测试，你可能会发现一个瓶颈，这会导致修改算法，然后导致整个产品要重新设计。谁想要这种结果？而且，在客户那边发现性能问题意味着你可以免费到外地旅游。你只要备好护照和最新照片就行了。</p><h4>永远不要写任何测试用例</h4><p>永远不要做代码覆盖率或路径覆盖率测试。自动化测试是给那些窝囊废用的。搞清楚哪些特性占到你的例程使用率的 90%，然后把 90% 的测试用在这些路径上。毕竟说起来，这种方法可能只测试到了大约你代码的 60%，这样你就节省了 40% 的测试工作。这能帮助你赶上项目后端的进度。等到有人发现所有这些漂亮的「市场特性」不能正常工作的时候，你早就跑路了。一些有名的大软件公司就是这样测试代码的，所以你也应该这样做。如果因为某种原因你还没走，那就接着看下一节。 &nbsp;</p><h4>测试是给懦夫用的</h4><p>勇敢的程序员会跳过这个步骤。太多程序员害怕他们的老板，害怕丢掉工作，害怕客户的投诉邮件，害怕遭到起诉。这种恐惧心理麻痹了行动，降低了生产率。有科学研究成果表明，取消测试阶段意味着经理有把握能提前确定交付时间，这对于规划流程显然是有利的。消除了恐惧心理，创新和实验之花就随之绽放。程序员的角色是生产代码，调试工作完全可以由技术支持和遗留代码维护组通力合作来进行。</p><p>如果我们对自己的编程能力有充分信心，那么测试就没有必要了。如果我们逻辑地看待这个问题，随便一个傻瓜都能认识到测试根本都不是为了解决技术问题，相反，它是一种感性的信心问题。针对这种缺乏信心的问题，更有效的解决办法就是完全取消测试，送我们的程序员去参加自信心培训课程。毕竟说起来，如果我们选择做测试，那么我们就要测试每个程序的变更，但其实我们只需要送程序员去一次建立自信的培训课就行了。很显然这么做的成本收益是相当可观的。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>编程语言的选择</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><p style="text-align:start"><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>计算机语言正在逐步进化，变得更加傻瓜化。使用最新的语言是不人性的。尽可能坚持使用你会用的最老的语言，先考虑用穿孔纸带，不行就用汇编，再不行用 FORTRAN 或者 COBOL，再不行就用 C 还有 BASIC，实在不行再用 C++。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>FØRTRAN</h4><p>用 FORTRAN 写所有的代码。如果老板问你为啥，你可以回答说有很多它非常有用的库，你用了可以节约时间。不过，用 FORTRAN 写出可维护代码的概率是 0，所以，要达到不可维护代码编程指南里的要求就容易多了。</p><h4>用 ASM</h4><p>把所有的通用工具函数都转成汇编程序。</p><h4>用 QBASIC</h4><p>所有重要的库函数都要用 QBASIC 写，然后再写个汇编的封包程序来处理 large 到 medium 的内存模型映射。</p><h4>内联汇编</h4><p>在你的代码里混杂一些内联的汇编程序，这样很好玩。这年头几乎没人懂汇编程序了。只要放几行汇编代码就能让维护代码的程序员望而却步。</p><h4>宏汇编调用 C</h4><p>如果你有个汇编模块被 C 调用，那就尽可能经常从汇编模块再去调用 C，即使只是出于微不足道的用途，另外要充分利用 goto, bcc 和其他炫目的汇编秘籍。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>与他人共事之道</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><h4>老板才是真行家</h4><p>如果你的老板认为他 20 年的 FORTRAN 编程经验对于现代软件开发具有很高的指导价值，你务必严格采纳他的所有建议。投桃报李，你的老板也会信任你。这会对你的职业发展有利。你还会从他那里学到很多搞乱程序代码的新方法。</p><h4>颠覆技术支持</h4><p>确保代码中到处是 bug 的有效方法是永远不要让维护代码的程序员知道它们。这需要颠覆技术支持工作。永远不接电话。使用自动语音答复「感谢拨打技术支持热线。需要人工服务请按 1，或在嘀声后留言。」，请求帮助的电子邮件必须忽略，不要给它分配服务追踪号。对任何问题的标准答复是「我估计你的账户被锁定了，有权限帮你恢复的人现在不在。」 &nbsp;</p><h4>沉默是金</h4><p>永远不要对下一个危机保持警觉。如果你预见到某个问题可能会在一个固定时间爆发，摧毁西半球的全部生命，不要公开讨论它。不要告诉朋友、同事或其他你认识的有本事的人。在任何情况下都不要发表任何可能暗示到这种新的威胁的内容。只发送一篇正常优先级的、语焉不详的备忘录给管理层，保护自己免遭秋后算账。如果可能的话，把这篇稀里糊涂的信息作为另外一个更紧急的业务问题的附件。这样就可以心安理得地休息了，你知道将来你被强制提前退休之后一段时间，他们又会求着你回来，并给你对数级增长的时薪！ &nbsp;</p><h4>每月一书俱乐部</h4><p>加入一个计算机每月一书俱乐部。选择那些看上去忙着写书不可能有时间真的去写代码的作者。去书店里找一些有很多图表但是没有代码例子的书。浏览一下这些书，从中学会一些迂腐拗口的术语，用它们就能唬住那些自以为是的维护代码的程序员。你的代码肯定会给他留下深刻印象。如果人们连你写的术语都理解不了，他们一定会认为你非常聪明，你的算法非常深奥。不要在你的算法说明里作任何朴素的类比。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>自立门户</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><p><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>你一直想写系统级的代码。现在机会来了。忽略标准库，&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.roll-your-own.com%2F" target="_blank">编写你自己的标准</a><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>，这将会是你简历中的一个亮点。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4>推出你自己的 BNF 范式</h4><p>总是用你自创的、独一无二的、无文档的 BNF 范式记录你的命令语法。永远不要提供一套带注解的例子（合法命令和非法命令之类）来解释你的语法体系。那样会显得完全缺乏学术严谨性。确保没有明显的方式来区分终结符和中间符号。永远不要用字体、颜色、大小写和其他任何视觉提示帮助读者分辨它们。在你的 BNF 范式用和命令语言本身完全一样的标点符号，这样读者就永远无法分清一段 (...), [...], {...} 或 "..." 到底是你在命令行里真正输入的，还是想提示在你的 BNF 范式里哪个语法元素是必需的、可重复的、或可选的。不管怎么样，如果他们太笨，搞不清你的 BNF 范式的变化，就没资格使用你的程序。 &nbsp;</p><h4>推出你自己的内存分配</h4><p>地球人儿都知道，调试动态存储是复杂和费时的。与其逐个类去确认它没有内存溢出，还不如自创一套存储分配机制呢。其实它无非是从一大片内存中 malloc 一块空间而已。用不着释放内存，让用户定期重启动系统，这样不就清除了堆么。重启之后系统需要追踪的就那么一点东西，比起解决所有的内存泄露简单得不知道到哪里去了！而且，只要用户记得定期重启系统，他们也永远不会遇到堆空间不足的问题。一旦系统被部署，你很难想象他们还能改变这个策略。</p><h2><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span>其他杂七杂八的招</span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2><blockquote><p><em>如果你给某人一段程序，你会让他困惑一天；如果你教他们如何编程，你会让他困惑一辈子。&nbsp;</em>-- Anonymous</p></blockquote><h4>不要重编译</h4><p>让我们从一条可能是有史以来最友好的技巧开始：把代码编译成可执行文件。如果它能用，就在源代码里做一两个微小的改动 -- 每个模块都照此办理。<strong>但是不要费劲巴拉地再编译一次了。</strong>&nbsp;你可以留着等以后有空而且需要调试的时候再说。多年以后，等可怜的维护代码的程序员更改了代码之后发现出错了，他会有一种错觉，觉得这些肯定是他自己最近修改的。这样你就能让他毫无头绪地忙碌很长时间。</p><h4>挫败调试工具</h4><p>对于试图用行调试工具追踪来看懂你的代码的人，简单的一招就能让他狼狈不堪，那就是把每一行代码都写得很长。特别要把 then 语句，和 if 语句放在同一行里。他们无法设置断点。他们也无法分清在看的分支是哪个 if 里的。</p><h4>公制和美制</h4><p>在工程方面有两种编码方式。一种是把所有输入都转换为公制（米制）计量单位，然后在输出的时候自己换算回各种民用计量单位。另一种是从头到尾都保持各种计量单位混合在一起。总是选择第二种方式，这就是美国之道！ &nbsp;</p><h4>持续改进</h4><p>要持续不懈地改进。要常常对你的代码做出「改进」，并强迫用户经常升级 -- 毕竟没人愿意用一个过时的版本嘛。即便他们觉得他们对现有的程序满意了，想想看，如果他们看到你又「完善「了它，他们会多么开心啊！不要告诉任何人版本之间的差别，除非你被逼无奈 -- 毕竟，为什么要告诉他们本来永远也不会注意到的一些 bug 呢？</p><h4>「关于」</h4><p>「关于」一栏应该只包含程序名、程序员姓名和一份用法律用语写的版权声明。理想情况下，它还应该链接到几 MB 的代码，产生有趣的动画效果。但是，里边永远不要包含程序用途的描述、它的版本号、或最新代码修改日期、或获取更新的网站地址、或作者的 email 地址等。这样，所有的用户很快就会运行在不同的版本上，在安装 N+1 版之前就试图安装 N+2 版。</p><h4>变更</h4><p>在两个版本之间，你能做的变更自然是多多益善。你不会希望用户年复一年地面对同一套老的接口或用户界面，这样会很无聊。最后，如果你能在用户不注意的情况下做出这些变更，那就更好了 -- 这会让他们保持警惕，戒骄戒躁。</p><h4>无需技能</h4><p>写无法维护代码不需要多高的技能。喊破嗓子不如甩开膀子，不管三七二十一开始写代码就行了。记住，管理层还在按代码行数考核生产率，即使以后这些代码里的大部分都得删掉。</p><h4>只带一把锤子</h4><p>一招鲜吃遍天，轻装前进。如果你手头只有一把锤子，那么所有的问题都是钉子。</p><h4>规范体系</h4><p>有可能的话，忽略当前你的项目所用语言和环境中被普罗大众所接受的编程规范。比如，编写基于 MFC 的应用时，就坚持使用 STL 编码风格。</p><h4>翻转通常的 True False 惯例</h4><p>把常用的 true 和 false 的定义反过来用。这一招听起来平淡无奇，但是往往收获奇效。你可以先藏好下面的定义：</p><p>#define TRUE 0<br> #define FALSE 1</p><p>把这个定义深深地藏在代码中某个没人会再去看的文件里不易被发现的地方，然后让程序做下面这样的比较</p><p>if ( var == TRUE )</p><p>if ( var != FALSE )</p><p>某些人肯定会迫不及待地跳出来「修正」这种明显的冗余，并且在其他地方照着常规去使用变量 var：</p><p>if ( var )</p><p>还有一招是为&nbsp;<span style="color:#000099"><span>TRUE</span></span>&nbsp;和&nbsp;<span style="color:#000099"><span>FALSE</span></span>赋予相同的值，虽然大部分人可能会看穿这种骗局。给它们分别赋值 1 和 2 或者 -1 和 0 是让他们瞎忙乎的方式里更精巧的，而且这样做看起来也不失对他们的尊重。你在 Java 里也可以用这一招，定义一个叫&nbsp;<span style="color:#000099"><span>TRUE</span></span>&nbsp;的静态常量。在这种情况下，其他程序员更有可能怀疑你干的不是好事，因为 Java 里已经有了内建的标识符&nbsp;<span style="color:#000099"><span>true</span></span>。</p><h4>第三方库</h4><p>在你的项目里引入功能强大的第三方库，然后不要用它们。潜规则就是这样，虽然你对这些好的工具仍然一无所知，却还是可以在你简历的「其他工具」一节中写上这些没用过的库。</p><h4>不要用库</h4><p>假装不知道有些库已经直接在你的开发工具中引入了。如果你用 VC++编程，忽略 MFC 或 STL 的存在，手工编写所有字符串和数组的实现；这样有助于保持你的指针技术，并自动阻止任何扩展代码功能的企图。</p><h4>创建一套 Build 顺序</h4><p>把这套顺序规则做得非常晦涩，让维护者根本无法编译任何他的修改代码。秘密保留&nbsp;SmartJ&nbsp;，它会让&nbsp;<span style="color:#000099"><span>make</span></span>脚本形同废物。类似地，偷偷地定义一个&nbsp;<span style="color:#000099"><span>javac</span></span>&nbsp;类，让它和编译程序同名。说到大招，那就是编写和维护一个定制的小程序，在程序里找到需要编译的文件，然后通过直接调用&nbsp;<span style="color:#000099"><span>sun.tools.javac.Main</span></span>&nbsp;编译类来进行编译。</p><h4>Make 的更多玩法</h4><p>用一个 makefile-generated-batch-file 批处理文件从多个目录复制源文件，文件之间的覆盖规则在文档中是没有的。这样，无需任何炫酷的源代码控制系统，就能实现代码分支，并阻止你的后继者弄清哪个版本的 DoUsefulWork() 才是他需要修改的那个。</p><h4>搜集编码规范</h4><p>尽可能搜集所有关于编写可维护代码的建议，例如&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.squarebox.co.uk%2Fjavatips.html" target="_blank">SquareBox 的建议</a>&nbsp;，然后明目张胆地违反它们。</p><h4>规避公司的编码规则</h4><p>某些公司有严格的规定，不允许使用数字标识符，你必须使用预先命名的常量。要挫败这种规定背后的意图太容易了。比如，一位聪明的 C++ 程序员是这么写的：</p><p>#define K_ONE 1<br> #define K_TWO 2<br> #define K_THOUSAND 999</p><h4>编译器警告</h4><p>一定要保留一些编译器警告。在 make 里使用 「-」 前缀强制执行，忽视任何编译器报告的错误。这样，即使维护代码的程序员不小心在你的源代码里造成了一个语法错误，make 工具还是会重新把整个包 build 一遍，甚至可能会成功！而任何程序员要是手工编译你的代码，看到屏幕上冒出一堆其实无关紧要的警告，他们肯定会觉得是自己搞坏了代码。同样，他们一定会感谢你让他们有找错的机会。学有余力的同学可以做点手脚让编译器在打开编译错误诊断工具时就没法编译你的程序。当然了，编译器也许能做一些脚本边界检查，但是真正的程序员是不用这些特性的，所以你也不该用。既然你用自己的宝贵时间就能找到这些精巧的 bug，何必还多此一举让编译器来检查错误呢？</p><h4>把 bug 修复和升级混在一起</h4><p>永远不要推出什么「bug 修复"版本。一定要把 bug 修复和数据库结构变更、复杂的用户界面修改，还有管理界面重写等混在一起。那样的话，升级就变成一件非常困难的事情，人们会慢慢习惯 bug 的存在并开始称他们为特性。那些真心希望改变这些」特性「的人们就会有动力升级到新版本。这样从长期来说可以节省你的维护工作量，并从你的客户那里获得更多收入。</p><h4>在你的产品发布每个新版本的时候都改变文件结构</h4><p>没错，你的客户会要求向上兼容，那就去做吧。不过一定要确保向下是不兼容的。这样可以阻止客户从新版本回退，再配合一套合理的 bug 修复规则（见上一条），就可以确保每次新版本发布后，客户都会留在新版本。学有余力的话，还可以想办法让旧版本压根无法识别新版本产生的文件。那样的话，老版本系统不但无法读取新文件，甚至会否认这些文件是自己的应用系统产生的！温馨提示：PC 上的 Word 文字处理软件就典型地精于此道。</p><h4>抵消 Bug</h4><p>不用费劲去代码里找 bug 的根源。只要在更高级的例程里加入一些抵销它的代码就行了。这是一种很棒的智力测验，类似于玩 3D 棋，而且能让将来的代码维护者忙乎很长时间都想不明白问题到底出在哪里：是产生数据的低层例程，还是莫名其妙改了一堆东西的高层代码。这一招对天生需要多回合执行的编译器也很好用。你可以在较早的回合完全避免修复问题，让较晚的回合变得更加复杂。如果运气好，你永远都不用和编译器前端打交道。学有余力的话，在后端做点手脚，一旦前端产生的是正确的数据，就让后端报错。</p><h4>使用旋转锁</h4><p>不要用真正的同步原语，多种多样的旋转锁更好 -- 反复休眠然后测试一个 (non-volatile 的) 全局变量，直到它符合你的条件为止。相比系统对象，旋转锁使用简便」，通用「性强」，灵活「多变，实为居家旅行必备。</p><h4>随意安插 sync 代码</h4><p>把某些系统同步原语安插到一些用不着它们的地方。本人曾经在一段不可能会有第二个线程的代码中看到一个临界区（critical section）代码。本人当时就质问写这段代码的程序员，他居然理直气壮地说这么写是为了表明这段代码是很」关键「（也是 critical）的！</p><h4>优雅降级</h4><p>如果你的系统包含了一套 NT 设备驱动，就让应用程序负责给驱动分配 I/O 缓冲区，然后在任何交易过程中对内存中的驱动加锁，并在交易完成后释放或解锁。这样一旦应用非正常终止，I/O 缓存又没有被解锁，NT 服务器就会当机。但是在客户现场不太可能会有人知道怎么弄好设备驱动，所以他们就没有选择（只能请你去免费旅游了）。</p><h4>定制脚本语言</h4><p>在你的 C/S 应用里嵌入一个在运行时按字节编译的脚本命令语言。</p><h4>依赖于编译器的代码</h4><p>如果你发现在你的编译器或解释器里有个 bug，一定要确保这个 bug 的存在对于你的代码正常工作是至关重要的。毕竟你又不会使用其他的编译器，其他任何人也不允许！</p><h4>一个货真价实的例子</h4><p>下面是一位大师编写的真实例子。让我们来瞻仰一下他在这样短短几行 C 函数里展示的高超技巧。</p><pre><code>void* Realocate(void*buf, int os, int ns)
{
    void*temp;
    temp = malloc(os);
    memcpy((void*)temp, (void*)buf, os);
    free(buf);
    buf = malloc(ns);
    memset(buf, 0, ns);
    memcpy((void*)buf, (void*)temp, ns);
    return buf;
}</code></pre><ul><li>重新发明了标准库里已有的简单函数。</li><li><em>Realocate</em>&nbsp;这个单词拼写错误。所以说，永远不要低估创造性拼写的威力。</li><li>无缘无故地给输入缓冲区产生一个临时的副本。</li><li>无缘无故地造型。 memcpy() 里有 (void*)，这样即使我们的指针已经是 (void*) 了也要再造型一次。另外这样可以传递任何东西作为参数，加 10 分。</li><li>永远不必费力去释放临时内存空间。这样会导致缓慢的内存泄露，一开始看不出来，要程序运行一段时间才行。</li><li>把用不着的东西也从缓冲区里拷贝出来，以防万一。这样只会在 Unix 上产生 core dump，Windows 就不会。</li><li>很显然，os 和 ns 的含义分别是」old size" 和 "new size"。</li><li>给 buf 分配内存之后，memset 初始化它为 0。不要使用 calloc()，因为某些人会重写 ANSI 规范，这样将来保不齐 calloc() 往 buf 里填的就不是 0 了。（虽然我们复制过去的数据量和 buf 的大小是一样的，不需要初始化，不过这也无所谓啦）</li></ul><h4>如何修复 "unused variable" 错误</h4><p>如果你的编译器冒出了 "unused local variable" 警告，不要去掉那个变量。相反，要找个聪明的办法把它用起来。我最喜欢的方法是：<br><span style="color:#000099"><span>i = i;</span></span></p><h4>大小很关键</h4><p>差点忘了说了，函数是越大越好。跳转和 GOTO 语句越多越好。那样的话，想做任何修改都需要分析很多场景。这会让维护代码的程序员陷入千头万绪之中。如果函数真的体型庞大的话，对于维护代码的程序员就是哥斯拉怪兽了，它会在他搞清楚情况之前就残酷无情地将他们踩翻在地。</p><h4>一张图片顶 1000 句话，一个函数就是 1000 行</h4><p>把每个方法体写的尽可能的长 -- 最好是你写的任何方法或函数都没有少于 1000 行代码的，而且里边深度嵌套，这是必须的。</p><h4>少个文件</h4><p>一定要保证一个或多个关键文件是找不到的。利用 includes 里边再 includes 就能做到这一点。例如，在你的 main 模块里，你写上：</p><p>#include &lt;stdcode.h&gt;</p><p>Stdcode.h 是有的。但是在 stdcode.h 里，还有个引用：</p><p>#include "a:\\refcode.h"</p><p>然后，refcode.h 就没地方能找到了。</p><p><span>到处可写，无处可读</span></p><p>至少要把一个变量弄成这样：到处被设置，但是几乎没有哪里用到它。不幸的是，现代编译器通常会阻止你做相反的事：到处读，没处写。不过你在 C 或 C++ 里还是可以这样做的。</p><blockquote><p><em><strong>原始博文发布于：&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmindprod.com%2Funmain.html" target="_blank">Roedy Green's Mindproducts&nbsp;</a>。</strong></em></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 08:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269949/unmaintainable-new-defensive-programming</guid>
            <link>https://www.oschina.net/news/269949/unmaintainable-new-defensive-programming</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[美国 CISA 建议放弃 C/C++，消除内存安全漏洞]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">美国网络安全与基础设施安全局 (CISA) 发布了一份名为「<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cisa.gov%2Fresources-tools%2Fresources%2Fcase-memory-safe-roadmaps" target="_blank">The Case for Memory Safe Roadmaps</a>」的文件，详细介绍了软件厂商应如何过渡到内存安全编程语言 (MSL)，以消除内存安全漏洞。</span></p><p><span style="color:#000000">CISA 认为，内存安全错误经常会造成重大损失，需要加以杜绝；因此敦促企业和技术领导者密切关注软件开发中的内存安全。而&nbsp;C 和 C++ 等编程语言就是内存不安全编程语言的典范；它们可能导致内存不安全代码，但仍然是当今使用最广泛的语言之一。</span></p><p><img height="339" src="https://oscimg.oschina.net/oscnet/up-5d0b5ed6634487780b08f8f39114dd5ed99.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">该指南文件由美国网络安全与基础设施安全局 (CISA)、国家安全局 (NSA)、联邦调查局 (FBI)，以及澳大利亚、加拿大、英国和新西兰的网络安全机构联合制定。旨在敦促每家软件厂商的高级管理人员通过优先考虑实施 MSL 的设计和开发实践来降低客户风险；同时敦促他们创建并发布内存安全路线图，以便客户了解所面临的内存安全风险。</span></p><blockquote><p><span style="color:#000000">「MSL 可以消除内存安全漏洞。因此，过渡到 MSL 可能会大大降低投资于旨在减少这些漏洞或将其影响降至最低的活动的必要性。此外，将不安全的代码库迁移到 MSL 的投资将以更安全的产品的形式带来长期回报--这也抵消了过渡到 MSL 的部分前期成本。」</span></p></blockquote><p><span style="color:#000000">文件指出，微软<span style="background-color:#ffffff">约 70% 的 CVE 是内存安全漏洞</span>（基于 2006-2018 年的 CVE），Mozilla 的 34 个关键/高危漏洞中有 32 个是内存安全漏洞。谷歌 Chromium 项目中所发现的漏洞，有约 70% 是内存安全漏洞；且 2021 年的零日漏洞中也有 67% 是内存安全漏洞。</span></p><p><span style="color:#000000">虽然一些组织为了减少&nbsp;<span style="background-color:#ffffff">C/C++</span> 内存不安全代码引入的风险，投入了大量资金用于开发人员培训。但 CISA 等机构认为，「虽然培训可以减少程序员可能引入的漏洞数量，但考虑到内存安全缺陷的普遍性，内存安全漏洞的出现几乎是不可避免的。」</span></p><p><span style="color:#000000">鉴于此，他们<span style="background-color:#ffffff">建议组织放弃 C/C++，转而使用 C#、Go、Java、Python、Rust 和 Swift&nbsp;等「内存安全语言」。</span></span></p><p><img height="355" src="https://oscimg.oschina.net/oscnet/up-e6e47911a81e83c6770f76378917ec074f9.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cisa.gov%2Fsites%2Fdefault%2Ffiles%2F2023-12%2FThe-Case-for-Memory-Safe-Roadmaps-508c.pdf" target="_blank">查看完整文档</a>。</span></p><hr><p><strong><span style="color:#000000">相关阅读：</span></strong></p><ul><li><a href="https://www.oschina.net/news/217425/nsa-memory-safe-programming-language" target="_blank">美国国家安全局建议从 C/C++ 切换到内存安全语言</a></li><li><a href="https://www.oschina.net/news/226780/c-plus-plus-bjarne-stroustrup-safety" target="news">C++ 之父：Rust 等内存安全语言的安全性并不优于 C++</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 07:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269933/cisa-the-case-for-memory-safe-roadmaps</guid>
            <link>https://www.oschina.net/news/269933/cisa-the-case-for-memory-safe-roadmaps</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Firefox 会被淘汰吗？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>近期关于 Firefox 的一篇文章引起了<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D38531104" target="_blank">广泛讨论</a></u>。作者表示，Firefox 正处于危险边缘，可能很快就会被淘汰。</p><blockquote><img src="https://oscimg.oschina.net/oscnet/up-3d6519dad6718f830b4b0fc8ad29f4f8032.png" referrerpolicy="no-referrer"><p>来源 <em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.brycewray.com%2Fposts%2F2023%2F11%2Ffirefox-brink%2F" target="_blank">https://www.brycewray.com/posts/2023/11/firefox-brink/</a></u></em></p></blockquote><p>文章提到，根据美国政府网站的开发指南 (<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdesignsystem.digital.gov%2F" target="_blank">U.S. Web Design System</a>, USWDS)，<strong>如果 Firefox 的市场份额低于 2%</strong>（参考 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fanalytics.usa.gov" target="_blank">analytics.usa.gov</a> 的统计使用率），那么美国政府的网站可以不再兼容 Firefox。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1df9adfb989c674f23068f0710d9ed2993c.png" referrerpolicy="no-referrer"></p><p>过去 90 天，访问 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fanalytics.usa.gov" target="_blank">analytics.usa.gov</a> 的浏览器中 Chrome 占 49%，Safari 占 34.8%，Edge 8.5%，<strong>Firefox 只有 2.2 %</strong>——已经非常接近临界点。如果 Firefox 失去了美国政府网站的支持，这有可能在整个 Web 开发界产生涟漪效应。因为政府的决定会影响到无数企业，就像多米诺骨牌倒下一样，会有越来越多的网站跟随步伐不兼容 Firefox，导致 Firefox 处于淘汰边缘。</p><p><img src="https://oscimg.oschina.net/oscnet/up-dcc027785814f919e453f18776391477b5d.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-4df67b9659f2a95d258721fbfed00bafe07.png" referrerpolicy="no-referrer"></p><p>有人可能会问；「政府网站不兼容 Firefox 又怎样？这只是针对美国政府的举措，并不会影响任何其他网站。」但作者认为：</p><ol><li><p>一旦 Firefox 在政府的访问者分析中跌破 2% 的阈值，USWDS 就会告诉政府网站开发者他们不必再支持 Firefox。</p></li><li><p>消息传出后，不仅前端开发社区，就连一些 Web 开发者所服务的企业 IT 部门也会迅速知晓。许多企业与政府有大量业务往来，因此，政府在 IT 方面的任何举措都会影响企业。</p></li><li><p>企业会将这一变化视为<strong>降低开发成本和缩短交付时间</strong>的机会，因为它提供了一个借口，可以从开发工作流程中移除一些测试（在极少数情况下还包括特定代码）。</p></li></ol><p>下图清晰展示了浏览器三巨头从 2009 到 2023 的市场份额变化情况，Firefox 在 2009 年 11 月达到了 31.82% 的峰值，此后便是持续下滑。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a1b0aacdd134ed153115b0354c1ba76e9d4.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 06:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269923/firefox-on-the-brink</guid>
            <link>https://www.oschina.net/news/269923/firefox-on-the-brink</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[防御性编程几大基本原则]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">当开发人员遇到意外的错误无法修复时，他们会「添加一些防御性代码」来使代码更安全，更容易找到问题所在。有时候，仅仅这样做就能解决问题。他们会加强数据验证——确保检查输入和输出字段以及返回值。审查并改进错误处理——也许在「不可能」的情况周围添加一些检查。增加一些有用的日志记录和诊断功能。换句话说，这些<strong>本应该从一开始就存在的代码</strong>。</p><blockquote><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">防御性编程的整个目的是为了防范你意想不到的错误。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">——Steve McConnell，《代码大全》</p></blockquote><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">防御性编程的几个基本原则在 Steve McConnell 经典著作《代码大全》中有详细解释：</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>保护你的代码免受「外部」传入的无效数据影响</strong>，无论你认为「外部」是指什么地方。这里指来自外部系统、用户、文件或模块/组件之外的任何数据。建立「壁垒」、「安全区域」或「信任边界」——边界之外的一切都是危险的，边界之内的一切都是安全的。在壁垒代码中，验证所有输入数据：检查所有输入参数的正确类型、长度和取值范围。再次检查限制和范围。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">在检查完坏数据后，决定如何处理它。<strong>防御性编程并不意味着吞没错误或隐藏错误</strong>。它是关于在健壮性（如果遇到可处理的问题则继续运行）和正确性（永远不返回错误结果）之间做出权衡。选择一种处理坏数据的策略：立即返回错误并停止运行（快速失败），返回一个中立值，替换数据值等等。确保策略明确且一致。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>不要假设你代码之外的函数调用或方法调用会按照广告所述正常工作</strong>。确保你理解并测试了周围外部 API 和库的错误处理机制。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>使用断言来记录假设，并突出显示「不可能」的条件</strong>，至少在开发和测试阶段如此。这对于长期由不同人维护或高可靠性代码特别重要。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">巧妙地<strong>添加诊断代码、日志记录和跟踪功能</strong>，以帮助解释运行时发生了什么问题，尤其是当遇到问题时。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>标准化错误处理</strong>。决定如何处理「正常错误」或「预期错误」和警告，并始终保持一致。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start"><strong>只在需要时使用异常处理</strong>，并确保你对语言的异常处理机制了如指掌。将异常作为正常处理流程的一部分的程序会遭受经典意义上代码结构混乱的可读性和可维护性问题。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">Michael Nygard 在《发布！》中还提到了其他几个规则，比如永远不要无限期等待外部调用，尤其是远程调用。当出现问题时，无限期可能会很长时间。使用超时/重试逻辑以及他的断路器稳定模式来处理远程故障。</p><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">对于 C 和 C++等编程语言，防御性编程还包括使用安全函数调用来避免缓冲区溢出和常见编码错误。</p><blockquote><p style="color:#101828; margin-left:0; margin-right:0; text-align:start">原文：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fswreflections.blogspot.com%2F2012%2F03%2Fdefensive-programming-being-just-enough.html" target="_blank">https://swreflections.blogspot.com/2012/03/defensive-programming-being-just-enough.html</a></p></blockquote><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 07 Dec 2023 06:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/269921/defensive-programming</guid>
            <link>https://www.oschina.net/news/269921/defensive-programming</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
