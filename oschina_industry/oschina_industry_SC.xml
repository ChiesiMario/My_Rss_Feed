<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 11 Dec 2023 04:36:16 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[TIOBE 12 月：C# 有望成为年度编程语言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#000000"><span style="background-color:#ffffff">TIOBE 公布了 2023&nbsp;年 12 月的</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tiobe.com%2Ftiobe-index%2F" target="_blank">编程语言排行榜</a><span style="background-color:#ffffff; color:#000000"><span style="background-color:#ffffff">。</span></span></p><p><img height="77" src="https://oscimg.oschina.net/oscnet/up-e944f70ee629593d3b3ba2ac7d008e89e4b.png" width="700" referrerpolicy="no-referrer"></p><p>2023 年度 TIOBE 编程语言名单即将出炉，其中最有望胜出的当属&nbsp;C#。事实上，早在 2022 年&nbsp;C# 就有望夺得该桂冠，但却在最后时刻被&nbsp;C++ 反超。而在今年，C# 的胜率又多出了几分；因为该语言在一年内的增长率为 +2.38%，与其最接近的竞争者 Fortran 和 F# 的增长率则仅分别上涨了 +0.64% 和 +0.48%。</p><p>此外，Top 20 中的大部分语言人气都出现了下降。<span style="background-color:#ffffff; color:#000000">TIOBE CEO&nbsp;Paul Jansen 评论称，</span>「答案就在所有小语言所在的长尾（long tail）部分。这些语言的受欢迎程度都在上升，而且越来越接近大语言」。例如：一年前，排名第 50 位的语言得分仅为 0.14%，但现在第 50 位语言的得分已经达到了 0.24%。</p><p><strong style="color:#333333">TIOBE 12 月 TOP 20 编程语言</strong></p><p><img height="414" src="https://oscimg.oschina.net/oscnet/up-b25283a71bbac81145079c4b2848ccc6e95.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#000000">相较上月，除了 Ruby<span>&nbsp;</span>(18→19)、R (19→20) 以及 Rust (20→18) 之间出现了小范围波动外，Top&nbsp;10-20 榜单没有其他任何排名变化，这也是近期以来榜单变动最小的一次。</span></p><p><strong style="color:#333333">TOP 10 编程语言 TIOBE 指数走势（2002-2024）</strong></p><p><img height="228" src="https://oscimg.oschina.net/oscnet/up-c048f61fdb18f5fa94fbc07b575f6acc8f9.png" width="700" referrerpolicy="no-referrer"></p><p><strong style="color:#333333">第 21-50 名编程语言排行</strong></p><p><img height="430" src="https://oscimg.oschina.net/oscnet/up-e1c00e5bc23507475a73c563cbdb213cdc9.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#000000">第 51-100 名如下，由于它们之间的数值差异较小，仅以文本形式列出（按字母排序）：</span></p><p>&nbsp;</p><blockquote><p>4th Dimension/4D, ABC, Algol, Apex, ATLAS, AutoLISP, Bash, Boo, Carbon, CIL, CL (OS/400), Clipper, Clojure, Curl, Eiffel, Elm, Erlang, GAMS, Groovy, Icon, Inform, Io, J#, LabVIEW, Ladder Logic, LiveCode, Maple, Modula-2, MOO, MQL5, NATURAL, Nim, OCaml, OpenEdge ABL, PostScript, Pure Data, Q, Racket, Ring, RPG, Smalltalk, Snap!, Solidity, SPARK, SPSS, Tcl, VHDL, Wolfram, X10, Zig</p></blockquote><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">TIOBE 编程社区指数（The TIOBE Programming Community index）是一个衡量编程语言受欢迎程度的指标，该指数每月更新一次。评判的依据来自世界范围内的工程师、课程和第三方供应商，包括流行的搜索引擎，如 Google、必应、雅虎、维基百科、亚马逊、YouTube 和百度都被用于指数计算。值得注意的是，TIOBE 指数并不代表编程语言的好坏或编写代码的多少。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">该指数可以用来检查你的编程技能是否还能跟上时代的步伐，或者在开始建立一个新的软件系统时，基于指数对采用何种编程语言做出决策。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tiobe.com%2Ftiobe-index%2Fprogramminglanguages_definition%2F" target="_blank">TIOBE 指数</a><span style="color:#000000">的定义方式，以及详细榜单信息<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tiobe.com%2Ftiobe-index%2F" target="_blank">均可查看官网</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 03:48:04 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270438/tiobe-index-2023012</guid>
            <link>https://www.oschina.net/news/270438/tiobe-index-2023012</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[因 EXT4 数据损坏错误，Debian 12.3 推迟发布]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Debian 团队发布公告称，由于 Linux 内核 6.1.64-1 中的<strong> ext4 文件系统出现数据损坏问题</strong>，因此原计划昨天发布的 Debian 12.3 将会被推迟，同时进行修复。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-6b960c796ab8ff358469f03578c81866ec1.png" referrerpolicy="no-referrer"></p><p>来源：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.debian.org%2FNews%2F2023%2F2023120902" target="_blank">https://www.debian.org/News/2023/2023120902</a></u></p></blockquote><p>据介绍，此 bug 由从 Linux 6.5 回溯的一个有问题补丁导致，它引起了 EXT4 和 iomap 代码之间的干扰，可能导致旧内核上的数据损坏。</p><p>这个问题主要出现在最近的 Linux 6.1 LTS 点版本中，新的 Linux 6.1.66 版本已经回滚了有问题的提交。Debian 的 bug 报告称这个问题为「非严重的数据丢失」，因此应该是可以恢复的。</p><p>但由于 Debian 12.3 原本计划发布的内核版本受到了影响，因此被推迟发布。建议 Debian 12 用户在 Linux 6.1.66 内核镜像推出之前不要升级系统。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 03:22:04 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270435/debian-12-3-delayed-ext4-corrupt</guid>
            <link>https://www.oschina.net/news/270435/debian-12-3-delayed-ext4-corrupt</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[周鸿祎：有人找我做养猪大模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在 2023 中国企业领袖年会上，360 创始人周鸿祎对于最近的 AI 大模型热潮发表了看法。</p><p>他表示，（感觉）大家对大模型充满了一种无限的向往或者不切实际的膜拜，之前还有人找他做养猪大模型。他认为，大模型的技术路线突破才短短几年，目前还存在着很多缺点。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-391bf18f540407673913ddee0ac73938969.png" referrerpolicy="no-referrer"></p><p>来源：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2Ftv%2Fshow%2F1034%3A4977511076134973%3Ffrom%3Dold_pc_videoshow" target="_blank">https://weibo.com/tv/show/1034:4977511076134973</a></u></p></blockquote><p>他希望大家对大模型有一个正确的认知，<strong>不要高估现在大模型的能力，不要低估大模型未来发展的潜力</strong>，虽然它现在已经可以跟实体产业相结合，但它还不能完全接管此类业务，应该扬长避短发挥它的长处，因为很多短板还有待解决。</p><p>目前国内各大企业、科研机构和高校等单位已公开的 AI 大模型至少已经达到了 188 个，而首批通过《生成式人工智能服务管理暂行办法》备案的大模型已于 8 月 31 日公布，第二批通过备案的 AI 大模型也已于 11 月开放服务。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3a3b3aaeff5f0043de536b6f5f44b963797.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 03:03:59 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270430</guid>
            <link>https://www.oschina.net/news/270430</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[理想汽车全自研多模态认知大模型 —— Mind GPT]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>理想汽车于 12 月 10 日晚正式发布 OTA 5.0 版本，并计划于 12 月 19 日开启全量用户推送。官方介绍称，在 OTA 5.0 中，理想同学最大的变化是引入了 Mind GPT 的能力。</p><p>Mind GPT 是理想全自研的多模态认知大模型，据称他们从 0 到 1 构建了 Mind GPT 原始基座模型，<strong>模型结构采用了自研的 TaskFormer 神经网络架构</strong>，基于用车、娱乐、出行等场景使用 SFT、RLHF 等技术进行了一系列的训练，让 Mind GPT 拥有了理解、生成、知识记忆及推理的三大能力。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-7aa6319e367ca499b8541b306ec3892d181.png" referrerpolicy="no-referrer"></p><p>目前 Mind GPT 还处于内测版本阶段，那么 Mind GPT 在行业里到底是什么水平呢？</p><p>官方称在目前国内极具权威性的，中文大语言模型评测榜单 C-EVAL，覆盖了人文、社科、理工等多个方向共 52 个学科，Mind GPT 在 58 个参加测评的大模型中排行第一名；同时，还有涵盖从基础学科到高级专业包含 67 个主题领域的评测榜单 CMMLU，Mind GPT 也获得第一名，拿下了双冠军。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d89ae63875873819f3b3676b6fea16d8c81.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-af86f00982833de97dd852d6a57f17288dd.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 02:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270426</guid>
            <link>https://www.oschina.net/news/270426</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[DDE V23 全新升级，引爆海外科技媒体关注！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>内容来源：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fdde-overseas-concerns%2F" target="_blank">deepin 社区</a></p><hr><p>近日，DDE (Deepin Desktop Environment，深度桌面环境) 迎来版本升级，并被移植到多个主流 Linux 发行版中，引发多家海外知名科技媒体的关注和报道。</p><p style="color:#333333; margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="555" src="https://storage.deepin.org/thread/202312111015036481_1.png" width="1041" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><em>TechBullion，英国知名科技媒体</em></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">报道称，诞生于中国 Linux 开源社区的桌面环境 DDE，自 2013 年推出以来，创造了中国 Linux 历史的多个「首次」：推出首个&nbsp;Linux 桌面应用商店，率先在 Linux 桌面引入智能助手，首家支持高分屏、软件包签名、人脸识别登录……与 GNOME、KDE、XFCE 等国际主流桌面环境一样，DDE 在全球广受欢迎，已经被移植到包括 Arch、openSUSE、Ubuntu、Fedora、Manjaro 等主流 Linux 发行版中。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><img alt="" height="508" src="https://storage.deepin.org/thread/202312111015122694_2.png" width="1037" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><em>Gearrice，美国知名技术和创新媒体网站</em></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">DDE V23 预览版公布后，全新设计引发了广大开源社区网友们的关注。同时随着 DDE V23 各个项目的代码开源以及代码稳定程度的不断改善，不同发行版的包维护者们也开始了对全新 DDE 桌面环境的移植。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">现如今，在这些来自不同发行版的包维护者和社区贡献者们的一同努力下，已经有多个发行版完成 DDE V23 桌面环境的主要组件适配，包括 Arch Linux、UbuntuDDE、NixOS、openSUSE 等。还有很多发行版仍在积极的对 DDE V23 进行移植，其中知名的发行版包括 Debian、Gentoo、Fedora 等。</p><p style="color:#333333; margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="755" src="https://storage.deepin.org/thread/20231211101533641_3.png" width="1027" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">&nbsp;</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">此外，针对 DDE V23 全新升级的报道，海外用户给出了积极的评价，认为「deepin（深度）操作系统已经很好地满足了用户所需要的一切，DDE is so pretty！」</p><p style="color:#333333; margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="605" src="https://storage.deepin.org/thread/20231211101547509_4.png" width="1032" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Flatest-news-deepin-v23%2F" target="_blank">同时，deepin（深度）社区研发负责人表示，DDE V23 即将在明年的 deepin V23 正式版里与大家见面。</a>deepin V23 是 deepin（深度）社区最新的发行版，将具备全新的系统结构、更多的系统架构的支持、桌面环境的持续优化、全自研 Wayland 合成器 Treeland、多会话全局窗口管理器、更强大的功能以及系统兼容性、稳健性的持续提升。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start">deepin 积极拥抱新技术，努力推出更多创新的功能和服务。如果你对 DDE V23 的适配感兴趣，希望参与进来，为 DDE 的移植贡献一份力量，欢迎加入 deepin（深度）社区下的 [<strong>DDE-porting 兴趣小组</strong>]，一同展开 DDE 移植相关的话题讨论，让更多用户体验 DDE 桌面环境。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:start"><strong>DDE-porting 兴趣小组：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdeepin-community%2Fsig-dde-porting" target="_blank">https://github.com/deepin-community/sig-dde-porting</a></strong></p><hr><p style="text-align:right">内容来源：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Findex%2Fzh" target="_blank">deepin 社区</a></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 02:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270420/dde-updated</guid>
            <link>https://www.oschina.net/news/270420/dde-updated</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[大湾区一体化算力服务平台正式发布，算力规模超 5000P]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>12 月 10 日，在第二届数字政府建设峰会暨数字湾区发展论坛上，深圳市前海管理局、国家（深圳·前海）新型互联网交换中心（下称「前海交换中心」）共同<strong>发布粤港澳大湾区一体化算力服务平台，并正式成立前海算力服务联盟</strong>。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-e379cb9cc7c4002e4f3fb84f03c47a13c02.png" referrerpolicy="no-referrer"></p></blockquote><p>据介绍，该平台由前海管理局提出设想和要求，在深圳市通管局、市工信局的支持下，由前海交换中心和紫金山实验室共同开发部署。</p><p>官方透露，该平台自 10 月 31 日试运行以来，汇聚的算力规模大幅增长近 4 倍，<strong>总规模已达 5180 PFLOPS</strong>，主流芯片覆盖率超 75%，并已为 10 余个企业、高校、科研机构的人工智能团队提供算力服务。</p><ul><li><p><strong>在算力调度方面</strong>，创新多维一体编排算法，实现算力高效调度和智能供给；</p></li><li><p><strong>在算力交易方面</strong>，平台不收取中介费用，促进供需双方合作与交易；</p></li><li><p><strong>在算力应用方面</strong>，高度集成各类算法工具，实现应用一键部署、资源秒级开通，进一步降低门槛、提升效率；</p></li><li><p><strong>在算力安全方面</strong>，构建算网一体化安全防护体系，持续强化算力安全保障。</p></li></ul><p><img height="360" src="https://static.oschina.net/uploads/space/2023/1211/102814_wKUa_2720166.png" width="640" referrerpolicy="no-referrer"></p><p>同时， <strong>大湾区首个算力服务行业组织 —— 前海算力服务联盟正式成立</strong>，首批成员单位包括前海科创集团、前海交换中心、紫金山实验室、华为、深圳商汤、万国数据、世纪互联、深圳数据交易所、深圳科创学院、香港中文大学未来智联网络研究院、粤港澳大湾区大数据研究院。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 02:30:59 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270418</guid>
            <link>https://www.oschina.net/news/270418</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[郭炜：开源大侠是怎样炼成的]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 6 月 1 日，首个由国人主导的开源数据集成工具 Apache SeaTunnel 正式宣布从 Apache 软件基金会孵化器毕业成为顶级项目。历经 18 个月的孵化，这个项目终于瓜熟蒂落，社区贡献者 200+，代码 24.5 万行，上千家企业使用，风光无限。令人难以想象，郭炜刚接手它时，仓库被封、贡献者四散的落魄样子。</p><p>&nbsp;</p><span id="OSC_h1_1"></span><h1>大侠出手， SeaTunnel 浴火重生</h1><p>SeaTunnel 原名 Waterdrop，于 2017 年由乐视创建，并于同年在 Github 上开源，是一个大数据集成处理平台。当时国内各种数据引擎风起云涌，却少有项目解决数据源之间的无缝集成和高速同步问题，因此 Waterdrop 在其中显得颇为亮眼。可惜这种亮眼却为它招来了横祸——开源项目 Waterdrop 的商标被抢注了，而且对方的法务还发送律师函给开源的发起者和 Github 。</p><p>由于开源项目的名称不属于【商标】，而国内的商标又是【申请在先】原则，谁先申请谁先得到，因此 Waterdrop</p><p>一下子百口莫辩，落了下风， Github 在收到律师函后，把 Github 上 Waterdrop 的整个仓库都封了，所有的代码、PR、Issue 也全都无法访问，而且 Waterdrop 的创始团队还面临诉讼纠纷。没办法，团队只能在圈内四处求助，机缘巧合之下，遇到了郭炜。</p><p>郭炜，人称「郭大侠」，平时就爱在开源圈内热心给大家帮忙。创始团队找到郭炜后，郭炜看到这样的事情，又是这样有前途的项目，不忍心袖手旁观，他便把项目接了过来，一边找律师解决法律纠纷，一边利用自己的资源辗转联系微软的 Github 管理人员解释，帮助项目解封。</p><p>2021 年，争议终于告一段落，Waterdrop 改名 SeaTunnel，得以继续运转。可大侠并不放心，毕竟团队才 3 个人，维护社区已是够呛，哪还有能力顾及法律合规的事情？万一这剧情重来一遍，可就不是闹着玩的了。郭炜开始当 SeaTunnel 的 Mentor，手把手带起了开源项目，并致力于把项目孵化到 Apache 基金会里面。一方面，基金会是专业的，有专人管理法务，比现在的草台班子好多了。另一方面，SeaTunnel 也可以接替退役的 Apache Sqoop，解决数据源之间数据打通的问题。</p><p>最终，在多位导师的帮助下，2021 年 12 月 9 日，SeaTunnel 正式通过 Apache 软件基金会的投票决议，顺利进入 Apache 孵化器，成为基金会中第一个诞生自中国的数据集成平台项目，目标是「连接万源，同步如飞」。</p><p>如今，SeaTunnel 从 Apache 软件基金会孵化器毕业成为顶级项目，也在全球拥有很多企业用户和开发者，早已告别最初的窘迫。郭大侠也轻轻招手，奔赴了下一个难题。</p><p style="text-align:center"><img height="664" src="https://oscimg.oschina.net/oscnet/up-8c5e3b11d68a2569fa44bc1e66d5f395f95.png" width="500" referrerpolicy="no-referrer"></p><p>&nbsp;</p><span id="OSC_h1_2"></span><h1>大侠当年也是开源「小趴菜」</h1><p>SeaTunnel 团队最初之所以求助郭炜，是因为他成功运营过多个开源社区，在圈内早已小有名气。时间回拨到 2010 年，郭炜就开始接触开源了。那时候他在 Hadoop 社区里当「潜水党」，以一个小白的身份，旁观各路大神在里面交流技术问题，给出」炫酷「的解决方案。「在开源社区里，你能看到很多全新的项目，全新的技术，能不断学到新东西，保持走在技术圈的前排，这是别的渠道无法替代的。书上的东西太陈旧了，网上的东西又特别杂，只有在开源社区，才能纯粹地了解新技术，了解开源圈在关注啥。」</p><p>当然，郭炜这样的「 e 人」不会一直坐边角。很快他就融入了社区，经常参加线下 meetup，也 contribute 过不少文档。但在开源社区里，郭炜这个名字就是一个「 nobody 」。到联想工作之后，郭炜继续坚持开源，也把开源带到了联想。在联想 COC 核心技术架构委员会，郭炜作为全球大数据平台负责人，一直在当开源布道者，推动开源技术的应用，许多同事都是因为他的宣传才「入坑」的。</p><p>但那时候在企业内部做开源布道，也是困难重重。首先开源当时并没有现下这么火，很多人对开源知之甚少，唯一的印象就是「免费」。其次，习惯了商业软件的企业，更倾向于沿用原来的选择，毕竟商业软件虽然收费，可是有人售后，有人负责。而开源软件，虽然免费，却有风险，遇到问题，谁来解决呢？尤其是对于全球化的大公司而言，开源在当地还可能存在法律风险，哪怕这是个「省钱」的决定，想拍板也不容易。</p><p><strong>郭炜坦言，在大企业内部做开源推广，就是要承担很多的责任。</strong>说白了就是，这个锅一开始你得背一背，才能让一些关键的业务用户用起来。等他们用起来觉得不错了，你才能压住质疑，谈下一步的推广。当时为了推广 Hadoop、Spark 且要符合各国的法务规范，郭炜要跟全球的同事开会，会议从早上六点排到了夜里两三点，一遍一遍地跟大家科普这个项目是什么、怎么用、出问题怎么办、合不合规、为什么要用它......经过跟业务部门「过五关斩六将」的 battle，最后一个美国的部门率先接受了 Spark，之后因为口碑不错，才慢慢推广到了其他国家、其他部门。</p><p>「我们开源社区里面的每一个用户都是很珍贵、很不容易的，尤其是那些为刚出来的新开源项目做企业内部推广的小伙伴，每一个都是勇士。他们在企业内部推广一项新技术，不仅需要做很多工作，更是拿自己头上的乌纱帽在为社区布道、保驾护航。所以，我们关注开源社区，我们不能只看到 contributor、committer、PMC，更要看到我们社区里的普通用户、他们的艰辛和不易。」郭炜说，<strong>「其实每一个使用开源的人，都是这个社区的 contributor，他们做了很多的 contribution，只不过没有体现在代码上面而已。」</strong></p><p>&nbsp;</p><span id="OSC_h1_3"></span><h1>从开源 User 变 Owner，大侠不好当</h1><p>2016 年，郭炜加入易观，担任 CTO（首席技术官）。当时公司在做一款用户行为分析的产品，主要依靠 Presto 进行二次修改来适配场景。有一天，郭炜正在网上闲逛，突然发现有个新项目，跟自家产品的场景有点像。于是就测试了一下，结果发现比自家产品快 10 倍！郭炜一下子就被震惊了。</p><p><strong>这个项目就是 ClickHouse，俄罗斯的 Yandex 于 2016 年开源的</strong><strong>列式存储数据库</strong><strong>（</strong><strong>DBMS</strong><strong>），主要用于在线分析处理查询（</strong><strong>OLAP</strong><strong>），能够使用 </strong><strong>SQL</strong><strong> 查询实时生成分析数据报告。</strong></p><p>郭炜自问在数据技术圈已属「先锋达人」，各种研究都是随时关注的，可即便这样也没听说过这个项目，想来其他人知道它的概率就更低了。这样的好东西，怎么能忍住不分享呢？于是，郭炜联系了 ClickHouse 的全球社区负责人 Ivan，提出帮忙运营中国的社区。ClickHouse 同意了。</p><p>但是，万事开头难，从 0 到 1 新建一个开源社区，就更难。没人知道你是谁，没人愿意用你。郭炜访谈了早期快手、新浪用户，并组建了社区群。但是这第一个群，花了一年半的时间才凑满。线下社区的人就更少了，第一次 ClickHouse meetup，才来了 11 个人。</p><p>由于这是属于个人爱好的行为，ClickHouse 的各种运营活动都得自己做。日常的建群、验证、答疑、指导等等，都是下班和周末抽空完成的，每天晚上 11 点，就是郭炜的 ClickHouse 支持时间。最开始的时候，还要到每个群里手把手教大家 ClickHouse 怎么用、怎么装、怎么配？周末还要找到一些关键用户，跟他们聊天、吃饭，把他们组织起来，邀请他们来参加线下的组局等等。</p><p>「<strong>做开源不是到各种大会上去讲一讲就完了，</strong><strong>开源</strong><strong>布</strong><strong>道师</strong><strong>高光背后其实是无数的日常琐碎。</strong>想要运营好一个社区是很繁琐的，比方说群里有人发广告，你得把他踢出去；有人在里边吵架了，你要怎么维护？有人向社区扔臭鸡蛋了，你怎么判断是不是开源项目的问题？如果项目有问题，我们怎么样虚心接受？这些都是在社区维护里面要去做的事。一点一滴长年累月的积累，才能真的把社区这件事做好。」郭炜说，「你看前 Apache 的董事会主席 Craig，这样的顶级大佬，都 70 多岁了，还在基金会里做 secretary 给大家建 Apache 的账号，你就知道社区运营有多琐碎了。在哪里都一样的。」</p><p>所幸，在这条路上，郭炜不是一个人在战斗。随着 ClickHouse 用户的增加，社区队伍也愈发壮大了。微信群达到 10 个的时候，郭炜开始招募志愿者，帮忙处理群事务。线下的 meetup，一开始一二十人，在公司找个会议室就能办。后来发展到线下两三百人，线上一千多人，普通场地都装不下了，郭炜就到处找朋友借场地，再自掏腰包飞过去组织。有一次在上海的 Meetup，报名的有 300 多人，但是找不到 Meetup 的地方，当时的趣头条大数据负责人金海就找公司帮忙提供了一个酒店，有布台，有大屏，有 4 个 session，跟开源大会一样。还有当年在阅文集团的刘文成，是 ClickHouse 的小 C，帮忙回答各种问题。在这些贡献者的帮助下，ClickHouse 中国社区终于办上了正规的 meetup。</p><p style="text-align:center"><img height="898" src="https://oscimg.oschina.net/oscnet/up-3c53346abc745644c05c6c876f2b686ccc7.png" width="1860" referrerpolicy="no-referrer"></p><p>三年后的 2019 年，ClickHouse 爆火，截至目前，ClickHouse 仍是 OLAP 方面用户最多的社区。在整个社区里，中国用户也是最多的。头条、阿里等企业用户也相继加入。在这一年的 meetup，社区邀请了俄罗斯 Yandex 公司 ClickHouse 开源社区创始人 Alexey Milovidov，他说：<strong>「中国的 ClickHouse 用户量能取得这样爆发性的增长（一个季度内用户增长了四倍），离不开 William（郭炜）在中国的推广。」</strong><strong></strong></p><p>&nbsp;</p><span id="OSC_h1_4"></span><h1>功成不在我，失败犹更多</h1><p>能得到 ClickHouse 创始人的认可，郭炜很开心。不过他还是觉得，ClickHouse 能达到现在的程度，与其说是因为他这个推动者，不如说是因为这个产品本身的优秀和中国开源小伙伴们的支持。「在数据和大数据领域里，中国对开源的接受程度和开源的使用速度在全球都是最快的，比美国还要快。这得益于中国互联网的发展速度，和大量互联网公司的使用。也许开源商业的天花板没有美国那么高，但是中国卷起来的速度更快。<strong>中国往往能快速接受一个新技术，然后快速卷，快速迭代，加上中国有广大的开发者和用户基础，做起开源来有得天独厚的优势。</strong>」</p><p>现在回头看，这四五年里，郭炜自己和小伙伴们，都受益良多。当初跟他一起在社区里改代码的小伙伴们，现在薪资都翻了四五倍了。其中一个志愿者小 C 刘文成，被腾讯选中，从一个小厂跳槽到了微信里面做 ClickHouse 的维护。「人人为我，我为人人。你在社区里面做的贡献，大家都是看得见的。你的技术水平被大家认可了，那你获得的机会自然也会比别人多。<strong>我觉得这就是开源社区的魅力吧，在这里大家都是平等的，是金子很快就会发光。</strong>这也算是对社区贡献者的一种回报吧。只不过这种回报不是金钱上的，而是别人对你的认可和你的影响力上的。」郭炜说。</p><p>当然，也不是所有的开源项目都能像 ClickHouse 那么幸运。大侠也会遇到挫折，运营的开源项目中失败的更多，有好多开源项目亲自运营了两三年，star 数才十几个。自己做开源项目，哪有那么容易成功呢？「犯错没关系，犯的错误多了你积累的经验也会多。你看我现在做产品能成功，背后反而是那些失败的经验在发挥作用。做其他事也一样。」郭炜两手一摊，「因为每个人的成功，都有当时特殊的时代背景和需求，所以成功的经验，反而不重要，失败的经验更重要，它才能指导你怎么避免犯错。所以每一个成功的背后，可能都有 99 个失败，只不过大家最后只能看到那 1 个成功的而已。」</p><p>经过无数失败的郭炜，也锻炼出了自己看项目的眼光。「<strong>我觉得做开源社区，最关键的是要看准这个产品的定位：它到底解决什么问题，用什么样的技术框架？如果真的看好这个社区的发展的话，就到里面去跟社区一起成长好了。」</strong>郭炜说，「产品有 bug 没关系，每个社区都不是完美的，当初 ClickHouse 也有各种各样的问题，但只要你把大的架构定好之后，剩下的细节就在这个基础上去迭代、去完善就好了。ClickHouse 当时解决的其实就是宽表和日志查询问题，就这一件事。然后它把当时最新的技术——向量计算，直接放到引擎里，速度就是比我原来的 Presto 快十倍。它就解决这个问题，且解决得最好，所以在社区也能发展得很好。」</p><p><strong>看准了产品思路、底层逻辑和创始团队之后，剩下的事情就是坚持了。</strong>「 ClickHouse 2016 年刚刚开源的时候，我就把它引进中国了，那时候还默默无闻，直到 2019 年才爆火。前面这几年，完全就是靠熬过去的。你要相信你的眼光，持续坚持，不能半途而废。有时候一个开源社区最后能不能成功，就看你坚持的时间够不够长了。」郭炜说，「等到社区真的成长起来，影响力足够大的时候，里面的每一个小伙伴都会受益。」</p><p>&nbsp;</p><span id="OSC_h1_5"></span><h1>多重身份，在开源与商业间做平衡</h1><p>2022 年 4 月，Ted Liu（刘天栋）突然来通知郭炜：我们提名你做 Apache Software Foundation（ASF）Member，你写个材料吧！就这样，郭炜成了 Apache 基金会 Member。「收到这个荣誉的时候，特别开心，觉得这是大家对我的肯定，同时觉得自己身上的责任更重了，也更有动力去考察和维护好 Apache 的每一个项目。」</p><p>而在 2023 年，郭炜身上又多了一个身份，白鲸开源的 CEO。很少有人同时当基金会 Member 和商业公司的领导人，郭炜会不会觉得冲突呢？做决策的时候，是先考虑开源还是商业化？如果开源和商业化功能打架，大侠不就很难办？</p><p>不过，郭炜对此很淡定，他认为，开源和商业化并不冲突，甚至是相辅相成的。<strong>一个开源项目如果想长治久安可持续</strong><strong>发展</strong><strong>，那商业化大概是不可避免的。</strong>如果没有商业公司去承接对核心开发者和贡献者的支持，去满足深度用户的需求，久而久之，纯靠爱发电的核心贡献者可能也会难以为继。</p><p>「像白鲸开源这样做（Apache SeaTunnel 和 DolphinScheduler）商业化的公司，不是开源的对立面，而是开源的促进者。」郭炜说，「商业能够更好地保住开源的调性和核心贡献者的饭碗，让他们能够持续地在开源上发力。同样地，有些深度的用户，当开源项目无法完全满足他的需求，或者需要有人帮他在企业内部做推广的时候，有一个商业实体来帮他一起做这件事，那这个布道师也会轻松一点，而不必像我当初那样独自一个人舌战群儒，过五关斩六将。」</p><p>可是，开源项目之所以商业化困难，恰恰是因为公开了代码。商业和开源究竟如何取舍？哪些应该开源，哪些不开源？遇到冲突的时候，又该如何抉择？</p><p>郭炜笑笑，露了一手聪明的「切糕大法」：「首先从产品定位来讲，你得把你的开源主力用户群和你的非开源主力用户群分开——如果技术水平很强，而且自己还有时间有预算去折腾，那就用开源的好了。如果时间不够，人力预算又不足，那使用商业版更省心。所以，这两者的使用人群是不同的，你的开源软件和商业软件定位也不一样。明白了这个，你纠结的点也就没那么多了。」</p><p>按照惯例，最新的功能都会被放到开源版里面，相对稳定的、有行业属性的功能则通常放到商业版里，两边不时互通有无。郭炜要做的，就是把握好两边放功能的时间和节奏就行了。「至于具体哪些功能放到商业版、哪些功能放到开源版，这就是刀法怎么切的问题了：切得少了，你这个商业版没有价值；切多了，又会影响社区。那怎么来把握，就是一门艺术而不是技术了，这只可意会不可言传哪（笑~）」</p><p>总的来说，郭炜对中国的开源商业环境非常看好。毕竟中国对开源的接受程度很高。虽然从开源社区到商业公司和商业产品这一条路大家还在摸索，但至少，郭炜接触到的新一代决策者，已经跟过去不一样了：他们明白开源会让公司的技术和国际接轨、和全球最新的科技接轨。无论是传统公司还是互联网企业，都在逐步尝试使用开源原生的商业软件。</p><p>「中国开源商业的氛围和整体的步伐，正在觉醒。」甚至中国开源走向全球，郭炜也觉得大有希望：「毕竟中国有这么好的土壤，特别在大数据领域里，有这么多的数据、终端、场景、性能......卷出来的项目，它一定是全球排名前列的，最终跟海外商业场景相结合，一定能卖得很好。」</p><p>&nbsp;</p><span id="OSC_h1_6"></span><h1>开源老将，在酝酿下一个社区</h1><p>在开源圈里，郭大侠也有自己的偶像：「Craig 给我做了一个榜样，他都 70 多了还在坚持为开源做贡献，我觉得我活到 70 岁时候也能继续做开源，他就是我的榜样。哈哈。」</p><p>活到老学到老，这也许不止是郭炜一个人的开源理想，但至少，郭炜坚持到了现在。</p><p>如今，作为开源老将，郭炜又在关注下一个热点了——大模型，特别是开源的大模型。「我认为将来的每一款软件，都会被大模型和相关的 AI 技术再改造一遍、重做一遍。下一步如果再去孵化项目，可能就是跟大模型相关的了。」郭炜说，「如果只是训练大模型，那么国内外只有寥寥几家公司能玩得起。但是大模型生态上下游的公司如果要做好，还是有很多机会的。那么，哪些东西能够促进大模型的应用、降低大模型的使用门槛、让大模型真正跑起来，尤其是大模型跟数据之间的关联，将会是我关注的重点。」</p><p>郭大侠收拾行囊，又奔赴了下一场挑战。</p><p>不知道接下来，他又会遇到怎样的故事呢？</p><div style="text-align:center"><img height="750" src="https://oscimg.oschina.net/oscnet/up-5203b04a5dc96550855c4bae1487b99f11a.png" width="500" referrerpolicy="no-referrer"></div><div>
  &nbsp; 
</div><div>
  &nbsp; 
</div><div><blockquote><div><span style="color:#16a085"><strong><span style="background-color:#f6f6f6">【溯源】</span><span style="background-color:#f6f6f6">在每一场对话中，追溯关于开源的故事，认识那些极客、自由，并坚持着的开源人。</span></strong></span></div></blockquote><p style="color:#494949; margin-left:0; margin-right:0; text-align:left"><span><span>OSCHINA 推出的开源人物专访栏目【溯源】。</span></span></p><p style="color:#494949; margin-left:0; margin-right:0; text-align:left"><span><span>溯源，意指向源头追溯，为开源求解。问渠哪得清如许，为有源头活水来。每一个开源参与者，都是掀起开源浪潮最鲜活的源泉。所有开源故事，共同构建着我们今天看到的开源世界。</span></span></p><p style="color:#494949; margin-left:0; margin-right:0; text-align:left"><span><span>开源刚出现的数十年里，为开源奔走的黑客团体都在遭受来自社会主流的冷漠和排斥。即便现在的软件行业已经大喊出 「拥抱开源」 的口号，问题也依然存在。</span></span></p><p style="color:#494949; margin-left:0; margin-right:0; text-align:left"><span><span>我们不知道开源贡献者、开源布道师，以及所有参与开源的人还会面临多少阻碍，但给予我们信心的是，更多的人在投身开源事业。</span></span></p><p style="color:#494949; margin-left:0; margin-right:0; text-align:left"><span><span>所以 OSCHINA 希望面向开发者社区，寻找每一个积极参与开源、对开源有想法的人，了解他们以及他们的开源故事，窥探故事中的开源事业发展规律。</span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">【溯源】系列文章：</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">01&nbsp;<a href="https://my.oschina.net/u/4105562/blog/4721676"><span style="background-color:#ffffff; color:#494949">适兕</span><span>&nbsp;</span>：成为开源布道师</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">02&nbsp;<a href="https://my.oschina.net/u/4489239/blog/4875125">衞剑钒：开源圈的 「世外高手」</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">03&nbsp;<a href="https://my.oschina.net/u/4489239/blog/4945872" target="_blank">「工具人」 赵生宇：清北本硕，为开源从阿里辞职去同济读博</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">04&nbsp;<a href="https://my.oschina.net/u/4489239/blog/5047833" target="_blank">吴晟：开源对我来说，社交是最重要的</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">05&nbsp;<a href="https://my.oschina.net/u/4489239/blog/6215354" target="_blank">悟空刘歧：技术瑕疵不除不快，开源社区代码说话</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">06&nbsp;<a href="https://my.oschina.net/u/3859945/blog/5504643" target="_blank">姜宁，带程序员前往开源 「乌托邦」</a></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">【溯源】专栏正在征集开源人物故事，如果你认为自己或是身边的人对开源做出过独特贡献，欢迎留言评论，让我们听听 TA 的故事。</p></div></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6852546/blog/10320168</guid>
            <link>https://my.oschina.net/u/6852546/blog/10320168</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[phpy —— Python 与 PHP 互调用库]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>phpy 是<code>Python</code>与<code>PHP</code>互调用库，可以在<code>PHP</code>中使用<code>Python</code>语言的函数和类库，或者在<code>Python</code>中使用<code>PHP</code>的包。 但不是语言内嵌。编码依然使用各自的原生语法。</p><p><code>phpy</code>使得<code>PHP</code>可以调用所有<code>Python</code>的包，包括当下非常流行的<code>PyTorch</code>、<code>transformers</code>、<code>TensorFlow</code>等<code>AI</code>库，以及<code>Numpy</code>、<code>Pandas</code>、<code>Scikit</code>等科学计算库，还可以使用<code>PyQt</code>、<code>wxPython</code>等图形界面库。</p><ul><li>目前仅支持 Linux 平台（理论上可以支持所有操作系统，待实现）</li><li>不支持 Python 多线程、<code>async-io</code>特性</li></ul><h2>PHP 调用 Python</h2><p>编译安装<code>phpy.so</code>作为扩展加载，修改<code>php.ini</code>追加<code>extension=phpy.so</code>即可。</p><p>例子：</p><pre><code>$os = PyCore::import("os");
$un = $os-&gt;uname();
echo strval($un);</code></pre><h2>Python 中调用 PHP</h2><p>直接作为<code>C++ Mudule</code>，import 加载即可。</p><pre><code>import phpy

content = phpy.call('file_get_contents', 'test.txt')

o = phpy.Object('redis')
assert o.call('connect', '127.0.0.1', 6379)
rdata = phpy.call('uniqid')
assert o.call('set', 'key', rdata)
assert o.call('get', 'key') == rdata</code></pre><h2>实现原理</h2><p>在进程内同时创建了<code>ZendVM</code>和<code>CPython VM</code>，直接在进程堆栈空间内使用<code>C</code>函数互相调用， 开销只有<code>zval &lt;-&gt; PyObject</code>结构体转换，因此性能是非常高的。</p><h2 style="margin-left:0; margin-right:0; text-align:left">实际案例</h2><h3 style="margin-left:0; margin-right:0; text-align:left">基于<span>&nbsp;</span><code>tkinter</code><span>&nbsp;</span>实现<span>&nbsp;</span><code>GUI</code><span>&nbsp;</span>的例子</h3><div style="text-align:left"><pre style="margin-left:0; margin-right:0"><code class="language-php"><span><span><span style="color:#6a737d">&lt;?</span></span></span><span><span><span style="color:#6a737d">php</span></span></span><span></span><span style="color:#056de8"><span>$tkinter</span></span><span></span><span><span>=</span></span><span></span><span><span>PyCore</span></span><span><span>::</span></span><span style="color:#056de8"><span>import</span></span><span><span>(</span></span><span style="color:#f1403c"><span><span style="color:#032f62">'tkinter'</span></span></span><span><span>);</span></span><span></span><span style="color:#056de8"><span>$root</span></span><span></span><span><span>=</span></span><span></span><span style="color:#056de8"><span>$tkinter</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>Tk</span></span><span><span>();</span></span><span></span><span style="color:#056de8"><span>$root</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>title</span></span><span><span>(</span></span><span style="color:#f1403c"><span><span style="color:#032f62">'我的窗口'</span></span></span><span><span>);</span></span><span></span><span style="color:#056de8"><span>$root</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>geometry</span></span><span><span>(</span></span><span style="color:#f1403c"><span><span style="color:#032f62">"500x500"</span></span></span><span><span>);</span></span><span></span><span style="color:#056de8"><span>$root</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>resizable</span></span><span><span>(</span></span><span><span><span style="color:#d73a49">False</span></span></span><span><span>,</span></span><span></span><span><span><span style="color:#d73a49">False</span></span></span><span><span>);</span></span><span></span><span style="color:#056de8"><span>$button</span></span><span></span><span><span>=</span></span><span></span><span style="color:#056de8"><span>$tkinter</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>Button</span></span><span><span>(</span></span><span style="color:#056de8"><span>$root</span></span><span><span>,</span></span><span></span><span><span>text</span></span><span><span>:</span></span><span></span><span style="color:#f1403c"><span><span style="color:#032f62">"Click Me!!"</span></span></span><span><span>,</span></span><span></span><span><span>command</span></span><span><span>:</span></span><span></span><span><span>PyCore</span></span><span><span>::</span></span><span style="color:#056de8"><span>fn</span></span><span><span>(</span></span><span><span><span><span style="color:#d73a49">function</span></span></span></span><span><span></span></span><span><span><span><span>()</span></span></span></span><span><span></span></span><span><span>{</span></span><span></span><span><span>var_dump</span></span><span><span>(</span></span><span><span>func_get_args</span></span><span><span>());</span></span><span></span><span><span><span style="color:#d73a49">echo</span></span></span><span></span><span style="color:#f1403c"><span><span style="color:#032f62">'click me!!'</span></span></span><span></span><span><span>.</span></span><span></span><span><span>PHP_EOL</span></span><span><span>;</span></span><span></span><span><span>}));</span></span><span></span><span style="color:#056de8"><span>$button</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>pack</span></span><span><span>();</span></span><span></span><span style="color:#056de8"><span>$tkinter</span></span><span><span>-&gt;</span></span><span style="color:#056de8"><span>mainloop</span></span><span><span>();</span></span></code></pre></div><div style="text-align:left"><img src="https://static.oschina.net/uploads/img/202312/09171840_0Wzd.jpg" referrerpolicy="no-referrer"></div></div>
                                                                ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 01:58:33 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/phpy</guid>
            <link>https://www.oschina.net/p/phpy</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 开源基础密码库，铜锁/Tongsuo]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-概述" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E6%A6%82%E8%BF%B0"></a>概述</h1><p>铜锁/Tongsuo 是一个提供现代密码学算法和安全通信协议的开源基础密码库，为存储、网络、密钥管理、隐私计算等诸多业务场景提供底层的密码学基础能力，实现数据在传输、使用、存储等过程中的私密性、完整性和可认证性，为数据生命周期中的隐私和安全提供保护能力。</p><p>铜锁获得了国家密码管理局商用密码检测中心颁发的商用密码产品认证证书，助力用户在国密改造、密评、等保等过程中，更加严谨地满足我国商用密码技术合规的要求。可在<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fmisc%2Fst247r05s8b5dtct">此处</a>下载资质原始文件。</p><img src="https://github.com/Tongsuo-Project/Tongsuo/blob/master/validation-android.png" width="50%" height="50%" referrerpolicy="no-referrer"><h1><a id="user-content-特性" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E7%89%B9%E6%80%A7"></a>特性</h1><p>铜锁提供如下主要的功能特性：</p><ul><li>技术合规能力
<ul><li>符合 GM/T 0028《密码模块安全技术要求》的"软件密码模块安全一级"资质</li><li>符合 GM/T 0005-2021《随机性检测规范》</li></ul></li><li>零知识证明（ZKP）
<ul><li>Bulletproofs range</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fts%2Fbulletproofs">Bulletproofs R1CS</a></li></ul></li><li>密码学算法
<ul><li>中国商用密码算法：SM2、SM3、SM4、<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fts%2Fcopzp3">祖冲之</a>等</li><li>国际主流算法：ECDSA、RSA、AES、SHA 等</li><li>同态加密算法：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fmisc%2Fec-elgamal">EC-ElGamal</a>、<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fmisc%2Frdibad">Paillier</a>等</li><li>后量子密码学*：Kyber、Dilithium 等</li></ul></li><li>安全通信协议
<ul><li>支持 GB/T 38636-2020 TLCP 标准，即<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fts%2Fhedgqf">双证书国密</a>通信协议</li><li>支持<a href="https://gitee.com/link?target=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc8998">RFC 8998</a>，即 TLS 1.3 +<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fts%2Fgrur3x">国密单证书</a></li><li>支持<a href="https://gitee.com/link?target=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc9000">QUIC</a> API</li><li>支持<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fts%2Fleubbg">Delegated Credentials</a>功能，基于<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.ietf.org%2Farchive%2Fid%2Fdraft-ietf-tls-subcerts-10.txt">draft-ietf-tls-subcerts-10</a></li><li>支持<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftsdoc%2Fts%2Fdf5pyi">TLS 证书压缩</a></li><li>支持紧凑 TLS 协议*</li></ul></li></ul><p>注：*号表示正在支持中</p><h1><a id="user-content-典型应用" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"></a>典型应用</h1><p>开源应用（Opensource Application）</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fangie.software%2Fen%2F">Angie</a>, Angie 是一个可以替换掉 NGINX 的新型 Web 服务器，我们建议使用铜锁的用户优先选择 Angie (We highly recommend you to replace NGINX with Angie to enable Tongsuo's functionality)</li><li>Apache APISIX</li><li>Tengine</li></ul><p>商业应用 (Commercial Application)</p><ul><li>支付宝 App</li><li>OceanBase 数据库</li><li>阿里云</li><li>天威诚信</li></ul><h1><a id="user-content-编译和安装" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85"></a>编译和安装</h1><p>一般来说，典型的编译和安装过程如下：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">./config --prefix=/path/to/install/dir</span><span id="LC2" class="line">make</span><span id="LC3" class="line">make install</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如果是 Windows，则需要：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">perl Configure enable-ntls</span><span id="LC2" class="line">nmake</span><span id="LC3" class="line">nmake install</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>以上将会安装铜锁的头文件、library 文件和铜锁二进制程序。如果需要在独立的 build 目录中编译铜锁以保证源代码仓库的整洁，则可以：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">cd tongsuo-build</span><span id="LC2" class="line">/path/to/Tongsuo/source/config --prefix=/path/to/dest</span><span id="LC3" class="line">make</span><span id="LC4" class="line">make install</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>目前铜锁支持的操作系统有：各种 Linux 发行版、macOS、Android、iOS 和 Windows。在这些操作系统上，还需要事先准备好对应的环境：</p><ul><li>make</li><li>Perl 5，以及 Text::Template 模块</li><li>C 编译器</li><li>C 库</li></ul><p>铜锁对第三方库的依赖很少，但是目前依然对 Perl 依赖较大。</p><p>如果希望执行自动化测试用例，则需：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">make test</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>在安装的时候，可以选择只安装 library 文件：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">make install_runtime_libs</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如果还需要安装头文件以便于基于铜锁开发应用程序，则可以：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">make install_dev</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>也可以只安装铜锁二进制程序和其依赖的铜锁 library 文件：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">make install_programs</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>铜锁的 Configure 脚本提供了大量的用于开关各种特性的选项。一般来讲，使用<code>enable-xxx</code>做为对某个特性的开启，而使用<code>no-xxx</code>来关闭某个特性。例如，<code>enable-ntls</code>即开启 TLCP，而<code>no-rsa</code>则是不编译 RSA 算法。</p><h1><a id="user-content-文档" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E6%96%87%E6%A1%A3"></a>文档</h1><p>铜锁的相关文档组织在 <a href="https://gitee.com/link?target=https%3A%2F%2Fyuque.com%2Ftsdoc">铜锁文档网站</a> 上。</p><h1><a id="user-content-交流群" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E4%BA%A4%E6%B5%81%E7%BE%A4"></a>交流群</h1><p>铜锁使用钉钉群进行用户答疑和交流，欢迎扫码入群（也可直接搜索群号：44810299）：
<img src="https://github.com/Tongsuo-Project/Tongsuo/blob/master/tongsuo-dingtalk.jpg" width="50%" height="50%" referrerpolicy="no-referrer"></p><h1><a id="user-content-报告安全缺陷" class="anchor" href="https://gitee.com/babassl/Tongsuo#%E6%8A%A5%E5%91%8A%E5%AE%89%E5%85%A8%E7%BC%BA%E9%99%B7"></a>报告安全缺陷</h1><p>铜锁目前使用蚂蚁集团的威胁搜集系统，请访问如下地址进行安全缺陷的报告：</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fsecurity.alipay.com%2F">https://security.alipay.com/</a></li></ul><p>注意：对于非安全相关的 Bug，请使用 GitHub 的 Issues 进行提交。</p>]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 01:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/babassl/Tongsuo</guid>
            <link>https://gitee.com/babassl/Tongsuo</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 并发情况如何实现加锁来保证数据一致性？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1>单体架构下锁的实现方案</h1><span id="OSC_h3_2"></span><h3>1. ReentrantLock 全局锁</h3><p>ReentrantLock（可重入锁），指的是一个线程再次对已持有的锁保护的临界资源时，重入请求将会成功。</p><p>简单的与我们常用的 Synchronized 进行比较：</p><table><thead><tr><th>&nbsp;</th><th><strong>ReentrantLock</strong></th><th><strong>Synchronized</strong></th></tr></thead><tbody><tr><td><strong>锁实现机制</strong></td><td>依赖 AQS</td><td>监视器模式</td></tr><tr><td><strong>灵活性</strong></td><td>支持响应超时、中断、尝试获取锁</td><td>不灵活</td></tr><tr><td><strong>释放形式</strong></td><td>必须显示调用 unlock() 释放锁</td><td>自动释放监视器</td></tr><tr><td><strong>锁类型</strong></td><td>公平锁 &amp; 非公平锁</td><td>非公平锁</td></tr><tr><td><strong>条件队列</strong></td><td>可关联多个条件队列</td><td>关联一个条件队列</td></tr><tr><td><strong>可重入性</strong></td><td>可重入</td><td>可重入</td></tr></tbody></table><p><strong>AQS 机制</strong>：如果被请求的共享资源空闲，那么就当前请求资源的线程设置为有效的工作线程，将共享资源通过 CAS<code>compareAndSetState</code>设置为锁定状态；如果共享资源被占用，就采用一定的阻塞等待唤醒机制（CLH 变体的 FIFO 双端队列）来保证锁分配。</p><p><strong>可重入性</strong>：无论是公平锁还是非公平锁的情况，加锁过程会利用一个 state 值</p><pre><code>private volatile int state

</code></pre><ul><li>state 值初始化的时候为 0，表示没有任何线程持有锁</li><li>当有线程来请求该锁时，state 值会自增 1，同一个线程多次获取锁，就会多次+1，这就是可重入的概念</li><li>解锁也是对 state 值自减 1，一直到 0，此线程对锁释放。</li></ul><pre><code>public class LockExample {

    static int count = 0;
    static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {

        Runnable runnable = new Runnable() {
            @Override
            public void run() {

                try {
                    // 加锁
                    lock.lock();
                    for (int i = 0; i &lt; 10000; i++) {
                        count++;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                finally {
                    // 解锁，放在 finally 子句中，保证锁的释放
                    lock.unlock();
                }
            }
        };

        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println("count: " + count);
    }
}

/**
 * 输出
 * count: 20000
 */

</code></pre><span id="OSC_h3_3"></span><h3>2. Mysql 行锁、乐观锁</h3><p>乐观锁即是无锁思想，一般都是基于 CAS 思想实现的，而在 MySQL 中通过 version 版本号 + CAS 无锁形式实现乐观锁；例如 T1，T2 两个事务一起并发执行时，当 T2 事务执行成功提交后，会对 version+1，所以 T1 事务执行的 version 条件就无法成立了。</p><p>对 sql 语句进行加锁以及状态机的操作，也可以避免不同线程同时对 count 值访问导致的数据不一致问题。</p><pre><code>// 乐观锁 + 状态机
update
    table_name
set
    version = version + 1,
    count = count + 1
where
    id = id AND version = version AND count = [修改前的 count 值];

// 行锁 + 状态机
 update
    table_name
set
    count = count + 1
where
    id = id AND count = [修改前的 count 值]
for update;

</code></pre><span id="OSC_h3_4"></span><h3>3. 细粒度的 ReetrantLock 锁</h3><p>如果我们直接采用 ReentrantLock 全局加锁，那么这种情况是一条线程获取到锁，整个程序全部的线程来到这里都会阻塞；但是我们在项目里面想要针对每个用户在操作的时候实现互斥逻辑，所以我们需要更加细粒度的锁。</p><pre><code>public class LockExample {
    private static Map&lt;String, Lock&gt; lockMap = new ConcurrentHashMap&lt;&gt;();
    
    public static void lock(String userId) {
        // Map 中添加细粒度的锁资源
        lockMap.putIfAbsent(userId, new ReentrantLock());
        // 从容器中拿锁并实现加锁
        lockMap.get(userId).lock();
    }
    public static void unlock(String userId) {
        // 先从容器中拿锁，确保锁的存在
        Lock locak = lockMap.get(userId);
        // 释放锁
        lock.unlock();
    }
}

</code></pre><p><strong>弊端</strong>：如果每一个用户请求共享资源，就会加锁一次，后续该用户就没有在登录过平台，但是锁对象会一直存在于内存中，这等价于发生了内存泄漏，所以锁的超时和淘汰机制机制需要实现。</p><span id="OSC_h3_5"></span><h3>4. 细粒度的 Synchronized 全局锁</h3><p>上面的加锁机制使用到了锁容器<code>ConcurrentHashMap</code>，该容易为了线程安全的情况，多以底层还是会用到<code>Synchronized</code>机制，所以有些情况，使用 lockMap 需要加上两层锁。</p><p>那么我们是不是可以直接使用<code>Synchronized</code>来实现细粒度的锁机制</p><pre><code>public class LockExample {
    public static void syncFunc1(Long accountId) {
        String lock = new String(accountId + "").intern();

        synchronized (lock) {

            System.out.println(Thread.currentThread().getName() + "拿到锁了");
            // 模拟业务耗时
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            System.out.println(Thread.currentThread().getName() + "释放锁了");
        }
    }

    public static void syncFunc2(Long accountId) {
        String lock = new String(accountId + "").intern();

        synchronized (lock) {

            System.out.println(Thread.currentThread().getName() + "拿到锁了");
            // 模拟业务耗时
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            System.out.println(Thread.currentThread().getName() + "释放锁了");
        }
    }

    // 使用 Synchronized 来实现更加细粒度的锁
    public static void main(String[] args) {
        new Thread(()-&gt; syncFunc1(123456L), "Thread-1").start();
        new Thread(()-&gt; syncFunc2(123456L), "Thread-2").start();
    }
}

/**
 * 打印
 * Thread-1 拿到锁了
 * Thread-1 释放锁了
 * Thread-2 拿到锁了
 * Thread-2 释放锁了
 */

</code></pre><ul><li>从代码中我们发现实现加锁的对象其实就是一个与用户 ID 相关的一个字符串对象，这里可能会有疑问，我每一个新的线程进来，new 的都是一个新的字符串对象，只不过字符串内容一样，怎么能够保证可以安全的锁住共享资源呢；</li><li>这其实需要归功于后面的<code>intern()</code>函数的功能；</li><li><code>intern()</code>函数用于在运行时将字符串添加到堆空间中的字符串常量池中，如果字符串已经存在，返回字符串常量池中的引用。</li></ul><span id="OSC_h1_6"></span><h1>分布式架构下锁的实现方案</h1><p><strong>核心问题</strong>：我们需要找到一个多个进程之间所有线程可见的区域来定义这个互斥量。</p><p>一个优秀的分布式锁的实现方案应该满足如下几个特性：</p><ol><li>分布式环境下，可以保证不同进程之间的线程互斥</li><li>同一时刻，同时只允许一条线程成功获取到锁资源</li><li>保证互斥量的地方需要保证高可用性</li><li>要保证可以高性能的获取锁和释放锁</li><li>可以支持同一线程的锁重入性</li><li>具备合理的阻塞机制，竞争锁失败的线程要有相应的处理方案</li><li>支持非阻塞式的获取锁。获取锁失败的线程可以直接返回</li><li>具备合理的锁失效机制，如超时失效等，可以确保避免死锁情况出现</li></ol><span id="OSC_h3_7"></span><h3>Redis 实现分布式锁</h3><ul><li>redis 属于中间件，可独立部署；</li><li>对于不同的 Java 进程来说都是可见的，同时性能也非常可观</li><li>依赖与 redis 本身提供的指令<code>setnx key value</code>来实现分布式锁；区别于普通<code>set</code>指令的是只有当 key 不存在时才会设置成功，key 存在时会返回设置失败</li></ul><p>代码实例：</p><pre><code>// 扣库存接口
@RequestMapping("/minusInventory")
public String minusInventory(Inventory inventory) {
    // 获取锁
    String lockKey = "lock-" + inventory.getInventoryId();
    int timeOut = 100;
    Boolean flag = stringRedisTemplate.opsForValue()
            .setIfAbsent(lockKey, "竹子-熊猫",timeOut,TimeUnit.SECONDS);
    // 加上过期时间，可以保证死锁也会在一定时间内释放锁
    stringRedisTemplate.expire(lockKey,timeOut,TimeUnit.SECONDS);
    
    if(!flag){
        // 非阻塞式实现
        return "服务器繁忙...请稍后重试！！！";
    }
    
    // ----只有获取锁成功才能执行下述的减库存业务----        
    try{
        // 查询库存信息
        Inventory inventoryResult =
            inventoryService.selectByPrimaryKey(inventory.getInventoryId());
        
        if (inventoryResult.getShopCount() &lt;= 0) {
            return "库存不足，请联系卖家....";
        }
        
        // 扣减库存
        inventoryResult.setShopCount(inventoryResult.getShopCount() - 1);
        int n = inventoryService.updateByPrimaryKeySelective(inventoryResult);
    } catch (Exception e) { // 确保业务出现异常也可以释放锁，避免死锁
        // 释放锁
        stringRedisTemplate.delete(lockKey);
    }
    
    if (n &gt; 0)
        return "端口-" + port + ",库存扣减成功！！！";
    return "端口-" + port + ",库存扣减失败！！！";
}

作者：竹子爱熊猫
链接：https://juejin.cn/post/7038473714970656775

</code></pre><p><strong>过期时间的合理性分析：</strong></p><p>因为对于不同的业务，我们设置的过期时间的长短都会不一样，太长了不合适，太短了也不合适；</p><p>所以我们想到的解决方案是设置一条子线程，给当前锁资源续命。具体实现是，子线程间隔 2-3s 去查询一次 key 是否过期，如果还没有过期则代表业务线程还在执行业务，那么则为该 key 的过期时间加上 5s。</p><p>但是为了避免主线程意外死亡后，子线程会一直为其续命，造成「长生锁」的现象，所以将子线程变为主（业务）线程的守护线程，这样子线程就会跟着主线程一起死亡。</p><pre><code>// 续命子线程
public class GuardThread extends Thread { 
    private static boolean flag = true;

    public GuardThread(String lockKey, 
        int timeOut, StringRedisTemplate stringRedisTemplate){
        ……
    }

    @Override
    public void run() {
        // 开启循环续命
        while (flag){
            try {
                // 先休眠一半的时间
                Thread.sleep(timeOut / 2 * 1000);
            }catch (Exception e){
                e.printStackTrace();
            }
            // 时间过了一半之后再去续命
            // 先查看 key 是否过期
            Long expire = stringRedisTemplate.getExpire(
                lockKey, TimeUnit.SECONDS);
            // 如果过期了，代表主线程释放了锁
            if (expire &lt;= 0){
                // 停止循环
                flag = false;
            }
            // 如果还未过期
            // 再为则续命一半的时间
            stringRedisTemplate.expire(lockKey,expire
                + timeOut/2,TimeUnit.SECONDS);
        }
    }
}


// 创建子线程为锁续命
GuardThread guardThread = new GuardThread(lockKey,timeOut,stringRedisTemplate);
// 设置为当前，业务线程，的守护线程
guardThread.setDaemon(true);
guardThread.start();

作者：竹子爱熊猫 
链接：https://juejin.cn/post/7038473714970656775

</code></pre><span id="OSC_h3_8"></span><h3>Redis 主从架构下锁失效的问题</h3><p>为了在开发过程保证 Redis 的高可用，会采用主从复制架构做读写分离，从而提升 Redis 的吞吐量以及可用性。但是如果一条线程在 redis 主节点上获取锁成功之后，主节点还没有来得及复制给从节点就宕机了，此时另一条线程访问 redis 就会在从节点上面访问，同时也获取锁成功，这时候临界资源的访问就会出现安全性问题了。</p><p><strong>解决办法：</strong></p><ul><li>红锁算法（官方提出的解决方案）：多台独立的 Redis 同时写入数据，在锁失效时间之内，一半以上的机器写成功则返回获取锁成功，失败的时候释放掉那些成功的机器上的锁。但这种做法缺点是成本高需要独立部署多台 Redis 节点。</li><li>额外记录锁状态：再额外通过其他独立部署的中间件（比如 DB）来记录锁状态，在新线程获取锁之前需要先查询 DB 中的锁持有记录，只要当锁状态为未持有时再尝试获取分布式锁。<strong>但是</strong>这种情况缺点显而易见，获取锁的过程实现难度复杂，性能开销也非常大；另外还需要配合定时器功能更新 DB 中的锁状态，保证锁的合理失效机制。</li><li>使用 Zookepper 实现</li></ul><span id="OSC_h3_9"></span><h3>Zookeeper 实现分布式锁</h3><p>Zookeeper 数据区别于 redis 的数据，数据是实时同步的，主节点写入后需要一半以上的节点都写入才会返回成功。所以如果像电商、教育等类型的项目追求高性能，可以放弃一定的稳定性，推荐使用 redis 实现；例如像金融、银行、政府等类型的项目，追求高稳定性，可以牺牲一部分性能，推荐使用 Zookeeper 实现。</p><span id="OSC_h3_10"></span><h3><strong>分布式锁性能优化</strong></h3><p>上面加锁确实解决了并发情况下线程安全的问题，但是我们面对 100w 个用户同时去抢购 1000 个商品的场景该如何解决呢？</p><p><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-28-16-5151742Rx9fXhfc11ZcV.png" referrerpolicy="no-referrer"></p><ul><li>可与将共享资源做一下提前预热，分段分散存储一份。抢购时间为下午 15：00，提前再 14：30 左右将商品数量分成 10 份，并将每一块数据进行分别加锁，来防止并发异常。</li><li>另外也需要在 redis 中写入 10 个 key，每一个新的线程进来先随机的分配一把锁，然后进行后面的减库存逻辑，完成之后释放锁，以便之后的线程使用。</li><li>这种分布式锁的思想就是，将原先一把锁就可以实现的多线程同步访问共享资源的功能，为了提高瞬时情况下多线程的访问速度，还需要保证并发安全的情况下一种实现方式。</li></ul><span id="OSC_h3_11"></span><h3>参考文章：</h3><ol><li><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7236213437800890423%23heading-3" target="_blank">https://juejin.cn/post/7236213437800890423</a></p></li><li><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7038473714970656775" target="_blank">https://juejin.cn/post/7038473714970656775</a></p></li><li><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.meituan.com%2F2019%2F12%2F05%2Faqs-theory-and-apply.html" target="_blank">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></p></li></ol><blockquote><p>作者：京东科技，焦泽斌</p><p>来源：京东云开发者社区，转载请注明来源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Mon, 11 Dec 2023 01:46:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10319213</guid>
            <link>https://my.oschina.net/u/4090830/blog/10319213</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[惊人发现：加班与生产力下降之间的联系]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Slack 的劳动力指数揭示了如何安排工作日以最大化员工生产力、幸福感和满意度的新发现。</p><p><strong>概要：</strong> 你在工作上如何花费时间，它又在怎样消耗你？Slack 的劳动力指数是基于对全球 10,000 多名办公室员工的调查回复得出的，揭示了如何安排工作日以最大化生产力和增强员工幸福感和满意度的新发现。</p><p>主要知识点包括：</p><ul><li>在工作日结束时下线的员工比那些觉得有义务在下班后工作的员工的生产力得分高出 20%。</li><li>在工作日中抽出时间休息可以提高员工的生产力和幸福感，但有一半的办公室员工表示他们很少或从不休息。</li><li>平均而言，办公室员工表示每天理想的专注时间约为四个小时，而每天超过两个小时的会议是大多数员工感到会议负担过重的临界点。</li><li>每四个办公室员工中就有三个表示在下午 3 点到 6 点的时间段工作，但其中只有四分之一的人认为这些时间高效。</li></ul><p>几十年来，许多人在办公室加班被视为努力工作和生产力的标志，甚至是一种荣誉的象征。但 Slack 的新研究表明，尽管存在这种长期观念，但下班后工作往往与<em>较低</em>的生产力水平相关，并且可能是一个警告信号，表明员工正在处理过多的任务，需要帮助确定优先顺序和平衡时间。</p><p>根据 Slack 对全球 10,000 多名办公员工的调查，最新的劳动力指数结果显示生产力差距取决于是什么促使员工加班至深夜（或凌晨）。每五个办公员工中就有两个（37%）每周至少有几次在公司的标准工作时间之外登录系统，其中超过一半（54%）的员工表示这是由于感受到压力，而不是自己选择加班。</p><p>那些觉得有义务在业余时间工作的员工比那些在标准工作日结束时下班的员工生产力得分低 20%。这些员工还报告：</p><ul><li>与工作相关的压力大 2.1 倍</li><li>对整体工作环境的满意度低 1.7 倍</li><li>疲惫程度高 2 倍</li></ul><p><img src="https://d34u8crftukxnk.cloudfront.net/slackpress/prod/sites/6/Workforce-Lab-Blog-Graphics-Pulse-11_V2_After-Hours-Horchata.png" alt="受到压力而需要在非工作时间工作的员工全天的工作效率低 20%" referrerpolicy="no-referrer"></p><p>这两组员工都表示，他们用于工作的时间约 70% 是富有成效的——这表明那些加班的员工与他们的同事一样努力——但那些在非工作时间工作的员工比那些按时上下班的员工更容易认为他们的生产力被相互冲突的优先事项所阻碍（高出 50%）。</p><p>另一方面，那些选择在标准工作时间之外工作的员工，以更好地安排自己的时间表或追求个人抱负，他们的健康状况和生产力得分没有负面影响，甚至略有提高。</p><blockquote><p>「长期以来，从我们如何分配时间到如何定义生产力，许多工作的重点都放在数量而非质量上。始终感觉需要迎头赶上正在损害员工和企业的利益。这更加突显了建立信任文化的重要性，在这种文化中，员工在需要确定优先事项并平衡工作时间以便完成工作时，敢于表达自己的需求。」</p></blockquote><h2>关于生产率，关键不在于工作时间的长短，而在于质量</h2><p>根据劳动力指数的结果，全球范围内有相当一部分办公员工难以平衡工作时间，不同职业层级的员工面临不同程度的问题。</p><p>超过四分之一的办公员工（27%）表示他们花费太多时间开会，其中超过一半（55%）的高管也认同这一点。同样比例（25%）的员工表示他们花费太多时间在电子邮件上，其中 43% 的高管也表示同样的情况。</p><p>五分之一（20%）的员工表示他们没有足够的时间与同事沟通，这个问题在初级员工中最为明显。</p><p>令人担忧的是，数据显示各个层级的许多员工都在没有休息的情况下完成日常任务：在接受调查的办公员工中，有一半（50%）的人表示他们很少或从不休息。这些员工发生职业倦怠的可能性要高 1.7 倍。</p><p>然而，那些经常休息的同事表现出更高的工作与生活平衡能力（高 62%）、更强的应对压力和焦虑的能力（高 43%）、更高的整体满意度（高 43%），并且出人意料的是，他们的生产力得分高出 13%。</p><blockquote><p>「为什么我们都开始相信，如果我们始终处于工作状态，为了成功我们需要精疲力竭？这可以追溯到第一次工业革命，当时我们开始崇拜机器。机器的目标是尽量减少停机时间。但对于作为人类操作系统来说，停机时间并非缺陷，而是其特点。精英运动员知道恢复是达到最佳表现的一部分。休息时间则是生产力的一个乘数。」</p><p>健康和生产力平台 Thrive Global 创始人兼首席执行官阿丽安娜·赫芬顿（Arianna Huffington）如是说。</p></blockquote><p><img src="https://d34u8crftukxnk.cloudfront.net/slackpress/prod/sites/6/Workforce-Lab-Blog-Graphics-Pulse-11_V2_Taking-Breaks-Horchata.png" alt="经常休息的员工生产力高出 13%" referrerpolicy="no-referrer"></p><h2>最佳工作时间：无论你是晨型人还是夜猫子，下午的低迷期都是真实存在的</h2><p>平均而言，办公员工表示他们工作时间内只有 70% 的时间是高效的。当被问及工作效率最佳时间时，答案差异很大，有些员工喜欢在早上工作，有些则偏爱在晚上。但不管他们的偏好如何，大多数（71%）办公员工都认为下午晚些时候是最不适合工作的时间，从下午 3 点到 6 点这段时间内，工作效率急剧下降。</p><p><img src="https://d34u8crftukxnk.cloudfront.net/slackpress/prod/sites/6/Workforce-Lab-Blog-Graphics-Pulse-11_V2_Afternoon-Slump-Purple.png" alt="" referrerpolicy="no-referrer"></p><p>尽管有四分之三的办公员工表示在下午 3 点到 6 点这段时间内工作，但只有四分之一的人认为这段时间工作效率很高。</p><blockquote><p>「这表明生产效率并非线性增长。生产效率是在一天中不间断地爆发式增长和下降，并不一定在规定的时间窗口内，而且绝对不是连续八小时。‘下午的低迷期’不应该被视为一件坏事；对于许多员工来说，这可能是休息的理想时间，这将提高他们当天的整体工作效率。」</p><p>Slack 研究与分析部高级副总裁兼劳动力实验室负责人 Christina Janzer</p></blockquote><p>那些会管理时间的人往往更高效。他们使用时间管理策略的可能性高出 1.6 倍，更有可能安排一段时间来完成特定任务，只在特定时间查看电子邮件，并设置专注计时器，这样的可能性高出 2.2 倍。</p><h2>工作的「适居带」：如何平衡工作日以优化生产力</h2><p>尽管没有一种适用于所有行业、角色和职位的通用时间表，但仔细研究数据会发现一个公式，可以帮助员工获得成功。</p><p>研究表明，无论职位高低，理想的工作日安排都存在一个「适居带」，即专注时间、协作时间、社交联系和休息时间的平衡。平均而言，办公员工表示每天理想的专注时间约为四个小时。每天超过两个小时的会议是大多数员工表示他们在会议上花费「太多时间」的临界点，所有职位级别都出现了类似的模式。表示在会议上花费太多时间的人更有可能说他们没有足够的时间来集中注意力。相比之下，约有 10% 的办公员工（在新公司工作不到一年或 30 岁以下的员工中最常见）表示他们在会议上花费的时间_太少_，这也与归属感和生产力的降低有关。</p><blockquote><p>「专注时间、协作时间、连接和休息就像工作日的宏量营养素。正确的平衡可以为你提供最佳工作所需的能量。我们不能把这些工作的关键组成部分孤立起来考虑。为了最有效地工作，我们必须为协作工作和专注工作创造空间。」</p><p>Slack 和 Salesforce 员工成功部高级副总裁 David Ard</p></blockquote><h2>办公员工最希望 AI 提供什么帮助？协助和自动化以合理安排会议并腾出时间</h2><p>在办公员工时间管理困难的同时，他们也对 AI 工具的潜力感到兴奋，认为它可以更好地平衡他们的时间。</p><p>绝大多数高管——94%——感到整合 AI 的紧迫性，其中一半的高管表示有强烈的紧迫感。然而，我们的调查显示 AI 的采用仍处于初级阶段，只有五分之一的办公员工表示他们使用过 AI 工具。</p><p>鉴于采用率很低，大多数办公员工（超过 80%）表示 AI 工具尚未提高他们的工作效率也就不足为奇了。但他们预计 AI 将协助解决工作日中最大的难题之一：会议。员工期望 AI 未来能够提供最大价值的三大活动是：1）会议记录和回顾；2）写作协助；3）工作流程自动化。</p><blockquote><p>「各个职位级别的员工可能会惊讶地发现，每天超过两小时的会议会降低生产力。对于许多团队领导者来说，今天达到这个目标可能不切实际。但新一代的 AI 工具可能是救星。能够准确总结会议记录并自动化常见工作流程的 AI 助手可能是腾出时间、成功平衡的关键。」</p><p>Slack 研究和劳动力实验室高级副总裁兼负责人 Christina Janzer</p></blockquote><p><strong>你是在努力工作还是聪明地工作？在我们关于如何优化工作时间的研究中深入探讨这些问题。参加我们的网络研讨会「新研究揭示高效工作日的秘诀」</strong></p><h2>研究方法</h2><p><em>《劳动力指数》于 2023 年 8 月 24 日至 9 月 15 日对美国、澳大利亚、法国、德国、日本和英国的 10,333 名员工进行了调查。调查由 Qualtrics 负责，并未针对 Slack 或 Salesforce 的员工或客户进行。所有受访者都是全职员工（每周工作 30 小时或以上），担任以下其中一种职位，或表示他们「处理数据、分析信息或进行创造性思维」：执行管理层（例如总裁/合伙人、首席执行官、首席财务官、C 级高管）、高级管理层（例如执行副总裁、资深副总裁）、中级管理层（例如部门/团队经理、副总裁）、初级管理层（例如经理、团队负责人）、高级职员（非管理职位）、技术办公室员工（例如分析师、图形设计师）。为简洁起见，我们将调查对象称为「办公室员工」或「办公员工」。</em></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 10 Dec 2023 08:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/1434828/blog/10320336</guid>
            <link>https://my.oschina.net/u/1434828/blog/10320336</link>
            <author>
                <![CDATA[andalousie]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Mistral AI 用「磁链链接」开源了 87 GB 的 8x7B MoE 模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>有「欧洲版 OpenAI」之称的大模型创业公司——Mistral AI 昨天发布了一条<strong>仅包含磁力链接</strong>的推文：</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-6d2f1eed8e7b0598bb332db3f7da2a8db77.png" referrerpolicy="no-referrer"></p><p>来源：<u><em><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2FMistralAI%2Fstatus%2F1733150512395038967" target="_blank">https://twitter.com/MistralAI/status/1733150512395038967</a></strong></em></u></p></blockquote><p>网友打开该磁力链接后发现居然是一个大小为 87 GB 的种子。从命名和目录结构来看，这是一个 PyTorch 模型文件。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f146450c2aefd9e4dd128ccf383b4348362.png" referrerpolicy="no-referrer"></p></blockquote><p>上图的「params.json」JSON 格式文件显然是该模型的主要参数信息，具体如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-1c197917ca03f170a988e23832ba8a2f592.png" referrerpolicy="no-referrer"></p><p>结合参数和文件名信息，Mistral AI 这次「开源」的&nbsp;<strong>mixtral-8x7b-32kseqlen&nbsp;</strong>是一个基于<strong>混合专家 (Mixture of Experts, MoE)</strong>&nbsp;的大模型，<strong>由 8 个 70 亿参数规模 (8×7b) 的专家网络组成</strong>。据称是全球首个开源 MoE 大模型。</p><p>MoE 是用于提高大语言模型效率和准确度的技术。这种方法的核心是将复杂任务划分为更小、更易管理的子任务，每个子任务由专门的小型模型或「专家」负责，然后根据输入数据的特性选择性地激活这些「专家」。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span>MoE 核心组成：</span></p><ol><li><p style="margin-left:0; margin-right:0"><span><strong>专家 (Experts)</strong>：</span><span style="background-color:#ffffff; color:#0f1419">训练有素的小型神经网络，擅长特定领域。</span><span>每个专家通常专注于处理一种特定类型的数据或任务。专家的设计可以是多种形式，如完全连接的网络、卷积网络等。</span></p></li><li><p style="margin-left:0; margin-right:0"><span><strong>门控机制 (Gating Mechanism)</strong>：</span><span style="background-color:#ffffff; color:#0f1419">MoE 架构决策者，</span><span>这是一个智能路由系统，负责决定哪些专家应该被激活来处理当前的输入数据。门控机制基于输入数据的特性，动态地将数据分配给不同的专家。</span></p></li></ol><p>根据 mixtral-8x7b-32kseqlen 的参数信息，该模型对每个 token 的推理使用 2 个专家进行处理（和传闻中的 GPT-4 一样）。</p><blockquote><p>此前<u><a href="https://www.oschina.net/news/249106/gpt-4-architecture-infrastructure" target="_blank">揭秘 GPT-4 技术细节</a></u>的文章提到，GPT-4 是由 16 个专家组成的 MoE 模型，每个专家则是一个包含 1110 亿参数的大模型，每次前向传递路由经过 2 个专家模型。</p></blockquote><p>Mistral AI 目前仍没公布除模型下载链接外的任何信息，如果不想下载但又想体验一把，可以访问下面的网站：</p><ul><li><strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Freplicate.com%2Fnateraw%2Fmixtral-8x7b-32kseqlen" target="_blank">https://replicate.com/nateraw/mixtral-8x7b-32kseqlen</a></u></strong></li><li><strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fapp.fireworks.ai%2Fmodels%2Ffireworks%2Fmixtral-8x7b-fw-chat" target="_blank"><span style="background-color:rgba(0, 0, 0, 0); color:inherit">https://</span>app.fireworks.ai/models/firewor<span style="background-color:rgba(0, 0, 0, 0); color:inherit">ks/mixtral-8x7b-fw-chat</span></a></u></strong></li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-93dba40a2cac79b8ffbc7720a6db69dfd02.png" referrerpolicy="no-referrer"></p><p>对了，这不是 Mistral AI 第一次用「留种」的方式发布开源大模型。Mistral AI 在 9 月底发布的那条磁力链接是其开源的第一个大模型 Mistral-7B，该模型至今仍被称为「最好的 7B 模型」，在每个基准测试中都优于 Llama-2 13B，并且在代码、数学和推理方面优于 LLaMA-1 34B。</p><p><img src="https://oscimg.oschina.net/oscnet/up-28671bd6c309caf5b0fcc86e275681ef529.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 10 Dec 2023 07:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270317/mixtral-8x7b-32kseqlen</guid>
            <link>https://www.oschina.net/news/270317/mixtral-8x7b-32kseqlen</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[从浏览器原理出发聊聊 Chrome 插件]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h3_1"></span><h3>浏览器架构演进</h3><p style="text-align:justify"><strong>单进程浏览器时代</strong></p><p style="text-align:justify">单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。在 2007 年之前，市面上浏览器都是单进程的。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-3442db3861bb3221f7e853cfffa1ea45_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">单进程浏览器的架构</p><p style="text-align:justify">很多功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。</p><ul><li><strong>不稳定：</strong>早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。</li><li><strong>不流畅：</strong>所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。如果一个脚本非常耗时，它就会独占整个线程，这样导致其他运行在该线程中的页面没有机会去执行任务，导致整个浏览器失去响应，变卡顿。</li><li><strong>不安全：</strong>当你在页面运行一个插件时，插件可以操作系统资源，如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</li></ul><span id="OSC_h4_2"></span><h4><strong>多进程浏览器时代</strong></h4><p style="text-align:justify"><strong>早期架构</strong></p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-98f663221fa15549837f9cd878d40653_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">2008 年 Chrome 发布时的进程架构</p><p style="text-align:justify">从图中可以看出，早期的架构已经对浏览器的能力进行了拆分，主要拆分为三类：<strong>浏览器进程、插件进程和渲染进程。</strong>每个页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，进程之间是通过 IPC 机制进行通信。这就解决了单进程时代浏览器的各种问题：</p><ul><li><strong>解决不稳定：</strong>由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面。</li><li><strong>解决不流畅：</strong>JavaScript 运行在渲染进程中，所以即使 JavaScript 阻塞了渲染进程，也只会影响当前的渲染页面，并不会影响浏览器和其他页面，因为其他页面的脚本运行在它们自己的渲染进程中。</li><li><strong>解决不安全：</strong>Chrome 把插件进程和渲染进程锁在沙箱里面，沙箱里面的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</li></ul><p style="text-align:justify"><strong>近期架构</strong></p><p style="text-align:justify">相较之前，近期的架构又有了很多新的变化。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-4c1b8fc023fcd2ad0aa618575cdbc74b_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">近期 Chrome 进程架构</p><p style="text-align:justify">从图中可以看出，最新的 Chrome 浏览器包括：<strong>1 个浏览器主进程、1 个 GPU 进程、1 个网络进程、多个渲染进程和多个插件进程。</strong></p><ul><li><strong>浏览器进程：</strong>主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。可以理解浏览器进程是一个统一的"<strong>调度大师</strong>"去调度其他进程，比如我们在地址栏输入 url 时，浏览器进程首先会调用网络进程。</li><li><strong>渲染进程：</strong>核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong>GPU 进程：</strong>其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li><li><strong>网络进程：</strong>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><strong>插件进程：</strong>主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul><p style="text-align:justify"><strong>当前架构</strong></p><p style="text-align:justify">目前 Chrome 浏览器的架构正在发生一些改变，称为<strong>面向服务的架构 (SOA)</strong>，目的是将和浏览器本身（Chrome）相关的部分拆分为一个个不同的服务，服务化之后，这些功能既可以放在不同的进程里面运行也可以合并为一个单独的进程运行。这样做的主要原因是让 Chrome 在不同性能的硬件上有不同的表现。当 Chrome 运行在一些性能比较好的硬件时，浏览器进程相关的服务会被放在不同的进程运行以提高系统的稳定性。相反如果硬件性能不好，这些服务就会被放在同一个进程里面执行来减少内存的占用。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-42fd4b754c12dcb3981338f765d81a60_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">面向服务的架构</p><span id="OSC_h3_3"></span><h3>插件运行机制</h3><p style="text-align:justify">在运行机制前，我们先来回顾一下打开页面会发生什么：</p><span id="OSC_h4_4"></span><h4><strong>打开页面发生了什么</strong></h4><ul><li>用户新增一个 tab，此时系统浏览器进程、渲染进程、GPU 进程、网络进程会被创建好；</li><li>用户输入 url，浏览器进程检查 url，组装协议，构成完整的 url；</li><li>浏览器进程通过进程间通信（IPC）把 url 请求发送给网络进程；</li><li>网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程；</li><li>如果没有，网络进程向 web 服务器发起 http 请求（网络请求）；</li><li>网络进程解析响应流程； 
  <ul><li>检查状态码，非 200 执行状态码对应的处理逻辑；</li><li>200 响应处理：检查响应类型 Content-Type，如果是字节流类型，则将该请求提交给下载管理器，不再进行后续的渲染，如果是 html 则通知浏览器进程准备渲染进程进行渲染；</li></ul></li><li>准备渲染进程 
  <ul><li>浏览器进程检查当前 url 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程；</li></ul></li><li>传输数据、更新状态 
  <ul><li>渲染进程准备好后，浏览器向渲染进程发起「提交文档」的消息，渲染进程接收到消息和网络进程建立传输数据的「管道」；</li><li>渲染进程接收完数据后，向浏览器发送确认消息；</li><li>浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏 url、前进后退的历史状态、更新 web 页面；</li></ul></li></ul><span id="OSC_h4_5"></span><h4><strong>打开插件发生了什么</strong></h4><p style="text-align:justify">插件的运行相较于页面会有简化</p><p style="text-align:justify">1.我们打开浏览器，新增一个空白 tab 页</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-fbdf73e0cfb877800ffc5a6b290cbee8_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">2.tab 栏空白处右键，选择任务管理器，打开任务管理器面板</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-71e105d5e40961a19574affc5d405506_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">3.可以看到运行了 6 个进程，分别是浏览器进程、GPU 进程、网络进程、存储进程、渲染进程和扩展进程。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-fd99f7006599b3a820d7ffb6dbeaab0d_720w.webp" referrerpolicy="no-referrer"></p><ul><li>扩展进程中运行 Extension Page，主要包括 backgrount.html 和 popup.html； 
  <ul><li>backgrount.html 中没有任何内容，是通过 background.js 创建生成，当浏览器打开时，会自动加载插件的 background.js 文件，它独立于网页并且一直运行在后台，它主要通过调用浏览器提供的 API 和浏览器进行交互；</li><li>popup.html 有内容的，跟我们普通的 web 页面一样，由 html、css、Javascript 组成，它是按需加载的，需要用户去点击地址栏的按钮去触发，才能弹出页面；</li></ul></li><li>渲染进程主要运行 Web Page,当打开页面时，会将 content_script.js 加载并注入到该网页的环境中，它和网页中引入的 Javascript 一样，可以操作该网页的 DOM Tree，改变页面的展示效果；</li><li>GPU 进程主要为插件界面的渲染提供硬件能力支持；</li><li>网络进程主要处理插件中的外部资源请求，比如 nexydy 插件依赖到一些外部 js；</li><li>存储进程为插件提供本地存储能力，比如使用 chrome.storage.local 进行持久化存储；</li><li>浏览器进程在这里更多起到桥梁作用，作为中转可以实现 Extension Page 和 content_script.js 之间的消息通信。</li></ul><span id="OSC_h3_6"></span><h3>插件基本介绍</h3><span id="OSC_h4_7"></span><h4><strong>版本发展</strong></h4><p style="text-align:justify">chrome 插件存在三个版本，分别是<strong>Manifest V1、Manifest V2 和 Manifest V3</strong>。其中 MV1 版本已经被废弃了，目前市面上存在 MV2 和 MV3 版本，以 MV2 为主流，在被 MV3 慢慢取代。时间线：</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-950393136d16d081528b01b5fbc794f1_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>Manifest V2 新特性</strong></p><p style="text-align:justify"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%2Fmv2%2FmanifestVersion%2F%253Fspm%253Da2c6h.13046898.publish-article.26.c7c96ffa7eZ9TZ%2523manifest-v1-changes" target="_blank">https://developer.chrome.com/docs/extensions/mv2/manifestVersion/#manifest-v1-changes</a></p><ul><li>设置了默认的内容安全策略`script-src 'self'; object-src 'self';`。有关内容安全策略的详细配置，可以参考 MDN 文档；</li><li>默认情况下，插件包内的资源不再可供外部网站使用。需要通过清单 web_accessible_resources 属性将其显式列入白名单；</li><li>browser action API 更改；</li><li>page action API 更改；</li><li>chrome.extension 代替 chrome.self 来指向插件本身；</li><li>chrome.extension.getTabContentses 和 chrome.extension.getExtensionTabs 废弃，使用 extension.getViews 替代；</li><li>Port.tab 废弃，使用 runtime.Port 替代；</li></ul><p style="text-align:justify"><strong>Manifest V3 新特性</strong></p><ul><li>Service worker 替换 Background Page；</li><li>网络请求修改废弃 webRequest API 使用新的 declarativentrequest API 来处理；</li><li>不再允许执行远程托管的代码，只能执行扩展包内包含的 JS；</li><li>Promises 已经被添加到许多方法中，但仍支持回调作为替代方法；</li><li>Browser Action API 和 Page Action API 被统一为单独的 Action API；</li><li>Web 可访问的资源，可以只对指定的站点和扩展可用；</li><li>内容安全策略 (CSP)，现在可以为单个对象中的不同执行上下文指定单独的 CSP；</li><li>executeScript 的变化，不能再执行任意字符串，只能执行脚本文件和函数；</li></ul><p style="text-align:justify"><strong>切换 MV3 会带来的问题</strong></p><ul><li>由于 background 不再支持 page 页面配置 background.html，因此也无法调用 window 对象上的 XMLHttpRequest 来构建 ajax 请求，也就是说我们不能像 V2 版本一样，在 background.html 中使用 XMLHttpRequest 来发送请求了，而是需要使用 fetch 来获取接口数据；</li><li>由于 service workers 是短暂的，在不使用时会终止，这意味着它们在整个插件运行期间会不断的启动、运行和终止，也就是不稳定的；因此我们可能需要对 V2 中 background.js 的代码逻辑进行一些改造，以往我们会习惯将一些数据直接存储到全局变量，比如像下面这样：</li></ul><pre><code>// V2 background.js
let saveUserName = "";

// 其他页面，比如 content-script 或者 popup 中存储数据
chrome.runtime.onMessage.addListener(({ type, name }) =&gt; {
  if (type === "set-name") {
    saveUserName = name;
  }
});

// 点击 popup 时展示数据
chrome.action.onClicked.addListener((tab) =&gt; {
  // 这里 saveUserName 可能为空字符串
  console.log(saveUserName, "saveUserName");
});</code></pre><ul><li>因此在 V3 中，需要对这种全局变量数据进行改造，改造的方式也很简单，就是将数据持久化保存到 storage 中，需要用到的地方随用随取：</li></ul><pre><code>// V3 service worker
chrome.runtime.onMessage.addListener(({ type, name }) =&gt; {
  if (type === "set-name") {
    chrome.storage.local.set({ name });
  }
});

chrome.action.onClicked.addListener(async (tab) =&gt; {
  const { name } = await chrome.storage.local.get(["name"]);
  chrome.tabs.sendMessage(tab.id, { name });
});</code></pre><ul><li>由<strong>webRequest API</strong>切换至<strong>declarativentrequest API</strong>，很多代码逻辑需要重构；</li></ul><p style="text-align:justify"><strong>为什么切换 MV3？</strong></p><p style="text-align:justify">从 Manifest V1 到 Manifest V2，可以看到 Chrome 想提高插件的隐私和安全，同时也优化了不少 API。而 Manifest V3 除了安全性更完善外，还在性能上下了功夫。Manifest V3 的核心非常明确，就是限制扩展对系统资源的使用。一直以来高资源占用都是 Chrome 为人诟病的痛点，而且扩展由于在后台运行，如果出现问题，更是难以定位和管理。虽然增加了诸多限制，但 Manifest V3 还是有优点的：</p><ul><li>Service Worker 使扩展不再能常驻后台，让扩展所占用的资源可以被回收，降低了浏览器整体的开销；</li><li>限制规则的数量，相当于控制了单一扩展在规则计算方面的资源使用上限；</li></ul><p style="text-align:justify">这些变化可以让 Chrome 变得更加流畅，对于用户来说是好事。</p><span id="OSC_h4_8"></span><h4><strong>展示形式</strong></h4><p style="text-align:justify">Chrome 插件有以下常见的 8 中展现形式：</p><p style="text-align:justify"><strong>browserAction(浏览器右上角)</strong></p><p style="text-align:justify">在浏览器右上角扩展程序一栏显示，包含一个图标、名称和 popup</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-d1c2fce69c1223a54300c9a2ea96eb9b_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">山海关插件 popup</p><p style="text-align:justify"><strong>pageAction(地址栏右侧)</strong></p><p style="text-align:justify">pageAction 指的是在当某些特定页面打开才显示的图标。在早些版本的 Chrome 是将 pageAction 放在地址栏的最右边，左键单击弹出 popup，右键单击则弹出相关默认的选项菜单。而新版的 Chrome 更改了这一策略，pageAction 和普通的 browserAction 一样也是放在浏览器右上角，只不过没有点亮时是灰色的，点亮了才是彩色的，灰色时无论左键还是右键单击都是弹出选项。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-00231bae7597112980d8851b90979347_720w.webp" referrerpolicy="no-referrer"></p><p><strong>右键菜单</strong></p><p style="text-align:justify">通过开发 Chrome 插件可以自定义浏览器的右键菜单，主要是通过 chrome.contextMenus API 实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-21338dc0d8e7b00dd4bcd5ef3922e777_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">掘金插件右键菜单</p><p style="text-align:justify"><strong>override(覆盖特定页面)</strong></p><p style="text-align:justify">使用 override 可以将 Chrome 默认的一些特定页面替换掉，改为使用扩展提供的页面。扩展可以替代如下页面：</p><ul><li>历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 chrome://history</li><li>新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 chrome://newtab</li><li>书签：浏览器的书签，或者直接输入 chrome://bookmarks</li></ul><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-c730b7492405900d5f1c3cd9131abf06_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">掘金插件替换了新标签页</p><p style="text-align:justify"><strong>devtools(开发者工具)</strong></p><p style="text-align:justify">Chrome 允许插件在开发者工具 (devtools) 上开发，主要表现在：</p><ul><li>自定义一个和多个和 Elements、Console、Sources 等同级别的面板；</li><li>自定义侧边栏 (sidebar)，目前只能自定义 Elements 面板的侧边栏；</li></ul><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-1dca64511239cf86d0d29e29fccc403d_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">React Developer Tools</p><p style="text-align:justify"><strong>option(选项页)</strong></p><p style="text-align:justify">插件的设置页面，可以在右上角入口右键，有一个选项标签</p><div style="text-align:center"><img height="610" src="https://pic1.zhimg.com/80/v2-9fc5b949ed631b4718e3af633977c024_720w.webp" width="672" referrerpolicy="no-referrer"></div><div style="text-align:center">
  &nbsp; 
</div><div style="text-align:center"><img height="506" src="https://pic1.zhimg.com/80/v2-bb3b7e3db84d9b3f544b5fd3e1295b90_720w.webp" width="880" referrerpolicy="no-referrer"></div><p style="text-align:justify"><strong>omnibox</strong></p><p style="text-align:justify">omnibox 是向用户提供搜索建议的一种方式，可以在搜索栏输入特定的标识然后按 Tab 进入搜索。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-670f0e06b91ac66ccda32a21a111d409_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center">JSON Viewer 插件</p><p style="text-align:justify"><strong>桌面通知</strong></p><p style="text-align:justify">Chrome 提供了一个 chrome.notificationsAPI 以便插件推送桌面通知，暂未找到 chrome.notifications 和 HTML5 自带的 Notification 的显著区别及优势。在后台 JS 中，无论是使用 chrome.notifications 还是 Notification 都不需要申请权限（HTML5 方式需要申请权限），直接使用即可。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-e9d3bc3ad06b822b37b4e3ba8543a8a5_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_9"></span><h4><strong>核心介绍</strong></h4><p style="text-align:justify"><strong>manifest.json</strong></p><p style="text-align:justify">这是一个 Chrome 插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，manifest_version、name、version3 个是必不可少的。</p><p style="text-align:justify"><strong>Manifest V2</strong></p><pre><code>{
// 清单文件的版本，这里先使用 2 演示
"manifest_version": 2,
// 插件的名称
"name": "...",
// 插件的版本
"version": "1.0.0",
// 插件描述
"description": "...",
// 图标，一般偷懒全部用一个尺寸的也没问题
"icons": {
"16": "img/icon.png",
"48": "img/icon.png",
"128": "img/icon.png"
  },
// 会一直常驻的后台 JS 或后台页面
"background": {
"scripts": ["js/background.js"]
  },
// 浏览器右上角图标设置，browser_action、page_action、app 必须三选一
"browser_action": {
"default_icon": "img/icon.png",
"default_title": "...",
"default_popup": "popup.html"
  },
// 当某些特定页面打开才显示的图标
"page_action": {
"default_icon": "img/icon.png",
"default_title": "...",
"default_popup": "popup.html"
  },
// 需要直接注入页面的 JS
"content_scripts": [{
"matches": ["&lt;all_urls&gt;"],
"js": ["js/content-script.js"],
"css": ["css/custom.css"],
// 代码注入的时机，document_start, document_end, document_idle，默认 document_idle
"run_at": "document_start"
    },
  ],
// 权限申请
"permissions": [
"contextMenus", // 右键菜单
"tabs", // 标签
"notifications", // 通知
"webRequest", // web 请求
"webRequestBlocking",
"storage", // 插件本地存储
"https://*/*" // 可以通过 executeScript 或者 insertCSS 访问的网站
  ],
// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的
"web_accessible_resources": ["js/inject.js"],
"homepage_url": "...", // 插件主页
"chrome_url_overrides": { // 覆盖浏览器默认页面
"newtab": "newtab.html"
  },
"options_ui": { // 插件选项页
"page": "options.html",
"chrome_style": true
  },
"omnibox": { "keyword" : "..." }, // 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字
"default_locale": "zh_CN", // 默认语言
"devtools_page": "devtools.html", // devtools 页面入口，注意只能指向一个 HTML 文件，不能是 JS 文件
"content_security_policy": "...", // 安全策略
"web_accessible_resources": [ // 可以加载的资源
    RESOURCE_PATHS
  ]
}</code></pre><p style="text-align:justify"><strong>Manifest V3（仅展示与 V2 版本的不同点）</strong></p><pre><code>{
"manifest_version": 3,
"background": {
"service_worker": js/background.js"
  },
  "action": { //browser_action 和 page_action，统一为 Action
    "default_icon": "img/icon.png",
    "default_title": "这是一个示例 Chrome 插件",
    "default_popup": "popup.html"
  }
  "content_security_policy": {
    "extension_pages": "...",
    "sandbox": "..."
  },
  "web_accessible_resources": [{
    "resources": [RESOURCE_PATHS]
  }]
}</code></pre><p style="text-align:justify"><strong>content-scripts</strong></p><p style="text-align:justify">是 Chrome 插件中向页面注入脚本的一种形式（虽然名为 script，其实还可以包括 css 的），借助 content-scripts 我们可以实现通过配置的方式轻松向指定页面注入 JS 和 CSS。content-scripts 和原始页面共享 DOM，但不共享 JS。如要访问页面 JS（例如某个 JS 变量），只能通过 injected js 来实现。content-scripts 不能访问绝大部分 chrome API，除了下面这 4 种：</p><ul><li>chrome.extension</li><li>chrome.i18n</li><li>chrome.runtime</li><li>chrome.storage</li></ul><p style="text-align:justify">这些 API 绝大部分时候都够用了，有需要调用其它 API 的话，可以通过通信让 background 或 service worker 来帮忙调用</p><p style="text-align:justify"><strong>background</strong></p><p style="text-align:justify">后台是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在 background 里面。background 的权限非常高，几乎可以调用所有的 Chrome 扩展 API（除了 devtools），而且它可以无限制跨域，可以跨域访问任何网站而无需要求对方设置 CORS。background 的概念在 MV3 版本中变为了 service worker，区别在于生命周期变短了，service worker 是短暂的基于事件的脚本，所以不适合用来保存全局变量。</p><p style="text-align:justify"><strong>popup</strong></p><p style="text-align:justify">popup 是点击右上角图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。权限级别和 background 差不多，就是生命周期比较短。</p><p style="text-align:justify"><strong>injected-script</strong></p><p style="text-align:justify">chrome 插件中其实没有 injected-script 这一概念，这是开发者们在开发过程中衍生出来的一种概念，指的是通过 DOM 操作的方式向页面注入的一种 JS。因为 content-script 无法访问页面中的 JS，虽然可以操作 DOM，但是 DOM 却不能调用它，也就是无法在 DOM 中通过绑定事件的方式调用 content-script 中的代码。但是在网页中增加一个按钮来调用插件的能力是一个比较常见的需求，所以诞生了 injected-script。</p><span id="OSC_h4_10"></span><h4><strong>插件通信机制</strong></h4><p style="text-align:justify">讲通信机制之前，先回顾一下插件中存在的脚本类型。Chrome 插件的 JS 主要可以分为这 5 类：injected script、content-script、popup js、background js 和 devtools js。</p><p style="text-align:justify"><strong>权限对比</strong></p><table><tbody><tr><td style="text-align:justify">JS 种类</td><td style="text-align:justify">可访问的 API</td><td style="text-align:justify">DOM 访问情况</td><td style="text-align:justify">JS 访问情况</td><td style="text-align:justify">直接跨域</td></tr><tr><td style="text-align:justify">injected</td><td style="text-align:justify">和普通 JS 无任何差别，不能访问任何扩展 API</td><td style="text-align:justify">可以访问</td><td style="text-align:justify">可以访问</td><td style="text-align:justify">不可以</td></tr><tr><td style="text-align:justify">content</td><td style="text-align:justify">只能访问 extension、runtime 等部分 API</td><td style="text-align:justify">可以访问</td><td style="text-align:justify">不可以</td><td style="text-align:justify">不可以</td></tr><tr><td style="text-align:justify">popup</td><td style="text-align:justify">可访问绝大部分 API，除了 devtools 系列</td><td style="text-align:justify">不可直接访问</td><td style="text-align:justify">不可以</td><td style="text-align:justify">可以</td></tr><tr><td style="text-align:justify">background</td><td style="text-align:justify">可访问绝大部分 API，除了 devtools 系列</td><td style="text-align:justify">不可直接访问</td><td style="text-align:justify">不可以</td><td style="text-align:justify">可以</td></tr><tr><td style="text-align:justify">devtools</td><td style="text-align:justify">只能访问 devtools、extension、runtime 等部分 API</td><td style="text-align:justify">可以</td><td style="text-align:justify">可以</td><td style="text-align:justify">不可以</td></tr></tbody></table><p style="text-align:justify">通过权限对比可以看到，每一种脚本在权限上都不相同，所以各种脚本间的相互通信就非常重要，这也是插件能够实现众多功能的基础。</p><p style="text-align:justify"><strong>通信概览</strong></p><table><tbody><tr><td style="text-align:justify">&nbsp;</td><td style="text-align:justify">injected</td><td style="text-align:justify">content</td><td style="text-align:justify">popup</td><td style="text-align:justify">background</td></tr><tr><td style="text-align:justify">injected</td><td style="text-align:justify">-</td><td style="text-align:justify">window.postMessage</td><td style="text-align:justify">-</td><td style="text-align:justify">-</td></tr><tr><td style="text-align:justify">content</td><td style="text-align:justify">window.postMessage</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.runtime.sendMessage chrome.runtime.connect</td><td style="text-align:justify">chrome.runtime.sendMessage chrome.runtime.connect</td></tr><tr><td style="text-align:justify">popup</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.tabs.sendMessage chrome.tabs.connect</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.extension. getBackgroundPage</td></tr><tr><td style="text-align:justify">background</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.tabs.sendMessage chrome.tabs.connect</td><td style="text-align:justify">chrome.extension.getViews</td><td style="text-align:justify">-</td></tr><tr><td style="text-align:justify">devtools</td><td style="text-align:justify">chrome.devtools. inspectedWindow.eval</td><td style="text-align:justify">-</td><td style="text-align:justify">chrome.runtime.sendMessage</td><td style="text-align:justify">chrome.runtime.sendMessage</td></tr></tbody></table><span id="OSC_h3_11"></span><h3>一些常见插件的实现思路</h3><span id="OSC_h4_12"></span><h4><strong>埋点日志检测</strong></h4><p style="text-align:justify">一般业务中都会进行一些埋点上报，埋点的本质就是发送一些带特定参数的请求，前端本地调试的时候想实时查看埋点信息通常需要去查看上报接口的入参，或者去对应的埋点平台查看，这样非常不方便。基于这个，我们可以使用插件来帮助我们快速的可视化查看埋点信息：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-d9e6e16e3db7cd8922d8b437219a96e2_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_13"></span><h4><strong>页面注入小工具</strong></h4><p style="text-align:justify">插件的另一个常见用法就是往页面注入一些工具代码，比如去除页面广告工具。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-0de602a3e05ff59d5e0b6f1450c44d76_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h3_14"></span><h3>总结</h3><ul><li>随着浏览器不断的发展，Chrome 逐渐把一些基础服务独立出来，类似于一个跨平台的线上操作系统。</li><li>Chrome 插件提供的能力很丰富，比如代码注入、跨域请求、持久化方案、各种通信机制等，开发者可以发挥想象，组装不同能力以适应不同场景的需求，基本可以实现现代 web 所能支持的所有功能。</li><li>Chrome 插件 MV2 版本将在 24 年 1 月全面废弃，需要尽快迁移至 MV3 版本。</li></ul><span id="OSC_h3_15"></span><h3><strong>参考资料：</strong></h3><p>《浏览器工作原理与实践》：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Ftime.geekbang.org%2Fcolumn%2Fintro%2F100033601%253Fspm%253Da2c6h.13046898.publish-article.27.c7c96ffa7eZ9TZ%2526tab%253Dcatalog" target="_blank">https://time.geekbang.org/column/intro/100033601?tab=catalog</a></p><p>《Inside look at modern web browser》：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fblog%2Finside-browser-part1%2F%253Fspm%253Da2c6h.13046898.publish-article.28.c7c96ffa7eZ9TZ" target="_blank">https://developer.chrome.com/blog/inside-browser-part1/</a></p><p>《图解浏览器的基本工作原理》：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F47407398%3Fspm%3Da2c6h.13046898.publish-article.29.c7c96ffa7eZ9TZ" target="_blank">https://zhuanlan.zhihu.com/p/47407398</a></p><p>《Welcome to Manifest V3》：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%2Fmv3%2Fintro%2F%253Fspm%253Da2c6h.13046898.publish-article.30.c7c96ffa7eZ9TZ" target="_blank">https://developer.chrome.com/docs/extensions/mv3/intro/</a></p><p>MDN 文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCSP%253Fspm%253Da2c6h.13046898.publish-article.31.c7c96ffa7eZ9TZ" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP</a>web_accessible_resources：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%2Fmv2%2Fmanifest%2Fweb_accessible_resources%2F%253Fspm%253Da2c6h.13046898.publish-article.32.c7c96ffa7eZ9TZ" target="_blank">https://developer.chrome.com/docs/extensions/mv2/manifest/web_accessible_resources/</a></p><p style="text-align:justify">作者｜闵子</p><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1381666%3Futm_content%3Dg_1000385322" target="_blank">原文链接</a></strong></p><p style="text-align:justify"><strong>本文为阿里云原创内容，未经允许不得转载。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 10 Dec 2023 04:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10319584</guid>
            <link>https://my.oschina.net/yunqi/blog/10319584</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[余承东：华为明年将推出颠覆性产品，改写行业历史]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>12 月 9 日，2023 华为花粉年会在松山湖基地举行。华为常务董事、终端 BG CEO、智能汽车解决方案 BU 董事长余承东在年会上表示，<strong>明年会推出非常有引领性、创新性、颠覆性的产品。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d15077f4297790d71ee33fb17fcdc27333c.png" referrerpolicy="no-referrer"></p><p><strong><strong>余承东直言：「到时候你可以看到我们怎么样能够</strong>改写这个行业的历史</strong>。希望能够不断地带来超越大家的期待，做别人想不到的事情或者想到但做不到的事，甚至是他们不敢想的事情。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e2b780aafbf00c463c0e8273e50a58bead5.png" referrerpolicy="no-referrer"></p><p>余承东还预告，华为明年将会推出鸿蒙原生应用与原生体验的产品，「<strong>那将会是整个中国终端类操作系统里真正的王者</strong>」。</p><p>此前，有消息称华为可能明年推出不兼容 Android 的鸿蒙版本。11 月 20 日，据澎湃新闻报道，一华为相关人士表示，推出时间还不确定，未来 iOS、鸿蒙、Android 将为三个各自独立的系统。</p><p>稍早前据证券时报报道，有业内人士亦表示：「华为内部确实有这计划，就是明年推出不兼容 Android 的鸿蒙版本，但目前内部还没有下发相关通知，所以具体何时推出暂不明确。」</p><p>在 9 月 25 日举行的华为秋季全场景新品发布会上，华为常务董事、终端 BG CEO、智能汽车解决方案 BU 董事长余承东宣布，鸿蒙原生应用全面启动，HarmonyOS NEXT 开发者预览版将在 2024 年第一季度面向开发者开放。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-619518ef25720c3272f8663f57f84ce9cbb.png" referrerpolicy="no-referrer"></p><p>会上，华为与近 40 家合作伙伴举办鸿蒙生态合作签约仪式，包括：小红书、招商银行、携程旅行、美图、58 同城、360 浏览器、网易有道词典、石墨文档、classln 应用、洪恩识字、汉王科技、作业帮、亿图脑图 MindMaster 应用、会见会议、2345 好压、宝宝巴士、喜马拉雅、讯飞听见、浩辰 CAD、掌上生活、邮储银行、钛媒体、驾考宝典、书生电子、交通银行、中信银行、兴业证券、央广网、搜狐新闻、蜻蜓 FM、京东健康、动卡空间、东方财富、天天基金、大智慧、深圳 CA 签章、中软国际、中国音像与数字出版协会等应用与服务商。</p><p>10 月 26 日，包含支付宝、小红书、哔哩哔哩、滴滴出行、同程旅行、哈啰等十余家知名互联网企业，参加了华为在上海举行的鸿蒙生态伙伴联合创新会，了解 HarmonyOS NEXT 的能力与特性，现场达成 10+创新场景合作意向。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 10 Dec 2023 03:15:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270290</guid>
            <link>https://www.oschina.net/news/270290</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[黑客攻击招聘 APP 短信验证码接口用于「撞库」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>央视新闻报道了招聘 APP 遭黑客攻击导致 300 万条数据泄露的案件。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-e4acf1c1251a484866c2db701cf03469b78.png" referrerpolicy="no-referrer"></p><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F2656274875%2FNwrWnni5v%3Fpagetype%3Dprofilefeed" target="_blank">https://www.weibo.com/2656274875/NwrWnni5v?pagetype=profilefeed</a></u></em></p></blockquote><p>根据报道，前段时间北京警方接到辖区内一家互联网公司报案，称该公司求职招聘类 App 的短信验证码接口遭受 1300 余万次攻击，且成功匹配注册账号 30 余万个。北京警方迅速研判，<strong>确定这是一起黑客利用网站漏洞非法获取账号信息并用于违法活动的案件</strong>。</p><p>据了解，犯罪嫌疑人喻某交代称，自己于 2022 年 10 月 18 日在该招聘平台注册账号，并数次尝试验证接口。<strong>他发现该网站的签名算法相对单一，便利用该弱点编写指令，制作黑客软件对网站进行「撞库」攻击</strong>。</p><p>同时，他还利用类似方式对其他各大网站进行渗透，并伺机查询网站漏洞，<strong>以此为诱饵向他人兜售自己编写的恶意程序、黑客工具，从中牟利</strong>。经过民警不懈努力，专案组成功在四川成都将另一名嫌疑人焦某抓获，<strong>现场起获各类公司、人员数据 330 余万条</strong>。</p><p>犯罪嫌疑人喻某、焦某因破坏计算机信息系统罪被依法刑事拘留，案件正进一步办理中。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 10 Dec 2023 02:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270288</guid>
            <link>https://www.oschina.net/news/270288</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[systemd 新组件 systemd-bsod — 为 Linux 引入「蓝屏」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>systemd 255 近日<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsystemd%2Fsystemd%2Freleases%2Ftag%2Fv255" target="_blank">发布了稳定版</a></u>，其新增的"<strong>systemd-bsod</strong>"实验性组件让人眼前一亮——没错，正是大名鼎鼎的「蓝屏死机」（Blue Screen of Death，简称 BSOD）。</p><p>BSOD 是微软 Windows 操作系统在无法从一个系统错误中恢复过来时，为保护电脑数据文件不被破坏而强制显示的屏幕图像。Windows 的蓝屏死机提示已成为标志性画面，大部分是系统崩溃的现象。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-51d3ac36bc416abe53fe1c0517c774a1824.png" referrerpolicy="no-referrer"></p><p><em>上图是 Windows 10 的蓝屏死机画面（版本 1607-21H2），它包含了一个悲伤的颜文字和一个用于快速排查错误的二维码</em>。</p><p>简而言之，BSOD 就是用于展示错误信息的诊断工具。虽然大家讨厌看到蓝屏界面，但这不意味着 BSOD 本身是一个坏方案。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d1cfdcf33e390c881d32ad1ef5146419e5e.png" referrerpolicy="no-referrer"></p><p>根据&nbsp;systemd 更新日志的介绍，当日志级别设置为"<strong>LOG_EMERG</strong>"时，如果 Linux 系统出现引导错误，新组件"systemd-bsod"会全屏显示报错信息（即 BSOD）。和 Windows 的 BSOD 类似，它也会生成二维码，以便用户通过手机获取启动失败报错的更多信息。</p><p>"systemd-bsod" 属于&nbsp;<span>Outreachy 项目的一部分，该项目是为开发开源工具的人员提供实习机会的组织。</span></p><p>systemd-bsod 目前处于实验性阶段，GitHub 上的更新日志也指出它仍会有改动。但不管怎样，不少主流 Linux 发行版如 Ubuntu、Fedora、Debian 和 Red Hat 都采用了 systemd。所以 2024 年，相信不少 Linux 发行版都会引入「蓝屏」。</p><p>对了，systemd 创始人兼首席开发者 Lennart Poettering 去年<u><a href="https://www.oschina.net/news/202119/systemd-creator-microsoft" target="_blank">被微软从 Red Hat 挖走</a></u>&nbsp;—— 继续专注于开发 systemd。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 09 Dec 2023 05:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270207/systemd-255-bsod</guid>
            <link>https://www.oschina.net/news/270207/systemd-255-bsod</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[雷军 30 年前写的论文：《计算机病毒判定专家系统原理与设计》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>雷军 1992 年发表的《计算机病毒判定专家系统原理与设计》论文在网上曝光，引发热议。</p><p>这份论文详细地描述了计算机病毒判定专家系统的原理与具体设计方法，一定程度上解决了流行病毒的判定问题。论文结语写道：<strong>研制解决流行病毒判定问题的专家系统，在目前具有相当大的使用价值。本文介绍的这种智能判定方法大大优于传统的检测方法，具有准确率高，适用性广的有点，还可以不断发展和扩充。关于这种方法，目前国内外文献上尚未提及。（参考文献略）</strong></p><p>附论文原文：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-00e57539a1c6a07aa17cb70f341f3f2d3c1.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-9babb896439e0b4a049532c7537dba1318f.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-c000968b49128269073f6f38373e6162709.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-a14bb1726495836bf7d6d463cbbefdb16a1.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-63cb2ee41ae8f0981dc0a88d94251dd61fb.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-d7986af830afb49d055c14584452431d642.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-dea1bb17744fa373895687fd84a7d5520ab.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-b68d4f4408348e18bba5c70dd2006a1a855.png" referrerpolicy="no-referrer"></p><p>来源：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F5714719345%2FNvR23gzWc%3Fpagetype%3Dviewer" target="_blank">https://weibo.com/5714719345/NvR23gzWc?pagetype=viewer</a></em></u></p><p>华为消费者 BG 战略 Marketing 部副总裁李昌竹转发了该论文的微博，<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1402329495%2FNwbO90AHM%3Fpagetype%3Dprofilefeed" target="_blank">并说道</a></u>：<strong>「技术创新和前沿探索都是值得尊敬和学习的。」</strong></p><p><img src="https://oscimg.oschina.net/oscnet/up-4cbc7936df3d1ad8b4a787215eb1fbea304.png" referrerpolicy="no-referrer"></p><p>1992 年，雷军还与求伯君合著了《深入 DOS 编程》一书。在接下来的两年里，雷军涉猎广泛，写过加密软件、杀毒软件、财务软件、CAD 软件、中文系统以及各种实用小工具等。</p><p><img src="https://oscimg.oschina.net/oscnet/up-389de1159783b7b408cade4d27be661e412.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-d80cc19de34a8b5e73cfe14690d437a0a70.png" referrerpolicy="no-referrer"></p><p>公开资料显示，1987 年，雷军毕业于原沔阳中学（现湖北省仙桃中学），同年考上了武汉大学计算机系。</p><p>1992 年初，雷军加盟金山公司。先后出任金山公司北京开发部经理、珠海公司副总经理、北京金山软件公司总经理等职务。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 09 Dec 2023 03:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270190</guid>
            <link>https://www.oschina.net/news/270190</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[大家好，我龙博，我们做了个很酷的开源工具]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Hello ，大家好，我是龙博，目前担任 ILLA Cloud 的 CEO 。 创业之前在字节跳动和快手写代码，一直以来都是一个热爱技术的小伙伴！</p><h2>介绍一下我们产品</h2><p>ILLA Cloud 是一个非常好用的开源低代码工具，我们已经完整的迭代两年了。</p><p>传送门：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Filla.cloud" target="_blank">https://illa.cloud</a></p><p>Github: <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fillacloud%2Filla-builder" target="_blank">https://github.com/illacloud/illa-builder</a></p><p>我们的 star 都是我们用户一个一个点上去的，我们没有进行任何的操作行为，所以 star 并没有那么多，还在冲击 1w ，希望大家多给我们点赞～</p><p>我们是一个开箱即用的低代码工具，希望大家能使用一下去解决公司里面搭建内部系统的问题，专注各种管理后台，也就是大家无法购买到的系统，只能通过传统前端方式构建，大家都知道没有前端喜欢写后台，^_^</p><p>使用我们可以构建出来相对比较美观的各种内部工具，保证大家的 App ，Web 网站有一个好用的管理后台工具。</p><p><img src="https://cdn.illacloud.com/illa-blog/Discussion/Frame%2033402x.png" alt="低代码" referrerpolicy="no-referrer"></p><p>我们也有很多用户在使用我们的产品搭建属于自己公司的内部 AI 工具，比如使用 Agent 去做邮件生成，使用低代码工具搭建属于自己的 Stable Diffusion 面板。</p><p><img src="https://cdn.illacloud.com/illa-blog/Discussion/discussion2.png" alt="AI" referrerpolicy="no-referrer"></p><p>我们在过去的大量工作里面支持了大量的集成能力，主流的数据库和接口都支持了。我们还同 Hugging Face 达成了官方的合作，保证每一个用户都可以快速的访问 Hugging Face 中的模型从而让自己构建出来的产品有大量开箱即用的 AI 能力</p><h2>关于我们公司</h2><p>我们是 2022 年元旦之后开始创立的，目前这个产品已经完整迭代两年了，才敢宣传一下，我们相信这里的小伙伴对产品都有极高的追求滴！</p><p>我们产品在创立初期也获得了高领资本，源码资本，奇绩创坛的融资，所以大家不用担心我们的生存问题。感谢国内顶级的资本对开源事业的支持，我们相信开源可以让产品更加的茁壮成长。</p><p>主要是真心邀请大家一起构建我们的产品，我们相信中国的开发者是全世界最优秀的一群人（数据上看也确实是），我们作为一家服务开发者的公司非常荣幸可以让大家来用一用我们的产品。</p><h2>最后</h2><p>如果你对我们产品感兴趣，欢迎找我聊聊，我的 v：owen_longbo</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 10:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/xlyg/blog/10320194</guid>
            <link>https://my.oschina.net/xlyg/blog/10320194</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[商汤科技发布 AI 编程助手「代码小浣熊 Raccoon」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>商汤科技宣布，基于商汤自研大语言模型的智能编程助手 —— 代码小浣熊 Raccoon (<strong>R</strong>accoon is<strong>A</strong>nother&nbsp;<strong>C</strong>ode&nbsp;<strong>CO</strong>-pil<strong>O</strong>t&nbsp;<strong>N</strong>avigator) 已开放公测。</p><p>代码小浣熊 Raccoon 支持 Python、Java、JavaScript、C++、Go、SQL 等 30+ 主流编程语言和 VS Code、IntelliJ IDEA 等主流 IDE。主要特性如下：</p><ul><li><p>代码编写建议覆盖 30 多种主流编程语言，依据上下文，自动生成代码。</p></li><li><p>开放对话功能，理解用户的自然语言需求描述。</p></li><li><p>预设基于注释生成代码、跨编程语言翻译、单元测试用例生成、代码修正、代码重构、技术领域知识问答等功能。</p></li><li><p>支持用户自定义需求：包括需求文档生成、代码生成注释、代码的解释文档生成、技术文档生成等开放式能力。</p></li></ul><blockquote><p><strong>体验地址：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.sensetime.com" target="_blank">https://code.sensetime.com</a></u></em><br> 使用文档</strong>：<strong><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.sensetime.com%2Fdocs" target="_blank">https://code.sensetime.com/docs</a></em></u></strong></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2c679cff58be01097976aee3c1003e89b3a.png" referrerpolicy="no-referrer"></p><p><img height="722" src="https://oscimg.oschina.net/oscnet/up-21140dc87019c7b03213e62078c9e35292d.png" width="2398" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-fa0feda14f70e8765c400cbbda8eb386722.png" referrerpolicy="no-referrer"></p><p>代码小浣熊由商汤自研大语言模型提供支持，覆盖软件需求分析、架构设计、代码编写、软件测试等环节，满足用户代码编写、数据分析、编程学习等各类需求。在实际应用中，可帮助开发者提升编程效率超 50%。</p><p>在最新权威代码生成测试集 HumanEval 的测试中，该模型精度表现惊艳，一次通过率甚至达到惊人的 71%，已经大幅超越 GPT-3.5。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 07:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270111</guid>
            <link>https://www.oschina.net/news/270111</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[虚拟机成为 Android 的核心结构]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>安卓虚拟化框架（AVF）将出现在即将推出的部分安卓 14 设备上。AVF 于 Android 13 首次在 Pixel 设备上推出，为开发特权应用程序的平台开发人员提供了新的功能。</p><p>有了 AVF，我们将更广泛地支持安卓的虚拟化。虚拟化被广泛应用和部署，以隔离工作负载和操作系统。它可以有效地扩展基础设施、测试环境、兼容传统软件、创建虚拟桌面等。</p><p style="text-align:start">有了 AVF，虚拟机就成了安卓操作系统的核心结构，类似于安卓利用 Linux 进程的方式。开发人员可以灵活选择虚拟机的隔离级别：</p><ul><li><p>单向隔离：安卓（主机）可以控制和检查虚拟机的内容。这些虚拟机最常用于沙箱和隔离，使多个操作系统能在同一台机器/设备上运行，由一个操作系统主机（Android）控制和监视所有其他操作系统。</p></li></ul><ul><li><p>双向隔离（隔离虚拟机）：Android（主机）和虚拟机（客户机）完全相互隔离。处理或存储敏感数据的开发人员可能会受益于隔离虚拟机。隔离虚拟机具有双向屏障，主机（Android）和虚拟机都无法访问对方，除非通过明确商定的通信渠道。这有两个主要特性：</p></li></ul><blockquote><blockquote><ol><li><p>主机（Android）无法访问虚拟机内的工作负载和数据（保密）。</p></li><li><p>即使 Android 一直到（包括）主机内核都受到攻击，隔离的虚拟机也不会受到攻击。</p></li></ol></blockquote></blockquote><h3 style="text-align:start"><strong>AVF 的意义</strong></h3><h4 style="text-align:start"><strong>隔离</strong></h4><p style="text-align:start">有了隔离虚拟机，开发人员现在有了 Trustzone 之外的另一种选择，可用于需要在不升级权限的情况下与 Android 隔离的用例。</p><h4 style="text-align:start"><strong>便携性</strong></h4><p style="text-align:start">虚拟机及其内部运行的应用程序的可移植性远高于可信 applets。例如，带有 Linux 应用程序有效载荷的基于 Linux 的虚拟机可以在所有支持 AVF 的设备上运行。这意味着开发人员只需构建一次应用程序，就可以将其部署到任何地方。与移植到 Trustzone 操作系统相比，虚拟机还能无缝、轻松地移植基于 Linux 的现有应用程序。</p><h4 style="text-align:start"><strong>性能</strong></h4><p style="text-align:start">AVF 设计轻巧、高效、灵活。虚拟机可以：</p><ul><li><p>根据开发者的需要，小到一个 C 语言程序，大到整个操作系统；</p></li><li><p>做到持续性或间歇性；</p></li><li><p>根据整个系统的健康状况增加或缩小内存；</p></li><li><p>遵循 Android 的调度程序提示和低内存警告。</p></li></ul><h4 style="text-align:start"><strong>可扩展性</strong></h4><p style="text-align:start">AVF 在设计时考虑到了开发人员的需求。虚拟机可以定制，以满足特定用例的需求。只要符合 AVF 规定的某些启动和通信协议，开发人员就可以部署任何虚拟机有效载荷。</p><p style="text-align:start">除了将虚拟化的强大功能引入安卓系统，实现虚拟桌面、沙箱、AVF 使用隔离虚拟机的所有可能性外，还能使以下常见的安卓使用场景（以及更多使用场景）受益：</p><ul><li><p>生物识别：通过在隔离的虚拟机中部署生物识别可信 applets，开发人员将获得隔离保证、生物识别算法所需的更多计算能力、与 Trustzone 操作系统无关的轻松更新能力以及更简化的部署。</p></li></ul><ul><li><p>DRM：Widevine 可在安卓设备上实现流式 DRM。一旦部署在隔离的虚拟机中，无论安卓设备上部署的各种 Trustzone 操作系统的细节如何，Widevine 的更新在这些设备上都会变得更加容易。</p></li></ul><h3 style="text-align:start"><strong>AVF 使用</strong></h3><p style="text-align:start">AVF 提供了简单的应用程序接口，用于查询设备创建虚拟机的能力及其支持的类型，以及从创建虚拟机的应用程序和服务与这些虚拟机建立安全的通信渠道。</p><p style="text-align:start">例如，检查 AVF API 的可用性，以及隔离虚拟机和常规虚拟机的可用性：</p><pre><code>VirtualMachineManager manager =
     (VirtualMachineManager)context.
          getSystemService(VirtualMachineManager.class);
if (manager == null) {
    // AVF not supported
} else {
    int capabilities = manager.getCapabilities();
    if ((capabilities &amp; CAPABILITY_PROTECTED_VM) != 0) {
        // protected VM is supported
    }
    if ((capabilities &amp; CAPABILITY_NON_PROTECTED_VM) != 0) {
        // non protected VM is supported
    }
}
</code></pre><p style="text-align:start">有关 AVF 及其 API 的其他文档，请<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fvirtualization" target="_blank">点击此处查看</a>。</p><h3 style="text-align:start"><strong>AVF 组件</strong></h3><p><img align="left" alt="AVF Component architecture" height="219" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjqoflrFdKllbCL-ksao2ozMc0Vwp3eAXNadr58iaiCyd4noAKVuwaetGcVVoU1s1s_g3FA94wCHv_wg8AYbnczEY518U98tUwpYqkyLM-H2IbKpJcNY55xg6yCw5KO2Nk5HW2uAxAGNBXVdDVm8dNdG4das2y7RBWaQCWleykRilaLbd0sfFnb0JOXgC0/s1600/image1.png" width="453" referrerpolicy="no-referrer"></p><p>AVF 由框架 API、<strong>Hypervisor </strong>和虚拟机管理器组成。<strong>Hypervisor </strong>确保虚拟机（包括 Android）相互隔离，就像 Linux 内核对进程的隔离一样。不过，与 Linux 内核相比，AVF <strong>Hypervisor</strong>（pKVM）的代码量要小得多（约 50 倍）。</p><h4 style="text-align:start"><strong>Hypervisor (</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fvirtualization%2Farchitecture%23hypervisor" target="_blank"><strong>pKVM</strong></a><strong>)&nbsp;</strong></h4><p style="text-align:start"><strong>Hypervisor </strong>侧重于开源可用性、安全性、虚拟机的设备分配以及虚拟机之间的隔离安全。它的攻击面较小，符合较高的安全保证级别。受保护的 KVM <strong>Hypervisor</strong>（pKVM）完全支持 AVF API 和功能。</p><p style="text-align:start">pKVM 构建在 Linux 中基于内核的虚拟机（KVM）这一行业标准之上。这意味着所有依赖基于 KVM 的虚拟机的现有操作系统和工作负载都能通过 pKVM 在安卓设备上无缝运行。</p><h4 style="text-align:start"><strong>虚拟机管理器 (</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fexternal%2Fcrosvm%2F" target="_blank"><strong>crosvm</strong></a><strong>)</strong></h4><p style="text-align:start">crosvm 是基于 Rust 的虚拟机管理器（VMM），是 <strong>Hypervisor </strong>与 AVF 框架之间的桥梁。它负责创建、管理和销毁虚拟机。此外，它还提供了一个跨多个 <strong>Hypervisor </strong>实现的抽象层。</p><h4 style="text-align:start"><strong>隔离虚拟机</strong></h4><p style="text-align:start">隔离的虚拟机对 Android 来说是不可见的，即在 Android 中运行的任何进程都无法检查、查看或篡改此类虚拟机的内容。这一保证由 <strong>Hypervisor </strong>提供。</p><h4 style="text-align:start"><strong>虚拟机</strong></h4><p style="text-align:start">虚拟机与隔离的虚拟机相同，只是拥有正确权限的 Android 进程可以访问虚拟机。</p><h4 style="text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fvirtualization%2Fmicrodroid" target="_blank"><strong>Microdroid</strong></a></h4><p style="text-align:start">Microdroid 是一个经过精简的 Android 操作系统软件包，可作为启动虚拟机（VM）的模板。它为开发人员在虚拟机中构建和运行工作负载提供了熟悉的环境。Microdroid 使用熟悉的 Android 工具和库，如 Bionic、Binder IPC 和 keystore 支持。</p><h4 style="text-align:start"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsource.android.com%2Fdocs%2Fcore%2Fvirtualization%2Fvirtualization-service" target="_blank"><strong>虚拟化服务</strong></a></h4><p style="text-align:start">VirtualizationService 管理所有客户虚拟机（无论是否隔离）。它主要通过管理 crosvm 实例来实现。它还公开了 AIDL API，系统服务或特权应用程序可使用该 API 启动、监控和停止虚拟机。</p><h4 style="text-align:start"><strong>RpcBinder</strong></h4><p style="text-align:start">RpcBinder 是为 Android 界面定义语言（AIDL）开发的全新后端。RpcBinder 可使用现有的 binder 线协议与虚拟机进行通信。这意味着：</p><ol><li><p>开发人员可以使用他们已经熟悉的语言和基础架构（AIDL）编写虚拟机接口。</p></li><li><p>只需继续使用现有的 AIDL 接口，即使绑定端点转移到虚拟机中也是如此。</p></li></ol><h3 style="text-align:start"><strong>Android 14 有哪些新功能？</strong></h3><p style="text-align:start">安卓 14 不仅使 AVF 可以在更多设备上使用，还提供了一个新的工具包，使用户可以使用 AVF 及其组件构建更多内容：</p><ul><li><p><strong>用于 AVF 的安卓系统应用程序接口</strong>&nbsp;</p></li></ul><blockquote><p>特权应用程序现在可以使用虚拟机来执行需要隔离的关键工作负载；</p></blockquote><ul><li><p><strong>Hypervisor DevEx 工具包</strong>&nbsp;</p></li></ul><blockquote><p>添加了跟踪功能、改进的可调试性和监控功能，以提供洞察力并协助平台开发人员在隔离虚拟机内进行开发；</p></blockquote><ul><li><p><strong>Hypervisor 供应商模块</strong></p></li></ul><blockquote><p>通过供应商模块扩展，我们的合作伙伴可以定制谷歌的 pKVM，以满足他们的特定需求，实现差异化；</p></blockquote><ul><li><p><strong>改善系统健康</strong>&nbsp;</p></li></ul><blockquote><p>安卓 14 中，基于 microdroid 的虚拟机启动速度比安卓 13 快 2 倍，而内存使用量却只有安卓 13 的一半。</p></blockquote><p>AVF 框架的其它部分可让 Android 服务和应用程序轻松使用虚拟化。例如，使用 AIDL 作为传输层抽象虚拟机之间的通信，管理虚拟机生命周期或虚拟机的创建方式。</p><blockquote><p>原文链接：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid-developers.googleblog.com%2F2023%2F12%2Fvirtual-machines-as-core-android-primitive.html" target="_blank">https://android-developers.googleblog.com/2023/12/virtual-machines-as-core-android-primitive.html</a></p><p><em>Posted by Sandeep Patil – Principal Software Engineer, and Irene Ang – Product Manager</em></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Fri, 08 Dec 2023 03:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270066/virtual-machines-as-core-android-primitive</guid>
            <link>https://www.oschina.net/news/270066/virtual-machines-as-core-android-primitive</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
