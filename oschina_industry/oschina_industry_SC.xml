<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 17 Nov 2023 05:30:27 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Rust 语言官方规范的制定进展]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Rust 团队在几个月前接受了&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frust-lang.github.io%2Frfcs%2F3355-rust-spec.html" target="_blank">RFC 3355</a>&nbsp;<span style="color:#000000">的提议，决定开始制定 Rust 语言的官方规范。由 Eric（Rust Reference 的维护者）、Felix（Rust 语言团队）、Joel（Rust 基金会）和 Mara（RFC 的作者）来共同推动这项工作的进行。</span></p><p><span style="color:#000000">截至今日，Eric 四人代表规范团队<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.rust-lang.org%2Finside-rust%2F2023%2F11%2F15%2Fspec-vision.html" target="_blank">发文介绍了</a>这项工作的最新进展，以及后续的一些其他规划。</span></p><h4 style="text-align:start"><span><span><strong><span><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Editor</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></span></span></h4><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>第一步是填补&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frust-lang.github.io%2Frfcs%2F3355-rust-spec.html%23role-of-the-editor" target="_blank">RFC 中规定的</a>「editor」角色。规范的协调和编辑职责被特意委托给 Rust 基金会，以确保工作的连续性。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>由于没有面试到合适的人选，基金会选择考虑内部选择作为替代方案。作为其现有工作的一部分，该基金会的技术总监 Joel 表示愿意担任该职位的候选人。Eric、Felix 和 Mara 等也同意了这一提议，「因为他在行业标准和技术编辑方面拥有丰富的经验，并且与 Rust 项目关系密切」。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4 style="text-align:start"><strong style="color:#000000">规范团队（Specification Team）</strong></h4><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>由于相关工作不可能只由 editor 单人完成，因此还在围绕规范工作组建一个团队，即规范团队（Specification Team），作为语言团队的一个子团队。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>最初成员包括：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>Felix Klock (team lead)</li><li>Mara Bos (team lead)</li><li>Joel Marcey (team member, editor)</li><li>Eric Huss (team member)</li></ul><h4 style="text-align:start"><strong style="color:#000000">利益相关者</strong>（<span><span><strong><span><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Stakeholders</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></span></span>）</h4><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>将挑选并维护一份利益相关者名单，他们将担任顾问和审阅者。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>最初名单包括：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>Rust 语言团队全体成员</li><li>来自 types team 的一名或多名代表</li><li>operational semantics team 的一名或多名代表</li><li>来自 Ferrocene 的一名或多名代表（高可靠性/可用性，例如汽车行业。）</li><li>Formal Methods Research and Development 的一名或多名代表</li><li>Operating System Development 的一名或多名代表 (Rust for Linux; Microsoft)</li></ul><h4 style="text-align:start"><span><span><strong><span><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Authority and Approval</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></span></span></h4><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>虽然规范团队负责撰写和编辑规范，但 Rust 语言的定义权仍属于相关团队，如语&nbsp;language team 和 library API team。这些团队应在必要时让其他团队/子团队参与进来，例如提出问题、提名问题进行​​讨论以及请求 FCP 批准关键决策。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p style="text-align:start"><span style="color:#000000">为了让规范团队能够在不受审批流程限制的情况下生成内容并进行迭代，我们将在工作存储库中制定规范草案。在一些工具的帮助下，我们将公开跟踪哪些项目仍需要团队批准，以及哪些项目受到利益相关者的公开关注。</span></p><p style="text-align:start"><span style="color:#000000">我们将所有变更分类为次要变更或重大变更。较小的更改是对规范团队来说似乎没有争议或微不足道的项目。例如，语言团队已经通过 FCP 批准的更改、排版和语法修复、初衷明确的澄清，以及类似的令人兴奋的更改。重大变更是那些可能有问题、重要或有争议的变更。规范团队和相关权威团队的任何成员以及任何规范利益相关者都可以将更改标记为重大更改。对规范的重大更改必须经过通常的批准流程（例如语言 FCP）才能出现在规范的已发布（非草案）版本中。</span></p><p style="text-align:start"><span style="color:#000000">语言和规范团队应努力拥有至少一名共同成员（例如 Felix）充当联络人，以帮助确保我们对次要变更与重大变更的理解保持同步。</span></p></blockquote><h4 style="text-align:start"><span><span><strong><span><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>目标</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></span></span></h4><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>规范团队的目标是创建和维护 Rust 规范。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Rust 规范的目的是提供权威资源来确定哪些源文本是有效的 Rust 程序以及此类程序的行为方式。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>一个理想的规范既要：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>为当前和未来的 Rust 版本定义给定 Rust 程序的语义的规范边界</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li><li style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>提供与该规范实例相关的 Rust 版本特有的语义描述细节。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li></ul><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>特定于版本的详细信息的规定可以直接在规范中提供，也可以通过委托给相关 Rust 团队拥有的其他文档来间接提供。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4 style="text-align:start"><span><span><span><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>渐进式开发</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></h4><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>既要为当前和未来的 Rust 版本提供规范性约束，又要描述当前 Rust 版本的细节。因此该团队决定将通过迭代和渐进的方式最大限度地提高其工作价值。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p style="text-align:start"><span style="color:#000000">我们预计该规范的早期版本将重点关注提供当前 Rust 版本的详细描述。这样的规范可以从现有的工作成果（如 Ferrocene 规范）中衍生出来，因为该规范明确侧重于提供特定 Rust 版本的详细说明。对这些特定版本描述的反馈意见将帮助我们了解如何以最佳方式在规范中制定规范性约束。</span></p><p style="text-align:start"><span style="color:#000000">由于我们前面提到的对当前 Rust 版本的关注，规范的早期版本可能会有一些空白，其中规定的界限比必要的更加不精确。例如，规定「不安全的 Rust 代码可能会导致未定义的行为」没有提供有关如何编写定义良好的不安全代码的指导。即使存在这种不精确性，规定的界限仍然可以提供有用的高级保证（例如「安全的 Rust 不会导致未定义的行为」）。规范的未来版本会添加更多说明性细节（例如「不安全的 Rust 代码在以下条件下不会导致未定义的行为：……」），直到我们达到所需的精度级别。</span></p></blockquote><h4 style="text-align:start"><strong><span><span><span><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>范围</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></h4><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>规范应至少涵盖 Rust 语法和语义的以下领域某些部分可能与特定后端或目标实现技术（如 inline asm）有内在联系。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>Rust 的语法，通过&nbsp;Backus-Naur Form (BNF) 或 BNF&nbsp;的一些合理扩展来指定。</li><li><span style="background-color:#ffffff; color:#000000">Macro expansion</span><ul><li>Macro-by-example (<code>macro_rules</code>) transcription; Hygiene</li><li><code>cfg</code><span>&nbsp;</span>属性</li><li>Procedural macros; attributes 以及 derive</li></ul></li><li>路径和标识符解析 
  <ul><li>Modules</li></ul></li><li>静态语义 
  <ul><li>类型定义；类型表达式；布局</li><li>类型推断和类型检查；子类型化</li><li>生命周期和借用检查</li></ul></li><li>泛型；关联项解析和&nbsp;Trait solving</li><li>安全 Rust 的操作语义 
  <ul><li>绑定表格；匹配表达式；drop glue</li><li>值的移动和复制；借用</li><li>field projection; method dispatch 
    <ul><li>operator overloading</li></ul></li></ul></li><li>不安全 Rust 的操作语义 
  <ul><li>memory model</li><li>inline assembly</li></ul></li><li>Const evaluation</li><li>Crates 和 crate linkage</li></ul><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>此列表可随着时间的推移而扩展。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4 style="text-align:start"><span><span><strong><span><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Presentation</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></span></span></h4><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Rust 规范将是一个可公开访问的文档，类似于所有其他 Rust 文档（并具有相同的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frust-lang%2Frust%2Fblob%2Fmaster%2FLICENSE-MIT" target="_blank">许可</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frust-lang%2Frust%2Fblob%2Fmaster%2FLICENSE-APACHE" target="_blank">条款</a>）。文本将以英语编写，并且仅使用规范本身定义的技术术语或在免费在线词典中具有明确定义的技术术语。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>规范中的各个项目都可以被引用和命名：不仅可以在超链接中，而且在文本中（例如「[syntax.patterns.arm.5]」）。在可能的情况下，这些名称/项目引用应在不同版本的规范中持续存在。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>规范的迭代应包括突出显示版本之间差异的 renderings。（参见 Ada 参考手册等。）</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Rust 规范将以鼓励志愿者贡献的格式进行维护，即使规范团队预计必须对每个贡献进行重新授权，以保持规范的一致性。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>虽然完整性和正确性是首要任务，但团队将尽力使规范尽可能易于理解。理想情况下，任何 Rust 程序员都应该能够深入研究并找到他们可能遇到的任何语言问题的答案，而无需询问已经非常熟悉该文档的「language lawyer」。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4 style="text-align:start"><span><span><strong><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>发布节奏</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></span></span></h4><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Rust 发布将独立于规范审批流程进行。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>如果给定版本的规范尚未获得批准，则该版本将在没有相关规范的情况下发布。（不过，该团队可能会在后续提供与给定版本相关的规范。）</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>这是设计使然。规范工作不得为项目增加需要克服的新障碍，以履行其现有义务，例如 6 周的发布周期。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>团队愿景是最终能够达到自动交付更新规范的程度，并且能够按照项目的 6 周发布节奏完成。但是，从短期和中期来看，其希望能够自由地滞后于 6 周的发布节奏。当规范团队为以前未涉及的领域逐步添加新内容，或大幅缩小当前版本规范的规定范围时，滞后于 Rust 发布计划的能力可能会特别有用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>虽然规范开发过程不会阻止发布，但语言功能的更改应与规范的相关更新相结合。一旦开始发布与特定版本相关的规范，那么如果没有规范团队批准对当前草案规范的相应拉取请求，则对当前规范中记录的语言功能的更改就无法稳定。规范中未记录的语言功能的更改可以在不更新规范的情况下稳定下来，但需要规范团队成员确认相应的功能未记录。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>通过强制执行新功能在稳定之前必须成为规范的一部分的规则，有望消除规范与 Rust 版本之间潜在滞后的主要根源。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><h4 style="text-align:start"><span><span><strong><span><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>下一步</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></span></span></h4><ul><li>为团队制定定期会议时间表。</li><li>确定利益相关者名单。</li><li>制作第一个「demo product」，供利益相关者审查。</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 04:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266889/spec-vision-rust</guid>
            <link>https://www.oschina.net/news/266889/spec-vision-rust</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微软确认为 Windows 10 引入 AI 助手 Copilot]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/news/265760">与之前的传言相印证</a></u>，微软宣布计划在 Windows 10 版本 22H2 中添加 AI 助手 Copilot。Copilot 将包含在 Windows 10 家庭版和专业版中。该更新的发布日期尚未公布，预计在不久的将来发布。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2023%2F11%2F16%2F23963576%2Fmicrosoft-copilot-windows-10-ai-features-release-preview" target="_blank">在一份新闻稿中</a></u>，<strong>微软表示在向 Windows 11 用户提供 Copilot 时收到了"很好的反馈"</strong>。与之前不为 Windows 10 22H2 提供主要功能升级的计划不同，微软现在决定"进行额外投资，以确保每个人都能从他们的 Windows PC 中获得最大价值，包括 Windows 中的 Copilot（预览版）"。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-6116c383b7c3be2c7b4c9bf35cc44cda3ea.png" referrerpolicy="no-referrer"></p><p>值得注意的是，<strong>并非所有 Windows 10 电脑都能运行 Copilot</strong>。根据微软的要求，<strong>您的设备必须配备 720p 显示屏（或更高分辨率）和至少 4GB 内存</strong>。此外，某些 Windows 10 版本将无法使用 Copilot，至少暂时无法使用。</p><p>由组织管理的版本为 22H2 的 Windows 10 专业版设备将不包含在 Copilot 在 Windows 中的初始推广中。版本 22H2 的 Windows 10 企业版和教育版设备也不会被纳入 Copilot in Windows 的初始推广范围。</p><p>微软所使用的措辞提供了一种可能性，即在某些时候，Copilot 可能会被添加到 Windows 10 的这些版本中。不过，Windows 10 的支持终止日期保持不变。该操作系统的生命周期将于 2025 年 10 月 14 日结束。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e281fe6f97375c953a2fe93f6baebeb2533.png" referrerpolicy="no-referrer"></p><p>除了在不久的将来将 Copilot 引入 Windows 10 之外，微软还将添加一项新功能，让用户能够尽快使用 Copilot 以及其他可能的重要新功能和改进。微软将在"设置"的"Windows 更新"部分为"发布预览版"内部用户添加"一旦有最新更新，立即获取"切换选项。</p><p>微软补充说："这将在未来几个月内通过受控功能推出（CFR）的方式分阶段推出。"</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 03:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266876</guid>
            <link>https://www.oschina.net/news/266876</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Unity 6 将于 2024 年发布，下一个 LTS 版本]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Unity 公司在今天举办的 Unite 2023 上<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Funity%2Fstatus%2F1725080342636192251" target="_blank">宣布</a></u>，2024 年将发布重大版本更新&nbsp;<strong>Unity 6</strong>，并表示其为下一个长期支持版本 (LTS)。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a6955e1397b32b26e403a1c0cdd519dc6fa.png" referrerpolicy="no-referrer"></p><p>Unity 在大会上演示了全新的 Unity 6 引擎，并通过 Syncy Studios 采用 Unity 6 制作的《幻想王国（Fantasy Kingdom）》Demo 进行了<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fyoutu.be%2FyggoHVLd01c" target="_blank">演示</a></u></em>，强调 Unity 6 的性能与画面改进。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3fd8486e8d8b61d16fec201e834d5fd2ba3.png" referrerpolicy="no-referrer"></p><p><img height="1302" src="https://oscimg.oschina.net/oscnet/up-5d7463e58f86e8e5cae6592b2bfc92aa80c.png" width="2348" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-daf8fe34d603bc0c73addb3fda72e81707d.png" referrerpolicy="no-referrer"></p><p><img height="1316" src="https://oscimg.oschina.net/oscnet/up-220b5372a5f614527cfd3b4da88df5a3dc3.png" width="2360" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-9fa7c45bc268f01ef3b71f6aec5e2ae2bd2.png" referrerpolicy="no-referrer"></p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.unity.com%2Fnews%2Funite-2023-keynote-game-development-unity-6" target="_blank">Unity 公司称</a></u> Unity 6 将带来显著的性能增强、提升创建多人游戏的速度，以及对 XR 设备更深入的支持。此外还解锁了新渲染功能的支持，实现了更高水平的图形保真度。</p><ul><li>以惊人的性能提供先进的视觉效果</li><li>加速多人游戏的创建和规模化</li><li>利用 AI 工具探索新的创意可能性</li><li>通过下一代移动功能和创新的 VR 设备支持让玩家随时随地接触</li></ul><p>Untiy&nbsp;提到的 AI 工具为 Sentis，允许开发者在&nbsp;Unity&nbsp;运行时导入&nbsp;AI&nbsp;模型，从而创建基于&nbsp;AI&nbsp;的 NPC。Sentis&nbsp;的独特之处在于 AI 模型最终在用户设备上本地运行，不需要开发者额外配置云服务器。</p><p>Unity 6 还将带来对全新 WebGPU 图形后端的初步支持。从 Unity 6 开始，玩家将能够在网络上的任何位置运行 Unity 游戏，包括在原生应用程序内或浏览器内的 Web 视图中。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 02:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266869/unity-6-unite-2023</guid>
            <link>https://www.oschina.net/news/266869/unity-6-unite-2023</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[pyvideotrans —— 视频翻译和配音工具]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#1f2328">这是一个视频翻译工具，可将一种语言的视频翻译为另一种语言和配音的视频。 语音识别基于<span>&nbsp;</span></span><code>openai-whisper</code><span style="background-color:#ffffff; color:#1f2328"><span>&nbsp;</span>离线模型、文字翻译使用</span><code>google|baidu|chatGPT</code><span style="background-color:#ffffff; color:#1f2328">翻译接口，文字合成语音使用<span>&nbsp;</span></span><code>Microsoft Edge tts</code><span style="background-color:#ffffff; color:#1f2328">。</span></p><p><img height="407" src="https://static.oschina.net/uploads/space/2023/1107/143850_zTPQ_4252687.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:start"><strong>使用预编译版本方法</strong></p><ol start="0"><li><p>只可用于 win10 win11 系统 (编译版非最新，建议源码部署)</p></li><li><p>从 release 中下载最新版，解压，双击 sp.exe</p></li><li><p>原始视频目录：选择 mp4 视频；</p></li><li><p>输出视频目录：如果不选择，则默认生成在同目录下的<span>&nbsp;</span><code>_video_out</code></p></li><li><p>选择翻译：可选 google、百度、chatGPT，后两者需要点击「设置翻译 key」，设置相应信息</p></li><li><p>网络代理地址：如果你所在地区无法直接访问 google，需要在软件界面，网络代理，中设置代理，比如若使用 v2ray ，则填写<span>&nbsp;</span><code>http://127.0.0.1:10809</code>,若 clash，则填写<span>&nbsp;</span><code>http://127.0.0.1:7890</code>. 如果你修改了默认端口或使用的其他代理软件，则按需填写</p></li><li><p>视频原始语言：选择待翻译视频里的语言种类</p></li><li><p>翻译目标语言：选择希望翻译到的语言种类</p></li><li><p>选择配音：选择翻译目标语言后，可从配音选项中，选择配音角色；</p><p>硬字幕: 是指始终显示字幕，不可隐藏，如果希望网页中播放时也有字幕，请选择硬字幕嵌入</p><p>软字幕: 如果播放器支持字幕管理，可显示或者隐藏字幕，该方式网页中播放时不会显示字幕，某些国产播放器可能不支持,需要将生成的视频同名 srt 文件和视频放在一个目录下才会显示</p><p><strong>不能「既不嵌入字幕又不选择配音角色」</strong></p></li><li><p>文字识别模型: 选择 base/small/medium/large, 识别效果越来越好，但识别速度越来越慢，第一次将需要下载模型，默认 base,可以预先单独下载模型后，放到<span>&nbsp;</span><code>当前软件目录/models</code>目录下.</p><p><strong>模型单独下载地址</strong></p><p><a href="https://openaipublic.azureedge.net/main/whisper/models/65147644a518d12f04e32d6f3b26facc3f8dd46e5390956a9424a650c0ce22b9/tiny.pt">tiny 模型</a></p><p><a href="https://openaipublic.azureedge.net/main/whisper/models/ed3a0b6b1c0edf879ad9b11b1af5a0e6ab5db9205f891f668f8b0e6c6326e34e/base.pt">base 模型</a></p><p><a href="https://openaipublic.azureedge.net/main/whisper/models/9ecf779972d90ba49c06d968637d720dd632c55bbf19d441fb42bf17a411e794/small.pt">small 模型</a></p><p><a href="https://openaipublic.azureedge.net/main/whisper/models/345ae4da62f9b3d59415adc60127b97c714f32e89e936602e85993674d08dcb1/medium.pt">medium 模型</a></p><p><a href="https://openaipublic.azureedge.net/main/whisper/models/e4b87e7e0bf463eb8e6956e646f1e277e901512310def2c24bf0e11bd3c28e9a/large.pt">large 模型</a></p></li><li><p>配音语速：填写 -90 到+90 之间的数字，同样一句话在不同语言语音下，所需时间是不同的，因此配音后可能声画字幕不同步，可以调整此处语速，负数代表降速，正数代表加速播放。</p></li><li><p>自动加速: 如果翻译后的语音时长大于原时长，并且这里确认选中，那么将强制加速播放该片段，以缩小时长</p></li><li><p>静音片段: 填写 100 到 2000 的数字，代表毫秒，默认 500，即以大于等于 500ms 的静音片段为区间分割语音</p></li><li><p>点击，开始按钮，底部会显示当前进度和日志，右侧文本框内显示字幕</p></li></ol><blockquote><p>原始视频统一使用 mp4 格式，处理速度快，网络兼容性好</p><p>采用软合成字幕：字幕作为单独文件嵌入视频，可再次提取出，如果播放器支持，可在播放器字幕管理中启用或禁用字幕；</p><p>默认会在，原始视频目录，下生成同名的字幕文件，视频名.srt</p><p>对于无法识别的语音将直接复制原语音</p></blockquote></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 02:25:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/pyvideotrans</guid>
            <link>https://www.oschina.net/p/pyvideotrans</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 基于一致性缓存的分布式事务应用框架 Zeze]]>
            </title>
            <description>
                <![CDATA[<p>What Is Zeze?</p><p>Zeze 是一个基于一致性缓存的分布式事务应用框架，详见 doc/zeze.docx</p>]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 02:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/e2wugui/zeze</guid>
            <link>https://gitee.com/e2wugui/zeze</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 视觉 BEV 基本原理和方案解析]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>BEV(Bird’s-Eye-View) 是一种鸟瞰视图的传感器数据表示方法，它的相关技术在自动驾驶领域已经成了「标配」，纷纷在新能源汽车、芯片设计等行业相继量产落地。BEV 同样在高德多个业务场景使用，例如：<strong>高精地图地面要素识别</strong>、<strong>车道线拓扑构建</strong>、<strong>车端融合定位</strong>中都扮演了重要角色。如图 1‑1 所示：</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-6877926e4fd053ef08b19049d51767f8_1440w.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center">图 1‑1 BEV 在高德应用场景（仅列举部分）a) 高精底图 b) 地面要素识别 c) 车道线拓扑构建[1] d) 车端融合定位 (BEV 特征和底图匹配)[2]</p><p>本文分享的内容主要包括两个部分：视觉 BEV 基本原理、方案解析。</p><p><strong>1.BEV 基础</strong></p><p><strong>1.1.引言</strong></p><p>如图 1‑2 所示，BEV 具有如下优势：</p><p><strong>1) BEV 视图尺度变化小</strong>。在 PV 空间（即透视图，类似通常行车记录仪所采集的车辆前视图）中，物体近大远小，物体的大小和类别、远近都有关，而在 BEV 空间中，物体的大小只和类别有关；</p><p><strong>2) BEV 空间是决策友好空间</strong>。BEV 空间更接近 3D 真实空间的平面空间，而 PV 空间是真实物理世界在透视投影下的视图，以图 1‑2 的车道线举例，在真实世界中平行的两条车道线，在 BEV 空间下还是平行的，在 PV 空间却是相交的。相比之下，BEV 空间下的信息能更方便地被下游规控模块理解和使用。</p><p>本章将介绍 BEV 基础知识。首先介绍 BEV 的核心**「视角转换模块」的基本原理**，包括 2D-&gt;3D 和 3D-&gt;2D 两种路线，然后介绍 BEV 使用的<strong>魔法「可形变模块」</strong>，最后介绍<strong>BEV 方案中常用的损失函数</strong>。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-a9e4e534bb87131577673960410b5677_1440w.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center">图 1‑2 BEV 空间和 PV 空间的图像可视化，a) BEV 空间 b) PV 空间</p><p><strong>1.2.视角转换</strong></p><p>如 1.1 所述，在 BEV 空间下进行数据处理和操作具有尺度变化小、决策友好的优势，但原始的图像数据是在 PV 空间下的，如何将 PV 空间的数据转换到 BEV 空间或者是 3D 空间（有 3D 空间下的数据，将其拍扁就能转到 BEV 空间）呢？这就是视角转换模块要干的事。</p><p><strong>1.2.1. 2D-&gt;3D 转换模块</strong></p><p>2D-&gt;3D 转换模块基本思想是从 2D 像素或者特征出发去找 3D 空间下的对应表示，类似深度估计。下面介绍主流的 2D-&gt;3D 转换方法。</p><p>LSS(Lift-Splat-and-Shot)[3]是主流的 2D-&gt;3D 转换方法，如图 1‑3 所示，Lift 指对各相机的图像显式地估计特征点的深度分布，得到包含图像特征的视锥（点云）；Splat——结合相机内外参把所有相机的视锥（点云）分配到 BEV 空间的网格中，对每个格子中的多个视锥点进行 pooling 计算，形成 BEV 特征图；Shoot——用 task head 处理 BEV 特征图，输出感知结果。最后将 C 维的特征和 D 维的深度分布做外积，得到每个深度下的特征，深度概率越大，对应特征响应就越强。</p><p style="text-align:center"><img alt="" src="https://pica.zhimg.com/80/v2-43d4c71faf7a138576f6ba06458e22aa_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 1‑3 LSS 示意，每个特征点生成系列离散深度点，再为深度点生成特征[3]</p><p>Pseudo-LiDAR 是另一种 2D-&gt;3D 转换方法，如图 1‑4 所示，相比 LSS 为特征点预测一系列离散深度，Pseudo-LiDAR 直接预测深度图，每个像素都有且仅有一个深度。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-53fd09fd23b24641939a1b729c035932_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 1‑4 Pseudo-LiDAR 示意，预测深度图，根据原始图像和深度图映射至 3D 空间[4]</p><p><strong>1.2.2. 3D-&gt;2D 转换模块</strong></p><p>3D-&gt;2D 转换模块基本思想是根据 3D 点查找对应的 2D 特征，类似 3D 空间投影到 PV 空间。下面介绍主流的 3D-&gt;2D 转换方法。</p><p>如图 1‑5 所示，将 3D 参考点根据成像原理投影到 PV 空间获取对应图像特征的方式可以认为是显式映射，这里的参考点可以使用预设的 BEV 空间的参考点，也可以使用网络生成。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-cc01c8996b31566d84f9db31ce62143e_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 1‑5 显式映射[5]</p><p>相比显式映射，隐式映射不再通过投影映射，而是让网络自己学特征和 3D 座标的映射。如图 1‑6 所示，它先生成视锥空间下的一系列点，再转换到 3D 空间下，然后将提取的图像特征和 3D 点传入 encoder，encoder 处理后输出的就是带有 3D 座标信息的特征。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-015461e8177d0ce576c5768410dcb80b_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 1‑6 隐式映射[6]</p><p><strong>1.3. 可形变模块</strong></p><p>要介绍的可形变模块有两种，<strong>可形变卷积</strong>和<strong>可形变注意力</strong>，可形变模块的作用更容易通过可形变卷积理解，所以先介绍可形变卷积。</p><p>可形变卷积是在卷积的基础上添加 offset 得到的，如图 1‑7 最左边的 a) 所示，普通卷积通过人工设计的 pattern 整合 pattern 内采样点的信息，其 pattern 设计好后就是固定的，可形变卷积，如图 1‑7 b) 所示，可以计算出每个采样点的 offset，采样点+offset 才是真实的采样点，使得卷积的 pattern 形式更加灵活，且一定程度上可学习。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-25ee3e549c4c201ec23b27b2927ed7f0_1440w.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center">图 1‑7 可形变卷积示意，a) 普通卷积 b) 可形变卷积[7]</p><p>如图 1‑8 所示，注意力机制需要通过 Q (query) 找到 K (key)，获得 K 的信息，这个过程也存在可变形的操作空间，让网络自己学习参考点的偏移量。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-ae9b641901f4aabf7cd99d5cbbea4c9d_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 1‑8 可变形注意力示意[8]</p><p><strong>1.4. 损失函数</strong></p><p>损失函数大部分与任务相关，且大同小异，这里集中介绍下后续方案解析需要用到的一些共性的损失函数。</p><p>Box Loss (包围盒损失函数) 是目标检测常用的几何损失函数，常采用 L1 Loss 的形式：</p><p><img alt="" src="https://pic1.zhimg.com/80/v2-7cd755ebefb004c45aa1d2f8ed391d17_1440w.jpg" referrerpolicy="no-referrer"></p><p>Focal Loss 是交叉熵损失函数的拓展，常用于分类问题。普通交叉熵损失函数在正负样本不均衡时表现不佳，因此引入平衡交叉熵。另外普通交叉熵损失函数对于难例无法重点学习，因此引入难例聚焦。最终形式为：</p><p><img alt="" src="https://picx.zhimg.com/80/v2-7b684f60a21cd467d25d4dc4a869d7d9_1440w.jpg" referrerpolicy="no-referrer"></p><p><strong>2. 视觉 BEV 方案解析</strong></p><p><strong>2.1. 引言</strong></p><p>第一章的内容为第二章的方案解析打下知识基础，接下来第二章主要解析具有代表性的视觉 BEV 方案，主要根据视角转换模块的类型对方案进行分类，首先介绍 2D-&gt;3D 的代表性方案，然后介绍 3D-&gt;2D 的代表性方案。</p><p><strong>2.2. 2D-&gt;3D 代表性方案解析</strong></p><p>2D-&gt;3D 的代表性 BEV 方案有<strong>BEVDet</strong>和<strong>BEVDepth</strong>，下面我们逐一介绍。</p><p><strong>2.2.1. BEVDet</strong></p><p>3D 目标检测跟踪由基于 PV 空间的方法主导，BEV 语义分割跟踪由基于 BEV 空间的方法主导，那么 PV 空间和 BEV 空间哪个更适合做自动驾驶感知呢？是否可以在同一的框架下做这些任务？作者为了回答这两个问题，提出了如图 2‑1 所示的基于 BEV 空间的 3D 目标检测框架，BEVDet。BEVDet 主要由四个部分组成，分别为图像特征编码器，视角转换模块，BEV 特征编码器，检测头。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-1e60694f26d5751b2879bb3b208d9895_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 2‑1 BEVDet 框架[9]</p><p>图像特征编码器 (Image-view Encoder) 使用 2D Backbone 网络，如 ResNet、SwinTransformer 等，对输入的多视角图像做多尺度特征提取，得到多尺度特征。</p><p>视角转换模块 (View Transformer) 对输入的多视角图像特征使用 LSS 进行离散深度分布预测，获得 3D 视锥特征。</p><p>3D 视锥特征经过 pooling 操作拍扁到 BEV 空间，BEV 特征编码器 (BEV Encoder) 对 BEV 空间下的特征做多尺度特征提取，得到 BEV 特征。</p><p>最后送入检测头进行 3D 目标检测，分类监督使用的损失函数为 Focal loss，包围盒监督使用的损失函数为 L1 loss。</p><p><strong>2.2.2. BEVDepth</strong></p><p>作者实验发现 LSS 估计的深度替换成随机值影响不大，而采用真值深度对指标提升很大，因此得出 LSS 估计深度不准的结论，如图 2‑2 所示，在没有明确的深度监督的情况下，很难输出准确，泛化性强的深度感知结果，要想获得更好的检测结果，需要更准的深度，因此引入深度监督训练深度子网络。</p><p style="text-align:center"><img alt="" src="https://pica.zhimg.com/80/v2-81044f858876fb86f021267da764c5b7_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 2‑2 LSS 的深度预测结果和 BEVDepth 的深度预测结果的对比[10]</p><p>图 2‑3 是 BEVDepth 的框架，也能大致分为图像特征编码器，视角转换模块，BEV 特征编码器，检测头四个部分。图像特征编码模块大同小异，后续不再展开说明。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-a4ad33f6e9c360247e91b77932b374e5_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 2‑3 BEVDepth 框架[10]</p><p>视角转换模块的核心是深度估计，深度估计网络 DepthNet 的框架如图 2‑4 所示，首先使用 MLP 对相机内参进行特征化，然后用 SE (Squeeze-and-Extraction) 对图像特征进行通道加权，然后经过 3 个残差块以及可形变卷积，得到深度。深度再与图像特征进行外积，得到 3D 视锥特征。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-fa606fad900b85501db561a22819eef8_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 2‑4 深度估计网络框架[10]</p><p>相机和用于监督的点云之间的外参可能不准，内参也可能不准，都会导致深度估计有偏，因此 BEV 特征编码器引入深度修正对 3D 视锥特征的深度进行修正，然后进行高效体素池化获得 BEV 特征。</p><p>检测头所使用的损失函数和 BEVDet 是一致的，不做赘述。深度监督使用的损失函数为二分类交叉熵。</p><p><strong>2.3. 3D-&gt;2D 代表性方案解析</strong></p><p>前面介绍的 2D-&gt;3D 的方案始终绕不过深度估计，深度估计难免会引入误差，换个思路，先有 3D 点，再根据 3D 点找 2D 特征的方式无需进行深度估计，避免了这部分误差。3D-&gt;2D 的代表性方案有 Detr3D、BEVFormer 和 PETR。</p><p><strong>2.3.1. Detr3D</strong></p><p>如图 2‑5 所示，Detr3D 是 Detr 在 3D 目标检测的扩展，也是使用 query 进行特征获取，然后进行检测。Detr3D 的图像特征编码器大同小异，不再赘述。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-aecefc46ac607f6b9cfe9a8c72d878cb_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 2‑5 Detr3D 框架[5]</p><p>特征转换模块首先使用 object query 生成 3D 参考点，将参考点投影到 PV 空间获取图像特征，获取到的图像特征能进一步优化物体的 3D 表征，得到物体的 3D 特征。</p><p>将特征送入检测头进行目标检测，可以得到一系列的检测结果。普遍地，大家会用 NMS 等后处理方式获得最终用于 Loss 计算的检测结果，如图 2‑6 所示，Detr3D 继承了 Detr 的做法，采用双边图匹配获得与真值一一对应的检测结果。损失函数与前面所述并未本质差异，不做赘述了。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-ecb60b683e331a3662bddef87ba2deed_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 2‑6 双边图匹配获得与真值一一对应的检测结果[11]</p><p><strong>2.3.2. BEVFormer</strong></p><p>行车过程有天然的时序特点，当前帧看到的车道线，在后续几帧大概率也是存在且可见的，如何利用这个时序特点是前述方案没有考虑的。BEVFormer 引入时序信息进一步增强 BEV 的检测能力。BEVFormer 的图像特征编码模块和前述大同小异，不做赘述。</p><p>BEVFormer 的核心是中间的 BEV 特征编码模块，BEV 特征编码模块的核心是时序自注意力 (Temporal Self-Attention) 和空间交叉注意力 (Spatial Cross-Attention)，时序注意力是为了利用历史帧 BEV 特征增强当前帧 BEV 特征，空间交叉注意力则是为了从图像特征获取信息。</p><p style="text-align:center"><img alt="" src="https://pica.zhimg.com/80/v2-f3bbe02646e521461ad36b8e2d4e159f_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 2‑7 BEVFormer 框架[12]</p><p>具体地，BEVFormer 的时序自注意力首先利用车辆运动信息将当前帧 BEV 特征和历史帧 BEV 特征进行对齐，然后再使用自注意力融合两者信息，由于车辆运动信息可能不准，不同时刻周围的可利用信息分布也不一致，所以具体使用的是图 2‑8 所示的可变形注意力机制。</p><p style="text-align:center"><img alt="" src="https://pica.zhimg.com/80/v2-4f86254bec875df7b4c8b27b3c7d1484_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 2‑8 时序可变形自注意力[12]</p><p>BEVFormer 的空间交叉注意力首先为每个格子在 Z 方向上采样 4 个值，得到一个格子上的 4 个参考点，然后与图像特征进行交叉注意力，获得图像特征。如图 2‑9 所示，这里的交叉注意力也采用可变形注意力机制。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-b65c4f416dedc9b27608bc42b4d8f0b2_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 2‑9 空间可变形交叉注意力[12]</p><p>损失函数的计算和 Detr3D 一致，不再赘述。</p><p><strong>2.3.3. PETR</strong></p><p>3D-&gt;2D 的方案一般都需要将参考点投影到 PV 空间，再取图像特征，PETR 避免了复杂的 3D-&gt;2D 转换及特征采样，直接让网络自己学习 2D-3D 的映射。PETR 的框架如图 2‑10 所示，包括图像特征编码器、3D 座标生成器、3D 特征编码器 (3D Position Encoder)、3D 特征解码器和检测头。图像特征编码器大同小异，不再赘述。</p><p style="text-align:center"><img alt="" src="https://picx.zhimg.com/80/v2-3bd06c74ccb12b7e4de4e16d317b7cb0_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 2‑10 PETR 框架[6]</p><p>3D 座标生成器生成视锥空间的一系列 3D 点，具体地，首先将相机视锥空间离散成大小为的网格，网格中的每一点用表示。3D 空间中一个点用表示。通过相机内外参可以将相机视锥空间转换到 3D 空间中。最后再进行归一化。</p><p>2D 图像特征和 3D 座标一起送入到 3D 特征编码器中，2D 特征进行卷积通道降维，3D 座标进行位置编码，然后将处理后的 2D 特征和 3D 座标编码整合，最后特征展平。</p><p style="text-align:center"><img alt="" src="https://pic1.zhimg.com/80/v2-ec98be180482b7f680c1edfa0471e7e0_1440w.png" referrerpolicy="no-referrer"></p><p style="text-align:center">图 2‑11 3D 特征编码器[6]</p><p>3D 特征解码器先在 3D 空间生成一系列随机点，再通过 MLP 生成可学习的 query，query 在 3D 特征中取特征，最后使用检测头进行检测。损失函数与 Detr3D 大同小异，不再赘述。</p><p><strong>3. 总结展望</strong></p><p>本文从 BEV 的基础出发，介绍了视觉 BEV 具有代表性的方案。视觉 BEV 已经展现出强大的场景理解能力。但是还存在很多值得探索且有挑战的方向[13]：</p><p>深度估计是 BEV 的核心，LSS、Pseudo-LiDAR、激光蒸馏、立体视觉或运动恢复结构等都是有前景的方向。</p><p>如何融合传感器的信息也是至关重要的，使用 Transformer 的自注意力、交叉注意力融合不同模态的特征已经被证明是个可行的方向。多模态中 CLIP 的文本-图像对也是个很有启发的思路。</p><p>泛化性是深度学习亘古不变的话题和努力的方向，在一个设备（数据）上训练好的模型在另一个设备（数据）表现是否一样好。每个设备都要付出训练成本是让人难以接受的。如何将模型和设备解耦在未来一段时间都将是重要的研究方向。</p><p>大模型或者基础模型已经在不同领域上取得令人印象深刻的结果，并一举成为 SOTA。在 BEV 感知中如何利用大模型中丰富的知识，在更多的任务上取得更好的效果，这将会逐步引起人们的重视。</p><p><strong>4. 参考文献</strong></p><p>[1] Bencheng Liao, Shaoyu Chen, Xinggang Wang, et al. Maptr: Structured modeling and learning for online vectorized hd map construction[J]. arXiv preprint arXiv:2208.14437,2022,</p><p>[2] Yuzhe He, Shuang Liang, Xiaofei Rui, et al. EgoVM: Achieving Precise Ego-Localization using Lightweight Vectorized Maps[J]. arXiv preprint arXiv:2307.08991,2023,</p><p>[3] Jonah Philion and Sanja Fidler. Lift, splat, shoot: Encoding images from arbitrary camera rigs by implicitly unprojecting to 3d[A]. Springer: 194-210</p><p>[4] Yan Wang, Wei-Lun Chao, Divyansh Garg, et al. Pseudo-lidar from visual depth estimation: Bridging the gap in 3d object detection for autonomous driving[A]. 8445-8453</p><p>[5] Yue Wang, Vitor Campagnolo Guizilini, Tianyuan Zhang, et al. Detr3d: 3d object detection from multi-view images via 3d-to-2d queries[A]. PMLR: 180-191</p><p>[6] Yingfei Liu, Tiancai Wang, Xiangyu Zhang, et al. Petr: Position embedding transformation for multi-view 3d object detection[A]. Springer: 531-548</p><p>[7] Jifeng Dai, Haozhi Qi, Yuwen Xiong, et al. Deformable convolutional networks[A]. 764-773</p><p>[8] Xizhou Zhu, Weijie Su, Lewei Lu, et al. Deformable detr: Deformable transformers for end-to-end object detection[J]. arXiv preprint arXiv:2010.04159,2020,</p><p>[9] Junjie Huang, Guan Huang, Zheng Zhu, et al. Bevdet: High-performance multi-camera 3d object detection in bird-eye-view[J]. arXiv preprint arXiv:2112.11790,2021,</p><p>[10] Yinhao Li, Zheng Ge, Guanyi Yu, et al. BEVDepth: Acquisition of Reliable Depth for Multi-View 3D Object Detection[J]. Proceedings of the AAAI Conference on Artificial Intelligence,2023,37(2): 1477-1485</p><p>[11] Nicolas Carion, Francisco Massa, Gabriel Synnaeve, et al. End-to-end object detection with transformers[A].Springer: 213-229</p><p>[12] Zhiqi Li, Wenhai Wang, Hongyang Li, et al. Bevformer: Learning bird’s-eye-view representation from multi-camera images via spatiotemporal transformers[A].Springer: 1-18</p><p>[13] Hongyang Li, Chonghao Sima, Jifeng Dai, et al. Delving into the Devils of Bird's-eye-view Perception: A Review, Evaluation and Recipe[J]. arXiv preprint arXiv:2209.05324,2022,</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 02:16:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/amaptech/blog/10143491</guid>
            <link>https://my.oschina.net/amaptech/blog/10143491</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Dromara 社区新晋开源项目 - Akali(阿卡丽)，轻量化的热点&降级处理框架！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img height="383" src="https://oscimg.oschina.net/oscnet/up-be8fcabf525c0668386e7be6a812d46264e.png" width="900" referrerpolicy="no-referrer"></p><h2>前言</h2><p>Dromara 社区再添一个成员项目！</p><p>今天为大家介绍的是——Akali。</p><p>它轻量小巧，来无影去无踪，不足 500 行代码，却能解决高流量场景中主要的问题：热点处理和降级处理。</p><h2>介绍</h2><p>Akali（阿卡丽）是一个轻量级本地化热点检测/降级框架，适用于大流量场景，可轻松解决业务中超高流量的并发查询等场景。并且接入和使用极其简单，10 秒钟即可接入使用！</p><p>Akali 框架的理念就是小巧，实用，丝血团战，满血退场，所到之处，皆为虚无。</p><p>Gitee：<a href="https://gitee.com/dromara/Akali">https://gitee.com/dromara/Akali</a></p><p>Github：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbryan31%2FAkali" target="_blank">https://github.com/bryan31/Akali</a></p><p>官方网站：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fakali.yomahub.com%2F" target="_blank">https://akali.yomahub.com/</a></p><h2>使用</h2><p>引入依赖：</p><pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.yomahub&lt;/groupId&gt;
  &lt;artifactId&gt;akali&lt;/artifactId&gt;
  &lt;version&gt;1.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h2>对任意方法进行热点处理</h2><p>只需要加上<code>@AkaliHot</code>这个标注，任意方法均可以获得热点检测，并在热点期间用热点数据进行返回，在热点过后，又会自动调用原本业务逻辑。</p><p>举例：比如有一个商品查询的业务，传入 SkuCode，返回商品信息。当某个商品进行促销时，访问的量就会增加，但是对于相同的 SkuCode 而言，其短时间窗口内返回的 SkuInfo 是一致的，我们的目标是当某个商品 sku 被大量查询时，框架能够在短时间内把这个商品 sku 提为热点数据，并通过对其进行缓存返回来降低对下游业务的压力。而当热点值过后，框架又能够自动摘除这个热点值，使其按照原有方式进行查询。</p><p>其本质相当于实时的监测了热点，并对其热点数据做了一个短时间内的缓存。</p><p>以下示例代表了：当相同的 skuCode 在 5 秒内超过 50 次调用时，会自动把这个 skuCode 的值提为热点，并用最后一次的返回值直接返回。当调用低于 5 秒 50 次调用时，框架会自动的摘除掉这个热点。使其正常的调用你原有代码进行逻辑计算并返回。这一切都是自动的。</p><pre><code>@AkaliHot(grade = FlowGradeEnum.FLOW_GRADE_QPS, count = 50, duration = 5)
public SkuInfo getSkuInfo(String skuCode){
  //do your biz and return sku info
}
</code></pre><p>其中<code>grade</code>参数除了有以<code>QPS</code>作为维度统计，还有以<code>Thread</code>个数作为维度统计。比如：</p><pre><code>@AkaliHot(grade = FlowGradeEnum.FLOW_GRADE_THREAD, count = 50, duration = 5)
public SkuInfo getSkuInfo(String skuCode){
  //do your biz and return sku info
}
</code></pre><p>这就代表了，如果某个 skuCode 在 5 秒之内有超过 50 个线程正在运行，那么就提为热点，并用热点数据直接返回。</p><p>对开源项目比较熟悉的同学看到这肯定想到了京东的框架-<code>hotkey</code>，<code>Akali</code>不同于<code>hotkey</code>，完全是本地运行的，不依赖于服务端，而且接入比<code>hotkey</code> 方便多了。性能完全相当于<code>hotkey</code>。</p><h2>对任意方法进行降级</h2><p>只需要加上<code>@AkaliFallback</code>注解。任意方法均可获得降级功能。</p><p>举例：某一个方法需要调用外部的接口，但是外部的接口性能不佳，耗时高。当并发一高时，线程池就会吃满，线程池队列也会逐渐堆积从而导致超时，或者丢弃，严重时会拖垮整个系统。</p><p>这时，我们只要对这个方法加上<code>@AkaliFallback</code>标注，即可解决。</p><pre><code>@AkaliFallback(grade = FlowGradeEnum.FLOW_GRADE_THREAD, count = 100)
public String sayHi(String name){
  return "hi,"+name;
}

public String sayHiFallback(String name){
  return "fallback str";
}
</code></pre><p>以上注解表示了，当这个方法的同时运行的线程超过 100 个时，触发降级，降级会自动调用<code>原方法名+Fallback</code>方法名 (并且参数要一致)，当降级触发后会直接返回<code>fallback str</code>，当线程数小于 100 时，框架也会自动摘除降级，还是输出<code>hi,xxxx</code>。</p><p>如果你的类中没有定义 fallback 方法，那么触发降级时会报错，当然你可以在降级方法中去抛错，来让上游系统知道你这个方法已经达到了瓶颈。</p><h2>注意事项</h2><p>Akali 只针对于 Springboot，Spring 环境，并且所有标注了<code>@AkaliHot</code>或者<code>@AkaliFallback</code>的类一定得注册到 spring 上下文中。</p><p>Akali 在 springboot 中会自动扫描所有标注的类，您无需做任何配置，在 spring 中，你需要配置：</p><pre><code>&lt;bean class="com.yomahub.akali.strategy.FallbackStrategy"/&gt;
&lt;bean class="com.yomahub.akali.strategy.MethodHotspotStrategy"/&gt;
&lt;bean class="com.yomahub.akali.spring.AkaliScanner"/&gt;
</code></pre><h2>最后</h2><p>如果大家感兴趣的话，请在 Gitee 上为 Akali 点上小星星哦。</p><p>Gitee：<a href="https://gitee.com/dromara/Akali">https://gitee.com/dromara/Akali</a></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 16 Nov 2023 01:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266848</guid>
            <link>https://www.oschina.net/news/266848</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微软推出全新「Windows App」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">微软在&nbsp;Ignite 2023 上宣布推出一款适用于 iOS、iPadOS、Web 和 Windows 的全新「Windows App」，目前正以预览版形式提供。</span></p><p><span style="color:#000000">用户可以通过该 APP 连接 Windows 365、Azure 虚拟桌面、Microsoft Dev Box 或个人远程桌面 PC。在手机或 iPad 上，用户无需下载或安装任何内容即可启动 Windows 环境。</span></p><p><span style="color:#000000"><img alt="" height="309" src="https://oscimg.oschina.net/oscnet/up-6de517b3878e038efe903ec950a3f14d987.webp" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">新的 Windows APP 带来了多项新功能：如支持多显示器、自定义显示分辨率、动态显示缩放、网络摄像头、音频和打印机的设备重定向等。用户可以固定最喜欢的应用程序，以便快速访问，还可以在不同账户之间轻松切换。</span></p><p><span style="color:#000000">虽然微软官方表示该应用程序仅上架 iOS、Windows、macOS 以及网页端，但提供的屏幕截图显示 Android&nbsp;平板上也能运行该应用。或许 Android 版本将会在不久的未来推出。</span></p><p><span style="color:#000000">不过，该 Windows APP 仅面向微软企业用户提供，个人账户无法访问相关服务。但有迹象表明，微软计划通过 Windows 365 为普通消费者提供云 PC。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 09:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266787/microsoft-windows-app-launched-run-cloud-pc</guid>
            <link>https://www.oschina.net/news/266787/microsoft-windows-app-launched-run-cloud-pc</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[ClickHouse 联合创始人、前 Google 副总裁 Yury 到访杭州玖章算术公司，双方建立生态合作]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span><span style="color:#000000">10 月 31 日，ClickHouse 联合创始人 Yury 到访未来科技城，与玖章算术创始人叶正盛和国际总经理 Ni Demai 展开沟通与推进合作。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-3abad57e89ff8fcc5278d96ff167a2bf87d.jpg" width="1707" referrerpolicy="no-referrer"></p><p style="color:#999999; margin-left:0; margin-right:0; text-align:center">图片备注：Ni Demai(左),Yury(中),叶正盛 (右)</p></div><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">ClickHouse 是深受开发者青睐的实时分析型数据库，成立 2 年就发展成为基础软件领域的独角兽，玖章算术核心产品 NineData 则是中国数据库工具领域的佼佼者。通过本次沟通，</span><span style="color:#f04142">ClickHouse 将继续增加其在生态能力上的投入，引入玖章算术成为 ClickHouse 全球正式合作伙伴</span><span style="color:#000000">，NineData 将提供数据复制、SQL 开发等能力，帮助开发者更加便捷、稳定地使用 ClickHouse。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">ClickHouse 中国区负责人王楠（Tracy）、玖章算术首席产品经理蔡冬者参与了本次会议，双方深度交流了 NineData 帮助 ClikHouse 完成数据复制的实践场景，将在 ClickHouse 中国社区发展深度合作。</span></span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="1659" src="https://oscimg.oschina.net/oscnet/up-29fbbc98347ec5e04fcc19c903bdcbea0d0.jpg" width="2091" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">Yury 作为 ClickHouse 的联合创始人、产品和工程总裁，是前谷歌、Netflix 的副总裁。<span style="color:#f04142">本次代表 ClickHouse 与玖章算术 CEO 叶正盛进行沟通，旨在加强两家公司之间的合作，增强 ClickHouse 的生态能力建设，帮助开发者更好地使用 ClickHouse。</span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="1080" src="https://oscimg.oschina.net/oscnet/up-d6908642b538092775611c1383c849b5928.jpg" width="2301" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">叶正盛是玖章算术创始人，在数据库生态工具产品里有 20 年经验，是国内把数据库生态工具体系做成专业产品的第一人。后续，</span><span style="color:#f04142">NineData 将快速支持 ClickHouse 最新版本，适配 ClickHouse Cloud，同时会更大力度投入中国 ClickHouse 社区建设。</span></span></p><div><p style="text-align:center"><img alt="" height="1080" src="https://oscimg.oschina.net/oscnet/up-e0d4a2d815c5fc2bf9daf62ae54c45c901c.jpg" width="2301" referrerpolicy="no-referrer"></p><p style="color:#999999; margin-left:0; margin-right:0; text-align:center">玖章算术创始人叶正盛（中）</p></div><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">NineData 提供企业级 SQL 开发能力，包括数据库堡垒机、生产变更服务，以及细粒度权限管控、审计、敏感数据脱敏处理等功能。并集成了大模型 AI 技术，提供智能 SQL 编写、SQL 优化和数据库专业知识问答，能够帮助客户提高 DBA 与技术团队及 ISV 伙伴的合作效率。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">NineData 的数据复制能力可应用于多种场景，包括在线数据库到数据仓库实时同步、数据库国产化替换、数据上云、数据容灾等，支持 1000 公里数据实时同步，复制性能超过 10 万 TPS，领先于市场主流产品。</span></span></p><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">NineData 的创始团队由阿里云、华为、IBM 等公司资深数据库专家组成。NineData 支持 MySQL、Oracle、PostgreSQL、ClickHouse、Redis、MongoDB、Doris 等 60 种主流数据源。</span></span></p><div><p style="text-align:center"><img alt="" height="1332" src="https://oscimg.oschina.net/oscnet/up-7e72cd287ff75493e4b1730da64f74e22f5.png" width="2878" referrerpolicy="no-referrer"></p><p style="color:#999999; margin-left:0; margin-right:0; text-align:center">NineData 支持 60 种主流数据源</p></div><p style="margin-left:0; margin-right:0"><span><span style="color:#000000">目前，NineData 已经为上万开发者提供服务，在中国移动、沃尔沃、绿城集团等大型企业上线，与华为云、阿里云、腾讯云、百度云、移动云、AWS、Apache Doris、SelectDB 等平台建立了紧密合作关系。NineData 的目标是让企业各个数据源之间的数据自由流动，让数据管理与研发流程更安全、更高效。</span></span></p><p style="margin-left:0px; margin-right:0px"><span><strong><span style="color:#000000">结束语：</span></strong><span style="color:#000000"><span>&nbsp;</span>ClickHouse 与玖章算术 NineData 的合作将促进其生态系统的发展，NineData 将更好地支持 ClickHouse 数据库复制、SQL 开发等。这一合作将为中国的 ClickHouse 社区带来更多支持和创新，进一步推动社区发展，帮助开发者更好的使用 ClickHouse，发掘数据价值，推进企业业务发展。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 09:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266785</guid>
            <link>https://www.oschina.net/news/266785</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GitHub 报告：TypeScript 取代 Java 成为第三受欢迎语言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">GitHub 发布了 2023 年度&nbsp;Octoverse 开源状态报告。主要研究了围绕 AI、云和 Git 的开源活动如何改变开发人员体验，以及如何在开发者和企业中产生越来越大的影响。</span></p><p><span style="color:#000000">报告发现了三大趋势：</span></p><ul><li><span style="color:#000000"><strong>开发人员正在大量使用生成式 AI 进行构建。</strong>越来越多的开发人员尝试使用 OpenAI 和其他 AI 公司的基础模型，开源生成式 AI 项目甚至在 2023 年进入了按贡献者数量排名的十大最受欢迎的开源项目。几乎所有开发人员 (92%) 都在使用或尝试借助 AI 编码工具。</span></li><li><span style="color:#000000"><strong>开发人员正在大规模运行云原生应用程序。</strong>使用基于 Git 的基础设施即代码 (IaC) 工作流的声明式语言越来越多，云部署的标准化程度更高，开发人员使用 Dockerfile 和容器、IaC 以及其他云原生技术的速度也急剧加快。</span></li><li><span style="color:#000000"><strong>2023 年 first-time 开源贡献者数量最多。</strong>其中，有商业支持的开源项目依旧最受贡献者欢迎。但生成式 AI 项目在今年进入了 first-time 贡献者最受欢迎的的十大项目之列。GitHub 上的私人项目显着增长，同比增长 38%，占 GitHub 上所有活动的 80% 以上。</span></li></ul><p><span style="color:#000000"><strong>全球开发者社区</strong>继续增长。美国拥有 2020 万开发者，开发者人数在去年增长了 21%，仍然是全球最大的开发者社区。亚太地区、非洲、南美洲和欧洲的开发者社区规模逐年扩大，其中印度、巴西和日本处于领先地位。</span></p><p><span style="color:#000000">预计到 2027 年，印度将取代美国成为 GitHub 上最大的开发者社区。新加坡今年是亚太地区开发者人数增长最快的国家，并且是开发者占总人口的比例最高的第地区（全球范围内）。报告指出，由于日本在技术和初创企业方面的进一步投资，明年日本的开发者将有持续增长。</span></p><p><img alt="" height="281" src="https://oscimg.oschina.net/oscnet/up-ac720a0e760e91cc5b2eb3fbe5912621880.webp" width="500" referrerpolicy="no-referrer"></p><p><img height="356" src="https://oscimg.oschina.net/oscnet/up-80f62228356fcbdefb478e041a0eac39e37.png" width="400" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><strong>生成式 AI </strong>在 2023 年经历了爆发式增长，仅半年内涌现出的生成式 AI 项目数量就已达到了 2022 年全年的两倍之多。开发人员也开始更多地尝试使用 AI 模型。前几年，开发人员常使用 tensorflow/tensorflow、pytorch/pytorch 等机器学习库构建项目；现在则更多尝试使用 AI 模型和 LLM（如 ChatGPT API）。</span></p><p><img height="270" src="https://oscimg.oschina.net/oscnet/up-7496f60e2ee0f94240f5faf6341e5262a5b.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">报告分析了 GitHub 上排名前 20 位的开源生成式 AI 项目，发现其中一些顶级项目都是由个人所有。生成式 AI 项目中的个人贡献者正在全球范围内大幅飙升，同比增长幅度达到了 148%，而生成式 AI 项目总数也同比增长 248%。</span></p><p><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">美国、印度和日本在开发者社区中处于领先地位，</span><span style="background-color:#ffffff; color:#24292f">香港特别行政区</span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">、英国和巴西紧随其后。</span></p><p><img height="257" src="https://oscimg.oschina.net/oscnet/up-24b4f2b8554174e97591f4e9b11183c4b8e.png" width="500" referrerpolicy="no-referrer"></p><p><strong style="color:rgba(0, 0, 0, 0.9)">最流行的编程语言</strong></p><p><img height="144" src="https://oscimg.oschina.net/oscnet/up-3a0a14c95ce1e310f742e6ce36ad9af9795.png" width="500" referrerpolicy="no-referrer"></p><p>报告指出，<span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">自 2019 年云原生开发大规模增长以来，IaC 在开源领域持续增长。2023 年，Shell 和 Hashicorp 配置语言（HCL）再次成为开源项目中的顶级语言，</span><span style="background-color:#ffffff; color:#24292f">HCL 采用率同比增长 36%；「表明运维和 IaC 工作在开源领域越来越受到重视」。</span></p><p><img height="263" src="https://oscimg.oschina.net/oscnet/up-72dde2bf24c363d79ba454d8df65c964a2b.png" width="500" referrerpolicy="no-referrer"></p><ul style="list-style-type:disc; margin-left:0; margin-right:0"><li><span style="color:#000000">JavaScript 仍然是 GitHub 上最常用的语言，其次是 Python。</span></li><li><span style="color:#000000">TypeScript 越来越受欢迎，<span style="background-color:#ffffff">首次取代 Java 成为 GitHub 上 OSS 项目中第三大最受欢迎的语言，其用户群增长了 37%。</span></span></li><li><span style="color:#000000">用于数据分析和操作的流行语言和框架明显增加。T-SQL 和 TeX 等古老的语言在 2023 年均有所增长，凸显了数据科学家、数学家和分析师越来越多地使用开源平台和工具。「<span style="background-color:#ffffff">编程语言不再仅仅局限于传统软件开发领域</span>」。</span></li><li><span style="color:#000000"><span style="background-color:#ffffff">在 GitHub 上一些较新的项目中，Kotlin、Rust、Go 和 Lua 的采用出现了较大的增长。「Rust 和 Lua 都以内存安全和高效著称，而且都可用于系统和嵌入式系统编程，这也是它们增长的原因。而 Go 最近的增长则是由 Kubernetes 和 Prometheus 等云原生项目的推动。」</span></span></li></ul><p><img height="262" src="https://oscimg.oschina.net/oscnet/up-58e41eb95e2505a64d2a2a8a7b46fdf4ee6.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">其他一些发现还包括：</span></span></p><ul><li><span style="color:#000000"><span style="background-color:#ffffff">与 2022 年相比，2023 年开源代码开发人员合并的针对易受攻击软件包的自动 Dependabot 拉取请求增加了 60%</span></span></li><li><span style="color:#000000"><span style="background-color:#ffffff">2023 年，</span><span style="background-color:#ffffff">开发者</span><span style="background-color:#ffffff">为 GitHub 上的开源项目做出了 3.01 亿次贡献，这些项目既有像 Mastodon 这样的热门项目，也有像 Stable Diffusion 和 LangChain 这样的生成式 AI 项目。</span></span></li><li><span style="color:#000000"><span style="background-color:#ffffff">2023 年有 430 万个存储库使用了 Docker。Linux 发行版 NixOS/nixpkgs 在过去两年中一直位居开源项目贡献者榜首。</span></span></li></ul><p><span style="background-color:#ffffff; color:#333333">更多详情可</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.blog%2F2023-11-08-the-state-of-open-source-and-ai%2F" target="_blank">查看完整报告</a><span style="background-color:#ffffff; color:#333333">。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 07:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266757/2023-state-of-the-octoverse</guid>
            <link>https://www.oschina.net/news/266757/2023-state-of-the-octoverse</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[李开复再回应争议：受益于开源也贡献开源]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>针对旗下「零一万物」 开源的 Yi 大模型近日被质疑照搬 Llama 架构，只对两个张量（Tensor）名称做了修改的风波，李开复在朋友圈<span style="color:#030303">转发了「</span><a href="https://www.oschina.net/news/266597" target="news">零一万物对 Yi-34B 训练过程的说明</a><span style="color:#030303">」文章，并配文</span>回应称：</p><blockquote><p><span style="color:#030303">零一万物 Yi-34B 模型训练的说明也回应这两天大家对于模型架构的探讨。全球大模型架构一路从 GPT2--&gt;Gopher--&gt;Chinchilla--&gt;Llama2-&gt;Yi，行业逐渐形成大模型的通用标准（就像做一个手机 app 开发者不会去自创 iOS、Android 以外的全新基础架构）。01.AI 起步受益于开源，也贡献开源，从社区中虚心学习，我们会持续进步。</span></p></blockquote><p><img height="290" src="https://static.oschina.net/uploads/space/2023/1116/141708_SLoh_4252687.png" width="300" referrerpolicy="no-referrer"></p><p><strong>相关阅读：</strong></p><ul><li><a href="https://www.oschina.net/news/266377">李开复旗下 AI 公司 「零一万物」 开源的 Yi 大模型照搬 Llama 架构</a></li><li><a href="https://www.oschina.net/news/266525">「零一万物」 回应 Yi 开源大模型 「套壳」 Llama</a></li><li><p style="margin-left:0px; margin-right:0px; text-align:start"><a href="https://www.oschina.net/news/266597" target="_blank">零一万物对 Yi-34B 训练过程的说明</a></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 06:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266727</guid>
            <link>https://www.oschina.net/news/266727</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[.NET 8.0 中有哪些新的变化？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong>1 性能提升</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fperformance-improvements-in-aspnet-core-8%2F" target="_blank">.NET 8 在整个</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fdotnet-8-performance-improvements-in-dotnet-maui%2F" target="_blank">堆栈</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fthis-arm64-performance-in-dotnet-8%2F" target="_blank">中</a>带来了数千项性能<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fperformance-improvements-in-net-8%2F" target="_blank">改进</a> 。默认情况下会启用一种名为动态配置文件引导优化 (PGO) 的新代码生成器，它可以根据实际使用情况优化代码，并且可以将应用程序的性能提高高达 20%。现在支持的 AVX-512 指令集能够对 512 位数据向量执行并行操作，这意味着可以在更短的时间内处理更多的数据。原始类型（数字及其他类型）现在实现了新的可格式化和可解析接口，这使它们能够直接格式化和解析为 UTF-8，而无需任何转码开销。 <img src="https://img-blog.csdnimg.cn/img_convert/b91071a2632a5da242e53238fb844e52.png" alt="" referrerpolicy="no-referrer"></p><p><strong>2.NET Aspire</strong></p><p>.NET Aspire 是一个用于使用 .NET 构建弹性、可观察和可配置的云原生应用程序的堆栈。它包括一组针对云原生而增强的精选组件，默认情况下包括遥测、弹性、配置和运行状况检查。结合复杂而简单的本地开发人员体验，.NET Aspire 可以在第 1 天和第 100 天轻松发现、获取和配置云原生应用程序的基本依赖项。</p><p>点击这里查看.NET Aspire 的预览版本。 <img src="https://img-blog.csdnimg.cn/img_convert/ba664a021af354f1fc46c013578b8946.png" alt="" referrerpolicy="no-referrer"></p><p><strong>3.NET 8 容器增强功能 – 更安全、更紧凑、更高效</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fsecuring-containers-with-rootless%2F" target="_blank">使用 .NET 比以往更轻松、更安全地使用容器</a>打包应用程序。每个 .NET 映像都包含一个非 root 用户，从而通过单行配置启用更安全的容器。.NET SDK 工具无需 Dockerfile 即可发布容器映像，并且默认情况下是非 root 的。由于 .NET 基础映像更小，因此可以更快地部署容器化应用程序 - 包括我们映像的新实验变体，这些变体可为本机 AOT 提供真正最小的应用程序大小。选择使用新的 Chiseled Ubuntu 映像变体进行更多安全强化，以进一步减少攻击面。使用 Dockerfile 或 SDK 工具，为任何架构构建应用程序和容器映像。 <img src="https://img-blog.csdnimg.cn/img_convert/16b65a6962356cd1e24f164cf66ead3c.png" alt="" referrerpolicy="no-referrer"></p><p><strong>4 原生 AoT – 迈向更高密度可持续计算的旅程</strong></p><p>无需等待 JIT（即时）编译器在运行时编译代码。无需部署 JIT 编译器和 IL 代码。AOT 应用程序仅部署应用程序所需的代码。应用程序现在可以在不允许使用 JIT 编译器的受限环境中运行。 <img src="https://img-blog.csdnimg.cn/img_convert/5037b084ad2c4e26f6696f6c7b74712a.png" alt="" referrerpolicy="no-referrer"></p><p><strong>5 人工智能 – 将 AI 融入您的 .NET 应用程序</strong></p><p>生成式人工智能和大型语言模型正在改变人工智能领域，使开发人员能够在其应用程序中创建独特的人工智能体验。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgist.github.com%2FLadyNaggaga%2F5b0a708f2b945f5c8ca8ade4974665ff" target="_blank">.NET 8 可以</a>通过 .NET SDK 中一流的开箱即用 AI 功能以及与多种工具的无缝集成来轻松利用 AI。</p><p>.NET 8 为该，库带来了多项增强功能，以提高其与生成式 AI 工作负载的兼容性，例如集成 Tensor Primitives。随着人工智能应用程序的兴起，新的工具和 SDK 出现了。我们与众多内部和外部合作伙伴合作，例如 Azure OpenAI、Azure Cognitive Search、Milvus、Qdrant 和 Microsoft Teams，以确保 .NET 开发人员可以通过各自的 SDK 轻松访问各种 AI 模型、服务和平台。此外，开源语义内核 SDK 简化了这些 AI 组件与新的和现有应用程序的集成，以帮助您提供创新的用户体验。System.Numerics</p><p>现在提供各种示例和参考模板，展示模式和实践，以便开发人员轻松入门：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdotnet%2FeShop" target="_blank">客户聊天机器人</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAzure-Samples%2Fazure-search-openai-demo-csharp" target="_blank">检索增强生成</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fdemystifying-retrieval-augmented-generation-with-dotnet%2F" target="_blank">使用 Azure AI 服务开发应用程序</a><img src="https://img-blog.csdnimg.cn/img_convert/892b90ec5d84e0bf792f8dba707dce58.png" alt="" referrerpolicy="no-referrer"></li></ul><p><strong>6Blazor – 使用 .NET 构建全栈 Web 应用程序</strong></p><p>.NET 8 中的 Blazor 可以同时使用服务器和客户端来处理您的所有 Web UI 需求。这是全栈 Web UI！通过专注于优化页面加载时间、可扩展性和提升用户体验的多项新增强功能，开发人员现在可以在同一应用程序中使用 Blazor Server 和 Blazor WebAssembly，在运行时自动将用户从服务器转移到客户端。得益于新的基于「Jiterpreter」的运行时和新的内置组件，您的 .NET 代码在 WebAssembly 上的运行速度显着加快。作为增强.NET 8 中整体身份验证、授权和身份管理的一部分，Blazor 现在支持生成完整的基于 Blazor 的身份 UI。 <img src="https://img-blog.csdnimg.cn/img_convert/f0563b1ef218bb7b09130df55e5de700.png" alt="" referrerpolicy="no-referrer"></p><p><strong>7.NET MAUI – 提升性能、可靠性和开发人员体验</strong></p><p>.NET MAUI 提供单一项目系统和单一代码库来构建 WinUI、Mac Catalyst、iOS 和 Android 应用程序。本机 AOT（实验性）现在支持针对类似 iOS 的平台。适用于 .NET MAUI 的新 Visual Studio Code 扩展为您提供了开发跨平台 .NET 移动和桌面应用程序所需的工具。现在支持 Xcode 15 和 Android API 34，允许您瞄准最新版本的 iOS 和 Android。在性能、控件和 UI 元素以及特定于平台的行为方面进行了大量的质量改进，例如桌面交互添加了更好的点击处理、键盘侦听器等。 <img src="https://img-blog.csdnimg.cn/img_convert/130807a5e11b784d65aa556290afda0d.png" alt="" referrerpolicy="no-referrer"></p><p><strong>8 C# 12 功能 – 简化语法以提高开发人员的工作效率</strong></p><p>C# 12 让您的编码体验更加高效和愉快。现在，您可以使用简单而优雅的语法在任何类和结构中创建主构造函数。不再需要样板代码来初始化您的字段和属性。使用简洁且富有表现力的语法创建数组、跨度和其他集合类型时会感到高兴。对 lambda 表达式中的参数使用新的默认值。不再需要重载或空检查来处理可选参数。您甚至可以使用 usingalias 指令为任何类型添加别名，而不仅仅是命名类型！</p><p><strong>8.1 集合表达式</strong></p><p>在 C# 12 之前，创建集合需要针对不同场景使用不同的语法。初始化所需的与 or 不同的语法。以下是创建集合的几种方法：List&lt;int&gt;int[]Span&lt;int&gt;</p><pre><code class="language-C#">int[] x1 = new int[] { 1, 2, 3, 4 };
int[] x2 = Array.Empty&lt;int&gt;();
WriteByteArray(new[] { (byte)1, (byte)2, (byte)3 });
List&lt;int&gt; x4 = new() { 1, 2, 3, 4 };
Span&lt;DateTime&gt; dates = stackalloc DateTime[] { GetDate(0), GetDate(1) };
WriteByteSpan(stackalloc[] { (byte)1, (byte)2, (byte)3 });
</code></pre><p><strong>8.2 任何类或结构上的主构造函数</strong></p><p>C# 12 扩展了主构造函数以适用于所有类和结构，而不仅仅是记录。主构造函数允许在声明类时定义构造函数参数：</p><pre><code class="language-C#">public class BankAccount(string accountID, string owner)
{
    public string AccountID { get; } = accountID;
    public string Owner { get; } = owner;

    public override string ToString() =&gt; $"Account ID: {AccountID}, Owner: {Owner}";
}
</code></pre><p>主构造函数参数最常见的用途是：</p><ul><li>作为 base() 构造函数调用的参数。</li><li>初始化成员字段或属性。</li><li>在实例成员中引用构造函数参数。</li><li>删除依赖注入中的样板。</li></ul><p><strong>8.3 别名任意类型</strong></p><p>别名类型是从代码中删除复杂类型签名的便捷方法。using 从 C# 12 开始，其他类型在别名指令中有效。例如，这些别名在早期版本的 C# 中无效：</p><pre><code class="language-C#">using intArray = int[]; // Array types.
using Point = (int x, int y);  // Tuple type
using unsafe ArrayPtr = int*;  // Pointer type (requires "unsafe")
</code></pre><p><strong>8.4 默认 lambda 参数</strong></p><p>从 C# 12 开始，您可以在 lambda 表达式中声明默认参数：</p><pre><code class="language-C#">var IncrementBy = (int source, int increment = 1) =&gt; source + increment;

Console.WriteLine(IncrementBy(5)); // 6
Console.WriteLine(IncrementBy(5, 2)); // 7
</code></pre><p><strong>8.5 内联数组</strong></p><p>运行时团队和其他库作者使用内联数组来提高应用的性能。 内联数组使开发人员能够创建固定大小的 struct 类型数组。 具有内联缓冲区的结构应提供类似于不安全的固定大小缓冲区的性能特征。 你可能不会声明自己的内联数组，但当它们从运行时 API 作为 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.span-1" target="_blank">System.Span&lt;T&gt;</a> 或 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.readonlyspan-1" target="_blank">System.ReadOnlySpan&lt;T&gt;</a> 对象公开时，你将透明地使用这些数组。</p><pre><code class="language-C#">[System.Runtime.CompilerServices.InlineArray(10)]
public struct Buffer
{
    private int _element0;
}
</code></pre><p>它们的用法与任何其他数组类似：</p><pre><code class="language-C#">var buffer = new Buffer();
for (int i = 0; i &lt; 10; i++)
{
    buffer[i] = i;
}

foreach (var i in buffer)
{
    Console.WriteLine(i);
}
</code></pre><p>区别在于编译器可以利用有关内联数组的已知信息。 你可能会像使用任何其他数组一样使用内联数组。 有关如何声明内联数组的详细信息，请参阅有关 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fcsharp%2Flanguage-reference%2Fbuiltin-types%2Fstruct%23inline-arrays" target="_blank">struct</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fcsharp%2Flanguage-reference%2Fbuiltin-types%2Fstruct%23inline-arrays" target="_blank">类型</a>的语言参考。</p><p><strong>9.反射改进</strong></p><p>.NET 5 中引入了函数指针，但当时未添加对反射的相应支持。 对函数指针使用 typeof 或反射时（例如分别使用 typeof(delegate*&lt;void&gt;()) 或 FieldInfo.FieldType），返回了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.intptr" target="_blank">IntPtr</a>。 从 .NET 8 开始，将改为返回 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.type" target="_blank">System.Type</a> 对象。 此类型提供对函数指针元数据的访问，包括调用约定、返回类型和参数。</p><p>新功能目前仅在 CoreCLR 运行时和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.reflection.metadataloadcontext" target="_blank">MetadataLoadContext</a> 中实现。已将新的 API 添加到 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.type" target="_blank">System.Type</a>（例如 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.type.isfunctionpointer%23system-type-isfunctionpointer" target="_blank">IsFunctionPointer</a>）以及 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.reflection.propertyinfo" target="_blank">System.Reflection.PropertyInfo</a>、System.Reflection.FieldInfo 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.reflection.parameterinfo" target="_blank">System.Reflection.ParameterInfo</a>。 以下代码演示如何使用一些新 API 进行反射。</p><pre><code class="language-C#">// Sample class that contains a function pointer field.
public unsafe class UClass
{
    public delegate* unmanaged[Cdecl, SuppressGCTransition]&lt;in int, void&gt; _fp;
}

// ...

FieldInfo fieldInfo = typeof(UClass).GetField(nameof(UClass._fp));

// Obtain the function pointer type from a field.
Type fpType = fieldInfo.FieldType;

// New methods to determine if a type is a function pointer.
Console.WriteLine($"IsFunctionPointer: {fpType.IsFunctionPointer}");
Console.WriteLine($"IsUnmanagedFunctionPointer: {fpType.IsUnmanagedFunctionPointer}");

// New methods to obtain the return and parameter types.
Console.WriteLine($"Return type: {fpType.GetFunctionPointerReturnType()}");

foreach (Type parameterType in fpType.GetFunctionPointerParameterTypes())
{
    Console.WriteLine($"Parameter type: {parameterType}");
}

// Access to custom modifiers and calling conventions requires a "modified type".
Type modifiedType = fieldInfo.GetModifiedFieldType();

// A modified type forwards most members to its underlying type.
Type normalType = modifiedType.UnderlyingSystemType;

// New method to obtain the calling conventions.
foreach (Type callConv in modifiedType.GetFunctionPointerCallingConventions())
{
    Console.WriteLine($"Calling convention: {callConv}");
}

// New method to obtain the custom modifiers.
foreach (Type modreq in modifiedType.GetFunctionPointerParameterTypes()[0].GetRequiredCustomModifiers())
{
    Console.WriteLine($"Required modifier for first parameter: {modreq}");
}
</code></pre><p>输出：</p><pre><code class="language-C#">IsFunctionPointer: True
IsUnmanagedFunctionPointer: True
Return type: System.Void
Parameter type: System.Int32&amp;
Calling convention: System.Runtime.CompilerServices.CallConvSuppressGCTransition
Calling convention: System.Runtime.CompilerServices.CallConvCdecl
Required modifier for first parameter: System.Runtime.InteropServices.InAttribute
</code></pre><p><strong>10.配置绑定源生成器</strong></p><p>.NET 8 引入了一个源生成器，用于在 ASP.NET Core 中提供 AOT 和适合剪裁的配置。 该生成器是现有的基于反射的实现的替代方法。</p><p>源生成器探测 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fmicrosoft.extensions.options.configureoptions-1.configure%23microsoft-extensions-options-configureoptions-1-configure%28-0%29" target="_blank">Configure(TOptions)</a>、Bind 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fmicrosoft.extensions.configuration.configurationbinder.get" target="_blank">Get</a> 调用来从中检索类型信息。 在项目中启用生成器后，编译器将隐式选择生成的方法，而非预先存在的基于反射的框架实现。</p><p>无需更改源代码即可使用生成器。 AOT Web 应用中默认启用该生成器。 对于其他项目类型，源生成器默认关闭，但你可通过在项目文件中将 EnableConfigurationBindingGenerator 属性设置为 true 来选择使用它：</p><pre><code class="language-XML">&lt;PropertyGroup&gt;
    &lt;EnableConfigurationBindingGenerator&gt;true&lt;/EnableConfigurationBindingGenerator&gt;
&lt;/PropertyGroup&gt;
</code></pre><p>以下代码演示了调用绑定器的示例：</p><pre><code class="language-C#">using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

WebApplicationBuilder builder = WebApplication.CreateBuilder(args);
IConfigurationSection section = builder.Configuration.GetSection("MyOptions");

// !! Configure call - to be replaced with source-gen'd implementation
builder.Services.Configure&lt;MyOptions&gt;(section);

// !! Get call - to be replaced with source-gen'd implementation
MyOptions options0 = section.Get&lt;MyOptions&gt;();

// !! Bind call - to be replaced with source-gen'd implementation
MyOptions options1 = new MyOptions();
section.Bind(options1);

WebApplication app = builder.Build();
app.MapGet("/", () =&gt; "Hello World!");
app.Run();

public class MyOptions
{
    public int A { get; set; }
    public string S { get; set; }
    public byte[] Data { get; set; }
    public Dictionary&lt;string, string&gt; Values { get; set; }
    public List&lt;MyClass&gt; Values2 { get; set; }
}

public class MyClass
{
    public int SomethingElse { get; set; }
}
</code></pre><p><strong>11.针对 Android 应用的 AOT 编译</strong></p><p>为了减小应用大小，面向 Android 的 .NET 和 .NET MAUI 应用在发布模式下构建时使用分析的预先 (AOT) 编译模式。 与常规 AOT 编译相比，分析的 AOT 编译所影响的方法更少。 .NET 8 引入了 &lt;AndroidStripILAfterAOT&gt; 属性，你可使用它进一步对 Android 应用进行 AOT 编译，从而更进一步减少应用大小。</p><pre><code class="language-XML">&lt;PropertyGroup&gt;
  &lt;AndroidStripILAfterAOT&gt;true&lt;/AndroidStripILAfterAOT&gt;
&lt;/PropertyGroup&gt;
</code></pre><p>默认情况下，将 AndroidStripILAfterAOT 设置为 true 会替代默认的 AndroidEnableProfiledAot 设置，从而允许剪裁已 AOT 编译的（几乎）所有方法。 还可通过将两个属性都显式设置为 true 来结合使用分析的 AOT 和 IL 条带化：</p><pre><code class="language-XML">&lt;PropertyGroup&gt;
  &lt;AndroidStripILAfterAOT&gt;true&lt;/AndroidStripILAfterAOT&gt;
  &lt;AndroidEnableProfiledAot&gt;true&lt;/AndroidEnableProfiledAot&gt;
&lt;/PropertyGroup&gt;
</code></pre><p><strong>12.代码分析</strong></p><p>.NET 8 包括几个新的代码分析器和修复程序，可帮助验证是否正确且高效地使用 .NET 库 API。 下表总结了新的分析器。</p><table><thead><tr><th>规则 ID</th><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>CA1856</td><td>性能</td><td>未在参数上正确应用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.diagnostics.codeanalysis.constantexpectedattribute" target="_blank">ConstantExpectedAttribute</a> 属性时触发。</td></tr><tr><td>CA1857</td><td>性能</td><td>当参数使用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.diagnostics.codeanalysis.constantexpectedattribute" target="_blank">ConstantExpectedAttribute</a> 添加批注但提供的参数不是常量时触发。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1858" target="_blank">CA1858</a></td><td>性能</td><td>若要确定字符串是否以给定前缀开头，最好调用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.string.startswith" target="_blank">String.StartsWith</a>，而不是调用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.string.indexof" target="_blank">String.IndexOf</a>，然后将结果与零进行比较。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1859" target="_blank">CA1859</a></td><td>性能</td><td>此规则建议尽可能将特定局部变量、字段、属性、方法参数和方法返回类型从接口或抽象类型升级到具体类型。 使用具体类型可生成更高质量的代码。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1860" target="_blank">CA1860</a></td><td>性能</td><td>若要确定集合类型是否具有任何元素，最好使用 Length、Count 或 IsEmpty，而不是调用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.linq.enumerable.any" target="_blank">Enumerable.Any</a>。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1861" target="_blank">CA1861</a></td><td>性能</td><td>重复调用时，不会重复使用作为参数传递的常量数组，这意味着每次都会创建一个新数组。 若要提高性能，请考虑将数组提取到静态只读字段。</td></tr><tr><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Ffundamentals%2Fcode-analysis%2Fquality-rules%2Fca1865-ca1867" target="_blank">CA1865-CA1867</a></td><td>性能</td><td>对於单字符串，char 重载的性能更好。</td></tr><tr><td>CA2021</td><td>可靠性</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.linq.enumerable.cast%23system-linq-enumerable-cast-1%28system-collections-ienumerable%29" target="_blank">Enumerable.Cast(IEnumerable)</a> 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.linq.enumerable.oftype%23system-linq-enumerable-oftype-1%28system-collections-ienumerable%29" target="_blank">Enumerable.OfType(IEnumerable)</a> 需要兼容的类型才能正常运行。 泛型类型不支持扩大转换和用户定义的转换。</td></tr><tr><td>CA1510-CA1513</td><td>可维护性</td><td>在构造新的异常实例方面，引发帮助程序比 if 块更简单、更高效。 这四个分析器是为以下例外情况创建的：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.argumentnullexception" target="_blank">ArgumentNullException</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.argumentexception" target="_blank">ArgumentException</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.argumentoutofrangeexception" target="_blank">ArgumentOutOfRangeException</a> 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.objectdisposedexception" target="_blank">ObjectDisposedException</a>。</td></tr></tbody></table><p><strong>13.Core .NET 库</strong></p><p><strong>13.1 时间抽象</strong></p><p>新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.timeprovider" target="_blank">TimeProvider</a> 类和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.itimer" target="_blank">ITimer</a> 接口添加了时间抽象功能，让你可以在测试方案中模拟时间。 此外，还可以使用时间抽象，通过 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.tasks.task.delay" target="_blank">Task.Delay</a> 和 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.tasks.task.waitasync" target="_blank">Task.WaitAsync</a> 来模拟依赖于时间进度的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.threading.tasks.task" target="_blank">Task</a> 操作。 时间抽象支持以下基本时间操作：</p><ul><li>检索本地和 UTC 时间</li><li>获取用于测量性能的时间戳</li><li>创建计时器</li></ul><p>以下代码片段演示了一些使用情况示例。</p><pre><code class="language-C#">// Get system time.
DateTimeOffset utcNow = TimeProvider.System.GetUtcNow();
DateTimeOffset localNow = TimeProvider.System.GetLocalNow();

// Create a time provider that works with a
// time zone that's different than the local time zone.
private class ZonedTimeProvider : TimeProvider
{
    private TimeZoneInfo _zoneInfo;

    public ZonedTimeProvider(TimeZoneInfo zoneInfo) : base()
    {
        _zoneInfo = zoneInfo ?? TimeZoneInfo.Local;
    }

    public override TimeZoneInfo LocalTimeZone =&gt; _zoneInfo;

    public static TimeProvider FromLocalTimeZone(TimeZoneInfo zoneInfo) =&gt;
        new ZonedTimeProvider(zoneInfo);
}

// Create a timer using a time provider.
ITimer timer = timeProvider.CreateTimer(callBack, state, delay, Timeout.InfiniteTimeSpan);

// Measure a period using the system time provider.
long providerTimestamp1 = TimeProvider.System.GetTimestamp();
long providerTimestamp2 = TimeProvider.System.GetTimestamp();

var period = GetElapsedTime(providerTimestamp1, providerTimestamp2);
</code></pre><p><strong>13.2UTF8 改进</strong></p><p>如果要启用将类型的类似字符串的表示形式写出到目标范围，请在类型上实现新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.iutf8spanformattable" target="_blank">IUtf8SpanFormattable</a> 接口。 此新接口与 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.ispanformattable" target="_blank">ISpanFormattable</a> 密切相关，但面向 UTF8 和 Span&lt;byte&gt;，而不是 UTF16 和 Span&lt;char&gt;。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.iutf8spanformattable" target="_blank">IUtf8SpanFormattable</a> 已在所有基元类型（以及其他）上实现，无论是面向 string、Span&lt;char&gt; 还是 Span&lt;byte&gt;，其共享逻辑完全一致。 它完全支持所有格式（包括新的「B」二进制说明符）和所有区域性。 这意味着现在可以从 Byte、Complex、Char、DateOnly、DateTime、DateTimeOffset、Decimal、Double、Guid、Half、IPAddress、IPNetwork、Int16、Int32、Int64、Int128、IntPtr、NFloat、SByte、Single、Rune、TimeOnly、TimeSpan、UInt16、UInt32、UInt64、UInt128、UIntPtr 和 Version 直接格式化为 UTF8。</p><p>新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.text.unicode.utf8.trywrite" target="_blank">Utf8.TryWrite</a> 方法向现有 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.memoryextensions.trywrite" target="_blank">MemoryExtensions.TryWrite</a> 方法（基于 UTF16）提供基于 UTF8 的对应方法。 可以使用内插字符串语法将复杂表达式直接格式化为 UTF8 字节范围，例如：</p><pre><code class="language-C#">static bool FormatHexVersion(
    short major,
    short minor,
    short build,
    short revision,
    Span&lt;byte&gt; utf8Bytes,
    out int bytesWritten) =&gt;
    Utf8.TryWrite(
        utf8Bytes,
        CultureInfo.InvariantCulture,
        $"{major:X4}.{minor:X4}.{build:X4}.{revision:X4}",
        out bytesWritten);
</code></pre><p><strong>13.3 加密</strong></p><p>.NET 8 添加了对 SHA-3 哈希基元的支持。 （目前，具有 OpenSSL 1.1.1 或更高版本和 Windows 11 Build 25324 或更高版本的 Linux 支持 SHA-3。）可在其中使用 SHA-2 的 API 现在提供对 SHA-3 的补充。 对于哈希，这包括 SHA3_256、SHA3_384 和 SHA3_512；对于 HMAC，这包括 HMACSHA3_256、HMACSHA3_384 和 HMACSHA3_512；对于其中可配置算法的哈希，这包括 HashAlgorithmName.SHA3_256、HashAlgorithmName.SHA3_384 和 HashAlgorithmName.SHA3_512；对于 RSA OAEP 加密，这包括 RSAEncryptionPadding.OaepSHA3_256、RSAEncryptionPadding.OaepSHA3_384 和 RSAEncryptionPadding.OaepSHA3_512。</p><p>以下示例演示如何使用 API（包括 SHA3_256.IsSupported 属性）来确定平台是否支持 SHA-3。</p><pre><code class="language-C#">// Hashing example
if (SHA3_256.IsSupported)
{
    byte[] hash = SHA3_256.HashData(dataToHash);
}
else
{
    // ...
}

// Signing example
if (SHA3_256.IsSupported)
{
     using ECDsa ec = ECDsa.Create(ECCurve.NamedCurves.nistP256);
     byte[] signature = ec.SignData(dataToBeSigned, HashAlgorithmName.SHA3_256);
}
else
{
    // ...
}
</code></pre><p><strong>13.4 基于流的 ZipFile 方法</strong></p><p>.NET 8 包含 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.io.compression.zipfile.createfromdirectory" target="_blank">ZipFile.CreateFromDirectory</a> 的新重载，通过它可以收集目录中包含的所有文件并压缩这些文件，然后将生成的 zip 文件存储到提供的流中。 同样，通过新的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fapi%2Fsystem.io.compression.zipfile.extracttodirectory" target="_blank">ZipFile.ExtractToDirectory</a> 重载，可提供包含压缩文件的流，并将其内容提取到文件系统中。 下面是新的重载：</p><pre><code class="language-C#">namespace System.IO.Compression;

public static partial class ZipFile
{
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination);
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, CompressionLevel compressionLevel, bool includeBaseDirectory);
    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, CompressionLevel compressionLevel, bool includeBaseDirectory, Encoding? entryNameEncoding);

    public static void ExtractToDirectory(Stream source, string destinationDirectoryName) { }
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, bool overwriteFiles) { }
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, Encoding? entryNameEncoding) { }
    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, Encoding? entryNameEncoding, bool overwriteFiles) { }
}
</code></pre><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fdeveloper%2Factivereports" target="_blank">ActiveReports</a>是一款专注于 .NET 和 .NET Core 平台的报表控件。通过拖拽式报表设计器， 可以快速地设计 Excel 表格、Word 文档、图表、数据过滤、数据钻取、精准套打等类型报表， 全面满足 WinForm、ASP.NET、ASP.NET MVC、WPF 平台中各种报表的开发需要。 同时，通过丰富的 API 可以灵活的实现报表创建、加载和运行时的个性化自定义需求。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fsolutions%2Fwyn" target="_blank">Wyn 商业智能</a>是基于葡萄城 20 多年数据分析技术积累打造的全新一代嵌入式 BI 产品，旨在提供可与应用系统深度集成的数据分析功能，能够与企业现有业务系统 OA， ERP，MES，CRM 等应用系统深度集成，整合、分析多个业务系统的数据，自助式分析业务数据、实时分析决策，全面提升企业竞争力。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fdeveloper%2Fspreadstudio" target="_blank">Spread .NET</a>是一个功能、布局与 Excel 高度类似的 .NET 表格控件，可全面满足 WinForm、ASP.NET、XAML 和 WinRT 等平台下表格数据处理、数据可视化开发需求。Spread .NET 支持 462 种 Excel 公式，提供可嵌入系统的类 Excel 设计器和全面开放的 API，为 .NET 开发人员构建企业级表格应用程序提供更加专业的选择。</p><p>参考资料：</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flearn.microsoft.com%2Fzh-cn%2Fdotnet%2Fcore%2Fwhats-new%2Fdotnet-8%23networking" target="_blank">https://learn.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-8#networking</a></p><p><strong>扩展链接：</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fblogs%2Fexcel-io-spreadjs-blazor" target="_blank">如何使用 Blazor 框架在前端浏览器中导入/导出 Excel XLSX</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fblogs%2Fcreate-flow-chart-dotnet" target="_blank">如何在.NET 电子表格应用程序中创建流程图</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.grapecity.com.cn%2Fblogs%2Fsjs-realtime-data-refresh-part1" target="_blank">如何将实时数据显示在前端电子表格中</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 06:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/powertoolsteam/blog/10143465</guid>
            <link>https://my.oschina.net/powertoolsteam/blog/10143465</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米推出 Xiaomi Vela 快应用开发工具：Aiot-IDE]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米在今天举办的《2023&nbsp;小米 IoT 生态伙伴大会》上<a href="https://www.oschina.net/news/266688/xiaomi-vela-opensource">宣布</a>全面开源&nbsp;Xiaomi Vela。</p><p><img alt="" height="667" src="https://oscimg.oschina.net/oscnet/up-2e4d78299513d8dd8e48dd44f9f1c80cbea.png" width="500" referrerpolicy="no-referrer"></p><blockquote><p>Xiaomi Vela 是小米基于开源实时操作系统&nbsp;<strong><a href="https://www.oschina.net/p/nuttx">NuttX</a></strong>&nbsp;打造的物联网嵌入式软件平台，Vela 在各种物联网硬件平台上提供统一的软件服务，支持丰富的组件和易用的框架，打通碎片化的物联网应用场景。</p></blockquote><p>随 Xiaomi Vela 一同发布的还有 Aiot-IDE，官方称这是用于开发<strong> Xiaomi Vela 快应用</strong>的工具。据介绍，在小米智能穿戴 (Wearable) 设备上进行应用开发，此类应用统称为 <strong>Xiaomi Vela 快应用</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8c26527175a6a981cbd609b6b5fa67209b5.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-642ef5598b7a4dfdf8d448948a0b32a4fbc.png" referrerpolicy="no-referrer"></p><p>官方称 Aiot-IDE 基于 VS Code 进行开发，此外快应用的开发也类似网页开发。感兴趣可以下载安装体验：</p><ul><li><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fiot.mi.com%2Fvela%2Fquickapp%2Fzh%2Fcontent%2Fguide%2Fstart%2Fuse-ide.html" target="_blank">Aiot-IDE 下载地址</a></u>（该&nbsp;IDE 只支持在<code>Ubuntu 20.04</code>下进行 vela 项目的开发）</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 06:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266723</guid>
            <link>https://www.oschina.net/news/266723</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[开源中国将在年末推出大模型托管平台，大量人才招募中]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">Gitee 正在招募大量人才，欢迎加入。</span></span></p><p><img alt="" height="1348" src="https://static.oschina.net/uploads/space/2023/1116/151453_9FSP_3820517.jpg" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000"><span style="background-color:#ffffff">开源中国于 2023 年 6 月完成了&nbsp;</span><strong><span style="background-color:#ffffff">7.75 亿元&nbsp;</span></strong></span><span style="color:#000000">B+ 轮战略融资</span><span style="color:#000000">，公司创始团队重新成为实际控制人，经此股份重组企业成为完全中立平台。目前，开源中国员工共计 300 余人，其中研发团队占比 85% 以上。</span></p><p><span style="color:#000000"><strong><span style="background-color:#ffffff">开源中国将在年末推出大模型托管平台</span></strong><span style="background-color:#ffffff">，在 AI 时代为广大开发者和企业提供更高质量的服务。从软件应用到 AI 时代，开源中国将坚持帮助国内开发者和企业共同发展，创造健康的生态环境。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Gitee 是开源中国旗下，国内第一大企业级研发效能平台和全球第二大开源代码托管平台。经过 10 年发展，Gitee 已经拥有超过 1100 万开发者，托管超过 2500 万个代码仓库，服务 26 万家企业（含 1200 家中大型私有化部署企业）和 2000 多所高校，为他们提供优质的 DevOps 产品服务。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 03:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266707/gitee-hiring</guid>
            <link>https://www.oschina.net/news/266707/gitee-hiring</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[金山办公 WPS AI 开启公测]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>金山办公<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FcSKhX3tqmZgdw7EfTid_TA" target="_blank">宣布</a>旗下只能办公助手 WPS AI 开启公测，即日起面向全体用户陆续开放体验。WPS AI 是一款生成式人工智能应用，具备了大语言模型能力。它提供起草、改写、总结、润色等功能，可以提高办公创作效率。</p><p>用户可前往 <strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fai.wps.cn%2F" target="_blank">WPS AI 官网</a></strong>申请权益，并下载最新版 WPS PC 客户端限时体验文字/智能文档、表格/智能表格、PPT 演示组件的 AI 能力，安卓、iOS 和 Mac 端预计将于 11 月底陆续开放。</p><p><img alt="" height="376" src="https://oscimg.oschina.net/oscnet/up-9b4717aaa45d58081e02785ba28fc5dda23.png" width="300" referrerpolicy="no-referrer"></p><p><img alt="" height="354" src="https://oscimg.oschina.net/oscnet/up-fa29542a7d817329492fdc62024e16f7025.png" width="300" referrerpolicy="no-referrer"></p><p><img alt="" height="379" src="https://oscimg.oschina.net/oscnet/up-f98e75322933cd6c5d3e5239be36401148e.png" width="300" referrerpolicy="no-referrer"></p><p>更多详细功能介绍可查看 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhome.wps.cn%2Ftopic%2F10254" target="_blank">WPS AI 能力介绍（11 月最新版）</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 03:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266706</guid>
            <link>https://www.oschina.net/news/266706</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微软将 Bing Chat 更名为 Copilot in Bing]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">在 Ignite 2023 大会上，微软宣布将今年早些时候在 Bing 上推出的 AI 聊天机器人 Bing Chat 更名为 Copilot in Bing。与此同时，Bing Chat 的高端企业版（之前称为 Bing Chat Enterprise）也已更名为 Copilot。</span></p><p><span style="color:#000000">目前该公司现在约有十几种产品共享 Copilot 品牌，微软方面表示，此次改名并不是为了造成混淆。其通信总监 Caitlin Roulston 解释称，「将 Bing Chat Enterprise 更名为 Copilot 反映了我们为消费者和商业客户打造统一的 Copilot 体验的愿景。」</span></p><p><span style="color:#000000">科技媒体 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2023%2F11%2F15%2Fbing-chat-is-now-copilot%2F" target="_blank">TechCrunch</a> 认为，虽然 Roulston 的言论有一定的道理。但也不排除是因为 Bing Chat 并没有给 Bing 带来多大的推动，所以微软希望将这项技术与推出它的搜索引擎剥离开来的原因。StatCounter 8 月份的一份报告指出，在 Bing Chat 推出六个月后，Bing 未能从 Google 手中夺取任何市场份额；不过微软方面对这一调查结果提出异议。</span></p><p><img height="279" src="https://oscimg.oschina.net/oscnet/up-3a23b972d5c87805c49dd110d3b0bb06145.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">除了改名之外，从 12 月 1 日起，使用企业账户（准确地说，是 Microsoft Entra ID）登录 Bing 的用户在 Bing 中使用 Copilot 时，将享受"商业数据保护"的好处。Roulston 称，这意味着用户的数据不会被保存、不会被用于训练人工智能模型，且微软也无法访问这些数据。</span></p><p><span style="color:#000000">「Copilot 将于 12 月 1 日更新商业条款和条件，以反映它是微软的通用产品。作为其中的一部分，它将继承微软在线服务的通用许可条款……随着时间的推移，微软将免费向更多的 Entra ID 用户提供具有商业数据保护功能的 Copilot。」</span></p><p><span style="color:#000000">除了 Copilot.Microsoft.com 和 Bing 之外，现在还可以在 Windows 中访问 Copilot，并在 Microsoft 的一系列企业订阅计划（Microsoft 365 E、E5、Business Premium 和 Business Standard）中提供，无需额外付费。Copilot 将从 12 月 1 日起包含在 Microsoft 365 F3 中。对于所有其他客户，它将以每月 5 美元的价格提供服务。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 03:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266700/bing-chat-rename-copilot</guid>
            <link>https://www.oschina.net/news/266700/bing-chat-rename-copilot</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[阿里云 11.12 故障原因曝光：访问密钥服务 (Access Key) 异常]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>针对阿里云 11.12 的重大服务故障， 该公司发给客户的一份「官方故障报告」昨天在网上被广泛流传。</span></p><blockquote><p><span>事件回顾：</span><u><a href="https://www.oschina.net/news/266144">阿里云严重故障，全线产品受影响（已恢复）</a></u></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-12e038da50562b9fb7806fac53534a272ac.png" referrerpolicy="no-referrer"></p><hr><p style="margin-left:0; margin-right:0"><strong><span>影响范围</span></strong></p><p><span style="color:#021eaa"><strong><span style="color:#021eaa">1、OSS、OTS、SLS、MNS 等产品的部分服务受到影响，大部分产品如 ECS、RDS、网络等运行不受影响。</span></strong></span></p><p><span style="color:#0052ff"><strong><span>2、云产品控制枱、管控 API 等功能受到影响。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span>时间</span></strong></p><p><span style="color:#0052ff"><strong><span>2023 年 11 月 12 日 17:39～19.20，</span></strong></span><span style="color:#021eaa"><strong><span>故障时间为 1 小时 41 分。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span style="color:rgba(0, 0, 0, 0.9)">问题概况</span></strong></p><p><span style="color:#0052ff"><strong><span>2023 年 11 月 12 日 17:39 起，阿里云云产品控制枱访问及管控 API 调用出现异常、部分云产品服务访问异常，工程师排查故障原因与访问密钥服务 (AK) 异常有关。工程师修订白名单版本后，采取分批重启 AK 服务的措施，于 18:35 开始陆续恢复，19:20 绝大部分 Region 产品控制枱和管控 API 恢复。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span style="color:rgba(0, 0, 0, 0.9)">处理过程</span></strong></p><p><span>17:39：阿里云云产品控制枱访问及管控 API 调用出现异常。</span></p><p><span>17:50：工程师确认故障是 AK 服务异常导致，影响云产品控制枱、管控 API 调<span>用异常，以及依赖 AK 服务的云产品服务运行异常。</span></span></p><p><span>18:01：工程师定位到根因。</span></p><p><span>18:07：开始执行恢复措施，包括修订白名单版本、重启 AK 服务。</span></p><p><span>18:35：杭州等 Region 开始恢复正常。</span></p><p><span>19:20：绝大部分 Region 的云产品控制枱和管控 API 调用恢复正常。</span></p><p style="margin-left:0; margin-right:0"><strong><span>原因</span></strong></p><p><span style="color:#021eaa"><strong><span>访问密钥服务 (AK）在读取白名单数据时出现读取异常，因处理读取异常的代码存在逻辑缺陷，生成了一份不完整白名单，导致不在此白名单中的有效请求失败，影响云产品控制枱及管控 API 服务出现异常，同时部分依赖 AK 服务的产品因不完整的白名单出现部分服务运行异常。</span></strong></span></p><p style="margin-left:0; margin-right:0"><strong><span>改进措施</span></strong></p><p><span>1、增加 AK 服务白名单生成结果的校验及告警拦截能力。</span></p><p><span>2、增加 AK 服务白名单更新的灰度验证逻辑，提前发现异常。</span></p><p><span>3、增加 AK 服务白名单的快速恢复能力。</span></p><p><span>4、加强云产品侧的联动恢复能力。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 03:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266694</guid>
            <link>https://www.oschina.net/news/266694</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米官宣 Xiaomi Vela 全面开源，底层内核为 NuttX]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米澎湃 OS 刚刚在微博<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F1786860821%2FNsNK2mfse%3Fpagetype%3Dprofilefeed" target="_blank">宣布</a></u>，Xiaomi Vela 采用 Apache 2.0 License 面向全球软硬件开发者正式开源。</p><blockquote><p><img height="1352" src="https://static.oschina.net/uploads/space/2023/1116/102959_ekSh_2720166.png" width="2000" referrerpolicy="no-referrer"></p></blockquote><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fiot.mi.com%2Fvela" target="_blank">根据官网的介绍</a></u>，Xiaomi Vela 是小米基于开源实时操作系统<strong><u><a href="https://www.oschina.net/p/nuttx">NuttX</a></u></strong>打造的物联网嵌入式软件平台，Vela 在各种物联网硬件平台上提供统一的软件服务，支持丰富的组件和易用的框架，打通碎片化的物联网应用场景。‘Vela’ 一词源自拉丁语中船帆的含义，也是南方星空中最亮的星座之一。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2e4d78299513d8dd8e48dd44f9f1c80cbea.png" referrerpolicy="no-referrer"></p><p><strong>Xiaomi Vela 主要特性</strong></p><ul><li>高效性能：Vela 基于 NuttX 内核，具有高实时性、低功耗、低延迟等特点，适用于各种资源受限的嵌入式设备。</li><li>丰富组件：Vela 提供了多种常用的组件，如网络、音频、视频、图形、安全等，方便开发者快速构建应用。</li><li>易用框架：Vela 提供了一套统一的应用框架，支持 Lua、JavaScript 等脚本语言开发应用，并提供了丰富的 API 和文档。</li><li>万物互联：Vela 支持多种通信协议和标准，如 WiFi、BLE、Zigbee、MQTT 等，并提供了小米妙享技术，实现设备之间的无缝连接和协同。</li></ul><p><strong>Xiaomi Vela 系统架构如下</strong></p><p><img src="https://oscimg.oschina.net/oscnet/up-9bc7edd16b77b3d0ef73407769d0dc0b404.png" referrerpolicy="no-referrer"></p><ul><li><strong>底层 NuttX 内核</strong>：提供最基本的任务调度、跨进程间通信、文件系统等基础 OS 功能，同时也提供简洁高效的设备驱动、轻量级的 TCP/IP 协议栈和电源管理等组件。</li><li><strong>应用框架</strong>：分为上下两层，下层是为扩展系统服务而提供的通用应用框架，上层是针对不同的物联网应用而开发的定制应用框架，例如多媒体应用框架和传感应用框架，提供 Cloud SDK 可以方便开发者更快速的接入小米云服务。</li><li><strong>开发者工具</strong>：除了常见的 Logger 和 Debugger 工具，Xiaomi Vela 还提供 Emulator 工具来帮助开发者提升调试效率，使用 Emulator，开发者可以利用 PC 端丰富的调试工具和调试信息，降低嵌入式系统开发和调试的难度。</li></ul><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fiot.mi.com%2Fvela%2Fdetail.html" target="_blank">点此查看更多细节</a></u>。</p><hr><p>延伸阅读</p><ul><li><a href="https://www.oschina.net/news/263025" target="_blank">雷军公布小米澎湃 OS 完整系统架构，称底层全部重构</a></li><li><a href="https://www.oschina.net/news/263645" target="_blank">小米澎湃 OS 正式发布，Xiaomi Vela 将开源</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266688/xiaomi-vela-opensource</guid>
            <link>https://www.oschina.net/news/266688/xiaomi-vela-opensource</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Socket.D —— 基于语义消息流的网络协议]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">Socket.D&nbsp;是一个基于连接的、可扩展的、消息驱动的传输协议。具有异步，自动分片，背压流控，双向通讯，多路复用，断线重连，支持签权，基于主题消息等特性。</p><ul><li>具有语言无关性的二进制通信协议（支持 tcp, ws, udp）</li><li>异步非阻塞消息驱动通信</li><li>可以进行流量控制、自动连接恢复</li><li>支持双向通信（如：单链接双向 RPC 接口调用）</li><li>更加适合分布式通信场景</li><li>支持 ssl，支持国密 ssl</li><li>消息有由元信息和数据组成，通过元信息实现可扩展性</li><li>接口简单</li></ul><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">开发时，主要交互只有 2 接口对象（更多可见：<a href="https://gitee.com/noear/socketd/blob/main/API.md">API.md</a><span>&nbsp;</span>）：</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#40485b; display:block; font-family:-apple-system,&quot;system-ui&quot;,&quot;Segoe UI&quot;,Helvetica,Arial,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;,&quot;Liberation Sans&quot;,&quot;PingFang SC&quot;,&quot;Microsoft YaHei&quot;,&quot;Hiragino Sans GB&quot;,&quot;Wenquanyi Micro Hei&quot;,&quot;WenQuanYi Zen Hei&quot;,&quot;ST Heiti&quot;,SimHei,SimSun,&quot;WenQuanYi Zen Hei Sharp&quot;,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:left; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:835px; word-break:initial; word-spacing:0px"><thead><tr><th>接口</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">listener</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">监听器</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">（可双向互听）</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">会话</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">（可双向互发）</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::send</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">发送</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::sendAndRequest</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">发送并请求</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">要求一次答复</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::sendAndSubscribe</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">发送并订阅</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答复结束之前，不限答复次数</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::reply</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答复</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr><tr><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">session::replyEnd</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">答复结束</td><td style="border-color:#dfe2e5; border-style:solid; border-width:1px">&nbsp;</td></tr></tbody></table><h3 style="margin-left:0; margin-right:0; text-align:left">适用场景：</h3><p style="color:#40485b; margin-left:0; margin-right:0; text-align:left">可用于 MSG、RPC、IM、MQ，等一些的场景开发，可替代 http, websocket, grpc 等一些协议。比如移动设备与服务器的连接，比如一些微服务场景等等。</p></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/socketd</guid>
            <link>https://www.oschina.net/p/socketd</link>
        </item>
        <item>
            <title>
                <![CDATA[ChatGPT 代码解释器存在巨大安全漏洞]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenAI 近日为 ChatGPT 推出了全新的代码解释器（Code Interpreter）工具，可以帮助程序员调试、完善代码编程工作。该工具可以利用 AI 来编写 Python 代码，所编写的代码甚至可以在沙盒中运行。</p><p>不过根据 Johann Rehberger 网络安全专家、Tom's Hardware 等多家国外媒体<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tomshardware.com%2Fnews%2Fchatgpt-code-interpreter-security-hole" target="_blank">报道</a></u>，由于该代码解释器工具可以处理任何电子表格文件，并能以图表的形式分析和呈现数据，<strong>黑客可以欺骗 ChatGPT 聊天机器人，让其执行来自第三方 URL 的指令</strong>。</p><p>Tom's Hardware 媒体复现了相关漏洞，创建虚假的环境变量文件，利用 ChatGPT 的功能处理此数据，然后将其发送到外部恶意站点。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1ca35470cf685c96d916ec4c8a97265c843.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-df3cfd0173073986a718e72cfaab32eb096.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-787cc41d51a67b812ef60dda6ed6532d570.png" referrerpolicy="no-referrer"></p><p>ChatGPT 可以响应 Linux 命令，可以访问相关信息和文件，黑客通过这种方式，可以在用户没有防备的情况下，访问相关的敏感数据。</p><p>目前需要订阅 ChatGPT Plus，才能访问该代码解释工具，但这个漏洞引发了网络安全专家的担忧。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266683/chatgpt-code-interpreter-security-hole</guid>
            <link>https://www.oschina.net/news/266683/chatgpt-code-interpreter-security-hole</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
