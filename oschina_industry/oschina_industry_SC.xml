<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>开源中国-综合资讯</title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="http://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml"></atom:link>
        <description>开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)</description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>en</language>
        <lastBuildDate>Wed, 27 Mar 2024 13:06:00 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>武汉大学开设「雷军班」：计算机专业、今年招收 15 名本科生</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;3 月 25 日，武汉大学官网对校长张平文调研计算机学院进行了报道，文章提到：「就雷军班和机器人系建设方面，张平文希望学院提高站位、布局未来，发挥雷军校友捐赠的重要作用，凝心聚力早日把计算机学院建成国内知名、世界一流的学术高地。」&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-10c5c2cfd163009c4db026c83070c834fad.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;不少网友好奇，雷军班是个什么情况，跟企业家雷军有什么关系？&lt;/p&gt; 
&lt;p&gt;3 月 27 日，武汉大学计算机学院办公室工作人员回应记者称：「&lt;strong&gt;在今年高考后，雷军班将向全国招 15 名本科生，属于计算机专业，吸纳最优秀的有志向的学生就读，本博贯通培养。&lt;/strong&gt;」&lt;/p&gt; 
&lt;p&gt;工作人员强调：「与其他普通本科班相比，这个班肯定是不一样的。整个培养方面的各个环节都是高配置。」&lt;/p&gt; 
&lt;p&gt;另据武汉大学计算机学院官网 1 月 8 日报道，计算机学院院长杜博曾表示，「雷军校友捐赠除了助力基础学科研究和支持大学生培养，主要资助计算机学科发展和计算机领域科技创新。学院将加强师资力量，传承人才培养优良传统，发扬雷军的创新精神，设立雷军班，把有计算机天赋和有创新、创意、创业的优秀人才招进来。」&lt;/p&gt; 
&lt;p&gt;武汉大学是小米创始人雷军的母校，他在去年 11 月 29 日的武汉大学 130 周年校庆日上宣布，&lt;strong&gt;个人向母校捐赠 13 亿元人民币，刷新武大建校以来单笔最大捐赠额。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ddcdda06e0737310208f9c2696171fdb78b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;当时雷军表示，此次捐赠主要聚焦三个方向：支持数理化文史哲六大学科基础研究、支持计算机领域科技创新、支持大学生培养。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284988</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284988</guid>
            <pubDate>Wed, 27 Mar 2024 08:35:37 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>微软任命新的 Windows 和 Surface 负责人</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;微软任命 Pavan Davuluri 为新任 Windows 和 Surface 主管。去年，在前负责人&amp;nbsp;Panos Panay 跳槽前往亚马逊之后，微软就将 Windows 和 Surface 部门拆分为两个不同的领导团队；由&amp;nbsp;Davuluri 接管了 Surface 相关工作，Windows 方面则由 Mikhail Parakhin 进行领导。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;时至今日，该公司又将 Windows 和 Surface 整合，统一交由都将由 Davuluri 负责。微软体验和设备执行副总裁 Rajesh Jha 在一份内部备忘录中&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2024%2F3%2F25%2F24111931%2Fmicrosoft-windows-surface-pavan-davuluri&quot; target=&quot;_blank&quot;&gt;解释称&lt;/a&gt;，因为 Parakhin 现在正在&quot;探索新的角色&quot;，但他并没有有明确指出是在微软内部还是外部。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Jha 在备忘录中概述了新的 Windows 组织架构。指出 Davuluri 将领导一个合并的 Windows 和设备团队，作为 Experiences + Devices (E+D) 部门的&quot;核心部分&quot;。「这将使我们能够采取整体方法来构建跨 Windows 客户端和云的芯片、系统、体验和设备，以适应这个 AI 时代。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;333&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-90467fe07ce648d6b571892737ebc09c654.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;以下是 Rajesh Jha 的备忘录全文：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;我想分享继上周宣布并创建 Microsoft AI 组织之后 Windows 和 Web Experiences (WWE) 团队的最新动态。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Mikhail Parakhin 决定探索新角色。Satya 和我对 Mikhail 的贡献和领导表示感谢，并感谢他为帮助微软引领新人工智能浪潮所做的一切。他将向 Kevin Scott 汇报工作，同时支持 WWE 的过渡。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;作为此变更的一部分，我们将 Windows Experiences 和 Windows + Devices 团队合并为 Experiences + Devices (E+D) 部门的核心部分。这将使我们能够采取整体方法来构建这个人工智能时代跨越 Windows 客户端和云的芯片、系统、体验和设备。 Pavan Davuluri 将领导这个团队并继续向我汇报。 Shilpa Ranganathan 和 Jeff Johnson 及其团队将直接向 Pavan 汇报。 Windows 团队将继续与 Microsoft AI 团队在 AI、芯片和体验方面密切合作。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Web Experiences 团队将向新的 Microsoft AI 组织中的 Mustafa 汇报工作。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Jordi Ribas 将领导搜索、地图和平台业务，Andrey Proskurin、Fatima Kardar 和 Nick Lee 向他汇报。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Rukmini Iyer 将领导广告部，Paul Viola 和 Weiqing Tu 向她汇报。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Mike Davidson 继续领导设计部门，并将与 Pavan 和团队合作研究如何重新调整 Windows 设计。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Ali Akgun、Kya Sainsbury-Carter、Zhang Qi 和 Rajesh Sundaram 的角色保持不变。他们将与 Jordi、Mike 和 Rukmini 一起加入 Microsoft AI 领导团队，全部向 Mustafa 汇报。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;我们很高兴这个团队能够帮助 Microsoft AI 实现其打造世界一流的消费者 AI 产品的大胆雄心。我非常期待与 Mustafa 及其团队密切合作，将包括 Copilot 在内的 AI 产品广泛应用于我们的 E+D 产品和服务中。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Thanks,&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Rajesh&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284970/microsoft-windows-surface-pavan-davuluri</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284970/microsoft-windows-surface-pavan-davuluri</guid>
            <pubDate>Wed, 27 Mar 2024 07:39:43 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>日本政府称有朝鲜 IT 人员冒充日本人接外包赚外汇</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;日本政府 26 日发布了一份提醒国内 IT 相关企业注意的文件，指出疑似有朝鲜 IT 技术人员冒充日本人，在网上承接 IT 相关业务订单。联合国等表示，为了赚取外汇用于核与导弹开发，朝鲜正在利用技术人员。据称，若把业务发包给此类人员，可能违反《外汇法》等。&lt;/p&gt; 
&lt;p&gt;文件由警察厅、外务省、财务省、经济产业省联名发布。美国和韩国去年 10 月发出了类似提醒，日本则是首次。警察厅干部透露称「在日本也发现了案例，威胁高涨」。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2023/1023/112217_pba9_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;该文件等显示，朝鲜技术人员在为 IT 相关业务发包方和自由技术人员提供中介服务的网站上，或者伪造身份，或者通过住在日本的亲戚等进行注册。据称，他们大多在中国和俄罗斯工作并赚取报酬。&lt;strong&gt;其特点包括不参加视频会议、频繁变更收款账户、使用的日语不地道等&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;在日本，神奈川县警方等 6 日以涉嫌违规领取失业补贴为由，逮捕了广岛县 IT 相关公司社长等人。警方认为其有可能把业务发包给了朝鲜技术人员，正在查明案情。神奈川县警方的调查中还发现，2022 年，另外的朝鲜技术人员以熟人名义承接了兵库县防灾 APP 修改业务等。&lt;/p&gt; 
&lt;p&gt;延伸阅读：&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/news/262984/north-korea-it-workers-remote-work&quot; target=&quot;_blank&quot;&gt;朝鲜 IT 开发者为美国公司从事远程外包工作&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284953</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284953</guid>
            <pubDate>Wed, 27 Mar 2024 06:44:13 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>苹果和中国百度尚未达成人工智能技术供应协议</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;此前有报道称苹果公司已与百度达成合作，将在该地区使用百度的大模型 AI 功能。但现在又有消息称，双方并未达成这样的协议。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-2550020989aa58a4082d974f67ffa94e71c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.chinastarmarket.cn%2Fdetail%2F1628550&quot; target=&quot;_blank&quot;&gt;https://www.chinastarmarket.cn/detail/1628550&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;《中国日报》指出，这些早先的报道不正确。该刊物称，苹果和百度尚未就人工智能合作达成一致，它是从熟悉苹果公司运作的消息来源获得这一信息的。有关两家公司已达成协议的报道只是媒体的猜测。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-5cf43246dfdeb31ea068b82961ff89dc3e3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.chinadaily.com.cn%2Fa%2F202403%2F26%2FWS6602b2c1a31082fc043bec68.html&quot; target=&quot;_blank&quot;&gt;https://www.chinadaily.com.cn/a/202403/26/WS6602b2c1a31082fc043bec68.html&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;不过无论苹果公司目前签订的任何合同的具体情况如何，至少该公司很可能会与中国公司合作，这样做容易避免潜在的监管问题。&lt;/p&gt; 
&lt;p&gt;百度股价在最初的报道中上涨了 2.55%。百度和苹果公司均未对此发表评论。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284945</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284945</guid>
            <pubDate>Wed, 27 Mar 2024 06:08:20 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>Linux 6.9 弃用 ext2 文件系统驱动程序</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在即将发布的 6.9 Linux 内核中，ext2 文件系统驱动程序将被标记为已&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgit.kernel.org%2Fpub%2Fscm%2Flinux%2Fkernel%2Fgit%2Ftorvalds%2Flinux.git%2Fcommit%2F%3Fid%3Db960e8093e7a57de98724931d17b2fa86ff1105f&quot; target=&quot;_blank&quot;&gt;弃用&lt;/a&gt;。EXT2 第二代扩展文件系统是 Linux 内核所用的文件系统，最开始由 Rémy Card 设计用以代替 ext，于 1993 年 1 月加入 Linux 核心支持之中，至今已有三十多年的历史。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Linux 开发人员 Michael Opdenacker 解释称，ext2 被弃用的主要原因在于，即使文件系统是用 256 字节的 inodes（mkfs.ext2 -I 256）创建的，文件系统驱动程序也会坚持使用 32 位日期。因此，驱动程序不支持超过 2038 年 1 月 19 日 03:14:07 UTC 的 inode 时间戳。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;对于仍在使用 ext2 及其驱动程序，并且系统日期正确设置为截止日期之前最多 30 年的日期的用户，将收到此警告：&lt;/span&gt;&lt;/p&gt; 
&lt;pre style=&quot;margin-left:0; margin-right:0; text-align:start&quot;&gt;# mount -t ext2 /dev/sda1 /mnt
[  441.680685] ext2 filesystem being mounted at /mnt supports timestamps until 2038-01-19 (ox7fffffff)&lt;/pre&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;由于无法正确支持 2038 年 1 月 19 日之后的时间戳。官方建议 ext2 用户升级到使用 ext4 驱动程序来访问其文件系统，ext4 文件系统驱动程序与 ext2 完全兼容。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;416&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-9b1cc7bffe503a4e97379da4df9747b64d9.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;更多详情可查看此&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbootlin.com%2Fblog%2Fext2-filesystem-driver-now-marked-as-deprecated%2F&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284942/ext2-deprecat-linux-6-9</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284942/ext2-deprecat-linux-6-9</guid>
            <pubDate>Wed, 27 Mar 2024 05:50:46 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>开源日报 | AI PC 的价值到底在哪？Windows 格式化对话框的 UI 用了 30 年；丑头像生成器；独立的 Redis Copyleft 分支</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;欢迎阅读 OSCHINA 编辑部出品的开源日报，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#e67e22&quot;&gt;&lt;strong&gt;# 2024.3.26&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日要点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;OpenSource Daily&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284729/inkscape-switches-to-gtk4&quot; target=&quot;_blank&quot;&gt;开源图形编辑器 Inkscape 底层 UI 框架改用 GTK4&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;矢量图形编辑器 Inkscape 开发分支的最新上游代码已迁移至使用 GTK4，这是一次重大升级，同时也改进了架构，并为将来实现 GPU 加速做好了准备。&lt;/p&gt; 
&lt;p&gt;Inkscape 通过其 Mastodon 账户宣布了向 GTK4 过渡的消息。由于各种问题，尤其是在 macOS 和 Windows 上的问题，下一个稳定版本（v1.4）仍将使用 GTK3。&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284749/redict-independent-fork-redis&quot; target=&quot;_blank&quot;&gt;Redict：一个独立的 Redis Copyleft 分支&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;Redict 是由开发者 Drew DeVault 推出的一个 Redis OSS 7.2.4.2 的独立、非商业性的分叉。基于 Redis OSS 的 BSD 3-Clause 源代码，自此之后的所有更改均采用 Lesser GNU General Public license（LGPL-3.0-only）。&lt;/p&gt; 
&lt;p&gt;Redict 旨在作为 Redis OSS 7.2.4 的直接替代品。接下来，Redict 的目的是继续开发 Redis OSS 兼容软件的自由软件发行版，暂时只进行最小程度的破坏性更改。&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日观察&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img height=&quot;1142&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-720920b89166e12e4474df21d15cdb13e1d.png&quot; width=&quot;3290&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- &lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sohu.com%2Fa%2F766955186_166680&quot; target=&quot;_blank&quot;&gt;集微网&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-df160bed3a4a1edeecfaf0ea94367e6ffce.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微博&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1834645454%2FO6OaUrIXM&quot; target=&quot;_blank&quot;&gt;dingtingli&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;今日推荐&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-3dd733b17408eabbeef0376a1b161484ca2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Ftxstc55%2Fugly-avatar&quot; target=&quot;_blank&quot;&gt;https://github.com/txstc55/ugly-avatar&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;事件点评&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-bce40dbed054e00f3808407c9d3f805a8b7.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;每日项目榜&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;每日 GitHub 精选&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-4f54b79a6c20ed322ca67c7d78f425b439b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;在线阅读完整日报内容，访问：&lt;/span&gt;&lt;/strong&gt;&lt;br&gt; &lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://report.oschina.net/api/files/jhim80u9qm1ofsw/sq4hlnesqz46pu8/37_ai_pc_windows_ui_30_redis_copyleft_jwb07bWFPR.pdf&quot; target=&quot;_blank&quot;&gt;开源日报第 037 期：AI PC 的价值到底在哪？Windows 格式化对话框的 UI 用了 30 年；丑头像生成器；独立的 Redis Copyleft 分支&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/h4&gt; 
&lt;/blockquote&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;欢迎扫码下载「开源中国 APP」&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;随时在线阅读完整日报内容 ↓&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7871d27245192b8ecfcd21043d309382749.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;889&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-842e51ced6d226559af1af95c8041338cb2.gif&quot; width=&quot;400&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284926</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284926</guid>
            <pubDate>Wed, 27 Mar 2024 03:28:20 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>罗永浩本周日晚将首度直播卖「云」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;阿里云官微宣布，罗永浩将于 3 月 31 日晚首次淘宝直播卖云，选品涵盖云服务器、云存储及企业网盘等热门阿里云产品，重点面向创业者及中小企业群体。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;475&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d2c9f7747404286dff54e6e9df56b4abb39.webp&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此前的 2 月 29 日，阿里云宣布全线降价 20%。根据阿里云官网报价数据显示，降价清单中的云服务器 ECS 最高降 36%、对象存储 OSS 最高降 55%、云数据库 RDS 最高降 40%，都是云上用户使用频率最高的核心产品。此次史上最大规模降价引发了一波中小企业上云热潮。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;最近披露的财报显示，阿里云正通过减少利润率较低的项目制合约类收入，持续提高收入质量。阿里云智能集团资深副总裁、公共云事业部总裁刘伟光此前表示，阿里云期待与行业共同铸造中国云计算产业的规模效应。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284923</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284923</guid>
            <pubDate>Wed, 27 Mar 2024 03:10:20 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>适用于原生 Arm64 设备的 Chrome 即将发布</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;谷歌与高通公司（Qualcomm）共同&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2024%2F3%2F26%2F24112273%2Fchrome-native-windows-on-arm-qualcomm-snapdragon&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;，将于本周发布针对 Windows on Arm 的 Chrome 浏览器优化版。事实上早在两个月前，就曾有用户在 Chrome 浏览器的 Canary 频道发现过该浏览器的早期版本，现如今谷歌终于正式将其正式推出。高通公司表示，该版本&quot;将从今天开始推出&quot;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;292&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-6bba083617132dcd93860160703973230b4.webp&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;对于使用基于 Arm 处理器的 Windows 机器的 Chrome 浏览器用户来说，该版本的发布将是一件大事，因为他们现在可以使用速度更快的原生浏览器了。相比之下，他们以前只能在模拟状态下运行性能缓慢的 x64 版 Chrome 浏览器。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;高通最新推出的基于 Arm 的 Windows 处理器被称为骁龙 X Elite（Snapdragon X Elite），预计将于今年夏天上市，据称将带来不俗的性能表现。谷歌经过 Arm 优化的 Chrome 浏览器在技术上可以在任何基于 Arm 的 Windows PC 上运行，与处理器制造商无关，但高通公司是目前唯一一家为 Windows 生产基于 Arm 处理器的公司。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;谷歌公司的 Hiroshi Lockheimer 表示：「我们设计的 Chrome 浏览器快速、安全且易于在台式机和移动终端上使用。我们与高通公司的密切合作将有助于确保 Chrome 浏览器用户在当前 Arm 兼容 PC 上浏览网页时获得最佳体验。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;这并不是谷歌第一次发布经过 Arm 优化的 Chrome 浏览器版本，早在 2020 年，谷歌就为苹果基于 Arm 的 Mac 发布了原生版本的浏览器。长期以来，这家搜索巨头还在 ChromeOS 中为 Chromebook 提供基于 Arm 处理器的支持。但是，在以消费者为中心的 Surface 设备有望全面转向 Arm 的这一年，为 Windows 发布基于 Arm 的世界上最流行的 Windows 浏览器原生版本，将极大地推动 Windows on Arm 的发展。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284903/chrome-native-arm-based-windows-pc</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284903/chrome-native-arm-based-windows-pc</guid>
            <pubDate>Wed, 27 Mar 2024 02:03:39 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>Java 8 内存管理原理解析及内存故障排查实践</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                    &lt;div class=&quot;rich_media_content js_underline_content
                       autoTypeSetting24psection
            &quot; id=&quot;js_content&quot;&gt; 
 &lt;section style=&quot;font-size: 15px;line-height: 1.6;&quot;&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;作者：vivo 互联网服务器团队-&amp;nbsp; Zeng Zhibin&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;&quot;&gt; 
    &lt;section style=&quot;text-align: left;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);&quot;&gt; 
      &lt;p style=&quot;text-wrap: wrap;&quot;&gt;介绍 Java8 虚拟机的内存区域划分、内存垃圾回收工作原理解析、虚拟机内存分配配置，介绍各垃圾收集器优缺点及场景应用、实践内存故障场景排查诊断，方便读者面临内存故障时有一个明确的思路和方向。&lt;/p&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
    &lt;section style=&quot;margin-right: 0%;margin-bottom: -5px;margin-left: 0%;text-align: right;line-height: 1;font-size: 5px;transform: translate3d(5px, 0px, 0px);&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;width: 0px;display: inline-block;vertical-align: top;border-bottom: 0.6em solid rgb(160, 160, 160);border-right: 0.6em solid rgb(160, 160, 160);border-top: 0.6em solid transparent !important;border-left: 0.6em solid transparent !important;&quot;&gt; 
      &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;一、背景&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 是一种流行的编程语言，可以在不同的操作系统上运行。它具有跨平台、面向对象、自动内存管理等特点，Java 程序在运行时需要使用内存来存储数据和程序状态。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 的自动内存管理机制是由 JVM 中的垃圾收集器来实现的，垃圾收集器会定期扫描堆内存中的对象，检测并清除不再使用的对象，以释放内存资源。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 的自动内存管理机制带来了许多好处，首先，它可以避免程序员手动管理内存时的错误，例如内存泄漏和悬空指针等问题。其次，它可以提高程序的运行效率，因为程序员不需要频繁地手动分配和释放内存，而是可以将更多时间和精力专注于程序的业务逻辑，最后，它可以提高程序的可靠性和稳定性，因为垃圾收集器可以自动检测和清除不再使用的内存资源，避免内存溢出等问题。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;了解和掌握垃圾收集器原理可以帮助提高程序的性能、稳定性和可维护性。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;font-size: 14px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;名词解释：&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;响应速度&lt;/strong&gt;：响应速度指程序或系统对一个请求的响应有多迅速。比如，用户查询数据响应时间，对响应速度要求很高的系统，较大的停顿时间是不可接受的。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;：吞吐量关注在一个特定时间段内应用系统的最大工作量，例如每小时批处理系统能完成的任务数量，在吞吐量方面优化的系统，较长的 GC 停顿时间也是可以接受的，因为高吞吐量应用更关心的是如何尽可能快地完成整个任务，不考虑快速响应用户请求。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;GC 导致的应用暂停时间影响系统响应速度，GC 处理线程的 CPU 使用率影响系统吞吐量。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;二、Java&amp;nbsp;8&amp;nbsp;的内存管理&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;2.1 JVM（Java 虚拟机）内存划分&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 运行时数据区域划分，Java 虚拟机在执行 Java 程序时，将其所管理的内存划分为不同的数据区域，每个区域都有特定的用途和创建销毁的时间。其中，有些区域在虚拟机进程启动时就存在，而有些区域则是随着用户线程的启动和结束而建立和销毁。这些数据区域包括程序计数器、虚拟机栈、本地方法栈、堆、方法区等，每个区域都有其自身的特点和作用。了解这些数据区域的使用方式和特点，可以更好地理解 Java 虚拟机的内存管理机制和运行原理。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;JVM 的内存区域划分可分为：1.堆内存空间、2.Java 虚拟机栈区域、3.程序计数器、4.本地方法栈、5.元空间区域、6.直接内存。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014615&quot; data-ratio=&quot;0.774074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/1e56b454-4e41-465a-8ba6-8c53e10fc02c.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014616&quot; data-ratio=&quot;0.9365079365079365&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/ec4c9ff4-4b80-46ad-aff9-ce2ce396b38b.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1008&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;堆内存空间&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;：JVM 中占用内存空间最大的是堆，平常对象的创建大部分都是在堆上分配内存的，是垃圾回收的主要目标和方向。&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;本地方法栈区域&lt;/strong&gt;：Native Mehod Stack 与 Java 虚拟机栈的作用非常相似，区别是 Java 虚拟机栈为虚拟机执行 Java 方法或者为字节码而服务，本地方法栈是为了 Java 虚拟机栈得到 Native 方法。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;Java 虚拟机栈区域&lt;/strong&gt;：负责 Java 的解释过程、程序的执行过程、入栈和出栈，它是与线程相关的，当启动一个新的线程时，Java 程序就会分配一个 Java 虚拟机栈提供运行；Java 虚拟机栈从方法入栈到具体字节码执行是一个双层栈结构，可以栈里包含栈。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;：记录线程执行位置，线程私有，因为操作系统不停的调度，无法获取到线程被调度之前的位置，程序计数器提供了这样一个线程执行位置。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;元空间区域&lt;/strong&gt;：在原来的老的 Java 7 之前划分中，永久代用来存放类的元数据信息、静态变量以及常量池等。在现在 Java8 后类的元信息存储在元空间中，静态变量和常量池等并入堆中，相当于原来的永久代中的数据，被元空间和堆内存给瓜分了。&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;直接内存&lt;/strong&gt;：使用了 Java 的直接内存的 API 的内存，例如缓冲 ByteBuffer，可以控制虚拟机参数调整大小，而本地内存是使用了 native 函数操作的内存，是不受 JVM 管理控制。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;堆内存空间&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;JVM 回收的主要目标是堆内存，对象主要的创建分配内存在堆上进行，堆可以想象成一个对象池子，对象不停创建放入池子中，而 JVM 垃圾回收是不停的回收池子中一些被标记为可回收对象的对象，启动回收线程进行打扫战场，当回收对象的速度赶不上程序的创建时，池子就会立马满，当满了之后从而发生溢出，就是常见的 OOM。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;GC 的速度和堆的内存中存活对象的数量有关，与堆内存所有的对象无关，GC 的速度和堆内存的大小无关，如一个 4GB 大小的堆内存和一个 16GB 的堆内存，只要 2 个堆内存存活对象都是一样多的时候，GC 速度都是基本差不多。每次垃圾回收也不是必须要把垃圾清理干净，重要的是保证不把正在使用的对象给标记清除掉。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;2.2 堆内存管理&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;JVM 中占用内存空间最大的是堆内存，平常对象的创建大部分都是在堆上分配内存的，是 Java 垃圾回收的主要目标和方向、是 Java 内存管理机制的核心组成部分，它可以自动管理 Java 程序的内存分配和释放，Java 垃圾收集器可以自动检测和回收不再使用的内存，以便重新分配给其他需要内存的程序。这种自动内存管理的机制可以提高程序的运行效率和可靠性，防止因内存泄漏等问题导致程序崩溃或性能下降，Java 垃圾收集器使用了不同的垃圾回收算法和垃圾收集器实现，以适应不同的应用场景和需求。Java 垃圾收集器的性能特征和优化技术也是 Java 程序员需要了解和掌握的重要知识。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;因此，了解 Java 垃圾回收的背景、原理和实践经验对于编写高效、可靠的 Java 程序非常重要。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.1 对象如何被判断为可回收&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;JVM 怎么判断堆内存里面的对象是否可回收的，就是当一个对象没有任何引用指向它了，它就是可回收对象，判断的方式有两种算法，一个是引用计数法，一个是可达性分析法。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;可回收对象：&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;424&quot; data-imgfileid=&quot;100014617&quot; data-ratio=&quot;0.7333333333333333&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/891ef4a1-7e31-4cc2-81d3-8e27a1779354.jpg&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;width: 578px;height: 424px;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（1）引用计数法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;给对象中添加一个引用计数器，每当有一个地方引用它时，这个计数器值加一，当引用失效断开时，计数器值就减一，在任何时刻时计数器为 0 的时候，代表这个对象是可以被回收的，没有任何引用使用它了。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014618&quot; data-ratio=&quot;0.6796296296296296&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/bce27aab-824a-4e0d-ab6b-789c5e0799ba.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;引用计数法是有缺点，当对象直接互相依赖引用时，这些对象的计数器都不能为 0，都不能被回收。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（2）可达性分析法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;它使用 tracing（链路追踪）方式寻找存活对象的方法，通过一些列称为「GC Roots」的对象作为初始点，从这些初始点开始向下查找，直到向下查找没有任何链路时，代表这个对象可以被回收，这种算法是目前 Java 唯一且默认使用来判定可回收的算法。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014620&quot; data-ratio=&quot;0.6796296296296296&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/0f23e95f-e8c9-4525-8d62-34b5ac4636b4.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.2 GC Roots 的概念和对象类型&lt;/strong&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ol class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: decimal;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;Java 虚拟机栈中引用的对象，例如各个线程被调用的方法栈用到的参数、局部变量或者临时变量等。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;方法区的静态类属性引用对象或者说 Java 类中的引用类型的静态变量。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;方法区中的常量引用或者运行时常量池中的引用类型变量。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;JVM 内部的内存数据结构的一些引用、同步的监控对象（被修饰同步锁）。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;JNI 中的引用对象。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ol&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;当然，被 GC Roots 追溯到的对象不是一定不会被垃圾回收，具体需要看情况，Java 对象与对象引用存在四种引用级别：分别是强引用、软引用、弱引用、虚引用，默认的对象关系是强引用，只有在和 GCRoots 没有关系时才会被回收；软引用用于维护一些可有可无的对象，当内存足够时不会被回收；弱引用只要发生了垃圾回收就会被清理；虚引用人如其名形同虚设，任何对象都与它无关。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.3 垃圾对象回收算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;当 JVM 定位到了那些对象可回收时，这个时候是通过三个算法标记清除，分别是标记清除算法、复制算法、标记压缩算法。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（1）标记清除算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;首先标记出所有需要回，收的对象，在标记完成后，统一回收掉所有被标记的对象，但是该算法缺点是执行效率低，当大量对象时需要大量标记和清理动作，而且容易产生内存碎片化，当需要一块连续内存时，会因为碎片化无法分配。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014621&quot; data-ratio=&quot;0.2324074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/d964fb76-5184-4844-a6a8-c1e2e8c0d9a0.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（2）标记压缩算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;标记压缩算法跟清除算法很像，只不过它对内存进行了整理， 让存活对象都向内存空间的一端移动，然后将边界的其它对象全部清理，这样能达到内存碎片化问题，不过它比清除算法多了移步动作。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014622&quot; data-ratio=&quot;0.1527777777777778&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/eb4ba1e3-b7b5-42f5-9087-2567b4355f6d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（3）复制算法&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，将存活对象复制到一块空置的空间里，然后将原来的区域全部清理，缺点是需要额外空间存放存活对象。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014623&quot; data-ratio=&quot;0.3425925925925926&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/a0b97901-6eeb-445a-8dd8-46b6bc0481ce.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.4 分代垃圾回收模型概念和原理&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;堆内存分代模型图&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014624&quot; data-ratio=&quot;0.25277777777777777&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/5f8f3b05-14d8-4730-9825-0dbb1e914d4f.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;当 JVM 进行 GC（垃圾回收）时，JVM 会发起「Stop the world」，所有的业务线程都进行停止，进入 SafePoint 状态，JVM 回收垃圾线程开始进行标记和追溯，如何解决这种停止和如何减少 STW 的时间呢？&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;目前主流垃圾收集器采用分代垃圾回收方式，大部分对象的声明周期都比较短，只有少部分的对象才存活的比较长，分代垃圾回收会在逻辑上把堆内存空间分为两部分，一部分为年轻代，一部分为老年代。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;（1）年轻代空间&lt;/strong&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;年轻代主要是存放新生成的对象，一般占用堆空间的三分之一空间，因为会频繁创建对象，所以年轻代 GC 频率是最高的。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;分为 Eden 空间、Survivor1（from）区、Survivor2（to）区，S1 和 S2 总要有一块空间是空的，为了方便年轻代存活对象来回存放，晋升存活对象年龄。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;三个区的默认比例是 8:1:1，可以通过配置参数调整比例。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;年轻代回收发起 Minor GC（YongGC），当 Eden 内存区域被占满之后就发起 GC，短暂的 STW，基于垃圾收集器。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;（2）老年代空间&lt;/strong&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;是堆内存中最大的空间， ，里面的对象都是比较稳定或者老顽固，GC 频率不会频繁执行。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014625&quot; data-ratio=&quot;0.4685185185185185&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/b655ab3a-9352-4372-b97a-570be86cd06d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;老年代对象：&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ol class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: decimal;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;正常提升&lt;/strong&gt;：由年轻代存活对象年龄到达阈值时，这个对象则会被移动到老年代中。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;分配担保&lt;/strong&gt;：如果年轻代中的空间不足时，此时有新的对象需要分配对象空间，需要依赖其它内存进行分配担保，老年代担保直接创建。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;大对象&lt;/strong&gt;：当创建需要大量连续内存空间的对象时，如长字符串或者数组等，大小超过了阈值时，直接在老年代分配。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;动态年龄对象&lt;/strong&gt;：有的垃圾收集器不需要到达指定年龄大小直接晋升老年代，比如相同年龄的对象的大小总和 &amp;gt; Survivor 空间的 50%， 年龄大于等于该年龄对象直接移动老年代，无需等待正常提升。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ol&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;老年代回收发起 Major GC / FULL GC，当老年代满时会触发 MajorGC，通常至少经历过一次 Minor GC，再紧接着进行 Major GC， Major GC 清理 Tenured 区，用于回收老年代（CMS 才能单独清理）。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;FUll GC：清除整个堆空间，一般来说是针对整个新生代、老生代、元空间的全局范围的清理。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;不管是 Major GC 还是 Full GC， STW 的耗时都是 Ygc 的十倍以上，所以说对象能在年轻代被回收是最优的。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;Full GC 触发条件：&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;老年代空间不足。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;元空间不足扩容导致。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;程序代码执行 System.gc 时可能会执行。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;当程序创建一个大对象时，Eden 区域放不下大对象，老年代内存担保分配，老年代也不足空间时。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;年轻代存留对象晋升老年代时，老年代空间不足时。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.5 Java 对象内存分配过程&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014626&quot; data-ratio=&quot;0.6027777777777777&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/d2937f98-1501-4a47-ab87-fd64453954f6.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&amp;nbsp;对象的分配过程&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ol class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: decimal;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;编译器通过逃逸分析优化手段，确定对象是否在栈上分配还是堆上分配。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;如果在堆上分配，则确定是否大对象，如果是则直接进入老年代空间分配， 不然则走 3。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;对比 tlab， 如果 tlab_top + size &amp;lt;= tlab_end， 则在 tlab 上直接分配，并且增加 tlab_top 值，如果 tlab 不足以空间放当前对象，则重新申请一个 tlab 尝试放入当前对象，如果还是不行则往下走 4。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;分配在 Eden 空间，当 eden 空间不足时发生 YGC， 幸存者区是否年龄晋升、动态年龄、老年代剩余空间不足发生 Full GC 。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;当 YGC 之后仍然不足当前对象放入，则直接分配老年代。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ol&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;TLAB&lt;strong&gt;作用原理&lt;/strong&gt;：Java 在内存新生代 Eden 区域开辟了一小块线程私有区域，这块区域为 TLAB，默认占 Eden 区域大小的 1%， 作用于小对象，因为小对象用完即丢，不存在线程共享，快速消亡 GC，JVM 优先将小对象分配在 TLAB 是线程私有的，所以没有锁的开销，效率高，每次只需要线程在自己的缓冲区分配即可，不需要进行锁同步堆 。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;对象除了基本类型的不一定是在堆内存分配，在 JVM 拥有逃逸分析，能够分析出一个新的对象所拥有的范围，从而决定是否要将这个对象分配到堆上，是 JVM 的默认行为；Java 逃逸分析是一种优化技术，可以通过分析 Java 对象的作用域和生命周期，确定对象的内存分配位置和生命周期，从而减少不必要的内存分配和垃圾回收。可以在栈上分配，可以在栈帧上创建和销毁，分离对象或标量替换，同步消除。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 2px;border-color: transparent;background-color: rgb(255, 255, 255);padding: 1px;&quot;&gt; 
    &lt;section style=&quot;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;display: inline-block;width: 100%;height: 200px;vertical-align: top;overflow-y: auto;&quot;&gt; 
      &lt;section style=&quot;overflow: hidden;&quot;&gt; 
       &lt;section style=&quot;margin-bottom: 120px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
        &lt;section style=&quot;text-align: justify;&quot;&gt; 
         &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
          &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; TaoYiFenxi {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; obj;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; setObj() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        obj = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; getObject() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; obj1 = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; obj1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; test1() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        synchronized (&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
         &lt;/section&gt; 
        &lt;/section&gt; 
       &lt;/section&gt; 
      &lt;/section&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.6 JVM 垃圾收集器特点与原理&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（1）Serial 垃圾收集器、Serial Old 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014627&quot; data-ratio=&quot;0.5712962962962963&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/04a94627-31bb-4e85-a8a8-5ae052deed2b.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Serial 收集器采用复制算法， 作用在年轻代的一款垃圾收集器，串行运行，执行过程中会 STW，是使用单个线程进行垃圾回收，响应速度优先。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Serial Old 收集器采用标记整理算法，作用在老年代的一款收集器，串行运行，执行过程中会暂停所有用户线程，会 STW，使用单个线程进行垃圾回收，响应速度优先。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用场景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;适合内存小几十兆以内，比较适合简单的服务或者单 CPU 服务，避免了线程交互的开销。&lt;br&gt;&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;优点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;小堆内存且单核 CPU 执行效率高。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;堆内存大，多核 CPU 不适合，回收时长非常长。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（2）Parallel Scavenge 垃圾收集器、Parallel Old 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014628&quot; data-ratio=&quot;0.5722222222222222&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/8cf072c7-a51e-4f76-b268-577b9c499ab2.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Parallel Scavenge 垃圾收集器采用了复制算法，作用在年轻代的一款垃圾收集器，是并行的多线程运行，执行过程中会发生 STW，关注与程序吞吐量。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Parallel Old 垃圾收集器采用标记整理算法，作用，作用在老年代的一款垃圾收集器， 是并行的多线程运行，执行过程中会发生 STW，关注与程序吞吐量。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Parallel Scavenge + Parallel Old 组合是 Java8 当中默认使用的一个组合垃圾回收。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;所谓的吞吐量是 CPU 用于运行用户代码时间与 CPU 总消耗时间的比值，也就是说吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集器时间)， 录入程序运行了 100 分钟，垃圾收集器花费时间 1 分钟&lt;span style=&quot;letter-spacing: 0.034em;&quot;&gt;，则吞吐量达到了 99%。&lt;/span&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用场景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;适用于内存在几个 G 之间，适用于后台计算服务或者不需要太多交互的服务，保证吞吐量的服务。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;优点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;可控吞吐量、保证吞吐量，并行收集。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;回收期间 STW，随着堆内存增大，回收暂停时间增大。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（3）Par New 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Par New 垃圾收集器采用了复制算法，作用在年轻代的一款垃圾收集器， 也是并行多线程运行，跟 Parallel 非常相似，是它的增强版本，或者说是 Serial 收集器的多线程版本，是搭配 CMS 垃圾收集器特制的一个收集器。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;使用场景：&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;搭配 CMS 使用&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（4）CMS 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;CMS 是一款多线程+分段操作的一款垃圾收集器。其最大的优点就是将一次完整的回收过程拆分成多个步骤，并且在执行的某些过程中可以使用户线程可以继续运行，分别有初始标记，并发标记，重新标记，并发清理和并发重置。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014629&quot; data-ratio=&quot;0.5064814814814815&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/fa0a6a57-a712-446f-b037-0153ff732161.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;CMS 是一款多线程+分段操作的一款垃圾收集器。其最大的优点就是将一次完整的回收过程拆分成多个步骤，并且在执行的某些过程中可以使用户线程可以继续运行，分别有初始标记，并发标记，重新标记，并发清理和并发重置。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;CMS 分段&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;初始标记阶段&lt;/strong&gt;， 这个阶段会暂停用户线程， 扫描所有的根对象，因为根对象比较少，所以一般 stw 时间都非常短。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;并发标记阶段&lt;/strong&gt;，这个阶段与用户线程一起执行，会一直沿着根往下扫描，不停的识别对象是否为垃圾，标记，采用了三色算法， 在对象头 (Mark World) 标识了一个颜色属性，不同的颜色代表不同阶段，扫描过程中给与对象一个颜色，记录扫描位置，防止 cpu 时间片切换不需要重新扫描。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;重新标记阶段&lt;/strong&gt;， 这个阶段暂停用户线程， 修正一些漏标对象，回扫发生引用变化的对象。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;并发清理阶段&lt;/strong&gt;， 这个阶段与用户线程一起执行，标记清除已经成为垃圾的对象。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;三色标记&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;黑色&lt;/strong&gt;：代表了自己已经被扫描完毕，并且自己的引用对象也已经确定完毕。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;灰色&lt;/strong&gt;：代表自己已经被扫描完毕了， 但是自己的引用还没标记完。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;白色：则代表还没有被扫描过。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;标记过程结束后，所有未被标记的对象都是不可达的，可以被回收。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014630&quot; data-ratio=&quot;0.725925925925926&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/c4354e81-0441-4f2c-839a-825920ac5e2d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;三色标记算法的&lt;strong&gt;问题场景&lt;/strong&gt;：当业务线程做了对象引用变更，会发生 B 对象不会被扫描，当成垃圾回收。&lt;/p&gt; 
  &lt;section style=&quot;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 2px;border-color: transparent;background-color: rgb(255, 255, 255);padding: 1px;&quot;&gt; 
    &lt;section style=&quot;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;display: inline-block;width: 100%;height: 200px;vertical-align: top;overflow-y: auto;&quot;&gt; 
      &lt;section style=&quot;overflow: hidden;&quot;&gt; 
       &lt;section style=&quot;margin-bottom: 120px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
        &lt;section style=&quot;text-align: justify;&quot;&gt; 
         &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
          &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Demo3&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        R r = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; R();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        B b = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; B();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GCroot 遍历 R， R 为黑色， R 下面的 a 引用链还未扫完置灰灰色，R.b 无引用， 切换时间分片&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a.b = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 业务线程发生了引用改变， 原本 r.a.b 的引用置为 null&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a.b = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 线程回来继续上次扫描，发现 r.a.b 无引用，则认为 b 对象无任何引用清除&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.b = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 回收了 b， 业务线程无法使用 b&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;R&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    B b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    B b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;B&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
         &lt;/section&gt; 
        &lt;/section&gt; 
       &lt;/section&gt; 
      &lt;/section&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014631&quot; data-ratio=&quot;0.45185185185185184&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/c965a3e4-1d3c-41bd-8a87-f1e559362200.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;当 GC 线程标记 A 时，CPU 时间片切换，业务线程进行了对象引用改变，这时候时间片回到了 GC 线程，继续扫描对象 A， 发现 A 没有任何引用，则会将 A 赋值黑色扫描完毕，这样 B 则不会被扫描，会标记 B 是垃圾， 在清理阶段将 B 回收掉，错误的回收正常的对象，发生业务异常。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;CMS 基于这种错误标记的解决方案是采取写屏障 + 增量更新 Incremental Update ， 在业务线程发生对象变化时，重新将 R 标识为灰色，重新扫描一遍，Incremental Update 在特殊场景下还是会产生漏标。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014632&quot; data-ratio=&quot;0.8445378151260504&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/4dce9b78-c6ab-4129-b955-11ce7716fe3d.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;952&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;border-style: solid;border-width: 2px;border-color: transparent;background-color: rgb(255, 255, 255);padding: 1px;&quot;&gt; 
    &lt;section style=&quot;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;display: inline-block;width: 100%;height: 200px;vertical-align: top;overflow-y: auto;&quot;&gt; 
      &lt;section style=&quot;overflow: hidden;&quot;&gt; 
       &lt;section style=&quot;margin-bottom: 120px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
        &lt;section style=&quot;text-align: justify;&quot;&gt; 
         &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
          &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Demo3&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// Incremental Update 还会产生的问题&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        R r = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; R();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        A a = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        A b = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; A();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a1 = a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 线程切换， r 扫完 a1， 但是没有扫完 a2， 还是灰色&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a2 = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 业务线程发生引用切换， r 置灰灰色（本身灰色）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        r.a1 = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// GC 线程继续扫完 a2， R 为黑色， b 对象又漏了~&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;R&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A a1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    A a2;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;A&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
         &lt;/section&gt; 
        &lt;/section&gt; 
       &lt;/section&gt; 
      &lt;/section&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;当 GC 1 线程正在标记 O， 已经标记完 O 的属性 O.1， 准备标记 O.2 时，业务线程把属性 O,1 = B，这时候将 O 对象再次标记成灰色， GC 1 线程切回，将 O.2 线程标记完成，这时候认为 O 已经全部标记完成，O 标记为黑色， B 对象产生了漏标， CMS 针对 Incremental Update 产生的问题，只能在 remark 阶段，暂停所有线程，将这些发生过引用改变过的，重新扫描一遍。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用场景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;适用于互联网或者 B/S 服务， 响应速度优先，适合 6G 左右。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;优点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;并发收集， 低停顿，回收过程中最耗时的是并发标记和并发清除，它都能与用户线程保持一起工作。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;收集器对 CPU 的资源非常敏感，会占用用户线程部分使用，导致程序会变得缓慢，吞吐量下降。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;无法处理浮动垃圾，在并发清理阶段用户线程还是在运行，这时候产生的新垃圾无法在这次当中处理，只有等待下次才会清理。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;因为 CMS 使用了 Incremental Update，remark 阶段还是会所有暂停，重新扫描发生引用改变的 GC root，效率慢耗时高。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;因为收集器是基于标记清除算法实现的，所以在收集器回收结束后，内存会产生碎片化，当碎片化非常严重的时候，这时候有大对象进入无法分配内存时会触发 FullGC，特殊场景下会使用 Serial 收集器，导致停顿不可控。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;（5）G1 垃圾收集器&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 也是采用三色标记分段式进行回收的算法， 不过它是写屏障 + STAB 快照实现，G1 设定的目标是在延迟可控（低暂停）的情况下获得尽可能高的吞吐量，仍然可以通过并发的方式让 Java 程序继续运行，G1 垃圾收集器在很多方面弥补了 CMS 的不足，比如 CMS 使用的是 mark-sweep 标记清除算法，自然会产生内存碎片 (CMS 只能在 Full GC 时，STW 整理内存碎片)，然而 G1 整体来看是基于标记整理算法实现的收集器，但是从局部来看也是基于复制算法实现的，高效的整理剩余内存，而不需要管理内存碎片它。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 同样有年轻代和老年代的概念，只不过物理空间划分已经不存在，逻辑分区还存在，G1 会把堆切成若干份，每一份当作一个目标，在部分上目标很容易达成，G1 在进行垃圾回收的时候，将会根据最大停顿时间设置值动态选取部分小堆区垃圾回收。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014633&quot; data-ratio=&quot;0.6731481481481482&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/3baad622-5f9e-4052-8a43-43203fcb039b.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 的特点是尽量追求吞吐量，追求响应时间，并发收集，压缩空闲空间不会延长 GC 暂停时间，更容易预测 GC 暂停时间，能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU 对 STW 进行控制 (200ms 以内) 灵活的分区回收，优先回收花费时间少的或者垃圾比例高的 region 新老比例也是动态调整，不需要配置；年龄晋升也是 15，但是可以动态年龄，当幸存者 region 超过了 50 时，会把年龄最大的放入老年代。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 动态 Y 区域设置，G1 每个分区都可能是年轻代或者老年代，但是同一时刻只属于一个代，分代概念还存在，逻辑上分代方便复用以前分代逻辑，在物理上不需要连续，这样能带来额外好处，有的分区内垃圾比较多，有的分区比较少，G1 会优先回收垃圾比较多的分区，这样可以花费少量的时间来回收这些分区垃圾，即收集最多垃圾分区；但是新生代回收不适合这种，新生代达到阈值时发生 YGC，对整个新生代进行回收或者晋升幸存，新生代也分区是方便动态调整分区大小，在进行垃圾回收时，会将存活对象拷贝到另一个可用分区上，这样也能避免一定程度的内存碎片化过程，每个分区的大小都是在 1M- 32M 之间，取决 2 的幂次方。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;Humingous&lt;/strong&gt;：如果一个对象占用的空间超过了分区容量 50% 以上，G1 收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响；为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放巨型对象。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;CardTable&lt;/strong&gt;：记录每一块 card 内存区域是否 dirty，如果在发生 YGC 时，怎么知道那些是存活对象，并且其它代区域有没有引用这部分对象，于是把内存划分了很多 card 区域， 每个区域大小不超过 512b，当该 card 区域里的对象有引用关系，将当前 card 置为「dirty」， 并且使用卡表（CardTable）来记录每一块 card 是否 dirty，在进行 GC 时，不用遍历所有的空间， 只需要遍历卡表中为&quot;dirty&quot;或者说布尔符合条件的 card 区域进行回扫。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014634&quot; data-ratio=&quot;0.6703703703703704&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/317b89d9-596b-458e-ba5d-b9c955eb7575.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;CSet&lt;/strong&gt;：Collection SET 用于记录可被回收分区的集合组， G1 使用不同算法，动态的计算出那些分区是需要被回收的，将其放到 CSet 中，在 CSet 当中存活的数据都会在 GC 过程中拷贝到另一个可用分区，CSet 可以是所有类型分区，它需要额外占用内存，堆空间的 1%。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;RSet&lt;/strong&gt;：RememberedSet 每个 Region 都有一个 Rset，是一个记录了其他 Region 中的对象到本身 Region 的引用，它可以使得垃圾收集器不需要扫描整个堆去找到谁的引用了当前分区对象，是 G1 高效回收的关键点，也是三色算法的一个以来点。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014635&quot; data-ratio=&quot;0.2824074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/a1cb4f90-eef7-4393-9c20-eb6badbc354e.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;RSet 和卡表的区别是什么？&lt;/strong&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;p&gt;卡表记录的是堆内存中 card 有没有变成&quot;dirty&quot;， 但是它本身不知道 dirty 里面哪些是引用了的对象，它是一个大维度的一个记录，RSet 是记录自身 Region 中对象引用了其它 Region 中的那些对象，详细的记录对方引用对象信息，G1 使用了两者的结合，实现了增量式的垃圾回收，并优化跨区引用的最终处理。&lt;/p&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;strong&gt;SATB 算法&lt;/strong&gt;：是一种基于快照的算法，它可以避免在垃圾回收时出现对象漏标或者重复标记的问题，从而提高垃圾回收的准确性和效率，在垃圾回收开始时，对堆中的对象引用进行快照，然后在并发标记阶段中记录下所有被修改过对象引用，保存到 satb_mark_queue 中，最后在重新标记阶段重新扫描这些对象，标记所有被修改的对象，保证了准确性和效率。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;SATB 算法在 remark 阶段不需要暂停遍历整个堆对象，只需要扫描「satb_mark_queue」队列中的记录，避免了这个阶段长耗时，而 cms 的增量算法在这个阶段是需要重新扫描 GC Roots 标记整个堆对象，导致了不可控时间暂停，总的来说 G1 是通过回收领域应用并行化策略，将原来的几块大内存块回收问题，演变成了 N 个小内存块回收，使得回收效率可以高度并行化，停顿时间可控，可以与用户线程并发执行，将一块内存分而治之。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014636&quot; data-ratio=&quot;0.35462962962962963&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/7545f663-b201-495f-9cf2-b522f1c96976.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;G1 默认当分区内存占用阈值达到总内存的 45%，会发生 Mixed gc（混和 GC），YoungGC + 并发回收 Mixed GC 过程：初始标记（stw）、并发标记、最终标记 (重新标记 stw)、筛选回收（stw 并行）。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;使用场景：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;响应速度优先，较高的吞吐量，面向服务端，使用内存 6G 以上。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;优点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;并行与并发收集，分代分区收集，优先垃圾收集，空间整合，可控或者可预测停顿时间。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;缺点：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;收集中产生内存，G1 的每个 region 都需要有一份记忆集和卡表记录跨代指针，这导致记忆集可能占用堆空间 10-20% 甚至更多空间。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;执行过程中额外负载开销加大，写屏障进行维护卡表操作外，还需要原始快照能够减少并发标记和重新标记阶段的消耗，避免最终标记阶段停顿过长，运行过程中会产生由跟踪引用变化带来的额外开销负担，比 CMS 增量算法消耗更多，CMS 的写屏障实现直接是同步操作， 而 G1 是把写屏障和写后屏障中要做的事情放到队列里异步处理。&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;G1 对于 Full GC 是没有处理流程， 一旦发生 Full GC G1 的回收执行的是单线程的 Serial 回收器进行回收。&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.2.7 垃圾收集器配置使用&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;机器配置：64 位 4C8G&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;Java 程序使用 CMS 收集器进行内存垃圾回收初始内存划分情况：&lt;/p&gt; 
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-Xms4096M&amp;nbsp;-Xmx4096M&amp;nbsp;-XX:+HeapDumpOnOutOfMemoryError&amp;nbsp;-XX:HeapDumpPath=&lt;span class=&quot;code-snippet__regexp&quot;&gt;/data/&lt;/span&gt;{runuser}/logs/other&amp;nbsp;-XX:+UseConcMarkSweepGC&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014637&quot; data-ratio=&quot;0.5889967637540453&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/9ca62bea-63ea-499e-b9e7-0d0f7a002676.png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;span style=&quot;letter-spacing: 0.034em;&quot;&gt;CMS 跟 parNew 占比情况， 默认下 ParNew 占用整个堆的空间为：机器位数 * CPU 核数 * 13 /10 ， 当前机器配置计算得出 64 * 4 * 13 / 10 = 332M ， 与图上数值差别不大。&lt;/span&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Java 程序使用 G1 收集器进行内存垃圾回收初始内存划分情况：&lt;/p&gt; 
   &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt; 
    &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-Xms4096M&amp;nbsp;-Xmx4096M&amp;nbsp;-XX:+HeapDumpOnOutOfMemoryError&amp;nbsp;-XX:HeapDumpPath=&lt;span class=&quot;code-snippet__regexp&quot;&gt;/data/&lt;/span&gt;{runuser}/logs/other&amp;nbsp;-XX:+UseG1GC&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
   &lt;/section&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014638&quot; data-ratio=&quot;0.5726495726495726&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/f87fe847-d5a8-4609-b631-234fab58b8c7.png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;G1 新老年代的占比是动态调整， 随着运行时根据实际情况划分空间。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;Java8 默认 ParallerGC 收集器初始内存划分情况：&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014639&quot; data-ratio=&quot;0.5694591728525981&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/b3a135dc-2a00-4a54-acd4-c3600b573ab9.png&quot; data-type=&quot;png&quot; data-w=&quot;943&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;parallel GC 回收器默认堆 old 区与 young 区内存大小比例 2：1， 图上数值差别不大。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;三、内存诊断实践&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;3.1 内存快照生成&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;当发生线上应用告警，告警相关内存故障问题时， 应当如何进行故障排查呢？首先应用在发生内存溢出无法执行时，应 DUMP 当前内存快照，需要在 Java 程序执行启动命令时添加上：&lt;/p&gt; 
  &lt;section style=&quot;margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;-XX:+HeapDumpOnOutOfMemoryError&amp;nbsp;&lt;/p&gt; 
     &lt;p style=&quot;text-wrap: wrap;&quot;&gt;-XX:HeapDumpPath=${filePath} 参数&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&amp;nbsp;当发生时自动生成一份当前内存快照，方便与开发人员使用快照文件进行问题诊断分析。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;在 Java 应用运行时，想手动生成内存快照，可以使用 JDK 自带几个问题排查工具，可以使用 jmap 工具生成指定 PID 内存快照，不过需要耗费较长的一个时间，会暂停应用程序执行，使用 jcmd 工具可以快速的 DUMP 内存快照，因为在堆转储存文件过程中，jcmd 可以利用虚拟机中的一些优化技术，例如分代堆、增量式垃圾回收等技术，相比传统的 jmap 效率高很多，一般来说在 DUMP 内存前会进行一次&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;Full FC，可以指定屏蔽这次 Full GC，保留当前所有内存中的对象。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;除了自带的内存诊断工具， 也可以使用 Arthas 诊断工具，提供了多个命令来帮助诊断内存问题，例如 dashboard（当前 Java 程序内存实时数据面板）、JVM（查看当前 JVM 信息，包括使用的 gc 收集器、内存分区分布情况等信息）、heapdump（当前内存快照类似 jmap 命令的 heap dump）、memory（当前内存分区及占用情况）、monitor（监控模式，可监控内存及查看对象占用情况）profiler（火焰图可以输出多种火焰图，内存分区占用火焰图）等相关内存命令。这些命令可以帮助获取应用程序的内存快照、堆内存使用情况等信息，能快速定位内存问题。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;引用：&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farthas.aliyun.com%2Fdoc%2Fcommands.html&quot; textvalue=&quot;Arthas 命令列表&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Arthas 命令列表&lt;/a&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(65, 95, 255);&quot;&gt;3.2 dump 内存快照分析&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;（1）jhat 是 Java 开发工具包自带的一款堆内存分析工具，它可以帮助解决 Java 应用程序的内存问题。Jhat 可以读取 Java 应用程序生成的堆转储文件，并以 HTML 格式展示内存中的对象信息和引用关系，支持 OQL 查询和灵活的过滤和排序功能。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;用例&amp;nbsp;&lt;span style=&quot;background-color: rgb(214, 214, 214);&quot;&gt; jhat E:\diydump\Java_pid2680.hprof&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014640&quot; data-ratio=&quot;0.597&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/ed38fad9-e21f-4c52-b7db-b83e26d1ef28.jpg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: left;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;All classes including platform&lt;/strong&gt;：列举应用程序中所有类的信息，并快速定位内存问题。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;Show all members of the rootset&lt;/strong&gt;：显示堆内存中所有根对象的信息，包括系统对象、静态对象、本地对象等。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;Show instance counts for all classes (including platform)&lt;/strong&gt;：显示所有类的实例数量。&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p&gt;&lt;strong&gt;Show heap histogram&lt;/strong&gt;：显示程序堆内存的直方图，可以知道每个类的实例数量和占用内存大小等信息，快速知道内存泄漏原因。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;（2）jvisualvm 也是 Java 开发工具包里自带的一款图形化工具，可以用于监控和诊断 Java 应用程序的性能问题。使用它可以实时查看 Java 应用程序的内存使用情况、CPU 使用情况、线程情况等，并可以进行内存分析、CPU 分析、线程分析等内容。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;以 Java_pid2680.hprof 为例，进行内存分析内存泄漏原因：&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014641&quot; data-ratio=&quot;0.4685185185185185&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/cecd7993-3d90-45ea-9aec-eb5bbc6a811b.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;（3）MAT 是基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java 内存分析工具，能够快速的分析出 dump 文件中各项结果，快速给出内存泄漏原因报告。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;还是以 Java_pid2680.hprof 文件进行分析，比原生的 jhat 方便很多，功能也比原生的更加丰富：&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014642&quot; data-ratio=&quot;0.5074074074074074&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/f7caef82-cb1c-4a39-9ee8-103c551796d8.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;MAT 的一些常用功能点介绍（如图所示）：&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;margin-bottom: -2.25em;margin-right: 5px;background-color: rgb(247, 247, 247);&quot;&gt; 
    &lt;section style=&quot;padding: 10px;margin-bottom: 5px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;text-align: center;&quot;&gt; 
      &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;list-style-type: disc;&quot;&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;Overview &lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;text-align: center;&quot;&gt;标签内容有比较多块内容，其中 details 末块介绍总共使用内存大小，类的数量，实例的数量，类的加载器，以及实例的内存直方图；&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;Biggest Objects by Retained Size&lt;/strong&gt;模块，使用了饼状图列出了当前内存中占用最大的几个对象，按照百分比划分，点击不同的饼状块能够看到具体对象及其对象属性等信息；&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;actions&lt;/strong&gt;模块，这里拥有不同的分析功能，Histogram 生成视图列出每个类所对应的对象个数以及占用内存大小，Dominator Tree 生成视图寻找出大对象，每个实例对象的内存占比比重；&lt;/p&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;p style=&quot;text-align: left;&quot;&gt;&lt;strong&gt;Reports&lt;/strong&gt;模块是生成报告，其中 Leak Suspects 可以自动分析内存泄漏主要原因报告，可以通过报告准确定位泄漏原因或者可能造成泄漏的原因，并且可以定位到具体累积实例，线程 stack 等信息。&lt;/p&gt;&lt;/li&gt; 
      &lt;/ul&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;margin-left: auto;width: 2.25em;height: 2.25em;border-right: 5px solid transparent;border-bottom: 5px solid transparent;&quot;&gt; 
    &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;例子中：leak Suspects 报告给出「0xfe3be480」 非常多内存， Gc root Thread 所引用，在发生 gc 时，不是可回收对象，无法回收内存，导致内存溢出。&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-imgfileid=&quot;100014643&quot; data-ratio=&quot;0.4861111111111111&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/df138f30-3373-4dfb-a6d2-95dba48cdf83.png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; style=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: center;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);&quot;&gt; 
    &lt;p&gt;四、总结&lt;/p&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;本文介绍了 Java 程序中的内存模型，内存模型划分多份内存区域，不同区域的作用介绍及不同区域的线程之间的内存共享范围，可以帮助开发人员更加理解 Java 中内存管理的机制和原理。&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;&lt;br&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-wrap: wrap;&quot;&gt;堆是内存模型中最大的一块内存区域，以堆的空间划分详细的介绍了内存分代，部分垃圾收集器即是物理分代和逻辑分代，G1 收集器则物理不分代逻辑保留了以前分代，讲述了不同收集器的原理实现和优缺点，可以根据项目的业务属性，机器配置等因素选择最优的收集器，帮助程序使用最优的收集器可以使得程序的吞吐量和响应速度达到最佳状态。还讲述了不同的参数调优收集器，并且当发生了程序内存溢出崩溃，如何进行内存分析，介绍不同工具的使用，快速定位内存溢出的罪魁祸首，从而在代码层面上根本解决这类问题。&lt;/p&gt; 
  &lt;/section&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-wrap: wrap;&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;br&gt;&lt;/p&gt; 
  &lt;section style=&quot;margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;margin-top: 0.5em;margin-bottom: 0.5em;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;border-top: 1px dotted rgb(90, 98, 114);&quot;&gt; 
      &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;text-align: center;color: rgb(45, 66, 87);font-size: 11px;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;p&gt;END&lt;/p&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;&quot;&gt; 
    &lt;section style=&quot;margin-top: 0.5em;margin-bottom: 0.5em;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;section style=&quot;border-top: 1px dotted rgb(90, 98, 114);&quot;&gt; 
      &lt;svg viewBox=&quot;0 0 1 1&quot; style=&quot;float:left;line-height:0;width:0;vertical-align:top;&quot;&gt;&lt;/svg&gt; 
     &lt;/section&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
  &lt;section style=&quot;margin-top: 10px;margin-bottom: 10px;text-align: left;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
   &lt;section style=&quot;padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;&quot;&gt; 
    &lt;span style=&quot;display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);&quot; title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:234.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;&quot;&gt; 
    &lt;section style=&quot;font-size: 14px;text-align: left;&quot; powered-by=&quot;xiumi.us&quot;&gt; 
     &lt;ul class=&quot;list-paddingleft-1&quot; style=&quot;padding-left: 40px;list-style-position: outside;&quot;&gt; 
      &lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247498348%26idx%3D1%26sn%3Da070a524928c6d312a56ead073e14a7c%26chksm%3Debdb8afedcac03e89c1a233dc19e01b468331219eaad321cb6346c0f73a2c06135503e6a83a6%26scene%3D21%23wechat_redirect&quot; textvalue=&quot;vivo 统一接入网关 VUA 转发性能优化实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;vivo 统一接入网关 VUA 转发性能优化实践&lt;/a&gt;&lt;/p&gt;&lt;/li&gt; 
      &lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247498342%26idx%3D1%26sn%3Db314e59b249a74cd76464d16895d8696%26chksm%3Debdb8af4dcac03e2defb1d7339379dadf13f2597f924f5c974e1083c668c971016d199fb1d07%26scene%3D21%23wechat_redirect&quot; textvalue=&quot;Sharding-JDBC 源码解析与 vivo 的定制开发&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Sharding-JDBC 源码解析与 vivo 的定制开发&lt;/a&gt;&lt;/p&gt;&lt;/li&gt; 
      &lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247498320%26idx%3D1%26sn%3Dc0180b1567a8b362c3c23c51528dfb7d%26chksm%3Debdb8ac2dcac03d4a3113cf75191bbf134746649184986b161fc521f4e340e1753ad6afbf744%26scene%3D21%23wechat_redirect&quot; textvalue=&quot;vivo 在离线混部探索与实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;vivo 在离线混部探索与实践&lt;/a&gt;&lt;/p&gt;&lt;/li&gt; 
     &lt;/ul&gt; 
    &lt;/section&gt; 
   &lt;/section&gt; 
  &lt;/section&gt; 
 &lt;/section&gt; 
 &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt; 
  &lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo 互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;&gt;&lt;/mp-common-profile&gt; 
 &lt;/section&gt; 
 &lt;p style=&quot;display: none;&quot;&gt; 
  &lt;mp-style-type data-value=&quot;3&quot;&gt;&lt;/mp-style-type&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color: #858585; font-size: 13px;&quot;&gt;本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。&lt;br&gt;如有侵权，请联系 support@oschina.cn 删除。&lt;br&gt;本文参与「&lt;a href=&quot;https://www.oschina.net/sharing-plan&quot; target=&quot;_blank&quot;&gt;OSC 源创计划&lt;/a&gt;」，欢迎正在阅读的你也加入，一起分享。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://my.oschina.net/vivotech/blog/11048619</link>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/11048619</guid>
            <pubDate>Wed, 27 Mar 2024 01:51:40 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>大数据应用场景落地实践</title>
            <description></description>
            <link>https://www.oschina.net/event/2331846</link>
            <guid isPermaLink="false">https://www.oschina.net/event/2331846</guid>
            <pubDate>Tue, 26 Mar 2024 09:29:17 GMT</pubDate>
        </item>
        <item>
            <title>mybatis-mp - 亮点八：mybatis-xml returnType 的 ORM 映射</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;strong&gt;mybatis-mp - 亮点八:&amp;nbsp; 可对 xml 实体类返回，进行自动映射：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;当你需要写一个很复杂的 sql 时，你可能会选择用 xml 去做例如：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;findUserList&quot; returnType=&quot;User&quot;&amp;gt;

&amp;nbsp; &amp;nbsp; &amp;nbsp; select id,user_name as userName,nick_name as nickName,password from user where xx and xx2 and xx3 ........

&amp;lt;/select&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style=&quot;color:#e74c3c&quot;&gt;如上：你可能需要自己，一个一个 as userName , as nickName 之类的，是不是很麻烦&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;现在好，只要接入 mybatis-mp；这些完全不用写了，如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;findUserList&quot; returnType=&quot;User&quot;&amp;gt;

&amp;nbsp; &amp;nbsp; &amp;nbsp; select id,user_name,nick_name,password from user where xx and xx2 and xx3 ........

&amp;lt;/select&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;自动帮你进行了映射，而且不仅仅支持实体，还支持 VO；省去了很多麻烦步骤！&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284803</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284803</guid>
            <pubDate>Tue, 26 Mar 2024 06:44:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>Ubuntu LTS 支持延长至 12 年</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Canonical &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fubuntu.com%2F%2Fblog%2Fcanonical-expands-long-term-support-to-12-years-starting-with-ubuntu-14-04-lts&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;全面推出 Legacy Support —— 一个 Ubuntu Pro 插件，可将 Ubuntu LTS 版本的安全性和支持范围扩大到 12 年。适用于 Ubuntu 14.04 LTS 及以上版本。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;312&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2a2eb37bed9123652265f19a8da71c4a8b3.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此前，Ubuntu 的 LTS 版本一般将获得 5 年的安全更新、错误修复和精选应用程序更新。Ubuntu Pro 则会在此基础上额外增加 5 年的安全保障，为现代的 LTS 版本提供长达十年的支持。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;通过此次推出的 Legacy Support 插件，Ubuntu Pro 用户将可以在原有的基础上，额外再两年的安全维护和支持。这意味着，Ubuntu 14.04 LTS 及以上版本的 LTS 从发布之日起将可获得长达 12 年的支持期。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Canonical 支持工程全球副总裁 Maximilian Morgan 称，「我们很高兴能为客户提供额外几年的 Ubuntu LTS 版本安全维护和支持......通过 Legacy Support，我们使企业能够满怀信心地引导其运营需求和对开源的投资，确保他们的系统在未来许多年内保持可用、安全和支持。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;这意味着原定于今年 4 月结束支持的 Ubuntu 14.04 LTS &quot;Trusty Tahr&quot; 将推迟至 2026 年 4 月，从而为 IT 人员预留了更多的时间来计划和准备升级到更新的版本。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284787/ubuntu-lts-12-years</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284787/ubuntu-lts-12-years</guid>
            <pubDate>Tue, 26 Mar 2024 06:21:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Ugly avatar —— 丑头像生成器</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;Ugly avatar 是生成丑头像的在线工具。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-c1df4ccc6fa20c1982e151f5404498a50a0.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

&lt;p&gt;体验地址：&lt;a href=&quot;https://txstc55.github.io/ugly-avatar/&quot;&gt;https://txstc55.github.io/ugly-avatar/&lt;/a&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/ugly-avatar</link>
            <guid isPermaLink="false">https://www.oschina.net/p/ugly-avatar</guid>
            <pubDate>Tue, 26 Mar 2024 04:21:50 GMT</pubDate>
        </item>
        <item>
            <title>Windows 格式化对话框是一个使用了 30 年的「临时解决方案」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;戴夫-普卢默（Dave Plummer）是微软的资深工程师，曾创造了任务管理器、Windows 弹球、原生 ZIP 支持（微软出钱买断该功能后，他用这笔钱购买了一辆红色克尔维特）等传奇，近日他在自己的 X 账户上分享了创建&quot;格式化&quot;对话框的故事——称其是一个使用了长达 30 年的「临时解决方案」。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-5518f52befb96158f97eb7d1b4e287baa1a.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fdavepl1968%2Fstatus%2F1772042158046146792&quot; target=&quot;_blank&quot;&gt;https://twitter.com/davepl1968/status/1772042158046146792&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;故事还要追溯到 1994 年，当时 Dave 和其他软件工程师们正忙于将&quot;海量的代码&quot;从 Windows 95 迁移到 Windows NT 系统上。由于后者引入了许多改动，格式化对话框的界面也亟待重新设计。&lt;/p&gt; 
&lt;p&gt;Dave 拿起纸笔，列出了一些必要的功能，并使用 VC++ 2.0 的资源编辑器快速搭建了一个简单的纵向列表界面。选择垂直布局是为了让用户可以按照大致正确的顺序勾选所有选项。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-94c12885f8f91ab589c030879f7914d81f2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Dave 表示，&lt;strong&gt;这个设计的初衷并不是为了美观，仅仅是为了在「更优雅的界面」到来之前先用着&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;然而让人没想到的是，这个「临时解决方案」一用就是 30 年。即使是最新版本的 Windows 11 预览版，在格式化对话框仍然维持着当年的样式，没有任何升级的迹象。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-db2b723d3944610ef606bc557efc549a365.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Dave 还提到，「30 年前我做的那个星期四上午做出来的临时方案，现在还在使用！」他还感慨：「在开发软件时，可要当心‘临时’这两个字眼儿啊！」&lt;/p&gt; 
&lt;p&gt;此外，Dave 当初还凭直觉决定了 cluster slack 大小的限制，这直接导致了 FAT 卷的格式化最大容量为 32GB。同样，这也是一个当初的临时决定，却意外地变成了至今仍在使用的永久限制。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284757</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284757</guid>
            <pubDate>Tue, 26 Mar 2024 04:01:50 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>开源日报 | AI 手机需要新故事；做了十几年的操作系统和 AI 应用，跨界到机器人领域；VitePress 1.0；苹果曾试图为安卓开发手表</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;欢迎阅读 OSCHINA 编辑部出品的开源日报，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#e67e22&quot;&gt;&lt;strong&gt;# 2024.3.25&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日要点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;OpenSource Daily&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284627/vitepress-1-0-released&quot; target=&quot;_blank&quot;&gt;尤雨溪宣布推出 VitePress 1.0&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;尤雨溪宣布正式发布 VitePress 1.0 版本，并声称其 「基于 Vite 和 Vue 构建，是 VuePress 的精神继承者和现代替代品。」&lt;/p&gt; 
&lt;p&gt;VitePress 是一个静态站点生成器 (SSG)，专为构建快速、以内容为中心的站点而设计。简而言之，VitePress 获取用 Markdown 编写的内容，对其应用主题，并生成可以轻松部署到任何地方的静态 HTML 页面。&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/284652/fydeos-18-released&quot; target=&quot;_blank&quot;&gt;FydeOS v18 发布，控制中心重构，虚拟桌面、剪贴板、文件搜索全面升级&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;-虚拟桌面：改进了虚拟桌面功能，通过底部快捷按钮实现工作空间快速切换，以提升任务管理效率。&lt;br&gt; -控制中心重构：采用最新的 Material Design 美学全面优化了控制中心界面和操作逻辑。&lt;br&gt; -剪切板升级：增强剪切板功能，支持快捷键「Windows 键 + V / Command + V」访问历史记录，简化内容管理。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-31e5336fef60aeba4e748aa77d18d5cb244.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span style=&quot;color:#16a085&quot;&gt;今日观察&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-2a0ccdb00566a9d3ad038133136b3eee31f.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微信&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIyNDA0MjM4MA%3D%3D%26mid%3D2649518102%26idx%3D1%26sn%3Dea853ae3d1d4c6030b500ae21ab60820%26chksm%3Df00ddcf5c77a55e32cf5a221d62419c93280d09709c43ba15b6aa24c3575cf7390efeb8f3b8f&quot; target=&quot;_blank&quot;&gt;夜半谈&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-1bf927795554e535d08fdbf09793ae8f502.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微博&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F2421203193%2FO69YioUgh&quot; target=&quot;_blank&quot;&gt;生活芯科技&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-b0e3bd1ad453972eab42ea2a8ada18f9ae2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;- 微博&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1815369323%2FO6BYglY0I&quot; target=&quot;_blank&quot;&gt;乔忠良&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;今日推荐&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-3d80e5f9c5a5082466f21b598d417a6e509.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpassbolt%2Fpassbolt_api&quot; target=&quot;_blank&quot;&gt;https://github.com/passbolt/passbolt_api&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;事件点评&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-40301b39e04e7b4b0352352c9a25dc340a5.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;每日项目榜&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;每日 GitHub 精选&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-d0d1da6a4c6c9ec4dceb1e7f059577deb75.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#e67e22&quot;&gt;在线阅读完整日报内容，访问：&lt;/span&gt;&lt;/strong&gt;&lt;br&gt; &lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://report.oschina.net/api/files/jhim80u9qm1ofsw/ojkci7trx2o8oun/36_ai_ai_vite_press_1_0_BYIu9kQwRD.pdf&quot; target=&quot;_blank&quot;&gt;开源日报第 035 期：AI 手机需要新故事；做了十几年的操作系统和 AI 应用，跨界到机器人领域；VitePress 1.0；苹果曾试图为安卓开发手表&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/h4&gt; 
&lt;/blockquote&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;欢迎扫码下载「开源中国 APP」&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;strong&gt;随时在线阅读完整日报内容 ↓&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7871d27245192b8ecfcd21043d309382749.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;889&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-842e51ced6d226559af1af95c8041338cb2.gif&quot; width=&quot;400&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284752</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284752</guid>
            <pubDate>Tue, 26 Mar 2024 03:38:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Redict：Redis 的一个独立的 Copyleft 分支</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Redict 是由开发者 Drew DeVault 推出的一个&amp;nbsp;Redis OSS 7.2.4.2 的独立、非商业性的分叉。基于 Redis OSS 的 BSD 3-Clause 源代码，自此之后的所有更改均采用 Lesser&amp;nbsp;GNU General Public license（LGPL-3.0-only）。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;296&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-c9a0f9b14c09863d0ed266a9efd6915d926.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在许可证的选择上，Drew DeVault 解释称，LGPL 是经过深思熟虑且平衡了多方面的考量之后的选择，是&lt;span style=&quot;color:#000000&quot;&gt;最适合 Redict 的许可证&lt;/span&gt;。最重要的是，这是一个不可撤销的承诺，即 Redict 将永远是免费的。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;「这比 RedisLabs 联合创始人、前首席执行官 Yiftach 在 2018 年做出的承诺要有力得多。通过使用 Copyleft 许可证，Redict 的所有更改都必须使用相同的 LGPL 自由软件许可证发布，从而保证软件的修改版本将是免费的。」&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;此外，他保证 Redict 将不会使用任何形式的贡献者许可协议。Redict 的版权由所有贡献者共同拥有，Redict 许可证的变更将需要取得所有贡献者的同意。从而使得 Redict 未来几乎不可能出现类似 &lt;span style=&quot;color:#000000&quot;&gt;Redis&amp;nbsp;&lt;/span&gt;的许可证变更。&lt;/p&gt; 
&lt;p&gt;Drew DeVault 补充道，没有选择常用的&amp;nbsp;AGPL 或&amp;nbsp;EUPL 许可的原因在于，「我们希望让用户尽可能轻松地遵守 Redict 许可证，而且我们认为没有任何理由阻止云厂商使用 Redict。」&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;选择 LGPL 而不是 GPL，则是为了减少与 Redis 兼容模块或 Lua 插件的集成会受到 GNU GPL 的「病毒式传播」影响的担忧。选择 LGPL 既能保护 Redict 项目的未来，又能在这些问题之间取得最佳平衡。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;到目前为止，项目面向用户的变更包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;可执行文件已重命名为 redict-*，例如 redict-cli。&lt;/li&gt; 
 &lt;li&gt;Lua API 提供了与 Redis OSS API 兼容的「redict」 global，可通过「redis」 global 实现向后兼容。&lt;/li&gt; 
 &lt;li&gt;Module API symbols 已重命名，但是，Redict 保留了与 Redis OSS 模块（最高版本 7.2.4）的 ABI 兼容性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Redict 旨在作为 Redis OSS 7.2.4 的直接替代品。接下来，Redict 的目的是继续开发 Redis OSS 兼容软件的自由软件发行版，暂时只进行最小程度的破坏性更改。目前正在围绕以下变更进行讨论：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;利用这个机会删除一些长期弃用的功能，例如「redis-trib」&lt;/li&gt; 
 &lt;li&gt;消除供应商依赖并转向上游 Lua、jemalloc&lt;/li&gt; 
 &lt;li&gt;减轻与下游的关联性，删除例如 systemd 或 upstart 服务&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;以及计划分叉 Redict 的内部依赖项&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fredis%2Fhiredis&quot; target=&quot;_blank&quot;&gt;Hiredis&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;更多详情可&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fredict.io%2Fposts%2F2024-03-22-redict-is-an-independent-fork%2F&quot; target=&quot;_blank&quot;&gt;查看官方公告&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:start&quot;&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style=&quot;text-align:start&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/284082/redis-adopts-dual-source-available-licensing&quot; target=&quot;news&quot;&gt;Redis 不再「开源」，未来采用 SSPLv1 和 RSALv2 许可证&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284749/redict-independent-fork-redis</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284749/redict-independent-fork-redis</guid>
            <pubDate>Tue, 26 Mar 2024 03:28:35 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>工信部拟规范工业机器人行业管理</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;工业和信息化部装备工业一司公开征求对工业机器人行业规范条件及管理实施办法（征求意见稿）的意见，征集截止日期为 2024 年 4 月 10 日。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「为落实《「十四五」机器人产业发展规划》，进一步规范工业机器人行业管理，营造良好市场环境，我们对 2016 年以来发布的《工业机器人行业规范条件》和《工业机器人行业规范管理实施办法》进行了修订，形成了《工业机器人行业规范条件（2024 版）》（征求意见稿）和《工业机器人行业规范管理实施办法（2024 版）》（征求意见稿），现向社会公开征求意见。」&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height=&quot;332&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-0e0aa12963d2a68db6da214d7f97bc61c59.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;《工业机器人行业规范条件（2024 版）》（征求意见稿）要求，依据国家法律法规设立，符合机器人产业发展政策要求，具有独立法人资格，取得企业法人营业执照，且从事工业机器人相关业务时间不少于三年。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;同时，近三年，关键零部件制造企业营业收入年均不小于 3000 万元；本体制造企业营业收入年均不小于 5000 万元；集成应用企业营业收入年均不小于 1 亿元。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;上年度营业收入小于 5000 万元（含）的企业，近三年每年研发经费投入不低于营业收入的 5%；上年度营业收入在 5000 万元至 2 亿元（含）的企业，近三年每年研发经费投入不低于营业收入的 4%；上年度营业收入在 2 亿元以上的企业，近三年每年研发经费投入不低于营业收入的 3%。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284737</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284737</guid>
            <pubDate>Tue, 26 Mar 2024 02:46:42 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>开源图形编辑器 Inkscape 底层 UI 框架改用 GTK4</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;矢量图形编辑器 Inkscape 开发分支的最新上游代码已迁移至使用 GTK4，这是一次重大升级，同时也改进了架构，并为将来实现 GPU 加速做好了准备。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-8eae6c1e1874b541787e9278fd14b3a3d96.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;u&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmastodon.art%2F%40inkscape%2F112151266538190571&quot; target=&quot;_blank&quot;&gt;https://mastodon.art/@inkscape/112151266538190571&lt;/a&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Inkscape 通过其 Mastodon 账户宣布了向 GTK4 过渡的消息。由于各种问题，尤其是在 macOS 和 Windows 上的问题，下一个稳定版本（v1.4）仍将使用 GTK3。其开发团队表示他们正在解决 Windows/MacOS 上的这些问题，希望 GTK4 版本的 Inkscape 在后续更新中有更好的表现。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-346fb9083f0607d9c44eb938ccec6b143cb.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/284729/inkscape-switches-to-gtk4</link>
            <guid isPermaLink="false">https://www.oschina.net/news/284729/inkscape-switches-to-gtk4</guid>
            <pubDate>Tue, 26 Mar 2024 02:16:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>nvitop —— GPU 进程管理的一站式解决方案</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;nvitop 是一种交互式 NVIDIA 设备和进程监控工具。它有一个丰富多彩的信息界面，可以不断更新设备和进程的状态。作为资源监控器，它包含许多功能和选项，例如树视图、环境变量查看、进程过滤、进程指标监控等。除此之外，该软件包还为深度学习研究人员提供了 CUDA 设备选择工具&lt;a href=&quot;https://github.com/XuehaiPan/nvitop#cuda-visible-devices-selection-tool&quot;&gt;&lt;code&gt;nvisel&lt;/code&gt;&lt;/a&gt;。它还提供方便的 API，允许开发人员编写自己的监控工具。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;320&quot; src=&quot;https://static.oschina.net/uploads/space/2023/0322/154814_iQnD_4252687.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

&lt;p&gt;特性：&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;strong&gt;信息丰富且精美的输出&lt;/strong&gt;：显示比&lt;code&gt;nvidia-smi&lt;/code&gt;彩色精美方框绘图更多的信息。&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;监控模式&lt;/strong&gt;：可以作为资源监控器运行，而不是只打印一次结果。
	&lt;ul&gt;
		&lt;li&gt;条形图和历史图&lt;/li&gt;
		&lt;li&gt;过程排序&lt;/li&gt;
		&lt;li&gt;过程过滤&lt;/li&gt;
		&lt;li&gt;通过击键向进程发送信号&lt;/li&gt;
		&lt;li&gt;GPU 进程及其父进程的树视图屏幕&lt;/li&gt;
		&lt;li&gt;环境变量屏幕&lt;/li&gt;
		&lt;li&gt;帮助屏幕&lt;/li&gt;
		&lt;li&gt;鼠标支持&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;交互式&lt;/strong&gt;：在监控模式下响应用户输入（来自键盘和/或鼠标）。（对比&lt;a href=&quot;https://github.com/wookayin/gpustat&quot;&gt;gpustat&lt;/a&gt;和&lt;a href=&quot;https://github.com/fbcotter/py3nvml&quot;&gt;py3nvml&lt;/a&gt;）&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;高效&lt;/strong&gt;：
	&lt;ul&gt;
		&lt;li&gt;&lt;a href=&quot;https://pypi.org/project/nvidia-ml-py&quot;&gt;直接使用 NVML Python 绑定&lt;/a&gt;查询设备状态，而不是解析&lt;code&gt;nvidia-smi&lt;/code&gt;的输出（与&lt;a href=&quot;https://github.com/peci1/nvidia-htop&quot;&gt;nvidia-htop&lt;/a&gt;相比）&lt;/li&gt;
		&lt;li&gt;支持稀疏查询并使用来自 cachetools 的 TTLCache 缓存结果（与&lt;a href=&quot;https://github.com/wookayin/gpustat&quot;&gt;gpustat&lt;/a&gt;相比）&lt;/li&gt;
		&lt;li&gt;使用 curses 库显示信息，而不是用 ANSI 转义代码打印（与&lt;a href=&quot;https://github.com/fbcotter/py3nvml&quot;&gt;py3nvml&lt;/a&gt;相比）&lt;/li&gt;
		&lt;li&gt;使用多线程异步收集信息并更快地响应用户输入。（与&lt;a href=&quot;https://github.com/Syllo/nvtop&quot;&gt;nvtop&lt;/a&gt;相比）&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;便携式&lt;/strong&gt;：适用于 Linux 和 Windows。
	&lt;ul&gt;
		&lt;li&gt;使用跨平台库&amp;nbsp;&lt;a href=&quot;https://github.com/giampaolo/psutil&quot;&gt;psutil&lt;/a&gt;&amp;nbsp;获取主机进程信息，而不是在子进程中调用&lt;code&gt;ps -p &amp;lt;pid&amp;gt;&lt;/code&gt;。（与&lt;a href=&quot;https://github.com/peci1/nvidia-htop&quot;&gt;nvidia-htop&lt;/a&gt;和&lt;a href=&quot;https://github.com/fbcotter/py3nvml&quot;&gt;py3nvml&lt;/a&gt;相比）&lt;/li&gt;
		&lt;li&gt;用纯 Python 编写，易于使用&lt;code&gt;pip&lt;/code&gt;安装（与&lt;a href=&quot;https://github.com/Syllo/nvtop&quot;&gt;nvtop&lt;/a&gt;相比）&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;strong&gt;可集成&lt;/strong&gt;：易于集成到其他应用程序中，不仅仅是监控。（对比&lt;a href=&quot;https://github.com/peci1/nvidia-htop&quot;&gt;nvidia-htop&lt;/a&gt;和&lt;a href=&quot;https://github.com/Syllo/nvtop&quot;&gt;nvtop&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;281&quot; src=&quot;https://static.oschina.net/uploads/space/2023/0322/155406_yOXI_4252687.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/nvitop</link>
            <guid isPermaLink="false">https://www.oschina.net/p/nvitop</guid>
            <pubDate>Tue, 26 Mar 2024 02:10:00 GMT</pubDate>
        </item>
        <item>
            <title>每日一博 | 分布式数据库技术的演进和发展方向</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                    &lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=OGJkODIyMmU2YTFkZTIwYzMwNzU5NjZjZWRlM2M5OWQsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;这些年大家都在谈分布式数据库，各大企业也纷纷开始做数据库的分布式改造。那么，所谓的分布式数据库到底是什么？采用什么架构？优势在哪？为什么越来越多企业选择它？分布式数据库技术会向什么方向发展？带着这些疑问，一探究竟吧！参与文末的话题互动，更有机会赢取精美奖品~&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;分布式数据库的架构演进&lt;/h1&gt; 
&lt;p&gt;随着数据量的爆发增长，传统集中式数据库面临极大的挑战：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;性能瓶颈：&lt;/strong&gt;数据规模爆发增长，传统集中式数据库难以维持数据量大时的性能，而分布式数据库的性能可以水平扩展；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;缺失混合负载能力：&lt;/strong&gt;数据量爆发增长带来对数据分析（OLAP）需求的增长。企业需要使用两套系统分别支撑事务交易（OLTP）和数据分析（OLAP），不仅造成了大量的数据冗余，同时增加了系统的复杂度和运维难度。而分布式数据库的混合负载能力可大幅度提升分析的时效性，减少数据冗余，并大大提高灵活性；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;高昂成本：&lt;/strong&gt;集中式数据库水平扩展难，可靠性需要付出高昂的成本。而分布式数据库的架构支持灵活扩展，实现高可用方案的成本较低。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;分布式数据库与单机数据库的不同在于其可以将核心功能扩展到多台节点，甚至多个地域，包括事务管理、数据存储和数据查询等。从实现方式上看，分布式数据库主要有 3 种不同的技术路线：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1. 分布式中间件 + 单机数据库&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;这条路线本质上是分布式系统由两部分组成：&lt;/p&gt; 
&lt;p&gt;a) 上层是分布式中间件：维护一套统一的分片规则，提供 SQL 解析，请求转发和结果合并的能力。&lt;/p&gt; 
&lt;p&gt;b) 底层单机数据库：开源 MySQL 或 PG 单机数据库，提供数据存储和执行能力。&lt;/p&gt; 
&lt;p&gt;这种方式主要使用比较成熟的内核来解决扩展性的问题，所以生态友好、成本较低，也比较容易实现。&lt;/p&gt; 
&lt;p&gt;不过，缺点也显而易见。比如功能降级、在全局事务能力和高可用等方面存在短板，需要有针对性增强，导致整个方案的复杂度高、机器冗余多。最重要的是，因为使用的是开源产品的内核，数据库会始终受制于开源代码修改、专利、发行方式等很多方面的风险，这种形式显然无法满足当前国内金融、政企客户的需求。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=YjFlYTkzMzMzNDQ5MTk4MjQ3ZmIzOGQ1MzYwMjA0YzMsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;strong&gt;2. 基于分布式存储的分布式数据库。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;这种形态基于分布式存储，再叠加数据库能力。大部分公有云数据库采用这条技术路线。华为云 GaussDB(for MySQL) 就是这种形态的典型代表。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=NDIxMThjMTc3MWIwMWFiMTY3MDZhNTU0ZjU5ODI0ZTYsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;这条路线有限地解决了扩展性问题，数据一致性主要依赖分布式存储引擎。上层的计算节点无状态，共享存储提供跨节点读写。这种架构充分利用分布式存储提供的高级特性，更容易形成技术竞争力。但是这种架构的扩展性有限，尤其是写节点。&lt;/p&gt; 
&lt;p&gt;另外，这种架构对底座（分布式存储）有比较重的依赖，线下实现的成本高。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3. 原生分布式数据库。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;这种形态是基于分布式数据库理论实现的分布式数据库。这条路线是根据分布式一致性协议做底层设计。原生分布式数据库将分布式存储、事务和计算结合在一起，数据由系统自动打散并存储多个副本，通过一致性协议保证多个副本和事务的一致性。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=ZjhiNTM5OGY0MzhiMTdiOTExNTQ2YTY5YTUzYmM4ZDgsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;这种形态更容易在数据库本身所擅长的领域发挥优势，比如说性能、复杂 SQL 处理能力、企业级能力。集群的扩展和收缩对应用透明，按需扩展，支持大规模部署限制；数据一致性由事务层一致性协议保护，安全性更高；灵活部署，多活架构，对硬件的依赖低，可以通过普通服务器实现集群和高可用。&lt;/p&gt; 
&lt;p&gt;因为金融政企客户在使用分布式技术之前，往往已经有分库分表、使用分布式中间件产品的经验，所以对原生分布式架构的认可度更高，学习成本也相对较低，因此，这种形态也是国内当前被采用较多的一种。&lt;/p&gt; 
&lt;p&gt;华为云 GaussDB 分布式数据库就是这种形态的典型代表。GaussDB 基于华为在数据库领域 20 多年的战略投入，已经在金融行业积累了非常丰富的实践经验，是企业数字化转型、核心数据上云、分布式改造的信赖之选。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;原生分布式数据库的挑战和关键技术&lt;/h1&gt; 
&lt;p&gt;原生分布式数据库基于分布式数据库理论，是一款对于用户应用透明的分布式数据库。不过，实现分布式关系数据库有几个关键挑战：&lt;/p&gt; 
&lt;p&gt;第一，安全可信。&lt;/p&gt; 
&lt;p&gt;分布式、云化环境的复杂性增加了安全风险，比如数据泄露和丢失的风险增加，身份认证和访问控制以及数据传输、存储安全的控制难度提升。&lt;/p&gt; 
&lt;p&gt;第二，事务系统的正确性及性能。&lt;/p&gt; 
&lt;p&gt;分布式数据库中经常有一次操作涉及多台数据库的场景，需要一种方案来维护整个数据库集群事务的 ACID 特性，避免出现部分成功部分失败等无法接受的情况。&lt;/p&gt; 
&lt;p&gt;另外，在大并发场景下事务管理器容易成为性能的单点瓶颈，比如获取事务唯一标识、全局快照、频繁交互导致大量的网络通信和锁等待等。&lt;/p&gt; 
&lt;p&gt;第三，分布式查询能力。&lt;/p&gt; 
&lt;p&gt;在分布式系统中，需要在最短时间内获取准确的查询结果，提升查询性能。&lt;/p&gt; 
&lt;p&gt;第四，高可用能力。&lt;/p&gt; 
&lt;p&gt;分布式数据库需要确保异常场景下（如：节点硬件故障或者 Bug 宕机等）数据库系统的连续可用。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=MDc0NjM2NWQyZGI5YmI0ZjQwMzYzZDVjMzU2MzMyYmIsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;分布式数据库的挑战和关键技术&lt;/p&gt; 
&lt;p&gt;GaussDB 分布式数据库研发了一系列高性能、高可用、安全特性迎接上述四大挑战，下面挑选几个有代表性的特性加以说明。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_3&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;全密态&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;传统的加密方式在服务端加密，密钥管理员是可以获取的。而全密态数据库的密钥掌握在用户自己手上，数据库管理员无法获取，加解密过程仅在客户侧完成，数据在存储、传输、查询整个生命周期过程中均以密文形态存在，避免管理员恶意获取密钥解密数据。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=NTliMTZjNGU0OWY0ZTVlMmZjNmYzYWNlY2MwYjgxMjAsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;全密态数据库&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_4&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;分布式事务 GTM-Lite&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;如下图所示，GaussDB 没有采用传统的事务列表的管理方式，而是提供了一个 CSN（提交系列号），通过对比 CSN 的大小来实现事务可见性判断。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=MGMwYjFhNjIzYzBjMTY2Y2U5NTZiOTVlOWIwM2NhYTAsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;GTM-Lite 技术示意&lt;/p&gt; 
&lt;p&gt;当事务开始时，根据事务隔离级别的不同，从 GTM-Lite 获取一个 CSN 值，作为这个事务的查询快照点（如果是可重复读，只需要在事务开始时获取一次 CSN 值，如果是读已提交，每次 SELECT 时都需要重新取一次 CSN 值）。&lt;/p&gt; 
&lt;p&gt;当事务提交时，向 GTM-Lite 申请一个新的 CSN 值，作为这个事务提交 CSN 值，并记录到事务提交记录中。&lt;/p&gt; 
&lt;p&gt;GTM-Lite 技术通过 CSN 提交序列号进行可见性判断，无需耗费大量计算资源来遍历列表；无锁化原子操作提供 CSN 序列号，无需锁等待；节点间事务交互仅需要一个 CSN，网络开销跟事务规模无关。在保证事务全局强一致的同时，提供高性能的事务处理能力，避免了单 GTM 的性能瓶颈。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_5&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;分布式查询优化&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;1. 分布式执行&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;GaussDB 是如何处理分布式数据库集群中的业务应用 SQL 的呢？&lt;/p&gt; 
&lt;p&gt;1）业务应用的 SQL 会下发给 CN 节点；&lt;/p&gt; 
&lt;p&gt;2）CN 利用数据库的优化器生成分布式的执行计划，每个 DN 会按照执行计划的要求处理数据；&lt;/p&gt; 
&lt;p&gt;3）数据基于一致性 Hash 算法分布在每个 DN，因此 DN 在处理数据的过程中，可能需要从其他 DN 获取数据，GaussDB 提供三种 stream 流（广播流 broadcast、聚合流 gather 和重分布流 redistribute）实现数据在 DN 间的流动；&lt;/p&gt; 
&lt;p&gt;4）DN 将结果集返回给 CN 进行汇总；&lt;/p&gt; 
&lt;p&gt;5）CN 将汇总的结果返回给业务应用。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=YTk0NjQzMTk0OGUxOWMwYjNjMjA3NzI4ZmIxOWIyN2YsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;分布式查询示意&lt;/p&gt; 
&lt;p&gt;让我们展开看一下节点间的数据交换。比如某条 SQL 的执行逻辑如下图所示：&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=Y2U2NDcxODQ4YTAyMTJhMDBkYmMwMWU3NjhlMGZmMTcsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;SQL 执行逻辑&lt;/p&gt; 
&lt;p&gt;以两个 DN 为例， 在执行过程中，DN 会按照 redistribute 键将数据发送到对应的节点。&lt;/p&gt; 
&lt;p&gt;Redistribute 算子接收到 C/D 两表 join 的数据之后，根据重分布键计算将数据发给 DN1 还是 DN2，Redistribute Collector 收集到重分布之后的数据之后发给上层的 Join 算子再做 Join 计算。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=MWI5OWMzMTUzNjVlYzdjODRhYzkxYTg0N2U4N2MyYTUsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;CN、DN 间的数据流动&lt;/p&gt; 
&lt;p&gt;另外，GaussDB 的优化器会根据统计信息选取针对当前 SQL 性能最优的 Stream 流算子完成 CN、DN 间的数据流动。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2. 全并行架构&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;GaussDB 采用全并行架构，从 MPP 节点并行、SMP 线程并行、到 SIMD 指令并行，到 LLVM CodeGen 技术，全面挖掘系统计算资源的潜力，提升查询性能。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=OTdjY2NjYjA2NjRhMDViODE3MzM1ZTY0M2FiYTM3MTEsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_6&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;高可用&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;1. GaussDB 重做日志&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;重做日志在如下场景可以发挥作用，提升系统的可用性&lt;/p&gt; 
&lt;p&gt;1）当数据库发生故障，如宕机，可以通过重做日志文件恢复数据。&lt;/p&gt; 
&lt;p&gt;2）HA 架构下，主备通过重做日志文件进行数据同步。&lt;/p&gt; 
&lt;p&gt;3）备份恢复时，通过归档重做日志文件实现 PITR。&lt;/p&gt; 
&lt;p&gt;GaussDB 使用 WAL (Write Ahead Log) 机制实现重做日志，在提升可用性的同时兼顾性能，即在数据修改时遵循 no-force-at-commit 策略，在提交时并不强制写。为了保证数据在数据库发生故障时可以恢复，通过 Redo 机制，用连续的、顺序的日志条目的写出将随机的、分散的数据块的写出推延，这个推延使得数据的写出可以获得批量效应的性能提升。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2. 分布式部署&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;GaussDB 支持多种高可用部署形态，保证系统的稳定性和可靠性。下面我们看两个典型案例。&lt;/p&gt; 
&lt;p&gt;1）两地三中心。&lt;/p&gt; 
&lt;p&gt;同城有两个双活数据中心，两个数据中心同时承载业务，异地一个容灾数据中心；同城可实现节点级、AZ 级、数据中心级等故障高可用，同时提供跨城的异地容灾能力。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=ODU0Yzc1ZmUzNjliNTdmYzdmNTc3ODEwMmRjZDc3MjgsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;GaussDB 两地三中心高可用部署&lt;/p&gt; 
&lt;p&gt;2）同城 3AZ 高可用+异地容灾。&lt;/p&gt; 
&lt;p&gt;同城采用逻辑 3AZ、3 副本部署，异地采用单 AZ、3 副本部署，提供了同城抵御节点级故障和 AZ 级故障的能力，跨城的 Region 级容灾的能力。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=ZTNlZjJiNWNiNzg5Y2ZkMjVjMGVkMWY4OTBiM2Q4MWEsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;GaussDB 同城 3AZ 高可用+异地容灾&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_7&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;分布式数据库技术的发展方向&lt;/h1&gt; 
&lt;p&gt;基于新需求、新场景、以及全池化架构、新网络和大模型等新技术的出现，我们认为分布式数据库技术主要向以下六个方向发展。&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=Mzc4MzRhNjFlYjE1YTI4ZWRmYjkzMTEyMTM5YTg4NGYsMTcxMTQxNTc4NTMwOA==&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;p&gt;分布式数据库技术的发展方向&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_8&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;高可用能力的持续提升&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;高可用是目前大多数金融政企客户首要关注的问题，特别是对于多地、多中心容灾有要求的客户。针对这样的客户，华为云 GaussDB 已经提供了多种解决方案，如支持同城双活、异地容灾、两地三中心的解决方案，支持同城双活强同步的解决方案，支持异步数据复制、多地多活的高可用解决方案。&lt;/p&gt; 
&lt;p&gt;面向未来，分布式数据库将具备真正全球部署能力的多活架构。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_9&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;软硬件深度协同&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;硬件和软件两者之间相辅相成，互相促进。利用新型硬件（GPU、FPGA、高速网络）和华为在芯片、服务器、存储、网络、操作系统、数据库的全栈软硬件能力，提升性能和高可用能力。&lt;/p&gt; 
&lt;p&gt;首先，数据库的持久化逻辑，深度整合到了计算与存储分离的技术底座中，分布式数据库可以获得在容量、弹性、扩展性方面的巨大提升，同时能提供给客户一致的体验。&lt;/p&gt; 
&lt;p&gt;其次，从计算节点卸载下推到存储中，特别是对一些复杂的查询处理，同时叠加并行处理能力，使得这些计算逻辑能充分利用下面整个存储池的能力，同时最关键的是能做到对业务透明。&lt;/p&gt; 
&lt;p&gt;最后，就是高性能。高性能的实现除了 I/O 聚合之外，单条交易的本质就是网络的时延和处理的时延。所以，网络对于分布式数据库的时延（性能）影响是巨大的。&lt;/p&gt; 
&lt;p&gt;总而言之，软硬协同带给我们的不仅仅是性能扩展方面的优势，更是可以通过软硬协同打造真正企业级的可靠性。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_10&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;企业级混合负载 （HTAP）&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;近年来企业级混合负载（HTAP）的兴起，旨在打破事务处理（TP）和分析（AP）之间的壁垒。分布式数据库都应具备混合负载能力，即在支持高并发、事务性请求的同时，对分析型的复杂查询提供了良好的支持，从而大幅度降低成本，同时提高企业决策的效率。&lt;/p&gt; 
&lt;p&gt;HTAP 架构的核心技术：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第一，透明路由&lt;/strong&gt;。通过自动选择行存引擎、列存引擎以及行列组合，提供查询的准确性和实时性，增加客户的易用性，提升 HTAP 产品的商用价值。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第二，性能提升&lt;/strong&gt;。TP 要求的是低时延、高吞吐，而 AP 要求的是复杂查询的能力。常规执行优化技术包括并行执行、编译执行、向量化执行等，在这些技术的基础上进一步加速复杂查询，支撑企业级混合负载。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第三，数据新鲜度&lt;/strong&gt;。保证数据高新鲜度、高性能，保证 HTAP 架构能够具备更多应对用户的能力。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第四，资源隔离&lt;/strong&gt;。用户对 TP 性能要求比较高，在引入实时 AP 的同时，不能影响 TP 的能力和性能，需要在资源隔离、数据新鲜度以及性能的提升方面做好权衡。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_11&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;云原生多主&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;单一架构其实并不能解决今天行业碰到的所有问题，但云原生多主架构可以帮助解决两类问题：&lt;/p&gt; 
&lt;p&gt;第一个，是高可用的问题，希望能基于多主架构，解决切换时业务中断的问题。&lt;/p&gt; 
&lt;p&gt;第二个，是扩展性的问题，基于多主架构，融合软硬协同的进展，真正能在计算节点以下，持续提升产品的性能和弹性。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_12&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;数据安全可信&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;当今世界，每个国家、组织和个人都在关注安全、合规和隐私的问题，几年前数据无保护随意获取并使用的便利不再，这也促进了技术的进步和落地。未来，全行业都会面临越来越严格的对于可信安全方面的要求。&lt;/p&gt; 
&lt;p&gt;全密态是华为云数据库为了提升隐私保护能力研制的一项关键技术，全密态支持数据在整个计算过程中同样是以密文形式存在，实现了让整个敏感数据在全生命周期当中都得到保护。因此，无论数据处于何种状态，攻击者都无法获取到有效信息，从而保障了企业数据全生命周期的隐私安全。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_13&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;AI-Native&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;机器学习已被广泛用于优化数据管理问题，如数据清理、数据分析、查询重写、数据库诊断等。然而，传统的机器学习算法无法解决泛化和推理问题。幸运的是，大模型（LLM）可以帮助解决这些限制，为智能化数据管理提供了很好的机会。&lt;/p&gt; 
&lt;p&gt;借助 AI/LLM，未来分布式数据库将朝着全流程、全链路、高效易用的智能化数据库的方向发展，在数据库咨询、开发、运维等关键阶段，构建相应的自动化能力：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第一，咨询阶段，提供专家式辅助，制定精细化方案。&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;HLD 助手&lt;/strong&gt;，结合专家经验，自动生成数据库 HLD；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;DB 知识库&lt;/strong&gt;，通过积累运维工单、答疑、文档手册等，形成数据库行业知识库；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;问答助手&lt;/strong&gt;，通过提供 ChatBot，实现交互式运维。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;第二，开发阶段，提供开发辅助，提升 SQL 开发效率。&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;通过构建 NL2SQL 转换能力，让自然语言转换为 SQL 语句；&lt;/li&gt; 
 &lt;li&gt;同时，增强的 SQL 转换能力提升异构数据库间的 SQL 语句转换自动化率。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;第三，运维阶段，实现预测性维护，提升系统可靠性。&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;智能巡检&lt;/strong&gt;，可以构筑 Schema/SQL、中间件/告警等全链路可观测可跟踪能力；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;智能故障处理&lt;/strong&gt;，通过全链路感知编排，提供精准分析，快速定位故障并给出建议；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;SQL 质量提升能力&lt;/strong&gt;，可以快速找出问题 SQL，诊断根因，提供全局分析。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;综上，分布式数据库性能卓越，凭借高可用、高可扩展性、高性价比等优势，已经被对数据库要求最严苛的金融行业所认可，并逐渐被应用在更广阔的领域。不过，从总体发展状态来看，目前还处于早期，但发展方向明朗，上升空间很大。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_14&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;参与有奖&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;GaussTech 技术专栏第一期&lt;/strong&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;对于分布式数据库的未来发展，你怎么看？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;1.你认为分布式是数据库未来的发展趋势吗？&lt;/p&gt; 
&lt;p&gt;2.哪种架构会得到更多企业的青睐？&lt;/p&gt; 
&lt;p&gt;3.分布式数据库技术又会向什么方向发展？&lt;/p&gt; 
&lt;p&gt;点击&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fforum%2Fthread-02109146796596102026-1-1.html%3Futm_source%3Doschina%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;链接&lt;/a&gt;&lt;/strong&gt;，即可参与「&lt;strong&gt;GaussTech 技术专栏第一期」话题讨论&lt;/strong&gt;，就有机会获得 HUAWEI mini 蓝牙音箱 _绮境森林、《华为数据之道》书籍、新贵族系列中性笔、平装套芯笔记本、GaussDB 字母笔、炫彩马卡龙指甲刀等好礼，快来参与吧！&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%3Futm_source%3Doschina%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;点击关注，第一时间了解华为云新鲜技术~&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://my.oschina.net/u/4526289/blog/11049010</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4526289/blog/11049010</guid>
            <pubDate>Tue, 26 Mar 2024 02:03:00 GMT</pubDate>
            <author>原创</author>
        </item>
    </channel>
</rss>