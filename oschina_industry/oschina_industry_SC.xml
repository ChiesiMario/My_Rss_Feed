<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 15 Nov 2023 13:15:29 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[向开源作者提问「项目还活着吗」非常粗鲁且无礼]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>最近几个月，开源 AI 项目的创始人 Max Woolf 经历了一场关于自己的工作的 「存在危机」。</p><p>他表示自己对 AI 的负面抵制情绪日益强烈，以及 AI 行业进展神速，Max 发现自己无法跟上进度，陷入了对开源工作的质疑。在此期间，他暂停了 GitHub 上自己开源项目的开发，其中包括 ChatGPT 的 Python 接口 simpleaichat。</p><p><img src="https://static.oschina.net/uploads/space/2023/1115/190841_hkBi_2720166.png" referrerpolicy="no-referrer"></p><p><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fminimaxir%2Fsimpleaichat" target="_blank">https://github.com/minimaxir/simpleaichat</a></u></em></p><p>简单来说，Max 压力太大，需要休息一段时间。按理来说，他的代码不应该有问题，因为项目本身设计就考虑到了他可能暂停开发的情况。</p><p>然而当 Max 想重操旧业时，却在自己项目的 GitHub 上收到了质疑开发是否已经停止的问题。尽管没有任何证据表明代码出问题，但项目 Stars 数高达 3k 的 simpleaichat 还是收到了 「这个项目被放弃了吗」 的问题。</p><p><img height="302" src="https://static.oschina.net/uploads/space/2023/1115/190713_TFZG_2720166.png" width="1454" referrerpolicy="no-referrer"></p><p>这让 Max 感到既震惊又气愤。他认为，这种质疑开发者的行为是在施加不必要的压力，也显得无礼。</p><p>事实上，开源项目从来没有 「必须持续开发」 的硬性规定。大多数开源许可协议都明确写明软件 「按原样」 提供，不承诺后续维护。但部分社区成员似乎默认开源项目有更新的义务，这让 Max 和其他开源开发者感到困扰。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9f8029289e5c8978243bb08f62b2b0a4dcf.png" referrerpolicy="no-referrer"></p><p>他认为，开源的最大优势是可以随时分叉。如果有开发者认为某项目 「死了」, 大可以复制代码自行维护。但是有些人却以 「分叉」 来威胁原作者，这让原作者不堪重负。</p><p>AI 行业进展迅速，也加重了这一问题。受 ChatGPT 热潮影响，部分 AI 新创通过风险投资大规模运营，让人产生开源 AI 必须 「快速迭代」 的误解。</p><p>Max 表示，这种对开源项目 「活跃度」 的不合理期待，已经成为阻止他继续开源工作的主要障碍。他正在考虑通过创业来全职维护自己的项目，但前景未卜。</p><p>他认为，质疑开源项目是否 「死了」 的问题本身，就可能让开发者产生继续工作的动力。开源社区如果不能保持友善，只会让更多优秀项目消失。</p><p>原文：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fminimaxir.com%2F2023%2F11%2Fopen-source-dead-github%2F" target="_blank">https://minimaxir.com/2023/11/open-source-dead-github/</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 10:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266608/open-source-dead-github</guid>
            <link>https://www.oschina.net/news/266608/open-source-dead-github</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[零一万物对 Yi-34B 训练过程的说明]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>事件背景：</p><ul><li><a href="https://www.oschina.net/news/266377">李开复旗下 AI 公司「零一万物」开源的 Yi 大模型照搬 Llama 架构</a></li><li><a href="https://www.oschina.net/news/266525">「零一万物」 回应 Yi 开源大模型「套壳」 Llama</a></li></ul><hr><p>零一万物今天正式发文回应 Yi 开源大模型引起的争议：</p><blockquote><p>就零一万物的观察和分析，大模型社区在技术架构方面现在是一个处于接近往通用化逐步收拢的阶段，基本上国际主流大模型都是基于<strong>Transformer</strong>的架构，做 attention，activation，normalization，positional embedding 等部分的改动，LLaMA、Chinchilla、Gopher 等模型的架构和 GPT 架构大同小异，全球开源社区基于主流架构的模型变化非常之多，生态呈现欣欣向荣，国内已发布的开源模型也绝大多数采用渐成行业标准的 GPT/LLaMA 的架构。然而，大模型持续发展与寻求突破口的<strong>核心点不仅在于架构，而是在于训练得到的参数</strong>。</p><p>模型训练过程好比做一道菜，架构只是决定了做菜的原材料和大致步骤，这在大多数人的认知中也逐步形成共识。<strong>要训练出好的模型，还需要更好的「原材料」（数据）和对每一个步骤细节的把控（训练方法和具体参数）</strong>。由于大模型技术发展还在非常初期，从技术观点来说，行业共识是与主流模型保持一致的模型结构，更有利于整体的适配与未来的迭代。</p><p>零一万物在训练模型过程中，沿用了 GPT/LLaMA 的基本架构，由于 LLaMA 社区的开源贡献，让零一万物可以快速起步。零一万物<strong>从零开始训练</strong>了 Yi-34B 和 Yi-6B 模型，并根据实际的训练框架重新实现了训练代码，用自建的数据管线构建了高质量配比的训练数据集（从 3PB 原始数据精选到 3T token 高质量数据）。除此以外，在 Infra 部分进行算法、硬件、软件联合端到端优化，实现训练效率倍级提升和极强的容错能力等原创性突破。<strong>这些科学训模的系统性工作，往往比起基本模型结构能起到巨大的作用跟价值。</strong></p><p>零一万物团队在训练前的实验中，尝试了不同的数据配比科学地选取了最优的数据配比方案，投注大部分精力调整训练方法、数据配比、数据工程、细节参数、baby sitting（训练过程监测）技巧等。这一系列超越模型架构之外，研究与工程并进且具有前沿突破性的研发任务，才是真正属于模型训练内核<strong>最为关键、能够形成大模型技术护城河 know-how 积累</strong>。在模型训练同时，零一万物也针对模型结构中的若干关键节点进行了大量的实验和对比验证。举例来说，我们实验了 Group Query Attention（GQA）、Multi-Head Attention（MHA）、Vanilla Attention 并选择了 GQA，实验了 Pre-Norm 和 Post-Norm 在不同网络宽度和深度上的变化，并选择了 Pre-Norm，使用了 RoPE ABF 作为 positional embedding 等。也正是在这些实验与探索过程中，为了执行对比实验的需要，模型对部分推理参数进行了重新命名。</p><p>在零一万物初次开源过程中，我们发现用和开源社区普遍使用的 LLaMA 架构会对开发者更为友好，对于沿用 LLaMA 部分推理代码经实验更名后的疏忽，原始出发点是为了充分测试模型，并非刻意隐瞒来源。<strong>零一万物对此提出说明，并表达诚挚的歉意</strong>，我们正在各开源平台重新提交模型及代码并补充 LLaMA 协议副本的流程中，承诺尽速完成各开源社区的版本更新。</p><p>我们非常感谢社区的反馈，零一万物在开源社区刚刚起步，希望和大家携手共创社区繁荣，在近期发布 Chat Model 之后，我们将择期发布技术报告，Yi Open-source 会尽最大努力虚心学习，持续进步。</p><p><em>开源社区讨论参考：</em><br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">https://huggingface.co/01-ai/Yi-34B/discussions/11#6553145873a5a6f938658491</a></p></blockquote><p>创新工场 CMO 在转发上文的朋友圈中表示：「沿用行业演进渐成通用、生态拥抱的基础架构就成了「套模、山寨」？（就像手机 app 开发者都得益于 iOS、Android 的共通架构）。零一万物会持续从社区中虚心学习，持续进步。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-76f874328ebdab1a891bfc44ea094f539e4.png" referrerpolicy="no-referrer"></p><p>原文：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FaDclX74mPPtjQvco3GYmZQ" target="_blank">https://mp.weixin.qq.com/s/aDclX74mPPtjQvco3GYmZQ</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 09:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266597</guid>
            <link>https://www.oschina.net/news/266597</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[CodeFuse 开源 ModelCache 大模型语义缓存]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p style="margin-left:0; margin-right:0"><img alt="" src="https://img.alicdn.com/imgextra/i2/O1CN01Moy0hq1P2Cgi8LERe_!!6000000001782-2-tps-900-383.png" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span>CodeFuse 开源火热进行中！本次开源的是 ModelCache 大模型语义缓存，可大幅降低大模型应用的推理成本，提升用户体验。</span></p><p style="margin-left:0; margin-right:0"><span>CodeFuse-ModelCache 项目地址：</span></p><p style="margin-left:0; margin-right:0"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-ModelCache" target="_blank" rel="nofollow"><span>https://github.com/codefuse-ai/CodeFuse-ModelCache</span></a></p><span id="OSC_h2_1"></span><h2><strong><span style="color:#000000">0 背景</span></strong></h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">在 LLM 技术浪潮席卷全球的背景下，大型模型快速增长的参数规模，对部署所需的推理资源带来了极大的挑战。为了提高大型模型的推理性能和效率，我们尝试从缓存角度解决当前大模型规模化服务部署的困境。类似传统应用，大模型的用户访问同样具有时间和空间的局部性（例如：热门话题相关内容，热门 GitHub repo）。如果有了缓存层，在遇到相似请求时，就无需调用大模型服务，直接从缓存的数据中返回已有的结果给用户，会大幅降低推理成本，提升用户体验。</span></p><span id="OSC_h2_2"></span><h2><span style="color:#333333">1 大模型缓存的意义</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">当前大模型服务面临一下三个挑战：</span></p><ol><li><span style="color:#333333">成本高：大模型参数量千亿级别，单实例就需要多张 A10 卡，规模化部署成本高昂。因此，当前大模型服务基本按照处理的 token 数量计费，导致用户侧使用成本也居高不下。</span></li><li><span style="color:#333333">速度慢：大型模型的推理速度也是一个关键问题。在许多实时应用中，如对话系统、业务助手，响应时间要求非常高，通常在毫秒级别。然而，大型模型的推理速度往往较慢，在秒级，导致无法实时返回结果，用户体验下降。</span></li><li><span style="color:#333333">稳定性无保障：由於单实例部署成本高昂，当前大模型服务接受到大流量请求时，通过限流的方式，防止服务不可用。</span></li></ol><span id="OSC_h2_3"></span><h2><span>2 方案调研</span></h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">我们对开源方案 GPTCache 进行了调研，其是致力于构建用于存储 LLM 响应的语义缓存的项目，该项目提供了语义相似度匹配框架，并提供了相对完善的功能模块和接口。具有以下优点：<span>&nbsp;</span></span></p><ul><li><span style="color:#333333">项目的活跃性，它不断引入新功能，使得我们能够紧跟最新的发展动态。<span>&nbsp;</span></span></li><li><span style="color:#333333">具备开放的功能模块，可以进行调整和优化，这为业务的扩展提供了便利。</span></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#333333">GPTCache 的整体架构如图 1 所示：</span></p><p style="margin-left:0; margin-right:0; text-align:left"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/275821/1699497539548-420014c2-90f5-45dc-929f-15a2e3d32ebf.png" width="642" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:center"><span style="color:#333333">图 1. GPTCache 架构</span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">但是，GPTCache 在落地应用上仍存在诸多不足，包括：</span></p><ol><li><span style="color:#333333">架构上将大模型调用和数据回写对用户进行了黑盒处理，使得大模型产品在流式输出、安全审核、问题排查等方面变的复杂。</span></li><li><span style="color:#333333">默认采用 faiss 和 sqlite 作为存储，不能进行分布式部署，尤其是在关系型数据库方面，SqlAlchemy 框架无法支持蚂蚁的 OceanBase。</span></li><li><span style="color:#333333">数据和资源隔离上，无法处理多模型多版本场景。</span></li><li><span style="color:#333333">不支持多轮会话，尤其是当模型有 system 指令时，无法很好兼容。更多待改进功能会在 3.3 部分会做详细介绍。</span></li></ol><span id="OSC_h2_4"></span><h2><span>3 ModelCache 建设</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">针对上述问题，我们基于 GPTCache 进行了二次开发，构建蚂蚁内部缓存产品 ModelCache，整体架构见图 2，接下来会详细介绍我们的工作，包括：3.1 整体架构；3.2 功能升级。在功能升级部分，会详细介绍 ModelCache 中新增的功能点。</span></p><span id="OSC_h3_5"></span><h3><span>3.1 整体架构</span></h3><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/305114/1699892547016-2e6263cc-8940-4c43-bffb-5bbd06c57998.png" width="941.818161404823" referrerpolicy="no-referrer"></p><p style="margin-left:16em; margin-right:0"><span>图 2. ModelCache 架构及上下游</span></p><span id="OSC_h4_6"></span><h4><span style="color:#000000">3.1.1 技术架构</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在初始架构中，将大模型调用和数据回写对用户进行了黑盒处理。然而，这种架构导致问题排查繁琐，以及流式输出和数据安全审核等方面难以满足企业级要求。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">因此，我们对架构进行了重新调整，ModelCache 采用了轻量化的接入方式，不打扰大模型产品的功能实现。我们设计 ModelCache 为类 redis 结构，提供了开放式的数据查询、数据回写、数据管理等 API，同时解</span><span style="color:#000000">耦</span><span style="color:#333333">了大模型调用，可作为一个独立模块嵌入到大模型产品。通过 ModelCache，产品侧能够更加灵活地管理和使用大模型，提高系统的可维护性和可扩展性。</span></p><span id="OSC_h4_7"></span><h4><span style="color:#000000">3.1.2 核心模块</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在 ModelCache 中，包含了一系列核心模块，包括 adapter、embedding、</span><span style="color:inherit">rank</span><span style="color:#333333">和 data_manager 等，具体功能如下：</span></p><ol><li><span>adapter 模块：其主要功能是处理各种任务的业务逻辑，并且能够将 embedding、</span><span style="color:inherit">rank</span><span>、data_manager 等模块串联起来。</span></li><li><span style="color:inherit">embedding 模块：该模块主要负责将文本转换为语义向量表示，它将用户的查询转换为向量形式，并用于后续的召回或存储操作。</span></li><li><span style="color:inherit">rank 模块：用于对召回的向量进行相似度排序和评估，可根据 L2 距离、余弦相似度或者评估模型，对两个向量进行相似度评分，并进行排序。</span></li><li><span style="color:inherit">data_manager 模块：该模块主要用于管理数据库，包括向量数据库和关系型数据库，它负责数据的存储、查询、更新和删除等操作。</span></li></ol><ol><li><ol><li><span style="color:inherit">向量数据库（Milvus）：</span><span style="color:#333333">Milvus 作为一个高性能、可扩展、多功能的向量数据库，适用于多种需要向量检索的应用场景。</span></li><li><span style="color:#333333">关系型数据库（OceanBase）：我们采用蚂蚁的 OceanBase 数据库，存储用户 query、LLM 相应、模型版本等信息。</span></li></ol></li></ol><span id="OSC_h4_8"></span><h4><span>3.1.3 功能对比</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">功能方面，为了解决 huggingface 网络问题并提升推理速度，增加了 embedding 本地推理能力。鉴于 SqlAlchemy 框架存在一些限制，我们对关系数据库交互模块进行了重写，以更灵活地实现数据库操作。在实践中，大型模型产品需要与多个用户和多个模型对接，因此在 ModelCache 中增加了对多租户的支持，同时也初步兼容了系统指令和多轮会话。更详细的功能对比请参见表 1。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333"><img alt="" src="https://img.alicdn.com/imgextra/i4/O1CN01P0Zr401heMlvow7LH_!!6000000004302-0-tps-716-788.jpg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0; text-align:center"><span>表 1. ModelCache 与 GPTCache 功能点对比</span></p><span id="OSC_h3_9"></span><h3><span>3.2 功能升级</span></h3><p style="margin-left:0; margin-right:0"><span style="color:inherit">为了将 Cache 产品应用于企业级用户，并实现真正的落地效果，我们对其功能进行了大量迭代升级，核心功能如图 3 所示。</span></p><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/2756586/1693799564935-9cb1f565-58a4-4f83-af78-54aaace84668.png" width="657" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:center"><span>图 3. ModelCache 核心功能</span></p><span id="OSC_h4_10"></span><h4><span>3.2.1 数据管理</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">Cache 需要确保过时或不必要的数据不会在缓存中累积，缓存管理是 Cache 中关键的一环，为此，我们实现了两个重要的功能：</span></p><ul><li><span>一键清空能力：</span><span style="color:#333333">ModelCache 中提供了数据移除接口，使用户能够一键清空其缓存。这项功能确保当模型版本或者参数发生变更时，前期版本的数据不会对线上的回答造成干扰。</span></li><li><span>缓存淘汰策略：</span><span style="color:#333333">ModelCache 支持可定制化的缓存淘汰策略，使用户能够根据自身需求来定制缓存。</span></li></ul><span id="OSC_h4_11"></span><h4><span>3.2.2 数据隔离</span></h4><p style="margin-left:0; margin-right:0"><span>在实际应用中，数据隔离是一个重要的功能，为了满足不同场景的需求，ModelCache 实现了多种数据隔离功能，包括：</span></p><ul><li><span>环境隔离： 支持在不同环境中进行数据隔离，包括 DEV、预发和线上环境。这些环境可能存在模型版本和参数上的差异，因此确保了数据在不同环境中的独立性。</span></li><li><span>模型隔离： 支持模型级别的隔离，使用向量数据库表和 OB 表字段实现独立存储。通过这种方式，不同模型之间的数据可以得到有效的隔离，确保数据的安全性和完整性。</span></li></ul><span id="OSC_h4_12"></span><h4><span>3.2.3 数据回流</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">数据回流功能具有知识持久化的能力，能够确保系统重要数据得到有效地保存和持续使用，从而支持系统的长期发展。为此，Cache 中提供了数据回流功能，使得系统中的数据能够得到有效的持久化，这项功能采用异步方式进行，尽可能减少对系统性能的影响。</span></p><span id="OSC_h4_13"></span><h4><span>3.2.4 system 指令及多轮对话支持</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在 ModelCache 中，提供了 system 指令和多轮对话支持，以满足用户的需求。具体如下：</span></p><ul><li><span style="color:#333333">system 指令支持： ModelCache 中支持 system 指令，尤其是后续用户可以自定义 system 指令的情况下，会区分不同 system 指令下对话的语义相似性，保持 Cache 的稳定性，未来，我们还计划将 system 指令与会话进行分离，以进一步提升系统的灵活性和可扩展性。</span></li><li><span style="color:#333333">多轮对话能力： ModelCache 还支持多轮对话，即能够匹配连续对话的语义相似性。</span></li></ul><span id="OSC_h4_14"></span><h4><span>3.2.5 可迁移性</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">ModelCache 具有出色的可迁移性，能够适应不同的场景，OceanBase 可以无缝迁移至 mysql 等产品，Milvus 也是一种可快速部署的数据库服务，所以无论是专有云还是公有云都能够快速应对，并提供高质量的服务。这种可迁移性意味着，ModelCache 可以为用户提供更加灵活和可扩展的部署方案，以满足不同的需求和场景。</span></p><span id="OSC_h4_15"></span><h4><span>3.2.6 Embedding 能力</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在当前的 cache 中，用户可使用中文通用 embedding 模型（text2vec-base-chinese）。我们也支持大模型 embedding 层的嵌入能力，这使得 embedding 能够更好地适应模型本身的语义，但仅使用大模型的 embedding 层，演变成了词袋模型，无法获取各个 token 的权重。为此，我们在训练 SGPT（GPT Sentence Embeddings<span>&nbsp;</span></span><span>for Semantic<span>&nbsp;</span></span><span style="color:#333333">Search），以更好的支持 ModelCache。</span></p><span id="OSC_h2_16"></span><h2>&nbsp;</h2><span id="OSC_h2_17"></span><h2><span>4 效果统计</span></h2><span id="OSC_h4_18"></span><h4><span>4.1 效率统计</span></h4><p style="margin-left:0; margin-right:0"><span>依据蚂蚁内部大模型产品的 GOC 日志信息，统计了缓存命中时长和直接调用模型时长，因为产品端采用了流式输出，时间上会有一定的增加。经过实际系统统计，命中缓存可以将平均耗时降低 10 倍，整体有效提速率可达 14.5%。有效提速率的定义参见下面公式：</span></p><p style="margin-left:0; margin-right:0"><span><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/ba80167f7563caedd5661a48c7813188.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">根据回流数据（排除流式输出的延迟），对缓存的耗时进行了评估，缓存未命中的耗时已经控制在数百毫秒量级，我们仍在持续进行查询耗时的优化。</span></p><span id="OSC_h4_19"></span><h4><span>4.2 embedding 模型的持续优化</span></h4><p style="margin-left:0; margin-right:0"><span style="color:#333333">在缓存场景中，我们发现仅仅评估语义相似性是不够的，核心目标应该是判断 query 对应的大型模型输出是否一致（query 的语义相似不等价于大型模型的回复一致）。例如下面的 query，一词之差，但生成的结果是完全不同的</span></p><ul><li><ul><li><span style="color:#333333">query: 从 1 遍历到 1000，找出所有能被 13 和 23 整除的数字，用 Python 实现</span></li><li><span style="color:#333333">query: 从 1 遍历到 1000，找出所有能被 13 和 23 整除的数字，用 Java 实现</span></li></ul></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#333333">我们调研了 SentenceTransformer 领域的诸多模型，但都无法满足缓存场景的需求。因此训练了一个面向企业级应用的 embedding 模型，并希望在此基础上进一步提升语义相似度评估的准确性，以提高缓存的准确率。</span></p><span id="OSC_h2_20"></span><h2><span>5 未来展望</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#333333">未来，我们旨在提供性能更强、精度更高的解决方案，以满足 LLM Cache 场景下的需求。将不断地进行研究和优化，以确保 Cache 系统能够在实际应用中取得最佳的性能和准确性</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">在性能方面，将通过深入优化各个环节，包括算法、数据和计算资源，以实现更快的召回时间，目标是将整体处理时间压缩到 300 毫秒以内，以提供更快捷高效的用户体验。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#333333">在精度方面，将注重语义模型的建设，通过深入研究和改进语义表示技术，致力于提升模型对复杂语义的准确理解能力，从而更精准地匹配用户的 query。此外，还会对相似度评估模块进行优化，以进一步提升召回率。我们将综合考虑多种评估指标，如准确度、召回率和 F1 分数，以确保模型在各个方面都取得显著的提升。</span></p><span id="OSC_h2_21"></span><h2>&nbsp;</h2><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#333333">想了解更多 CodeFuse 详情，点击进入</span><span style="color:#000000">CodeFuse 官网：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcodefuse.alipay.com%2F" target="_blank" rel="nofollow">https://codefuse.alipay.com</a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 08:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6942768/blog/10143074</guid>
            <link>https://my.oschina.net/u/6942768/blog/10143074</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Seata 进入 Apache 孵化器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#191919">Apache 基金会邮件列表<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fincubator.apache.org%2Fprojects%2Fseata.html" target="_blank">显示</a>，2023 年 10 月 29 日，分布式事务开源项目 Seata 正式通过 Apache 基金会的投票决议，正式成为 Apache 孵化器项目。</span></p><p><span style="background-color:#ffffff; color:#191919">Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</span></p><p><img height="243" src="https://oscimg.oschina.net/oscnet/up-d0f430ca0d175df97cdbcae3599abb935b9.png" width="700" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">2019 年 1 月，阿里巴巴中间件团队发起了开源项目<span>&nbsp;</span><a href="https://www.oschina.net/p/fescar" target="_blank">Fescar</a>（Fast &amp; EaSy Commit And Rollback），和社区一起共建开源分布式事务解决方案。Fescar 的愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><strong>Fescar 开源后，蚂蚁金服加入 Fescar 社区参与共建，并在 Fescar 0.4.0 版本中贡献了 TCC 模式。</strong></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">为了打造更中立、更开放、生态更加丰富的分布式事务开源社区，经过社区核心成员的投票，大家决定对 Fescar&nbsp;进行品牌升级，并更名为<span>&nbsp;</span><strong>Seata</strong>，意为：<strong>Simple Extensible Autonomous Transaction Architecture</strong>，是一套一站式分布式事务解决方案。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 08:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266588/seata-apache-incubator</guid>
            <link>https://www.oschina.net/news/266588/seata-apache-incubator</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux 内核中 Rust 的最新状态]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">在近日举行的 Linux Plumbers Conference 上，Linux 和 Rust 开发人员 Miguel Ojeda 向 Linux 内核开发人员介绍了有关 Linux 内核中 Rust 的最新情况。简而言之，Rust Linux 正在不断走向成熟，并得到了思科、三星和 Canonical 等开发者和供应商的大力支持。</span></p><p><span style="color:#000000">目前，一些发行版已经张开双臂拥抱 Rust。例如，Ubuntu 已经提供了「构建和测试树外内核模块所需的所有必要工具链和内核要求」。</span></p><p><span style="color:#000000">三大 Linux Rust 工具链也正在形成。一个是 rustc 的 GCC codegen，该工具链无需修改源代码即可编译并启动主线 Rust 和 Linux。</span></p><p><span style="color:#000000">另一个是 GCC Front-End for Rust，它可以由现有的 rustc 前端加载，但受益于 GCC 的优化；不过该项目仍处于 alpha 阶段。还有一个是 Coccinelle for Rust；Coccinelle 是一个用于制作大规模 Linux 内核 C 源代码的工具，而 Coccinelle for Rust 正试图将这一功能引入 Rust 代码库。</span></p><p><span style="color:#000000">一些开发者还在尝试使用 Rust 编写驱动程序。至于一些使 Rust 与 Linux 完全集成所需的日常工作，均可以在&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frust-for-linux.com%2F" target="_blank">Rust for Linux</a> 这一官方网站查询更多详情。</span></p><p><img height="222" src="https://oscimg.oschina.net/oscnet/up-331334d8e76a3e1efb2f883a44a9c3d254b.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">开发了两年之久的原始 rust 代码分支已经退役；代码还在，但已被冻结和归档。今后，rust-next 分支将包含新的 Rust 特性，并在 Linux 内核的下一个合并窗口中提交。而这个分支，顾名思义就是 Linux Next 的一部分。</span></p><p><span style="color:#000000">Rust-fixes 分支则包含 Linux 内核当前周期的 Rust 修复。还有一个用于集成的实验分支 Rust-dev ，是一个"look good enough"的补丁队列。</span></p><p><span style="color:#000000">理所当然的是，前进之路并非一帆风顺。Rust on Linux 的开发人员在过程中发现了一些问题：例如，当两个或多个线程等待另一个线程结束时，死锁在 Rust 中是安全的，因为它们不会导致未定义的行为，但它们在 Linux 内核中却不安全。目前开发人员正在努力解决这个问题。</span></p><p><span style="color:#000000">另一方面，开发人员还在担心如何处理 Rust 版本的问题。因为最新版本的 Rust Linux 兼容一些不稳定的功能，所以他们无法保证较新的 Rust 版本能在 Linux 中运行。Linux Rust 程序员现下正在跟踪最新版本的 Rust 编译器。</span></p><p><span style="color:#000000">与此相关的一个问题是，大众对将 Rust 支持反向移植到的 Linux 的 LTS 版本（特别是 5.15 和 6.1）中越来越感兴趣。但 Linux 通常不允许将 Rust 移植到 LTS Linux 中。因此，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zdnet.com%2Farticle%2Frust-in-linux-where-we-are-and-where-were-going-next%2F" target="_blank">ZDNet</a> 指出，如果你真的非常想要在旧版的 LTS 内核中获得功能齐全的 Rust 支持，那么你就需要以某种方式支付费用。</span></p><p><span style="color:#000000">总的来说，Rust 无疑正在成为 Linux 开发的重要语言。但在这一进程中无疑还有许多挑战需要克服，正如 Ojeda&nbsp;所述，虽然「核心团队随着新成员的加入而成长」，但前进之路上仍有很多工作要完成。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 08:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266584/rust-in-linux</guid>
            <link>https://www.oschina.net/news/266584/rust-in-linux</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Telegram 演示运行于 visionOS 的原生应用]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Telegram 创始人帕维尔-杜罗夫 (Pavel Durov) 今天展示了 Telegram 即将推出的 visionOS 应用程序的简短一瞥，这是我们目前看到的首批第三方 visionOS 应用程序概念之一。</p><p>在 Telegram 上提供的视频中，Telegram 应用采用了半透明设计，与周围区域融为一体，这也是苹果为 visionOS 所采用的设计语言。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-22ca9cb9d4938d2680c3ed6406f83b992af.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1115/150409_gDLb_2720166.png" referrerpolicy="no-referrer"></p><p>该应用的侧边栏列出了用户正在进行的所有可用对话。播放的视频会从界面中跳出，变得更加身临其境，而 emoji 字符则会占据显示屏，并在分享时以独特的方式呈现出动画效果。用户可以使用虚拟键盘或通过 Siri 听写来发送信息。</p><p>与主页界面上的所有 visionOS 图标一样，Telegram 图标在被视觉选中时会以动画的形式弹出，动画可作为应用程序被突出显示的视觉提示。由于 Vision Pro 头显使用眼睛和手势导航，因此手指轻点即可启动应用。</p><p>苹果预计将于 2024 年初推出 Vision Pro，也就是四月份或之前。随着首发日期的临近，我们很快就会看到许多其他第三方应用程序的 VisionOS 体验。</p><p><strong>演示视频可用 Telegram 观看：</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ft.me%2Fdurov%2F239" target="_blank">https://t.me/durov/239</a></p><hr><p>延伸阅读</p><ul><li><a href="https://www.oschina.net/news/244019/visionos-apples-latest-operating-system">苹果宣布最新操作系统：visionOS</a></li><li><a href="https://www.oschina.net/news/251993">Vision Pro 新专利：可模拟生成气味</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 07:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266572/telegram-visionos-app</guid>
            <link>https://www.oschina.net/news/266572/telegram-visionos-app</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[ChatGPT Plus 临时暂停新用户注册，CEO 称服务器扛不住了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenAI 首席执行官 Sam Altman 今日<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fsama%2Fstatus%2F1724626002595471740" target="_blank">发表推文称</a></u>，目前暂时暂停 ChatGPT Plus 新用户注册，原因是<strong>「自 DevDay 大会后，ChatGPT 使用量的激增超出了我们的承受能力，我们希望确保每个人都有良好的体验」</strong>。</p><p><img src="https://static.oschina.net/uploads/space/2023/1115/134613_H0qt_2720166.png" referrerpolicy="no-referrer"></p><blockquote><p>via&nbsp;<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fsama%2Fstatus%2F1724626002595471740" target="_blank">https://twitter.com/sama/status/1724626002595471740</a></u></em></p></blockquote><p><span>上周 ChatGPT 因为流量过高导致服务不稳定，</span><u><a href="https://www.oschina.net/news/265693">而中断了 2 个小时</a></u><span>。半年前，OpenAI 刚上线 ChatGPT Plus 订阅计划时，也是这番操作：</span><em><u><a href="https://www.oschina.net/news/235524/openai-has-temporarily-stopped-selling-the-plus" target="_blank">OpenAI 暂时关闭 ChatGPT Plus 升级</a></u></em><span>。</span></p><p>根据调查机构&nbsp;Writerbuddy.ai&nbsp;公布的一份报告，排名前 50 名的 AI 工具在 10 个月中累计被访问 240 亿次，<strong>而其中 ChatGPT 达到了惊人的 146 亿次，占比超过 60%，平均每月访问 15 亿次</strong>。排名前十的还有 Hugging Face、谷歌 BARD、Novel AI、Capcut、Janitor AI 和 Civit AI 等等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b6328a3f5e61c49394df02d7c0d63287218.png" referrerpolicy="no-referrer"></p><p>OpenAI 于 11 月 7 日举行了其首届开发者大会 DevDay，期间<u><a href="https://www.oschina.net/news/265331/openai-custom-versions-chatgpt"> CEO 重磅推出 GPTs </a></u>——允许开发者和公司定制 ChatGPT，以满足他们的特定需求和服务。</p><p><img height="802" src="https://static.oschina.net/uploads/space/2023/1115/141558_VJJd_2720166.png" width="1452" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#000000">GPTs 是一种新方式，任何人都可以创建 ChatGPT 的定制版本，以便在日常生活、特定任务、工作或家庭中更有帮助，然后与其他人分享该创作。例如，GPTs 可以帮助你学习任何棋盘游戏的规则、帮助你指导孩子的数学或设计贴纸。</span></p><p><em>DevDay 大会回顾</em></p><ul><li><u><em><a href="https://www.oschina.net/news/265330" target="_blank">OpenAI 开发者大会：GPT-4 Turbo、GPTs 商店、128k 上下文窗口、大降价</a></em></u></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 05:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266554</guid>
            <link>https://www.oschina.net/news/266554</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[悬赏十几万元以用 Rust 重写 Prettier]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Facebook 法国前端工程师、React Native 和 Prettier 的联合创始人 Vjeux&nbsp;在 Twitter </span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2FVjeux%2Fstatus%2F1722733472522142022" target="_blank">发帖</a><span style="color:#000000">，寻求有能力的开发者来使用 Rust 重写前端代码格式化工具&nbsp;Prettier，并悬赏 1 万美元。</span></p><blockquote><p><span style="color:#000000">使用 Rust 实现更快、更美观的 printers 引起了广泛关注。但主要问题在于，它们都无法与 prettier 的长尾格式化逻辑相匹配。</span></p><p><span style="color:#000000">如果用 Rust 编写的项目能通过通过 95% 以上的 prettier JavaScript 测试，我将悬赏 1 万美元。</span></p></blockquote><p><img alt="" height="229" src="https://oscimg.oschina.net/oscnet/up-6f7c5921c3486449f168f164f0c04ed72c1.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Vercel 的首席执行官&nbsp;Guillermo Rauch&nbsp;也跟帖<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Frauchg%2Fstatus%2F1723400569392656771" target="_blank">表示</a>，进一步对该悬赏进行加码，将赏金升级到了 2 万美元。</span></p><p><span style="color:#000000">此外，Wasmer 官方也附议了&nbsp;Vjeux 的这一提议，并表示将额外提供 2500 美元的奖励。「我们喜欢这一倡议！如果项目编译到 WASIX 并（通过 CI）发布到 Wasmer，我们将为项目所有者额外奖励 2500 美元。」</span></p><p><span style="color:#000000">Prettier 是一个 「有主见」 的代码格式化工具。它通过解析你的代码并根据自己的规则 re-printing（将最大行长考虑在内），并在必要时对代码进行封装，从而实现一致的风格。简而言之，这个工具能够使输出代码保持风格一致。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 04:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266545/rewriting-prettier-rust</guid>
            <link>https://www.oschina.net/news/266545/rewriting-prettier-rust</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[11.25 源创会杭州站报名开启：从数据到大模型应用]]>
            </title>
            <description>
                <![CDATA[11.25 源创会杭州站报名开启：从数据到大模型应用]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 03:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/action/visit/ad?id=1558</guid>
            <link>https://www.oschina.net/action/visit/ad?id=1558</link>
        </item>
        <item>
            <title>
                <![CDATA[李彦宏：百度目前 20% 代码由 AI 完成]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#222222">11 月 15 日，李彦宏在深圳举行的西丽湖论坛上表示，</span><span style="background-color:#ffffff; color:#3b3b3b">百度已经对旗下各产品线进行了 AI 原生化重构，</span><span style="background-color:#ffffff; color:#222222">百度每 100 行代码，20 行就由 AI 完成。</span></p><p><span style="background-color:#ffffff; color:#222222">他表示，大模型是基础底座，类似操作系统不会太多，重复开发大模型是对基础资源的浪费。文心一言有了很大进步，其调用量比国内其他两百家还多。</span></p><p><span style="background-color:#ffffff; color:#222222">目前，文心一言已有 800 万开发者，开发者可以通过插件调用文心一言。</span></p><p><img height="304" src="https://static.oschina.net/uploads/space/2023/1115/111350_ZpLo_4252687.png" width="700" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 03:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266536</guid>
            <link>https://www.oschina.net/news/266536</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[「零一万物」 回应 Yi 开源大模型「套壳」 Llama]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>李开复旗下 AI 公司<span style="background-color:#ffffff; color:#333333">「</span>零一万物<span style="background-color:#ffffff; color:#333333">」&nbsp;</span>(<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2F01.AI" target="_blank">01.AI</a>)&nbsp;<span style="background-color:#ffffff; color:#333333">上周</span><u><a href="https://www.oschina.net/news/265142/01-ai-valued-at-1b-open-source-yi-llm" target="_blank">宣布</a></u><strong>推出&nbsp;Yi-34B 和&nbsp;Yi-6B 两个开源大模型。</strong>其公布的基准测试结果显示虽然模型参数少于其它大模型，但性能更出色。零一万物的估值高达 10 亿美元，已跻身独角兽行列。</p><p>Yi 正式开源数日后，在其<span style="background-color:#ffffff; color:#333333"><span>&nbsp;</span>Hugging Face 主页的讨论区中，有人指出&nbsp;</span>Yi-34B 完全使用了 Meta 开源大模型 Llama 的架构，最明显的变化只是修改了张量 (Tensor) 名称。</p><p><img alt="111349_Novu_2720166.png" src="https://static.oschina.net/uploads/space/2023/1114/111349_Novu_2720166.png" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#333333">来源：</span><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11" target="_blank">https://huggingface.co/01-ai/Yi-34B/discussions/11</a></u></em></p><p>根据公开的信息，Yi 系列开源大模型没有在开源 License 中提及 Llama。上面的帖子内容经过广泛传播后，零一万物的 Yi 系列大模型被质疑是 Llama 的套壳。</p><p>昨天，「零一万物」 正式公开回应了此事。根据该公司开源团队总监<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">&nbsp;</a></u><span style="background-color:#ffffff"><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2F01-ai%2FYi-34B%2Fdiscussions%2F11%236553145873a5a6f938658491" target="_blank">Richard Lin 的跟帖回复</a></u>，他们承认了修改 Llama 张量名称的做法不妥，并会按照建议进行修改。</span></p><p>Richard Lin 称此问题是团队的疏忽。因为在大量的训练实验中，<strong>他们对代码进行了多次重命名，以满足实验要求</strong>。但最后没有在发布之前将它们改回来。他为这个失误造成的混乱表示抱歉。</p><p><span style="background-color:#ffffff">与此同时，Richard Lin 邀请这名指出问题的开发者提交包含上述改动的 PR——对 Yi 的张量名称进行重命名以符合 Llama 架构。</span></p><p><img src="https://oscimg.oschina.net/oscnet/up-5607cfe7fee8c2aaf087104396bd1d3d785.png" referrerpolicy="no-referrer"></p><p>最后，<span style="background-color:#ffffff">Richard Lin&nbsp;</span>表示团队会增强对流程的执行，避免此类错误再次发生，他们也将再次检查所有代码，确保其他一切正常。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266525</guid>
            <link>https://www.oschina.net/news/266525</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[EmotiVoice —— 多音色提示控制 TTS 引擎]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong>EmotiVoice（易魔声）</strong>是一个强大的开源 TTS 引擎，支持中英文双语，包含 2000 多种不同的音色，以及特色的<strong>情感合成</strong>功能，支持合成包含快乐、兴奋、悲伤、愤怒等广泛情感的语音。</p><p>EmotiVoice 提供一个易于使用的 Web 界面，还有用于批量生成结果的脚本接口。</p><p>点此查看具体示例：<em><u><a href="https://github.com/netease-youdao/EmotiVoice/blob/main/README.zh.md">https://github.com/netease-youdao/EmotiVoice/blob/main/README.zh.md</a></u></em></p></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/emotivoice</guid>
            <link>https://www.oschina.net/p/emotivoice</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 3D 裸眼风扇屏]]>
            </title>
            <description>
                <![CDATA[<p>项目说明</p><p>本项目是制作一个 3D 裸眼风扇广告机，它是一款裸眼 D 的新型产品，采用晶片、磁铁、发光二极管 (LED) 技能及螺旋桨叶片组合而成,叶片在驱动下随之动弹，继而显现出 D 浮空影像。同时还设计了喇叭，可以实现播放视频、听音乐功能</p><p>视频介绍：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1tN411y7ZS%2F">https://www.bilibili.com/video/BV1tN411y7ZS/</a></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/EE64VlOi1zKg5iufuLVZ46TzYQD5CyY1EIlaoftN.png" alt="输入图片说明" referrerpolicy="no-referrer"></p><p>开源协议</p><p>依据 GPL 3.0 开源协议，可以复制、修改和传播，并且不限制商业使用。</p><p>项目相关功能</p><p>1.图片显示，160x160 的分辨率，上传 jpeg 图片格式，可以显示多张图片</p><p>2.视频播放，不能直接播放 MP4 文件，需要单独解码后才能播放</p><p>3.音乐播放，可以播放音乐 wav 文件。</p><p>4.云端控制，使用手机 APP 进行控制。包括上传图片，开启/停止功能，按钮选择功能</p><p>项目属性</p><p>本项目为首次公开，为本人原创项目。项目未曾在别的比赛中获奖。</p><p>项目进度</p><p>2023 年 2 月 14 日，开始设计</p><p>2023 年 3 月 30 日，完成第一版设计，40x40 分辨率</p><p>2023 年 4 月 4 日，开始设计第二版本提高清晰度，160x160 分辨率</p><p>2023 年 4 月 15 日，开始编写 ESP32 程序，调试电机驱动，LED 显示，音乐播放功能。</p><p>2023 年 5 月 10 日，开始编写手机 APP，实现联网远程控制。</p><p>设计原理</p><p>电路部分</p><p>主控芯片选择 ESP32S3，带有 WiFi 功能，可以实现云端控制。ESP32S3 作为一个双核 240MHZ 处理器，有足够的性能解码 JPEG 图片，mp3 音乐文件。</p><p>电机驱动采用 TMC2209 芯片来驱动一个 28 步进电机，低速时可以静音驱动，带来很好的体验，不会影响音乐播放带来噪音。</p><p>LED 灯采用 WS2812 幻彩灯珠，1615 的小体积封装提高分辨率</p><p>音频驱动采用 MAX98357 芯片，可以驱动一个 3W 的小喇叭。</p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/CFYaQ1z8zbUII5cQohjbOsVbOxdZFypDSe3vojc9.png" alt="输入图片说明" referrerpolicy="no-referrer"></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/RHMgoiHGHXX0bkLdOpdoSmeQOL4TWiKnvqgOOZ2d.png" alt="输入图片说明" referrerpolicy="no-referrer"></p><p>外壳部分</p><p>使用 FreeCAD 软件进行外壳设计。在本次结构设计中有一个难点就是如何给电路板供电，采用电池供电但是续航不久，于是不采用。使用外置电源不用考虑续航问题，但绕线是个问题。于是设计了一个采用轴承导电的机构。其他零件使用 3D 打印出来。</p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/1tbNw9FV6ZrYcSQyd77pQUfiaCVZzsD01rQS1G1d.png" alt="输入图片说明" referrerpolicy="no-referrer"></p><p>软件说明</p><p>ESP32 主控</p><p>ESP32 主控主要是编写 LED 驱动程序，JPEG 图片解码程序，wav 音乐解码播放，已及通 MQTT 订阅来接收云端数据，实现远程控制。如下是一些主要代码</p><p>手机 APP</p><p>手机 App 是使用前端 html 和 JavaScript 写的一个网页，然后对网页打包成安卓应用。实现的功能主要有上传图片，控制 esp32 的各种功能。部分程序如下</p><p>此外为了实现流畅播放视频，我单独使用 python 脚本对视频进行了解码。</p><p>实物展示</p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/BDFCIOQkqrGEZcxuzO4QxZbk8wA5NyMuNJfNLNzm.jpeg" alt="输入图片说明" referrerpolicy="no-referrer"></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/JH1S503sxnVDZRkepAYyLV9BkgoL1VhoYjJtwW90.jpeg" alt="输入图片说明" referrerpolicy="no-referrer"></p><p><img src="https://gitee.com/qzr123/3-d-bare-eye-fan-screen/raw/master/%E5%9B%BE%E7%89%87/YWbrYCHZBPEeR5dIZoKDOrNhZc62yBtoJYfjzUgY.jpeg" alt="输入图片说明" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>其他</p><p>视频讲解稍后上传</p>]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/qzr123/3-d-bare-eye-fan-screen</guid>
            <link>https://gitee.com/qzr123/3-d-bare-eye-fan-screen</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | MYSQL 事务的底层原理]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><span><span>事务的底层原理</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在事务的实现机制上，MySQL 采用的是 WAL：Write-ahead logging，预写式日志，机制来实现的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在使用 WAL 的系统中，所有的修改都先被写入到日志中，然后再被应用到系统中。通常包含 redo 和 undo 两部分信息。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>为什么需要使用 WAL，然后包含 redo 和 undo 信息呢？举个例子，如果一个系统直接将变更应用到系统状态中，那么在机器掉电重启之后系统需要知道操作是成功了，还是只有部分成功或者是失败了。如果使用了 WAL，那么在重启之后系统可以通过比较日志和系统状态来决定是继续完成操作还是撤销操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>redo log 称为重做日志，每当有操作时，在数据变更之前将操作写入 redo log，这样当发生掉电之类的情况时系统可以在重启后继续操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>undo log 称为撤销日志，当一些变更执行到一半无法完成时，可以根据撤销日志恢复到变更之间的状态。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>MySQL 中用 redo log 来在系统 Crash 重启之类的情况时修复数据，而 undo log 来保证事务的原子性。</span></span></span></p><span id="OSC_h2_2"></span><h2><span><span><span>事务 id</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>一个事务可以是一个只读事务，或者是一个读写事务：可以通过 START TRANSACTION READ ONLY 语句开启一个只读事务。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在只读事务中不可以对普通的表进行增、删、改操作，但可以对用户临时表做增、删、改操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以通过 START TRANSACTION READ WRITE 语句开启一个读写事务，或者使用 BEGIN、START TRANSACTION 语句开启的事务默认也算是读写事务。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在读写事务中可以对表执行增删改查操作。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>如果某个事务执行过程中对某个表执行了增、删、改操作，那么 InnoDB 存储引擎就会给它分配一个独一无二的事务 id，针对 MySQL 5.7 分配方式如下：</span></strong></span></span></p><ul><li><span><span><span><span>对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个事务 id，否则的话是不分配事务 id 的。</span></span></span></span></li><li><span><span><span><span>对于读写事务来说，只有在它第一次对某个表执行增、删、改操作时才会为这个事务分配一个事务 id，否则的话也是不分配事务 id 的。</span></span></span></span></li><li><span><span><span><span>有的时候虽然开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个事务 id。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>这个事务 id 本质上就是一个数字，它的分配策略和隐藏列 row_id 的分配策略大抵相同，具体策略如下：</span></strong></span></span></p><ul><li><span><span><span><span>服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个事务 id 时，就会把该变量的值当作事务 id 分配给该事务，并且把该变量自增 1。</span></span></span></span></li><li><span><span><span><span>每当这个变量的值为 256 的倍数时，就会将该变量的值刷新到系统表空间的页号为 5 的页面中一个称之为 Max Trx ID 的属性处，这个属性占用 8 个字节的存，储空间。</span></span></span></span></li><li><span><span><span><span>当系统下一次重新启动时，会将上边提到的 Max Trx ID 属性加载到内存中，将该值加上 256 之后赋值给全局变量，因为在上次关机时该全局变量的值可能大于 Max Trx ID 属性值。</span></span></span></span></li><li><span><span><span><span>这样就可以保证整个系统中分配的事务 id 值是一个递增的数字。先被分配 id 的事务得到的是较小的事务 id，后被分配 id 的事务得到的是较大的事务 id。</span></span></span></span></li></ul><span id="OSC_h2_3"></span><h2><span><span><span>mvcc</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>全称 Multi-Version Concurrency Control，即多版本并发控制，主要是为了提高数据库的并发性能。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>同一行数据平时发生读写请求时，会上锁阻塞住。但 MVCC 用更好的方式去处理读写请求，做到在发生读写请求冲突时不用加锁。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这个读是指的快照读，而不是当前读，当前读是一种加锁操作，是悲观锁。</span></span></span></p><span id="OSC_h3_4"></span><h3><span><span><span>MVCC 原理</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在事务并发执行遇到的问题如下：</span></span></span></p><ul><li><span><span><span><span>脏读：如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了脏读；</span></span></span></span></li><li><span><span><span><span>不可重复读：如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了不可重复读；</span></span></span></span></li><li><span><span><span><span>幻读：如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了幻读，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录，幻读只是重点强调了读取到了之前读取没有获取到的记录。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>MySQL 在 REPEATABLE READ 隔离级别下，是可以很大程度避免幻读问题的发生的。</span></strong></span></span></p><span id="OSC_h4_5"></span><h4><span><span><span>版本链</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：</span></span></span></p><ul><li><span><span><span><span>trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务 id 赋值给 trx_id 隐藏列；</span></span></span></span></li><li><span><span><span><span>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo 日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修，改前的信息；</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>演示</span></strong></span></span></p><pre><code><span><span><span style="color:#708090">-- 创建表</span></span><span><span></span></span><span><span style="color:#0077aa">CREATE</span></span><span><span></span></span><span><span style="color:#0077aa">TABLE</span></span><span><span> mvcc_test </span></span><span><span style="color:#999999">(</span></span><span><span>
id </span></span><span><span style="color:#0077aa">INT</span></span><span><span style="color:#999999">,</span></span><span><span>
name </span></span><span><span style="color:#0077aa">VARCHAR</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">100</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">,</span></span><span><span>
domain </span></span><span><span style="color:#0077aa">varchar</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">100</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">PRIMARY</span></span><span><span></span></span><span><span style="color:#0077aa">KEY</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span>id</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">Engine</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#0077aa">InnoDB</span></span><span><span></span></span><span><span style="color:#0077aa">CHARSET</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span>utf8</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 添加数据</span></span><span><span></span></span><span><span style="color:#0077aa">INSERT</span></span><span><span></span></span><span><span style="color:#0077aa">INTO</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">VALUES</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'habit'</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">'演示 mvcc'</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>假设插入该记录的事务 id=50，那么该条记录的展示如图：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-497oLuqeLE7xPfzmr.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>假设之后两个事务 id 分别为 70、90 的事务对这条记录进行 UPDATE 操作。</span></span></span></p><div><table cellspacing="0" style="--tw-ring-color:rgba(59,130,246,.5); --tw-ring-inset:var(--tw-empty,/*!*/ /*!*/); --tw-ring-offset-color:#ffffff; --tw-ring-offset-shadow:0 0 #0000; --tw-ring-offset-width:0px; --tw-ring-shadow:0 0 #0000; --tw-shadow:0 0 #0000; border-collapse:collapse; border-color:inherit; border-style:solid; border-width:0px; box-sizing:border-box; margin:0px; outline:none; padding:0px; text-indent:0px; width:auto"><tbody><tr><th style="background-color:var(--w-e-textarea-slight-bg-color); text-align:center"><span><span><span>trx_id=70</span></span></span></th><th style="background-color:var(--w-e-textarea-slight-bg-color); text-align:center"><span><span><span>trx_id=90</span></span></span></th></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>begin</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>begin</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_70_01' where id=1</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_70_02' where id=1</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>commit</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_90_01' where id=1</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>update mvcc_test set name='habit_trx_id_90_02' where id=1</span></span></span></td></tr><tr><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>﻿</span></span></span></td><td style="border-style:solid; border-width:1px; text-align:left"><span><span><span>commit</span></span></span></td></tr></tbody></table></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>每次对记录进行改动，都会记录一条 undo 日志，每条 undo 日志也都有一个 roll_pointer 属性，可以将这些 undo 日志都连起来，串成一个链表。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-49y0loF49tpKQ7swfq.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>对该记录每次更新后，都会将旧值放到一条 undo 日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务 id。于是可以利用这个记录的版本链来控制并发事务访问相同记录的行为，那么这种机制就被称之为：</span></span></span><span><span><strong><span>多版本并发控制，即 MVCC。</span></strong></span></span></p><span id="OSC_h4_6"></span><h4><span><span><span>ReadView</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于使用 READ UNCOMMITTED 隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于使用 SERIALIZABLE 隔离级别的事务来说，InnoDB 使用加锁的方式来访问记录。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：READ COMMITTED 和 REPEATABLE READ 隔离级别在不可重复读和幻读上的区别是从哪里来的，其实结合前面的知识，这两种隔离级别关键是需要判断一下版本链中的哪个版本是当前事务可见的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>为此，InnoDB 提出了一个 ReadView 的概念，这个 ReadView 中主要包含 4 个比较重要的内容：</span></strong></span></span></p><ul><li><span><span><span><span>m_ids：表示在生成 ReadView 时当前系统中活跃的读写事务的事务 id 列表；</span></span></span></span></li><li><span><span><span><span>min_trx_id：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的事务 id，也就是 m_ids 中的最小值；</span></span></span></span></li><li><span><span><span><span>max_trx_id：表示在生成 ReadView 时系统中应该分配给下一个事务的 id 值，注：max_trx_id 并不是 m_ids 中的最大值，事务 id 是递增分配的。比方说现在有 id 为 1，2，3 这三个事务，之后 id 为 3 的事务提交了。那么一个新的读事务在生成 ReadView 时，m_ids 就包括 1 和 2，min_trx_id 的值就是 1，max_trx_id 的值就是 4；</span></span></span></span></li><li><span><span><span><span>creator_trx_id：表示生成该 ReadView 的事务的事务 id；</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>有了这个 ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</span></span></span></p><ol><li><span><span><span><span>如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问；</span></span></span></span></li><li><span><span><span><span>如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问；</span></span></span></span></li><li><span><span><span><span>如果被访问版本的 trx_id 属性值大于或等于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问；</span></span></span></span></li><li><span><span><span><span>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间 min_trx_id &lt; trx_id &lt; max_trx_id，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问；</span></span></span></span></li><li><span><span><span><span>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录；</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 MySQL 中，READ COMMITTED 和 REPEATABLE READ 隔离级别的一个非常大的区别就是它们生成 ReadView 的时机不同。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>还是以表 mvcc_test 为例，假设现在表 mvcc_test 中只有一条由事务 id 为 50 的事务插入的一条记录，接下来看一下 READ COMMITTED 和 REPEATABLE READ 所谓的生成 ReadView 的时机不同到底不同在哪里。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>READ COMMITTED：</span></strong></span></span><span><span><span> 每次读取数据前都生成一个 ReadView；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比方说现在系统里有两个事务 id 分别为 70、90 的事务在执行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- T 70</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此时表 mvcc_test 中 id 为 1 的记录得到的版本链表如下所示：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-50mpbjn7HMKz7hBhK.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>假设现在有一个使用 READ COMMITTED 隔离级别的事务开始执行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 READ COMMITTED 隔离级别的事务</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值为'habit'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>这个 SELECE1 的执行过程如下：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在执行 SELECT 语句时会先生成一个 ReadView，ReadView 的 m_ids 列表的内容就是[70, 90]，min_trx_id 为 70，max_trx_id 为 91，creator_trx_id 为 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 habit_trx_id_70_02，该版本的 trx_id 值为 70，在 m_ids 列表内，所以不符合可见性要求第 4 条：</span></span></span><span><span><code><strong><span>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间 min_trx_id &lt; trx_id &lt; max_trx_id，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</span></strong></code></span></span><span><span><span>根据 roll_pointer 跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit_trx_id_70_01，该版本的 trx_id 值也为 70，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit，该版本的 trx_id 值为 50，小于 ReadView 中的 min_trx_id 值，所以这个版本是符合要求的第 2 条：</span></span></span><span><span><strong><span>如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</span></strong></span></span><span><span><span>最后返回的版本就是这条列 name 为 habit 的记录。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>之后，把事务 id 为 70 的事务提交一下，然后再到事务 id 为 90 的事务中更新一下表 mvcc_test 中 id 为 1 的记录：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- T 90</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此时表 mvcc 中 id 为 1 的记录的版本链就长这样：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-507DFORnJ7Is10E8bC.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>然后再到刚才使用 READ COMMITTED 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 READ COMMITTED 隔离级别的事务</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 均未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值为'habit'</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE2：Transaction 70 提交，Transaction 90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值为'habit_trx_id_70_02'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>这个 SELECE2 的执行过程如下：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在执行 SELECT 语句时又会单独生成一个 ReadView，该 ReadView 的 m_ids 列表的内容就是[90]，min_trx_id 为 90，max_trx_id 为 91，creator_trx_id 为 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 habit_trx_id_90_02，该版本的 trx_id 值为 90，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit_trx_id_90_01，该版本的 trx_id 值为 90，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit_trx_id_70_02，该版本的 trx_id 值为 70，小于 ReadView 中的 min_trx_id 值 90，所以这个版本是符合要求的，最后返回这个版本中列 name 为 habit_trx_id_70_02 的记录。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>以此类推，如果之后事务 id 为 90 的记录也提交了，再次在使用 READ COMMITTED 隔离级别的事务中查询表 mvcc_test 中 id 值为 1 的记录时，得到的结果就是 habit_trx_id_90_02 了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>总结：</span></strong></span></span><span><span><span>使用 READ COMMITTED 隔离级别的事务在每次查询开始时都会生成一个独立的 ReadView。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>REPEATABLE READ：</span></strong></span></span><span><span><span>在第一次读取数据时生成一个 ReadView；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于使用 REPEATABLE READ 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 ReadView，之后的查询就不会重复生成了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比方说现在系统里有两个事务 id 分别为 70、90 的事务在执行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- T 70</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_70_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此时表 mvcc_test 中 id 为 1 的记录得到的版本链表如下所示：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-51UwvDNOV077PoRbf.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>假设现在有一个使用 REPEATABLE READ 隔离级别的事务开始执行：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 REPEATABLE READ 隔离级别的事务</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值为'habit'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>这个 SELECE1 的执行过程如下：</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在执行 SELECT 语句时会先生成一个 ReadView，ReadView 的 m_ids 列表的内容就是[70, 90]，min_trx_id 为 70，max_trx_id 为 91，creator_trx_id 为 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 habit_trx_id_70_02，该版本的 trx_id 值为 70，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit_trx_id_70_01，该版本的 trx_id 值也为 70，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit，该版本的 trx_id 值为 50，小于 ReadView 中的 min_trx_id 值，所以这个版本是符合要求的，最后返回的就是这条列 name 为 habit 的记录。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>之后，把事务 id 为 70 的事务提交一下，然后再到事务 id 为 90 的事务中更新一下表 mvcc_test 中 id 为 1 的记录：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 REPEATABLE READ 隔离级别的事务</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_01'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">UPDATE</span></span><span><span> mvcc_test &nbsp;</span></span><span><span style="color:#0077aa">SET</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">'habit_trx_id_90_02'</span></span><span><span></span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此刻，表 mvcc_test 中 id 为 1 的记录的版本链就长这样：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-51h9D8xW10EuQBNz51m.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p><span><span><span>然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：</span></span></span></p><pre><code><span><span><span style="color:#708090">-- 使用 REPEATABLE READ 隔离级别的事务</span></span><span><span></span></span><span><span style="color:#0077aa">BEGIN</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE1：Transaction 70、90 均未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">-- 得到的列 name 的值为'habit'</span></span><span><span></span></span><span><span style="color:#708090">-- SELECE2：Transaction 70 提交，Transaction 90 未提交</span></span><span><span></span></span><span><span style="color:#0077aa">SELECT</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">FROM</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">WHERE</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span> &nbsp;</span></span><span><span style="color:#708090">-- 得到的列 name 的值为'habit'</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这个 SELECE2 的执行过程如下：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>因为当前事务的隔离级别为 REPEATABLE READ，而之前在执行 SELECE1 时已经生成过 ReadView 了，所以此时直接复用之前的 ReadView，之前的 ReadView 的 m_ids 列表的内容就是[70, 90]，min_trx_id 为 70，max_trx_id 为 91， creator_trx_id 为 0。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列 name 的内容是 habit_trx_id_90_02，该版本的 trx_id 值为 90，在 m_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit_trx_id_90_01，该版本的 trx_id 值为 90，也在 m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit_trx_id_70_02，该版本的 trx_id 值为 70，而 m_ids 列表中是包含值为 70 的事务 id 的，所以该版本也不符合要求，同理下一个列 name 的内容是 habit_trx_id_70_01 的版本也不符合要求。继续跳到下一个版本。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下一个版本的列 name 的内容是 habit，该版本的 trx_id 值为 50，小于 ReadView 中的 min_trx_id 值 70，所以这个版本是符合要求的，最后返回给用户的版本就是这条列 name 为 habit 的记录。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>也就是说两次 SELECT 查询得到的结果是重复的，记录的列 name 值都是 habit，这就是可重复读的含义。如果之后再把事务 id 为 90 的记录提交了，然后再到刚才使用 REPEATABLE READ 隔离级别的事务中继续查找这个 id 为 1 的记录，得到的结果还是 habit。</span></span></span></p><span id="OSC_h3_7"></span><h3><span><span><span>MVCC 下的幻读解决和幻读现象</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>REPEATABLE READ 隔离级别下 MVCC 可以解决不可重复读问题，那么幻读呢？MVCC 是怎么解决的？幻读是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录，而这个记录来自另一个事务添加的新记录。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以想想，在 REPEATABLE READ 隔离级别下的事务 T1 先根据某个搜索条件读取到多条记录，然后事务 T2 插入一条符合相应搜索条件的记录并提交，然后事务 T1 再根据相同搜索条件执行查询。结果会是什么？按照 ReadView 中的比较规则中的第 3 条和第 4 条不管事务 T2 比事务 T1 是否先开启，事务 T1 都是看不到 T2 的提交的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>但是，在 REPEATABLE READ 隔离级别下 InnoDB 中的 MVCC 可以很大程度地避免幻读现象，而不是完全禁止幻读。怎么回事呢？来看下面的情况：</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-19-51wOnqygonsF10mmAn.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>首先在事务 T1 中执行：</span></span></span><span><span><code><span>select * from mvcc_test where id = 30;</span></code></span></span><span><span><span> 这个时候是找不到 id = 30 的记录的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在事务 T2 中，执行插入语句：</span></span></span><span><span><code><span>insert into mvcc_test values(30,'luxi','luxi');</span></code></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>此时回到事务 T1，执行：</span></span></span></p><pre><code><span><span><span style="color:#0077aa">update</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">set</span></span><span><span> domain</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#669900">'luxi_t1'</span></span><span><span></span></span><span><span style="color:#0077aa">where</span></span><span><span> id</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span style="color:#990055">30</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">select</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">*</span></span><span><span></span></span><span><span style="color:#0077aa">from</span></span><span><span> mvcc_test </span></span><span><span style="color:#0077aa">where</span></span><span><span> id </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">30</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>事务 T1 很明显出现了幻读现象。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 REPEATABLE READ 隔离级别下，T1 第一次执行普通的 SELECT 语句时生成了一个 ReadView，之后 T2 向 mvcc_test 表中新插入一条记录并提交。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>ReadView 并不能阻止 T1 执行 UPDATE 或者 DELETE 语句来改动这个新插入的记录，由于 T2 已经提交，因此改动该记录并不会造成阻塞，但是这样一来，这条新记录的 trx_id 隐藏列的值就变成了 T1 的事务 id。之后 T1 再使用普通的 SELECT 语句去查询这条记录时就可以看到这条记录了，也就可以把这条记录返回给客户端。因为这个特殊现象的存在，可以认为 MVCC 并不能完全禁止幻读。</span></span></span></p><span id="OSC_h3_8"></span><h3><span><span><span>mvcc 总结</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>从上边的描述中可以看出来，所谓的 MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 READ COMMITTD、REPEATABLE READ 这两种隔离级别的事务在执行普通的 SELECT 操作时访问记录的版本链的过程，这样子可以使不同事务的读写、写读操作并发执行，从而提升系统性能。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>READ COMMITTD、REPEATABLE READ 这两个隔离级别的一个很大不同就是：生成 ReadView 的时机不同，READ COMMITTD 在每一次进行普通 SELECT 操作前都会生成一个 ReadView，而 REPEATABLE READ 只在第一次进行普通 SELECT 操作前生成一个 ReadView，之后的查询操作都重复使用这个 ReadView 就好了，从而基本上可以避免幻读现象。</span></span></span></p><span id="OSC_h2_9"></span><h2><span><span><span>InnoDB 的 Buffer Pool</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引，包括：聚簇索引和二级索引，还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只不过是 InnoDB 对文件系统上一个或几个实际文件的抽象，也就是说数据还是存储在磁盘上的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>但是磁盘的速度慢，所以 InnoDB 存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，即使只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘 IO 的开销了。</span></span></span></p><span id="OSC_h3_10"></span><h3><span><span><span>Buffer Pool</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>InnoDB 为了缓存磁盘中的页，在 MySQL 服务器启动的时候就向操作系统申请了一片连续的内存，这块连续内存叫做：Buffer Pool，中文名：缓冲池。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>默认情况下 Buffer Pool 只有 128M 大小。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>查看该值：</span></span></span><span><span><code><span>show variables like 'innodb_buffer_pool_size';</span></code></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以在启动服务器的时候配置 innodb_buffer_pool_size 参数的值，它表示 Buffer Pool 的大小，配置如下：</span></span></span></p><pre><code><span><span><span>[server]
innodb_buffer_pool_size = 268435456</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>其中，268435456 的单位是字节，也就是指定 Buffer Pool 的大小为 256M，Buffer Pool 也不能太小，最小值为 5M，当小于该值时会自动设置成 5M。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>启动 MySQL 服务器的时候，需要完成对 Buffer Pool 的初始化过程，就是先向操作系统申请 Buffer Pool 的内存空间，然后把它划分成若干对控制块和缓，存页。但是此时并没有真实的磁盘页被缓存到 Buffer Pool 中，之后随着程序的运行，会不断的有磁盘上的页被缓存到 Buffer Pool 中。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在 Buffer Pool 中会创建多个缓存页，默认的缓存页大小和在磁盘上默认的页大小是一样的，都是 16KB。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>那么怎么知道该页在不在 Buffer Pool 中呢？</span></strong></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在查找数据的时候，先通过哈希表中查找 key 是否在哈希表中，如果在证明 Buffer Pool 中存在该缓存也信息，如果不存在证明不存该缓存也信息，则通过读取磁盘加载该页信息放到 Buffer Pool 中，哈希表中的 key 是通过表空间号+ 页号作组成的，value 是 Buffer Pool 的缓存页。</span></span></span></p><span id="OSC_h3_11"></span><h3><span><span><span>flush 链表的管理</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果修改了 Buffer Pool 中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为：</span></span></span><span><span><strong><span>脏页</span></strong></span></span><span><span><span>。最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能。所以每次修改缓存页后，并不着急把修改同步到磁盘上，而是在未来的某个时间进行同步。 但是如果不立即同步到磁盘的话，那之后再同步的时候怎么知道 Buffer Pool 中哪些页是脏页，哪些页从来没被修改过呢？总不能把所有的缓存页都同步到磁盘上吧，如果 Buffer Pool 被设置的很大，那一次性同步会非常慢。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>所以，需要再创建一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫 flush 链表。</span></span></span></p><span id="OSC_h3_12"></span><h3><span><span><span>刷新脏页到磁盘</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>从 flush 链表中刷新一部分页面到磁盘，后台线程也会定时从 flush 链表中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为：BUF_FLUSH_LIST。</span></span></span></p><span id="OSC_h2_13"></span><h2><span><span><span>redo 日志</span></span></span></h2><span id="OSC_h3_14"></span><h3><span><span><span>redo 日志的作用</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>InnoDB 存储引擎是以页为单位来管理存储空间的，增删改查操作其实本质上都是在访问页面，包括：读页面、写页面、创建新页面等操作。在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。但是在事务的时候又强调过一个称之为持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果只在内存的 Buffer Pool 中修改了页面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这是所不能忍受的。那么如何保证这个持久性呢？一个很简单的做法就是在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：</span></span></span></p><ol><li><span><span><span><span>刷新一个完整的数据页太浪费了；有时候仅仅修改了某个页面中的一个字节，但是在 InnoDB 中是以页为单位来进行磁盘 IO 的，也就是说在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，一个页面默认是 16KB 大小，只修改一个字节就要刷新 16KB 的数据到磁盘上显然是太浪费了。</span></span></span></span></li><li><span><span><span><span>随机 IO 刷起来比较慢；一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的 Buffer Pool 中的页面刷新到磁盘时，需要进行很多的随机 IO，随机 IO 比顺序 IO 要慢，尤其对于传统的机械硬盘来说。</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好，比方说：某个事务将系统表空间中的第 5 号页面中偏移量为 5000 处的那个字节的值 0 改成 5 只需要记录一下：</span></span></span><span><span><strong><span>将第 5 号表空间的 5 号页面的偏移量为 5000 处的值更新为：5</span></strong></span></span><span><span><span>。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这样在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足持久性的要求。因为在系统崩溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为：</span></span></span><span><span><strong><span>重做日志，即：redo log</span></strong></span></span><span><span><span>。与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的 redo log 刷新到磁盘的好处如下：</span></span></span></p><ol><li><span><span><span><span>redo log 占用的空间非常小存储表空间 ID、页号、偏移量以及需要更新的值所需的存储空间是很小的；</span></span></span></span></li><li><span><span><span><span>redo log 是顺序写入磁盘的在执行事务的过程中，每执行一条语句，就可能产生若干条 redo log，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序 IO；</span></span></span></span></li></ol><span id="OSC_h3_15"></span><h3><span><span><span>redo log 的写入过程</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>InnoDB 为了更好的进行系统崩溃恢复，把一次原子操作生成的 redo log 都放在了大小为 512 字节的块（block）中。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>为了解决磁盘速度过慢的问题而引入了 Buffer Pool。同理，写入 redo log 时也不能直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为 redo log buffer 的连续内存空间，即：redo log 缓冲区，也可以简称：log buffer。这片内存空间被划分成若干个连续的 redo log block，可以通过启动参数 innodb_log_buffer_size 来指定 log buffer 的大小，该启动参数的默认值为：16MB。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>向 log buffer 中写入 redo log 的过程是顺序的，也就是先往前边的 block 中写，当该 block 的空闲空间用完之后再往下一个 block 中写。</span></span></span></p><span id="OSC_h4_16"></span><h4><span><span><span>redo log 刷盘时机</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>log buffer 什么时候会写入到磁盘呢？</span></strong></span></span></p><ul><li><span><span><span><span>log buffer 空间不足时，如果不停的往这个有限大小的 log buffer 里塞入日志，很快它就会被填满。InnoDB 认为如果当前写入 log buffer 的 redo log 量已，经占满了 log buffer 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</span></span></span></span></li><li><span><span><span><span>事务提交时，必须要把修改这些页面对应的 redo log 刷新到磁盘。</span></span></span></span></li><li><span><span><span><span>后台有一个线程，大约每秒都会刷新一次 log buffer 中的 redo log 到磁盘。</span></span></span></span></li><li><span><span><span><span>正常关闭服务器时等等。</span></span></span></span></li></ul><span id="OSC_h2_17"></span><h2><span><span><span>undo 日志</span></span></span></h2><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做。但是偏偏有时候事务执行到一半会出现一些情况，比如：</span></span></span></p><ul><li><span><span><span><span>情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。</span></span></span></span></li><li><span><span><span><span>情况二：程序员可以在事务执行过程中手动输入 ROLLBACK 语句结束当前的事务的执行。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这两种情况都会导致事务执行到一半就结束，但是事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，需要把东西改回原先的样子，这个过程就称之为回滚，即：rollback，这样就可以造成这个事务看起来什么都没做，所以符合原子性要求。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>每当要对一条记录做改动时，都需要把回滚时所需的东西都给记下来。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比方说：</span></span></span></p><ul><li><span><span><span><span>插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉。</span></span></span></span></li><li><span><span><span><span>删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中。</span></span></span></span></li><li><span><span><span><span>修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值。</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这些为了回滚而记录的这些东西称之为撤销日志，即：undo log。这里需要注意的一点是，由于查询操作并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的 undo log。</span></span></span></p><span id="OSC_h3_18"></span><h3><span><span><span>undo 日志的格式</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>为了实现事务的原子性，InnoDB 存储引擎在实际进行增、删、改一条记录时，都需要先把对应的 undo 日志记下来。一般每对一条记录做一次改动，就对应着一条 undo 日志，但在某些更新记录的操作中，也可能会对应着 2 条 undo 日志。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>一个事务在执行过程中可能新增、删除、更新若干条记录，也就是说需要记录很多条对应的 undo 日志，这些 undo 日志会被从 0 开始编号，也就是说根据生成的顺序分别被称为第 0 号 undo 日志、第 1 号 undo 日志、...、第 n 号 undo 日志等，这个编号也被称之为 undo no。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这些 undo 日志是被记录到类型为 FIL_PAGE_UNDO_LOG 的页面中。这些页面可以从系统表空间中分配，也可以从一种专门存放 undo 日志的表空间，也就是所谓的 undo tablespace 中分配。</span></span></span></p><blockquote><p>作者：京东物流，张士欣</p><p>来源：京东云开发者社区，自圆其说 Tech 转载请注明来源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:14:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10142911</guid>
            <link>https://my.oschina.net/u/4090830/blog/10142911</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[🎁有奖问答 | 从 kkFileView 项目出发，聊聊怎么做开源项目]]>
            </title>
            <description>
                <![CDATA[<h1 class="header article-title"><a href="https://www.oschina.net/question/4700705_2331356">高手问答第 309 期 —— 从 kkFileView 项目出发，聊聊怎么做开源项目</a><div class="ui red label horizontal" data-tooltip="置顶">顶</div></h1><div class="extra ui horizontal list meta-wrap"><div class="item"><a href="https://my.oschina.net/u/4700705" class="__user"><span>小白兔爱吃大灰狼</span></a> 发布于，昨天 17:36
                    </div><div class="item">阅读 558</div><div class="item collect-btn " data-id="2331356" data-user-id="4700705" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i> 收藏 <span data-collect-count="" data-id="2331356" data-obj-type="2">0</span></div><div class="item comment-count"><a href="https://www.oschina.net/question/4700705_2331356#comments" class="normal"><i class="comment outline icon"></i> 答案 <span data-article-reply-count="">3</span></a></div></div><div class="tags"><a class="ui horizontal label" href="https://www.oschina.net/question/topic/masteronline" target="_blank"><img src="https://static.oschina.net/uploads/logo/masteronline_9WTeU.png" referrerpolicy="no-referrer">高手问答</a></div><div class="content" id="articleContent"><p><span><span>开源项目是每一个开发者无法绕过的一个词，无论你是否主动接触开源项目，他就在你身边，和你的工作息息相关。本期嘉宾 KL 博主 6 年前一次偶然的机会接触开源项目后，仿佛打开了代码世界的大门，打通了任督二脉。这里有书本上，你在公司里没有的知识和能量。从开源获取，然后反馈开源，是博主一直践行的开源原则，截止目前，博主开源了数 10+ 的项目，也参与了很多社区的项目，比如 apollo 、skywalking 、seata 等。其中 kkFileView 是博主开源最成功的一个项目，目前 kkFileView 获得过开源中国 GVP 项目，在 Gitee 的所有推荐项目里的 star 排名第 10 ，19281 个 star。kkFileView 一直保持着开源的初心，践行着佛性开源的路子做着开源项目。也因为如下：</span></span></p><ul><li><span><span>好的开源项目一定是架构优良可持续扩展优化的</span></span></li><li><span><span>好的开源项目一定是有需求场景，解决实际问题的</span></span></li><li><span><span>好的开源项目一定是有经济支撑可持续维护迭代的</span></span></li><li><span><span>好的开源项目一定是说明齐全，容易上手的</span></span></li></ul><p><span><span>kkFileView 可以一直健康发展迭代。</span></span></p><blockquote><p><span><span>kkFileView 项目地址：</span><a href="https://gitee.com/kekingcn/file-online-preview" target="_blank" rel="nofollow">https://gitee.com/kekingcn/file-online-preview</a></span></p></blockquote><p><strong><span><span>OSCHINA 本期高手问答（11 月 15 日-11 月 21 日）将以「从 kkFileView 项目聊聊怎么做开源项目」为切入点，聊一聊怎么做好开源项目，可讨论的内容包括带不限于以下：</span></span></strong></p><ul><li><span><span>怎么参与开源项目</span></span></li><li><span><span>怎么上手一个新的开源项目</span></span></li><li><span><span>怎么开源一个自己的开源项目</span></span></li><li><span><span>kkFileView 项目相关话题</span></span></li><li><span><span>怎么从开源项目里学以致用</span></span></li><li><span><span>等等</span></span></li></ul><p><span style="background-color:#ffffff; color:#000000">有其他相关问题，也欢迎大家积极提问！</span></p><h1>嘉宾简介</h1><p><span><span style="color:#000000">陈凯玲，网名：KL，在社区里一直以」KL 博主「自称。先后就职于凯京集团和 TapTap，一直从事 Java 架构、中间件、SRE 等开发工作。是开源项目 kkFileView&nbsp; 作者，也是 Apollo 配置中心社区的 PMC。</span></span></p><ul><li><span><span style="color:#000000">Gitee 主页：</span><a href="https://gitee.com/kailing" target="_blank" rel="nofollow">https://gitee.com/kailing</a></span></li><li><span><span>OSC 主页：</span><a href="https://my.oschina.net/klblog" target="_blank" rel="nofollow">https://my.oschina.net/klblog</a></span></li><li><span><span>个人博客：</span><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.kailing.pub%2F" target="_blank" rel="nofollow">http://www.kailing.pub/</a></span></li></ul><p><span><img alt="" height="533" src="https://oscimg.oschina.net/oscnet/up-25fffd13ffa4a26b83d8d969dd57c9be8ce.jpg" width="400" referrerpolicy="no-referrer"></span></p><p><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>为了鼓励踊跃提问，我们会在问答结束后从提问者中抽取 5 名幸运会员赠予定制开源魔方一个</span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>！</span></span></span></span></span></span></span></span></p><p><img alt="" height="356" src="https://oscimg.oschina.net/oscnet/up-d8b90a25d803f6b37329dec2c8bae8bdd2c.jpg" width="400" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#27ae60">OSChina 高手问答一贯的风格，不欢迎任何与主题无关的讨论和喷子。</span></p><p>下面欢迎大家就「怎么做好开源项目」<span>相关</span>问题向 <a href="https://my.oschina.net/klblog" rel="nofollow"><strong>KL 博主</strong><strong><span style="color:#000000">&nbsp;</span></strong></a>提问，直接回帖提问既可。</p></div><div class="poll-wrap"></div><div class="additional-remarks"></div><div class="ui basic center aligned segment action"><div class="ui big buttons"><a class="ui basic button collect-btn hover" data-id="2331356" data-user-id="4700705" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i>收藏 (<span data-collect-count="" data-id="2331356" data-obj-type="2">0</span>)</a><div class="ui basic dropdown share button osc-share dropdown-share" data-tag="share-question"><i class="share icon"></i><span>分享</span><div class="menu"><a class="item" data-platform="weibo" data-value="weibo"><i class="weibo icon"></i>微博</a><a class="item" data-platform="qq" data-value="qq"><i class="qq icon"></i>QQ</a><a class="item" data-platform="wechat" data-value="wechat"><i class="weixin icon"></i>微信</a></div></div></div><div class="ui basic segment"><a class="ban" ban-report="" data-id="2331356" data-obj-type="2" data-url="https://www.oschina.net/question/4700705_2331356"><i class="flag red icon"></i>举报</a></div></div>
            ]]>
            </description>
            <pubDate>Wed, 15 Nov 2023 02:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/question/4700705_2331356</guid>
            <link>https://www.oschina.net/question/4700705_2331356</link>
        </item>
        <item>
            <title>
                <![CDATA[Milvus 上新！全新 Range Search 功能，可精准控制搜索结果]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Range Search 功能诞生于社区。</p><p>某天，一位做系统推荐的用户在社区提出了需求，希望 Milvus 能提供一个新功能，可以返回向量距离在一定范围之内的结果。而这不是个例，开发者在做相似性查询时，经常需要对结果做二次过滤。</p><p>为了帮助用户解决这一问题，Milvus 推出了全新功能—— Range Search（范围搜索）。本文将带各位详解这一新功能，包括 Range Search 的基本介绍、使用场景及其背后的技术细节。</p><h2>01.什么是 Range Search？</h2><p>顾名思义，Range Search 即范围搜索。不同于 KNN Search 返回最相似的 TOP-K 个结果，Range Search 会返回向量距离落于某一区间的 TOP-K 个结果。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b4b328c7dc3151d09d501d9cc11ac3e0591.png" alt="" referrerpolicy="no-referrer"></p><p>那么，何时选择 Range Search 而非 Top-K 搜索？</p><p>Range Search 最典型的应用场景就是推荐系统。比如商品推荐，一个好的推荐系统，返回的应该是与用户点击的商品有一定相似度，但又不太相似的结果。太相似或太不相似的推荐都会导致推荐效果不尽如人意。</p><p>在有 Range Search 功能之前，做推荐系统的用户只能先执行一次 KNN Search，再在 Milvus 系统之外对查询结果进行二次过滤。如今，有了 Range Search 功能，他们可以直接调用 Range Search，一次性得到所需要的结果。</p><p>Range Search 新增了 2 个参数，分别是：</p><ul><li><p>radius（半径） - 指相似性的外边界</p></li><li><p>range_filter（范围过滤器） - 指相似性的内边界</p></li></ul><h2>02.Range Search 的技术实现细节</h2><p>接下来，我们深入 Range Search 功能的架构和算法，探讨其优势、局限性以及 Range Search 与第三方算法库集成。</p><p>Range Search 重用了现有的搜索流程，二者在上层所有数据通路几乎完全是一样的。以下是接收到搜索请求时所采取的步骤：</p><ul><li><p>SDK 接到一个用户的查询请求，在 search param 中包含了 radius 和 range_filter 信息；</p></li><li><p>proxy 在收到这个查询请求后，生成一个 SearchTask 传给 querynode；</p></li><li><p>querynode 在收到 SearchTask 后，通过 cgo 调用 segcore 的 Search 接口；</p></li><li><p>segcore 会解析 search_param 中带的参数，如果有 radius，则调用 knowhere::RangeSearch；</p></li><li><p>knowhere 再根据索引类型调用到对应的第三方库的 range_search 函数。</p></li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-312561d846ee7db2cdde2205ba34b589dd6.png" alt="" referrerpolicy="no-referrer"></p><p>目前，所有的第三方库索引都只支持单边 Range Search，也就是只接收一个参数 radius，而且返回的结果是全量未排序的结果。下表概述了不同索引类型的 Range Search 策略「</p><p><img src="https://oscimg.oschina.net/oscnet/up-f9423ca4e4532ca21a092bf739084b2aa65.png" alt="" referrerpolicy="no-referrer"></p><p>对于 binary 类型的索引，HAMMING 和 JACCARD 全部都支持 Range Search，SUBSTRUCTURE/SUPERSTRUCTURE 由于返回值是 true/false，不满足 Range Search 的语义，所以不支持 Range Search。其余 float 类型索引，对于 L2/IP/COSINE 全部支持 Range Search。</p><p>下表是所有支持 Range Search 的索引类型和 metric type：</p><p><img src="https://oscimg.oschina.net/oscnet/up-4cd875d0cf7b27184d6fe91878755240514.png" alt="" referrerpolicy="no-referrer"></p><h2>03.Range Search 使用方法</h2><p>如需使用 Range Search，只需要修改搜索请求中的搜索参数。接下来我会讲一下的详细使用指南，在指南的最后还提供了 Python 示例代码。</p><h3>开始前</h3><p>请确保已安装并运行 Milvus。</p><p>请确保已创建 1 个 Collection，并为该 Collection 创建索引。</p><h3>Range Search 参数</h3><ul><li><p>radius：必要参数。决定搜索请求将执行 Range Search 还是 KNN Search。</p></li><li><p>range_filter：可选参数。如果设置该参数，函数将对结果进行二次过滤。</p></li></ul><p>通过上述两个参数，我们可以根据不同应用场景和需求微调 Range Search 的行为。以下为示例代码：</p><pre><code class="language-plaintext">default_index = {"index_type": "HNSW","metric_type": "L2","params": {"M":48,"efConstruction":500}
}
collection.create_index("float_vector", default_index)
search_params = {"metric_type": "L2","limit": TOPK,
                 "params": {"ef":32,"range_filter":1.0,"radius":2.0}
}
res = collection.search(vectors[:nq], "float_vector", search_params, limit)
</code></pre><h2>04.参数检查</h2><p>下表列出了所有 metric type 对应的 radius 合法值范围：</p><p><img src="https://oscimg.oschina.net/oscnet/up-3931e0822befd3dcc21a619d6051825e253.png" alt="" referrerpolicy="no-referrer"></p><p>由于不同 metric type 对应的 radius 合法值范围不同，Milvus 不会检查 radius 的合法性，而是只检查 radius 和 range_filter 的相对合法性：</p><ul><li><p>对于 L2/Hamming/Jaccard，range_filter &lt; radius</p></li><li><p>对于 IP/Cosine，range_filter &gt; radius</p></li></ul><h2>05.总结</h2><p>Milvus 的 Range Search 功能不仅限于推荐引擎，还可以广泛应用在内容匹配、异常检测和 NLP 搜索等任务中。通过利用 radius 和 range_filter 两个参数，用户可以精准定制查询，满足不同用例的需求。</p><p>Range Search 现已正式登陆 Zilliz Cloud Beta 版！如需体验 Range Search 功能，请将 Zilliz Cloud（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzilliz.com.cn%2Fcloud%EF%BC%89" target="_blank">https://zilliz.com.cn/cloud）</a> 集群升级至 Beta 版或下载 Milvus 2.3.x（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmilvus.io%2Fdocs%2Finstall_cluster-milvusoperator.md%EF%BC%89%E3%80%82%E5%8F%A6%E5%A4%96%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%A4%A7%E5%AE%B6%E5%9C%A8%E4%BD%BF%E7%94%A8" target="_blank">https://milvus.io/docs/install_cluster-milvusoperator.md）。另外，如果大家在使用</a> Range Search 功能中遇到任何问题或者建议，欢迎向我们反馈！</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 10:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4209276/blog/10143103</guid>
            <link>https://my.oschina.net/u/4209276/blog/10143103</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[2023 年收入最高的 10 种编程语言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在过去的一年时间里（2022 年 10 月 1 日到 2023 年 10 月 1 日） ，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Fblog%2Ftop-10-highest-paid-programming-languages%2F" target="_blank">DevJobsScanner</a> 分析了来自世界各地的超过 1000 万份开发工作机会，以了解市场以及最热门、薪酬最高的编程语言。值得注意的是，本项研究只关注了来自美国的职位。在总共 1000 万个开发工作岗位中，有 130 万个有工资。在这 130 万个职位中，有 23 万个职位属于编程语言类。在这 23 万个职位中，约有 8.6 万个职位来自美国。</p><h4><strong>10 - Java</strong></h4><p><img height="144" src="https://oscimg.oschina.net/oscnet/up-da0d9c70bef29cef379fa443218b09df6dd.png" width="300" referrerpolicy="no-referrer"></p><p>Java 位列第十。DevJobsScanner 指出，Java 的工作机会大多要求份非常丰富的经验，Spring 等 Java 框架也是该行业的高薪职位。Java 开发人员的平均年薪约为 11.8 万美元。</p><ul style="margin-left:0; margin-right:0"><li>平均工资：~$118k</li><li>薪资中位数：$117k</li><li>发现的工作数量（带薪水）：23K 个</li></ul><p>查看具体的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-java-jobs%2F" target="_blank">&nbsp;Java 职位</a>。</p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><strong><span style="color:#000000">9-Python</span></strong></h4><p><img height="91" src="https://oscimg.oschina.net/oscnet/up-9bb3fb64562542db24cf36832f6b43d5966.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Python 是当今最流行的语言之一，也是排名第九的高薪职位。Python 是一种 non-typed 的高级语言。它拥有全方位的实用工具，从脚本和工具到使用 Django 框架编写整个 Web 应用程序。该语言多被用于数据科学。</span></p><p><span style="color:#000000">调查结果显示，虽然 Python 开发人员的平均工资为每年 12.5 万美元，但有些薪资已经达到了每年 50 万美元。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工资：~$125K</span></li><li><span style="color:#000000">薪资中位数：$120k</span></li><li><span style="color:#000000">发现的工作数量（带薪水）：14K 个</span></li></ul><p>&nbsp;查看具体的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-java-jobs%2F" target="_blank">&nbsp;</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-python-jobs%2F" target="_blank">Python 职位</a>。</p><h4><strong>8 - Swift</strong></h4><p><img height="123" src="https://oscimg.oschina.net/oscnet/up-3a30ea9fb6d3c66be2a2ad231125f7a79ba.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Swift 是，苹果公司开发的一种现代通用语言。它有多种用途，但最常见、流行的用途是开发 iOS 和 Mac 应用程序。Swift 开发人员的平均年薪为 12.7 万美元。</span></p><ul style="margin-left:0; margin-right:0"><li>平均工资：~$127k</li><li>薪资中位数：$125k</li><li><span style="color:#000000">发现的工作数量（带薪水）</span>：174 个</li></ul><p>查看具体的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-swift-jobs%2F" target="_blank">Swift 职位</a>。</p><h4><strong>7 - Go</strong></h4><p><img height="120" src="https://oscimg.oschina.net/oscnet/up-963f146d826e179eefe3c93c441a54055da.png" width="300" referrerpolicy="no-referrer"></p><p>Go 语言由&nbsp;Google 团队成员于 2007 年推出，一直广受欢迎。它简单、易用，能快速完成任务。Go 深受 C 语言的影响，但在内存安全、垃圾收集和结构类型方面也有重大改进。</p><ul style="margin-left:0; margin-right:0"><li>平均工资：~$130k</li><li>薪资中位数：$128k</li><li><span style="color:#000000">发现的工作数量（带薪水）</span>：1.2K 个</li></ul><p>查看具体的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-go-jobs%2F" target="_blank">Go 职位</a>。</p><h4><strong>6 - Ruby</strong></h4><p><img height="128" src="https://oscimg.oschina.net/oscnet/up-21b412b86bcb795c62b42a25bdd199348fd.png" width="300" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">Ruby 语言已经流行多年并且现在仍然很流行。调查显示，Ruby 需求相当高，而且大部分都是高薪。</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">Ruby 主要流行于 Web 开发，与著名的 Ruby on Rails 框架结合使用。它也有一些其他的实用工具，从脚本和原型设计到游戏开发（使用 DragonRuby）。DevJobsScanner 认为，鉴于&nbsp;Ruby 的多样性，学习该语言永远不会是一个糟糕的选择；它也是一种高级语言，可以快速开发应用程序（类似于 Python）。</span></p><blockquote><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">Ruby 开发人员的工资中位数（13.6 万美元）超过了平均工资（13.2 万美元）。这表明对中级和高级 Ruby 专业人员的强劲需求，说明掌握 Ruby 方面的专业知识往往能带来高于平均水平的薪酬。</span></p></blockquote><ul style="margin-left:0; margin-right:0"><li>平均工资：~$132k</li><li>薪资中位数：$136k</li><li>找到的工作数量（带薪水）：3.4K 个</li></ul><p>&nbsp;查看具体的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-ruby-jobs%2F" target="_blank">Ruby 职位</a>。</p><h4><strong>5 - Scala</strong></h4><p><img height="146" src="https://oscimg.oschina.net/oscnet/up-551dddb9d865060c07593f99b8a5b10d1e9.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">排在前五位的是 Scala。Scala 是一种结合了面向对象和函数式编程的高级语言。它可以编译成 Java 字节码，并在 Java 虚拟机（JVM）上运行。它的设计初衷是为了解决 Java 所面临的一些"缺陷"和批评。它拥有一个强大的爱好者社区，以及良好的周边库，可以轻松上手。</span></p><p><span style="color:#000000">虽然 Scala 开发人员的平均年薪为 13.5 万美元，但有些职位的年薪最高可达约 40 万美元。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工资：~$135k</span></li><li><span style="color:#000000">薪资中位数：$130k</span></li><li><span style="color:#000000">找到的工作数量（带薪水）： 533 个</span></li></ul><p>查看具体的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-scala-jobs%2F" target="_blank">Scala 职位</a>。</p><h4><strong>4 - C/C++</strong></h4><p><img height="179" src="https://oscimg.oschina.net/oscnet/up-6e86e1cf5b0d7679b684b0158bb78cd21ed.png" width="200" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">C/C++ 稳居前 4 位，平均年薪约为 13.6 万美元。 C++ 在行业中的应用非常广泛，视频游戏、服务器、数据库、空间探测器等许多领域都可以找到 C++ 的身影。区块链生态系统中也大量使用 C++，比特币或 Solidity 智能合约语言均完全由 C++ 编写。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工资：~$136K</span></li><li><span style="color:#000000">薪资中位数：$125k</span></li><li><span style="color:#000000">找到的工作数量（带薪水）：3K 个</span></li></ul><p><span style="color:#000000">&nbsp;查看具体的</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-c%2B%2B-jobs%2F" target="_blank">&nbsp;C/C++ 职位</a>。</p><h4><strong>3-ABAP</strong></h4><p><img height="124" src="https://oscimg.oschina.net/oscnet/up-c183b86954e313b623cd8417d793c87f6ba.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">ABAP 是 2023 年企业资源规划 (ERP) 生态系统中最有价值的语言之一。ABAP 是 SAP 创建的一种高级编程语言，用于在 SAP 平台上开发应用程序。自 20 世纪 80 年代以来，它一直是 SAP 应用程序的支柱，允许自定义开发和修改 SAP 应用程序。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工资：~$137k</span></li><li><span style="color:#000000">薪资中位数：$134k</span></li><li><span style="color:#000000">找到的工作数量（带薪水）：134 个</span></li></ul><p>查看具体的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-abap-jobs%2F" target="_blank">ABAP 职位</a>。</p><h4><strong>2 - Rust</strong></h4><p><img height="141" src="https://oscimg.oschina.net/oscnet/up-d07474ac36e203ae14401437617eca9135b.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Rust 平均薪资约为 15.6 万美元，且该语言的薪资和受欢迎程度都在持续上升。Rust&nbsp;与 C++ 类似，但具有内存安全或安全并发等更高级的功能，使其成为高性能大型应用程序的完美选择。该语言最近在 web3/区块链领域颇受欢迎，例如 Solana 合约不是用 Solidity 制作的，而是采用的 Rust。</span></p><p><span style="color:#000000">虽然 Rust 开发人员的平均年薪为 15.6 万美元，但有些职位的年薪达到了 50 万美元。</span></p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工资：~$156k</span></li><li><span style="color:#000000">薪资中位数：$150k</span></li><li><span style="color:#000000">找到的工作数量（带薪水）：197 个</span></li></ul><p><span style="color:#000000">查看具体的&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-rust-jobs%2F" target="_blank">Rust 职位</a>。</p><h4><span style="color:#000000"><strong>1 - Solidity</strong></span></h4><p><img height="109" src="https://oscimg.oschina.net/oscnet/up-49425fe9eab67498220eef604ab1e04f8fe.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">位居 2023 年薪资排行榜首的是 Solidity，平均薪资为 18.8 万美元。这门以太坊背后的前团队发明的语言最近受到了广泛关注。相关职位的求职者人数少，从而使得薪酬直线上升。Solidity 是一种高级面向对象编程语言。它用于编写当今大多数区块链中运行的智能合约背后的逻辑。</span></p><p>&nbsp;</p><ul style="margin-left:0; margin-right:0"><li><span style="color:#000000">平均工资：~$188k</span></li><li><span style="color:#000000">薪资中位数：1$180k</span></li><li><span style="color:#000000">找到的工作数量（带薪水）：136 个</span></li></ul><p><span style="color:#000000">查看具体的&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Ftop-paid-solidity-jobs%2F" target="_blank">Solidity 职位</a><span style="color:#000000">。</span></p><hr><p><strong>完整列表</strong></p><p><img height="657" src="https://oscimg.oschina.net/oscnet/up-9139be9626b0c984bca34d0c24578038302.png" width="500" referrerpolicy="no-referrer"></p><p><strong>薪资分布图</strong></p><p><img height="820" src="https://oscimg.oschina.net/oscnet/up-844c88902e330224b38a8a0448482adf31d.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.devjobsscanner.com%2Fblog%2Ftop-10-highest-paid-programming-languages%2F" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 08:42:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/266426/top-10-highest-paid-programming-languages</guid>
            <link>https://www.oschina.net/news/266426/top-10-highest-paid-programming-languages</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[国内最大、性能媲美 GPT 3.5，元象开源 650 亿参数高性能大模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#1f2328; text-align:start"><strong>XVERSE-65B</strong><span>&nbsp;</span>是由深圳元象科技自主研发的支持多语言的大语言模型（Large Language Model），参数规模为 650 亿，本次开源的模型为底座模型<span>&nbsp;</span><strong>XVERSE-65B</strong>，主要特点如下：</p><ul><li><strong>模型结构</strong>：XVERSE-65B 使用主流 Decoder-only 的标准 Transformer 网络结构，支持 16K 的上下文长度（Context Length），能满足更长的多轮对话、知识问答与摘要等需求，模型应用场景更广泛。</li><li><strong>训练数据</strong>：构建了 2.6 万亿 token 的高质量、多样化的数据对模型进行充分训练，包含中、英、俄、西等 40 多种语言，通过精细化设置不同类型数据的采样比例，使得中英两种语言表现优异，也能兼顾其他语言效果。</li><li><strong>分词</strong>：基于 BPE（Byte-Pair Encoding）算法，使用上百 GB 语料训练了一个词表大小为 100,534 的分词器，能够同时支持多语言，而无需额外扩展词表。</li><li><strong>训练框架</strong>：训练中采用 FlashAttention2 加速计算，3D 并行基础上采用虚拟流水线（virtual pipeline）技术，降低较长流水线和 16k 上下文窗口产生的过高气泡率，在千卡集群的峰值算力利用率达到业界前列。同时通过集群基础设施运营、资源调度、训练框架和调度平台协同等持续优化，打造出高稳定、低中断、强容错的训练系统，将每周有效训练率提升至 98.6%。</li></ul><h4 style="margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000"><strong>评测结果</strong></span></h4><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000"><img height="454" src="https://oscimg.oschina.net/oscnet/up-2cd1eb2bb0579c1ae7d9b7cdba455e38df6.png" width="500" referrerpolicy="no-referrer">&nbsp;</span></p><h4 style="text-align:start"><strong>硬件需求</strong></h4><p style="color:#1f2328; text-align:start">下表列出了在 XVERSE-65B 上进行推理和微调所需要的硬件资源：</p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#1f2328; display:block; font-family:-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Noto Sans&quot;,Helvetica,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; max-width:100%; orphans:2; overflow:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:max-content; word-spacing:0px"><thead><tr><th>&nbsp;</th><th>类型</th><th>方法</th><th>内存</th><th>GPU</th></tr></thead><tbody><tr><td style="border-style:solid; border-width:1px">XVERSE-65B</td><td style="border-style:solid; border-width:1px">训练</td><td style="border-style:solid; border-width:1px">LoRA with ZeRO-3</td><td style="border-style:solid; border-width:1px">1500GB</td><td style="border-style:solid; border-width:1px">8*A800 80G</td></tr><tr><td style="border-style:solid; border-width:1px">XVERSE-65B</td><td style="border-style:solid; border-width:1px">推理</td><td style="border-style:solid; border-width:1px">BF16/FP16</td><td style="border-style:solid; border-width:1px">500GB</td><td style="border-style:solid; border-width:1px">2*A800 80G</td></tr></tbody></table></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 08:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/xverse-65b</guid>
            <link>https://www.oschina.net/p/xverse-65b</link>
        </item>
        <item>
            <title>
                <![CDATA[从 JDK 11 升级到 JDK 17 的最全实践干货]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h1><strong>1、前言</strong></h1><p>上篇文章给大家带来了<a href="https://my.oschina.net/u/4090830/blog/10111749">JDK8 升级 JDK11 的最全实践，</a>相信大家阅读后已经对 JDK11 有了比较深入的了解。2021 年 9 月 14 日，Oracle 发布了可以长期支持的 JDK17 版本，那么从 JDK11 到 JDK17，到底带来了哪些特性呢？亚毫秒级的 ZGC 效果到底怎么样呢？值得我们升级吗？而且升级过程会遇到哪些问题呢？带着这些问题，本篇文章将带来完整的 JDK11 升级 JDK17 最全实践。</p><h1><strong>2、为什么升级 JDK17</strong></h1><p><strong>1）长期支持版本</strong></p><p>JDK17 是 Oracle 官方在 2021 年 9 月 14 日发布的一个长期支持（LTS）版本，意味着它将获得长期的更新和支持，有助于保持程序的稳定性和可靠性。</p><p><strong>2）性能提升</strong></p><p>更好的垃圾回收器。综合评估，从 Java 8 升级到 Java 11，**G1GC 平均速度提升 16.1%，ParallelGC 为 4.5%****，**从 Java 11 升级到 Java 17，<strong>G1GC 平均速度提升 8.66%，ParallelGC 为 6.54%</strong>（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.optaplanner.org%2Fblog%2F2021%2F09%2F15%2FHowMuchFasterIsJava17.html" target="_blank">基于 OptaPlanner 的用例基准测试表明）</a></p><p>最大的亮点是带来了<strong>稳定版的 ZGC 垃圾回收器，达到亚毫秒级停顿。</strong></p><p><strong>3）新语法和特性</strong></p><p>Switch 表达式简化、Text Blocks 文本块、instanceof 的模式匹配升级和 NullPointerException 提示信息改进等</p><p>4）<strong>支持最新的技术和框架</strong></p><p>Spring framework6 和 Spring Boot3 都默认使用 Java 17 作为最低版本</p><h1><strong>3、升级后压测效果</strong></h1><blockquote><p><strong>先给出结论：</strong></p><p>1、JDK17 相对于 JDK8 和 JDK11，<strong>所有垃圾回收器的性能都有很明显的提升，特别是稳定版的 ZGC 垃圾回收器</strong></p><p>2、<strong>不论任何机器配置下，都推荐使用 ZGC</strong>，ZGC 的停顿时间达到亚毫秒级，吞吐量也比较高</p></blockquote><p><strong>我在 JDOS 平台上选择了不同配置的机器（2C4G、4C8G、8C16G），并分别使用 JDK8、JDK11 和 JDK17 进行部署和压测。</strong></p><p>整个压测过程限时 60 分钟，用 180 个虚拟用户并发请求一个接口，每次接口请求都创建 512Kb 的数据。最终产出不同 GC 回收器的各项指标数据，来分析 GC 的性能提升效果。</p><p><strong>以下是压测的性能情况：</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-07-18-46yVgvcZ9YUGOrY9x.png" alt="" referrerpolicy="no-referrer"></p><h1><strong>4、OracleJDK 和 OpenJDK 的选择</strong></h1><p>2021 年 9 月，Oracle 宣布 JDK17 可以免费商用，直到下一个 LTS 版本之后继续提供整整一年，同时 Oracle 将继续按照自 Java 9 以来的相同版本和时间表提供 GPL 下的 Oracle OpenJDK 版本。</p><p>2023 年 9 月，OracleJDK 发布了新的 LTS 版本 JDK21，这就意味着从<strong>2024 年 9 月开始，在生产环境使用 OracleJDK17 将需要付费。</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-01-20-01PLCD1wvvcxLRLNv.png" alt="" referrerpolicy="no-referrer"></p><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.oracle.com%2Fhk%2Fjava%2Ftechnologies%2Fdownloads%2F%23java17" target="_blank">https://www.oracle.com/hk/java/technologies/downloads/#java17</a></p><p>OracleJDK 和 OpenJDK 这两个之间没有真正的技术差别，因为针对 Oracle JDK 构建过程是基于 OpenJDK 的。自从 JDK11 开始，OracleJDK 和 OpenJDK 在功能上基本相同，所以推荐使用 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjdk.java.net%2Farchive%2F" target="_blank">OpenJDK17</a> 或其他开源的 JDK 版本，这些开源版本都是基于 OpenJDK 构建并提供长期支持的,比如：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fadoptopenjdk.net%2F" target="_blank">AdoptOpenJDK</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevelopers.redhat.com%2Fproducts%2Fopenjdk%2Foverview" target="_blank">RedHatOpenJDK。</a></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-02-11-19DsSkxKErEDeigz2.png" alt="" referrerpolicy="no-referrer"></p><p>官方参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.oracle.com%2Fjava%2Fpost%2Foracle-jdk-releases-for-java-11-and-later" target="_blank">https://blogs.oracle.com/java/post/oracle-jdk-releases-for-java-11-and-later</a></p><h1><strong>5、JDK11 到 JDK17 带来了哪些新特性</strong></h1><h3><strong>5.1、JVM 改进</strong></h3><p>1、ZGC 垃圾回收器从实验性功能更改为<strong>正式产品功能</strong>，从 JDK11 引入以来，经过持续的迭代升级，目前已经足够稳定。<strong>需要手动开启，开启方式：-XX:+UseZGC</strong></p><p>2、G1 垃圾回收器仍然作为默认垃圾回收器，进行改进升级，主要包括可中止的混合收集集合、NUMA 可识别内存分配等</p><p>3、JDK14 开始删除 CMS 垃圾回收器</p><p>4、JDK14 开始弃用 ParallelScavenge 和 SerialOld GC 的组合使用</p><p>5、JDK15 禁用偏向锁，默认禁用：-XX:+UseBiasedLocking</p><p>6、NullPointerException 提示信息改进</p><p>JDK14 以前的出现 NullPointerException 时，只能定位到所在异常行，无法定位具体是哪个变量。改进后的 NullPointerException，可以清晰描述具体变量，提升了空指针异常的可读性。</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-27-10-50TTuaDvegXKr9SAo.png" alt="" referrerpolicy="no-referrer"></p><h3><strong>5.2、新语法特性</strong></h3><h4><strong>5.2.1、Switch 表达式简化</strong></h4><p>switch 表达式带来了简化式的编码方式，提供了新的分支切换方式，即 -&gt; 符号，右则表达式方法体在执行完分支方法之后，自动结束 switch 分支，同时 -&gt; 右则方法块中可以是表达式、代码块或者是手动抛出的异常</p><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F361" target="_blank">https://openjdk.org/jeps/361</a></p><p><strong>传统写法</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-17-22rnaBICUHwCBlYZf.png" alt="" referrerpolicy="no-referrer"></p><p><strong>新写法</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-10-18Z48ZmbyE6jT10uWqP.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.2、Text Blocks 文本块</strong></h4><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F378" target="_blank">https://openjdk.org/jeps/378</a></p><p>通过编写 """，来减少转义字符和换行符，达到简化代码和提高代码可读性的目的</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-18-16tXnkRnYOGkQhTMS.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.3、Record 类型</strong></h4><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F395" target="_blank">https://openjdk.org/jeps/395</a></p><p>record 是 JDK 14 引入的关键字，用于声明不可变的数据类。它适用于存储纯粹的值类型数据，如接口传输数据、座标点和只读的日志记录。与 lombok 相比，record 简化了定义纯粹数据类型的过程。由于 record 类是不可变的，成员变量只能设置一次且无法更改，无需提供显式的 setter() 方法。</p><p><strong>1、定义 Point 类，使用关键字 record，未定义 get/set</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-25-19-50LjIj50MDXubzNv07.png" alt="" referrerpolicy="no-referrer"></p><p><strong>2、查看编译后的字节码文件</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-12-05MfRyF9o9FOD120oS.png" alt="" referrerpolicy="no-referrer"></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-12-077FA41CoAIm41MkgIY.png" alt="" referrerpolicy="no-referrer"></p><p><strong>3、使用 Point 类</strong></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-12-11LdZCsODuD8JpjE0.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.4、instanceof 的模式匹配升级</strong></h4><ul><li>instanceof 类型判断再也不需要强制转换</li></ul><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F394" target="_blank">https://openjdk.org/jeps/394</a></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-25-18-20mhLGcH20q20N25D0a.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.5、密封的类和接口</strong></h4><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F409" target="_blank">https://openjdk.org/jeps/409</a></p><p>JDK15 开始，引入了 sealed 普通类或接口类，这些类只允许被指定的类或者 interface 进行扩展和实现。</p><p>使用修饰符 sealed，您可以将一个类声明为密封类。密封的类使用关键字 permits 列出可以直接扩展它的类。子类可以是最终的，非密封的或密封的</p><p>比较实用的一个特性，可以用来限制类的层次结构</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-26-19-23EeeAvjyEjufkdfY.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>5.2.6、其他优化和升级</strong></h4><p>感兴趣的同学，推荐阅读 OpenJDK 官方文档说明，从 JDK11 到 JDK17 的改动： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fprojects%2Fjdk%2F17%2Fjeps-since-jdk-11" target="_blank">https://openjdk.org/projects/jdk/17/jeps-since-jdk-11</a></p><h1><strong>6、升级步骤</strong></h1><h3><strong>6.1、JDK 选择</strong></h3><p>OpenJDK17 下载：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjdk.java.net%2Farchive%2F" target="_blank">https://jdk.java.net/archive/</a></p><p>行云镜像：jdt-base-tomcat/java-jdt-centos7.4-openjdk-17.0.2-tomcat8.0.53</p><h3><strong>6.2、pom 编译配置升级</strong></h3><p>maven 编译所需 JDK 升级至 17</p><pre><code>&lt;properties&gt;
    &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
&lt;/properties&gt;

</code></pre><h3><strong>6.3、SpringBoot 升级</strong></h3><p>SpringBoot 版本升级到<strong>2.7.15</strong>，Spring 版本升级为<strong>5.3.29</strong></p><p><strong>为什么不升级到 SpringBoot3？</strong></p><p>Spring Boot 3.0 最低要求 Java 17，SpringBoot3.0 带来了很多变化，和 SpringBoot2 差异较大。 考虑到公司很多中间件都是基于 SpringBoot2 构建的，所以此处推荐升级到 SpringBoot2 的最高版本 2.7.15。</p><p><strong>POM 升级</strong></p><pre><code>&lt;parent&gt;
 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
 &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
 &lt;version&gt;2.7.15&lt;/version&gt;
&lt;/parent&gt;

</code></pre><p>也可以通过设置 dependencyManagement 的方式：</p><pre><code>&lt;properties&gt;
    &lt;!-- 框架版本配置--&gt;
    &lt;springboot-version&gt;2.7.15&lt;/springboot-version&gt;
    &lt;springframework.version&gt;5.3.29&lt;/springframework.version&gt;
&lt;/properties&gt;  

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
            &lt;version&gt;${springboot-version}&lt;/version&gt;
            &lt;scope&gt;import&lt;/scope&gt;
            &lt;type&gt;pom&lt;/type&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;
            &lt;version&gt;${springframework.version}&lt;/version&gt;
            &lt;scope&gt;import&lt;/scope&gt;
            &lt;type&gt;pom&lt;/type&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

</code></pre><p>参考：</p><p>spring 升级指南： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-framework%2Fwiki%2FSpring-Framework-Versions" target="_blank">https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions</a></p><p>springboot 版本官网： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspring.io%2Fprojects%2Fspring-boot%23learn" target="_blank">https://spring.io/projects/spring-boot#learn</a></p><p><strong>循环依赖问题</strong></p><p>SpringBoot 升级到 2.7.15 后，如果应用中存在循环依赖的问题，启动时会报如下错误：</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-22-10-48Z10IRCapBcpKAVDi.png" alt="" referrerpolicy="no-referrer"></p><p><strong>原因</strong>：官方文档不鼓励循环依赖引用，默认情况下是禁止的</p><p><strong>解决方案：</strong></p><p>第一种：推荐更新应用中 bean 的依赖关系来解决</p><p>第二种：配置文件中加入以下配置，<strong>为了和旧版本保持一致，此配置推荐添加</strong></p><pre><code>#放开循环依赖
spring.main.allow-circular-references=true

</code></pre><h3><strong>6.4、常用中间件升级</strong></h3><h4><strong>6.4.1、Lombok 版本升级到 1.18.20 以上</strong></h4><pre><code>&lt;dependency&gt;
 &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
 &lt;artifactId&gt;lombok&lt;/artifactId&gt;
 &lt;version&gt;1.18.20&lt;/version&gt;
&lt;/dependency&gt;

</code></pre><p>如果不升级，编译时会报错如下：</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-09-13-20-01itBREuaDZdAzrpZ.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>6.4.2、swgger 问题，springfox3.0.0 和 springboot2.7 版本不兼容</strong></h4><p><strong>异常：</strong></p><pre><code>Failed to start bean 'documentationPluginsBootstrapper'; nested exception is java.lang.NullPointerException: 
Cannot invoke "org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.getPatterns()" because "this.condition" is null

</code></pre><p><strong>解决方案：</strong></p><pre><code>/**
 * 增加如下配置可解决 Spring Boot 2.7.15 与 Swagger 3.0.0 不兼容问题
 **/
@Bean
public BeanPostProcessor springfoxHandlerProviderBeanPostProcessor() {
return new BeanPostProcessor() {

@Override
 public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
if (bean instanceof WebMvcRequestHandlerProvider || bean instanceof WebFluxRequestHandlerProvider) {
                customizeSpringfoxHandlerMappings(getHandlerMappings(bean));
            }
return bean;
}

private &lt;T extends RequestMappingInfoHandlerMapping&gt; void customizeSpringfoxHandlerMappings(List&lt;T&gt; mappings) {
            List&lt;T&gt; copy = mappings.stream().filter(mapping -&gt; mapping.getPatternParser() == null).collect(Collectors.toList());
            mappings.clear();
            mappings.addAll(copy);
        }

@SuppressWarnings("unchecked")
private List&lt;RequestMappingInfoHandlerMapping&gt; getHandlerMappings(Object bean) {
try {
                Field field = ReflectionUtils.findField(bean.getClass(), "handlerMappings");
                field.setAccessible(true);
return (List&lt;RequestMappingInfoHandlerMapping&gt;) field.get(bean);
            } catch (IllegalArgumentException | IllegalAccessException e) {
throw new IllegalStateException(e);
            }
        }
    };
}

</code></pre><p>参考：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F950787" target="_blank">https://developer.aliyun.com/article/950787</a></p><h4><strong>6.4.3、AKS 升级（针对直接从 JDK8 升级的情况）</strong></h4><p><strong>异常</strong>：Causedby: java.lang.NoClassDefFoundError: javax/xml/bind/JAXBException</p><p><strong>原因</strong>：Java11 删除了 Java EE modules，其中就包括 java.xml.bind (JAXB)。</p><p><strong>解决方案：</strong></p><p>手动引入如下包即可</p><pre><code>&lt;!-- API, java.xml.bind module --&gt; 
&lt;dependency&gt;
      &lt;groupId&gt;jakarta.xml.bind&lt;/groupId&gt;
      &lt;artifactId&gt;jakarta.xml.bind-api&lt;/artifactId&gt;
      &lt;version&gt;2.3.2&lt;/version&gt;
&lt;/dependency&gt; 
&lt;!-- Runtime, com.sun.xml.bind module --&gt;
&lt;dependency&gt;
       &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
       &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
       &lt;version&gt;2.3.2&lt;/version&gt;
&lt;/dependency&gt;

</code></pre><h4><strong>6.4.4、Concrete 配置中心阻塞升级</strong></h4><p>使用 Concrete 时，启动时异常：</p><pre><code> Unable to make field private static final java.lang.reflect.Method jdk.proxy2.$Proxy97.m0 accessible: 
 module jdk.proxy2 does not "opens jdk.proxy2" to unnamed module @61d47554

</code></pre><p><strong>原因：</strong></p><p>分析下 Concrete 报错的原因，如下图，包内 com.wangyin.concrete.spring.ConcreteConfigProcessor#postProcessAfterInitialization（212 行）的实现逻辑</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-14-00LgxgUIrSYEUTxjm.png" alt="" referrerpolicy="no-referrer"></p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-27-13-44BFAP7OjBiZqyaDb.png" alt="" referrerpolicy="no-referrer"></p><p><strong>解决方案：</strong></p><p>1、在 JVM 启动参数中设置--add-opens jdk.proxy2 来开启私有字段的访问，但因为动态代理生成的包名是随机不明确的，<strong>所以这种方案不可行</strong>。JDK 官方文档也明确表示不支持访问动态代理内部的随机字段。官方说明：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcr.openjdk.org%2F%7Emr%2Fjigsaw%2Fspec%2Fapi%2Fjava%2Flang%2Freflect%2FProxy.html" target="_blank">https://cr.openjdk.org/~mr/jigsaw/spec/api/java/lang/reflect/Proxy.html</a></p><p>2、代码修改，只需把 f.setAccessible(true) 移到 Modifier.isStatic(f.getModifiers()) 的判断下方即可。原因是方法 Modifier.isStatic(f.getModifiers()) 本来就要跳过静态字段，这样修改直接避免了访问。<strong>推动 concrete 团队修复问题或更换使用 Ducc 配置中心</strong></p><h3><strong>6.5、JVM 启动参数配置</strong></h3><h4><strong>6.5.1、开启 ZGC</strong></h4><p><strong>启动参数中配置：</strong>-XX:+UseZGC</p><p>移除-XX:ConcGCThreads，行云部署下 JVM 参数配置需要清除</p><p><img src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-10-17-15-14Lyy3vSkGQSvlvGe.png" alt="" referrerpolicy="no-referrer"></p><h4><strong>6.5.2、不同中间件所需启动参数</strong></h4><p>升级 JDK17 后，项目启动时可能会遇到如下两种类型的异常：</p><p>1、cannot access class sun.util.calendar.ZoneInfo (in module java.base) because <strong>module java.base</strong> does not <strong>export sun.util.calendar</strong> to unnamed module @0x2611f533</p><p>2、Unable to make field final int java.math.BigInteger.signum accessible: <strong>module java.base</strong> does not "<strong>opens java.math</strong>" to unnamed module @525f1e4e</p><p><strong>异常原因：</strong></p><p>自从 JDK9 中引入了模块化功能后，再到 JDK17，对于包扫描和反射的权限控制更加的严格。常见的库比如（Spring）大量用到包扫描和反射，所以常出现此错误。</p><p><strong>解决方案：</strong></p><p>一个粗暴的解决办法是将没开放的 module 强制对外开放，即保持和 Java9 之前的版本一致。</p><ul><li>--add-exports 导出包，意味着其中的所有公共类型和成员都可以在编译和运行时访问。</li><li>--add-opens 打开包，意味着其中的所有类型和成员（不仅是公共类型）都可以在运行时访问。</li></ul><p>主要区别在于<code>--add-opens</code>允许「深度反射」，即非公共成员的访问，才可以调用<code>setAccessible(true)</code></p><p>参考： <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F44056405%2Fwhats-the-difference-between-add-exports-and-add-opens-in-java-9" target="_blank">https://stackoverflow.com/questions/44056405/whats-the-difference-between-add-exports-and-add-opens-in-java-9</a></p><p><strong>SGM 需要加入：</strong></p><pre><code>--add-opens java.management/java.lang.management=ALL-UNNAMED 
--add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED 
--add-opens java.management/sun.management=ALL-UNNAMED

</code></pre><p><strong>R2M 需要加入：</strong></p><pre><code>--add-opens java.base/java.time=ALL-UNNAMED

</code></pre><p><strong>Ducc 需要加入：</strong></p><pre><code>--add-opens java.base/java.util.concurrent=ALL-UNNAMED
--add-opens java.base/java.util.concurrent.locks=ALL-UNNAMED
--add-opens java.base/java.security=ALL-UNNAMED
--add-opens java.base/jdk.internal.loader=ALL-UNNAMED
--add-opens java.management/com.sun.jmx.mbeanserver=ALL-UNNAMED 
--add-opens java.base/java.net=ALL-UNNAMED 
--add-opens java.base/sun.nio.ch=ALL-UNNAMED 

</code></pre><p><strong>AKS 需要加入：</strong></p><pre><code>--add-exports java.base/sun.security.action=ALL-UNNAMED
--add-opens java.base/java.lang=ALL-UNNAMED
--add-opens java.base/java.math=ALL-UNNAMED
--add-opens java.base/java.util=ALL-UNNAMED
--add-opens java.base/sun.util.calendar=ALL-UNNAMED

</code></pre><h3><strong>6.6、启动后的验证</strong></h3><p>1.推荐先升级 JDK11，再到 JDK17，一边升级一边进行验证观察</p><p>2.观察日志是否有异常，特别是上面说到的启动时异常</p><p>3.观察监控类软件，比如 SGM、UMP 等监控是否正常</p><p>4.推荐逐步有序切量，并做好常态化压测，防止影响核心业务</p><p>5.升级完成后，<strong>最好能做个全流程的功能测试，防止功能异常</strong></p><h1><strong>7、总结</strong></h1><blockquote><p>1、升级后，除了可以使用新的语法特性，最大的亮点是可以使用亚毫秒级停顿的 GC 性能（至少百倍的 GC 性能提升），所以 <strong>强烈建议升级到 JDK17</strong></p><p>2、整个升级过程并不复杂，主要涉及到中间件版本的升级和启动参数的配置</p></blockquote><p>如果还停留在 JDK8，推荐先升级 JDK11，再到 JDK17，具体升级步骤先参考我的上篇文章「<a href="https://my.oschina.net/u/4090830/blog/10111749">JDK8 升级 JDK11 最全实践干货来了</a>」，再参考本章中的升级步骤。</p><p>希望以上分享可以给大家带来实际的帮助，升级过程中如果遇到问题，欢迎大家在评论区回复。</p><blockquote><p>作者：京东科技，曲振富</p><p>来源：京东云开发者社区，转载请注明来源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 07:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10142895</guid>
            <link>https://my.oschina.net/u/4090830/blog/10142895</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[开源模型 Zephyr-7B🪁发布 —— 跨越三大洲的合作]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p><span style="background-color:#ffffff; color:#333333">最近我们刚刚发布了新的开源模型 Zephry-7B🪁，</span><span style="background-color:#ffffff; color:#333333">这个模型的诞生离不开全球三大洲开源社区的协作 ❤️。</span></p><p><span style="background-color:#ffffff; color:#333333">我们的 CSO Thomas 录了一个视频介绍了它的起源故事。</span></p><p><img height="377" src="https://oscimg.oschina.net/oscnet/up-da1e6db4fb09e0c752bd317fe94e1e1d4a3.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#333333">✨ 就在几个月前，巴黎的一个新团队发布了他们首个模型: Mistral 7B，这个模型体积小巧但性能强劲，在基准测试中的表现超过了所有同类模型。而且这是个开源模型，这意味着大家都可以在此基础上进行开发。</span></p><p><span style="background-color:#ffffff; color:#333333">✨ 开发者 Lewis 在瑞士伯尔尼，Ed 在法国南部里昂，他们俩都是 Hugging Face H4 团队的一员。在 Hugging Face 举办的一次小聚中，他们边喝咖啡边讨论用斯坦福大学新发表的 DPO 方法对模型进行微调的可能性。于是大家决定用他们已经构建好的代码库来尝试一下💪</span></p><p><br><span style="background-color:#ffffff; color:#333333">✨接下来的一天，他们在 HF hub 上找到了一些公开的数据集，主要是由清华的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzk0NzM3OTc2Nw%3D%3D%26mid%3D2247487177%26idx%3D1%26sn%3Dcfbeb254d91501fdeadda5103f1d2279%26scene%3D21%23wechat_redirect" target="_blank">OpenBMB</a> 团队新近开源的两个大型、高质量的微调数据集: UltraFeedback 和 UltraChat 📊</span></p><p><br><span style="background-color:#ffffff; color:#333333">✨ 经过几轮训练实验，他们的想法得到了证实: 这个新模型非常强大，在伯克利和斯坦福的基准测试中是他们见过的最强模型。Clémentine 是 Hugging Face Open LLM Leaderboard 的领头人，她对模型的深入分析确认了其卓越性能。于是 H4 团队中另一位成员 Sasha Rush 教授迅速起草了一篇研究报告，将所有细节分享给整个社区 📰</span></p><p><br><span style="background-color:#ffffff; color:#333333">✨ 几天后，这个名为 Zephyr 的模型、研究论文以及所有细节都向世界公开了。不久之后，全球各地的公司开始应用这一模型。LlamaIndex，一个知名的数据框架和社区，分享了这个模型在实际用例基准测试中超乎预期的表现。与此同时，研究者和实践者们在 Hugging Face hub 上讨论着这篇论文和相关工作。</span></p><p>&nbsp;</p><p><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff; color:#333333">✨</span><span style="background-color:#ffffff; color:#333333"></span>很难相信，这一切的实现仅仅用了几周时间 🤯！这一切都得益于世界各地 (欧洲、加利福尼亚、中国) 对知识、模型、研究和数据集的开放，以及开源社区之间的相互协作 🤝</span></p><p><br><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff; color:#333333">✨</span><span style="background-color:#ffffff; color:#333333"></span>这样的故事在开源社区比比皆是，也正是这些人和事让开源社区始终保持不断创新的原动力 🔥</span></p><p><br><span style="background-color:#ffffff; color:#333333"><span style="background-color:#ffffff; color:#333333">✨ </span>齐心协力，我们可以一起创造出惊人的成果 ❤️</span></p><p>&nbsp;</p></div><p style="color:#858585">本文分享自微信公众号 - Hugging Face（gh_504339124f0f）。<br> 如有侵权，请联系 support@oschina.cn 删除。<br> 本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 14 Nov 2023 06:32:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/HuggingFace/blog/10142118</guid>
            <link>https://my.oschina.net/HuggingFace/blog/10142118</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
    </channel>
</rss>
