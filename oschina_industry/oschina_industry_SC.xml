<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 10 Jan 2024 18:55:28 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[ToolLearning Eval：CodeFuse 发布首个中文 Function Call 的大语言模型评测基准]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><h2><img alt="hjdfsbg.png" src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/98756342/1704878404965-d1c416d5-59da-4867-bcbf-ed5f2f607f42.png?x-oss-process=image%2Fresize%2Cw_900%2Climit_0" width="900" referrerpolicy="no-referrer"></h2><span id="OSC_h2_1"></span><h2><span>1.<span>&nbsp;</span></span><span style="color:#000000">背景</span></h2><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">随着 ChatGPT 等通用大模型的出现，它们可以生成令人惊叹的自然语言，使得机器能够更好地理解和回应人类的需求，但在特定领域的任务上仅靠通用问答是无法满足日常工作需要。随着 OpenAI 推出了 Function Call 功能，工具学习能力越来越作为开源模型的标配，目前业界较有影响力的是 ToolBench 的英文数据集。但是中文数据集的稀缺，使得我们很难判断各个模型在中文型工具上 Function Call 的能力差异。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">为弥补这一不足，CodeFuse 发布了首个面向 ToolLearning 领域的中文评测基准 ToolLearning-Eval，以帮助开发者跟踪 ToolLearning 领域大模型的进展，并了解各个 ToolLearning 领域大模型的优势与不足。ToolLearning-Eval 按照 Function Call 流程进行划分，包含工具选择、工具调用、工具执行结果总结这三个过程，方便通用模型可以对各个过程进行评测分析。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">目前，我们已发布了第一期的评测榜单，首批评测大模型包含 CodeFuse、Qwen、Baichuan、Internlm、CodeLLaMa 等开源大语言模型；我们欢迎相关从业者一起来共建 ToolLearning Eval 项目，持续丰富 ToolLearning 领域评测题目或大模型，我们也会定期更新评测集和评测榜单。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#000000">GitHub 地址：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-devops-eval" target="_blank" rel="nofollow"><span style="color:#000000">https://github.com/codefuse-ai/codefuse-devops-eval</span></a></p><p style="margin-left:0; margin-right:0"><span style="color:#000000">ModelScope 地址：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmodelscope.cn%2Fdatasets%2Fcodefuse-ai%2Fdevopseval-exam%2Fsummary" target="_blank" rel="nofollow"><span style="color:#000000">https://modelscope.cn/datasets/codefuse-ai/devopseval-exam/summary</span></a></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_2"></span><h2><span>2.<span>&nbsp;</span></span><span style="color:#000000">评测数据</span></h2><span id="OSC_h3_3"></span><h3><span>2.1.<span>&nbsp;</span></span><span style="color:#000000">数据来源</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">ToolLearning-Eval 最终生成的样本格式都为 Function Call 标准格式，采用此类格式的原因是与业界数据统一，不但能够提高样本收集效率，也方便进行其它自动化评测。经过统计，该项目的数据来源可以分为 3 类：</span></p><ol><li><span style="color:#000000">开源数据：对开源的 ToolBench 原始英文数据进行清洗；</span></li><li><span style="color:#000000">英译中：选取高质量的 ToolBench 数据，并翻译为中文；</span></li><li><span style="color:#000000">大模型生成：采用 Self-Instruct 方法构建了中文 Function Call 训练数据&amp;评测集；</span></li></ol><p style="margin-left:0; margin-right:0"><span style="color:#000000">我们希望越来越多的团队能参与到中文的 functioncall 数据构建，共同优化模型调用工具的能力。我们也会不断地强化这部分开源的数据集。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h3_4"></span><h3><span>2.2.<span>&nbsp;</span></span><span style="color:#000000">数据类别</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">ToolLearning-Eval 里面包含了两份评测集，fcdata-zh-luban 和 fcdata-zh-codefuse。里面总共包含 239 种工具类别，涵盖了 59 个领域，包含了 1509 条评测数据。ToolLearning-Eval 的具体数据分布可见下图</span></p><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/238517/1701934951404-984f915c-550e-4da6-93c0-3bcc70efe66d.png" width="793" referrerpolicy="no-referrer"></p><span id="OSC_h3_5"></span><h3><span>2.3.<span>&nbsp;</span></span><span style="color:#000000">数据样例</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">在数据上我们完全兼容了 OpenAI Function Calling，具体格式如下：</span></p><p style="margin-left:0; margin-right:0"><strong><span>Function Call 的数据格式</span></strong></p><p style="margin-left:0; margin-right:0"><img alt="截屏 2024-01-10 15.00.51.png" src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/98756342/1704878469274-e7c2e86e-d595-4095-b7e5-cb4b0c12b2fb.png" width="1516" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong><span>chatrounds 的数据格式</span></strong></p><p style="margin-left:0; margin-right:0"><img alt="截屏 2024-01-10 15.00.19.png" src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/98756342/1704878469290-acf7e74e-449a-4244-b911-0cf2273b7aff.png" width="1516" referrerpolicy="no-referrer"></p><pre><code>{
    "functions":
    [
        {
            "name": "get_fudan_university_scoreline",
            "description": "查询复旦大学往年分数线，例如：查询 2020 年复旦大学的分数线",
            "parameters":
            {
                "type": "object",
                "properties":
                {
                    "year":
                    {
                        "type": "string",
                        "description": "年份，例如：2020，2019，2018"
                    }
                },
                "required":
                [
                    "year"
                ]
            }
        }
    ],
    "chatrounds":
    [
        {
            "role": "system",
            "content": "CodeFuse 是一个面向研发领域的智能助手，旨在中立的、无害的帮助用户解决开发相关的问题，所有的回答均使用 Markdown 格式返回。\n 你能利用许多工具和功能来完成给定的任务，在每一步中，你需要分析当前状态，并通过执行函数调用来确定下一步的行动方向。你可以进行多次尝试。如果你计划连续尝试不同的条件，请每次尝试一种条件。若给定了 Finish 函数,则以 Finish 调用结束，若没提供 Finish 函数，则以不带 function_call 的对话结束。"
        },
        {
            "role": "user",
            "content": "查询 2020 年复旦大学的分数线"
        },
        {
            "role": "assistant",
            "content": null,
            "function_call":
            {
                "name": "get_fudan_university_scoreline",
                "arguments": "{\n  \"year\": \"2020\"\n}"
            }
        },
        {
            "role": "function",
            "name": "get_fudan_university_scoreline",
            "content": "{\n    \"scoreline\":{\n        \"文科一批\": 630,    \n        \"文科二批\": 610,  \n        \"理科一批\": 650,  \n        \"理科二批\": 630  \n    }\n}"
        },
        {
            "role": "assistant",
            "content": "2020 年复旦大学的分数线如下：\n\n- 文科一批：630 分\n- 文科二批：610 分\n- 理科一批：650 分\n- 理科二批：630 分"
        }
    ]
}</code></pre><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#000000">上述 Function Call 的数据样例为给定特定工具集后，用于回答用户查询某高校录取分数线的问题。此外限于篇幅，此处不再其它工具使用样例，具体可以查看 HuggingFace 数据集。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h3_6"></span><h3><span>2.4.<span>&nbsp;</span></span><span style="color:#000000">数据下载</span></h3><ul><li><span style="color:#000000">方法一： 直接下载（用浏览器打开下面的链接）</span></li></ul><p style="margin-left:0; margin-right:0"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmodelscope.cn%2Fdatasets%2Fcodefuse-ai%2Fdevopseval-exam%2Ffiles" target="_blank" rel="nofollow"><span style="color:#000000">https://modelscope.cn/datasets/codefuse-ai/devopseval-exam/files</span></a></p><ul><li><span style="color:#000000">方法二：使用 ModelScope datasets 库函数</span></li></ul><pre><code>from modelscope.msdatasets import MsDataset
MsDataset.clone_meta(dataset_work_dir='./xxx', dataset_id='codefuse-ai/devopseval-exam')
</code></pre><p style="margin-left:0; margin-right:0">&nbsp;</p><pre><code>sample_data
|- sampleData.json   # 数据样例
train_data
|- fcdata_toolbenchG1.jsonl  # 72783 toolbenchG1 整理数据
|- fcdata_toolbenchG2.jsonl  # 29417 toolbenchG2 整理数据
|- fcdata_toolbenchG3.jsonl  # 24286 toolbenchG3 整理数据
|- fcdata_toolbenchG1_zh.jsonl # 16335 toolbenchG1 部分中文翻译数据
|- fcdata_zh_train_v1.jsonl # 72032 自有采集生成的数据 V1
|- fcdata_zh_train_luban.jsonl  # 10214 自有采集生成的数据 luban
 test_data
 |- fcdata_zh_test_v1.jsonl # 1250 自有采集生成的测试数据 V1
|- fcdata_zh_test_luban.jsonl # 259 自有采集生成的测试数据 luban</code></pre><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_7"></span><h2><span>3.<span>&nbsp;</span></span><span style="color:#000000">评测设置</span></h2><span id="OSC_h3_8"></span><h3><span>3.1.<span>&nbsp;</span></span><span style="color:#000000">评测模型</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">一期我们选取了比较热门的不同参数大小、不同机构发布的通用大模型和 CodeFuse 大模型，具体细节如下表。后续我们也会评测更多其他的大模型。</span></p><p style="margin-left:0; margin-right:0"><img alt="截屏 2024-01-10 15.29.03.png" src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/98756342/1704878469347-f387ec7e-4b93-4600-9f00-6b43aba426e0.png" width="1124" referrerpolicy="no-referrer"></p><span id="OSC_h3_9"></span><h3><span>3.2.<span>&nbsp;</span></span><span style="color:#000000">评测指标</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">由于一般通用模型无法具备工具调用的能力，因此在进行 Tool Learn-Eval 评测之前需要对通用模型进行微调，先让模型学会工具使用的基本范式</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span style="color:#000000">下面，我们定义了几种评估工具使用的指标：</span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000"><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/e4f3eb9ec0085945e108c444bd8744d4.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000"><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/c00744c5d702dc52dd785c699051efe0.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000"><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/329076d813a344136a96bf6f06ad6e41.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000"><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/0bc2c431ba13d7463377259786f2f8b1.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000"><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/e1c18467331bc0bd1d2d7bf1ea6c4a4c.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0; text-align:left"><span style="color:#000000"><img src="https://intranetproxy.alipay.com/skylark/lark/__latex/2aeea17ffa6d1d6e8ae8275cbc63de33.svg" referrerpolicy="no-referrer"></span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000">②③④⑤的和为 1，代表工具调用失败的总数，⑤工具幻觉是工具名识别失败的一种特殊情况</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span>在此基础上，我们提供了一个相应的评测脚本，具体评测过程欢迎到 Github 项目中进一步了解。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_10"></span><h2><span>4.<span>&nbsp;</span></span><span style="color:#000000">评测结果</span></h2><span id="OSC_h3_11"></span><h3><span>4.1.<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-devops-eval%23-leaderboard" target="_blank" rel="nofollow"><span>🏆</span></a><span style="color:#1f2328"><span>&nbsp;</span>fcdata_luban_zh 数据集评测</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">如下图所示，在 fcdata_luban_zh 的评测结果中，不同模型在指令微调后 function call 能力存在一定的分化现象。Qwen-14B-Chat 在工具调用准确率 fccr 和 aar 的得分最高，说明通过 Qwen-14B-Chat 遵循指令微调的能力最好，同时也可以看到 Qwen-7b-chat 的 fccr 也基本与 Qwen-14b-chat 持平。Internlm-7B-Base 评分较低相对其它模型的指令微调能力较弱。从总体上来看，各模型经过 FunctionCall 的训练数据微调后，分数区分度不大。</span></p><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/14156567/1702348998847-95a5ff09-da9b-496e-b3fd-5475ed2f0fed.png" width="1461" referrerpolicy="no-referrer"></p><span id="OSC_h3_12"></span><h3><span>4.2.<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-devops-eval%23-leaderboard" target="_blank" rel="nofollow"><span>🏆</span></a><span style="color:#1f2328"><span>&nbsp;</span></span><strong><span>fcdata_zh</span></strong><span style="color:#1f2328">数据集评测</span></h3><p style="margin-left:0; margin-right:0"><span style="color:#000000">如下图所示，在 fcdata_zh 的评测结果中，不同模型在指令微调后 function call 能力不存在太大差异。同时也可以看到在 fcdata_zh 数据集上的 arr 评分相较于 luban 数据集有较大的提升，可能是 luban 评测集表述上与整体训练集上的回答存在较大差异，模型无法做出与 luban 数据匹配的合理回答。最好的 aar 得分模型分别是 CodeLLaMa 和 CodeFuse-7b-16k，而 CodeFuse-7b-16k 比 4k 要好也说明长 Token 模型拥有对工具进行总结的更优能力。</span></p><p style="margin-left:0; margin-right:0"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/14156567/1702348993031-375fb821-ec90-49e8-99aa-77e04075676f.png" width="1461" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_13"></span><h2><span>5.<span>&nbsp;</span></span><span style="color:#000000">未来展望</span></h2><p style="margin-left:0; margin-right:0"><span style="color:#000000">Tool Learning 现在已然成为大模型领域的研究热点，大模型与 Tool Learning 能碰撞出什么火花也是当前行业内最关心的话题。未来我们将持续对 ToolLearning-Eval 项目进行优化，主要优化方向包括以下几点：</span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000">1）不断优化评测数据集：</span></p><ul><li><ul><li><span style="color:#000000">目前 ToolLearning-Eval 已涵盖日常领域常见的工具集合，后续将继续增加不同领域的 Tool 集合，直至覆盖全领域的所有智能化任务；</span></li><li><span style="color:#000000">Tool Learning 的数据质量决定了模型掌握工具学习范式的上限，后面将通过更完善的数据构造方法和人工评测手段来生成更高质量的数据</span></li></ul></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#000000">2）拓展多工具多轮对话数据集：</span></p><ul><li><ul><li><span style="color:#000000">当前工具评测任务仅限於单工具的评测，对于不同类别之间的数据量存在较大差异，需要持续补充数据集，平衡各类别的数据量；</span></li></ul></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#000000">3）持续增加评测模型：</span></p><ul><li><ul><li><span style="color:#000000">一期主要评测了一些主流的、规模不是很大的开源模型，后续将覆盖更多的模型，并重点跟踪评测面向相关领域的大模型。</span></li></ul></li></ul><p style="margin-left:0; margin-right:0"><span style="color:#000000">希望大家一起来共建 ToolLearning-Eval，期待在大家的努力下，建立更准确、更全面的 ToolLearning 领域大模型评测体系，推动 ToolLearning 领域大模型技术的不断发展与创新。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_14"></span><h2><span>6.<span>&nbsp;</span></span><strong><span style="color:#000000">联系我们</span></strong></h2><p style="margin-left:0; margin-right:0"><span style="color:rgba(0, 0, 0, 0.9)">欢迎使用&amp;讨论&amp;共建</span><br><span>（1）Eval - DevOps 领域 LLM 行业标准评测：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-devops-eval" target="_blank" rel="nofollow"><span>https://github.com/codefuse-ai/codefuse-devops-eval</span></a><br><span>（2）ChatBot - 开箱即用的 DevOps 智能助手：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-chatbot" target="_blank" rel="nofollow"><span>https://github.com/codefuse-ai/codefuse-chatbot</span></a><br><span>（3）Model - DevOps 领域专属大模型：</span><span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-DevOps-Model" target="_blank" rel="nofollow">https://github.com/codefuse-ai/CodeFuse-DevOps-Model</a><br> &nbsp;&nbsp;</span><span>(4) CodeFuse 官网：<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcodefuse.alipay.com%2Fwelcome%2Fproduct" target="_blank" rel="nofollow"><span>https://codefuse.alipay.com</span></a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 11:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6942768/blog/10759392</guid>
            <link>https://my.oschina.net/u/6942768/blog/10759392</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[袁进辉新公司再获王慧文等 5000 万投资]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#000000">硅基流动（SiliconFlow) <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FW0SAITjjpiJItGe4dYvMCQ" target="_blank">宣布</a></span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">于近日完成 5000 万元天使轮融资。本轮融资由创新工场领投，耀途资本、奇绩创坛以及王慧文等科技界知名人士跟投，华兴资本担任独家财务顾问；</span><span style="background-color:#ffffff; color:#000000">投后估值为数亿元人民币。</span></p><p><span style="background-color:#ffffff; color:#000000">硅基流动是</span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">一流科技（OneFlow）</span><span style="background-color:#ffffff; color:#000000">创始人、光年之外联合创始人袁进辉于 </span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">2023 年 8 月</span><span style="background-color:#ffffff; color:#000000">成立的一个新公司，</span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">致力于打造大模型时代的 AI 基础设施（AI Infra），降低大模型应用成本和开发门槛，加速 AGI 普惠人类。</span></p><p><img height="283" src="https://oscimg.oschina.net/oscnet/up-21d1e3f3e5cd348650171057db95e4847a6.png" width="500" referrerpolicy="no-referrer"></p><p><span style="background-color:#ffffff; color:#000000">袁进辉在接受《晚点 LatePost》采访时表示，</span><span><span style="color:#000000">新公司延续 OneFlow 的方向，做 AI Infra（AI 基础设施）层中的 「框架」。</span></span></p><div style="text-align:start"><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">AI 框架介于算力层和模型层之间，是一种系统软件，就像电脑操作系统能使普通用户直接用鼠标和键盘操作应用，AI 框架能帮开发者简单方便地设计模型或使用模型，而无需操心底层算力资源的调配。</span></span></p></div><div style="text-align:start"><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">不同的是，OneFlow 当年以通用训练框架为主，服务深度模型的生产；硅基流动则专注做推理框架，服务大模型的应用。</span></span></p></div><div style="text-align:start"><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">袁进辉认为，服务大模型应用比服务大模型生产更容易做出标准化产品，市场空间也大得多：模型生产是阶段性的，且由少数公司主导；大模型应用则会遍布各行各业、无处不在，被各种行业和规模的企业需要。</span></span></p></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 10:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275107</guid>
            <link>https://www.oschina.net/news/275107</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[重庆大学 | 面向 RISC-V 架构的 AI 开发框架构建与优化大赛宣讲会成功举办]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">1 月 10 日，</span><strong>面向 RISC-V 架构的 AI 开发框架构建与优化大赛第八场宣讲会</strong><span style="color:#000000">在</span><strong>重庆大学</strong><span style="color:#000000">举行，重庆大学国家卓越工程师学院副院长刘凯、计算机学院副院长钟将、助理教授李荣振、助理教授李楚昭，openKylin 社区秘书长余杰博士、技术委员会委员王文竹博士</span><span style="color:#000000">参与活动。本次宣讲会旨在进一步加深同学们对大赛的了解，鼓励和动员更多同学参与到比赛中来。</span></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-e2ac0aa8c27173ea72ce9d177d889d9b978.jpg" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000"><span style="color:#000000">宣讲会上，openKylin 社区技术委员会委员王文竹</span><span style="color:#000000">围绕大赛概述、赛道设置、赛程安排、参赛要求等方面向同学们介绍了面向 RISC-V 架构的 AI 开发框架构建与优化大赛</span><span style="color:#000000">，并向同学们讲解介绍了一系列</span><span style="color:#000000">实践案例</span><span style="color:#000000">，帮助同学解读赛题，理清参赛思路，鼓励同学们积极参与报名。</span></span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000"><span style="color:#000000"><span style="color:#000000">希望通过</span><span style="color:#000000">此次宣讲会，能够</span><span style="color:#000000">帮助同学们更好地了解面向 RISC-V 架构的 AI 开发框架构建与优化大赛的相关内容和参赛规则，激发同学们的参赛热情。</span></span></span></p><p><strong>关于大赛</strong></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">面向 RISC-V 架构的 AI 开发框架构建与优化大赛是开放原子开源大赛设立的赛道，由 openKylin 社区、麒麟软件有限公司承办，国防科技大学、信创海河实验室协办，玄铁、北京算能科技有限公司、广东赛昉科技有限公司赞助。通过本项赛事，旨在探索如何将人工智能技术与 RISC-V 架构相结合，以实现高性能和低功耗的目标。各相关单位、高校、个人等均可免费报名参赛，目前正在火热报名中~</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 09:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275095</guid>
            <link>https://www.oschina.net/news/275095</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Atuin 作者宣布辞职，全职从事开源项目]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">流行的 Shell 历史记录管理工具 Atuin 作者 Ellie Huxtable 于近日发文<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fellie.wtf%2Fposts%2Fi-quit-my-job-to-work-full-time-on-my-open-source-project" target="_blank">宣布</a>，已经在 2023 年 12 月 22 日辞去了 PostHog 基础设施团队的领导工作。接下来，她将成立一家公司，全职服务于 Atuin 项目。</span></p><p><span style="color:#000000">「Atuin 将继续开源并以当前形式作为自托管工具免费提供。通过全职运营，我希望可以专注于为高级用户添加新的高级托管功能，并开始支持商业用途。」</span></p><p><span style="color:#000000">Atuin 是一款可跨设备同步的 Shell 历史记录工具。可使用 SQLite 数据库取代你现有的 shell 历史，并为你的命令记录额外的内容。此外，它还通过 Atuin 服务器，在机器之间提供可选的、完全加密的历史记录同步功能。</span></p><p><span style="color:#000000"><img alt="" height="222" src="https://oscimg.oschina.net/oscnet/up-204accc133a02e4d3372505f70244790d01.webp" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><img alt="" height="222" src="https://oscimg.oschina.net/oscnet/up-ff8b1563ecf919bb0341a800b897e2de8d4.webp" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">Ellie 表示，促使她作出这一决定的原因是她开始意识到，付出与收获是成正比的。因为受工作牵绊，她只能在在上班前抽空处理 Atuin 上的问题；但即便如此，很多时候甚至连公开的 PR 和 issue 都没时间处理，遑论开发需要的新 features/fixes。</span></p><p><span style="color:#000000">久而久之，她感觉自己与 Atuin 之间已经渐行渐远。在这一过程中，她的朋友 Conrad 也退出了项目的维护工作。</span></p><blockquote><p><span style="color:#000000">我觉得自己在辜负项目的期望，忽略了自己的社交生活，并且在工作中极力避免分心。</span></p><p><span style="color:#000000">为了按照我的意愿发展这个项目，我需要在全职工作的同时投入更多的时间。</span></p><p><span style="color:#000000">所以，我正在创办一家公司，全职开发 Atuin。</span></p><p><span style="color:#000000">我一直想经营自己的公司，这几乎是我一生的梦想。但我不想为了创业而创业。我想做一些人们喜欢的、有用的东西。</span></p></blockquote><p><span style="color:#000000">谈到资金问题，Ellie 则表示一直在自掏腰包运行 Atuin 服务器；「虽然数额不是很大，但也不小」。直至 2022 年底，她在朋友建议下开通了&nbsp;GitHub 赞助渠道，并收获了意料之外的金额 ——&nbsp;足够支付服务器费用，并抵消她迄今为止所支付的部分费用。</span></p><p><span style="color:#000000">但有一个弊端是，她需要经常提及赞助渠道的存在，否则就容易被遗忘。「这让我感到很奇怪，因为这感觉就像是在乞讨」。而有着与她相同感受的开发者并不在少数。因此，Ellie 引用了&nbsp;Sidekiq 创建者 Mike Perham 的两句话：</span></p><blockquote><p><span style="color:#000000">「最终，OSS 的倦怠将扼杀任何具有吸引力的免费项目」</span></p><p><span style="color:#000000">「如果你创造了一些有价值的东西，那就为它收费」</span></p></blockquote><p><span style="color:#000000">展望未来，Ellie 希望能在现有功能的基础上，开发出一些有价值的商业功能。同时将&nbsp;Atuin 发展到可以传承下去的地步，并对一些提供过帮助的项目和人提供资助。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 08:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275092/atuin-full-time-on-open-source-project</guid>
            <link>https://www.oschina.net/news/275092/atuin-full-time-on-open-source-project</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Sealos：在公有云和私有云之间，我选择第三条路]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span style="color:#494949"><span style="background-color:#ffffff"><span style="background-color:#ffffff">【创造者说】&nbsp;Created in the name of FOSS.</span></span></span></p><p style="text-align:center"><img height="450" src="https://oscimg.oschina.net/oscnet/up-aeccf4cfa39fbccb3b91bcb94207696b175.png" width="1080" referrerpolicy="no-referrer"></p><p>前段时间，上云和下云的争议如火如荼，公有云的价格、安全和透明度备受拷问，私有云的服务、维护成本又深受质疑。就在双方互掐不分上下的时候，一个新项目引起了我们的注意——Sealos，一个云操作系统，在公有云和私有云之间，他选择了第三条路——把公有云私有云抽象到一起。</p><p>Sealos 的作者方海涛，曾在讯飞担任容器平台负责人，后来在阿里云负责云原生集成平台，主导了 sealer 项目并捐献给 CNCF 社区。他觉得自己「骨子里就是个创业者」，早在 2016 年就开始了第一次创业，可惜没成。Sealos 每年翻倍的发展速度，让他看到了新的希望。拿到奇绩创坛的投资后，他火速拉上自己的老朋友和同事，出来成立了环界云计算公司。产品 Sealos 自从 2023 年 6 月份上线以来，<strong>仅半年时间注册用户已经突破 8 万，月收入超过 30w。</strong></p><p>方海涛认为，现在的公有云和私有云虽然吵得凶，但其实各有各的问题，也各有各的适用场景，脱离场景谈优势毫无意义。他认为，公有云和私有云并无本质区别，都是连接计算资源，<strong>可以做个</strong><strong>像安卓一样好用的云</strong><strong>操作系统</strong><strong>，谁要用云就装一个就行</strong>。而现在，这个想法实现了。</p><p>&nbsp;</p><span id="OSC_h1_1"></span><h1>01 创业的齿轮重新转动</h1><p>第一次创业失败后，方海涛回归了单纯的程序员身份。一天晚上，为了解决 K8s 早期版本的安装和高可用等问题，方海涛把自己写的一个安装脚本放在了阿里云市场上，命名为「 kubeinit 」，15 块钱一份。没想到的是，还真有人买。看着进账，方海涛很兴奋，仿佛看到了未来的商业帝国。可是，这第一个版本问题太多了，程序也十分复杂，方海涛不得不花了一整天时间为这位客户提供售后服务，电影院里还在帮用户解决问题。</p><p style="text-align:center"><img height="1454" src="https://oscimg.oschina.net/oscnet/up-de8b59708266427e5953e8b36da03e20ebc.png" width="808" referrerpolicy="no-referrer"></p><p>不过，这个好开头，让方海涛重拾了一点创业的信心。随着销量暴增，方海涛也借此换了一部新手机 iPhone 8。但不幸的是，问题也越来越多了，方海涛都抽不出时间进行售后维护。于是，他重写了一个基于 Ansible 的 v2 版本，但 Ansible 也只是使用起来方便许多，并没有解决根本的安装复杂度问题，很多用户安装失败，尤其是在离线环境中更容易出错，需要把 Ansible 放到 Docker 中。</p><p>为了解决这个问题，方海涛思考了很长时间，最后在 kube-proxy 源码上找到了灵感。借用负载均衡器的实现方式，去掉很重的组件，使整个脚本变得简单，于是第三个版本 Golang 解决了以往的问题，在安装方面做到简单极致，一条命令解决一切——这就是后来的 Sealos。</p><p>大概是众人都苦于 K8s 安装久矣，Sealos 口碑打开之后，在 Github 的趋势榜上连续霸榜了一周，可见需求之旺盛。这样出色的表现，也吸引了陆奇团队的注意。2022 年 3 月，Sealos 获得了陆奇团队 200 万的天使投资。方海涛的创业之路，也重新开启了。</p><p>&nbsp;</p><span id="OSC_h1_2"></span><h1>02 独树一帜的设计</h1><p>「上云是未来」虽已达成共识，但上的是公有云还是私有云，却存在分歧。尤其是在今年的公有云故障事件之后，私有云的声音也响亮了起来。毕竟，公有云干的本就是租赁的活儿，不少软件还是开源的，却还卖这么贵，难免让用户心生「割韭菜」的怀疑。而私有云，建设成本又太高，无论是采购还是自建，花销都少不了：采购起步上千万，自建少说 30 人。这也是当下用户纠结的原因。有评论说得好：<strong>云就是一座围城，外面的人想进去，里面的人想出来。</strong></p><p>不过面对这种 A or B 的难题，Sealos 却选择了第三条路：把公有云和私有云抽象到一起，集公有云的弹性、敏捷和私有云的安全可控于一身，同时再把价格给打下去。</p><p>还有这种好事？</p><p>怎么做到的？</p><p><strong>Sealos 将 Kubernetes 作为 「云内核」，基于这个云内核做一个可以运行在多台服务器上的云</strong><strong>操作系统</strong><strong>发行版，系统之上 「一切皆应用」。最终可以把整个数据中心所有服务器变成一台 「逻辑计算机」，让用云变得像用 PC 一样简单：</strong></p><p style="text-align:center"><img height="1974" src="https://oscimg.oschina.net/oscnet/up-1e1316ef681c726943f82545a53d490dd1f.png" width="3840" referrerpolicy="no-referrer"></p><p><strong>云的架构也从传统的 </strong><strong>IaaS</strong><strong>、</strong><strong>PaaS</strong><strong>、SaaS 三层架构，转向以 Kubernetes 为云内核的新架构：</strong></p><p style="text-align:center"><img height="590" src="https://oscimg.oschina.net/oscnet/up-be50dc03448ab6ce8c8b0188df4657401ce.png" width="1060" referrerpolicy="no-referrer"></p><p>最终，Sealos 和 Kubernetes 之间的关系，就像 Red Hat 和 Linux 内核之间的关系，只不过与单机操作系统的区别是，Sealos 是装在整个数据中心的，Sealos 上跑的也不是 QQ 微信这些单机应用，而是开发者需要用到的各种分布式应用。有了 Sealos，整个数据中心就不再是一台一台孤立的服务器，而是一个整体，变成一台超级逻辑计算机。这个时候再去用云，就像是在用一台服务器一样简单。</p><p><strong>哪家企业需要用云，就直接装一个云</strong><strong>操作系统</strong><strong>就搞定了。</strong></p><p>在方海涛看来，云计算的本质在于将计算资源（包括硬件、软件和网络等）通过互联网等方式提供给用户使用，连接单个数据中心的算力资源只给自己用就是私有云，通过公网让大家都能用就是公有云。至于功能上，公有云能做到的理论上私有云都能做到，并无本质区别。未来，公有云和私有云也许会走到一起，变成同一个东西。</p><p>在 Sealos 的设计中，也处处秉承了这样的理念。公有云与私有云是同一套代码，同一个抽象，只是配置与安装的应用不同，运行在企业自己机房就是私有云，对公网提供服务就是公有云。</p><p>两边的用户一手抓了。</p><p>这样的设计还使得 Sealos 简洁又简单，避免了传统用云的「屎山」体验。</p><p><strong>而在高度抽象的架构下，一切具体能力都通过应用去扩展。</strong>用户需要啥就装啥，不要就卸掉，自由灵活，云操作系统也不会随着软件功能的增加而增加复杂度。这样，不管懂不懂 Kubernetes 都能愉快地使用 Sealos 了，云原生专家可以打开终端敲各种原生命令，DBA 也可以直接使用数据库应用，极其灵活。</p><p>「用户需要关心 Kubernetes 吗？其实不需要。我们只要想办法把用户最终需要的应用直接交付给用户就行了，就像你去用 Linux 的时候你很少关心 Kernel 一样，云也是一样的道理，开发者需要用到的能力才是最重要的，未来没有多少人需要再去关心这个内核了。」方海涛说。</p><p>&nbsp;</p><span id="OSC_h1_3"></span><h1>03 学习 Linux，成为 Linux</h1><p>在 Sealos 的成长过程中，不难发现，很多产品思路都学习了 Linux。在采访过程中，方海涛也对 Linux 极为推崇。他认为，Linux 简单易用，运行稳定，几乎不用投入太高成本，也基本不需要定制化开发。而 Openstack 专业人士三天都不一定能装起来，还得改一堆代码才能用，实在是太复杂了，不应该成为私有云的代表。Linux 才是学习的榜样。</p><p>「Linux 在哪里用都是同一个 Linux，云也应该这样。否则一味地堆积很多乱七八糟的东西进来，变成一个大杂烩，那 Sealos 只会变成又一个失败的 PaaS 平台。」方海涛说。</p><p><strong>Sealos 目前只有一套</strong><strong>开源</strong><strong>代码，哪个版本都一样，没有分支</strong>。而它能得到众多开发者的欢迎，也是因为它像 Linux 一样低成本、易用和标准化。</p><p>「其实云都是大差不差的，Sealos 能解决的问题，其他的云基本上也能解决。但 Sealos 现在这么受欢迎，就在于它的易用性。」方海涛介绍，「同样的事情，如果放在 Sealos，K8s 集群已经有了，只需点一下按钮 CBT 就能起来。但是如果基于虚拟机去搭的话，你可能需要搞后端的数据库，再去搭建负载均衡，去搞备份恢复等等，才能把整套东西搞起来。成本差异就在这。」</p><p>在运维方面，Sealos 也很稳定。「在我们的理念中，不应该有运维这种角色的存在，整个系统是自运维的，就像 PC 操作系统运行起来很少发生问题的。」</p><p style="text-align:left">而且 Sealos 最小只有 300M，企业装了 Sealos 便能在各种环境中拥有完全属于自己的云。</p><p>「另外，Sealos 有标准化的应用市场。很多人需要的其实只是上层的应用，我们把这些应用封装好，直接给到他们去用就行了。一些云厂商可能也有类似的 Marketplace，可是这些 Marketplace 缺乏标准，软件的生产者跟消费者之间协作就很麻烦。我们以云操作系统的思维，在做这个事情的时候，我们会 follow 云原生生态的事实标准，让软件的生产者和消费者连接起来，相互协作，达成良性循环。」</p><p style="text-align:left">这种以操作系统的思维来做云最终也会改变生产关系，让云的生态可以像安卓生态一样，不再是单一厂商来提供云应用，而是形成多对多的网状协作关系。</p><p>&nbsp;</p><span id="OSC_h1_4"></span><h1>04 神奇的项目：开源、商业不分家</h1><p>截至目前，Sealos 在 Github 上已经拥有了 12000+的 star。良好的群众基础，也给 Sealos 打开了一条丝滑的商业化道路。</p><p>跟别的开源项目不同，Sealos 并没有走「先开源，后收费」的路子，而是从诞生起，就开始收费了。最早期时是卖安装包，代码开源但是安装包收费，如果用户自己根据源码去构建安装包可能需要一周时间，而花 50-168 元就可以立马下载，所以卖了很多，装机量超过 150 万次。</p><p>出来创业之后，Sealos 也开始了正式的商业化。目前主要的商业模式有两大块：公有云和私有云。<strong>但有意思的是，</strong><strong>不管是标准版还是商业版</strong><strong>，不管是公有云还是私有云，Sealos 都只有一套代码。开源和商业化不分家。</strong>那 Sealos 是怎么盈利的呢？</p><p>公有云很简单，打开浏览器，注册登录充值就可以用，按量计费。但真正的盈利点是：<strong>云服务</strong><strong>。</strong></p><p>「很多做开源项目的公司都会有这样的困惑：开源做得太好，用户就不付钱了？为了解决这个问题，很多公司就会做两个版本，一个是开源版，功能少一点；一个是商业版，放一些很强的功能。我就非常不喜欢这样的做法。因为维护两个版本是很累的事，每次都需要考虑哪些东西合并企业版，哪些东西不合并，时间一久两个版本就直接分叉了，后面直接索性开源版不投入了，这种方式很别扭，不高级。</p><p>我喜欢把所有的好东西都开源出去，让开源和商业化尽可能形成合力。那怎么规避'开源做得足够好之后，用户不愿意掏钱'这个问题？很简单——云服务。」方海涛说。</p><p style="text-align:left">即便 Sealos 的开源做得非常完美，用户搭建的时候还是需要掏钱买虚拟机。既然这样，不如直接把这个钱充值给 Sealos。「本质上是成本转移，但是这种模式对三方都好。」对用户来说：</p><ul><li><p><strong>使用上更简单可以打开浏览器直接用，省去自己搭建。</strong></p></li><li><p><strong>专门的团队维护肯定比自己维护专业。</strong></p></li><li><p><strong>用户一多每个用户成本会下降，花钱更少。</strong></p></li><li><p><strong>持续升级更新。</strong></p></li></ul><p>因此，公有云的用户，有非常大的可能性会使用云服务。用户在 Sealos 上花的钱多了，但需要支出的总成本很可能还降低了。Sealos 也获得了更多的资金去做新功能，扩大规模效应。</p><p>另一个商业模式就是私有云。有些用户买了服务器放在自己机房，这时候 Sealos 就延续了一开始的商业模式，但不是收安装包的下载费用，而是在 Sealos 内部实现了计量系统，按量计费，账户余额用完了就得充值了。</p><p>这种方式实现了公有云和私有云计费方式的完全统一，顺便一起解决了企业内部人员配额问题。针对大小不同的客户都有合理的价格，不会出现小客用不起，大客不敢用的情况。</p><p>至于这样收费会不会让用户反感？</p><p>「我还是觉得提供价值合理收费天经地义，原则也是尽可能找到<strong>让客户与项目整体利益最大化的点</strong>，收费贵了伤害了用户利益，收费便宜了我们没法快速前进，要平衡好这中间的利益关系，是个矛盾统一体。现在这种商业模式，能够让开源和商业化形成合力，我们也能放心大胆地投入，把开源做好，而不会有担心用户不付费的顾虑。」方海涛说。</p><p>&nbsp;</p><span id="OSC_h1_5"></span><h1>05 像开源模式的商业团队</h1><p>Sealos 不仅产品有趣，背后的团队也很有意思。</p><p>如今的环界云只有 21 个人，其中 20 个人都是写代码的，包括方海涛自己。即使是运营，也是技术出身。除了在商务方面分工明确一点，其余时候，环界云更像一个开源社区，每个人都在为这个开源项目贡献代码，只是负责的模块不同。这种去中心化的开源协作方式一直顺利运行至今，其中一个很重要的原因是：环界云不太依赖销售，大部分的客户都是自己主动找上门的，因此整个团队得以单纯地搞技术，少了很多传统企业的条条框框。</p><p>当然，这种「人在家中坐，钱从天上来」的舒坦，离不开开源本身给项目带来的流量。Sealos 在社区里的好口碑和高知名度，已经成为了环界云最大的获客点。目前的数据显示，高达 90% 的收入都是来自于社区里这些主动找来的客户。因为他们是主动来寻求解决方案的，因此这也意味着他们对产品的接受度和成交率都相对较高。</p><p>目前，除了 Sealos 之外，环界云还孵化出了两个爆款开源项目：Laf 和 FastGPT。Laf 是个函数计算平台，可以在线直接写代码，至今已有 6000 的 star。FastGPT 是个基于 LLM 大模型的 AI 知识库问答平台，把企业内部的私有化数据跟大模型结合，能变成企业内部的智能问答系统，目前已有 8000+的 star。</p><p style="text-align:center"><img height="184" src="https://oscimg.oschina.net/oscnet/up-f83ed0b7f4872bb32ae1a977145bcbda30b.png" width="438" referrerpolicy="no-referrer"></p><p style="text-align:left">Laf 和 FastGPT 为 Sealos 提供了丰富的应用，FastGPT 和 Laf 之间相互提供了 AI 自动编码能力和插件开发能力，Sealos 则为 Laf 提供扩展、使 FastGPT 得以运行。三个产品相互补充，紧密协同，已形成了一个完整的生态系统。</p><p><strong>三个产品上线半年，环界云计算已累计 8.4 万的注册用户，且拥有 10% 的付费率和超过 70% 的续费率。更难能可贵的是，Sealos 和 Laf 已成功支撑了多款百万注册用户级别的应用，其运行成本仅为传统</strong><strong>云服务</strong><strong>的 1/20。</strong></p><p>Laf 的作者王福根和 FastGPT 的作者余金隆，都是方海涛的创业合伙人。我们发现，环界云招募团队成员和社区贡献者的方式没什么区别，都是按照招募合伙人的方式招的。</p><p>Sealos 的一位开发主力+长期贡献者，原是 Sealos 的用户。当时方海涛做了一个「分享有奖」的活动推广 Sealos，他给社区挣了 100 块，方海涛却奖励他 1500，他觉得这个社区好生奇怪，于是就留了下来。方海涛则认为，一个开源项目背后没有商业化支撑，会走得很慢。而且，开源的贡献者也理应得到回报。于是，为了吸引开源社区，方海涛专门写了一个激励系统，来回馈社区的项目贡献者：当需求被合并完了之后，钱就会自动打到贡献者的支付宝账户里面。这一传统也保留到了现在。</p><p>「那个时候在项目挣到的钱几乎都回馈到社区了。要么给开发者了，要么买服务器提供更好的体验了。」方海涛说，「但我觉得这是挺好玩的一件事情，这个模式形成了一种良性循环，这样项目就会滚滚向前，其实非常好。」</p><p style="text-align:center"><img height="1125" src="https://oscimg.oschina.net/oscnet/up-0fed2c5356b827e053d2ce179e81c714791.png" width="1500" referrerpolicy="no-referrer"></p><p style="text-align:center"><span style="color:#999999">环界云计算团队</span></p><p>&nbsp;</p><span id="OSC_h1_6"></span><h1>06 小项目准备挑战大考验</h1><p>目前，Sealos 社区用户 10 万+，不乏各种大企业。</p><p style="text-align:center"><img height="1855" src="https://oscimg.oschina.net/oscnet/up-1be0d9a7470266e6fbb03554af9e5903e0c.png" width="2000" referrerpolicy="no-referrer"></p><p>上线两个月时间注册用户就已破万，云服务共计运行 7000+应用。</p><p>应用的类型也很多，GPT 相关的、大模型、游戏、企业官网和业务系统等等，不一而足。</p><p>但 Sealos 的宏图不止于此，它的目标是进化为一款无所不在的云操作系统，为人们提供如同使用个人电脑般简易的云服务体验。</p><p>方海涛透露，接下来，Sealos 会有两个进化方向：</p><p>一个是产品的稳定性。因为云本质上是一个信任问题。如果产品不稳定，那用户一定不会深度使用，可能就浅尝辄止一下，或者把一些不重要的东西如博客论坛等等往里放。Sealos 刚上线的时候，都是开发者在用，顶多充个十块二十块的。但经过时间的积累，市场上认可了 Sealos 的稳定性之后，慢慢地有企业进来使用，充值数额也上去了。所以说，产品的稳定性才是核心。</p><p>但是，想把稳定性建设得足够好，其实是有一定挑战的，尤其是达到了一定规模之后。「我举个例子，现在市面上几乎所有的云原生网关都不能满足我们的需求，几乎都被我们打爆了。这个时候就需要我们去建设网关，把鲁棒性搞得更强。或者挑一个上下游的开源社区，帮他们做优化，一起变得更好。」方海涛说。</p><p>第二个要做的就是生态建设。「现在已经有不少的应用支持容器和 Kubernetes 了，那首先要做的就是把它们上架到我们的应用市场，拓展应用的宽度跟深度，再把 deploy on Sealos 反馈到社区。这种跟上下游开源项目之间的合作，大家都挺欢迎的。因为一方面 Sealos 有庞大的用户流量，可以给这个开源项目导流。另一方面，这个开源项目也可以为 Sealos 导流，所以是个完全互利互惠的事情。」</p><p>路漫漫其修远兮，这个小项目未来会如何，让我们拭目以待吧。</p><div><hr><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span><span style="background-color:#ffffff"><span><strong><strong><span><span style="background-color:#ffffff"><span><span style="color:#27ae60"><span><strong><span><span>【创造者说】</span></span></strong></span></span></span></span></span></strong></strong></span></span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span><span style="background-color:#ffffff"><span><span><span>OSCHINA 全新开源创企访谈栏目【创造者说】。</span></span></span></span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span><span style="background-color:#ffffff"><span><span><span>开源社区需要创造者，他可以是个人，也可以是由个人组成的公司。开源软件发展 20 余年，来自公司的开源贡献者已经成为中坚力量，更是有一批公司围绕开源软件而创办。本栏目将聚焦开源创企和他们的创始人，探讨当下的开源现状，分享开源商业故事，为开源社区添砖加瓦。</span></span></span></span></span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="background-color:#ffffff; color:#333333">往期回顾：</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><a href="https://my.oschina.net/oscpyaqxylk/blog/5578009" target="_blank">一个技术人 「误入歧途」，做了个向量数据库新物种</a></p></div><div><p style="margin-left:0px; margin-right:0px; text-align:start"><a href="https://my.oschina.net/oscpyaqxylk/blog/5548404" target="_blank">90 后，辞职创业，说要卷死云数据库</a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 08:24:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6852546/blog/10758980</guid>
            <link>https://my.oschina.net/u/6852546/blog/10758980</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[网易有道 Qanything 开源：探索个性化问答的新纪元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong>网易有道最新开源力作：QAnything 引擎。</strong>是基于 RAG（Retrieval Augmentated Generation) 的引擎，可以用于建立本地知识库做问答，解锁本土 ChatGPT 般的问答体验。☝</p><p><strong>「QAynthing」<strong>是一个成熟的系统，有着准确率高、速度快、纯离线，易于使用（一键部署），占用资源小</strong>（只要 16G 显存即可）的特点。</strong></p><p>目前，<strong>「QAynthing」</strong>已经在有道的多个产品中落地应用，包括有道词典的文档问答，有道速读，以及有道课程业务（高中、少儿围棋等）的客服系统等，在有道合作的 2B 客户的场景中已经落地应用。</p><p>&nbsp;<img alt="" src="https://oscimg.oschina.net/oscnet/up-3a44e1a3842061c69c8d841262c86d5ea68.png" referrerpolicy="no-referrer"></p><p>chatgpt 的大模型能力很强，但其训练耗时很长，无法利用用户的私有数据，且有胡乱编造的幻觉问题。</p><p><strong><strong>与 ChatGPT 相比，<strong><strong><strong><strong>有道自研的</strong></strong></strong></strong>「<strong><strong><strong><strong>Q</strong></strong></strong></strong>Aynthing</strong>」有自己的突出优势。</strong>它能够快速塞入各种格式的文档，如 doc、ppt、excel、图片、pdf 等，系统将在很短的时间内对这些文档进行处理并根据语义建立知识库，用户可以基于这样的知识库做各种问答。系统将理解用户的意图，在全库中寻找相关的内容，理解、提取用户关心的要点，并加以总结后呈现给用户。</p><p>&nbsp;<img alt="" src="https://oscimg.oschina.net/oscnet/up-28dd89cb825ae0ca3ded8dd7b632f332405.png" referrerpolicy="no-referrer"></p><p><strong>「QAynthing」</strong>包含的模型和系统代码，我们都全面开源了。此次开源还包含了一个应用系统，用户可以通过前端页面上传文档，直接使用。也可以通过我们提供的 API 接口做二次开发，搭建诸如智能客服等应用。用户直接一键下载我们的代码和模型即可开始使用。</p><p>&nbsp;</p><p>&nbsp;&nbsp;<img alt="" height="500" src="https://oscimg.oschina.net/oscnet/up-b05477f7eac27220217144c83707d9f1048.png" width="1000" referrerpolicy="no-referrer"></p><p><strong><strong>在模型部分</strong></strong>，我们开源了有道自研的 BCE embedding 和 rerank，用来做语义检索和相关性排序。得益于有道在翻译领域的积累，有道自研的 embedding/rerank 模型在跨语种场景下表现尤其好。比如知识库的文档有中文、英文混合语种的内容，当用中文去问问题的时候，我们能够很好的检索出英文内容。目前所有的开源 embedding 模型都忽略了跨语种检索的问题，在跨语种上表现不佳。此外，开源的 embedding 很多时候忽略了 RAG 的问题，只是单纯追求语义相似。<strong>而<strong>我们的 embedding 和 rerank 模型专门针对 RAG 的场景做了训练，所以有着更高的准确率</strong></strong>。</p><p><img alt="" height="456" src="https://oscimg.oschina.net/oscnet/up-c8fb3f4f844d6a2d5ac3608bae03fc309f2.png" width="1000" referrerpolicy="no-referrer"></p><p>在<strong><strong>系统部分</strong></strong>，我们对文档的解析、切片、建库、embedding/LLM 的推理做了大量的优化，具有<strong><strong>稳定、速度快、易于安装</strong></strong>使用的特点。</p><p><strong><strong>目前该项目还处于<strong><strong><strong><strong>不断迭代的阶段</strong></strong></strong></strong>，<strong><strong><strong><strong>欢迎大家参与开发，并给予</strong></strong></strong></strong>我们更多反馈</strong></strong>。</p><p>官网地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fnetease-youdao%2FQAnything" target="_blank"><u>https://github.com/netease-youdao/QAnything</u></a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 06:39:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/youdaotech/blog/10739178</guid>
            <link>https://my.oschina.net/youdaotech/blog/10739178</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[中文 JDK 教程网站正式上线，助力开发者掌握 Java 编程语言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#d1d5db; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">为了满足日益增长的 Java 开发者学习需求，对官方英文文档理解困难，致力于提供优质编程教育的网站《存在码》宣布推出全新的中文 JDK 教程网站。这一网站的上线标志着学习 Java 编程语言的全新起点，为开发者们提供了丰富而易于理解的学习资源。</span></p><p style="color:#d1d5db; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>网站特色：</strong></span></p><ol><li><p style="margin-left:0; margin-right:0"><strong>全面教程：</strong> 中文 JDK 教程网站提供了覆盖 Java 各个方面的详尽教程，旨在帮助开发者建立坚实的编程基础。</p></li><li><p style="margin-left:0; margin-right:0"><strong>实用示例：</strong> 数百个实用的示例代码将帮助开发者深入理解 Java 语言的概念和技巧，实践中学习。</p></li><li><p style="margin-left:0; margin-right:0"><strong>学习路径：</strong> 精心设计的学习路径，从入门到精通，让开发者能够有系统地提升技能水平。</p></li><li><p style="margin-left:0; margin-right:0"><strong>及时更新：</strong> 网站内容将根据 Java 平台的最新发展和技术趋势进行及时翻译更新，确保学习者始终保持与行业同步。</p></li></ol><p style="color:#d1d5db; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>网站创始人表示：</strong>「我们创建这个网站的目标是为中文用户提供一个高质量、易于理解的 Java 教育平台。我们深知学习编程的挑战，希望通过这个平台让更多人轻松入门，深入学习 Java 编程语言。」</span></p><p style="color:#d1d5db; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">现在，开发者们可以通过访问 </span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjava.cunzaima.cn" target="_blank">中文 JDK 教程网站</a><span style="color:#000000">开始他们的 Java 编程之旅。</span></p><p style="color:#d1d5db; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>关于中文 JDK 教程网站：</strong> 中文 JDK 教程网站是一个专注于为中文用户提供 Java 编程语言教育的在线学习平台。通过清晰易懂的教程和实用的示例代码，我们致力于帮助开发者轻松学习 Java，并在编程领域取得成功。访问我们的网站：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjava.cunzaima.cn" target="_blank"><span style="color:#2980b9">https://java.cunzaima.cn/</span></a></p><p><strong>网站截图：</strong></p><p><img height="763" src="https://oscimg.oschina.net/oscnet/up-a4908099ab2cb02c513eecfbe99f50213fd.png" width="1050" referrerpolicy="no-referrer"></p><p><img height="852" src="https://oscimg.oschina.net/oscnet/up-2059c6f708e6ff8119fcdbb4866fa34a17c.png" width="1888" referrerpolicy="no-referrer"></p><p><img height="733" src="https://oscimg.oschina.net/oscnet/up-d84726feca2fd514680bc5a7aaf4848b0a0.png" width="1910" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 05:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275053</guid>
            <link>https://www.oschina.net/news/275053</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[上海 AI 实验室联合港中大（深圳）开源音频生成平台 Amphion]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>上海人工智能实验室（上海 AI 实验室）与香港中文大学（深圳）联合团队<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FCjsutc54MgqANMtZj3pOKg" target="_blank">推出</a> AI 音频生成平台安菲翁（Amphion）。现已开源并提供免费商用。</p><p>其不仅具备语音及歌声合成转换、音效及音乐生成等多种能力，更可实现转换过程可视化，有效地降低了应用门槛，助力更广泛的开发者进行 AI 音频研发。</p><p>Amphion 为古希腊神话中的传奇音乐家，传说其弹奏的优美琴声可让顽石感灵。上海 AI 实验室联合团队借此为 AI 音频生成平台命名，希望通过 AI 技术的创新为音频领域注入全新的研究思路，开源开放，「声」生不息。</p><p><img height="195" src="https://oscimg.oschina.net/oscnet/up-50aec28c64a629ade537a270d95c38ed10e.png" width="500" referrerpolicy="no-referrer"></p><h4><strong>集成经典模型架构，实现多项生成任务</strong></h4><p>为帮助初级开发者入门 AI 音频生成研究并使研究过程可复现，Amphion 将当前多个经典模型架构集中于统一平台，使其可实现多项音频生成任务。</p><p><strong>歌声转换 （SVC, Singing Voice Conversion）</strong></p><p>歌声转换是指通过 AI 技术，将一位演唱者的音色转变为另一位演唱者。该技术涉及信号处理、机器学习、深度学习等领域。</p><p>Amphion 系统集成了经典的特征提取模型用于 SVC 任务，包括经典的扩散模型、VITS 模型及 OpenAI 的 Whisper 模型等。基于扩散的架构使用双向扩张 CNN 作为后端，并支持 DDPM、DDIM、PNDM 等多种采样算法。此外，Amphion 还支持基于一致性模型的单步推理。</p><p>目前，Amphion 的特征设计已被当前业内流行的音频生成项目 So-VITS-SVC 5.0 借鉴。</p><p><img height="213" src="https://oscimg.oschina.net/oscnet/up-43ddb9355908a681234f663d7e8c32eb864.png" width="700" referrerpolicy="no-referrer"></p><p><strong>文生语音（TTS, Text To Speech）</strong></p><p>文生语音即输入文字转成相应语音的技术。当前，该模块主要采用了深度学习技术，将文本转换成自然流畅的高拟真度语音。在 TTS 任务模块，Amphion 系统集成了经典 FastSpeech2 模型、VITS 模型以及 zero-shot 语音合成技术，即 Vall-E，NaturalSpeech2。</p><p><img height="196" src="https://oscimg.oschina.net/oscnet/up-34bba51d4fba3469ce72f4d2904a953e523.png" width="700" referrerpolicy="no-referrer"></p><p><strong>文生音频（TTA, Text To Audio）</strong></p><p>文生音频指将文字输入转为音乐、场景音效等特定音频的技术。Amphion 集成了当下主流的文本驱动音频生成模型架构，即基于 VAE Encoder、Decoder 和 Latent Diffusion 的文本驱动的音频生成算法。在该架构下，Latent Diffusion 扩散模型以 T5 编码后的文本为输入，根据文本的指引生成对应的音频效果。</p><p>文生音频模型或将对文化创作产生积极深远的影响，从业者或可利用此项技术，根据特定需求生成场景音效，省去从头采集环节，提升生产效率。</p><p><img height="166" src="https://oscimg.oschina.net/oscnet/up-5675245eb7699e52230f19025f4a496385e.png" width="500" referrerpolicy="no-referrer"></p><p>声码器（Vocoder）是产生高质量音频信号的重要模块。为确保所生成音频的高音质输出，Amphion 集成了目前广泛使用的神经声码器（Neural Vocoders），包括 BigVGAN、HiFi-GAN、DiffWave 等主流声码器。</p><p>技术报告显示，Amphion 中的 HiFi-GAN 声码器在多项指标上领先于当前热门开源工具。</p><p><img height="189" src="https://oscimg.oschina.net/oscnet/up-df33b9c0a05c5f8d220f0d8aaf44e960d53.png" width="500" referrerpolicy="no-referrer"></p><h4><strong>可视化功能</strong></h4><p>与传统的音频开源工具不同，Amphion 提供了生成过程可视化及音频可视化功能。联合团队旨在通过可视化，使初级开发者者更好地理解模型的原理和细节。下图为在扩散模型中的 SVC 任务，形象地呈现出由一位歌手音色转换为另外一位歌手音色的渐变过程。</p><p><img height="242" src="https://oscimg.oschina.net/oscnet/up-a8cbbee92c42b4d6f600a91d234509595e5.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 03:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275031</guid>
            <link>https://www.oschina.net/news/275031</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GitHub 多项服务出现故障]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>GitHub 多项服务昨天出现了故障，具体表现为众多 API 都出现了 HTTP 5xx 错误，错误率上升了 1%~5%，涉及的服务包括但不限于：</p><ul><li>Codespaces</li><li>Packages</li><li>Webhooks</li><li>Git 操作</li><li>Pages</li><li>API 请求</li><li>Actions</li><li>Pull Requests</li></ul><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.githubstatus.com%2Fincidents%2Fpxg3dz4yg7lp" target="_blank">从事故报告页面来看</a></u>，GitHub 当时的解决方案是<strong>将相关问题隔离到一个数据中心进行处理</strong>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-ed70f2066fa0d8193dd82f9badfeb155b0a.png" referrerpolicy="no-referrer"></p><p>不知道 GitHub 最近频发故障是否跟升级 MySQL 有关？<br><u><em><a href="https://www.oschina.net/news/270460/upgrading-github-com-to-mysql-8-0" target="news">GitHub.com 跑了 1200 多台 MySQL 主机，如何无缝升级到 8.0？</a></em></u></p><p><em>延伸阅读：<u><a href="https://www.oschina.net/news/188164/github-recent-service-disruptions" target="news">GitHub 解释近期频繁宕机原因：MySQL 不堪重负</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 02:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/275025/github-incident-20230109</guid>
            <link>https://www.oschina.net/news/275025/github-incident-20230109</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[全球领先的向量数据库公司，过去一年都做了哪些事情？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img src="https://oscimg.oschina.net/oscnet/up-2c30b522dd3a9e1d13170c70fc3ed0b22c3.png" alt="" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-41ac69b2f61c0f7f629df531803918e3884.png" alt="" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-4b03e70caa6f70b95fe4992b8e5ab15d675.png" alt="" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 02:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4209276/blog/10740359</guid>
            <link>https://my.oschina.net/u/4209276/blog/10740359</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Jan —— ChatGPT 的开源替代软件]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Jan 是 ChatGPT 的开源替代软件，可在电脑上 100% 离线运行。</p><p>Jan 可以在任何硬件上运行。从 PC 到多 GPU 集群，Jan 支持通用架构：</p><ul><li>Nvidia GPUs (fast)</li><li>Apple M-series (fast)</li><li>Apple Intel</li><li>Linux Debian</li><li>Windows x64</li></ul><p><strong>桌面应用程序</strong></p><p>通过可定制的 AI &nbsp;助手、全局热键和内联 AI 将工作效率提高 10 倍。</p><p><strong>移动应用（即将推出）</strong></p><p>随身携带你的人工智能助手。具有优雅的功能，无缝集成到你的移动工作流程中 。</p><h4 style="margin-left:0px; margin-right:0px; text-align:left"><strong><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:rgb(0 0 0/var(--tw-text-opacity))"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>兼容 OpenAI</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></h4><p style="margin-left:0px; margin-right:0px; text-align:left">Jan 在&nbsp;<strong style="color:#52525b">localhost:&nbsp;</strong><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><strong><span style="background-color:rgb(37 99 235/var(--tw-bg-opacity))"><span style="color:rgb(255 255 255/var(--tw-text-opacity))"><span><span><span><span><span><span><span><span><span><span><span><span><span>1337&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>提供了一个与 OpenAI 等效的 API 服务器，可以用作兼容应用程序的直接替代品。</p><p style="margin-left:0px; margin-right:0px; text-align:left"><img height="339" src="https://static.oschina.net/uploads/space/2024/0104/164324_Vw4l_4252687.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:left"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#1c1e21"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>从本质上讲，Jan 是一个跨平台、本地优先的 AI 原生框架，可用于构建任何东西。事实上，当前的功能都是在此核心 SDK 之上作为第三方扩展实现的。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0px; margin-right:0px; text-align:left"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#1c1e21"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>项目团队的目标是建立一个类似 VSCode 或 Obsidian 的框架，允许开发人员在 15 分钟内根据其特定需求构建和定制复杂的 AI 应用程序。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>&nbsp;</p></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 02:10:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/jan</guid>
            <link>https://www.oschina.net/p/jan</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 面向 C# 程序员的 Visual Studio 效率提升器 Codist]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-codist" class="anchor" href="https://gitee.com/wmjordan/Codist#codist"></a>Codist</h1><p><em>Codist</em> is a Visual Studio extension which strives to provide better coding experience and productivity for C# programmers.
Codist 是一个致力于为 C# 程序员提供更佳的编码体验和效率的 Visual Studio 扩展。</p><h1><a id="user-content-features" class="anchor" href="https://gitee.com/wmjordan/Codist#features"></a>Features</h1><p>Here's a brief but not complete demonstration of <em>Codist</em>'s enhancement to Visual Studio.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/preview.png" alt="Feature overview" referrerpolicy="no-referrer"></p><p>Check out this list to see what <em>Codist</em> can do for you.</p><ul><li><a href="https://gitee.com/wmjordan/Codist#advanced-c-syntax-highlight">Advanced Syntax Highlight</a> ANY LANGUAGES, and <a href="https://gitee.com/wmjordan/Codist#comment-tagger-and-styles"><em>Comment Tagger</em></a> highlights <code>to-do</code> style comments
<img src="https://gitee.com/wmjordan/Codist/raw/master/doc/feature-brief-syntax-highlight.png" alt="" referrerpolicy="no-referrer"></li><li><a href="https://gitee.com/wmjordan/Codist#super-quick-info">Super Quick Info</a> with extended XML Doc, symbol tool-tips, selectable contents, appearance customization, etc.
<img src="https://gitee.com/wmjordan/Codist/raw/master/doc/feature-brief-super-quick-info.png" alt="Feature Brief Super Quick Info" referrerpolicy="no-referrer"></li><li><a href="https://gitee.com/wmjordan/Codist#navigation-bar">Navigation Bar</a> with a drag-and-drop and filter enabled member list
<img src="https://gitee.com/wmjordan/Codist/raw/master/doc/feature-brief-navigation-bar.png" alt="Feature Brief Navigation Bar" referrerpolicy="no-referrer"></li><li><a href="https://gitee.com/wmjordan/Codist#smart-bar">Smart Bar</a> with common edit commands, C# code refactoring and symbol reference analyzers
<img src="https://gitee.com/wmjordan/Codist/raw/master/doc/feature-brief-smart-bar.png" alt="Feature Brief Smart Bar" referrerpolicy="no-referrer"></li><li><a href="https://gitee.com/wmjordan/Codist#scrollbar-marker">Scrollbar Marker</a> draws a powerful mini code map
<img src="https://gitee.com/wmjordan/Codist/raw/master/doc/feature-brief-scrollbar-marker.png" alt="Feature Brief Scrollbar Marker" referrerpolicy="no-referrer"></li><li><a href="https://gitee.com/wmjordan/Codist#auto-changing-version-numbers">Auto Changing Version Numbers</a></li><li><a href="https://gitee.com/wmjordan/Codist#display-enhancements">Display Enhancements</a></li><li><a href="https://gitee.com/wmjordan/Codist#jump-list-shortcuts">Jump List Shortcuts</a></li><li><a href="https://gitee.com/wmjordan/Codist#auto-pair-punctuations">Auto Pair Punctuations</a></li><li><a href="https://gitee.com/wmjordan/Codist#codist-in-your-language">Codist in Your Language</a></li><li><a href="https://gitee.com/wmjordan/Codist#other-features">Others</a></li><li><a href="https://gitee.com/wmjordan/Codist#feature-control">Comprehensive Configurations</a></li><li><a href="https://gitee.com/wmjordan/Codist#acknowledgements">Acknowledgements</a></li><li><a href="https://gitee.com/wmjordan/Codist#license">License</a>, <a href="https://gitee.com/wmjordan/Codist#bugs-and-suggestions">Bugs and Suggestions</a>, <a href="https://gitee.com/wmjordan/Codist#support-codist-by-donation">Donate</a></li></ul><p><em>Codist</em> supports localization into other languages and it has both English and Chinese now.</p><h2><a id="user-content-advanced-c-syntax-highlight" class="anchor" href="https://gitee.com/wmjordan/Codist#advanced-c-syntax-highlight"></a>Advanced C# Syntax Highlight</h2><p>The advanced syntax highlight function highlights every aspect of C# language elements with diverse styles, including using various font families and text styles, underline styles, enlarging or shrinking font sizes, changing foreground or background colors and transparency.</p><p>You can change syntax highlight styles in any languages, such as Visual BASIC, F#, SASS, and so on, even if they are not recognized by Codist.</p><p>The following screenshots of the <code>TestPage.cs</code> file in the source code project demonstrates possible syntax highlight effects in the Light theme.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/highlight1.png" alt="Syntax highlight" referrerpolicy="no-referrer"></p><ul><li>The font size and font family for each syntax style can be changed, so it is much easier to spot them. This feature is helpful for color-blind people.</li><li>Syntax highlight can be applied to braces and parentheses.</li><li>Various syntax identifiers have different styles, temporary elements such as method parameters and local variables are italic, <code>static</code> symbols are underlined.</li><li>Comment content can be tagged (e.g. <em>todo</em>, <em>note</em>) and highlighted with individual style.</li><li>Unnecessary code can be marked strike-through.</li><li>Keywords are categorized and highlighted with various styles (e.g. <code>abstract</code> and <code>sealed</code>, <code>return</code> and <code>throw</code>, etc.).</li><li>Overriding members (such as <code>ToString</code>) can be painted with gradient background color, so at a glance we know that the marked implementations have overridden their base classes.</li><li>Imported symbols (from external assemblies, e.g. <code>NotImplementedException</code>, <code>ToString</code>) can be marked with a different style (bold here), distinguishing from symbols defined in your code.</li><li>All the above styles are customizable.</li></ul><h3><a id="user-content-default-syntax-highlight-themes" class="anchor" href="https://gitee.com/wmjordan/Codist#default-syntax-highlight-themes"></a>Default Syntax Highlight Themes</h3><p>To quickly get started with advanced syntax highlight, open a C# project, then click the <em>Customize Codist Syntax Highlighting</em> command under the <em>Tools</em> menu.</p><p>A window will pop up, click buttons at the left side of the dialog under the <strong>Predefined themes</strong> and see changes in effect. The styles on the right of the dialog immediately lists effects of corresponding syntax elements. Don't forget to click the <em>Save</em> button at the bottom of the dialog to confirm the changes.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/syntax-highlight-customization-window.png" alt="Load Theme" referrerpolicy="no-referrer"></p><p>With the <strong>Save</strong> and <strong>Load</strong> buttons, you can backup and share your own syntax highlight settings.</p><p>If you mess up your syntax highlight styles, you can press the <strong>Reset</strong> button to reset all settings to default, or reapply predefined themes by clicking buttons at the left bottom.</p><p><strong>Note</strong>: There is a known issue in <em>Codist</em> that <strong>if you change the theme of Visual Studio, you may have to restart it to make syntax highlight settings to work properly</strong>. If the <strong>Reset</strong> button does not work, please try restarting Visual Studio.</p><h3><a id="user-content-customization-of-syntax-highlight-styles" class="anchor" href="https://gitee.com/wmjordan/Codist#customization-of-syntax-highlight-styles"></a>Customization of Syntax Highlight Styles</h3><p>To customize and tweak the desired syntax highlight styles, click or select the text in the document window, and click the <em>Customize Codist Syntax Highlighting</em> command under the <em>Tools</em> menu.</p><p>The customization window will pop up and listing syntax classifications applied to the active text.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/syntax-highlight-customizing-selected.png" alt="Syntax Highlight Customizing Selected" referrerpolicy="no-referrer"></p><p>Click the style in the Syntax Styles list, adjustment controls will be displayed at the bottom of the dialog, where you can change the style. As you change the style, you can immediately see how it appears in the code document window.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/syntax-highlight-customization-preview.png" alt="Syntax Highlight Customization Preview" referrerpolicy="no-referrer"></p><p>Underline styles can be customized. Firstly assign a color for the <strong>Line</strong>, afterwards, more configuration elements will appear.</p><p>If you want to change another syntax element, click on the place where it is applied in the code document window. If the customization window is still opened, and the <em>Selected Code</em> section under <em>Syntax Categories</em> is selected, the list will display the corresponding syntax styles for the place you clicked immediately.</p><p>You can explore other syntax categories by clicking the list on the left of the dialog.</p><p>Syntax definitions in the <em>All languages</em> section will list all syntax styles for any languages installed; those under <em>Tagged comments</em> section apply to <a href="https://gitee.com/wmjordan/Codist#comment-tagger-and-styles">comment taggers</a>, others apply to corresponding languages accordingly.</p><p><strong>Note</strong>: <em>Font size</em> is relative value to editor default font size. Partially checked checkboxes denote default syntax styles are used.</p><p><strong>A Side Note for Editor Font</strong>: You may consider substituting the font used by Visual Studio code editor with professionally designed fonts for programming, for instance, <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FIBM%2Fplex">IBM Plex Mono</a>, <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Ftonsky%2FFiraCode">Fira Code</a>, etc. Employing <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fsnowie2000%2Fmactype">MacType</a> can significantly enhance system-wide textual display quality, especially for Chinese, Japanese and Korean programmers.</p><h3><a id="user-content-my-symbols-and-external-symbols" class="anchor" href="https://gitee.com/wmjordan/Codist#my-symbols-and-external-symbols"></a>My Symbols and External Symbols</h3><p><em>Codist</em> can identify symbols which are defined in your source C# code and which are imported from external assemblies. This feature is so unique that you may not find it elsewhere.</p><p>You can customize it in the <em>symbol markers</em> section under the <em>C#</em> section in the <em>Syntax Highlight Configurations</em> dialog. Style <em>C#: User symbol</em> is used for symbols from your code, and <em>C#: Metadata symbol</em> is used for symbols imported from external assemblies.</p><p><strong>Note</strong>: some predefined themes have defined external symbols with <strong>bold</strong> style, as the above screenshot shows.</p><h2><a id="user-content-comment-tagger-and-styles" class="anchor" href="https://gitee.com/wmjordan/Codist#comment-tagger-and-styles"></a>Comment Tagger and Styles</h2><ul><li><p>The comment tagger highlights comments to your specific styles, according to the first token inside the comment.</p><p>Here are the effects how they are applied.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/syntax-highlight-comments.png" alt="Comment syntax highlight" referrerpolicy="no-referrer"></p><p>To configure the comment tags, which identify comment types, click the <em>tags</em> section, under the <em>Tagged comments</em> section in the <em>Syntax Highlight Configurations</em> dialog, where you can add, remove or modify comment tags.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/syntax-highlight-comment-tags.png" alt="Syntax Highlight Comment Tags" referrerpolicy="no-referrer"></p><p>To disable comment tagger, open the <em>Options</em> dialog, find the <em>Codist/Syntax Highlight</em> section and  uncheck the check box labeled <em>Enable comment tagger</em> in the <em>Syntax Highlight</em> option page.</p></li></ul><h2><a id="user-content-super-quick-info" class="anchor" href="https://gitee.com/wmjordan/Codist#super-quick-info"></a>Super Quick Info</h2><p>The quick info (the tool-tip shown when you hover your mouse pointer on your C# source code) can be enhanced by <em>Codist</em>.</p><h3><a id="user-content-general-quick-info" class="anchor" href="https://gitee.com/wmjordan/Codist#general-quick-info"></a>General Quick Info</h3><p>To customize the <em>Super Quick Info</em>, adjust the settings in the options page.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-options.png" alt="Super Quick Info Options" referrerpolicy="no-referrer"></p><p>Options in the <em>General</em> page apply to all code editor windows.</p><ul><li><p><strong>Hide Quick Info until Shift key is pressed</strong></p><p>By default, <em>Quick Info</em> appears when you hover your mouse over a symbol or syntax token in code editor. Some programmers think this behavior interferes their workflow. Checking this option will suppress the <em>Quick Info</em> until Shift key is pressed.</p></li><li><p><strong>Selection info</strong></p><p>This option will show how many characters and lines in your selection (if your selection spans over multiple lines). So you don't have to count characters one by one.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-selection-length.png" alt="Super Quick Info Selection Length" referrerpolicy="no-referrer"></p></li><li><p><strong>Color info</strong></p><p>This option enables you preview color values. It works for hex color values (such as <code>#00FF00</code>，<code>#33993300</code>), named colors (such as <code>Black</code>, <code>White</code>, etc.). The 12 sample blocks under color values list the color as the foreground or background against various gray scale colors to help designers to determine the best readability.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-color.png" alt="Super Quick Info - Color" referrerpolicy="no-referrer"></p><p>In C# code editor, Codist can also analyze system colors (such as <code>SystemColors.WindowColor</code>, <code>SystemColors.Control</code>, etc.), <code>Color.FromArgb</code> or <code>Color.FromRgb</code> expression with constant values as well.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-csharp-color.png" alt="Super Quick Info - C# Color" referrerpolicy="no-referrer"></p><p>The color info not only works in code windows, but also in debugger <em>Watch</em> window.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-debugger-watch.png" alt="Super Quick Info - Color" referrerpolicy="no-referrer"></p></li><li><p><strong>Quick Info size</strong></p><p>From version 7.5 on, it is possible to limit the size of the Quick Info popup, so the window won't cover your whole screen.</p><p>By default, <em>Codist</em> does not apply size limitations. You must manually set the <em>Max width</em> and <em>Max height</em> here. If the contents exceed the width, they are wrapped, and scrollbars will appear when necessary, as the screenshot below demonstrates.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-size.png" alt="Super Quick Info - Size" referrerpolicy="no-referrer"></p></li><li><p><strong>Display Delay</strong></p><p>From version 7.5 on, Codist can delay the display of Quick Info, so it won't get into your way when you move your mouse in the document window.</p></li><li><p><strong>Background</strong></p><p>The background color of the Quick Info can be changed. Click the <strong>Background</strong> button and pick your favorite color.</p></li></ul><h3><a id="user-content-c-quick-info" class="anchor" href="https://gitee.com/wmjordan/Codist#c-quick-info"></a>C# Quick Info</h3><p><em>Super Quick Info</em> especially enhances programming experience for C# programmers. There are plenty of options available in the options page.</p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-csharp-options.png" title="" alt="Super Quick Info - Options" width="617" referrerpolicy="no-referrer"><ul><li><p><strong>Use enhanced symbol signature style</strong> is a new setting in version 6.6, enabled by default, which optimizes the display of symbol signatures with a reorganized layout. The layout is especially optimized for long and complex signatures, yet ordinary short symbols can also benefit from it. The following is an example for the style. A large icon on the top-left part of the quick info can be clicked and brings out a menu for symbol analysis. Next to the icon is the name of the symbol standing out with larger text. Clicking on the name can jump to its definition. The parameters for the method are listed next. The reorganized layout never breaks the parameter type from its name, so it is easier to find out and locate each parameter type and name. Beneath the signature is the containing type of the symbol, as well the kind of the symbol. And the member type (return value) of the symbol is under the containing type.
<img src="https://gitee.com/wmjordan/Codist/raw/master/doc/csharp-optimized-quick-info.png" alt="C# optimized quick info" referrerpolicy="no-referrer"></p></li><li><p><strong>Highlight current syntax node in code editor</strong> will draw polygonal markers the syntax node related to the place where Quick Info is triggered.</p></li><li><p>A <strong>Context menu</strong> with many symbol analysis commands will show up when you right click the signature of the symbol definition or any symbol that appears in the Super Quick Info.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-csharp-menu.png" alt="Super Quick Info Csharp Menu" referrerpolicy="no-referrer"></p></li><li><p><strong>Override XML Documentation</strong></p><p>The overridden XML Documentation makes the following changes to displayed documentation.</p><ul><li>More syntax colors (adopting syntax highlight colors) for symbols.</li><li>Icons for documentation parts.</li><li>Selectable content of the documentation.</li><li>Copyable quick info content (First select text with your mouse, then press <code>Ctrl + C</code> shortcut key, or right click to show up a context menu with Copy command).</li><li>Concise form of members (without leading namespace or containing type names, hover your mouse over a symbol to view its full definition).</li><li>Extra tags, such as <code>&lt;b&gt;</code> (for bold), <code>&lt;i&gt;</code> (for italic) and <code>&lt;u&gt;</code> (for underline) are supported.</li><li>Extra information from documentations (see below).</li></ul></li></ul><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-override-doc.png" alt="Super Quick Info Override Doc" referrerpolicy="no-referrer"></p><p>When <em>Override XML Documentation</em> checkbox is checked in the options page, it is also possible to activate options under it.</p><ul><li><p><strong>Inherit from base type or interfaces</strong> option will show documentation description from base <code>class</code>es or implemented <code>interface</code>s if the XML Doc description of the current symbol is absent.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-inherit-base.png" alt="Super Quick Info - Inherit Base" referrerpolicy="no-referrer"></p></li><li><p><strong>Inherit from <code>&lt;inheritdoc cref="MemberName"/&gt;</code> target</strong> option will borrow description from the referenced <code>MemberName</code>.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-inheritdoc.png" alt="Super Quick Info Inheritdoc" referrerpolicy="no-referrer"></p></li><li><p><strong>Show <code>&lt;returns&gt;</code> XML Doc</strong> and <strong>Show <code>&lt;remarks&gt;</code> XML Doc</strong> will add content of those tags.</p></li><li><p><strong>Override <code>&lt;exception&gt;</code> XML Doc</strong> option adds back documentations for exceptions to the Quick Info.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-override-exception.png" alt="Super Quick Info - Override Exception" referrerpolicy="no-referrer"></p></li></ul><p><em>Codist</em> shows XML Doc for those <code>namespace</code>s with an embedded <code>NamespaceDoc</code> class, like what is done in <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FEWSoftware%2FSHFB">SandCastle</a>.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-csharp-namespace.png" alt="Super Quick Info Csharp Namespace" referrerpolicy="no-referrer"></p><h3><a id="user-content-additional-quick-info-items" class="anchor" href="https://gitee.com/wmjordan/Codist#additional-quick-info-items"></a>Additional Quick Info Items</h3><p>A dozen of additional quick info items could be displayed in the <em>Additional Quick Info Items</em> options page.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-csharp-items.png" alt="Super Quick Info Csharp Items" referrerpolicy="no-referrer"></p><ul><li><p><strong>Attributes</strong> option shows attributes of a symbol.</p></li><li><p><strong>Base type</strong> and <strong>Interfaces</strong> options shows inheritance and implementation info of a type. It is recommended to check <strong>All ancestor types</strong> and <strong>Inherited interfaces</strong> to display the complete info of the hierarchy of a type.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-attribute-base-interface.png" alt="Super Quick Info Attribute Base Interface" referrerpolicy="no-referrer"></p><p><strong>Note</strong>: the <code>IDisposable</code> interface has special importance in .NET programming, thus it is assigned a special icon and pinned to the top of the interface list.</p></li><li><p><strong>Declaration</strong> option shows modifiers to a symbol when it is not a public instance one.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-declaration.png" alt="Super Quick Info Declaration" referrerpolicy="no-referrer"></p></li><li><p><strong>Interface implementation</strong> option shows if a member implements any interface.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-interface-implementation.png" alt="Super Quick Info Interface Implementation" referrerpolicy="no-referrer"></p></li><li><p><strong>Method overload</strong> options shows possible overloads of a method (including applicable extension methods).</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-method-overloads.png" alt="Super Quick Info - Method Overloads" referrerpolicy="no-referrer"></p><p>This option also helps you find out correct overloads when any argument passed to a method is incorrect.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-param-candidate.png" alt="Super Quick Info Param Candidate" referrerpolicy="no-referrer"></p></li><li><p><strong>Parameter of method</strong> options shows whether a token or an expression is the parameter of a method in the argument list. What is more, the documentation of the parameter is also displayed.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-param.png" alt="Super Quick Info - Param" referrerpolicy="no-referrer"></p></li><li><p><strong>Type parameter</strong> option shows information and documentation about type parameters.</p></li><li><p><strong>Symbol location</strong> shows where a symbol is defined.</p></li><li><p><strong>Numeric forms</strong> shows decimal, hexadecimal and binary forms for constant integer and <code>Enum</code> values.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-const.png" alt="Super Quick Info Const" referrerpolicy="no-referrer"></p><p>The binary form is useful when working with bit flags.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/super-quick-info-enum.png" alt="Super Quick Info Enum" referrerpolicy="no-referrer"></p></li><li><p><strong>String length and Hash codes</strong> for string constants.
(Hint: We can use Hash codes to quickly compare whether two strings that look alike are identical)</p></li></ul><h2><a id="user-content-navigation-bar" class="anchor" href="https://gitee.com/wmjordan/Codist#navigation-bar"></a>Navigation Bar</h2><p><em>Navigation bar</em> locates at the top of the code editor window. It overrides the original navigation bar. When the <em>Navigation Bar</em> is loaded, it hides two drop-down lists on the original Navigation Bar, but preserves the project drop-down list.</p><p>Basically, the <em>Navigation Bar</em> serves the same purpose of the original one comes with Visual Studio, displaying symbol information where the caret is placed.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-overview.png" alt="Navigation Bar Overview" referrerpolicy="no-referrer"></p><p><strong>Note</strong>: Navigation Bar works with both C# code documents and Markdown documents.</p><p>Nodes on the <em>Navigation Bar</em> are clickable.</p><ol><li><p>Clicking on the left-most <strong>Search Document node</strong> will popup a menu, displaying namespaces and types defined in the active document.</p><p>On top of the menu, there is a <strong>Search Declaration</strong> box, within which you can type and search declarations.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-search.png" alt="Navigation Bar Namespace Types" referrerpolicy="no-referrer"></p><p>Besides the <em>Search Declaration</em> box, there are three buttons. The first one is pressed by default, which restricts the search scope to active document. If the second one is pressed, it pops up the first button and expands the search scope to current project (see screen shot below). The third button clears the search box and reverts the items back to unfiltered namespaces and types.</p><p><strong>Note</strong>: Press <code>-</code> or <code>=</code> key on keyboard to switch search scope between current document and current project.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-search-declaration.png" alt="Navigation Bar Search Declaration" referrerpolicy="no-referrer"></p><p><strong>Note</strong>: If the first character in the search box is an upper case one, the search will be <strong>case-sensitive</strong>, otherwise, it is case-insensitive.</p><p>You can <strong>drag and drop</strong> items in the menu to reorder types within the document.</p></li><li><p>Clicking on the <strong>global namespace node</strong>, which has a house as the icon, will popup a menu, displaying all root namespaces defined in the project and referenced assemblies, as well as types without any namespace. You can click namespaces to check out its sub-namespaces and types.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-global-namespaces.png" alt="Global namespaces" referrerpolicy="no-referrer"></p><p>There is also a search box in this menu, which filters content of the menu.</p><p>There are several buttons beside the search box. Numbers on the buttons counts corresponding items within the type. Hover your mouse cursor over the button, you can read meanings of them. Pressing down those buttons filters members within the menu to corresponding ones.</p><p>You can right click items on the menu to bring out a context menu for corresponding members.</p></li><li><p>Clicking a <strong>Namespace node</strong> which follows the Document node will popup a menu, displaying namespaces and types defined in the corresponding namespace. You can click on those items and jump to the beginning of corresponding definitions.</p></li><li><p>Clicking on a <strong>Type node</strong> will popup a menu, displaying members and regions defined within the type. You can click on those items and jump to the definition of the corresponding member.</p><p>You can <strong>drag and drop</strong> items in the menu to reorder members, nested types and <code>#region</code>s within the document. If a <code>partial</code> type spans over several code files, it is also possible to rearrange members among them.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-fields.png" alt="Navigation Bar Fields" referrerpolicy="no-referrer"></p><p>The current symbol where the caret is on is highlighted.</p><p>Field values and auto-property expressions are also displayed on this menu. So, you can read the initial value of fields immediately.</p><p>You can right click items to bring out a context menu for the symbol.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-context-menu.png" alt="Navigation Bar Fields" referrerpolicy="no-referrer"></p><ol start="5"><li><p>Clicking on a <strong>Member node</strong> will select the whole member. If you have the <em>Smart Bar</em> feature on and let it appear when selection is changed, <em>Smart Bar</em> will be displayed and let you perform actions onto the member.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-select.png" alt="Navigation Bar Select" referrerpolicy="no-referrer"></p></li></ol></li></ol><h3><a id="user-content-customization" class="anchor" href="https://gitee.com/wmjordan/Codist#customization"></a>Customization</h3><p>The <em>Navigation Bar</em> can be configure via the options page.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-options.png" alt="Navigation Bar Options" referrerpolicy="no-referrer"></p><ul><li><p>If <strong>Syntax detail</strong> option is set, the <em>Navigation Bar</em> not only shows available types and declarations in the code window like the original navigation bar, but also syntax nodes such as statements and expressions containing the caret.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-syntax-details.png" alt="Navigation Bar Syntax Details" referrerpolicy="no-referrer"></p></li><li><p>If <strong>Symbol info tip</strong> option is set, you can read information about a symbol when you hover your mouse onto a node.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-symbol-info.png" alt="Navigation Bar Symbol Info" referrerpolicy="no-referrer"></p></li><li><p>If <strong>Highlight syntax range</strong> option is set, when you hover the mouse over the node on the bar, corresponding span of the node will be highlighted in the editor.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-node-range.png" alt="Navigation Bar Node Range" referrerpolicy="no-referrer"></p><ul><li>If <strong>Region</strong> option is set, <code>#region</code> names will be displayed on the Navigation Bar. If you pad region names with some non-alphabetic characters like "<code>#region [====== private methods ======]</code>", you can check the <strong>Trim non-letter characters in region</strong> checkbox so only alphabetic part like "<code>private methods</code>" will be displayed on the <em>Navigation Bar</em>.</li></ul><p>To customize drop-down menus of the <em>Navigation Bar,</em> change options in the <em>Drop-down Menu</em> tab.</p></li></ul><h3><a id="user-content-markdown-navigation-bar" class="anchor" href="https://gitee.com/wmjordan/Codist#markdown-navigation-bar"></a>Markdown Navigation Bar</h3><p>The Markdown navigation bar lists all titles appear in a Markdown document.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/navigation-bar-markdown.png" alt="Navigation Bar Markdown" referrerpolicy="no-referrer"></p><p>Similarly, you can type in the search box to filter down the titles.</p><p>From version 7.8 on, there are buttons near the search box to limit displaying titles to specific levels.</p><h2><a id="user-content-smart-bar" class="anchor" href="https://gitee.com/wmjordan/Codist#smart-bar"></a>Smart Bar</h2><p>The <em>Smart Bar</em> is a context-aware tool bar that appears automatically when you select some text, or double tap the <em>Shift</em> key on your keyboard.</p><p>There are two toolbars on <em>Smart Bar</em>. The top bar contains general editing commands for all file types. Buttons on the bottom bar changes according to file types.</p><p>Buttons on the <em>Smart Bar</em> changes according to your selection, typical buttons are editing operations (e.g. <em>Cut</em>, <em>Copy</em>, <em>Paste</em>,  <em>Delete</em>, <em>Duplicate</em>, <em>Formatting</em>, <em>Find</em>, etc.), code analysis operations (e.g. <em>Go to definition</em>, <em>Find references</em>), refactoring operations (e.g. <em>Rename</em>, <em>Extract method</em>, etc.)</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar.png" alt="Smart Bar" referrerpolicy="no-referrer"></p><p>Each button on <em>Smart Bar</em> usually has multiple functions. Left clicking, right clicking, Ctrl+clicking and Shift+clicking trigger different commands. For details, see the tool-tip for the buttons. Right clicking a button usually expands the effective range of a command to the whole line, or brings out a pop-up menu for more commands.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-2.png" alt="Smart Bar" referrerpolicy="no-referrer"></p><p>There are multiple predefined <strong>web search</strong> commands in the menu when you right click the Find button, which will launch your browser to search the text you select in document window. So, it is handier to look for answers from the web or find code examples in <em>GitHub</em>.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-search.png" alt="Smart Bar Search" referrerpolicy="no-referrer"></p><p>You can specify what browser you prefer to use in the options page.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-search-options.png" alt="Smart Bar Search Options" referrerpolicy="no-referrer"></p><h3><a id="user-content-c-specific-commands" class="anchor" href="https://gitee.com/wmjordan/Codist#c-specific-commands"></a>C# Specific Commands</h3><p>When you select a symbol, you may probably see a <em>Smart Bar</em> like below.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar.png" alt="Smart Bar" referrerpolicy="no-referrer"></p><p>The C# commands are on the second row.</p><p>The first one is <strong>Go to Definition</strong>, that behaves the same as the keyboard <code>F12</code> command. With this, you no longer need hitting the <code>F12</code> key to go to definition.</p><p>The second one is the <strong>Analyze symbol...</strong> button, a menu will pop up showing possible symbol analysis commands for the symbol. Since some commands require considerable amount of calculation, items ending with "..." will require a mouse click to expand. For instance, clicking the <strong>Find Callers</strong> command in the following screen shot will search the source code and list at what places are calling the selected method in a symbol list. In the symbol list, you can filter items like the what you can do in the <em>Navigation Bar</em>, click items on the sub-menu and jump to the corresponding location.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-symbol-analysis.png" alt="Smart Bar Symbol Analysis" referrerpolicy="no-referrer"></p><p>Various commands will be conditionally listed under the <strong>Analyze symbol...</strong> menu. Here is a list of commands for an interface.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-symbol-analysis-2.png" alt="Smart Bar Symbol Analysis 2" referrerpolicy="no-referrer"></p><p>The <strong>Find Members</strong> command under <strong>Analyze symbol...</strong> lists all members defined within a type. For some special types, for instance, <code>SystemColors</code>, <code>Colors</code>, <code>Brushes</code>, etc. The preview is shown on the list.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-member-colors.png" alt="Smart Bar Member Colors" referrerpolicy="no-referrer"></p><p>For Visual Studio extension developers, the preview offers more, for instances, it allows previewing images of <code>KnownImageIds</code>, colors in <code>VsBrush</code>, etc.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-member-knownimageids.png" alt="Smart Bar Member KnownImageIds" referrerpolicy="no-referrer"></p><p>The <strong>Find Implementations</strong> command for an interface type will display all types that implement that interface. The same command will also appear for interface members, which finds out corresponding members that implement the specific interface member.</p><p>When we begin to work with new libraries, we usually have to learn new types and APIs. Two typical scenario are that "<em>what methods, properties return specific instance of a type?</em>" and "<em>what methods can an instance of a given type can be passed into?</em>". Thus, <em>Smart Bar</em> provides <em>Find Instance Producer</em> and <em>Find Instance as Parameter</em> for type names. The following screen shot demonstrates the result of finding instance producers which returns an instance of <code>IWpfTextView</code>.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-instance-producer.png" alt="Smart Bar Instance Producer" referrerpolicy="no-referrer"></p><p>There are two buttons on the top right corner in the result list of symbol analysis commands. The <em>Pin</em> button will keep the list on the screen. And you can use your mouse to drag those lists around.</p><h3><a id="user-content-code-refactorings" class="anchor" href="https://gitee.com/wmjordan/Codist#code-refactorings"></a>Code Refactorings</h3><p>From version 7.0 on, quite a few code refactorings are provided via a button on the C# Smart Bar.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-refactoring.png" alt="Smart Bar Code Refactoring" referrerpolicy="no-referrer"></p><p>You can access the menu from keyboard by assigning a shortcut key to the <code>Refactor.RefactoringCode</code> command.</p><h3><a id="user-content-symbol-marker" class="anchor" href="https://gitee.com/wmjordan/Codist#symbol-marker"></a>Symbol Marker</h3><p><em>Symbol marker</em> draws markers for C# symbols.</p><p>Typically, you can double click a symbol in the C# source code, select the <em>Mark Symbol</em> command on the <em>Smart Bar</em> and choose the desired highlight marker on the drop-down menu.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/symbolmarker.png" alt="Symbol Marker" referrerpolicy="no-referrer"></p><p>After applying the command, all occurrences of the marked symbol will be marked with a different style.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/symbolmarker-effect.png" alt="Symbol Marker Effect" referrerpolicy="no-referrer"></p><p>To remove symbol marker, click the <em>Remove symbol mark</em> command in the drop-down menu of the <em>Mark symbol</em> command.</p><p>Symbol markers will be cleared when the solution is unloaded.</p><p><strong>Note</strong>: The style of symbol markers can be customized in the <em>Syntax highlight Configurations</em> dialog. The default colors are listed below. You also need to turn on the <em>Syntax Highlight</em> feature in order to make this feature work.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/symbolmarker-options.png" alt="Symbol marker Options" referrerpolicy="no-referrer"></p><h3><a id="user-content-behavior-of-smart-bar" class="anchor" href="https://gitee.com/wmjordan/Codist#behavior-of-smart-bar"></a>Behavior of Smart Bar</h3><p>By default, <em>Smart Bar</em> appears after selection changes, you can alter the behavior in the options page by unchecking the <em>Show Smart Bar when selection is changed</em> checkbox.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-options.png" alt="Smart Bar Options" referrerpolicy="no-referrer"></p><p><em>Smart Bar</em> automatically disappears when you move your mouse cursor away from it, or execute a certain commands on the <em>Smart Bar</em>, or click somewhere else in the code editor window, emptying the selection.</p><p>To make the <em>Smart Bar</em> reappear, you can tap the <code>Shift</code> key on your keyboard twice within a second. This behavior can also be suppressed by unchecking the <strong>Show/hide Smart Bar with Shift key</strong> checkbox.</p><h3><a id="user-content-smart-bar-in-other-windows" class="anchor" href="https://gitee.com/wmjordan/Codist#smart-bar-in-other-windows"></a>Smart Bar in Other Windows</h3><p><em>Smart Bar</em> also works on <em>Output</em>, <em>C# Interactive</em>, <em>Immediate (Debug)</em>, <em>Find Results</em> and some other text selectable window panes. If you select a path within those windows, extra commands will pop up allowing you to open it directly or locate it in <em>Windows Explorer</em>.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/smart-bar-file-operations.png" alt="Smart Bar File Operations" referrerpolicy="no-referrer"></p><h2><a id="user-content-scrollbar-marker" class="anchor" href="https://gitee.com/wmjordan/Codist#scrollbar-marker"></a>Scrollbar Marker</h2><p><em>Scrollbar Marker</em> draws extra glyphs and shapes on the vertical scrollbar for the following syntax elements:</p><ul><li><strong>Line numbers</strong> (marked with gray dashed lines and numbers, from version 7.4 on, total line count is displayed at the bottom of the scroll bar)</li><li>Selection range (marked with semi-transparent color blocks over the bar)</li><li>Special comments tagged by comment tagger (marked with small squares)</li><li>C# <code>class</code>/<code>struct</code>/<code>interface</code>/<code>enum</code><strong>declarations</strong> (marked with lines indicating their ranges and a square, and their names indicating their declaration locations)</li><li>C# compiler directives, e.g. <code>#if</code>, <code>#else</code>, <code>#region</code>, <code>#pragma</code>, etc. (marked with a gray spot)</li><li>C# symbol match marker (matches symbol under the caret, marked with an aqua square)</li></ul><p>Please see the first screenshot of this article. The markers can be toggled via the options page.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/scrollbar-marker-options.png" alt="Scrollbar Marker Options" referrerpolicy="no-referrer"></p><h2><a id="user-content-auto-changing-version-numbers" class="anchor" href="https://gitee.com/wmjordan/Codist#auto-changing-version-numbers"></a>Auto Changing Version Numbers</h2><p>Codist can automatically change version numbers for output assemblies before build.</p><p>To activate the behavior, right click the project in the Solution Explorer and select the <em>Auto Build Version Numbers...</em> command.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/auto-version.png" alt="Auto Build Version" referrerpolicy="no-referrer"></p><p>On the left side of the dialog, build configurations are listed. "&lt;Any&gt;" configuration applies to all build configuration scenarios. Others applies to the corresponding scenarios respectively.</p><p>On the right side of the dialog, current version numbers are listed. And four drop-down list controls specify the behavior how version number parts are changed.</p><p>Once you change the drop-down list control to a value rather than "Unchanged", the new version number will be displayed next to the current version number as a preview how it will be changed before next build.</p><p>Press the "Save" button to save the settings and Codist will change build numbers for you before future builds.</p><p><strong>Note</strong>: The build settings are saved in the <em>obj</em> folder where the project file locates.</p><h2><a id="user-content-display-enhancements" class="anchor" href="https://gitee.com/wmjordan/Codist#display-enhancements"></a>Display Enhancements</h2><p>In the <em>Display</em> tab of the <em>General</em> options page, several display enhancement options are offered.</p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/display-options.png" title="" alt="General Options Display" width="783" referrerpolicy="no-referrer"><p>Within the <em>Extra line margins</em> group box, you can adjust margins between lines to make code lines more readable.</p><p>Programmers who do not like <em>ClearType</em> rendering, which made text blurry and colorful, may want to try <em>Force Grayscale Text Rendering</em> options.</p><p>From version 6.6 on, resource monitors can be used to monitorCPU, disk and memory usage via the status bar on Visual Studio. Checking the <em>Monitor CPU</em>, <em>Monitor disk</em> or <em>Monitor memory</em> check box enables the corresponding monitors.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/resource-monitors.png" alt="Resource Monitors" referrerpolicy="no-referrer"></p><p>It is possible to use Compact menu like <em>Visual Studio 2019</em> in <em>Visual Studio 2017</em>. Simply checking the <em>Move main menu to title bar</em> option will do.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/compact-menu.png" alt="Compact Menu" referrerpolicy="no-referrer"></p><p>By checking the check boxes started with "Hide...", it is possible to hide some elements from the user interface of Visual Studio from options under the <em>Layout Override</em> section.</p><h2><a id="user-content-jump-list-shortcuts" class="anchor" href="https://gitee.com/wmjordan/Codist#jump-list-shortcuts"></a>Jump List Shortcuts</h2><p>Jump List is a menu section that appears when you right click the Visual Studio button on the task bar. It lists your recently opened solutions, projects or documents.</p><p>If you are using Open-Shell or other similar Start Menu applications, Codist can add three shortcuts to the Quick Start list of Visual Studio when you check the <em>Jump List Shortcuts</em> option. Those shortcuts start Visual Studio in a special mode.</p><ol><li><em>Non-scaling mode</em>: disables DPI-awareness of Visual Studio and let you design WinForm applications with 100% scaling.</li><li><em>Safe mode</em>: disables most extensions in Visual Studio. If an extension keeps crashing the development environment, you can use the Safe mode to enter Visual Studio to disable or uninstall it.</li><li><em>Presentation mode</em>: opens a particular instance of Visual Studio which has its own settings and layouts.</li></ol><h2><a id="user-content-auto-pair-punctuations" class="anchor" href="https://gitee.com/wmjordan/Codist#auto-pair-punctuations"></a>Auto Pair Punctuations</h2><p>From version 7.6 on, Codist can automatically "pair" punctuations around selections.</p><p>To make this work, follow the steps below:</p><ol><li>Check the <em>Auto Pair Punctuation</em> option in the option page, which is off by default.</li><li>Select some text in the code editor.</li><li>Type an "opening" punctuation, for instance, <code>(</code>, <code>&lt;</code>, <code>{</code>, <code>[</code>, <code>"</code> or <code>'</code>.</li><li>When this option is turned off, the typed character will replace the selection; when this option is turned on, typed character will be inserted in front of the selection, and their counterpart--that is, <code>)</code>, <code>&gt;</code>, <code>}</code>, <code>]</code>, <code>"</code> or <code>'</code>--will be appended behind the selection. For example, if you select <code>abc</code> in the code, and type <code>"</code>, you will get <code>"abc"</code>; if you select <code>x + y</code> in the code, and type <code>(</code>, you will get <code>(x + y)</code>.</li><li>Once the first character is typed,
a. If you actually want the typed character to replace the selection, press the <em>Delete</em> or <em>Backspace</em> key, the selection and the automatically inserted counterpart will be erased;
b. If more characters are to be inserted after the first character, just keep typing, the not-yet-removed content as well as the punctuation counterpart will be replaced.
c. If the automatically inserted paired punctuation is what you need, that is what you get now.</li><li>When we edit Markdown documents, the <tt>`</tt>, <code>*</code>, <code>_</code> and <code>~</code> are also auto-paired.</li><li>For Chinese users, Chinese full width punctuations are also auto-paired.</li></ol><p>You can always turn off this feature by unchecking the <em>Auto Pair Punctuation</em> option in the option page.</p><h2><a id="user-content-codist-in-your-language" class="anchor" href="https://gitee.com/wmjordan/Codist#codist-in-your-language"></a>Codist in Your Language</h2><p>It is possible to localize <em>Codist</em> to other language. Simplified Chinese (简体中文) and English are provided by default.</p><p>The interface of <em>Codist</em> will change according to the <em>International</em> settings of <em>Visual Studio</em>.</p><h2><a id="user-content-other-features" class="anchor" href="https://gitee.com/wmjordan/Codist#other-features"></a>Other Features</h2><p>From version 7.4 on, extra menu commands to open build output target folder are added to the <em>Build</em> menu.</p><p>It is possible to output a time stamp after each build.</p><p>For VSIX developers, there is also an option to automatically increment version number for your VSIX manifest file.</p><h1><a id="user-content-feature-control" class="anchor" href="https://gitee.com/wmjordan/Codist#feature-control"></a>Feature Control</h1><p>Open the <em>Codist</em> section in the <em>Tools-&gt;Options</em> dialog. In the <em>General</em> section you can toggle features of <em>Codist</em>.</p><p><img src="https://gitee.com/wmjordan/Codist/raw/master/doc/general-options.png" alt="General customization" referrerpolicy="no-referrer"></p><ol><li><p><em>Feature controllers</em> contains check boxes which can be used to enable/disable features of <em>Codist</em>.</p><p>Someone who does not like the syntax highlight or use another syntax highlighter can also turn off the <em>Syntax Highlight</em> feature individually here.</p><p>These <strong>options will take effect on new document windows</strong>. Existing document windows won't be affected.</p></li><li><p>To share or backup your settings of Codist, you can use the <em>Save</em> and <em>Load</em> buttons.</p></li></ol><h1><a id="user-content-acknowledgements" class="anchor" href="https://gitee.com/wmjordan/Codist#acknowledgements"></a>Acknowledgements</h1><p>I have learned a lot from the following extension projects (sorted by the time when I learned from them). Codist would not be what you see today without them.</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmhoumann%2FCommentsPlus">CommentsPlus</a>, <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fomsharp%2FBetterComments">Better comments</a>, <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fjgyo%2Fremarker">Remarker</a>: syntax tagger</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FOceanware%2FFontSizer">Font Sizer</a>: changing font size in syntax styles</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FMicrosoft%2FVS-PPT">Visual Studio Productivity Power Tools</a>: extending code window margin</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Ftunnelvisionlabs%2FInheritanceMargin">Inheritance Margin</a>: extending code window margin</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FGeorgeAlexandria%2FCoCo">CoCo</a>: extensive syntax highlighting</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FKhaosCoders%2FVSCodeBlockEndTag">CodeBlockEndTag</a>: adornments</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fcpmcgrath%2FUntabifyReplacement">UntabifyReplacement</a>: replacing text in code window</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmadskristensen%2FExtensibilityTools">Extensibility Tools</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fcodecadwallader%2Fcodemaid">CodeMaid</a>: how to support multi-language localization</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2F2mas%2FSelectNextOccurrence">Select Next Occurrence</a>: code navigation</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmike-ward%2FVSColorOutput">VSColorOutput</a>: extending output window pane</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FNuGet%2FNuGet.Build.Packaging">NuGet</a>: build events</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FGordianDotNet%2FGoToImplementation">GoToImplementation</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fdotnet%2Froslyn">Roslyn</a>: lots about code analysis</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FVsixCommunity%2FCommunity.VisualStudio.Toolkit">Community.VisualStudio.Toolkit</a>: VS extension points</li><li>ReviewBoard: code.google.com/p/reviewboardvsx</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmadskristensen%2FTweakster">Tweaks</a>: VS tweaks</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmadskristensen%2FVsStatus">VsStatus</a>: hacking the status bar</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FJosefPihrt%2FRoslynator">Roslynator</a>: hundreds of code refactorings and analyzers</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmadskristensen%2FShowTheShortcut">ShowTheShortcut</a>: discovering identifiers of executed commands</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DMadsKristensen.CopyNice">Copy Nice</a>: copying text without indentation</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.codeproject.com%2FArticles%2F131708%2FWPF-Color-Picker-Construction-Kit">WPF Color Picker Construction Kit</a>: color picker with spectrum</li></ul><p>And thank you, every donators, beta testers, feedback providers to this project.</p><h1><a id="user-content-license" class="anchor" href="https://gitee.com/wmjordan/Codist#license"></a>License</h1><p><em>Codist</em> comes from the open source community and it goes back to the community.</p><p><em>Codist</em> is <strong>free</strong> software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p><p>You should have received a copy of the GNU General Public License along with this program. If not, see "<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.gnu.org%2Flicenses">https://www.gnu.org/licenses</a>".</p><h1><a id="user-content-bugs-and-suggestions" class="anchor" href="https://gitee.com/wmjordan/Codist#bugs-and-suggestions"></a>Bugs and Suggestions</h1><p>Please <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fwmjordan%2FCodist%2Fissues">post New Issue</a> in the <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fwmjordan%2FCodist">GitHub project</a> if you find any bug or have any suggestion.</p><p>Your vote and feedback on the <a href="https://gitee.com/link?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Dwmj.Codist">Visual Studio Extension Marketplace</a> are also welcomed.</p><h1><a id="user-content-support-codist-by-donation" class="anchor" href="https://gitee.com/wmjordan/Codist#support-codist-by-donation"></a>Support Codist by Donation</h1><p>If you like <em>Codist</em>, consider <a href="https://gitee.com/link?target=https%3A%2F%2Fpaypal.me%2Fwmzuo%2F19.99">buying me a cup of Chinese tea</a>.</p><p>You can donate any amount of money as you like. The recommended amount of donation is <code>$19.99</code>.</p><p>6 donations have been received so far :)</p><p>Well, you have already reached here. Why not give Codist a ★★★★★ rating on the <a href="https://gitee.com/link?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Dwmj.Codist">Visual Studio Extension Marketplace</a>?</p>]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 01:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/wmjordan/Codist</guid>
            <link>https://gitee.com/wmjordan/Codist</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | DDD 落地实践 - 架构师眼中的餐厅]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100019057" data-ratio="0.22676579925650558" src="https://oscimg.oschina.net/oscnet/be541383-3ac2-4c3d-ab96-d48400b38902.gif" data-type="gif" data-w="1076" style="" referrerpolicy="no-referrer"></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">本文以餐厅场景为敍事主线，以领域驱动为核心思想，结合架构设计与功能设计方法论。是从领域分析到落地的全过程案例，内容偏重于落地，因此不乏一些探讨，欢迎指正。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">文章较长、全程干货、耐心读完、必有收获。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">本文不针对餐厅的实现细节，重在探讨设计思想和方法。</span></p><span id="OSC_h1_1"></span><h1 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1、领域设计</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h1><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">让我们抛开技术人员的本能技术视角、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">站在纯业务视角来分析领域问题</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">领域设计的核心是分而治之，<span style="font-size: 15px;color: rgb(0, 82, 255);">目的是<span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">实现业务领域的自治性</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">就像你平时不会将枕头和被子放在厨房或衞生间一样，你的床上不会放着大米白面，否则你想睡觉是一件很复杂的事情，软件系统也是如此，这就是我们要解决的问题。</span><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><span id="OSC_h2_2"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1.1 宏观流程</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">假如我要设计一个餐厅，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">由于分而治之的需要，我会首先从宏观流程去分析</span>，</span>可以帮我们迅速找到重要的区域。</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024662" data-ratio="0.1361111111111111" src="https://oscimg.oschina.net/oscnet/1995e109-8620-4e1e-841d-607a4bc8a114.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">因此会得到几个明确的行为区域，我将餐厅划分为「菜品域」，「订单域」，「厨房域」，「用餐域」，这是业务级别的领域划分，后续应该针对每个区域单独分析。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物是：宏观流程和参与角色</span></p><span id="OSC_h2_3"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1.2 统一语言</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">语言贯穿于整个开发过程，从需求分析到设计、从设计到编码，因此好的语言非常重要，好的语言<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">体现了清晰的业务概念</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">在这个阶段，我们需要通过梳理，找到业务中都有哪些实体与行为，对其做一些归纳。我们的核心问题是：<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">「谁」通过什么「行为」影响了「谁」</span>，</span>其中的三个要素分别是：角色、行为、实体。我的建议是先<span style="font-size: 15px;color: rgb(0, 82, 255);">找到 「角色」、「实体」、「行为」，并对其归类，</span>我常常关注角色以及具体身份、实体以及实体实例，功能以及包含的重要步骤。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">角色：是施事主语、是名词，是主动发起行为的一类实体。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">行为：是动词、是做了什么事情，是行为本身。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">实体：是名词，是除「角色」之外的其他实体。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">推荐使用脑图画出来，我认为归纳后的脑图有助于我们识别根本要素，有利于抽象。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物是：名词、概念定义、相关脑图。</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024663" data-ratio="0.8055555555555556" src="https://oscimg.oschina.net/oscnet/3a551592-572d-4f16-bb95-006b67d18d1d.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><span id="OSC_h2_4"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1.3 用例分析</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">在这一步、我们使用相对宏观的分析，不需要进入用例的细节分析，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">掌握角色与行为之间的关系，理清谁在做什么，角色的职责差异是什么</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物：用例图</span><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">以做菜为例，如图</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024666" data-ratio="0.7333333333333333" src="https://oscimg.oschina.net/oscnet/719968e8-a2f2-4e2f-94ab-5d80df8c3497.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"></p><span id="OSC_h2_5"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1.4 领域划分</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我们在分析宏观流程时，划分了几个行为区域，但那是业务级别的。在那基础之上，我们需要拉进某个区域的视角，再结合之前的用例分析，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">按照「功能相关性」、「角色相关性」进一步划分领域</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">功能相关性：是<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">用例与领域之间的关系</span>，</span>任何业务的领域都是由一套用例组成的，所以领域划分以功能相关性为主，例如与做菜相关的用例都应该归属于厨房，所以我们确认了厨房域，确认了厨房域包含的用例，这是很自然的事。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">角色相关性：其次是角色，常用于划分子域，某个区域涉及多个角色参与，可以按照角色的分工，拆分为多个子域，从而满足不同角色的个性化需要。例如厨房的采购人员负责买菜、刀工负责切菜、大厨负责烹饪。我们就会考虑将厨房划分为「采购域」、「加工域」、「烹饪域」。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">通常来说，<span style="font-size: 15px;color: rgb(0, 82, 255);">子域不具备独立的问题空间，不会作为独立的领域存在。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物：领域、子域</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">以厨房域为例，如图</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024665" data-ratio="0.6148148148148148" src="https://oscimg.oschina.net/oscnet/47930a5b-4f34-4ab2-9f17-d9d4163e22b7.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><span id="OSC_h2_6"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1.5 领域建模</span></strong></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">这是大家比较熟知的阶段，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">重点分析实体与领域之间关系（领域聚合），实体与实体的关系（OO 聚合）</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">领域模型是实现功能的基石、需要有对功能的本质理解，才能找到最核心的实体，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">实体之间的 OO 聚合关系决定了功能的扩展性</span>，</span>OO 聚合是最重要的核心点。</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024664" data-ratio="0.7805555555555556" src="https://oscimg.oschina.net/oscnet/e4372046-ee12-481f-a38b-f2d3b8549773.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">组合、聚合</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">聚合（aggregation）：聚合关系是一种弱的关系，整体和部分可以相互独立。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">组合（composition）：组合关系是一种强的整体和部分的关系，整体和部分具有相同的生命周期。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">可以使用如下案例，既能表达领域聚合，又能表达 OO 聚合的关系。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">﻿</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024669" data-ratio="0.8277511961722488" src="https://oscimg.oschina.net/oscnet/0d0f7028-5be7-4b87-a5c8-62f466df112a.png" data-type="png" data-w="836" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物：聚合、实体、值对象、实体的属性</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">（领域服务和事件在后续的功能设计中提供）</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><br></p><span id="OSC_h2_7"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">1.6 领域上下游</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">领域上下游关系，不是领域的依赖关系，依赖关系指的是能力的依赖，是共用了某些能力，依赖关系是固定的。领域上下游关系，也不是调用关系，调用关系是与用例相关的，并非描述领域处境的。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">领域上下游关系指的是影响力的关系，</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">上游影响下游，影响力分为「逻辑影响」和「数据影响」，一般说来我们更应该关注「数据影响」，所以<span style="font-size: 15px;color: rgb(0, 82, 255);">领域上下游关系是一种数据流向的限定，是业务发生的顺序限定，</span>用于规定该领域所使用的数据，是下游领域依赖上游领域「准备就绪」的体现。合理的上下游限定，有助于减少领域之间的不必要依赖，有利于数据的复用并减少重复计算。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">领域上下游是与场景相关的，</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">并不是一成不变的，不同的场景存在不同的上下游，各场景应该独立说明。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物：各场景的上下游说明</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">例：在【菜品管理】场景下</span></strong></p><p><img class="rich_pages wxw-img" data-imgfileid="100024670" data-ratio="0.15065502183406113" src="https://oscimg.oschina.net/oscnet/dae06ae3-c3f4-4895-af71-27f6442af29d.png" data-type="png" data-w="916" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">如果厨房的某些食材不足了，或者某个厨师休假了，就会影响到菜品的展示，从而影响到客户的订单。</span><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">例：在【客户消费】场景下</span></strong></p><p><img class="rich_pages wxw-img" data-imgfileid="100024668" data-ratio="0.29259259259259257" src="https://oscimg.oschina.net/oscnet/a4ffc3a9-e55e-4ee4-811a-5e6adfe115c2.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">客户的订单、影响厨房生产的菜，从而影响刀工的行为，也影响到了采购。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">请对比下面两个图，用于理解领域的上下游</span></strong></p><p><img class="rich_pages wxw-img" data-imgfileid="100024671" data-ratio="0.37222222222222223" src="https://oscimg.oschina.net/oscnet/e785c504-4faf-4ccb-b87e-b7151c9bbcb0.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"></p><p><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">﻿﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">实际上，厨师不应该依赖采购人员的采购功能，也不依赖刀工的切菜功能，他只是依赖「初加工食材」而已，而「初加工食材」就是被处理好的数据，厨师在做饭时，「初加工食材」就已经被处理好了，上面的图例只是为了说明一个关于领域上下游的问题，这是业务<strong><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">发生顺序</span></strong>以及<strong><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">数据来源</span></strong>的问题。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我们常常使用领域事件串联业务流程，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">在使用领域事件时，不止要关注点对点的解耦，更应该使业务流程符合领域上下游限定</span>，</span>让各个领域独立运行，减少领域之间的功能依赖，降低领域之间的耦合，减少业务变化带来的影响。</span></p><span id="OSC_h1_8"></span><h1 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">2、架构设计</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h1><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">架构设计是为了<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">解决软件系统复杂度带来的问题，找到系统中的元素并搞清楚他们之间关系</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">架构的目标是用于管理复杂性、易变性和不确定性，以确保在长期的系统演化过程中，一部分架构的变化不会对其它部分产生不必要的负面影响。这样做可以确保业务和研发效率的敏捷，让应用的易变部分能够频繁地变化，对应用的其它部分的影响尽可能地小。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">架构设计三原则：合适原则、简单原则、演化原则</span><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><span id="OSC_h2_9"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">2.1 分层架构</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我们需要<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">按照，接口层、领域层（领域用例层、领域模型层）</span>、<span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">依赖层、基础层，构建架构模型</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">接口层：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">为外部提供服务的入口，是适配层的北向网关。不实现任何业务逻辑，也不处理事务，是跨领域的，是流程编排层，是门面服务。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">领域用例层：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">是领域服务层，是领域用例的实现层、隶属于某个领域、是业务逻辑层，是事务层，业务逻辑应该在这层完整体现，不要分散到其他层级。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">领域模型层：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">是领域模型（实体、值对象、聚合）的所在位置，专注于领域模型自身的能力，不包含业务功能，可以处理事务，是原子化的能力，是领域对象的自我实现<em style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">。</em></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">依赖层：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">是连接外部服务的出口，是适配层的南向网关。包括仓储，端点、RPC 等，主要作用是领域和外部解耦，用于保持领域的独立性，是跨领域的。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">基础层：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">与业务无关的，与领域无关的，通用的技术能力，技术组件等。</span></p><span id="OSC_h2_10"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">2.2 架构映射</span></strong></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">架构的视角，从大到小依次是：系统-&gt;应用（微服务）-&gt;模块（包）-&gt;子模块，这样的从大到小的层级。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">业务领域映射：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我们将划分好的领域，按照对应的视角映射为对应的元素，领域模型映射到架构模型时，<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">应该是视角对等的</span>，</span>如果餐厅是系统、那么厨房就是应用，如果餐厅是应用、那么厨房就是模块。<span style="font-size: 15px;color: rgb(0, 82, 255);">也应该层级匹配的，</span>将用例的实现映射到用例层，将领域模型的实现映射到领域模型层。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">技术和抽象问题：</span></strong><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">有时候、业务领域分析不能体现那些共性的技术问题，所以需要适当结合技术视角，可能需要对领域模型微调。同时、我们需要找到共同需要的基础能力，例如「水」、「电」、「煤气」等等，将这些作为额外的考虑因素，要做到<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">业务问题与技术问题解耦，不要将技术问题和业务逻辑揉成一团</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">领域设计，类似餐厅设计师，他设计餐厅有几个区域，区域的用途是什么。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">架构设计，类似建筑设计师，他设计如何走水电煤气、如何施工等。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">产出物：分层架构图</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">以厨房为视角，其架构如下</span></strong></p><p><img class="rich_pages wxw-img" data-imgfileid="100024667" data-ratio="0.568039950062422" src="https://oscimg.oschina.net/oscnet/27a6f4f5-c098-49fd-b107-29a2889433ed.png" data-type="png" data-w="801" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">以餐厅为视角，其架构如下</span></strong></p><p><img class="rich_pages wxw-img" data-imgfileid="100024672" data-ratio="0.5816203143893591" src="https://oscimg.oschina.net/oscnet/57e1f389-d39a-4c65-a624-60ea4946afc6.png" data-type="png" data-w="827" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">分层架构图，体现逻辑上的层级分布，而不是代表组件的具体含义，组件是应用还是模块、需要结合实际情况而定。</span></p><span id="OSC_h2_11"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">2.3 必要的约束</span></strong></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">1、分层架构越往下层就越是稳定的：下层是被上层依赖的，下层不可以反向依赖上层（扩展点除外）。因为分层架构的核心原则是将容易变化的逻辑上浮，将共性的、原子化的、通用的逻辑下沉，被依赖的下层应该是稳定的，这要求上层承接更多业务变化。下层离开上层应该是可以独立存在的，例如在接口层定义的 DTO 不可以在下层被使用，但领域层定义的实体可以被上层使用。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">2、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">在使用充血模型时，应该符合面向对象编程原则</span>：</span>不要随意的将一些能力都充到领域实体模型中。以「菜」为例，重量和规格是「菜」的自身的属性，激发味蕾是「菜」的能力，「菜」可以维护自身的持久化状态。但是、请注意、「菜」不可以「炒菜」，因为「炒菜」的时候，「菜」还没有出现呢，「菜」不是自己的上帝，「菜」需要被做出来，所以「菜」被做出来之前是没有「菜」的，这是个时间上的概念，不要错把「炒菜」的能力放在「菜」的身上。「炒菜」用到的「水+电+气+食材+调料+厨具」不应该是「菜」的属性范围，这些元素都在「厨房」的范围中，<span style="font-size: 15px;color: rgb(0, 82, 255);">不要让领域的模型包含不属于自身的元素，领域的实体模型只是领域的一部分，只用于实现通用的模型能力。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">3、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">接口层和依赖层是与领域无关的</span>：</span>他们是与技术相关的层级，不属于任何领域，这两层不能包含业务逻辑。有时候我们可以把接口层拆为两层（接口层+应用层），也可以把依赖层拆分为两个（模型依赖、服务依赖）。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">4、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">领域层是与环境无关的</span>：</span>无论某个领域是应用还是模块，都应该具备独立的用例层和独立的模型层，即使多个领域在同一个应用当中，也要按照他们是分别独立去看待，无论某个领域是应用还是模块，<span style="font-size: 15px;color: rgb(0, 82, 255);">领域对外部的交互，不可以绕过依赖层和接口层。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">5、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">领域应该是最小完备的</span>：</span>把一个领域拆分为子域、子子域、子子子...... 无限拆分，拆分到一定程度之后，某个子域就不完整了，<span style="font-size: 15px;color: rgb(0, 82, 255);">不完整的子域是不可以独立存在的。</span>拆分不不够或者过度拆分，都是不符合低耦合高内聚原则的。<span style="font-size: 15px;color: rgb(0, 82, 255);">当一个领域的内部子域不具备独立性时，他们之间不必严格解耦，不需要通过依赖层访问本领域的其他子域，他们之间可以直接调用。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">6、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">领域服务层就是领域用例层</span>：</span>他们俩是同一回事儿，都是用于实现领域内的用例的。<span style="font-size: 15px;color: rgb(0, 82, 255);">不要将领域服务与领域用例视为两个独立的层，也不要将领域服务与领域模型视为同一层，</span>否则会导致逻辑的分散（一部分在领域服务层、一部分在领域模型层、还有一部分可能在用例层），也会导致每个层的职责不明确，容易搞乱。如果将业务逻辑写在领域模型中，会导致业务逻辑进一步下沉，业务逻辑的不确定性太大，是不适合下沉的，是违反分层架构原则的。<span style="font-size: 15px;color: rgb(0, 82, 255);">领域模型对应的是实体、领域服务对应的是用例。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">7、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">领域用例层只能承接符合自身领域的用例</span>：</span>我们划分出领域的目的，就是为了区分每个领域的职责所在，因此他们必须严格按照职责办事，我们在之前已明确了用例和领域之间的关系，需要严格遵守。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">8、<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">领域模型层遵循最小依赖原则</span>：</span>只可以依赖必要的资源，必要资源指的是领域模型实现自身能力需要的资源，不包括实现业务逻辑包含的资源。例如领域模型需要依赖 DB 完成持久化，可以依赖数据访问资源，但不应该依赖其他领域资源、不可以依赖 RPC 资源等。</span></p><span id="OSC_h2_12"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">2.4 微服务划分</span></strong></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">服务划分以领域划分为参考，主要看我们要拆分到什么粒度，这 <span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">应该符合低耦合高内聚原则，不破坏领域实体的聚合关系</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物：微服务</span><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">例如餐厅：是有必要拆分的，餐厅的「菜品域」，「订单域」，「厨房域」有独立的问题空间。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">例如厨房：是没有必要拆分的，厨师与刀工的耦合非常高，他们都在做饭，分开之后是不完整的，分开就是没有必要的。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">所以餐厅被拆分为：厨房（Kitchen）、菜品（Category）、订单（Order）三个微服务。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">基于此、我们单独拿出<strong><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">餐厅门面服务</span></strong>作为接口层应用，再单独拿出<strong><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">餐厅基础服务</span></strong>作为水电煤气的应用。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">一般情况下，依赖层不会作为单独的服务提供，会被以组件的形式嵌入到其他服务中。</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024673" data-ratio="0.4546296296296296" src="https://oscimg.oschina.net/oscnet/a75f1afb-0c1f-4d71-8cb5-b6e8c1b0bfec.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"></p><span id="OSC_h1_13"></span><h1 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3、功能设计（用例实现）</span></strong></h1><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">如果说领域设计是餐厅的设计师、架构设计是餐厅的建筑师、那么功能设计就是餐厅的厨师或服务员。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">任何设计都要落地到功能设计，如果厨师不守规则，偏偏要去洗手间洗菜，最后的结果依然是一团乱，最终会导致设计无法落地。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">功能设计是实现 「面向扩展开放、面向修改关闭」 的途径，是指导研发落地必备环节。</span></p><span id="OSC_h2_14"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.1 功能的概念</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">功能迭代时，功能会发生一些变化，所以他的含义是可能变化的，所以我们需要再次审视功能的概念，及时加以调整。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">例如、我们实现了一个「做蛋炒饭」的功能，后来又实现了一个「做辣椒炒蛋」的功能，那么我们应该将功能升级为「炒菜」，甚至是「制作菜品」等。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">明确功能的概念，是功能设计的前提。</span><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物：更新语言库，更新脑图</span></p><span id="OSC_h2_15"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.2 用例的位置</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我们在领域分析章节，已明确了<span style="font-size: 15px;color: rgb(0, 82, 255);"><span data-slate-leaf="true" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">用例与角色的关系，用例与领域的关系</span>。</span></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">然而一个新功能的加入，我们仍然要再次评估，以确保他处于正确的位置。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物：更新用例图</span><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><span id="OSC_h2_16"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.3 事件风暴</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">我们需要深入功能的细节，首推的方法是事件风暴，适用于解构复杂功能。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">事件风暴的作用并不限于功能分析，只是我觉得很适用于功能分析，事件风暴的一张图包含很多内容，正好是功能设计所需要的。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">将功能拆分为多个子功能（步骤）。</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">（在后续使用）</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">确认参与该步骤的角色和领域。</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">（在后续的 3.6 章节落地）</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">确认步骤的串联流程和领域事件。</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">（在后续的 3.6 章节落地）</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">确认参与该步骤的领域实体。</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">（在后续的 3.7 章节落地）</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物：事件风暴模型</span></p><span id="OSC_h2_17"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.4 用例分析</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">我们暂且收回思路，首先要关注共性和差异问题，以确保功能的扩展性。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">确认用例的泛化+差异点，实现功能的扩展。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">寻找共同包含的步骤，实现逻辑的复用。</span><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物：用例分析图</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">例：制作菜品（做大拌菜、做铁锅炖、做炒鸡蛋、做蒸米饭、做炒米饭）</span></strong></p><p><img class="rich_pages wxw-img" data-imgfileid="100024674" data-ratio="0.590443686006826" src="https://oscimg.oschina.net/oscnet/3d972a5e-7349-4ac8-b30a-4da19b1aa1d5.png" data-type="png" data-w="879" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"></p><p><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">﻿﻿</span><strong style="font-size: 16px;letter-spacing: 0.034em;"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.5 用例实现类（领域服务类）结构图</span></strong></p><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">专注于用例层的类设计，实现「面相修改关闭，面相扩展开放」。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">用例的类结构图是用例分析图的一种映射。</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">出物：用例层的类结构图</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024676" data-ratio="0.7601851851851852" src="https://oscimg.oschina.net/oscnet/efec1931-71d9-4241-9f9b-dfc1c268782f.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><span id="OSC_h2_18"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.6 用例流程图</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">我们接回思路，更进一步，将事件风暴模型落实到代码层面。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我们<span style="font-size: 15px;color: rgb(0, 82, 255);">将步骤分配到实现类中、步骤就是该类的一个方法，</span>进一步明确由哪个类和方法来实现该步骤，从而就规定了步骤所在的领域。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我们<span style="font-size: 15px;color: rgb(0, 82, 255);">将步骤和领域事件串联起来，规定了业务实现流程。</span>推荐使用泳道图表达上述内容。泳道的纵向组件是用例的实现类。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);color: rgb(0, 82, 255);">这是真实业务流程的映射。</span><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物：用例流程图</span><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">以炒鸡蛋为例，其用例流程图如下</span></strong><span style="font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024675" data-ratio="0.5287037037037037" src="https://oscimg.oschina.net/oscnet/0fdde59e-7025-468d-89b7-746265e0220c.png" data-type="png" data-w="1080" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><span id="OSC_h2_19"></span><h2 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">3.7 活动图（时序图）</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h2><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="font-size: 15px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">我们进一步将事件风暴模型落实到代码层面，我们<span style="font-size: 15px;color: rgb(0, 82, 255);">使用时序图，体现依赖和调用关系，规定了步骤与领域实体模型的关系，</span>进一步说明用例是如何实现的。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">这时候，为了简便、我们可以收起领域服务类（用例层）的泳道。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(217, 33, 66);">产出物：时序图、活动图</span></p><p><img class="rich_pages wxw-img" data-imgfileid="100024677" data-ratio="0.7818361303060217" src="https://oscimg.oschina.net/oscnet/6cbb7948-b8d2-4075-aeab-c0939bed59da.png" data-type="png" data-w="1013" style="border-width: 0px;border-style: none;border-color: rgb(235, 238, 245);" referrerpolicy="no-referrer"><span style="font-size: 15px;letter-spacing: 0.034em;">﻿</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"><em style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);">试想一下、假如把业务逻辑放在领域模型当中（例如聚合），如何实现「面相扩展开放、面相修改关闭」呢？</em></span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><span id="OSC_h1_20"></span><h1 data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">4、编码实现</span></strong><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></h1><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">编码实现...... &nbsp;我决定还是...... &nbsp;偷个懒吧...... &nbsp;哈哈哈。</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;">但是我们回顾一下之前的内容，是否足够了？不同的研发人员依照设计去编码，是否会写出不一样的代码？</span></p><p data-slate-node="element" data-slate-inline="false" style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);"><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;color: rgb(0, 82, 255);">最后、我们的目标是「解决软件复杂度带来的问题」，而实现这个目标的途径是「设计指导研发落地」。</span><span style="border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);font-size: 15px;"></span></p><p><br></p><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - 京东云开发者（JDT_Developers）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 01:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10675650</guid>
            <link>https://my.oschina.net/u/4090830/blog/10675650</link>
            <author>
                <![CDATA[京东云开发者]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[探索 Zadig 自测模式，一套环境多人协同，释开发者创造力！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><div><div><div><div><div><div><p style="margin-left:0; margin-right:0"><img alt="" src="https://oscimg.oschina.net/oscnet/up-0d0eca0dd098c1cd307613306af4a974609.png" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">在日常开发中，研发工程师经常遇到环境不足、环境管理混乱以及互相抢占环境的问题，这种情况不仅使得研发工程在等待环境准备和切换中花费大量宝贵的工作时间，无法充分发挥创造性，还直接影响了项目的进度和质量。对于业务架构简单、服务数量较少的情况，往往会选择扩展出一套完整的新环境来满足不同研发同时自测联调的诉求，减少不必要的等待时间。而面对复杂的业务场景，一套测试环境中可能包含成千上百个服务，额外搭建这样一套完整的环境成本极高，甚至由于一些服务的基础架构的原因，复制多套环境几乎不可能。</p><div><img height="940" src="https://pic1.zhimg.com/80/v2-aaa680bac5f2ab99ffc7ac984730c2d4_1440w.webp" width="976" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">为了应对上述痛点问题，Zadig 提出了一种低成本搭建子环境的解决方案。在 Zadig 自测模式的子环境中，只需部署少量服务，并与基准服务进行交互，实现了更为高效的开发和联调流程。</p><p style="margin-left:0; margin-right:0">在本文中，我们将深入探讨 Zadig 自测模式的基本原理、应用场景、管理员操作细节和工程师在日常使用中的实际操作等。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_1"></span><h2><strong>基本原理</strong></h2><div><img src="https://pic4.zhimg.com/80/v2-3569090a3b2610750992ee5a07320383_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">自测模式是 Zadig 为降低环境管理复杂度和部署成本而推出的一种面向开发者的功能模块。当开启了环境的自测模式后，该环境则成为基准环境，该环境拥有完整的服务调用链。没有灰度标的请求会在基准环境中进行调用，调用链路为<em><strong><span>&nbsp;</span><span style="background-color:#dddddd">A -&gt; B -&gt; C</span></strong></em>。</p><p style="margin-left:0; margin-right:0">当开发者需要进行开发、联调时，比如涉及到到 A 和 C 两个服务的变更，可以基于基准环境新建 dev1 子环境，该子环境中仅部署变更后的 A 和 C 服务，即 A' 和 C'。联调时请求加上灰度标，如在 http header 中设定<strong><em><span>&nbsp;</span><span style="background-color:#dddddd">x-env=dev1&nbsp;</span></em></strong>的灰度标，此时请求会按照<span>&nbsp;</span><strong><em><span style="background-color:#dddddd">A' -&gt; B -&gt; C'</span></em></strong><span style="background-color:#dddddd">&nbsp;</span>进行。</p><p style="margin-left:0; margin-right:0">同理，当开发、联调时仅涉及到 B 和 C 两个服务的变更时，可以基于基准环境新建 dev2 子环境，该子环境仅部署变更后的 B 和 C 服务，即 B'' 和 C''。联调时加上灰度标<span style="background-color:#dddddd">&nbsp;</span><em><strong><span style="background-color:#dddddd">x-env=dev2</span></strong></em>，这样请求按照<span>&nbsp;</span><em><strong><span style="background-color:#dddddd">A -&gt; B'' -&gt; C''</span></strong></em><span style="background-color:#dddddd">&nbsp;</span>进行。</p><span id="OSC_h2_2"></span><h2>&nbsp;</h2><span id="OSC_h2_3"></span><h2><strong>应用场景</strong></h2><p style="margin-left:0; margin-right:0">Zadig 的自测模式支持用较低成本快速拉起包括部分服务的子环境，在子环境中开发、变更目标服务，并和包括全量服务的基准环境交互来实现自测联调，企业可使用自测模式解决的问题包括但不限于：</p><p style="margin-left:0; margin-right:0">1. 开发频率快，业务验证需求旺盛，亟需小快跑的方式迭代业务，但缺乏相关工程底座建设。</p><p style="margin-left:0; margin-right:0">2. 微服务的数量大，业务复杂度高，导致建设一套完整的环境成本高，代价大。</p><p style="margin-left:0; margin-right:0">3. 部分微服务因基础技术架构等原因，无法完整地复制出多套完整环境，导致多个团队绑定在一个环境中，环境稳定性难保障。</p><p style="margin-left:0; margin-right:0">4. ......</p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_4"></span><h2><strong>如何使用</strong></h2><p style="margin-left:0; margin-right:0">下面以<em><strong><span>&nbsp;</span><span style="color:#3498db"><span style="background-color:#dddddd">simple-service</span></span><span>&nbsp;</span></strong></em>为例来说明如何配置和使用 Zadig 自测模式。项目背景以及自测联调需求说明如下：</p><p style="margin-left:0; margin-right:0">1. 项目中共包括 3 个微服务 a、b、c，服务调用链路：a -&gt; b -&gt; c</p><p style="margin-left:0; margin-right:0">2.<em>dev<span>&nbsp;</span></em>环境为日常完整稳定的测试环境，包括全部微服务 a、b、c</p><p style="margin-left:0; margin-right:0">3. 日常会对 a 服务进行高频改动，希望能对 a 服务进行充分自测，确保其变更可交付</p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h3_5"></span><h3><strong>管理员：配置自测模式</strong></h3><p style="margin-left:0; margin-right:0"><strong>步骤 1：开启自测模式</strong></p><p style="margin-left:0; margin-right:0">访问<span style="background-color:#dddddd">&nbsp;</span><em><strong><span style="background-color:#dddddd">dev</span></strong></em><span style="background-color:#dddddd">&nbsp;</span>环境 &gt; 更多 &gt; 点击开启自测模式</p><div><img src="https://pic4.zhimg.com/80/v2-7b890f74b62982518abdaf65c03685a7_1440w.webp" width="690" referrerpolicy="no-referrer"></div><div><img src="https://pic2.zhimg.com/80/v2-86baeb0dc983dc5f93a90ed2feba0b81_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">这时会对自测模式的依赖条件做检查：</p><p style="margin-left:0; margin-right:0">1. 业务架构实现全链路数据透传能力或者使用 Tracing 组件。系统无法自动检查，需要管理员自行确保，此处支持较为广泛应用的 SkyWalking、Zipkin、Jaeger 等。</p><p style="margin-left:0; margin-right:0">2. 系统会对 Istio 是否安装做自动检查，如果没有请在环境所在集群进行安装</p><p style="margin-left:0; margin-right:0">3. 服务调用链自动检查，主要依据是有 K8s Service 类型的资源和服务 a、b、c 对应</p><p style="margin-left:0; margin-right:0">当开启自测模式后，<em><span style="background-color:#dddddd">dev&nbsp;</span></em>环境即成为基准环境。</p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><strong>步骤 2：配置入口服务</strong></p><p style="margin-left:0; margin-right:0">若需要在子环境中添加并联调入口服务，即本项目中<em><span>&nbsp;</span><strong><span style="background-color:#dddddd">a&nbsp;</span></strong></em>服务，则需要在基准环境中，配置入口服务的 Istio 网关。并将配置的访问地址解析到集群 istio-ingressgateway service 的外网访问地址上，如下图所示。</p><div><img src="https://pic2.zhimg.com/80/v2-7d041ec097ffe3fe94015bbe8f537165_1440w.webp" width="690" referrerpolicy="no-referrer"></div><div><img src="https://pic2.zhimg.com/80/v2-14f4bd70d8f00152a5eb358b250679c9_1440w.webp" width="690" referrerpolicy="no-referrer"></div><span id="OSC_h3_6"></span><h3>&nbsp;</h3><span id="OSC_h3_7"></span><h3><strong>工程师：日常自测联调</strong></h3><p style="margin-left:0; margin-right:0"><strong>创建子环境</strong></p><p style="margin-left:0; margin-right:0">在 dev 基准环境中通过点击<span>&nbsp;</span><em><strong><span style="background-color:#dddddd">创建子环境</span></strong></em>，选择 a 服务可创建包含 a 服务的子环境<span>&nbsp;</span><em><strong><span style="background-color:#dddddd">dev-subenv1</span></strong></em>。</p><div><img src="https://pic4.zhimg.com/80/v2-454a167d92a068bc2feea3a3c61556db_1440w.webp" width="690" referrerpolicy="no-referrer"></div><div><img src="https://pic1.zhimg.com/80/v2-e68c0d0aab9efaf0e0a63f250860ada8_1440w.webp" width="690" referrerpolicy="no-referrer"></div><div><img src="https://pic4.zhimg.com/80/v2-585b3bba48ecaf31b7c53f1454006177_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><strong>请求验证</strong></p><p style="margin-left:0; margin-right:0">当需要请求服务 a 时，在请求头部加入<span>&nbsp;</span><em><strong><span style="background-color:#dddddd">x-env=dev-subenv1</span></strong></em><span style="background-color:#dddddd">&nbsp;</span>即可将请求流量转发到子环境<span>&nbsp;</span><em><strong><span style="background-color:#dddddd">dev-subenv1</span></strong></em><span style="background-color:#dddddd">&nbsp;</span>中，实现子环境和<strong><span>&nbsp;</span></strong><em><span style="background-color:#dddddd">dev</span></em><span>&nbsp;</span>环境的自测联调。测试效果如下所示：</p><p style="margin-left:0; margin-right:0">1. 增加<span>&nbsp;</span><em><strong><span style="background-color:#dddddd">x-env=dev-subenv1</span></strong></em><span style="background-color:#dddddd">&nbsp;</span>请求头访问服务 a，子环境中的服务 a 会接收到请求并给出响应，对于请求链路上的 b 和 c 服务，<em><span style="background-color:#dddddd">dev</span></em><span>&nbsp;</span>环境中的服务会给出正常响应。</p><div><img src="https://pic1.zhimg.com/80/v2-f4d69dfe4cd4ba380ebc2f696852b2b4_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">子环境 dev-subenv1 中&nbsp;<em><strong><span style="background-color:#dddddd">a</span></strong><span style="background-color:#dddddd">&nbsp;</span></em>服务的日志：</p><div><img src="https://pic2.zhimg.com/80/v2-2bbe8c22df5df855985ff74c49a765b9_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">2. 执行不带任何头部信息的请求，直接请求服务 a，<em><strong><span style="background-color:#dddddd">dev</span></strong><span>&nbsp;</span></em>环境中的服务 a、b、c 会处理请求，子环境中无请求流量输入。</p><div><img src="https://pic4.zhimg.com/80/v2-a1d064a8b4dd98a88c0e72ff3a1820f3_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">基准环境 dev 中<em><strong><span>&nbsp;</span>a<span>&nbsp;</span></strong></em>服务的日志：</p><div><img src="https://pic4.zhimg.com/80/v2-e770e666e0996145de47c3e3447f0817_1440w.webp" width="690" referrerpolicy="no-referrer"></div><p style="margin-left:0; margin-right:0">Zadig 的自测模式是为开发者量身定制的解决方案，适用于多人协同开发、业务规模大、服务相互关联、日常变更频繁的场景。传统测试环境所带来的有限资源、高成本、复杂性等问题，在 Zadig 的自测模式下迎刃而解。</p><p style="margin-left:0; margin-right:0">通过低成本搭建子环境、灵活部署少量服务，Zadig 的自测模式使开发者能够在独立的测试环境中进行高效工作，摆脱了对同一测试环境的争夺，提升了开发流程的质量和效率。</p><p style="margin-left:0; margin-right:0">欢迎大家下载试用，体验更高效的开发方式！</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center">&nbsp;</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">立即体验 Zadig V2.0 新架构，开启高效交付之旅！🚀&nbsp;</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><strong><span style="color:#ff2968">Zadig 开放，链接，专业</span></strong></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-16e6b25cd9b3c92bc711c17b21e99e9b040.png" referrerpolicy="no-referrer"></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491363%26idx%3D1%26sn%3Dd6ccb8938f4702f560f28d5b79324cf3%26chksm%3Dcfb45383f8c3da9540c0c3eb1080f729fa2545db2063159b5fb05ddeb818f082e21adb2f9189%26token%3D1376697300%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow">阅读原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank" rel="nofollow">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig" rel="nofollow">Zadig 在 Gitee</a></p><p style="color:#191b1f; margin-left:0; margin-right:0; text-align:start"><strong>推荐阅读 :&nbsp;</strong><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491441%26idx%3D1%26sn%3D3eb5d7125489434ff567d60ae48ef5e5%26chksm%3Dcfb453d1f8c3dac7a9ba2de20d6d8d37f94ea5a0812030843cde5d9512bd93deb208073ff1bf%26scene%3D21%23wechat_redirect" target="_blank" rel="nofollow">只有大厂才可以有 DevOps 平台？</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank" rel="nofollow">Zadig vs. Jenkins 详细比对：时代的选择与开发者之选</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491437%26idx%3D1%26sn%3D4bfa94daef9e61087984cb2ab9e9a6d9%26chksm%3Dcfb453cdf8c3dadbaabff32876f84646767db645228c14c84279b706139db4de6081ed4376e6%26scene%3D21%23wechat_redirect" target="_blank" rel="nofollow">基于 Istio + Zadig，零负担实现云原生全链路灰度发布</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491474%26idx%3D1%26sn%3D5f7c40d430e16fcbfa69104c4a46a797%26chksm%3Dcfb45332f8c3da247c792998c84b0885a3b40a534cfd2011e0e7ea30a51cadeeabb37fdba14d%26scene%3D21%23wechat_redirect" target="_blank" rel="nofollow">阿里云 MSE + Zadig，面向开发者的全链路灰度发布解决方案</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247491336%26idx%3D1%26sn%3D805f7d2c44c96cab529ffef120d84ca0%26chksm%3Dcfb453a8f8c3dabe83163a873135f2a72cdddcb9faeecefe5e40f20a358681304484c56cce51%26scene%3D21%23wechat_redirect" target="_blank" rel="nofollow">ZADIG 专家版倾情上线：一键高效发布，119 元/人月起，社区老友享年终福利！</a></p></div></div></div></div></div></div></div><div>
  &nbsp; 
</div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 10 Jan 2024 01:46:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/koderover/blog/10676758</guid>
            <link>https://my.oschina.net/koderover/blog/10676758</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[2023 年中国软件名城评估结果公布：深圳、杭州、北京获得最高三星评级]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>工信部近日印发《工业和信息化部关于 2023 年中国软件名城评估结果的通告》，<strong>确定了 2023 年中国软件名城评估结果</strong>。</p><p>1、<strong><span style="background-color:#e67e22">深圳</span></strong>：★★★</p><p>2、<strong><span style="background-color:#e67e22">杭州</span></strong>：★★★</p><p>3、<strong><span style="background-color:#e67e22">北京</span></strong>：★★★</p><p>4、南京：★★</p><p>5、上海：★★</p><p>6、成都：★★</p><p>7、济南：★★</p><p>8、武汉：★★</p><p>9、广州：★★</p><p>10、苏州：★★</p><p>11、青岛：★★</p><p>12、厦门：★★</p><p>13、福州：★★</p><p>14、无锡：★★</p><hr><p>工信部 2017 年印发了《中国软件名城创建管理办法（试行）》，目前已授牌&nbsp;14 个名城。</p><p>申请创建中国软件名城的城市需为<strong>地级及以上</strong>。同时需具备以下条件：</p><ul><li><p>一是软件和信息技术服务业基础良好、规模较大、发展潜力较强，对国民经济的贡献程度较高，拥有若干全国知名度较高的骨干软件企业和若干全国市场占有率较高的软件产品，创新能力较强，产业特色鲜明、生态较好；</p></li><li><p>二是软件和信息技术服务业带动效应明显，对拉动经济增长、促进就业、加速传统行业数字化转型，以及提升城市管理和社会服务水平具有重要支撑作用，对城市文化塑造及品牌提升具有积极影响；</p></li><li><p>三是产业政策支持力度较大，具有较为丰富的科技、教育、人才等资源条件和良好的城市人文环境，具有较为完善的适合软件和信息技术服务业集聚发展的物理载体环境，产业基地园区、公共服务平台等建设情况良好。</p></li><li><p>此外，申请城市及所属省级人民政府要对发展软件和信息技术服务业高度重视，并积极主动开展名城创建工作。</p></li></ul><p>2022 年 12 月，<strong><u><a href="https://www.oschina.net/news/221868">工信部发布了关于印发中国软件名城（园）管理办法的通知</a></u></strong>，进一步规范名城、名园管理工作，新的管理办法将对中国软件名城、名园动态管理实行<strong>退出机制</strong>。</p><p>通过每年组织开展评估工作，以星级体现（最高级为三星，星级越高发展质量越好）评估结果，充分调动地方发展软件和信息技术服务业的积极性。<strong>对评估结果为一星的名城、名园，工业和信息化部给予提醒，责令整改；对连续两年评估结果为一星的，公告退出</strong>。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 10:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274956</guid>
            <link>https://www.oschina.net/news/274956</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[工信部：到 2027 年，制定云计算国家标准和行业标准达 50 项以上]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>工信部<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fgzcy%2Fyjzj%2Fart%2F2024%2Fart_0dba24687491428a8939060c79ee358a.html" target="_blank">征集</a>对《云计算综合标准化体系建设指南》（征求意见稿）（以下简称《指南》）的意见。</p><p><img height="264" src="https://oscimg.oschina.net/oscnet/up-249312eb4a023d062a0a406036a6f3ae7a6.png" width="500" referrerpolicy="no-referrer"></p><p>《指南》明确，到 2025 年，云计算标准体系更加完善。推进修订参考架构、术语等基础标准，优先制定云计算创新技术产品、新型服务应用和重要缺失领域的关键标准。开展云原生、边缘云、混合云、分布式云等重点技术与产品标准研制，制定一批新型云服务标准，面向制造、软件和信息技术服务、信息通信、金融、政务等重点行业领域开展应用标准建设。</p><p>到 2027 年，制定云计算国家标准和行业标准达 50 项以上，基本覆盖基础、技术与产品、服务、应用、管理、安全等各类研制方向，有效满足我国产业标准化新阶段需求。结合云计算产业发展情况及各行业用户上云用云需求，推动云计算国行团标落地实施。提高国际标准参与度与转化率，协同推进互联互通与标准开放。</p><p>《指南》指出，立足我国云计算产业发展及生态系统建设新阶段，总结现阶段云计算标准体系建设成效，结合国内外云计算技术演进趋势和关键挑战，研究分析各领域方向的标准制定和缺失情况，在《云计算综合标准化体系建设指南》（工信厅信软〔2015〕132 号）基础上，修订更新云计算综合标准化体系，以指导具体标准的立项与制定。修订后的云计算综合标准化体系结构见图 1，包括「01 基础标准」、「02 技术与产品标准」、「03 服务标准」、「04 应用标准」、「05 管理标准」和「06 安全标准」六个部分。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 10:10:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274952</guid>
            <link>https://www.oschina.net/news/274952</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[云原生周刊：K8sGPT 加入 CNCF]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>开源项目推荐</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbackube%2Fvolsync" target="_blank">VolSync</a></h3><p>VolSync 使用 rsync 或 rclone 在集群之间异步复制 Kubernetes 持久卷。它还支持通过 Restic 创建持久卷的备份。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopenclarity%2Fkubeclarity" target="_blank">KubeClarity</a></h3><p>KubeClarity 是一种用于检测和管理软件物料清单 (SBOM) 以及容器映像和文件系统漏洞的工具。它扫描运行时 K8s 集群和 CI/CD 管道，以增强软件供应链的安全性。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmariadb-operator%2Fmariadb-operator" target="_blank">mariadb-operator</a></h3><p>以云原生方式运行和操作 MariaDB。使用 Kubernetes CRD 而不是命令式命令以声明方式管理 MariaDB 。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpadok-team%2Fburrito" target="_blank">Burrito</a></h3><p>Burrito 是 TACoS（Terraform 自动化协作软件）Kubernetes 运营商。它解决了管理基础架构状态漂移、为 Terraform 编写 CI/CD 流水线以及提供 Terraform 状态修改可见性的挑战。</p><h2>文章推荐</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmedium.com%2F%40kylelzk%2Fkubernetes-theory-understanding-kubernetes-components-a-deep-dive-ac31b7463df2" target="_blank">理解 Kubernetes 组件：深入探讨</a></h3><p>这篇文章深入介绍了 Kubernetes 组件，帮助读者全面了解这个强大的容器编排平台。文章首先介绍了 Kubernetes 的架构，包括主要组件和它们的功能，如 kube-apiserver、etcd、kube-scheduler、kube-controller-manager 和 cloud-controller-manager。接下来，文章讨论了运行在每个节点上的节点组件，如 kubelet、kube-proxy 和容器运行时。然后，文章介绍了一些附加组件，如 DNS、Web UI（Dashboard）、容器资源监控和集群级别的日志记录。最后，文章讨论了网络组件和存储组件，包括 CNI、Ingress、Service、Persistent Volumes 和 Storage Classes。通过深入了解这些组件的作用和功能，开发人员和管理员可以充分利用 Kubernetes 的功能，有效地管理和扩展他们的应用程序。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcollabnix.com%2Fwhats-new-in-kubernetes-1-29-mandala-the-universe%2F" target="_blank">Kubernetes 1.29 新增功能：PersistentVolume 访问模式、节点卷扩展、KMS 加密、调度程序优化等</a></h3><p>这篇文章介绍了 Kubernetes 1.29 版本的新功能和改进。其中包括持久卷访问模式、节点卷扩展、KMS 加密、调度器优化等方面的内容。文章强调了 Kubernetes 社区的协作精神，并概述了各个稳定、测试和实验性功能的特点和用途。这些新功能提供了更好的持久性、存储灵活性和加密能力，同时通过优化调度效率和改进节点生命周期管理，提升了集群的性能和可靠性。全文通过 Mandala 主题来展示 Kubernetes 的发展和创新，鼓励读者参考官方发布说明，全面了解 Kubernetes 1.29 版本的变化，并共同探索容器编排的未来。</p><h2>云原生动态</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fk8sgpt.ai%2Fblog%2Fpost-7%2F" target="_blank">K8sGPT 加入 CNCF</a></h3><p>K8sGPT 是一个用于扫描您的 Kubernetes 集群、以简单的英语诊断和处理问题的工具。它将 SRE 经验编码到其分析器中，并帮助提取最相关的信息，并结合人工智能来丰富分析结果。</p><p>K8sGPT 项目获选加入 CNCF，成为第一个被接受的 AI + Kubernetes 工具。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpicluster.ricsanfre.com%2Fblog%2F2024%2F01%2F04%2Fannouncing-release-1.8%2F" target="_blank">Kubernetes Pi Cluster 发布 v1.8</a></h3><p>Kubernetes Pi Cluster 项目的第八个版本（v1.8）发布了。该版本的主要特性和改进包括：</p><ul><li>K3S 高可用配置：使用 3 个主节点实现高可用性部署，并采用嵌入式 etcd 数据存储。为了提供 Kubernetes API 的高可用性，使用网络负载均衡器 HAProxy。</li><li>迁移 Ingress Controller：从 Traefik 迁移到 NGINX。这个迁移的主要原因是使用标准的 Ingress 资源，简化 Linkerd 集成配置。</li><li>单点登录（Single Sign-on）：基于 OAuth2.0/OpenID Connect 标准，部署了一个基于 Keycloak 的单点登录解决方案。Keycloak 是一个开源的身份访问管理解决方案，支持集中身份验证和授权服务。</li><li>新增 Kafka 服务：添加 Kafka 作为事件流平台，实现面向数据驱动的微服务架构。部署 Kafka Schema Registry，用于集中管理 Kafka 生产者和消费者的模式。</li></ul><blockquote><p>本文由博客一文多发平台 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenwrite.cn%3Ffrom%3Darticle_bottom" target="_blank">OpenWrite</a> 发布！</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 09:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4197945/blog/10726775</guid>
            <link>https://my.oschina.net/u/4197945/blog/10726775</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GTK 将采用「统一渲染器」取代 OpenGL 和 Vulkan]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>GTK 近日合并了名为「Add new unified renderer」的 PR。</p><blockquote><p style="margin-left:0; margin-right:0">GTK (GIMP Toolkit) 是一套跨多种平台的图形工具包，最初为 GIMP 而写，GIMP 是指 GNU 图像处理程序 (GNU Image Manipulation Program)，GIMP 拥有几乎所有图象处理所需的功能，号称 Linux 下的 Photoshop。GTK 后来发展成为 Linux 下开发图形界面应用的主流开发工具。</p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-730b58563ec58c49ba1dd57df43a1e3cb9e.png" referrerpolicy="no-referrer"></p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.gnome.org%2FGNOME%2Fgtk%2F-%2Fmerge_requests%2F6588" target="_blank">根据描述</a></u>，该 PR 添加了新的<strong><span style="background-color:#e67e22">统一渲染器 (unified renderer)</span></strong>，又称「GPU 渲染器」。它取代了现有的 Vulkan 渲染器和 OpenGL 渲染器 —— 未来直接默认使用 Vulkan。此举意味着 GTK 的现代 GPU 加速渲染向前迈出了一大步。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FGTK-Unified-Renderer-Progress" target="_blank">据介绍</a>，GTK 统一渲染器的主要补丁集有 24.8k 行新代码，同时删除了 9.6k 行现有代码。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 07:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274918/gtk-unified-renderer-progress</guid>
            <link>https://www.oschina.net/news/274918/gtk-unified-renderer-progress</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 称《纽约时报》的版权诉讼毫无根据]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">《纽约时报》曾于去年 12 月起诉 OpenAI 和微软公司，称这两家公司非法使用其受版权保护的材料来训练 AI 模型。时至今日，OpenAI 公开回击并发表了一篇<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Fblog%2Fopenai-and-journalism" target="_blank">博文称</a>：「我们支持新闻业，与新闻机构合作，并认为《纽约时报》的诉讼毫无根据。」</span></p><p><span style="color:#000000">该公司在博文中重申了以下四点立场：</span></p><ul><li><span style="color:#000000">我们与新闻机构合作并创造新的机会</span></li><li><span style="color:#000000">培训属于合理使用，但我们提供选择退出的机会，因为这是正确的做法</span></li><li><span style="color:#000000">「反刍（Regurgitation）」是一种罕见的错误，我们正在努力将其降至为零</span></li><li><span style="color:#000000">《纽约时报》没有讲述完整的事实</span></li></ul><p><img height="312" src="https://oscimg.oschina.net/oscnet/up-2b1881fb593ade980a7bc0e1308304de93c.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000">OpenAI 方面表示，其目标是支持健康的新闻生态系统、成为良好的合作伙伴、创造互利的机会；考虑到这一点，该公司一直在寻求与新闻机构建立合作伙伴关系。通过与美联社、Axel Springer、American Journalism Project 和纽约大学的早期合作，他们已经对相关方法有了初步了解。</span></p><p><span style="color:#000000">该公司认为，一些已经普遍被接受的先例表明，使用公开可用的互联网资料训练 AI 模型是属于合理使用范畴。「我们认为这一原则对创造者是公平的，对创新者是必要的，对美国的竞争力也是至关重要的。」</span></p><p><span style="color:#000000">而关于「反刍」问题，OpenAI 则解释道，他们已经采取了措施来限制非故意记忆，并防止大模型输出中的反刍现象。并指出，如果训练数据来自单一来源（如《纽约时报》），则反刍的可能性较小；同时也敦促用户"act responsibly"，避免故意促使其模型反刍。「故意操纵我们的模型进行反刍不是对我们技术的适当使用，也违反了我们的使用条款」。「反刍」是指特定内容在大模型的训练数据中多次出现的一种现象。</span></p><p><span style="color:#000000">OpenAI 透露与《纽约时报》的最后一次沟通是在 2023 年 12 月 19 日，「我们与《纽约时报》的讨论似乎取得了建设性进展......我们向《纽约时报》解释说，与任何单一来源一样，他们的内容对我们现有模型的训练没有任何有意义的贡献，也不会对未来的训练产生足够的影响。但他们于 12 月 27 日提起了诉讼 —— 我们是也通过《纽约时报》才了解到的 —— 这令我们感到惊讶和失望。」</span></p><p><span style="color:#000000">值得一提的是，OpenAI 称《纽约时报》在双方的沟通过程中已经发现了一些内容的反刍，但却在 OpenAI 承诺调查和解决任何问题的前提下，一再拒绝分享任何示例。</span></p><blockquote><p><span style="color:#000000">有趣的是，《纽约时报》<span style="background-color:#f8f9f9">提到的反刍</span>似乎来自于多个第三方网站上大量传播的多年前的文章。为了让我们的模型进行反刍，他们似乎有意篡改了提示语，通常包括冗长的文章节选。即使在使用此类提示时，我们的模型通常也不会像《纽约时报》影射的那样，这表明他们要么是指示模型进行反刍，要么是从众多尝试中精心挑选了一些示例。</span></p><p><span style="color:#000000">尽管他们声称，这种误用并非典型或允许的用户行为，也不能替代《纽约时报》。但无论如何，我们都在不断提高系统的抗逆向攻击能力，以避免训练数据被反刍，并在最近的模型中取得了很大进展。</span></p></blockquote><p><span style="color:#000000">在声明的最后，OpenAI 表示，尽管他们<span style="background-color:#ffffff">认为《纽约时报》的诉讼毫无根据；但仍然对《纽约时报》保持尊重并希望与其建立建设性的合作伙伴关系。「我们期待与新闻机构继续合作，通过实现 AI 的变革潜力，帮助他们提高生产高质量新闻的能力。」</span></span></p><p><span style="color:#000000">OpenAI 做出回应之际，围绕生成式 AI 的版权争论正值白热化。一些数据表明，公众更倾向于站在媒体出版商这一方。The AI Policy Institute 最近的一项民意调查结果显示，当得知《纽约时报》起诉 OpenAI 的详情后，59% 的受访者同意 AI 公司不应该被允许使用出版商的内容来训练模型；70% 的受访则表示，如果这些公司想在模型训练中使用受版权保护的材料，就应该向出版商提供补偿。</span></p><p><strong><span style="color:#000000">延伸阅读：</span></strong></p><ul><li><a href="https://www.oschina.net/news/274326/openai-offers-publishers-little-1m" target="news">OpenAI 拟每年投入 100-500 万美元，以获取新闻使用许可</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 07:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274916/openai-and-journalism</guid>
            <link>https://www.oschina.net/news/274916/openai-and-journalism</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[openKylin 2.0 揭秘 | 新一代不可变系统探索]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">openKylin 不可变系统，由社区 UpdateManager &nbsp;SIG 基于 OStree 技术研发，目标是为用户提供更加稳定、安全和高效的不可变系统架构，提高系统的安全性和稳定性，简化系统管理。目前，大家可通过安装 openKylin 2.0 Alpha 版本时勾选「不可变系统安装」进行体验，完整功能请期待 openKylin 2.0 正式版本上线！</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:center"><img alt="" height="410" src="https://oscimg.oschina.net/oscnet/up-715de6551bd2081ffda9898ef990c804ae4.png" width="940" referrerpolicy="no-referrer"></p><p style="text-align:center"><strong>什么是不可变系统</strong></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">不可变系统，是一种不可更改且只读的操作系统，即用户或应用程序不能直接修改正在运行的系统的核心文件和目录，用户通过原子更新实现系统的更新升级，<strong>在更新失败时能够迅速回滚，确保系统不会陷入异常状态</strong>。应用程序通过容器技术与核心操作系统相互隔离，确保一个应用程序所做的更改不会影响核心系统。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><strong><span style="color:#000000">openKylin 不可变系统，采用 OStree 技术实现对新一代不可变系统的探索</span></strong><span style="color:#000000">。OStree 是一种用于操作系统的版本控制系统，它类似于 Git，用于整个操作系统文件系统树的版本控制。OStree 允许用户对整个操作系统进行版本控制，包括内核、库、二进制文件和配置文件等，这使得系统升级、回滚变得更加容易。OStree 技术的另一个重要特点是不可变性。它将整个操作系统视为一个不可变的文件系统树，每个版本都被视为一个不可变文件系统树分支版本。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="text-align:center"><strong>openKylin 不可变系统技术优势</strong></p><p><span><strong>强大的稳定性</strong></span></p><p style="margin-left:0px; margin-right:0px">借助 OStree 技术，openKylin 不可变系统可实现系统架构的不可变性，确保每次系统更新都是无风险、原子级的操作，大大降低系统运行中出现问题的可能性，为用户提供更加强大的稳定性保障。</p><p><span><strong>安全可靠</strong></span></p><p style="margin-left:0px; margin-right:0px">通过 openKylin 不可变系统架构，可有效应对恶意软件和系统漏洞的威胁，为用户数据和隐私安全提供坚实的保障，极大地提升系统的安全性。</p><p><span><strong>应用隔离</strong></span></p><p>通过容器化技术实现应用程序与核心操作系统隔离，确保应用程序所做的更改不会影响核心系统或其他应用程序。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">综上所述，openKylin 基于 OStree 的不可变系统实现，确保系统核心不可变，将为用户带来更加稳定、安全的体验。在后续揭秘中，我们也将对 openKylin 不可变系统方案特性进行详细解读，敬请期待！</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p><strong>关于 UpdateManager&nbsp;SIG</strong></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">openKylin 社区 UpdateManager SIG 组致力于开发和维护 openKylin 系统升级机制，并探索和研发新一代不可变系统相关技术，包括系统架构、OStree、系统更新组件等，提供不可变系统相关的技术规划、设计、开发、维护和系统升级方案。欢迎社区中对系统更新升级、不可变系统等技术领域感兴趣的开发者加入我们！</span></p><ul><li><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">SIG 主页：</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#0b43d1">https://gitee.com/openkylin/community/tree/master/sig/UpdateManager</span></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 08 Jan 2024 09:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274942</guid>
            <link>https://www.oschina.net/news/274942</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
