<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Sun, 05 Nov 2023 07:08:42 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[OpenELA 公开发布 Enterprise Linux 源代码]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#000000">Open Enterprise Linux Association (OpenELA)</span><span style="color:#000000"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenela.org%2Fnews%2F2023.11.02-governance_and_code_availability%2F" target="_blank">宣布</a>公开发布 Enterprise Linux (EL) 源代码并成立技术指导委员会。</span></p><blockquote><p><span style="color:#000000">「OpenELA 很高兴地宣布，现在所有人都可以获取构建衍生&nbsp;Enterprise Linux 操作系统所需的全部源代码包。初步侧重点在于 EL8 和 EL9，EL7 的软件包也即将推出。该项目致力于确保向社区无限期提供 EL 源代码。」</span></p></blockquote><p><img alt="" height="381" src="https://oscimg.oschina.net/oscnet/up-08878f094d1e8bcafadeca1ea19e8f93ccc.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">OpenELA 是在今年 8 月份，由甲骨文、SUSE 和 CIQ (Rocky Linux 背后的商业实体) 联合组建的一个开源企业 Linux 发行版开发商的行业协会；旨在通过提供开放和免费的 Enterprise Linux 源代码，鼓励<span style="background-color:#ffffff">与 Red Hat Enterprise Linux (RHEL) 兼容的发行版的开发和协作</span>。</span><span style="background-color:#ffffff; color:#000000">OpenELA 的形成源于红帽</span><a href="https://www.oschina.net/news/246331/red-hat-centos-stream-sources">对 RHEL 源代码可用性的更改</a><span style="background-color:#ffffff; color:#000000">。</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Oracle、SUSE 和 CIQ&nbsp;方面都表达了对这一进展的喜悦之情。CIQ 首席执行官兼 Rocky Linux 创始人 Gregory Kurtzer 发言称：</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">「几十年来，各组织都在 CentOS 上进行标准化，因为它是免费的，遵循 Enterprise Linux 标准，并且得到许多供应商的大力支持。CentOS 停产后，不仅在生态系统中留下了一个巨大的漏洞，而且也清楚地表明了社区需要团结起来才能做得更好。OpenELA 正是这样的一个社区答案，它将确保所有专业 IT 部门和企业用例拥有一个协作和稳定的未来。」</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">AlmaLinux 尚未加入该协会。AlmaLinux 操作系统基金会主席 benny Vasquez 评论表示，「</span></span><span style="background-color:#ffffff; color:#000000">我总是很乐于看到一个新的非营利组织站稳脚跟并开始</span><span style="color:#000000"><span style="background-color:#ffffff">运作。不过我们目前还不会使用他们发布的代码，因为我们已经建立了自己的工作流程，不需要使用这些代码。」</span></span></p><p><span style="color:#000000">OpenELA&nbsp;已经<span style="background-color:#ffffff">完成了在美国特拉华州的非营利性非股份公司的注册，正在向美国国税局申请 501(c)(6) 免税资格。该公司表示，将为有兴趣支持开源企业 Linux 发行版开发目标和利益的利益相关者提供一个论坛。「创始公司认为，法律实体是对开源工作产生积极影响的基础性工具，可以统一开源工作的价值观，并确保与开源社区的适当接触。」</span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>相关阅读：</strong></span></p><ul><li style="text-align:start"><a href="https://www.oschina.net/news/253319/oracle-suse-ciq-openela" target="_blank">SUSE、甲骨文和 CIQ 组建 OpenELA：企业 Linux 源代码的社区存储库</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Sat, 04 Nov 2023 04:22:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264995/openela-enterprise-linux-source</guid>
            <link>https://www.oschina.net/news/264995/openela-enterprise-linux-source</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[昆仑万维「天工」大模型正式向全社会开放]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 11 月 3 日，昆仑万维「天工」大模型宣布通过《生成式人工智能服务管理暂行办法》备案，面向全社会开放服务！</p><p>用户在应用商店下载「天工 APP」或登陆「天工官网」（<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.tiangong.cn" target="_blank">www.tiangong.cn</a>）均可直接注册使用。</p><p>官方介绍称，「天工」是国内首个对标 ChatGPT 的双千亿级大语言模型，也是一个 AI 搜索引擎，一个对话式 AI 助手。「天工」拥有强大的自然语言处理和智能交互能力，能够实现个性化 AI 搜索、智能问答、聊天互动、文本生成、编写代码、语言翻译等多种应用场景，并且具有丰富的知识储备，涵盖科学、技术、文化、艺术、历史等领域。</p><p><img height="232" src="https://oscimg.oschina.net/oscnet/up-4220721cc203df8b9704c1aa7e7fb303f00.png" width="500" referrerpolicy="no-referrer"></p><p>2022 年 12 月 15 日，昆仑万维在北京举行 AIGC 技术发布会，发布自研 AIGC 全系列算法与模型，覆盖了图像、音乐、文本、编程等多模态的 AI 内容生成能力。</p><p>2023 年 4 月 17 日，昆仑万维正式发布自研千亿级大语言模型「天工」，同时宣布启动邀请测试。「天工」用过通过自然语言与用户进行问答式交互，AI 生成能力可满足文案创作、知识问答、代码编程、逻辑推演、数理推算等多元化需求。</p><p>2023 年 5 月 19 日，北京市经济和信息化局公布第一批《北京市通用人工智能产业创新伙伴计划成员名单》。昆仑万维成为第一批模型伙伴和投资伙伴。</p><p>2023 年 8 月 23 日，昆仑万维推出国内第一款 AI 搜索产品——「天工 AI 搜索」，并开启内测申请。「天工 AI 搜索」深度融合 AI 大模型能力，通过人性化、智能化的方式全面提升用户的搜索体验，为用户提供快速、可靠的交互式搜索服务，并集成 AI 对话、AI 写作等常用功能，帮助用户提升工作效率，全面重塑中文搜索体验。</p><p>2023 年 9 月，昆仑万维多模态大模型 Skywork-MM 在腾讯优图实验室联合厦门大学开展的多模态大语言模型测评 MME 中，综合得分排名第一。该评测首次对全球范围内 MLLM 模型进行了全面定量评测并公布了 16 个排行榜，包含感知、认知两个总榜单以及 14 个子榜单。Skywork-MM 模型位列综合榜单第一，其中，感知榜单排名第一、认知榜单排名第二。</p><p>2023 年 9 月 16 日，在权威推理榜单 Benchmark GSM8K 测试中，昆仑万维「天工」大模型以 80% 的正确率脱颖而出，大幅领先 GPT-3.5（57.1%）和 LLaMA2-70B（56.8%）。</p><p>2023 年 9 月 17 日，昆仑万维通过信通院「可信 AI」评估，并被评选为人工智能实验室副组长单位。经中国信通院评估，昆仑万维天工大模型符合 AIIA/PG 0071-2023、AIIA/PG 0072-2023 评估标准，模型开发、以及模型能力均达到了「4+级」。</p><p>10 月 30 日，昆仑万维开源百亿级大语言模型「天工」Skywork-13B 系列，并配套开源了 600GB、150B Tokens 的超大高质量开源中文数据集。「天工」Skywork-13B 系列目前包括 130 亿参数的两大模型，Skywork-13B-Base 模型、Skywork-13B-Math 模型，它们在 CEVAL、GSM8K 等多个权威评测与基准测试上都展现了同等规模模型的最佳效果，其中文能力尤为出色，在中文科技、金融、政务等领域表现均高于其他开源模型。同时，昆仑万维「天工」Skywork-13B 系列大模型全面开放商用——开发者无需申请，即可商用。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 04 Nov 2023 03:06:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264987</guid>
            <link>https://www.oschina.net/news/264987</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[WinterJS —— Rust 编写的 Service Worker]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>WinterJS 是用 Rust 编写的 JavaScript Service Worker。</p><p>WinterJS 使用 SpiderMonkey 运行时执行 JavaScript（与 Firefox 使用的运行时相同），并遵循 WinterCG 规范，目的是最大限度地兼容 Cloudflare Workers、Deno Deploy 和 Vercel 等其他服务（因此命名为 WinterJS）。</p><p>WinterJS 除了速度极快，还能通过 WASIX&nbsp;<strong>编译成 WebAssembly</strong>，因此完全支持在 Wasmer 上运行。</p></div>
                                                                ]]>
            </description>
            <pubDate>Sat, 04 Nov 2023 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/winterjs</guid>
            <link>https://www.oschina.net/p/winterjs</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 基于连接的可扩展消息传输协议 SocketD]]>
            </title>
            <description>
                <![CDATA[<h1 align="center"><a id="user-content---socketd" class="anchor" href="https://gitee.com/noear/socketd#--socketd"></a>
  SocketD
</h1><p align="center"><strong>基于连接的可扩展消息传输协议</strong></p><p align="center"><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fsearch.maven.org%2Fartifact%2Forg.noear%2Fsocketd"><img src="https://img.shields.io/maven-central/v/org.noear/socketd.svg?label=Maven%20Central" alt="Maven" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.apache.org%2Flicenses%2FLICENSE-2.0.txt"><img src="https://img.shields.io/:license-Apache2-blue.svg" alt="Apache 2" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjavase-jdk8-downloads.html"><img src="https://img.shields.io/badge/JDK-8-green.svg" alt="jdk-8" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk11-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-11-green.svg" alt="jdk-11" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk17-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-17-green.svg" alt="jdk-17" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk21-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-21-green.svg" alt="jdk-21" referrerpolicy="no-referrer"></a><br><a target="_blank" href="https://gitee.com/noear/socketd/stargazers"><img src="https://gitee.com/noear/socketd/badge/star.svg" alt="gitee star" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fnoear%2Fsocketd%2Fstargazers"><img src="https://img.shields.io/github/stars/noear/socketd.svg?logo=github" alt="github star" referrerpolicy="no-referrer"></a></p><br><p align="center"><a href="https://gitee.com/link?target=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3DkjB5JNiC"><img src="https://img.shields.io/badge/QQ%E4%BA%A4%E6%B5%81%E7%BE%A4-870505482-orange" referrerpolicy="no-referrer"></a></p><hr><p>SocketD 是一个基于连接的、可扩展的、消息驱动的传输协议。具有异步，自动分片，背压流控，双向通讯，多路复用，断线重连，支持签权，基于主题消息等特性。</p><ul><li>具有语言无关性的二进制通信协议（支持 tcp, ws, udp）</li><li>异步非阻塞消息驱动通信</li><li>可以进行流量控制、自动连接恢复</li><li>支持双向通信（如：单链接双向 RPC 接口调用）</li><li>更加适合分布式通信场景</li><li>支持 ssl，支持国密 ssl</li><li>消息有由元信息和数据组成，通过元信息实现可扩展性</li><li>接口简单</li></ul><p>开发时，主要交互只有 2 接口对象（更多可见：<a href="https://gitee.com/noear/socketd/blob/main/API.md">API.md</a> ）：</p><table><thead><tr><th>接口</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td>listener</td><td>监听器</td><td>（可双向互听）</td></tr><tr><td>session</td><td>会话</td><td>（可双向互发）</td></tr><tr><td></td><td></td><td></td></tr><tr><td>session::send</td><td>发送</td><td></td></tr><tr><td>session::sendAndRequest</td><td>发送并请求</td><td>要求一次答复</td></tr><tr><td>session::sendAndSubscribe</td><td>发送并订阅</td><td>答复结束之前，不限答复次数</td></tr><tr><td>session::reply</td><td>答复</td><td></td></tr><tr><td>session::replyEnd</td><td>答复结束</td><td></td></tr></tbody></table><h3><a id="user-content-适用场景" class="anchor" href="https://gitee.com/noear/socketd#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"></a>适用场景：</h3><p>可用于 MSG、RPC、IM、MQ，等一些的场景开发，可替代 http, websocket, grpc 等一些协议。比如移动设备与服务器的连接，比如一些微服务场景等等。</p><h3><a id="user-content-协议格式" class="anchor" href="https://gitee.com/noear/socketd#%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F"></a>协议格式：</h3><ul><li>codec</li></ul><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">[len:int][flag:int][sid:str][\n][topic:str][\n][metaString:str][\n][data:byte..]</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><ul><li>flag</li></ul><table><thead><tr><th>Flag</th><th>Server</th><th>Client</th><th>备注</th></tr></thead><tbody><tr><td>Unknown</td><td>::close()</td><td>::close()</td><td></td></tr><tr><td>Connect</td><td>/</td><td>c(Connect)-&gt;s</td><td></td></tr><tr><td>Connack</td><td>s(Connack),s::c.onOpen()-&gt;c</td><td>s(Connack)-&gt;c::onOpen()</td><td></td></tr><tr><td>Ping</td><td>/</td><td>c(Ping)-&gt;s</td><td></td></tr><tr><td>Pong</td><td>s(Pong)-&gt;c</td><td>/</td><td></td></tr><tr><td>Close</td><td>s(Close)-&gt;c</td><td>c(Close)-&gt;s</td><td>用于特殊场景（如：T 人）</td></tr><tr><td>Message</td><td>s(Message)-&gt;c</td><td>c(Message)-&gt;s</td><td></td></tr><tr><td>Request</td><td>s(Request)-&gt;c(Reply)-&gt;s</td><td>c(Request)-&gt;s(Reply)-&gt;c</td><td></td></tr><tr><td>Subscribe</td><td>s(Subscribe)-&gt;c(Reply?..)-&gt;s</td><td>c(Subscribe)-&gt;s(Reply?..)-&gt;c</td><td></td></tr><tr><td>Reply</td><td>s(Reply)-&gt;c</td><td>c(Reply)-&gt;s</td><td></td></tr><tr><td>ReplyEnd</td><td>s(ReplyEnd)-&gt;c</td><td>c(ReplyEnd)-&gt;s</td><td>结束答复</td></tr></tbody></table><h3><a id="user-content-链接示例" class="anchor" href="https://gitee.com/noear/socketd#%E9%93%BE%E6%8E%A5%E7%A4%BA%E4%BE%8B"></a>链接示例:</h3><ul><li>tcp://19.10.2.3:9812/path?u=a&amp;p=2</li><li>udp://19.10.2.3:9812/path?u=a&amp;p=2</li><li>ws://19.10.2.3:1023/path?u=a&amp;p=2</li></ul><h3><a id="user-content-简单演示" class="anchor" href="https://gitee.com/noear/socketd#%E7%AE%80%E5%8D%95%E6%BC%94%E7%A4%BA"></a>简单演示:</h3><ul><li>java</li></ul><p><a href="https://gitee.com/noear/socketd/blob/main/java">java/README.md</a></p>]]>
            </description>
            <pubDate>Sat, 04 Nov 2023 02:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/noear/socketd</guid>
            <link>https://gitee.com/noear/socketd</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 复用性风控：软件复用成本的量化管理]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:justify">复用性（Reusability）是软件工程中一个被频频使用的术语，它一般作为产品的卖点被宣传，或者出现在技术设计文档之中。大部分看到这个概念的的受众只是将其作为一个积极的软件非功能属性去理解，但却忽略了其背后隐藏的风险。本文从另一个角度出发，去分析「复用性」这一概念背后的风险及成因，借助笔者在业务安全和基础安全的一点经验，提出了一个在软件研发流程中，管理「复用性成本风险」的风险管理模型。从模型出发，我们可以认识到实现复用时面临的各项挑战、开发认知谬误、复用成本的形式化定义方法等，希望这些输入能为读者在后续的技术决策和软件研发流程提供些许帮助。</p><p style="text-align:justify">本文主要分为三个部分：第一部分介绍复用性的定义以及不合理复用引入的主要技术债，第二部分分析复用性失效的原因；第三部分为复用性软件资产的构建方和使用方提供一个形式化的度量工具，该工具将奠定后续风险管理模型评估阶段定量分析的基础；第四部分提出一个用于管理「复用性风险」的模型，覆盖软件研发生命周期的全流程，通过事前评估、事中缓释和事后迭代三个环节最大程度地降低由于软件复用带来的软件开发和维护成本。</p><span id="OSC_h3_1"></span><h3>一、复用性的理想与现实</h3><span id="OSC_h4_2"></span><h4><strong>1.1 复用定义：从代码到系统</strong></h4><p style="text-align:justify">软件复用是解决软件质量和生产力问题的一种方法，它指的是在软件开发过程中重复使用相同或相似的软件元素。通过合理利用软件复用技术，我们可以提高开发效率，并且降低开发过程中的错误率。同时，软件复用还可以促进团队协作和知识共享，使得开发者们能够更好地利用彼此的经验和资源。因此，在当今快节奏的开发环境中，软件复用已经成为提高生产力和质量的关键策略之一。在过去几十年的时间里，很多编程语言的成功（Python、Java 等）和开源文化的蓬勃发展，都与复用密不可分。软件复用可以在不同粒度上进行，包括代码和设计拷贝、源代码复用、设计和软件体系结构复用以及领域特定的软件体系结构复用等。早期的软件复用主要集中在代码级别，例如共享方法、抽象类、库、微服务和 Docker 镜像等。随着时间推移，其外延拓展至领域知识、开发经验、设计文档、需求分析和测试用例及数据等在不同阶段所产生的各种软件产品。<strong>在本文中，除非特别说明，复用性主要指的就是聚焦代码的复用，下文中的「组件复用」，不仅限于通常我们认知中的公共库，还包括代码方法、公共类、软件框架、可集成系统等软件开发中的可复用元素。</strong></p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-963651fba23c39dc34c4a58a1a6eaacb_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_3"></span><h4><strong>1.2 复用风险：复杂度和成本</strong></h4><p style="text-align:justify">诚然，通过组件的复用可以提高软件开发效率和质量，但复用不是银弹，复用也会有一些副作用：</p><p style="text-align:justify">1.兼容性/安全性/性能；</p><p style="text-align:justify">2.增加了系统间的依赖；</p><p style="text-align:justify">3.增加了开发和维护成本。</p><p style="text-align:justify"><strong>首先，兼容性/安全性/性能</strong>等这几类问题，是针对可复用组件的使用方来说的，一般来说，在决策是否复用之前就可以评估，其指标和过程也比较清晰，这里就不具体展开了。</p><p style="text-align:justify"><strong>其次，复用会增加系统依赖。</strong>依赖关系是软件的基本组成部分，无法消除，但软件设计的目标之一是尽可能消除依赖关系，并使依赖关系尽可能简单和明显。当我们引入外部组件进行复用时，软件组件之间的依赖关系会导致组件变更范围的扩大以及组件认知负荷的增加，前者是针对组件维护方而言的，即看似简单的变更需要在许多不同的地方修改代码，<strong>随着消费者数量的增长，在不同需求之间进行平衡变得越来越困难；</strong>后者是对于组件使用方而言的，即开发人员需要了解大量组件领域知识才能实现有效的组件复用。比如，需要了解待使用接口中若干入参的设计意图、是否存在隐式依赖传递从而导致依赖冲突等。依赖的增加会为系统引入更多的复杂性，而我们知道，构建软件系统的核心挑战就是管理复杂性，复用组件只会在一定程度上转移复杂性，但并不能消除复杂性。因此，我们需要在「复用组件降低成本」和「复用组件引入依赖（复杂性）」之间取得平衡。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-3612b21399b66c7600b9f27155d86f92_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>最后，复用会增加各项成本。</strong>包括开发的成本、变更的成本、集成的成本、领域知识迁移的成本。对于一个面向复用设计的组件来说，实现正确抽象和通用框架的设计和开发成本，比一次性的解决方案高得多，对于组件的后续维护者来说，这样的可复用框架和库通常也会带来陡峭的学习曲线（因为文档一般是缺失的），组件会逐渐走向腐化，最后不得不推倒重来。此外，对于可复用组件的使用方来说，其理解和集成组件的成本通常也是被忽略的，一些强推的业务层的「伪复用框架」给前台集成的同学带来了巨大的集成、学习和维护成本。</p><p style="text-align:justify">上述复用带来问题，有一些是可以规避的，如兼容性、性能、容量等的匹配度，有一些是无法避免的，如设计通用化组件的开发成本、不合理的抽象导致的代码腐化、不合理的复用导致的维护成本等。事实上，无论我们在技术上做多么精妙的设计，技术的创新永远滞后于系统的腐化速度。</p><p style="text-align:justify">为了最大程度的降低复用带来的风险，本文提出一套从类比于安全风险管理的「复用性风险」应对模型，从事前评估、事中缓释、事后迭代三个阶段出发，最大程度地降低我们在开发可复用组件、使用可复用组件中遇到的各类风险。需要说明的是，<strong>上面以及后面指的「复用性风险」，定义为「由于不合理的复用决策，导致依赖和复杂度膨胀过快，从而导致软件维护成本过高」的问题，</strong>除了成本风险外，由于复用组件的不合理使用或存在的缺陷而导致的兼容性、安全性、性能等方面的风险，其风险更为显著和易于治理，因此不是本文论述的重点。此外，复用开发过程中的开发目标偏移、迭代和发布计划的延期、人员短缺等风险，限于篇幅也不在这里展开。</p><p style="text-align:justify">第二部分首先会介绍导致「复用提升软件开发效率」这一原则失效的几类主要原因，第三部分会重点介绍用于评估复用性的若干工具，有了对复用性本质的认识后，再第四部分我们会简要介绍复用性风险管理模型。</p><span id="OSC_h3_4"></span><h3>二、复用性风险根因分析</h3><span id="OSC_h4_5"></span><h4><strong>2.1 现实挑战：正确和错误的抽象</strong></h4><p style="text-align:justify">我们复用组件的一个初衷，除了是为了提升研发效率之外，也是希望可复用组件可以将领域的复杂性隔离在一个我们永远看不到的地方，从而整体降低组件使用方的系统复杂度。因此，一个可复用的组件，无论其规模大小，其设计过程就是对某个领域高度抽象的过程。在设计组件时，向上面对当前或潜在的需求，需要我们做一定的前向通用设计，向下尽可能屏蔽掉组件的实现细节，抽象的结果直接决定了后续该组件可复用性程度的高低（可复用性的度量将在下一个章节详述）。但遗憾的是，良好的抽象能力对于大部分开发者来说是一个稀缺的产物，它需要对问题进行清晰的定义、简化和分解，同时识别和利用通用模式，将子问题的解法组合起来形成一个整体解决方案，依赖对设计模式、开源的库和框架、数据结构和算法以及大量生产项目的长期实践和思考。</p><p style="text-align:justify">在日常的代码中，我们不乏抽象，但大部分都是不合理的抽象。错误的抽象造成的危害甚于不抽象，比如常见的一个现象：对设计模式的适用范围知之甚少，仅仅为了炫技而滥用设计模式，导致代码的可读性和可维护性下降。</p><p style="text-align:justify">除了对抽象能力的要求外，很多时候需求紧迫度、开发资源、责任心以及组件所在领域职责的变更等因素，都会导致可复用组件从出生就带着「高成本」的原罪，其后续的使用成本和维护成本会急剧上升，这里就不一一展开了。</p><span id="OSC_h4_6"></span><h4><strong>2.2 认知谬误：复用不是设计目标</strong></h4><p style="text-align:justify">一个对于复用性的认知谬误就是，把「不重复」等效为「复用」，这两个概念之间有相似之处，但还是有一些微妙的差别。「不重复」即我们所熟知的 DRY 原则（Don’t Repeat Yourself），其目标是通过减少重复建设从而避免承担副本不一致的维护成本，而 Reusability 是从所有代码中找到重复的部分，然后在复杂度可控的前提下，努力抽象出可复用的东西。一堆不重复的代码，并不代表存在可复用的组件。</p><p style="text-align:justify"><strong>复用只是实现不重复目标的一种手段，「不重复」才是我们设计软件系统时的目标，单纯追逐「复用性」很多时候会出现一些本末倒置的现象。</strong>如出现了一些接入成本非常高的自动测试框架、业务中台框架，一味追逐「（我）一次开发，（你）随处使用」，殊不知在使用方需要消耗大量的精力去内化框架设计者的设计初衷，面对十几个接入参数或配置文件一筹莫展。</p><p style="text-align:justify">举个例子，偶尔会看到我们在业务层代码中，部分同学会把简单的新增和修改逻辑抽象为一个方法，美其名曰「提供给接入层复用」，如下面的 insertOrUpdate 方法中，初看是复用了领域对象转换和用户对象是否存在的代码，符合 DRY 原则，但实际上却是混用了两个不同的业务语义，会给后续的维护带来较高的成本，如变更用户信息时，需要做更个性化的用户属性处理，这时候调整领域对象转换处的代码，将会影响新增逻辑。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-3c8e7289db213680d7aa473520b964c9_720w.webp" referrerpolicy="no-referrer"></p><p>更合理的实现是，将明显不同语义的代码进行拆分，虽然看上去存在一定程度上的代码重复，但其设计会更利于后续的功能迭代，也更符合代码的「单一职责」设计原则。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-5f8500b6ba012049c89989be0edced10_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_7"></span><h4><strong>2.3 决策偏差：复用的决策权在哪</strong></h4><p style="text-align:justify">代码的复用更多的时候是软件开发者自发完成的，但我们无法忽视的一点是，如何集成、是否复用、如何复用、是否是同一个功能、使用什么粒度的复用，很多时候是由业务架构决定的，「康威定律」还是无法回避的。</p><p style="text-align:justify">比如，在一个新的场景里，产品要求把「PPT 上与其名字相同的一个功能」进行复用，以快速上线，虽然他们除了名字相同，其产品形态、业务流程、环境依赖等都不一样。最终强行「复用」的结果就是代码逻辑里出现了大量的分支判断，底层技术架构变得臃肿。由于对于领域的理解不同，出现这种情况在所难免。虽然很多时候软件复用的决策权并不在开发者这里，但出于技术情怀也好，责任心也罢，开发者有义务去做这种纠偏，最大程度地消除这种差异性。但需要认识到技术的作用在这里并不是决定性的，卓越的技术是复用成功的必要非充分条件。</p><span id="OSC_h4_8"></span><h4><strong>2.4 工具缺失：如何计算复用成本</strong></h4><p style="text-align:justify">复用性度量，主要分为两个部分：</p><p style="text-align:justify">1.复用度：决定一个组件复用性高低水平的因素有哪些？</p><p style="text-align:justify">2.复用成本：组件集成方、组件所在的组织，决定实行复用策略后的 ROI 如何计算？</p><p style="text-align:justify">通过复用度和复用成本两个指标，我们可以进行一定程度上的复用性定量分析，做出更为长远的技术决策。比如，可以了解到一个复用性高的组件，其特征有哪些？引入一个新的第三方组件时，除了基础的功能性组件外，我还需要考虑哪些？相较于使用已经存在的组件，是否考虑重新造一个轮子？「复用」和「造轮子」间成本有多大？关于复用性的度量工具，第三部分将重点论述。</p><span id="OSC_h3_9"></span><h3>三、复用性的形式化度量</h3><span id="OSC_h4_10"></span><h4><strong>3.1 组件度量：可复用水平的评估</strong></h4><p style="text-align:justify">我们在设计一段代码/一个类/一个模块等可复用的组件时，一些可衡量的软件指标共同决定了组件的可复用性水平的高低。这些指标包括：可靠性（Reliability）、可读性（Understandability）、可维护性（Maintainability）、通用性（Generality）与可迁移性（Portability），如下图所示。每一个指标可由各类代码度量属性决定，如组件的可迁移性由「组件的独立性」和「耦合性」两个属性决定，大部分的度量属性都是可以通过形式化定义并计算出来。不同指标的决定因子及度量值（括号中）如下：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-ae30c926a96772aa3e71efcc921e9e0e_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">1.<strong>可靠性：</strong>性能（响应时间）、容错程度（恢复时间）；</p><p style="text-align:justify">2.<strong>通用性：</strong>类泛化水平（子类实例个数或接口实现类个数）；</p><p style="text-align:justify">3.<strong>可读性：</strong>内聚性（类之间耦合度）、复杂度（圈复杂度）、规模（代码行数）、文档水平（数量+完整度）；</p><p style="text-align:justify">4.<strong>可维护性：</strong>易于修改、单测和回归测试（测试覆盖度）、组件的独立性（依赖数）、耦合性（类间耦合度）；</p><p style="text-align:justify">5.<strong>可迁移性：</strong>组件的独立性（依赖数）、耦合性（类间耦合度）。</p><p style="text-align:justify">为了度量整个组件的的可复用性，有必要定义一个可复用性计算模型。该模型基于上图所示的复用性属性模型。主要的可复用性属性、影响这些属性的因素以及度量这些因素的量度之间的关系显示在这个模型中。理论上，软件组件的可复用性 (用&nbsp;<em>Reusability</em>&nbsp;表示) 可以用表达式来计算：</p><p style="text-align:justify"><em>Reusability = w1*M + w2*R + w3*P + w4*U + w5*G</em></p><p style="text-align:justify">其中&nbsp;<em>w1 ~ w5</em>&nbsp;为不同指标的权重值，指标&nbsp;<em>M（Maintainability）、R（Reliability）、P（Portability）、U（Understandability）、G（Generality）</em>&nbsp;值进行归一化（0 ... 1）后，乘以每个指标不同的权重值，通过计算得到最终的组件的可复用度。</p><p style="text-align:justify">在上面的分析过程中，存在部分度量无法进行定量分析的情况，但不同因子组合计算还是有意义的，我们可以拿这些指标去评估我们目前的系统，存在的问题的严重程度。当下次别人问我们为什么要复用组件 A 而不是组件 B 时，我们可以给出更令人信服的理由，而不仅仅是「我觉得」、「A 比 B 好很多」等论述。</p><span id="OSC_h4_11"></span><h4><strong>3.2 组织度量：复用的投入产出比</strong></h4><p style="text-align:justify">对组件的复用性有了一个感性认知后，更加一步地，让我们从经济的角度去思考复用性背后的成本问题。首先，我们先定义几个变量&nbsp;<strong>RL、NUC、RCR、RCWR</strong>。</p><ul><li><strong>RL（Reuse Level）</strong>：可复用组件在应用中的比例，即 RL=复用的组件中代码行数/应用总的代码行数；</li><li><strong>NUC（Not Use Cost）</strong>：应用开发过程中完全不使用可复用组件的成本，注意不包括后续的维护成本；</li><li><strong>RCR（Relative Cost of Reuse）</strong>：复用既有的组件与重新造一个相似的轮子，这两者之间工作量的比值，一般在 0.03~0.4 之间，经验值为 20%，即这意味着复用所花费的成本大约是编写新组件所投入的 20%；</li><li><strong>RCWR（Relative Cost of Writing for Reuse）</strong>：开发可复用的组件与开发一次性使用的模块，这两者之间工作量的比值，一般在 1.0~2.2 之间，经验值为 1.5，即这意味着编写可复用软件需要大约 50% 的额外成本。</li></ul><p style="text-align:justify">对于集成方而言，可以计算因复用节省的成本（DCA，Development Cost Avoidance）以及复用后的成本节省比占比（ DCAR，Development Cost Avoidance Ratio）：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-ac493599b0c28acc0e45e8e36f988186_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">举例，如果复用度 RL = 40%， RCR = 0.2，则软件集成方节约成本占比 = 0.64，即节省了 64% 的成本。同时我们可以得到一个简单的结论，对于组件的集成方来说，如果想要提升成本占比，则需要：<strong>可复用组件在项目中的复用度越高越好，同时可复用组件的 RCR 应较低。</strong>这意味着可复用组件拓展性、可读性需要保持在一个较高的水平，这样集成方在集成时的二次开发和适配成本会较低，这个结论也是契合我们研发时的直觉的。</p><p style="text-align:justify">对于组织而言，假如某可复用组件的 N 个场景被使用了，则组织复用收益 OROI 可计算如下：</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-6d2fc9255a7e8362245fea5bbc0424ab_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">举例：如果复用度 RL = 40%，RCR = 0.2，RCWR = 1.5，复用次数为 5 次，则，组织收益 OROI = 167%，这意味着开发一个可复用的组件，同时在多个场景进行复用，是有超额回报的。但是不是只要复用了就会有收益呢？另 OROI = (N*(1-RCR) - RCWR)/RCWR &gt; 0 可以得到 N &gt; RCWR/(1-RCR)，带入上面预设的 RCR = 0.2，RCWR = 1.5 这两个值，得到 N &gt; 2，这意味着需要两个或两个以上的场景复用了此组件，我们此次研发活动才会取得正向的收益。与此同时，我们可以从上面的公式得到以下几个关于提升组织复用 ROI 的结论：<strong>可复用组件在项目中复用度越高越好，开发可复用组件时，RCWR 和 RCR 越低越好。</strong>RCWR 低意味着不要去过度设计，组件的泛化性需要在领域内得到一定的控制，RCR 低意味着可复用组件可读性好、拓展性高，集成时的成本不高。</p><p style="text-align:justify">马丁·福勒（Martin Fowler）在《重构》一书提出了一条代码重构经验法则「Rule of Three 」，即我们可以复制和粘贴一次代码，但是当复制相同的代码三次时，应将其提取到新过程中进行抽象以便于复用，法则里面的最小重复次数 3，其值亦符合上述 N &gt; RCWR/(1-RCR) 的结论。</p><span id="OSC_h4_12"></span><h4><strong>3.3 重复度量：复用和复制的边界</strong></h4><p style="text-align:justify">回到我们第二节中所提到的问题：为什么说 DRY 原则不等价于复用？假设以下场景：1. 项目中设计了全局的字符串常量类，所有的公共常量都放在此处，其他模块中的类都引用此常量，这是一个好的实践吗，是不是定义模块内的常量类或类中的常量字段会更好？2. 我需要进行字符串判重逻辑，是自己重写一个字符串工具类，还是直接使用如 commons-lang 或 guava 包中的代码呢？上面的场景都没有绝对的答案，但就我目前看到的情况来看，在很多开发者的编码习惯中，因为过度去追逐「复用性」，出现了一些没有必要的依赖负担，如使用全局常量类，出现没必要的类加载，第三方包的随意使用，造成应用包膨胀或者集成时的包冲突问题。<strong>有时候，复制一些类似的代码比尝试泛化再实例要好得多，过度使用抽象只会模糊真正关键的问题。</strong></p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-0ce4791fa1d8b3d3c325d20da80465f7_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">那什么时候可以复制，什么时候不建议呢？除了 2.2 中提到的语义不一致时的适度复制（就不是复用），当我们真实使用的代码占可复用组件整体代码逻辑的比例较低时（譬如只使用了 commons-lang 包中的 StringUitls 类），可以考虑重写一份，进行适度的复制粘贴，实现该处逻辑和集成方「自治」。对应前面的结论，这种情况下意味着 RL 较低，同时&nbsp;<strong>RCR 较高，比如 RL = 0.01，RCR = 0.8，则，软件集成方节约成本占比只有 RL*(1-RCR) = 0.2%</strong>，这一点收益同后续可能潜在的风险（包膨胀和包冲突）相比，复制可能是一个更好的选择。</p><span id="OSC_h3_13"></span><h3>四、复用性风险管理模型</h3><p style="text-align:justify">有了前面两个部分的铺垫，我们再回头去审视因为复用引入的成本风险，应该采取哪些措施能使得风险最小化呢？在业务风控和数据安全等泛信息安全的业务中，我们对风险管理的抽象，都会强调事前、事中、事后的风险控制流程。相似地，我们可以在代码研发过程中，<strong>通过建立事前评估、事中缓释及事后迭代的复用性风险管控手段</strong>，降低风险发生的可能性及其造成的影响，并根据业务架构和技术架构的发展趋势采取规避、降低和转移风险的措施，将风险控制到团队可承受的水平之内，最大程度地避免或延缓因为复用导致的维护成本高、系统快速腐化等问题。</p><p style="text-align:justify">事前评估、事中缓释、事后迭代形成的全生命周期复用性风险管理模型如下图所示：</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-68fe36560c29dea37111fa27bd2310e9_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_14"></span><h4><strong>4.1 事前评估：成本与启发式决策</strong></h4><p style="text-align:justify">风控的事前阶段（评估+分析），一般基于某些黑样本出发，挖掘出适用于后续风险对抗阶段的某些风险行为特征或模型，并基于历史样本计算出准确率和召回率。在复用性风险的事前阶段，我们也可以通过定性和定量的评估手段，尽早发现各种复用时的「坏味道」，立即予以纠正或防范，把风险消灭在萌芽状态，避免因为错误的复用引入过多技术债。评估的流程主要分为：可复用组件评估、复用成本和收益的度量、启发式决策这三个阶段，具体地：</p><p style="text-align:justify">1.如果待复用的组件是已存在的，则可以计算或估算出已复用组件的可复用水平，考量的指标即上面提到的可靠性、可读性、可维护性、通用性和可迁移性，不同场景的指标权重不一，可以结合具体场景进行判断；</p><p style="text-align:justify">2.如果待复用的组件是需要新建的，则可以计算出后续集成节约的人力成本，以及中长期的时间里组织通过复用组件获取的整体收益，通过结合复用成本、复用收益、当前组织人力现状、后续业务进行最终的决策；</p><p style="text-align:justify">3.如果步骤 1 和 2 都得不到一个最终的结论，下面还有一些启发式的经验帮助我们决定是否真的需要复用。</p><p style="text-align:justify"><strong>可能需要复用的场景</strong>（抽象组件或复用既有组件）：</p><p style="text-align:justify">1.待复用的业务逻辑非常专业，如 Json 序列化、加解密；</p><p style="text-align:justify">2.相同或相似业务语义的代码已经存在多（3）处，需要重构；</p><p style="text-align:justify">3.待选的可复用组件文档非常全面，易于接入、拓展、替换或移除；</p><p style="text-align:justify">4.业务逻辑变更频繁，每次变更需要同时变更多个系统或模块以保持同步；</p><p style="text-align:justify">5.需要即时共享且对不一致性容忍度较低的一些业务逻辑单元，如表的元信息。</p><p style="text-align:justify"><strong>可能无需复用的场景</strong>（那就再造一个轮子吧）：</p><p style="text-align:justify">1.没有文档，或文档质量较差；</p><p style="text-align:justify">2.重复造一个不太难，同时维护成本较低；</p><p style="text-align:justify">3.只使用了可复用组件所有功能里的很少一点逻辑；</p><p style="text-align:justify">4.要花费大量的时间去了解可复用组件的设计思路；</p><p style="text-align:justify">5.可复用组件在拓展新功能时，需要投入大量的精力去协同推进；</p><p style="text-align:justify">6.可复用组件集成时的适配或拓展代码，比单独重写该组件的代码还要多；</p><p style="text-align:justify">7.可复用的组件是整个应用的核心，且后续业务发展迅速有较多的定制需求；</p><p style="text-align:justify">8.可复用组件的产品文档或系统设计中承诺了太多的功能（饼），过于「雄心勃勃」；</p><p style="text-align:justify">9.最后一点：如果决策时觉得可用可不用，那大概率也是不需要复用的，相信自己的第一判断。</p><p style="text-align:justify">通过成本和收益估算，以及若干启发式的决策经验，大多数的场景我们都可以评估得到一个清晰的是否复用的答案。软件复用可能会在短期内提高生产力，但它可能会产生长期后果，所以这一步需要慎之又慎。</p><span id="OSC_h4_15"></span><h4><strong>4.2 事中缓释：HCLC&amp;测试&amp;文档</strong></h4><p style="text-align:justify">事中缓释阶段是控制复用性风险的核心环节，它主要聚焦在可复用组件的开发阶段，通过一系列的关键步骤将复用风险在开发或正式使用前尽可能地降低，主要包括下面几个要点：</p><ul><li>高内聚低耦合</li><li>单元测试和回归测试</li><li>完整且有效的文档化</li></ul><p style="text-align:justify"><strong>高内聚低耦合（HCLC）。</strong>这是一个老生常谈的事情了，内聚和耦合会影响可复用水平中的多个指标，如是否内聚会影响可读性和可迁移性，耦合会影响可维护性、可迁移性和可读性。软件工程中已经有很多设计原则或模式供我们选择了，如在代码开发阶段，优先组合、依赖倒置、里式替换、接口隔离、单一职责、开放封闭、23 种设计模式等，在架构设计阶段，也有若干的架构设计模式或方法论，如分层、CQRS、异步事件驱动、领域驱动设计等。</p><p style="text-align:justify"><strong>完整且有效的文档。</strong>「好的代码是自解释性的」，这句话不完全对。首先，无论是我们的架构设计抑或是代码设计，很多东西是无法在代码中体系出来的，如对于领域抽象的取舍、决策的思考过程等，即便是我们的的接口、成员变量、实现，其命名和设计过程已经到了一个非常高的水平，代码中「隐藏信息」还是会损失，而注释可以尽可能去弥补这部分损失。其次，需要认识到：人类的感知与沟通速度是很慢且低效的，需要通过文档去填补双方沟通时的这一道鸿沟。当然，这里讨论的是一般情况，依托「无文档化」构建核心「竞争力」的行为模式不应归入此类。最后，一个正常的组织，人员是会流失的，大部分人最终都会离开这个组织，可复用组件的关键设计者如果不在组织里了，这种知识性的损失将是永久性的，文档（注释、设计）起到了一个备份领域知识的作用。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-865f007635a00f99fa6fbed28bc1075e_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>单元测试和回归测试。</strong>复用理论之所以成立，出发点是我们希望使用已经存在的、成熟的软件资产来提升研发效率，同时降低系统缺陷，一套全面的自动化回归测试，不仅有利于集成方，也会让后续和此可复用组件相关的每一个人受益。如果我们开发的可复用组件没有自动化的回归测试，那这样的组件是不合格的，是不应该发布公共仓库的。缺少自动化测试或核心流程自动化测试覆盖度较低的组件，对于集成方和组件后续的维护者来说是一场灾难，它给系统引入的巨大的技术债甚于完全没有配套文档的可复用组件。</p><span id="OSC_h4_16"></span><h4><strong>4.3 事后迭代：捕捉领域变化&amp;组织</strong></h4><p style="text-align:justify">在开发可复用组件时，如果一开始就大刀阔斧地投入研发资源，最终可能会创建与直接需求无关的软件资产，并由于设计、开发和测试时间的增加而产生重大的进度风险，相反，通过多次迭代改进可复用组件来降低这些风险，<strong>一个良好的组件、框架和软件架构需要时间来设计、实现、优化、验证、应用、维护和增强。</strong>与此同时，第一阶段的开发和集成结束后，在迭代的过程中进行持续性的风险管理，可以使得可复用组件的风险保持在一个较低的水位，尽可能地延长组件的生命力，需要做的主要事项包括：持续捕捉领域变化以及相应的组织支持。</p><p style="text-align:justify"><strong>捕捉领域变化。</strong>上面提到了，代码中有部分内隐的知识，事实上，<strong>一个可复用的组件就是开发者对于某个领域思考的结果</strong>，无论它是以类文件、模块还是系统的方式呈现。而领域都是会变化的，变化包括：领域的边界会拓展、领域内部分实体内涵会变化、不同领域之间的边界会重叠或者融合等。领域变化后，如果在这其中的可复用组件没有进行适当的调整，就会出现技术和业务配速失效的问题。可复用组件在封装了领域知识的同时，也一定程度上屏蔽了复杂度，当组件不足以承担起领域的实体或功能出现偏差时，就会出现「复杂度泄漏」的问题。</p><p style="text-align:justify">捕捉域变化的两个关键动作：统一领域上下文以及关注上游需求池。统一领域上下文重要性不言而喻，<strong>很多时候各方意见出现偏差的根本原因是大家没有形成统一沟通的语言，无法简单、准确且清晰地描述各自的诉求。</strong>我在进行某风险域架构治理时，做的第一件事情就是拉上了业产研三方，统一大家对「规则」和「策略」两个概念的内涵和边界的认知。其次，开发人员和架构师需紧密关注需求池，从需求本身出发，区分领域中可变性和通用性的关键来源。识别出问题域中的所有变化是不现实的，我们可以关注一些关键问题，如面对一个新的需求，可以考虑：</p><p style="text-align:justify">1.我们讨论的概念是否一致？</p><p style="text-align:justify">2.该需求涉及哪些领域实体？</p><p style="text-align:justify">3.该需求是否需要有我们新增实体？</p><p style="text-align:justify">4.新增实体是否会与既有实体产生二义性？</p><p style="text-align:justify">5.之前是否存在类似的需求？有什么不同？</p><p style="text-align:justify">6.新增的需求是否可以和既有的逻辑进行隔离？</p><p style="text-align:justify">7.......</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-b4a6ff6154f2348778fd424cd86b6cfc_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">是否有一种指导原则，可以让我们在跟踪这些域变化的时候，进行更合理的设计与取舍呢？熵增原理告诉我们：一个孤立的热力学系统的熵不减。对于系统的可逆过程熵不变，不可逆过程熵增加。因此，类比软件工程领域，在组件的事后迭代阶段，<strong>一个尽可能消除代码设计/软件架构中熵增的设计原则：在既有组件中新增的功能点需要存在逆向的删除机制</strong>，这样就可以尽可能让可复用组件跳出逐渐混乱无法维护的宿命。功能可逆的具体操作具体可以表现为：SPI 机制（Service Provider Interface ）、面向接口的编程、通过模块隔离随机的或一次性的需求等。</p><p style="text-align:justify"><strong>组织和配套的文化。首先，组织是业务架构的投射</strong>，当复用组件内的领域实体和组织负责的领域实体出现偏差时，就会出现因错位产生的技术债，结果无非是两种：一种是之前的可复用组件直接被抛弃，任由其自生自灭；另一种缺少破釜沉舟进行重构勇气与担当，既然不是我负责的，那就改一改重新用，原先统一均衡的结构会快速打破。<strong>其次，可复用组件和框架的好坏取决于构建和使用它们的人</strong>，我们需要能评估风险和机遇的管理者，需要能识别领域本质复杂度和偶然复杂度、同时能很好掌握设计模式和架构模式的架构师，以及，在开发原则、模式和实践上经验丰富的开发人员，组件是否可复用、可以复用多久，很大程度上是具备良好设计和经验丰富的开发人员的副产品。<strong>再者，在事后迭代阶段，我们需要专门的团队或负责人为此可复用资产负责</strong>，不断监控平台代码库的健康，跟踪和修复错误，坚持正确抽象，不断完善文档。当然上述只是理想情况，更多的时候，这样的人或团队是不存在的，或者即便存在，相应的组织激励也是缺失的，在一个没有复用的文化土壤中，组件腐化只是时间问题。最后，有了正确的组织和优秀的人，长期的<strong>信心、热情、激励以及管理层的支持与响应</strong>，也都是成功的复用必不可少的条件。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-2228938440622697c56b0d0ace934f73_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h3_17"></span><h3>五、关于复用的一点感想</h3><p style="text-align:justify">本文想重点去表达的几个观点：不要过度去追逐「复用」、可复用的水平以及复用投入产出比是可量化的、可复用资产是内隐的领域知识、适度的重复也是可接受的、文档可以弥补领域知识的损失、架构演进中新增功能需可逆。</p><p style="text-align:justify">撰写此篇文章的初衷，一方面源于近几年来在指导新同学时，发现出现较多的「伪复用」现象，例如为了减少代码，将共享的方法签名放在接口中，形成「过程式接口」，另一方面，自己也写过一些「为了复用」而设计的组件或模块，从中间件到业务组件大概有十几个了。但最近逐渐开始意识到，很多时候为了后续的可迁移性，一些架构或代码层的的前向防御性设计作用并不大，过度抽象反而是给使用方造成了一些理解上的困难。到底哪些真的需要复用，哪些可以妥协，梳理完这篇文章后，坚定了一部分想法（例如全程文档化），也给一些既有观念做了纠偏。</p><p style="text-align:justify">上面也一直在传递一个观点，好的软件资产是一个优秀团队的副产品。当把复用的目光从软件聚焦到人，我们自己身上，哪些是可以复用的，哪些又是平台或组织赋予我们的？去除掉那些光怪陆离的虚幻部分，不可变的部分又有哪些？授权后的高价值专利算一种，其有效期为二十年。思考过程中沉淀可能算另一种，它们或多或少且阶段性地概述了当时的所思所想，无论内容是否全面、正确，也涂抹上了时光的颜色，这也是这篇文章产生的另一个动机。</p><p style="text-align:justify">作者｜齐光</p><blockquote><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fclick.aliyun.com%2Fm%2F1000373503%2F" target="_blank"><span style="color:#ff9900">点击立即免费试用云产品，开启云上实践之旅！</span></a></strong></blockquote><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1364680%3Futm_content%3Dg_1000382902" target="_blank">原文链接</a></strong></p><p style="text-align:justify"><strong>本文为阿里云原创内容，未经允许不得转载</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 04 Nov 2023 02:51:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10140476</guid>
            <link>https://my.oschina.net/yunqi/blog/10140476</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[因使用过时 jQuery 版本，7.5 亿个网站存在隐私和安全风险]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">OpenJS 基金会<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjsf.org%2Fannouncement%2F2023%2F11%2F01%2Fopenjs-foundation-warns-consumer-privacy-and-security-at-risk-in-three-quarters-of-a-billion-websites%2F" target="_blank">公布</a>了一项基于 IDC 调查的最终用户审计结果显示，十亿个网站中有四分之三的网站正在使用过时的软件，并且其中大多数网站都会收集个人和财务信息。超过三分之一的受访者证实，在过去 24 个月中曾经历过安全事件。</span></p><p><span style="color:#000000">OpenJS 基金会分析了本次最终用户审计的 IDC 调查结果和其他数据点，估计全球 19 亿个网站中有近 90% 使用开源软件 jQuery，其中 7.5 亿个站点需要升级。鉴于问题的严重性，OpenJS 基金会建议在 Web 安全性方面进行行为改变。</span></p><p><span style="color:#000000">「jQuery 使网页开发变得简单易用，但也导致数亿个网站仍然使用旧的、不受支持的版本。即使 jQuery 团队发布安全修复，这些网站通常也不会进行更新，从而导致容易受到攻击。」</span></p><p><span style="color:#000000">主要发现包括：</span></p><ul><li><span style="color:#000000">89％的随机调查受访者报告称，他们知道自己的互联网面向的网站上使用了 jQuery。</span></li><li><span style="color:#000000">其中 80％ 的组织会捕获个人身份信息 (PII) 等重要信息，包括付款信息 (52%)、位置 (64%)、联系信息 (80%)。</span></li><li><span style="color:#000000">85％的受访者认为，网站是必不可少或极其重要的。</span></li><li><span style="color:#000000">安全事件造成的业务损失严重，28％的受访者表示有客户流失，29％的受访者表示造成了收入损失。此外还有 39% 的受访者报告了违规行为，45% 的受访者报告了品牌受损。</span></li><li><span style="color:#000000">48% 的受访者表示，提升安全性是升级的首要动机。</span></li></ul><p><span style="color:#000000">IDC 软件开发和开源 IDC 集团副总裁 Al Gillen 称：「这项研究给我们带来的启示很简单：jQuery 用户可以使用一项强大的、由社区支持的技术，他们无需支付订阅费用即可获得或使用这项技术，而且这个项目还在不断得到投资和改进。用户已经从这项技术中享受到了可观的收益，但如果你还没有使用最新版本，那么为了你的业务，你有义务升级到一个受支持版本，以实现收益最大化和潜在风险最小化。」</span></p><p><span style="color:#000000">OpenJS 基金会执行董事 Robin Bender Ginn 则表示，「当十亿个网站中有四分之三仅仅因为一个开源项目而需要升级时，问题就大了。这让我们相信，公司正在使用更过时和不受支持的技术，有可能将消费者置于风险之中。要解决如此大规模的问题，我们需要开始考虑定期评估网站技术，就像人们每年都去医生那里做体检一样。」</span></p><p><span style="color:#000000">为此，OpenJS 基金会正在开发一款免费的 Healthy Web 检查工具，以广泛提供给世界各地的企业和组织。该检查工具只需耗时 5 秒，但目前仅可用于检查 jQuery 的版本，OpenJS 基金会计划接下来将其扩展到更多网络健康相关的开源 JavaScript 项目。</span></p><p><span style="color:#000000">jQuery 核心团队成员兼高级软件工程师 Michał Gołębiowski-Owczarek 也呼吁称，改善网站健康状况的第一步是确定该的技术堆栈是否需要升级。在团队不断地改进 jQuery 的安全性和性能的同时，也建议大家使用 Healthy Web checkup 工具或自己的评估工具来检查网站上使用的软件版本。</span></p><p><span style="color:#000000">OpenJS Healthy Web 检查工具目前处于 beta 阶段，仅限技术评估人员和 OpenJS 成员使用，计划于 2024 年初全面推出。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 07:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264791/openjs-foundation--websites-risk-jquery</guid>
            <link>https://www.oschina.net/news/264791/openjs-foundation--websites-risk-jquery</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[【SIG 月报】10 月 openKylin 社区 SIG 组最新进展分享]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span><span style="color:#000000">为推动社区繁荣发展，打造开源操作系统创新生态，openKylin 社区围绕创新硬件、人机交互、智能支撑、终端安全、互联协同、云端融合等多个技术领域，以技术小组的形式开展深入研究和技术创新。接下来，让我们一起盘点 10 月份 openKylin 社区 SIG 组的最新进展：</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#4f9eff">10 月社区新增 SIG</span></span></strong></span></p><p>10 月社区新增 4 个 SIG 组，目前已累计成立 90 个 SIG 组，新增 SIG 组信息如下：</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><strong><span style="color:#ff9b0e"><span style="background-color:#f5faff">01</span></span><span style="color:#1c9cee"><span style="background-color:#f5faff">H2CHAIN SIG</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000"><span style="background-color:#f5faff">H2CHAIN 由华夏好瑞（天津）科技有限公司发起成立。H2CHAIN（海河信创链）致力于搭建大规模异构区块链互通互联的高性能平台，丰富 openKylin 区块链应用场景。</span></span></span></p><ul><li><span><span style="color:#000000">SIG 主页：</span></span></li><li><span><span style="color:#0052ff">https://gitee.com/openkylin/community/tree/master/sig/H2CHAIN</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><strong><span style="color:#ff9b0e"><span style="background-color:#f5faff">02</span></span><span style="color:#1c9cee"><span style="background-color:#f5faff">Cinnamon SIG</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000"><span style="background-color:#f5faff">Cinnamon 是一个易上手的，高度可定制的桌面环境，深受 Linux 爱好者喜爱。Cinnamon SIG 组由社区爱好者发起成立，负责移植 Cinnamon 桌面环境，让其在 openKylin 拥有完美的体验。</span></span></span></p><ul><li><span><span style="color:#000000">SIG 主页：</span></span></li><li><span><span style="color:#0052ff">https://gitee.com/openkylin/community/tree/master/sig/Cinnamon</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><strong><span style="color:#ff9b0e"><span style="background-color:#f5faff">03</span></span><span style="color:#1c9cee"><span style="background-color:#f5faff">LXQt SIG</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000"><span style="background-color:#f5faff">LXQt 是一个轻量级的桌面环境，使用 Qt 作为图形界面库，支持多种窗口管理器，如 Openbox、Xfwm4 或 KWin 等。LXQt SIG 组由社区爱好者发起成立，负责移植 LXQt 桌面环境，为 openKylin 提供一个快速、美观、易用的桌面环境，同时保持低资源占用和高可定制性。</span></span></span></p><ul><li><span><span style="color:#000000">SIG 主页：</span></span></li><li><span><span style="color:#0052ff">https://gitee.com/openkylin/community/tree/master/sig/LXQt</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><strong><span style="color:#ff9b0e"><span style="background-color:#f5faff">04</span></span><span style="color:#1c9cee"><span style="background-color:#f5faff">MakerFrame SIG</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000"><span style="background-color:#f5faff">MakerFrame SIG 组由社区爱好者发起成立，负责为 openKylin 开发简单高效的游戏框架引擎，致力于让专业人士和非专业人士都来开发跨平台的游戏和应用，大力促进 openKylin 游戏生态推广。</span></span></span></p><ul><li><span><span style="color:#000000">SIG 主页：</span></span></li><li><span><span style="color:#0052ff">https://gitee.com/openkylin/community/tree/master/sig/MakerFrame</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#4f9eff">10 月社区 SIG 活跃度汇总</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">10 月社区新增有效 PR 数 411 个、仓库 Fork 数新增 550 个，SIG 组公开例会召开 10 次。截至目前，社区累计有效 PR 数 11517 个、仓库 Fork 数 4452 个、SIG 组公开例会召开 102 次，其中：</p><ul><li><span><span style="color:#000000">10 月社区 SIG 组 PR 贡献 top15 如下：</span></span></li></ul><div><p style="text-align:center"><img height="537" src="https://oscimg.oschina.net/oscnet/up-52c4cf042b90758cb944f6bb2cdd076db70.png" width="794" referrerpolicy="no-referrer"></p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">10 月社区 SIG 组活跃地图分布情况（颜色越深代表越活跃，参考维度：PR、issue、SIG 会议）如下：</span></span></p><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-0aa7f9b3b5d67f3ce0208dec81b09816e3a.png" referrerpolicy="no-referrer"></p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#4f9eff">10 月社区技术进展与成果</span></span></strong></span></p><h1>一、UKUI SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">UKUI（Ultimate Kylin User Interface）SIG 小组致力于桌面环境相关软件包的规划、维护和升级工作，满足各种设备和用户需求的桌面环境程序，主要包含程序启动器（开始菜单）、用户配置、文件管理、登录锁屏、桌面、网络工具、快捷配置等，为用户提供基本的图形化操作平台。桌面核心组件开发工具以 Qt、C++为主，宗旨是始终如一地提升系统的操作体验，提供集稳定性、美观性、流畅性和便捷性为一体的桌面环境。10 月进展如下：</span></span></p><ul><li><span><span style="color:#000000">【任务栏 4.X】托盘区分类、非合并状态图标拖拽及动画功能实现；</span></span></li><li><span><span style="color:#000000">【任务栏 4.X】全局配置加载逻辑优化；</span></span></li><li><span><span style="color:#000000">【USD】新增多媒体控制协议实现及接口；</span></span></li><li><span><span style="color:#000000">【小插件框架】新增对配置文件目录的文件监听功能；</span></span></li><li><span><span style="color:#000000">【元数据】新增 png 格式元数据解析，新增 ocr 解析异常处理；</span></span></li><li><span><span style="color:#000000">【quick-items】新增调整访问系统调色板和字体的方式，添加适配 UKUI 风格的窗口；</span></span></li><li><span><span style="color:#000000">【托盘网络】单网卡场景显示策略优化 ；</span></span></li><li><span><span style="color:#000000">【主题框架】主题框架优化部分控件背景和样式；</span></span></li><li><span><span style="color:#000000">【侧边栏】优化侧边栏快捷配置面板进出动；</span></span></li><li><span><span style="color:#000000">【搜索】新增命令行查询索引状态&amp;进度功能、托盘右键功能和 OCR 开关和内容索引开关询问弹窗；</span></span></li><li><span><span style="color:#000000">修复系统监视器、控制面板电源搜索、侧边栏唤出和隐藏异常等相关问题；</span></span></li><li><span><span style="color:#000000">完成与 openEuler FT 团队线下 meetup 技术分享会。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎各位感兴趣的社区开发者加入我们，一起打造 openKylin 桌面系统稳定易用的桌面环境！</span></span></p><h1>二、RISC-V SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#333333">本</span>SIG 组主要负责 RISC-V 架构开源软件包的维护，发布 openKylin 的 RISC-V 版本，进行软件包构建、系统构建等工作。10 月 RISC-V SIG 组进展如下：</span></p><ul><li><span><span style="color:#000000">解决鉴释平板触屏问题，制作平板的新镜像；</span></span></li><li><span><span style="color:#000000">编译荔枝派 1.2.1 版本 sdk，解决 GPU 适配问题，完成了镜像内核 moudle，GPU 驱动，mesa 库等移植工作，构建新版本荔枝派镜像；</span></span></li><li><span><span style="color:#000000">构建 RISC-V 专属 PPA，用于后续 RISC-V 定制包版本编译及镜像发行；</span></span></li><li><span><span style="color:#000000">解决算能新开发板的启动问题，制作新镜像；</span></span></li><li><span><span style="color:#000000">开始编写根据 RISC-V 硬件类型修改镜像中配置的包 kylin-riscv-hardware-config，后续可以通过装包的方式实现各硬件镜像的快速配置；</span></span></li><li><span><span style="color:#000000">成功集成 RISC-V 版本 nim 语言开发编译环境到 RISC-V 专属 PPA；</span></span></li><li><span><span style="color:#000000">调研从上游源代码编译包至镜像制作的全流程，初步具备 RISC-V 版本镜像独立发行的能力；</span></span></li><li><span><span style="color:#000000">二进制翻译针对 Wine 与 steam 添加对应的包装函数，如 vulkan 插件集，OpenCL 及其内存操作相关函数。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对 RISC-V 开发平台技术方向感兴趣的爱好者加入到 RISC-V SIG！</span></span></p><h1>三、Release SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">Release SIG 主要负责协调各个 SIG 组，把控版本开发进度和风险，制定版本发布计划，完成版本发布工作等。Release SIG 10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">推动 openKylin 2.0 基础库组件选型、新特性需求开发进展，新需求评审等；</span></span></li><li><span><span style="color:#000000">完成 openKylin 2.0 pre-alpha1 构建，处理版本构建问题；</span></span></li><li><span><span style="color:#000000">推动 openKylin 遗留缺陷 issue 修复，集成 1023 版本提测。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对 openKylin 社区版本集成、版本管理、版本发行等工作感兴趣的爱好者加入到 Release SIG！</span></span></p><h1>四、Packaging SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">Packaging SIG 负责维护 openKylin 社区的软件包打包规范，维护公共软件包，以及协调和决策社区版本发布过程中的包依赖问题。10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">Sogou-ime-ng 闭源组件包上传；</span></span></li><li><span><span style="color:#000000">openKylin 中科睿芯 rv64g 非压缩指令集架构仓库创建，chroot 制作调试；</span></span></li><li><span><span style="color:#000000">openKylin 2.0 AI 软件包选型分析，编译部署方式调研；</span></span></li><li><span><span style="color:#000000">测试评审任务发布平台-生态软件适配任务提交的构建成果；</span></span></li><li><span><span style="color:#000000">2.0 基础库软件 systemd 依赖包选型构建：[nile] json-c(0.15-ok1), cryptsetup(2:2.4.3-ok1); 构建 2.0 基础库软件 network-manager 的依赖包 netplan.io，并解决编译问题；</span></span></li><li><span><span style="color:#000000">nvidia-driver-510 安装问题分析解决；</span></span></li><li><span><span style="color:#000000">openkylin-2.0-pre-alpha1 预编译版本报错，缺少"dhcpcd-base、dracut-install"，新构建软件包 dhcpcd，dracut。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对 openKylin 社区软件自主选型、编译打包工作感兴趣的社区爱好者加入我们！</span></span></p><h1>五、QA SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">QA SIG 组致力于提升 openKylin 社区版本质量，包括社区版本测试、质量保障等。10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">审核 1.0.1 发布版本用户反馈 issue 50+条；</span></span></li><li><span><span style="color:#000000">openKylin 2.0 版本测试：</span></span></li><li><span><span style="color:#000000">1）UKUI4.10 需求测试用例编写：共 120 个需求需要进行用例编写，已完成 14 个，整体进度：18.3%；</span></span></li><li><span><span style="color:#000000">2）输出 2.0 版本测试计划；</span></span></li><li><span><span style="color:#000000">3）openKylin-1.0.1-1023 周版本测试，截止目前回归 bug25 个，通过 18 个，失败 3 个，阻塞 4 个，整体进度 40%。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对 openKylin 社区版本测试、质量管理感兴趣的社区爱好者加入我们！</span></span></p><h1>六、SecurityGovernance SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin SecurityGovernance SIG 通过接收和响应 openKylin 社区的产品安全问题报告、提供社区安全指导，开展安全治理等活动提升社区产品的安全性。10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">Genmai 项目：完成 C/S 架构开发，实现根据服务器版本自动更新功能，解决传输数据耗费时长过程而导致失败的问题；</span></span></li><li><span><span style="color:#000000">Genmai 项目：完善 PDF 报告格式优化功能；</span></span></li><li><span><span style="color:#000000">Genmai 项目：编制项目技术白皮书，发布 TS 版的技术白皮书；</span></span></li><li><span><span style="color:#000000">Genmai 项目：新增安全基线检测项 100+；</span></span></li><li><span><span style="color:#000000">Genmai 项目：优化 106 个 POC 检测的输出内容；</span></span></li><li><span><span style="color:#000000">Genmai 项目：新增集成 POC 测试用例 14 个；</span></span></li><li><span><span style="color:#000000">Genmai 项目：研发了 CVE-2023-4911、CVE-2023-38545、CVE-2022-2602 POC 三个；</span></span></li><li><span><span style="color:#000000">Genmai 项目：验证使用了 docker 容器运行内核 POC 的破坏性，调研内核漏洞检测的可行性；</span></span></li><li><span><span style="color:#000000">解决 C/S 架构数据返回接口异步故障的问题。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对 openKylin 版本安全全漏洞挖掘/验证、安全漏洞修复等安全方面工作感兴趣的社区爱好者加入我们！</span></span></p><h1>七、OpenSDK SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">OpenSDK SIG 组负责开发者套件（base、system、applications）规划、开发、维护等工作，致力于解决应用在多操作系统中的兼容性问题。10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">扩展了处理器、内存、网络等详细信息获取接口；</span></span></li><li><span><span style="color:#000000">新增账户管理模块，包含创建用户、修改密码、用户名校验等功能；</span></span></li><li><span><span style="color:#000000">新增 sdk release note；</span></span></li><li><span><span style="color:#000000">规范了 SDK 的动态库存放路径。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对开发者套件感兴趣的社区爱好者们加入 OpenSDK SIG 组！</span></span></p><h1>八、CompatWinApp SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">CompatWinApp SIG 组致力于将大量的 Windows 系统应用程序引入到 openKylin 系统。SIG 组将通过研究应用兼容技术和指令翻译技术，研制完善的 Windows 应用兼容方案，让更多的 Windows 应用能兼容运行于 openKylin 系统，不断繁荣 openKylin 软件生态。10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">修复 Wine 助手下载程序页面无法点击其他链接的问题，改为弹出提示框，提示用户点击其他链接可能出错；</span></span></li><li><span><span style="color:#000000">修复当应用下载链接更新时无法下载的问题，改提示用户下载新版本软件还是旧版本软件；</span></span></li><li><span><span style="color:#000000">修复 wine riched20 中导致微信输入框光标异常，滚轮失效的问题；</span></span></li><li><span><span style="color:#000000">为 win-program 仓库开发分支上 1000 多个应用配置文件增加下载详情页参数；</span></span></li><li><span><span style="color:#000000">Wine 助手在 openKylin 社区开源事项通过内部审核，代码已上传 wine-assistant 仓库，累计有效代码约 8000 行；</span></span></li><li><span><span style="color:#000000">开发 Wine 助手帮助文档功能；</span></span></li><li><span><span style="color:#000000">openKylin Wine 助手发布公测。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对应用兼容技术和指令翻译技术感兴趣的爱好者加入到 CompatWinApp SIG！</span></span></p><h1>九、Infrastructure SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">Infrastructure SIG 负责 openKylin 社区的基础平台系统功能的开发、维护。10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">openKylin 看板功能增强，增加仓库大小、代码总行数统计；</span></span></li><li><span><span style="color:#000000">openKylin 看板相关问题修复，贡献者数据、PR 数据统计等；</span></span></li><li><span><span style="color:#000000">openKylin 看板修复当仓库默认分支为 null 时新增仓库数据到数据库报错问题；</span></span></li><li><span><span style="color:#000000">门禁检查增加合规性检查。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对 openKylin 社区基础设施平台开发维护感兴趣的爱好者加入到 Infrastructure SIG！</span></span></p><h1>十、Security SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">Security SIG 负责研制操作系统安全防护技术和功能，提供并维护操作系统安全防御机制。针对目前 openKylin 开源版本中的安全功能、安全组件等软件包进行维护和 cve 修复；并结合目前 Linux 平台上的一些安全技术进行研究、开源安全软件进行维护和研制、Linux 系统中的安全加固方案进行工具化设计和研制。10 月份 SIG 组进展如下：</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#000000">openKylin 2.0 需求研制：</span></span></p><ul><li><span><span style="color:#000000">【身份认证】国密支持、账户安全：</span></span></li><li><span><span style="color:#000000">1）openKylin 社区身份认证添加国密支持，本地编包功能验证通过，待提交 gitee；</span></span></li><li><span><span style="color:#000000">2）libxcrypt 添加 sm3 支持，已提交代码，已合入；</span></span></li><li><span><span style="color:#000000">3）pam 添加 sm3 支持，pam 修改正在调试中；</span></span></li><li><span><span style="color:#000000">【强访】添加 RISC-V 系统调用审计支持：调试 audit 包 riscv64 架构编译问题。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对安全技术感兴趣的社区爱好者加入 Security SIG 组！</span></span></p><h1>十一、GPU SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin GPU SIG 组致力于 GPU 驱动相关技术研究，包括 OpenGL、OpenCL、Vulkan、VDPAU 和 VAAPI 等，提供 GPU 相关软件包的技术规划、设计、开发、维护和升级服务，共同推动国产 GPU 技术发展。GPU SIG 组 10 月份进展如下：</span></span></p><ul><li><span><span style="color:#000000">完成景美 JM9100 显卡驱动适配 openKylin 系统，完成 patch 提交、评审、合并等工作。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对 CPU 驱动、国产 GPU 技术、显示等相关领域感兴趣的社区小伙伴加入 GPU SIG 组！</span></span></p><h1>十二、TrustedComputing SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#000000">可信计算兴趣组（Trusted Computing SIG）主要目标是致力可信计算基础软件开源与优化，并提供可信计算相关的应用规范与接口，探索国内外可信计算技术的应用实践。10 月份 SIG 组进展如下：</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#000000">openKylin 2.0 需求研制：</span></span></p><ul><li><span><span style="color:#000000">可信软件栈：本地进行 tpm2-tss、tpm2-abrmd 的验证打包。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#000000">欢迎所有对可信计算技术感兴趣的社区爱好者和开发者加入 TrustedComputing SIG 组！</span></span></p><h1>十三、I18n SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">I18N SIG 组负责 openKylin 社区国际化和本地化相关工作，包括多语言开发框架、多语言平台开发和维护，以及社区、版本内文档的翻译管理相关工作。10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">翻译官网新闻 7 篇。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对操作系统、网站网页、文档等翻译工作感兴趣的社区爱好者们加入 I18n SIG 组！</span></span></p><h1>十四、InputMethod SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">本 SIG 组致力于组建输入法开源社区，推进开源输入法框架及开源输入法在社区维护。10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">评审 OK 输入法设计文档，包括引擎设计文档和 UI 设计文档；</span></span></li><li><span><span style="color:#000000">讨论输入法通用插件 SDK，以减少输入法厂商适配难度；</span></span></li><li><span><span style="color:#000000">解决优麒麟系统默认集成搜狗输入法问题，提升使用优麒麟系统的用户输入体验；</span></span></li><li><span><span style="color:#000000">向 fcitx 社区贡献关于虚拟键盘 Callback 的 pr，支持第三方开发虚拟键盘；</span></span></li><li><span><span style="color:#000000">向 fcitx 社区贡献关于 UKUI 环境判断的 pr，支持 fcitx 诊断工具识别 UKUI 桌面环境。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对 openKylin 社区 fcitx 输入法框架、桌面虚拟键盘开发工作感兴趣的社区爱好者加入我们！</span></span></p><h1>十五、Kernel SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">Kernel SIG 组致力于新硬件适配、新功能、新特性开发。不断提升内核健壮性、稳定性，能更好的为 openKylin 系统和应用程序提供底层技术支持。10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">6.1 内核从 6.1.55 更新到 6.1.59。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对内核感兴趣的社区小伙伴加入 openKylin 社区 Kernel SIG 组！</span></span></p><h1>十六、Virtualization SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">Virtualization SIG 组致力于构建 openKylin 社区系统虚拟化技术，打造面向端、边、云的全场景虚拟化解决方案。10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">qemu:修复丢失的 cq eventidx 更新。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对虚拟化组件或软件包技术感兴趣的社区小伙伴加入 openKylin 社区 Virtualization SIG 组！</span></span></p><h1>十七、Framework SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">本 SIG 组致力于为 openKylin 社区提供集程序编辑、编译、调试、发布、分析等全套开发功能的编程环境，涵盖通用集成开发环境、编译工具链、运行时环境、类库等，10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">maven 插件，gradle 插件， clangd 插件，死锁检测插件，cmake 插件，java 插件等完善中英文 readme；</span></span></li><li><span><span style="color:#000000">离线插件管理器增加刷新插件列表，以及主动关闭插件预览信息的按钮；</span></span></li><li><span><span style="color:#000000">clangd 插件修复 shift-f1 跳转到文档功能提示安装插件的问题；</span></span></li><li><span><span style="color:#000000">java 依赖管理添加远程开发模式下，导出 jar 包成功，屏蔽打开 Jar 包按钮；</span></span></li><li><span><span style="color:#000000">ide-gitlens 插件修复同时安装上游 gitlens 插件和本插件的情况下报错问题；</span></span></li><li><span><span style="color:#000000">项目管理插件：添加 deb 源码打包功能；修复 war 打包，针对带有括号的特殊工程打包失败的错误；修复创建项目、deb、rpm 打包字段检查逻辑和输出问题；优化界面输入框行高与对齐问题；修复创建项目默认路径问题；完善 depends.json。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎对集成开发环境研发感兴趣的社区开发者和爱好者加入 Framework SIG！</span></span></p><h1>十八、RTHypervisor SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">RTHypervisor SIG 小组致力于实时虚拟化技术的研究，目前主要包括 Jailhouse，提供工控、车载等领域实时控制的虚拟化解决方案，Jailhouse 项目 10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">新增 arm64 平台上基于 INTx 中断的 pci 设备隔离，实现了 pci 设备在 jailhouse 下的透传功能。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎所有对 openKylin 社区实时虚拟化技术感兴趣的社区爱好者加入我们！</span></span></p><h1>十九、SystemService SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">系统服务小组致力于服务管理的技术研究，提供系统基础组件的集合和服务管理，提供稳定的系统底层环境。10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">openKylin-2.0 systemd 编包工作，完成 upstream、pristine-tar、openkylin/nile 以及 packaging/openkylin/nile 分支代码整理工作；</span></span></li><li><span><span style="color:#000000">修复编译错误，完成 amd64、arm64、riscv64 架构的编译。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#000000">欢迎社区对基础能力搭建感兴趣的开发者或爱好者加入我们！</span></span></p><h1>二十、FAQ SIG</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">FAQ SIG 小组致力于收集各渠道社区开发者、爱好者等用户反馈的问题，并建立相关标准化流程推动问题解答或解决同时，在这一过程中不断为 openKylin 社区积累 FAQ 知识库。10 月主要进展如下：</span></span></p><ul><li><span><span style="color:#000000">收集论坛、社群高频问题并提交 issue 指派给开发；</span></span></li><li><span><span style="color:#000000">调查部分用户硬件驱动适配情况，提交 issue 指派解决网卡驱动适配问题；</span></span></li><li><span><span style="color:#000000">收集用户针对桌面环境的建议并反馈给 UKUI SIG。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">欢迎社区热心、善于解答问题的小伙伴加入 FAQ SIG 组！</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#4f9eff">关于 openKylin 社区 SIG</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>openKylin（开放麒麟）社区是一个自由开放的社区，社区中所有的 SIG 小组都是开放的，任何人和组织都可以参与。你可以选择加入已有 SIG，也可以选择创建新的 SIG。截至目前，openKylin 社区已有<strong>90</strong>个 SIG 在运行，包括 Architecture、Infrastructure、Release、Kernel、Security、Compatibility 等。</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#4f9eff">关于 openKylin 社区</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>openKylin（开放麒麟）社区旨在以「共创」为核心，在开源、自愿、平等、协作的基础上，通过开源、开放的方式与企业构建合作伙伴生态体系，共同打造桌面操作系统顶级社区，推动 Linux 开源技术及其软硬件生态繁荣发展。</span></p><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span><span style="color:#000000">社区理事成员单位包括麒麟软件、普华基础软件、中科方德、麒麟信安、凝思软件、一铭软件、中兴新支点、元心科技、中国电科 32 所、技德系统、北京麟卓、先进操作系统创新中心、飞腾、兆芯、龙芯中科、景美、京东科技、平头哥、申泰信息、海光等 21 家产业同仁和行业机构。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 06:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264771</guid>
            <link>https://www.oschina.net/news/264771</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[深言科技联合清华大学 NLP 实验室开源 LingoWhale-8B 模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">深言科技与清华大学 NLP 实验室共同研发的语鲸 LingoWhale-8B 模型已面向社会开源。</span></p><p style="margin-left:0; margin-right:0"><span style="color:#000000">深言科技（DeepLang AI）由清华大学计算机系自然语言处理实验室（THUNLP）与北京智源人工智能研究院（BAAI）共同孵化，是国内最早开展大模型研发与探索大模型落地的创业公司之一。公司创始团队曾深度参与智源·悟道大模型的研发，目前已发布产品包括世界首个中文及跨语言反向词典 WantWords、名句语义检索系统 WantQuotes、智能写作工具深言达意等。</span></p><p><span style="color:#000000">根据<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FDJ8saXn9wOhuK2v_x-lVSQ" target="_blank">介绍</a>，LingoWhale-8B 模型是拥有约 80 亿参数的中英双语大语言模型，在 C-Eval、MMLU、CMMLU 等多个权威的公开评测基准上，在 10B 以下开源模型中达到领先效果。</span></p><p>LingoWhale-8B 是深言科技与清华大学 NLP 实验室共同推出的语鲸系列大模型中首个开源的中英双语大语言模型。</p><p>LingoWhale-8B 模型在数万亿 token 的高质量中英数据上进行预训练，具有强大的基础能力，在多个公开评测基准上均达到领先效果。在预训练阶段，模型使用 8K 的上下文长度进行训练，能够完成更长上下文的理解和生成任务。LingoWhale-8B 模型对学术研究<strong>完全开放</strong>，开发者通过邮件申请并获得官方商用许可后，即可<strong>免费商用</strong>。</p><p>在开源模型权重的同时，项目团队也提供了符合用户习惯的 Huggingface 推理接口以及 LoRA 等参数高效微调示例，便于开发者快速使用 LingoWhale-8B 模型。</p><p>受模型参数量影响，大模型固有的幻觉问题、数学计算能力相对较弱、生成内容有无法预见性等问题在 LingoWhale-8B 模型中仍然存在。因此建议在使用前了解这些问题，评估可能存在的风险。后续版本的语鲸大模型将会针对此类问题进行持续优化。</p><h4><strong>测评分析</strong></h4><p><span style="background-color:#ffffff"><span style="color:#3f3f3f">截至 10 月 24 日，在中文领域权威评测 C-Eval 中，</span></span><strong>LingoWhale-8B 模型的性能仅次于 GPT-4</strong><span style="background-color:#ffffff"><span style="color:#3f3f3f">。在 C-Eval、CMMLU、GAOKAO 测评中，性能超过 GPT-3.5Turbo，在 10B 以下尺寸模型中性能处于领先位置。</span></span></p><p><span style="background-color:#ffffff"><span style="color:#3f3f3f"><img alt="" height="122" src="https://oscimg.oschina.net/oscnet/up-61dd8a402d70f3fb6aec85b2fed702eeeb7.png" width="500" referrerpolicy="no-referrer"></span></span></p><p><strong><span style="color:#3f3f3f">一些示例：</span></strong></p><p><img alt="" height="500" src="https://oscimg.oschina.net/oscnet/up-333f791c81206afba4f06c2312f9341df88.png" width="269" referrerpolicy="no-referrer">&nbsp;<img alt="" height="501" src="https://oscimg.oschina.net/oscnet/up-9749d978fa111b77c07bdf07348dec30ef5.png" width="299" referrerpolicy="no-referrer"></p><p><img alt="" height="289" src="https://oscimg.oschina.net/oscnet/up-1ad6a289253e964f8715f8610900e858395.png" width="269" referrerpolicy="no-referrer">&nbsp;<img alt="" height="354" src="https://oscimg.oschina.net/oscnet/up-082b16c3e8e0198200f7aa32d91bcfda558.png" width="299" referrerpolicy="no-referrer"></p><p><img alt="" height="1087" src="https://oscimg.oschina.net/oscnet/up-c1b525b15cc376c23f24cd7500bd6fd3fa8.png" width="270" referrerpolicy="no-referrer">&nbsp;<img alt="" height="1087" src="https://oscimg.oschina.net/oscnet/up-5c686d13e35bbfc670e1c3fbad8b9824689.png" width="188" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 06:06:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264763</guid>
            <link>https://www.oschina.net/news/264763</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[国外 HR：如果看到简历有参与开源贡献的内容，直接扔掉]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>自称曾负责 FAANG（美国科技巨头）招聘工作的「猎头」在推特<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fallgarbled%2Fstatus%2F1719266732869886325" target="_blank">发表了如下内容</a></u>：</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1103/120614_vhOu_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>他表示自己在招人的时候，<strong>如果看到开发者的简历出现参与开源贡献的内容</strong>，会直接把简历扔掉。他认为，开发者有这么多的空闲时间来不求回报地写代码，对工作的投入程度能有多高？</p><p>他继续补充道：「对于初级开发者来说，他们参与开源可以理解。但对于高级开发者来说，这表明他们缺乏成熟度。」</p><p>最后他附上了自己拒绝别人求内推的截图：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-fb3a53178796db604e1b3319b0bf7346147.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 04:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264751</guid>
            <link>https://www.oschina.net/news/264751</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌放弃 Web Environment Integrity API 提案]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">谷歌<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid-developers.googleblog.com%2F2023%2F11%2Fincreasing-trust-for-embedded-media.html" target="_blank">宣布</a>放弃其备受争议的&nbsp;<span style="background-color:#ffffff">Web Environment Integrity API 提案，转而开发&nbsp;</span><span style="background-color:#ffffff">Android WebView Media Integrity API。</span></span></p><p><span style="color:#000000">今年 5 月份，谷歌在开发者邮件列表中宣布了其&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FRupertBenWiser%2FWeb-Environment-Integrity%2Fblob%2Fmain%2Fexplainer.md%23goals" target="_blank">Web Environment Integrity API</a><span style="color:#000000">，旨在作为一种限制在线欺诈和滥用的方法，同时不会引发跨站点跟踪或浏览器指纹识别等隐私问题。但却遭受了公众的强烈反对，认为其更类似于一种网站的数字版权管理（DRM）功能，担心谷歌借此限制网络自由。</span></p><p><span style="color:#000000">因此在收到众多反馈后，谷歌表示其&nbsp;<span style="background-color:#ffffff">Chrome 团队不再考虑&nbsp;Web Environment Integrity API；并将重点转向范围更窄的解决方案 Android WebView Media Integrity API，仅针对应用程序中嵌入的 WebView。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">根据介绍，这个新的 API 只扩展了具有 Google 移动服务 (GMS) 的 Android 设备上的现有功能，并且没有计划提供超出嵌入式媒体（例如流媒体视频和音频）或 Android WebView 之外的功能。</span></span></p><p><span style="color:#000000"><img height="248" src="https://oscimg.oschina.net/oscnet/up-79bb6dbdddd857c0a5caad36bd7b735e59e.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Android WebView API 允许应用程序开发人员显示嵌入媒体的网页，并增强对 UI 的控制和高级配置选项，以允许在应用程序中无缝集成。这为移动应用开发带来了很大的灵活性，但同时也为欺诈和滥用提供了途径；因为它允许应用程序开发人员访问网页内容，拦截或修改用户与网页的交互。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">新的 Android WebView Media Integrity API 旨在使嵌入式媒体提供商能够访问定制的完整性响应，其中包含设备和应用程序的完整性判定，以便他们能够确保他们的流媒体在安全、可信的环境中运行，无论嵌入式应用程序是从哪个应用程序商店安装的。</span></span></p><p><span style="color:#000000">谷歌方面计划<span style="background-color:#ffffff">在明年初，与选定的嵌入式媒体供应商一起试点实验性 Android WebView Media Integrity API。</span></span></p><p><span style="color:#000000">详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fandroid-developers.googleblog.com%2F2023%2F11%2Fincreasing-trust-for-embedded-media.html" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 04:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264883/google-abandons-web-environment-integrity-api</guid>
            <link>https://www.oschina.net/news/264883/google-abandons-web-environment-integrity-api</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[贵阳银行回应证实弃用易鲸捷]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#333333">知名打假人王海发文<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.toutiao.com%2Farticle%2F7297260518304219682%2F" target="_blank">表示</a>，</span><span style="background-color:#ffffff; color:#000000">11 月 2 日下午，贵阳银行董事长张正海在 2023 年第三季度业绩说明会上，回应证实了媒体报道的「贵阳银行弃用了贵州易鲸捷假国产数据库」。</span></p><p><span style="background-color:#ffffff; color:#000000">在与投资者互动和交流中，面对投资人提出的「易鲸捷在贵阳银行建设的数据库进展到什么程度？」的问题时。贵阳银行董事长张正海回答称，「贵阳银行新核心业务系统目前已经完成的开发测试工作，系统进入上线准备阶段，预计于 2023 年 11 月 3 日 17:00 至 11 月 6 日 8:00 进行系统的上线工作。」</span></p><p><img height="199" src="https://oscimg.oschina.net/oscnet/up-54c947b770fd5c4889d4ea002bca25562ad.png" width="700" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">自 2020 年 10 月贵阳银行耗资 4.26 亿元以单一来源方式采购贵州易鲸捷国产数据库应用项目以来，这是贵阳银行第一次在与投资者互动和交流中，针对「易鲸捷数据建设到什么程度」的回答中未提及「贵州易鲸捷」和「国产数据库应用项目」，而是将 11 月 3 日「贵阳银行系统升级」明确改为「上线新核心业务系统」，也拒绝回答关于「易鲸捷数据库项目是否失败？4.27 亿是否存在利益输送」的提问。</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">互动和交流的前一天，已有媒体公开报道称，贵阳银行系统升级，即为贵阳银行酝酿三年的核心业务系统替代工程正式启动，甲骨文将替代贵州易鲸捷承担起改行核心交易业务中的数据库任务，双方合作事宜将另行商议，贵州易鲸捷通过贴牌假冒国产数据库这一丑闻震惊业内，成为舆论热点。</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">此前 10 月 23 日，贵阳银行发布在 11 月 3 日 17：00 至 11 月 6 日 8：00 进行系统升级暂停服务的公告，以系统升级降低舆论对弃用 4.26 亿元天价国产数据的关注。</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000"><img alt="" height="533" src="https://oscimg.oschina.net/oscnet/up-1fd874a630e4c716e5830945c23e9031a97.png" width="300" referrerpolicy="no-referrer"></span></p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 03:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264876</guid>
            <link>https://www.oschina.net/news/264876</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Hyprland —— 动态平铺式 Wayland 合成器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Hyprland 是一款基于 wlroots 的动态平铺式 Wayland 合成器。</p><p>它提供最新的 Wayland 功能，可高度自定义，拥有所有美观的外观、最强大的插件、简易的 IPC，以及比其他基于 wlr 的合成器更多的 QoL 功能等等...</p><p><strong>特性：</strong></p><ul><li>所有令人赏心悦目的内容：渐变边框、模糊、动画、阴影等等</li><li>大量定制</li><li>比其他基于 wlr 的合成器提供更多的生活质量内容</li><li>自定义贝塞尔曲线以获得最佳动画</li><li>强大的插件支持</li><li>撕裂支持以获得更好的游戏性能</li><li>易于扩展和可读的代码库</li><li>快速、积极的开发</li><li>不害怕提供尖端功能</li><li>保存后立即重新加载配置</li><li>完全动态的工作空间</li><li>两个内置布局以及更多可用作插件的布局</li><li>紧随<code>wlroots-git</code></li><li>全局按键绑定传递给你选择的应用程序</li><li>平铺/伪平铺/浮动/全屏窗口</li><li>特殊工作区（便签本）</li><li>窗口组（选项卡模式）</li><li>强大的窗口/监视器/图层规则</li><li>基于套接字的 IPC</li><li>原生 IME 和输入面板支持</li></ul><p>&nbsp;<img height="282" src="https://static.oschina.net/uploads/space/2023/1030/172906_LCd1_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img height="281" src="https://static.oschina.net/uploads/space/2023/1030/172925_yXI2_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img height="313" src="https://static.oschina.net/uploads/space/2023/1030/172946_yrzI_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 02:53:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/hyprland</guid>
            <link>https://www.oschina.net/p/hyprland</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 将 Web 动画渲染为视频的框架 WebVideoCreator]]>
            </title>
            <description>
                <![CDATA[<p><a href="https://gitee.com/vblog/web-video-creator/blob/master/README.md">简体中文</a> | <a href="https://gitee.com/vblog/web-video-creator/blob/master/README.en-US.md">English</a></p><p align="center"><img width="650px" src="https://gitee.com/vblog/web-video-creator/raw/master/assets/web-video-creator.png" referrerpolicy="no-referrer"></p><h1><a id="user-content-简介" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E7%AE%80%E4%BB%8B"></a>简介</h1><p>WebVideoCreator（简称 WVC）是一个将 Web 动画渲染为视频的框架，基于 Node.js + Puppeteer + Chrome + FFmpeg 实现，它执行确定性的渲染，准确的以目标帧率捕获任何可在 HTML5 播放动画（CSS3 动画/SVG 动画/Lottie 动画/GIF 动画/APNG 动画/WEBP 动画）以及任何基于时间轴使用<a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FrequestAnimationFrame">RAF</a>驱动的动画（<a href="https://gitee.com/link?target=https%3A%2F%2Fanimejs.com%2F">anime.js</a>是一个不错的选择 :D），当然您也可以调皮的使用 setInterval 或者 setTimeout 来控制动画，支持嵌入 mp4 和透明 webm 视频，还支持转场合成、音频合成与字体加载等功能。让我们<a href="https://gitee.com/vblog/web-video-creator#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">快速开始</a>。</p><p>WVC 为您酷炫的动画页面创造了一个虚拟时间环境（也许可以想象成是一个《楚门的世界》），它的主要职责是将一个 <a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/renderer-env.md#%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E6%B8%B2%E6%9F%93%E7%8E%AF%E5%A2%83">不确定性渲染的环境</a> 转化到 <a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/renderer-env.md#%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E6%B8%B2%E6%9F%93%E7%8E%AF%E5%A2%83">确定性渲染的环境</a>。</p><p>这一切的前提由 Chrome 提供的<a href="https://gitee.com/link?target=https%3A%2F%2Fgoo.gle%2Fchrome-headless-rendering">确定性渲染模式</a>和无头实验 API 支持：<a href="https://gitee.com/link?target=https%3A%2F%2Fchromedevtools.github.io%2Fdevtools-protocol%2Ftot%2FHeadlessExperimental%2F%23method-beginFrame">HeadlessExperimental.beginFrame</a></p><p>答疑交流 QQ 群：752693580</p><br><h1><a id="user-content-特性" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E7%89%B9%E6%80%A7"></a>特性</h1><ul><li>基于 Node.js 开发，使用非常简单，易于扩展和开发。</li><li>视频处理速度非常快，最快 5 分钟视频可在 1 分钟内完成渲染。</li><li>支持单幕和多幕视频渲染合成，多幕视频可应用<a href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5%E8%BD%AC%E5%9C%BA%E6%95%88%E6%9E%9C">转场效果</a>。</li><li>支持分块视频合成，可以将分块分发到多个设备上渲染回传再合成为多幕视频，大幅降低长视频渲染耗时。</li><li>支持并行多个视频渲染合成任务，充分利用系统资源。</li><li>API 支持进行<a href="https://gitee.com/vblog/web-video-creator#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88">分布式渲染</a>封装，只需对 WVC 进行一些封装即可将大量视频分块分发到多个设备渲染并最终取回合并输出</li><li>支持使用 GPU 加速渲染和合成，可以显著的降低视频渲染耗时。</li><li>支持在 Windows 和 Linux 平台部署运行。</li></ul><br><h1><a id="user-content-视频 demo" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E8%A7%86%E9%A2%91demo"></a>视频 DEMO</h1><p>我们还缺少动画设计师，不过还是从开放的平台中使用 WVC 捕获渲染了一些优秀的动画 Demo。</p><p>在这里查看所有 DEMO：<strong><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FVinlic%2FWebVideoCreator%2Fwiki%2FRendering-Example">渲染示例页面</a></strong></p><img src="https://gitee.com/vblog/web-video-creator/raw/master/assets/demo.gif" referrerpolicy="no-referrer"><br><h1><a id="user-content-支持的动画库" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%94%AF%E6%8C%81%E7%9A%84%E5%8A%A8%E7%94%BB%E5%BA%93"></a>支持的动画库</h1><p>理论上所有的 Web 动画/图形库都能够在 WVC 环境正常运行，以下仅列出我已验证可用的库：</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Fanimejs.com%2F">Anime.js</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fgreensock.com%2F">GSAP</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fd3js.org%2F">D3.js</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fthreejs.org%2F">Three.js</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fecharts.apache.org%2F">Echart</a> / <a href="https://gitee.com/link?target=http%3A%2F%2Fairbnb.io%2Flottie%2F%23%2Fweb">Lottie-Web</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fpixijs.download%2Frelease%2Fdocs%2Findex.html">PixiJS</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fanimate.style%2F">Animate.css</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Fmojs.github.io%2F">Mo.js</a> / <a href="https://gitee.com/link?target=https%3A%2F%2Ftweenjs.github.io%2Ftween.js%2F">Tween.js</a></p><p>需要注意的是，如果您手动使用<a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FrequestAnimationFrame">RAF</a>驱动动画，请确保从回调中接收 timestamp 参数设置动画的进度到该时间点，否则可能出现帧率不同步。</p><br><h1><a id="user-content-快速开始" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"></a>快速开始</h1><h2><a id="user-content-安装" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%AE%89%E8%A3%85"></a>安装</h2><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c"># 从 NPM 安装 WebVideoCreator</span></span><span id="LC2" class="line">npm i web-video-creator</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如遇到 ffmpeg-static 下载失败，请先设置环境变量：<code>FFMPEG_BINARIES_URL=https://cdn.npmmirror.com/binaries/ffmpeg-static</code></p><h2><a id="user-content-创建本地服务器" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"></a>创建本地服务器</h2><p>WVC 需要从 Web 页面中捕获动画，您可以在本地创建一个临时的 Web 服务器来提供静态页面服务，方便接下来的测试，使用 live-server 是最简单的方式之一，如果您已经有静态页面可跳过这个步骤。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c"># 从 NPM 全局安装 live-server</span></span><span id="LC2" class="line">npm i <span class="nt">-g</span> live-server</span><span id="LC3" class="line"><span class="c"># 启用 Web 服务</span></span><span id="LC4" class="line">live-server</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>创建一个测试页面到 Web 服务根路径，以下 html 内容展示一个自动旋转的三角形 svg 动画。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="cp">&lt;!DOCTYPE html&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;html&gt;</span></span><span id="LC3" class="line"><span class="nt">&lt;head&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;meta</span><span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">/&gt;</span></span><span id="LC5" class="line"><span class="nt">&lt;title&gt;</span>测试页面<span class="nt">&lt;/title&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;/head&gt;</span></span><span id="LC7" class="line"><span class="nt">&lt;body&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;svg</span><span class="na">width=</span><span class="s">"120"</span><span class="na">height=</span><span class="s">"120"</span><span class="na">viewBox=</span><span class="s">"0 0 120 120"</span><span class="na">
                xmlns=</span><span class="s">"http://www.w3.org/2000/svg"</span><span class="na">version=</span><span class="s">"1.1"</span></span><span id="LC9" class="line"><span class="na">
                xmlns:xlink=</span><span class="s">"http://www.w3.org/1999/xlink"</span><span class="nt">&gt;</span></span><span id="LC10" class="line"><span class="nt">&lt;polygon</span><span class="na">points=</span><span class="s">"60,30 90,90 30,90"</span><span class="nt">&gt;</span></span><span id="LC11" class="line"><span class="nt">&lt;animateTransform</span><span class="na">attributeName=</span><span class="s">"transform"</span><span class="na">attributeType=</span><span class="s">"XML"</span><span class="na">type=</span><span class="s">"rotate"</span><span class="na">from=</span><span class="s">"0 60 70"</span><span class="na">to=</span><span class="s">"360 60 70"</span></span><span id="LC12" class="line"><span class="na">dur=</span><span class="s">"10s"</span><span class="na">repeatCount=</span><span class="s">"indefinite"</span><span class="nt">/&gt;</span></span><span id="LC13" class="line"><span class="nt">&lt;/polygon&gt;</span></span><span id="LC14" class="line"><span class="nt">&lt;/svg&gt;</span></span><span id="LC15" class="line"><span class="nt">&lt;/body&gt;</span></span><span id="LC16" class="line"><span class="nt">&lt;/html&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-渲染单幕视频" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%B8%B2%E6%9F%93%E5%8D%95%E5%B9%95%E8%A7%86%E9%A2%91"></a>渲染单幕视频</h2><img src="https://gitee.com/vblog/web-video-creator/raw/master/assets/single-video.gif" referrerpolicy="no-referrer"><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">import</span><span class="nx">WebVideoCreator</span><span class="p">,</span><span class="p">{</span><span class="nx">VIDEO_ENCODER</span><span class="p">,</span><span class="nx">logger</span><span class="p">}</span><span class="k">from</span><span class="dl">"</span><span class="s2">web-video-creator</span><span class="dl">"</span><span class="p">;</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="kd">const</span><span class="nx">wvc</span><span class="o">=</span><span class="k">new</span><span class="nx">WebVideoCreator</span><span class="p">();</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="c1">// 配置 WVC</span></span><span id="LC6" class="line"><span class="nx">wvc</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span></span><span id="LC7" class="line"><span class="c1">// 根据您的硬件设备选择适合的编码器，这里采用的是 Nvidia 显卡的 h264_nvenc 编码器</span></span><span id="LC8" class="line"><span class="c1">// 编码器选择可参考 docs/video-encoder.md</span></span><span id="LC9" class="line"><span class="na">mp4Encoder</span><span class="p">:</span><span class="nx">VIDEO_ENCODER</span><span class="p">.</span><span class="nx">NVIDIA</span><span class="p">.</span><span class="nx">H264</span></span><span id="LC10" class="line"><span class="p">});</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">// 创建单幕视频</span></span><span id="LC13" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC14" class="line"><span class="c1">// 需要渲染的页面地址</span></span><span id="LC15" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/test.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC16" class="line"><span class="c1">// 视频宽度</span></span><span id="LC17" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC18" class="line"><span class="c1">// 视频高度</span></span><span id="LC19" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC20" class="line"><span class="c1">// 视频帧率</span></span><span id="LC21" class="line"><span class="na">fps</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span></span><span id="LC22" class="line"><span class="c1">// 视频时长</span></span><span id="LC23" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC24" class="line"><span class="c1">// 视频输出路径</span></span><span id="LC25" class="line"><span class="na">outputPath</span><span class="p">:</span><span class="dl">"</span><span class="s2">./test.mp4</span><span class="dl">"</span><span class="p">,</span></span><span id="LC26" class="line"><span class="c1">// 是否在 cli 显示进度条，默认是不显示</span></span><span id="LC27" class="line"><span class="na">showProgress</span><span class="p">:</span><span class="kc">true</span></span><span id="LC28" class="line"><span class="p">});</span></span><span id="LC29" class="line"></span><span id="LC30" class="line"><span class="c1">// 监听合成完成事件</span></span><span id="LC31" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">once</span><span class="p">(</span><span class="dl">"</span><span class="s2">completed</span><span class="dl">"</span><span class="p">,</span><span class="nx">result</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC32" class="line"><span class="nx">logger</span><span class="p">.</span><span class="nx">success</span><span class="p">(</span><span class="s2">`Render Completed!!!\nvideo duration: </span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">duration</span><span class="o">/</span><span class="mi">1000</span><span class="p">)}</span><span class="s2">s\ntakes: </span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">takes</span><span class="o">/</span><span class="mi">1000</span><span class="p">)}</span><span class="s2">s\nRTF: </span><span class="p">${</span><span class="nx">result</span><span class="p">.</span><span class="nx">rtf</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span></span><span id="LC33" class="line"><span class="p">});</span></span><span id="LC34" class="line"></span><span id="LC35" class="line"><span class="c1">// 启动合成</span></span><span id="LC36" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-渲染多幕视频" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%B8%B2%E6%9F%93%E5%A4%9A%E5%B9%95%E8%A7%86%E9%A2%91"></a>渲染多幕视频</h2><img src="https://gitee.com/vblog/web-video-creator/raw/master/assets/multi-video.gif" referrerpolicy="no-referrer"><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">import</span><span class="nx">WebVideoCreator</span><span class="p">,</span><span class="p">{</span><span class="nx">VIDEO_ENCODER</span><span class="p">,</span><span class="nx">TRANSITION</span><span class="p">,</span><span class="nx">logger</span><span class="p">}</span><span class="k">from</span><span class="dl">"</span><span class="s2">web-video-creator</span><span class="dl">"</span><span class="p">;</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="kd">const</span><span class="nx">wvc</span><span class="o">=</span><span class="k">new</span><span class="nx">WebVideoCreator</span><span class="p">();</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="c1">// 配置 WVC</span></span><span id="LC6" class="line"><span class="nx">wvc</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span></span><span id="LC7" class="line"><span class="c1">// 根据您的硬件设备选择适合的编码器，这里采用的是 Nvidia 显卡的 h264_nvenc 编码器</span></span><span id="LC8" class="line"><span class="c1">// 编码器选择可参考 docs/video-encoder.md</span></span><span id="LC9" class="line"><span class="na">mp4Encoder</span><span class="p">:</span><span class="nx">VIDEO_ENCODER</span><span class="p">.</span><span class="nx">NVIDIA</span><span class="p">.</span><span class="nx">H264</span></span><span id="LC10" class="line"><span class="p">});</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">// 创建多幕视频</span></span><span id="LC13" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createMultiVideo</span><span class="p">({</span></span><span id="LC14" class="line"><span class="c1">// 视频宽度</span></span><span id="LC15" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC16" class="line"><span class="c1">// 视频高度</span></span><span id="LC17" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC18" class="line"><span class="c1">// 视频帧率</span></span><span id="LC19" class="line"><span class="na">fps</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span></span><span id="LC20" class="line"><span class="c1">// 视频段参数</span></span><span id="LC21" class="line"><span class="na">chunks</span><span class="p">:</span><span class="p">[</span></span><span id="LC22" class="line"><span class="p">{</span></span><span id="LC23" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/scene-1.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC24" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC25" class="line"><span class="c1">// 在第一和第二幕之间插入转场</span></span><span id="LC26" class="line"><span class="na">transition</span><span class="p">:</span><span class="nx">TRANSITION</span><span class="p">.</span><span class="nx">CIRCLE_CROP</span></span><span id="LC27" class="line"><span class="p">},</span></span><span id="LC28" class="line"><span class="p">{</span></span><span id="LC29" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/scene-2.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC30" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span></span><span id="LC31" class="line"><span class="p">}</span></span><span id="LC32" class="line"><span class="p">],</span></span><span id="LC33" class="line"><span class="c1">// 视频输出路径</span></span><span id="LC34" class="line"><span class="na">outputPath</span><span class="p">:</span><span class="dl">"</span><span class="s2">./test.mp4</span><span class="dl">"</span><span class="p">,</span></span><span id="LC35" class="line"><span class="c1">// 是否在 cli 显示进度条，默认是不显示</span></span><span id="LC36" class="line"><span class="na">showProgress</span><span class="p">:</span><span class="kc">true</span></span><span id="LC37" class="line"><span class="p">});</span></span><span id="LC38" class="line"></span><span id="LC39" class="line"><span class="c1">// 监听合成完成事件</span></span><span id="LC40" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">once</span><span class="p">(</span><span class="dl">"</span><span class="s2">completed</span><span class="dl">"</span><span class="p">,</span><span class="nx">result</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC41" class="line"><span class="nx">logger</span><span class="p">.</span><span class="nx">success</span><span class="p">(</span><span class="s2">`Render Completed!!!\nvideo duration: </span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">duration</span><span class="o">/</span><span class="mi">1000</span><span class="p">)}</span><span class="s2">s\ntakes: </span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">takes</span><span class="o">/</span><span class="mi">1000</span><span class="p">)}</span><span class="s2">s\nRTF: </span><span class="p">${</span><span class="nx">result</span><span class="p">.</span><span class="nx">rtf</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span></span><span id="LC42" class="line"><span class="p">});</span></span><span id="LC43" class="line"></span><span id="LC44" class="line"><span class="c1">// 启动合成</span></span><span id="LC45" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-渲染分块视频合并为多幕视频" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%B8%B2%E6%9F%93%E5%88%86%E5%9D%97%E8%A7%86%E9%A2%91%E5%90%88%E5%B9%B6%E4%B8%BA%E5%A4%9A%E5%B9%95%E8%A7%86%E9%A2%91"></a>渲染分块视频合并为多幕视频</h2><img src="https://gitee.com/vblog/web-video-creator/raw/master/assets/chunk-video.gif" referrerpolicy="no-referrer"><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">import</span><span class="nx">WebVideoCreator</span><span class="p">,</span><span class="p">{</span><span class="nx">VIDEO_ENCODER</span><span class="p">,</span><span class="nx">TRANSITION</span><span class="p">,</span><span class="nx">logger</span><span class="p">}</span><span class="k">from</span><span class="dl">"</span><span class="s2">web-video-creator</span><span class="dl">"</span><span class="p">;</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="kd">const</span><span class="nx">wvc</span><span class="o">=</span><span class="k">new</span><span class="nx">WebVideoCreator</span><span class="p">();</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="c1">// 配置 WVC</span></span><span id="LC6" class="line"><span class="nx">wvc</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span></span><span id="LC7" class="line"><span class="c1">// 根据您的硬件设备选择适合的编码器，这里采用的是 Nvidia 显卡的 h264_nvenc 编码器</span></span><span id="LC8" class="line"><span class="c1">// 编码器选择可参考 docs/video-encoder.md</span></span><span id="LC9" class="line"><span class="na">mp4Encoder</span><span class="p">:</span><span class="nx">VIDEO_ENCODER</span><span class="p">.</span><span class="nx">NVIDIA</span><span class="p">.</span><span class="nx">H264</span></span><span id="LC10" class="line"><span class="p">});</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">// 创建分块视频 1</span></span><span id="LC13" class="line"><span class="kd">const</span><span class="nx">chunk1</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createChunkVideo</span><span class="p">({</span></span><span id="LC14" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/scene-1.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC15" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC16" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC17" class="line"><span class="na">fps</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span></span><span id="LC18" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC19" class="line"><span class="na">showProgress</span><span class="p">:</span><span class="kc">true</span></span><span id="LC20" class="line"><span class="p">});</span></span><span id="LC21" class="line"></span><span id="LC22" class="line"><span class="c1">// 创建分块视频 2</span></span><span id="LC23" class="line"><span class="kd">const</span><span class="nx">chunk2</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createChunkVideo</span><span class="p">({</span></span><span id="LC24" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/scene-2.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC25" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC26" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC27" class="line"><span class="na">fps</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span></span><span id="LC28" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC29" class="line"><span class="na">showProgress</span><span class="p">:</span><span class="kc">true</span></span><span id="LC30" class="line"><span class="p">});</span></span><span id="LC31" class="line"></span><span id="LC32" class="line"><span class="c1">// 等待分块们渲染完成</span></span><span id="LC33" class="line"><span class="k">await</span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">chunk1</span><span class="p">.</span><span class="nx">startAndWait</span><span class="p">(),</span><span class="nx">chunk2</span><span class="p">.</span><span class="nx">startAndWait</span><span class="p">()]);</span></span><span id="LC34" class="line"></span><span id="LC35" class="line"><span class="c1">// 设置 chunk1 和 chunk2 之间的转场效果为淡入淡出</span></span><span id="LC36" class="line"><span class="nx">chunk1</span><span class="p">.</span><span class="nx">setTransition</span><span class="p">({</span><span class="na">id</span><span class="p">:</span><span class="nx">TRANSITION</span><span class="p">.</span><span class="nx">FADE</span><span class="p">,</span><span class="na">duration</span><span class="p">:</span><span class="mi">500</span><span class="p">});</span></span><span id="LC37" class="line"><span class="c1">// 不设置时长可以直接提供效果 ID</span></span><span id="LC38" class="line"><span class="c1">// chunk1.setTransition(TRANSITION.FADE);</span></span><span id="LC39" class="line"></span><span id="LC40" class="line"><span class="c1">// 创建多幕视频</span></span><span id="LC41" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createMultiVideo</span><span class="p">({</span></span><span id="LC42" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC43" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC44" class="line"><span class="na">fps</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span></span><span id="LC45" class="line"><span class="c1">// 视频段</span></span><span id="LC46" class="line"><span class="na">chunks</span><span class="p">:</span><span class="p">[</span></span><span id="LC47" class="line"><span class="nx">chunk1</span><span class="p">,</span></span><span id="LC48" class="line"><span class="nx">chunk2</span></span><span id="LC49" class="line"><span class="p">],</span></span><span id="LC50" class="line"><span class="c1">// 视频输出路径</span></span><span id="LC51" class="line"><span class="na">outputPath</span><span class="p">:</span><span class="dl">"</span><span class="s2">./test.mp4</span><span class="dl">"</span><span class="p">,</span></span><span id="LC52" class="line"><span class="c1">// 是否在 cli 显示进度条</span></span><span id="LC53" class="line"><span class="na">showProgress</span><span class="p">:</span><span class="kc">true</span></span><span id="LC54" class="line"><span class="p">});</span></span><span id="LC55" class="line"></span><span id="LC56" class="line"><span class="c1">// 监听合成完成事件</span></span><span id="LC57" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">once</span><span class="p">(</span><span class="dl">"</span><span class="s2">completed</span><span class="dl">"</span><span class="p">,</span><span class="nx">result</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC58" class="line"><span class="nx">logger</span><span class="p">.</span><span class="nx">success</span><span class="p">(</span><span class="s2">`Render Completed!!!\nvideo duration: </span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">duration</span><span class="o">/</span><span class="mi">1000</span><span class="p">)}</span><span class="s2">s\ntakes: </span><span class="p">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">takes</span><span class="o">/</span><span class="mi">1000</span><span class="p">)}</span><span class="s2">s\nRTF: </span><span class="p">${</span><span class="nx">result</span><span class="p">.</span><span class="nx">rtf</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span></span><span id="LC59" class="line"><span class="p">});</span></span><span id="LC60" class="line"></span><span id="LC61" class="line"><span class="c1">// 启动合成</span></span><span id="LC62" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-全局配置" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE"></a>全局配置</h2><p>您可以全局配置 WVC 调整一些通用参数。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">import</span><span class="nx">WebVideoCreator</span><span class="p">,</span><span class="p">{</span><span class="nx">VIDEO_ENCODER</span><span class="p">,</span><span class="nx">AUDIO_ENCODER</span><span class="p">}</span><span class="k">from</span><span class="dl">"</span><span class="s2">web-video-creator</span><span class="dl">"</span><span class="p">;</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="kd">const</span><span class="nx">wvc</span><span class="o">=</span><span class="k">new</span><span class="nx">WebVideoCreator</span><span class="p">();</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="nx">wvc</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span></span><span id="LC6" class="line"><span class="c1">// 开启后将输出一些 WVC 的调试日志</span></span><span id="LC7" class="line"><span class="na">debug</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC8" class="line"><span class="c1">// 开启后将输出浏览器的运行日志</span></span><span id="LC9" class="line"><span class="na">browserDebug</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC10" class="line"><span class="c1">// 开启后将输出每一条执行的 FFmpeg 命令</span></span><span id="LC11" class="line"><span class="na">ffmpegDebug</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC12" class="line"><span class="c1">// ffmpeg 可执行文件路径，设置后将禁用内部的 ffmpeg-static，建议您默认使用内部的 FFmpeg 以确保功能完整性</span></span><span id="LC13" class="line"><span class="na">ffmpegExecutablePath</span><span class="p">:</span><span class="dl">"</span><span class="s2">...</span><span class="dl">"</span><span class="p">,</span></span><span id="LC14" class="line"><span class="c1">// ffprobe 可执行文件路径，设置后将禁用内部的 ffprobe-static，建议您默认使用内部的 ffprobe 以确保功能完整性</span></span><span id="LC15" class="line"><span class="na">ffprobeExecutablePath</span><span class="p">:</span><span class="dl">"</span><span class="s2">...</span><span class="dl">"</span><span class="p">,</span></span><span id="LC16" class="line"><span class="c1">// 浏览器 GPU 加速开关，建议开启提高渲染性能，如果您没有 GPU 设备或遭遇了诡异的渲染问题则可以关闭它</span></span><span id="LC17" class="line"><span class="na">browserUseGPU</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC18" class="line"><span class="c1">// 浏览器是否使用 Angle 作为渲染后端，建议开启增强渲染跨平台兼容性和性能</span></span><span id="LC19" class="line"><span class="na">browserUseAngle</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC20" class="line"><span class="c1">// 是否禁用浏览器使用共享内存，当/dev/shm 分区较小时建议开启此选项</span></span><span id="LC21" class="line"><span class="na">browserDisableDevShm</span><span class="p">:</span><span class="kc">false</span><span class="p">,</span></span><span id="LC22" class="line"><span class="c1">// 浏览器可执行文件路径，设置后将禁用内部的浏览器，建议您默认使用内部的浏览器以确保功能完整性</span></span><span id="LC23" class="line"><span class="na">browserExecutablePath</span><span class="p">:</span><span class="dl">"</span><span class="s2">...</span><span class="dl">"</span><span class="p">,</span></span><span id="LC24" class="line"><span class="c1">// 是否允许不安全的上下文，默认禁用，开启后能够导航到不安全的 URL，但由于不安全上下文限制，将无法在页面中使用动态图像和内嵌视频</span></span><span id="LC25" class="line"><span class="na">allowUnsafeContext</span><span class="p">:</span><span class="kc">false</span><span class="p">,</span></span><span id="LC26" class="line"><span class="c1">// 兼容渲染模式，不建议启用，启用后将禁用 HeadlessExperimental.beginFrame API 调用改为普通的 Page.screenshot</span></span><span id="LC27" class="line"><span class="c1">// 这会导致渲染性能下降，且部分动画可能帧率无法同步，当你遭遇 TargetCloseError: Protocol error (HeadlessExperimental.beginFrame): Target closed 错误的时候可以尝试开启它</span></span><span id="LC28" class="line"><span class="na">compatibleRenderingMode</span><span class="p">:</span><span class="kc">false</span><span class="p">,</span></span><span id="LC29" class="line"><span class="c1">// 资源池最小浏览器实例数量</span></span><span id="LC30" class="line"><span class="na">numBrowserMin</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span></span><span id="LC31" class="line"><span class="c1">// 资源池最大浏览器实例数量</span></span><span id="LC32" class="line"><span class="na">numBrowserMax</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span></span><span id="LC33" class="line"><span class="c1">// 每个浏览器实例最小页面实例数量</span></span><span id="LC34" class="line"><span class="na">numPageMin</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span></span><span id="LC35" class="line"><span class="c1">// 每个浏览器实例最大页面实例数量</span></span><span id="LC36" class="line"><span class="na">numPageMax</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span></span><span id="LC37" class="line"><span class="c1">// 访问页面时的用户 UA</span></span><span id="LC38" class="line"><span class="na">userAgent</span><span class="p">:</span><span class="kc">null</span><span class="p">,</span></span><span id="LC39" class="line"><span class="c1">// 捕获帧图质量（0-100），仅 jpeg 有效</span></span><span id="LC40" class="line"><span class="na">frameQuality</span><span class="p">:</span><span class="mi">80</span><span class="p">,</span></span><span id="LC41" class="line"><span class="c1">// 帧图格式（jpeg/png），建议使用 jpeg，png 捕获较为耗时</span></span><span id="LC42" class="line"><span class="na">frameFormat</span><span class="p">:</span><span class="dl">"</span><span class="s2">jpeg</span><span class="dl">"</span><span class="p">,</span></span><span id="LC43" class="line"><span class="c1">// BeginFrame 捕获图像超时时间</span></span><span id="LC44" class="line"><span class="na">beginFrameTimeout</span><span class="p">:</span><span class="mi">5000</span><span class="p">,</span></span><span id="LC45" class="line"><span class="c1">// MP4 格式的视频编码器，默认使用 libx264 软编码器，建议根据您的硬件选用合适的硬编码器加速合成，编码器选择可参考 docs/video-encoder.md</span></span><span id="LC46" class="line"><span class="na">mp4Encoder</span><span class="p">:</span><span class="nx">VIDEO_ENCODER</span><span class="p">.</span><span class="nx">CPU</span><span class="p">.</span><span class="nx">H264</span><span class="p">,</span></span><span id="LC47" class="line"><span class="c1">// WEBM 格式的视频编码器，默认使用 libvpx 软编码器，建议根据您的硬件选用合适的硬编码器加速合成</span></span><span id="LC48" class="line"><span class="na">webmEncoder</span><span class="p">:</span><span class="nx">VIDEO_ENCODER</span><span class="p">.</span><span class="nx">CPU</span><span class="p">.</span><span class="nx">VP8</span><span class="p">,</span></span><span id="LC49" class="line"><span class="c1">// 音频编码器，建议采用默认的 aac 编码器</span></span><span id="LC50" class="line"><span class="na">audioEncoder</span><span class="p">:</span><span class="nx">AUDIO_ENCODER</span><span class="p">.</span><span class="nx">AAC</span></span><span id="LC51" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-插入音频" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5%E9%9F%B3%E9%A2%91"></a>插入音频</h2><p>只需在需要渲染的 html 中添加 <code>&lt;audio&gt;</code> 元素，您还可以设置循环，WVC 会自动为视频合入循环音轨。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;audio</span><span class="na">src=</span><span class="s">"bgm.mp3"</span><span class="na">loop</span><span class="nt">&gt;&lt;/audio&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>还可以设置一些其它属性控制音频的行为，这些属性并不总是需要成对出现，您可以根据自己的需求定制。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c">&lt;!-- 控制音频音量为原来的一半 --&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;audio</span><span class="na">src=</span><span class="s">"bgm.mp3"</span><span class="na">volume=</span><span class="s">"0.5"</span><span class="nt">&gt;&lt;/audio&gt;</span></span><span id="LC3" class="line"><span class="c">&lt;!-- 控制音频在 3 秒后开始播放并在 10 秒处停止播放 --&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;audio</span><span class="na">src=</span><span class="s">"bgm.mp3"</span><span class="na">startTime=</span><span class="s">"3000"</span><span class="na">endTime=</span><span class="s">"10000"</span><span class="nt">&gt;&lt;/audio&gt;</span></span><span id="LC5" class="line"><span class="c">&lt;!-- 截取音频第 5 秒到第 15 秒的片段并循环播放它 --&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;audio</span><span class="na">src=</span><span class="s">"bgm.mp3"</span><span class="na">seekStart=</span><span class="s">"5000"</span><span class="na">seekEnd=</span><span class="s">"15000"</span><span class="na">loop</span><span class="nt">&gt;&lt;/audio&gt;</span></span><span id="LC7" class="line"><span class="c">&lt;!-- 控制音频 300 毫秒淡入且 500 毫秒淡出 --&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;audio</span><span class="na">src=</span><span class="s">"bgm.mp3"</span><span class="na">fadeInDuration=</span><span class="s">"300"</span><span class="na">fadeOutDuration=</span><span class="s">"500"</span><span class="nt">&gt;&lt;/audio&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>在代码中添加和移除 <code>&lt;audio&gt;</code> 元素来实现音频出入场也是被允许的，WVC 将检测到它们。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">audio</span><span class="o">=</span><span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">audio</span><span class="dl">"</span><span class="p">);</span></span><span id="LC2" class="line"><span class="nx">audio</span><span class="p">.</span><span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">bgm.mp3</span><span class="dl">"</span><span class="p">;</span></span><span id="LC3" class="line"><span class="c1">// 音频在视频第 3 秒入场</span></span><span id="LC4" class="line"><span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">audio</span><span class="p">),</span><span class="mi">3000</span><span class="p">);</span></span><span id="LC5" class="line"><span class="c1">// 音频在视频第 8 秒出场</span></span><span id="LC6" class="line"><span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="nx">audio</span><span class="p">.</span><span class="nx">remove</span><span class="p">(),</span><span class="mi">8000</span><span class="p">);</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>或者在页面中调用 <a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/capture-ctx.md#capturecontextaddaudiooptions-object">captureCtx.addAudio</a> 添加音频到视频中。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 添加单个音频</span></span><span id="LC2" class="line"><span class="nx">captureCtx</span><span class="p">.</span><span class="nx">addAudio</span><span class="p">({</span></span><span id="LC3" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">bgm.mp3</span><span class="dl">"</span><span class="p">,</span></span><span id="LC4" class="line"><span class="na">startTime</span><span class="p">:</span><span class="mi">500</span><span class="p">,</span></span><span id="LC5" class="line"><span class="na">loop</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC6" class="line"><span class="c1">// 80% 的音量</span></span><span id="LC7" class="line"><span class="na">volume</span><span class="p">:</span><span class="mi">80</span></span><span id="LC8" class="line"><span class="p">});</span></span><span id="LC9" class="line"><span class="c1">// 添加多个音频</span></span><span id="LC10" class="line"><span class="nx">captureCtx</span><span class="p">.</span><span class="nx">addAudios</span><span class="p">([...]);</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>也可以在 WVC 中直接使用 <a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/api-reference-high-level.md#singlevideoaddaudiooptions-object">addAudio</a> 将本地或远程的音频添加到视频中。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span><span class="p">...</span><span class="p">});</span></span><span id="LC2" class="line"><span class="c1">// 添加单个音频</span></span><span id="LC3" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">addAudio</span><span class="p">({</span></span><span id="LC4" class="line"><span class="c1">// url: "http://.../bgm.mp3"</span></span><span id="LC5" class="line"><span class="na">path</span><span class="p">:</span><span class="dl">"</span><span class="s2">bgm.mp3</span><span class="dl">"</span><span class="p">,</span></span><span id="LC6" class="line"><span class="na">startTime</span><span class="p">:</span><span class="mi">500</span><span class="p">,</span></span><span id="LC7" class="line"><span class="na">loop</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC8" class="line"><span class="c1">// 80% 的音量</span></span><span id="LC9" class="line"><span class="na">volume</span><span class="p">:</span><span class="mi">80</span></span><span id="LC10" class="line"><span class="p">});</span></span><span id="LC11" class="line"><span class="c1">// 添加多个音频</span></span><span id="LC12" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">addAudios</span><span class="p">([...]);</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>这样的操作同样适用于 MultiVideo 和 ChunkVideo 。</p><h2><a id="user-content-插入视频" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91"></a>插入视频</h2><p>目前支持 <code>mp4</code> 和 <code>webm</code> 格式的视频，只需在需要渲染的 html 中添加 <code>&lt;video&gt;</code> 元素，您可以设置循环和静音，如果您的 src 不包含 <code>.mp4</code> 后缀名可能无法被识别，请添加 <code>capture</code> 属性标识为需要捕获的元素。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"background.mp4"</span><span class="na">loop</span><span class="na">muted</span><span class="nt">&gt;&lt;/video&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如果希望插入透明通道的视频请见：<a href="https://gitee.com/vblog/web-video-creator#%E9%80%8F%E6%98%8E%E9%80%9A%E9%81%93%E8%A7%86%E9%A2%91">透明通道视频</a>，对视频帧率同步或透明视频绘制感兴趣可以参考：<a href="https://gitee.com/vblog/web-video-creator#%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0">技术实现</a>。</p><p>和音频一样，它也支持设置一些属性控制视频的行为，这些属性并不总是需要成对出现，您可以根据自己的需求定制。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c">&lt;!-- 控制音频音量为原来的 70% --&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"test.mp4"</span><span class="na">volume=</span><span class="s">"0.7"</span><span class="nt">&gt;&lt;/video&gt;</span></span><span id="LC3" class="line"><span class="c">&lt;!-- 控制视频在 3 秒后开始播放并在 10 秒处停止播放 --&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"test.mp4"</span><span class="na">startTime=</span><span class="s">"3000"</span><span class="na">endTime=</span><span class="s">"10000"</span><span class="nt">&gt;&lt;/video&gt;</span></span><span id="LC5" class="line"><span class="c">&lt;!-- 截取视频第 5 秒到第 15 秒的片段并循环播放它 --&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"test.mp4"</span><span class="na">seekStart=</span><span class="s">"5000"</span><span class="na">seekEnd=</span><span class="s">"15000"</span><span class="na">loop</span><span class="nt">&gt;&lt;/video&gt;</span></span><span id="LC7" class="line"><span class="c">&lt;!-- 控制视频的音频在 300 毫秒淡入且 500 毫秒淡出 --&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"test.mp4"</span><span class="na">fadeInDuration=</span><span class="s">"300"</span><span class="na">fadeOutDuration=</span><span class="s">"500"</span><span class="nt">&gt;&lt;/video&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>在代码中添加和移除 <code>&lt;video&gt;</code> 元素来实现视频出入场也是被允许的，WVC 将检测到它们。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">video</span><span class="dl">"</span><span class="p">);</span></span><span id="LC2" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">test.mp4</span><span class="dl">"</span><span class="p">;</span></span><span id="LC3" class="line"><span class="c1">// 视频在第 3 秒入场</span></span><span id="LC4" class="line"><span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">video</span><span class="p">),</span><span class="mi">3000</span><span class="p">);</span></span><span id="LC5" class="line"><span class="c1">// 视频在第 8 秒出场</span></span><span id="LC6" class="line"><span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="nx">video</span><span class="p">.</span><span class="nx">remove</span><span class="p">(),</span><span class="mi">8000</span><span class="p">);</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-透明通道视频" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E9%80%8F%E6%98%8E%E9%80%9A%E9%81%93%E8%A7%86%E9%A2%91"></a>透明通道视频</h3><p>透明视频非常适合用于将 vtuber 数字人合成到视频画面中，结合精美的动画可以获得非常好的观看体验，合成效果请参考 <strong><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FVinlic%2FWebVideoCreator%2Fwiki%2FRendering-Example">渲染示例页面</a></strong> 最后一个 Demo。</p><p>透明通道视频格式需为 <code>webm</code> ，在内部它会被重新编码为两个 mp4 容器的视频，分别是原色底视频和蒙版视频后在浏览器 canvas 中使用进行 <code>globalCompositeOperation</code> 进行图像混合并绘制。</p><p>对于使用者是无感的，像下面代码演示中那样，只需需要渲染的 html 中添加 <code>&lt;video&gt;</code> 元素，并设置 src 为 webm 格式视频地址即可。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"vtuber.webm"</span><span class="nt">&gt;&lt;/video&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>webm 编解码通常比较耗时，如果您可以直接获得原始 mp4 视频和蒙版 mp4 视频是更好的方案，只需增加设置 maskSrc 即可。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;video</span><span class="na">src=</span><span class="s">"vtuber.mp4"</span><span class="na">maskSrc=</span><span class="s">"vtuber_mask.mp4"</span><span class="nt">&gt;&lt;/video&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-插入动态图像" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5%E5%8A%A8%E6%80%81%E5%9B%BE%E5%83%8F"></a>插入动态图像</h2><p>动态图像指的是 <code>gif</code> / <code>apng</code> / <code>webp</code> 格式的序列帧动画，他们可以在浏览器中自然播放，帧率通常是不可控的，但 WVC 代理了它们的绘制，img 元素被替换为 canvas 并通过 ImageDecoder 解码绘制每一帧，让序列帧动画按照虚拟时间同步绘制。</p><p>以下这些动图都能够正常绘制，您也可以照常给他们设置样式。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"test.gif"</span><span class="nt">/&gt;</span></span><span id="LC2" class="line"><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"test.apng"</span><span class="nt">/&gt;</span></span><span id="LC3" class="line"><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"test.webp"</span><span class="nt">/&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-插入 lottie 动画" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5lottie%E5%8A%A8%E7%94%BB"></a>插入 Lottie 动画</h2><p>WVC 已经内置 <a href="https://gitee.com/link?target=http%3A%2F%2Fairbnb.io%2Flottie%2F%23%2Fweb">lottie-web</a> 动画库，如果您的页面有自己实现的 lottie 动效则可以忽略本内容，因为它们也能够正常工作。</p><p>只需要插入一个 <code>&lt;lottie&gt;</code> 元素并设置 src 即可。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;lottie</span><span class="na">src=</span><span class="s">"example.json"</span><span class="nt">&gt;&lt;/lottie&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-应用字体" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%BA%94%E7%94%A8%E5%AD%97%E4%BD%93"></a>应用字体</h2><p>WVC 能够检测样式表中的 <code>@font-face</code> 声明并等待字体加载完成再开始渲染。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;style&gt;</span></span><span id="LC2" class="line"><span class="k">@font-face</span><span class="p">{</span></span><span id="LC3" class="line"><span class="nl">font-family</span><span class="p">:</span><span class="s1">"FontTest"</span><span class="p">;</span></span><span id="LC4" class="line"><span class="nl">src</span><span class="p">:</span><span class="sx">url("font.ttf")</span><span class="n">format</span><span class="p">(</span><span class="s1">"truetype"</span><span class="p">);</span></span><span id="LC5" class="line"><span class="p">}</span></span><span id="LC6" class="line"><span class="nt">&lt;/style&gt;</span></span><span id="LC7" class="line"><span class="nt">&lt;p</span><span class="na">style=</span><span class="s">'font-family: "FontTest"'</span><span class="nt">&gt;</span>Hello World<span class="nt">&lt;/p&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>或者，可以通过代码注册本地或远程的字体。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span><span class="p">...</span><span class="p">});</span></span><span id="LC2" class="line"><span class="c1">// 注册单个字体</span></span><span id="LC3" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">registerFont</span><span class="p">({</span></span><span id="LC4" class="line"><span class="c1">// url: "http://.../font.ttf"</span></span><span id="LC5" class="line"><span class="na">path</span><span class="p">:</span><span class="dl">"</span><span class="s2">font.ttf</span><span class="dl">"</span><span class="p">,</span></span><span id="LC6" class="line"><span class="na">family</span><span class="p">:</span><span class="dl">"</span><span class="s2">FontTest</span><span class="dl">"</span><span class="p">,</span></span><span id="LC7" class="line"><span class="na">format</span><span class="p">:</span><span class="dl">"</span><span class="s2">truetype</span><span class="dl">"</span></span><span id="LC8" class="line"><span class="p">});</span></span><span id="LC9" class="line"><span class="c1">// 注册多个字体</span></span><span id="LC10" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">registerFonts</span><span class="p">([...]);</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>您需要确保字体能够正常加载，否则可能无法启动渲染。</p><h2><a id="user-content-插入转场效果" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5%E8%BD%AC%E5%9C%BA%E6%95%88%E6%9E%9C"></a>插入转场效果</h2><p>WVC 支持使用 FFmpeg 所支持的 <a href="https://gitee.com/link?target=https%3A%2F%2Ftrac.ffmpeg.org%2Fwiki%2FXfade">Xfade</a> 滤镜来合成转场效果，可参考<a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/transition.md">转场列表</a>、</p><p>每个分块视频参数都能够设置转场效果和持续时长。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="k">import</span><span class="nx">WebVideoCreator</span><span class="p">,</span><span class="p">{</span><span class="nx">TRANSITION</span><span class="p">}</span><span class="k">from</span><span class="dl">"</span><span class="s2">web-video-creator</span><span class="dl">"</span><span class="p">;</span></span><span id="LC2" class="line"></span><span id="LC3" class="line"><span class="p">...</span></span><span id="LC4" class="line"></span><span id="LC5" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createMultiVideo</span><span class="p">({</span></span><span id="LC6" class="line"><span class="p">...</span></span><span id="LC7" class="line"><span class="c1">// 视频段参数</span></span><span id="LC8" class="line"><span class="na">chunks</span><span class="p">:</span><span class="p">[</span></span><span id="LC9" class="line"><span class="p">{</span></span><span id="LC10" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/scene-1.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC11" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC12" class="line"><span class="c1">// 在第一和第二幕之间插入淡入淡出转场</span></span><span id="LC13" class="line"><span class="na">transition</span><span class="p">:</span><span class="p">{</span></span><span id="LC14" class="line"><span class="na">id</span><span class="p">:</span><span class="nx">TRANSITION</span><span class="p">.</span><span class="nx">FADE</span><span class="p">,</span></span><span id="LC15" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">500</span></span><span id="LC16" class="line"><span class="p">},</span></span><span id="LC17" class="line"><span class="c1">// 如果不需要设置时长也可以直接设置转场 ID</span></span><span id="LC18" class="line"><span class="c1">// transition: TRANSITION.FADE</span></span><span id="LC19" class="line"><span class="p">},</span></span><span id="LC20" class="line"><span class="p">{</span></span><span id="LC21" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/scene-2.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC22" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span></span><span id="LC23" class="line"><span class="p">}</span></span><span id="LC24" class="line"><span class="p">],</span></span><span id="LC25" class="line"><span class="p">...</span></span><span id="LC26" class="line"><span class="p">});</span></span><span id="LC27" class="line"></span><span id="LC28" class="line"><span class="p">...</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>需要注意的是，应用转场会导致视频总时长缩短，转场效果实际上是两段视频的部分重叠，两段 5 秒的视频插入转场，会合成时长为 9 秒的视频。</p><p>Lottie 动画也很适合作为转场效果，您可以在一段视频的尾部播放一半时长的全屏 Lottie 动画，然后在下一段视频开头播放另一半时长的全屏 Lottie 动画实现更动感的转场效果。</p><h2><a id="user-content-延迟启动渲染" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%BB%B6%E8%BF%9F%E5%90%AF%E5%8A%A8%E6%B8%B2%E6%9F%93"></a>延迟启动渲染</h2><p>WVC 默认页面导航完成后立即启动渲染，如果希望在渲染之前进行一些工作，可以在选项中禁用自动启动渲染，禁用后请记得在您的页面中调用 <a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/capture-ctx.md#capturecontextstart">captureCtx.start()</a>，否则将永远阻塞。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/test.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC3" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC4" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC5" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC6" class="line"><span class="c1">// 禁用自动启动渲染</span></span><span id="LC7" class="line"><span class="na">autostartRender</span><span class="p">:</span><span class="kc">false</span></span><span id="LC8" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>页面代码中，在您觉得合适的时机调用启动。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;script&gt;</span></span><span id="LC2" class="line"><span class="c1">// 数据加载完成后启动渲染</span></span><span id="LC3" class="line"><span class="nx">loadData</span><span class="p">()</span></span><span id="LC4" class="line"><span class="p">.</span><span class="nx">then</span><span class="p">(()</span><span class="o">=&gt;</span><span class="nx">captureCtx</span><span class="p">.</span><span class="nx">start</span><span class="p">())</span></span><span id="LC5" class="line"><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="o">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">));</span></span><span id="LC6" class="line"><span class="nt">&lt;/script&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-启动渲染前操作页面" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%90%AF%E5%8A%A8%E6%B8%B2%E6%9F%93%E5%89%8D%E6%93%8D%E4%BD%9C%E9%A1%B5%E9%9D%A2"></a>启动渲染前操作页面</h2><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="na">url</span><span class="p">:</span><span class="dl">"</span><span class="s2">http://localhost:8080/test.html</span><span class="dl">"</span><span class="p">,</span></span><span id="LC3" class="line"><span class="na">width</span><span class="p">:</span><span class="mi">1280</span><span class="p">,</span></span><span id="LC4" class="line"><span class="na">height</span><span class="p">:</span><span class="mi">720</span><span class="p">,</span></span><span id="LC5" class="line"><span class="na">duration</span><span class="p">:</span><span class="mi">10000</span><span class="p">,</span></span><span id="LC6" class="line"><span class="na">pagePrepareFn</span><span class="p">:</span><span class="k">async</span><span class="nx">page</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC7" class="line"><span class="c1">// 获取 puppeteer Page 对象</span></span><span id="LC8" class="line"><span class="kd">const</span><span class="nx">_page</span><span class="o">=</span><span class="nx">page</span><span class="p">.</span><span class="nx">target</span><span class="p">;</span></span><span id="LC9" class="line"><span class="c1">// 点击按钮</span></span><span id="LC10" class="line"><span class="k">await</span><span class="nx">_page</span><span class="p">.</span><span class="nx">tap</span><span class="p">(</span><span class="dl">"</span><span class="s2">#play-button</span><span class="dl">"</span><span class="p">);</span></span><span id="LC11" class="line"><span class="p">}</span></span><span id="LC12" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-页面控制枱输出" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E9%A1%B5%E9%9D%A2%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA"></a>页面控制枱输出</h2><p>如果想看到页面的日志，可在视频选项中开启 consoleLog。开启 videoPreprocessLog 将输出内嵌视频预处理日志。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 输出页面控制枱打印的日志</span></span><span id="LC4" class="line"><span class="na">consoleLog</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC5" class="line"><span class="c1">// 输出内嵌视频预处理日志</span></span><span id="LC6" class="line"><span class="na">videoPreprocessLog</span><span class="p">:</span><span class="kc">true</span></span><span id="LC7" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-截取封面图" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%88%AA%E5%8F%96%E5%B0%81%E9%9D%A2%E5%9B%BE"></a>截取封面图</h2><p>合成视频后可以截取某一帧图像并保存，可以作为视频封面图。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 是否截取图像</span></span><span id="LC4" class="line"><span class="na">coverCapture</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span></span><span id="LC5" class="line"><span class="c1">// 图像截取时间点（毫秒），默认是视频时长的 20% 位置）</span></span><span id="LC6" class="line"><span class="na">coverCaptureTime</span><span class="p">:</span><span class="mi">1000</span><span class="p">,</span></span><span id="LC7" class="line"><span class="c1">// 图像保存格式（jpg/png/bmp），默认 jpg</span></span><span id="LC8" class="line"><span class="na">coverCaptureFormat</span><span class="p">:</span><span class="dl">"</span><span class="s2">jpg</span><span class="dl">"</span></span><span id="LC9" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-插入封面图" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8F%92%E5%85%A5%E5%B0%81%E9%9D%A2%E5%9B%BE"></a>插入封面图</h2><p>WVC 支持往视频的首帧插入图像，当视频未被播放时将展示首帧图像。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 设置附加的封面图地址，支持 jpg/png/bmp</span></span><span id="LC4" class="line"><span class="na">attachCoverPath</span><span class="p">:</span><span class="dl">"</span><span class="s2">./cover.jpg</span><span class="dl">"</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-调整视频音量" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E8%B0%83%E6%95%B4%E8%A7%86%E9%A2%91%E9%9F%B3%E9%87%8F"></a>调整视频音量</h2><p>您可以控制输出视频的总音量。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 设置视频音量为原来的 80%</span></span><span id="LC4" class="line"><span class="na">volume</span><span class="p">:</span><span class="mi">80</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-控制输出视频质量" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8E%A7%E5%88%B6%E8%BE%93%E5%87%BA%E8%A7%86%E9%A2%91%E8%B4%A8%E9%87%8F"></a>控制输出视频质量</h2><p>WVC 支持通过 <code>videoQuality</code> 或 <code>videoBitrate</code> 控制视频图像质量。</p><p>videoQuality 是通过图像总像素量简单计算码率，以下 WVC 内计算视频码率方法。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">pixels</span><span class="o">=</span><span class="nx">width</span><span class="o">*</span><span class="nx">height</span><span class="p">;</span></span><span id="LC2" class="line"><span class="kd">const</span><span class="nx">videoBitrate</span><span class="o">=</span><span class="p">(</span><span class="mi">2560</span><span class="o">/</span><span class="mi">921600</span><span class="o">*</span><span class="nx">pixels</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nx">videoQuality</span><span class="o">/</span><span class="mi">100</span><span class="p">);</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>可以在视频选项中提供 videoQuality（0-100）</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 设置视频质量为 80%</span></span><span id="LC4" class="line"><span class="na">videoQuality</span><span class="p">:</span><span class="mi">80</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如果您认为码率不合适，可以单独设置 videoBitrate。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 设置视频码率为 8Mbps</span></span><span id="LC4" class="line"><span class="na">videoBitrate</span><span class="p">:</span><span class="dl">"</span><span class="s2">8192k</span><span class="dl">"</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>另外还可以调整帧图质量，当使用 jpeg 作为帧图格式时可以调整 frameQuality，详见 <a href="https://gitee.com/vblog/web-video-creator#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE">全局配置</a>。</p><p>音频质量则可以通过设置音频码率 audioBitrate 调整。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 设置音频码率为 320Kbps</span></span><span id="LC4" class="line"><span class="na">audioBitrate</span><span class="p">:</span><span class="dl">"</span><span class="s2">320k</span><span class="dl">"</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-修改像素格式" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E4%BF%AE%E6%94%B9%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F"></a>修改像素格式</h2><p>WVC 目前支持输出 <code>yuv420p</code> / <code>yuv444p</code> / <code>rgb24</code> 像素格式的视频，默认采用兼容性更好的 yuv420p ，如果您发现输出的视频与页面的颜色有较大的差异，可以切换为 rgb24 改善这个问题。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span></span><span id="LC2" class="line"><span class="p">...,</span></span><span id="LC3" class="line"><span class="c1">// 设置像素格式为 rgb24</span></span><span id="LC4" class="line"><span class="na">pixelFormat</span><span class="p">:</span><span class="dl">"</span><span class="s2">rgb24</span><span class="dl">"</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><br><h1><a id="user-content-视频编码器选择" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%99%A8%E9%80%89%E6%8B%A9"></a>视频编码器选择</h1><p>浏览器渲染输出帧图流输入 FFmpeg 时需要通过视频编码器将图像数据按指定帧率编码为视频数据并存储于指定格式容器中，视频编码是一项较为消耗资源的操作，选用硬编码器可以加速这个过程并降低 CPU 的负载。</p><p>WVC 支持的视频编码器请参考：<a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/video-encoder.md">视频编码器说明</a></p><br><h1><a id="user-content-进度监听" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E8%BF%9B%E5%BA%A6%E7%9B%91%E5%90%AC"></a>进度监听</h1><p>您可以通过视频实例的 <code>progress</code> 事件监听渲染合成进度。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span><span class="p">...</span><span class="p">});</span></span><span id="LC2" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">progress</span><span class="dl">"</span><span class="p">,</span><span class="p">(</span><span class="nx">progress</span><span class="p">,</span><span class="nx">synthesizedFrameCount</span><span class="p">,</span><span class="nx">totalFrameCount</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span></span><span id="LC3" class="line"><span class="c1">// 输出，进度 / 已合成帧数 / 总帧数</span></span><span id="LC4" class="line"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">progress</span><span class="p">,</span><span class="nx">synthesizedFrameCount</span><span class="p">,</span><span class="nx">totalFrameCount</span><span class="p">);</span></span><span id="LC5" class="line"><span class="p">});</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>这同样适用于 <code>MultiVideo</code> / <code>ChunkVideo</code> 以及低级别 API 的合成器。</p><br><h1><a id="user-content-异常处理" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"></a>异常处理</h1><h2><a id="user-content-抛出错误" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF"></a>抛出错误</h2><p>您可以在页面中主动抛出错误来中断渲染。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;script&gt;</span></span><span id="LC2" class="line"><span class="nx">____throwError</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="dl">"</span><span class="s2">Abort</span><span class="dl">"</span><span class="p">);</span></span><span id="LC3" class="line"><span class="nt">&lt;/script&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-监听页面崩溃" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E5%B4%A9%E6%BA%83"></a>监听页面崩溃</h2><p>如果您的页面存在大量密集计算或者占用过多的运行内存，页面将可能崩溃，从而导致渲染中断。</p><p>如果使用高级别 API，页面崩溃时通过视频实例的 <code>error</code> 事件通知。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span><span class="p">...</span><span class="p">});</span></span><span id="LC2" class="line"><span class="c1">// 错误时输出 Page crashed:...</span></span><span id="LC3" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">,</span><span class="nx">err</span><span class="o">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">));</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>使用低级别 API 时，页面崩溃时通过 Page 实例的 <code>crashed</code> 事件通知</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 错误时输出崩溃错误</span></span><span id="LC2" class="line"><span class="nx">page</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">crashed</span><span class="dl">"</span><span class="p">,</span><span class="nx">err</span><span class="o">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">));</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-监听其它错误" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E7%9B%91%E5%90%AC%E5%85%B6%E5%AE%83%E9%94%99%E8%AF%AF"></a>监听其它错误</h2><p>如果使用高级别 API，页面崩溃时通过视频实例的 <code>error</code> 事件通知。</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">const</span><span class="nx">video</span><span class="o">=</span><span class="nx">wvc</span><span class="p">.</span><span class="nx">createSingleVideo</span><span class="p">({</span><span class="p">...</span><span class="p">});</span></span><span id="LC2" class="line"><span class="nx">video</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">,</span><span class="nx">err</span><span class="o">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">));</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>使用低级别 API 时，页面崩溃时通过 Page 实例的 <code>error</code> 事件通知</p><div class="monokai"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nx">page</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">,</span><span class="nx">err</span><span class="o">=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">));</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><br><h1><a id="user-content-分布式渲染方案" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88"></a>分布式渲染方案</h1><p>如果您有多台设备可以为这些设备部署 WVC，它提供了 <code>MultiVideo</code> 和 <code>ChunkVideo</code>，您可以将动画页面分为很多个分段，如 0-10 秒、10-20 秒...，将它们的参数分发到不同设备的 WVC 上，在这些设备上创建 ChunkVideo 实例并执行并行渲染为多个视频 <code>ts</code> 分段，将他们回传到核心节点上，并最终输入 MultiVideo 进行合并以及转场、音轨合成输出。<strong>这个分发以及回传流程 WVC 还未实现，但它并不难，您可以根据自己的场景进行封装并欢迎为 WVC 贡献<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FVinlic%2FWebVideoCreator%2Fpulls">PR</a>！</strong></p><br><h1><a id="user-content-api 参考" class="anchor" href="https://gitee.com/vblog/web-video-creator#api%E5%8F%82%E8%80%83"></a>API 参考</h1><h2><a id="user-content-高级别 api" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E9%AB%98%E7%BA%A7%E5%88%ABapi"></a>高级别 API</h2><p>大部分时候，建议使用高级别 API，因为它足够的简单，但可能不够灵活。</p><p><a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/api-reference-high-level.md">API Reference High Level</a></p><h2><a id="user-content-低级别 api" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E4%BD%8E%E7%BA%A7%E5%88%ABapi"></a>低级别 API</h2><p><a href="https://gitee.com/vblog/web-video-creator/blob/master/docs/api-reference-low-level.md">API Reference Low Level</a></p><br><h1><a id="user-content-性能提示" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%80%A7%E8%83%BD%E6%8F%90%E7%A4%BA"></a>性能提示</h1><p>性能通常受动画和媒体的复杂程度影响，您可以将长时间动画分为多个分段动画播放，比如为每个页面地址带一个 seek 参数，加载页面后 seek 到指定时间点开始播放，然后作为多幕视频进行渲染合成，可以显著的降低长视频的渲染耗时。</p><ul><li>并行更多的视频块渲染，如果希望榨干系统资源，在确保系统内存充足的情况下并行数选定为 CPU 的线程数</li><li>CPU 主频对于基准速度影响较大，通常消费级 CPU 主频很高，可以获得更佳的性能。</li><li>建议使用 GPU 加速渲染和合成，如果您设备有 GPU 但没有被使用，请检查配置项或报告问题。</li><li>采用 SSD（固态硬盘）可以提升并行渲染时的硬盘缓存写入性能从而降低渲染耗时。</li><li>选择正确的视频硬编码器很重要，默认采用的是软编码器（mp4 是 libx264，webm 是 libvpx），如果您有核显或者独显请记得配置他们支持的硬编码器。</li><li>有些耗时可能来自于网络文件传输，建议将静态文件服务部署于同一台服务器或从局域网访问文件服务器。</li><li>降低输出视频分辨率和帧率是降低耗时最有效的方法。</li></ul><hr><p>目前手上没有更好的测试设备，我将以我的个人主机的性能参数作为参考：</p><p>系统：Windows10（在 Linux 系统中性能表现更好）</p><p>CPU: AMD Ryzen 7 3700X（主频 3.6-4.4GHz 8 核 16 线程）</p><p>GPU: Nvidia GeForce GTX 1660 SUPER（6GB 显存，支持 NVENC）</p><p>RAM: 16GB（DDR4 2400MHz）</p><p>视频类型：SVG 动画+GIF+Lottie 动画播放</p><p>视频分辨率：1280x720</p><p>视频帧率：30</p><p>视频时长：300s（5 分钟）</p><p>渲染耗时：61s（1 分钟）</p><p>实时率：4.844</p><p>并行渲染数：16</p><hr><br><h1><a id="user-content-局限性" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E5%B1%80%E9%99%90%E6%80%A7"></a>局限性</h1><ul><li>受制于浏览器的<a href="https://gitee.com/link?target=https%3A%2F%2Fw3c.github.io%2Fwebappsec-secure-contexts%2F">安全上下文限制</a>，只能访问 localhost / 127.0.0.1 或者使用 HTTPS 协议且证书有效的域，从安全角度考虑建议使用本机静态服务器（live-server 是一个不错的选择）。</li><li>在 Mac 系统中使用无头实验 API 在会发生崩溃，需要改为兼容渲染模式才能运行，但兼容渲染模式存在诸多问题，不建议在 Mac 系统使用，详见<a href="https://gitee.com/vblog/web-video-creator#%E5%85%BC%E5%AE%B9%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F">兼容渲染模式</a></li><li>WebVideoCreator 是纯 ESM 包，无法使用 CommonJS 风格引入，如果依然希望使用 require 引入，请参考：<a href="https://gitee.com/link?target=https%3A%2F%2Fgist.github.com%2Fsindresorhus%2Fa39789f98801d908bbc7ff3ecc99d99c">https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c</a></li></ul><br><h1><a id="user-content-技术实现" class="anchor" href="https://gitee.com/vblog/web-video-creator#%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"></a>技术实现</h1><p>正在编写中...</p>]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 02:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/vblog/web-video-creator</guid>
            <link>https://gitee.com/vblog/web-video-creator</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | vivo 网络端口安全建设技术实践]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="letter-spacing: 0.578px;text-wrap: wrap;font-size: 15px;"><section powered-by="xiumi.us" style="text-align: center;font-size: 14px;"><p><span style="color: rgb(0, 82, 255);"><span style="letter-spacing: 0.578px;">揭秘 vivo 互联网海量服务的研发之路&nbsp;</span><span style="letter-spacing: 0.034em;">报名中👇</span></span></p></section><section powered-by="xiumi.us" style="margin-top: 0.5em;margin-bottom: 0.5em;padding-right: 0.5em;padding-left: 0.5em;text-align: center;"><section style="border-width: 5px;border-style: solid;border-color: rgb(255, 255, 255);display: inline-block;line-height: 0;box-shadow: rgb(102, 102, 102) 0.2em 0.2em 0.5em;width: 394.094px;height: auto;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdev.vivo.com.cn%2Fvdc%2F2023%2Findex.html%23%2F" textvalue="‍‍" linktype="text" imgurl="" tab="outerlink" data-linktype="1"><span class="js_jump_icon h5_image_link"><img class="rich_pages wxw-img" data-cropselx1="0" data-cropselx2="384" data-cropsely1="0" data-cropsely2="384" data-ratio="0.21944444444444444" data-s="300,640" src="https://oscimg.oschina.net/oscnet/67276678-97b5-4d79-8ae3-651f665ab878.png" data-type="jpeg" data-w="1080" style="height: 127px;vertical-align: middle;width: 578px;" referrerpolicy="no-referrer"></span></a></section></section></section><section style="font-size: 15px;line-height: 1.6;"><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">作者：vivo 互联网安全团队 - Peng Qiankun</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: left;" powered-by="xiumi.us"><section style="font-size: 14px;text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);"><p style="text-wrap: wrap;">随着互联网业务的快速发展，网络攻击的频率和威胁性也在不断增加，端口是应用通信中的门户，它是数据进出应用的必经之路，因此端口安全也逐渐成为了企业内网的重要防线之一，然而网络端口因其数量庞大、端口开放和关闭的影响评估难度大，业务影响程度高、以及异常识别技术复杂度高等特点给网络端口安全治理带来了一定挑战，如何对端口风险进行有效治理几乎是每个企业安全团队在攻击面管理工作中持续探索的重点项。</p></section></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>一、网络端口简介</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">在网络空间中，标记一个服务资源实体最基本的两个要素就是 IP 和逻辑端口，二者构建服务资源实体的唯一标志符。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. &nbsp;常见的端口分布划分：</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（1）知名端口 (Well-Known Ports)</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">知名端口即众所周知的端口号，范围从 0 到 1023，这些端口号一般固定分配给一些服务。比如 21 端口分配给 FTP 服务，25 端口分配给 SMTP(简单邮件传输协议) 服务，80 端口分配给 HTTP 服务，135 端口分配给 RPC(远程过程调用) 服务等等。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）动态端口 (Dynamic Ports)</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">动态端口的范围从 1024 到 65535，这些端口号一般不固定分配给某个服务，也就是说许多服务都可以使用这些端口。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。比如 1024 端口就是分配给第一个向系统发出申请的程序。在关闭程序进程后，就会释放所占用的端口号。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;&nbsp;另外，端口还会按照协议类型划分</strong></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">（1）TCP 端口</p><p style="text-wrap: wrap;">&nbsp;</p><p style="text-wrap: wrap;">即传输控制协议端口，需要在客户端和服务器之间建立连接，这样可以提供可靠的数据传输。常见的包括 FTP 服务的 21 端口，Telnet 服务的 23 端口，SMTP 服务的 25 端口，以及 HTTP 服务的 80 端口等等。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">（2）&nbsp;UDP 端口</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">即用户数据包协议端口，无需在客户端和服务器之间建立连接，安全性得不到保障。常见的有 DNS 服务的 53 端口，SNMP(简单网络管理协议) 服务的 161 端口，QQ 使用的 8000 和 4000 端口等等。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>3.&nbsp;&nbsp;常用的网络端口映射表</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6138917262512769" data-s="300,640" src="https://oscimg.oschina.net/oscnet/affd180b-4e93-4677-a843-2a267a05b99a.png" data-type="png" data-w="979" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp;图 1 常用网络端口映射表</span></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">PS：更多详细端口规范可查阅：</p><p style="text-wrap: wrap;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.iana.org%2Fassignments%2Fservice-names-port-numbers%2Fservice-names-port-numbers.xhtml" textvalue="http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml" linktype="text" imgurl="" tab="outerlink" data-linktype="2">http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml</a></p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>二、端口利用方式</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.1 基于传输层的资源耗尽攻击（DDoS）</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">该攻击是非常有效的利用小流量冲击大带宽的攻击手段，也是十分常见的攻击方式。其本质还是利用 TCP 协议的链接建立（三次握手）及链接关闭（四次挥手）阶段机制漏洞进行攻击，链接资源耗尽攻击方式主要分为以下几个类别：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（1）&nbsp;SYN flood</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">SYN flood 是基于 TCP 协议产生的，它利用三次握手机制，制造多个半连接，消耗服务器的连接数。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.44166666666666665" data-s="300,640" src="https://oscimg.oschina.net/oscnet/8c97a12b-6829-4190-9266-30e097022e4a.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">图 2&nbsp;SYN flood 示意图</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">攻击者伪造源 IP 地址向服务器发送大量的 SYN 报文，请求建立三次握手。由于发送源 IP 是伪造的，所以服务器回应了 SYN-ACK 报文后，源 IP 并不会再继续回应 ACK 报文进行确认。这样服务器就会维持一个庞大的等待列表，不停地重试发送 SYN-ACK 报文，同时占用着大量的资源无法释放。这就导致，被攻击的服务器被恶意半连接占满，不再接受新的 SYN 请求，而合法用户无法完成三次握手建立 TCP 连接。另外，随着对抗技术的持续演进，攻击者通过肉鸡或 Ddos 服务发起大规模分布式真实 IP 集中进行资源耗尽攻击，此类攻击成功率更高。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（2）SYN-ACK Flood</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通信双方通过三次握手建立一个 TCP 连接的过程中，SYN-ACK 报文出现在第二次握手中，是用来确认第一次握手的。一方收到 SYN-ACK 报文后，首先会判断该报文是不是属于三次握手范畴之内的报文。如果都没有进行第一次握手就直接收到了第二次握手的报文，那么就会向对方发送 RST 报文，告知对方其发来报文有误，不能建立连接。SYN-ACK Flood 攻击正是利用了这一点，攻击者利用工具或者操纵僵尸主机，向目标服务器发送大量的 SYN-ACK 报文，这些报文都属于凭空出现的第二次握手报文，服务器忙于回复 RST 报文，导致资源耗尽，无法响应正常的请求。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（3）ACK Flood</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">在 TCP 三次握手的过程中，ACK 报文出现在第三次握手中，用来确认第二次握手中的 SYN-ACK 报文。ACK Flood 攻击指的是攻击者利用工具或者操纵僵尸主机，向目标服务器发送大量的 ACK 报文，服务器忙于回复这些凭空出现的第三次握手报文，导致资源耗尽，无法响应正常的请求。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（4）FIN/RST Flood</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">TCP 交互过程中还存在 FIN 和 RST 报文，FIN 报文用来关闭 TCP 连接，RST 报文用来断开 TCP 连接。这两种报文也可能会被攻击者利用来发起 DDoS 攻击，导致目标服务器资源耗尽，无法响应正常的请求。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（5）TCP connection Flood</strong></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">TCP 是面向连接的协议，通信双方必须保持连接状态，并且通过确认、重传、滑动窗口等机制，保证数据传输的可靠性和稳定性。攻击者利用 TCP 协议的上述特点，在 TCP 连接上做文章，利用 TCP 连接来消耗被攻击目标的系统资源。例如，攻击者与被攻击目标完成三次握手后，立刻发送 FIN 或 RST 报文，释放本端连接，同时快速发起新的连接，以此来消耗被攻击目标的系统资源，或者攻击者与被攻击目标完成三次握手后，发送很少的报文来维持连接状态，通过这种异常的 TCP 连接来消耗被攻击目标的系统资源。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.2 基于应用层的资源耗尽攻击（cc）</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">CC 攻击的原理就是攻击者控制某些主机不停地发大量数据包给对方服务器造成服务器资源耗尽，一直到宕机崩溃。CC 主要是用来消耗服务器资源的，每个人都有这样的体验：当一个网页访问的人数特别多的时候，打开网页就慢了，CC 就是模拟多个用户 (多少线程就是多少用户) 不停地进行访问那些需要大量数据操作 (就是需要大量 CPU 时间) 的页面，造成服务器资源的浪费，CPU 长时间处于 100%，永远都有处理不完的连接直至就网络拥塞，正常的访问被中止。以下介绍一些 cc 攻击的常用变种。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（1）基于 HTTP-header 慢速 cc 攻击</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Web 应用在处理 HTTP 请求之前都要先接收完所有的 HTTP 头部，因为 HTTP 头部中包含了一些 Web 应用可能用到的重要的信息。攻击者利用这点，发起一个 HTTP 请求，一直不停的发送 HTTP 头部，消耗服务器的连接和内存资源。抓包数据可见，攻击客户端与服务器建立 TCP 连接后，每 30 秒才向服务器发送一个 HTTP 头部，而 Web 服务器再没接收到 2 个连续的\r\n 时，会认为客户端没有发送完头部，而持续的等等客户端发送数据。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（2）基于 HTTP-body 慢速 cc 攻击</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">攻击者发送一个 HTTP POST 请求，该请求的 Content-Length 头部值很大，使得 Web 服务器或代理认为客户端要发送很大的数据。服务器会保持连接准备接收数据，但攻击客户端每次只发送很少量的数据，使该连接一直保持存活，消耗服务器的连接和内存资源。抓包数据可见，攻击客户端与服务器建立 TCP 连接后，发送了完整的 HTTP 头部，POST 方法带有较大的 Content-Length，然后每 10s 发送一次随机的参数。服务器因为没有接收到相应 Content-Length 的 body，而持续的等待客户端发送数据。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（3）基于 HTTP-read 慢速 cc 攻击</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">客户端与服务器建立连接并发送了一个 HTTP 请求，客户端发送完整的请求给服务器端，然后一直保持这个连接，以很低的速度读取 Response，比如很长一段时间客户端不读取任何数据，通过发送 Zero Window 到服务器，让服务器误以为客户端很忙，直到连接快超时前才读取一个字节，以消耗服务器的连接和内存资源。抓包数据可见，客户端把数据发给服务器后，服务器发送响应时，收到了客户端的 ZeroWindow 提示（表示自己没有缓冲区用于接收数据），服务器不得不持续的向客户端发出 ZeroWindowProbe 包，询问客户端是否可以接收数据。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">剖析其原理，本质上还是对任何一个开放了 HTTP 访问的服务器 HTTP 服务器，先建立了一个连接，指定一个比较大的 content-length，然后以非常低的速度发包，比如 1-10s 发一个字节，然后维持住这个连接不断开。如果客户端持续建立这样的连接，那么服务器上可用的连接将一点一点被占满，从而导致拒绝服务。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.3&nbsp;基于端口发起的渗透测试</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">IP 和端口作为应用暴露在公网的唯一入口，攻击者通常发起渗透测试的起点便是通过扫描目标 IP 上的开放端口来发现系统的漏洞、薄弱点或安全隐患。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">往往服务器系统本身或引入的应用服务就具备一定的脆弱性，攻击者获取到目标服务器的端口列表后会逐一去比对自己的武器库进行漏洞利用尝试。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以下是整理的常见端口利用清单及攻击利用方式：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.787962962962963" data-s="300,640" src="https://oscimg.oschina.net/oscnet/ffff7d43-b2d6-4387-8509-ca5522e4afd4.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">图 3 常见的端口利用清单</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>三、基于端口利用的案例</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;"><strong>Equifax 数据泄露案落幕：七亿赔款，索赔期限延长四年</strong></p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6046511627906976" data-s="300,640" src="https://oscimg.oschina.net/oscnet/67512766-7039-4567-9399-288fd0ae5076.jpg" data-type="jpeg" data-w="860" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;letter-spacing: 0.034em;color: rgb(136, 136, 136);">图 4 EQUIFAX （图片来源：<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fglobalnews.ca%2F" textvalue="globalnews.ca" linktype="text" imgurl="" tab="outerlink" data-linktype="2">globalnews.ca</a>）<br></span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">2017 年 9 月，Equifax 系统遭到黑客攻击，导致超过 1.45 亿美国消费者的个人信息，以及 1520 万英国居民的记录和 8000 名加拿大用户的数据遭到泄露，其中包括姓名、地址、出生日期、身份证号、护照、驾照、信用卡等信息。事件曝光后，Equifax 股票暴跌 30%，相当于蒸发掉 50 亿美元市值，成为史上罕见大型数据泄露事件之一。2018 年 12 月，美国国会众议院的政府改革暨监督委员会发布报告指出，因 Equifax 公司组织架构的缺陷，导致公司部门间的沟通失效，从而致使大量的关键系统补丁没有被及时开发，其中包括一个超 19 个月未做更新的漏洞。最终，黑客对 Equifax 进行了长达 76 天的攻击，先后 265 次从公司获取未被加密的数据。该事件最初是由于 Equifax 未修补针对 Apache Struts 的漏洞而导致的，攻击者利用该漏洞访问了 Equifax 的数据库，这个漏洞是通过开放的 80 端口进行攻击的。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;"><strong>爱尔兰国家医疗保健局数据泄露事件</strong></p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6926829268292682" data-s="300,640" src="https://oscimg.oschina.net/oscnet/e6de8c64-5e42-4524-9573-34df37515805.jpg" data-type="jpeg" data-w="615" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">图 5 爱尔兰衞生部&nbsp;</span></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">（图片来源：<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sohu.com%2Fa%2F480716983_121123851" textvalue="https://www.sohu.com/a/480716983_121123851" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.sohu.com/a/480716983_121123851</a>）</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">爱尔兰国家医疗保健局（HSE）是负责为爱尔兰居民提供医疗保健的机构。在 2021 年 5 月，该机构发生了一起数据泄露事件，影响到数百万个患者的个人信息。该事件起因于攻击者通过暴露的 VPN 服务端口进行攻击，成功登录了 HSE 的 IT 系统。接着，攻击者开始利用系统漏洞，并最终获取了 HSE 服务器的管理员权限。攻击者随后将一个 WastedLocker 勒索软件的恶意代码安装在服务器上，并要求赎金以释放数据。在攻击过程中，攻击者还利用了 HSE 的 Exchange 电子邮件系统，以及 HSE 员工用于管理患者信息的软件系统。这些系统中的漏洞使得攻击者能够访问和窃取大量患者的个人信息，包括姓名、出生日期、地址、电话号码、诊断信息和病历等。据称，该事件涉及到的患者数量达到了数百万。HSE 在发现事件后，立即关闭了受影响的系统，并采取措施保护患者数据的安全。HSE 还与执法部门和网络安全专家合作，以追查攻击者的身份和追回数据。截至目前，尚未有人或组织宣称对此次攻击负责。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>四、端口风险防护及治理实践</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.1&nbsp;端口风险防护</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">无论是 Flood 还是 cc 防护，一般都是借助一些安全设备及安全设备提供的策略定制能力，流量级的可以依靠运营商提供的抗 D 服务，如云盾、云堤，流量清洗服务等，面向应用层的攻击可以借助防火墙，WAF，NIDS 等安全设备/节点提供的能力。无论是借助厂商还是自身建设抗 D 能力，<strong>都需要摸清企业所面临的资源耗尽风险，一方面理清基础架构的脆弱点，治理脆弱点；另一方面需要熟悉攻击利用原理，制定针对性策略来进行异常检测及攻击缓解。</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">这里简述一些对抗思路，例如上文提到 SYN Flood 攻击，其本质上是利用 TCP 建立链接的机制漏洞，只要持续发送建立链接请求，服务端就会进行响应同时在连接池里记录一条链接，那么依据该原理，防护思路就很明确了：</p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;"><strong>1. 对发起源进行主动认证</strong></p><p style="text-wrap: wrap;"><strong><br></strong></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.5030549898167007" data-s="300,640" src="https://oscimg.oschina.net/oscnet/4f91784c-a5bc-44b3-874a-575b58e44aa2.png" data-type="png" data-w="982" style="font-size: 15px;letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="color: rgb(136, 136, 136);font-size: 14px;">图 6 主动认证示意图</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>当连续一段时间内去往目标服务器的 SYN 报文超过告警阈值后，抗 DDoS 设备启动源认证机制。源认证机制启动后，抗 DDoS 设备将会代替服务器向客户端响应带有正确确认序号的 SYN-ACK 报文；</p></li><li><p>如果这个源是虚假源，是一个不存在的地址或者是存在的地址但却没有发送过 SYN 报文，不会做出任何响应；</p></li><li><p>如果这个源是真实客户端，则会向服务器发送 ACK 报文，对收到的 SYN-ACK 报文进行确认。抗 DDoS 设备收到 ACK 报文后，将该客户端的源 IP 地址加入白名单。同时，抗 DDoS 设备会向客户端发送 RST 报文，要求重新建立连接；</p></li><li><p>后续这个客户端发出的 SYN 报文命中白名单直接通过。</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;首包丢弃</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.0574074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/afd85ac0-8ab8-4f3c-874c-b655dcb18041.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="color: rgb(136, 136, 136);font-size: 14px;">图 7 首包丢弃示意图</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">TCP 的可靠性保证除了面向连接（三次/四次握手）之外，还体现在超时与重传机制。TCP 协议规范要求发送端每发送一个报文，就启动一个定时器并等待确认信息；如果在定时器超时前还没有收到确认，就会重传报文。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">首包丢弃功能就是利用了 TCP 的超时重传机制，Anti-DDoS 系统对收到的第一个 SYN 报文直接丢弃，然后观察客户端是否重传。如果客户端重传了 SYN 报文，再对重传的 SYN 报文进行源认证，即反弹 SYN-ACK 报文，这样就可以大大减少反弹报文的数量。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>混合使用，效果更佳</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">实际部署时，一般将首包丢弃和源认证结合使用。防御 SYN Flood 攻击时，先通过首包丢弃功能来过滤掉一些攻击报文，当重传的 SYN 报文超过告警阈值后，再启动源认证。这样就能够减少反弹的 SYN-ACK 报文的数量，缓解网络拥塞情况。对于虚假源攻击，尤其是对于不断变换源 IP 和源端口的虚假源攻击，可以达到最佳防御效果。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>针对连接耗尽场景，其防御思路可以总结为以下内容：</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">针对此攻击会耗尽服务器的 TCP 连接资源的特点，对目的 IP 地址的新建连接速率和并发连接数分布进行统计，当新建连接速率或并发连接数大于阈值时，则触发对源 IP 地址的相应检查，当检查发现异常时，将异常源 IP 地址加入黑名单，切断其 TCP 流量。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>源 IP 地址新建连接速率检查：启动源 IP 地址新建连接速率检查后，如果某个源 IP 地址在检查周期内发起的 TCP 新建连接数大于阈值，则将该源 IP 地址判定为攻击源。</p><p><br></p></li><li><p>源 IP 地址并发连接数检查：启动源 IP 地址并发连接数检查后，如果某个源 IP 地址的 TCP 并发连接数大于阈值，则将该源 IP 地址判定为攻击源。</p><p><br></p></li><li><p>慢速连接速率检查：启动慢速连接速率检查后，统计同一源 IP 地址对同一目的 IP 地址的连接次数，在各统计时间间隔内，如果连续多次连接数相同并超过阈值，则判定为 TCP 慢速连接攻击。</p><p><br></p></li><li><p>异常会话检查：如果在检查周期内，某个源 IP 地址发起的 TCP 异常会话的连接数大于阈值时，则将该源 IP 地址判定为攻击源。</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">判定 TCP 异常会话依据如下：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>【空连接检查】：如果在检查周期内，在某条 TCP 连接上通过的报文数小于阈值，则判定该连接为异常连接。</p></li><li><p>【重传会话检查】：当某条 TCP 连接上重传报文数量大于阈值时，则判定该连接为异常连接。</p></li><li><p>【慢启动连接检查】：当某条 TCP 连接上通过的报文窗口小于阈值时，则判定该连接为异常连接。</p></li><li><p>当异常会话数超过一定数量时，将此源加入黑名单。异常会话数量可配置。</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>同样的，应用层 CC 攻击，按照相对应的原理进行内容检查，这也是一般 WAF 或 NIDS 设备提供的基础能力，这里就不再累述。</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.2&nbsp;端口风险治理实践</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">上段内容有提到的防护思路，理解协议的脆弱性原理再依据攻击者的视角进行防护措施的定制，则会有比较清晰的防护思路和防护效果，因此在端口安全治理实践上，我们通过建立常态化端口发现机制以及常态化的漏洞扫描机制，将网络端口及端口漏洞风险进行持续统一治理，同时建立基于流量的异常识别能力丰富基于行为的异常端口检测能力，再辅以脆弱性管理以及端口生命周期管理（规范与流程）来形成整个端口安全治理体系。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 建立常态化的端口发现机制</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">使用网络发现工具进行异常端口识别，设计思路是首先通过 vscheduler 中间件触发扫描（支持两种模式：一网段配置表全表网段扫描、二是：指定网段扫描。），调用扫描工具（以 nmap 为例）进行扫描，通过增加两个异步线程去读取缓冲区内容以解决缓冲区拥塞问题，通过异步线程进行缓冲区内容读取以及清理的同时通过错误缓冲区内容判断是否扫描失败。扫描结果输出 xml 后通过 dom4j 进行解析，再进行分批保存，避免大事务以及减少 jvm 内存占用。最后把文件删除，释放存储空间。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.34629629629629627" data-s="300,640" src="https://oscimg.oschina.net/oscnet/70667ba7-7a93-43b8-9c41-cca278403648.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">图 8 端口扫描架构图</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;建立常态化漏洞扫描机制</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">结合漏洞扫描工具及端口扫描工具构建自动化漏洞扫描平台，漏扫平台架构设计思路如下图：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6351851851851852" data-s="300,640" src="https://oscimg.oschina.net/oscnet/090f99ff-bff8-4792-9c61-7362919ce184.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="color: rgb(136, 136, 136);font-size: 14px;">图 9 漏扫平台架构图</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">该系统架构的核心功能点包括：资产收集、Web 漏洞扫描、依赖包扫描、端口扫描，辅助功能包括：扫描任务管理、风险管理等。</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>【资产收集】：</p></li><li><p>扫描的目标是公司的网络资产，没有资产无法进行扫描，资产不全面扫描的效果也会打折扣，所以平台采集了多种途径进行资产的采集，力求做到无遗漏，持续丰富采集的手段。</p></li><li><p>【Web 漏洞扫描】：</p><p>用于发现暴露在公网的站点、URL 等 Web 资源是否存在漏洞。<br></p></li><li><p>【依赖包扫描】：</p><p>用于发现线上业务是否使用了高危的 Java 依赖包。</p></li><li><p>【端口扫描】：</p><p>用于发现公司服务器是否对公网开放了高危端口。</p></li><li><p>【扫描任务管理】：</p><p>无论是依赖包扫描、端口扫描，都是通过创建扫描任务的形式来发起的，扫描任务分为立即扫描任务和定时扫描任务两种类型，用户可以创建立即扫描任务来一次性执行扫描，也可以创建定时任务来周期性执行扫描。</p></li><li><p>【风险管理】：</p><p>对于扫描出来的 Web、依赖包和端口风险，系统能够对其处理状态进行管理，以便安全工程师对风险状态进行跟踪和处理。</p></li><li><p>【工单管理】：</p><p>对于扫描出来的 Web、依赖包和端口风险，运营人员可对其创建工单，工单会对接到漏洞管理系统，通过漏洞管理系统的工单体系来对跟踪风险的处理进程。</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">常用的漏扫工具：</p><section style="font-size: 15px;line-height: 1.5;"><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>【Nmap】：</p><p>Nmap 是一款常用的网络发现和安全审计工具，支持多种扫描技术和扫描选项，可以快速扫描本地或远程计算机上的开放端口和服务。</p></li><li><p>【Masscan】：</p><p>Masscan 是一款高速的端口扫描工具，可以在短时间内扫描数百万个端口，支持 TCP 和 UDP 扫描，适用于大规模网络扫描。</p></li><li><p>【Zenmap】：</p><p>Zenmap 是 Nmap 的图形用户界面（GUI）版本，可以方便地进行扫描选项配置和结果分析。</p></li><li><p>【Angry IP Scanner】：</p><p>Angry IP Scanner 是一款轻量级的端口扫描工具，支持多线程扫描和快速扫描本地网络和远程主机。</p></li><li><p>【SuperScan】：</p><p>SuperScan 是一款 Windows 平台上的端口扫描工具，支持 TCP 和 UDP 扫描、多线程扫描、服务版本识别等功能。</p></li><li><p>【Unicornscan】：</p><p>Unicornscan 是一款高速的网络扫描工具，支持 TCP、UDP、ICMP 等多种扫描方式和扫描选项。</p></li><li><p>【Netcat】：</p><p>Netcat 是一款多功能的网络工具，其中包括端口扫描功能，支持 TCP 和 UDP 扫描，可以快速扫描本地或远程计算机上的开放端口和服务。</p></li></ul></section></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>3.&nbsp;建立基于流量的异常识别能力</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（1）流量基线学习</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">流量基线一般对五元组进行配置学习，通过对比应用流量基线，发现孤立的端口流量，对比端口开放库以发现异常开放的端口，另外，可以同步建设告警能力与处置能力，在发现异常的第一时间切断风险源头。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.5585106382978723" data-s="300,640" src="https://oscimg.oschina.net/oscnet/7a8242ee-8c70-4d47-8f96-d25e0bc636ca.png" data-type="png" data-w="752" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">图 10 基线学习</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">流量基线学习的核心表：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>【策略快照表】：</p><p>从离线同步过来的每个小时的服务维度的多种策略计算结果</p></li><li><p>【学习配置表】：</p><p>用于存放学习配置，包括各种策略的加解锁条件（偏离阈值+次数）、偏离告警条件（偏离阈值+次数，可以预留出来，告警下迭代做）</p></li><li><p>【当前策略集】：</p><p>服务维度自定义的的策略集</p></li><li><p>【策略状态表】：</p><p>记录各个服务节点的锁状态，偏离情况，策略生效时间等</p></li><li><p>【策略目标集】：</p><p>部分策略拥有自己的目标机器/服务结算逻辑，该表用于存放目标范围，用于定时清理不在目标集的策略</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）异常检测</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通过对上节提到的流量基线结果的数据分析来识别网络个体或群体的异常行为，一方面建立行为偏离预警机制，另一方面需要引入一些统计分析模型帮助建立阈值点，在偏离预警机制这块我们做了一些架构实践，其逻辑简单描述如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6716981132075471" data-s="300,640" src="https://oscimg.oschina.net/oscnet/94966a61-a614-46b5-8441-05525442a106.jpg" data-type="jpeg" data-w="795" style="" referrerpolicy="no-referrer"></p><p><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">行为偏离比对逻辑：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.42362002567394097" data-s="300,640" src="https://oscimg.oschina.net/oscnet/89ad5fbd-82ed-46d0-9ebc-a7dcfd769801.png" data-type="png" data-w="779" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">总结四个关键点分别为：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><strong>配置文件</strong>，用于描述对应服务的流量特征</p></li><li><p><strong>上锁</strong>，参数或配置文件在满足预设规则条件下或人工干预下停止动态学习行为</p></li><li><p><strong>解锁</strong>，参数或配置文件在满足预设规则条件下或人工干预下重新开始动态学习行为</p></li><li><p><strong>偏离</strong>，指同一服务下某一时间切片的配置文件与已上锁的配置文件的参数值对比，发生超过阈值的变化</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">此外便是阈值的设定问题，通过引入统计模型的使用来帮助我们制定阈值，常用的入侵检测统计模型有以下几类：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><strong>操作模型</strong>：该模型假设异常可通过测量结果与一些固定指标相比较得到，固定指标可以根据经验值或一段时间内的统计平均得到，举例来说，在短时间内多次针对某一端口尝试建立连接失败，则可能是针对端口的拒绝服务</p></li><li><p><strong>方差</strong>：这也是常用的模型，通过计算参数的方差，设定置信区间，当测量值超过置信区间的范围时表明可能存在异常</p></li><li><p><strong>多元模型</strong>：操作模型的扩展，通过同时分析多个参数实现异常检测</p></li><li><p><strong>马尔柯夫过程模型</strong>：将每种类型的事件定义为系统状态，用状态转移矩阵来表示状态的变化，当一个事件发生时，如果状态矩阵中该转移的概率较小则可能是异常事件</p></li><li><p><strong>时间序列分析</strong>：将流量切片特征提取出来按照时间排成序列，如果一个新的请求或一个新的请求集合在该时间发生的概率较低，则该事件可能是异常</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">在异常识别这块通常也会引入基于图的数据分析方法，针对网络个体和网络群体进行流量行为分析来发现异常行为，但应用起来相对较为复杂，也需要较高学习与实践成本，这块更多在 NIDS 的应用范畴，在此模块不再赘述。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">需要提醒的是以上这种方法还是存在一些局限，如爬虫类服务，商业广告类服务因为其服务的特殊性，以上机制比较难进行准确的基线生成，虽说无法解决 100% 的问题，但也能 cover 住大部分的服务类型，同样的，在这个领域还需要持续探索来提升服务类型的覆盖率以及异常检测精度。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>4. 健全脆弱性管理能力实现风险追踪与闭环</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">端口暴露的最核心问题就是脆弱性利用，因此健全基础架构的脆弱性管理能力是阻断外部威胁，有效控制风险的重要手段，我们通过建立统一的脆弱性管理平台来建立业务关系流，脆弱性库，资产三者的关联关系，针对脆弱性做到持续发现，持续修复并将脆弱性作为安全告警关联分析中的重要评价维度。脆弱性管理系统因其安全管理战略特殊性，此处只能简单介绍给读者一些建设思路：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>脆弱性管理系统核心功能模块结构</strong><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.1944444444444444" data-s="300,640" src="https://oscimg.oschina.net/oscnet/1927c6cb-f74d-4bff-ac4b-21a4364a1376.png" data-type="png" data-w="936" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">另外脆弱性关联分析 AVC 是脆弱性管理系统的核心功能，读者可以从以下评价维度进行建设实践：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.47129629629629627" data-s="300,640" src="https://oscimg.oschina.net/oscnet/4effb9d9-df3a-4e35-9085-79d4b7e1ee29.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>5.&nbsp;完善端口生命周期管理（规范与流程）</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（1）制定端口管理规范</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">规范原则</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><strong>最小权限原则</strong>：端口开放遵循最小权限原则，只允许开放运行 http 和 https 的 80/443 端口，其他对外开放的端口必须有合理的业务理由，并且应该只开放业务需要的最小端口集合，由端口使用者提出工作联络单进行申请经审批同意后方可开放。</p></li><li><p><strong>可审计原则</strong>：所有端口开放都必须有可追溯的对应申请依据、安全性评估依据、审批依据，不允许私自开放端口。</p></li><li><p><strong>闭环原则</strong>：端口开放应实施闭环管理，在业务不再需要时，应及时关闭端口。</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">对端口进行明确定义</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.325" data-s="300,640" src="https://oscimg.oschina.net/oscnet/8fa433a8-b65b-4250-93e5-b09f8e6d64d1.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;text-align: center;" powered-by="xiumi.us"><span style="font-size: 14px;color: rgb(136, 136, 136);">图 11 端口定义示例</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">规范内容可包含端口申请规范，端口使用规范，端口关闭规范以及明确的处罚规定。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（2）端口生命周期管理</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">实现从端口申请到端口关闭全流程管理</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><p style="text-wrap: wrap;">应用申请 → 端口记录→ 开墙（映射）→ 安全节点纳管 → 流量反馈 → 主动关闭 → 端口映射记录清除→ 安全节点卸载→ 端口资源池回收</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>（3）持续评估</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">结合异常端口发现机制和端口开放库以及相关流程建立起持续端口风险评估机制，用以保障规范以及风险处置有效性的落地。</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>五、总结</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">端口作为应用对外暴露的主要入口，是应用暴露在公网上的标识，因此端口安全建设是企业信息安全防护体系中的重要一环，安全团队需要详细了解其内部网络中使用的所有端口，以及开放和关闭的端口数量和情况，在理解协议的脆弱性原理基础上制定合适的安全策略和措施。同时再安全策略和措施制定的过程中，通过对各类端口扫描工具的使用，安全团队可以快速获取目标网络中的端口开放情况。然后根据扫描结果，采取合适的安全策略和措施，禁止不必要端口的开放或者采取过滤、加密等方式对端口进行保护。在技术实践上，建设常态化端口发现机制以及常态化的漏洞扫描机制，将网络端口及端口漏洞风险进行持续统一治理，同时建立基于流量的异常识别能力丰富基于行为的异常端口检测能力，再辅以脆弱性管理以及端口生命周期管理（规范与流程）来形成整个端口安全治理体系。另外值得强调的是，全员网络安全意识的水位决定整体安全态势的下限，个人行为和错误配置通常是网络漏洞的一大原因，因此安全管理团队需要持续加强内部员工的网络安全教育和培训，提高其网络安全意识和知识水平，建立全员参与的安全意识文化。总的来说，可以通过规范，流程，技术和人员意识培训来构建全面的网络端口风险治理体系。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="color: rgb(65, 95, 255);" powered-by="xiumi.us"><p style="text-wrap: wrap;">参考文献：</p></section><section powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><span style="font-size: 14px;">《网络端口安全治理的研究与实践》（姜云飞，高国权，张全超，2019）</span></p></li><li><p><span style="font-size: 14px;">《基于漏洞扫描的网络端口安全治理研究》（黄珂，杨明，张鹏飞，2017）</span></p></li><li><p><span style="font-size: 14px;">《基于流量监测的网络端口安全治理技术研究》（胡彩玲，申伟，周婷婷，2016）</span></p></li><li><p><span style="font-size: 14px;">《网络端口安全治理技术研究》（程显霞，郑晓宁，2014）</span></p></li><li><p><span style="font-size: 14px;">《网络端口安全治理策略研究》（朱绍军，李彦霞，陈琳琳，2013）</span></p></li><li><p><span style="font-size: 14px;">vivo 互联网端口开放管理规范</span></p></li><li><p><span style="font-size: 14px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.csdn.net%2FJackMaF%2Farticle%2Fdetails%2F123676195" textvalue="什么是网络端口？" linktype="text" imgurl="" tab="outerlink" data-linktype="2">什么是网络端口？</a></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2FShepherdzhao%2Fp%2F15219310.html" textvalue="【漏洞分析】DDOS 攻防分析（四）——TCP 篇" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">【漏洞分析】DDOS 攻防分析（四）——TCP 篇</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fkenshinobiy%2Fp%2F10215913.html" textvalue="CC 攻击原理及防范方法和如何防范 CC 攻击&nbsp;" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">CC 攻击原理及防范方法和如何防范 CC 攻击&nbsp;</span></a><span style="font-size: 14px;"></span></p></li><li><p><span style="font-size: 14px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.csdn.net%2Fweixin_50464560%2Farticle%2Fdetails%2F118962399" textvalue="常用的端口攻击" linktype="text" imgurl="" tab="outerlink" data-linktype="2">常用的端口攻击</a></span></p></li><li><p><span style="font-size: 14px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fforum.huawei.com%2Fenterprise%2Fzh%2Fthread%2F580895552575520769" textvalue="TCP 连接耗尽攻击与防御原理" linktype="text" imgurl="" tab="outerlink" data-linktype="2">TCP 连接耗尽攻击与防御原理</a></span></p></li><li><p><span style="font-size: 14px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.freebuf.com%2Farticles%2Fnetwork%2F258061.html" textvalue="DDOS 之 TCP 连接耗尽攻击与防御" linktype="text" imgurl="" tab="outerlink" data-linktype="2">DDOS 之 TCP 连接耗尽攻击与防御</a></span></p></li></ol><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;"><section style="text-align: center;color: rgb(45, 66, 87);font-size: 11px;" powered-by="xiumi.us"><p>END</p></section></section><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: left;" powered-by="xiumi.us"><section style="padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;"><span style="display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);" title="" opera-tn-ra-cell="_$.pages:0.layers:0.comps:224.title1"><p>猜你喜欢</p></span></section><section style="border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;"><section style="font-size: 14px;text-align: left;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497432%26idx%3D1%26sn%3Df372c83043de8da859cec802976e371a%26chksm%3Debdb864adcac0f5cf753444f2c9198b08d6b0831e66e4b5b6405a1eaa32e53b8747aa9dc1217%26scene%3D21%23wechat_redirect" textvalue="Dubbo 路由及负载均衡性能优化" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">Dubbo 路由及负载均衡性能优化</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D1%26sn%3D5795a683e52f70384a13b34aa3daf731%26chksm%3Debdb8632dcac0f2468a461db09d8de6219af346e51436b91e6c946ee8b37e6ae8175b2f5d55e%26scene%3D21%23wechat_redirect" textvalue="深入理解 Netty FastThreadLocal" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">深入理解 Netty FastThreadLocal</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497343%26idx%3D1%26sn%3D959b66ceb9a8c2fe060b6981b41a807e%26chksm%3Debdb86eddcac0ffb229636ec51ec94433af75c7bc58aaa5ae52b4a2bf6a2d6d2ab11583b3174%26scene%3D21%23wechat_redirect" textvalue="记一次 Redis Cluster Pipeline 导致的死锁问题" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">记一次 Redis Cluster Pipeline 导致的死锁问题</a><br></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互联网技术" data-alias="vivoVMIC" data-signature="分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Fri, 03 Nov 2023 02:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10140381</guid>
            <link>https://my.oschina.net/vivotech/blog/10140381</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[TUI 库开发商 Charm 融资 600 万，打造下一代命令行]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>TUI 库开发商 Charm <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcharm.sh%2Fblog%2Fthe-next-generation%2F" target="_blank">宣布融资 600 万美金</a></u>。Charm 专注于命令行工具开发，目标是让命令行变得充满魅力、功能强大、有趣和现代化。</p><p><img src="https://static.oschina.net/uploads/space/2023/1103/190910_uqZD_2720166.png" referrerpolicy="no-referrer"></p><p>从 Charm 的 GitHub 开源主页看到，其最欢迎的项目均采用 Go 语言开发。</p><p>简单列举几个：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcharmbracelet%2Fbubbletea%23bubble-tea" target="_blank">Bubble Tea</a>：功能强大的轻量级 TUI 框架</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcharmbracelet%2Fgum%23gum" target="_blank">Gum</a>：界面优雅的 Shell 脚本工具</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcharmbracelet%2Fvhs%23vhs" target="_blank">VHS</a>：CLI 录制工具</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcharmbracelet%2Fglow%23glow" target="_blank">Glow</a>：命令行界面 Markdown 渲染工具</li></ul><p><img height="1242" src="https://static.oschina.net/uploads/space/2023/1103/192626_xjM1_2720166.png" width="3114" referrerpolicy="no-referrer"></p><p><em>△&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcharmbracelet" target="_blank">https://github.com/charmbracelet</a></u></em></p><p>Charm 公司认为，在过去的 30 多年里，命令行一直是无处不在的计算平台，部分原因归功于<strong>它是专注于做好一件事的简单工具</strong>，并且能够轻松地将这些工具组合成独特的解决方案，以及有大量的现有命令行程序库可供使用。这些特性与当代互联网及其孤立的数据、缺乏可组合性以及大型、不透明的解决方案形成了鲜明对比，后者往往包含大量的跟踪、广告和其他「黑暗面」。</p><p>在他们看来，命令行是网络和封闭移动平台的健康替代品。当前更新的时机也已经成熟，重点是打造以用户为中心的设计和加密的自托管网络服务。他们希望为下一个 30 年打造命令行平台。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 11:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264838</guid>
            <link>https://www.oschina.net/news/264838</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[数据库国产化，是一门圈钱的生意吗？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>最近两天，技术圈掀起了一场关于数据库国产化的大讨论，国产数据库到底是真自研还是来套壳圈钱的？</p><p><span style="background-color:#ffffff; color:#333333">开源 PG 发行版&nbsp;</span>Pigsty 创始人冯若航在微信公众号「非法加冯」发布的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fvh1JE_BdaLetWtt5vvPDDw" target="_blank">《数据库真被卡脖子了吗？》</a>一文认为，<strong>很多「国产数据库」就是烂泥扶不上墙的残次品。<span style="background-color:#ffffff; color:#3f3f3f">把开源免费的软件包装一下，用 Oracle 的价格卖给你！</span></strong></p><p>「真正自研的数据库出现两极分化：极少数真正有创新贡献与使用价值的产品爱惜羽毛，不会刻意标榜「国产」。而剩下的大多数往往多是闭门造车、技术落后的土法数据库，或者开源古早分叉、负向阉割出来的劣质轮子。国产数据库并非没有踏实做事的好公司，只是「国产」这个标签被大量钻入数据库领域的平庸低劣产品污染。</p><p>「更让人扼腕的是劣币驱逐良币。本已稀缺的数据库研发人力经过这样的挥霍，反而会真正卡死国内数据库产业的脖子。特别是核心的 OLTP/关系型数据库领域因为开源的存在，已经不缺足够好用的内核了。能把 PostgreSQL / MySQL 用好并提供服务支持，远比自欺欺人的大炼内核要有价值的多。」</p><p>冯若航认为，业界已经不缺足够完美的数据库内核了 —— 比如 PostgreSQL，功能完备且开源免费（BSD-Like）。无数」国产数据库「基于 PG 换皮套壳魔改而成。如果说谁在数据库内核上被卡了脖子，那肯定是吃饱了撑着给噎着的。</p><p>但数据库国产化又是必要的，正如微信公众号「白鳝的洞穴」发布的文章<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F1btCxNVkBOirr_O05P__YA" target="_blank">《数据库国产化是在套壳圈钱吗》</a>所言：「<strong>一旦<span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">上了老美的黑名单，你想买 Oracle 人家也不卖了。」</span></strong></p><p><strong>文章还认为，利用国产数据库去圈钱真的有点脑洞太大了。</strong></p><p>「想要圈钱的人，没必要去搞数据库，有大量的可以更好圈钱的项目可以去折腾。我所见到的国产数据库的朋友，大多数还是有些情怀的。就像十年前我见到南大通用当时的董事长崔维力的时候他所说的想干点点天元的事情的时候的感受一样，只有有点情怀的人才会去干这种十分长线的、不知道啥时候能挣着钱的买卖。</p><p>」我认识的朋友中不乏一些在数据库领域中很成功的人，自从入圈自研数据库后，虽然也看到他们几个亿几个亿的融资，不过算下来，这些人干的基本上都是过路财神的活，融来的钱很快就填到无底洞似的研发与营销中了。虽然如此，国产数据库企业的技术人员待遇并不高，除了几家财大气粗，能够长期大投入的企业外，大多数国产数据库企业的研发骨干和管理高层并没有像有些人所想象的那样赚得盆满钵满。圈钱之说其实是不成立的，我看到的反而，是有不少国产数据库的从业人员十年清贫，依然痴心不改。这种人哪怕我们不去尊重，也没必要去诋毁他们。」</p><p>去 IOE 已经说了很多年了，真要操作起来，不光是嘴上喊喊口号的事。薛晓刚在其公众号」四海内皆兄弟「发文<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Feetz1aAfa_oogr9keAjJbg" target="_blank">《替换数据库的代价与真假国产》</a>认为，<strong>从开发、运维以及成本的角度来看，放弃 Oracle，替换成国产数据库并不容易。</strong></p><p>」国产也有好的，可能只占少数吧。这些集中在 2016 年以前从事这个行业的，那可能是真的做。就是这个不被看好的时候就做的是还可以的，最起码不是骗人的。至于做的好坏另说啊。总之不是在有了政策之后才冒出来的抢钱就行。但凡是大家一窝蜂的去做的，基本就是乱来了。</p><p>」<span style="background-color:#ffffff; color:#000000">日常我看到不少手机用苹果的，笔记本用 MAC 的，开着特斯拉或者用 IPad 的，对我说要替换某某国产数据库</span>。这些人可能不参与开发，不参与运维，不参与采购，属于站着说话不腰疼的。这些成本谁出？出了问题你上不？不少人连锁是什么都搞不清楚就来说数据库选型这不是外行指挥内行吗？「</p><p><strong>关于数据库国产化替代，你觉得有必要吗？至于国产化的路子，应该重新开发数据库内核，还是基于现有开源数据库搞国产化？数据库自研与否，其实并不难分辨，为什么还会出现那么多圈钱的企业？在评论区留下你的看法吧~</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 11:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/3859945/blog/10140824</guid>
            <link>https://my.oschina.net/u/3859945/blog/10140824</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[KubeEdge-Ianvs v0.2 发布：终身学习支持非结构化场景]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>本文分享自华为云社区《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%2F414430%3Futm_source%3Doschina%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent" target="_blank" rel="nofollow">KubeEdge-Ianvs v0.2 发布：终身学习支持非结构化场景</a>》，作者： 云容器大未来。</p><p>在边缘计算的浪潮中，AI 是边缘云乃至分布式云中最重要的应用。随着边缘设备的广泛使用和性能提升，将人工智能相关的部分任务部署到边缘设备已经成为必然趋势。KubeEdge-Ianvs 子项目，作为业界首个分布式协同 AI 基准测试平台，基于 KubeEdge-Sedna 为算法及服务开发者提供全场景可扩展的分布式协同 AI 基准测试，以研发、衡量和优化分布式协同 AI 系统。</p><p>然而在边缘设备中部署静态的 AI 模型往往不足以应对复杂多变的真实世界环境，因此终身学习能力对于边缘 AI 模型来说变得越来越重要。为了方便边缘 AI 算法研究者开发及测试终身学习算法在真实世界环境中的效果，KubeEdge-Ianvs 在新版本的更新中发布了支持终身学习范式的相关算法的研发与测试功能。</p><p>本篇文章为大家阐释相关<strong>背景</strong>和<strong>Ianvs 终身学习架构</strong>，并<strong>以 Ianvs 云机器人终身学习测试</strong>为例对 Ianvs 终身学习的特性进行介绍。欢迎关注 Ianvs 项目，持续获得第一手独家公开数据集与完善基准测试配套。</p><p>开源项目 GitHub 地址：https://github.com/kubeedge/ianvs</p><span id="OSC_h1_1"></span><h1>一、背景</h1><span id="OSC_h2_2"></span><h2>1.1 终身学习能力对边缘模型越来越重要</h2><p>边缘设备所处的环境通常是不稳定的，环境变化会导致数据分布的大幅变化，即数据漂移。数据漂移会显著降低模型准确性。为了解决数据漂移问题，边缘设备需要具备动态更新模型的能力，以适应环境变化。下图展示了一个典型的终身学习算法流程框架。在该框架中，终身学习任务被定义为：已处理 N 个任务，将陆续处理 M 个任务。如何维护知识库并利用其中的模型处理这些任务是关键。</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/28/28a09244308b8b649ede40334d8c9c5d.png" referrerpolicy="no-referrer"></p><p>终身学习的流程分为四步，首先根据之前已处理的 N 个任务初始化云端的知识库中的已知任务处理模型；然后在遇到新的任务时，从云端知识库中选取合适的模型部署到边缘端处理任务，如果新任务是已知的任务则更新原来的模型，如果遇到了未知任务则重新训练新的模型用于处理该任务；在边缘端处理好该任务后，对云端知识库进行更新；最后遇到新任务时重复前两步操作。通过以上流程可以确保边缘部署的模型具备终身学习的能力，从而可以应对数据漂移等问题带来的影响。</p><span id="OSC_h2_3"></span><h2>1.2 业界缺少合适的终身学习测试工具</h2><p>目前终身学习算法相关测试工具发展较慢，目前比较成熟的测试工具只有 ContinualAI 推出的 Avalanche。Avalanche 支持的特性如下：</p><p>&nbsp;</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/92/92b1cb696aac2abe74896dc16aeefc09.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>Avalanche 支持的特性非常丰富，但是对于终身学习算法开发者来说 Avalanche 还存在一些局限性：</p><p>&nbsp;</p><ul><li><strong>未能覆盖终身学习全生命周期算法</strong>：支持的场景主要局限于增量学习等场景，而终身学习中任务定义、分配以及未知任务识别等流程无法体现在该 benchmark 中。</li><li><strong>缺乏配套真实世界数据集</strong>：配套的数据集主要包括 Split-MNIST、Cifar10 等学术界常用的玩具测试集，缺乏适用的真实世界数据集及配套算法。</li><li><strong>研发算法难以落地</strong>：Avalanche 更多面向终身学习算法的测试实验，并没有考虑未来将算法落地部署的需求。</li></ul><p>&nbsp;</p><div><p>因此目前业界亟需一个更好的终身学习测试 benchmarking 工具，Ianvs 发布的非结构化终身学习新特性可以很好的解决上述问题。</p><span id="OSC_h1_4"></span><h1>二、lanvs 终身学习架构</h1><span id="OSC_h2_5"></span><h2>2.1 Ianvs 终身学习优势</h2><p>终身学习近年来得到了越来越多的关注，越来越多的边缘智能从业者认识到了终身学习的重要性。但是终身学习相比其他 AI 算法来说有着更高的研究门槛，经过我们的调研发现终身学习研发存在<strong>模型训练流程复杂、算法效果难以衡量</strong>和<strong>算法落地应用困难</strong>三大挑战。</p><p><strong>第一个挑战是终身学习模型训练流程较为复杂</strong>，比如对于一个刚入门终身学习的同学来说，可能对终身学习算法流程中的未知任务识别模块比较感兴趣，但是要想完整实现终身学习还需要填补任务定义、任务分配等模块，而这对于刚入门的同学不太友好，想复现别人的工作还需要去额外完成其他终身学习模块。</p><p>针对这一挑战，KubeEdge-Ianvs 中对终身学习全生命周期的各个模块都进行了设计，包括并不限于任务定义、任务分配、未知任务识别和未知任务处理等多个终身学习核心算法模块，各个模块之间是解耦合的，用户可以只研究自己感兴趣的模块，其他模块采用默认配置即可跑通终身学习实验。</p><p><strong>第二个挑战是终身学习算法效果衡量困难</strong>，不同论文中的终身学习算法由于其测试流程不一样难以比较其工作的优劣。同时大部分论文的工作都是在 MNIST、CIFAR10 这些非真实数据集上进行的实验，由于缺乏在真实世界数据集上的测试，算法在现实世界中的实际应用效果往往要大打折扣。</p><p>针对这一挑战，KubeEdge-Ianvs 中对终身学习的测试流程进行了统一，提供 BWT、FWT 等公认的终身学习系统指标，方便衡量算法效果。同时 KubeEdge-Ianvs 开源了 Cloud-Robotics 等真实世界终身学习数据集，并配套了对应的运行样例，用户可以直接开箱使用该真实世界数据集测试自己提出的算法的效果。</p><p><strong>第三个挑战是终身学习算法落地较为困难</strong>，算法研发与实际部署之间存在一定鸿沟。用户训练好的模型需要进一步封装才能实际在生产环境上使用。</p><p>针对这一挑战，KubeEdge-Ianvs 在开发时就考虑到了和其姊妹项目 KubeEdge-Sedna 开源服务平台是配套兼容关系，因此在 KubeEdge-Ianvs 上研发的终身学习算法可以直接迁移到 KubeEdge-Sedna 平台上实现落地部署，解决了从研发到落地最后一公里的问题。</p><p>总而言之，Ianvs 终身学习优势包括：</p><ul><li><p><strong>覆盖终身学习全生命周期</strong>，包括任务定义、任务分配、未知任务识别和未知任务处理等多个模块，各个模块是解耦合的；</p></li><li><p><strong>统一化的测试流程</strong>，系统内置权威的终身学习测试指标，并且支持测试结果的可视化；并提供真实世界数据集用于终身学习测试，能更好测试终身学习算法在真实环境的效果；</p></li><li><p><strong>和</strong><span>&nbsp;</span><strong>KubeEdge-Sedna 终身学习相兼容</strong>，研发算法可以快捷迁移到 Sedna 上实现落地部署。</p></li></ul><span id="OSC_h2_6"></span><h2>2.2 Ianvs 终身学习新特性</h2><p>Ianvs 在去年发布的 0.1.0 版本中已具备支持单任务学习范式和增量学习范式的算法研发与测试，在新版的 Ianvs 中增加了支持对终身学习范式的相关算法的研发与测试的功能，同时也为终身学习算法测试提供了新的开源数据集。主要新特性如下：</p><span id="OSC_h3_7"></span><h3>特性一：覆盖终身学习全生命周期</h3><p>Ianvs 终身学习具体架构如下图所示，主要包括任务定义、任务分配、未知任务识别和未知任务处理等模块，覆盖终身学习全生命周期。</p><p>&nbsp;</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/60/6050b9d43e911475220f06f46c31a403.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>对于已处理任务，Ianvs 通过任务定义模块，将已知任务抽象成若干个模型存储进云端知识库中。在遇到新任务时，Ianvs 首先通过未知任务识别模块判断推理样本属于未知任务还是已知任务。若是已知任务，则从云端知识库中调度对应模型部署在边侧处理该任务，同时基于已知任务样本对模型进行增量更新。若是未知任务，则 Ianvs 通过未知任务处理模块处理该任务，利用外部系统标注并重新训练新的模型用于处理该任务。处理完成后，新的任务模型或是更新后的已知任务模型再重新整合至云端知识库中。</p><p>为了方便初学者使用 Ianvs，在 Ianvs 仓库中的 examples/robot/ 文件夹下提供了一个可以直接运行的样例 https://github.com/kubeedge/ianvs/examples/robot/ ， 详细的教程在第三节。</p><span id="OSC_h3_8"></span><h3>特性二：统一化的测试流程和真实世界数据集</h3><p>Ianvs 对终身学习测试流程进行了统一，主要参考了 NIPS2017 的论文 「Gradient Episodic Memory for Continual Learning」，复现了其中提出的 BWT 和 FWT 指标，用于评价终身学习算法的抗遗忘能力和未知任务泛化能力。</p><p>Ianvs 还开源了 Cloud-Robotics 等真实世界数据集，并提供了配套的可以开箱即用的实验代码，帮助用户快速上手 Ianvs 终身学习。</p><p>数据集官网链接：https://kubeedge-ianvs.github.io/</p><p><img src="https://static001.geekbang.org/infoq/1e/1e8f57b13470035bc9206eb90fe80ec0.png" referrerpolicy="no-referrer"></p><span id="OSC_h3_9"></span><h3>特性三：支持快捷落地部署</h3><p>如下图所示，Ianvs 中终身学习算法实现的组件与 Sedna 上终身学习算法实现的组件是相兼容的，因此在 Ianvs 上研发测试的算法可以无障碍迁移部署到 Sedna 上，方便相关从业人员实地部署算法。</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/91/913df4ee6292b224808ec6b3e7e3032f.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_10"></span><h1>三、lanvs 终身学习快速教，程</h1><p>在这章中我们通过运行 Ianvs 终身学习的 cloud-robotics 样例向大家讲解 Ianvs 终身学习的基本流程。Ianvs 安装流程以及终身学习更详细的介绍可以参考：Ianvs-lifelong-learning-tutorial</p><p>相关链接：https://ianvs.readthedocs.io/en/latest/</p><p>1）首先我们需要配置好 Cloud-Robotics 的数据集，先创建数据集的文件夹，注意如果你把数据集放到别的位置，本教程中的部分路径配置也要一并修改。</p><blockquote><p>mkdir /data</p><p>&nbsp;</p><p>cd /data</p><p>&nbsp;</p><p>mkdir datasets</p><p>&nbsp;</p><p>cd datasets</p></blockquote><p>Cloud-Robotics 数据集可以根据该数据集专属网站的指示操作获得，链接：https://kubeedge-ianvs.github.io/download.html</p><p>2）下载完成后解压数据集：unzip cloud-robotics.zip</p><p>3）配置好数据集后，我们可以准备运行示例代码了。Cloud-Robotics 示例运行的代码放在 /ianvs/project/ianvs/examples/robot/lifelong_learning_bench/ 下，我们首先要配置 python 路径（这里如果 Ianvs 安装位置不一样的话需要更改路径）：</p><blockquote><p>export PYTHONPATH=$PYTHONPATH:/ianvs/project/ianvs/examples/robot/lifelong_learning_bench/testalgorithms/rfnet/RFNet</p></blockquote><p>4）然后我们检查一下 yaml 文件的信息：</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/4d/4dafcc020a4950e7bd1c6505e75cf829.png" referrerpolicy="no-referrer"></p><p>5）上图 benchmarkjob.yaml 中 workplace 是存放模型训练输出的路径，可以改成你需要的路径。</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/ae/aebaf7029f5459ef0e0e4458cff0d8b8.png" referrerpolicy="no-referrer"></p><p>6）上图 testenv-robot.yaml 中 train_url 和 test_url 是数据集索引的路径，如果你的数据集存放位置和教程不一样，则需要修改 train_url 和 test_url 的路径。</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/da/da7c61c3e5bd4110f1bb82f3110c86d8.png" referrerpolicy="no-referrer"></p><p>7）在上图 rfnet_algorithm.yaml 中可以根据你的需求添加测试的<strong>终身学习算法</strong>，比如任务定义、任务分配等算法。本样例中提供了一个简单的示例。</p><p>8）其他的配置文件暂时没有需要调整的。接下来我们就可以运行示例代码了：</p><pre>cd /ianvs/project/ianvs
ianvs -f examples/robot/lifelong_learning_bench/benchmarkingjob.yaml</pre><p><img alt="图片" src="https://static001.geekbang.org/infoq/90/9089fecf78972336f37aaf91c5c30e8a.png" referrerpolicy="no-referrer"></p><p>在模型终身学习任务结束后你可以看到以下内容，包括 BWT、FWT 等终身学习系统衡量指标：</p><p><img alt="图片" src="https://static001.geekbang.org/infoq/6a/6a86722ddf7ffdf6e21531931fd3c9e6.png" referrerpolicy="no-referrer"></p><p>9）出现以上显示结果，则成功跑通了一个 Ianvs 终身学习样例！</p><p>如果读者对于本次版本发布的更多细节感兴趣，欢迎查阅 Ianvs v0.2 Release Note：https://github.com/kubeedge/ianvs/releases/tag/v0.2.0</p><p>后续 KubeEdge SIG AI 将发布系列文章，陆续具体介绍终身学习全面升级的特性，欢迎各位读者继续关注社区动态。</p><span id="OSC_h3_11"></span><h3>相关链接</h3><p><strong>[1]</strong><span>&nbsp;</span>开源项目 GitHub 地址：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubeedge%2Fianvs" rel="nofollow" target="_blank">https://github.com/kubeedge/ianvs</a></u></p><p><strong>[2]<span>&nbsp;</span></strong>数据集官网链接：<u>https://kubeedge-ianvs.github.io/</u></p><p><strong>[3]<span>&nbsp;</span></strong>Ianvs 安装流程以及终身学习更详细的介绍链接：<u>https://ianvs.readthedocs.io/en/latest/</u></p><p><strong>[4]<span>&nbsp;</span></strong>Cloud-Robotics 数据集：<u><strong>https://kubeedge-ianvs.github.io/download.html</strong></u></p><p><strong>[5]<span>&nbsp;</span></strong>Ianvs v0.2 Release Note：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubeedge%2Fianvs%2Freleases%2Ftag%2Fv0.2.0" rel="nofollow" target="_blank">https://github.com/kubeedge/ianvs/releases/tag/v0.2.0</a></u></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%3Futm_source%3Doschina%26utm_medium%3Dbbs-ex%26utm_campaign%3Dother%26utm_content%3Dcontent" rel="nofollow" target="_blank"><strong>点击关注，第一时间了解华为云新鲜技术~</strong></a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 09:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4526289/blog/10140642</guid>
            <link>https://my.oschina.net/u/4526289/blog/10140642</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米 HyperOS 内置 32 位 App 转译器，性能比原生支持更好]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>小米手机系统软件部总监张国全介绍了 Xiaomi HyperOS 对第三方应用进行兼容的开发工作。</p><p>据介绍，小米 14&nbsp; 搭载的 CPU 虽然仅支持 64 位架构，但 HyperOS 通过内置 32 位转译内核的方式让用户在新设备上无缝运行 32 位应用。</p><p>相比小米 13 通过 CPU 小核原生运行 32 位应用，<strong>小米 14 凭借译码器可以在大核上运行 32 位应用</strong>，所以即便 CPU 不支持 32 位但依然实现了 32 位应用的兼容支持，而且性能反而更好。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-543d609013f751cb4c431b863bcca7c25bb.png" referrerpolicy="no-referrer"></p><p>此外，小米工程师分析了每年不兼容的三方应用，发现有一大类三方应用修改的内容都比较相似、在应用适配新系统前会出现种闪退和无法使用的问题，因此自研了一套 <strong>CompatEngine 引擎</strong>，可以不依赖三方应用开发者主动做兼容适配第三方应用，经验证目前超过 90% 未适配应用均可正常使用。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 09:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264814</guid>
            <link>https://www.oschina.net/news/264814</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Chrome 支持运行 Kotlin、Java 等 GC 编程语言]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>谷歌 Chrome 开发者博客<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.chrome.com%2Fblog%2Fwasmgc%2F" target="_blank">官宣</a></u></strong>：Chrome 已默认启用 <strong>WebAssembly 垃圾回收 (WasmGC) </strong>功能&nbsp;—— 能够<strong>将具有 GC 的编程语言编译为 WebAssembly (Wasm)</strong>。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1103/165225_wBLu_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>下面是示例代码</p><ul><li><strong>Kotlin Wasm</strong></li></ul><pre><code class="language-java">import kotlinx.browser.document
import kotlinx.dom.appendText
import org.w3c.dom.HTMLDivElement

fun main() {
    (document.getElementById("warning") as HTMLDivElement).style.display = "none"
    document.body?.appendText("Hello, ${greet()}!")
}

fun greet() = "world"</code></pre><p>据介绍，<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FWebAssembly%2Fgc%2Fblob%2Fmain%2Fproposals%2Fgc%2FOverview.md" target="_blank">WasmGC </a></u>是 WebAssembly 社区群组发布的一项提案。当前的 Wasm 最小可行化实现只能处理线性内存中的 number 类型数据，即整数和浮点数。随着引用类型 (<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FWebAssembly%2Freference-types%2Fblob%2Fmaster%2Fproposals%2Freference-types%2FOverview.md" target="_blank">reference types</a>) 提案的发布，Wasm 还可以保留外部引用。</p><p>WasmGC 现在添加了结构体和数组堆类型，因此<strong>支持非线性内存分配</strong>。每个 WasmGC 对象都有固定的类型和结构，这使得虚拟机可以轻松生成有效的代码来访问其字段，而不会像 JavaScript 等动态语言那样存在去优化的风险。</p><p>因此，<strong>该提案通过结构和数组堆类型为 WebAssembly 增加了对高级托管语言的有效支持</strong>，使得针对 Wasm 的语言编译器能够与主机 VM 中的垃圾回收器集成。简单来说，通过 WasmGC，将编程语言移植到 Wasm 意味着编程语言的垃圾回收器不再需要成为移植的一部分，而是可以<strong>直接使用现有的垃圾回收器</strong>。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 09:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264807/wasmgc-chrome</guid>
            <link>https://www.oschina.net/news/264807/wasmgc-chrome</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[查询平均提速 700%，奇安信基于 Apache Doris 升级日志安全分析系统]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong>本文导读</strong>：数智时代的到来使网络安全成为了不可忽视的重要领域。奇安信作为一家领先的网络安全解决方案领军者，致力于为企业提供先进全面的网络安全保护，其日志分析系统在网络安全中发挥着关键作用，通过对运行日志数据的深入分析，能够对漏洞和异常行为生成关键见解，帮助企业建立有效的防御策略。本文将深入探讨奇安信在网络安全与日志分析解决方案的关键优势，了解基于 Apache Doris 构建的全新一体化日志存储分析平台如何实时监测和分析日志事件，加强对可疑活动的追踪与应对，提升系统安全性与快速响应能力。（作者｜奇安信，服务端技术专家，舒鹏）</p><p>奇安信是中国企业级网络安全市场的领军者，专注于为政府和企业用户提供新一代网络安全产品和服务。目前核心产品天擎终端安全系统在国内已有 4000 万政企用户部署、全国部署服务器超过 100 万台、服务超 40 万大型机构。作为网络安全国家队，奇安信立志为国家构建安全的网络空间，在终端安全、云安全、威胁情报、态势感知等领域的技术研发持续领先。</p><p>随着现代企业数字化转型的不断深化，大数据、物联网、5G 等创新技术的广泛应用加速了企业的数字化转型步伐，这使得原先的网络边界被打破，多源多样的终端设备成为了新的安全边界。</p><p>网络安全系统的防御性能与日志分析密不可分，当网络设备、操作系统以及应用程序在运行时，会产生大量的运行日志，其中蕴涵了丰富的数据价值。最大化地利用运行日志数据能够有效检测内部系统的安全风险、还原攻击路径、回溯攻击入口等，可以进一步提升系统安全性、保障企业网络安全，因此日志分析系统在其中发挥着不可或缺的作用。</p><p>本文将介绍奇安信在网络安全场景中，基于 Apache Doris 进行架构升级迭代并建设全新一体化日志存储分析平台的实践经验。</p><h1>早期架构痛点与需求</h1><p>安全日志平台的架构如下图所示，原始的设备、系统日志首先经过业务处理环节，包括归一化和扩充维度等操作。这些处理步骤旨在将来自不同设备和系统日志转化为半结构化 JSON 格式的安全日志，并将其写入 Kafka 消息队列中。</p><p>最新的日志会被写入实时数仓，安全分析师可以通过分析平台对实时数仓中的最新数据进行交互式查询，从而进行攻击研判和追踪溯源等安全分析工作。另外，离线数仓用于保存历史数据，以支持长周期数据挖掘的离线分析。</p><p><img src="https://cdn.selectdb.com/static/Wechat_IMG_494_f5c46bcc5d.jpg" alt="WechatIMG494.jpg" referrerpolicy="no-referrer"></p><p>在以上日志数据平台中，日志数据的写入速度与查询分析效率对上层业务人员进行实时安全事件监控和分析至关重要，这也是当前我们所面对的最主要痛点。</p><p>一方面，每天所生产的安全日志数据达到千亿级，写入压力很大。最初我们选择使用某 Apache Doris 的 Fork 版本来存储日志数据，但在实际应用中，随着每天新增日志量的不断增长，入库速度逐渐降低、集群写入压力过大、高峰期数据积压严重，对集群稳定性造成很大影响，并且数据压力较高时、查询效率也达不到有效果的保证。随后我们对集群进行多次扩容，从 3 节点逐步扩容到 13 节点，尽管机器成本已经大幅超过预期、但写入效率并没有发生本质的改善。</p><p>另一方面，业务人员在进行安全日志分析时，经常需要对文本字段（如 URL，payload 等）进行关键字匹配。在原系统中只能通过 SQL LIKE 进行全量扫描和暴力匹配，整体查询性能不佳，千亿级数量的数据表查询耗时接近分钟级甚至达到数百秒，即便按照时间区间过滤大量数据后、查询耗时仍在数秒到数十秒。一旦遇到并发查询性能还会进一步恶化，很难满足日常安全分析的需求。</p><p>除写入和查询效率以外，运维监控也是我们的痛点之一，该厂商提供的可视化运维系统需要商业 License 授权，对于开源社区用户不友好，集群维护处于原始手动状态。</p><h1>架构选型与升级的思考</h1><p>为了解决过去版本的痛点、满足更高效实时的日志分析诉求，我们亟需对早期系统升级改造。同时面向安全日志分析场景，我们也对新日志分析平台的架构提出了更高的要求：</p><ul><li><p><strong>写入性能</strong>：系统一方面需要支持海量病毒查杀事件等数据实时写入与存储，以满足分析时效性的要求，另一方面需要基于日志数据 Schema Free 特点支持丰富数据类型的写入与变更。</p></li><li><p><strong>查询性能</strong>：由于日志查询分析会涉及对文本类型、JSON 数据进行全文检索、日期或普通数值的范围查询，系统需要对字符串提供模糊查询的能力，还需要支持能够灵活创建且类型丰富的索引，以加速筛选过滤海量数据，提升查询效率。</p></li><li><p><strong>存储成本</strong>：设备每天产生大量的日志数据，为了挖掘这些有价值的日志信息，业务人员还需要从数据中进行筛选和分析，并对异常日志回溯追踪，这使得日志存储的规模很大、存储周期相对较长，因此高性价比的存储成本也是系统构建的目标之一。</p></li><li><p><strong>运维成本</strong>：系统自身的运维简易程度以及是否具备合适的管控工具都能帮助我们进一步提效。</p></li></ul><p>在持续关注业界 OLAP 数据库的过程中，我们发现 Apache Doris 最近一年的发展非常迅猛，最新的 2.0 版本也把日志存储和检索分析作为新的发力点，推出了倒排索引、NGram BloomFilter 索引等特性，对关键词检索、LIKE 文本匹配的性能有大幅提升，与我们文本检索慢的痛点需求非常契合，因此开启了新架构的升级之旅。</p><h1>架构升级之旅</h1><p>上文中提到，在整体架构选型过程中我们主要关注的地方包括写入性能、查询性能、数据存储成本以及运维成本等方面。在架构升级过程中，我们选择了 Apache Doris 当时最新发布的 2.0 版本，具体升级收益如下。</p><h3>01 写入性能提升超 200%</h3><p>为了评估 Apache Doris 写入的极限性能，我们初期使用与线上系统相同配置的 3 台服务器，从 Kafka 接入线上真实写入流量，测试期间当 CPU 写入效率跑满至 100% 时写入吞吐达到了 108 万条/s、1.15 GB/s，写入数据的可见性延迟保持在秒级。</p><p>而线上运行的原系统集群规模达 13 台，在同样的数据写入情况下，CPU 利用率 30% 左右、写入吞吐仅 30 万条/s，并且存在高峰期 CPU Load 高、系统响应慢的问题。</p><p>根据测试结果，我们预估架构<strong>替换为 Apache Doris 后保持同样 30% 的 CPU 占用，只需要 3 台服务器即可满足写入需求，机器资源成本至少节约 70%</strong>。值得注意的是，在测试中对 Apache Doris 表中一半字段开启了倒排索引，如果不开启倒排索引的话，写入性能在之前基础上还能够再提升 50% 左右。</p><h3>02 存储成本降低近 40%</h3><p>在看到写入性能的大幅提升后，Apache Doris 存储空间占用也给我们带来了惊喜。<strong>在开启倒排索引的前提下，存储空间比原系统不具备倒排索引还要略低，压缩比从 1 : 4.3 提高至 1 : 5.7。</strong></p><p>通过对比 Apache Doris 在磁盘上存储的文件大小，同一份数据的索引文件 (.idx) 与数据文件 (.dat) 大小相差无几。换言而之，增加索引后 Doris 数据膨胀率大约在 1 倍左右，与许多数据库和检索引擎 3-5 倍的膨胀率相比，Doris 的数据存储空间占用相对较低。经过研究发现，Apache Doris 采用了列式存储和 ZSTD 压缩算法来优化存储空间占用。Doris 将原始数据和倒排索引都以列的形式存储，使同一列的数据被存储在相邻位置，从而实现了更高的压缩率。</p><p>ZSTD 是一个优秀的新型压缩算法，使用了智能优化算法，相较于常见的 GZIP 算法， ZSTD 具有更高的压缩率和更快的解压速度，尤其在处理日志场景时表现非常出色。</p><h3>03 查询性能平均提升 690%</h3><p>对于业务最关注的查询性能，我们从线上查询日志进行去重后分析出 79 条 SQL，在同一天总数据（1000 亿条）、同样规模的集群（10 BE 节点）上对比测试 Apache Doris 与原系统的查询耗时。</p><p><strong>我们发现，与原系统相比，所有的查询语句均有明显提升，整体查询性能提升近 7 倍，有 26 条 SQL 查询语句性能提升 10 倍以上</strong>，其中 8 条 SQL 查询提升 10-20 倍、14 条 SQL 查询提升 20-50 倍、还有 4 条 SQL 查询提升 50 倍以上。最大差异的一条 SQL 查询语句为 Q43，在原系统中执行时间接近一分钟，在 Apache Doris 中仅需不到 1 秒，其性能差异高达到 88 倍。</p><p><img src="https://cdn.selectdb.com/static/Wechat_IMG_495_6ac4f35ed5.jpg" alt="WechatIMG495.jpg" referrerpolicy="no-referrer"></p><p>针对性能提升幅度高的查询，我们进行了对比分析并发现了其中几个共同点：</p><p><strong>倒排索引对关键词查找的加速：Q23、Q24、Q30、Q31、Q42、Q43、Q50 等</strong></p><pre><code>1 -- 例如 q43 提升 88.2 倍
2 
3 SELECT count() from table2 
4 WHERE ( event\_time &gt;= 1693065600000 and event\_time &lt; 1693152000000) 
5 &nbsp; AND (rule\_hit\_big MATCH 'xxxx');
</code></pre><p>这种基于倒排索引进行关键词检索的技术，相较于基本的暴力扫描后进行文本匹配具有显著的优势，一方面极大地减少了需要读取的数据量；另一方面，在查询过程中无需进行文本匹配操作，因此查询效率往往提升一个数量级甚至更高。</p><p><img src="https://cdn.selectdb.com/static/Wechat_IMG_496_12be3ae384.jpg" alt="WechatIMG496.jpg" referrerpolicy="no-referrer"></p><p><strong>NGram BloomFilter 索引对 LIKE 的加速：Q75、Q76、Q77、Q78 等</strong></p><pre><code>1 -- 例如 q75 提升 44.4 倍
2 
3 SELECT * FROM table1
4 WHERE  ent_id = 'xxxxx' 
5 &nbsp;  AND event_date = '2023-08-27' 
6 &nbsp;  AND file_level = 70 
7 &nbsp;  AND rule\_group\_id LIKE 'adid:%' 
8 ORDER BY event_time LIMIT 100；
</code></pre><p>对于要查找的非一个完整关键词的场景，LIKE 仍然是有用的查询方式，Apache Doris 的 NGram BloomFilter 索引能对常规的 LIKE 进行加速。</p><p>NGram BloomFilter 索引与普通 BloomFilter 索引不同，它不是将整个文本放入 BloomFilter ，而是将文本分成连续的子串，每个子串长度为 n ，并将他们放入 NGram BloomFilter 中。对于 <code>cola LIKE '%pattern%'</code> 的查询，将<code>'pattern'</code>按照同样的方式分成长度为 n 的子串，判断每个子串在 BloomFilter 中是否存在，如果有一个子串不存在，则说明 BloomFilter 对应的数据块中没有跟<code>'pattern'</code>匹配的数据块，因此通过跳过数据块扫描的步骤，达到加速查询的效果。</p><p><strong>满足条件的最新 TopN 条日志明细查询优化：Q19-Q29 等</strong></p><pre><code>1 -- 例如 q22，提升 50.3 倍
2 
3 SELECT * FROM table1
4 where event\_date = '2023-08-27' and file\_level = 70 
5 &nbsp; and ent\_id = 'nnnnnnn' and file\_name = 'xxx.exe'
6 order by event_time limit 100;
</code></pre><p>这种<code>SELECT * FROM t WHERE xxx ORDER BY xx LIMIT n</code> 的查询，在查找满足某种条件的最新 n 条日志时使用频率非常高，Apache Doris 针对这种 SQL 查询模式进行了专门的优化，根据查询的中间状态确定排序字段的动态范围，并利用自动动态谓词下推的方式，避免读全部数据进行排序取 TopN，从而减少需要读取的数据量（有时甚至可以减少一个数量级），进而提升了查询效率。</p><h3><strong>04 可视化运维管控和可视化查询 WebUI，最大化减少运维和探索分析成本</strong></h3><p>为了提高日常集群维护的效率，我们使用了飞轮科技免费开放的可视化集群管理工具 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.selectdb.com%2Fblog%2F102" target="_blank">Cluster Manager for Apache Doris</a> （以下简称 Doris Manager ）。Doris Manager 提供的功能可以满足日常运维中集群监控、巡检、修改配置、扩缩容、升级等操作，降低登陆机器手动操作的麻烦和误操作风险。</p><p><img src="https://cdn.selectdb.com/static/Wechat_IMG_497_a752c765ea.jpg" alt="WechatIMG497.jpg" referrerpolicy="no-referrer"></p><p>除了管控 Apache Doris 集群之后，Doris Manager 还集成了类似 Kibana 的可视化日志探索分析 WebUI，对于习惯 ELK 日志分析的用户非常友好，支持关键词检索、趋势图展示、趋势图拖拽日期范围、明细日志平铺和折叠展示、字段值过滤等交互方便的探索式分析，跟日志场景探索下钻的分析需求很契合。</p><p><img src="https://cdn.selectdb.com/static/Wechat_IMG_498_2e65f945f0.jpg" alt="WechatIMG498.jpg" referrerpolicy="no-referrer"></p><h1><strong>总结与规划</strong></h1><p>在跟随 Apache Doris 2.0-alpha，2.0-beta，2.0 正式版本发布的节奏，我们根据业务场景进行了详细的评测，也为社区反馈了不少优化建议，得到社区的积极响应和解决。系统经历试运行一个月之后，我们将 2.0.1 版本正式用于生产环境，替换了原系统集群，完成架构升级改造，实现了写入性能、查询性能、存储成本、运维成本等多方面收益：</p><ul><li><p><strong>写入性能提升 3 倍以上</strong>：目前，奇安信的日志分析平台每日平均有数千亿的新增安全日志数据，通过 Doris 的 Routine Load 能够将数据实时稳定写入库，保障数据低延迟高吞吐写入。</p></li><li><p><strong>查询性能平均提升 7 倍</strong>：查询响应时间大幅减少，与之前的查询效率相比达到平均 7 倍提升，其中业务特别关注的全文检索速度达到 20 倍以上的提升，助力日志分析与网络安全运营效率。</p></li><li><p><strong>高效便捷的可视化管理</strong>：Cluster Manager for Apache Doris 工具提供了可视化集群监控告警平台，满足日常集群监控等一系列操作，同时 WebUI 多种功能为分析人员提供了操作简单、使用便捷的交互式分析。总而言之，Doris 的易用性、灵活性大幅降低了开发、运维、分析人员的学习与使用成本。</p></li></ul><p>后续我们还将在日志分析场景下探索更多 Apache Doris 的能力。我们将扩大 JSON 数据类型的相关应用，加强系统对于半结构化数据深度分析的能力。同时，我们也<strong>非常期待 Apache Doris 2.1 版本中新增的 Variant 可变数据类型，支持存储任意结构的 JSON 数据，支持字段个数与类型的变化，让业务人员灵活定义特殊字符，以更好地实现半结构数据 Schema Free 的分析需求</strong>。</p><p>非常感谢 SelectDB 团队一直以来对我们的技术支持，助力奇安信走向「体系化防御、数字化运营」的网络日志安全管理，帮助客户准确识别、保护和监管网络设备与各类系统，确保业务人员在任何时候都能够安全、可信、稳定地访问数据与业务。</p><p>最后，我们也将持续参与到 Apache Doris 社区建设中，将相关成果贡献回馈社区，希望 Apache Doris 飞速发展，越来越好！</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 02 Nov 2023 08:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5735652/blog/10140250</guid>
            <link>https://my.oschina.net/u/5735652/blog/10140250</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
    </channel>
</rss>
