<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 26 Dec 2023 02:19:28 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 跨平台的截图/录屏/录音/录像软件 pear-rec]]>
            </title>
            <description>
                <![CDATA[<p align="center"><img src="https://027xiguapi.github.io/pear-rec/logo.png" height="120" referrerpolicy="no-referrer"></p><h1><a id="user-content-pear-rec" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#pear-rec"></a>pear-rec</h1><p><img src="https://img.shields.io/github/stars/027xiguapi/pear-rec" alt="stars" referrerpolicy="no-referrer"><img src="https://img.shields.io/badge/react-v18-blue" alt="react" referrerpolicy="no-referrer"><img src="https://img.shields.io/badge/electron-v26-blue" alt="react" referrerpolicy="no-referrer"><img src="https://img.shields.io/badge/express-v4-blue" alt="react" referrerpolicy="no-referrer"><img src="https://img.shields.io/badge/-TypeScript-blue?logo=typescript&amp;logoColor=white" alt="typescript" referrerpolicy="no-referrer"><img src="https://img.shields.io/badge/-Vite-646cff?logo=vite&amp;logoColor=white" alt="vite" referrerpolicy="no-referrer"></p><hr><h2><a id="user-content-readme" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#readme"></a>README</h2><p><a href="https://gitee.com/xiguapi027/pear-rec/blob/main/README.zh-CN.md">中文</a> | <a href="https://gitee.com/xiguapi027/pear-rec/blob/main/README.md">English</a> | <a href="https://gitee.com/xiguapi027/pear-rec/blob/main/README.de-DE.md">Deutsch</a></p><h2><a id="user-content-架构" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E6%9E%B6%E6%9E%84"></a>架构</h2><img src="https://027xiguapi.github.io/pear-rec/imgs/1700442414996.jpg" referrerpolicy="no-referrer"><h2><a id="user-content-简介" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E7%AE%80%E4%BB%8B"></a>简介</h2><blockquote><p>pear-rec(梨子 rec) 是一个跨平台的截图、录屏、录音、录像、录制 (动图)gif、查看图片、查看视频、查看音频和修改图片的软件。</p><p>pear-rec(pear rec) 是基于 react + electron + vite + viewerjs + plyr + aplayer + react-screenshots + tui-image-editor + gif.js 的一个项目。</p><p>更多功能和 api 可以查看<a href="https://gitee.com/link?target=https%3A%2F%2F027xiguapi.github.io%2Fpear-rec">官网 (https://027xiguapi.github.io/pear-rec)</a> 或 <a href="https://xiguapi027.gitee.io/pear-rec" rel="nofollow">https://xiguapi027.gitee.io/pear-rec</a></p></blockquote><h2><a id="user-content-例子" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E4%BE%8B%E5%AD%90"></a>例子</h2><p><a href="https://gitee.com/link?target=https%3A%2F%2Fpear-rec-xiguapi.vercel.app%2F">网页</a></p><h2><a id="user-content-下载地址" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80"></a>下载地址</h2><blockquote><p>gitee: <a href="https://gitee.com/xiguapi027/pear-rec">https://gitee.com/xiguapi027/pear-rec</a></p><p>github: <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2F027xiguapi%2Fpear-rec">https://github.com/027xiguapi/pear-rec</a></p></blockquote><h2><a id="user-content-源码运行编译" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E6%BA%90%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BC%96%E8%AF%91"></a>源码运行&amp;编译</h2><p>编译需要<code>nodejs</code>和<code>pnpm</code>环境</p><h3><a id="user-content-测试环境" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"></a>测试环境</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">nodejs: 18</span><span id="LC2" class="line">pnpm: 8</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-开始" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E5%BC%80%E5%A7%8B"></a>开始</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c"># 拷贝代码</span></span><span id="LC2" class="line">git clone https://gitee.com/xiguapi027/pear-rec.git</span><span id="LC3" class="line"><span class="c"># 进入项目</span></span><span id="LC4" class="line"><span class="nb">cd </span>pear-rec</span><span id="LC5" class="line"><span class="c"># 安装依赖</span></span><span id="LC6" class="line">pnpm <span class="nb">install</span></span><span id="LC7" class="line"><span class="c"># 调试页面</span></span><span id="LC8" class="line">pnpm run dev:web</span><span id="LC9" class="line"><span class="c"># 调试服务</span></span><span id="LC10" class="line">pnpm run dev:server</span><span id="LC11" class="line"><span class="c"># 调试软件</span></span><span id="LC12" class="line">pnpm run dev:desktop</span><span id="LC13" class="line"><span class="c"># 运行页面</span></span><span id="LC14" class="line">pnpm run start:web</span><span id="LC15" class="line"><span class="c"># 运行软件</span></span><span id="LC16" class="line">pnpm run start:desktop</span><span id="LC17" class="line"><span class="c"># 编译软件</span></span><span id="LC18" class="line">pnpm run build:desktop</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-功能" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E5%8A%9F%E8%83%BD"></a>功能</h2><p>已经勾选的功能是开发过程最新功能，但可能还没发布在最新版本</p><ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 截屏 (react-screenshots)
<ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 框选裁切</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 框选大小位置可调整</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 取色器</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 放大镜</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 画笔（自由画笔）</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 几何形状（边框填充支持调节）</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 高级画板设置</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 图像滤镜（支持局部马赛克模糊和色彩调节）</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 自定义框选松开后的操作</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 以图搜图</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 扫描二维码</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 快速截取全屏到剪贴板或自定义的目录</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 截屏历史记录</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 窗口和控件选择（使用 OpenCV 边缘识别）</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 长截屏</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 多屏幕</li></ul></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 录屏 (WebRTC)
<ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 录制全屏</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 截图</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 自定义大小</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 静音</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 按键提示</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 光标位置提示</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 录制栏</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 流写入</li></ul></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 录音 (WebRTC)
<ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 录音设置</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 查看录音</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 下载录音</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 编辑录音</li></ul></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 录像
<ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 自定义比特率</li></ul></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 图片预览 (viewerjs)
<ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 放大</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 缩小</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 拖拽</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 翻转</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 钉上层</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 查看</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 下载</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 打印</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> ocr</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 查看列表</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 以图搜图</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 扫描二维码</li></ul></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 图片编辑 (tui-image-editor)</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 视频预览 (plyr)</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 音频预览 (aplayer)</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 动图 (gif) 编辑 (gif.js)</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 基本设置
<ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 用户 uuid</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 保存地址</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 开机自启动</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 国际化 (中、英、德)</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 服务设置</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 快捷键设置</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled=""> 重置设置</li></ul></li></ul><h2><a id="user-content-国际化 i18n" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E5%9B%BD%E9%99%85%E5%8C%96i18n"></a>国际化 (I18n)</h2><ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 简体中文</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 英语</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" checked="" disabled=""> 德语</li></ul><h2><a id="user-content-download" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#download"></a>Download</h2><table><thead><tr><th>系统</th><th>Windows</th><th>Linux</th><th>Macos</th></tr></thead><tbody><tr><td>链接</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2F027xiguapi%2Fpear-rec%2Freleases">下载</a></td><td>◯</td><td>◯</td></tr></tbody></table><p>国内可以用 <a href="https://gitee.com/link?target=https%3A%2F%2Fghproxy.com%2F">GitHub Proxy</a> 加速下载</p><h2><a id="user-content-反馈和交流" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E5%8F%8D%E9%A6%88%E5%92%8C%E4%BA%A4%E6%B5%81"></a>反馈和交流</h2><p>我们推荐使用 <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2F027xiguapi%2Fpear-rec%2Fissues">issue</a> 列表进行最直接有效的反馈，也可以下面的方式</p><ul><li>qq 群</li></ul><p align="center"><img src="https://027xiguapi.github.io/pear-rec/imgs/pear-rec_qq_qrcode.png" referrerpolicy="no-referrer"></p><h2><a id="user-content-开源协议" class="anchor" href="https://gitee.com/xiguapi027/pear-rec#%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE"></a>开源协议</h2><p><a href="https://gitee.com/xiguapi027/pear-rec/blob/main/LICENSE">pear-rec(梨子 rec) 可在 Apache License V2 下使用。</a></p><p><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FMDN%2FCommunity%2FOpen_source_etiquette">开源项目礼节</a></p>]]>
            </description>
            <pubDate>Tue, 26 Dec 2023 01:57:30 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/xiguapi027/pear-rec</guid>
            <link>https://gitee.com/xiguapi027/pear-rec</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 揭开事件循环的神秘面纱]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><img src="https://oscimg.oschina.net/oscnet/up-f9d098f5cee0090732c3958edc97164b6c7.png" alt="" referrerpolicy="no-referrer"></p><p>作者 |&nbsp;小萱</p><blockquote><p>导读&nbsp;</p><p>这篇文章会全方位讲解事件循环机制，从这篇文章你可以学到，「事件循环」和「浏览器渲染」的关系，浏览器 setTimeout、requestAnimationFrame（RAF）、requestIdleCallback（RIC）等 API 在事件循环的「执行时机」，导致浏览器卡顿的原因、交互指标是如何测量的以及如何提升网站的交互性能。</p></blockquote><blockquote><p><em>全文 10503 字，预计阅读时间 27 分钟。</em></p></blockquote><h1><strong>01 前言</strong></h1><p>我们常常会提到页面性能，为什么要优化长任务，又为什么 React 要做时间切片呢。这篇文章把浏览器的渲染、事件循环与页面性能串联起来。</p><p>从这篇文章你可以学到，「事件循环」和「浏览器渲染」的关系，浏览器 setTimeout、</p><p>requestAnimationFrame（RAF）、requestIdleCallback（RIC）等 API 在事件循环的「执行时机」，导致浏览器卡顿的原因、交互指标是如何测量的以及如何提升网站的交互性能。</p><p>学完这些，你可以对为什么动画要用 RAF、又何时去用 RIC、该不该选择 setTimeout、如何规避长任务之类的问题应对自如。</p><h1><strong>02 事件循环概述</strong></h1><h2><strong>2.1 为什么要了解事件循环？</strong></h2><p>深入了解事件循环是性能优化的基础。在讨论事件循环之前，我们需要先了解浏览器的多进程和多线程架构。</p><h2><strong>2.2 浏览器的架构</strong></h2><p>回顾浏览器的架构，现代浏览器都是多进程和多线程的。</p><h3><strong>2.2.1 多进程</strong></h3><p>Chrome 浏览器使用多进程架构，意味着每个标签页（在某些浏览器中也包括每个扩展程序）通常在其自己的进程中运行。这样做的好处是，一个标签页崩溃不会影响到其他标签页。</p><p>站点隔离特性，浏览器每个 tab，都是独立的渲染进程，这点的好处是假设你打开三个标签页，一个标签卡死不影响其他两个。但如果三个标签共用一个进程，一个卡死会导致全部都卡，这样体验很差。</p><p><img src="https://oscimg.oschina.net/oscnet/up-ea0fa24c2b466fa5d6ee4b2d3f43537fb03.png" alt="图片" referrerpolicy="no-referrer"></p><p><strong><strong>△浏览器的多进程示意图</strong></strong></p><h3><strong>2.2.2 多线程</strong></h3><p>每个浏览器进程都可以包含多个线程。例如，主线程用于执行 JavaScript 代码和处理页面布局，而其他线程可能用于网络请求、渲染等任务。</p><p><strong>主线程</strong></p><p>Web 应用程序需要在此单个主线程上执行某些关键操作。当您导航到 Web 应用程序时，浏览器将创建并向您的应用程序授予该线程，以便您的代码在其上执行。</p><p>主线程指的是渲染进程下的主线程，负责解析 HTML、计算 CSS 样式、执行 JavaScript、计算布局、绘制图层等任务。</p><p><img src="https://oscimg.oschina.net/oscnet/up-835102f787ff8cc334c66e30face4316758.png" alt="图片" referrerpolicy="no-referrer"></p><p><strong><strong>△主进程即渲染进程包含的线程图</strong></strong></p><p>某些任务<strong>必须</strong> 在主线程上运行。例如，任何直接需要访问 DOM（即 DOM ﻿document﻿）的操作都必须在主线程上运行（因为 DOM 不是线程安全的）。这将包括大多数 UI 相关代码。</p><p>主线程上一次只能运行 <strong>一个任务</strong>。</p><p>此外，一个任务<strong>必须在主线程上运行完成</strong>，然后才能运行另一个任务。浏览器没有「部分」执行任务的机制，每个任务都完整地运行直至完成。</p><p>在下面的示例中，在浏览器展示界面的时候，按顺序运行下面的任务，并且每个任务都在主线程上完成：</p><p><img src="https://oscimg.oschina.net/oscnet/up-b89c629a6370f9eaf9aeae593adc5bc8d21.png" alt="图片" referrerpolicy="no-referrer"></p><h1><strong>03 事件循环的具体流程</strong></h1><p>我们这里主要讨论的是&nbsp;window event loop。也就是浏览器一个渲染进程内主线程所控制的&nbsp;Event Loop。</p><p><img src="https://oscimg.oschina.net/oscnet/up-7597949bda55e109f8b7f0eef42bde61edd.png" alt="图片" referrerpolicy="no-referrer"></p><p><strong><strong>△发生一次事件循环的具体流程</strong></strong></p><p>发生一次事件循环，也就是浏览器一帧中可以用于执行﻿JS﻿的流程如下：</p><p>从 task queue 取出一个 task(宏任务) 执行并删除 &nbsp;-&gt; 执行并清空队列中全部 job(微任务) -&gt; requestAnimationFrame -- 浏览器更新渲染 -- requestIdleCallback</p><p><strong>3.1 更新渲染的步骤</strong></p><p>前两个步骤，耳熟能详，这里不再讨论，重点讨论「更新渲染」之后的步骤。</p><p>1. Rendering opportunities: 标志是否一次事件循环后会发生渲染。在每次事件循环的结束，不一定会发生渲染。导致不渲染的可能：无法维持当前刷新率、浏览器上下文不可见、浏览器判断更新不会造成视觉改变并且 raf 的回调为空。</p><p>如果这些条件都不满足，当前文档不为空，设置 hasARenderingOpportunity 为 true。</p><p>2.如果窗口变化，执行 resize。</p><p>3.如果滚动，执行 scroll。</p><p>4.媒体查询。</p><p>5.canvas 。</p><p>6.执行 RAF 回掉，传递回掉参数 DOMHighResTimeStamp，开始执行回调的时间。</p><p>7.重新执行 Layout 等计算，渲染绘制界面。</p><p>8.如果满足，任务队列和微任务队列都为空，并且渲染时机 hasARenderingOpportunity 为 false，执行算法是否执行 requestIdleCallback 的回调函数。</p><p><strong>3.2</strong><strong>执行顺序与渲染</strong></p><p>来一道简单的题目，将创建宏任务、微任务、RIC、RAF 的代码同时定义，输出执行顺序。</p><pre><code>console.log('开始执行');
console.log('start');
setTimeout(() =&gt; {
  console.log('setTimeout');
}, 0);

requestAnimationFrame(() =&gt; {
  console.log('requestAnimationFrame');
});
new Promise((resolve, reject) =&gt; {
  console.log('Promise');
  resolve('promise resolved');
})

requestIdleCallback(() =&gt; {
  console.log('requestIdleCallback');
});

(async function asyncFunction() {
  console.log(await 'asyncFunction');
})();

console.log('执行结束');
// 开始执行
// Promise
// 执行结束
// promise resolved
// asyncFunction
// setTimeout
// requestAnimationFrame
// requestIdleCallback
</code></pre><p>你可能会疑问为什么 RAF 会在 setTimeout(fn, 0) 之前执行，setTimeout(fn, 0) 的执行时机是延迟 0-4ms，RAF 可以粗暴理解为 settimeout(fn, Math.random() * 16.6)，因此 setTimeout 会优先。但如果在 setTimeout 执行之前主线程被其他的任务跑满了，超过了一帧的耗时，setTimeout 会在 RAF 的回调之后执行（用例见下面的代码段），因此 setTimeout 的延迟时间并不稳定，RAF 的执行时机稳定，在一帧内注册的，都会在这一帧的结束，下一帧的开始之前执行。</p><pre><code>  let task = new Array(10000).fill(null).map((_, i) =&gt; () =&gt; {
    const span = document.createElement("span");
    span.innerText = i;
    console.log("==&gt;task", i);
  });
  task.forEach((i) =&gt; i());
  requestAnimationFrame(() =&gt; {
    console.log("===&gt;requestAnimationFrame");
  });
  setTimeout(() =&gt; {
    console.log("===&gt;setTimeout");
  }, 0);
  //输出：
  // ===&gt;requestAnimationFrame
  // ===&gt;setTimeout
</code></pre><p>注意，Promise.then 的回调可以保证第一轮的准确性，如果继续.then 发生的行为和浏览器版本有关，开发时不要过分依赖多.then 的回调顺序，这是不可靠的。</p><p>上面提到渲染是在一次事件循环的「最后」发生，那么对于多次「修改 dom」的操作，是会被合并取最后一次的结果作为布局渲染。</p><pre><code>    const btn = document.querySelector(".btn");
    btn.addEventListener("click", () =&gt; {
      box.style.transform = "translateX(400px)";
      box.style.transition = "transform 1s ease-in-out";
      box.style.transform = "translateX(200px)";
    });
</code></pre><p>外层父容器 400px，这段代码，表现是盒子从 0 到 200px，盒子设置 400px 的动作，被合并掉了。那如何实现盒子从 400px 呢，可以采取延迟到下一帧渲染。</p><p><img src="https://oscimg.oschina.net/oscnet/up-12acd27c0e4668c804c101feaff4900b941.gif" alt="图片" referrerpolicy="no-referrer"></p><p><strong><strong>△演示效果</strong></strong></p><pre><code>    btn.addEventListener("click", () =&gt; {
      box.style.transform = "translateX(400px)";
      requestAnimationFrame(() =&gt; {
        requestAnimationFrame(() =&gt; {
          box.style.transition = "transform 1s ease-in-out";
          box.style.transform = "translateX(200px)";
        });
      });
    });
</code></pre><p>「嵌套的 RAF」可以保证回调在下一帧执行。当然，此处用 setTimeout 也可以达到同样的延迟效果。</p><p><img src="https://oscimg.oschina.net/oscnet/up-aba5e3515d83ac5a4002123ffa2fe772441.gif" alt="图片" referrerpolicy="no-referrer"></p><p><strong><strong>△延迟后的演示效果</strong></strong></p><h1><strong>04 任务队列与执行时机</strong></h1><p><strong>执行 JavaScript task 是在渲染之前，如果在一帧之内 JavaScript 执行时间过长就会阻塞渲染，同样会导致丢帧、卡顿</strong>，这里的 js 执行时间过长，就是长任务，下面会仔细介绍。</p><p>对长任务的定义：如果任务耗时<strong>超过 50ms</strong>，则认为该任务是长任务。</p><p>当我们谈到长任务造成页面卡顿时，通常指的是主线程（Main Thread）上的任务。主线程指的是渲染进程下的主线程，负责解析 HTML、计算 CSS 样式、执行 JavaScript、计算布局、绘制图层等任务。当主线程上的一个任务（例如一个 JavaScript 函数）运行时间过长时，它会阻塞主线程上的其他任务，包括但不限于 UI 更新和用户交互事件的处理，从而导致页面卡顿或不响应。</p><p><strong>JS 的执行和渲染的关系：</strong></p><p>JS 执行与 Paint 任务都发生在主线程，具体的绘制操作是交由合成线程完成，与主线程并不互斥，但是 JS 的执行时间过长，会导致 Paint 整理好的数据没有及时提交给合成线程，因此页面有帧没有执行绘制，也就是掉帧。</p><p><img src="https://oscimg.oschina.net/oscnet/up-a9ff20ab17a1d01227807dc759a9caafc2e.png" alt="图片" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-45b704b84e7ef58a85990b189f3cefe42ce.png" alt="图片" referrerpolicy="no-referrer"></p><p><strong><strong>△JS 的执行和渲染的关系图</strong></strong></p><h2><strong>4.1 为什么不使用 setTimeout 做动画</strong></h2><p><strong>raf 和 setTimeout 对比:</strong></p><p><em>（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjsfiddle.net%2Fhixuanxuan%2Fmrw6upgs%2F3%2F__%EF%BC%89" target="_blank">https://jsfiddle.net/hixuanxuan/mrw6upgs/3/__）</a></em></p><p><strong>1.不同步与显示刷新率：</strong></p><p>浏览器通常以每秒 60 帧的速度刷新，大约每 16.67 毫秒刷新一次。如果你使用 setTimeout 来创建动画，并尝试每 16.67 毫秒运行一帧，你的代码不会完全与浏览器的刷新速率同步，导致丢帧</p><p><strong>2.延迟执行：</strong></p><p>setTimeout 的延迟时间参数只是一个最小延迟时间，而不是保证执行的精确时间。如果主线程忙于其他任务，setTimeout 的回调可能会被延迟，导致丢帧</p><p><strong>3.计时器合并：</strong></p><p>浏览器渲染有渲染时机（Rendering opportunity），也就是浏览器会根据当前的浏览上下文判断是否进行渲染，因为考虑到硬件的刷新频率限制、页面性能以及页面是否存在后台等等因素，宏任务之间不一定会伴随着浏览器绘制。如果两个 Task 距离的很近，他们可能会被合并在一次渲染任务，得到的结果是意料之外的，如果 Task 距离较大，那他跟不上浏览器的刷新频率，会导致丢帧。</p><p>RAF 的执行时机是在下一次渲染前调用，也就是说使用这个 API 允许你在下一次渲染开始之前更改 DOM，然后在本次渲染中立即体现，因此他是制作动画的绝佳选择。</p><p><strong>4.2 requestIdleCallback 的执行时机</strong></p><p>主要在浏览器的主线程空闲时执行，为了保证响应性，会计算一个截止时间，computeDeadline，它将决定何时执行&nbsp;requestIdleCallback&nbsp;中注册的回调。下面是计算截止时间算法的简要概述：</p><p><strong>1.设置初始截止时间：</strong></p><p>初始化时，将事件循环的最后闲置周期开始时间设置为当前时间。</p><p>设置一个基本的截止时间，该时间是事件循环的最后闲置周期开始时间加上 50 毫秒（为了保证对新用户输入的响应性）。为什么要加这个 50ms，是因为浏览器为了提前应对一些可能会突发的用户交互操作，比如用户输入文字。如果给的时间太长了，你的任务把主线程卡住了，那么用户的交互就得不到回应了。50ms 可以确保用户在无感知的延迟下得到回应。</p><p><strong>2.检查是否有待处理的渲染：</strong></p><p>初始化一个变量 hasPendingRenders 为 false。</p><p>遍历相同事件循环的所有窗口，检查每个窗口是否有未执行的 RAF 回调或可能的渲染更新。如果有，将 hasPendingRenders 设置为 true。</p><p><strong>3.基于 timeout 调整截止时间：</strong></p><p>如果 RIC 传入第二个参数 timeout，更新截止时间为 timeout。这会强制浏览器不管多忙，都在超过这个时间之后去执行 rIC 的回调函数。</p><p><strong>4.考虑渲染的时间：</strong></p><p>如果 hasPendingRenders 为 true，计算下一个渲染的截止时间，基于事件循环的最后渲染机会时间和当前的刷新率。</p><p>如果下一个渲染的截止时间早于当前设置的截止时间，那么更新截止时间为下一个渲染的截止时间。</p><p><strong>5.返回最终的截止时间：</strong></p><p>返回计算出的截止时间，这个时间将用于确定何时执行 requestIdleCallback 中注册的回调。</p><p><strong>6.开始空闲期：</strong></p><p>对于相同事件循环的每个窗口，执行「开始空闲期」算法，使用 computeDeadline 作为参数，确定何时执行 requestIdleCallback 中注册的回调。</p><p>也就是说，这个&nbsp;timeRemaining()&nbsp;的计算非常动态，会根据上面这些因素去决定。</p><h2><strong>4.3 React 如何实现 Time slice，没有使用 RIC、setTimeout 的原因是什么</strong></h2><p>没使用 RIC 的原因是他在部分浏览器表现不佳，比如 safari。</p><p>需要满足的条件：</p><p>1.暂停 JS 执行，将主线程去执行 style、layout、paint 等任务，让浏览器有机会更新页面。</p><p>2.在未来某个时刻可以继续调度任务，执行上次还没有完成的任务。</p><p>对于 react 的 Time Slice，他的目的是中断当前 js 的执行，让他去执行渲染相关任务，因此需要的 API 是在浏览器的 Paint 之后执行，浏览器并未提供除了 RIC 这样的 API。RAF 的执行时机是在一帧的结束，此时创建宏任务开启下一轮 Task，渲染的任务放在 RAF 里在这一帧执行。如果使用 setTimeout(fn, 0) 创建宏任务，如果 timeout 嵌套的层级超过了 5 层，最低会有 4ms 的延迟，具体定义的代码可以参考<strong>chrome 对计时器的定义</strong><em>（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fchromium.googlesource.com%2Fchromium%2Fblink%2F%2B%2Fmaster%2FSource%2Fcore%2Fframe%2FDOMTimer.cpp%EF%BC%89" target="_blank">https://chromium.googlesource.com/chromium/blink/+/master/Source/core/frame/DOMTimer.cpp）</a></em>，因此首选的是 message channel，优先级高于 setTimeout 可以在上一帧渲染结束后立即执行，这样就实现了<strong>可以中断的 JS 执行的效果</strong>。</p><h2><strong>4.4 模拟实现 requestIdecallback</strong></h2><p>要模拟实现 requestIdecallback 的效果，定义的任务队列在浏览器完成渲染任务之后执行，扩展来说也可以用来测量浏览器渲染任务的执行时间。</p><p><strong>Background Tasks API - Web API 接口参考 | MDN</strong>（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FBackground_Tasks_API%EF%BC%89" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API）</a></p><pre><code>  // 当到时间了，立即执行的函数
  const performWorkUntilDeadline = () =&gt; {
    if (scheduledHostCallback !== null) {
      const currentTime = getCurrentTime();
      // 分配任务的剩余时间，这个可执行时间是根据 fps 动态算的
      deadline = currentTime + yieldInterval;
      const hasTimeRemaining = true;
      // 调用已计划的回调，并传递剩余时间和当前时间。
      const hasMoreWork = scheduledHostCallback(
          hasTimeRemaining,
          currentTime,
        );
        if (!hasMoreWork) {
          isMessageLoopRunning = false;
          scheduledHostCallback = null;
        } else {
          // If there's more work, schedule the next message event at the end
          // of the preceding one.
          port.postMessage(null);
        }
    } else {
      isMessageLoopRunning = false;
    }
    // 给浏览器一个绘制的机会，并重置需要绘制的标志。
    needsPaint = false;
  };
  
 
  const channel = new MessageChannel();
  const port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;

  requestHostCallback = function(callback) {
    scheduledHostCallback = callback;
    if (!isMessageLoopRunning) {
      isMessageLoopRunning = true;
      port.postMessage(null);
    }
  };
</code></pre><h1><strong>05 交互性能指标与优化方法</strong></h1><p>长任务对页面的影响，带来「卡顿」、「掉帧」等不好的体验，常用衡量交互性能的指标有 TTI 和 FID，这些均可使用 web-vital 库进行测量。下面展开对指标的详细介绍。</p><h2><strong>5.1 交互性能的衡量指标</strong></h2><p>衡量交互性能的指标主要关注以下几个方面：</p><h3><strong>5.1.1&nbsp;TTI （理想可交互时间）</strong></h3><p><strong>1.定义可交互：</strong></p><p>首先，需要明确什么是「可交互」。一个页面被认为是可交互的，意味着页面的主要内容已经加载完毕，用户可以进行点击、输入等交互操作，而且页面能够快速响应。</p><p><strong>2.监测首次内容绘制 (FCP) 和 DOMContentLoaded：</strong></p><p>测量 TTI 的过程通常开始于监测首次内容绘制 (FCP) 和 DOMContentLoaded 事件。这两个事件分别表示浏览器开始绘制页面内容和 DOM 结构加载完毕的时刻。</p><p><strong>3.长任务监测：</strong></p><p>长任务是指那些执行时间超过 50 毫秒的任务。长任务通常会阻塞主线程，延迟页面的交互可用性。通过监测长任务，可以了解主线程何时变得空闲。</p><p><strong>4.寻找交互窗口：</strong></p><p>为了确定 TTI，需要找到一个至少 5 秒钟主线程空闲的窗口，且该窗口应在首次内容绘制 (FCP) 之后。在这个 5 秒空闲窗口期间，没有长任务执行，意味着用户可以与页面交互。一旦找到这个空闲窗口，记录 TTI。如果未找到长任务，则 TTI 与 FCP 相同。</p><p><img src="https://oscimg.oschina.net/oscnet/up-f839eeb20c4ce164ffb346f0ee1b8f69072.png" alt="图片" referrerpolicy="no-referrer"></p><p><strong><strong>△TTI 测量示意图（源于 web.dev）</strong></strong></p><h3><strong>5.1.2&nbsp;FID（首次输入延迟）</strong></h3><p>FID，即 First Input Delay，用于量化用户在页面加载时首次交互的响应延迟。一个低的 FID 表示页面是快速响应用户交互的，而一个高的 FID 表示页面在响应用户交互时有延迟。</p><p><strong>1.事件监听:</strong></p><p>为了计算 FID，浏览器需要监听用户的交互事件，如点击、键盘输入或者触摸事件。当用户与页面交互时，会触发这些事件。</p><p><strong>2.事件处理时间:</strong></p><p>当事件被触发时，浏览器会计算从事件触发到浏览器开始处理事件的时间。这个时间就是 FID。它包括了浏览器将事件放入事件队列、事件队列的等待时间、以及浏览器开始处理事件的时间。</p><p><strong>3.事件处理:</strong></p><p>一旦事件开始被处理，浏览器会记录下处理开始的时间。如果页面在处理事件时非常忙碌，或者有其他高优先级的任务，那么事件处理可能会被延迟，这会增加 FID。</p><h3><strong>5.1.3 INP（交互到下一次绘制）</strong></h3><p>INP，即 Interaction to Next Paint，主要关注的是用户交互（如点击、滚动或按键操作）到页面响应的时间长度，具体到页面上的某个元素的可视更新。</p><p>比起来 FID 关注的是页面加载完成后用户<strong>首次交互</strong>，INP 关注的是<strong>所有交互的最长渲染延迟</strong>，因此 INP 不仅仅代表第一印象，可以全面评估响应情况， 使 INP 比 FID 在衡量用户交互体验上更为可靠。</p><p>INP 将会在 2024 年 3 月取代 FID 成为标准性能指标。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3bf10348f63ae93f27266efad4b84531629.png" alt="图片" referrerpolicy="no-referrer"></p><p><strong><strong>△交互到绘制的时间</strong></strong></p><h2><strong>5.2 如何优化交互性能指标</strong></h2><p><strong>1、拆分任务，这是避免长任务的有效手段。</strong></p><ul><li><p>利用 performance 进行分析，找出 long task</p></li><li><p>针对 long task，进行每个步骤的任务拆分，执行优先级高的，剩下的部分利用延迟代码执行的方法进行中断。</p></li></ul><p>比如，有个 Input 框，当输入的内容发生变更，需要进行大量计算/创建 dom 等耗时操作，造成输入卡顿。因此我们需要在用户「尝试发生互动」的时候，「退让主线程」。</p><pre><code>// 通过 Promise 实现中断后继续执行，setTimeout 调用来延迟任务
function yieldToMain () {
  return new Promise(resolve =&gt; {
    setTimeout(resolve, 0);
  });
}
    async function saveSettings(tasks) {
      let deadline = performance.now() + 50;

      while (tasks.length &gt; 0) {
        // 判断当前是否有用户交互，isInputPending Chrome87+支持。
        // 可以采用判断 Expire Time 达到类似效果
        if (
          navigator.scheduling?.isInputPending() ||
          performance.now() &gt;= deadline
        ) {
         // 如果有，退让主线程，等主线程任务完成再回来继续执行。
          await yieldToMain();
          deadline = performance.now() + 50;
          continue;
        }
        const task = tasks.shift();
        task();
      }
    }

    const performLongTask = () =&gt; {
       // 创建耗时的任务
      let task = new Array(10000).fill(null).map((_, i) =&gt; () =&gt; {
        const span = document.createElement("span");
        span.innerText = i;
      });
      saveSettings(task); // 任务切片
    };
    input.addEventListener("input", (e) =&gt; {
      input.value = e.target.value;
      performLongTask();
    });
</code></pre><p>2、非关键模块，延迟执行。对于点击率不高、非核心模块等，采取 dynamic import 的方式，用到了再加载，或是延迟到一定时间后再加载，减少首次主线程所需要执行的任务。</p><p>3、对于视口内不可见的内容，延迟加载。</p><ul><li><p>图片的延迟加载。</p></li><li><p>为 img 标签 loading 设为 lazy，延迟加载资源，直到资源达到与视口的计算距离，Chrome77+支持。</p></li><li><p>利用 IntersectionObserver 监测图片是否在可视区域，再进行渲染。推荐使用<strong>lazy-load-image-component</strong><em>（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Freact-lazy-load-image-component%EF%BC%89" target="_blank">https://www.npmjs.com/package/react-lazy-load-image-component）</a></em> 等库。</p></li><li><p>减少大量 dom 的渲染。使用 content-visibility 延迟渲染屏幕外元素，Chrome85+支持。</p></li></ul><p>4、灵活的缓存策略。</p><ul><li>用 service-worker 跨站资源共享。</li></ul><p>除了资源可以采取强缓存+协商缓存配合的方式，用 service-worker 实现更为灵活的缓存策略。比如站点 a 和站点 b 仅满足同源，技术栈渲染方式都完全不同，如何实现在访问 a 的时候可以预取 b 的资源。站点 a 空闲的时候注册 service-worker，访问站点 b 即可从 cache 里读取缓存，提升加载速度。sw 不仅在缓存方面表现优秀，也可以帮我们实现离线应用，以及无法被浏览器强缓存的文件手动添加缓存（不同浏览器对可以强缓存的文件的体积限制不同）。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6d991b243783e8ba64b09daeb68baf2d6b8.png" alt="图片" referrerpolicy="no-referrer"></p><p><strong><strong>△使用 sw 做跨站资源预取</strong></strong></p><h1><strong>06 总结</strong></h1><p>1.浏览器是多进程和多线程的，通常说主线程指的是渲染进程下的主线程。</p><p>2.主线程上一次只能运行一个任务，浏览器的绘制和主线程并不互斥，但长任务会导致延迟进入合成，甚至在这一帧不发生合成也就是掉帧。</p><p>3.在每次事件循环的结束，不一定会发生渲染。setTimeout 的执行时机并不稳定。</p><p>4.RAF 的执行时机稳定是在当前帧的最后，下一帧的开始之前，非常适合做动画。</p><p>5.RIC 的执行时机并不稳定，computeDeadline 由被多因素影响计算得出，但可以传递 timeout 控制执行的 deadline。</p><p>6.用 TTI 和 FID（INP）去衡量页面的交互性能。</p><p>7.用长任务拆分、延迟非关键模块执行、延迟非可视区域图片加载、减少页面渲染以及配置灵活的缓存策略等手段，提升网站的交互性能。</p><p>——END——</p><p><strong>参考资料：</strong></p><p>[1]HTML living standand - evnet loop processing model:</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fwebappapis.html%23event-loop-processing-model" target="_blank">https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model</a></p><p><strong>推荐阅读：</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247574835%26idx%3D1%26sn%3D31d1b6ec0ecf857f5fb12ca8a2816fb1%26chksm%3Dc03f954ff7481c599d34556eeaba1960a4261d2e304e86989a54fa9e334c15a9ff8d58aa00b1%26scene%3D21%23wechat_redirect" target="_blank">百度搜索展现服务重构：进步与优化</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247574780%26idx%3D1%26sn%3D8eda1e3f3dc06d6f10394be4a9df86f8%26chksm%3Dc03f9480f7481d968a54f75a113c16651a5c371ae43f078705f965d0a51a19491f41d2179ab7%26scene%3D21%23wechat_redirect" target="_blank">百度 APP iOS 端包体积 50M 优化实践 (七) 编译器优化</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247574670%26idx%3D1%26sn%3D45e9f922faad4fffceca07bc116b15eb%26chksm%3Dc03f94f2f7481de45ad4b17e0235eb0074e4d78dff760654e44aed98d6684d7e0ba1ccbeffcd%26scene%3D21%23wechat_redirect" target="_blank">百度搜索内容 HTAP 表格存储系统</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247574408%26idx%3D1%26sn%3Dfc0f0b325a348a401d647f3cb048b68a%26chksm%3Dc03f93f4f7481ae2c964c6fd7ab54a8291edb7b2dae16c20c5e30e998a0bceb418d631d40abf%26scene%3D21%23wechat_redirect" target="_blank">大模型时代，「人人可 AI」的百度开发者平台长什么样？</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247574315%26idx%3D1%26sn%3De1fe788ba3ae4f0b2d503bfac899cefa%26chksm%3Dc03f9357f7481a413ba7325eb9064078f097e7586136b885d11db67b4a5955412312d2428869%26scene%3D21%23wechat_redirect" target="_blank">数十万 QPS，百度热点大事件搜索的稳定性保障实践</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 26 Dec 2023 01:53:30 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/10322486</guid>
            <link>https://my.oschina.net/u/4939618/blog/10322486</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[开源，想说爱你不容易~]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h3>前言</h3><p>其实很早以前，我就想写一篇文章，聊聊我之前的开源历程，我不是什么大牛，只是 github 上千万项目中一名普通 owner，但是我热爱开源，热爱分享，热爱编程，正因为如此，我打算借着 teamlinker 开源之际，从一名普通开源从业者的角度和大家聊聊我开源生涯中的种种过往，对自己对别人也算是一种借鉴和启发吧。</p><p>我不是计算机科班出身，只是秉持着从小对编程的热爱，通过自学走上了软件开发的道路，这一路上有风雨有彩虹，受到过质疑，但也受到过更多的鼓励和支持，也正因为如此，我格外能感受到所谓的自我学习和提升是一件多么不容易的事情，所以当我接触到开源的时候，自然而然的就有种说不出的亲切感，看着那些工整的源码，就仿佛像一个老师，循循善诱的给我们讲解着它的结构和功能，只要你愿意探索，就可以在其中发现无穷的乐趣。</p><h3>从开源走向创业</h3><p>还记得在 2016 年的时候，我当时在一家软件公司担任技术总监的职务，其中遇到的一个令人头疼的问题就是前后端总是为接口文档的同步问题争执不下，我当时就想如何有一个产品可以管理并且自动的同步接口文档，让前后端都有一个唯一的参照物的话，这个问题就可以得到很大的缓解，在网上找了一遍后并没有发现满意的产品，于是我决定自力更生，利用业余时间，完成了这个接口文档管理软件的开发，取名为：DOClever（老粉应该还记得这个产品一开始的名字叫 SBDoc ~）。</p><p>其实在一开始的时候，我并没有想太多，当时只是试探性的放到 github 上，并且给我的一些朋友试用，却出乎意料的大受好评。看见大家的积极的反馈以及 github 上 star 数目的与日俱增，我获得了作为程序员生涯以来第一次无与伦比的满足感。真正感受到原来开源是一件这么美妙的事情。</p><p>随着 DOClever 业务的加剧以及用户的扩大，在 2017 年的时候，我决定将 DOClever 做大做强，找了一些朋友，我们决定出来创业，当时也正值创业风口，我们的这个项目也很快受到了不少关注。我们当时主要的宣传窗口就是开源中国，在这里我们认识了很多志同道合的朋友，也得到了编辑们对我们项目的各种肯定与支持，在此我还是要好好感谢下开源中国，感谢你们对中国开源事业所做的贡献。</p><h3>商业化的探索与反思</h3><p>创业后很快我面临的便是广大开源软件共同遇到的一个问题：盈利。当时我试过很多方案，比如开源版本与收费版本分开，打造收费插件，产品免费服务收费等，但最后都发现很难真正落地，而我当时的想法也很单纯，觉得只要产品好，用户爱用就一定会有办法挣钱，所以我当时的精力全部扎进了产品研发中，开发了接口自动化测试模块，还大胆做出了一个决定：利用 electron 打造了桌面端，在当时的竞品中，敢做桌面端的我们算是第一个了，桌面端出来后用户的反馈很好，但是我们还是陷入无法盈利的恶性循环。也就是说你的产品不错，大家爱用，给你捐点小钱也 ok，但是一旦触及商业化，那么对不起在下告辞了~</p><p>后来我们也接过一些企业的定制化服务，周期长，任务重，有的甚至要驻点，但是为了团队的发展我们又不得不做，我内心知道这个不是长久之计，也实在不想把我们做成一个外包公司，我更希望大家能认可我们统一化的产品，如果你有什么需求，可以给我们一点时间，我们可以把它打造成模块化的功能。但是往往甲方爸爸告诉我：不行，你需要专门为我定制一个 VVVVVVIP 至尊特供版。</p><p>其实我事后有认真反思过商业化的问题，觉得主要有两点，接口管理平台本身市场就那么大，竞品也不少，而且软件的门槛也低，我之所以能脱颖而出无非是我免费开源，功能也不差，但用户不是非我不可，很多用户都是因为 postman 的协作功能需要收费而转向了我们，这些人的需求也很明确，就是要用免费的。第二点就是对于稍微大一点公司，他们内部都有自己的 api 接口管理，不会轻易的去使用外面的平台，就算去使用，也会对你原来的平台改的面目全非，有点公司良心点的还会请你去做个宣讲啥的，感谢你下。有的就直接 copy 你的代码把它变成他们内部开发的一个平台，这对于我们开源创业者可谓是竹篮打水一场空。</p><h3>创业失败</h3><p>在 2018 年年中的时候，我向现实做出了屈服，我解散了我们团队，我也去了一家大厂面试。我记得当时那个面试官问我做过哪些项目的时候，我把我的 github 给他看了下，他满意的笑了笑，于是我很快就被录取了。DOClever 自此也停止了更新，我把精力都投入了新的工作中，日子就这样一天天波澜不惊的过去，直到有一天群里的一个小伙伴给我发了一个链接，我点进去一看直接无语了，也是一个接口管理平台，但是里面的功能，业务逻辑甚至页面的布局和按钮的摆放都和 DOClever 一摸一样，霎那间我明白我们被抄袭了。可是我又能做些什么呢，DOClever 很久没有更新了，我当时的公司也注销了，软件著作权也失效了，我能做的就是祝福他们做的比我更好吧！</p><p>时光荏苒，如今，我也从那个大厂离开了，庆幸的是我在此期间积累了一些资本，至少可以做几年自己想做的事情，回顾过往，你问我开源后悔嘛，我不后悔，却又五味杂陈，因为开源我可以让更多人认识我，了解我，实现自我价值，也能找到满意的工作，五味杂陈是因为开源只是一个商业化的手段，不是目的，开源不光是源码的公开，更是一种价值的传递，内心的坚持，精神的坦诚，它对于创业者的要求更高，而我还远远不够。</p><h3>感悟</h3><p>我个人认为，开源创业需要满足两个条件：<br> 1、你的产品所在市场潜力够大，而你的产品的业务和功能又有一定的不可替代性。<br> 2、必须要有一套清晰的盈利模式，哪些东西可以通过开源来吸引流量，哪些东西是你的压箱底的宝贝，真正能让用户掏钱买单，这些我们自己是必须清楚的。很多人会吐槽国内的开源氛围太差，全是伸手党，你辛辛苦苦写的东西，别人给你一包装就是他自己的了。其实很多时候我们自己又何尝不是呢，我们的产品几乎没有哪个不用开源框架或者开源库的，但是不代表我们不尊重开源，国外的很多商用软件都会把用到的开源包列举出来一一感谢，这就是一个很好的例子，国内最近关于开源协议的几起民事诉讼的胜诉我相信也将成为一个很好的典范。</p><h3>新的征程</h3><p>回到我现在在做的事情 Teamlinker，这是一个基于人工智能的团队协作平台，融入了项目管理，视频会议，文件共享等功能，可以最大程度的让团队成员协同办公。很多人劝我 teamlinker 不要开源，但是我觉得作为一个技术从业者，我的骨子里有一种自由分享的精神，我也非常期望能和别人的交流来让我的产品变得更好，我想再试一试，失败并不可怕，可怕是在同样的地方跌倒却再也不敢站起来了~</p><p>开源，想说爱你不容易，但是我却甘之如饴。</p><p>后记：欢迎大家给我们的 teamlinker 提出一点建议和批评，如果能有一点小小的鼓励那就更好啦。<br> 官网：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fteam-linker.com" target="_blank">https://team-linker.com</a><br> Github：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FTeamlinker%2FTeamlinker" target="_blank">https://github.com/Teamlinker/Teamlinker</a><br> Gitee：<a href="https://gitee.com/sx1989827/teamlinker">https://gitee.com/sx1989827/teamlinker</a></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 10:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272643</guid>
            <link>https://www.oschina.net/news/272643</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Windows 也可以用 eBPF 了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>此项目<span style="background-color:#ffffff; color:#1f2328">允许在 Windows 上使用 Linux 生态中熟悉的现有 eBPF 工具链和应用接口。也就是说，该项目将现有的 eBPF 项目作为子模块，并添加中间层，使其能在 Windows 上运行。</span></p><p><span style="background-color:#ffffff; color:#1f2328">下图显示了本项目的基本架构和相关组件：</span><img height="1140" src="https://static.oschina.net/uploads/space/2023/1225/174251_tkYJ_3820517.png" width="1556" referrerpolicy="no-referrer"></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>现有的 eBPF 工具链（clang 等）可用于从各种语言的源代码生成 eBPF 字节码。字节码可以被任何应用程序使用，也可以通过 bpftool 或 Netsh 命令行工具使用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>eBPF 字节码会被发送到一个静态验证器（PREVAIL 验证器），该验证器托管在一个安全的用户模式环境中，如系统服务、飞地或可信虚拟机。如果 eBPF 程序通过了验证器的所有检查，就可以加载到内核模式执行上下文中。通常情况下，这是通过 JIT 编译器（通过 uBPF JIT 编译器）将程序编译成本地代码并传递给执行上下文来实现的。在调试构建中，字节码可直接加载到解释器（从内核模式执行上下文中的 uBPF），但解释器不会仅在调试模式中支持，不提供发布构建频道支持，因为它被认为安全性较低。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>安装到内核模式执行上下文中的 eBPF 程序可以附加到各种钩子上，并调用 eBPF shim 公开的各种辅助 API，eBPF shim 内部封装了公共 Windows 内核 API，允许在现有版本的 Windows 上使用 eBPF。许多辅助程序已经存在，随着时间的推移，还将添加更多钩子和辅助程序。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start">此项目并不是 eBPF 的分支，<span style="background-color:#ffffff; color:#1f2328">eBPF for Windows 利用现有项目，包括 IOVisor uBPF 项目和 PREVAIL 校验器，通过为代码添加 Windows 特定的托管环境，将它们运行在 Windows 上。</span></p><p style="text-align:start"><span style="background-color:#ffffff; color:#1f2328">Linux 提供了许多钩子和辅助工具，其中有些是 Linux 特有的（例如，使用 Linux 内部数据结构），不适用于其它平台，而其它钩子和辅助工具则是通用的，目的是为 eBPF 程序提供支持。</span></p><p style="text-align:start"><span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>eBPF 还可以与 </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>HyperVisor-enforced Code Integrity（<span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>HyperVisor 强制代码完整性，HVCI）一起使用</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#1f2328">。启用 HVCI 后，eBPF 程序无法进行 JIT 编译，但可以以本地模式或解释模式运行。</span></p></div>
                                                                ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 10:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/ebpf-for-windows</guid>
            <link>https://www.oschina.net/p/ebpf-for-windows</link>
        </item>
        <item>
            <title>
                <![CDATA[Windows 也可以用 eBPF 了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>此项目<span style="background-color:#ffffff; color:#1f2328">允许在 Windows 上使用 Linux 生态中熟悉的现有 eBPF 工具链和应用接口。也就是说，该项目将现有的 eBPF 项目作为子模块，并添加中间层，使其能在 Windows 上运行。</span></p><p><span style="background-color:#ffffff; color:#1f2328">下图显示了本项目的基本架构和相关组件：</span><img height="1140" src="https://static.oschina.net/uploads/space/2023/1225/174251_tkYJ_3820517.png" width="1556" referrerpolicy="no-referrer"></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>现有的 eBPF 工具链（clang 等）可用于从各种语言的源代码生成 eBPF 字节码。字节码可以被任何应用程序使用，也可以通过 bpftool 或 Netsh 命令行工具使用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>eBPF 字节码会被发送到一个静态验证器（PREVAIL 验证器），该验证器托管在一个安全的用户模式环境中，如系统服务、飞地或可信虚拟机。如果 eBPF 程序通过了验证器的所有检查，就可以加载到内核模式执行上下文中。通常情况下，这是通过 JIT 编译器（通过 uBPF JIT 编译器）将程序编译成本地代码并传递给执行上下文来实现的。在调试构建中，字节码可直接加载到解释器（从内核模式执行上下文中的 uBPF），但解释器不会仅在调试模式中支持，不提供发布构建频道支持，因为它被认为安全性较低。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>安装到内核模式执行上下文中的 eBPF 程序可以附加到各种钩子上，并调用 eBPF shim 公开的各种辅助 API，eBPF shim 内部封装了公共 Windows 内核 API，允许在现有版本的 Windows 上使用 eBPF。许多辅助程序已经存在，随着时间的推移，还将添加更多钩子和辅助程序。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start">此项目并不是 eBPF 的分支，<span style="background-color:#ffffff; color:#1f2328">eBPF for Windows 利用现有项目，包括 IOVisor uBPF 项目和 PREVAIL 校验器，通过为代码添加 Windows 特定的托管环境，将它们运行在 Windows 上。</span></p><p style="text-align:start"><span style="background-color:#ffffff; color:#1f2328">Linux 提供了许多钩子和辅助工具，其中有些是 Linux 特有的（例如，使用 Linux 内部数据结构），不适用于其它平台，而其它钩子和辅助工具则是通用的，目的是为 eBPF 程序提供支持。</span></p><p style="text-align:start"><span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>eBPF 还可以与 </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>HyperVisor-enforced Code Integrity（<span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>HyperVisor 强制代码完整性，HVCI）一起使用</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#1f2328">。启用 HVCI 后，eBPF 程序无法进行 JIT 编译，但可以以本地模式或解释模式运行。</span></p></div>
                                                                ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 10:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/ebpf-for-windows</guid>
            <link>https://www.oschina.net/p/ebpf-for-windows</link>
        </item>
        <item>
            <title>
                <![CDATA[昆仑万维「天工 SkyAgents」Beta 版全网测试]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><strong><span><span><span><span style="color:#1f2329">12 月 25 日，昆仑万维 AI Agents 开发平台「天工 SkyAgents」Beta 版正式开放测试，用户可在 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmodel-platform.tiangong.cn%2F" target="_blank">https://model-platform.tiangong.cn/ </a>立即体验。</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">昆仑万维「天工 SkyAgents」AI Agents 开发平台，基于昆仑万维「天工大模型」打造，具备从感知到决策，从决策到执行的自主学习和独立思考能力。用户可以通过自然语言构建自己的单个或多个「私人助理」，并能将不同任务模块化，通过操作系统模块的方式，实现执行包括问题预设、指定回复、知识库创建与检索、意图识别、文本提取、http 请求等</span></span></span></span><span><span><span>任务。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span>在大模型技术高速发展、AI Agents 应用不断进步的当下，</span></span></span><span><span><span><span style="color:#1f2329">昆仑万维「天工 SkyAgents」是我们在智能体领域的一次探索与尝试。这个平台也许并不完美，但我们希望与广大开发者们携手共建、互助成长，不断开拓人工智能技术的应用边界。</span></span></span></span><span><span><span>现在不完美是为了未来的完美，我们一直在技术追求的过程中，坚信而勇于突破。</span></span></span></span></span></span></span></p><h4><span><span><span><span><strong><span><span><span>携手探索，合作共创</span></span></span></strong></span></span></span></span></h4><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span>大模型时代，交互式 AI 有望成为未来大模型技术的主流落地方向。历史告诉我们，新兴事物的演进总会找到一个稳定的术语来描述这种载体，而 AI Agents（智能体）已经显现出了巨大潜力。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span>目前，全球对智能体的关注异常热烈，OpenAI 高度关注智能体领域，并在 OpenAI dev day 发布会上发布了自定义 GPTs 以及 Assistance API；DeepMind 的联合创始人最近</span></span></span><span><span><span>也</span></span></span><span><span><span>提到下一代人工智能技术的发展方向将是交互式 AI，而不是生成式 AI。这种交互式 AI 很大程度上与智能体的描述是相符的，用户可以通过要求智能体完成各种任务，而智能体则可以操作软件或与人类协作，完成复杂场景的工作。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span>在技术范式上，昆仑万维也在不断思考驱动智能体技术快速发展的底层技术和架构。我们同时也清楚地认识到，即使在大模型的语言交互能力的加持下，我们离一个完全可以自动做决策并执行任务的智能体还有距离。</span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span>今天，昆仑万维正式开放「天工 SkyAgents」Beta 版，</span></span></span><strong><u><span><span><span><u><span>作为我们在 AI Agents 技术能力和应用能力上的一次探索</span></u></span></span></span></u></strong><span><span><span>。我们希望通过此次探索，能让越来越多的用户与开发者能够将大</span></span></span><span><span><span><span style="color:#1f2329">模型技术应用到工作生活中，打造出满足日常需求、激发灵感创新的专属 AI Agents。我们也希望更多对 AI Agents 感兴趣的朋友们能够与我们一同携手共创。欢迎广大伙伴们提出建议与意见。 </span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><img alt="" height="619" src="https://oscimg.oschina.net/oscnet/up-e7a06ccac57f87401c80becb561193a4041.png" width="1265" referrerpolicy="no-referrer"></p><h4><span><span><span><span><strong><span><span><span>什么是 AI Agents？</span></span></span></strong></span></span></span></span></h4><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">Agent 一般译为「智能体」或「代理」，其概念最早由麻省理工学院人工智能实验室（MIT AI Lab）创始人之一 Marvin Minsky 在其 1986 年出版的《思维的社会》一书中提出。它由社会与社会行为概念被引入计算系统内，指的是在某一环境下，能持续自主地发挥作用的计算实体。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">AI Agents 指的则是由人工智能技术驱动，能够感知环境、进行决策和执行动作的智能实体。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">AI Agents 并不是一个新兴的概念，自人工智能技术学科建立以来，就陆续有围绕 AI Agents 的研究出现。2012 年深度神经网络浪潮兴起后，有一支以强化学习训练 AI Agents 的学术派系诞生，轰动全球的围棋机器人 AlphaGo 可以看作是这一流派的研究成果。不过，此类 AI Agents 更适合对抗性游戏场景，在真实世界中较难落地。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">然而，大模型的出现改变了这一切。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">2023 年，随着大模型技术在自然语言理解、工程能力、数据能力、存储能力等领域的突破，大量对话交互类「GPT」涌现，以大模型技术驱动的 AI Agents 在通用性、实用性、可落地性等都得到了飞速发展，在全球掀起了又一阵 AI Agents 热潮。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">传统大模型应用大多基于 Prompt（用户提示词）实现，Prompt 的质量将直接影响大模型的回答效果，</span></span></span></span><strong><span><span><span><span style="color:#1f2329">缺乏提示词工程能力的普通用户难以将大模型的真正能力发挥到极致</span></span></span></span></strong><span><span><span><span style="color:#1f2329">。而 AI Agents 只需要用户给定工作目标，就可以通过独立思考、调用工具去逐步完成任务，极大降低大模型技术应用门槛。</span></span></span></span></span></span></span></span></p><h4><span><span><span><span><strong><span><span><span>AI Agents 三大核心模块：大脑、感知、执行</span></span></span></strong></span></span></span></span></h4><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">根据复旦大学论文《The Rise and Potential of Large Language Model Based Agents: A Survey》，AI Agents 可以划分为大脑（Brain），感知（Perception）、执行（Action）三大模块化能力。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:center"><img alt="" height="497" src="https://oscimg.oschina.net/oscnet/up-e9dac7f27a534b98ae08bc84f655f2b0dff.png" width="828" referrerpolicy="no-referrer"></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">（图片来源：《The Rise and Potential of Large Language Model Based Agents: A Survey》） </span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">1. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">大脑（Brain）</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">大脑是 AI Agents 的「核心信息处理中心」，具备理解当前环境并形成「记忆（Memory）」的能力，同时也具备存储并检索长期记忆的能力。「大脑」可以根据「记忆」和当前接收的信息进行逻辑推理，并将复杂问题拆解成可实现的子任务，应对复杂场景任务。同时，通过 RAG（检索增强生成）技术，AI Agent 可以根据当前场景和用户设定的目标进行进一步决策，实现独立思考、规划（Planning）和推理（Reasoning）。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">2. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">感知（Perception）</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">感知模块能够让 AI Agents 基于当前的环境和场景获取足够的信息，这正是其与传统 RPA 系统的区别之处。RPA 系统在面对大量未知信息、难以预测的环境时无法进行工作，AI Agents 则可以通过感知信息并做出对应的思考和行动，从而实现感知、理解和自主探索世界。 </span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">3. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">执行（Action）</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">执行模块赋予了 AI Agents 执行任务的权限和能力。AI Agents 在接收到用户任务指令后，结合由感知模块收集的当前场景信息，通过大脑进行总结和推理后，输出到执行模块中，使 AI Agents 能够根据用户需求完成指令。同时，AI Agents 拥有调用、使用工具（Tool use）的能力，这些工具可以帮助 Agents 更高效地完成复杂任务，同时也提高了其在某些具体场景中的可信度和灵活度，相关应用场景包括让 AI Agents 购买飞机票、点外卖、完成企业 IT/客服/法律任务等。</span></span></span></span></span></span></span></span></p><h4><span><span><span><span><strong><span><span><span>天工 SkyAgents</span></span></span></strong></span></span></span></span></h4><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">「天工 SkyAgents」基于昆仑万维「天工大模型」打造，拥有专属「大脑」、「感知」、「执行」模块。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">个人用户/开发者可以通过「天工 SkyAgents」进行自然语言和简单操作，无需代码编程能力，即可在几分钟之内部署属于自己的 AI Agents，完成行业研究报告、单据填写、商标设计、甚至健身计划、旅行航班预定等多项私人定制需求。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">企业用户/开发者则可以将「天工 SkyAgents」的众多能力按需拼装成企业 IT、智能客服、企业培训、HR、法律顾问等众多个性化的应用，并支持一键服务部署，确保其在不同业务系统中的无缝接入。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">「天工 SkyAgents」的 AI 能力背后，是昆仑万维 AI Agents 技术在模块化任务组件、智能知识库构建、第三方工具调用、个性化 AI Agents 一键分享等领域的能力积累。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">1. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">模块化任务组件，零代码打造专属 AI Agents</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">当前，多数用户既不具备代码开发经验，也不具备训练大模型提示词工程（Prompt Engineering）的能力，难以将众多日常生活的实际需求通过对话问答形式快速实现，无法将大模型能力发挥到极致。为了解决这一问题，「天工 SkyAgents」将大量任务组件模块化，集成了智能对话、信息加工、信息提取、信息分类、第三方数据获取、向量检索等能力。</span></span></span></span></span></span></span></span></p><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">智能对话：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">智能对话模块借助 AI 能力，将用户发送的内容，通过大语言模型进行处理并回复给用户指定内容。</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">信息加工：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">通过预设提示词（Prompt）的方式让大模型对特定信息输入进行加工，以获得符合需求的内容。</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">信息提取：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">通过大模型对语义的理解，可以从输入信息中提取目标信息</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">信息分类：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">借助大模型的智能分析，将用户问题进行分类，针对不同类型的问题执行不同操作，方便进行个性化处理；</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">第三方数据获取：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">第三方数据接入会携带相关的参数，系统向指定地址发送 POST 请求，并接收响应。系统在携带相关参数的同时，可以实现与其他应用服务的数据互联互通。基于第三方数据获取模块可以极大扩展 AI Agents 的能力，打通数据库操作、联网搜索等更多场景。</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">向量检索：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">针对常见的用户提问，系统可以将问题添加进知识库，便于搜索和查找。而对于「知识库」模块而言，用户可以输入问题，系统将在知识库中搜索相关问题与解答，并用自然语言进行输出。</span></span></span></span></span></span></span></span></li></ul><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">2. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">智能知识库构建，支持大规模知识导入</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">大模型能力虽强，但也有其天生的弱项。一方面，大模型通过参数训练获得的知识只能停留在某一时点，更新成本很高；另一方面，大模型的训练数据通常以通用知识为主，细分领域的数据往往缺乏。为了解决这一问题，「天工 SkyAgents」支持导入更多格式和更大规模的数据和知识，给大模型增加了「知识库外脑」。</span></span></span></span></span></span></span></span></p><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">支持多种数据导入形式：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">文本、文件、网站、问答对、在线文档等方式，轻松将已有知识进行导入</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">知识库 Embedding：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">将知识库中的内容元素表示为低维度的向量，使得知识库中的元素可以更容易地进行计算相似性、寻找相邻的实体等数学运算，从而提高了知识库在 AI Agents 中的可操作性。</span></span></span></span></span></span></span></span></li></ul><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">知识库自由链接：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">每个 AI Agents 可以自由链接所属知识库并同时由多个知识库进行内容供给，每个知识库也可以同时链接多个 AI Agents，知识库内容可根据需要启用和弃用，实现更灵活的知识内容管理。</span></span></span></span></span></span></span></span></li></ul><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">3. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">第三方工具调用，多场景随心应对</span></span></span></span></strong></span></span></span></span></p><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">第三方工具调用：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">工具调用能力是将 AI Agents 与大量对话类 GPT 区别开来的核心能力之一，比如在机票预订场景中，除了对用户需求与航班信息进行分析判断，AI Agents 还需要调用票务平台、电子支付等不同工具。因此，除了基础的模块外，「天工 SkyAgents」还支持各类第三方工具的调用，用户可以根据自身需要进行工具的开发，使得构建 AI Agent 时拥有更多灵活的自由度。</span></span></span></span></span></span></span></span></li></ul><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#3370ff">4. </span></span></span></span><strong><span><span><span><span style="color:#1f2329">个性化 AI Agents 一键分享</span></span></span></span></strong></span></span></span></span></p><ul><li><span><span><span><span><strong><span><span><span><span style="color:#1f2329">一键分享：</span></span></span></span></strong><span><span><span><span style="color:#1f2329">为了回馈广大用户与开发者们，更便捷地打造与使用 AI Agents，「天工 SkyAgents」上线新年专属活动，推出理想伴侣、有缘机伴、暖心家园三款官方新年模版，并全面简化了分发和使用流程。用户根据自己的创意设计出的 AI Agents 可以通过链接的方式向更多人分享，使用者只需点击链接，即可获得对该 AI Agents 的访问权。点击创建：https://model-platform.tiangong.cn/</span></span></span></span></span></span></span></span></li></ul><p style="margin-left:.0001pt; margin-right:0; text-align:left"><span><span><span><span><span><span><span><span style="color:#1f2329">能力更全面、应用更智能、分享更便捷、平台更好用。本次「天工 SkyAgents」beta 版的正式开放内容，将进一步推动大模型技术的普惠化，帮助缺乏代码开发能力的个人与中小企业积极拥抱大模型技术，助力大模型走入千家万户，为人工智能生态发展贡献力量。</span></span></span></span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:center"><span><span><span><span><strong><span><span style="background-color:#fbbfbc"><span><span>扫码进入「天工开放平台」 ，快速构建 AI Agent</span></span></span></span></strong></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:center"><img alt="" height="280" src="https://oscimg.oschina.net/oscnet/up-9032e1a9041a11a6ce891a3020335655fae.png" width="280" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 09:18:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272624</guid>
            <link>https://www.oschina.net/news/272624</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[燧原科技增资至 1 亿元，腾讯为第一大股东]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">天眼查 App 显示，上海燧原科技股份有限公司于近日发生工商变更，注册资本由约 443 万人民币增至 1 亿人民币。</span></p><p><span style="color:#000000">上海燧原科技股份有限公司（曾用名：上海燧原科技有限公司）成立于 2018 年 3 月，法定代表人、董事长兼总经理为赵立东（ZHAO LIDONG），经营范围含集成电路、计算机硬件研发、批发、零售，自有研发成果转让，并提供相关技术咨询与技术服务，销售自产产品，集成电路制造等。</span></p><p><span style="color:#000000">股东信息显示，<span style="background-color:#ffffff">该公司由腾讯科技（上海）有限公司、赵立东、张亚林、国家集成电路产业投资基金二期股份有限公司等共同持股。其中，腾讯科技（上海）有限公司持股约 21.37%，为第一大股东。</span></span></p><p><img height="250" src="https://oscimg.oschina.net/oscnet/up-1732a5466871889cdbf8c8cbb652bc144ab.png" width="700" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 09:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272620</guid>
            <link>https://www.oschina.net/news/272620</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[和 ChatGPT 聊天费水，提 10 个问题或消耗半升水]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>《央视财经》报道称，如果一个用户向 ChatGPT 问了 10 到 50 个问题，可能会消耗掉 500 毫升的水。</p><p>因为训练和运行 AI 大模型通常需要数以万计的服务器来提供计算资源、存储资源以及低延迟的网络连接，这些服务器会以集群的方式部署在名为「数据中心」的物理场所，当它们一起工作时，会在短时间内产生高度集中的热量，所以需要大量的水资源进行冷却。</p><p><img height="240" src="https://oscimg.oschina.net/oscnet/up-07526f86e0540f3acb7c39b414feef1d080.png" width="500" referrerpolicy="no-referrer"></p><p>以微软和谷歌为例。2022 年，微软一共用掉了约 17 亿加仑（约 64 亿升）水，相当于可以填满约 2500 个奥运会规格的泳池；而谷歌的数据中心和办公室则用掉了总计 56 亿加仑（约 212 亿升）水，相当于 8500 个奥运会规格的游泳池。</p><p>数据显示，现在 AI 所需要的算力预计每 100 天就会翻一番，并且在未来五年内可能会增长超过一百万倍。研究人员预计，到 2027 年，全球范围内的 AI 需求可能会需要消耗掉 66 亿立方米的水资源，几乎相当于美国华盛顿州全年的取水量。</p><p>美国圣克拉拉大学马库拉应用伦理学中心高级主管，安·斯基特表示：「我认为很快就会有监管机构开始行动，而欧盟明年就会提高相关的监管要求，要求公司披露它们的用水情况。」</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 07:41:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272594</guid>
            <link>https://www.oschina.net/news/272594</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[openKylin 社区第三次理事会会议成功召开！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span><span style="color:#000000">2023 年 12 月 22 日下午，openKylin 社区第三次理事会会议在北京成功召开。本次会议由 openKylin 社区秘书长余杰主持，麒麟软件、普华基础软件、中科方德、麒麟信安、凝思软件、中兴新支点、元心科技、中国电科 32 所、技德系统、北京麟卓、先进操作系统创新中心、飞腾、兆芯、龙芯中科、景美、京东科技、玄铁、申泰信息、海光等 21 家社区理事单位代表参会。</span></span></p><div><img alt="" height="720" src="https://oscimg.oschina.net/oscnet/up-89ff214b26c58cc74cf9c9fcbb41c82fefe.png" width="1080" referrerpolicy="no-referrer"></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社区咨询委员会委员韩乃平为本次会议作开场致辞，向出席会议的各位来宾致以欢迎和感谢，并表示一个社区的良性发展，不仅需要主流软硬件厂商的积极合作，更需要吸引全球众多开源社区开发者不断涌入。openKylin 作为我国开源操作系统根社区，通过聚合产、学、研、用等开源力量，在过去一年取得了行业瞩目的成绩，希望通过本次会议，共同商讨如何更好推进社区发展，挖掘社区更多潜能，为推进中国信息化产业的发展作出更大的贡献。</span></span></p><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-b126e34cb4bad1857b66cf44f36cad418cf.jpg" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#6ec1f5"><span style="background-color:#f7fcff">社区工作汇报</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社区副秘书长刘敏以线上形式参与会议，围绕社区治理、基础设施、SIG 组、社区版本、社区会员和品牌推广等维度，向理事单位代表汇报 2023 年社区运营进展及 2024 年发展规划。openKylin 社区技术委员会委员李剑峰从系统版本构建和社区技术创新等维度向理事单位代表进行汇报。</span></span></p><div><p style="text-align:center"><img alt="" height="2432" src="https://oscimg.oschina.net/oscnet/up-c40a204c7c674be4aca5f9baa697d7f0959.jpg" width="3648" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">2023 年，openKylin 社区发布了 3 个系统版本，并围绕桌面操作系统底层核心技术和用户体验提升，推出了「分级冻结」应用生命周期管理机制、软硬件生态「原生兼容」技术、VirtIO-GPU 硬件视频加速机制、新一代图形显示框架 wlcom 合成器、开明软件包格式等一系列创新成果。</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">此外，面向快速发展的人工智能技术领域，openKylin 社区积极布局，2023 年 6 月启动了对 AI 大模型产品的生态兼容和系统级融合，发布 openKylin AI 框架安装助手，并在 openKylin 1.0 版本中支持桌面 AI 大模型插件和智能语音助手功能，推动桌面操作系统智能交互创新发展。</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#6ec1f5"><span style="background-color:#f7fcff">理事单位贡献分享</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">北京麟卓总经理温研发表《绘制辉煌，驱动未来--图形 SIG 组工作汇报》主题分享，基于社区平台，北京麟卓成立了 GraphicSystem SIG，负责 openKylin 社区中 GPU 驱动的适配与优化、图形软件栈优化、基于 GPU 的通用计算、图形处理系统综合测试评估等与图形系统相关的信息交流和配套软件开发工作。未来，麟卓将于与社区加深合作，为拓展社区应用生态提供支撑。</span></span></p><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-8281f0b89a1a8051710c2f34a8299ec7806.jpg" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">元心科技研究院副院长李何佳发表《Flutter SIG 组的工作进展及后续工作方向》主题分享，加入社区后，元心科技参与了 Security SIG 相关工作，并对相关仓库进行了 CVE 的漏洞修复。同时发起成立了 Flutter SIG，致力于为推进 Flutter 应用开发框架在 openKylin 社区的支持，包括对 Flutter 开发环境支持和 Flutter 应用运行支持。后续，将与 openKylin 社区紧密协作，共同开展更多技术尝试与创新探索。</span></span></p><div><p style="text-align:center"><img alt="" height="2432" src="https://oscimg.oschina.net/oscnet/up-c1d070fd8ccd1211a40b6ec0ef66c5d8f84.jpg" width="3648" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">飞腾软件支持经理郑俊普发表《与开放的麒麟共飞腾》主题分享，飞腾与 openKylin 社区在技术支持、开源社区建设和生态活动等方面有着密切合作。基于社区，创建了 Phytium SIG，2024 年，飞腾将围绕服务器平台上的 openKylin 内核和软件适配开展工作，为社区生态繁荣贡献一份力量。</span></span></p><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-42ac95fa812d4ddef5b497314b302201ea9.jpg" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">阿里巴巴达摩院，RISC-V 及生态高级技术专家王云龙发表《openKylin&amp;玄铁 RISC-V 合作进展》主题分享，王云龙表示，玄铁与 openKylin 社区在技术融合、软件适配和生态推广方面有着深度合作，基于玄铁 CPU+openKylin 操作系统的基础平台，联合钉钉，三方共同努力完成了 27000+文件的编译、Qt&amp;CEF 等核心组件、17 个第三方库的构建工作，在 RISC-V 架构上首次实现了大型商业 IM 的流畅运行。</span></span></p><div><p style="text-align:center"><img alt="" height="2432" src="https://oscimg.oschina.net/oscnet/up-086ff4a6aea5896e7cea8088376720081e1.jpg" width="3648" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">景美产品总监邱江发表《国产 GPU 的 openKylin 开源之路》主题分享，景美在加入 openKylin 社区后发起成立 GPU SIG 组，并邀请了国内多家 GPU 厂商陆续加入并贡献社区，目前已正式完成景美 JM9100 显卡与 openKylin 1.0 版本操作系统的适配工作，其适配成果后续也将逐步合并到 openKylin 2.0 版本中。</span></span></p><div><p style="text-align:center"><img alt="" height="2432" src="https://oscimg.oschina.net/oscnet/up-4c6fb975407dd2b4754514f4b7c64beac2d.jpg" width="3648" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">兆芯高级产品经理张伟发表《共建 openKylin 社区》主题分享，兆芯加入社区 GPU SIG 后，积极开展 openKylin 内核在兆芯 CPU 平台上的验证适配、性能优化、新需求支持等相关工作，协助社区有序推进 openKylin 开源操作系统的完善和版本更新，目前，兆芯最新一代开先 KX-6000G 处理器已与 openKylin 操作系统完成适配认证工作，并在 openKylin 社区代码贡献位列前茅。</span></span></p><div><p style="text-align:center"><img alt="" height="2432" src="https://oscimg.oschina.net/oscnet/up-7fbab6bb17d73843fd51af01b0036d508af.jpg" width="3648" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#6ec1f5"><span style="background-color:#f7fcff">闭门讨论</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社区理事会作为社区决策机构和领导机构，主要职责为指导社区的发展方向，制定长期发展规划和实施指导意见。会上，openKylin 副秘书长刘敏就 openKylin 社区章程更新向理事单位进行汇报。随后，各理事单位围绕</span><strong><span style="color:#000000">社区运营、生态共建、技术创新发展方向</span></strong><span style="color:#000000">等重大事宜发表了各自意见，并进行了深入讨论。</span></span></p><div><p style="text-align:center"><img alt="" height="1549" src="https://oscimg.oschina.net/oscnet/up-ec6edfcdc1519d9b04b5729e9a7ed94fa38.jpg" width="3921" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#6ec1f5"><span style="background-color:#f7fcff">总结致辞</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">最后，由社区理事长朱晨对本次理事会进行总结致辞，朱晨表示，openKylin 社区的繁荣发展，离不开每一位贡献者的辛勤付出。在今天上午的社区 2023 年度伙伴暨开发者大会上，我们对参与社区共建的优秀企业伙伴和个人开发者进行了表彰颁奖。我们很高兴地看到，越来越多优秀伙伴加入，为打造国产开源操作系统根社区贡献力量。</span></span></p><div><p style="text-align:center"><img alt="" height="720" src="https://oscimg.oschina.net/oscnet/up-6daf096096b8cee46f43e5562cd5d447400.png" width="1080" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">未来，openKylin 将继续秉持「开源聚力、共创未来」的社区理念，持续推动技术创新和生态拓展，打造一个更加强大和优秀的桌面操作系统开源社区，同时将不断提升自身在开源技术发展中的影响力，为推进中国信息化产业的发展作出更大的贡献。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 06:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272584</guid>
            <link>https://www.oschina.net/news/272584</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[开源共创，携手成长 | openKylin 伙伴暨开发者年度会议圆满落幕！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span><span style="color:#000000">12 月 22 日，openKylin 伙伴暨开发者年度会议在北京成功召开。本次会议以「开源共创，携手成长」为主题，邀请了社区杰出共建单位和开发者代表线下相聚，共鉴社区新进展、共享开源操作系统新技术、共研产业未来新趋势。</span></span></p><div><p style="text-align:center"><img height="1280" src="https://oscimg.oschina.net/oscnet/up-95191a5aa9adb13597715074c98ca955469.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><em><span><strong><span style="color:#ffce73">01</span></strong></span></em></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#57b8f6">会议开场致辞</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社区理事、麒麟软件总经理孔金珠在开场致辞中表示，过去一年里，越来越多优秀的企业伙伴和开发者加入到 openKylin 开源大家庭中，为操作系统根技术创新奠定智囊基础。在社区 400+生态伙伴和 5500+开发者的携手共创下，openKylin 社区取得多项技术创新成果，实现了从系统效能、功能体验、生态融合、应用开发等方面的全栈技术创新。此次会议是一次技术的交流，也是一次思想的碰撞，更是一次创新的启程。希望通过交流和分享，碰撞出智慧的火花，进一步推动操作系统创新技术融合。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-5f02f52e732f362c83ecc5301f00c9bc212.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><em><span><strong><span style="color:#ffce73">02</span></strong></span></em></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#57b8f6">社区成果回顾</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社区生态委员会主任李震宁分享了 openKylin 进展成果及未来展望，李震宁表示，2023 年，在建立中国开源操作系统根社区的信念引领下，openKylin 社区汇聚了社会各界的产业力量、院士专家、高校师生、个人开发者，共同推动社区治理体系完善、社区产品打造、系统生态建设及使用体验提升。openKylin 社区的快速发展，充分体现了开源作为一种创新的软件协同生产模式所绽放的活力和无限潜能。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-08a7ee5efbc0ff067ea9d9b9ea7e78bc67e.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><ul><li><span><strong><span style="color:#000000">生态共建</span></strong><span style="color:#000000">方面，目前，openKylin 社区已汇聚了涵盖操作系统、数据库、办公软件、CPU、GPU、整机、人工智能等在内的 400+企业会员和 36 所研究型、教学型、应用型的各层次高等院校。</span></span></li><li><span><strong><span style="color:#000000">版本发布</span></strong><span style="color:#000000">方面，openKylin 社区累计发布 6 个版本，完成 20+核心组件选型工作，累计下载量超百万。</span></span></li><li><span><strong><span style="color:#000000">创新演进</span></strong><span style="color:#000000">方面，成立 94 个 SIG 开展技术研究与创新，其中，开明包格式环境、wlcom 合成器、KARE 生态兼容、不可变系统和跨版本升级工具等社区最新重大技术成果都将融入到 openKylin 2.0 版本中，颠覆性创新带来全新体验。目前 openKylin 2.0 alpha 版本已发布，面向开发者和尝新用户体验。</span></span></li><li><span><strong><span style="color:#000000">智能融合</span></strong><span style="color:#000000">方面，发布 openKylin AI 框架安装助手，实现一键安装 AI 框架，并在 openKylin 1.0 版本中实现支持桌面 AI 大模型插件和智能语音助手功能，从智能输入、智能输出两方面入手，深度融合 AI 技术，推动桌面操作系统智能交互创新发展。</span></span></li><li><span><strong><span style="color:#000000">RISC-V 布</span></strong><span style="color:#000000">局方面，openKylin 社区正式加入 RISC-V 基金会，从源码级别自主构建了 RISC-V 开源桌面操作系统版本成为其产业联盟成员，支持 80% 以上市场主流 RISC-V 芯片，并携手深度数智发布全球首款 RISC-V 笔记本电脑 DC-ROMA。</span></span></li></ul><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">迈向 2024 年，openKylin 社区将立足新起点、实现新跨越。以开源、开放、平等、协作模式融智共创，为用户及开发者创造全新体验及价值。</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><em><span><strong><span style="color:#ffce73">03</span></strong></span></em></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#57b8f6">年度贡献榜单揭晓</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社区的繁荣发展，离不开每一位贡献者的辛勤付出。会上，openKylin 社区公布了 2023 年度贡献榜单并进行颁奖，以表彰在过去一年中为社区做出突出贡献的杰出企业伙伴、高校共建先锋、SIG 团队和开发者菁英等。</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#888888">感谢每一位参与社区共建的小伙伴！欢迎更多企业、高校和开发者加入社区，共同打造中国开源操作系统根社区！以下为现场部分颁奖留影：</span></span></p><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-ec33487714ec154fceead05a87ff6e18c15.jpg" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-055afff730218da4aae68795a967a3d0076.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-28988997294bf968c922166fab67c3b46e8.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-538daf8e0d17bd318f74522b98e8a380362.jpg" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><em><span><strong><span style="color:#ffce73">04</span></strong></span></em></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#57b8f6">共建伙伴成果分享</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#000000">格兰菲市场支持科主管岳晓帅发表《格兰菲 openKylin 社区会员开源实践技术分享》主题演讲，岳晓帅表示，在加入 openKylin 社区后，格兰菲积极参与社区共建，并加入社区 GPU SIG，目前已完成了 Arise1 平台与 openKylin 操作系统的兼容适配认证工作，并在功能、性能及兼容性方面表现优异。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-6caa8d88cb5fad2a0b4f66d85c5519373b4.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">信创海河实验室副研究员王文竹发表《信创海河实验室 openKylin 社区会员开源实践分享》主题演讲，王文竹表示，信创海河实验室与 openKylin 社区在 RISC-V 版本共建、运营推广和人才培养等方面有着紧密的合作关系。双方携手从源码级别自主构建了 RISC-V 开源桌面操作系统版本，目前已实现 openKylin 对算能 RISC-V 产品的全方位支持，涵盖了桌面环境、软件生态、容器化部署和人工智能等多个关键领域。未来双方将深化合作，共同推进 RISC-V 生态技术发展。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-488499cad322a4e5f7f7ca8e2efe730b22a.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">南开大学软件学院团委书记王真发表《南开大学+openKylin: 共同推动开源社区国际化建设》主题演讲，王真表示，南开大学软件学院作为 openKylin 社区共建伙伴，创建了 InternationalPromotion SIG，负责对接 30+国家，103 位国外留学生开展相关国际化推广工作，目前已开展四届国际推广交流活动，颁发尼泊尔、肯尼亚、塞拉利昂等 11 个国家星级推广站点授权证书。未来，双方将进一步携手扩大国际项目交流圈，推动 openKylin 社区科技创新合作、技术推广交流和成果转化应用。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-a2b78bd919f34e066c3561280f2edccd3c0.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">儒特科技 CEO 马铁发表《QSFramework SIG 贡献及成果分享》主题演讲，儒特科技加入社区后，发起成立了 QSFramework SIG，SIG 团队维护的开源项目青霜框架（QSFramework），是一款新形态、轻量化、微内核 Web 引擎。目前，已正式完成 QSFramework 与 openKylin 操作系统的兼容适配，并已发布到 openKylin 2.0 软件仓库，感兴趣的小伙伴可以下载体验。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-09f68cf3fcaad8955597abd5839fa41d054.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">社区个人开发者孙圣博也分享了他与 openKylin 社区的结缘故事以及在社区的开源实践之旅，孙圣博作为一名高中生，在加入社区后，发起成立了 Cutefish SIG 等，完成了 Cutefish 等桌面环境及相关组件与 openKylin 的兼容适配。同时，还积极参与社区 RISC-V 生态共建，并成立了 FAQ SIG，负责收集各渠道开发者、爱好者等用户反馈的问题，建立相关标准化流程推动问题解答或解决。孙圣博的发言引发阵阵掌声，让更多的开发者感受到了开源的魅力与活力。</span></span></p><div><p style="text-align:center"><img alt="" height="1280" src="https://oscimg.oschina.net/oscnet/up-b66fe15ad20ef69fcfdceeb97f16025fe9d.jpg" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><em><span><strong><span style="color:#ffce73">05</span></strong></span></em></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#57b8f6">会议落幕致辞</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">openKylin 社区生态委员会主任李震宁在总结致辞中提到，过去一年，正是有了大家的共同努力，openKylin 才能取得今天的靓丽成绩。在 openKylin 社区，各界伙伴都可以在开源、开放、协作的模式下，基于产业发展现状、院校科研积累和开发者实践经验等，开放自由的交流想法与建议，并进行实践、检验与完善。通过本次会议，不仅加深了社区与企业伙伴、社区与个人开发者之间的了解，也为 openKylin 的发展提供了新的思路和方向。</span></span></p><div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-55cfd98b21f0d69d4c5e8f11a5b09378305.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-863b3b1f00649033bd11bb0edd70ec04d76.jpg" referrerpolicy="no-referrer"></p><p style="text-align:center">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">展望未来，openKylin 社区也将持续把握发展机遇，聚焦操作系统根技术，发挥社区平台支撑作用，聚合产、学、研、用及国内外开源力量，加速系统创新迭代，共同推动 openKylin 开源操作系统根社区构建，为推动形成众研众用众创的开源软件生态添砖加瓦，逐步走向同国际顶尖开源社区比肩的星辰大海。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 06:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272582</guid>
            <link>https://www.oschina.net/news/272582</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GTA 5 完整源代码被公开泄露]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">在国外正值圣诞假期之际，一个匿名用户公开<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cyberkendra.com%2F2023%2F12%2Fgta-5-source-code-leaked-on-christmas.html" target="_blank">泄露</a>了 Rockstar 旗下知名游戏《侠盗猎车手 5》（GTA 5）的所有源代码。</span></p><p><span style="color:#000000">泄露的文件大约有 4GB，其中包含与游戏 RAGE 引擎相关的关键文件、概念图、游戏圣安地列斯背景的早期地图以及其他敏感资料。此外，还包括未发布的《GTA 6》中的一些 Python 脚本文件和<span style="background-color:#ffffff">一个 Bully 2 文件</span>。</span></p><p><img height="287" src="https://oscimg.oschina.net/oscnet/up-cea5c5b3990f3c01ce94728fdbbf1d3c3ad.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">早在 2022 年 9 月，就有一匿名黑客声称获得了《GTA 5》和《GTA 6》的源代码，并威胁要公开这些数据企图敲诈 Rockstar 游戏公司。此后，Rockstar 官方也发布声明<span style="background-color:#ffffff">确认遭遇网络入侵，证实了</span>大规模的《GTA 6》泄漏。</span></p><p><span style="color:#000000">时至今日，《GTA 5》的完整源代码似乎又被泄露，并在几个文件共享网站和专门讨论《GTA》修改和黑客问题的论坛上公开。目前尚未清楚相关的泄露事件是如何发生的。但有人<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2FGTAFocal%2Fstatus%2F1739051532149039111" target="_blank">推测</a>，早自 2022 年泄露事件以来，游戏完整的源代码就一直在被交易。</span></p><p><span style="color:#000000"><img alt="" height="500" src="https://oscimg.oschina.net/oscnet/up-9cc40522a4d848442c48a30ddc5b5226046.jpg" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Rockstar Games 及其母公司 Take-Two Interactive 尚未就最新泄露事件发表官方声明。</span></span></p><p><strong><span style="color:#000000"><span style="background-color:#ffffff">相关阅读：</span></span></strong></p><ul><li><a href="https://www.oschina.net/news/210946/gta-6-leak" target="_blank">官方确认，GTA 6 源代码泄漏</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 06:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272581/gta-5-source-code-leaked-on-christmas</guid>
            <link>https://www.oschina.net/news/272581/gta-5-source-code-leaked-on-christmas</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[周热点 | 知名开源项目作者「在线求打钱」；No Star, No Fix；支持苹果芯片的 Fedora 发行版推出......]]>
            </title>
            <description>
                <![CDATA[回顾一周热门资讯。2023.12.18-2023.12.24]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 06:27:00 GMT</pubDate>
            <guid isPermaLink="false">https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649094075&#38;idx=1&#38;sn=00275798424976ecbd47ae4f4f525775&#38;chksm=880c4ca8bf7bc5be2e47003634d2fd46e6617414e6d8b2a9906ba9429ad095d432067a48c04d&#38;token=288730784&#38;lang=zh_CN#rd</guid>
            <link>https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649094075&#38;idx=1&#38;sn=00275798424976ecbd47ae4f4f525775&#38;chksm=880c4ca8bf7bc5be2e47003634d2fd46e6617414e6d8b2a9906ba9429ad095d432067a48c04d&#38;token=288730784&#38;lang=zh_CN#rd</link>
        </item>
        <item>
            <title>
                <![CDATA[生成式 AI 的下一阶段将走向何方？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p><strong>编者按：</strong> 最近，随着&nbsp;ChatGPT&nbsp;的出现，很多人认为人工智能领域进入了大探索时代。然而这仅仅只是生成式 AI 发展的第一幕。</p><p>我们今天要给大家带来的这篇文章认为，生成式 AI 已经进入第二幕，即整合时代，不同系统和企业之间将出现广泛合作，以定制解决方案将 AI 能力深度嵌入各行各业。</p><p>文章详细阐述了第二幕的几个特征：(1) 科技巨头纷纷与 AI 初创公司建立合作伙伴关系；(2) 将生成式 AI 无缝嵌入已有产品成为主流；(3) 内容公司与模型公司达成授权协议；(4)AI 与设备、系统集成；(5) 初创公司通过 API 为大公司提供服务。</p><p>生成式 AI 正在重塑软件世界，小公司的长期生存面临挑战，开源仍然至关重要。未来第三幕可能是物联网与 AI、合成生物学的深度融合。我们有理由相信未来会出现更多惊喜。</p></blockquote><p><strong>作者 | Paul DelSignore</strong></p><p><strong>🚢🚢🚢欢迎小伙伴们加入<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaihai-idp.yuque.com%2Fmwvla8%2Fdoc%3F%23" target="_blank">AI 技术软件及技术交流群</a>，追踪前沿热点，共探技术难题~</strong></p><p>生成式人工智能的历史可追溯至 20&nbsp;世纪 60&nbsp;年代，但直到 2022 年，才迎来生成式人工智能大觉醒之年。</p><h1><strong>01 第一幕：探索</strong></h1><p>我还记得 2022 年 4 月我第一次看到 DALLE-2 时的情景，那就像是一种顿悟，我知道有大事将要发生了。我开始使用 GPT-3 和当时的一些人工智写作工具。</p><p>然后在 8 月，开源图像大模型 Stable Diffusion 发布，突然间，图像工具的数量呈现爆炸式增长。</p><p>到 2022 年 12 月，一款利用 Stable Diffusion 的手机拍照应用 Lensa AI 在短短一个月内就实现了全球近 2000&nbsp;万次的下载记录。</p><p>2022 年，ChatGPT 的公开发布让人工智能推向了新高潮，这标志着该技术突破性地进入了主流市场。ChatGPT 在短短几个月内用户数量就达到了 1 亿。</p><p>ChatGPT 的成功让其他行业开始思索大模型可能带来的颠覆性变化，成为人工智能创新的催化剂。突然间，每个人都在尝试使用生成式人工智能，几乎每天都有新工具发布。</p><p>举几个例子，比如大语言模型（GPT-4、PaLM2、Claude、LLaMA 等）、图像、视频和代码模型的创新，以及 AutoGPT 和 AI 智能体的新实验范例等等。</p><p>关于 ChatGPT 发布以来的大量创新，我也许可以写一本书，但如果要我用一个词来概括，那就是：<strong>探索</strong></p><h1><strong>02 第二幕：整合</strong></h1><p>最近，红杉（Sequoia）的一篇文章[1]，伊桑-莫利克（Ethan Mollick）的一篇文章[2]等都表明，变革之风正盛，我们正处于 Gen AI 故事的第二幕。</p><p>我也注意到了这种变化。人工智能正在走向成熟，而且正在产生一种捆绑效应（bundling effect）。我想用以下标题来定义第二幕：<strong>整合</strong></p><p>将其称为新阶段并不意味着「探索」阶段已经结束，远非如此。在未来几年里，我们将继续看到令人惊叹的创新水平。</p><p><strong>Gen AI 的时间轴并不是一个阶段结束，另一个新的阶段接着开始，而是一个嵌套的阶段。我们在接近整合时代的同时，仍将迎来创新时代。</strong></p><p><img src="https://oscimg.oschina.net/oscnet/up-4504e82e3d41c557191aa6309817670fdd5.png" alt="" referrerpolicy="no-referrer"></p><h1><strong>03 整合时代</strong></h1><p><strong>整合时代始于生成式 AI 人工智能军备竞赛元年。</strong></p><p>大型科技公司纷纷建立合作伙伴关系，以确保自己在竞争中占据主导地位和主要优势。这其中包括微软&nbsp;+ OpenAI、亚马逊&nbsp;+ Anthropic 和谷歌&nbsp;+ Nvidia。</p><p>由于 Gen AI 是一种功能、一种超级能力，而不是一种特定的应用或软件，因此现有的科技公司都拥有一个完美的战略来确保自己的立足点，即：<strong>将生成式 AI 融入一切。</strong></p><p>这个战略很简单，将人工智能的精华嵌入消费者和企业已经在使用的工具和产品中。因此，如果你想在人工智能的帮助下写作，你不需要一个新的人工智能写作应用程序，因为它已经包含在微软的 Word 工具中了。</p><p>对于微软来说，他们的计划是将人工智能嵌入到一切中，包括他们的 365 Office 工具套件、必应搜索引擎、基于网络的应用程序和 Xbox 游戏机，以及最重要的，他们的 Windows 操作系统。</p><p>对于谷歌来说，他们的计划是相同的。谷歌搜索将由他们日益强大的 LLM（如 PaLM 和 Genesis）提供支持，谷歌 Workspace 将服务于商业用途，AI 将赋能包括电子商务、导航和图像捕捉在内的每个移动应用。</p><p>在图像和图形方面，尽管 Midjourney 和 Stable Diffusion 在探索时代占据了主导地位，但 Adobe 现已通过 Firefly v2 赶上，并在其所有应用程序和创意工具套件中整合了一系列令人印象深刻的生成式 AI 功能。</p><p>亚马逊作为云计算提供商，现在也是 LLM 提供商，通过 Bedrock 提供模型即服务（model-as-a-service，MaaS）。</p><p>Meta 将继续构建新的沉浸式技术，并通过 AI 增强其社交应用体验，而我们甚至还不清楚苹果一旦加入这场游戏会做些什么。AppleGPT 很可能会成为 AI 个人助理，超越包括 ChatGPT 在内的所有其他 chatbot。为什么呢？因为它将被整合进苹果生态系统——iPhone、电脑和其他设备中。</p><p>整合时代意味着生成式 AI 进入软件领域，就像为家庭供电一样。它将成为系统的一部分，成为我们已有的用户体验的一部分。</p><h1><strong>04 初创公司面临的挑战</strong></h1><p>虽然我们将继续看到初创公司在 Discord 频道、Github repos 和社交媒体上的惊人创新，但小公司与 Gen AI 玩长期游戏将变得越来越困难。</p><p>至少，他们需要「缴税「，因为大型科技公司拥有 LLM，他们拥有铁路和电网。</p><p>毫无疑问，这就是为什么大多数大型科技公司（Meta 除外）反对开源 LLM 的原因。不要相信关于安全问题的谎言。</p><p>这就是为什么开源必须继续成为生成式 AI 的一个充满活力的组成部分。创新需要公司在不受专有 LLM 公司限制的情况下进行实验和创新。</p><h1><strong>05 合作推动定制化</strong></h1><p>随着生成式 AI 进入下一个阶段，系统和这些公司之间的合作将增加，以便为工业和商业的各种应用提供整合 AI 能力的定制解决方案。</p><p>那看起来会是什么样的？</p><ul><li>随着多模态体验的增加，我们可能会看到专注于某一细分市场的公司与其他公司合作。最近的一个例子是 Canva + Runway。</li><li>像 Anthropic 或 OpenAI 这样的 LLM 公司将寻找高质量的内容进行训练。内容公司将会对模型公司进行授权或合作。最近的一个例子是 AP 将内容授权给 OpenAI[3]。</li><li>随着设备开始变得智能并融入 AI，预计 LLM 将开始与设备连接。最近的一个例子是使用 LLM 进行视觉引导的自动驾驶[4]。</li><li>像 Pika Labs 或 Midjourney 这样的公司将通过 API 为大公司提供服务集成。最近的一个例子是 Google 将 Adobe 的 Firefly 用于图像生成。</li></ul><h1><strong>06 未来行动展望</strong></h1><p>如果让我预测&nbsp;"第三幕&nbsp;"会是什么样子，我会说，我们将看到人工智能在物理世界中越来越多地出现。</p><p><strong>集成时代主要是人工智能与软件&nbsp;(AI+Software)&nbsp;的融合，而生物空间时代将是人工智能与物理和生物的融合 (AI + Physical + Biology)。</strong></p><p>第三幕将是由人工智能物联网（AIoT）和不断涌现的合成生物学驱动的的物联网融合时代。我们还没有一个合适的词来形容它，所以我称之为&nbsp;"生物空间时代"。我相信会有更好的词出现。</p><p><img src="https://oscimg.oschina.net/oscnet/up-9dd15fd57035e012224407de4ba25a9f7a5.png" alt="" referrerpolicy="no-referrer"></p><h1><strong>07 最后的思考</strong></h1><p><strong>生成式人工智能已进入第二幕</strong>，其特点是不同系统和企业协作的融合，协同为各行各业的各种应用提供量身定制的人工智能能力，并将其深度融入到到应用解决方案中。</p><p>作为一个谨慎的技术乐观主义者，我深知进步将伴随着许多挑战。随着生成式人工智能进一步深入我们的工具和生活，围绕人工智能伦理、数据隐私和安全的合理担忧也将变得突出。</p><p><strong>Thanks for reading!</strong></p><p><strong>🚢🚢🚢欢迎小伙伴们加入<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaihai-idp.yuque.com%2Fmwvla8%2Fdoc%3F%23" target="_blank">AI 技术软件及技术交流群</a>，追踪前沿热点，共探技术难题~</strong></p><p><strong>END</strong></p><p><strong>参考资料</strong></p><p>[1]&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sequoiacap.com%2Farticle%2Fgenerative-ai-act-two%2F" target="_blank">https://www.sequoiacap.com/article/generative-ai-act-two/</a></p><p>[2]&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tandfonline.com%2Fdoi%2Ffull%2F10.1080%2F08956308.2023.2213102" target="_blank">https://www.tandfonline.com/doi/full/10.1080/08956308.2023.2213102</a></p><p>[3]&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fapnews.com%2Farticle%2Fopenai-chatgpt-associated-press-ap-f86f84c5bcc2f3b98074b38521f5f75a" target="_blank">https://apnews.com/article/openai-chatgpt-associated-press-ap-f86f84c5bcc2f3b98074b38521f5f75a</a></p><p>[4]&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D37710865" target="_blank">https://news.ycombinator.com/item?id=37710865</a></p><p><strong>本文经原作者授权，由 Baihai IDP 编译。如需转载译文，请联系获取授权。</strong></p><p><strong>原文链接：</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmedium.com%2Fthe-generator%2Fthe-next-phase-of-generative-ai-984b109915ed" target="_blank">https://medium.com/the-generator/the-next-phase-of-generative-ai-984b109915ed</a></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 05:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/IDP/blog/10388555</guid>
            <link>https://my.oschina.net/IDP/blog/10388555</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 拟以 1000 亿美元估值开启新一轮融资]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">彭博社援引知情人士<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2023-12-22%2Fopenai-in-talks-to-raise-new-funding-at-100-billion-valuation" target="_blank">消息称</a>，OpenAI&nbsp;正在以 1000 亿美元或以上的估值筹集新一轮融资，相关谈判尚处于早期阶段。这笔交易将巩固这家 ChatGPT 制造商作为全球最有价值初创公司之一的地位。</span></p><p><span style="color:#000000">可能参与本轮融资的投资者的相关信息并未有过多透露，且本轮融资的条款、估值和时间安排等细节也尚未最终确定，仍可能发生变化。根据 </span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cbinsights.com%2Fresearch-unicorn-companies" target="_blank">CBInsights 的数据</a><span style="color:#000000">，如果本轮融资按计划进行，那么 OpenAI 将成为美国价值第二高的初创企业，仅次于 Elon Musk 的太空探索技术公司（SpaceX）。</span></p><p><span style="color:#000000">OpenAI 对此拒绝置评。</span></p><p><img height="240" src="https://oscimg.oschina.net/oscnet/up-933407733ad072a31a3b04922263ecc0b34.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">知情人士称，OpenAI 还与阿布扎比 G42 进行了商讨，为一家新的芯片合资企业募集资金。其中一位知情人士称，OpenAI 已经讨论过从 G42 筹集 80 亿至 100 亿美元的资金。目前尚不清楚芯片合资企业和公司更广泛的融资计划之间是否有关联。</span></p><p><span style="color:#000000">事实上，OpenAI 首席执行官 Sam Altman 一直在为代号为 Tigris 的芯片制造项目寻求资金。据彭博社上个月报道，其目标是生产能够与英伟达半导体竞争的半导体。</span></p><p><span style="color:#000000">10 月份，G42 曾宣布与 OpenAI 合作，"向阿联酋和地区市场提供尖端的人工智能解决方案"，但没有公布具体的财务细节。G42 公司成立于 2018 年，由阿联酋国家安全顾问兼阿布扎比投资局主席 Sheikh Tahnoon bin Zayed Al Nahyan 领导。</span></p><p><strong><span style="color:#000000">相关阅读：</span></strong></p><ul><li><a href="https://www.oschina.net/news/259735/openai-seeks-new-valuation-90-billion" target="news">OpenAI 寻求出售现有股票，估值高达 900 亿美元</a></li><li><a href="https://www.oschina.net/news/269384/openai-buy-ai-chips-startup-sam-altma" target="_blank">OpenAI 承诺从 Altman 投资的初创公司购买 AI 芯片</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 03:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272549/openai-valuation-100-billion-funding-round</guid>
            <link>https://www.oschina.net/news/272549/openai-valuation-100-billion-funding-round</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[苹果发布开源多模态大语言模型 Ferret]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>科技媒体 VentureBeat&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fventurebeat.com%2Fai%2Fapple-quietly-released-an-open-source-multimodal-llm-in-october%2F">报道称</a></u>，苹果公司在 2023 年 10 月低调发布了一款名为 Ferret 的开源多模态大语言模型，这是苹果与哥伦比亚大学研究人员的合作成果。当时发布的内容包括了<strong>代码和权重</strong>（仅限研究用途，不包含商业许可），但并未引起太多关注。</p><p>随着近期<a href="https://www.oschina.net/news/270317/mixtral-8-7b-32kseqlen">Mistral 的开源 MoE 模型</a>成为焦点，以及谷歌的 Gemini 模型即将在 Pixel Pro 上亮相，未来还将进入 Android 系统，越来越多人开始关注<strong>本地 LLMs 为小型设备提供支持</strong>的潜力。</p><p>近日，专注于医疗领域开源 AI 的欧洲非营利组织负责人 Bart de Witte 在 X 平台上分享了他的惊讶：「我之前竟然没发现这个。」 他表示，「苹果在 10 月份加入了开源 AI 圈子。<strong>Ferret 的推出展现了苹果对影响深远的 AI 研究的承诺</strong>，巩固了它在多模态 AI 领域的领先地位…… 另外，我很期待有一天 Local Large Language Models (LLLMs) 能作为重新设计的 iOS 的一部分，在我的 iPhone 上运行。」</p><p>苹果公司 AI/ML 研究科学家 Zhe Gan 在 10 月份发布的一条<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fzhegan4%2Fstatus%2F1712345137983201716" target="_blank">推文</a></u>中解释了 Ferret 的用途 —— 一个可以在图像中 "以任何粒度对任何地方的任何东西进行参照和定位" 的系统。它还可以通过使用图像中任何形状的区域来做到这一点。</p><p>简单地说，该模型可以分析图像上绘制的区域，确定其中对用户查询有用的元素，并将其识别出来，在检测到的元素周围绘制一个边界框。然后，它就可以将识别出的元素用作查询的一部分，并以典型的方式作出响应。</p><p>例如，高亮显示图像中的动物图片并询问 LLM 这是什么动物，LLM 可以确定该动物的种类，并确定用户所指的是动物群中的某只动物。然后，它还可以利用图像中检测到的其他项目的上下文，提供进一步的回复。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a440d5b0e01c06148ff9a53a44893647400.png" referrerpolicy="no-referrer"></p><blockquote><p><strong>GitHub</strong>：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ft.co%2FX29q1Kazew" target="_blank">https://github.com/apple/ml-ferret</a></u><br><strong>论文</strong>：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ft.co%2FOdhGoyK33r" target="_blank">https://arxiv.org/abs/2310.07704</a></u></p></blockquote><p>Ferret 拥有 (7B, 13B) 两个版本，为了增强 Ferret 模型的能力苹果特别收集了一个 GRIT 数据集。它包含了 1.1M 个样本，这些样本包含了丰富的层次空间知识。</p><p>尽管苹果以往以其产品和技术的封闭性著称，但现在它通过发布开源 LLM 模型，正逐渐改变这一形象，展现出其在 AI 领域的活跃参与和创新精神。这不仅对苹果自身，也对整个 AI 领域来说，都是一个值得关注的重要发展方向。</p><p>VentureBeat 撰稿人 Ben Dickson 写道：「2023 年最让你意外的人工智能进展是什么？对我来说，是苹果发布了开源 LLMs（虽然是非商业许可）。」他指出，苹果一贯以来是封闭系统、围墙花园开发、保密、严格的保密协议、发布极少细节、并为其产品申请每一项小的专利的代表。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 02:53:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272543/apple-quietly-released-an-open-source-multimodal-llm-in-october</guid>
            <link>https://www.oschina.net/news/272543/apple-quietly-released-an-open-source-multimodal-llm-in-october</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[De4py —— Python 逆向工程工具包]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>De4py 是一款高级 python 反混淆器，拥有漂亮的用户界面和一系列高级功能，可帮助恶意软件分析师和反向工程师对 python 文件等进行反混淆。</p><table border="1" cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; border:1px solid var(--borderColor-default, var(--color-border-default)); box-sizing:border-box; color:#1f2328; display:block; font-family:-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Noto Sans&quot;,Helvetica,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; max-width:100%; orphans:2; overflow:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:max-content; word-spacing:0px"><tbody><tr><th>特征</th><th>功能</th></tr></tbody><tbody><tr><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>反混淆</span></td><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>De4py 支持一些流行的混淆器，例如：Jawbreaker、BlankOBF、PlusOBF、Wodx、Hyperion、pyobfuscate.com 混淆器</span></td></tr><tr><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>Pycode 执行</span></td><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>在进程内执行 python 代码，这在许多情况下很有用，可以使程序执行您想让它执行的操作，例如，如果程序具有许可并且它调用真正的「main」只有购买了程序才可以直接调用。</span></td></tr><tr><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>字符串转储</span></td><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>在 python 进程中转储字符串并将其保存为文件，这对于从内存中提取数据（例如 webhook）非常有用。</span></td></tr><tr><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>删除退出功能</span></td><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>删除退出函数，如果 python 程序在找到调试器或虚拟机时尝试退出，该函数将非常有用</span></td></tr><tr><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>获取所有功能</span></td><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>获取 python 进程内的所有函数，这在尝试修改内存中的 python 函数时非常有用</span></td></tr><tr><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>Pyshell 图形用户界面</span></td><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>自定义 GUI，可以轻松在所需进程内执行 python 代码。</span></td></tr><tr><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>GUI 和控制枱支持</span></td><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>De4py 同时支持控制枱和 GUI</span></td></tr><tr><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>文件分析器</span></td><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>一个具有许多功能的分析器，例如检测 python 程序是否已打包，并尝试在使用 pyinstaller 时解包它，例如，它还有一个功能，可以显示所有字符串或可疑字符串（可疑字符串，例如：IP、网站和「token」「discord」「leveldb」字符串和文件中的其他可疑字符串）并在一个漂亮的输出窗口中显示它们。</span></td></tr><tr><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>行为监控</span></td><td style="background-color:#ffffff; border-style:solid; border-width:1px"><span>De4py 可以监控 python 进程，查看它们是否打开了任何文件句柄、打开了进程、写入/读取了其他进程的内存，还可以监控该进程是否终止了其他进程，此外还可以监控套接字（包括正在传输的数据大小）发送和正在发送/接收的 IP）。</span></td></tr></tbody></table><p><img height="281" src="https://static.oschina.net/uploads/space/2023/1218/162454_FC7o_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img height="291" src="https://static.oschina.net/uploads/space/2023/1218/162502_5f0Q_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 02:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/de4py</guid>
            <link>https://www.oschina.net/p/de4py</link>
        </item>
        <item>
            <title>
                <![CDATA[联想毛世杰：行业元宇宙愿景需要分阶段实现]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span>「满足人和机器的协同效率，为现实世界提供服务，这是元宇宙的愿景」，1</span></span><span><span>2</span></span><span><span>月 2</span></span><span><span>2</span></span><span><span>日，联想集团副总裁、联想研究院上海分院院长毛世杰在网易未来大会上表示，「而这个愿景需要分阶段实现。」</span></span></span></span></span></p><p><img height="333" src="https://static.oschina.net/uploads/space/2023/1225/101601_t3iM_4252687.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span>「之所以我们需要元宇宙，需要数字空间，是因为在虚拟空间里可以实现真实世界难以实现，或者是实现成本很高的事情。」毛世杰强调，但是在构建虚拟空间以后，最终的目的仍然是要回到现实世界，一步一步赋能现实世界变得更加美好和高效。</span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span>以工业元宇宙为例，毛世杰指出，第一步是要构建元宇宙产线。在元宇宙产线中，工业产线叠加虚拟世界的信息与感知能力，可以提升人与机器人的决策能力和协作效率；</span></span><span><span>在人、机器、数据等关键要素融合的产线数字孪生体和工业元宇宙虚拟装配空间中，非接触式检测手段可以实现三维自动化、智能化质检；工艺仿真模型库可以引导规范产线操作，提供专家远程协同指导等。</span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span>第二步是要构建元宇宙工厂。在元宇宙工厂中，通过低时延、高保真、智能决策的工厂级元宇宙平台可以实现多类型工业软件集成、沉浸交互设备实现智能巡检、远程协作等应用，工厂生产运营各环节信息可以全面感知和实时反馈。</span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span>第三步是打造元宇宙园区。在元宇宙园区中，虚实结合的新型园区建设模式和运营模式可以提升工业园区产业规划和布局能力，优化园区空间布局、设施配套、资源调配等协同服务能力和运营效率。此外，还可以建立基于工业元宇宙的科技创新和招商引资平台，创新园区服务模式。</span></span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span><span>「未来，联想将把持续打造成熟的工业元宇宙，开拓虚实互促的制造业增长新模式作为长期目标。」毛世杰强调。</span></span></span></span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 02:16:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272529</guid>
            <link>https://www.oschina.net/news/272529</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 支持私有部署的云端双链笔记软件 Blossom]]>
            </title>
            <description>
                <![CDATA[<p align="center"><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/blossom_name.png" height="auto" referrerpolicy="no-referrer"></p><p align="center"><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.wangyunf.com%2Fblossom-demo%2F%23%2Fsettingindex">💻️ 试用</a> | <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.wangyunf.com%2Fblossom-doc%2Findex.html">📃 文档</a> | <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.wangyunf.com%2Fblossom-doc%2Fguide%2Fabout%2Fdownload.html">📥 下载</a></p><p>Blossom 是一个支持<strong>私有部署</strong>的<strong>云端双链笔记软件</strong>，你可以将你的笔记，图片，个人计划安排保存在自己的服务器中，并在任意设备之间实时同步。同时还是一个动态博客。</p><p>支持 Windows，Mac，网页客户端，网页移动端。</p><p align="center"><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/device.png" referrerpolicy="no-referrer"></p><h1><a id="user-content-️-在线试用" class="anchor" href="https://gitee.com/blossom-editor/blossom#%EF%B8%8F-%E5%9C%A8%E7%BA%BF%E8%AF%95%E7%94%A8"></a>🛎️ 在线试用</h1><p>你可以通过<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.wangyunf.com%2Fblossom-demo%2F%23%2Fsettingindex">在线地址</a>或<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.wangyunf.com%2Fblossom-doc%2Fguide%2Fabout%2Fdownload.html">下载客户端</a>试用，详细信息请查看<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.wangyunf.com%2Fblossom-doc%2Fguide%2Ftryuse.html">试用</a>文档。</p><p><br><br></p><h1><a id="user-content--blossom-的特点" class="anchor" href="https://gitee.com/blossom-editor/blossom#-blossom-%E7%9A%84%E7%89%B9%E7%82%B9"></a>👏 Blossom 的特点:</h1><h3><a id="user-content-完善的文件关系" class="anchor" href="https://gitee.com/blossom-editor/blossom#%E5%AE%8C%E5%96%84%E7%9A%84%E6%96%87%E4%BB%B6%E5%85%B3%E7%B3%BB"></a>完善的文件关系</h3><p>Blossom 不依赖任何三方存储和图床，其本身就是一个图床，并且提供了完善的图片管理，访勿删，以及图片和文章的双向关系绑定。</p><p>基于 Markdown 编写，没有破坏性的语法拓展，在这里编写的内容在任何 Markdown 软件中都能正常显示。</p><h3><a id="user-content-快速迁移" class="anchor" href="https://gitee.com/blossom-editor/blossom#%E5%BF%AB%E9%80%9F%E8%BF%81%E7%A7%BB"></a>快速迁移</h3><p>所有图片和文章都支持一键备份和导出，可以在几分钟内轻松迁出。导出的文件可以无缝使用 VS Code 或 Obsidian 等本地软件正常打开。</p><h3><a id="user-content-丰富的附加功能" class="anchor" href="https://gitee.com/blossom-editor/blossom#%E4%B8%B0%E5%AF%8C%E7%9A%84%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD"></a>丰富的附加功能</h3><ul><li>📅 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.wangyunf.com%2Fblossom-doc%2Fguide%2Fplan.html">计划安排</a></li><li>🏷️ <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.wangyunf.com%2Fblossom-doc%2Fguide%2Ftodo.html">待办事项</a></li><li>🎫 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.wangyunf.com%2Fblossom-doc%2Fguide%2Fnote.html">快捷便签</a></li><li>🍅 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.wangyunf.com%2Fblossom-doc%2Fguide%2Farticle.html%23tomato">番茄钟</a></li><li>🧰 多用户、字数统计、字数折线图、编辑热力图、天气预报、主题设置...</li></ul><p>Blossom 拥有丰富的功能，不仅仅是知识管理，更是一个可以供多人同时使用的全面实用性工具。</p><p><br><br></p><h1><a id="user-content--docker-compose-一键部署" class="anchor" href="https://gitee.com/blossom-editor/blossom#-docker-compose-%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2"></a>🚀 Docker Compose 一键部署</h1><div class="black"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker compose -f docker/compose/blossom-mysql8.yaml up -d</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p><br><br></p><h1><a id="user-content--加入群聊" class="anchor" href="https://gitee.com/blossom-editor/blossom#-%E5%8A%A0%E5%85%A5%E7%BE%A4%E8%81%8A"></a>🥳 加入群聊</h1><p>加入群聊进行沟通，反馈问题。</p><ul><li>1 群：522359970 (即将满)</li><li>2 群：921906098</li></ul><p align="center"><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/qq1.png" height="400" referrerpolicy="no-referrer"><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/qq2.png" height="400" referrerpolicy="no-referrer"></p><h1><a id="user-content--赞助-blossom" class="anchor" href="https://gitee.com/blossom-editor/blossom#-%E8%B5%9E%E5%8A%A9-blossom"></a>🤝 赞助 Blossom</h1><p><strong>Blossom 不会向你收取任何的费用，你可以永久免费使用！</strong></p><p>但开源软件的收益目前很难维持生活，并且项目设计，开发，测试需要大量的时间和精力，如果你愿意赞助我的工作，将非常有助于该项目的成长，并激励我长期持续下去！</p><p><strong>感谢每一个位赞助者对 Blossom 的大力支持，Blossom 因为你们变得更好。</strong></p><table><thead><tr><th align="left">赞助者 / Sponsors</th><th align="left">赞助者 / Sponsors</th><th align="left">赞助者 / Sponsors</th><th align="left">赞助者 / Sponsors</th></tr></thead><tbody><tr><td align="left">i just walked away🏃</td><td align="left">KalyanYang</td><td align="left">dsx</td><td align="left">熊猫不是猫</td></tr><tr><td align="left">白驹过隙</td><td align="left">支付宝用户-*发</td><td align="left">支付宝用户-*琛</td><td align="left">支付宝匿名用户</td></tr><tr><td align="left">疾风剑豪索隆</td><td align="left">放羊的星星</td><td align="left">立冬</td><td align="left">给你一支烟</td></tr><tr><td align="left">林诗</td><td align="left">Criesgod</td><td align="left">支付宝用户-*伟</td><td align="left">黑醋栗和丁香</td></tr><tr><td align="left">Mr_tg000</td><td align="left">Lucky</td><td align="left">egil</td><td align="left">Glimpse</td></tr><tr><td align="left">支付宝用户-**衡</td><td align="left">支付宝用户-**福</td><td align="left">支付宝用户-**盼</td><td align="left">何其正</td></tr><tr><td align="left">-A 明</td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><hr><h4 align="center"><a id="user-content-你可以通过以下几种方式赞助-blossom" class="anchor" href="https://gitee.com/blossom-editor/blossom#%E4%BD%A0%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%B5%9E%E5%8A%A9-blossom"></a>你可以通过以下几种方式赞助 Blossom。</h4><p align="center"><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/sponsors/wechat.png" height="400" referrerpolicy="no-referrer"><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/sponsors/ali.png" height="400" referrerpolicy="no-referrer"><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/sponsors/aifadian.png" height="400" referrerpolicy="no-referrer"></p><br><h1><a id="user-content-更多图片" class="anchor" href="https://gitee.com/blossom-editor/blossom#%E6%9B%B4%E5%A4%9A%E5%9B%BE%E7%89%87"></a>更多图片</h1><p><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/article.png" alt="&quot;编辑器&quot;" referrerpolicy="no-referrer"></p><p align="center">编辑器</p><hr><p><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/article_reference.png" alt="&quot;双链笔记&quot;" referrerpolicy="no-referrer"></p><p align="center">双链笔记</p><hr><p><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/picture.png" alt="&quot;照片墙&quot;" referrerpolicy="no-referrer"></p><p align="center">照片墙</p><hr><p><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/todo.png" alt="&quot;日历计划&quot;" referrerpolicy="no-referrer"></p><p align="center">待办事项清单</p><hr><p><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/plan.png" alt="&quot;日历计划&quot;" referrerpolicy="no-referrer"></p><p align="center">日历计划</p><hr><p><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/note.png" alt="&quot;便签管理&quot;" referrerpolicy="no-referrer"></p><p align="center">便签管理</p><hr><p><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/blog_home_pc.png" alt="&quot;博客&quot;" referrerpolicy="no-referrer"></p><p align="center">博客</p><p align="center"><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/blog_home_m.png" height="600" referrerpolicy="no-referrer"><img src="https://gitee.com/blossom-editor/blossom/raw/dev/doc/imgs/blog_article.png" height="600" referrerpolicy="no-referrer"></p><p align="center">博客移动端</p>]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 02:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/blossom-editor/blossom</guid>
            <link>https://gitee.com/blossom-editor/blossom</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 前端 JS 安全对抗原理与实践]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="letter-spacing: 0.578px;text-wrap: wrap;font-size: 15px;line-height: 1.6;"><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;"><section style="padding-left: 8px;display: inline-block;width: 578px;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;align-self: flex-start;flex: 0 0 auto;"><section powered-by="xiumi.us" style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;"><p>作者：vivo 互联网安全团队- Luo Bingsong</p></section></section></section><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><section style="padding: 10px;display: inline-block;width: 578px;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);"><section powered-by="xiumi.us" style="text-align: left;"><section style="padding-right: 5px;padding-left: 5px;text-align: justify;line-height: 1.8;color: rgb(160, 160, 160);"><p>前端代码都是公开的，为了提高代码的破解成本、保证 JS 代码里的一些重要逻辑不被居心叵测的人利用，需要使用一些加密和混淆的防护手段。</p></section></section><section powered-by="xiumi.us" style="margin-bottom: -5px;text-align: right;line-height: 1;font-size: 5px;transform: translate3d(5px, 0px, 0px);"><section style="width: 0px;display: inline-block;vertical-align: top;border-bottom: 0.6em solid rgb(160, 160, 160);border-right: 0.6em solid rgb(160, 160, 160);border-top: 0.6em solid transparent !important;border-left: 0.6em solid transparent !important;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>一、概念解析</p></section></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">1.1 什么是接口加密</span></p><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p>如今这个时代，数据已经变得越来越重要，网页和 APP 是主流的数据载体，如果获取数据的接口没有设置任何的保护措施的话，数据就会被轻易地窃取或篡改。</p><p><br></p><p>除了数据泄露外，一些重要功能的接口如果没有做好保护措施也会被恶意调用造成 DDoS、条件竞争等攻击效果，比如如下几个场景：</p><p><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014131" data-ratio="0.3388888888888889" data-s="300,640" src="https://oscimg.oschina.net/oscnet/7ad9ffb7-adfb-4eda-b6ab-870efe6f751f.png" data-type="png" data-w="1080" referrerpolicy="no-referrer"></p><p><br></p></section><section powered-by="xiumi.us"><p>一些营销活动类的 Web 页面，领红包、领券、投票、抽奖等活动方式很常见。此类活动对于普通用户来说应该是「拼手气」，而对于非正常用户来说，可以通过直接刷活动 API 接口的这种「作弊」方式来提升「手气」。这样对普通用户来说就很不公平。</p><p><br></p><p>所以对重要接口都会采用加密验签的方式进行保护，而验签的加密逻辑大多数都通过 JS 代码实现，所以保护 JS 代码不被攻击者窃取尤为重要。</p></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">1.2 为什么要保护 JS 代码</span><span style="background-color: rgb(239, 239, 239);letter-spacing: 0.034em;"></span></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: right;"><section style="padding: 10px;display: inline-block;width: 578px;border-width: 1px;border-style: solid;border-color: transparent;background-color: rgb(239, 239, 239);height: auto;"><section powered-by="xiumi.us" style="text-align: justify;"><ul class="list-paddingleft-1" style="width: 555.438px;"><li><p><span style="letter-spacing: 0.578px;">JavaScript 代码运行于客户端</span><br></p></li><li><p><span style="letter-spacing: 0.034em;">JavaScript 代码是公开透明的</span><br></p></li></ul></section></section></section><p powered-by="xiumi.us"><span style="letter-spacing: 0.034em;">由于这两个原因，致使 JavaScript 代码是不安全的，任何人都可以读、分析、复制、盗用甚至篡改。</span><br></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">1.3 应用场景</span></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">以下场景就通过特定的防护措施提高了攻击成本：</p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><section style="padding: 10px;display: inline-block;width: 578px;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);"><section powered-by="xiumi.us" style="padding-right: 5px;padding-left: 5px;text-align: justify;line-height: 1.8;"><ul class="list-paddingleft-1" style="width: 545.453px;"><li><p><span style="letter-spacing: 0.578px;">某些网站会在页面中使用 JavaScript 对数据进行加密，以保护数据的安全性和隐私性，在爬取时需要通过解密 JavaScript 代码才能获取到数据。</span><br></p></li><li><p>某些网站的 URL 会有某个参数带有一些看不太懂的长串加密参数，攻击者要爬取的话就必须要知道这些参数是怎么构造的，否则无法正确地访问该 URL。</p></li><li><p><span style="letter-spacing: 0.034em;">翻看网站的 JavaScript 源代码，可以发现很多压缩了或者看不太懂的字符，比如 JavaScript 文件名被编码，JavaScript 的文件内容都压缩成几行，JavaScript 变量也被修改成单个字符或者一些十六进制的字符，所以我们不能轻易地根据 JavaScript 找出某些接口的加密逻辑。</span></p></li></ul></section></section></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">1.4 涉及的技术</span></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">这些场景都是网站为了保护数据不被轻易抓取采取的措施，运用的技术主要有：</p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><section style="padding: 10px;display: inline-block;width: 578px;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);"><section powered-by="xiumi.us" style="padding-right: 5px;padding-left: 5px;text-align: justify;line-height: 1.8;"><ul class="list-paddingleft-1" style="width: 545.453px;"><li><p><span style="letter-spacing: 0.578px;">接口加密技术</span><br></p></li><li><p><span style="letter-spacing: 0.034em;">JavaScript 压缩、混淆和加密技术</span><br></p></li></ul></section></section></section><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>二、技术原理</p></section></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.1 接口加密技术</span></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">数据和功能一般是通过服务器提供的接口来实现，为了提升接口的安全性，客户端会和服务端约定一种接口检验方式，通常是各种加密和编码算法，如 Base64、Hex、MD5、AES、DES、RSA 等。</p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">常用的数据接口都会携带一个 sign 参数用于权限管控：</p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><section style="padding: 10px;display: inline-block;width: 578px;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);"><section powered-by="xiumi.us" style="padding-right: 5px;padding-left: 5px;text-align: justify;line-height: 1.8;"><p>① 客户端和服务端约定一种接口校验逻辑，客户端在每次请求服务端接口的时候附带一个 sign 参数。<br>② sign 参数的逻辑自定义，可以由当前时间戳信息、设备 ID、日期、双方约定好的秘钥经过一些加密算法构造而成。<br>③ 客户端根据约定的加密算法构造 sign，每次请求服务器的时候附带上 sign 数。<br>④ 服务端根据约定的加密算法和请求的数据对 sign 进行校验，如果检验通过，才返回数据，否则拒绝响应。</p></section></section></section><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014130" data-ratio="0.5841708542713567" data-s="300,640" src="https://oscimg.oschina.net/oscnet/31059832-3a24-49be-bc27-11ceb57f0134.png" data-type="png" data-w="796" referrerpolicy="no-referrer"></p><p><br></p><p>这就是一个比较简单的接口参数加密的实现，如果有人想要调用这个接口的话，必须要破解 sign 的生成逻辑，否则是无法正常调用接口的。</p><p><br></p><p>当然上面的实现思路比较简单，还可以增加一些时间戳信息和访问频次来增加时效性判断，或使用非对称加密提高加密的复杂程度。</p><p><br></p><p>实现接口参数加密需要用到一些加密算法，客户端和服务器都有对应的 SDK 来实现这些加密算法，如 JavaScript 的 crypto-js、Python 的 hashlib、Crypto 等等。如果是网页且客户端的加密逻辑是用 JavaScript 来实现的话，其源代码对用户是完全可见的，所以我们需要用压缩、混淆、加密的方式来对 JavaScript 代码进行一定程度的保护。</p></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.2 什么是压缩</span></p><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p>去除 JavaScript 代码中不必要的空格、换行等内容，使源码都压缩为几行内容，降低代码可读性，同时可提高网站的加载速度。</p><p><br></p><p>如果仅仅是去除空格换行这样的压缩方式，几乎没有任何防护作用，这种压缩方式仅仅是降低了代码的直接可读性，可以用 IDE、在线工具或 Chrome 轻松将 JavaScript 代码变得易读。</p><p><br></p><p>所以 JavaScript 压缩技术只能在很小的程度上起到防护作用，想提高防护的效果还得依靠 JavaScript 混淆和加密技术。</p></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.3 什么是混淆</span></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">使用变量混淆、字符串混淆、属性加密、控制流平坦化、调试保护、多态变异等手段，使代码变得难以阅读和分析，同时不影响代码原有功能，是一种理想且实用的 JS 保护方案。<span style="background-color: rgb(239, 239, 239);letter-spacing: 0.034em;"></span></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: right;"><section style="padding: 10px;display: inline-block;width: 578px;border-width: 1px;border-style: solid;border-color: transparent;background-color: rgb(239, 239, 239);height: auto;"><section powered-by="xiumi.us" style="text-align: justify;"><ul class="list-paddingleft-1" style="width: 555.438px;"><li><p><strong>变量混淆</strong><span style="letter-spacing: 0.578px;">：将变量名、方法名、常量名随机变为无意义的乱码字符串，降低代码可读性，如转成单个字符或十六进制字符串。</span><br></p></li><li><p><strong>字符串混淆</strong>：将字符串阵列化集中放置，并进行 MD5 或 Base64 编码存储，使代码中不出现明文字符串，可以避免使用全局搜索字符串的方式定位到入口点。</p></li><li><p><strong>属性加密</strong><span style="letter-spacing: 0.578px;">：针对 JavaScript 对象的属性进行加密转化，隐藏代码之间的调用关系，把 key-value 的映射关系混淆掉。</span></p></li><li><p><strong>控制流平坦化</strong><span style="letter-spacing: 0.578px;">：打乱函数原有代码执行流程及函数调用关系，使代码逻辑变得混乱无序。</span></p></li><li><p><strong>调试保护</strong><span style="letter-spacing: 0.578px;">：基于调试器特性，加入一些强制调试 debug 语句，无限 debug、定时 debug、debug 关键字，使其在调试模式下难以顺利执行 JavaScript 代码。</span></p></li><li><p><strong>多态变异</strong><span style="letter-spacing: 0.578px;">：JavaScript 代码每次被调用时，代码自身立刻自动发生变异，变化为与之前完全不同的代码，避免代码被动态分析调试。</span><span style="letter-spacing: 0.034em;"></span></p></li></ul></section></section></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.4 什么是加密</span></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">JavaScript 加密是对 JavaScript 混淆技术防护的进一步升级，基本思路是将一些核心逻辑用 C/C++语言来编写，并通过 JavaScript 调用执行，从而起到二进制级别的防护作用，加密的方式主要有 Emscripten 和 WebAssembly 等。</p><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p><strong>1. Emscripten</strong></p><p>Emscripten 编译器可以将 C/C++代码编译成 asm.js 的 JavaScript 变体，再由 JavaScript 调用执行，因此某些 JavaScript 的核心功能可以使用 C/C++语言实现。</p></section><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p><strong>2.WebAssembly</strong></p><p>WebAssembly 也能将 C/C++代码转成 JavaScript 引擎可以运行的代码，但转出来的代码是二进制字节码，而 asm.js 是文本，因此运行速度更快、体积更小，得到的字节码具有和 JavaScript 相同的功能，在语法上完全脱离 JavaScript，同时具有沙盒化的执行环境，利用 WebAssembly 技术，可以将一些核心的功能用 C/C++语言实现，形成浏览器字节码的形式，然后在 JavaScript 中通过类似如下的方式调用：</p></section><p powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014132" data-ratio="0.31203703703703706" data-s="300,640" src="https://oscimg.oschina.net/oscnet/6fc3ee11-4879-4a3a-a9fd-1ae1cf3e94de.png" data-type="png" data-w="1080" referrerpolicy="no-referrer"></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">这种加密方式更加安全，想要逆向或破解需要逆向 WebAssembly，难度极大。</p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.5 工具介绍</span></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><strong>2.5.1 压缩混淆工具</strong></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><section style="padding: 10px;display: inline-block;width: 578px;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);"><section powered-by="xiumi.us" style="padding-right: 5px;padding-left: 5px;text-align: justify;line-height: 1.8;"><ul class="list-paddingleft-1" style="width: 545.453px;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmishoo%2FUglifyJS" textvalue="Uglifyjs" linktype="text" imgurl="" tab="outerlink" data-linktype="2" style="letter-spacing: 0.578px;"><strong>Uglifyjs</strong></a><span style="letter-spacing: 0.578px;">（开源）：</span><br></p><p>用 NodeJS 编写的 JavaScript 压缩工具，是目前最流行的 JS 压缩工具，JQuery 就是使用此工具压缩，UglifyJS 压缩率高，压缩选项多，并且具有优化代码，格式化代码功能。</p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.jshaman.com%2F" textvalue="jshsman" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><strong>jshaman</strong></a>：</p><p><span style="letter-spacing: 0.034em;">jshaman 是一个商业级</span><span style="letter-spacing: 0.034em;">工具，看了很多社区的评论，这个目前是最好的，可以在线免费使用，也可以购买商业版。</span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.jsfuck.com%2F" textvalue="jsfuck" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><strong>jsfuck</strong></a>：</p><p>开源的 js 混淆工具，原理比较简单，通过特定的字符串加上下标定位字符，再由这些字符替换源代码，从而实现混淆。</p></li><li><p><strong><span style="letter-spacing: 0.034em;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fyui.github.io%2Fyuicompressor%2F" textvalue="YUI Compressor" linktype="text" imgurl="" tab="outerlink" data-linktype="2">YUI Compressor</a>：</span></strong></p><p><span style="letter-spacing: 0.034em;">业界巨头 yahoo 提供的一个前端压缩工具，通过 java 库编译 css 或 js 文件进行压缩</span></p></li></ul></section></section></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><strong>2.5.2 反混淆工具</strong></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><section style="padding: 10px;display: inline-block;width: 578px;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);"><section powered-by="xiumi.us" style="padding-right: 5px;padding-left: 5px;text-align: justify;line-height: 1.8;"><ul class="list-paddingleft-1" style="width: 545.453px;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbeautifier.io%2F" textvalue="jsbeautifier" linktype="text" imgurl="" tab="outerlink" data-linktype="2" style="letter-spacing: 0.578px;"><strong>jsbeautifier</strong></a><span style="letter-spacing: 0.578px;">：</span></p><p>jsbeautifier 是一个为前端开发人员制作的 Chrome 扩展，能够直接查看经过压缩的 Javascript 代码。</p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Feth-sri%2FUnuglifyJS" textvalue="UnuglifyJS" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><strong>UnuglifyJS</strong></a>：</p><p>压缩工具 uglify 对应的解混淆工具。</p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.jspacker.org%2F" textvalue="jspacker" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="letter-spacing: 0.034em;"><strong>jspacker</strong></span></a><span style="letter-spacing: 0.034em;">：</span></p><p><span style="letter-spacing: 0.034em;"></span><span style="letter-spacing: 0.034em;">用 PHP 编写的压缩工具，可以混淆代码保护知识产权，产生的代码兼容 IE、FireFox 等常用浏览器，国内大部分在线工具网站都采用这种算法压缩。</span><br></p></li></ul></section></section></section><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>三、前端安全对抗</p></section></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.1 前端调试手法</span></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><strong>3.1.1 Elements</strong></p><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p>Elements 面板会显示目前网页中的 DOM、CSS 状态，且可以修改页面上的 DOM 和 CSS，即时看到结果，省去了在编辑器修改、储存、浏览器查看结果的流程。</p><p><br></p><p>有时候一些 dom 节点会嵌套很深，导致我们很难利用 Element 面板 html 代码来找到对应的节点。inspect(dom 元素) 可以让我们快速跳转到对应的 dom 节点的 html 代码上。</p><p><br></p></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014129" data-ratio="0.19074074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/39694af8-33f5-487e-a5b7-77e04bb1b89c.png" data-type="png" data-w="1080" referrerpolicy="no-referrer"></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><strong>3.1.2 Console</strong></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">Console 对象提供了浏览器控制枱调试的接口，Console 是一个对象，上面有很多方便的方法。</p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: right;"><section style="padding: 10px;display: inline-block;width: 578px;border-width: 1px;border-style: solid;border-color: transparent;background-color: rgb(239, 239, 239);height: auto;"><section powered-by="xiumi.us" style="text-align: justify;"><ul class="list-paddingleft-1" style="width: 555.438px;"><li><p><strong style="letter-spacing: 0.578px;">console.log( )</strong><span style="letter-spacing: 0.578px;">：</span><span style="letter-spacing: 0.578px;">最常用的语句，可以将变量输出到浏览器的控制枱中，方便开发者调用 JS 代码</span><br></p></li><li><p><strong>console.table( )</strong>：可用于打印 obj/arr 成表格<br></p></li><li><p><strong><span style="letter-spacing: 0.034em;">console.trace( )</span></strong><span style="letter-spacing: 0.034em;">：</span><span style="letter-spacing: 0.034em;">可用于 debugger 堆栈调试，方便查看代码的执行逻辑，看一些库的源码</span></p></li><li><p><strong style="letter-spacing: 0.034em;"><span style="letter-spacing: 0.034em;"></span></strong><strong style="letter-spacing: 0.034em;">console.count( )</strong><span style="letter-spacing: 0.034em;">：</span><span style="letter-spacing: 0.034em;">打印标签被执行了几次，预设值是 default，可用在快速计数</span></p></li><li><p><strong style="letter-spacing: 0.034em;">console.countReset( )</strong><span style="letter-spacing: 0.034em;">：</span><span style="letter-spacing: 0.034em;">用来重置，可用在计算单次行为的触发的计数</span></p></li><li><p><strong style="letter-spacing: 0.034em;">console.group( )/console.groupEnd( )</strong><span style="letter-spacing: 0.034em;">：</span></p><p><span style="letter-spacing: 0.034em;"></span><span style="letter-spacing: 0.034em;">为了方便一眼看到自己的 log，可以用 console.group 自定义 message group 标签，还可以多层嵌套，并用 console.groupEnd 来关闭 Group。</span></p></li></ul></section></section></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><strong>3.1.3 JS 断点调试</strong></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">JS 断点调试，即在浏览器开发者工具中为 JS 代码添加断点，让 JS 执行到某一特定位置停住，方便开发者对该处代码段进行分析与逻辑处理。</p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><strong>&nbsp;Sources 面板</strong></p><section powered-by="xiumi.us"><p><br></p><p><strong>① 普通断点（breakpoint）</strong></p><p>给一段代码添加断点的流程是："F12（Ctrl + Shift + I）打开开发工具"-&gt;"点击 Sources 菜单"-&gt;"左侧树中找到相应文件"→"点击行号列"即完成在当前行添加/删除断点操作。当断点添加完毕后，刷新页面 JS 执行到断点位置停住，在 Sources 界面会看到当前作用域中所有变量和值。</p><p><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014133" data-ratio="0.2953703703703704" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b8309fa8-8bcf-4c9d-9911-0c4940c2fc03.png" data-type="png" data-w="1080" referrerpolicy="no-referrer"></p><p><br></p></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><section style="padding: 10px;display: inline-block;width: 578px;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);"><section powered-by="xiumi.us" style="padding-right: 5px;padding-left: 5px;text-align: justify;line-height: 1.8;"><ul class="list-paddingleft-1" style="width: 545.453px;"><li><p><span style="letter-spacing: 0.578px;"><strong>恢复（Resume）</strong>：</span><span style="letter-spacing: 0.578px;">&nbsp;恢复按钮 (第一个按钮)，继续执行，快捷键 F8，继续执行，如果没有其他的断点，那么程序就会继续执行，并且调试器不会再控制程序。</span><br></p></li><li><p><strong>跨步（Step over）</strong>：运行下一条指令，但不会进入到一个函数中，快捷键 F10。</p></li><li><p><span style="letter-spacing: 0.034em;"><strong>步入（Step into）</strong>：</span><span style="letter-spacing: 0.034em;">快捷键 F11，和「下一步（Step）」类似，但在异步函数调用情况下表现不同，步入会进入到代码中并等待异步函数执行。</span></p></li><li><p><strong>步出（Step out）</strong>：继续执行到当前函数的末尾，快捷键 Shift+F11，继续执行代码并停止在当前函数的最后一行，当我们使用偶然地进入到一个嵌套调用，但是我们又对这个函数不感兴趣时，我们想要尽可能的继续执行到最后的时候是非常方便的。</p></li><li><p><span style="letter-spacing: 0.034em;"><strong>下一步（Step）</strong></span><span style="letter-spacing: 0.034em;">：</span><span style="letter-spacing: 0.034em;">运行下一条语句，快捷键 F9，一次接一次地点击此按钮，整个脚本的所有语句会被逐个执行，下一步命令会忽略异步行为。</span></p></li></ul></section></section></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">启用/禁用所有的断点：这个按钮不会影响程序的执行。只是一个批量操作断点的开/关。</p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><section style="padding: 10px;display: inline-block;width: 578px;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);"><section powered-by="xiumi.us" style="padding-right: 5px;padding-left: 5px;text-align: justify;line-height: 1.8;"><ul class="list-paddingleft-1" style="width: 545.453px;"><li><p><span style="letter-spacing: 0.578px;"><strong>察看（Watch）</strong>：</span><span style="letter-spacing: 0.578px;">显示任意表达式的当前值</span></p></li><li><p><span style="letter-spacing: 0.034em;"><strong>调用栈（Call Stack）</strong>：</span><span style="letter-spacing: 0.034em;">显示嵌套的调用链</span></p></li><li><p><span style="letter-spacing: 0.034em;"><strong>作用域（Scope）</strong>：</span><span style="letter-spacing: 0.034em;">显示当前的变量</span></p></li><li><p><span style="letter-spacing: 0.034em;"><strong>Local</strong>：</span><span style="letter-spacing: 0.034em;">显示当前函数中的变量</span></p></li><li><p><span style="letter-spacing: 0.034em;"><strong>Global</strong>：</span><span style="letter-spacing: 0.034em;">显示全局变量</span></p></li></ul></section></section></section><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p><strong>② 条件断点（Conditional breakpoint）</strong></p><p>给断点添加条件，只有符合条件时，才会触发断点，条件断点的颜色是橙色。</p><p><br></p></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014135" data-ratio="0.5224111282843895" data-s="300,640" src="https://oscimg.oschina.net/oscnet/0b4c6239-c36d-463c-8821-b3c4b21aa82a.png" data-type="png" data-w="647" referrerpolicy="no-referrer"></p><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p><strong>③ 日志断点（logpoint）</strong></p><p>当代码执行到这里时，会在控制枱输出你的表达式，不会暂停代码执行，日志断点式粉红色。</p></section><p powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-cropselx1="0" data-cropselx2="578" data-cropsely1="0" data-cropsely2="302" data-imgfileid="100014134" data-ratio="0.5037707390648567" data-s="300,640" src="https://oscimg.oschina.net/oscnet/a82c513e-796f-42e8-b27a-f2e2c01d0b61.png" data-type="png" data-w="663" style="width: 578px;height: 291px;" referrerpolicy="no-referrer"></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><strong>debugger 命令</strong></p><section powered-by="xiumi.us"><p><br></p><p>通过在代码中添加"debugger;"语句，当代码执行到该语句的时候就会自动断点，之后的操作和在 Sources 面板添加断点调试，唯一的区别在于调试完后需要删除该语句。</p><p><br></p><p>在开发中偶尔会遇到异步加载 html 片段（包含内嵌 JS 代码）的情况，而这部分 JS 代码在 Sources 树中无法找到，因此无法直接在开发工具中直接添加断点，那么如果想给异步加载的脚本添加断点，此时"debugger;"就发挥作用了。</p></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.2 反调试手段</span></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><strong>3.2.1 禁用开发者工具</strong></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">监听是否打开开发者工具，若打开，则直接调用 JavaScript 的 window.close( ) 方法关闭网页</p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">① 监听 F12 按键、监听 Ctrl+Shift+I（Windows 系统）组合键、监听右键菜单，监听 Ctrl+s 禁止保存至本地，避免被 Overrides。</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="xml"><code><span class="code-snippet_outer"><span class="code-snippet__tag">&lt;<span class="code-snippet__name">script</span>&gt;</span></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//监听 F12、Ctrl+Shift+i、Ctrl+s</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">document</span>.onkeydown = <span class="code-snippet__function"><span class="code-snippet__keyword">function</span> (<span class="code-snippet__params">event</span>) </span>{</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (event.key === <span class="code-snippet__string">"F12"</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.close();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.location = <span class="code-snippet__string">"about:blank"</span>;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (event.ctrlKey &amp;&amp; event.shiftKey &amp;&amp; event.key === <span class="code-snippet__string">"I"</span>) {<span class="code-snippet__comment">//此处 I 必须大写</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.close();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.location = <span class="code-snippet__string">"about:blank"</span>;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (event.ctrlKey &amp;&amp; event.key === <span class="code-snippet__string">"s"</span>) {<span class="code-snippet__comment">//此处 s 必须小写</span></span></code><code><span class="code-snippet_outer">            event.preventDefault();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.close();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.location = <span class="code-snippet__string">"about:blank"</span>;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer">    };</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//监听右键菜单</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">document</span>.oncontextmenu = <span class="code-snippet__function"><span class="code-snippet__keyword">function</span> (<span class="code-snippet__params"></span>) </span>{</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.close();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.location = <span class="code-snippet__string">"about:blank"</span>;</span></code><code><span class="code-snippet_outer">    };</span></code><code><span class="code-snippet_outer"><span class="code-snippet__tag">&lt;/<span class="code-snippet__name">script</span>&gt;</span></span></code></pre></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">② 监听窗口大小变化</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="xml"><code><span class="code-snippet_outer"><span class="code-snippet__tag">&lt;<span class="code-snippet__name">script</span>&gt;</span></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">var</span> h = <span class="code-snippet__built_in">window</span>.innerHeight, w = <span class="code-snippet__built_in">window</span>.innerWidth;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.onresize = <span class="code-snippet__function"><span class="code-snippet__keyword">function</span> (<span class="code-snippet__params"></span>) </span>{</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (h !== <span class="code-snippet__built_in">window</span>.innerHeight || w !== <span class="code-snippet__built_in">window</span>.innerWidth) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.close();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.location = <span class="code-snippet__string">"about:blank"</span>;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__tag">&lt;/<span class="code-snippet__name">script</span>&gt;</span></span></code></pre></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">③ 利用 Console.log</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="xml"><code><span class="code-snippet_outer"><span class="code-snippet__tag">&lt;<span class="code-snippet__name">script</span>&gt;</span></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//控制枱打开的时候回调方法</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">function</span><span class="code-snippet__title">consoleOpenCallback</span>(<span class="code-snippet__params"></span>)</span>{</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.close();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.location = <span class="code-snippet__string">"about:blank"</span>;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span><span class="code-snippet__string">""</span>;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//立即运行函数，用来检测控制枱是否打开</span></span></code><code><span class="code-snippet_outer">    !<span class="code-snippet__function"><span class="code-snippet__keyword">function</span> (<span class="code-snippet__params"></span>) </span>{</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 创建一个对象</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">let</span> foo = <span class="code-snippet__regexp">/./</span>;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 将其打印到控制枱上，实际上是一个指针</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">console</span>.log(foo);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 要在第一次打印完之后再重写 toString 方法</span></span></code><code><span class="code-snippet_outer">        foo.toString = consoleOpenCallback;</span></code><code><span class="code-snippet_outer">    }()</span></code><code><span class="code-snippet_outer"><span class="code-snippet__tag">&lt;/<span class="code-snippet__name">script</span>&gt;</span></span></code></pre></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><strong>3.2.2 无限 debugger 反调试</strong></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">① constructor</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="xml"><code><span class="code-snippet_outer"><span class="code-snippet__tag">&lt;<span class="code-snippet__name">script</span>&gt;</span></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">function</span><span class="code-snippet__title">consoleOpenCallback</span>(<span class="code-snippet__params"></span>) </span>{</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.close();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__built_in">window</span>.location = <span class="code-snippet__string">"about:blank"</span>;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer">    setInterval(<span class="code-snippet__function"><span class="code-snippet__keyword">function</span> (<span class="code-snippet__params"></span>) </span>{</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">const</span> before = <span class="code-snippet__keyword">new</span><span class="code-snippet__built_in">Date</span>();</span></code><code><span class="code-snippet_outer">        (<span class="code-snippet__function"><span class="code-snippet__keyword">function</span>(<span class="code-snippet__params"></span>)</span>{}).constructor(<span class="code-snippet__string">"debugger"</span>)();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// debugger;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">const</span> after = <span class="code-snippet__keyword">new</span><span class="code-snippet__built_in">Date</span>();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">const</span> cost = after.getTime() - before.getTime();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (cost &gt; <span class="code-snippet__number">100</span>) {</span></code><code><span class="code-snippet_outer">            consoleOpenCallback();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }, <span class="code-snippet__number">1000</span>);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__tag">&lt;/<span class="code-snippet__name">script</span>&gt;</span></span></code></pre></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">② Function</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="xml"><code><span class="code-snippet_outer"><span class="code-snippet__tag">&lt;<span class="code-snippet__name">script</span>&gt;</span></span></code><code><span class="code-snippet_outer">    setInterval(<span class="code-snippet__function"><span class="code-snippet__keyword">function</span> (<span class="code-snippet__params"></span>) </span>{</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">const</span> before = <span class="code-snippet__keyword">new</span><span class="code-snippet__built_in">Date</span>();</span></code><code><span class="code-snippet_outer">        (<span class="code-snippet__function"><span class="code-snippet__keyword">function</span> (<span class="code-snippet__params">a</span>) </span>{</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> (<span class="code-snippet__function"><span class="code-snippet__keyword">function</span> (<span class="code-snippet__params">a</span>) </span>{</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> (<span class="code-snippet__built_in">Function</span>(<span class="code-snippet__string">'Function(arguments[0]+"'</span> + a + <span class="code-snippet__string">'")()'</span>))</span></code><code><span class="code-snippet_outer">            })(a)</span></code><code><span class="code-snippet_outer">        })(<span class="code-snippet__string">'bugger'</span>)(<span class="code-snippet__string">'de'</span>);</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Function('debugger')();</span></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// debugger;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">const</span> after = <span class="code-snippet__keyword">new</span><span class="code-snippet__built_in">Date</span>();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">const</span> cost = after.getTime() - before.getTime();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (cost &gt; <span class="code-snippet__number">100</span>) {</span></code><code><span class="code-snippet_outer">            consoleOpenCallback2();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer">    }, <span class="code-snippet__number">1000</span>);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__tag">&lt;/<span class="code-snippet__name">script</span>&gt;</span></span></code></pre></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;"><section style="padding-left: 8px;display: inline-block;width: 578px;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;align-self: flex-start;flex: 0 0 auto;"><section powered-by="xiumi.us" style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;"><p>有大佬写了一个库专门用来判断是否打开了开发者工具，可供参考使用：<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsindresorhus%2Fdevtools-detect" textvalue="点击查看>>" linktype="text" imgurl="" tab="outerlink" data-linktype="2">点击查看&gt;&gt;</a></p></section></section></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.3 反反调试手段</span></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><strong>3.3.1 禁用开发者工具</strong></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">针对判断是否打开开发者工具的破解方式很简单，只需两步就可以搞定。</p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-align: center;"><section style="padding: 10px;display: inline-block;width: 578px;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);"><section powered-by="xiumi.us" style="padding-right: 5px;padding-left: 5px;text-align: justify;line-height: 1.8;"><p>① 将开发者工具以独立窗口形式打开</p><p>② 打开开发者工具后再打开网址</p></section></section></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us"><strong>3.3.2 无限 debugger</strong></p><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">针对无限 debugger 反调试，有以下破解方法</p><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p>① 直接使用 dubbger 指令的，可以在 Chrome 找到对应行（格式化后），右键行号，选择 Never pause here 即可。</p><p><br></p><p>② 使用了 constructor 构造 debugger 的，只需在 console 中输入以下代码后，点击 F8（Resume script execution）回复 js 代码执行即可（直接点击小的蓝色放行按钮即可）。</p></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="javascript"><code><span class="code-snippet_outer"><span class="code-snippet__built_in">Function</span>.prototype.constructor=<span class="code-snippet__function"><span class="code-snippet__keyword">function</span>(<span class="code-snippet__params"></span>)</span>{}</span></code></pre></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">③ 使用了 Function 构造 debugger 的，只需在 console 中输入以下代码。</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="javascript"><code><span class="code-snippet_outer"><span class="code-snippet__built_in">Function</span> = <span class="code-snippet__function"><span class="code-snippet__keyword">function</span> (<span class="code-snippet__params"></span>) </span>{}</span></code></pre></section><p powered-by="xiumi.us"><br></p><section powered-by="xiumi.us" style="font-size: 16px;color: rgb(65, 95, 255);"><p>3.4 总结</p></section><p powered-by="xiumi.us"><br></p><p powered-by="xiumi.us">JavaScript 混淆加密使得代码更难以被反编译和分析，从而提高了代码的安全性，攻击者需要花费更多的时间和精力才能理解和分析代码，从而降低了攻击者入侵的成功率，但它并不能完全保护代码不被反编译和分析，如果攻击者有足够的时间和资源，他们仍然可以理解代码并找到其中的漏洞，道高一尺，魔高一丈，任何客户端加密混淆都会被破解，只要用心都能解决，我们能做的就是拖延被破解的时间，所以尽量避免在前端代码中嵌入敏感信息或业务逻辑。</p><p powered-by="xiumi.us"><span style="font-size: 14px;text-align: left;background-color: rgb(239, 239, 239);letter-spacing: 0.578px;"><br></span></p><section style="font-size: 15px;"><section style="margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;"><section style="text-align: center;color: rgb(45, 66, 87);font-size: 11px;" powered-by="xiumi.us"><p>END</p></section></section><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: left;" powered-by="xiumi.us"><section style="padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;"><span style="display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);" title="" opera-tn-ra-cell="_$.pages:0.layers:0.comps:1.title1"><p>猜你喜欢</p></span></section><section style="border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;"><section style="font-size: 14px;text-align: left;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497810%26idx%3D1%26sn%3Dfb5334c9637cdde4b5125f69ed32e89f%26chksm%3Debdb88c0dcac01d6faf82e4d44e8421616ec9128f46ea494339a599c346b13212b9f1d774886%26scene%3D21%23wechat_redirect" textvalue="Hudi 在 vivo 湖仓一体的落地实践" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">Hudi 在 vivo 湖仓一体的落地实践</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497721%26idx%3D1%26sn%3D7fc575754a006dc68bb08cf730971cde%26chksm%3Debdb876bdcac0e7d1b579c0e69b8d36854bb08457c231640dab9418ee75dd35788e90e0688bf%26scene%3D21%23wechat_redirect" textvalue="RocksDB 在 vivo 消息推送系统中的实践" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">RocksDB 在 vivo 消息推送系统中的实践</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497638%26idx%3D1%26sn%3D7c773beb9f6062991ff11a068d55b132%26chksm%3Debdb8734dcac0e22e33f20a45472e8918c2b4bb7ccc47f138e3d1d37af76cd1fef986283edbd%26scene%3D21%23wechat_redirect" textvalue="线上 ES 集群参数配置引起的业务异常案例分析" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">线上 ES 集群参数配置引起的业务异常案例分析</a></p></li></ul></section></section></section></section><p powered-by="xiumi.us"><span style="font-size: 14px;text-align: left;background-color: rgb(239, 239, 239);letter-spacing: 0.578px;"></span></p><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互联网技术" data-alias="vivoVMIC" data-signature="分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。" data-from="0" data-is_biz_ban="0"></mp-common-profile><span style="background-color: rgb(239, 239, 239);font-size: 14px;letter-spacing: 0.578px;text-align: left;"></span><span style="background-color: rgb(239, 239, 239);font-size: 14px;letter-spacing: 0.578px;text-align: left;"></span></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 25 Dec 2023 02:07:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10322909</guid>
            <link>https://my.oschina.net/vivotech/blog/10322909</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Sam Altman 公布网友对 OpenAI 的新年愿望清单]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Sam Altman 今日在社交平台向网友<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fsama%2Fstatus%2F1738639394800906381" target="_blank">征集</a></u>大家希望 OpenAI 在 2024 年实现的事项。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-a33e81dfe8ecf936111917e0da6407d3e23.png" referrerpolicy="no-referrer"></p></blockquote><p>从回复来看，「AGI」是呼声最高的请求，但 Sam Altman <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fsama%2Fstatus%2F1738640093097963713" target="_blank">表示</a></u>，OpenAI 无法在 2024 年实现这一目标。</p><blockquote><p><img src="https://oscimg.oschina.net/oscnet/up-2b8df6a16780c81b36c005e358f02452201.png" referrerpolicy="no-referrer"></p></blockquote><p>下面是 Sam Altman <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fsama%2Fstatus%2F1738673279085457661" target="_blank">汇总</a></u>的网友愿望清单：</p><blockquote><p>AGI (a little patience please)<br> GPT-5<br> better voice mode<br> higher rate limits<br> better GPTs<br> better reasoning<br> control over degree of wokeness/behavior<br> video<br> personalization<br> better browsing<br> 'sign in with openai'<br> open source</p></blockquote><p>翻译如下：</p><blockquote><p>AGI（请耐心等待）<br> GPT-5<br> 更好的语音模式<br> 更高的速率限制<br> 更好的 GPTs<br> 更好的推理<br> 控制觉醒/行为的程度<br> 视频<br> 个性化<br> 更好的浏览<br> '使用 openai 登录'<br><strong>开源</strong></p></blockquote><p>不过网友似乎不太满意 Sam Altman 把「开源」放在最后，表示<strong>「开源可能是大多数人的首选愿望</strong>」。</p><p><img src="https://oscimg.oschina.net/oscnet/up-8fb26700d80d2984ab70cc7e89c07cdf8c2.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 24 Dec 2023 03:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/272394</guid>
            <link>https://www.oschina.net/news/272394</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
