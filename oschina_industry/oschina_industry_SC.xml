<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 09 Jan 2024 13:45:36 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[2023 年中国软件名城评估结果公布：深圳、杭州、北京获得最高三星评级]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>工信部近日印发《工业和信息化部关于 2023 年中国软件名城评估结果的通告》，<strong>确定了 2023 年中国软件名城评估结果</strong>。</p><p>1、<strong><span style="background-color:#e67e22">深圳</span></strong>：★★★</p><p>2、<strong><span style="background-color:#e67e22">杭州</span></strong>：★★★</p><p>3、<strong><span style="background-color:#e67e22">北京</span></strong>：★★★</p><p>4、南京：★★</p><p>5、上海：★★</p><p>6、成都：★★</p><p>7、济南：★★</p><p>8、武汉：★★</p><p>9、广州：★★</p><p>10、苏州：★★</p><p>11、青岛：★★</p><p>12、厦门：★★</p><p>13、福州：★★</p><p>14、无锡：★★</p><hr><p>工信部 2017 年印发了《中国软件名城创建管理办法（试行）》，目前已授牌&nbsp;14 个名城。</p><p>申请创建中国软件名城的城市需为<strong>地级及以上</strong>。同时需具备以下条件：</p><ul><li><p>一是软件和信息技术服务业基础良好、规模较大、发展潜力较强，对国民经济的贡献程度较高，拥有若干全国知名度较高的骨干软件企业和若干全国市场占有率较高的软件产品，创新能力较强，产业特色鲜明、生态较好；</p></li><li><p>二是软件和信息技术服务业带动效应明显，对拉动经济增长、促进就业、加速传统行业数字化转型，以及提升城市管理和社会服务水平具有重要支撑作用，对城市文化塑造及品牌提升具有积极影响；</p></li><li><p>三是产业政策支持力度较大，具有较为丰富的科技、教育、人才等资源条件和良好的城市人文环境，具有较为完善的适合软件和信息技术服务业集聚发展的物理载体环境，产业基地园区、公共服务平台等建设情况良好。</p></li><li><p>此外，申请城市及所属省级人民政府要对发展软件和信息技术服务业高度重视，并积极主动开展名城创建工作。</p></li></ul><p>2022 年 12 月，<strong><u><a href="https://www.oschina.net/news/221868">工信部发布了关于印发中国软件名城（园）管理办法的通知</a></u></strong>，进一步规范名城、名园管理工作，新的管理办法将对中国软件名城、名园动态管理实行<strong>退出机制</strong>。</p><p>通过每年组织开展评估工作，以星级体现（最高级为三星，星级越高发展质量越好）评估结果，充分调动地方发展软件和信息技术服务业的积极性。<strong>对评估结果为一星的名城、名园，工业和信息化部给予提醒，责令整改；对连续两年评估结果为一星的，公告退出</strong>。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 10:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274956</guid>
            <link>https://www.oschina.net/news/274956</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[工信部：到 2027 年，制定云计算国家标准和行业标准达 50 项以上]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>工信部<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fgzcy%2Fyjzj%2Fart%2F2024%2Fart_0dba24687491428a8939060c79ee358a.html" target="_blank">征集</a>对《云计算综合标准化体系建设指南》（征求意见稿）（以下简称《指南》）的意见。</p><p><img height="264" src="https://oscimg.oschina.net/oscnet/up-249312eb4a023d062a0a406036a6f3ae7a6.png" width="500" referrerpolicy="no-referrer"></p><p>《指南》明确，到 2025 年，云计算标准体系更加完善。推进修订参考架构、术语等基础标准，优先制定云计算创新技术产品、新型服务应用和重要缺失领域的关键标准。开展云原生、边缘云、混合云、分布式云等重点技术与产品标准研制，制定一批新型云服务标准，面向制造、软件和信息技术服务、信息通信、金融、政务等重点行业领域开展应用标准建设。</p><p>到 2027 年，制定云计算国家标准和行业标准达 50 项以上，基本覆盖基础、技术与产品、服务、应用、管理、安全等各类研制方向，有效满足我国产业标准化新阶段需求。结合云计算产业发展情况及各行业用户上云用云需求，推动云计算国行团标落地实施。提高国际标准参与度与转化率，协同推进互联互通与标准开放。</p><p>《指南》指出，立足我国云计算产业发展及生态系统建设新阶段，总结现阶段云计算标准体系建设成效，结合国内外云计算技术演进趋势和关键挑战，研究分析各领域方向的标准制定和缺失情况，在《云计算综合标准化体系建设指南》（工信厅信软〔2015〕132 号）基础上，修订更新云计算综合标准化体系，以指导具体标准的立项与制定。修订后的云计算综合标准化体系结构见图 1，包括「01 基础标准」、「02 技术与产品标准」、「03 服务标准」、「04 应用标准」、「05 管理标准」和「06 安全标准」六个部分。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 10:10:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274952</guid>
            <link>https://www.oschina.net/news/274952</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[云原生周刊：K8sGPT 加入 CNCF]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>开源项目推荐</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbackube%2Fvolsync" target="_blank">VolSync</a></h3><p>VolSync 使用 rsync 或 rclone 在集群之间异步复制 Kubernetes 持久卷。它还支持通过 Restic 创建持久卷的备份。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopenclarity%2Fkubeclarity" target="_blank">KubeClarity</a></h3><p>KubeClarity 是一种用于检测和管理软件物料清单 (SBOM) 以及容器映像和文件系统漏洞的工具。它扫描运行时 K8s 集群和 CI/CD 管道，以增强软件供应链的安全性。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmariadb-operator%2Fmariadb-operator" target="_blank">mariadb-operator</a></h3><p>以云原生方式运行和操作 MariaDB。使用 Kubernetes CRD 而不是命令式命令以声明方式管理 MariaDB 。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpadok-team%2Fburrito" target="_blank">Burrito</a></h3><p>Burrito 是 TACoS（Terraform 自动化协作软件）Kubernetes 运营商。它解决了管理基础架构状态漂移、为 Terraform 编写 CI/CD 流水线以及提供 Terraform 状态修改可见性的挑战。</p><h2>文章推荐</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmedium.com%2F%40kylelzk%2Fkubernetes-theory-understanding-kubernetes-components-a-deep-dive-ac31b7463df2" target="_blank">理解 Kubernetes 组件：深入探讨</a></h3><p>这篇文章深入介绍了 Kubernetes 组件，帮助读者全面了解这个强大的容器编排平台。文章首先介绍了 Kubernetes 的架构，包括主要组件和它们的功能，如 kube-apiserver、etcd、kube-scheduler、kube-controller-manager 和 cloud-controller-manager。接下来，文章讨论了运行在每个节点上的节点组件，如 kubelet、kube-proxy 和容器运行时。然后，文章介绍了一些附加组件，如 DNS、Web UI（Dashboard）、容器资源监控和集群级别的日志记录。最后，文章讨论了网络组件和存储组件，包括 CNI、Ingress、Service、Persistent Volumes 和 Storage Classes。通过深入了解这些组件的作用和功能，开发人员和管理员可以充分利用 Kubernetes 的功能，有效地管理和扩展他们的应用程序。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcollabnix.com%2Fwhats-new-in-kubernetes-1-29-mandala-the-universe%2F" target="_blank">Kubernetes 1.29 新增功能：PersistentVolume 访问模式、节点卷扩展、KMS 加密、调度程序优化等</a></h3><p>这篇文章介绍了 Kubernetes 1.29 版本的新功能和改进。其中包括持久卷访问模式、节点卷扩展、KMS 加密、调度器优化等方面的内容。文章强调了 Kubernetes 社区的协作精神，并概述了各个稳定、测试和实验性功能的特点和用途。这些新功能提供了更好的持久性、存储灵活性和加密能力，同时通过优化调度效率和改进节点生命周期管理，提升了集群的性能和可靠性。全文通过 Mandala 主题来展示 Kubernetes 的发展和创新，鼓励读者参考官方发布说明，全面了解 Kubernetes 1.29 版本的变化，并共同探索容器编排的未来。</p><h2>云原生动态</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fk8sgpt.ai%2Fblog%2Fpost-7%2F" target="_blank">K8sGPT 加入 CNCF</a></h3><p>K8sGPT 是一个用于扫描您的 Kubernetes 集群、以简单的英语诊断和处理问题的工具。它将 SRE 经验编码到其分析器中，并帮助提取最相关的信息，并结合人工智能来丰富分析结果。</p><p>K8sGPT 项目获选加入 CNCF，成为第一个被接受的 AI + Kubernetes 工具。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpicluster.ricsanfre.com%2Fblog%2F2024%2F01%2F04%2Fannouncing-release-1.8%2F" target="_blank">Kubernetes Pi Cluster 发布 v1.8</a></h3><p>Kubernetes Pi Cluster 项目的第八个版本（v1.8）发布了。该版本的主要特性和改进包括：</p><ul><li>K3S 高可用配置：使用 3 个主节点实现高可用性部署，并采用嵌入式 etcd 数据存储。为了提供 Kubernetes API 的高可用性，使用网络负载均衡器 HAProxy。</li><li>迁移 Ingress Controller：从 Traefik 迁移到 NGINX。这个迁移的主要原因是使用标准的 Ingress 资源，简化 Linkerd 集成配置。</li><li>单点登录（Single Sign-on）：基于 OAuth2.0/OpenID Connect 标准，部署了一个基于 Keycloak 的单点登录解决方案。Keycloak 是一个开源的身份访问管理解决方案，支持集中身份验证和授权服务。</li><li>新增 Kafka 服务：添加 Kafka 作为事件流平台，实现面向数据驱动的微服务架构。部署 Kafka Schema Registry，用于集中管理 Kafka 生产者和消费者的模式。</li></ul><blockquote><p>本文由博客一文多发平台 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenwrite.cn%3Ffrom%3Darticle_bottom" target="_blank">OpenWrite</a> 发布！</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 09:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4197945/blog/10726775</guid>
            <link>https://my.oschina.net/u/4197945/blog/10726775</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[openKylin 2.0 揭秘 | 新一代不可变系统探索]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">openKylin 不可变系统，由社区 UpdateManager &nbsp;SIG 基于 OStree 技术研发，目标是为用户提供更加稳定、安全和高效的不可变系统架构，提高系统的安全性和稳定性，简化系统管理。目前，大家可通过安装 openKylin 2.0 Alpha 版本时勾选「不可变系统安装」进行体验，完整功能请期待 openKylin 2.0 正式版本上线！</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:center"><img alt="" height="410" src="https://oscimg.oschina.net/oscnet/up-715de6551bd2081ffda9898ef990c804ae4.png" width="940" referrerpolicy="no-referrer"></p><p style="text-align:center"><strong>什么是不可变系统</strong></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">不可变系统，是一种不可更改且只读的操作系统，即用户或应用程序不能直接修改正在运行的系统的核心文件和目录，用户通过原子更新实现系统的更新升级，<strong>在更新失败时能够迅速回滚，确保系统不会陷入异常状态</strong>。应用程序通过容器技术与核心操作系统相互隔离，确保一个应用程序所做的更改不会影响核心系统。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><strong><span style="color:#000000">openKylin 不可变系统，采用 OStree 技术实现对新一代不可变系统的探索</span></strong><span style="color:#000000">。OStree 是一种用于操作系统的版本控制系统，它类似于 Git，用于整个操作系统文件系统树的版本控制。OStree 允许用户对整个操作系统进行版本控制，包括内核、库、二进制文件和配置文件等，这使得系统升级、回滚变得更加容易。OStree 技术的另一个重要特点是不可变性。它将整个操作系统视为一个不可变的文件系统树，每个版本都被视为一个不可变文件系统树分支版本。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="text-align:center"><strong>openKylin 不可变系统技术优势</strong></p><p><span><strong>强大的稳定性</strong></span></p><p style="margin-left:0px; margin-right:0px">借助 OStree 技术，openKylin 不可变系统可实现系统架构的不可变性，确保每次系统更新都是无风险、原子级的操作，大大降低系统运行中出现问题的可能性，为用户提供更加强大的稳定性保障。</p><p><span><strong>安全可靠</strong></span></p><p style="margin-left:0px; margin-right:0px">通过 openKylin 不可变系统架构，可有效应对恶意软件和系统漏洞的威胁，为用户数据和隐私安全提供坚实的保障，极大地提升系统的安全性。</p><p><span><strong>应用隔离</strong></span></p><p>通过容器化技术实现应用程序与核心操作系统隔离，确保应用程序所做的更改不会影响核心系统或其他应用程序。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">综上所述，openKylin 基于 OStree 的不可变系统实现，确保系统核心不可变，将为用户带来更加稳定、安全的体验。在后续揭秘中，我们也将对 openKylin 不可变系统方案特性进行详细解读，敬请期待！</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p><strong>关于 UpdateManager&nbsp;SIG</strong></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">openKylin 社区 UpdateManager SIG 组致力于开发和维护 openKylin 系统升级机制，并探索和研发新一代不可变系统相关技术，包括系统架构、OStree、系统更新组件等，提供不可变系统相关的技术规划、设计、开发、维护和系统升级方案。欢迎社区中对系统更新升级、不可变系统等技术领域感兴趣的开发者加入我们！</span></p><ul><li><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">SIG 主页：</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#0b43d1">https://gitee.com/openkylin/community/tree/master/sig/UpdateManager</span></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 09:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274942</guid>
            <link>https://www.oschina.net/news/274942</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GTK 将采用「统一渲染器」取代 OpenGL 和 Vulkan]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>GTK 近日合并了名为「Add new unified renderer」的 PR。</p><blockquote><p style="margin-left:0; margin-right:0">GTK (GIMP Toolkit) 是一套跨多种平台的图形工具包，最初为 GIMP 而写，GIMP 是指 GNU 图像处理程序 (GNU Image Manipulation Program)，GIMP 拥有几乎所有图象处理所需的功能，号称 Linux 下的 Photoshop。GTK 后来发展成为 Linux 下开发图形界面应用的主流开发工具。</p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-730b58563ec58c49ba1dd57df43a1e3cb9e.png" referrerpolicy="no-referrer"></p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.gnome.org%2FGNOME%2Fgtk%2F-%2Fmerge_requests%2F6588" target="_blank">根据描述</a></u>，该 PR 添加了新的<strong><span style="background-color:#e67e22">统一渲染器 (unified renderer)</span></strong>，又称「GPU 渲染器」。它取代了旧的 Vulkan 渲染器，并将最终取代 OpenGL。此举意味着 GTK 的现代 GPU 加速渲染向前迈出了一大步。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FGTK-Unified-Renderer-Progress" target="_blank">据介绍</a>，GTK 统一渲染器的主要补丁集有 24.8k 行新代码，同时删除了 9.6k 行现有代码。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 07:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274918/gtk-unified-renderer-progress</guid>
            <link>https://www.oschina.net/news/274918/gtk-unified-renderer-progress</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 称《纽约时报》的版权诉讼毫无根据]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">《纽约时报》曾于去年 12 月起诉 OpenAI 和微软公司，称这两家公司非法使用其受版权保护的材料来训练 AI 模型。时至今日，OpenAI 公开回击并发表了一篇<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Fblog%2Fopenai-and-journalism" target="_blank">博文称</a>：「我们支持新闻业，与新闻机构合作，并认为《纽约时报》的诉讼毫无根据。」</span></p><p><span style="color:#000000">该公司在博文中重申了以下四点立场：</span></p><ul><li><span style="color:#000000">我们与新闻机构合作并创造新的机会</span></li><li><span style="color:#000000">培训属于合理使用，但我们提供选择退出的机会，因为这是正确的做法</span></li><li><span style="color:#000000">「反刍（Regurgitation）」是一种罕见的错误，我们正在努力将其降至为零</span></li><li><span style="color:#000000">《纽约时报》没有讲述完整的事实</span></li></ul><p><img height="312" src="https://oscimg.oschina.net/oscnet/up-2b1881fb593ade980a7bc0e1308304de93c.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000">OpenAI 方面表示，其目标是支持健康的新闻生态系统、成为良好的合作伙伴、创造互利的机会；考虑到这一点，该公司一直在寻求与新闻机构建立合作伙伴关系。通过与美联社、Axel Springer、American Journalism Project 和纽约大学的早期合作，他们已经对相关方法有了初步了解。</span></p><p><span style="color:#000000">该公司认为，一些已经普遍被接受的先例表明，使用公开可用的互联网资料训练 AI 模型是属于合理使用范畴。「我们认为这一原则对创造者是公平的，对创新者是必要的，对美国的竞争力也是至关重要的。」</span></p><p><span style="color:#000000">而关于「反刍」问题，OpenAI 则解释道，他们已经采取了措施来限制非故意记忆，并防止大模型输出中的反刍现象。并指出，如果训练数据来自单一来源（如《纽约时报》），则反刍的可能性较小；同时也敦促用户"act responsibly"，避免故意促使其模型反刍。「故意操纵我们的模型进行反刍不是对我们技术的适当使用，也违反了我们的使用条款」。「反刍」是指特定内容在大模型的训练数据中多次出现的一种现象。</span></p><p><span style="color:#000000">OpenAI 透露与《纽约时报》的最后一次沟通是在 2023 年 12 月 19 日，「我们与《纽约时报》的讨论似乎取得了建设性进展......我们向《纽约时报》解释说，与任何单一来源一样，他们的内容对我们现有模型的训练没有任何有意义的贡献，也不会对未来的训练产生足够的影响。但他们于 12 月 27 日提起了诉讼 —— 我们是也通过《纽约时报》才了解到的 —— 这令我们感到惊讶和失望。」</span></p><p><span style="color:#000000">值得一提的是，OpenAI 称《纽约时报》在双方的沟通过程中已经发现了一些内容的反刍，但却在 OpenAI 承诺调查和解决任何问题的前提下，一再拒绝分享任何示例。</span></p><blockquote><p><span style="color:#000000">有趣的是，《纽约时报》<span style="background-color:#f8f9f9">提到的反刍</span>似乎来自于多个第三方网站上大量传播的多年前的文章。为了让我们的模型进行反刍，他们似乎有意篡改了提示语，通常包括冗长的文章节选。即使在使用此类提示时，我们的模型通常也不会像《纽约时报》影射的那样，这表明他们要么是指示模型进行反刍，要么是从众多尝试中精心挑选了一些示例。</span></p><p><span style="color:#000000">尽管他们声称，这种误用并非典型或允许的用户行为，也不能替代《纽约时报》。但无论如何，我们都在不断提高系统的抗逆向攻击能力，以避免训练数据被反刍，并在最近的模型中取得了很大进展。</span></p></blockquote><p><span style="color:#000000">在声明的最后，OpenAI 表示，尽管他们<span style="background-color:#ffffff">认为《纽约时报》的诉讼毫无根据；但仍然对《纽约时报》保持尊重并希望与其建立建设性的合作伙伴关系。「我们期待与新闻机构继续合作，通过实现 AI 的变革潜力，帮助他们提高生产高质量新闻的能力。」</span></span></p><p><span style="color:#000000">OpenAI 做出回应之际，围绕生成式 AI 的版权争论正值白热化。一些数据表明，公众更倾向于站在媒体出版商这一方。The AI Policy Institute 最近的一项民意调查结果显示，当得知《纽约时报》起诉 OpenAI 的详情后，59% 的受访者同意 AI 公司不应该被允许使用出版商的内容来训练模型；70% 的受访则表示，如果这些公司想在模型训练中使用受版权保护的材料，就应该向出版商提供补偿。</span></p><p><strong><span style="color:#000000">延伸阅读：</span></strong></p><ul><li><a href="https://www.oschina.net/news/274326/openai-offers-publishers-little-1m" target="news">OpenAI 拟每年投入 100-500 万美元，以获取新闻使用许可</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 07:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274916/openai-and-journalism</guid>
            <link>https://www.oschina.net/news/274916/openai-and-journalism</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[开源神器 LSPosed 宣布停更，作者称遭受大量恶意攻击]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Android 平台 Xposed Framework 的替代实现版本 LSPosed 宣布停止维护，目前 LSPosed 的 GitHub 仓库已经设置为只读状态。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">LSPosed 是一个 Magisk<span>&nbsp;</span><span><span><span>模块，尝试提供一个 ART hooking 框架，该框架提供与 OG Xposed 一致的 API，其利用 LSPlant hooking 框架。</span></span></span></p><p><img src="https://oscimg.oschina.net/oscnet/up-75beeed327a7d34771f31dd9958c3920723.png" referrerpolicy="no-referrer"></p><p><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FLSPosed%2FLSPosed" target="_blank">https://github.com/LSPosed/LSPosed</a></em></u></p><p>对于停止开发的原因，开发者在其订阅频道中表示停止维护的主要原因是出现许多谣言、诽谤、种族主义和咒骂等。同时开发者也受到 Magisk 社区的一些咒骂，因此开发者决定休息，停止开发和维护。</p><p><img src="https://oscimg.oschina.net/oscnet/up-c9dc6d212bdbe837a4322248a364756b5ff.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 03:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274877</guid>
            <link>https://www.oschina.net/news/274877</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[渠成开源社区 2023 年工作总结]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>「道虽迩，不行不至；事虽小，不为不成。」2023 年，对渠成开源社区来说，是不平凡的一年，更是值得回味的一年。</span></p><p><span>这一年，我们从零搭建了渠成开源社区，确定了工作组成员；</span></p><p><span>这一年，我们链接了开源作者/开源社区，为他们提供了服务；</span></p><p><span>这一年，我们举办了多场活动，为更多用户创建了彼此交流的机会；</span></p><p><span>……</span></p><p><span>回望 2023 年，渠成开源社区所经历的惊喜与感动，都离不开社区中每位伙伴的陪伴和努力。我们不断迭代、不断创新，我们共同走过的每一个瞬间都值得纪念与庆贺。</span></p><p style="text-align:center"><span><strong>一、从 0 到 1 搭建社区</strong></span></p><p><strong><em>1&nbsp;</em>成立社区工作组</strong></p><p><span>2023 年 4 月，我们确定了<strong>渠成开源社区的工作组团队</strong>，包括顾问专家、市场运营、产品规划、网站开发、设计以及财务几大角色。期间完善了社区相关运营机制，包括不限于确定社区 23 年的目标、完善社区的媒体账号、确定社区对外信息公开机制等。</span></p><p><span>社区的对外信息公开机制，真正让社区内每一次的会议、每一笔的支出都做到有迹可寻。在官网的「<strong>财务公开</strong>」版块，现已公开了 2021 年 11 月-2023 年 11 月渠成开源社区的现金流水账。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>2023 年，工作组共开展了<strong>13 场</strong>的会议，工作组成员在会上提出各项社区成员关注的问题，共同探讨以提供相应的解决方案。往期会议详情可在渠成开源社区官网查看：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qucheng.cc%2Fmeetings.html" target="_blank" rel="nofollow"><span>https://www.qucheng.cc/meetings.html</span></a></p><p><strong><em>2&nbsp;</em></strong><span><strong>搭建官方媒体矩阵</strong></span></p><p><span>2023 年 4 月，我们上线了<strong>渠成开源社区官网</strong>（</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qucheng.cc%2F" target="_blank" rel="nofollow"><span>https://www.qucheng.cc/</span></a><span>）</span><span>，详细介绍了社区的定位、章程、会员入驻机制和会员权益等。同时，为了方便大家从多渠道、多途径了解开源项目，我们还开通渠成开源社区的微信公众号、视频号、Bilibili、开源中国、知乎号、GitHub 等社媒账号。</span></p><ul><li><p><span>微信公众号：</span><strong>渠成开源社区</strong></p></li><li><p><span>视频号、Bilibili、开源中国、知乎号：渠成开源社区</span></p></li><li><p><span>GitHub：</span><span>@QuCheng-OpenSource</span></p></li></ul><p style="margin-left:0px; margin-right:0px; text-align:center"><span><span><strong>二</strong><strong>、</strong></span><strong>链接开源生态中的各种角色</strong></span></p><p><strong><em>1&nbsp;</em></strong><span><strong>链接开源作者/开源社区</strong></span></p><ul><li><p><strong><span>持续邀请开源项目入驻社区</span></strong></p></li></ul><p><span>我们欢迎更多的开源项目可以入驻渠成开源社区，社区会为会员项目<strong>提供项目运营、周边设计、赞助招募、法律咨询以及商业化咨询等多项服务。</strong></span></p><p><span>截至目前，已有<strong>39 个项目</strong>入驻渠成开源社区，成为了渠成开源社区的会员项目。会员项目可享受入驻渠成 Demo 中心的权益，让所有人都能在线体验会员项目的 Demo，轻松实现高可用。同时，渠成开源社区所接受的捐赠与赞助会根据捐赠方或赞助方的意愿使用该资金，用于鼓励、支持社区会员的开源项目。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:center"><img alt="" height="383" src="https://oscimg.oschina.net/oscnet/up-0a2fc114545f42267ae6fc4321861ef99e5.jpg" width="600" referrerpolicy="no-referrer"></p><ul><li><p><strong><span>持续设计开源周边产品</span></strong></p></li></ul><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>为帮助各个开源项目提高知名度，同时让更多开源软件的粉丝获取相关周边产品，我们与国内外数十个开源项目联络，获取各大开源项目的授权，使用其 Logo 设计出精美的周边 T 恤。我们已将 T 恤设计稿开源至 GitHub，供大家下载与使用：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FQuCheng-OpenSource%2FT-shirt" target="_blank" rel="nofollow"><span>GitHub - QuCheng-OpenSource/T-shirt</span></a></p><ul><li><p><strong><span>打造社区礼品体系</span></strong></p></li></ul><p><span>渠成开源社区官网的「<strong>开源周边</strong>」板块已上架了我们为各开源项目设计的周边 T 恤，用户可以直接在线下单购买。周边产品的所有销售利润，均会公开透明地用于到社区发展中。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="237" src="https://oscimg.oschina.net/oscnet/up-f3b16af9cf4e22ea243581eeac04c5bd5f0.jpg" width="600" referrerpolicy="no-referrer"></p><ul><li><p><strong><span>持续上线官网新版块</span></strong></p></li></ul><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>2023 年，根据用户反馈和日常讨论，<strong>我们在官网上线了开源动态和社区活动两个板块。</strong>用户可以在官网的「开源动态」板块进行在线投稿。同时，社区公众号邀请了众多优秀开源作者开放白名单，以帮助转发推广文章与活动。</span></p><p><strong><em>2&nbsp;</em></strong><span><strong>传递社区价值主张</strong></span></p><ul><li><p><span><strong>发起「源来是你」系列栏目</strong></span></p></li></ul><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>本着为更多开源相关的用户提供更好的服务原则，切实帮助每一个开源软件实现商业化。我们搜集了大家关心的各类问题。分别在北京、上海两地分别<strong>举办了</strong><strong>2 场专场沙龙活动，开展了 4 期线上直播，涵盖了商业沟通、产品定价、法律风险规避等多个主题。线上线下共参与人数达 1218 人。</strong></span></p><ul><li><p><strong><span>出品《开源商业化白皮书》</span></strong></p></li></ul><p><span>开源软件发挥着越来越重要的作用，但国内没有建立起一个开源软件商业化的生态体系。为此，渠成开源社区组织撰写了白皮书，<strong>探讨了国内开源现状、常见的开源商业模式、如何做开源商业化等多个方面</strong>，希望为开源软件作者、贡献者以及创业者提供了实际的商业化落地建议。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:center"><img alt="" height="385" src="https://oscimg.oschina.net/oscnet/up-376a4a0355e49acb1a584a0eac177637db7.jpg" width="600" referrerpolicy="no-referrer"></p><ul><li><p><strong><span>多次参与国内各项大会活动</span></strong></p></li></ul><p style="text-align:center"><img alt="" height="450" src="https://oscimg.oschina.net/oscnet/up-d2ba2578656efd103183dbb7237b299f6a6.jpg" width="600" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>渠成开源社区积极投入到国内的开源布道，陆续参加了 2023 上海人工智能大会开源集市、开源社 2023 开源年会、DevOps 社区广州峰会等活动，以传递社区的价值主张。<strong>为了能够与众多开源社区保持友好联系，我们创建了社区合作伙伴群，持续分享有价值的开源信息，积极促成合作，共同推动开源事业的发展。</strong></span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><span><strong>三</strong></span><span><strong>、</strong></span><strong>欢迎入驻社区</strong></p><p><span>如果您正在经营一个开源项目，如果您有开源商业化的诉求，<strong>欢迎携项目入驻渠成开源社区</strong></span><span>：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qucheng.cc%2Fproject.html" target="_blank" rel="nofollow"><strong><span>开源项目—项目入驻</span></strong></a><span>。审核通过后，我们将拉您进入项目作者群。在这里，您可以与各位开源创业者共同交流、共同成长。</span></p><p style="text-align:center"><strong>欢迎扫码查看官网</strong></p><p style="text-align:center"><img alt="" height="300" src="https://oscimg.oschina.net/oscnet/up-ce97b5277dc03f6cb550c89d44660add1b3.png" width="300" referrerpolicy="no-referrer"></p><p><span>很多时候，我们会被星辰大海的征途所鼓动，进而热血沸腾。可实际上，所有的大事都要从小事做起，从细节着手。渠成开源社区，一直秉承的就是这样的态度，踏踏实实为中国开源软件事业做贡献。正因如此，渠成开源社区在 2023 年的努力得到了国内知名开源技术社区开源中国（OSCHINA）的肯定，荣获 OSCHINA 2023 年度 「<strong>优秀开源技术团队</strong>」荣誉称号。</span></p><p><span>征途漫漫从头越，奋楫扬帆向未来。2024 年，渠成开源社区将服务更多的开发者，帮助大家解决实实在在的问题。<strong>我们期待有更多的开源项目加入社区，也期待与各开源开发者一起携手打造适合中国国情的开源软件生态。</strong>&nbsp;</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 03:53:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6928219/blog/10712985</guid>
            <link>https://my.oschina.net/u/6928219/blog/10712985</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Unity 将裁员 25%，涉及 1800 人]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#222222">电子游戏引擎厂商 Unity 计划裁员 25%，削减近 1800 个工作岗位。该公司在向</span>美国证券交易委员会<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fd18rn0p25nwr6d.cloudfront.net%2FCIK-0001810806%2Ffa621098-7a4d-4e51-8f59-725dc0210b98.pdf" target="_blank">提交的文件</a>中表示，进行裁员是「为了重组和重新聚焦于核心业务，并<span style="background-color:#ffffff; color:#222222">提高长期盈利能力</span>」。</p><p><img height="260" src="https://oscimg.oschina.net/oscnet/up-aa72d8f006422f94c3ee97fa70136996b11.png" width="700" referrerpolicy="no-referrer"></p><p>Unity 的公关总监 Kelly Ekins 在给 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2024%2F1%2F8%2F24030695%2Funity-layoff-staff-25-percent" target="_blank">The Verge</a> 的一份声明中表示：</p><p>"今天，作为我们在 2023 年 11 月 9 日《股东信》中概述的公司重组的一部分，我们宣布 Unity 做出了一个艰难的决定，即实施裁员，目标是裁减我们所有团队总人数的约 25%。这个决定并不容易，我们向那些受到影响的员工表示最深切的感谢，感谢他们的奉献和贡献。"</p><p>事实上，<span style="background-color:#ffffff; color:#222222">Unity </span>在过去一年已经经历了多次裁员。<span style="color:#000000">最近一次裁员是在去年 11 月，</span><span style="background-color:#ffffff; color:#222222">Unity 终止与《指环王》导演 </span><span style="background-color:#ffffff; color:#333333">Peter Jackson</span>&nbsp;<span style="background-color:#ffffff; color:#222222">创办的视觉特效公司 Weta FX 所达成协议中的专业服务部分。与该协议有关的 <a href="https://www.oschina.net/news/268858/unity-software-cut-38-staff">265 名员工被解雇</a>，占公司当时全球员工总数的 3.8%。</span></p><p><span style="background-color:#ffffff; color:#222222">在此之前，</span><span style="background-color:#ffffff; color:#333333">Unity 刚宣布了新的定价模式。在引起业内人士的强烈不满之后，Unity 向公众和业内人士道歉，并调整了收费规则，</span><span style="background-color:#ffffff; color:#222222">但其前首席执行官 John Riccitiello 也因此辞职。</span></p><p><span style="background-color:#ffffff; color:#222222">此外，Unity 还宣布将关闭德国柏林和新加坡等 14 个地区的办公室，并大幅缩减包括旧金山和华盛顿贝尔维尤在内的其余办公室面积。</span></p><p><strong><span style="background-color:#ffffff; color:#222222">相关阅读：</span></strong></p><ul><li><u><em><a href="https://www.oschina.net/news/257929/unity-runtime-fee">Unity 引擎明年起根据游戏安装量收费 (runtime fee)</a></em></u></li><li><u><em><a href="https://www.oschina.net/news/258513/unity-apologize-for-runtime-fee">Unity 道歉：将修改 "runtime fee" 收费政策</a></em></u></li><li><u><em><a href="https://www.oschina.net/news/258477/wait-is-unity-allowed-to-just-change-its-fee-structure-like-that">走近 「收费门」：互相矛盾的服务条款导致 Unity 面临被起诉的风险</a></em></u></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 03:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274868/unity-layoff-staff-25-percent</guid>
            <link>https://www.oschina.net/news/274868/unity-layoff-staff-25-percent</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[女高管开除员工事件后续：公司董事长称员工「惯犯」并质疑「学历简历造假」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p><em><strong>前情提要：<u><a href="https://www.oschina.net/news/274850" target="news">被女高管违法开除员工发声，因反对用盗版 EDA 工具设计芯片遭针对</a></u></strong></em></p></blockquote><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffinance.sina.com.cn%2Ftech%2Fshenji%2F2024-01-09%2Fdoc-inaawvsf7734023.shtml" target="_blank">根据新浪科技的独家报道</a></u>，针对「女高管违法开除员工」一事，涉事公司董事长陈怡然今日在与新浪科技沟通中回应了此事，并进一步透露称，<strong>被开除员工可能涉嫌「学历造假、简历造假」，此前一路讹了多家公司，「惯犯了」</strong>。</p><p>近日，一段「公司女高管违法开除员工」的视频在社交网络上流传。网传视频内容显示，一名公司女高管井某与视频拍摄者孙某因解除劳动合同产生了矛盾。视频中，拍摄者孙某指出公司存在违法解除劳动合同的行为，井某则回应称，「我就违法了，怎么着？我就是违法解除，你去告我吧！我让你两年半找不到工作，我下个月有饭吃，你自己想想吧。」</p><p>据悉，女高管在北京尼欧克斯科技有限公司工作，该公司又名苹芯科技。此前有消息称，井某系该公司董事长的大学同学。</p><p>董事长陈怡然向新浪科技澄清，称「双方并非大学同班同学」，此外，事发时他并不知情，「也压根不知道这个人的招聘和离职，直到有人将视频转发给我」。同时，他还透露称员工孙某或系「惯犯」，此前可能「学历造假、简历造假」，曾「一路讹了多家公司，又找到了新苦主了」。</p><p>「我只能说这事上政府查过了，公司程序并无瑕疵。」陈怡然表示。</p><p>此前，北京尼欧克斯科技有限公司也发布声明称：网传我司人力员工井某与前员工孙某因解除劳动关系出现争执，井某发表不当言论，已责令其停职反省并严肃处理。前员工孙某于 2023 年 6 月 25 日入职，签订 3 年劳动合同及保密与竞业限制协议，试用期 6 个月。因工作能力不胜任，决定不予通过试用期。经协商一致，12 月 1 日双方签署解除劳动关系协议，我司按照协议于 12 月 8 日足额支付了 11 月份工资及离职补偿金。以上程序均依法合规处理。</p><p>目前，双方已就离职补偿达成协议。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 03:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274858</guid>
            <link>https://www.oschina.net/news/274858</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[被女高管违法开除员工发声，因反对用盗版 EDA 工具设计芯片遭针对]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p><em>后续：<strong><u><a href="https://www.oschina.net/news/274858" target="news">女高管开除员工事件后续：公司董事长称员工「惯犯」并质疑「学历简历造假」</a></u></strong></em></p></blockquote><p>近日「女高管违法开除员工」事件在网上引起争议。网传视频显示，一位女子与视频拍摄者疑似就解除劳动合同产生了矛盾。</p><p>视频中，拍摄者指出公司存在违法解除劳动合同的行为，该女子回应称，「我就违法了，怎么着？我就是违法解除，你去告我吧！我让你两年半找不到工作，我下个月有饭吃，你自己想想吧。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-599c10f7c4239b1ea57ee669a901a765353.png" referrerpolicy="no-referrer"></p><p>现在，疑似被开除员工在网上发声，他自称是被女高管开除的男员工，称北京尼欧克斯又名苹芯科技，所谓女高管停职不可能的，女高管井玥是清华 94 级无线电毕业，跟公司大老板杜克教授陈怡然是清华同班同学，关系铁的很，敷衍一下过阵子又回去了。</p><p>他谈到，自己被开除的原因是他反对苹芯（尼欧克斯）使用盗版 EDA 工具设计芯片，因为盗版设计出的芯片可能有 Bug，质量无法保证。苹芯把 IC 核心研发业务外包，开除原因是他反对什么都外包，打铁还需自身硬；PimChip 芯片覆盖率只有 20% 多就拿去投片，「清华帮」趁着国产替代跑去投机蹭芯片风口。</p><p>疑似被开除男员工还表示，他去年 8 月份急着从上一个项目脱身，迅速将 resource 投入下一个项目，当时井玥拍桌子怒吼：「你从小就没有教养」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8020424bc0a40d59a9981ebbcd6e721db4b.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274850</guid>
            <link>https://www.oschina.net/news/274850</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[超 200K Star 的 Dromara 开源社区的年终总结，请查收!]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>过去一年大家见证了 Dromara 开源社区的飞速发展，社区的进步离不开社区成员们的，社区下开源项目贡献者们的辛勤劳动贡献和触达用户们，开源爱好者们的大力支持，对此我们感激不尽。</p></blockquote><p>接下来我们看看社区这 2023 一年的成长吧！</p><h2>新增捐赠孵化 20+ 非常棒的开源项目，目前社区下的总项目数量超 50 个。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-cd45685d0d58c390c2a602b6fa8b4f993d2.png" referrerpolicy="no-referrer"></p><h2>社区下孵化项目 HertzBeat, Dynamic-Tp, Easy-Es 发展迅速，成功毕业成为社区顶级开源项目。云原生大数据平台 CloudEon 成为被评为 Gitee GVP (Gitee 最具价值开源), 目前 Dromara 社区下的 GVP 项目数量已达到 16 个。社区下开源实时监控 HertzBeat 被 CNCF 全景图收录。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-57dd1fe6b9e62ba97232f902938e10c0d5e.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-c665b706e30849fdccba304c6f3226bd098.png" referrerpolicy="no-referrer"></p><h2>在 Gitee 和 Github 平台上，Dromara 社区项目总共获得超 200K star 小星星🌟，和，数不清的 Fork Watch 次数 (偷懒了😂)。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0e7dd59596493651ef93f0b787bf91d26a7.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e1a07f1f7757b3920a6bce244c954b50320.png" referrerpolicy="no-referrer"></p><p><strong>2023 年这一年社区下开源项目在 Github 平台上新增 2 万，颗小星星，PR 数量 1000+，Issues 数量 1400+</strong></p><h2>社区下开源项目作为课题项目成功参与中科院的 OSPP 开源之夏和计算机学会的 GLCC 编程夏令营活动，申请的同学们热情很高，最终中选的同学在导师的指导下顺利完成课题项目并结项。祝贺他们㊗️。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-039817cad68c8914e145aa186c735bc42b9.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-c83015dfabd64150f30a6c081082afbeb82.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-5252b18b809174ab7ab7264ebb9d1d3c011.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a2d294f2653e0b5fba7efb586b816d5013c.png" referrerpolicy="no-referrer"></p><h2>5 月 Dromara 参展全球开源技术峰会 GOTC，社区小伙伴的在上海线下面基成功，+薅了很多羊毛。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-00d418cbf39fcd588c3fd257bfd7d9a884e.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-72c42499ed92108ce0cbfa33de5f427e87b.png" referrerpolicy="no-referrer"></p><h2>7 月 Dromara 参加华为云开发者大会，社区小伙伴们又东莞线下面基一波，三位小伙伴做了 Dromara 与华为云开源主题分享，收获满满。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0eee75600e49e8fcf942ecb738bdd651c00.png" referrerpolicy="no-referrer"></p><h2>10 月 Dromara 参加了 COSCon'23 中国开源年会，社区小伙伴们又成都线下面基一波，我们准备的小礼品很受欢迎，社区小伙伴做了关于社区项目的主题分享。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0f6ec31ce57910497c6c6ac659c922b419f.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e563f49ea48de821e2f0207c7af025a2545.png" referrerpolicy="no-referrer"></p><h2>12 月 Dromara 参加了 2023 开放原子开发者大会，虽然没有面基成功 (下次一定)，但是社区大佬明哥在会上给开源同行们分享介绍了我们社区，收获满满+1。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9dccc42b3cbf031c94c3e5dda2b80e99d3d.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-cb265cd99f93341e99b2f6bde68a2bb05e9.png" referrerpolicy="no-referrer"></p><h2>关于荣誉</h2><blockquote><p>荣获中国开源创新大赛优秀奖, 2023 年度最受关注喜爱的开源组织和最活跃组织之一, 掘金 2023 年度人气团队等。</p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-15a7659a08f3aeb5aa3ccebd13fcaa3c608.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-126e2fd2fbfcda5620d434d66220f85ad07.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ec2a4083fc9ffe0899aa0a5e46fa9fd65a6.png" referrerpolicy="no-referrer"></p><h4>还有更多事件在 2023 年的 Dromara 发生。。。就先列举到这里了</h4><blockquote><p>社区下项目团队在 2023 年也发布了无数个版本，维护者上万人的开源社群，回答并帮助解决了数不清的用户问题，安装量，下载量，被引用量都是以万的单位计数。这一切此时此刻依然正在发生。</p></blockquote><p><strong>2023 已然结束，期待 2024 更加美好！</strong></p><p><strong>船新官网: <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdromara.org%2F" target="_blank">https://dromara.org/</a></strong><br><strong>Github: <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdromara" target="_blank">https://github.com/dromara</a></strong><br><strong>Gitee: <a href="https://gitee.com/dromara">https://gitee.com/dromara</a></strong></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:17:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274844</guid>
            <link>https://www.oschina.net/news/274844</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[北京司法鉴定所破解 AirDrop 匿名溯源]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>北京市司法局微信公众号「京司观澜」<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fhy6zPU2y_lR1cgMnmP1IbQ" target="_blank">发文称</a></u>，北京网神洞鉴司法鉴定所对手机「隔空投送」传播不当信息案件的司法鉴定突破了 AirDrop 匿名溯源的技术难题，提升了案件侦破的效率和准确性，防止了不当言论的进一步传播和潜在的恶劣影响。</p><p>iPhone 的 AirDrop 功能用于在苹果设备之间「匿名」共享文件，这些设备无需连接同一局域网，且无需接收方为通讯录联系人。</p><p><img alt="" height="509" src="https://oscimg.oschina.net/oscnet/up-c0ec4f267efa1fcbecd3a436f62bb40e799.png" width="300" referrerpolicy="no-referrer"></p><p>司法鉴定所的专家通过分析 iPhone 设备日志，发现发送者的设备名、邮箱和手机号相关字段，<strong>其中手机号与邮箱相关字段是以哈希值的形式记录，且哈希值部分字段被隐藏</strong>。</p><p>北京网神洞鉴司法鉴定所的司法鉴定技术专家们通过深度解析 iPhone 设备日志，明确传输原理，找出了与 AirDrop 相关的记录。经检验发现发送者的设备名、邮箱和手机号相关字段，其中手机号与邮箱相关字段是以哈希值的形式记录，且哈希值部分字段被隐藏。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-83eeeb8a2bc7d373aada3f0f5f141335c92.png" referrerpolicy="no-referrer"></p><p>△AirDrop 哈希值转换工具</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ece996136f3eb01c07f94d9ed812b2e8a1d.png" referrerpolicy="no-referrer"></p><p>△隔空投送取证溯源</p><p>为实现快速破解该字段，<strong>技术团队制作了一张详尽的手机号与邮箱账号「彩虹表 」，能够将密文转换成原始文本，快速锁定发送者的手机号与邮箱账号</strong>。&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274843</guid>
            <link>https://www.oschina.net/news/274843</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[虽迟但到！MySQL 可以用 JavaScript 写存储过程了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>任何能用 JavaScript 来干的事情，最终都会用 JavaScript 来干</p></blockquote><h2>背景</h2><p>不久前，Oracle 在 MySQL 官方博客<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.oracle.com%2Fmysql%2Fpost%2Fintroducing-javascript-support-in-mysql" target="_blank">官宣了</a>在 MySQL 中支持用 JavaScript 来写存储过程。</p><p><img src="https://oscimg.oschina.net/oscnet/up-31abaabbc716421cb6516bf32657d2f1527.png" alt="file" referrerpolicy="no-referrer"></p><p>最流行的编程语言 + 最流行的数据库。程序员不做选择，当然是全都要。</p><p><img src="https://oscimg.oschina.net/oscnet/up-e39605d191281540f71e825f686f15c7a6f.png" alt="file" referrerpolicy="no-referrer"></p><h2>使用方法</h2><p>用 JavaScript 写存储过程的示例</p><p><img src="https://oscimg.oschina.net/oscnet/up-40ae1df9662c4efc0104883c69bc2517326.png" alt="file" referrerpolicy="no-referrer"></p><p>在 SQL 中调用</p><p><img src="https://oscimg.oschina.net/oscnet/up-33872be6f36f152268f4056e7ad7961b89a.png" alt="file" referrerpolicy="no-referrer"></p><p>Debug 依然是 print + throw 大法</p><p><img src="https://oscimg.oschina.net/oscnet/up-19512efc33452b3ae4fb7bf7ba9e1e12342.png" alt="file" referrerpolicy="no-referrer"></p><p>Oracle 通过自家的 GraalVM 来保证在 MySQL 中执行 JavaScript 的安全性和性能。</p><p><img src="https://oscimg.oschina.net/oscnet/up-287e034c12abfa5b480cbb42bfd66100db8.png" alt="file" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-a7976a65fd5cb74e1e3f7287f834443dc58.png" alt="file" referrerpolicy="no-referrer"></p><h2>业界评论</h2><p>虽然这个功能还在预览阶段，并且只在 MySQL 企业版以及 HeatWave 云服务上提供，但还是引起了巨大反响。Reddit 网友金句频出</p><p><img src="https://oscimg.oschina.net/oscnet/up-fbba7393022d7517b30dbcd00c7f76ce45d.png" alt="file" referrerpolicy="no-referrer"></p><p>又一大波 JS 框架即将到来</p><p><img src="https://oscimg.oschina.net/oscnet/up-9da6f07f451ece47fccfc858cc062a4cf61.png" alt="file" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-04d3f48d68d405de781a02ba7a948abb52d.png" alt="file" referrerpolicy="no-referrer"></p><p>任何能用 JavaScript 来干的事情，最终都会用 JavaScript 来干 - Jeff Atwood (Stack Overflow 联合创始人)</p><p><img src="https://oscimg.oschina.net/oscnet/up-edb7e08bad7336b2291a826261d86dd2791.png" alt="file" referrerpolicy="no-referrer"></p><p>对呀，干嘛不直接叫 jQuery 呢？</p><p>另一边 Hacker News 网友也不甘示弱。</p><p><img src="https://oscimg.oschina.net/oscnet/up-fd369f9f8f9da6ae078c178abb2884e9306.png" alt="file" referrerpolicy="no-referrer"></p><p>「太酷辣，我在 Snowflake 里都是用 JavaScript 写存储过程来生成视图。缺点是把不同语言揉在一起，会让代码变得不可读。但优点是我的饭碗稳了，因为分析师们无法同时理解 SQL 和 JavaScript，而必须依赖我去帮他们更新。」</p><h2>结束语</h2><ol><li>MySQL 在数据库圈的话题性很强，但碰上 JavaScript，发现梗完全不够用呀。</li><li>这次官宣的第一作者，之前也曾在阿里云数据库团队工作过 3 年。</li></ol><p><img src="https://oscimg.oschina.net/oscnet/up-f77257c586e82036c86d393181de11f7bb9.png" alt="file" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-0ed6070e29a07aa8c892fbd246b8a411b82.png" alt="file" referrerpolicy="no-referrer"></p><ol start="3"><li>PostgreSQL 依然「遥遥领先」，毕竟通过 PLV8 写 JavaScript 都不知道是多久以前的事情了。</li></ol><hr><p>💡 更多资讯，请关注 Bytebase 公号：Bytebase</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6148470/blog/10712918</guid>
            <link>https://my.oschina.net/u/6148470/blog/10712918</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[DreamTalk —— 音频驱动型表情包生成框架]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>DreamTalk 是一种基于 diffusion 的音频驱动型表情包生成框架，可以生成高质量的表情包视频，涵盖多种说话风格。DreamTalk 在处理各种输入（包括歌曲、多语言语音、嘈杂音频和域外肖像）时表现出强劲的性能。</p><p>具体来说，DreamTalk 由三个关键组件组成：去噪网络、风格感知唇部专家和风格预测器。基于扩散的去噪网络能够一致地合成不同表情的高质量音频驱动的面部运动。为了增强唇部动作的表现力和准确性，项目团队引入了风格感知型唇部专家，可以指导唇部同步，同时注意说话风格。为了消除对表情参考视频或文本的需要，利用额外的基于扩散的风格预测器直接从音频预测目标表情。通过这种方式，DreamTalk 可以利用强大的扩散模型有效地生成富有表现力的面孔，并减少对昂贵的风格参考的依赖。</p><p>实验结果表明，DreamTalk 能够生成具有多种说话风格的逼真说话面孔，并实现准确的嘴唇动作，超越了现有最先进的同类产品。</p><p><img alt="" height="214" src="https://static.oschina.net/uploads/space/2024/0105/161846_cUbY_4252687.gif" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:10:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/dreamtalk</guid>
            <link>https://www.oschina.net/p/dreamtalk</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 使用 TypeScript 开发的可视化库 VISLite]]>
            </title>
            <description>
                <![CDATA[<ul><li>💘 开源不易，去 <i><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Foi-contrib%2FVISLite">Github 给个 Star</a></i>吧！</li></ul><img src="https://oi-contrib.github.io/VISLite/images/logo.png" height="300px" referrerpolicy="no-referrer"><p><a href="https://gitee.com/link?target=https%3A%2F%2Fzxl20070701.github.io%2Ftoolbox%2F%23%2Fnpm-download%3Fpackages%3Dvislite%26interval%3D7"><img src="https://img.shields.io/npm/dm/vislite.svg" alt="downloads" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvislite"><img src="https://img.shields.io/npm/v/vislite.svg" alt="npm" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.jsdelivr.com%2Fpackage%2Fnpm%2Fvislite"><img src="https://data.jsdelivr.com/v1/package/npm/vislite/badge" alt="cdn" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Foi-contrib%2FVISLite" target="_blank"><img alt="GitHub repo stars" src="https://img.shields.io/github/stars/oi-contrib/VISLite?style=social" referrerpolicy="no-referrer"></a></p><h1><a id="user-content-vislite" class="anchor" href="https://gitee.com/oi-contrib/VISLite#vislite"></a>VISLite</h1><p><code>VISLite</code>是一个使用<code>TypeScript</code>开发的可视化库。官网地址：<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite">https://oi-contrib.github.io/VISLite</a></p><p>主要提供了跨端的画布和计算，开发人员只需要按照文档的描述就可以非常简单的完成包括 Web、uni-app、微信小程序等平台的可视化开发，除了必要的初始化差异，主要的业务代码部分不同端完全一致。</p><h2><a id="user-content-简介" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E7%AE%80%E4%BB%8B"></a>简介</h2><p>这是一个轻量级的数据可视化资源库，目标是：帮助你更快速、简单、高效的开发出任意的可视化业务产品。</p><blockquote><p>本项目已在<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.oschina.net%2Fp%2Fvislite">开源中国</a>中开源，欢迎关注和留言。</p></blockquote><h3><a id="user-content-常用的算法" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95"></a>常用的算法</h3><p>我们通过提供可视化常用的算法来帮助你绘制复杂图表。比如下面的树图，通过简单的配置就可以把任意格式的数据变成任意绘制的带座标的数据：</p><img src="https://oi-contrib.github.io/VISLite/images/docs/what_1.png" width="400" height="300" referrerpolicy="no-referrer"><blockquote><p>上述例子的运行地址：<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fexample%2Fcanvas%2Ftree-layout-lr">从左到右树状图</a>。</p></blockquote><p>除了<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fapi%2FtreeLayout">树布局</a>外，我们还提供了：<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fapi%2Fruler">刻度尺算法</a>来帮助你计算刻度应该如何确定、<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fapi%2Feoap">等角斜方位投影</a>和<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fapi%2Fmercator">墨卡托投影</a>来绘制地图、<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fapi%2Fcardinal">插值函数</a>来完成折线变光滑的曲线、<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fapi%2Fmatrix4">变换矩阵</a>提供各种座标变换等。</p><h3><a id="user-content-画笔加强" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E7%94%BB%E7%AC%94%E5%8A%A0%E5%BC%BA"></a>画笔加强</h3><p>我们对画笔进行了加强，使得其更简单好用。比如 canvas、webgl，抽象出区域的概念，使得无论你绘制的图形多么的不规则，都可以很轻松的实现交互功能：</p><img src="https://oi-contrib.github.io/VISLite/images/docs/what_2.png" width="400" height="300" referrerpolicy="no-referrer"><blockquote><p>上述例子的运行地址：<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fexample%2Fcanvas%2Fchina">中国地图</a>。</p></blockquote><p>画笔除了像上面那样为了方便交互而补充区域的设计外，还对原来的 API 进行了一次抽象，使得 API 更友好简单<code>（比如 WebGL，即使不会 3D 的人也可以轻松使用，而 SVG 的使用，你无需去记忆那些晦涩难懂的属性）</code>，同时，我们还抹平了不同版本浏览器等之间的差异。</p><h3><a id="user-content-支持跨端开发" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E6%94%AF%E6%8C%81%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91"></a>支持跨端开发</h3><p>除了 Web 端外，我们还针对 uni-app、微信小程序等端进行了支持，并且不同端 API 保持一致，大大提高了代码的复用性：</p><img src="https://oi-contrib.github.io/VISLite/images/docs/what_3.png" width="600" height="300" referrerpolicy="no-referrer"><blockquote><p>上述例子的运行地址：<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fexample%2Fsvg%2Fmoney-schedule">金额波浪球</a>。</p></blockquote><p>基于实际需要，我们目前对 <code>Canvas</code> 提供了跨端支持，除 <code>Web 端</code> 外，还支持 <code>原生微信小程序</code> 和 <code>uni-app 端</code> （编译成 H5、微信小程序、支付宝小程序等） ，如果后续有必要，我们会对 Canvas 支持的端或 SVG、WebGL 等画笔进行更多端扩展。</p><h3><a id="user-content-可视化大屏" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F"></a>可视化大屏</h3><p>当然，按照业务和 UI 设计，快速开发一个大屏也是相对容易的：</p><img src="https://oi-contrib.github.io/VISLite/images/docs/bigview.jpeg" width="500" referrerpolicy="no-referrer"><blockquote><p>上述例子的运行地址：<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fbigview%3Fpage%3Ddataboard">数据看板大屏</a>。</p></blockquote><h2><a id="user-content-特点" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E7%89%B9%E7%82%B9"></a>特点</h2><ul><li>灵活的引入方式：包括 npm 安装后按照<code>ES Module</code>或<code>CommonJS</code>规范引入或直接使用 script 标签的<code>CDN</code>方式。</li><li>按需引入或全局引入：支持源码 TS 引入、按需 JS 引入或者全量引入等多种方式。</li><li>简单与复杂共存：一方面我们提供了可视化需要的基础功能，你可以按照自己的需要组合使用；另一方面，为了加速开发，我们针对常见的可视化业务场景进行了封装，可以帮助你快速完成，你可以根据实际情况进行选择。</li><li>向下兼容：我们向你保证，始终向下兼容<code>（alpha 和 beta 版本为测试版本，不包括）</code>，因此，无论何时，最新版本总是最好的选择。</li></ul><blockquote><p>版本说明：alpha 为开发阶段、beta 为发布前测试、无后缀的为正式版本。</p></blockquote><h2><a id="user-content-需求墙" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E9%9C%80%E6%B1%82%E5%A2%99"></a>需求墙</h2><p>我们的目标是不断完善丰富可视化功能，非常希望获得你宝贵的建议和批评，无论任何想法，都可以给我们<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Foi-contrib%2FVISLite%2Fissues">留言</a>告诉我们。</p><p>你所提的任何建议我们都会在最长一周内进行反馈说明。</p><h2><a id="user-content-更新日志" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97"></a>更新日志</h2><p>详见<a href="https://gitee.com/oi-contrib/VISLite/blob/master/CHANGELOG">正式版更新日志</a>，我们会在每次发布完正式版本后更新其内容。</p><h2><a id="user-content-下一步" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E4%B8%8B%E4%B8%80%E6%AD%A5"></a>下一步</h2><p>我们会在这里列出接下来的工作重心：</p><ul><li>Canvas、SVG 和 WebGL 画笔功能丰富</li><li>为加速开发，提供常用座标系和布局</li><li>文档优化（提高可读性、丰富用例、补充教程）</li></ul><p>给我们<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Foi-contrib%2FVISLite%2Fissues">留言</a>告诉我们你希望快速扩展的功能，我们会优先你的建议考虑哦～</p><h2><a id="user-content-参与贡献" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E5%8F%82%E4%B8%8E%E8%B4%A1%E7%8C%AE"></a>参与贡献</h2><p>你可以选择下列一项或多项进行参与：</p><ul><li>代码维护：由于新功能或一些 BUG 的出现，对代码进行维护和升级。</li><li>文档编辑：主要是接口文档和教程需要编辑，这很重要。</li><li>用例开发和测试：在项目的 test 文件夹下有一些测试，而在 docs 文档中存在一些例子需要补充。</li><li>参与讨论：主要是讨论未来如何发展，改造的方向等。</li></ul><p>如果有意向加入我们，你可以通过提 <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Foi-contrib%2FVISLite%2Fissues">issue</a> 和我们取到联系，请简单说明一下情况，我们会尽快回复。</p><p>你可以查看<a href="https://gitee.com/oi-contrib/VISLite/blob/master/.github/CONTRIBUTING.md">VISLite 贡献指南</a>文件了解更多细节，查看<a href="https://gitee.com/oi-contrib/VISLite/blob/master/AUTHORS.txt">AUTHORS.txt</a>了解所有的贡献者。</p><h2><a id="user-content-版权" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E7%89%88%E6%9D%83"></a>版权</h2><p>MIT License</p><p>Copyright (c) <a href="https://gitee.com/link?target=https%3A%2F%2Fzxl20070701.github.io%2Fnotebook%2Fhome.html">zxl20070701</a> 走一步，再走一步</p>]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/oi-contrib/VISLite</guid>
            <link>https://gitee.com/oi-contrib/VISLite</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | Spring 七种事务传播性介绍]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="font-size: 15px;line-height: 1.6;"><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">作者：vivo 互联网服务器团队 - Zhou Shaobin</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: left;" powered-by="xiumi.us"><section style="font-size: 14px;text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);"><p style="text-wrap: wrap;">本文主要介绍了 Spring 事务传播性的相关知识。<br><br></p><p style="text-wrap: wrap;">Spring 中定义了 7 种事务传播性：</p><p style="text-wrap: wrap;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="text-wrap: wrap;"><span style="color: rgb(160, 160, 160);font-size: 14px;letter-spacing: 0.578px;text-wrap: wrap;">PROPAGATION_REQUIRED&nbsp;</span></p></li><li><p style="text-wrap: wrap;"><span style="letter-spacing: 0.034em;">PROPAGATION_SUPPORTS</span></p></li><li><p style="text-wrap: wrap;"><span style="letter-spacing: 0.034em;">PROPAGATION_MANDATORY</span></p></li><li><p style="text-wrap: wrap;"><span style="letter-spacing: 0.034em;">PROPAGATION_REQUIRES_NEW</span></p></li><li><p style="text-wrap: wrap;"><span style="letter-spacing: 0.034em;">PROPAGATION_NOT_SUPPORTED</span></p></li><li><p style="text-wrap: wrap;"><span style="letter-spacing: 0.034em;">PROPAGATION_NEVER</span></p></li><li><p style="text-wrap: wrap;"><span style="letter-spacing: 0.034em;">PROPAGATION_NESTED</span></p></li></ul><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">在 Spring 环境中，含有事务的方法嵌套调用，事务是如何传递的规则，以及每种规则是如何开展工作的。文章还提到每种事务传播性是如何使用的，方便读者依据实际的场景，使用不同的事务规则。</p></section></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>一、什么是 Spring 事务的传播性</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Spring 事务传播性是指， 在 Spring 的环境中，当多个含有事务的方法嵌套调用时，每个事务方法都处于自己事务的上下文中，其提交或者回滚行为应该如何处理。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通俗讲，就是当一个事务方法调用另外一个事务方法时，事务如何跨上下文传播。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014182" data-ratio="0.4357142857142857" data-s="300,640" src="https://oscimg.oschina.net/oscnet/f25cb074-716b-471d-b42b-34d9ef981030.jpg" data-type="jpeg" data-w="700" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">1）当事务方法 A 调用事务方法 B 时，事务方法 B 是合并到事务方法 A 中，还是开启新事务？</p><p style="text-wrap: wrap;">2）当事务方法 B 抛出异常时&nbsp; ，在合并事务或者开启新的事务的场景中，事务的回滚是如何处理的 ？</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">以上事务的处理规则，都取决于事务传播级别的设置。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>二、事务的传播性都有哪些行为</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014183" data-ratio="0.6296829971181557" data-s="300,640" src="https://oscimg.oschina.net/oscnet/3c651ebf-1386-492f-8623-e4771fafefc0.jpg" data-type="jpeg" data-w="694" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">事务的传播行为，主要分为三种类型，分别是：<strong>支持当前事务</strong>、<strong>不支持当前事务</strong>、<strong>嵌套事务</strong>。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.1 支持当前事务</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><strong>REQUIRED</strong>：默认的事务传播级别，表示如果当前方法已在事务内，该方法就在当前事务中执行，否则，开启一个新的事务并在其上下文中执行。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;"><strong>SUPPORTED</strong>：当前方法在事务内，则在其上下文中执行该方法，否则，开启一个新的事务。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;"><strong>MANDATORY</strong>：必须在事务中执行，否则，将抛出异常。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.2 不支持当前事务</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><strong>REQUIRES_NEW</strong>：无论当前是否有事务上下文，都会开启一个事务&nbsp; 。如果已经有一个事务在执行 ，则正在执行的事务将被挂起 ，新开启的事务会被执行。<br></p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">事务之间相互独立，互不干扰。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;"><strong>NOT_SUPPORTED</strong>：不支持事务，如果当前存在事务上下文，则挂起当前事务，然后以非事务的方式执行。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;"><strong>NEVER</strong>：不能在事务中执行，如果当前存在事务上下文，则抛出异常。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.3&nbsp;嵌套事务</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>NESTED</strong>：嵌套事务，如果当前已存在一个事务的上下文中，则在嵌套事务中执行，如果抛异常，则回滚嵌套事务，而不影响其他事务的操作。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>三、每种事务的传播性如何工作</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.1 REQUIRED&nbsp;&nbsp;</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">默认的事务传播行为，保证多个嵌套的事务方法在同一个事务内执行，并且同时提交，或者出现异常时，同时回滚。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;"></span><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;">这个机制可以满足大多数业务场景。</span></p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014184" data-ratio="0.577490774907749" data-s="300,640" src="https://oscimg.oschina.net/oscnet/2aff859c-0701-434b-8a2b-41e9905f3c02.jpg" data-type="jpeg" data-w="542" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">&nbsp;例子 ：</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014185" data-ratio="0.4429447852760736" data-s="300,640" src="https://oscimg.oschina.net/oscnet/45fcfef2-2fd6-4ce0-a377-3336137657e9.jpg" data-type="jpeg" data-w="815" style="" referrerpolicy="no-referrer"></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014186" data-ratio="0.3899755501222494" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b792582b-cfe0-4df3-903e-9343f2dd235b.jpg" data-type="jpeg" data-w="818" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;">1）类 TestAService 的方法通过声明式事务的方式，加上了事务注解@Transactional ，并设置事务的传播性为 REQUIRED。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">2）调用者调用 TestAService 的 A 方法时，如果调用者没有开启事务，那么 A 方法会开启一个事务。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">A 方法的具体执行过程如下 ：</p><p style="text-wrap: wrap;">a. 执行 insert，但没有提交；</p><p style="text-wrap: wrap;">b.调用 TestBServcie 的 B 方法，由于 B 方法也声明了事务，并且传播性是 REQUIRED，所以方法 B 的事务，合并到方法 A 开启的事务中。</p><p style="text-wrap: wrap;">c.方法 B 执行 insert 操作，此时也没有提交。<br><br></p><p style="text-wrap: wrap;">3）由于这两个方法的操作都在同一个事务中执行，当这两个方法所有操作执行成功之后，提交事务。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">嵌套调用链路：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014187" data-ratio="0.13892078071182548" data-s="300,640" src="https://oscimg.oschina.net/oscnet/ccbb2e64-6419-4c89-9109-df8c1be5957b.jpg" data-type="jpeg" data-w="871" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(70, 97, 246);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgb(62, 62, 62);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">当方法 B 执行时抛出了 Exception 异常后，事务是如何处理的 ？</p></section></section></section><p>1）方法 B 声明了事务，insert 操作会回滚</p><p>2）由于方法 A 和方法 B 同属一个事务，方法 A 也会执行回滚，由此说明该规则保证了事务的原子性。</p><p><br></p><p>嵌套调用，异常后的链路：</p><p><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014188" data-ratio="0.15219842164599776" data-s="300,640" src="https://oscimg.oschina.net/oscnet/077cdda3-e7bc-45b6-8ea9-807b3765adb5.jpg" data-type="jpeg" data-w="887" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 8px;font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;"><section style="padding-left: 8px;display: inline-block;width: 578px;vertical-align: top;border-left: 3px solid rgb(70, 97, 246);border-bottom-left-radius: 0px;align-self: flex-start;flex: 0 0 auto;"><section powered-by="xiumi.us" style="color: rgb(62, 62, 62);text-align: justify;"><p>如果，方法 B 抛出异常后，方法 A 使用 try-catch 处理了方法 B 的异常（如下代码），并没有向外抛出，此时事务又如何处理的 ？</p></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014189" data-ratio="0.33291457286432163" data-s="300,640" src="https://oscimg.oschina.net/oscnet/9fc563a6-9984-4d9d-af11-bcfd49b19b70.jpg" data-type="jpeg" data-w="796" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">方法 A 也会回滚。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">从事务的特性我们可知，事务具有原子性。方法 A 和方法 B 同属一个事务，当方法 B 抛出异常，触发回滚操作后，整个事务的操作都会回滚。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">因此，Spring 在处理事务过程中，当事务的传播性设置为 REQUIRED，在整个事务的调用链上，任何一个环节抛出的异常都会导致全局回滚。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.2 REQUIRES_ NEW</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">每次都开启一，个新的事务。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014190" data-ratio="0.4325153374233129" data-s="300,640" src="https://oscimg.oschina.net/oscnet/d0097908-7fd0-42c9-b288-0b49b60534b0.jpg" data-type="jpeg" data-w="652" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">&nbsp;例子：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014191" data-ratio="0.20330368487928843" data-s="300,640" src="https://oscimg.oschina.net/oscnet/3f4398b9-1173-4e3b-a0d2-bbca386e67b9.jpg" data-type="jpeg" data-w="787" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">上面例子中，方法 B 的传播性设置为 REQUIRES_NEW，方法 A 仍然是 REQUIRED，当 A 调用 B 时，具体调用链路如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014193" data-ratio="0.2803203661327231" data-s="300,640" src="https://oscimg.oschina.net/oscnet/dd34f32f-ad1d-4cdc-921d-e5fbb11b2bfe.jpg" data-type="jpeg" data-w="874" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 A 被执行前，如果调用者没有开启事务，方法 A 开启一个事务 1，然后执行 insert ，此时没有提交；</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 B 的事务传播性设置为 REQUIRES_NEW，当被方法 A 调用时，此时方法 A 的事务 1 会被挂起，方法 B 开启自己的事务 2，然后执行 insert，此时并没有提交；</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">当方法 B 执行完毕后，提交事务 2；</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">恢复事务 1，最终提交。</span><span style="letter-spacing: 0.034em;"></span></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(70, 97, 246);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgb(62, 62, 62);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">当，方法 B 执行时抛出了异常，会发生什么？</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">方法 B 的 insert 操作会被回滚掉,方法 A 不受影响。但这里有个前提，方法 A 需要 try-catch 方法 B 的异常，使其异常不会往上传递，从而导致方法 A 接收到异常，导致回滚。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014194" data-ratio="0.2877939529675252" data-s="300,640" src="https://oscimg.oschina.net/oscnet/a9c7c98f-053d-4c12-a5c8-777f32b699e6.jpg" data-type="jpeg" data-w="893" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.3&nbsp; SUPPORTED</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">当外层方法 A 存在事务，方法 B 加入到当前事务中，以事务的方式执行。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014195" data-ratio="0.559748427672956" data-s="300,640" src="https://oscimg.oschina.net/oscnet/ce1639fd-a2c7-407f-8c2e-0c7b4af8a7ff.jpg" data-type="jpeg" data-w="636" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">当外层方法 A 不存在事务，方法 B 不会创建新的事务，以非事务的方式执行。</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014196" data-ratio="0.6865671641791045" data-s="300,640" src="https://oscimg.oschina.net/oscnet/e348a11f-faad-48b0-a6e1-70aeedc01de0.jpg" data-type="jpeg" data-w="536" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">&nbsp;例子 1：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014197" data-ratio="0.23020527859237536" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b3fc986f-f0f3-4126-bcf1-1f0a2ce71fbd.jpg" data-type="jpeg" data-w="682" style="" referrerpolicy="no-referrer"></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014198" data-ratio="0.1793103448275862" data-s="300,640" src="https://oscimg.oschina.net/oscnet/28c10e68-1769-4b67-86cd-90901a489191.jpg" data-type="jpeg" data-w="725" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以上例子，方法 A 没有加事务注解，方法 B 的加了事务注解，并且传播为 SUPPORTS。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 A 以非事务的方式执行 insert 操作。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 B 被调用，由于其外层事务 A 没有开启事务，方法 B 也是以非事务方法执行 insert 操作。</span></p></li></ul></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014199" data-ratio="0.21016949152542372" data-s="300,640" src="https://oscimg.oschina.net/oscnet/96736113-0a60-4cc9-a14f-49b7a4b68331.jpg" data-type="jpeg" data-w="590" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">例子 2：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014200" data-ratio="0.12777777777777777" data-s="300,640" src="https://oscimg.oschina.net/oscnet/a87c1624-cb04-4f02-b57c-99ae40a3de71.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以上例子，方法 A 和 B 都加上了事务注解，其中方法 A 的传播性为 REQUIRED，方法 B 的传播性为 SUPPORTS。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">如果方法 A 的调用方没有开启事务，则方法 A 开启事务，并执行 insert 操作，但没有提交；</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">方法 B 被调用，由于其外层方法 A 开启了事务，因此方法 B 加入到方法 A 开启的事务中，并执行 insert,但没有提交；</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">当事务中的所有操作执行成功后，事务提交。</span></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014201" data-ratio="0.13157894736842105" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bca29bf0-2c58-4174-9477-3903aafa4180.jpg" data-type="jpeg" data-w="798" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.4&nbsp; NOT_SUPPORTED</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">不支持事务。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">如果外层方法存在事务，则挂起外层事务，以非事务方式执行，执行完毕后，恢复外层事务。</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014202" data-ratio="0.4672131147540984" data-s="300,640" src="https://oscimg.oschina.net/oscnet/6355266c-c5d2-46c2-9add-c5a7a34131d8.jpg" data-type="jpeg" data-w="610" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">例子：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014203" data-ratio="0.12407407407407407" data-s="300,640" src="https://oscimg.oschina.net/oscnet/458980db-9a97-4419-975a-121889eafd90.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以上例子：方法 A 和 B 都加上了事务注解，方法 A 的传播性为 REQUIRED,方法 B 为 NOT_SUPPORTED。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">如 A 的调用方没有开启事务，方法 A 开启事务，并执行 insert，但没有提交。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">方法 A 调用方法 B 时，方法 B 的传播性为 NOT_SUPPORTED,不支持事务，然后挂起外层方法 A 的事务，方法 B 以非事务的方式执行 insert。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">方法 B 执行完毕后，恢复方法 A 的事务，最终提交事务。</span></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">调用链路过程：</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014204" data-ratio="0.1400208986415883" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b5ec0c68-b769-433a-ab3c-7fe1941627af.jpg" data-type="jpeg" data-w="957" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.5 NEVER</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">不支持事务</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">当外层方法 A 开启了事务，方法 B 抛出异常</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014205" data-ratio="0.578" data-s="300,640" src="https://oscimg.oschina.net/oscnet/8567887f-aa12-473c-b4cb-b2e6f6c00360.jpg" data-type="jpeg" data-w="500" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">例子：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014206" data-ratio="0.12777777777777777" data-s="300,640" src="https://oscimg.oschina.net/oscnet/65811a67-78a5-49c0-b95f-a277d8537a52.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以上代码，两个方法都打上了事务注解，方法 A 的传播性是 REQUIRED,方法 B 的传播性是 NEVER。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 A 开启事务，执行 insert,没有提交。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">含有事务的方法 A 调用方法 B，方法 B 的传播性是 NEVER,表示不支持事务，因此方法 B 抛出异常。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">方法 A 的事务执行回滚。</span></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014207" data-ratio="0.26361867704280156" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b642401a-cde6-4635-b66e-370d0cb534d2.jpg" data-type="jpeg" data-w="1028" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.6 MANDATORY</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">必须在事务中执行。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">如果外层方法 A 没有开启事务，方法 B 抛出异常。</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014208" data-ratio="0.5640535372848948" data-s="300,640" src="https://oscimg.oschina.net/oscnet/e520ab89-d9b6-4d44-b30d-bf83e5ca9a5e.jpg" data-type="jpeg" data-w="523" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">如果外层方法 A 开启了事务，方法 B 加入事务，方法 A&amp;B 在同一事务中执行。</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014209" data-ratio="0.6473029045643154" data-s="300,640" src="https://oscimg.oschina.net/oscnet/cec503c3-7c18-4447-8538-cbaa55395d02.jpg" data-type="jpeg" data-w="482" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">例子：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014210" data-ratio="0.15" data-s="300,640" src="https://oscimg.oschina.net/oscnet/5946ff56-8e70-42bf-b73b-e4ea86828e1a.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以上例子，方法 A 没有加事务注解，方法 B 的传播性为 MANDATORY。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 A 的调用方如果本身没有开启事务，方法 A 执行前不会开启事务。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">当非事务方法 A 调用方法 B 时，由于方法 B 的传播性为 MANDATORY，必须在事务中执行，条件不满足，抛出异常。</span></p></li></ul></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014211" data-ratio="0.30708661417322836" data-s="300,640" src="https://oscimg.oschina.net/oscnet/416475ff-f185-4c51-b748-3bd01b71c1d9.jpg" data-type="jpeg" data-w="889" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.7 NESTED</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="margin-bottom: 10px;text-wrap: wrap;">嵌套事务</p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;">如果外层方法 A 不存在事务，内层方法 B 的规则与 REQUIRED 一致。</p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">如果外层方法 A 存在事务，内层方法 B 做为外层方法 A</span><span style="letter-spacing: 0.034em;">事务的子事务执行，两个方法是一起提交，但子事务是独立回滚。</span></p><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;"></span><span style="letter-spacing: 0.034em;">内层方法 B 抛出异常，则会回滚方法 B 的所有操作，但不影响外层事务方法 A。</span><span style="letter-spacing: 0.034em;">（方法 A 需要 try-catch 子事务，避免异常传递到父层事务）</span></p><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;"></span><span style="letter-spacing: 0.034em;">外层方法 A 回滚，则内层方法 B 也会回滚。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">该传播性的特点是可以保存状态点，当回滚时，只会回滚到某一个状态点，保证了子事务之间的独立性，避免嵌套事务的全局回滚。</span></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014212" data-ratio="0.5464949928469242" data-s="300,640" src="https://oscimg.oschina.net/oscnet/19442a82-a558-40f9-9c12-48c694a7be5b.jpg" data-type="jpeg" data-w="699" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">例子：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014213" data-ratio="0.22870370370370371" data-s="300,640" src="https://oscimg.oschina.net/oscnet/1842fc23-33da-437d-aadf-6126ceee7570.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以上例子，方法 A 的传播性为 REQUIRED,方法 B 为 NESTED。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 A 执行时，如调用方没有开启事务，则开启一个事务。</span></p></li><li><p style="margin-bottom: 10px;">方法 B 被外层方法 A 调用时，因为方法 B 的传播性为 NESTED，方法 B 在此处建立 savepoint,标记 insert 行为。</p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">当方法 B 抛出异常，其 insert 操作会回滚，但只会回滚到 savepoint，（前提是方法 A 要 try-catch 方法 B，使方法 B 的异常不会往外传递）。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">方法 B 回滚后，方法 A 的事务提交。</span></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">调用链路：</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014214" data-ratio="0.2857142857142857" data-s="300,640" src="https://oscimg.oschina.net/oscnet/76197617-a9ba-44b1-af8b-90ccfeb45afc.jpg" data-type="jpeg" data-w="910" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>四、总结</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">本文解释了 Spring 框架中的事务传播性，即多个业务方法之间调用时事务如何处理的规则。Spring 提供了七种传播级别，如</p><p style="text-wrap: wrap;">PROPAGATION_REQUIRED、</p><p style="text-wrap: wrap;">PROPAGATION_REQUIRES_NEW 等。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">每种级别都有适用场景和限制，本文提供了一些示例，介绍了声明式事务如何使用，每种事务的规则，产生哪种行为，当方法抛出异常时，事务的提交和回滚是如何被处理的。正确处理事务对于任何企业级应用程序都是必要的，了解 Spring 事务传播性是构建高效、可靠和可扩展应用程序的关键。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;"><section style="text-align: center;color: rgb(45, 66, 87);font-size: 11px;" powered-by="xiumi.us"><p>END</p></section></section><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: left;" powered-by="xiumi.us"><section style="padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;"><span style="display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);" title="" opera-tn-ra-cell="_$.pages:0.layers:0.comps:148.title1"><p>猜你喜欢</p></span></section><section style="border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;"><section style="font-size: 14px;text-align: left;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497989%26idx%3D1%26sn%3Da98e270e4612356756966bd9d90d80ee%26chksm%3Debdb8997dcac0081e35a2c9ba681902e703f8c52406ee49fcedaafbba77b7dc3279f56305782%26scene%3D21%23wechat_redirect" textvalue="vivo 数据库备份恢复系统演化" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">vivo 数据库备份恢复系统演化</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497821%26idx%3D1%26sn%3D80e04511f5a5d5acfee4a44a8a8b3e31%26chksm%3Debdb88cfdcac01d954242fd24907b69c542e43fcb99ebe6a03d66858194e03ad14105281b62f%26scene%3D21%23wechat_redirect" textvalue="vivo 容器平台资源运营实践" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">vivo 容器平台资源运营实践</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497821%26idx%3D2%26sn%3Db5d635106e88b9f918f54111f11b3027%26chksm%3Debdb88cfdcac01d952d021c34f90aabe3c193fc1b0bd4d86721f2ec3d696c909cf4503936be9%26scene%3D21%23wechat_redirect" textvalue="前端 JS 安全对抗原理与实践" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">前端 JS 安全对抗原理与实践</a></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互联网技术" data-alias="vivoVMIC" data-signature="分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10583852</guid>
            <link>https://my.oschina.net/vivotech/blog/10583852</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[年度盘点｜深圳工信十件大事]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>「i 深圳」官微<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F_8-u5N6_fIBUYJZGu1fGYg" target="_blank">发文</a>盘点了 2023 年深圳工信十大事件，具体如下：</p><p><span style="color:#007aaa"><strong>一、企业创新主体地位不断强化，「深圳制造」爆款迭出</strong></span></p><p><span style="color:#595959">企业研发投入达 1784.6 亿元，约占全社会研发投入比重 94.9%，位居全国第一。华为推出全球首款支持衞星通话和应用星闪技术的 Mate 60 系列手机产品，引发线上线下抢购热潮；荣耀推出全球最轻薄大内折高端机 Magic V2，引领折叠屏厚度进入「毫米时代」；仰望 U8、问界 M9 等高端车型先后发布，搭载业内领先的自研车身控制系统和智能科技配置，代表了全球高端新能源汽车前沿水平。</span></p><p><img height="383" src="https://oscimg.oschina.net/oscnet/up-c427126861041278cce2734057b420f8024.png" width="500" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#007aaa"><strong>二、「新一代世界一流汽车城」建设全面提速，比亚迪勇夺全球新能源汽车销冠</strong></span></p><p><span style="color:#595959">高标准规划建设「新一代世界一流汽车城」，全市全年新能源汽车产量继续实现翻倍增长。汽车出口屡创新高，全市新车电动化渗透率、充电基础设施密度全国领先，新能源汽车保有量超 96 万辆，入围国家首批公共领域全面电动化一类试点城市。全力支持深汕特别合作区建设世界级汽车制造城，深汕比亚迪汽车工业园二期建成投产，东风李尔、壁虎科技、佛吉亚等一批新能源汽车产业链上下游明星企业集聚深汕。比亚迪累计下线超 600 万辆新能源汽车，2023 年全年销售汽车 302.44 万辆，同比增长 61.9%，一举夺得全国汽车年度销冠、全球新能源汽车销冠，创下中国汽车年销量最高纪录，新能源汽车行业迈向规模化、全球化高质量发展之路。</span></p><p><img height="395" src="https://oscimg.oschina.net/oscnet/up-37f0d216108702b10da9071d67a72e94422.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#007aaa"><strong>三、优质通用大模型接连推出，人工智能全域全时场景应用加快拓展</strong></span></p><p><span style="color:#595959">印发实施《深圳市加快推动人工智能高质量发展高水平应用行动方案（2023-2024 年）》，构建「一条例、一方案、一清单、一基金群」的政策体系。华为云盘古 3.0。腾讯混元、云天励飞天书等一批高水平通用大模型陆续推出。升腾系列芯片成为国内具备全栈技术的最高水平的人工智能算力芯片。累计发布人工智能清扫等 41 个「城市+AI」场景，举办人工智能专场产学研对接系列活动，人工智能全域全时场景应用加快拓展。</span></p><p><img height="323" src="https://oscimg.oschina.net/oscnet/up-09bda6383445c51b8c4c7c3c38d87601298.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#007aaa"><strong>四、开源鸿蒙欧拉产业高地建设再上台阶，「软件名城」获评「三星级」</strong></span></p><p><span style="color:#595959">印发实施《深圳市推动开源鸿蒙欧拉产业创新发展行动计划（2023—2025 年）》，全体系增强操作系统技术能力，开源鸿蒙装机量已超过 7 亿台，开源欧拉装机量占据国内服务器市场份额近 4 成。落地全球智慧物联网联盟等国际组织，建设鸿蒙生态创新中心，加快推动我国操作系统技术创新和高水平自立自强。在全国「软件名城」考核中名列前茅，获评最高等次「三星级」。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="275" src="https://oscimg.oschina.net/oscnet/up-45f99849e79a7af19baff203be73c45bcee.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#007aaa"><strong>五、75 个「工业上楼」项目开工建设，高标准谋划共建产业园区</strong></span></p><p><span style="color:#595959">持续加大产业用地用房供应，积极稳妥推进「工业上楼」，为制造业高质量发展提供强有力空间保障。2023 年开工建设 75 个「工业上楼」项目，预计可提供总建筑面积超 2000 万㎡。龙岗宝龙专精特新产业园正式开园，全国首个全装配式智能产业园坪山区新能源汽车产业园交付使用，推广实现「上下游就是上下楼，产业园就是产业链」。与汕头、潮州等地加大产业合作力度，高标准谋划共建产业园区，努力实现优势互补、合作共赢。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="351" src="https://oscimg.oschina.net/oscnet/up-0e185217af6add18c0a3dc295242507811b.png" width="500" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#007aaa"><strong>六、中小企业发展环境综合排名全国第一，专精特新「小巨人」增量全国第一</strong></span></p><p><span style="color:#595959">《2022 年度中小企业发展环境评估报告》发布，深圳中小企业发展环境综合排名全国第一。「深 i 企」平台用户数突破 300 万。创新开展「我帮企业找市场」等系列行动，线上打造供需对接平台，线下开展上百场各类主题的「链上配对」精准对接服务，帮助企业拿订单、拓市场，打通上下游合作「最后一公里」。2023 年新增专精特新「小巨人」企业 309 家，新增数量居全国大中城市第一，总数达 742 家、位列全国第二。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="350" src="https://oscimg.oschina.net/oscnet/up-bb68fd01669b2204acf6e1a401f88b4d831.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#007aaa"><strong>七、千兆城市建设水平领跑全国，率先迈入 5G-A 时代</strong></span></p><p><span style="color:#595959">启动「极速宽带先锋城市」建设行动，全年新增 5G 基站超 1 万个、累计建成超 7.5 万个，重点场所 5G 网络通达率 100%，多项千兆城市指标位居全国大中城市首位。启动数字家庭 3T 跃升行动试点，深圳市公共场所 WIFI 管理平台累计服务近 3 亿人次，为市民节省约 1.7 亿元流量费，市民生活数字化服务水平得到大幅提升。出台《深圳市算力基础设施高质量发展行动计划（2024-2025）》，力争将算力打造成像水、电「一点接入、即取即用」的基础设施，夯实数字经济发展「底座」。全面加速 5G-A 行业应用创新与产业融合发展，成为全球首个迈入 5G-A 时代的城市。</span></p><p><span style="color:#007aaa"><strong>八、一批重大先进制造业项目落地，工业投资实现高速增长</strong></span></p><p><span style="color:#595959">市区协同、部门联动，赴法国、德国、马来西亚、沙特等 25 个国家和北京、上海等 30 多个城市精准招商，招引西门子、椭圆星池、京西重工、壁虎科技等一批国内外知名企业重点项目成功落地。推动与中国一汽、中国化学、中汽中心等一批央企签署合作协议，打造央地产业合作新典范。全年先进制造业领域成功招引落地百亿以上项目 8 个，10 亿以上项目超 80 个，投资金额合计超 4000 亿元。2023 年工业投资规模再创历史新高，实现增长超 30%。出台《深圳市关于新形势下加快工业企业技术改造升级的若干措施》，将重大项目支持金额上限提高至 1 亿元，推动 1200 余家企业开展技术改造。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="318" src="https://oscimg.oschina.net/oscnet/up-d1e0659e29ba6df8968fad30a54240bfb54.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#007aaa"><strong>九、国际星闪无线短距通信联盟落户河套，高水平产业创新平台加快打造</strong></span></p><p><span style="color:#595959">国际星闪无线短距通信联盟正式落户河套深港科技创新合作区，成为第二个注册地设立在深圳的国际性产业与标准组织。联盟已发布星闪芯片、测试仪表等产品，加快在智能汽车、智能家居、智能终端等领域推进产业化和国际化进程。新增 1 家国家级「双跨」平台、总数占全国十分之一，电子元器件和集成电路国际交易中心交易规模突破 500 亿元。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="357" src="https://oscimg.oschina.net/oscnet/up-56ac4a5cdf50607b2958f21ad8d17cac815.png" width="500" referrerpolicy="no-referrer"></p><p><strong><span style="color:#007aaa">十、中国—东盟新兴产业论坛成功举办，国际产业交流合作成效斐然</span></strong></p><p><span style="color:#595959">成功举办中国-东盟新兴产业论坛，来自东盟各国的 9 位部长、29 位东盟国家驻华使领馆代表以及相关国际组织、商协会、智库、企业共计 180 余位外方嘉宾参加盛会，共话新兴产业发展。发布《新兴产业合作倡议（深圳倡议）》，举办中国-东盟产业对接会（深圳），达成 20 项战略合作框架协议，意向合作金额超 50 亿元。延伸举办中国（深圳、香港）-东盟（吉隆坡）新兴产业对接会，深港携手「并船出海」，达成 22 项合作协议，签约金额超 100 亿元。</span></p><p><img height="640" src="https://oscimg.oschina.net/oscnet/up-3b53abdd29e47790a9ca14a4c7ddea89cdd.png" width="936" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 08 Jan 2024 09:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274769</guid>
            <link>https://www.oschina.net/news/274769</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[祝贺！openKylin 社区再次入选「科创中国」开源创新榜]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#333333">近日，由中国科协科学技术传播中心、中国计算机学会、中国通信学会和中国科学院软件研究所联合主办，CSDN 承办的</span><strong><span style="color:#333333">2023 年开源创新榜专家评审会</span></strong><span style="color:#333333">圆满落幕。</span><span style="color:#0060e8"><strong><span>openKylin 社区荣获「2023 开源创新榜」优秀开源社区奖，这也是 openKylin 社区<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MDc5MDU1OQ%3D%3D%26mid%3D2247488006%26idx%3D1%26sn%3D9829fb8b7f075f1239b239d4be35d36b%26chksm%3Dce205876f957d160ca609fd7c95b3f6698bd2fddacb2697724ae7a20292e6780bd3b7ba44906%26scene%3D21%23wechat_redirect" target="_blank">连续两年</a>入选该榜单。</span></strong></span></p><p style="text-align:center"><img alt="" height="1654" src="https://oscimg.oschina.net/oscnet/up-5a2d6ec6c333def9c35daa719508157beef.png" width="2339" referrerpolicy="no-referrer"></p><p><span style="color:#333333">2023 开源创新榜面向中国开源行业领域，评选具有创新性、贡献度和影响力的开源项目、社区、人物。突出「与时俱进、鼓励创新」的原则，旨在挖掘和推广我国在开源技术领域的优秀成果和先进经验。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#333333">相较于往年，2023 年开源创新榜在</span><strong><span style="color:#333333">权威性、公信力和专业度</span></strong><span style="color:#333333">方面均有显著提升。</span></p><ul><li><p style="margin-left:0; margin-right:0">权威性。主办单位新加入中国计算机学会、中国通信学会、中国科学院软件研究所，四家主办单位优势互补，共同推动榜单策划、征集申报、专家评审等工作重点。</p></li><li><p style="margin-left:0; margin-right:0">公信力。由王怀民院士担任评委会主任，指导组建了结构更加科学、领域更加全面的评审专家库，从中提名形成最终评审专家。</p></li><li><p style="margin-left:0; margin-right:0">专业度。围绕项目、社区、人物三大类别，四家主办单位打磨了更加客观、严谨、贴合实际的评审标准和更加开放、公平、科学的评审办法，在征集过程中公开标准细节，接受社会的意见反馈，形成良性循环。</p></li></ul><p>&nbsp;</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#333333">作为中国领先的开源操作系统根社区，openKylin 社区自成立以来便积极推动开源生态建设。截至目前，openKylin 社区已累计发布 6 个社区版本，下载量达 100 万+；聚合 400+家单位会员，涵盖操作系统、数据库、办公软件、CPU、GPU、整机、人工智能优势企业及高等院校；拥有 5700+位开发者，并累计成立 95 个 SIG 组开展技术研究与创新。广泛的产、学、研、用各领域力量加入社区共建之中，为操作系统根技术创新奠定智囊基础。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#333333">此次入选科创中国「开源创新榜」是对 openKylin 社区开源创新能力和行业影响力的高度肯定。未来，openKylin 也将保持初心，聚焦开源创新生态建设、为营造良好开源生态持续努力。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 08 Jan 2024 09:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274766</guid>
            <link>https://www.oschina.net/news/274766</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[CodeFuse 开源这半年]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="hjfgjkf.png" src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/98756342/1704681398439-ec399b89-4898-4a2c-94e5-3981b90ed95d.png?x-oss-process=image%2Fresize%2Cw_900%2Climit_0" width="900" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span>2023 年可以称得上是大模型元年，在过去的这一年里，大模型领域飞速发展，新的大模型纷纷涌现，基于大模型的新产品也吸引着大家的眼球，未来，这个领域又会给大家带来多少惊喜？</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span>蚂蚁也推出了自己的百灵代码大模型 CodeFuse，经历近半年内部打磨后，在 9 月正式对外开源。下面就让我们来看一下，在过去的半年里，CodeFuse 在开源方面取得了哪些进展？</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_1"></span><h2><span>一、让研发变得更简单</span></h2><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span>在大模型落地到多个场景的过程中，代码自动生成，成为技术实现的必要环节。在这一趋势下，蚂蚁集团基于百灵大模型，推出了蚂蚁百灵研发助手，帮助开发者自动生成代码、注释、测试用例等，提高研发效率。</span></p><p style="margin-left:0; margin-right:0"><br><span>CodeFuse 源于蚂蚁自身的开发场景及代码库沉淀，基于海量高质量代码数据和代码领域特色词表，和多任务微调技术 MFT，在蚂蚁一万多内部研发人员的日常编码、测试、运维等场景中，经过反复验证与迭代。当前，CodeFuse 从研发效能、DevOps 衍生到了企业 IT 智能化场景智能体的探索。同时，基于 CodeFuse，蚂蚁集团打造了代码大模型的完整工具链，包括：模型服务、风险防护、数据质量、平台工程。</span></p><p style="margin-left:0; margin-right:0"><br><span>2023 年中，CodeFuse 及其必要的工具链，面向技术社区开源开放，帮助社区开发人员在此之上作研究、评价和二次开发和训练。</span></p><p style="margin-left:0; margin-right:0"><br><span>目前，CodeFuse 在蚂蚁各部门落地支持 40 多种编程语言，10 多个主流 IDE 平台。整体采纳率 30%，代码通过 AI 占比 20%。比如，CodeFuse 在蚂蚁数字科技的 SOFAStack 云原生应用智能商业产品线全面融合，涵盖设计、研发、测试、运维等领域，形成从领域建模到智能运维端到端 Copilot 产品解决方案，提升了企业级应用的交付效率和质量，加速行业数字化降本增效。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_2"></span><h2><span>二、丰富的开源内容</span></h2><p style="margin-left:0; margin-right:0"><span>CodeFuse 的使命是开发专门设计用于支持整个软件开发生命周期的大型代码语言模型（Code LLMs），当前内容涵盖代码、运维、分析、测试、推理、评价六大方向。截止 2023.12.31，CodeFuse 已累计开源了 11 个代码仓库、4 个数据集、11 个大模型参数文件，总计关注/点赞数超过 3000、下载量超过 2.4 万，并有 1 篇论文已被接收，2 篇预影印在 Arxiv 上。</span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/276193/1704259197296-b8ea3135-7387-4a92-a84f-d02643811793.png" width="739" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h4_3"></span><h4><strong>1、代码 - MFTCoder 系列：</strong></h4><p>国际首个高精度、高效率、多任务、多模型支持、多训练算法，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FMFTCoder" target="_blank" rel="nofollow"><span>大模型代码能力微调框架</span></a><span>；多任务微调的技术细节已在 Arxiv 公布，可参考</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2311.02303" target="_blank" rel="nofollow"><span>MFTCoder 论文</span></a><span>，以及</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484188%26idx%3D1%26sn%3D27c9fe0e849f9f27eac588fda76574be%26chksm%3Dc139d02df64e593b2fcb9101cea55c4b78af5a6b4dd0f6518d7993bc864a36150ae438abc902%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>此前发布的文章</span></a></p><div><p style="margin-left:0; margin-right:0"><span>预训练语言模型可以在大量的文本数据上学习通用的语言模式和结构。通过运用无监督学习技术，模型可以基于前面的词序列来预测句子中的下一个词。然而，仅仅进行预训练并不能在特定的自然语言处理任务上取得高性能。因此，需要在特定任务的小型数据集上对预训练模型进行微调，以学习任务特定的特征并提高性能。微调过程使用监督学习技术将预训练模型适应到特定的任务上。将训练过程分为预训练和微调两个阶段，可以使自然语言处理模型充分发挥无监督学习和有监督学习的优势。</span></p><p style="margin-left:0; margin-right:0"><span>但是，需要注意的是，当模型的参数量巨大时，为每一个下游任务独立进行微调并部署将需要大量的资源。然而，是否存在一种方法可以让一个模型同时支持所有的下游任务呢？答案是肯定的，多任务微调（multitask fine-tuning，MFT）为解决这个问题提供了一种有效的途径。</span></p><p style="margin-left:0; margin-right:0"><span>多任务微调不仅能够节省资源，还能够带来其他优势。通过联合训练，模型可以学习到多个任务之间的特征和规律。相比于针对每一个任务单独进行微调，多任务微调能够更好地完成各种任务。同时，由于学习到的特征和规律是相互联系的，模型的泛化能力也会得到提高。这意味着，即使在面对未见过的任务时，模型也能够表现出色，因为它已经学习到了许多相关任务的特征和规律。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p></div><span id="OSC_h4_4"></span><h4>2、运维 - DevOps 系列：</h4><p>业界首个开源的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-DevOps-Model" target="_blank" rel="nofollow"><span>中文开发运维大模型</span></a><span>，能够帮助工程师回答在 DevOps 生命周期中遇到的问题，并提供通过检索增强生成、工具学习和沙盒环境来构建软件开发全生命周期的<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-chatbot" target="_blank" rel="nofollow"><span>AI 智能助手</span></a><span>；详细介绍可以参看此前文章<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484045%26idx%3D1%26sn%3D838d9de49922b0d04bcffb3efbeec4df%26chksm%3Dc139d1bcf64e58aa0c92696d74ccebc64281a9ed287f88333bdd139e34ee5e8d46726ef9cd6e%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>DevOps-Eval</span></a><span>、</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484350%26idx%3D1%26sn%3Dc9875496ec1b2c75f47db73986007a05%26chksm%3Dc139d08ff64e5999b5c55f727d1b98475cc50a328662b5c84d921fe8c45a477f452effc2c41f%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>DevOps-Model</span></a><span>、</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484642%26idx%3D1%26sn%3De7dde520532b0868d267cff5ff4bc449%26chksm%3Dc139d7d3f64e5ec53f110495dbefc8e1903c9f09e13c909b2d236b1808bb9683d034b065e007%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>DevOps-Chatbot</span></a></p><div><p style="margin-left:0; margin-right:0"><span>我们希望用户逐渐从各处资料查询、独立分散平台操作的传统开发运维模式转变到大模型问答的智能化开发运维模式，改变人们的开发运维习惯。</span></p><p style="margin-left:0; margin-right:0"><span>核心差异技术、功能点：</span></p><ul><li><span>智能调度核心： 构建了体系链路完善的调度核心，支持多模式一键配置，简化操作流程。</span></li><li><span>代码整库分析： 实现了仓库级的代码深入理解，以及项目文件级的代码编写与生成，提升了开发效率。</span></li><li><span>文档分析增强： 融合了文档知识库与知识图谱，通过检索和推理增强，为文档分析提供了更深层次的支持。</span></li><li><span>垂类专属知识： 为 DevOps 领域定制的专属知识库，支持垂类知识库的自助一键构建，便捷实用。</span></li><li><span>垂类模型兼容： 针对 DevOps 领域的小型模型，保证了与 DevOps 相关平台的兼容性，促进了技术生态的整合。</span></li></ul><p style="margin-left:0; margin-right:0"><span>依托于开源的 LLM 与 Embedding 模型，可实现基于开源模型的离线私有部署，此外，也支持 OpenAI API 的调用。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p></div><span id="OSC_h4_5"></span><h4><span>3、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-Query" target="_blank" rel="nofollow">分析 - CodeFuse-Query</a></span><span>：</span></h4><p><span style="color:#000000">基于查询的代码分析引擎，适合大规模、复杂的代码库分析场景。可参考论文<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2401.01571" target="_blank" rel="nofollow"><span>https://arxiv.org/abs/2401.01571</span></a><span>；详细介绍可以参看</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484536%26idx%3D1%26sn%3D2e985b431ff9bd219c93b97ce4f4f444%26chksm%3Dc139d749f64e5e5f96f248f99d18bc55a5cd75fcb58c7726f52cfd6cd131f640d09e7d0e122a%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>此前文章</span></a></p><div><p style="margin-left:0; margin-right:0"><span>CodeFuse-Query 的特点和优势可以概括为以下几点：</span></p><ul><li><span>高度可扩展：CodeQuery 可以处理大规模的代码库，且能够适应不同的分析需求。这种高度的可扩展性使得 CodeQuery 可以在大型组织中发挥重要作用。</span></li><li><span>以数据为中心：CodeQuery 将源代码和分析结果视作数据，这种以数据为中心的方法使其在处理大数据环境中的代码分析问题时具有独特优势。</span></li><li><span>高度集成：CodeQuery 能够无缝地融入大型组织的各种系统中，包括数据仓库、数据计算设施、对象存储和灵活计算资源等。这种高度的集成性使得 CodeQuery 在大型组织中的使用变得更加方便和高效。</span></li><li><span>支持多元化的需求：CodeQuery 不仅可以处理大规模的代码库，还可以应对各种复杂的分析需求，包括服务质量分析需求、跨编程语言分析需求、算法需求和性能需求等。</span><br> &nbsp;</li></ul></div><span id="OSC_h4_6"></span><h4><span>4、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FTest-Agent" target="_blank" rel="nofollow">测试 - Test-Agent</a></span><span>：</span></h4><p><span>测试领域的「智能体」，打造创新的测试领域解决方案，构建 24 小时在线的测试助理服务；详细介绍可以参看</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247483884%26idx%3D3%26sn%3Db92d3cbbe82c9487777f63ad6a38851b%26chksm%3Dc139d2ddf64e5bcb2246335bf6ee327900c789dbfead77bfc3c325a8a4854f5d50bd839eb8ad%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>此前文章</span></a></p><div><p style="margin-left:0; margin-right:0"><span>大模型的号角已经吹响，测试领域大模型也在不断进化中，通过预训练过程中积累的丰富世界知识，在复杂交互环境中展现出了非凡的推理与决策能力。</span></p><p style="margin-left:0; margin-right:0"><span>尽管在测试领域中，基础模型取得了显著的成果，但仍然存在一些局限性，特定领域的测试任务通常需要专业化的工具或领域知识来解决。例如，基础模型可以通过预训练知识完成单次测试代码生成和测试文本生成等任务，但处理复杂的集成用例生成、特定领域用例生成和测试流程 pipeline 交互等问题时，需要更专业的工具和领域知识。</span></p><p style="margin-left:0; margin-right:0"><span>因此将专用工具与基础模型整合在一起，可以充分发挥它们各自的优势。专用工具可以解决模型时效性不足、增强专业知识、提高可解释性和鲁棒性的问题。而基础模型则具备类人的推理规划能力，可以理解复杂的数据和场景，并与现实世界进行交互。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p></div><span id="OSC_h4_7"></span><h4><span>5、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-ModelCache%2Fblob%2Fmain%2FREADME_CN.md" target="_blank" rel="nofollow">推理 - ModelCache</a></span><span>：</span></h4><p><span>大模型语义缓存系统，通过缓存已生成的模型结果，降低类似请求的响应时间，提升用户体验；详细介绍可以参看</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484139%26idx%3D1%26sn%3Df6b0fbe4d4dc7b47759146de60a1c820%26chksm%3Dc139d1daf64e58ccd522435f3769c2dd5b1953b7974c5efbb53ef0f9247ae3c037428a1770bf%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>此前文章</span></a><span>。</span></p><div><p style="margin-left:0; margin-right:0"><span>当前大模型服务面临以下三个挑战：</span></p><ul><li><span>成本高：大模型参数量千亿级别，单实例就需要多张 A10 卡，规模化部署成本高昂。因此，当前大模型服务基本按照处理的 token 数量计费，导致用户侧使用成本也居高不下。</span></li><li><span>速度慢：大型模型的推理速度也是一个关键问题。在许多实时应用中，如对话系统、业务助手，响应时间要求非常高，通常在毫秒级别。然而，大型模型的推理速度往往较慢，在秒级，导致无法实时返回结果，用户体验下降。</span></li><li><span>稳定性无保障：由於单实例部署成本高昂，当前大模型服务接受到大流量请求时，通过限流的方式，防止服务不可用。</span></li></ul><p style="margin-left:0; margin-right:0"><span>针对上述挑战，引入大模型缓存可以解决当前问题：通过引入 Cache 机制，缓存已计算的结果，当接收到类似请求，可以直接从缓存获取结果，避免重复计算，节约计算资源，显著提升响应时间，提升用户体验；同时，缓存可以起到分流的作用，降低透传到后端的请求量，降低后端压力，提升服务稳定性。因此，Cache 作为一种重要的大模型服务部署解决方案，在资源有限和对实时性要求较高的场景下，可以帮助企业和研究机构更好地应用大型语言模型，提升模型性能和效率。未来，随着大型模型在各个领域的广泛应用，Cache 的重要性将不断凸显。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p></div><span id="OSC_h4_8"></span><h4><span>6、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-evaluation%2Fblob%2Fmaster%2FREADME_CN.md" target="_blank" rel="nofollow">评测 - CodeFuse-Evaluation</a></span><span>：</span></h4><p><span>在 HumanEval-x、MBPP 的基准上开发的编程领域多任务的评测基准， 可用于评估大模型在代码补全，自然语言生成代码，测试用例生成、跨语言代码翻译、中文指令生成代码等多类任务的性能；详细介绍可以参看</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484436%26idx%3D1%26sn%3D55ad2d46c2d6b8e9ef0d3e94201945b0%26chksm%3Dc139d725f64e5e331deb25933742bc70e9b608756059458bfa3700e16974711000ad20a32a86%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>此前文章</span></a><span>。</span></p><div><p style="margin-left:0; margin-right:0"><span>目前对于大语言模型评估的按照生成的结果是否可定量衡量比如数学计算和文章生成分为客观评测和主观评测。客观评测：基于业界影响力较高评测基准对生成内容进行各维度评估；主观评测：组织多位有专业背景知识的专家进行相关维度评估。</span></p><p style="margin-left:0; margin-right:0"><span>按照评测执行方式可分为自动化评测，人工评测和模型评测三类。</span></p><p style="margin-left:0; margin-right:0"><span>模型训练完成后，基于评估基准跑出评分，这个过程可以完全工程化的执行因此成为自动化评测。人工评测特别是领域知识需要着急各领域专家进行测评，此种方式评估成本较高但是评估结果更具有说服力。模型（如 PandaLM）评测模型即通过训练大模型学习到人类对不同生成文本的总体偏好，并作出基于习得的人类偏好的相对评价，这种评价方式相比人工更稳定、高效。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p></div><span id="OSC_h2_9"></span><h2><span>三、精彩的社区活动</span></h2><p style="margin-left:0; margin-right:0"><span>我们深知，开源不只是开放代码，还包括在社区的分享与交流。在开源内容上干货满满，社区活动定也不落下风，让我们看看都有哪些吧！！</span></p><p style="margin-left:0; margin-right:0"><span>8 月，我们在 AI+ 软件研发数字峰会上进行了专场分享《基于 AIGC 的测试生成》；</span></p><p style="margin-left:0; margin-right:0"><span>9 月，外滩大会上正式对外宣布 CodeFuse 开源；</span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/217410/1704420417098-5d63a0fa-ef73-4abe-8569-db04857eddef.png" width="540" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span>10 月，在 MLSummit 2023 上，对外分享了 CodeFuse 研发经验；</span></p><p style="margin-left:0; margin-right:0"><span>11 月初，在云栖大会上进行 CodeFuse 专题演讲；</span></p><p style="margin-left:0; margin-right:0"><span>11 月，和始智 AI 等联合举办了「代码大模型技术与应用发展」论坛；</span></p><p style="margin-left:0; margin-right:0"><span>12 月初，在 CCF 中国软件大会上，与参会者现场体验、互动交流；</span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/217410/1704420830670-62d284f9-b89c-4c3f-9f10-1bc174d4154e.png" width="480" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span>12 月末，在全球软件开发者大会 QCon 上经验分享《基于 CodeFuse 的下一代研发探索》。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_10"></span><h2><span>四、获得业界认可</span></h2><p style="margin-left:0; margin-right:0"><span>今年，CodeFuse 还获得了多个奖项，感谢业界的认可：</span></p><ul><li><span>荣获开源中国 2023 年度优秀开源技术团队</span></li></ul><p style="margin-left:0px; margin-right:0px; text-align:center"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/217410/1704420476632-42355276-1d79-46dd-bcb6-eb0c29a62311.png" width="540" referrerpolicy="no-referrer"></p><ul><li><span>入选极客公园 2023 大模型先锋案例 TOP10</span></li></ul><p style="margin-left:0px; margin-right:0px; text-align:center"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/217410/1704420452319-a2eabbe9-21a1-47e2-a54f-84d5fce1b04b.png" width="540" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:center">&nbsp;</p><span id="OSC_h2_11"></span><h2><span>五、2024 新的期待</span></h2><p style="margin-left:0; margin-right:0"><br><span>2023 年以来，大模型在代码领域落地不断深入。经过一年的实践，我们对相关的技术也有了更深层次的理解与认识。也看到了很多有趣的方向与落地实践。在 2024 新的一年里，我们还会继续深耕开源：</span></p><ul><li><span>更多创新功能发布，例如近期 1 月份将发布支持 MoE 的 MFTCoder v0.2; 2 月份将发布支持前端设计到代码的训练框架和模型；</span></li><li><span>更多的线下活动，会组织多次 CodeFuse 线下 meetup，欢饮感兴趣的同行多多参与；也会积极参与国内和国际行业会议/论坛更多分享 CodeFuse 的实践经验；</span></li><li><span>更多的社区参与和互动，会社区调研，让大家能够参与到项目中来；包括不限于发起社区一起捉虫、一起贡献新特性，推动相关体系的标准化，甚至组织相关比赛活动等。</span></li></ul><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span>非常欢迎大家能够跟我们一起交流探索，一起来定义下一代基于大模型的全生命周期研发解决方案。欢迎大家参与到我们社区中，一起探讨、交流。 2024，一起向未来！</span></p><p style="margin-left:0; margin-right:0"><span style="color:rgba(0, 0, 0, 0.9)">CodeFuse 官网：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcodefuse.alipay.com" rel="nofollow" target="_blank"><span style="color:#0080ff">https://codefuse.alipay.com</span></a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Mon, 08 Jan 2024 07:55:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6942768/blog/10678192</guid>
            <link>https://my.oschina.net/u/6942768/blog/10678192</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
    </channel>
</rss>
