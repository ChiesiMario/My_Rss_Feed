<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 30 Nov 2023 23:03:19 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Unity 裁员 265 人]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Unity 在 2021 年以 16.25 亿美元收购了 Peter Jackson 联合创办的视觉特效公司 Weta Digital 的工程技术部门，与美术部门 Weta FX 达成服务协议。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reuters.com%2Ftechnology%2Funity-software-cut-38-staff-company-reset-2023-11-28%2F" target="_blank">根据路透社的报道</a></u>，现在作为公司重组 (company reset) 的一部分它宣布<strong>终止服务协议裁掉相关的 265 名员工，约占员工总数的 3.8%</strong>。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1130/170155_SD5i_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>Unity 是规模最大的游戏引擎开发商，目前还有 7000 名员工。它同时宣布将关闭部分办事处，缩小办公面积，不再强制要求员工每周前往办公室工作三天。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">9 月份，Unity 宣布了新的收费规则，此举引起业内人士的强烈不满。之后 Unity 向公众和业内人士道歉，并调整了收费规则。</p><ul><li><u><em><a href="https://www.oschina.net/news/257929/unity-runtime-fee">Unity 引擎明年起根据游戏安装量收费 (runtime fee)</a></em></u></li><li><u><em><a href="https://www.oschina.net/news/258513/unity-apologize-for-runtime-fee">Unity 道歉：将修改 "runtime fee" 收费政策</a></em></u></li><li><u><em><a href="https://www.oschina.net/news/258477/wait-is-unity-allowed-to-just-change-its-fee-structure-like-that">走近 「收费门」：互相矛盾的服务条款导致 Unity 面临被起诉的风险</a></em></u></li></ul><p>Unity CEO John Riccitiello 上个月因受争议的运行时费用而<u><a href="https://www.oschina.net/news/261101/unity-ceo-john-riccitiello-is-retiring">离职</a></u>，前 IBM 总裁 Jim Whitehurst 担任临时 CEO，Whitehurst 表示为了重新专注于公司业务，更多的变化即将到来。虽然这对受影响的员工来说是一个挑战，但对于公司来说，这可能是一个重新调整和提高效率的机会。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 08:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268858/unity-software-cut-38-staff</guid>
            <link>https://www.oschina.net/news/268858/unity-software-cut-38-staff</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微软 2023 款丑毛衣：基于 WinXP 蓝天白云壁纸]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">Windows <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.windows.com%2Fwindowsexperience%2F2023%2F11%2F28%2Fwindows-brings-nostalgia-to-the-holidays-with-the-return-of-windows-ugly-sweaters-this-year-featuring-the-bliss-backdrop%2F" target="_blank">宣布</a>推出 2023 新款丑毛衣 (Windows Ugly Sweater)：基于经典 WinXP 系统中标志性的 Bliss 壁纸 —— 蓝天白云青草地。</span></p><p><span style="color:#000000">这张照片由摄影师 Charles O'Rear 在 1996 年拍摄于加利福尼亚州索诺玛县，微软在 2000 年以「不到六位数」的价格买下了版权。微软于 2018 年首次推出 Windows 丑毛衣，今年是连续推出的第 6 年。</span></p><p><span style="color:#000000">毛衣尺码涵盖 S-3XL，在微软 Xbox Gear Shop <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgear.xbox.com%2Fproducts%2Fwindows-merry-blissmas-knit-holiday-sweater" target="_blank">官网上限量发售</a>（目前已售罄）。售价在人民币 500 元左右，微软方面表示售出所得全部收益将捐给大自然保护协会。预计购买者将于 12 月 2 日至 17 日期间收到货。</span></p><p><span style="color:#000000"><img alt="" height="266" src="https://oscimg.oschina.net/oscnet/up-93a909038c76d1e72eb6c4f2167c779fde2.jpg" width="300" referrerpolicy="no-referrer"><img alt="" height="260" src="https://oscimg.oschina.net/oscnet/up-a1683a329b2c046f9927ac467d8e74448cd.jpg" width="300" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><img alt="" height="276" src="https://oscimg.oschina.net/oscnet/up-c476b2849bbc0f49e47b35265dbace5e969.jpg" width="275" referrerpolicy="no-referrer">&nbsp;<img alt="" height="276" src="https://oscimg.oschina.net/oscnet/up-44dd702c39368126e2e5e120bc91a44071b.jpg" width="300" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><img alt="" height="298" src="https://oscimg.oschina.net/oscnet/up-bbe8781e5f77acb8ce6d5bc96add615538c.jpg" width="300" referrerpolicy="no-referrer">&nbsp;<img alt="" height="302" src="https://oscimg.oschina.net/oscnet/up-7dc53486d194b5b6bebdb5e2dd92ae46c79.jpg" width="300" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">微软还发布了新版的 Bliss 壁纸，感兴趣的用户可前往&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgear.xbox.com%2Fpages%2Fwindows" target="_blank">Xbox Gear Shop</a><span style="background-color:#ffffff; color:#000000"><span>&nbsp;</span></span>进行下载。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 08:56:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268857/windows-2023-ugly-sweater</guid>
            <link>https://www.oschina.net/news/268857/windows-2023-ugly-sweater</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Roundcube 与 Nextcloud 合并]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">开源电子邮件项目&nbsp;Roundcube 已与 Nextcloud 完成合并。公告<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnextcloud.com%2Fblog%2Fopen-source-email-pioneer-roundcube-comes-aboard-nextcloud%2F" target="_blank">指出</a>，合并完成后的</span><span style="background-color:#ffffff; color:#121212">短期内计划是改进集成和加速开发，包括</span>扩展 Roundcube 团队，以及支持和​​发展贡献社区，邀请新人才来促进项目的发展和健康。</p><p><span style="background-color:#ffffff; color:#121212">除此之外，Roundcube 和 Nextcloud </span><span style="background-color:#ffffff; color:#050404">之间的直接合并尚未计划</span><span style="background-color:#ffffff; color:#121212">。</span><span style="color:#000000">Roundcube 不会取代 Nextcloud Mail，反之亦然。Nextcloud Mail 将按原计划发展，专注于在 Nextcloud 中的使用；Roundcube 则将继续作为独立的安全邮件客户端为其活跃用户和新用户提供服务。</span></p><p><span style="background-color:#ffffff; color:#121212">2024 年，Nextcloud 将持续投资<span>&nbsp;</span>Roundcube，对该项目进行调整和改进，以创建适合广大用户的完整产品。</span></p><p><span style="background-color:#ffffff; color:#121212"><img alt="" height="313" src="https://oscimg.oschina.net/oscnet/up-97ca74865ebcea22f7fe4d93ba5e30eb8af.webp" width="500" referrerpolicy="no-referrer"></span></p><blockquote><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">Roundcube 是一款多语言 IMAP 客户端，具有类似应用程序的用户界面，支持 MIME、地址簿、文件夹、邮件搜索和拼写检查。提供充分的安全和隐私保护，包括 PGP、XSS 抵御和暴力保护。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">Nextcloud&nbsp;是一套用于创建网络硬盘的客户端－服务器软件。其功能与 Dropbox 相近，但 Nextcloud 是自由及开放源代码软件，每个人都可以在私人服务器上安装并运行它。</span></p></blockquote><p><span style="color:#000000">Nextcloud 创始人&nbsp;Frank Karlitschek 称，「此次合并不仅彰显了开源社区的集体力量，还突出了我们对隐私、安全和用户授权的持久承诺。」</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnextcloud.com%2Fblog%2Fopen-source-email-pioneer-roundcube-comes-aboard-nextcloud%2F" target="_blank">查看官方公告</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 06:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268830/roundcube-comes-aboard-nextcloud</guid>
            <link>https://www.oschina.net/news/268830/roundcube-comes-aboard-nextcloud</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[为什么会有人去 DDoS 攻击 Blender？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#000000">Blender 上周发布</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.blender.org%2Fnews%2Fcyberattack-november-2023%2F" target="_blank">公告称</a><span style="background-color:#ffffff; color:#000000">，blender.org 网站在 2023 年 11 月 18 日至 23 日期间持续受到 DDoS 攻击，攻击者通过不断发送请求致使网站服务器超载而瘫痪，导致网站运营严重中断。除了 blender.org 主网站外，其他一些服务也无法使用。</span></p><blockquote><p><strong><em><u><a href="https://www.oschina.net/news/267990/blender-cyberattack-2023" target="_blank">Blender 连续 5 天遭受大规模 DDoS 攻击</a></u></em></strong></p></blockquote><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">该攻击由具有数百个 IP 地址的僵尸网络执行，发送超过 15 亿个恶意请求，峰值速率为 10 万 rps（每秒请求）。网站断断续续的可用了几天，但即使在攻击者暂停攻击的短时间内，Blender 的基础设施仍然因大量待处理的合法请求而超载，导致服务器难以跟上。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">在经过四天的抵御攻击之后 (11 月 21 日) 后，Blender 决定将其网站转移到了 CloudFlare，以减少攻击的影响。目前尚未有人声称对这次袭击负责，动机也未知。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img alt="up-affc1ae024c2e2724c7542ba5f0d983081b.png" src="https://oscimg.oschina.net/oscnet/up-affc1ae024c2e2724c7542ba5f0d983081b.png" referrerpolicy="no-referrer"></p><p>问题来了，为什么像 Blender 这样没有商业价值的网站也会遭遇 DDoS 攻击？</p><p>HN 上的一名网友<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D38454048" target="_blank">发表了自己的看法</a></u><strong>：提供 DDoS 服务的攻击者需要向黑市「展示」能力</strong>，以证明它们自己的能力。恰好，Blender 是一个理想的目标——知名度高，团队有技术专家，而且拥有足够的技术专业知识来发布和覆盘 DDoS 的详细信息。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3b538a86727834eae0b853e70980a29a231.png" referrerpolicy="no-referrer"></p><p>所以，并不是有人想要伤害 Blender 本身，只是 DDoS 服务供应商/骇客组织想要公开展示自己并宣传他们的服务。刚好这次 Blender 被选中了。</p><p>对于「无辜」的开源项目（如 Blender）受到无端攻击，各位有什么看法？欢迎在评论区讨论交流。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 06:13:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268827</guid>
            <link>https://www.oschina.net/news/268827</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[工信部印发《2023 年 5G 工厂名录》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#333333">工业和信息化部近日印发《</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fzwgk%2Fzcwj%2Fwjfb%2Ftz%2Fart%2F2023%2Fart_53532488d3394047b85116f5b29b3e32.html" target="_blank">2023 年 5G 工厂名录</a><span style="background-color:#ffffff; color:#333333">》。</span></p><blockquote><p><span style="color:#070707">为深入推进「5G+工业互联网」创新发展，打造 5G 工厂中国品牌，各地依据《5G 全连接工厂建设指南》（工信厅信管〔2022〕23 号）加快推动 5G 工厂建设，取得积极成效。经省级工业和信息化主管部门、通信管理局推荐，工业互联网战略咨询专家委评审以及公示等程序，确定了 2023 年 5G 工厂名录，现予以公布。</span></p></blockquote><p><span style="color:#070707"><img alt="" height="4404" src="https://oscimg.oschina.net/oscnet/up-5a849aef64cd677596498f4b34767f9b5b8.jpg" width="500" referrerpolicy="no-referrer"></span></p><hr><h4 style="margin-left:0px; margin-right:0px"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fzwgk%2Fzcjd%2Fart%2F2023%2Fart_1741388b2be2476b819199c8b1127b5e.html" target="_blank"><strong>一图读懂《2023 年 5G 工厂名录》</strong></a></h4><p style="margin-left:0px; margin-right:0px"><strong><img alt="" height="5541" src="https://oscimg.oschina.net/oscnet/up-3998b1700458d5f0a87e0f258eb9f38c9dc.jpg" width="500" referrerpolicy="no-referrer"></strong></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 03:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268811</guid>
            <link>https://www.oschina.net/news/268811</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[苹果每台设备的 Arm 专利费比塑料薄膜还便宜]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theinformation.com%2Farticles%2Fhow-a-lopsided-apple-deal-got-under-arms-skin">根据 The Information 的报道</a></u>，苹果每年销售数亿部 iPhone、iPad、Mac 和 Apple Watch 和其他使用 Arm 芯片的智能设备，但每台设备只向 Arm 支付不到 30 美分（约合人民币 2.15 元）的版权专利费用。</p><blockquote><p><img height="736" src="https://static.oschina.net/uploads/space/2023/1130/105919_wrxb_2720166.png" width="1768" referrerpolicy="no-referrer"></p></blockquote><p><strong>在所有获得 Arm 授权的芯片设计公司里，苹果支付的费率最低，每年支付的费用不到 Arm 收入的 5%。相比之下，Arm 最大的两个客户高通和联发科，支付的费用比苹果高一倍</strong>。</p><p>这种不平衡的交易对于 Arm 来说是一个问题，因为它无法从苹果这个重要客户那里获得足够的收入。文章提到，软银首席执行官孙正义曾在 2017 年的一次会议上向 Arm 的高管们抱怨苹果的低费用，并以 iPhone 上的塑料保护膜来强调这一观点——孙正义告诉与会者，<strong>苹果为保护新 iPhone 屏幕的塑料薄膜支付的费用比为 Arm 知识产权授权的费用还要高</strong>。</p><p>然而，多年过去了，这个问题仍然存在。</p><p>据了解，软银集团在 2016 年收购 Arm 时，首席执行官孙正义希望能重新谈判并提高费率，不过并没有成功。Arm 最初是由多家科技公司投资的合资企业，苹果是其创始成员之一，未来双方也没有分开的打算。</p><p>Arm 递交的美国 IPO 文件显示：苹果公司与 Arm 就芯片技术签署新版长期性协议，「双边合作关系将延续至 2040 年之后」。远远超过科技领域通常的五年期限。</p><p>除了 Arm 架构外，苹果也在研究开源的 RISC-V 架构，过往曾有发布相关的招聘信息。一方面 RISC-V 架构不需要支付任何专利费，可进一步降低成本，另一方面可以作为与 Arm 等其他公司合作的筹码。从目前情况来看，苹果和 Arm 复杂的合作关系可能会持续数十年。</p><ul><li><u><em><a href="https://www.oschina.net/news/158746/apple-looking-for-risc-v-programmers">苹果正在招聘 RISC-V 开发者</a></em></u></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268797</guid>
            <link>https://www.oschina.net/news/268797</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[幻方量化旗下 DeepSeek 发布 67B 开源大模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">知名私募巨头幻方量化<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZj7gPGqJ8UTTxp1umfWjKQ" target="_blank">宣布</a>，其探索 AGI（通用人工智能）的新组织「深度求索（DeepSeek）」继 11 月初发布 Coder 代码模型之后，正式发布通用大语言模型：DeepSeek LLM 67B。模型已完全开源，同时服务已经全面开放内测。</span></p><p><span style="color:#000000">目前 DeepSeek 已同时开源 7B 和 67B 的两种规模模型，均含基础模型（base）和指令微调模型（chat）。无需申请，免费商用。同时，项目团队还将训练中途的 9 个模型 checkpoints 开放下载。</span></p><p><span style="color:#000000">相比开源的同级别模型 LLaMA2 70B，DeepSeek LLM 67B 在近 20 个中英文的公开评测榜单上表现更佳。尤其突出的是推理、数学、编程等能力（如：HumanEval、MATH、CEval、CMMLU）。</span></p><p><img height="412" src="https://oscimg.oschina.net/oscnet/up-90b96f11cad1cebc1a6f8ed065af941752e.png" width="500" referrerpolicy="no-referrer"></p><p><img height="418" src="https://oscimg.oschina.net/oscnet/up-b18e003f54e25e5fcb9112b2733d0c1afc3.png" width="500" referrerpolicy="no-referrer">&nbsp;</p><p><img height="418" src="https://oscimg.oschina.net/oscnet/up-ae3911e345f12b177ff22551b6f2adfd615.png" width="500" referrerpolicy="no-referrer"></p><p><img height="432" src="https://oscimg.oschina.net/oscnet/up-fb75c7324ae7131702fad2abdc8a6f96af6.png" width="500" referrerpolicy="no-referrer"></p><p><img height="288" src="https://oscimg.oschina.net/oscnet/up-2f23eeacbc701e424120f6c2507412d23de.png" width="500" referrerpolicy="no-referrer"></p><p><img height="418" src="https://oscimg.oschina.net/oscnet/up-4e497e6c1d9e0cb35dfd6f064c7ad2f7ea0.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:25:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268792</guid>
            <link>https://www.oschina.net/news/268792</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[助力 AI 开发，openKylin AI 框架安装助手正式发布！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0; margin-right:0; text-align:justify"><span>当前，以大模型为代表的人工智能技术迅猛发展，成为全球技术焦点，越来越多的开发者投入到人工智能技术的学习和应用中。AI 框架是 AI 算法模型设计、训练和验证的一套标准接口、特性库和工具包，集成了算法的封装、数据的调用以及计算资源的使用，同时面向开发者提供了开发界面和高效的执行平台，是现阶段 AI 算法开发的必备工具。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span>目前在操作系统上安装 AI 框架并不是件容易的事情，需要安装合适的显卡驱动、加速工具、依赖软件以及配置系统环境等。每一个环节出问题都会导致 AI 框架安装失败。</span><strong><span>为了让 AI 开发者能够更快的投入到算法设计和 AI 开发当中，openKylin 社区 AI4OS SIG 组开发了 AI 框架安装助手</span></strong><strong><span>，助力 AI 开发者实现一键安装 AI 框架</span></strong><span>。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span>AI 框架安装助手采用前后端分离架构：前端负责检测系统硬件，自动推荐安装方式，提供安装选择，获取安装选项，显示安装信息及进度；后端执行具体任务并向前端及时反馈信息。该架构提高了开发效率、可维护性和可扩展性，同时也提供了更好的用户体验。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><strong><span>openKylin AI 框架安装助手具有以下特点：</span></strong></p><ol><li><span style="color:#0052ff"><strong>智能推荐</strong></span>，用户只需选择需要安装的 AI 框架，应用根据系统硬件智能推荐最佳安装方式，同时支持用户选择。</li><li><span style="color:#0052ff"><strong>一键自动</strong></span>，软件自动安装最适合的硬件驱动，加速工具，依赖软件，并且配置好系统环境。免去了繁复的安装过程和系统环境配置。</li><li><span style="color:#0052ff"><strong>无需值守</strong></span>，由于网络等原因造成的安装失败，能自动恢复继续安装。</li><li><span style="color:#0052ff"><strong>过程可见</strong></span><span>，软件显示安装的各个步骤，以及各个步骤的进度等信息。</span></li><li><span style="color:#0052ff"><strong>节省资源</strong></span><span>，支持资源断点继续下载，过程断点继续安装。</span></li><li><span style="color:#0052ff"><strong><span>支持</span>热更新</strong></span><span>，确保能及时更新 AI 框架版本以及安装方式，同时能以最快的速度解决软件可能存在的 BUG。</span></li><li><span style="color:#0052ff"><strong>界面友好</strong></span><span>，采用简洁、直观的 AI 框架选项，并提供良好的安装过程反馈。</span></li></ol><p style="text-align:center"><img alt="" height="1800" src="https://oscimg.oschina.net/oscnet/up-e6dc32eede425550f426b66a8c26400aaee.png" width="2880" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>目前，openKylin AI 框架安装助手已上架至软件商店。后续，AI4OS SIG 也将持续开发，优化 openKylin AI 框架安装助手交互界面、支持更多主流 AI 框架及其套件等等，紧跟人工智能技术发展的潮流，更好地助力 AI 开发者！</span></p><p><span>AI4OS SIG 致力于为 openKylin 社区适配主流的 AI 框架，同时将人工智能（AI）与操作系统（OS）相结合，以实现 openKylin 操作系统的智能化和性能优化，欢迎感兴趣的小伙伴加入！</span></p><ul><li><p style="margin-left:0; margin-right:0; text-align:justify"><span>项目地址：</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#0052ff">https://gitee.com/openkylin/ai-frame-installer</span></p></li><li><p><span>AI4OS SIG 主页：</span></p><p><span style="color:#0052ff">https://gitee.com/openkylin/community/tree/master/sig/AI4OS</span></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268789</guid>
            <link>https://www.oschina.net/news/268789</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 正式宣布 Sam Altman 回归担任 CEO]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenAI 今天<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Fblog%2Fsam-altman-returns-as-ceo-openai-has-a-new-initial-board">正式宣布</a></u>，Sam Altman 回归 OpenAI 担任 CEO 一职。与此同时，Mira Murati 仍将继续担任 CTO 一职，Greg Brockman 也将继续担任 OpenAI 总裁。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a1347c1ff57c70bc945b594b050d3a5203b.png" referrerpolicy="no-referrer"></p><p>此外，OpenAI 成立全新董事会，董事会主席由 Bret Taylor 担任。其他的董事会成员还包括 Larry Summers 以及 Adam D'Angelo。</p><p>Ilya Sutskever 、Tasha McCauley 以及 Helen Toner 将退出董事会。不过 Sam Altman 表示，<strong>正在讨论如何让 Ilya Sutskever 继续在 OpenAI 工作</strong>。</p><p>OpenAI 还让微软以「<strong>无投票权观察员</strong>」的身份加入董事会，他们将有更多机会了解公司的内部运作，但在重大决策中没有正式投票权。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:17:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268788/altman-returns-as-ceo-openai-has-a-new-initial-board</guid>
            <link>https://www.oschina.net/news/268788/altman-returns-as-ceo-openai-has-a-new-initial-board</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[MobSlide —— 将智能手机变成演示文稿遥控器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>MobSlide 是一个可将你的将智能手机变成演示文稿遥控器的工具。</p><p><img alt="" height="225" src="https://static.oschina.net/uploads/space/2023/1122/142007_UPpG_4252687.png" width="300" referrerpolicy="no-referrer">&nbsp;<img alt="" height="225" src="https://static.oschina.net/uploads/space/2023/1122/142018_XS3R_4252687.png" width="300" referrerpolicy="no-referrer"></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>适用于 MacOS 和 Windows。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Tauri for Linux 不支持 webrtc，因此目前不支持 Linux</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>用法</strong></p><p><span style="background-color:#ffffff; color:#1f2328">使用智能手机扫描二维码并打开链接。</span></p><p><img alt="" height="225" src="https://static.oschina.net/uploads/space/2023/1122/141937_4l9Z_4252687.png" width="300" referrerpolicy="no-referrer"></p><p><strong>特性：</strong></p><ul><li>扫描二维码。无需安装</li><li>轻量级应用程序<code>~2.5M</code></li><li>简约而有效的设计</li></ul></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:16:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/mobslide</guid>
            <link>https://www.oschina.net/p/mobslide</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 内存型消息中间件 FolkMQ]]>
            </title>
            <description>
                <![CDATA[<h1 align="center"><a id="user-content---folkmq" class="anchor" href="https://gitee.com/noear/folkmq#--folkmq"></a>
  FolkMQ
</h1><p align="center"><strong>一个内存型消息中间件（支持快照持久化、Broker 集群），目前为预览阶段</strong></p><p align="center"><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fsearch.maven.org%2Fartifact%2Forg.noear%2Ffolkmq"><img src="https://img.shields.io/maven-central/v/org.noear/folkmq.svg?label=Maven%20Central" alt="Maven" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.apache.org%2Flicenses%2FLICENSE-2.0.txt"><img src="https://img.shields.io/:license-Apache2-blue.svg" alt="Apache 2" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjavase-jdk8-downloads.html"><img src="https://img.shields.io/badge/JDK-8-green.svg" alt="jdk-8" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk11-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-11-green.svg" alt="jdk-11" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk17-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-17-green.svg" alt="jdk-17" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk21-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-21-green.svg" alt="jdk-21" referrerpolicy="no-referrer"></a><br><a target="_blank" href="https://gitee.com/noear/folkmq/stargazers"><img src="https://gitee.com/noear/folkmq/badge/star.svg" alt="gitee star" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fnoear%2Ffolkmq%2Fstargazers"><img src="https://img.shields.io/github/stars/noear/folkmq.svg?logo=github" alt="github star" referrerpolicy="no-referrer"></a></p><br><p align="center"><a href="https://gitee.com/link?target=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3DkjB5JNiC"><img src="https://img.shields.io/badge/QQ%E4%BA%A4%E6%B5%81%E7%BE%A4-870505482-orange" referrerpolicy="no-referrer"></a></p><hr><h2><a id="user-content-简介" class="anchor" href="https://gitee.com/noear/folkmq#%E7%AE%80%E4%BB%8B"></a>简介</h2><ul><li>采用，类似 Redis 的策略（内存运行 + 快照持久化）</li><li>功能，订阅、取消订阅、发布消息、发布定时消息、ACK，自动重试、延时策略、Qos0、Qos1</li><li>集群，采用 Socket.D Broker 集群模式</li><li>支持，使用 ws,udp 通讯（或许，也可用于物联网）</li></ul><h2><a id="user-content-特点" class="anchor" href="https://gitee.com/noear/folkmq#%E7%89%B9%E7%82%B9"></a>特点</h2><ul><li>快、是真的快（大约 100_000 TPS）。有点像 Redis 之于 MySql。</li></ul><img src="https://gitee.com/noear/folkmq/raw/main/DEV-TEST.png" width="600" referrerpolicy="no-referrer"><p>//使用 MacBook pro 2020 + JDK8 本机测试，单客户端发与收（跑分难免有波动，我是选了好看点的）</p><ul><li>简单的管理后台</li></ul><img src="https://gitee.com/noear/folkmq/raw/main/DEV-PREVIEW.png" width="600" referrerpolicy="no-referrer"><h3><a id="user-content-加入到社区交流群" class="anchor" href="https://gitee.com/noear/folkmq#%E5%8A%A0%E5%85%A5%E5%88%B0%E7%A4%BE%E5%8C%BA%E4%BA%A4%E6%B5%81%E7%BE%A4"></a>加入到社区交流群</h3><table><thead><tr><th>QQ 交流群：316697724</th><th>微信交流群（申请时输入：FolkMQ）</th></tr></thead><tbody><tr><td></td><td><img src="https://gitee.com/noear/folkmq/raw/main/group_wx.png" width="120" referrerpolicy="no-referrer"></td></tr></tbody></table><h2><a id="user-content-开发过程视频记录" class="anchor" href="https://gitee.com/noear/folkmq#%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%A7%86%E9%A2%91%E8%AE%B0%E5%BD%95"></a>开发过程视频记录</h2><ul><li>开发过程视频：<a href="https://gitee.com/noear/folkmq/blob/main/DEV-RECORD.md">《DEV-RECORD.md》</a></li><li>成果展示：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1mc411D7pY%2F">《[FolkMQ] 一个新的内存型消息队列（快，特别的快）》</a></li><li>快速入门：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1Yj411L7fB%2F">《FolkMQ - Helloworld 入门》</a></li></ul><h2><a id="user-content-服务端容器镜像" class="anchor" href="https://gitee.com/noear/folkmq#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F"></a>服务端容器镜像</h2><table><thead><tr><th>镜像</th><th>说明</th></tr></thead><tbody><tr><td>noearorg/folkmq-server:1.0.10</td><td>服务端（主端口：8602，消息端口：18602）</td></tr><tr><td>noearorg/folkmq-broker:1.0.10</td><td>服务端（主端口：8602，消息端口：18602）</td></tr></tbody></table><p>当使用 broker 集群时，把 folkmq-server 端口改成：8601</p><ul><li>可选配置</li></ul><table><thead><tr><th>属性或环境变量</th><th>默认值</th><th></th></tr></thead><tbody><tr><td><code>server.port</code></td><td>8602</td><td>主端口 (http，管理用)</td></tr><tr><td></td><td>18602</td><td>消息端口 (tcp)，等于主端口+10000</td></tr><tr><td><code>folkmq.admin</code></td><td>admin</td><td>管理密码</td></tr></tbody></table><ul><li>添加消息访问账号：</li></ul><p>添属性或环境变量，例： <code>folkmq.access.ak1=sk1</code>，<code>folkmq.access.ak2=sk2</code></p><h2><a id="user-content-helloworld" class="anchor" href="https://gitee.com/noear/folkmq#helloworld"></a>Helloworld</h2><h3><a id="user-content-1 启动服务-更多部署参考部署说明" class="anchor" href="https://gitee.com/noear/folkmq#1%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1-%E6%9B%B4%E5%A4%9A%E9%83%A8%E7%BD%B2%E5%8F%82%E8%80%83%E9%83%A8%E7%BD%B2%E8%AF%B4%E6%98%8E"></a>1、启动服务 (更多部署参考：<a href="https://gitee.com/noear/folkmq/blob/main/deploy">部署说明</a>)</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker run -p 18602:18602 -p 8602:8602 noearorg/folkmq-server:1.0.10 </span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-2 编写客户端代码" class="anchor" href="https://gitee.com/noear/folkmq#2%E7%BC%96%E5%86%99%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"></a>2、编写客户端代码</h3><ul><li>maven import</li></ul><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;dependencies&gt;</span></span><span id="LC2" class="line"><span class="c">&lt;!-- 可选包：java-tcp（90kb 左右）, smartsocket（260Kb 左右）, netty（2.5Mb 左右） --&gt;</span></span><span id="LC3" class="line"><span class="nt">&lt;dependency&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;groupId&gt;</span>org.noear<span class="nt">&lt;/groupId&gt;</span></span><span id="LC5" class="line"><span class="nt">&lt;artifactId&gt;</span>folkmq-transport-java-tcp<span class="nt">&lt;/artifactId&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;version&gt;</span>1.0.10<span class="nt">&lt;/version&gt;</span></span><span id="LC7" class="line"><span class="nt">&lt;/dependency&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;/dependencies&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><ul><li>client(consumer + producer) use</li></ul><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">public</span><span class="kd">class</span><span class="nc">ClientDemo1</span><span class="o">{</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kd">static</span><span class="kt">void</span><span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span><span class="n">args</span><span class="o">)</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC3" class="line"><span class="c1">//客户端（鉴权为可选。服务端，不添加则不鉴权）</span></span><span id="LC4" class="line"><span class="nc">MqClient</span><span class="n">client</span><span class="o">=</span><span class="nc">FolkMQ</span><span class="o">.</span><span class="na">createClient</span><span class="o">(</span><span class="s">"folkmq://127.0.0.1:18602?ak=folkmq&amp;sk=YapLHTx19RlsEE16"</span><span class="o">)</span></span><span id="LC5" class="line"><span class="o">.</span><span class="na">connect</span><span class="o">();</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="c1">//订阅（consumer = ip or cluster name）</span></span><span id="LC8" class="line"><span class="n">client</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="s">"demo"</span><span class="o">,</span><span class="s">"demoapp"</span><span class="o">,</span><span class="n">message</span><span class="o">-&gt;</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">);</span></span><span id="LC10" class="line"><span class="o">});</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">//发布</span></span><span id="LC13" class="line"><span class="n">client</span><span class="o">.</span><span class="na">publish</span><span class="o">(</span><span class="s">"demo"</span><span class="o">,</span><span class="s">"helloworld!"</span><span class="o">).</span><span class="na">get</span><span class="o">();</span></span><span id="LC14" class="line"><span class="o">}</span></span><span id="LC15" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-自动重试与延时策略" class="anchor" href="https://gitee.com/noear/folkmq#%E8%87%AA%E5%8A%A8%E9%87%8D%E8%AF%95%E4%B8%8E%E5%BB%B6%E6%97%B6%E7%AD%96%E7%95%A5"></a>自动重试与延时策略</h2><table><thead><tr><th>派发次数</th><th>自动延时</th><th></th></tr></thead><tbody><tr><td>0</td><td>0s</td><td>相当于马上发</td></tr><tr><td>1</td><td>5s</td><td></td></tr><tr><td>2</td><td>30s</td><td></td></tr><tr><td>3</td><td>3m</td><td></td></tr><tr><td>4</td><td>9m</td><td></td></tr><tr><td>5</td><td>15m</td><td></td></tr><tr><td>6</td><td>30m</td><td></td></tr><tr><td>7</td><td>1h</td><td></td></tr><tr><td>n..</td><td>2h</td><td>第 8 次之后都是 2 小时</td></tr></tbody></table><h2><a id="user-content-客户端接口字典" class="anchor" href="https://gitee.com/noear/folkmq#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%8F%A3%E5%AD%97%E5%85%B8"></a>客户端接口字典</h2><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">//消息客户端接口</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kd">interface</span><span class="nc">MqClient</span><span class="o">{</span></span><span id="LC3" class="line"><span class="c1">//连接</span></span><span id="LC4" class="line"><span class="nc">MqClient</span><span class="nf">connect</span><span class="o">()</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC5" class="line"></span><span id="LC6" class="line"><span class="c1">//断开连接</span></span><span id="LC7" class="line"><span class="kt">void</span><span class="nf">disconnect</span><span class="o">()</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">//客户端配置</span></span><span id="LC10" class="line"><span class="nc">MqClient</span><span class="nf">config</span><span class="o">(</span><span class="nc">ClientConfigHandler</span><span class="n">configHandler</span><span class="o">);</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">//自动回执</span></span><span id="LC13" class="line"><span class="nc">MqClient</span><span class="nf">autoAcknowledge</span><span class="o">(</span><span class="kt">boolean</span><span class="n">auto</span><span class="o">);</span></span><span id="LC14" class="line"></span><span id="LC15" class="line"><span class="c1">//订阅主题</span></span><span id="LC16" class="line"><span class="kt">void</span><span class="nf">subscribe</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">consumer</span><span class="o">,</span><span class="nc">MqConsumeHandler</span><span class="n">consumerHandler</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC17" class="line"></span><span id="LC18" class="line"><span class="c1">//取消订阅主题</span></span><span id="LC19" class="line"><span class="kt">void</span><span class="nf">unsubscribe</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">consumer</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC20" class="line"></span><span id="LC21" class="line"><span class="c1">//发布消息</span></span><span id="LC22" class="line"><span class="k">default</span><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">{</span></span><span id="LC23" class="line"><span class="k">return</span><span class="nf">publish</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span><span class="n">content</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span></span><span id="LC24" class="line"><span class="o">}</span></span><span id="LC25" class="line"></span><span id="LC26" class="line"><span class="c1">//发布消息</span></span><span id="LC27" class="line"><span class="k">default</span><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">,</span><span class="kt">int</span><span class="n">qos</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">{</span></span><span id="LC28" class="line"><span class="k">return</span><span class="nf">publish</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span><span class="n">content</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="n">qos</span><span class="o">);</span></span><span id="LC29" class="line"><span class="o">}</span></span><span id="LC30" class="line"></span><span id="LC31" class="line"><span class="c1">//发布消息</span></span><span id="LC32" class="line"><span class="k">default</span><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">,</span><span class="nc">Date</span><span class="n">scheduled</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">{</span></span><span id="LC33" class="line"><span class="k">return</span><span class="nf">publish</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span><span class="n">content</span><span class="o">,</span><span class="n">scheduled</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span></span><span id="LC34" class="line"><span class="o">}</span></span><span id="LC35" class="line"></span><span id="LC36" class="line"><span class="c1">//发布消息</span></span><span id="LC37" class="line"><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">,</span><span class="nc">Date</span><span class="n">scheduled</span><span class="o">,</span><span class="kt">int</span><span class="n">qos</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC38" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div>]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/noear/folkmq</guid>
            <link>https://gitee.com/noear/folkmq</link>
        </item>
        <item>
            <title>
                <![CDATA[关于 deepin V23 的发热、续航问题，我们做了电源配置优化]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>之前一些用户反馈，在使用 deepin （深度）操作系统过程中遇到了 CPU 功耗过高导致的设备发热、续航较差情况，而在这些负载场景下，CPU 的占用往往不高。为了解决这个痛点，deepin 团队特别成立专项计划，对于 deepin 的电源进行专项优化。</p><p>在对电源进行专项优化之前，首先对 deepin （深度）操作系统进行了深入调查和分析，以了解其在负载场景下的实际运行情况。</p><p>经过对 CPU 使用率和功耗的监测，我们发现了一个令人惊讶的事实：尽管在高负载场景下 CPU 的占用率不高，但其功耗却持续升高，最终导致设备发热并影响续航。也就是说，我们前期做的省电优化工作，不仅无效，还起了反作用。那么到底该如何解决这一问题呢？</p><p>在刚刚结束的 DDUC 2023 上，deepin（深度）社区用户 fslong 从社区参与共创的角度，分享了帮助 deepin 团队一起完成优化工作的故事。那么，本文就让我们从 deepin 团队研发工程师的角度来回顾解决这一问题的历程吧！</p><h2><strong>&nbsp;找到问题的根源&nbsp;</strong></h2><p><strong>1.内核</strong><br> 最开始发现问题的地方在内核。有用户将 deepin 的内核和 Ubuntu 的内核进行对比后发现，虽然二者性能相差无几，但是在发热和续航上，较 Ubuntu 落后较多。有用户在 deepin （深度）操作系统上使用 Ubuntu 和其他开源 Linux 发行版的配置文件分别编译内核，发现 deepin 的主要问题在于发热控制上。deepin 团队的测试伙伴高度重视这一社区反馈，对该问题进行复现，佐证了这一现象。</p><p>于是，我们立即联系了内核研发的伙伴，并邀请部分对内核配置有一定研究的社区用户共同参与，合力排查后发现，deepin V23 中提供的 HWE 内核存在部分 debug 和无用的内核选项被开启的情况，并且部分节电功能实际未能获得启用，这些都在一定程度上导致了 deepin V23 的续航表现不佳。</p><p><strong>2. 系统</strong><br> 系统层面，重新审视了 dde-daemon 提供的电源调度模块，并且对比内核文档提供的文件接口，分析用户使用的电源模式，发现其中存在可以优化的空间。这是本文着重讲解的内容之一。</p><h2><strong>一些前置知识&nbsp;</strong></h2><h3><strong>1.ACPI</strong></h3><p>ACPI（Advanced Configuration and Power Interface）是一种计算机硬件和操作系统之间交换能源相关信息的接口规范。它定义了计算机硬件的能源相关信息，如电源供应器状态、设备功耗、设备功率因数等。ACPI 是操作系统控制计算机硬件能源管理的标准，同时也是硬件厂商和操作系统之间通信的标准。<br> 在 deepin （深度）操作系统中，ACPI 负责处理计算机硬件的能源管理，与电源管理模块进行交互，以实现对计算机硬件的能源管理。</p><p>在分析系统层面的问题时，需要了解 ACPI 和电源管理模块的作用和功能，以及它们是如何协同工作的。本文将会详细讲解 ACPI 的工作原理以及 deepin （深度）操作系统中的电源调度模块工作模式，并提出可行优化建议。</p><p>ACPI 的工作原理是：当计算机硬件发生电源变化时，ACPI 会收集硬件信息，并向操作系统发送电源请求。操作系统收到电源请求后，会根据用户配置自动调整各个硬件的电源策略。</p><p>deepin （深度）操作系统的电源模块则是帮助用户生成配置来调整 ACPI 的行为。所以在这一方面，我们能做的就是向 ACPI 提供合理的电源策略，在保证性能的同时，降低设备温度并提升续航表现。</p><h3><strong>2.平台电源配置</strong></h3><p>相关内核文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.kernel.org%2Fuserspace-api%2Fsysfs-platform_profile.html" target="_blank">https://docs.kernel.org/userspace-api/sysfs-platform_profile.html</a></p><p>UEFI ACPI 文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fuefi.org%2Fhtmlspecs%2FACPI_Spec_6_4_html%2Findex.html" target="_blank">https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/index.html</a></p><p>平台电源配置是电源管理模块的重要组成部分，用于管理计算机平台硬件（指所有支持 ACPI 的设备）的电源状态。CPU 也属于 ACPI 设备的一部分，不过 CPU 是计算机的核心发热大户，对于其使用平台电源管理可能粒度较粗，所以 APCI 引入了一些 CPU 独有的性能管理方式，在下一小节将详细说明。</p><p>平台电源配置提供了三种可选模式：performance（性能模式），balance（平衡模式），low-power（节能模式）。一般情况下，用户使用平衡模式就可以。在台式机和 mini 主机类（对于功耗和发热没有任何要求）设备上默认提供性能模式，在笔记本等移动设备上默认提供平衡模式。默认不提供节能模式，因为某些 ACPI 设备在节能模式工作过程中可能出现「睡死现象」，所以为了避免此问题，默认不提供 low-power 节电模式。</p><h3><strong>3.CPU 电源配置</strong></h3><p>传统电源模式（SCalling）内核文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.kernel.org%2Fdoc%2Fhtml%2Fv6.1%2Fadmin-guide%2Fpm%2Fcpufreq.html" target="_blank">https://www.kernel.org/doc/html/v6.1/admin-guide/pm/cpufreq.html</a></p><p>Intel PState 内核文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.kernel.org%2Fdoc%2Fhtml%2Fv6.1%2Fadmin-guide%2Fpm%2Fintel_pstate.html" target="_blank">https://www.kernel.org/doc/html/v6.1/admin-guide/pm/intel_pstate.html</a></p><p>AMD PState 内核文档：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.kernel.org%2Fadmin-guide%2Fpm%2Famd-pstate.html" target="_blank">https://docs.kernel.org/admin-guide/pm/amd-pstate.html</a></p><p>如果有时间，可以自行研读上述电源文档，就很容易理解 CPU 电源配置相关内容。作者在这里的讲述将忽略大量技术细节和实现方式，仅表述如何调整 CPU 的电源模式。</p><p>在 /sys/devices/system/cpu/cpufreq 目录下有许多文件名为 policy&lt;x&gt;（x 代表核心编号），这些文件对应着电脑上的 CPU 核心，而 CPU 的电源调度细节就在这些文件夹里。在 policy&lt;x&gt; 目录下有一个文件`scaling_driver`，使用 cat 或其他方式访问它，得到的结果就是当前使用的调度器：</p><ul><li>intel_cpufreq / acpi_cpufreq : 使用 scaling freq 调度；</li><li>intel_pastate : 使用 Intel PState 调度；</li><li>amd-pstate : 使用 AMD PState 调度。</li></ul><p><strong>&nbsp;scalling freq 调度</strong></p><p>这是最传统的 CPU 调度方式，可以在 policy 文件夹下的 scaling_available_governors 获取可选电源模式：</p><p style="text-align:center"><img height="742" src="https://oscimg.oschina.net/oscnet/up-30d23181f6f0f60ab32af9f63d163238aa5.png" width="765" referrerpolicy="no-referrer"></p><p>其实这些平衡模式的作用都是是一样的：平衡性能和续航，不过使用的算法可能不同。</p><p><strong>Intel PState</strong></p><p>这是 Intel 近几代 CPU 独享的 moment，内核开启 Intel PState 后（deepin V23 内核默认开启），在 policy 文件夹下多了几个文件：</p><p>我们只需要关注：</p><ul><li>energy_performance_available_perference : 可用的 PState 电源调度；</li><li>energy_performance_perference：当前选定的 PState 电源调度，可以更改此文件内容来更改电源调度。</li></ul><p>在 Intel PState 中出现了两个新的调度方案：</p><ul><li>balance_performance : 平衡偏性能，平时工作频率不高，在负载增大时能快速响应；</li><li>balance_power : 平衡偏节能，电源策略较为保守，在部分电脑上还有 default 方案，此方案就是经过 PState 优化过的 balance 策略。具体 PState 使用的黑魔法以及主动模式和被动模式的调度策略，可以参照内核文档进行分析。</li></ul><p><strong>AMD PState</strong></p><p>这是 AMD ZEN2 以上用户，以及支持 kernel 6.4.x 用户独享的 moment。其实 AMD 在 6.1 内核已经做了 PState 的支持，不过是被动模式。</p><ul><li>（Actvie Mode）主动模式</li></ul><p>Active Mode 仅在内核版本大于 6.4 以上，且内核选项打开 AMD PState 时可用。可能需要在 grub 内加入启动参数以打开此功能：amd_pstate=active，也可以修改文件实现 Active Mode 的电源策略和 Intel PStatewi 类似。</p><ul><li>（Passive Mode）被动模式</li></ul><p>Passtive Mode 仅在内核大于 6.1 以上，且内核选项打开 AMD PState 时可用。可能需要在 grub 加入启动参数开启此功能：amd_pstate=passive，也可修改文件实现。</p><p>Passive Mode 提供两种电源模式，在/sys/device/system/cpu/cpufreq/scaling_governor 文件进行调整：</p><p>（1）performance 使用 platform_profile 进行配置，调度积极性较高；<br> （2）scheutils 在/sys/device/system/cpu/cpufreq/schedutil/rate_limit_us 文件中调整调度粒度（两次调度的间隔时间）和 ACPI 的 scheutils 类 &nbsp;/sys/device/system/cpu/cpufreq/scaling_governor 。</p><ul><li>（Guided Mode）引导模式</li></ul><p>Guided Mode 仅在内核大于 6.1 以上，且内核选项打开 AMD PState 时可用。可能需要在 grub 加入启动参数开启此功能：amd_pstate=guided，也可修改文件实现。这就类似汽车的自动挡，驱动程序请求最低和最大性能级别，平台自动选择此范围内适合当前工作负荷的性能级别。</p><h3><strong>4.GPU 电源管理部分</strong></h3><p><strong>&nbsp;AMD GPU</strong></p><p>如果是 AMD GPU 则需要更改两个文件（使用 tee 命令进行写入）：</p><ul><li>/sys/class/drm/card0/device/power_dpm_state（这是一个遗留接口，目的是向后兼容）；</li><li>performance 高性能模式；</li><li>balance 平衡模式；</li><li>battery 节能模式；</li><li>/sys/class/drm/card0/device/power_dpm_force_performance_level 。</li></ul><p>以下设置来自 AMD 官方驱动文档：</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdri.freedesktop.org%2Fdocs%2Fdrm%2Fgpu%2Famdgpu.html%23power-dpm-force-performance-level" target="_blank">https://dri.freedesktop.org/docs/drm/gpu/amdgpu.html#power-dpm-force-performance-level</a></p><pre><code>power_dpm_force_performance_level:</code></pre><p>AMD GPU 驱动程序提供了一个 sysfs API，用于调整某些与功率相关的参数。文件 power-dpm-force-performance-level 将用于执行此操作。它接受以下参数：</p><ul><li>auto：当选择 auto 时，设备将尝试针对驱动中的当前条件动态选择最佳功率曲线；</li><li>low：当选择低时，GPU 被强制到最低功率状态；</li><li>high：当选择高时，GPU 被强制到最高功率状态；</li><li>manual：当选择手动时，用户可以通过 sysfs pp_dpm_mclk、pp_dpm_sclk 和 pp_dpm_pcie 文件手动调整每个时钟域启用的电源状态，并通过 pp_power_profile_mode sysfs 文件调整电源状态转换方式；</li><li>profile_standard 固定时钟级别分析模式。此模式将时钟设置为固定级别，该级别因 ASIC 而异。这对于分析特定工作负载很有用（不常用）；</li><li>profile_min_sclk 最小 SCLK 分析模式。此模式将 SCLK 强制设置为最低级别。这对于分析最小功耗的场景很有用（不常用）；</li><li>profile_min_mclk 最小 MCLK 分析模式。此模式将 MCLK 强制设置为最低级别。这对于分析最小功耗的场景很有用（不常用）；</li><li>profile_peak 峰值分析模式。此模式将所有时钟（MCLK、SCLK、PCIe）设置为最高级别。这对于分析最大性能的场景很有用（不常用）。</li></ul><p><strong>测试：</strong></p><ul><li>Low 模式的跑分</li></ul><p style="text-align:center"><img height="527" src="https://oscimg.oschina.net/oscnet/up-a7c7db000560426ab1a9b7c748e27c0a1b7.png" width="905" referrerpolicy="no-referrer"></p><ul><li>Auto 模式的跑分</li></ul><p style="text-align:center"><img height="368" src="https://oscimg.oschina.net/oscnet/up-5bb4cd6ed50bbcdc27d0be3b221b6393b32.png" width="715" referrerpolicy="no-referrer"></p><ul><li><p>High 模式的跑分</p></li></ul><p><img height="482" src="https://oscimg.oschina.net/oscnet/up-34be1d83b01eab80986cba3af73de7fbe2d.png" width="885" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><strong>Intel GPU</strong></p><p>Intel GPU 使用的 i915 驱动，并不希望你对其做出调整，因为其驱动自带的电源策略已经足够聪明。不过你也可以通过 Intel 提供的 intel-gpu-tools 进行调整和获取信息。</p><pre><code>sudo apt install intel-gpu-tools &nbsp; </code></pre><p>然后使用</p><pre><code>sudo intel_gpu_frequency</code></pre><p>来获取当前频率（当前使用的是 Intel A750）。</p><p style="text-align:center"><img height="133" src="https://oscimg.oschina.net/oscnet/up-8f915468117bd14d8fe8cefa8f8035b08d6.png" width="594" referrerpolicy="no-referrer"></p><p>可以看到 Intel 的显卡驱动是在 600 MHz 到 2400 MHz 之间动态调整（如上图）。</p><p>测试笔记本下 Intel 核显跑分如下：</p><p style="text-align:center"><img height="490" src="https://oscimg.oschina.net/oscnet/up-97908337d81f9e30651c110d9dddbf88129.png" width="732" referrerpolicy="no-referrer"></p><p><strong>NVIDIA</strong></p><p>由于 NVIDIA 驱动不开源，所以在系统层面无法对其做控制。</p><h2><strong>应用级别的省电&nbsp;</strong></h2><p>应用级别的省电，应该就是在保证用户使用流畅度的情前提下节省性能。之前也有用户提出过，是否能参照某手机厂商的不公平调度算法来实现优化，毕竟安卓系统的底层也是 Linux，理论上实现难度不大。</p><p>Cgroups，全称 Control Groups，是 Linux 内核提供的一种资源管理机制，用于对进程分组并对其资源进行限制和隔离。Cgroups 可以用于限制进程的 CPU、内存、磁盘、网络等资源，也可以用于限制进程的优先级和 IO 权限。利用其提供的能力，很容易实现类似不公平调度算法（新的 AM 天然支持 Cgroups 的操作），但是还有一些顾虑：</p><ul><li>不同于手机操作系统，计算机操作系统是多任务并行的，在多数窗口管理器下，我们并没有一个明显的前台应用，此时使用不公平调度可能存在隐患；</li><li>容易引发人机对抗。在我的观念里面，计算机是为人服务的，那么用户的意志必定是第一优先级，所以我们不应改变用户的行为，如果使用不平衡调度和用户预期不一致，会极大降低用户体验；</li><li>使用前后台区分应用，可能导致开销和收益比下降，性价比不高。Linux 桌面不像安卓设备有明显前后台，用户频繁切换应用的操作将导致调度器频繁切换调度，使得开销过大。最佳的解决方案是：提供能力，但不提供方案。可以提供基于 Cgroups 方式修改应用组的优先级，然后让用户自己选择什么应用优先级更高，什么应用优先级低，以实现调度（比如在 dock 上右键选择优先级）或提供一套配置以供用户自由选择。</li></ul><p>如果一个电脑需要使用不平衡调度来保证使用流畅性，可能这并不是一个操作系统能解决的问题，而更应该考虑硬件是否需要更换，以保证多任务使用的流畅性。</p><h4><strong>附录——常用的调试测试工具</strong></h4><p>1. S-tui</p><p>可以看到 CPU 频率变化，配合 stress 可以对 CPU 进行压力测试。</p><p style="text-align:center"><img height="553" src="https://oscimg.oschina.net/oscnet/up-9035dd7df12eda9d831c879f89d1e2f3230.png" width="1025" referrerpolicy="no-referrer"></p><p>2. intel-gpu-tools</p><p>可以使用 intel_gpu_frequency 来获取和调整 i965 的驱动频率。</p><p>3. GLMark2</p><p>GPU 跑分软件。</p><p>4. stress-ng</p><p>CPU 压力测试软件。</p><p>5. PowerTOP</p><p>电源测试软件，可以看到电源的功耗和使用情况。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268783</guid>
            <link>https://www.oschina.net/news/268783</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Go 语言微服务框架重磅升级：dubbo-go v3.2.0 -alpha 版本预览]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:justify">随着 Dubbo3 在云原生微服务方向的快速发展，Dubbo 的 go 语言实现迎来了 Dubbo3 版本以来最全面、最大幅度的一次升级，这次升级是全方位的，涉及 API、协议、流量管控、可观测能力等。总的来说，新版本的 dubbo-go：</p><ul><li><strong>全面升级 Triple 协议，</strong>兼容 gRPC、标准 HTTP 客户端，提供简单明了的 API 用于编写 RPC server 与 client，解决组件间的基本通信问题。</li><li><strong>针对微服务场景，提供了完善的服务治理能力，</strong>这包括配置管理、可观测性、流量管控规则、生态集成与适配等的全面升级。</li></ul><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-c4c6b5317adb83a4b234eb8fcd15d8c9_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h3_1"></span><h3>全新升级的 Triple 协议</h3><p style="text-align:justify">基于 dubbo-go 实现的 Triple 协议，你可以轻松编写浏览器、gRPC 兼容的 RPC 服务，并让这些服务同时运行在 HTTP/1 和 HTTP/2 上。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-8146beb5d33000f7180c25928e62fba0_720w.webp" referrerpolicy="no-referrer"></p><p>如上图所示，你可以使用 "http+json" 的标准形式访问 dubbo-go 发布的后端 triple 服务，基于这一特性， 我们可以在 dubbo 客户端在浏览器页面、移动设备上访问后端服务，使用标准 cURL 工具访问服务，也可以让比如 Spring 体系的应用轻松的调通 Dubbo 服务。</p><p style="text-align:justify">由于 Triple 协议完全兼容 gRPC 协议，Dubbo 后端服务有可以直接调通标准的 gRPC 服务，它们之间可以无缝的互通，不论是 unary 还是 streaming 通信模式。</p><span id="OSC_h4_2"></span><h4>发布一个 triple rpc 服务</h4><p style="text-align:justify">为了体验升级后的 triple 协议，我们接下来会尝试启动一个 dubbo-go server，并发布一个基于 triple 协议的服务。</p><p style="text-align:justify">创建一个新的 server 并启动 server，它将在指定的端口监听 triple 协议请求。</p><pre><code>func main() {
  srv, err := server.NewServer(
    server.WithServerProtocol(
      protocol.WithTriple(),
      protocol.WithPort(50051),
    ),
  )
  if err != nil {
    panic(err)
  }
  if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
  }
  if err := srv.Serve(); err != nil {
    panic(err)
  }
}</code></pre><span id="OSC_h4_3"></span><h4>cURL 访问服务</h4><p style="text-align:justify">Triple 服务启动完成之后，最简单方式是使用 HTTP/1.1 POST 访问服务，参数则作以标准 JSON 格式作为 HTTP 负载传递。如下是使用 cURL 命令的访问示例：</p><pre><code>curl \
    --header "Content-Type: application/json" \
    --data '{"name": "Dubbo"}' \
    http://localhost:50051/greet.GreetService/Greet</code></pre><p style="text-align:justify">Triple 协议的一项重大升级是支持标准 http 工具直接访问，通过 cURL 可以极大的降低 dubbo-go 服务的测试验证、前端接入成本。</p><span id="OSC_h3_4"></span><h3>简单明了的 API</h3><p style="text-align:justify">Dubbo Go SDK 支持使用 IDL 或编程语言特有的方式定义服务，并提供一套轻量的 API 来发布或调用这些服务。在上一节的示例中，我们已经看到了部分 dubbo-go API 的使用方式，接下来，让我们更仔细全面的看一下新版本的 API 设计。</p><span id="OSC_h4_5"></span><h4>RPC Server 与 Client</h4><p style="text-align:justify">对于一些 RPC 通信的场景，开发者只需要使用 dubbo-go 编写一个最简单的 RPC server 或者 RPC client，这在新版本 dubbo-go 中只需要几行代码即可完成。</p><p style="text-align:justify">通常，我们会使用 Protocol Buffer (IDL) 来定义一个 Dubbo 服务。</p><pre><code>syntax = "proto3";
package greet;

message GreetRequest {
  string name = 1;
}

message GreetResponse {
  string greeting = 1;
}

service GreetService {
  rpc Greet(GreetRequest) returns (GreetResponse) {}
}</code></pre><p style="text-align:justify">使用 Protocol Buffers Compiler 从 IDL 生成 stub 代码（篇幅关系，我们不在此展示，具体请参见官网 dubbo-go 快速开始）。接下来，我们实现 greettriple.GreeterClient 接口并提供自定义服务实现。</p><pre><code>type GreeterServer struct {
}

func (s *GreeterServer) SayHello(ctx context.Context, in *greet.HelloRequest) (*greet.User, error) {
  return &amp;greet.User{Name: "Hello " + in.Name, Id: "12345", Age: 21}, nil
}</code></pre><p style="text-align:justify">以下是一个简单的 RPC server 示例，执行协议信息，并注册服务到 server 中：</p><pre><code>func main() {
  srv, err := server.NewServer(
    server.WithServer_Protocol(
      protocol.WithTriple(),
      protocol.WithPort(50052),
    ),
  )
  if err != nil {
    panic(err)
  }
  if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
  }
  if err := srv.Serve(); err != nil {
    panic(err)
  }
}</code></pre><p style="text-align:justify">如前面 Triple 协议一节所述，你可以使用 cURL 直接测试以上 server 服务运行正常。与此同时，对应的 RPC client 示例如下：</p><pre><code>func main() {
  // for the most brief RPC case
  cli, err := client.NewClient(
    client.WithURL("tri://127.0.0.1:50052"),
  )
  if err != nil {
    panic(err)
  }
  svc, err := greettriple.NewGreetService(cli)
  if err != nil {
    panic(err)
  }

  common.TestClient(svc)
}</code></pre><span id="OSC_h4_6"></span><h4>微服务开发</h4><p style="text-align:justify">如果你正在开发微服务应用，那么除了 RPC 通信之外，你通常还需要为应用配置一些服务治理能力，比如 retistry 注册中心、配置中心、可观测能力等。</p><p style="text-align:justify">以下展示了如何使用 dubbo-go 开发一个微服务应用。</p><p style="text-align:justify">首先，创建一个代表微服务的应用 Server，将服务注册给它，添加注册中心等服务治理配置。</p><pre><code>func main() {
  // configure global configurations and common modules
  ins, err := dubbo.NewInstance(
    dubbo.WithName("dubbo_test"),
    dubbo.WithRegistry(
      registry.WithZookeeper(),
      registry.WithAddress("127.0.0.1:2181"),
    ),
    dubbo.WithProtocol(
      protocol.WithTriple(),
      protocol.WithPort(50052),
    ),
  )
    // create a server with registry and protocol set above
  srv, err := ins.NewServer()
  if err != nil {
    panic(err)
  }
    // register a service to server
  if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
  }
    // start the server
  if err := srv.Serve(); err != nil {
    panic(err)
  }
}</code></pre><p style="text-align:justify">其中，Instance 是我们在新版本中引入的全局配置，你可以将所有微服务全局配置在这里进行初始化。这里，我们设置了微服务通信协议 protocol 和注册中心 registry，如以下代码片段所示：</p><pre><code>ins, err := dubbo.NewInstance(
    dubbo.WithName("dubbo_test"),
    dubbo.WithRegistry(
        registry.WithZookeeper(),
        registry.WithAddress("127.0.0.1:2181"),
    ),
    dubbo.WithProtocol(
        protocol.WithTriple(),
        protocol.WithPort(50052),
    ),
)</code></pre><p style="text-align:justify">接下来的操作就非常简单明了了，我们创建一个 server，将服务注册给它并启动，如下所示。如果有更多的服务，则可以依次注册到 server 后再启动。</p><pre><code>// create a server with registry and protocol set above
srv, err := ins.NewServer()
// register a service to server
if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
}
// start the server
if err := srv.Serve(); err != nil {
    panic(err)
}</code></pre><p style="text-align:justify">以上就是一个微服务应用的基本开发过程，如果你的微服务应用要调用一些远程 Dubbo 服务，那么你只需要参照以下方式创建一个 client 就行了。</p><p style="text-align:justify">下面的代码示例创建了一个 client，紧接着生成了一个 GreetService 远程服务代理，之后，就可以像调用本地方法一样调用远端 Dubbo 服务了。client 将基于注册中心实现 server 实例的自动发现并自动为流量应用负载均衡策略。</p><pre><code>func main() {
  // configure global configurations and common modules
  ins, err := dubbo.NewInstance(
    dubbo.WithName("dubbo_test"),
    dubbo.WithRegistry(
      registry.WithZookeeper(),
      registry.WithAddress("127.0.0.1:2181"),
    ),
  )
  
  // configure the params that only client layer cares
  cli, err := ins.NewClient()
  if err != nil {
    panic(err)
  }

  svc, err := greettriple.NewGreetService(cli)
  if err != nil {
    panic(err)
  }

  resp, err := svc.Greet(context.Background(), &amp;greet.GreetRequest{Name: "triple"})
  if err != nil {
    return err
  }
  logger.Infof("TRIPLE unary call resp: %s", resp.Greeting)
}</code></pre><span id="OSC_h3_7"></span><h3>企业级服务治理能力</h3><span id="OSC_h4_8"></span><h4>动态配置</h4><p style="text-align:justify">除了 API 模式之外，Dubbo-go 支持基于配置文件驱动的编码方式，这对于一些更大规模的微服务开发场景非常适用。在这种模式下，我们将 registry、protocol 等组件配置，甚至包括服务声明等都放在 dubbogo.yml 文件中，框架会在启动过程中完成配置文件加载。</p><p style="text-align:justify">以下是一个基于 dubbogo.yml 的微服务应用的开发示例：</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-7420aaf1df69816f650d9fafc20a94e5_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">其中，server.go 定义如下：</p><pre><code>func main() {
  greettriple.SetProviderService(&amp;GreeterServiceImpl{})
  if err := dubbo.Load(); err != nil {
    panic(err)
  }
}</code></pre><p style="text-align:justify">dubbogo.yml 示例内容如下：</p><pre><code>dubbo:
  application: # 应用信息，服务启动后会将相关信息注册到注册中心，可被客户端从 url 中识别
    name: myApp
  registries:
    nacos:
      protocol: nacos # 注册中心选择 nacos 
      address: 127.0.0.1:8848 # nacos ip
      group: DEFAULT_GROUP # nacos group, 默认 DEFAULT_GROUP
      namespace: 9fb00abb-278d-42fc-96bf-e0151601e4a1 # nacos namespaceID, should be created before. 默认 public
      username: abc
      password: abc
  protocols:
    dubbo:
      name: tri
      port: 20000
  provider:
    services:
      UserProviderWithCustomGroupAndVersion: # 接口三元组：接口名、版本号、分组。client 和 server 需要保持一致。
        interface: org.apache.dubbo.UserProvider.Test # 接口名必填
        version: myInterfaceVersion # 默认为空
        group: myInterfaceGroup # 默认为空</code></pre><p style="text-align:justify">可以看到相比于之前的 API 编码方式，这里的 server.go 只有两行代码，dubbo.Load() 会完成所有配置的自动组装并启动相关组件，我们只需要在启动应用时指定 export DUBBO_GO_CONFIG_PATH=$ABSOLUTE_PATH/conf/dubbogo.yml 即可。</p><span id="OSC_h4_9"></span><h4>可观测性</h4><p style="text-align:justify">自 3.2.0 版本开始，dubbo-go 重点升级了内置 metrics 指标采集能力，提供 RPC 调用（RT、QPS、调用量、请求成功数、请求失败数、并发请求数等）、注册中心、元数据中心、配置中心交互统计等丰富的内置采集埋点，支持多维度的指标聚合。</p><p style="text-align:justify">dubbo-go 内置 metrics 指标导出到 Prometheus + Grafana 体系的能力，以下是 dubbo-go v3.2.0 示例在 Grafana 的监控效果图，具体示例我们将与随后发布在 dubbo-go-samples/metrics。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-b4ec54c1891c2d1f09b91227746c751e_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_10"></span><h4>流量管控</h4><p style="text-align:justify">Dubbo 提供了丰富的流量管控策略：</p><ul><li><strong>地址发现与负载均衡，</strong>地址发现支持服务实例动态上下线，负载均衡确保流量均匀的分布到每个实例上。</li><li><strong>基于路由规则的流量管控，</strong>路由规则对每次请求进行条件匹配，并将符合条件的请求路由到特定的地址子集。</li></ul><p style="text-align:justify">服务发现保证调用方看到最新的提供方实例地址，服务发现机制依赖注册中心 (Zookeeper、Nacos、Istio 等) 实现。在消费端，Dubbo 提供了多种负载均衡策略，如随机负载均衡策略、一致性哈希负载、基于权重的轮询、最小活跃度优先、P2C 等。</p><p style="text-align:justify">Dubbo 的流量管控规则可以基于应用、服务、方法、参数等粒度精准的控制流量走向，根据请求的目标服务、方法以及请求体中的其他附加参数进行匹配，符合匹配条件的流量会进一步的按照特定规则转发到一个地址子集。以下是 dubbo-go 流量管控规则可以实现的一些具体管控场景示例：</p><ul><li>基于权重的比例流量分发</li><li>灰度验证</li><li>金丝雀发布</li><li>按请求参数的路由</li><li>同区域优先</li><li>超时时间调整</li><li>重试</li><li>限流降级</li></ul><p style="text-align:justify">以下是一个基于 dubbo-go 实现的全链路灰度示例：</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-d3af29d517bd1d38914a8b7df29c0384_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">以下是一个基于 dubbo-go 实现的按比例流量转发示例：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-4688342e32359c6fa7e25ef3bc3c22b6_720w.webp" referrerpolicy="no-referrer"></p><p>关于 dubbo-go 流量管控，我们以一个商城系统提供了一个完整的 demo 示例，感兴趣的读者可以参考详细信息：</p><ul><li>流量管控规则详情<strong>[1]</strong></li><li>流量管控商场示例解读<strong>[2]</strong></li></ul><span id="OSC_h4_11"></span><h4>生态</h4><p style="text-align:justify">dubbo-go 总体上遵循框架内核+插件的的设计理念，左侧的框架内核定义了 dubbo-go 作为微服务框架的一些核心概念，右侧的插件部分则提供了核心概念扩展实现。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-c4c6b5317adb83a4b234eb8fcd15d8c9_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">框架内核，可分为 4 个层次，从上到下依次为：</p><ul><li><strong>API 层</strong></li></ul><p style="text-align:justify">dubbo-go 同时支持基于 IDL、interface/struct 的服务契约定义，兼顾跨语言与易用性诉求；支持基于纯 yaml 文件的微服务配置模式；提供了同步、异步、单次 (unary)、流式 (streaming) 等 RPC 通信与编码模型。</p><ul><li><strong>服务治理层</strong></li></ul><p style="text-align:justify">dubbo-go 内置了多维度的服务治理能力抽象，确保满足微服务开发与集群治理的核心诉求，这包括地址发现（Service Discovery）、负载均衡（Load Balancing）、可观测指标（Metrics）、流量管控（Traffic Management）、全链路追踪（Tracing）等。</p><ul><li><strong>RPC 协议层</strong></li></ul><p style="text-align:justify">dubbo-go 实现的最核心的 RPC 协议是 - triple 协议，triple 可同时工作在 http1/2 之上 (支持 CURL 直接访问)，兼容 gRPC；从设计上，dubbo-go 还提供了多协议发布服务的支持，你可以在一个进程内同时发布 triple、dubbo2、rest、jsonRPC 等多种不同通信协议的服务。</p><ul><li><strong>传输层</strong></li></ul><p style="text-align:justify">支持 HTTP1/2、TCP 传输层，兼顾性能与通用性，同时支持多种序列化方式。</p><p style="text-align:justify">插件体系极大的丰富了 dubbo-go 功能与生态，社区内置提供了大量的内置扩展实现，同时，开发者可以非常容易的根据需求增加扩展实现。以下是一些典型的插件定义：</p><ul><li><strong>Protocol</strong></li></ul><p style="text-align:justify">dubbo-go 基于 protocol 插件内置提供了 triple、dubbo2、rest 等协议支持，通过扩展 protocol 可以为 dubbo-go 扩展更多协议。</p><ul><li><strong>Service Discovery</strong></li></ul><p style="text-align:justify">支持 Nacos、Zookeeper、Polaris 等主流注册中心集成。</p><ul><li><strong>Traffic Management</strong></li></ul><p style="text-align:justify">dubbo-go 支持 Dubbo 体系定义的流量规则，可以实现在运行期动态的调整服务行为如超时时间、重试次数、限流参数等，通过控制流量分布可以实现 A/B 测试、金丝雀发布、多版本按比例流量分配、条件匹配路由、黑白名单等。</p><ul><li><strong>Metrics</strong></li></ul><p style="text-align:justify">提供 RPC 调用（RT、QPS、调用量、请求成功数、请求失败数、并发请求数等）、注册中心、元数据中心、配置中心交互统计等丰富的内置采集埋点，支持多维度的指标聚合。</p><ul><li><strong>Logging</strong></li></ul><p style="text-align:justify">提供通用的日志采集接口定义，内置 Zap、Logrus 支持</p><ul><li><strong>Tracing</strong></li></ul><p style="text-align:justify">提供分布式链路追踪能力，通过此插件扩展可接入 Zipkin、Jaeger、Skywalking 等链路追踪系统。</p><span id="OSC_h3_12"></span><h3>总结</h3><p style="text-align:justify">dubbo-go 3.2.0 的首个 alpha 版本将于 11 月底发布，本文是发版前的抢先预览，感兴趣的读者也可以访问源码尝鲜：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fapache%2Fdubbo-go%2Ftree%2Ffeature-triple%2Fprotocol%2Ftriple%2Finternal%253Fspm%253Da2c6h.13046898.publish-article.3.79d66ffahA9acR" target="_blank">https://github.com/apache/dubbo-go/tree/feature-triple/protocol/triple/internal</a></em></u></p><p style="text-align:justify">接下来，我们将持续推进 3.2.0 版本迭代并计划与 2 月份发布正式稳定版本，详细 Roadmap 请关注项目仓库：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fapache%2Fdubbo-go%253Fspm%253Da2c6h.13046898.publish-article.4.79d66ffahA9acR" target="_blank">https://github.com/apache/dubbo-go</a></em></u></p><p style="text-align:justify"><strong>相关链接：</strong></p><p style="text-align:justify">[1] 流量管控规则详情</p><p style="text-align:justify"><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Ftraffic%2F%253Fspm%253Da2c6h.13046898.publish-article.5.79d66ffahA9acR" target="_blank">https://cn.dubbo.apache.org/zh-cn/overview/core-features/traffic/</a></em></u></p><p style="text-align:justify">[2] 流量管控商场示例解读</p><p style="text-align:justify"><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Ftasks%2Ftraffic-management%2F%253Fspm%253Da2c6h.13046898.publish-article.6.79d66ffahA9acR" target="_blank">https://cn.dubbo.apache.org/zh-cn/overview/tasks/traffic-management/</a></em></u></p><p style="text-align:justify"><em>作者：王宇轩， Apache Dubbo Committer</em></p><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1380725%3Futm_content%3Dg_1000384715" target="_blank">原文链接</a></strong></p><p style="text-align:justify"><strong>本文为阿里云原创内容，未经允许不得转载。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 09:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10314426</guid>
            <link>https://my.oschina.net/yunqi/blog/10314426</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[国内首个农业开源鸿蒙操作系统]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0px; margin-right:0px; text-align:start">11 月 29 日，在全球首个以供应链为主题的国家级展会——中国国际供应链促进博览会上，中信农业科技股份有限公司（简称「中信农业」）联合深圳开鸿数字产业发展有限公司（简称「深开鸿」）、华为技术有限公司（简称「华为」）正式对外发布了<strong>国内首个自主可控的农业开源鸿蒙操作系统。</strong></p><p style="margin-left:0px; margin-right:0px; text-align:start">据介绍，农业开源鸿蒙是致力于维护农业数据安全，打造自主可控的农业操作系统。</p><p><img src="https://static.oschina.net/uploads/space/2023/1129/170904_6My8_2720166.png" referrerpolicy="no-referrer"></p><p>下图是农业开源鸿蒙操作系统的演示：</p><p><img height="906" src="https://static.oschina.net/uploads/space/2023/1129/171101_l9cl_2720166.png" width="2232" referrerpolicy="no-referrer"></p><p><img height="928" src="https://static.oschina.net/uploads/space/2023/1129/171017_86bC_2720166.png" width="2226" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-116c65e954d843c9b90f6fb5ba8f83258c5.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-c8e4bc96284803ab6547db6797684372387.png" referrerpolicy="no-referrer"></p><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fj4EIO_8RPUdwqLJBhsozAQ" target="_blank">https://mp.weixin.qq.com/s/j4EIO_8RPUdwqLJBhsozAQ</a></u></em></p><p>深开鸿 CEO 王成录博士介绍道，农业开源鸿蒙操作系统是基于 KaihongOS 的新一代面向数字农业领域的万物智联操作系统，为大小不一、类型多样设备的互联和协同提供统一的数字底座，让所有农业设备都用统一的操作系统，讲同一种语言，而且全栈关键核心技术均为国产自主研发，从底层操作系统源头上保证了数据的安全可靠。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 09:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268706</guid>
            <link>https://www.oschina.net/news/268706</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微软开源 Azure RTOS，更名为 Eclipse ThreadX]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">微软<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcommunity.microsoft.com%2Ft5%2Finternet-of-things-blog%2Fmicrosoft-contributes-azure-rtos-to-open-source%2Fba-p%2F3986318" target="_blank">宣布</a>将 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fazure-rtos" target="_blank">Azure RTOS</a> 托管至&nbsp;<span style="background-color:#ffffff">Eclipse 基金会，并更名为&nbsp;Eclipse ThreadX。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Azure RTOS 是一个带有 ThreadX 实时操作系统（RTOS）的嵌入式开发套件。ThreadX 是一个普及性很高的小型 RTOS，</span>可为资源受限的设备提供可靠、超快的性能；<span style="background-color:#ffffff">目前已部署在全球超过 120 亿台设备上。除了作为 RTOS 内核的 Azure RTOS ThreadX 之外，Azure RTOS 还提供了一组系统组件来加速构建嵌入式系统和物联网应用程序。</span></span></p><p><span style="color:#000000">在基金会管理下，<span style="background-color:#ffffff">Eclipse ThreadX 项目计划将于 2024 年第一季度在 MIT 协议下开源提供。「</span><span style="background-color:#ffffff">ThreadX 将成为世界上第一个开源实时操作系统。</span><span style="background-color:#ffffff">」</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff"><img alt="" height="374" src="https://oscimg.oschina.net/oscnet/up-70e9a7d446ccf867ef9551516c458a9610d.png" width="700" referrerpolicy="no-referrer"></span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">公告称，Eclipse ThreadX 为实时应用提供了一个供应商中立、开放源代码、安全认证的操作系统。它是第一个也是唯一一个具有这种独特混合属性的实时操作系统，可满足广泛的需求，使行业采用者、开发人员和最终用户都能从中受益。</span><span style="background-color:#ffffff">主要优点包括：</span></span></p><ul><li><span style="color:#000000">不间断访问：更广泛、持续地访问 ThreadX 技术</span></li><li><span style="color:#000000">加速创新：通过社区参与提供更快的更新和改进</span></li><li><span style="color:#000000">开放且可预测：透明的开发流程以增强社区协作</span></li><li><span style="color:#000000">更广泛的覆盖范围：对于各种应用来说更易于访问和通用</span></li></ul><p><span style="color:#000000">「这一变革性合作为嵌入式 RTOS 技术的空前发展铺平了道路，并将在新成立的 </span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fprojects.eclipse.org%2Fproposals%2Feclipse-threadx" target="_blank">Eclipse ThreadX Project</a>&nbsp;<span style="color:#000000"><span style="background-color:#ffffff">和</span></span>&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fprojects.eclipse.org%2Finterest-groups%2Fthreadx-interest-group" target="_blank">Eclipse ThreadX Interest Group</a><span style="color:#4c4d4e">&nbsp;</span><span style="color:#000000">的框架内展开。<span style="background-color:#ffffff">与我们一起塑造嵌入式系统的未来并利用开源的力量促进创新！</span>」&nbsp;</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Eclipse 基金会<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Feclipse-foundation.blog%2F2023%2F11%2F21%2Fintroducing-eclipse-threadx%2F" target="_blank">认为</a>，</span></span><span style="background-color:#ffffff"><span style="color:#222222">ThreadX 将凭借其全面的属性，迅速扩大在航空航天、汽车、物联网、医疗、交通、自动化和消费可穿戴设备等广泛用例中的采用。「Eclipse ThreadX 为行业带来了改变游戏规则的机会。」</span></span></p><p><strong><span style="background-color:#ffffff"><span style="color:#222222">项目官网：</span></span></strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthreadx.io%2F" target="_blank">https://threadx.io/</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 09:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268705/microsoft-azure-rtos-eclipse-threadx</guid>
            <link>https://www.oschina.net/news/268705/microsoft-azure-rtos-eclipse-threadx</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[1 - 10 月我国电子信息制造业生产持续回升]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 1-10 月份电子信息制造业运行情况已<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F-NlHIDx-kRamtsv2EoBppQ" target="_blank">公布</a>。1-10&nbsp;<span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">月份，我国电子信息制造业生产持续回升，出口降幅收窄，效益持续改善，投资稳定增长，地区间营收分化明显。</span></p><p style="margin-left:0; margin-right:0"><strong>一、生产持续回升</strong></p><p style="margin-left:0; margin-right:0">1—10 月份，规模以上电子信息制造业增加值同比增长 1.7%，增速较前三季度提高 0.3 个百分点；<span>增速分别比同期工业、高技术制造业低 2.4 个和 0.2 个百分点。10 月份，规模以上电子信息制造业增加值同比增长 4.8%，较同期工业高 0.2 个百分点。</span></p><p><img height="284" src="https://oscimg.oschina.net/oscnet/up-c7e8347b11afa929069846f119706440564.png" width="500" referrerpolicy="no-referrer"></p><p>1—10 月份，主要产品中，手机产量 12.5 亿台，同比增长 1.6%，其中智能手机产量 9.06 亿台，同比下降 4.8%；微型计算机设备产量 2.81 亿台，同比下降 20.8%；集成电路产量 2765 亿块，同比增长 0.9%；光电子器件产量 11753 亿只，同比增长 9.3%。</p><p style="margin-left:0; margin-right:0"><strong>二、出口降幅收窄</strong></p><p>1—10 月份，规模以上电子信息制造业出口交货值同比下降 6.9%，降幅较前三季度收窄 1.2 个百分点，比同期工业降幅深 2.7 个百分点。10 月份，规模以上电子信息制造业出口交货值与去年同期持平。</p><p><img height="278" src="https://oscimg.oschina.net/oscnet/up-8fddcd7d4c558e2d88e81617b79a9576a58.png" width="500" referrerpolicy="no-referrer"></p><p>据海关统计，1—10 月份，我国出口笔记本电脑 11774 万台，同比下降 18%；出口手机 6.42 亿台，同比下降 6.5%；出口集成电路 2218 亿个，同比下降 4.1%。</p><p style="margin-left:0; margin-right:0"><strong>三、效益持续改善</strong></p><p style="margin-left:0px; margin-right:0px; text-align:justify">1—10 月份，规模以上电子信息制造业实现营业收入 12.1 万亿元，同比下降 2.9%，较前三季度降幅收窄 0.5 个百分点；营业成本 10.5 万亿元，同比下降 2.6%；实现利润总额 4826 亿元，同比下降 18.2%，较前三季度降幅收窄 0.4 个百分点；营业收入利润率为 4%，较前三季度持平。</p><p><img height="280" src="https://oscimg.oschina.net/oscnet/up-8fb3765349827aa46ce821c7b2ef59dfc32.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>四、投资稳定增长</strong></p><p style="margin-left:0; margin-right:0">1—10 月份，电子信息制造业固定资产投资同比增长 9.6%，比同期工业投资增速高 0.7 个百分点，但比高技术制造业投资增速低 1.7 个百分点。</p><p><img height="274" src="https://oscimg.oschina.net/oscnet/up-ed620009a27ece0de52f59079cdf61d17da.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>五、地区间营收分化明显</strong></p><p>1—10 月份，规模以上电子信息制造业东部地区实现营业收入 82003 亿元，同比下降 3%，较前三季度降幅收窄 0.8 个百分点；中部地区实现营业收入 19834 亿元，同比下降 3.9%，较前三季度降幅收窄 1.3 个百分点；西部地区实现营业收入 17982 亿元，同比下降 1.9%，较前三季度降幅加深 1.8 个百分点；东北地区实现营业收入 823 亿元，同比增加 9%，较前三季度回落 0.5 个百分点。四个地区电子信息制造业营业收入占全国比重分别为 68.0%、16.4%、14.9% 和 0.7%。</p><p><img height="310" src="https://oscimg.oschina.net/oscnet/up-b0043b1d7c4585093e396d4d7d5f544fe2a.png" width="500" referrerpolicy="no-referrer"></p><p>1—10 月份，规模以上电子信息制造业京津冀地区实现营业收入 5995 亿元、同比下降 6.3%，较前三季度降幅持平，营收占全国比重 5%；长三角地区实现营业收入 33990 亿元、同比下降 3.8%，较前三季度降幅收窄 1.1 个百分点，营收占全国比重 28.2%。</p><p><span style="color:#888888">（注：1.文中统计数据除注明外，其余均为国家统计局数据或据此测算。2.文中「电子信息制造业」与国民经济行业分类中的「计算机、通信和其他电子设备制造业」为同一口径。）</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 08:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268691</guid>
            <link>https://www.oschina.net/news/268691</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[滴滴向所有用户补偿 10 元无门槛打车通用券]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>滴滴出行今日就 11 月 27 日夜间发生的系统故障进行了说明，并再一次道歉。同时，滴滴还为所有用户派发了一张「致歉补偿券」，无门槛使用，立减 10 元。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f2fd281711327e482dba21d9ff535b24145.png" referrerpolicy="no-referrer"></p></blockquote><p>扫码领取：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-28207da7bde2ec3598e23358e58cbbeaafd.png" referrerpolicy="no-referrer"></p><p>滴滴表示，目前滴滴 App 的所有服务已经全部恢复。初步确定，这起事故的起因是底层系统软件发生故障，并非网传的「遭受攻击」，后续将深入开展技术风险隐患排查和升级工作，全面保障服务稳定性。</p><hr><p><strong>事件回顾</strong></p><ul><li><a href="https://www.oschina.net/news/268635" target="news">滴滴史上最严重服务故障，罪魁祸首是底层软件 or 「降本增笑」？</a></li><li><a href="https://www.oschina.net/news/268480" target="news">滴滴昨晚系统服务故障，技术团队连夜修复</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 07:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268677</guid>
            <link>https://www.oschina.net/news/268677</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[AWS 推出 AI 聊天机器人 Amazon Q]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">AWS 正式加入聊天机器人赛道，宣布推出一款名为 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Faws.amazon.com%2Fcn%2Fblogs%2Faws%2Famazon-q-brings-generative-ai-powered-assistance-to-it-pros-and-developers-preview%2F" target="_blank">Amazon Q</a> 的生成式 AI 助手；可以帮助用户完成工作中的各种任务，如聊天、生成内容和采取行动。</span></p><p><span style="color:#000000">根据介绍，Amazon Q 主要面向企业提供，旨在帮助员工完成日常任务，例如总结文档、填写内部文件以及回答有关公司政策的问题。其可供企业使用多种功能，包括开发应用程序、转换代码、生成商业智能、充当业务应用程序的生成式 AI 助手以及帮助客户通过 Amazon Connect 产品的服务代理。</span></p><p><span style="color:#000000"><img alt="" height="260" src="https://oscimg.oschina.net/oscnet/up-1f94a6a3ef5eecb740529e810e21d309130.png" width="700" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">AWS 首席执行官 Adam Selipsky 介绍称，Amazon Q 可以利用来自各种应用程序的业务数据，包括办公软件 Microsoft 365、企业协作软件 Slack、客户服务软件 Salesforce、网络储存应用 Dropbox 和 Amazon S3。目前开箱即用地支持 40 多种应用程序和服务。</span></p><p><span style="color:#000000">他还强调了安全和隐私的重要性，并表示 Amazon Q 尊重用户现有的身份、角色和权限，不会使用用户的内容来训练其底层模型。</span></p><p><span style="color:#000000">Selipsky 表示，AWS 已将许多功能融入 Amazon Q 中以帮助开发人员，其中包括允许程序员在构建应用程序时提出问题的自然语言对话功能。与此同时，该公司还在将 Amazon Q 集成到 Visual Studio Code 和 IntelliJ IDEA 等 IDE 中。</span></p><p><span style="color:#000000">Amazon Q 目前处于预览阶段，部分功能免费对外提供。亚马逊计划未来将面向企业用户收取每人每月 20 美元的费用，为开发人员和 IT 人员提供功能的版本则将收取每人每月 25 美元。</span></p><p><span style="color:#000000">更多详情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Faws.amazon.com%2Fcn%2Fblogs%2Faws%2Famazon-q-brings-generative-ai-powered-assistance-to-it-pros-and-developers-preview%2F" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 06:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268675/amazon-q</guid>
            <link>https://www.oschina.net/news/268675/amazon-q</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[AI 生成图片著作权侵权第一案宣判：被告构成侵权，赔偿 500 元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>11 月 29 日消息，近日，北京互联网法院针对<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrdzctOfPu9zQaKO4ZVDCwQ" target="_blank">人工智能生成图片（AI 绘画图片）著作权侵权纠纷</a></u>作出一审判决，据悉该案为 AI 生成图片相关领域著作权第一案。</p><p>法院最终判决，<strong>被告构成侵权，需向原告公开道歉，并赔偿 500 元</strong>。</p><p>据悉，原告李某使用 AI 生成涉案图片后发布于小红书平台；被告系百家号博主，发布文章配图使用了原告该 AI 生成的图片，原告遂起诉。</p><p>北互审理认为涉案人工智能生成图片（AI 绘画图片）具备「独创性」要件，体现了人的独创性智力投入，应当被认定为作品，受到著作权法保护等。</p><p><img alt="1701225443968.png" src="https://static.oschina.net/uploads/img/202311/29143541_fABc.png" referrerpolicy="no-referrer"></p><p><img alt="图片" src="https://static.oschina.net/uploads/img/202311/29143541_3GlB.png" referrerpolicy="no-referrer"></p><p>来源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FWu3-GuFvMJvJKJobqqq7vQ" target="_blank">https://mp.weixin.qq.com/s/Wu3-GuFvMJvJKJobqqq7vQ</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 06:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268672</guid>
            <link>https://www.oschina.net/news/268672</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Promise 规范与原理解析 | 京东物流技术团队]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><span><span>摘要</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Promise 对象用于清晰的处理异步任务的完成，返回最终的结果值，本次分享主要介绍 Promise 的基本属性以及 Promise 内部的基础实现，能够帮我们更明确使用场景、更快速定位问题。</span></span></span></p><span id="OSC_h1_2"></span><h1><span><span><span>Promise 出现的原因</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>首先我们先来看一段代码：异步请求的层层嵌套</span></span></span></p><pre><code><span><span><span>function fn1(params) {
  const xmlHttp = new XMLHttpRequest();
  xmlHttp.onreadystatechange = function(){
    if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
      const fn1Data = {name: 'fn1'}
      console.log(fn1Data, 'fn1Data');
      // 请求 2
      (function fn2() {
        xmlHttp.onreadystatechange = function(){
        if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
          const fn2Data = {name: `${fn1Data.name}-fn2`}
          console.log(fn2Data, 'fn2Data');
          // 请求 3
          (function fn2() {
            xmlHttp.onreadystatechange = function(){
            if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
              const fn3Data = {name: `${fn2Data.name}-fn3`}
              console.log(fn3Data, 'fn3Data');
            }
          }
          xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
          xmlHttp.send();
          })()
        }
      }
      xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
      xmlHttp.send();
      })()
    }
  }
  xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
  xmlHttp.send();
}

fn1()

</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>或者我们可以将上面的代码优化为下面这样</span></span></span></p><pre><code><span><span><span>function fn1(params) {
  console.log(`我是 fn1，我在函数${params}中执行！！！`);
}
  
function fn2(params) {
  try {
    const xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function(){
      if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
        console.log(`我是 fn2，我在函数${params}中执行！！！结果是：`,params.data);
        fn1('fn2')
      }
    }
    xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
    xmlHttp.send();
  } catch (error) {
    console.error(error);
  }
}
  
function fn3() {
  try {
    const xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function(){
      if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
          console.log('fn3 请求已完成');
          fn2('fn3')
      }
    }
    xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
    xmlHttp.send();
    console.log('我是 f3 函数呀');
  } catch (error) {
    console.error(error);
  }
}
  
fn3()

</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>由上面的两种写法的请求可见，在 promise 之前，为了进行多个异步请求并且依赖上一个异步请求的结果时，我们必须进行层层嵌套，大多数情况下，我们又对异步结果进行数据处理，这样使得我们的代码非常难看，并且难以维护，这就形成了回调地狱，由此 Promise 开始出现了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>回调地狱缺点</span></span></span></p><ul><li><span><span><span><span>代码臃肿</span></span></span></span></li><li><span><span><span><span>可读性差</span></span></span></span></li><li><span><span><span><span>耦合性高</span></span></span></span></li><li><span><span><span><span>不好进行异常处理</span></span></span></span></li></ul><span id="OSC_h1_3"></span><h1><span><span><span>Promise 的基本概念</span></span></span></h1><span id="OSC_h3_4"></span><h3><span><span><span>含义</span></span></span></h3><ol><li><span><span><span><span>ES6 将其写进了语言标准里统一了用法，是一个构造函数，用来生成 Promise 实例</span></span></span></span></li><li><span><span><span><span>参数为一个执行器函数 (执行器函数是立即执行的),该函数有两个函数作为参数，第一个参数是成功时的回调,第二个参数是失败时的回调</span></span></span></span></li><li><span><span><span><span>函数的方法有 resolve(可以处理成功和失败)、reject(只处理失败)、all 等方法</span></span></span></span></li><li><span><span><span><span>then、catch、finally 方法为 Promise 实例上的方法</span></span></span></span></li></ol><span id="OSC_h3_5"></span><h3><span><span><span>状态</span></span></span></h3><ol><li><span><span><span><span>pending --- 等待状态</span></span></span></span></li><li><span><span><span><span>Fulfilled --- 执行状态 （resolve 回调函数，then）</span></span></span></span></li><li><span><span><span><span>Rejected --- 拒绝状态 (reject 回调函数，catch)</span></span></span></span></li><li><span><span><span><span>状态一旦改变就不会再变，状态只可能是两种改变，从 pending-&gt;Fulfilled，pending-&gt;Rejected</span></span></span></span></li><li><span><span><span><span>有两个关键的属性：PromiseState --- 状态改变，PromiseResult --- 结果数据改变</span></span></span></span></li></ol><pre><code><span><span><span>const p1 = Promise.resolve(64)
const p2 = Promise.reject('我错了')
const p3 = Promise.then()
const p4 = Promise.catch()

// 状态改变 PromiseState 结果改变 PromiseResult
console.log(new Promise(()=&gt;{}), 'Promise');  // PromiseState='pending' PromiseResult=    
console.log(p1,'p1');  // PromiseState='Fulfilled' PromiseResult=64
console.log(p2,'p2');  // PromiseState="Rejected" PromiseResult='我错了'
console.log(p3, 'p3'); // then 为实例上的方法，报错
console.log(p4, 'p4');  // catch 为实例上的方法，报错
</span></span></span></code></pre><div><img alt="" height="457" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-14-14-59d8dPWcg59hoiOwx59.png" width="705" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h3_6"></span><h3><span><span><span>特点</span></span></span></h3><div><span>1.</span><span><span><span><span>错误信息清晰定位：可以在外层捕获异常信息（网络错误、语法错误都可以捕获），有「冒泡」性质，会一直向后传递，直到被捕获，所以在最后写一个 catch 就可以了</span></span></span></span></div><div><span>2.</span><span><span><span><span>链式调用：每一个 then 和 catch 都会返回一个新的 Promise，把结果传递到下一个 then/catch 中，因此可以进行链式调用 --- 代码简洁清晰</span></span></span></span></div><span id="OSC_h3_7"></span><h3><span><span><span>结果由什么决定</span></span></span></h3><span id="OSC_h4_8"></span><h4><span><span><span>resolve</span></span></span></h4><ol><li><span><span><span><span>如果传递的参数是非 Promise 类型的对象，则返回的结果是成功状态的 Promise 对象，进入下一个 then 里面</span></span></span></span></li><li><span><span><span><span>如果传递的参数是 Promise 类型的对象，则返回的结果由返回的 Promise 决定，如果返回的是 resolve 则是成功的状态，进入下一个 then 里，如果返回的是 reject 则是失败的状态，进入下一个 catch 里</span></span></span></span></li></ol><span id="OSC_h4_9"></span><h4><span><span><span>reject</span></span></span></h4><ol><li><span><span><span><span>如果传递的参数是非 Promise 类型的对象，则返回的结果是拒绝状态的 Promise 对象，进入下一个 catch 里面或者是下一个 then 的第二个参数 reject 回调里面</span></span></span></span></li><li><span><span><span><span>如果传递的参数是 Promise 类型的对象，则返回的结果由返回的 Promise 决定，如果返回的是 resolve 则是成功的状态，进入下一个 then 里，如果返回的是 reject 则是拒绝的状态，进入下一个 catch 里面或者是下一个 then 的第二个参数 reject 回调里面</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>这在我们自己封装的 API 里面也有体现：为什么 code 为 1 时都是 then 接收，其他都是 catch 接收，就是因为在 then 里面也就是 resolve 函数中对 code 码进行了判断，如果是 1 则返回 Promise.resolve()，进入 then 里处理，如果是非 1 则返回 Promise.reject()，进入 catch 里处理。</span></span></span></p><span id="OSC_h3_10"></span><h3><span><span><span>流程图</span></span></span></h3><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-14-14-59rKXgoFvRLU89IXE.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h3_11"></span><h3><span><span><span>简单使用</span></span></span></h3><pre><code><span><span><span>// 模拟一个 promise 的 get 请求
let count = 0
function customGet(url){
    count += 1
    return new Promise((resolve, reject)=&gt;{
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.open("GET",url, true);
        xmlHttp.onload = ()=&gt;{
          console.log(xmlHttp, 'xmlHttp---onload');
          if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
            console.log('customGet 请求成功了');
            // 返回非 Promise，结果为成功状态
            resolve({data:`第${count}次请求获取数据成功`})

            // 返回 Promise，结果由 Promise 决定
            // resolve(Promise.reject('resolve 中返回 reject'))
          } else {
            reject('customGet 请求错误了')
          }
        }

        // Promise 状态改变就不会再变
        // onreadystatechange 方法会被执行四次
        // 当地次进来的时候，readyState 不等于 4，执行 else 逻辑，执行 reject，状态变为 Rejected，所以即使再执行 if，状态之后不会再改变
        // xmlHttp.onreadystatechange = function(){
        //   console.log(xmlHttp,'xmlHttp---onreadystatechange')
        //   if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
        //     console.log('customGet 请求成功了');
        //     resolve({data:`第${count}次请求获取数据成功`})
        //   } else {
        //     reject('customGet 请求错误了')
        //   }
        // }
        xmlHttp.send();
      })
 }

// 使用 Promise，并且进行链式调用
customGet('https://v0.yiketianqi.com/api/cityall?appid=&amp;appsecret=').then((res)=&gt;{
   console.log(res.data);
   return '第一次请求处理后的数据'
}).then((data)=&gt;{
   console.log(data)
   // console.log(data.toFixed());
   return customGet('https://v0.yiketianqi.com/api/cityall?appid=&amp;appsecret=')
}).then((res)=&gt;{
   console.log(res.data);
}).catch((err)=&gt;{
    // 以类似'冒泡'的性质再外层捕获所有的错误
   console.error(err, '这是 catch 里的错误信息');
})

</span></span></span></code></pre><span id="OSC_h3_12"></span><h3><span><span><span>手写实现简单的 Promise</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>通过上面的回顾，我们已经了解了 Promise 的关键属性和特点，下面我们一起来实现一个简单的 Promise 吧</span></span></span></p><pre><code><span><span><span>  // 1、封装一个 Promise 构造函数，有一个函数参数
  function Promise(executor){
    // 7、添加对象属性 PromiseState PromiseResult
    this.PromiseState = 'pending'
    this.PromiseResult = null

    // 14、创建一个保存成功失败回调函数的属性
    this.callback = null

    // 8、this 指向问题
    const that = this

    // 4、executor 有两个函数参数（resolve，reject）
    function resolve(data){
      // 10、Promise 状态只能修改一次（同时记得处理 reject 中的状态）
      if(that.PromiseState !== 'pending') return

      // console.log(this, 'this');
      // 5、修改对象的状态 PromiseState
      that.PromiseState = 'Fulfilled'

      // 6、修改对象的结果 PromiseResult
      that.PromiseResult = data

      // 15、异步执行 then 里的回调函数
      if(that.callback?.onResolve){
        that.callback.onResolve(that.PromiseResult)
      }
    }
    function reject(data){
      console.log(that.PromiseState, 'that.PromiseState');
      if(that.PromiseState !== 'pending') return

      // 9、处理失败函数状态
      that.PromiseState = 'Rejected'
      that.PromiseResult = data
      console.log(that.PromiseResult, 'that.PromiseResult');
      console.log(that.PromiseState, 'that.PromiseState');

      // 16、异步执行 then 里的回调函数
      if(that.callback?.onReject){
        that.callback.onReject(that.PromiseResult)
      }
    }
    // 3、执行器函数是同步调用的，并且有两个函数参数
    executor(resolve,reject)
  }
  // 2、函数的实例上有方法 then
  Promise.prototype.then = function(onResolve,onReject){
    // 20、处理 onReject 没有的情况
    if(typeof onReject !== 'function'){
      onReject = reason =&gt; {
        throw reason
      }
    }
    // 21、处理 onResolve 没有的情况
    if(typeof onResolve !== 'function'){
      onResolve = value =&gt; value
    }
    // 17、每一个 then 方法都返回一个新的 Promise，并且把上一个 then 返回的结果传递出去
    return new Promise((nextResolve,nextReject)=&gt;{
      // 11、处理成功或失败
      if(this.PromiseState === 'Fulfilled'){
        // 12、将结果传递给函数
        // onResolve(this.PromiseResult)

        // 18、拿到上一次执行完后返回的结果,判断是不是 Promise
        const result = onResolve(this.PromiseResult)
        if(result instanceof Promise){
          result.then((v)=&gt;{
            nextResolve(v)
          },(r)=&gt;{
            nextReject(r)
          })
        } else {
          nextResolve(result)
        }
      }
      // 当你一步步写下来的时候有没有怀疑过为什么不用 else
       if(this.PromiseState === 'Rejected'){
            // 第 12 步同时处理此逻辑
            // onReject(this.PromiseResult)

            // 22、处理 catch 异常穿透捕获错误
            try {
              const result = onReject(this.PromiseResult)
              if(result instanceof Promise){
                result.then((v)=&gt;{
                  nextResolve(v)
                }).catch((r)=&gt;{
                  nextReject(r)
                })
              } else {
                nextReject(result)
              }
            } catch (error) {
              nextReject(this.PromiseResult)
            }
         }
  
      // 13、异步任务时处理成功或失败,想办法等异步任务执行完成后才去执行这两个函数
      if(this.PromiseState === 'pending'){
        this.callback = {
          onResolve,
          onReject
        }
        console.log(this.callback, 'this.callback');
      }
    })
  }
  // 19、函数实例上有方法 catch
  Promise.prototype.catch = function(onReject) {
    return this.then(null,onReject)
  }

  // 使用自定义封装的 Promise
  const customP = new Promise((resolve,reject)=&gt;{
    // 模拟异步执行请求
    // const xmlHttp = new XMLHttpRequest();
    // xmlHttp.open("GET",'https://v0.yiketianqi.com/api/cityall?appid=&amp;appsecret=', true);
    // xmlHttp.onload = ()=&gt;{
    //   if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
    //     resolve('success')
    //   } else {
    //     reject('error')
    //   }
    // }
    // xmlHttp.send();

    // 同步执行
    resolve('success')
    // reject('error')
  })

  console.log(customP, 'customP');
  customP.then((res)=&gt;{
    console.log(res, 'resolve 回调');
    return '第一次回调'
    // return new Promise((resolve,reject)=&gt;{
    //   reject('错错错')
    // })
  },(err)=&gt;{
    console.error(err, 'reject 回调');
    return '2121'
  }).then(()=&gt;{
    console.log('then 里面输出');
  }).then().catch((err)=&gt;{
    console.error(err, 'catch 里的错误');
  })

</span></span></span></code></pre><span id="OSC_h4_13"></span><h4><span><span><span>针对 resolve 中返回 Promise 对象时的内部执行顺序</span></span></span></h4><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-14-15-00IiDMseqfyk0DroM.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_14"></span><h1><span><span><span>总结</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>以上就是我们常用的 Promise 基础实现，在实现过程中对比了 Promise 和函数嵌套处理异步请求的优缺点，Promise 仍存在缺点，但是的确方便很多，同时更清晰的理解到错误处理如何进行异常穿透的，也能帮助我们更规范的使用 Promise 以及快速定位问题所在。</span></span></span></p><blockquote><p>作者：京东物流&nbsp;孙琦</p><p>来源：京东云开发者社区，自猿其说 Tech 转载请注明来源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Fri, 24 Nov 2023 01:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10150936</guid>
            <link>https://my.oschina.net/u/4090830/blog/10150936</link>
            <author>
                <![CDATA[京东云开发者]]>
            </author>
        </item>
    </channel>
</rss>
