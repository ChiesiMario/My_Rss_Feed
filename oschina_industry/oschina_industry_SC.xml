<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[开源中国-综合资讯]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 09 Jan 2024 08:24:05 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[GTK 将采用「统一渲染器」取代 OpenGL 和 Vulkan]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>GTK 近日合并了名为「Add new unified renderer」的 PR。</p><blockquote><p style="margin-left:0; margin-right:0">GTK (GIMP Toolkit) 是一套跨多种平台的图形工具包，最初为 GIMP 而写，GIMP 是指 GNU 图像处理程序 (GNU Image Manipulation Program)，GIMP 拥有几乎所有图象处理所需的功能，号称 Linux 下的 Photoshop。GTK 后来发展成为 Linux 下开发图形界面应用的主流开发工具。</p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-730b58563ec58c49ba1dd57df43a1e3cb9e.png" referrerpolicy="no-referrer"></p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.gnome.org%2FGNOME%2Fgtk%2F-%2Fmerge_requests%2F6588" target="_blank">根据描述</a></u>，该 PR 添加了新的<strong><span style="background-color:#e67e22">统一渲染器 (unified renderer)</span></strong>，又称「GPU 渲染器」。它取代了旧的 Vulkan 渲染器，并将最终取代 OpenGL。此举意味着 GTK 的现代 GPU 加速渲染向前迈出了一大步。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FGTK-Unified-Renderer-Progress" target="_blank">据介绍</a>，GTK 统一渲染器的主要补丁集有 24.8k 行新代码，同时删除了 9.6k 行现有代码。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 07:22:55 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274918/gtk-unified-renderer-progress</guid>
            <link>https://www.oschina.net/news/274918/gtk-unified-renderer-progress</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 称《纽约时报》的版权诉讼毫无根据]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">《纽约时报》曾于去年 12 月起诉 OpenAI 和微软公司，称这两家公司非法使用其受版权保护的材料来训练 AI 模型。时至今日，OpenAI 公开回击并发表了一篇<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Fblog%2Fopenai-and-journalism" target="_blank">博文称</a>：「我们支持新闻业，与新闻机构合作，并认为《纽约时报》的诉讼毫无根据。」</span></p><p><span style="color:#000000">该公司在博文中重申了以下四点立场：</span></p><ul><li><span style="color:#000000">我们与新闻机构合作并创造新的机会</span></li><li><span style="color:#000000">培训属于合理使用，但我们提供选择退出的机会，因为这是正确的做法</span></li><li><span style="color:#000000">「反刍（Regurgitation）」是一种罕见的错误，我们正在努力将其降至为零</span></li><li><span style="color:#000000">《纽约时报》没有讲述完整的事实</span></li></ul><p><img height="312" src="https://oscimg.oschina.net/oscnet/up-2b1881fb593ade980a7bc0e1308304de93c.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000">OpenAI 方面表示，其目标是支持健康的新闻生态系统、成为良好的合作伙伴、创造互利的机会；考虑到这一点，该公司一直在寻求与新闻机构建立合作伙伴关系。通过与美联社、Axel Springer、American Journalism Project 和纽约大学的早期合作，他们已经对相关方法有了初步了解。</span></p><p><span style="color:#000000">该公司认为，一些已经普遍被接受的先例表明，使用公开可用的互联网资料训练 AI 模型是属于合理使用范畴。「我们认为这一原则对创造者是公平的，对创新者是必要的，对美国的竞争力也是至关重要的。」</span></p><p><span style="color:#000000">而关于「反刍」问题，OpenAI 则解释道，他们已经采取了措施来限制非故意记忆，并防止大模型输出中的反刍现象。并指出，如果训练数据来自单一来源（如《纽约时报》），则反刍的可能性较小；同时也敦促用户"act responsibly"，避免故意促使其模型反刍。「故意操纵我们的模型进行反刍不是对我们技术的适当使用，也违反了我们的使用条款」。「反刍」是指特定内容在大模型的训练数据中多次出现的一种现象。</span></p><p><span style="color:#000000">OpenAI 透露与《纽约时报》的最后一次沟通是在 2023 年 12 月 19 日，「我们与《纽约时报》的讨论似乎取得了建设性进展......我们向《纽约时报》解释说，与任何单一来源一样，他们的内容对我们现有模型的训练没有任何有意义的贡献，也不会对未来的训练产生足够的影响。但他们于 12 月 27 日提起了诉讼 —— 我们是也通过《纽约时报》才了解到的 —— 这令我们感到惊讶和失望。」</span></p><p><span style="color:#000000">值得一提的是，OpenAI 称《纽约时报》在双方的沟通过程中已经发现了一些内容的反刍，但却在 OpenAI 承诺调查和解决任何问题的前提下，一再拒绝分享任何示例。</span></p><blockquote><p><span style="color:#000000">有趣的是，《纽约时报》<span style="background-color:#f8f9f9">提到的反刍</span>似乎来自于多个第三方网站上大量传播的多年前的文章。为了让我们的模型进行反刍，他们似乎有意篡改了提示语，通常包括冗长的文章节选。即使在使用此类提示时，我们的模型通常也不会像《纽约时报》影射的那样，这表明他们要么是指示模型进行反刍，要么是从众多尝试中精心挑选了一些示例。</span></p><p><span style="color:#000000">尽管他们声称，这种误用并非典型或允许的用户行为，也不能替代《纽约时报》。但无论如何，我们都在不断提高系统的抗逆向攻击能力，以避免训练数据被反刍，并在最近的模型中取得了很大进展。</span></p></blockquote><p><span style="color:#000000">在声明的最后，OpenAI 表示，尽管他们<span style="background-color:#ffffff">认为《纽约时报》的诉讼毫无根据；但仍然对《纽约时报》保持尊重并希望与其建立建设性的合作伙伴关系。「我们期待与新闻机构继续合作，通过实现 AI 的变革潜力，帮助他们提高生产高质量新闻的能力。」</span></span></p><p><span style="color:#000000">OpenAI 做出回应之际，围绕生成式 AI 的版权争论正值白热化。一些数据表明，公众更倾向于站在媒体出版商这一方。The AI Policy Institute 最近的一项民意调查结果显示，当得知《纽约时报》起诉 OpenAI 的详情后，59% 的受访者同意 AI 公司不应该被允许使用出版商的内容来训练模型；70% 的受访则表示，如果这些公司想在模型训练中使用受版权保护的材料，就应该向出版商提供补偿。</span></p><p><strong><span style="color:#000000">延伸阅读：</span></strong></p><ul><li><a href="https://www.oschina.net/news/274326/openai-offers-publishers-little-1m" target="news">OpenAI 拟每年投入 100-500 万美元，以获取新闻使用许可</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 07:12:55 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274916/openai-and-journalism</guid>
            <link>https://www.oschina.net/news/274916/openai-and-journalism</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[开源神器 LSPosed 宣布停更，作者称遭受大量恶意攻击]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Android 平台 Xposed Framework 的替代实现版本 LSPosed 宣布停止维护，目前 LSPosed 的 GitHub 仓库已经设置为只读状态。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">LSPosed 是一个 Magisk<span>&nbsp;</span><span><span><span>模块，尝试提供一个 ART hooking 框架，该框架提供与 OG Xposed 一致的 API，其利用 LSPlant hooking 框架。</span></span></span></p><p><img src="https://oscimg.oschina.net/oscnet/up-75beeed327a7d34771f31dd9958c3920723.png" referrerpolicy="no-referrer"></p><p><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FLSPosed%2FLSPosed" target="_blank">https://github.com/LSPosed/LSPosed</a></em></u></p><p>对于停止开发的原因，开发者在其订阅频道中表示停止维护的主要原因是出现许多谣言、诽谤、种族主义和咒骂等。同时开发者也受到 Magisk 社区的一些咒骂，因此开发者决定休息，停止开发和维护。</p><p><img src="https://oscimg.oschina.net/oscnet/up-c9dc6d212bdbe837a4322248a364756b5ff.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 03:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274877</guid>
            <link>https://www.oschina.net/news/274877</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[渠成开源社区 2023 年工作总结]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span>「道虽迩，不行不至；事虽小，不为不成。」2023 年，对渠成开源社区来说，是不平凡的一年，更是值得回味的一年。</span></p><p><span>这一年，我们从零搭建了渠成开源社区，确定了工作组成员；</span></p><p><span>这一年，我们链接了开源作者/开源社区，为他们提供了服务；</span></p><p><span>这一年，我们举办了多场活动，为更多用户创建了彼此交流的机会；</span></p><p><span>……</span></p><p><span>回望 2023 年，渠成开源社区所经历的惊喜与感动，都离不开社区中每位伙伴的陪伴和努力。我们不断迭代、不断创新，我们共同走过的每一个瞬间都值得纪念与庆贺。</span></p><p style="text-align:center"><span><strong>一、从 0 到 1 搭建社区</strong></span></p><p><strong><em>1&nbsp;</em>成立社区工作组</strong></p><p><span>2023 年 4 月，我们确定了<strong>渠成开源社区的工作组团队</strong>，包括顾问专家、市场运营、产品规划、网站开发、设计以及财务几大角色。期间完善了社区相关运营机制，包括不限于确定社区 23 年的目标、完善社区的媒体账号、确定社区对外信息公开机制等。</span></p><p><span>社区的对外信息公开机制，真正让社区内每一次的会议、每一笔的支出都做到有迹可寻。在官网的「<strong>财务公开</strong>」版块，现已公开了 2021 年 11 月-2023 年 11 月渠成开源社区的现金流水账。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>2023 年，工作组共开展了<strong>13 场</strong>的会议，工作组成员在会上提出各项社区成员关注的问题，共同探讨以提供相应的解决方案。往期会议详情可在渠成开源社区官网查看：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qucheng.cc%2Fmeetings.html" target="_blank" rel="nofollow"><span>https://www.qucheng.cc/meetings.html</span></a></p><p><strong><em>2&nbsp;</em></strong><span><strong>搭建官方媒体矩阵</strong></span></p><p><span>2023 年 4 月，我们上线了<strong>渠成开源社区官网</strong>（</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qucheng.cc%2F" target="_blank" rel="nofollow"><span>https://www.qucheng.cc/</span></a><span>）</span><span>，详细介绍了社区的定位、章程、会员入驻机制和会员权益等。同时，为了方便大家从多渠道、多途径了解开源项目，我们还开通渠成开源社区的微信公众号、视频号、Bilibili、开源中国、知乎号、GitHub 等社媒账号。</span></p><ul><li><p><span>微信公众号：</span><strong>渠成开源社区</strong></p></li><li><p><span>视频号、Bilibili、开源中国、知乎号：渠成开源社区</span></p></li><li><p><span>GitHub：</span><span>@QuCheng-OpenSource</span></p></li></ul><p style="margin-left:0px; margin-right:0px; text-align:center"><span><span><strong>二</strong><strong>、</strong></span><strong>链接开源生态中的各种角色</strong></span></p><p><strong><em>1&nbsp;</em></strong><span><strong>链接开源作者/开源社区</strong></span></p><ul><li><p><strong><span>持续邀请开源项目入驻社区</span></strong></p></li></ul><p><span>我们欢迎更多的开源项目可以入驻渠成开源社区，社区会为会员项目<strong>提供项目运营、周边设计、赞助招募、法律咨询以及商业化咨询等多项服务。</strong></span></p><p><span>截至目前，已有<strong>39 个项目</strong>入驻渠成开源社区，成为了渠成开源社区的会员项目。会员项目可享受入驻渠成 Demo 中心的权益，让所有人都能在线体验会员项目的 Demo，轻松实现高可用。同时，渠成开源社区所接受的捐赠与赞助会根据捐赠方或赞助方的意愿使用该资金，用于鼓励、支持社区会员的开源项目。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:center"><img alt="" height="383" src="https://oscimg.oschina.net/oscnet/up-0a2fc114545f42267ae6fc4321861ef99e5.jpg" width="600" referrerpolicy="no-referrer"></p><ul><li><p><strong><span>持续设计开源周边产品</span></strong></p></li></ul><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>为帮助各个开源项目提高知名度，同时让更多开源软件的粉丝获取相关周边产品，我们与国内外数十个开源项目联络，获取各大开源项目的授权，使用其 Logo 设计出精美的周边 T 恤。我们已将 T 恤设计稿开源至 GitHub，供大家下载与使用：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FQuCheng-OpenSource%2FT-shirt" target="_blank" rel="nofollow"><span>GitHub - QuCheng-OpenSource/T-shirt</span></a></p><ul><li><p><strong><span>打造社区礼品体系</span></strong></p></li></ul><p><span>渠成开源社区官网的「<strong>开源周边</strong>」板块已上架了我们为各开源项目设计的周边 T 恤，用户可以直接在线下单购买。周边产品的所有销售利润，均会公开透明地用于到社区发展中。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0px; margin-right:0px; text-align:center"><img alt="" height="237" src="https://oscimg.oschina.net/oscnet/up-f3b16af9cf4e22ea243581eeac04c5bd5f0.jpg" width="600" referrerpolicy="no-referrer"></p><ul><li><p><strong><span>持续上线官网新版块</span></strong></p></li></ul><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>2023 年，根据用户反馈和日常讨论，<strong>我们在官网上线了开源动态和社区活动两个板块。</strong>用户可以在官网的「开源动态」板块进行在线投稿。同时，社区公众号邀请了众多优秀开源作者开放白名单，以帮助转发推广文章与活动。</span></p><p><strong><em>2&nbsp;</em></strong><span><strong>传递社区价值主张</strong></span></p><ul><li><p><span><strong>发起「源来是你」系列栏目</strong></span></p></li></ul><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>本着为更多开源相关的用户提供更好的服务原则，切实帮助每一个开源软件实现商业化。我们搜集了大家关心的各类问题。分别在北京、上海两地分别<strong>举办了</strong><strong>2 场专场沙龙活动，开展了 4 期线上直播，涵盖了商业沟通、产品定价、法律风险规避等多个主题。线上线下共参与人数达 1218 人。</strong></span></p><ul><li><p><strong><span>出品《开源商业化白皮书》</span></strong></p></li></ul><p><span>开源软件发挥着越来越重要的作用，但国内没有建立起一个开源软件商业化的生态体系。为此，渠成开源社区组织撰写了白皮书，<strong>探讨了国内开源现状、常见的开源商业模式、如何做开源商业化等多个方面</strong>，希望为开源软件作者、贡献者以及创业者提供了实际的商业化落地建议。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:center"><img alt="" height="385" src="https://oscimg.oschina.net/oscnet/up-376a4a0355e49acb1a584a0eac177637db7.jpg" width="600" referrerpolicy="no-referrer"></p><ul><li><p><strong><span>多次参与国内各项大会活动</span></strong></p></li></ul><p style="text-align:center"><img alt="" height="450" src="https://oscimg.oschina.net/oscnet/up-d2ba2578656efd103183dbb7237b299f6a6.jpg" width="600" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>渠成开源社区积极投入到国内的开源布道，陆续参加了 2023 上海人工智能大会开源集市、开源社 2023 开源年会、DevOps 社区广州峰会等活动，以传递社区的价值主张。<strong>为了能够与众多开源社区保持友好联系，我们创建了社区合作伙伴群，持续分享有价值的开源信息，积极促成合作，共同推动开源事业的发展。</strong></span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><span><strong>三</strong></span><span><strong>、</strong></span><strong>欢迎入驻社区</strong></p><p><span>如果您正在经营一个开源项目，如果您有开源商业化的诉求，<strong>欢迎携项目入驻渠成开源社区</strong></span><span>：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qucheng.cc%2Fproject.html" target="_blank" rel="nofollow"><strong><span>开源项目—项目入驻</span></strong></a><span>。审核通过后，我们将拉您进入项目作者群。在这里，您可以与各位开源创业者共同交流、共同成长。</span></p><p style="text-align:center"><strong>欢迎扫码查看官网</strong></p><p style="text-align:center"><img alt="" height="300" src="https://oscimg.oschina.net/oscnet/up-ce97b5277dc03f6cb550c89d44660add1b3.png" width="300" referrerpolicy="no-referrer"></p><p><span>很多时候，我们会被星辰大海的征途所鼓动，进而热血沸腾。可实际上，所有的大事都要从小事做起，从细节着手。渠成开源社区，一直秉承的就是这样的态度，踏踏实实为中国开源软件事业做贡献。正因如此，渠成开源社区在 2023 年的努力得到了国内知名开源技术社区开源中国（OSCHINA）的肯定，荣获 OSCHINA 2023 年度 「<strong>优秀开源技术团队</strong>」荣誉称号。</span></p><p><span>征途漫漫从头越，奋楫扬帆向未来。2024 年，渠成开源社区将服务更多的开发者，帮助大家解决实实在在的问题。<strong>我们期待有更多的开源项目加入社区，也期待与各开源开发者一起携手打造适合中国国情的开源软件生态。</strong>&nbsp;</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 03:53:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6928219/blog/10712985</guid>
            <link>https://my.oschina.net/u/6928219/blog/10712985</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Unity 将裁员 25%，涉及 1800 人]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#222222">电子游戏引擎厂商 Unity 计划裁员 25%，削减近 1800 个工作岗位。该公司在向</span>美国证券交易委员会<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fd18rn0p25nwr6d.cloudfront.net%2FCIK-0001810806%2Ffa621098-7a4d-4e51-8f59-725dc0210b98.pdf" target="_blank">提交的文件</a>中表示，进行裁员是「为了重组和重新聚焦于核心业务，并<span style="background-color:#ffffff; color:#222222">提高长期盈利能力</span>」。</p><p><img height="260" src="https://oscimg.oschina.net/oscnet/up-aa72d8f006422f94c3ee97fa70136996b11.png" width="700" referrerpolicy="no-referrer"></p><p>Unity 的公关总监 Kelly Ekins 在给 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2024%2F1%2F8%2F24030695%2Funity-layoff-staff-25-percent" target="_blank">The Verge</a> 的一份声明中表示：</p><p>"今天，作为我们在 2023 年 11 月 9 日《股东信》中概述的公司重组的一部分，我们宣布 Unity 做出了一个艰难的决定，即实施裁员，目标是裁减我们所有团队总人数的约 25%。这个决定并不容易，我们向那些受到影响的员工表示最深切的感谢，感谢他们的奉献和贡献。"</p><p>事实上，<span style="background-color:#ffffff; color:#222222">Unity </span>在过去一年已经经历了多次裁员。<span style="color:#000000">最近一次裁员是在去年 11 月，</span><span style="background-color:#ffffff; color:#222222">Unity 终止与《指环王》导演 </span><span style="background-color:#ffffff; color:#333333">Peter Jackson</span>&nbsp;<span style="background-color:#ffffff; color:#222222">创办的视觉特效公司 Weta FX 所达成协议中的专业服务部分。与该协议有关的 <a href="https://www.oschina.net/news/268858/unity-software-cut-38-staff">265 名员工被解雇</a>，占公司当时全球员工总数的 3.8%。</span></p><p><span style="background-color:#ffffff; color:#222222">在此之前，</span><span style="background-color:#ffffff; color:#333333">Unity 刚宣布了新的定价模式。在引起业内人士的强烈不满之后，Unity 向公众和业内人士道歉，并调整了收费规则，</span><span style="background-color:#ffffff; color:#222222">但其前首席执行官 John Riccitiello 也因此辞职。</span></p><p><span style="background-color:#ffffff; color:#222222">此外，Unity 还宣布将关闭德国柏林和新加坡等 14 个地区的办公室，并大幅缩减包括旧金山和华盛顿贝尔维尤在内的其余办公室面积。</span></p><p><strong><span style="background-color:#ffffff; color:#222222">相关阅读：</span></strong></p><ul><li><u><em><a href="https://www.oschina.net/news/257929/unity-runtime-fee">Unity 引擎明年起根据游戏安装量收费 (runtime fee)</a></em></u></li><li><u><em><a href="https://www.oschina.net/news/258513/unity-apologize-for-runtime-fee">Unity 道歉：将修改 "runtime fee" 收费政策</a></em></u></li><li><u><em><a href="https://www.oschina.net/news/258477/wait-is-unity-allowed-to-just-change-its-fee-structure-like-that">走近 「收费门」：互相矛盾的服务条款导致 Unity 面临被起诉的风险</a></em></u></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 03:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274868/unity-layoff-staff-25-percent</guid>
            <link>https://www.oschina.net/news/274868/unity-layoff-staff-25-percent</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[女高管开除员工事件后续：公司董事长称员工「惯犯」并质疑「学历简历造假」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p><em><strong>前情提要：<u><a href="https://www.oschina.net/news/274850" target="news">被女高管违法开除员工发声，因反对用盗版 EDA 工具设计芯片遭针对</a></u></strong></em></p></blockquote><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffinance.sina.com.cn%2Ftech%2Fshenji%2F2024-01-09%2Fdoc-inaawvsf7734023.shtml" target="_blank">根据新浪科技的独家报道</a></u>，针对「女高管违法开除员工」一事，涉事公司董事长陈怡然今日在与新浪科技沟通中回应了此事，并进一步透露称，<strong>被开除员工可能涉嫌「学历造假、简历造假」，此前一路讹了多家公司，「惯犯了」</strong>。</p><p>近日，一段「公司女高管违法开除员工」的视频在社交网络上流传。网传视频内容显示，一名公司女高管井某与视频拍摄者孙某因解除劳动合同产生了矛盾。视频中，拍摄者孙某指出公司存在违法解除劳动合同的行为，井某则回应称，「我就违法了，怎么着？我就是违法解除，你去告我吧！我让你两年半找不到工作，我下个月有饭吃，你自己想想吧。」</p><p>据悉，女高管在北京尼欧克斯科技有限公司工作，该公司又名苹芯科技。此前有消息称，井某系该公司董事长的大学同学。</p><p>董事长陈怡然向新浪科技澄清，称「双方并非大学同班同学」，此外，事发时他并不知情，「也压根不知道这个人的招聘和离职，直到有人将视频转发给我」。同时，他还透露称员工孙某或系「惯犯」，此前可能「学历造假、简历造假」，曾「一路讹了多家公司，又找到了新苦主了」。</p><p>「我只能说这事上政府查过了，公司程序并无瑕疵。」陈怡然表示。</p><p>此前，北京尼欧克斯科技有限公司也发布声明称：网传我司人力员工井某与前员工孙某因解除劳动关系出现争执，井某发表不当言论，已责令其停职反省并严肃处理。前员工孙某于 2023 年 6 月 25 日入职，签订 3 年劳动合同及保密与竞业限制协议，试用期 6 个月。因工作能力不胜任，决定不予通过试用期。经协商一致，12 月 1 日双方签署解除劳动关系协议，我司按照协议于 12 月 8 日足额支付了 11 月份工资及离职补偿金。以上程序均依法合规处理。</p><p>目前，双方已就离职补偿达成协议。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 03:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274858</guid>
            <link>https://www.oschina.net/news/274858</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[被女高管违法开除员工发声，因反对用盗版 EDA 工具设计芯片遭针对]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p><em>后续：<strong><u><a href="https://www.oschina.net/news/274858" target="news">女高管开除员工事件后续：公司董事长称员工「惯犯」并质疑「学历简历造假」</a></u></strong></em></p></blockquote><p>近日「女高管违法开除员工」事件在网上引起争议。网传视频显示，一位女子与视频拍摄者疑似就解除劳动合同产生了矛盾。</p><p>视频中，拍摄者指出公司存在违法解除劳动合同的行为，该女子回应称，「我就违法了，怎么着？我就是违法解除，你去告我吧！我让你两年半找不到工作，我下个月有饭吃，你自己想想吧。」</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-599c10f7c4239b1ea57ee669a901a765353.png" referrerpolicy="no-referrer"></p><p>现在，疑似被开除员工在网上发声，他自称是被女高管开除的男员工，称北京尼欧克斯又名苹芯科技，所谓女高管停职不可能的，女高管井玥是清华 94 级无线电毕业，跟公司大老板杜克教授陈怡然是清华同班同学，关系铁的很，敷衍一下过阵子又回去了。</p><p>他谈到，自己被开除的原因是他反对苹芯（尼欧克斯）使用盗版 EDA 工具设计芯片，因为盗版设计出的芯片可能有 Bug，质量无法保证。苹芯把 IC 核心研发业务外包，开除原因是他反对什么都外包，打铁还需自身硬；PimChip 芯片覆盖率只有 20% 多就拿去投片，「清华帮」趁着国产替代跑去投机蹭芯片风口。</p><p>疑似被开除男员工还表示，他去年 8 月份急着从上一个项目脱身，迅速将 resource 投入下一个项目，当时井玥拍桌子怒吼：「你从小就没有教养」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8020424bc0a40d59a9981ebbcd6e721db4b.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274850</guid>
            <link>https://www.oschina.net/news/274850</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[超 200K Star 的 Dromara 开源社区的年终总结，请查收!]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>过去一年大家见证了 Dromara 开源社区的飞速发展，社区的进步离不开社区成员们的，社区下开源项目贡献者们的辛勤劳动贡献和触达用户们，开源爱好者们的大力支持，对此我们感激不尽。</p></blockquote><p>接下来我们看看社区这 2023 一年的成长吧！</p><h2>新增捐赠孵化 20+ 非常棒的开源项目，目前社区下的总项目数量超 50 个。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-cd45685d0d58c390c2a602b6fa8b4f993d2.png" referrerpolicy="no-referrer"></p><h2>社区下孵化项目 HertzBeat, Dynamic-Tp, Easy-Es 发展迅速，成功毕业成为社区顶级开源项目。云原生大数据平台 CloudEon 成为被评为 Gitee GVP (Gitee 最具价值开源), 目前 Dromara 社区下的 GVP 项目数量已达到 16 个。社区下开源实时监控 HertzBeat 被 CNCF 全景图收录。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-57dd1fe6b9e62ba97232f902938e10c0d5e.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-c665b706e30849fdccba304c6f3226bd098.png" referrerpolicy="no-referrer"></p><h2>在 Gitee 和 Github 平台上，Dromara 社区项目总共获得超 200K star 小星星🌟，和，数不清的 Fork Watch 次数 (偷懒了😂)。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0e7dd59596493651ef93f0b787bf91d26a7.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e1a07f1f7757b3920a6bce244c954b50320.png" referrerpolicy="no-referrer"></p><p><strong>2023 年这一年社区下开源项目在 Github 平台上新增 2 万，颗小星星，PR 数量 1000+，Issues 数量 1400+</strong></p><h2>社区下开源项目作为课题项目成功参与中科院的 OSPP 开源之夏和计算机学会的 GLCC 编程夏令营活动，申请的同学们热情很高，最终中选的同学在导师的指导下顺利完成课题项目并结项。祝贺他们㊗️。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-039817cad68c8914e145aa186c735bc42b9.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-c83015dfabd64150f30a6c081082afbeb82.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-5252b18b809174ab7ab7264ebb9d1d3c011.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a2d294f2653e0b5fba7efb586b816d5013c.png" referrerpolicy="no-referrer"></p><h2>5 月 Dromara 参展全球开源技术峰会 GOTC，社区小伙伴的在上海线下面基成功，+薅了很多羊毛。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-00d418cbf39fcd588c3fd257bfd7d9a884e.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-72c42499ed92108ce0cbfa33de5f427e87b.png" referrerpolicy="no-referrer"></p><h2>7 月 Dromara 参加华为云开发者大会，社区小伙伴们又东莞线下面基一波，三位小伙伴做了 Dromara 与华为云开源主题分享，收获满满。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0eee75600e49e8fcf942ecb738bdd651c00.png" referrerpolicy="no-referrer"></p><h2>10 月 Dromara 参加了 COSCon'23 中国开源年会，社区小伙伴们又成都线下面基一波，我们准备的小礼品很受欢迎，社区小伙伴做了关于社区项目的主题分享。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0f6ec31ce57910497c6c6ac659c922b419f.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e563f49ea48de821e2f0207c7af025a2545.png" referrerpolicy="no-referrer"></p><h2>12 月 Dromara 参加了 2023 开放原子开发者大会，虽然没有面基成功 (下次一定)，但是社区大佬明哥在会上给开源同行们分享介绍了我们社区，收获满满+1。</h2><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9dccc42b3cbf031c94c3e5dda2b80e99d3d.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-cb265cd99f93341e99b2f6bde68a2bb05e9.png" referrerpolicy="no-referrer"></p><h2>关于荣誉</h2><blockquote><p>荣获中国开源创新大赛优秀奖, 2023 年度最受关注喜爱的开源组织和最活跃组织之一, 掘金 2023 年度人气团队等。</p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-15a7659a08f3aeb5aa3ccebd13fcaa3c608.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-126e2fd2fbfcda5620d434d66220f85ad07.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ec2a4083fc9ffe0899aa0a5e46fa9fd65a6.png" referrerpolicy="no-referrer"></p><h4>还有更多事件在 2023 年的 Dromara 发生。。。就先列举到这里了</h4><blockquote><p>社区下项目团队在 2023 年也发布了无数个版本，维护者上万人的开源社群，回答并帮助解决了数不清的用户问题，安装量，下载量，被引用量都是以万的单位计数。这一切此时此刻依然正在发生。</p></blockquote><p><strong>2023 已然结束，期待 2024 更加美好！</strong></p><p><strong>船新官网: <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdromara.org%2F" target="_blank">https://dromara.org/</a></strong><br><strong>Github: <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdromara" target="_blank">https://github.com/dromara</a></strong><br><strong>Gitee: <a href="https://gitee.com/dromara">https://gitee.com/dromara</a></strong></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:17:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274844</guid>
            <link>https://www.oschina.net/news/274844</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[北京司法鉴定所破解 AirDrop 匿名溯源]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>北京市司法局微信公众号「京司观澜」<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fhy6zPU2y_lR1cgMnmP1IbQ" target="_blank">发文称</a></u>，北京网神洞鉴司法鉴定所对手机「隔空投送」传播不当信息案件的司法鉴定突破了 AirDrop 匿名溯源的技术难题，提升了案件侦破的效率和准确性，防止了不当言论的进一步传播和潜在的恶劣影响。</p><p>iPhone 的 AirDrop 功能用于在苹果设备之间「匿名」共享文件，这些设备无需连接同一局域网，且无需接收方为通讯录联系人。</p><p><img alt="" height="509" src="https://oscimg.oschina.net/oscnet/up-c0ec4f267efa1fcbecd3a436f62bb40e799.png" width="300" referrerpolicy="no-referrer"></p><p>司法鉴定所的专家通过分析 iPhone 设备日志，发现发送者的设备名、邮箱和手机号相关字段，<strong>其中手机号与邮箱相关字段是以哈希值的形式记录，且哈希值部分字段被隐藏</strong>。</p><p>北京网神洞鉴司法鉴定所的司法鉴定技术专家们通过深度解析 iPhone 设备日志，明确传输原理，找出了与 AirDrop 相关的记录。经检验发现发送者的设备名、邮箱和手机号相关字段，其中手机号与邮箱相关字段是以哈希值的形式记录，且哈希值部分字段被隐藏。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-83eeeb8a2bc7d373aada3f0f5f141335c92.png" referrerpolicy="no-referrer"></p><p>△AirDrop 哈希值转换工具</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ece996136f3eb01c07f94d9ed812b2e8a1d.png" referrerpolicy="no-referrer"></p><p>△隔空投送取证溯源</p><p>为实现快速破解该字段，<strong>技术团队制作了一张详尽的手机号与邮箱账号「彩虹表 」，能够将密文转换成原始文本，快速锁定发送者的手机号与邮箱账号</strong>。&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274843</guid>
            <link>https://www.oschina.net/news/274843</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[虽迟但到！MySQL 可以用 JavaScript 写存储过程了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>任何能用 JavaScript 来干的事情，最终都会用 JavaScript 来干</p></blockquote><h2>背景</h2><p>不久前，Oracle 在 MySQL 官方博客<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.oracle.com%2Fmysql%2Fpost%2Fintroducing-javascript-support-in-mysql" target="_blank">官宣了</a>在 MySQL 中支持用 JavaScript 来写存储过程。</p><p><img src="https://oscimg.oschina.net/oscnet/up-31abaabbc716421cb6516bf32657d2f1527.png" alt="file" referrerpolicy="no-referrer"></p><p>最流行的编程语言 + 最流行的数据库。程序员不做选择，当然是全都要。</p><p><img src="https://oscimg.oschina.net/oscnet/up-e39605d191281540f71e825f686f15c7a6f.png" alt="file" referrerpolicy="no-referrer"></p><h2>使用方法</h2><p>用 JavaScript 写存储过程的示例</p><p><img src="https://oscimg.oschina.net/oscnet/up-40ae1df9662c4efc0104883c69bc2517326.png" alt="file" referrerpolicy="no-referrer"></p><p>在 SQL 中调用</p><p><img src="https://oscimg.oschina.net/oscnet/up-33872be6f36f152268f4056e7ad7961b89a.png" alt="file" referrerpolicy="no-referrer"></p><p>Debug 依然是 print + throw 大法</p><p><img src="https://oscimg.oschina.net/oscnet/up-19512efc33452b3ae4fb7bf7ba9e1e12342.png" alt="file" referrerpolicy="no-referrer"></p><p>Oracle 通过自家的 GraalVM 来保证在 MySQL 中执行 JavaScript 的安全性和性能。</p><p><img src="https://oscimg.oschina.net/oscnet/up-287e034c12abfa5b480cbb42bfd66100db8.png" alt="file" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-a7976a65fd5cb74e1e3f7287f834443dc58.png" alt="file" referrerpolicy="no-referrer"></p><h2>业界评论</h2><p>虽然这个功能还在预览阶段，并且只在 MySQL 企业版以及 HeatWave 云服务上提供，但还是引起了巨大反响。Reddit 网友金句频出</p><p><img src="https://oscimg.oschina.net/oscnet/up-fbba7393022d7517b30dbcd00c7f76ce45d.png" alt="file" referrerpolicy="no-referrer"></p><p>又一大波 JS 框架即将到来</p><p><img src="https://oscimg.oschina.net/oscnet/up-9da6f07f451ece47fccfc858cc062a4cf61.png" alt="file" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-04d3f48d68d405de781a02ba7a948abb52d.png" alt="file" referrerpolicy="no-referrer"></p><p>任何能用 JavaScript 来干的事情，最终都会用 JavaScript 来干 - Jeff Atwood (Stack Overflow 联合创始人)</p><p><img src="https://oscimg.oschina.net/oscnet/up-edb7e08bad7336b2291a826261d86dd2791.png" alt="file" referrerpolicy="no-referrer"></p><p>对呀，干嘛不直接叫 jQuery 呢？</p><p>另一边 Hacker News 网友也不甘示弱。</p><p><img src="https://oscimg.oschina.net/oscnet/up-fd369f9f8f9da6ae078c178abb2884e9306.png" alt="file" referrerpolicy="no-referrer"></p><p>「太酷辣，我在 Snowflake 里都是用 JavaScript 写存储过程来生成视图。缺点是把不同语言揉在一起，会让代码变得不可读。但优点是我的饭碗稳了，因为分析师们无法同时理解 SQL 和 JavaScript，而必须依赖我去帮他们更新。」</p><h2>结束语</h2><ol><li>MySQL 在数据库圈的话题性很强，但碰上 JavaScript，发现梗完全不够用呀。</li><li>这次官宣的第一作者，之前也曾在阿里云数据库团队工作过 3 年。</li></ol><p><img src="https://oscimg.oschina.net/oscnet/up-f77257c586e82036c86d393181de11f7bb9.png" alt="file" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-0ed6070e29a07aa8c892fbd246b8a411b82.png" alt="file" referrerpolicy="no-referrer"></p><ol start="3"><li>PostgreSQL 依然「遥遥领先」，毕竟通过 PLV8 写 JavaScript 都不知道是多久以前的事情了。</li></ol><hr><p>💡 更多资讯，请关注 Bytebase 公号：Bytebase</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6148470/blog/10712918</guid>
            <link>https://my.oschina.net/u/6148470/blog/10712918</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[DreamTalk —— 音频驱动型表情包生成框架]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>DreamTalk 是一种基于 diffusion 的音频驱动型表情包生成框架，可以生成高质量的表情包视频，涵盖多种说话风格。DreamTalk 在处理各种输入（包括歌曲、多语言语音、嘈杂音频和域外肖像）时表现出强劲的性能。</p><p>具体来说，DreamTalk 由三个关键组件组成：去噪网络、风格感知唇部专家和风格预测器。基于扩散的去噪网络能够一致地合成不同表情的高质量音频驱动的面部运动。为了增强唇部动作的表现力和准确性，项目团队引入了风格感知型唇部专家，可以指导唇部同步，同时注意说话风格。为了消除对表情参考视频或文本的需要，利用额外的基于扩散的风格预测器直接从音频预测目标表情。通过这种方式，DreamTalk 可以利用强大的扩散模型有效地生成富有表现力的面孔，并减少对昂贵的风格参考的依赖。</p><p>实验结果表明，DreamTalk 能够生成具有多种说话风格的逼真说话面孔，并实现准确的嘴唇动作，超越了现有最先进的同类产品。</p><p><img alt="" height="214" src="https://static.oschina.net/uploads/space/2024/0105/161846_cUbY_4252687.gif" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:10:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/dreamtalk</guid>
            <link>https://www.oschina.net/p/dreamtalk</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推荐 | 使用 TypeScript 开发的可视化库 VISLite]]>
            </title>
            <description>
                <![CDATA[<ul><li>💘 开源不易，去 <i><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Foi-contrib%2FVISLite">Github 给个 Star</a></i>吧！</li></ul><img src="https://oi-contrib.github.io/VISLite/images/logo.png" height="300px" referrerpolicy="no-referrer"><p><a href="https://gitee.com/link?target=https%3A%2F%2Fzxl20070701.github.io%2Ftoolbox%2F%23%2Fnpm-download%3Fpackages%3Dvislite%26interval%3D7"><img src="https://img.shields.io/npm/dm/vislite.svg" alt="downloads" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvislite"><img src="https://img.shields.io/npm/v/vislite.svg" alt="npm" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.jsdelivr.com%2Fpackage%2Fnpm%2Fvislite"><img src="https://data.jsdelivr.com/v1/package/npm/vislite/badge" alt="cdn" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Foi-contrib%2FVISLite" target="_blank"><img alt="GitHub repo stars" src="https://img.shields.io/github/stars/oi-contrib/VISLite?style=social" referrerpolicy="no-referrer"></a></p><h1><a id="user-content-vislite" class="anchor" href="https://gitee.com/oi-contrib/VISLite#vislite"></a>VISLite</h1><p><code>VISLite</code>是一个使用<code>TypeScript</code>开发的可视化库。官网地址：<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite">https://oi-contrib.github.io/VISLite</a></p><p>主要提供了跨端的画布和计算，开发人员只需要按照文档的描述就可以非常简单的完成包括 Web、uni-app、微信小程序等平台的可视化开发，除了必要的初始化差异，主要的业务代码部分不同端完全一致。</p><h2><a id="user-content-简介" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E7%AE%80%E4%BB%8B"></a>简介</h2><p>这是一个轻量级的数据可视化资源库，目标是：帮助你更快速、简单、高效的开发出任意的可视化业务产品。</p><blockquote><p>本项目已在<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.oschina.net%2Fp%2Fvislite">开源中国</a>中开源，欢迎关注和留言。</p></blockquote><h3><a id="user-content-常用的算法" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95"></a>常用的算法</h3><p>我们通过提供可视化常用的算法来帮助你绘制复杂图表。比如下面的树图，通过简单的配置就可以把任意格式的数据变成任意绘制的带座标的数据：</p><img src="https://oi-contrib.github.io/VISLite/images/docs/what_1.png" width="400" height="300" referrerpolicy="no-referrer"><blockquote><p>上述例子的运行地址：<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fexample%2Fcanvas%2Ftree-layout-lr">从左到右树状图</a>。</p></blockquote><p>除了<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fapi%2FtreeLayout">树布局</a>外，我们还提供了：<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fapi%2Fruler">刻度尺算法</a>来帮助你计算刻度应该如何确定、<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fapi%2Feoap">等角斜方位投影</a>和<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fapi%2Fmercator">墨卡托投影</a>来绘制地图、<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fapi%2Fcardinal">插值函数</a>来完成折线变光滑的曲线、<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fapi%2Fmatrix4">变换矩阵</a>提供各种座标变换等。</p><h3><a id="user-content-画笔加强" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E7%94%BB%E7%AC%94%E5%8A%A0%E5%BC%BA"></a>画笔加强</h3><p>我们对画笔进行了加强，使得其更简单好用。比如 canvas、webgl，抽象出区域的概念，使得无论你绘制的图形多么的不规则，都可以很轻松的实现交互功能：</p><img src="https://oi-contrib.github.io/VISLite/images/docs/what_2.png" width="400" height="300" referrerpolicy="no-referrer"><blockquote><p>上述例子的运行地址：<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fexample%2Fcanvas%2Fchina">中国地图</a>。</p></blockquote><p>画笔除了像上面那样为了方便交互而补充区域的设计外，还对原来的 API 进行了一次抽象，使得 API 更友好简单<code>（比如 WebGL，即使不会 3D 的人也可以轻松使用，而 SVG 的使用，你无需去记忆那些晦涩难懂的属性）</code>，同时，我们还抹平了不同版本浏览器等之间的差异。</p><h3><a id="user-content-支持跨端开发" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E6%94%AF%E6%8C%81%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91"></a>支持跨端开发</h3><p>除了 Web 端外，我们还针对 uni-app、微信小程序等端进行了支持，并且不同端 API 保持一致，大大提高了代码的复用性：</p><img src="https://oi-contrib.github.io/VISLite/images/docs/what_3.png" width="600" height="300" referrerpolicy="no-referrer"><blockquote><p>上述例子的运行地址：<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fexample%2Fsvg%2Fmoney-schedule">金额波浪球</a>。</p></blockquote><p>基于实际需要，我们目前对 <code>Canvas</code> 提供了跨端支持，除 <code>Web 端</code> 外，还支持 <code>原生微信小程序</code> 和 <code>uni-app 端</code> （编译成 H5、微信小程序、支付宝小程序等） ，如果后续有必要，我们会对 Canvas 支持的端或 SVG、WebGL 等画笔进行更多端扩展。</p><h3><a id="user-content-可视化大屏" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%A7%E5%B1%8F"></a>可视化大屏</h3><p>当然，按照业务和 UI 设计，快速开发一个大屏也是相对容易的：</p><img src="https://oi-contrib.github.io/VISLite/images/docs/bigview.jpeg" width="500" referrerpolicy="no-referrer"><blockquote><p>上述例子的运行地址：<a href="https://gitee.com/link?target=https%3A%2F%2Foi-contrib.github.io%2FVISLite%2F%23%2Fbigview%3Fpage%3Ddataboard">数据看板大屏</a>。</p></blockquote><h2><a id="user-content-特点" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E7%89%B9%E7%82%B9"></a>特点</h2><ul><li>灵活的引入方式：包括 npm 安装后按照<code>ES Module</code>或<code>CommonJS</code>规范引入或直接使用 script 标签的<code>CDN</code>方式。</li><li>按需引入或全局引入：支持源码 TS 引入、按需 JS 引入或者全量引入等多种方式。</li><li>简单与复杂共存：一方面我们提供了可视化需要的基础功能，你可以按照自己的需要组合使用；另一方面，为了加速开发，我们针对常见的可视化业务场景进行了封装，可以帮助你快速完成，你可以根据实际情况进行选择。</li><li>向下兼容：我们向你保证，始终向下兼容<code>（alpha 和 beta 版本为测试版本，不包括）</code>，因此，无论何时，最新版本总是最好的选择。</li></ul><blockquote><p>版本说明：alpha 为开发阶段、beta 为发布前测试、无后缀的为正式版本。</p></blockquote><h2><a id="user-content-需求墙" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E9%9C%80%E6%B1%82%E5%A2%99"></a>需求墙</h2><p>我们的目标是不断完善丰富可视化功能，非常希望获得你宝贵的建议和批评，无论任何想法，都可以给我们<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Foi-contrib%2FVISLite%2Fissues">留言</a>告诉我们。</p><p>你所提的任何建议我们都会在最长一周内进行反馈说明。</p><h2><a id="user-content-更新日志" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97"></a>更新日志</h2><p>详见<a href="https://gitee.com/oi-contrib/VISLite/blob/master/CHANGELOG">正式版更新日志</a>，我们会在每次发布完正式版本后更新其内容。</p><h2><a id="user-content-下一步" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E4%B8%8B%E4%B8%80%E6%AD%A5"></a>下一步</h2><p>我们会在这里列出接下来的工作重心：</p><ul><li>Canvas、SVG 和 WebGL 画笔功能丰富</li><li>为加速开发，提供常用座标系和布局</li><li>文档优化（提高可读性、丰富用例、补充教程）</li></ul><p>给我们<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Foi-contrib%2FVISLite%2Fissues">留言</a>告诉我们你希望快速扩展的功能，我们会优先你的建议考虑哦～</p><h2><a id="user-content-参与贡献" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E5%8F%82%E4%B8%8E%E8%B4%A1%E7%8C%AE"></a>参与贡献</h2><p>你可以选择下列一项或多项进行参与：</p><ul><li>代码维护：由于新功能或一些 BUG 的出现，对代码进行维护和升级。</li><li>文档编辑：主要是接口文档和教程需要编辑，这很重要。</li><li>用例开发和测试：在项目的 test 文件夹下有一些测试，而在 docs 文档中存在一些例子需要补充。</li><li>参与讨论：主要是讨论未来如何发展，改造的方向等。</li></ul><p>如果有意向加入我们，你可以通过提 <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Foi-contrib%2FVISLite%2Fissues">issue</a> 和我们取到联系，请简单说明一下情况，我们会尽快回复。</p><p>你可以查看<a href="https://gitee.com/oi-contrib/VISLite/blob/master/.github/CONTRIBUTING.md">VISLite 贡献指南</a>文件了解更多细节，查看<a href="https://gitee.com/oi-contrib/VISLite/blob/master/AUTHORS.txt">AUTHORS.txt</a>了解所有的贡献者。</p><h2><a id="user-content-版权" class="anchor" href="https://gitee.com/oi-contrib/VISLite#%E7%89%88%E6%9D%83"></a>版权</h2><p>MIT License</p><p>Copyright (c) <a href="https://gitee.com/link?target=https%3A%2F%2Fzxl20070701.github.io%2Fnotebook%2Fhome.html">zxl20070701</a> 走一步，再走一步</p>]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/oi-contrib/VISLite</guid>
            <link>https://gitee.com/oi-contrib/VISLite</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | Spring 七种事务传播性介绍]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="font-size: 15px;line-height: 1.6;"><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">作者：vivo 互联网服务器团队 - Zhou Shaobin</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: left;" powered-by="xiumi.us"><section style="font-size: 14px;text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);"><p style="text-wrap: wrap;">本文主要介绍了 Spring 事务传播性的相关知识。<br><br></p><p style="text-wrap: wrap;">Spring 中定义了 7 种事务传播性：</p><p style="text-wrap: wrap;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="text-wrap: wrap;"><span style="color: rgb(160, 160, 160);font-size: 14px;letter-spacing: 0.578px;text-wrap: wrap;">PROPAGATION_REQUIRED&nbsp;</span></p></li><li><p style="text-wrap: wrap;"><span style="letter-spacing: 0.034em;">PROPAGATION_SUPPORTS</span></p></li><li><p style="text-wrap: wrap;"><span style="letter-spacing: 0.034em;">PROPAGATION_MANDATORY</span></p></li><li><p style="text-wrap: wrap;"><span style="letter-spacing: 0.034em;">PROPAGATION_REQUIRES_NEW</span></p></li><li><p style="text-wrap: wrap;"><span style="letter-spacing: 0.034em;">PROPAGATION_NOT_SUPPORTED</span></p></li><li><p style="text-wrap: wrap;"><span style="letter-spacing: 0.034em;">PROPAGATION_NEVER</span></p></li><li><p style="text-wrap: wrap;"><span style="letter-spacing: 0.034em;">PROPAGATION_NESTED</span></p></li></ul><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">在 Spring 环境中，含有事务的方法嵌套调用，事务是如何传递的规则，以及每种规则是如何开展工作的。文章还提到每种事务传播性是如何使用的，方便读者依据实际的场景，使用不同的事务规则。</p></section></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>一、什么是 Spring 事务的传播性</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Spring 事务传播性是指， 在 Spring 的环境中，当多个含有事务的方法嵌套调用时，每个事务方法都处于自己事务的上下文中，其提交或者回滚行为应该如何处理。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通俗讲，就是当一个事务方法调用另外一个事务方法时，事务如何跨上下文传播。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014182" data-ratio="0.4357142857142857" data-s="300,640" src="https://oscimg.oschina.net/oscnet/f25cb074-716b-471d-b42b-34d9ef981030.jpg" data-type="jpeg" data-w="700" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">1）当事务方法 A 调用事务方法 B 时，事务方法 B 是合并到事务方法 A 中，还是开启新事务？</p><p style="text-wrap: wrap;">2）当事务方法 B 抛出异常时&nbsp; ，在合并事务或者开启新的事务的场景中，事务的回滚是如何处理的 ？</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">以上事务的处理规则，都取决于事务传播级别的设置。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>二、事务的传播性都有哪些行为</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014183" data-ratio="0.6296829971181557" data-s="300,640" src="https://oscimg.oschina.net/oscnet/3c651ebf-1386-492f-8623-e4771fafefc0.jpg" data-type="jpeg" data-w="694" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">事务的传播行为，主要分为三种类型，分别是：<strong>支持当前事务</strong>、<strong>不支持当前事务</strong>、<strong>嵌套事务</strong>。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.1 支持当前事务</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><strong>REQUIRED</strong>：默认的事务传播级别，表示如果当前方法已在事务内，该方法就在当前事务中执行，否则，开启一个新的事务并在其上下文中执行。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;"><strong>SUPPORTED</strong>：当前方法在事务内，则在其上下文中执行该方法，否则，开启一个新的事务。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;"><strong>MANDATORY</strong>：必须在事务中执行，否则，将抛出异常。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.2 不支持当前事务</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><strong>REQUIRES_NEW</strong>：无论当前是否有事务上下文，都会开启一个事务&nbsp; 。如果已经有一个事务在执行 ，则正在执行的事务将被挂起 ，新开启的事务会被执行。<br></p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">事务之间相互独立，互不干扰。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;"><strong>NOT_SUPPORTED</strong>：不支持事务，如果当前存在事务上下文，则挂起当前事务，然后以非事务的方式执行。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;"><strong>NEVER</strong>：不能在事务中执行，如果当前存在事务上下文，则抛出异常。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.3&nbsp;嵌套事务</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>NESTED</strong>：嵌套事务，如果当前已存在一个事务的上下文中，则在嵌套事务中执行，如果抛异常，则回滚嵌套事务，而不影响其他事务的操作。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>三、每种事务的传播性如何工作</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.1 REQUIRED&nbsp;&nbsp;</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">默认的事务传播行为，保证多个嵌套的事务方法在同一个事务内执行，并且同时提交，或者出现异常时，同时回滚。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;"></span><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;">这个机制可以满足大多数业务场景。</span></p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014184" data-ratio="0.577490774907749" data-s="300,640" src="https://oscimg.oschina.net/oscnet/2aff859c-0701-434b-8a2b-41e9905f3c02.jpg" data-type="jpeg" data-w="542" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">&nbsp;例子 ：</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014185" data-ratio="0.4429447852760736" data-s="300,640" src="https://oscimg.oschina.net/oscnet/45fcfef2-2fd6-4ce0-a377-3336137657e9.jpg" data-type="jpeg" data-w="815" style="" referrerpolicy="no-referrer"></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014186" data-ratio="0.3899755501222494" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b792582b-cfe0-4df3-903e-9343f2dd235b.jpg" data-type="jpeg" data-w="818" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;">1）类 TestAService 的方法通过声明式事务的方式，加上了事务注解@Transactional ，并设置事务的传播性为 REQUIRED。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">2）调用者调用 TestAService 的 A 方法时，如果调用者没有开启事务，那么 A 方法会开启一个事务。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">A 方法的具体执行过程如下 ：</p><p style="text-wrap: wrap;">a. 执行 insert，但没有提交；</p><p style="text-wrap: wrap;">b.调用 TestBServcie 的 B 方法，由于 B 方法也声明了事务，并且传播性是 REQUIRED，所以方法 B 的事务，合并到方法 A 开启的事务中。</p><p style="text-wrap: wrap;">c.方法 B 执行 insert 操作，此时也没有提交。<br><br></p><p style="text-wrap: wrap;">3）由于这两个方法的操作都在同一个事务中执行，当这两个方法所有操作执行成功之后，提交事务。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">嵌套调用链路：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014187" data-ratio="0.13892078071182548" data-s="300,640" src="https://oscimg.oschina.net/oscnet/ccbb2e64-6419-4c89-9109-df8c1be5957b.jpg" data-type="jpeg" data-w="871" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(70, 97, 246);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgb(62, 62, 62);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">当方法 B 执行时抛出了 Exception 异常后，事务是如何处理的 ？</p></section></section></section><p>1）方法 B 声明了事务，insert 操作会回滚</p><p>2）由于方法 A 和方法 B 同属一个事务，方法 A 也会执行回滚，由此说明该规则保证了事务的原子性。</p><p><br></p><p>嵌套调用，异常后的链路：</p><p><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014188" data-ratio="0.15219842164599776" data-s="300,640" src="https://oscimg.oschina.net/oscnet/077cdda3-e7bc-45b6-8ea9-807b3765adb5.jpg" data-type="jpeg" data-w="887" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 8px;font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;"><section style="padding-left: 8px;display: inline-block;width: 578px;vertical-align: top;border-left: 3px solid rgb(70, 97, 246);border-bottom-left-radius: 0px;align-self: flex-start;flex: 0 0 auto;"><section powered-by="xiumi.us" style="color: rgb(62, 62, 62);text-align: justify;"><p>如果，方法 B 抛出异常后，方法 A 使用 try-catch 处理了方法 B 的异常（如下代码），并没有向外抛出，此时事务又如何处理的 ？</p></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014189" data-ratio="0.33291457286432163" data-s="300,640" src="https://oscimg.oschina.net/oscnet/9fc563a6-9984-4d9d-af11-bcfd49b19b70.jpg" data-type="jpeg" data-w="796" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">方法 A 也会回滚。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">从事务的特性我们可知，事务具有原子性。方法 A 和方法 B 同属一个事务，当方法 B 抛出异常，触发回滚操作后，整个事务的操作都会回滚。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">因此，Spring 在处理事务过程中，当事务的传播性设置为 REQUIRED，在整个事务的调用链上，任何一个环节抛出的异常都会导致全局回滚。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.2 REQUIRES_ NEW</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">每次都开启一，个新的事务。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014190" data-ratio="0.4325153374233129" data-s="300,640" src="https://oscimg.oschina.net/oscnet/d0097908-7fd0-42c9-b288-0b49b60534b0.jpg" data-type="jpeg" data-w="652" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">&nbsp;例子：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014191" data-ratio="0.20330368487928843" data-s="300,640" src="https://oscimg.oschina.net/oscnet/3f4398b9-1173-4e3b-a0d2-bbca386e67b9.jpg" data-type="jpeg" data-w="787" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">上面例子中，方法 B 的传播性设置为 REQUIRES_NEW，方法 A 仍然是 REQUIRED，当 A 调用 B 时，具体调用链路如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014193" data-ratio="0.2803203661327231" data-s="300,640" src="https://oscimg.oschina.net/oscnet/dd34f32f-ad1d-4cdc-921d-e5fbb11b2bfe.jpg" data-type="jpeg" data-w="874" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 A 被执行前，如果调用者没有开启事务，方法 A 开启一个事务 1，然后执行 insert ，此时没有提交；</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 B 的事务传播性设置为 REQUIRES_NEW，当被方法 A 调用时，此时方法 A 的事务 1 会被挂起，方法 B 开启自己的事务 2，然后执行 insert，此时并没有提交；</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">当方法 B 执行完毕后，提交事务 2；</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">恢复事务 1，最终提交。</span><span style="letter-spacing: 0.034em;"></span></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(70, 97, 246);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgb(62, 62, 62);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">当，方法 B 执行时抛出了异常，会发生什么？</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">方法 B 的 insert 操作会被回滚掉,方法 A 不受影响。但这里有个前提，方法 A 需要 try-catch 方法 B 的异常，使其异常不会往上传递，从而导致方法 A 接收到异常，导致回滚。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014194" data-ratio="0.2877939529675252" data-s="300,640" src="https://oscimg.oschina.net/oscnet/a9c7c98f-053d-4c12-a5c8-777f32b699e6.jpg" data-type="jpeg" data-w="893" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.3&nbsp; SUPPORTED</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">当外层方法 A 存在事务，方法 B 加入到当前事务中，以事务的方式执行。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014195" data-ratio="0.559748427672956" data-s="300,640" src="https://oscimg.oschina.net/oscnet/ce1639fd-a2c7-407f-8c2e-0c7b4af8a7ff.jpg" data-type="jpeg" data-w="636" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">当外层方法 A 不存在事务，方法 B 不会创建新的事务，以非事务的方式执行。</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014196" data-ratio="0.6865671641791045" data-s="300,640" src="https://oscimg.oschina.net/oscnet/e348a11f-faad-48b0-a6e1-70aeedc01de0.jpg" data-type="jpeg" data-w="536" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">&nbsp;例子 1：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014197" data-ratio="0.23020527859237536" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b3fc986f-f0f3-4126-bcf1-1f0a2ce71fbd.jpg" data-type="jpeg" data-w="682" style="" referrerpolicy="no-referrer"></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014198" data-ratio="0.1793103448275862" data-s="300,640" src="https://oscimg.oschina.net/oscnet/28c10e68-1769-4b67-86cd-90901a489191.jpg" data-type="jpeg" data-w="725" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以上例子，方法 A 没有加事务注解，方法 B 的加了事务注解，并且传播为 SUPPORTS。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 A 以非事务的方式执行 insert 操作。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 B 被调用，由于其外层事务 A 没有开启事务，方法 B 也是以非事务方法执行 insert 操作。</span></p></li></ul></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014199" data-ratio="0.21016949152542372" data-s="300,640" src="https://oscimg.oschina.net/oscnet/96736113-0a60-4cc9-a14f-49b7a4b68331.jpg" data-type="jpeg" data-w="590" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">例子 2：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014200" data-ratio="0.12777777777777777" data-s="300,640" src="https://oscimg.oschina.net/oscnet/a87c1624-cb04-4f02-b57c-99ae40a3de71.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以上例子，方法 A 和 B 都加上了事务注解，其中方法 A 的传播性为 REQUIRED，方法 B 的传播性为 SUPPORTS。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">如果方法 A 的调用方没有开启事务，则方法 A 开启事务，并执行 insert 操作，但没有提交；</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">方法 B 被调用，由于其外层方法 A 开启了事务，因此方法 B 加入到方法 A 开启的事务中，并执行 insert,但没有提交；</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">当事务中的所有操作执行成功后，事务提交。</span></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014201" data-ratio="0.13157894736842105" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bca29bf0-2c58-4174-9477-3903aafa4180.jpg" data-type="jpeg" data-w="798" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.4&nbsp; NOT_SUPPORTED</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">不支持事务。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">如果外层方法存在事务，则挂起外层事务，以非事务方式执行，执行完毕后，恢复外层事务。</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014202" data-ratio="0.4672131147540984" data-s="300,640" src="https://oscimg.oschina.net/oscnet/6355266c-c5d2-46c2-9add-c5a7a34131d8.jpg" data-type="jpeg" data-w="610" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">例子：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014203" data-ratio="0.12407407407407407" data-s="300,640" src="https://oscimg.oschina.net/oscnet/458980db-9a97-4419-975a-121889eafd90.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以上例子：方法 A 和 B 都加上了事务注解，方法 A 的传播性为 REQUIRED,方法 B 为 NOT_SUPPORTED。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">如 A 的调用方没有开启事务，方法 A 开启事务，并执行 insert，但没有提交。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">方法 A 调用方法 B 时，方法 B 的传播性为 NOT_SUPPORTED,不支持事务，然后挂起外层方法 A 的事务，方法 B 以非事务的方式执行 insert。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">方法 B 执行完毕后，恢复方法 A 的事务，最终提交事务。</span></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">调用链路过程：</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014204" data-ratio="0.1400208986415883" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b5ec0c68-b769-433a-ab3c-7fe1941627af.jpg" data-type="jpeg" data-w="957" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.5 NEVER</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">不支持事务</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">当外层方法 A 开启了事务，方法 B 抛出异常</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014205" data-ratio="0.578" data-s="300,640" src="https://oscimg.oschina.net/oscnet/8567887f-aa12-473c-b4cb-b2e6f6c00360.jpg" data-type="jpeg" data-w="500" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">例子：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014206" data-ratio="0.12777777777777777" data-s="300,640" src="https://oscimg.oschina.net/oscnet/65811a67-78a5-49c0-b95f-a277d8537a52.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以上代码，两个方法都打上了事务注解，方法 A 的传播性是 REQUIRED,方法 B 的传播性是 NEVER。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 A 开启事务，执行 insert,没有提交。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">含有事务的方法 A 调用方法 B，方法 B 的传播性是 NEVER,表示不支持事务，因此方法 B 抛出异常。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">方法 A 的事务执行回滚。</span></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014207" data-ratio="0.26361867704280156" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b642401a-cde6-4635-b66e-370d0cb534d2.jpg" data-type="jpeg" data-w="1028" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.6 MANDATORY</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="text-wrap: wrap;">必须在事务中执行。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">如果外层方法 A 没有开启事务，方法 B 抛出异常。</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014208" data-ratio="0.5640535372848948" data-s="300,640" src="https://oscimg.oschina.net/oscnet/e520ab89-d9b6-4d44-b30d-bf83e5ca9a5e.jpg" data-type="jpeg" data-w="523" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">如果外层方法 A 开启了事务，方法 B 加入事务，方法 A&amp;B 在同一事务中执行。</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014209" data-ratio="0.6473029045643154" data-s="300,640" src="https://oscimg.oschina.net/oscnet/cec503c3-7c18-4447-8538-cbaa55395d02.jpg" data-type="jpeg" data-w="482" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">例子：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014210" data-ratio="0.15" data-s="300,640" src="https://oscimg.oschina.net/oscnet/5946ff56-8e70-42bf-b73b-e4ea86828e1a.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以上例子，方法 A 没有加事务注解，方法 B 的传播性为 MANDATORY。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 A 的调用方如果本身没有开启事务，方法 A 执行前不会开启事务。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">当非事务方法 A 调用方法 B 时，由于方法 B 的传播性为 MANDATORY，必须在事务中执行，条件不满足，抛出异常。</span></p></li></ul></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014211" data-ratio="0.30708661417322836" data-s="300,640" src="https://oscimg.oschina.net/oscnet/416475ff-f185-4c51-b748-3bd01b71c1d9.jpg" data-type="jpeg" data-w="889" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">3.7 NESTED</span></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;" powered-by="xiumi.us"><p style="margin-bottom: 10px;text-wrap: wrap;">嵌套事务</p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;">如果外层方法 A 不存在事务，内层方法 B 的规则与 REQUIRED 一致。</p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">如果外层方法 A 存在事务，内层方法 B 做为外层方法 A</span><span style="letter-spacing: 0.034em;">事务的子事务执行，两个方法是一起提交，但子事务是独立回滚。</span></p><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;"></span><span style="letter-spacing: 0.034em;">内层方法 B 抛出异常，则会回滚方法 B 的所有操作，但不影响外层事务方法 A。</span><span style="letter-spacing: 0.034em;">（方法 A 需要 try-catch 子事务，避免异常传递到父层事务）</span></p><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;"></span><span style="letter-spacing: 0.034em;">外层方法 A 回滚，则内层方法 B 也会回滚。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">该传播性的特点是可以保存状态点，当回滚时，只会回滚到某一个状态点，保证了子事务之间的独立性，避免嵌套事务的全局回滚。</span></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014212" data-ratio="0.5464949928469242" data-s="300,640" src="https://oscimg.oschina.net/oscnet/19442a82-a558-40f9-9c12-48c694a7be5b.jpg" data-type="jpeg" data-w="699" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">例子：</p></section></section></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014213" data-ratio="0.22870370370370371" data-s="300,640" src="https://oscimg.oschina.net/oscnet/1842fc23-33da-437d-aadf-6126ceee7570.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">以上例子，方法 A 的传播性为 REQUIRED,方法 B 为 NESTED。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具体执行过程：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="font-size: 15px;letter-spacing: 0.578px;text-wrap: wrap;background-color: rgb(239, 239, 239);">方法 A 执行时，如调用方没有开启事务，则开启一个事务。</span></p></li><li><p style="margin-bottom: 10px;">方法 B 被外层方法 A 调用时，因为方法 B 的传播性为 NESTED，方法 B 在此处建立 savepoint,标记 insert 行为。</p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">当方法 B 抛出异常，其 insert 操作会回滚，但只会回滚到 savepoint，（前提是方法 A 要 try-catch 方法 B，使方法 B 的异常不会往外传递）。</span></p></li><li><p style="margin-bottom: 10px;text-wrap: wrap;"><span style="letter-spacing: 0.034em;">方法 B 回滚后，方法 A 的事务提交。</span></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">调用链路：</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-imgfileid="100014214" data-ratio="0.2857142857142857" data-s="300,640" src="https://oscimg.oschina.net/oscnet/76197617-a9ba-44b1-af8b-90ccfeb45afc.jpg" data-type="jpeg" data-w="910" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>四、总结</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">本文解释了 Spring 框架中的事务传播性，即多个业务方法之间调用时事务如何处理的规则。Spring 提供了七种传播级别，如</p><p style="text-wrap: wrap;">PROPAGATION_REQUIRED、</p><p style="text-wrap: wrap;">PROPAGATION_REQUIRES_NEW 等。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">每种级别都有适用场景和限制，本文提供了一些示例，介绍了声明式事务如何使用，每种事务的规则，产生哪种行为，当方法抛出异常时，事务的提交和回滚是如何被处理的。正确处理事务对于任何企业级应用程序都是必要的，了解 Spring 事务传播性是构建高效、可靠和可扩展应用程序的关键。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;"><section style="text-align: center;color: rgb(45, 66, 87);font-size: 11px;" powered-by="xiumi.us"><p>END</p></section></section><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: left;" powered-by="xiumi.us"><section style="padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;"><span style="display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);" title="" opera-tn-ra-cell="_$.pages:0.layers:0.comps:148.title1"><p>猜你喜欢</p></span></section><section style="border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;"><section style="font-size: 14px;text-align: left;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497989%26idx%3D1%26sn%3Da98e270e4612356756966bd9d90d80ee%26chksm%3Debdb8997dcac0081e35a2c9ba681902e703f8c52406ee49fcedaafbba77b7dc3279f56305782%26scene%3D21%23wechat_redirect" textvalue="vivo 数据库备份恢复系统演化" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">vivo 数据库备份恢复系统演化</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497821%26idx%3D1%26sn%3D80e04511f5a5d5acfee4a44a8a8b3e31%26chksm%3Debdb88cfdcac01d954242fd24907b69c542e43fcb99ebe6a03d66858194e03ad14105281b62f%26scene%3D21%23wechat_redirect" textvalue="vivo 容器平台资源运营实践" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">vivo 容器平台资源运营实践</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497821%26idx%3D2%26sn%3Db5d635106e88b9f918f54111f11b3027%26chksm%3Debdb88cfdcac01d952d021c34f90aabe3c193fc1b0bd4d86721f2ec3d696c909cf4503936be9%26scene%3D21%23wechat_redirect" textvalue="前端 JS 安全对抗原理与实践" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">前端 JS 安全对抗原理与实践</a></p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互联网技术" data-alias="vivoVMIC" data-signature="分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公众号 - vivo 互联网技术（vivoVMIC）。<br>如有侵权，请联系 support@oschina.cn 删除。<br>本文参与「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源创计划</a>」，欢迎正在阅读的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 09 Jan 2024 02:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10583852</guid>
            <link>https://my.oschina.net/vivotech/blog/10583852</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[年度盘点｜深圳工信十件大事]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>「i 深圳」官微<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F_8-u5N6_fIBUYJZGu1fGYg" target="_blank">发文</a>盘点了 2023 年深圳工信十大事件，具体如下：</p><p><span style="color:#007aaa"><strong>一、企业创新主体地位不断强化，「深圳制造」爆款迭出</strong></span></p><p><span style="color:#595959">企业研发投入达 1784.6 亿元，约占全社会研发投入比重 94.9%，位居全国第一。华为推出全球首款支持衞星通话和应用星闪技术的 Mate 60 系列手机产品，引发线上线下抢购热潮；荣耀推出全球最轻薄大内折高端机 Magic V2，引领折叠屏厚度进入「毫米时代」；仰望 U8、问界 M9 等高端车型先后发布，搭载业内领先的自研车身控制系统和智能科技配置，代表了全球高端新能源汽车前沿水平。</span></p><p><img height="383" src="https://oscimg.oschina.net/oscnet/up-c427126861041278cce2734057b420f8024.png" width="500" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#007aaa"><strong>二、「新一代世界一流汽车城」建设全面提速，比亚迪勇夺全球新能源汽车销冠</strong></span></p><p><span style="color:#595959">高标准规划建设「新一代世界一流汽车城」，全市全年新能源汽车产量继续实现翻倍增长。汽车出口屡创新高，全市新车电动化渗透率、充电基础设施密度全国领先，新能源汽车保有量超 96 万辆，入围国家首批公共领域全面电动化一类试点城市。全力支持深汕特别合作区建设世界级汽车制造城，深汕比亚迪汽车工业园二期建成投产，东风李尔、壁虎科技、佛吉亚等一批新能源汽车产业链上下游明星企业集聚深汕。比亚迪累计下线超 600 万辆新能源汽车，2023 年全年销售汽车 302.44 万辆，同比增长 61.9%，一举夺得全国汽车年度销冠、全球新能源汽车销冠，创下中国汽车年销量最高纪录，新能源汽车行业迈向规模化、全球化高质量发展之路。</span></p><p><img height="395" src="https://oscimg.oschina.net/oscnet/up-37f0d216108702b10da9071d67a72e94422.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#007aaa"><strong>三、优质通用大模型接连推出，人工智能全域全时场景应用加快拓展</strong></span></p><p><span style="color:#595959">印发实施《深圳市加快推动人工智能高质量发展高水平应用行动方案（2023-2024 年）》，构建「一条例、一方案、一清单、一基金群」的政策体系。华为云盘古 3.0。腾讯混元、云天励飞天书等一批高水平通用大模型陆续推出。升腾系列芯片成为国内具备全栈技术的最高水平的人工智能算力芯片。累计发布人工智能清扫等 41 个「城市+AI」场景，举办人工智能专场产学研对接系列活动，人工智能全域全时场景应用加快拓展。</span></p><p><img height="323" src="https://oscimg.oschina.net/oscnet/up-09bda6383445c51b8c4c7c3c38d87601298.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#007aaa"><strong>四、开源鸿蒙欧拉产业高地建设再上台阶，「软件名城」获评「三星级」</strong></span></p><p><span style="color:#595959">印发实施《深圳市推动开源鸿蒙欧拉产业创新发展行动计划（2023—2025 年）》，全体系增强操作系统技术能力，开源鸿蒙装机量已超过 7 亿台，开源欧拉装机量占据国内服务器市场份额近 4 成。落地全球智慧物联网联盟等国际组织，建设鸿蒙生态创新中心，加快推动我国操作系统技术创新和高水平自立自强。在全国「软件名城」考核中名列前茅，获评最高等次「三星级」。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="275" src="https://oscimg.oschina.net/oscnet/up-45f99849e79a7af19baff203be73c45bcee.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#007aaa"><strong>五、75 个「工业上楼」项目开工建设，高标准谋划共建产业园区</strong></span></p><p><span style="color:#595959">持续加大产业用地用房供应，积极稳妥推进「工业上楼」，为制造业高质量发展提供强有力空间保障。2023 年开工建设 75 个「工业上楼」项目，预计可提供总建筑面积超 2000 万㎡。龙岗宝龙专精特新产业园正式开园，全国首个全装配式智能产业园坪山区新能源汽车产业园交付使用，推广实现「上下游就是上下楼，产业园就是产业链」。与汕头、潮州等地加大产业合作力度，高标准谋划共建产业园区，努力实现优势互补、合作共赢。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="351" src="https://oscimg.oschina.net/oscnet/up-0e185217af6add18c0a3dc295242507811b.png" width="500" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#007aaa"><strong>六、中小企业发展环境综合排名全国第一，专精特新「小巨人」增量全国第一</strong></span></p><p><span style="color:#595959">《2022 年度中小企业发展环境评估报告》发布，深圳中小企业发展环境综合排名全国第一。「深 i 企」平台用户数突破 300 万。创新开展「我帮企业找市场」等系列行动，线上打造供需对接平台，线下开展上百场各类主题的「链上配对」精准对接服务，帮助企业拿订单、拓市场，打通上下游合作「最后一公里」。2023 年新增专精特新「小巨人」企业 309 家，新增数量居全国大中城市第一，总数达 742 家、位列全国第二。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="350" src="https://oscimg.oschina.net/oscnet/up-bb68fd01669b2204acf6e1a401f88b4d831.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#007aaa"><strong>七、千兆城市建设水平领跑全国，率先迈入 5G-A 时代</strong></span></p><p><span style="color:#595959">启动「极速宽带先锋城市」建设行动，全年新增 5G 基站超 1 万个、累计建成超 7.5 万个，重点场所 5G 网络通达率 100%，多项千兆城市指标位居全国大中城市首位。启动数字家庭 3T 跃升行动试点，深圳市公共场所 WIFI 管理平台累计服务近 3 亿人次，为市民节省约 1.7 亿元流量费，市民生活数字化服务水平得到大幅提升。出台《深圳市算力基础设施高质量发展行动计划（2024-2025）》，力争将算力打造成像水、电「一点接入、即取即用」的基础设施，夯实数字经济发展「底座」。全面加速 5G-A 行业应用创新与产业融合发展，成为全球首个迈入 5G-A 时代的城市。</span></p><p><span style="color:#007aaa"><strong>八、一批重大先进制造业项目落地，工业投资实现高速增长</strong></span></p><p><span style="color:#595959">市区协同、部门联动，赴法国、德国、马来西亚、沙特等 25 个国家和北京、上海等 30 多个城市精准招商，招引西门子、椭圆星池、京西重工、壁虎科技等一批国内外知名企业重点项目成功落地。推动与中国一汽、中国化学、中汽中心等一批央企签署合作协议，打造央地产业合作新典范。全年先进制造业领域成功招引落地百亿以上项目 8 个，10 亿以上项目超 80 个，投资金额合计超 4000 亿元。2023 年工业投资规模再创历史新高，实现增长超 30%。出台《深圳市关于新形势下加快工业企业技术改造升级的若干措施》，将重大项目支持金额上限提高至 1 亿元，推动 1200 余家企业开展技术改造。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="318" src="https://oscimg.oschina.net/oscnet/up-d1e0659e29ba6df8968fad30a54240bfb54.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#007aaa"><strong>九、国际星闪无线短距通信联盟落户河套，高水平产业创新平台加快打造</strong></span></p><p><span style="color:#595959">国际星闪无线短距通信联盟正式落户河套深港科技创新合作区，成为第二个注册地设立在深圳的国际性产业与标准组织。联盟已发布星闪芯片、测试仪表等产品，加快在智能汽车、智能家居、智能终端等领域推进产业化和国际化进程。新增 1 家国家级「双跨」平台、总数占全国十分之一，电子元器件和集成电路国际交易中心交易规模突破 500 亿元。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="357" src="https://oscimg.oschina.net/oscnet/up-56ac4a5cdf50607b2958f21ad8d17cac815.png" width="500" referrerpolicy="no-referrer"></p><p><strong><span style="color:#007aaa">十、中国—东盟新兴产业论坛成功举办，国际产业交流合作成效斐然</span></strong></p><p><span style="color:#595959">成功举办中国-东盟新兴产业论坛，来自东盟各国的 9 位部长、29 位东盟国家驻华使领馆代表以及相关国际组织、商协会、智库、企业共计 180 余位外方嘉宾参加盛会，共话新兴产业发展。发布《新兴产业合作倡议（深圳倡议）》，举办中国-东盟产业对接会（深圳），达成 20 项战略合作框架协议，意向合作金额超 50 亿元。延伸举办中国（深圳、香港）-东盟（吉隆坡）新兴产业对接会，深港携手「并船出海」，达成 22 项合作协议，签约金额超 100 亿元。</span></p><p><img height="640" src="https://oscimg.oschina.net/oscnet/up-3b53abdd29e47790a9ca14a4c7ddea89cdd.png" width="936" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 08 Jan 2024 09:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274769</guid>
            <link>https://www.oschina.net/news/274769</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[祝贺！openKylin 社区再次入选「科创中国」开源创新榜]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#333333">近日，由中国科协科学技术传播中心、中国计算机学会、中国通信学会和中国科学院软件研究所联合主办，CSDN 承办的</span><strong><span style="color:#333333">2023 年开源创新榜专家评审会</span></strong><span style="color:#333333">圆满落幕。</span><span style="color:#0060e8"><strong><span>openKylin 社区荣获「2023 开源创新榜」优秀开源社区奖，这也是 openKylin 社区<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MDc5MDU1OQ%3D%3D%26mid%3D2247488006%26idx%3D1%26sn%3D9829fb8b7f075f1239b239d4be35d36b%26chksm%3Dce205876f957d160ca609fd7c95b3f6698bd2fddacb2697724ae7a20292e6780bd3b7ba44906%26scene%3D21%23wechat_redirect" target="_blank">连续两年</a>入选该榜单。</span></strong></span></p><p style="text-align:center"><img alt="" height="1654" src="https://oscimg.oschina.net/oscnet/up-5a2d6ec6c333def9c35daa719508157beef.png" width="2339" referrerpolicy="no-referrer"></p><p><span style="color:#333333">2023 开源创新榜面向中国开源行业领域，评选具有创新性、贡献度和影响力的开源项目、社区、人物。突出「与时俱进、鼓励创新」的原则，旨在挖掘和推广我国在开源技术领域的优秀成果和先进经验。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#333333">相较于往年，2023 年开源创新榜在</span><strong><span style="color:#333333">权威性、公信力和专业度</span></strong><span style="color:#333333">方面均有显著提升。</span></p><ul><li><p style="margin-left:0; margin-right:0">权威性。主办单位新加入中国计算机学会、中国通信学会、中国科学院软件研究所，四家主办单位优势互补，共同推动榜单策划、征集申报、专家评审等工作重点。</p></li><li><p style="margin-left:0; margin-right:0">公信力。由王怀民院士担任评委会主任，指导组建了结构更加科学、领域更加全面的评审专家库，从中提名形成最终评审专家。</p></li><li><p style="margin-left:0; margin-right:0">专业度。围绕项目、社区、人物三大类别，四家主办单位打磨了更加客观、严谨、贴合实际的评审标准和更加开放、公平、科学的评审办法，在征集过程中公开标准细节，接受社会的意见反馈，形成良性循环。</p></li></ul><p>&nbsp;</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#333333">作为中国领先的开源操作系统根社区，openKylin 社区自成立以来便积极推动开源生态建设。截至目前，openKylin 社区已累计发布 6 个社区版本，下载量达 100 万+；聚合 400+家单位会员，涵盖操作系统、数据库、办公软件、CPU、GPU、整机、人工智能优势企业及高等院校；拥有 5700+位开发者，并累计成立 95 个 SIG 组开展技术研究与创新。广泛的产、学、研、用各领域力量加入社区共建之中，为操作系统根技术创新奠定智囊基础。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#333333">此次入选科创中国「开源创新榜」是对 openKylin 社区开源创新能力和行业影响力的高度肯定。未来，openKylin 也将保持初心，聚焦开源创新生态建设、为营造良好开源生态持续努力。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 08 Jan 2024 09:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274766</guid>
            <link>https://www.oschina.net/news/274766</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[CodeFuse 开源这半年]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><p style="margin-left:0px; margin-right:0px; text-align:center"><img alt="hjfgjkf.png" src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/98756342/1704681398439-ec399b89-4898-4a2c-94e5-3981b90ed95d.png?x-oss-process=image%2Fresize%2Cw_900%2Climit_0" width="900" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span>2023 年可以称得上是大模型元年，在过去的这一年里，大模型领域飞速发展，新的大模型纷纷涌现，基于大模型的新产品也吸引着大家的眼球，未来，这个领域又会给大家带来多少惊喜？</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span>蚂蚁也推出了自己的百灵代码大模型 CodeFuse，经历近半年内部打磨后，在 9 月正式对外开源。下面就让我们来看一下，在过去的半年里，CodeFuse 在开源方面取得了哪些进展？</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_1"></span><h2><span>一、让研发变得更简单</span></h2><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span>在大模型落地到多个场景的过程中，代码自动生成，成为技术实现的必要环节。在这一趋势下，蚂蚁集团基于百灵大模型，推出了蚂蚁百灵研发助手，帮助开发者自动生成代码、注释、测试用例等，提高研发效率。</span></p><p style="margin-left:0; margin-right:0"><br><span>CodeFuse 源于蚂蚁自身的开发场景及代码库沉淀，基于海量高质量代码数据和代码领域特色词表，和多任务微调技术 MFT，在蚂蚁一万多内部研发人员的日常编码、测试、运维等场景中，经过反复验证与迭代。当前，CodeFuse 从研发效能、DevOps 衍生到了企业 IT 智能化场景智能体的探索。同时，基于 CodeFuse，蚂蚁集团打造了代码大模型的完整工具链，包括：模型服务、风险防护、数据质量、平台工程。</span></p><p style="margin-left:0; margin-right:0"><br><span>2023 年中，CodeFuse 及其必要的工具链，面向技术社区开源开放，帮助社区开发人员在此之上作研究、评价和二次开发和训练。</span></p><p style="margin-left:0; margin-right:0"><br><span>目前，CodeFuse 在蚂蚁各部门落地支持 40 多种编程语言，10 多个主流 IDE 平台。整体采纳率 30%，代码通过 AI 占比 20%。比如，CodeFuse 在蚂蚁数字科技的 SOFAStack 云原生应用智能商业产品线全面融合，涵盖设计、研发、测试、运维等领域，形成从领域建模到智能运维端到端 Copilot 产品解决方案，提升了企业级应用的交付效率和质量，加速行业数字化降本增效。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_2"></span><h2><span>二、丰富的开源内容</span></h2><p style="margin-left:0; margin-right:0"><span>CodeFuse 的使命是开发专门设计用于支持整个软件开发生命周期的大型代码语言模型（Code LLMs），当前内容涵盖代码、运维、分析、测试、推理、评价六大方向。截止 2023.12.31，CodeFuse 已累计开源了 11 个代码仓库、4 个数据集、11 个大模型参数文件，总计关注/点赞数超过 3000、下载量超过 2.4 万，并有 1 篇论文已被接收，2 篇预影印在 Arxiv 上。</span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/276193/1704259197296-b8ea3135-7387-4a92-a84f-d02643811793.png" width="739" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h4_3"></span><h4><strong>1、代码 - MFTCoder 系列：</strong></h4><p>国际首个高精度、高效率、多任务、多模型支持、多训练算法，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FMFTCoder" target="_blank" rel="nofollow"><span>大模型代码能力微调框架</span></a><span>；多任务微调的技术细节已在 Arxiv 公布，可参考</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2311.02303" target="_blank" rel="nofollow"><span>MFTCoder 论文</span></a><span>，以及</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484188%26idx%3D1%26sn%3D27c9fe0e849f9f27eac588fda76574be%26chksm%3Dc139d02df64e593b2fcb9101cea55c4b78af5a6b4dd0f6518d7993bc864a36150ae438abc902%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>此前发布的文章</span></a></p><div><p style="margin-left:0; margin-right:0"><span>预训练语言模型可以在大量的文本数据上学习通用的语言模式和结构。通过运用无监督学习技术，模型可以基于前面的词序列来预测句子中的下一个词。然而，仅仅进行预训练并不能在特定的自然语言处理任务上取得高性能。因此，需要在特定任务的小型数据集上对预训练模型进行微调，以学习任务特定的特征并提高性能。微调过程使用监督学习技术将预训练模型适应到特定的任务上。将训练过程分为预训练和微调两个阶段，可以使自然语言处理模型充分发挥无监督学习和有监督学习的优势。</span></p><p style="margin-left:0; margin-right:0"><span>但是，需要注意的是，当模型的参数量巨大时，为每一个下游任务独立进行微调并部署将需要大量的资源。然而，是否存在一种方法可以让一个模型同时支持所有的下游任务呢？答案是肯定的，多任务微调（multitask fine-tuning，MFT）为解决这个问题提供了一种有效的途径。</span></p><p style="margin-left:0; margin-right:0"><span>多任务微调不仅能够节省资源，还能够带来其他优势。通过联合训练，模型可以学习到多个任务之间的特征和规律。相比于针对每一个任务单独进行微调，多任务微调能够更好地完成各种任务。同时，由于学习到的特征和规律是相互联系的，模型的泛化能力也会得到提高。这意味着，即使在面对未见过的任务时，模型也能够表现出色，因为它已经学习到了许多相关任务的特征和规律。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p></div><span id="OSC_h4_4"></span><h4>2、运维 - DevOps 系列：</h4><p>业界首个开源的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-DevOps-Model" target="_blank" rel="nofollow"><span>中文开发运维大模型</span></a><span>，能够帮助工程师回答在 DevOps 生命周期中遇到的问题，并提供通过检索增强生成、工具学习和沙盒环境来构建软件开发全生命周期的<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-chatbot" target="_blank" rel="nofollow"><span>AI 智能助手</span></a><span>；详细介绍可以参看此前文章<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484045%26idx%3D1%26sn%3D838d9de49922b0d04bcffb3efbeec4df%26chksm%3Dc139d1bcf64e58aa0c92696d74ccebc64281a9ed287f88333bdd139e34ee5e8d46726ef9cd6e%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>DevOps-Eval</span></a><span>、</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484350%26idx%3D1%26sn%3Dc9875496ec1b2c75f47db73986007a05%26chksm%3Dc139d08ff64e5999b5c55f727d1b98475cc50a328662b5c84d921fe8c45a477f452effc2c41f%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>DevOps-Model</span></a><span>、</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484642%26idx%3D1%26sn%3De7dde520532b0868d267cff5ff4bc449%26chksm%3Dc139d7d3f64e5ec53f110495dbefc8e1903c9f09e13c909b2d236b1808bb9683d034b065e007%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>DevOps-Chatbot</span></a></p><div><p style="margin-left:0; margin-right:0"><span>我们希望用户逐渐从各处资料查询、独立分散平台操作的传统开发运维模式转变到大模型问答的智能化开发运维模式，改变人们的开发运维习惯。</span></p><p style="margin-left:0; margin-right:0"><span>核心差异技术、功能点：</span></p><ul><li><span>智能调度核心： 构建了体系链路完善的调度核心，支持多模式一键配置，简化操作流程。</span></li><li><span>代码整库分析： 实现了仓库级的代码深入理解，以及项目文件级的代码编写与生成，提升了开发效率。</span></li><li><span>文档分析增强： 融合了文档知识库与知识图谱，通过检索和推理增强，为文档分析提供了更深层次的支持。</span></li><li><span>垂类专属知识： 为 DevOps 领域定制的专属知识库，支持垂类知识库的自助一键构建，便捷实用。</span></li><li><span>垂类模型兼容： 针对 DevOps 领域的小型模型，保证了与 DevOps 相关平台的兼容性，促进了技术生态的整合。</span></li></ul><p style="margin-left:0; margin-right:0"><span>依托于开源的 LLM 与 Embedding 模型，可实现基于开源模型的离线私有部署，此外，也支持 OpenAI API 的调用。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p></div><span id="OSC_h4_5"></span><h4><span>3、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-Query" target="_blank" rel="nofollow">分析 - CodeFuse-Query</a></span><span>：</span></h4><p><span style="color:#000000">基于查询的代码分析引擎，适合大规模、复杂的代码库分析场景。可参考论文<span>&nbsp;</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2401.01571" target="_blank" rel="nofollow"><span>https://arxiv.org/abs/2401.01571</span></a><span>；详细介绍可以参看</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484536%26idx%3D1%26sn%3D2e985b431ff9bd219c93b97ce4f4f444%26chksm%3Dc139d749f64e5e5f96f248f99d18bc55a5cd75fcb58c7726f52cfd6cd131f640d09e7d0e122a%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>此前文章</span></a></p><div><p style="margin-left:0; margin-right:0"><span>CodeFuse-Query 的特点和优势可以概括为以下几点：</span></p><ul><li><span>高度可扩展：CodeQuery 可以处理大规模的代码库，且能够适应不同的分析需求。这种高度的可扩展性使得 CodeQuery 可以在大型组织中发挥重要作用。</span></li><li><span>以数据为中心：CodeQuery 将源代码和分析结果视作数据，这种以数据为中心的方法使其在处理大数据环境中的代码分析问题时具有独特优势。</span></li><li><span>高度集成：CodeQuery 能够无缝地融入大型组织的各种系统中，包括数据仓库、数据计算设施、对象存储和灵活计算资源等。这种高度的集成性使得 CodeQuery 在大型组织中的使用变得更加方便和高效。</span></li><li><span>支持多元化的需求：CodeQuery 不仅可以处理大规模的代码库，还可以应对各种复杂的分析需求，包括服务质量分析需求、跨编程语言分析需求、算法需求和性能需求等。</span><br> &nbsp;</li></ul></div><span id="OSC_h4_6"></span><h4><span>4、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FTest-Agent" target="_blank" rel="nofollow">测试 - Test-Agent</a></span><span>：</span></h4><p><span>测试领域的「智能体」，打造创新的测试领域解决方案，构建 24 小时在线的测试助理服务；详细介绍可以参看</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247483884%26idx%3D3%26sn%3Db92d3cbbe82c9487777f63ad6a38851b%26chksm%3Dc139d2ddf64e5bcb2246335bf6ee327900c789dbfead77bfc3c325a8a4854f5d50bd839eb8ad%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>此前文章</span></a></p><div><p style="margin-left:0; margin-right:0"><span>大模型的号角已经吹响，测试领域大模型也在不断进化中，通过预训练过程中积累的丰富世界知识，在复杂交互环境中展现出了非凡的推理与决策能力。</span></p><p style="margin-left:0; margin-right:0"><span>尽管在测试领域中，基础模型取得了显著的成果，但仍然存在一些局限性，特定领域的测试任务通常需要专业化的工具或领域知识来解决。例如，基础模型可以通过预训练知识完成单次测试代码生成和测试文本生成等任务，但处理复杂的集成用例生成、特定领域用例生成和测试流程 pipeline 交互等问题时，需要更专业的工具和领域知识。</span></p><p style="margin-left:0; margin-right:0"><span>因此将专用工具与基础模型整合在一起，可以充分发挥它们各自的优势。专用工具可以解决模型时效性不足、增强专业知识、提高可解释性和鲁棒性的问题。而基础模型则具备类人的推理规划能力，可以理解复杂的数据和场景，并与现实世界进行交互。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p></div><span id="OSC_h4_7"></span><h4><span>5、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2FCodeFuse-ModelCache%2Fblob%2Fmain%2FREADME_CN.md" target="_blank" rel="nofollow">推理 - ModelCache</a></span><span>：</span></h4><p><span>大模型语义缓存系统，通过缓存已生成的模型结果，降低类似请求的响应时间，提升用户体验；详细介绍可以参看</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484139%26idx%3D1%26sn%3Df6b0fbe4d4dc7b47759146de60a1c820%26chksm%3Dc139d1daf64e58ccd522435f3769c2dd5b1953b7974c5efbb53ef0f9247ae3c037428a1770bf%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>此前文章</span></a><span>。</span></p><div><p style="margin-left:0; margin-right:0"><span>当前大模型服务面临以下三个挑战：</span></p><ul><li><span>成本高：大模型参数量千亿级别，单实例就需要多张 A10 卡，规模化部署成本高昂。因此，当前大模型服务基本按照处理的 token 数量计费，导致用户侧使用成本也居高不下。</span></li><li><span>速度慢：大型模型的推理速度也是一个关键问题。在许多实时应用中，如对话系统、业务助手，响应时间要求非常高，通常在毫秒级别。然而，大型模型的推理速度往往较慢，在秒级，导致无法实时返回结果，用户体验下降。</span></li><li><span>稳定性无保障：由於单实例部署成本高昂，当前大模型服务接受到大流量请求时，通过限流的方式，防止服务不可用。</span></li></ul><p style="margin-left:0; margin-right:0"><span>针对上述挑战，引入大模型缓存可以解决当前问题：通过引入 Cache 机制，缓存已计算的结果，当接收到类似请求，可以直接从缓存获取结果，避免重复计算，节约计算资源，显著提升响应时间，提升用户体验；同时，缓存可以起到分流的作用，降低透传到后端的请求量，降低后端压力，提升服务稳定性。因此，Cache 作为一种重要的大模型服务部署解决方案，在资源有限和对实时性要求较高的场景下，可以帮助企业和研究机构更好地应用大型语言模型，提升模型性能和效率。未来，随着大型模型在各个领域的广泛应用，Cache 的重要性将不断凸显。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p></div><span id="OSC_h4_8"></span><h4><span>6、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcodefuse-ai%2Fcodefuse-evaluation%2Fblob%2Fmaster%2FREADME_CN.md" target="_blank" rel="nofollow">评测 - CodeFuse-Evaluation</a></span><span>：</span></h4><p><span>在 HumanEval-x、MBPP 的基准上开发的编程领域多任务的评测基准， 可用于评估大模型在代码补全，自然语言生成代码，测试用例生成、跨语言代码翻译、中文指令生成代码等多类任务的性能；详细介绍可以参看</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwOTU3NTc3NA%3D%3D%26mid%3D2247484436%26idx%3D1%26sn%3D55ad2d46c2d6b8e9ef0d3e94201945b0%26chksm%3Dc139d725f64e5e331deb25933742bc70e9b608756059458bfa3700e16974711000ad20a32a86%26token%3D1529034469%26lang%3Dzh_CN%23rd" target="_blank" rel="nofollow"><span>此前文章</span></a><span>。</span></p><div><p style="margin-left:0; margin-right:0"><span>目前对于大语言模型评估的按照生成的结果是否可定量衡量比如数学计算和文章生成分为客观评测和主观评测。客观评测：基于业界影响力较高评测基准对生成内容进行各维度评估；主观评测：组织多位有专业背景知识的专家进行相关维度评估。</span></p><p style="margin-left:0; margin-right:0"><span>按照评测执行方式可分为自动化评测，人工评测和模型评测三类。</span></p><p style="margin-left:0; margin-right:0"><span>模型训练完成后，基于评估基准跑出评分，这个过程可以完全工程化的执行因此成为自动化评测。人工评测特别是领域知识需要着急各领域专家进行测评，此种方式评估成本较高但是评估结果更具有说服力。模型（如 PandaLM）评测模型即通过训练大模型学习到人类对不同生成文本的总体偏好，并作出基于习得的人类偏好的相对评价，这种评价方式相比人工更稳定、高效。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p></div><span id="OSC_h2_9"></span><h2><span>三、精彩的社区活动</span></h2><p style="margin-left:0; margin-right:0"><span>我们深知，开源不只是开放代码，还包括在社区的分享与交流。在开源内容上干货满满，社区活动定也不落下风，让我们看看都有哪些吧！！</span></p><p style="margin-left:0; margin-right:0"><span>8 月，我们在 AI+ 软件研发数字峰会上进行了专场分享《基于 AIGC 的测试生成》；</span></p><p style="margin-left:0; margin-right:0"><span>9 月，外滩大会上正式对外宣布 CodeFuse 开源；</span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/217410/1704420417098-5d63a0fa-ef73-4abe-8569-db04857eddef.png" width="540" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span>10 月，在 MLSummit 2023 上，对外分享了 CodeFuse 研发经验；</span></p><p style="margin-left:0; margin-right:0"><span>11 月初，在云栖大会上进行 CodeFuse 专题演讲；</span></p><p style="margin-left:0; margin-right:0"><span>11 月，和始智 AI 等联合举办了「代码大模型技术与应用发展」论坛；</span></p><p style="margin-left:0; margin-right:0"><span>12 月初，在 CCF 中国软件大会上，与参会者现场体验、互动交流；</span></p><p style="margin-left:0px; margin-right:0px; text-align:center"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/217410/1704420830670-62d284f9-b89c-4c3f-9f10-1bc174d4154e.png" width="480" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><span>12 月末，在全球软件开发者大会 QCon 上经验分享《基于 CodeFuse 的下一代研发探索》。</span></p><p style="margin-left:0; margin-right:0">&nbsp;</p><span id="OSC_h2_10"></span><h2><span>四、获得业界认可</span></h2><p style="margin-left:0; margin-right:0"><span>今年，CodeFuse 还获得了多个奖项，感谢业界的认可：</span></p><ul><li><span>荣获开源中国 2023 年度优秀开源技术团队</span></li></ul><p style="margin-left:0px; margin-right:0px; text-align:center"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/217410/1704420476632-42355276-1d79-46dd-bcb6-eb0c29a62311.png" width="540" referrerpolicy="no-referrer"></p><ul><li><span>入选极客公园 2023 大模型先锋案例 TOP10</span></li></ul><p style="margin-left:0px; margin-right:0px; text-align:center"><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/217410/1704420452319-a2eabbe9-21a1-47e2-a54f-84d5fce1b04b.png" width="540" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px; text-align:center">&nbsp;</p><span id="OSC_h2_11"></span><h2><span>五、2024 新的期待</span></h2><p style="margin-left:0; margin-right:0"><br><span>2023 年以来，大模型在代码领域落地不断深入。经过一年的实践，我们对相关的技术也有了更深层次的理解与认识。也看到了很多有趣的方向与落地实践。在 2024 新的一年里，我们还会继续深耕开源：</span></p><ul><li><span>更多创新功能发布，例如近期 1 月份将发布支持 MoE 的 MFTCoder v0.2; 2 月份将发布支持前端设计到代码的训练框架和模型；</span></li><li><span>更多的线下活动，会组织多次 CodeFuse 线下 meetup，欢饮感兴趣的同行多多参与；也会积极参与国内和国际行业会议/论坛更多分享 CodeFuse 的实践经验；</span></li><li><span>更多的社区参与和互动，会社区调研，让大家能够参与到项目中来；包括不限于发起社区一起捉虫、一起贡献新特性，推动相关体系的标准化，甚至组织相关比赛活动等。</span></li></ul><p style="margin-left:0; margin-right:0">&nbsp;</p><p style="margin-left:0; margin-right:0"><span>非常欢迎大家能够跟我们一起交流探索，一起来定义下一代基于大模型的全生命周期研发解决方案。欢迎大家参与到我们社区中，一起探讨、交流。 2024，一起向未来！</span></p><p style="margin-left:0; margin-right:0"><span style="color:rgba(0, 0, 0, 0.9)">CodeFuse 官网：</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcodefuse.alipay.com" rel="nofollow" target="_blank"><span style="color:#0080ff">https://codefuse.alipay.com</span></a></p></div></div>
                                    ]]>
            </description>
            <pubDate>Mon, 08 Jan 2024 07:55:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6942768/blog/10678192</guid>
            <link>https://my.oschina.net/u/6942768/blog/10678192</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[商汤科技：前海深港人工智能算力中心正式启动]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>商汤科技发文宣布，前海深港人工智能算力中心正式点亮启动；目标打造粤港澳大湾区大规模、领先算力的智算中心。</p><p>一期建设算力将达 500 Petaflops（FP16），AI 算力规模每秒 50 亿亿次，相当于一小时可完成 16 亿张图像处理、190 万小时语音翻译、0.7 万公里自动驾驶 AI 数据处理；</p><p>该算力中心坐落于深圳市前海信息枢纽大厦，由深圳前海管理局、商汤科技、香港科技园公司三方共同推进，前海科技创新集团与商汤科技联合投资建设。</p><p>商汤科技董事长兼 CEO 徐立表示：</p><blockquote><p>「人工智能在 2023 年实现了跨越式发展，进入以大模型为基础的 AI 2.0 时代，先进智能算力作为当前最具活力的新型生产力，已成为重要的战略资源。前海加大科技基础设施建设和科技领域投入，又一次走在了全国新旧发展动能转换的前列。基于建成亚洲最大 AIDC 智算中心之一的成功经验，商汤愿意充分发挥在人工智能行业的优势，在深港合作、算法大模型、人工智能产业与投资等领域加强产业带动与应用示范，协同香港与前海融合发展做出贡献。」</p></blockquote><p>活动现场<span style="background-color:#ffffff; color:#4c4c4c">还举行了智算中心意向客户签约仪式，并与前海大数据资源管理中心有限公司签订了委托运营协议。</span></p><p><img height="292" src="https://oscimg.oschina.net/oscnet/up-f2e6b62e914595ab3929261a6cb9b2e07c8.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 08 Jan 2024 07:24:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274742</guid>
            <link>https://www.oschina.net/news/274742</link>
            <author>
                <![CDATA[来源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[R 语言社区知名开发者「谢益辉」被 RStudio/Posit 解雇]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>R Markdown、knitr、blogdown 和 bookdown 等 R 软件包的创建者<span style="background-color:#ffffff; color:#191b1f">谢益辉</span>于日前<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fyihui.org%2Fen%2F2024%2F01%2Fbye-rstudio%2F" target="_blank">发布博客表示</a>，自己已于 2023 年底被 Posit (原 Rstudio) 公司解雇，并于 2024 年 1 月 1 日正式离开该公司。</p><blockquote><p><span style="color:#000000">在写了这么多年的 「*down」 packages 后，我在这里宣布「Yihui-down」。</span></p><p>谁倒下了？我。在 RStudio/Posit 工作了 10 多年之后，<span style="color:#000000">现在是我探索其他机会的时候了</span>。两个多星期前，我被告知被裁员了，最后一天是 2023-12-31。坦率地说，我感到非常惊讶，但只是短暂的惊讶。我完全尊重 Posit 的决定，并很快接受了我的贡献不再配得上这里的全职工作这一结论。一段关系的结束往往并不意味着任何一方做错了什么或失败了什么。相反，它可能只是表明双方不匹配，这很正常。人就是会变。<span style="color:#000000">回想起这些美好的岁月，我离开时大多怀着感激之情。</span></p></blockquote><p><span style="background-color:#ffffff; color:#191b1f">谢益辉表示，</span><span style="background-color:#ffffff; color:#000000">Posit 同时</span><span style="background-color:#ffffff; color:#111111">为他提供了一个合同工方案；因此这一离开并不意味着诀别，他后续将继续维护 R Markdown 系列包（暂定一年）。现有的 R 软件包仍将得到维护。但 DT 软件包是唯一的例外，因为它不在合同之列，Posit 计划为它寻找新的维护者。</span></p><p><span style="background-color:#ffffff; color:#111111">但这一合同工并不足以维生，</span><span style="background-color:#ffffff; color:#191b1f">谢益辉也在需找新的工作机会，希望同时能够满足可以自由灵活地继续为 R 生态系统和开源做出贡献。</span></p><p><span style="background-color:#ffffff; color:#191b1f">考虑到被突然解雇后所面临的经济压力，谢益辉还发布了一个众筹的赞助页面，以寻求大家的帮助：</span><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsponsors%2Fyihui" target="_blank">https://github.com/sponsors/yihui</a></strong></p><p>「我以前从未向社区请求过经济支持，因为我从来没有感觉到有必要（感谢 Posit）。现在情况变得不一样了......如果有人能在我过渡到下一个稳定的生活阶段之前支持我几个月，我将非常感激。当我不再需要赞助时，我会通知大家，如果你们是月度赞助，可以取消赞助。我很乐意提供一些临时性的帮助作为回报。」</p><p><img height="250" src="https://oscimg.oschina.net/oscnet/up-53f457f44cfc3d2e70079cb04b2ef93e18a.png" width="500" referrerpolicy="no-referrer"></p><p>一些 R 用户对于<span style="background-color:#ffffff; color:#191b1f">谢益辉的离开</span>表达了震惊，研究软件工程师 Zhian N. Kamvar 在 Mastodon 上<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhachyderm.io%2F%40zkamvar%2F111699279163834211" target="_blank">发帖称</a>，「这绝对是毁灭性的消息。如果没有<span style="background-color:#ffffff; color:#191b1f">益</span>辉在 knitr 上的工作，我不可能取得过去十年的成就。如果你最近有使用过 RStats 构建的网站、报告或书籍，你都要感谢<span style="background-color:#ffffff; color:#191b1f">益</span>辉。」</p><p>外媒&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.infoworld.com%2Farticle%2F3712061%2Fposit-lays-off-r-markdown-knitr-creator-yihui-xie.html" target="_blank">InfoWorld</a> 认为，<span style="background-color:#ffffff; color:#191b1f">谢益辉的离开再次表明了一个信号，即&nbsp;Posit&nbsp;</span>正在专注于提供 R 和 Python 之间互操作性的产品。一个相关的佐证就是 2022 年发布的 Quarto 开源技术发布平台，该平台不区分语言，同样支持 R 和 Python，以及 Julia 和 Observable JavaScript。该公司当时表示，Quarto 将是下一代 R Markdown。</p><p>在<span style="background-color:#ffffff; color:#191b1f">谢益辉</span>被解雇的前一个月，Python pandas 创建者 Wes McKinney 也加入了 Posit，这也表明该公司正在认真地将其业务重点扩大到 R 之外。McKinney 当时表示，他将「在 Posit 的工作中倡导 PyData 生态系统的需求，并继续推进重要的开源计划。」</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 08 Jan 2024 06:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/274729/posit-lays-off-yihui-xie</guid>
            <link>https://www.oschina.net/news/274729/posit-lays-off-yihui-xie</link>
            <author>
                <![CDATA[来源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[🔥 周热点 | 「后开源」 时代已来；Redis 之父 「锐评」 LLM 编程；2024 前端圈「开年之战」上演....]]>
            </title>
            <description>
                <![CDATA[回顾一周热门资讯。2024.01.01-2024.01.07]]>
            </description>
            <pubDate>Mon, 08 Jan 2024 06:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649094095&#38;idx=1&#38;sn=ef33510eefe489ba79639ee09ff10152&#38;chksm=880c4cdcbf7bc5ca1ab8725a741382ed6cce96c7493e27dbb87e559dde82be3bbeb14def9960&#38;token=1679093283&#38;lang=zh_CN#rd</guid>
            <link>https://mp.weixin.qq.com/s?__biz=MzA4OTI5NjUwOA==&#38;mid=2649094095&#38;idx=1&#38;sn=ef33510eefe489ba79639ee09ff10152&#38;chksm=880c4cdcbf7bc5ca1ab8725a741382ed6cce96c7493e27dbb87e559dde82be3bbeb14def9960&#38;token=1679093283&#38;lang=zh_CN#rd</link>
        </item>
        <item>
            <title>
                <![CDATA[App 跨平台框架 VS 原生开发深度评测之 2023 版]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>App 跨平台框架历史悠久，从<code>cordova</code>、<code>react native</code>、<code>flutter</code>，直到最近的<code>uni-app x</code>。江山代有才人出，每个都试图颠覆原生，但过去却一直未成功。</p><p>过去的问题到底在哪里？</p><p>我们先捋一捋各种技术路线，分析这些跨平台开发框架和原生应用的差别具体在哪里。</p><table><thead><tr><th>逻辑层</th><th>渲染层</th><th>类型</th><th>代表作</th></tr></thead><tbody><tr><td>webview</td><td>webview</td><td>弱类型</td><td>5+App、cordova</td></tr><tr><td>js 引擎</td><td>webview</td><td>弱类型</td><td>uni-app 之<code>app-vue</code> 、小程序（dount）</td></tr><tr><td>js 引擎</td><td>原生渲染</td><td>弱类型</td><td>react native、uni-app 之<code>app-nvue</code>、weex</td></tr><tr><td>dart 引擎</td><td>flutter 渲染引擎</td><td>强类型</td><td>flutter</td></tr><tr><td>js 引擎</td><td>flutter 渲染引擎</td><td>弱类型</td><td>微信 skyline、webF、ArkUI-x</td></tr><tr><td>kotlin</td><td>原生渲染</td><td>强类型</td><td>uni-app x</td></tr><tr><td>kotlin</td><td>原生渲染</td><td>强类型</td><td>原生应用</td></tr></tbody></table><p>上面的表格，除了行尾的原生应用外，各个跨平台框架按出现时间排序，可以看到跨平台框架是如何演进的。</p><p>上表中，<code>uni-app x</code>和原生应用是一样的，逻辑层和渲染层都是原生，都是强类型；而其他跨平台框架或者在逻辑层、或者在渲染层与原生不一致。</p><p><code>webview</code>不行已经是业内常识了，启动慢、渲染慢、内存占用高。这块本文不再详述。</p><p>但那些非 web-view 的框架到底哪里不如原生？</p><h2>1. js 逻辑+ 原生渲染</h2><p><code>react native</code>、<code>weex</code>等抛弃<code>webview</code>，改由原生渲染的跨平台方案，2014 年就推出了。 如今手机硬件也越来越好了，为什么性能还达不到原生？</p><p>js+原生渲染的方案主要有 2 点缺陷：</p><ul><li>JS 引擎自身的性能问题</li><li>JS 和原生之间的通信延迟</li></ul><h3>1.1 js 引擎慢，启动速度和运行速度都弱于原生</h3><p>所以很多开发者即便使用这类方案，首页也还是原生来写。</p><p>React Native 的<code>Hermes</code>引擎和华为的<code>arkUI</code>，提供了 js 编译为字节码的方案，这是一种空间换时间的方案，启动速度有了一定优化，但仍然比不过原生。</p><p>弱类型在编译期可优化的幅度有限，还是需要一个运行时来跑，无法像强类型那样直接深入底层。</p><p>以数字运算为例，js 的<code>number</code>运算确实比强类型的<code>int</code>慢，内存开销也更大。</p><h3>1.2 js 语言与原生之间通信卡顿</h3><p>每个语言有自己的内存空间，跨语言通信都有折损，每次通信几十到几百毫秒不等，视手机当时的状态。一旦频繁通信，就会明显卡顿。</p><p>逻辑层的 js，即要和原生渲染层通信，还要和原生 API 通信：</p><h4>1.2.1 js 与原生 ui 通信</h4><p>举个简单的场景例子，在 js 里监听滚动，根据滚动变化实时调整界面上某些元素的高度变化。这个问题能难倒一大批跨平台开发框架。</p><p>如果全部在 webview 里，js 操作 ui 还好一些，所以 uni-app 的 app-vue 里的 renderjs 操作 UI 性能高，就是这个道理。同理还有微信小程序的<code>wsx</code>。</p><p>虽然小程序和 uni-app 都是 js，但实际上逻辑层在独立 js 引擎里，通过原生桥来控制 web-view，通信成本很高。</p><p>weex 提供了<code>bindingx</code>技术，这是一种弱编程，渲染层预先定义了一些操作 UI 的方式，调用时全部在渲染层运行，不会来回与逻辑层通信。但这种预定义方式的适应面有限，无法做到在 js 里高性能、自由的操作所有 UI。</p><h4>1.2.2 js 操作原生 api</h4><p>操作系统和三方 SDK 的 API 都是原生的，js 调用这些能力也需要跨语言通信。比如 js 调用原生的 Storage 或 IO，数据较多时遍历的性能非常差。</p><p>当然在 js API 的封装上可以做些优化，比如微信的 storage 提供了<code>wx.batchGetStorageSync</code>这种批量读取的 API，既然遍历性能差，那干脆一次性从原生读出来再传给 js。</p><p>这也只能是无奈的方案，如果在遍历时想用 js 做什么判断就实现不了了，而且一次性读出很大的数据后传给 js 这一下，也需要通信时间。</p><h2>2. flutter 方案</h2><p>flutter 在 2018 年发布，第一次统一了逻辑层和渲染层，而且使用了强类型。</p><p>它没有使用原生渲染，而是使用由<code>dart</code>驱动的渲染引擎，这样逻辑层的 dart 代码操作 UI 时，再也没有延时了！bindingx、wxs 这种补丁方案再也不需要了。</p><p>并且 dart 作为强类型，编译优化很好做，启动速度和运行速度都胜过 js。</p><p>在这个开源项目下<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitcode.net%2Fdcloud%2Ftest-cross%2F-%2Ftree%2Fmaster%2Ftest_flutter_slider_100" target="_blank">https://gitcode.net/dcloud/test-cross/-/tree/master/test_flutter_slider_100</a>，提供了一个 flutter 编写的 100 个 slider 同时滑动的示例， 项目下有源码也有打包好 apk，可以直接安装体验。</p><p>100 个 slider 同时滑动，非常考验逻辑和 UI 的通信。如果在 webview 内部，html 和 js 写 100 个这样的 slider，在新的手机上表现也还 ok。但在小程序和 react native 这种逻辑和 UI 分离的模式下，100 个 slider 是灾难。</p><p>下载安装 apk 后可以看到 dart 操作 flutter 的 UI 真的没有通信折损，100 个 slider 的拖动非常流畅。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ixigua.com%2F7317188140437864502%3FlogTag%3Dfd9af6e9d0d98f40568e" target="_blank">点击查看视频</a></p><p>flutter 看起来很完美。但为什么也没有成为主流呢？很多大厂兴奋的引入后为何又不再扩大使用范围呢？</p><h3>2.1 dart 与原生 API 的通信</h3><p>别忘了上面 1.2.2 提到的原生 API 通信。flutter 虽然在逻辑层和渲染层都是 dart，但要调用原生 API 时，还是要通信。</p><p>操作系统和三方 SDK 的 API 是原生的，让 dart 调用需要做一层封装，又落到了跨语言通信的坑里。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitcode.net%2Fdcloud%2Ftest_flutter_message_channel" target="_blank">https://gitcode.net/dcloud/test_flutter_message_channel</a>这是一个开源测试项目，来测试原生的 claas 数据与 dart 的通信耗时。</p><p>项目里面有源码，大家可自行编译；根目录有打包好的 apk，也可以直接安装体验。</p><p>这个项目首先在 kotlin 中构建了包含不同数据量的 class，传递到 dart 然后渲染在界面上，并且再写回到原生层。</p><p>有 0.1k 和 1k 两种数据量（点击界面上的 1k 数字可切换），有读和读并写 2 个按钮，各自循环 1000 次。</p><p>以下截图的测试环境是华为 mate 30 5G，麒麟 990。手机上所有进程杀掉。如下图：</p><ul><li>1k 数据从原生读到 dart 并渲染</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-b6da22344a6d16c9d69b06e7e643d8693c1.jpg" alt="flutter_1k_read.jpeg" referrerpolicy="no-referrer"></p><ul><li>1k 数据从原生读到 dart 并渲染再写回</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-bf956b25b963ff74a653cb15558cad78f00.jpg" alt="flutter_1k_readwrite.jpeg" referrerpolicy="no-referrer"></p><ul><li>0.1k 数据从原生读到 dart 并渲染</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-eec96c5ae67f8c3db0137dc2f84f5c757c3.jpg" alt="flutter_0.1k_read.jpeg" referrerpolicy="no-referrer"></p><ul><li>0.1k 数据从原生读到 dart 并渲染再写回</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-6df9c0934af2fed44809afdcad596493c1e.jpg" alt="flutter_0.1k_readwrite.jpeg" referrerpolicy="no-referrer"></p><p>通信损耗非常明显。并且数据量从 1k 降低到 0.1k 时，通信时间并没有减少 10 倍，这是因为通信耗时有一个基础线，数据再小也降不下去。</p><p>为什么会这样？因为<code>dart</code>和<code>kotlin</code>不是一种编程语言，不能直接调用<code>kotlin</code>的<code>class</code>，只能先序列化成字符串，把字符串数据从原生传到 dart，然后在 dart 层再重新构造。</p><p>当然也可以在原生层为 dart 封装 API 时提供 wx.batchGetStorageSync 这类批处理 API，把数据一次读好再给 dart，但这种又会遇到灵活性问题。</p><p>而在<code>uni-app x</code>中，这种跨语言通信是不存在的，不需要序列化，因为 uni-app x 使用的编程语言 uts，在 android 上就编译为了 kotlin，它可以直接调用 kotlin 的 class 而无需通信和封装。示例如下，具体 uni-app x 的原理后续章节会专题介绍。</p><pre><code>&lt;template&gt;
&lt;/template&gt;
&lt;script lang="uts"&gt;
import Build from 'android.os.Build';
export default {
onLoad() {
console.log(Build.MODEL); //uts 可以直接导入并使用原生对象，不需要封装，没有跨语言通信折损
}
}
&lt;/script&gt;
</code></pre><p>再分享一个知识：</p><p>很多人都知道 iPhone 上跨平台框架的应用，表现比 android 好。但大多数人只知道是因为 iPhone 的硬件好。</p><p>其实还有一个重要原因，iOS 的 jscore 是 c 写的，OS 的 API 及渲染层也都是 ObjectC，js 调用原生时，某些类型可以做共享内存的优化。但复杂对象也还是无法直接丢一个指针过去共享使用内存。</p><p>而 android，不管 java 还是 kotlin，他们和 v8、dart 通信仍然需要跨语言通信。</p><h3>2.2 flutter 渲染和原生渲染的并存问题</h3><p>flutter 的自渲染引擎，在技术上是不错的。但在生态兼容上有问题。</p><p>很多三方软件和 SDK 是原生的，原生渲染和 flutter 自渲染并存时，问题很多。</p><p>flutter 开发者都知道的一个常见坑是输入法，因为输入法是典型的原生 UI，它和 flutter 自绘 UI 并存时各种兼容问题，输入框被遮挡、窗体 resize 适应，输入法有很多种，很难适配。</p><p>混合渲染，还有信息流广告、map、图表、动画等很多三方 sdk 涉及。这个时候内存占用高、渲染帧率下降、不同渲染方式字体不一致、暗黑主题不一致、国际化、无障碍、UI 自动化测试，各种不一致。。。</p><p>这里没有提供开源示例，因为 flutter 官方是承认这个问题的，它提供了 2 种方式：混合集成模式和虚拟显示模式模式。</p><p>但在渲染速度、内存占用、版本兼容、键盘交互上都各自有各自的问题。详见 flutter 官网：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.flutter.dev%2Fplatform-integration%2Fandroid%2Fplatform-views%23performance" target="_blank">https://docs.flutter.dev/platform-integration/android/platform-views#performance</a>。这个是中文翻译：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fflutter.cn%2Fdocs%2Fplatform-integration%2Fandroid%2Fplatform-views%23performance" target="_blank">https://flutter.cn/docs/platform-integration/android/platform-views#performance</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fflutter.cn%2Fdocs%2Fplatform-integration%2Fandroid%2Fplatform-views%23performance" target="_blank"></a></p><p>在各大 App 中，微信的小程序首页是为数不多的使用 flutter UI 的界面，已经上线 1 年以上。</p><p>下面是微信 8.0.44（此刻最新版），从微信的发现页面进入小程序首页。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ixigua.com%2F7317194438416007206%3FlogTag%3D8165f43a009f28425f24" target="_blank">点击查看视频</a></p><p>视频中手机切换暗黑主题后，这个 UI 却还是白的，而且 flutter 的父容器原生 view 已经变黑了，它又在黑底上绘制了一个白色界面，体验非常差。</p><p>这个小程序首页界面很简单，没有输入框，规避了混合渲染，点击搜索图标后又跳转到了黑色的原生渲染的界面里。</p><p>假使这个界面再内嵌一个原生的信息流 SDK，那会看到白色 UI 中的信息流广告是黑底的，更无法接受。</p><p>当然这不是说 flutter 没法做暗黑主题，重启微信后这个界面会变黑。这里只是说明渲染引擎不一致带来的各种问题。</p><blockquote><p>注：如何识别一个界面是不是用 flutter 开发的？在手机设置的开发者选项里，有一个 GPU 呈现模式分析，flutter 的 UI 不触发这个分析。且无法审查布局边界。</p></blockquote><p>flutter 的混合渲染的问题，在所有使用原生渲染的跨平台开发框架中都不存在，比如 react native、weex、uni-app x。</p><p>总结下 flutter：逻辑层和 UI 层交互没有通信折损，但逻辑层 dart 和原生 api 有通信成本，自绘 UI 和原生 ui 的混合渲染问题很多。</p><h2>3. js+flutter 渲染</h2><p>flutter 除了上述提到的原生通信和混合渲染，还有 3 个问题：dart 生态、热更新、以及比较难用的嵌套写法。</p><p>一些厂商把 flutter 的 dart 引擎换成了 js 引擎，来解决上述 3 个问题。比如微信 skyline、webF、ArkUI-x。</p><p>其实这是让人困惑的行为。因为这又回到了 react native 和 weex 的老路了，只是把原生渲染换成了 flutter 渲染。</p><p>flutter 最大的优势是 dart 操作 UI 不需要通信，以及强类型，而改成 js，操作 UI 再次需要通信，又需要 js 运行时引擎。</p><p>为了解决 js 和 flutter 渲染层的通信问题，微信的 skyline 又推出了补丁技术 worklet 动画，让这部分代码运行在 UI 层。（当然微信的通信，除了跨语言，还有跨进程通信，会更明显）</p><p>这个项目<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitcode.net%2Fdcloud%2Ftest-cross%2F-%2Ftree%2Fmaster%2Ftest_arkuix_slider_100" target="_blank">https://gitcode.net/dcloud/test-cross/-/tree/master/test_arkuix_slider_100</a>， 使用 ArkUI-x 做了 100 个 slider，大家可以看源码，下载 apk 体验，明显能看到由于逻辑层和 UI 层通信导致的卡顿。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ixigua.com%2F7317196064589627411%3FlogTag%3D368ecfd6c36a3f4fe41a" target="_blank">点击查看视频</a></p><p>上述视频中，注意看手指按下的那 1 个 slider，和其他 99 个通过数据通讯指挥跟随一起行动的 slider，无法同步，并且界面掉帧。</p><p>不过自渲染由于无法通过 Android 的开发者工具查看 GPU 呈现模式，所以无法从条状图直观反映出掉帧。</p><blockquote><p>注意 ArkUI-x 不支持<code>Android8.0</code>以下的手机，不要找太老的手机测试。</p></blockquote><p>很多人以为自渲染是王道，但其实自渲染是坑。因为 flutter 的 UI 还会带来混合渲染问题。</p><p>也就是说，js+flutter 渲染，和 js+原生渲染，这 2 个方案相比，都是 js 弱类型、都有逻辑层和渲染层的通信问题、都有原生 API 通信问题，而 js+flutter 还多了一个混合渲染问题。</p><p>可能有的同学会说，原生渲染很难在 iOS、Android 双端一致，自渲染没有这个问题。</p><p>但其实完全可以双端一致，如果你使用某个原生渲染框架遇到不一致问题，那只是这个框架厂商做的不好而已。</p><p>是的，很遗憾 react native 在跨端组件方面投入不足，官方连 slider 组件都没有，导致本次评测中未提供 react native 下 slider-100 的示例和视频。</p><h2>4. uni-app x</h2><p>2022 年，uts 语言发布。2023 年，uni-app x 发布。</p><p>uts 语言是基于 typescript 修改而来的强类型语言，编译到不同平台时有不同的输出：</p><ul><li>编译到 web，输出 js</li><li>编译到 Android，输出 kotlin</li><li>编译到 iOS，输出 swift</li></ul><p>而 uni-app x，是基于 uts 语言重新开发了一遍 uni-app 的组件、API 以及 vue 框架。</p><p>如下这段示例，前端的同学都很熟悉，但它在编译为 Android App 时，变成了一个纯的 kotlin app，里面没有 js 引擎、没有 flutter、没有 webview，从逻辑层到 UI 层都是原生的。</p><pre><code>&lt;template&gt;
&lt;view class="content"&gt;
&lt;button @click="buttonClick"&gt;{{title}}&lt;/button&gt;
&lt;/view&gt;
&lt;/template&gt;

&lt;script&gt; //这里只能写 uts
export default {
data() {
return {
title: "Hello world"
}
},
onLoad() {
console.log('onLoad')
},
methods: {
buttonClick: function () {
uni.showModal({
"showCancel": false,
"content": "点了按钮"
})
}
}
}
&lt;/script&gt;

&lt;style&gt;
.content {
width: 750rpx;
background-color: white;
}
&lt;/style&gt;
</code></pre><p>这听起来有点天方夜谭，很多人不信。DCloud 不得不反复告诉大家，可以使用如下方式验证：</p><ul><li><p>在编译 uni-app x 项目时，在项目的 unpackage 目录下看看编译后生成的 kt 文件</p></li><li><p>解压打包后的 apk，看看里面有没有 js 引擎或 flutter 引擎</p></li><li><p>手机端审查布局边界，看看渲染是不是原生的（flutter 和 webview 都无法审查布局边界）</p></li></ul><p>但是开发者也不要误解之前的 uni-app 代码可以无缝迁移。</p><ul><li><p>之前的 js 要改成 uts。uts 是强类型语言，上面的示例恰好类型都可以自动推导，不能推导的时候，需要用<code>:</code>和<code>as</code>声明和转换类型。</p></li><li><p>uni-app x 支持 css，但是 css 的子集，不影响开发者排版出所需的界面，但并非 web 的 css 全都兼容。</p></li></ul><p>了解了 uni-app x 的基本原理，我们来看下 uni-app x 下的 100 个 slider 效果怎么样。</p><p>项目<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitcode.net%2Fdcloud%2Ftest-cross%2F-%2Ftree%2Fmaster%2Ftest_uniappx_slider_100" target="_blank">https://gitcode.net/dcloud/test-cross/-/tree/master/test_uniappx_slider_100</a>下有源码工程和编译好的 apk。</p><p>如下视频，打开了 GPU 呈现模式，可以看到没有一条竖线突破那条红色的掉帧安全横线，也就是没有一帧掉帧。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ixigua.com%2F7317198768934715433%3FlogTag%3D89299d3c416b4e9e6de7" target="_blank">点击查看视频</a></p><p>uni-app x 在 app 端，不管逻辑层、渲染层，都是 kotlin，没有通信问题、没有混合渲染问题。不是达到了原生的性能，而是它本身就是原生应用，它和原生应用的性能没差别。</p><p>这也是其他跨平台开发框架做不到的。</p><p>uni-app x 是一次大胆的技术突破，分享下 DCloud 选择这条技术路线的思路：</p><p>DCloud 做了很多年跨平台开发，uni-app 在 web 和小程序平台取得了很大的成功，不管规模大小的开发者都在使用；但在 app 平台，大开发者只使用 uni 小程序 sdk，中小开发者的 app 会整体使用。</p><p>究其原因，uni-app 在 web 和小程序上，没有性能问题，直接编译为了 js 或 wxml，uni-app 只是换了一种跨平台的写法，不存在用 uni-app 开发比原生 js 或原生 wxml 性能差的说法。</p><p>但过去基于小程序架构的 app 端，性能确实不及原生开发。</p><p>那么 App 平台，为什么不能像 web 和小程序那样，直接编译为 App 平台的原生语言呢？</p><p>uni-app x，目标不是改进跨平台框架的性能，而是给原生应用提供一个跨平台的写法。</p><p>这个思路的转换使得 uni-app x 超越了其他跨平台开发框架。</p><p>在 web 端编译为 js，在小程序端编译为 wxml 等，在 app 端编译为 kotlin。每个平台都只是帮开发者换种一致的写法而已，运行的代码都是该平台原生的代码。</p><p>然而在 2 年前，这条路线有 2 个巨大的风险：</p><ol><li><p>从来没有人走通过</p></li><li><p>即便能走通，工作量巨大</p></li></ol><p>没有人确定这个产品可以做出来，DCloud 内部争议也很多。</p><p>还好，经历了无数的困难和挑战，这个产品终于面世了。</p><p>换个写法写原生应用，还带来另一个好处。</p><p>同样业务功能的 app，使用 vue 的写法，比手写纯原生快多了。也就是 uni-app x 对开发效率的提升不只是因为跨平台，单平台它的开发效率也更高。</p><p>其实 google 自己也知道原生开发写法太复杂，关于换种更高效的写法来写原生应用，他们的做法是推出了 compose UI。</p><p>不过遗憾的是这个方案引入了性能问题。我们专门测试使用 compose UI 做 100 个 slider 滑动的例子，流畅度也掉帧。</p><p>源码见：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitcode.net%2Fdcloud%2Ftest-cross%2F-%2Ftree%2Fmaster%2Ftest_compose_ui_slider_100" target="_blank">https://gitcode.net/dcloud/test-cross/-/tree/master/test_compose_ui_slider_100</a>， 项目下有打包后的 apk 可以直接安装体验。</p><p>打开 GPU 呈现模式，可以看到 compose ui 的 100 个 slider 拖动时，大多数竖线都突破那条红色的掉帧安全横线，也就是掉帧严重。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ixigua.com%2F7317199270568787978%3FlogTag%3D198750168701d834e8ac" target="_blank">点击查看视频</a></p><p>既然已经把不同开发框架的 slider-100 应用打包出来了，我们顺便也比较了不同框架下的包体积大小、内存占用：</p><table><thead><tr><th></th><th>包体积（单位:M）</th><th>内存占用（单位:Kb）</th></tr></thead><tbody><tr><td>flutter</td><td>18</td><td>141324.8</td></tr><tr><td>ArtUI-x</td><td>45.7</td><td>133091.2</td></tr><tr><td>uni-app x</td><td>8.5</td><td>105451.2</td></tr><tr><td>compose ui</td><td>4.5</td><td>97683.2</td></tr></tbody></table><p><strong>包体积数据说明：</strong></p><ul><li><p>包含 3 个 CPU 架构：arm64、arm32、x86_64。</p></li><li><p>flutter 的代码都是编译为 so 文件，支持的 cpu 类型和包体积是等比关系，1 个 cpu 最小需要 6M 体积，业务代码越多，cpu 翻倍起来越多。</p></li><li><p>ArtUI-x 的业务代码虽然写在 js 里，但除了引用了 flutter 外还引用了 js 引擎，这些 so 库体积都不小且按 cpu 分类型翻倍。</p></li><li><p>uni-app x 里主业务都在 kotlin 里，kotlin 和 Android x 的兼容库占据了不少体积。局部如图片引用了 so 库，1 个 cpu 最小需要 7M 体积。但由于 so 库小，增加了 2 个 cpu 类型只增加了不到 1M。</p></li><li><p>compose ui 没有使用 so 库，体积裁剪也更彻底。</p></li><li><p>uni-app x 的常用模块并没有裁剪出去，比如 slider100 的例子其实没有用到图片，但图片使用的 fesco 的 so 库还是被打进去了。实际业务中不可能不用图片，所以实际业务中 uni-app x 并不会比 compose ui 体积大多少。</p></li></ul><p><strong>内存占用数据说明：</strong></p><ul><li>在页面中操作 slider 数次后停止，获取应用内存使用信息 VmRSS: 进程当前占用物理内存的大小</li><li>表格中的内存数据是运行 5 次获取的值取平均值</li><li>自渲染会占据更多内存，如果还涉及混合渲染那内存占用更高</li></ul><h2>5. 后记</h2><p>跨语言通信、弱类型、混合渲染、包体积、内存占用，这些都是过去跨平台框架不如原生的地方。</p><p>这些问题在<code>uni-app x</code>都不存在，它只是换了一种写法的原生应用。</p><table><thead><tr><th>各种框架</th><th>类型</th><th>逻辑层与 UI 通信折损</th><th>逻辑层与 OS API 通信折损</th><th>混合渲染</th></tr></thead><tbody><tr><td>react native、nvue、weex</td><td>弱</td><td>有</td><td>有</td><td>无</td></tr><tr><td>flutter</td><td>强</td><td>无</td><td>有</td><td>有</td></tr><tr><td>微信 skyline、webF、ArkUI-x</td><td>弱</td><td>有</td><td>有</td><td>有</td></tr><tr><td>uni-app x</td><td>强</td><td>无</td><td>无</td><td>无</td></tr><tr><td>原生应用</td><td>强</td><td>无</td><td>无</td><td>无</td></tr></tbody></table><p>当然，作为一个客观的分析，这里需要强调<code>uni-app x</code>刚刚面世，还有很多不成熟的地方。比如前文 diss 微信的暗黑模式，其实截止到目前 uni-app x 还不支持暗黑模式。甚至 iOS 版现在只能开发 uts 插件，还不能做完整 iOS 应用。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvote.dcloud.net.cn%2F%23%2F%3Fname%3Duni-app%2520x" target="_blank">需求墙</a>里都是 uni-app x 该做还未做的。也欢迎大家投票。</p><p>另外，原生 Android 中一个界面不能有太多元素，否则性能会拉胯。flutter 的自渲染和 compose ui 解决了这个问题。而原生中解决这个问题需要引入自绘机制来降低元素数量，这个在<code>uni-app x</code>里对应的是 draw 自绘 API。</p><p>uni-app x 这个技术路线是产业真正需要的东西，随着产品的迭代完善，它能真正帮助开发者即提升开发效率又不牺牲性能。</p><p>让跨平台开发不如原生，成为历史。</p><p>欢迎体验 uni-app x 的示例应用，感受它的启动速度，渲染流畅度。</p><p>源码在：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitcode.net%2Fdcloud%2Fhello-uni-app-x%2F" target="_blank">https://gitcode.net/dcloud/hello-uni-app-x/</a>； 或者扫描下方二维码下载打包后的 apk 文件：</p><p><img src="https://oscimg.oschina.net/oscnet/up-832ea9b51d5b53048d6ab133b791cc54ecb.png" alt="uts-01.png" referrerpolicy="no-referrer"></p><p>这个示例里有几个例子非常考验通信性能，除了也内置了 slider-100 外，另一个是「模版-scroll-view 自定义滚动吸顶」，在滚动时实时修改元素 top 值始终为一个固定值，一点都不抖动。</p><p>我们不游说您使用任何开发技术，但您应该知道它们的原理和差别。</p><p>欢迎指正和讨论。</p><h2>橄榄枝</h2><p><a href="https://www.oschina.net/action/GoToLink?url=mailto%3A%E6%AC%A2%E8%BF%8E%E5%AF%B9uni-app%E5%9B%A2%E9%98%9F%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E5%90%84%E4%BD%8D%E5%90%8C%E5%AD%A6%EF%BC%8C%E6%8A%95%E7%AE%80%E5%8E%86%E5%88%B0hr2013%40dcloud.io%E3%80%82" target="_blank">欢迎对 uni-app 团队感兴趣的各位同学，投简历到 hr2013@dcloud.io。</a></p><p>DCloud 是一个纯粹的工程师团队，公司 90% 的职员都是写代码的工程师，无需见客户、写方案，大部分都有原始股权，欢迎有好奇心、追求卓越的极客加盟。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 08 Jan 2024 06:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/hbcui/blog/10590182</guid>
            <link>https://my.oschina.net/hbcui/blog/10590182</link>
            <author>
                <![CDATA[原创]]>
            </author>
        </item>
    </channel>
</rss>
