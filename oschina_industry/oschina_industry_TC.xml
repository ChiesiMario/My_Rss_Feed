<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-綜合資訊]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 02 Jan 2024 10:19:51 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[出售破解無人機「限高、限飛」程序被判刑]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>近日南昌法院介紹了一起「全省首例破解無人機系統禁飛限飛限高程序案」。</p><blockquote><p><img height="1224" src="https://oscimg.oschina.net/oscnet/up-4faa1c12e0cd8f028545311b02c55fdda4f.png" width="1472" referrerpolicy="no-referrer"></p></blockquote><p>據介紹，犯罪嫌疑人張某曾花費 40 歐元，在外國一網站購買了飛行解禁證書程序。隨後，他通過二手交易平台，<strong>向國內消費者出售解除「無人機限飛、限高、禁飛」等服務，每台收取 400-1000 元服務費。</strong>在被抓獲前，張某已解禁了 21 台（次）無人機，違法收入 15060 元。</p><p><img src="https://oscimg.oschina.net/oscnet/up-6646f384a74184ff3010579aed13c3c1978.png" referrerpolicy="no-referrer"></p><p>經審理，張某犯「提供侵入、非法控制計算機信息系統程序罪」，<strong>判處有期徒刑六個月，緩刑一年，處罰金人民幣 5000 元，並沒收作案工具及違法所得 15060 元。</strong></p><p>據悉，我國無人機禁飛高度限制制度規定，輕型無人機的飛行高度限制為 120 米，與機場、公共建築的距離為 500 米。針對特定區域，如機場、火車站、政府機關、敏感單位等重點場所，實行更嚴格的禁飛措施。</p><p>此外，新版《無人駕駛航空器飛行管理暫行條例》於 2024 年 1 月 1 日起施行，要求個人非經營性活動，<strong>無人機均需實名登記</strong>。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 10:06:33 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273856</guid>
            <link>https://www.oschina.net/news/273856</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[MegEngine 版本最新發布！新增支持寒武紀思元系列 AI 芯片訓練和推理]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>近日，MegEngine 在 v1.13.3 正式完成了與國內 AI 芯片獨角獸寒武紀旗下雲端人工智能處理器芯片的兼容性適配。MegEngine 與，寒武紀目前完成了常見 cv 模型的算子適配，這也標誌着寒武紀端雲一體的人工智能芯片，與 MegEngine 深度學習框架的成功融合。</p><h2>如何在寒武紀上運行 MegEngine</h2><h3>MegEngine 寒武紀安裝説明</h3><ul><li>安裝的前置條件： 
  <ul><li>安裝寒武紀 MLU 驅動，sdk-1.13.0-driver</li><li>安裝 cntoolkit, cnnl, cnnl_extra, cncl, cnlight</li><li>安裝 MagicMind</li></ul></li><li>安裝方式：通過源碼編譯安裝 
  <ul><li>下載源碼&amp;編譯</li></ul></li></ul><pre><code class="language-Python">git clone https://github.com/MegEngine/MegEngine.git megengine
cd megengine
# 構建用於編譯並打包的 docker 鏡像
./scripts/whl/manylinux2014/build_image.sh
# 下載 mkl 依賴
./third_party/install-mkl.sh
# 編譯並打包
export ALL_PYTHON="39"  # 指定編譯的 python 版本，可選 36m 37m 38 39 310
export NEUWARE_HOME=/usr/local/neuware # 指定寒武紀 sdk 安裝路徑
./scripts/whl/manylinux2014/build_wheel_common.sh -sdk neuware113
</code></pre><ul><li>安裝與驗證生成的 whl 包 
  <ul><li>安裝生成的 whl 包，並進行測試</li></ul></li></ul><pre><code class="language-Python">cd megngine
pip3 install ./scripts/whl/manylinux2014/output/wheelhouse/neuware113/MegEngine-1.9999.0+neuware113-cp39-cp39-manylinux2014_x86_64.whl
# 驗證是否編譯成功
python3 -c "import megengine as mge; print(mge.is_cambricon_available()); print(mge.Tensor([1.]))"
</code></pre><ul><li><ul><li>輸出類似以下內容，表示安裝成功</li></ul></li></ul><pre><code class="language-Python">True
06 14:03:06[mgb] cambricon: card0: name=`MLU370' dyn_mem_reserve=0.00MiB alignment=0x100
Tensor([1.], device=xpux:0)
</code></pre><ul><li>MegEngine 寒武紀訓練示例見 cambircon_train</li></ul><h2>關於寒武紀</h2><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cambricon.com%2Findex.php%3Fm%3Dcontent%26c%3Dindex%26a%3Dlists%26catid%3D7%23nav2" target="_blank">寒武紀</a>成立於 2016 年，專注於人工智能芯片產品的研發與技術創新，致力於打造人工智能領域的核心處理器芯片，讓機器更好地理解和服務人類。寒武紀提供雲邊端一體、軟硬件協同、訓練推理融合、具備統一生態的系列化智能芯片產品和平台化基礎系統軟件。寒武紀產品廣泛應用於服務器廠商和產業公司，面向互聯網、金融、交通、能源、電力和製造等領域的複雜 AI 應用場景提供充裕算力，推動人工智能賦能產業升級。</p><h2>關於 MegEngine</h2><p>開源深度學習框架曠視天元（<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FMegEngine" target="_blank">MegEngine</a>）是曠視自主研發的國產工業級深度學習框架 ，是曠視新一代 AI 生產力平台 Brain++ 的最核心組件，在 2020 年 3 月正式向全球開發者開源 。MegEngine 憑藉其訓練推理一體、超低硬件門檻和全平台高效推理 3 大核心優勢，能夠幫助企業與開發者大幅節省產品從實驗室原型到工業部署的流程，真正實現小時級的轉化能力。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 09:53:33 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5265910/blog/10560224</guid>
            <link>https://my.oschina.net/u/5265910/blog/10560224</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[「北大-智元機器人聯合實驗室」正式成立]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>北京大學計算機學院官網<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcs.pku.edu.cn%2Finfo%2F1263%2F2856.htm" target="_blank">公告稱</a>，「北大-智元機器人聯合實驗室」現已正式成立。</p><p><img alt="" height="334" src="https://oscimg.oschina.net/oscnet/up-e05329fa21e140b58847f470224b04c6f50.jpg" width="500" referrerpolicy="no-referrer"></p><p>智元機器人由「華為天才少年」彭志輝（稚暉君）等來自多家大廠的科技人才聯合創立，於 2023 年 12 月完成新一輪融資。</p><p>公告指出，「北大-智元機器人聯合實驗室」的成立對校企合作與協同創新具有重要意義，並將在着力解決關鍵具身智能技術問題的同時，培養領域內的國際頂尖技術人才。北京大學將與智元機器人協同共進、持續探索，推動前沿技術創新與產業化的鏈接，為國傢俱身智能及通用人形機器人的產業發展貢獻力量。</p><p>稚暉君在聯合實驗室的揭牌儀式上介紹了智元機器人的發展歷程，強調了通用人形機器人、具身智能技術對國家科技創新和經濟發展的重要意義。</p><p>並表示，作為一家 2023 年上半年成立的新興科技企業，智元已經在決策模型、任務規劃、環境感知、通用抓取等環節具備了領先的技術積累。智元非常看重校企合作的發展模式，將與北京大學緊密配合，實現研發成果落地，推動具身智能和通用機器人產業的發展和迭代。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 09:44:33 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273848</guid>
            <link>https://www.oschina.net/news/273848</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[2024 的開源世界：或有更多企業轉向商業許可]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>未來一年，可能會有更多公司將其開源許可證變更為商業許可證、出現新一輪的監管浪潮以及 GenAI 的持續發展。</p></blockquote><p>開源世界在 2023 年伊始就充滿了不確定性，科技界大面積裁員、經濟動盪不安。生成式 AI 在過去的一年裏取得了突飛猛進的發展，而 HashiCorp 許可證的變更則表明，風投公司認為開源模式的前景並不樂觀。</p><p>在此背景下，Rust 基金會執行董事兼 CEO Rebecca Rumbul 在接受 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthenewstack.io%2Fopen-source-in-2024-more-volatility-more-risk-more-ai%2F" target="_blank">The New Stack</a> 的採訪時，就 2024 年的市場發展發表了一些看法。她認為，目前市場上的樂觀情緒已經日漸濃厚。在大幅削減開發人員關係職位之後，出現了一些空缺需要填補；削減職位可能是一種虛假經濟。Rumbul 指出，「與開源社區保持良好的關係可以帶來巨大的商業回報」。</p><p>不過企業還可以通過一些更直接的方式確保商業回報。譬如今年 8 月，HashiCorp 決定將包括 Terraform 在內的整個產品線轉為商業源碼許可，這一決定在業界引起了軒然大波；同時也引出了一個獲得了 Linux 基金會的支持的 OpenTofu 分叉。</p><p>HashiCorp CEO David McJannet 在其客戶會議上曾對整個基金會模式提出質疑，並表示 Linux 基金會對 OpenTofu 的支持是開源創新的悲劇。這最終可能意味着"硅谷將不再有開源公司"。</p><p>Linux 基金會歐洲區總經理 Gabriele Columbro 則評論稱，今後可能會出現更多的許可證轉換--以及隨之而來的分叉：「市場上由風投支持的開源初創公司越多，就越會有一部分公司在某一時刻決定轉換許可證，因為這樣做對公司最有利。」</p><p>他認為，HashiCorp 完全有權利轉換許可。但這一事件可能會鼓勵用戶更多地考慮開源和項目開放治理之間的區別，從而可能會加強基金會的作用。「當你選擇依賴某個開源項目時，你可能會問自己這個問題。它是否只是開源，任何一家專有公司都可以隨時打我個猝不及防？」</p><p>Columbro 指出，使用 Terraform 等產品的大公司可能會面臨數十萬美元的賬單，僅僅是為了弄清許可證變更對公司的影響。"我可以想象，摩根大通或谷歌必須花多少錢才能弄清楚他們在 Terraform 上的立場並進行影響評估"。鑑於大企業（特別是在金融領域）對開源的接受程度越來越高，這些計算也變得越來越重要。</p><p>"我認為，我們正處於金融服務和金融科技完全意識到自己是一個以技術為中心的行業的風口浪尖上，因此也會像大型科技公司那樣擁抱開源，將其作為數字化轉型的核心支柱，同時也是行業結構的核心支柱。"</p><p>Percona 社區負責人 Joe Brockmeier 表示，許多執行團隊已經在考慮，是否要冒着更大的風險和弊端轉而採用閉源模式。</p><p>但 OpenUK CEO Amanda Brock 認為，這些並不意味着行業不應該重新審視許可和相關問題。現在正是在持有不同觀點的不同派別之間進行更開放的對話的時機，讓用戶、貢獻者和社區之間產生更多的瞭解。</p><p><strong>開源和 GenAI</strong></p><p>AI（尤其是生成式 AI）正在給整個科技界和社會帶來巨大沖擊，「統一戰線可以説比以往任何時候都更加重要」。</p><p>DataStax 開發者關係副總裁 Patrick McFadin 認為，大眾對於 GenAI 的隱私問題已經"嚴重恐慌"，這一情緒將導致對 OpenAI 和超級計算機的反抗。「監管開源幾乎是不可能的。一旦事情被公開，你就無法對其進行監管。開源[大語言模型]已經存在，它們正在接受訓練，而且它們開始變得比 GPT-4 更好，這使得監管它們變得更加困難。」</p><p>Brock 沒有 McFadin 這麼末世論，但也同樣嚴肅。「當我們看到人工智能正常化，人們開始更好地理解它是什麼並不再被炒作所影響時，我們將更好地討論開源的含義以及開源如何融入人工智能」。這將導致「與開源社區及其代表的參與，而不僅僅是公司的參與，這是目前全球的一個趨勢。」</p><p>她認為，中國參加了在英國布萊切利公園舉行的人工智能安全會議是一個非常重要的節點，表明監管對話正在從主權轉移到關注跨界合作。這將產生更廣泛的影響，促進國際開源技術行業的發展，其中包括強大的本地生態系統和在全球範圍內開展合作的熟練勞動力。</p><p><strong>開源監管的前景如何？</strong></p><p>目前，美國和歐盟都已經圍繞人工智能制定了立法和監管，但具體的成效還需等到 2024 落地以後才能凸顯。歐盟的《網絡彈性法案》也將於 2024 年生效，其最近宣佈的修訂版貌似降低了對開源的限制，不過最終文本尚未公佈。</p><p>但要加強科技領域的國際合作還存在很多障礙，美國的制裁已經導致了一些對開源項目的貢獻被拒。Rumbul 稱，「如果開源只是以美國為中心，或者與美國的外交政策保持一致，那將是非常糟糕的。這不是開源的精神。」</p><p>針對開源在 2024 年的可持續性問題，Rumbul 也同樣表達了擔憂。「開源社區創造了一些精美的東西，但再精美的東西也會被人從桌子上打下來，摔得粉碎。 」。不過她也認為，雖然"風險"可能比以前更高，但風險並不總是一個壞詞，它總是和機遇並存。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 09:26:19 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273844/open-source-in-2024</guid>
            <link>https://www.oschina.net/news/273844/open-source-in-2024</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[MySQL 5.7、魔趣、李跳跳……盤點 2023「停更」的（開源）項目和網站]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年，許多陪伴我們很久的網站和（開源）項目紛紛揮手道別，或退役、或停更、或 EOL、或倒閉……</p><hr><h4><a href="https://www.oschina.net/news/224302/mokee-eol">開源 ROM 魔趣 (Mokee) 創始人宣佈項目結束</a></h4><p>國內最大的非營利性開源 ROM 項目魔趣 (Mokee) 在 2023 年 1 月 7 日正式宣佈關閉。魔趣下載頁面所有固件已備份到 SourceForge。項目作者馬丁龍豬發文稱，「刷機的時代其實早已落幕，遲遲下不定決心只是希望能讓魔趣多存續一些時間，但該來的終究會來。」</p><p><img src="https://oscimg.oschina.net/oscnet/up-a03702d6043769216aed5f1c60b250af639.png" referrerpolicy="no-referrer"></p><p>魔趣開源項目 20121212 ~ 20230107</p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/225416/afnetworking-officially-deprecated">網絡框架 AFNetworking 停止維護</a></h4><p>在停更近 3 年後，適用於蘋果旗下多個操作系統 (iOS、macOS、watchOS 和 tvOS) 的網絡框架 AFNetworking 在 2023 年 1 月 17 日正式發佈公告宣佈棄用，停止維護。原始倉庫將作為一個歸檔庫永久保留。</p><p>AFNetworking 建議開發者可以遷移到同樣由 Alamofire 軟件基金會所開發的 Alamofire —— 一個 100% 使用 Swift 編寫的網絡框架。</p><p><img src="https://static.oschina.net/uploads/space/2023/0118/153745_fT17_4937141.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/223913/aethersx2-end">開發者遭死亡威脅，項目停止開發</a></h4><p>因遭受過多的騷擾甚至於死亡威脅，AetherSX2 軟件的開發者 Tahlreth 於 2023 年 1 月宣佈無限期停止該項目的開發。</p><p>「AetherSX2 對我來説一直是一個有趣的愛好，而不是為了盈利。繼續開發一個不再有趣的項目是沒有任何意義的。」</p><p>AetherSX2 是 Android 平台上最好用的 PlayStation 2 模擬器（沒有之一）。用戶還可以繼續下載和使用 AetherSX2，但該應用程序已經不再有進一步的開發計劃。</p><p><img src="https://oscimg.oschina.net/oscnet/up-93a2a42d4210b16856fc57cda8138b21c0e.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/232215/peek-discontinued">問題堆積如山，GIF 錄屏工具 Peek 停止開發</a></h4><p>GIF 屏幕錄製工具 Peek 的開發者在 2023 年 1 月正式宣佈項目停止開發，主要原因在於 Wayland 上運行時所面臨的一些技術挑戰。而解決問題的唯一途徑就是以不同的方式、不同的 UI 完全重寫應用程序，但「現在的 Peek 幾乎沒有什麼資源可以重用」。</p><p>開發者表示自己並沒有興趣再開發一個全新的項目，所以做出了放棄該項目的決定。</p><p><img src="https://oscimg.oschina.net/oscnet/up-10c040add5089c3b13095d5f4ee74d1685a.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/230777">aardio 編程語言作者：因妻子患癌，再無精力維護項目</a></h4><p>aardio 編程語言作者發文表示，因妻子患癌，再無精力維護項目。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.aardio.com%2F">aardio</a> 是一門專注於桌面軟件開發的編程語言，特點是小、輕、快，體積僅 6.5MB，學習和使用成本極低。aardio 雖然小，但提供了驚人數量的開源標準庫、擴展庫 —— 這些庫基本都是由純 aardio 代碼實現。</p><p>aardio 的所有庫基本都是由作者一個人編寫，並且 17 年來一直保持非常活躍的更新。</p><p><img src="https://static.oschina.net/uploads/space/2023/0302/174216_nFqa_2720166.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/235303/touca-shutting-down">開源項目 Touca 開發商倒閉</a></h4><p>開源測試工具 Touca 的創始人 Pejman Ghorbanzade 於 2023 年 3 月宣佈其公司正式倒閉，不景氣的市場大環境是 Touca 倒閉的一個主要原因。</p><p>Pejman Ghorbanzade 於 2021 年創立了 Touca，並於 2022 年 5 在 Apache-2.0 許可下開源。Touca 可以幫助工程團隊發現日常代碼修改所導致的意外副作用。它將軟件的行為和性能與之前的可信版本進行比較，並以近乎實時的方式將差異可視化。</p><p>Touca 公司倒閉後，Touca 這個開源項目還將繼續存在，並保持開源，Pejman Ghorbanzade 表示自己會持續維護這個項目，並開始尋找新的機會。</p><p><img src="https://static.oschina.net/uploads/space/2023/0404/083735_MqQM_4937141.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/242988/qt-5-15-lts-support-ends">Qt 5.15 LTS 已結束標準支持</a></h4><p>Qt 5 系列的最後一個次要版本 Qt 5.15 LTS 於 2023 年 5 月 26 日正式結束標準支持。</p><p>Qt 5.15 LTS 是一個長期支持版本，有三年的標準支持期。最後一個補丁版本是 Qt 2023 年 5 月 25 日發佈的 5.15.14，適用於具有舊許可證的商業客戶的標準支持條款。</p><p><img src="https://static.oschina.net/uploads/space/2023/0530/072839_iyUd_2720166.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/243315/rarbg-shut-down">戰爭、疫情、通貨膨脹，資源網站 RARBG 宣佈關閉</a></h4><p>受戰爭、疫情、通貨膨脹等因素影響，資源網站 RARBG 於 2023 年年中宣佈關站。</p><p>RARBG 是一個著名的 BitTorrent 網站，提供了許多高質量的電影、電視劇、音樂、遊戲和軟件等種子資源。它成立於 2008 年，總部位於保加利亞，已經成為了 BitTorrent 社區中備受喜愛的網站之一。</p><p><img src="https://static.oschina.net/uploads/space/2023/0601/090415_Crb3_4937141.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/247891/libjpeg-turbo-fund">資金嚴重短缺，又一流行開源項目宣佈停止功能開發</a></h4><p>libjpeg-turbo 的首席開發人員 DRC 在完成該項目的 3.0.0 版本發佈後表示，由於資金短缺，其未來的功能開發或將受到限制，可能永遠不會有 libjpeg-turbo 3.1 版本。</p><p>他將繼續修復 libjpeg-turbo 中的錯誤，並在 3.0.x 發行版系列中發佈錯誤修復版本；但不會再有 libjpeg-turbo 3.1 發行版系列，除非該項目可以獲得更多的通用資金。</p><p>libjpeg-turbo 是一個 JPEG 圖像編解碼器，它使用 SIMD 指令（MMX、SSE2、AVX2、Neon、AltiVec）來加速 x86、x86-64、Arm 和 PowerPC 系統上的基線 JPEG 壓縮和解壓縮，以及 x86、x86-64 和 Arm 系統的漸進式 JPEG 壓縮。</p><p><img src="https://oscimg.oschina.net/oscnet/up-5009145e786948703fca4d615949b2aa180.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/255159">自動跳過開屏廣告應用「李跳跳」無限期停止更新</a></h4><p>「李跳跳」 作者於 2023 年 8 月在公眾號宣佈無限期停止更新，原因是收到了某集團律師函，對方稱 「李跳跳」 APP 涉嫌不正當競爭，對旗下的瀏覽器產生影響，並要求四十八小時內全網下架 「李跳跳」。</p><p>「李跳跳」 是一款利用無障礙權限進行跳過 APP 開屏廣告的 Android 輔助應用，無需聯網，免費使用。除了 「李跳跳」，其他同類開屏廣告應用也都在同一時期收到了律師函，比如 「大聖淨化」、「一指禪」 和 「叮小跳」。</p><p><img src="https://oscimg.oschina.net/oscnet/up-f76f9db79d31ec9572ff7a63c83b254b314.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/256175/visual-studio-for-mac-retirement">微軟官宣：Visual Studio for Mac 退役</a></h4><p>微軟於 2023 年 8 月發佈了 Visual Studio for Mac 的退役公告。未來，開發團隊將專注於增強 Visual Studio 和 VS Code，優化它們以進行跨平台開發。</p><p>自 2024 年 8 月 31 日起，Visual Studio for Mac 將不會再獲得任何支持。屆時，Visual Studio for Mac 將只能通過 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmy.visualstudio.com" target="_blank">my.visualstudio.com</a>，為已訂閲 Visual Studio 的用戶提供舊版安裝，但不再提供服務或維護。</p><p>Visual Studio for Mac 退役後，微軟方面仍會為 Mac 開發者提供替代方案，例如 C# Dev Kit for VS Code 和其他擴展。</p><p><img src="https://static.oschina.net/uploads/space/2023/0831/111644_7KuF_2720166.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/257320/wangeditor-suspend-maintained">開源富文本編輯器 wangEditor 暫停維護</a></h4><p>開源 Web 富文本編輯器 wangEditor 作者王福朋於 2023 年 8 月發佈宣佈暫停項目維護。主要原因在於作者暫無精力維護 wangEditor ，且 「最近行業形勢也不太好，先努力搞錢吧」。</p><p>他也歡迎有人接手 wangEditor 的維護，不過需要通過初步考覈：在 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwangeditor-team%2FwangEditor%2Fissues">issues</a> 列表中，回答 10 個 issue。</p><p><img src="https://static.oschina.net/uploads/space/2023/0908/105123_MDIq_2720166.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/256530/microsoft-deprecated-wordpad-in-windows">時隔 28 年，微軟計劃在 Windows 中淘汰寫字板</a></h4><p>微軟在 2023 年 9 月宣佈計劃在未來的 Windows 更新中棄用寫字板。對於 .doc 和 .rtf 等富文本文檔，該公司建議使用 Microsoft Word 作為替代品；對於 .txt 等純文本文檔，則建議使用 Windows 記事本。</p><p>寫字板是一種基本的文本編輯應用程序，允許用戶創建和編輯帶有格式化文本的文檔，幷包含圖像和其他文件的鏈接。自 1995 年 Windows 95 發佈以來就附帶在 Windows 系統上，為用戶提供集成到操作系統中的基本文字處理器和文檔編輯器。</p><p><img src="https://oscimg.oschina.net/oscnet/up-9eb98bd9630dd96807298f16da6fd2ec37f.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/224251/linux-4-9-eol">Linux 4.9 正式 EOL ，結束持續 6 年的 LTS 週期</a></h4><p>在長達 6 年多的長期支持後，Linux 4.9 內核系列在 Linux 4.9.337 更新中，結束了生命週期。</p><p>Linux 內核 4.9 於 2016 年 12 月 11 日發佈，它帶來了對 XFS 文件系統的共，享範圍和寫時複製支持、用於檢測固件引起的延遲的硬件延遲跟蹤器、對，來自 Project Ara 的 Greybus 總線的支持、更高效的 BPF 分析器、新的可選 BBR TCP 擁塞控制算法、虛擬映射內核堆棧等特性。</p><p>由於是 LTS 版本，Linux 4.被廣泛用於生產環境，比如基於 Linux 4.9 操作，系統驅動的大規模生產設備/硬件。</p><p><img alt="082401_IvCl_5430600.png" src="https://static.oschina.net/uploads/space/2023/0109/082401_IvCl_5430600.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://my.oschina.net/GreatSQL/blog/10117424">MySQL 5.7 於 2023.10.21 正式 EOL</a></h4><p>MySQL 目前已經成為中國用戶使用最廣泛的開源數據庫，其中 5.7 版本用戶的比重又是最高的。根據報告中的統計數字，MySQL 5.7 用戶佔比在國內高達 47%。屆時這些用戶將會面臨選擇，如何應對 EOL 事件。</p><p>實際上 2020 年的時候就有一些機構提醒用戶，MySQL 5.7 按照生命週期將於 2023 年到達服務期限，當時這件事還在 MySQL 社區和 DBA 圈子裏引發過一些關於開源項目安全性的討論。3 年後，這個狼來了的問題，終於正式要面對我們了。</p><p><img src="https://oscimg.oschina.net/oscnet/up-38ac7bf161ea28943b1db6cc2ac7b40b41d.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/258425">JS 工具庫 lodash 關閉所有 issue 和公開 PR</a></h4><p>老牌 JS 工具庫 lodash 關閉了所有 issue 並統一打上 "issue bankruptcy" 的 tag，此外還關閉了所有公開 PR，表示無力處理，一關了之。</p><p><img src="https://static.oschina.net/uploads/space/2023/0917/112931_OgKg_2720166.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4><a href="https://www.oschina.net/news/265128">承載微軟跨平台生態之夢的 UWP，正在消亡</a></h4><p>開發者發現，微軟最新的 Windows 11 Canary Build 25987 預覽版已經開始提供兩個版本的 XAML Shell 服務，新的版本直接基於 Win32 + XAML，曾經被寄予厚望的 UWP 在新版本里已經不見蹤影。</p><p><img src="https://static.oschina.net/uploads/space/2023/1106/113836_8gF1_2720166.png" referrerpolicy="no-referrer"></p><hr><p>更多年度重磅事件回顧，<strong>查看<em><u><a href="https://talk.gitee.com/report/china-open-source-2023-annual-report.pdf?fr=shida_news1231">《2023 中國開源開發者報告》</a></u></em></strong>。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 09:25:19 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273843</guid>
            <link>https://www.oschina.net/news/273843</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[守正出奇，穿越週期 - Bytebase 的 2023]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>前情提要：<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI2MDY5OQ%3D%3D%26mid%3D2247501714%26idx%3D1%26sn%3De042aa907bc5eb45bdcad8d4cd56cfd3%26chksm%3Dc25cf9a6f52b70b0ef011150790edb7f6864cc9dbfc94959d358b12506119eefb248d44faa36%26scene%3D21%23wechat_redirect" target="_blank">Bytebase 的 2022｜埋頭苦幹，孕育希望</a></p></blockquote><h2>產品迭代</h2><ul><li><p>2023 年共發佈了 25 個版本。這個數字和 2022 年一樣，除開春節和一次全員疫情，做到了兩週一次的更新。</p></li><li><p>版本號從 1.11.0 升級到了 2.13.0。其中在 5 月份，我們發佈了 Bytebase 2.0 版，明確了做 Database DevOps 的產品主張。 <img src="https://oscimg.oschina.net/oscnet/up-68868615564cc83e1c5c26bc6160165fd16.png" alt="file" referrerpolicy="no-referrer"></p></li><li><p>PR 數超過 10000，成為了 GitHub 上最繁忙的開源項目之一。 <img src="https://oscimg.oschina.net/oscnet/up-f94e6c186bd68ccd2a105ae853db7e9f04e.png" alt="file" referrerpolicy="no-referrer"></p></li><li><p>GitHub Star 數也從 4.7 k 增加到 8.7 k，不僅繼續保持同領域內最快的增速，而且還先後超越了國外的 Flyway 和國內的 Yearning，成為了同領域內，全球 Star 最多的開源項目。 <img src="https://oscimg.oschina.net/oscnet/up-2622bb405457359ff36b66daad3d244cc6d.png" alt="file" referrerpolicy="no-referrer"></p></li></ul><h2>企業級，可依賴</h2><p><img src="https://oscimg.oschina.net/oscnet/up-3c1a784de5a150efbfc8e71fe8cd4d2d3da.png" alt="file" referrerpolicy="no-referrer"></p><p>今年 Bytebase 成為了唯一被 CNCF Landscape 和 Platform Engineering (平台工程組織) 同時收錄的數據庫管理工具。</p><p><img src="https://oscimg.oschina.net/oscnet/up-72f780b2eedaf1328244e667365722b33e3.png" alt="file" referrerpolicy="no-referrer"></p><p>目前 Bytebase 已經支持市面上 17 種主流數據庫系統。提供了一套覆蓋變更，查詢，安全，治理的數據庫開發全生命週期的解決方案。</p><p><img src="https://oscimg.oschina.net/oscnet/up-9ebeef3b72d5ba1d510aea61c971e5be01d.png" alt="file" referrerpolicy="no-referrer"></p><p>今年 Bytebase 全面增強了企業級功能，SSO，多因素認證，動態脫敏，批量變更，自定義審批流，審計日誌等。並且還通過開放 API 的方式讓 Bytebase 能被集成到了企業已有的研發平台中。</p><h2>舊雨新知</h2><p>Bytebase 在 2022 年年中開始商業化，今年則是全面商業化的第一年。我們完成了所有老客戶的續約，並且在國內又收穫了電信，製造業，造車新勢力等行業的標杆。同時我們還把產品賣到了全球，北美，歐洲，東南亞，中東，非洲也都有了我們的客戶。</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI2MDY5OQ%3D%3D%26mid%3D2247502348%26idx%3D1%26sn%3D6d1056e2dcc09a35b327ab981a4b4d49%26chksm%3Dc25cf438f52b7d2ee6fb3e56dfa9917abaf470e014d2d04148bb726fcbe0b59295a3bef452cc%26token%3D1617600613%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank">1:1000，新能源車企如何將數據庫管理效能發揮到極致</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI2MDY5OQ%3D%3D%26mid%3D2247506285%26idx%3D1%26sn%3D37498d417a3c4b024504e590f89f39a4%26chksm%3Dc25ce759f52b6e4f8d884466b7d155635c031a864df18d3cd6b2d50cfacf2d3670da8a6fae37%26token%3D2062945217%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank">來自電子製造行業視源科技 (CVTE) 的數據庫變更管理實踐</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkzMjI2MDY5OQ%3D%3D%26mid%3D2247505728%26idx%3D1%26sn%3D6fa17fe88d8ba6d8f2635ab05ac3639f%26chksm%3Dc25ce974f52b6062a0d8a03d9669b4b5da3dba081e3f838a9a69b094bee5da0e5b873e40b535%26token%3D1617600613%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect" target="_blank">中東 Shopify 如何使用 Bytebase 構建一站式數據庫開發工作流</a></li></ul><h2>良師益友</h2><p>作為一款面向開發者和 DBA 的數據庫工具，Bytebase 今年也積極和上下游數據庫和開發者工具建立合作關係，先後成為了 PingCAP, Snowflake, GitHub, GitLab 的全球技術合作夥伴。</p><p><img src="https://oscimg.oschina.net/oscnet/up-8689af380e45d36553f6e3e3b79cf3a2c26.png" alt="file" referrerpolicy="no-referrer"></p><p>受邀在 OceanBase 的年度開發者大會進行了專題分享，並且基於一同服務的客戶案例，推出了「數據庫變更全生命週期管理」的聯合解決方案。</p><p><img src="https://oscimg.oschina.net/oscnet/up-87dc34a29f68218802d3b0e281a320767ef.png" alt="file" referrerpolicy="no-referrer"></p><p>此外我們還支持了 RisingWave, StarRocks 這些冉冉升起的數據庫新星。</p><h2>守正出奇，穿越週期</h2><p>不可否認，中國的企業服務正在經歷低谷，面向 toB 市場的 Bytebase 自然也是受到了衝擊。2023 以及即將迎來的 2024，我們依舊會開拓並且專注於「數據庫開發」這一個工作流。當年 Bytebase 最早推出的 GitOps 方案現在已經出現在了 Snowflake 的產品中。</p><p><img src="https://oscimg.oschina.net/oscnet/up-4189a487badbc0cf4ea8ebf2dd74463f905.png" alt="file" referrerpolicy="no-referrer"></p><p>今年我們繼續在產品上創新，比如第一次在數據庫工具裏引入了分支工作流 (Branching)。</p><p><img src="https://oscimg.oschina.net/oscnet/up-56b1418f8c2a0f29dbccd0cb17e9358b656.png" alt="file" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-17c7adc49e0b01b7c804bcfbb1f7a204b22.png" alt="file" referrerpolicy="no-referrer"></p><p>總之，Bytebase 既要滿足客戶的需求，又要交付出一個面向未來的方案。</p><p>最後感謝我們所有的企業客戶，社區用戶，感謝你們信任一家起步不到三年的初創公司。大家有時也會操心公司的命運 (代碼是完全開源的，結構清晰，部署簡單，如果公司倒閉了，就可以任意使用/二開)。感謝大家的關心，我們的現金流即將轉正，屆時等我們的好消息吧。</p><p>好啦，明年再見 👋</p><hr><p>💡 更多資訊，請關注 Bytebase 公號：Bytebase</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 09:23:19 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6148470/blog/10560159</guid>
            <link>https://my.oschina.net/u/6148470/blog/10560159</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[米老鼠原始版本進入公有領域 (Public Domain)]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在近一個世紀之後，米老鼠終於擺脫了迪斯尼的版權束縛。</p><p>這個標誌性卡通人物的原始版本最早出現在《威利號汽船》(Steamboat Willie) 和無聲版《瘋狂飛機》(Plane Crazy) 動畫電影，<strong>現在已於&nbsp;2024 年 1 月 1 日進入公有領域</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-034cd0975e2f207388bfd20852a4bd6fcd3.png" referrerpolicy="no-referrer"></p><blockquote><p><strong>公有領域 (Public Domain) </strong>是人類的一部分作品與一部分知識的總彙，可以包括文章、藝術品、音樂、科學、發明等等。對於領域內的知識財產，任何個人或團體都不具所有權益（所有權益通常由版權或專利體現）。</p><p>這些知識發明屬於公有文化遺產，任何人可以不受限制地使用和加工它們（此處不考慮有關安全、出口等的法律）。創立版權制度的初衷是藉由給予創作者一段時期的專有權利作為（經濟）刺激以鼓勵作者從事創作。當專有權利期間屆止，作品便進入公有領域。<strong>公有領域的作品由於沒有專屬權利人，因此公眾有權自由使用它們</strong>。</p><p>許多國家將每年 1 月 1 日定為「<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpublicdomainreview.org%2Fblog%2F2024%2F01%2Fpublic-domain-day-2024%2F" target="_blank"><strong>公有領域日 (Public Domain Day)</strong></a></u>」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-36bc427e8958111f8b21613b93880334f6a.png" referrerpolicy="no-referrer"></p></blockquote><p>進入公有領域的版本是 1928 年上映的動畫片《威利號汽船》中刻畫的米老鼠，米老鼠有多個版本，後續版本仍然受到了版權保護，仍然掌握在迪士尼手中。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-de4c25d0fcf3d14b5ec5b3b34339bb8e27d.png" referrerpolicy="no-referrer"></p><p>由於米老鼠是迪士尼的商標之一，因此即使版權到期，其他人在使用時不能將其作為商標或 logo，否則會構成侵權。</p><p>米老鼠對於版權法的影響力和意義極為深遠。美國將版權保護期限延長到 95 年，一個重要原因是迪士尼等公司的遊説，因此該法律被笑稱為「米老鼠保護法」。如此長的版權保護期限制了進入公有領域的作品，但另一方面迪士尼其實受益於公有領域作品，而且米老鼠本身的形象也是借鑑了卓別林等早期電影明星的風格。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 07:32:30 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273808/mickey-public-domain</guid>
            <link>https://www.oschina.net/news/273808/mickey-public-domain</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[mybatis-mp - 亮點二：支持不同數據庫 ID 自增配置]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>亮點二：支持不同數據庫 ID 自增配置</p><div><pre><span style="color:#9e880d">@Table
</span><span style="color:#0033b3">public class </span><span style="color:#000000">IdTest </span>{

 
    <span style="color:#9e880d">@TableId
</span><span style="color:#9e880d">    @TableId</span>(dbType = <span style="color:#000000">DbType</span>.<em>SQL_SERVER</em>,value = <span style="color:#000000">IdAutoType</span>.<em>AUTO</em>)
    <span style="color:#9e880d">@TableId</span>(dbType = <span style="color:#000000">DbType</span>.<em>PGSQL</em>,value = <span style="color:#000000">IdAutoType</span>.<em>SQL</em>, sql = <span style="color:#067d17">"select nextval('seq1')"</span>)
    <span style="color:#0033b3">private </span><span style="color:#000000">Long </span><span style="color:#871094">id</span>;

    <span style="color:#0033b3">private </span><span style="color:#000000">LocalDateTime </span><span style="color:#871094">createTime</span>;

}</pre></div><p><span style="color:#9e880d">@TableId 是默認配置（默認數據庫自增）</span></p><p><span style="color:#9e880d">@TableId</span>(dbType = <span style="color:#000000">DbType</span>.<em>SQL_SERVER</em>,value = <span style="color:#000000">IdAutoType</span>.<em>AUTO</em>) 則是在<em>SQL_SERVER 下</em>生效，方式，數據庫自增</p><p><span style="color:#9e880d">@TableId</span>(dbType = <span style="color:#000000">DbType</span>.<em>PGSQL</em>,value = <span style="color:#000000">IdAutoType</span>.<em>SQL</em>, sql = <span style="color:#067d17">"select nextval('seq1')"</span>)&nbsp;則是在<em>PGSQL</em><em>數據庫下</em>生效，方式，為 sql，使用序列！</p><p>非常適合需要支持不同數據庫場景下的開發</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 07:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273800</guid>
            <link>https://www.oschina.net/news/273800</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[@所有人 2023 IT 行業項目管理調查問卷，邀您參與！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span>2023 年，行業飛速發展，在這一年裏，新技術、新趨勢帶來了一波又一波創新浪潮，人工智能、物聯網、雲計算等技術正也在重塑我們的生活、工作方式。</span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span>作為項目管理工具廠商，禪道深知項目管理過程的困難與不易，也緊跟管理方式的迭代與更新。為共同探索行業趨勢，推動項目管理的進步與創新，我們聯合多方合作伙伴，發起了 2023 年 IT 行業項目管理調查問卷，現誠摯地邀請您參與填寫本問卷。</span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span>我們希望通過這次調查，瞭解不同公司和個人在項目管理中面臨的現狀與挑戰，為行業提供寶貴的數據、經驗，推動行業發展。</span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span>您的參與、轉發就是對行業的支持~問卷所填內容僅用於報告分析及禮品發放，不會對外披露或對第三方提供。問卷將於 2024 年 2 月 20 日截止，屆時我們將基於問卷數據生成調查報告，與您共享。</span></span></span></span>、</p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><span><span>認真完成問卷填寫，即可參與中獎率百分百的抽獎，超多驚喜好禮在等您！</span></span></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><span><span><strong><span><span><strong>點擊填寫問卷：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zentao.net%2Fredirect-index-23598.html" target="_blank">https://www.zentao.net/redirect-index-23598.html</a></strong></span></span></strong></span></span></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><img alt="" height="533" src="https://static.oschina.net/uploads/space/2024/0102/141727_mORd_4252687.png" width="300" referrerpolicy="no-referrer"></p><p style="margin-left:.0001pt; margin-right:0; text-align:justify"><img alt="" height="147" src="https://static.oschina.net/uploads/space/2024/0102/141752_M92b_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 06:18:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273789</guid>
            <link>https://www.oschina.net/news/273789</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Hugging Face 年度回顧：2023，開源大模型之年]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section data-tool="mdnice 編輯器" data-website="https://www.mdnice.com" style="font-size: 16px;color: black;padding-right: 10px;padding-left: 10px;line-height: 1.6;letter-spacing: 0px;word-break: break-word;text-align: left;font-family: Roboto, Oxygen, Ubuntu, Cantarell, PingFangSC-regular, PingFangTC-regular, &quot;Open Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif;"><blockquote data-tool="mdnice 編輯器" style="border-top: none;border-right: none;border-bottom: none;font-size: 0.9em;overflow: auto;color: rgb(106, 115, 125);padding: 10px 10px 10px 20px;margin-bottom: 20px;margin-top: 20px;border-left-color: rgb(255, 177, 27);background: rgb(255, 245, 227);"><p style="font-size: 16px;line-height: 26px;color: rgb(89, 89, 89);">查看本文完整鏈接，請點擊文末閲讀原文</p></blockquote><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在 2023 年，大型語言模型（Large Language Models，簡稱 LLMs）受到了公眾的廣泛關注，許多人對這些模型的本質及其功能有了基本的瞭解。是否開源的議題同樣引起了廣泛的討論。在 Hugging Face，我們對開源模型抱有極大熱情。開源模型的優勢在於，它們不僅促進了研究的可複製性，還鼓勵社區參與到人工智能模型的開發中來，這樣做有助於我們更容易地審視模型中可能存在的偏差和侷限性。此外，通過重複利用已有的檢查點，我們還能夠減少整個領域的碳足跡（這只是，眾多優點，中的一部分）。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">讓我們一起回顧開源 LLMs 在過去一年的發展歷程吧！</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><span style="color: rgb(136, 136, 136);">為了確保本文篇幅適中，我們將不涉及代碼模型的相關內容。</span></p><span id="OSC_h2_1"></span><h2 data-tool="mdnice 編輯器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">🍜 預訓練大型語言模型的配方</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">首先，如何獲得一個大型語言模型呢？（如果你對此已有所瞭解，可以跳過這部分內容。）</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">模型的 <strong style="color: black;">架構</strong>（即其代碼表示）定義了它的具體實現和數學結構：這包括所有的相關參數，以及這些參數如何與輸入數據進行交互。目前，大多數高性能的大型語言模型（LLMs）都是基於 「僅解碼器」（decoder-only）的 Transformer 架構的衍生版本，有關原始 Transformer 的詳細信息可以參考其，發表的論文。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">訓練數據集</strong> 是模型訓練過程中（即參數被學習時）所依賴的全部樣本和信息的集合，它使模型能夠學習到特定的數據模式。這些數據通常包括多樣的文本材料，既可以是各種自然語言文本，如法語、英語、漢語等，也可以是各類編程語言代碼，比如 Python、C 語言等，或者是任何能夠以文本形式表現的結構化信息，例如 Markdown 或 LaTeX 中的表格、公式等。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">分詞器</strong> 是定義如何將訓練數據集中的文本轉化為數字的工具（因為模型是一個數學函數，因此需要數字作為輸入）。分詞是通過將文本轉換為稱為 「詞元」 的子單元（可以是單詞、子詞或字符，具體取決於分詞方法）來完成的。分詞器的詞彙量大小決定了其能夠將文本分割成的不同詞元的種類數目，這個數字通常介於 32,000 到 200,000 之間。數據集的規模常常用它包含的 <strong style="color: black;">詞元數量</strong> 來衡量。經過分詞後，如今的數據集範圍從幾千億詞元到幾萬億詞元不等，這些詞元是構成數據集的基本單元。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">訓練超參數</strong> 定義了模型訓練的方法。這些參數決定了模型應如何調整自身以適應新的數據樣本，以及模型參數更新的速度應該是多快。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">一旦確定了這些超參數，接下來需要的就是 1）充足的計算資源來進行模型訓練；2）具備專業技能的人員來執行和監督訓練過程。訓練過程本身包括在訓練所用的硬件上初始化模型架構，以及依據前述超參數在訓練數據集上應用訓練算法。訓練的成果是一系列模型權重 —— 這些就是經過學習的 <strong style="color: black;">模型參數</strong>，也正是人們通常所説的開放獲取的預訓練模型。這些權重可以用於後續的 <strong style="color: black;">推理過程</strong>，即對新的輸入數據進行預測，例如生成文本。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">預訓練的大型語言模型（LLM）在完成初始訓練後，還可以根據具體任務進行定製化或進一步調整。特別是當這些模型的參數被開放共享時，它們可以作為不同用例和應用的基礎，經過一種稱為 「微調」 的過程進行優化。微調包括在與原始預訓練數據集不同的、通常更小且更專業化的數據集上，對模型執行額外的訓練步驟，目的是為了針對特定應用場景優化模型性能。儘管微調步驟在計算資源消耗上有一定成本，但這一成本通常遠低於從零開始訓練一個全新模型所需的財務投入和環境代價。這也是高品質開源預訓練模型極具吸引力的一個原因，它們使得即便是計算預算有限的從業者也能夠自由地使用和改進這些模型。</p><span id="OSC_h2_2"></span><h2 data-tool="mdnice 編輯器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">🗝️ 2022 年，從規模競賽轉向數據競賽</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在 2023 年之前，社區有哪些開源模型可用？</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">直至 2022 年初，機器學習界普遍認為，模型的規模越大（即擁有的參數越多），其性能也越出色。特別是，模型一旦超過某個特定的規模閾值，其能力似乎會實現質的飛躍，這兩種現象分別被稱為 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">突現能力</code> 和 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">規模定律</code>。2022 年推出的多個預訓練開源模型家族大多遵循這種範例。</p><ol data-tool="mdnice 編輯器" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;" class="list-paddingleft-1"><li><p style="margin-top: 5px;line-height: 26px;color: rgb(58, 58, 58);margin-bottom: 16px;"><strong>BLOOM (BigScience Large Open-science Open-access Multilingual Language Model)<br></strong>BLOOM 是由 BigScience 研究團隊推出的，一系列模型。BigScience 是一個由 Hugging Face 協調，聯合法國的 GENCI 和 IDRIS 組織共同參與的國際合作項目，涵蓋了來自 60 個國家、250 個研究機構的 1000 名科研人員。這些模型採用了僅包含解碼器的 transformer 架構，並進行了細微調整，比如引入了嵌入後歸一化和 ALiBi 位置嵌入技術。在這一系列模型中，最大的一個擁有 1760 億個參數，它接受了 46 種人類語言和 13 種編程語言的 3500 億個多語言數據詞元的訓練。大量的訓練數據已經向公眾開放，包括數據的來源、策劃和處理過程的詳細信息。它是目前為止發佈的最大的開源多語言模型。</p></li><li><p style="margin-top: 5px;line-height: 26px;color: rgb(58, 58, 58);margin-bottom: 16px;"><strong>OPT (Open Pre-trained Transformer)<br></strong>Meta 發佈的 OPT 模型，系列採用了僅包含解碼器的 Transformer 架構。這些模型借鑑了 GPT-3 論文中的技術，如特定的權重初始化和預歸一化策略，並對注意力機制進行了改進，比如引入了交替的密集型與局部帶狀注意力層。系列中最大的模型擁有 1750 億個參數，其訓練數據涵蓋了來自公共領域的 1800 億個數據詞元，包括書籍、Reddit 社交平台數據、新聞、維基百科以及其他多種互聯網來源。這一系列模型在性能上與 GPT-3 不相上下，並且通過編碼優化減少了計算資源的消耗。</p></li><li><p style="margin-top: 5px;line-height: 26px;color: rgb(58, 58, 58);margin-bottom: 16px;"><strong>GLM-130B (General Language Model)<br></strong>清華大學聯合智譜 AI 共同發佈了 GLM-130B 模型。該模型基於完整的 Transformer 架構，並引入了一些創新（如採用 DeepNorm 進行層後歸一化、使用旋轉式位置嵌入）。GLM-130B 擁有 1300 億參數，是在包含英文和中文的互聯網數據集上訓練的，這些數據集包括 The Pile、WuDao 語料庫以及其他中文語料庫，共計 4000 億個詞元。在性能上，GLM-130B 與 GPT-3 模型不相上下。</p></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);"><strong>較小或更專業的開源大語言模型<br></strong>近期，一些較小型的開源模型也相繼發佈，這些模型主要服務於科研領域：Meta 推出了 Galactica 系列的大型語言模型（LLM），其中規模最大的模型擁有高達 120B 參數，這些模型是在科學文獻中的 1060 億個詞元基礎上進行預訓練的。EleutherAI 則發佈了 GPT-NeoX-20B 模型，這是一個完全開源的僅解碼器式 Transformer 模型（包括模型架構、權重和數據），在 5000 億詞元上經過訓練，並採用了 RoPE 以及對注意力機制和初始化過程的若干改進，為科學研究提供了一個完整的工具集。 
    </section></li></ol><section style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);margin-top: 16px;">
    這些巨大的模型令人振奮，然而，它們的運行成本也高得驚人！在進行推理計算（即從模型中得出預測結果）時，模型必須被加載到內存中，而一個具有一千億參數的模型往往需要佔用高達 220GB 的內存空間（這個過程我們將在後文中詳細闡述），這樣的內存需求對於大多數機構和專業人士來説都是難以承擔的！ 
  </section><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">然而，2022 年 3 月，DeepMind 發表了一篇，論文，探討了在固定計算預算條件下，模型參數與數據量的最優配比。簡而言之，如果你的模型訓練預算有限，應該如何平衡模型大小和數據規模？研究者們發現，在平均計算預算下，對於大型語言模型（LLMs），更高效的策略是維持一個相對較小的模型，並在更廣泛的數據集上進行訓練。他們開發的模型 Chinchilla（未公開）擁有 700 億個參數，僅為某些大型模型參數總數的三分之一，卻在高達 1.4 萬億個詞元的數據集上進行了訓練，是其他模型所使用數據量的三到四倍。結果顯示，Chinchilla 在性能上不僅媲美甚至超越了其他更大的同類型模型，無論是開源還是非開源的。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">這種範式的變化，儘管可能已在封閉的實驗室環境中為人所知，但它卻讓整個開放的科學界感到措手不及。</p><span id="OSC_h2_3"></span><h2 data-tool="mdnice 編輯器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">🌊 2023, 開放發佈之年</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><span id="OSC_h3_4"></span><h3 data-tool="mdnice 編輯器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);"><em style="color: black;">小型</em> 大語言模型的崛起</span><span style="display: none;"></span></h3><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">2023 年，僅解碼器（decoder-only）式的 Transformer 模型迎來了爆發式增長。幾乎每月都有新的預訓練模型問世，發展速度之快以至於漸漸演變為每週甚至每日都有新模型的推出。Meta 在 2 月推出了 LLaMA 模型；Eleuther AI 在 4 月帶來了 Pythia 模型；MosaicML 在 5 月推出了 MPT 模型；Salesforce 和 TIIUAE 則在 6 月分別發佈了 X-GEN 和 Falcon 模型。Meta 緊隨其後，在 7 月發佈了 LLaMA 的升級版本 LLaMA 2。進入下半年，9 月阿里巴巴發佈了 Qwen 模型；Mistral.AI 推出了同名 Mistral 模型；01-ai 在 11 月發佈了 Yi 模型；Deci 推出了 DeciLM 模型；而 Upstage 則在 12 月帶來了 Phi-2 和 SOLAR 模型。這一系列的模型發佈，不僅展示了人工智能領域的快速進步，也預示着技術的不斷迭代與革新。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">這些發佈包括了：a) 模型權重（在不同程度的開源許可下）；b) 對於較小規模的模型（介於 30 億至 700 億參數之間），它們的性能都相當出色，因此立刻被社區採用。這些模型幾乎都採用僅解碼器的 Transformer 架構，並且進行了各種調整（比如 ALiBi 或 RoPE、RMS 預歸一化、SwiGLU），以及對注意力函數的一些改變（如 Flash-Attention、GQA、滑動窗口注意力），並且在不同的代碼庫實現中進行了優化，以提高訓練或推理速度。這些調整很可能在一定程度上影響模型的性能和訓練速度；然而，由於所有架構都已經連同權重一起公開發布，剩下的核心差異主要在於訓練數據和模型的許可方式。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">Meta AI 發佈的 LLaMA 系列是該系列中的首款模型。研究團隊的目標是在既定的計算預算內訓練不同規模的模型，以求達到最優性能。他們首次明確將訓練預算與推理成本（即在滿足特定性能目標時，模型推理所需的成本）並重考慮。基於這樣的考量，他們選擇在更大量的數據和更多的訓練步驟上，訓練規模較小的模型，以期在較小的模型尺度上獲得更高的性能（這是對訓練計算效率的一種權衡）。在 LLaMA 系列中，最大的模型擁有 650 億參數，經過了 1.4 萬億的詞元訓練，而規模較小的模型 —— 分別具有 60 億和 130 億參數 —— 則在 1 萬億詞元訓練後完成。在大多數基準測試中，130 億參數的 LLaMA 小型模型的表現超過了 GPT-3，而 650 億參數的 LLaMA 大模型在發佈時則代表了最先進的技術水平。然而，這些模型的權重是以非商業許可的形式發佈的，這限制了它們在社區中的應用範圍。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">Eleuther AI 是一個開源的非營利實驗室，它發佈了一系列名為 Pythia 的大型語言模型（LLMs）。這些模型有不同的規模，全部採用公開數據進行訓練，目的是為了幫助研究人員理解大型語言模型訓練的不同階段。有關 Pythia 模型的更多信息，可以通過它們在 Hugging Face 上的，系列合集，查看。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">MosaicML 公司在兩個月後推出了 MPT 模型，該模型的性能優越，並且支持商業用途，同時公司還公開了其訓練的具體細節。MPT 的首個版本是一個 7B 的模型，緊接着在 6 月份，公司發佈了一個更大的 30B 版本。這兩個模型都是基於 1 萬億個英語和編程語言的詞元訓練而成，訓練數據包括了 C4、CommonCrawl、The Stack、S2ORC 等數據集。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">MPT 模型推出後不久，TIIUAE 團隊便發佈了 Falcon 系列模型，中的 7B 和 30B 版本。這些模型在 1 至 1.5 萬億個英文和代碼詞元上進行了訓練，訓練數據包括來自 RefinedWeb、Project Gutenberg、Reddit、StackOverflow、GitHub、arXiv、Wikipedia 等多個來源。同年晚些時候，TIIUAE 還發布了一款更為龐大的 180B 模型。Falcon 模型的細節、所用數據以及訓練過程均在一份技術報告及隨後發表的，研究論文，中有詳盡的描述。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">先前的模型在公開時通常會公開其數據集，但隨後推出的模型很少公佈其訓練過程中使用的具體信息，這使得重現它們的成果變得困難。儘管如此，這些模型通過發佈它們的權重參數，為研究社區提供了一個研究和進一步開發的起點。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">Salesforce 在夏初推出了 X-Gen 模型，這是一款擁有 70 億參數的模型，訓練數據包括了 15 萬億個 「自然語言和代碼」 詞元，訓練過程分為多個步驟，並採用了數據調度系統（並非所有數據同時輸入模型）。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">X-Gen 在 Meta 推出的更為引人注目的新的 LLaMA-2 家族的陰影下顯得有些黯然失色。LLaMA-2 是 Meta 推出的一個新的模型系列，規模從 7B 到 70B 不等，這些模型是在 2 萬億個 「來自公開來源的詞元」 上訓練而成的，採用了寬鬆的社區許可證，並經過了人類偏好的精細調整（RLHF），即所謂的對齊過程。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">隨後，新興初創企業 Mistral 推出了其首款模型 ——Mistral-7B，該模型，是基於互聯網公開數據集的大量數據訓練而成，具體數據量尚未公佈。隨着 2023 年末的臨近，模型發佈活動日益頻繁。Mistral 緊接着發佈了更為龐大的第二款模型 Mixtral 8x7B。與此同時，Deci.AI 公司也帶來了其令人矚目的首款模型 DeciLM，upstage 公司也不甘落後，推出了規模更大的 SOLAR 模型。這些模型均採用了來源和數量未公開的數據進行訓練。在各大排行榜和公開基準測試中，這些模型均展現出穩步的進步。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在 2023 年年底，值得關注的一大事件是中國訓練並公開發布了多個性能顯著提升的模型。其中，阿里巴巴推出了其雙語（英漢）模型 Qwen 系列，其參數規模從 70 億，至 700 億不等，經過了 240 億詞元數據的訓練。與此同時，01-AI 公司也發佈了 Yi 系列模型，其參數規模介於 60 億至 340 億之間，訓練數據量達到了 300 億詞元。這些模型在公開排行榜（如 Open LLM leaderboard）以及一些極具挑戰性的基準測試（例如 Skill-Mix）中的表現，均超過了之前的模型。2023 年底的另一強有力的新競爭者是 DeepSeek AI，他們推出了 「DeepSeek-Coder」，該模型從零開始訓練了 200 億詞元數據，其中包含 87% 的代碼和 13% 的英漢混合自然語言。</p><span id="OSC_h3_5"></span><h3 data-tool="mdnice 編輯器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">隨處可見的對話模型</span><span style="display: none;"></span></h3><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">2023 年，與前一年相比，幾乎所有新發布的預訓練模型都配備了預訓練版本和對話微調版本，這些版本採納了多種現有的調整方法。儘管適用於聊天環境的模型調整技術在 2022 年及以前已有所開發，但這些技術在 2023 年得到了廣泛應用並迅速興起，這突顯了聊天模型在普羅大眾中使用的快速增長，以及通過與模型的互動對其進行的人工評估（即 「氛圍檢查」 評估）。本文將詳細介紹幾種著名的訓練調整預訓練模型以進行聊天的方法，實際上，相關的變體還有很多！</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">基於對話的微調</strong> 是一種特殊形式的監督式微調。在這種方法中，我們使用的標註數據是對話形式的，類似於社交媒體上的多輪對話記錄。通過這種方式，可以對模型進行特定的微調。在這個過程中，我們可以採用與模型訓練階段相同的技術。例如，在處理僅解碼器 Transformer 模型時，可以訓練模型通過自迴歸方法，即逐一預測接下來的詞元。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">指令微調</strong>（Instruction-based Fine-Tuning，IFT）採用相同的方法，但使用指令數據集，該數據集包含一系列類似查詢的提示以及答案（如果需要，還可以包含可選的附加輸入）。這些數據集教導模型如何遵循指示，並且可以是人類生成的，也可以是大型語言模型生成的。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">利用大規模模型輸出的合成數據集（由模型生成的數據集，例如來自 GPT-4 的生成，可以是來自指示或用戶與模型之間的交互）是實現指導微調和聊天微調的一種方式。這通常被稱為 「蒸餾」，因為它涉及從性能較高的模型中獲取知識，以訓練或微調較小的模型。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">這兩種方法都相對容易執行：你只需找到或創建相應的數據集，然後採用與訓練時相同的技術對模型進行調整即可。去年，發佈了眾多指導性數據集，它們有效提升了模型在對話場景中的表現。想要了解更多關於此主題的信息，可以參閲這篇介紹性博文的，鏈接。然而，儘管模型的性能有了顯著提升，但它們仍未能完全達到人類的預期水平。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">從人類反饋中強化學習</strong>（Reinforcement Learning from Human Feedback，RLHF）是一項旨在使模型輸出與人類偏好（基於特定標準）相一致的特定方法。具體操作流程如下：模型根據給定的提示生成多個潛在答案；人類評估者對這些答案進行排序；然後，這些排序結果用於訓練一個偏好模型（該模型學習如何給出反映人類對答案偏好程度的評分）；最後，利用偏好模型通過強化學習對語言模型進行進一步的微調。更詳細的信息，請參閲這篇，博客文章，原始 RLHF 論文，或者 Anthropic 關於 RLHF 的論文。需要注意的是，這是一種成本較高的方法（註釋 / 排名 + 訓練新模型 + 微調的整個過程成本很高），主要用於確保模型的輸出與安全目標相符。為了降低成本，人們開發了一種低成本的變體方法，即利用高質量的語言模型來對模型輸出進行評分，而不是完全依賴人類評價，這種方法稱為從 <strong style="color: black;">人工智能反饋中學習的強化學習</strong>（Reinforcement Learning from AI Feedback, RLAIF）。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">直接偏好優化</strong>（Direct Preference Optimization, DPO）是 RLHF 的另一種變體，其核心優勢在於無需訓練和運用獨立的偏好模型。這一方法同樣需要人類或人工智能生成的排序數據集，但它通過直接利用這些數據來更新模型，即通過對比模型現有的策略（即預測行為）與理想的策略（即能夠預測出最優排序答案的行為）。換言之，模型本身即扮演了對齊和偏好模型的雙重角色，這不僅簡化了優化流程，而且根據報告，還能夠實現與其他方法相媲美的性能水平。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">回到來自（大多數）私企的小型開放權重模型的浪潮，其中很多模型都發布了經過精細調整的對應版本：MPT-7B 還配備了一個指令微調和一個對話版本，Falcon 和 XGen 模型的指令微調版本在年底發佈，Llama-2、Qwen 和 Yi 發佈了對話版本，DeciLM 則發佈了一個指令微調版本。Llama-2 的發佈尤其引人注目，因為它在預訓練和指令微調模型中都特別注重安全性。</p><span id="OSC_h3_6"></span><h3 data-tool="mdnice 編輯器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">社區的進展如何？</span><span style="display: none;"></span></h3><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">雖然隨着新模型的發佈，聊天模型和指令微調模型通常會立即推出，但社區成員和研究人員並沒有把這看作是理所應當的。在這些基礎模型提供的沃土上，湧現出了一個龐大而活躍的微調愛好者社區。這些微調專家經常會構建新的數據集，並對模型進行細緻的微調，以此來展現新發布模型的出色性能。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在 2023 年伊始，一些專為指令交互和對話微調設計的數據集已經被髮布。例如，代表人類偏好的數據集包括 OpenAI 的 WebGPT 數據集、Anthropic 的 HH-RLHF 數據集以及 OpenAI 的，摘要，數據集，它們在這一領域是開拓者。指令數據集的例子包括 BigScience 的，公共提示池、Google 的 FLAN 1 和 2（FLAN 數據集）、AllenAI 的，自然指令，數據集、由不同機構的研究人員開發的自動生成指令框架，自我指令、由專家創建的指令基準，超自然指令（有時用作微調數據），以及由特拉維夫大學和 Meta 合作生成的自動指令數據集，非自然指令，等。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">❄️ 冬 2022/2023: 一月，來自中國多個研究機構的研究人員共同發佈了，人類 ChatGPT 指令語料庫（HC3），其中包含了人類與模型對各種問題的回答。3 月份，發佈活動接連不斷：斯坦福大學推出了 Alpaca 模型，這是首個遵循指令的 LLaMA 模型（7B），以及相關的數據集，包括用大型語言模型生成的 52K 條指令。非營利開源實驗室 LAION 發佈了，開放指令通用數據集（OIG），包含 4300 萬條指令，這些指令既有通過數據增強創建的，也有編譯自其他現有數據源的。同月，位於加州大學伯克利分校的 LMSYS 組織發佈了 Vicuna，這也是一個基於 ChatGPT 聊天數據的 LLaMA 精調模型（13B），這些聊天數據是用戶與 ChatGPT 之間的對話，由用戶自己公開分享在 ShareGPT 上。還發布了 Guanaco 數據集，它是 Alpaca 數據集的擴展版（增加了 50 萬條多語言條目），以及相關的 LLaMA-7B 精調模型。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">🌱 春：四月，伯克利人工智能研究實驗室（Berkeley AI Research lab，BAIR）發佈了 Koala，這是一個經過聊天調優的 LLaMA 模型，它使用了多個先前的數據集（包括 Alpaca、HH-RLHF、WebGPT、ShareGPT），而 DataBricks 則發佈了 Dolly 數據集，這是一個由 15K 條人工生成的指令組成的數據集，以及相關的 Pythia 微調模型。五月，清華大學發佈了 UltraChat，這是一個包含 1.5M 對話指令的數據集，以及在該數據集上進行微調的 UltraLLaMA 模型。隨後，微軟發佈了 GPT4-LLM 數據集 / 框架，用於生成 GPT4 的指令。六月，微軟研究院分享了一種新方法 Orca，通過使用大型模型的推理軌跡（逐步解釋其推理過程）來構建指令數據集，該方法很快被社區（尤其是 Alignementlab.ai）復現，他們創建了 Open Orca 數據集，包含數百萬條條目，隨後用於微調多個模型（如 Llama、Mistral 等）。五月和六月期間，Camel-AI 發佈了多個關於不同話題（物理、生物、化學等）的指令或聊天數據集，每個領域都有超過 20K 的示例。同樣在六月，發佈了 Airoboros 框架，用於使用模型生成的數據微調模型（遵循自我指導方法），以及一系列的，指令數據集。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">🌻 夏：八月，由中國的非營利組織 OpenBMB 發佈了 UltraLM（一種基於 LLaMA 的高性能聊天模型微調版本），隨後在九月，他們又發佈了相關的偏好數據集 UltraFeedback，這是一個包含與 GPT4 對比的輸入反饋數據集，並附有註釋。在整個夏天，一個名為 NousResearch 的集體發佈了多個基於私有和公開指導數據集的微調版本（特別是 Hermes 和 Capybara 系列）。九月，清華大學的一個學生團隊發佈了 OpenChat，這是一個應用了新的強化學習微調策略的 LLaMA 微調版本。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">🍂 秋：十月，Hugging Face 發佈了 Zephyr 模型，這是一個在 UltraChat 和 UltraFeedback 上使用 DPO 和 AIF 技術對 Mistral 模型進行微調的產物。同時，社區成員發佈了 OpenHermes 2，這是一個在來自網絡或使用 Axolotl 生成的 900K 條目上對 Mistral-7B 模型進行微調的版本。Lmsys 發佈了 LMSYS-Chat-1M，包含了與 25 個大型語言模型（LLMs）的真實用戶對話。十一月，OpenBuddy 發佈了 OpenBuddy-Zephyr，這是一個對 Zephyr 模型進行微調的多輪對話模型。同月，NVIDIA 發佈了 HelpSteer 數據集，這是一個對齊微調數據集，提供了提示、相關模型迴應以及基於幾個標準對這些回答的評分，而微軟研究院則發佈了 Orca-2 模型，這是一個在新的合成推理數據集上對 Llama 2 模型進行微調的版本。十二月，伯克利大學發佈了 Starling 模型，這是一個對 Open-Chat 模型進行 RLAIF 微調的版本，以及相關的數據集 Nectar，包含了 20 萬條比較數據。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">正如我們看到的，今年整個領域的發展既依賴於通過使用高質量的預訓練大型語言模型（LLMs）創建新數據集，也依賴於社區發佈的各種開源模型，這使得該領域進步飛速！如果你現在在模型名稱中看到這些名字中的任何一個，你就能夠大概瞭解它的來源了🤗。</p><ul data-tool="mdnice 編輯器" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      還有一些更專業的數據集，例如用於數學問題微調的 MetaMath 和 MathInstruct，以及涉及數學和代碼指令的 Evol-Instruct，還有 CodeAlpaca 與 CodeCapybara 等代碼指令相關的數據集也已發佈。雖然這些數據集同樣被用於提升模型在特定任務上的表現，但我們在此不會詳細介紹它們。你還可以訪問，令人心動的指令數據集，來查看其他相關數據集的集合。 
    </section></li></ul><span id="OSC_h2_7"></span><h2 data-tool="mdnice 編輯器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">開啓定製模型的大門</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><span id="OSC_h3_8"></span><h3 data-tool="mdnice 編輯器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">模型融合：極致的定製化</span><span style="display: none;"></span></h3><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在開源社區的典範實踐中，一個重要的里程碑是模型與數據的融合。隨着每一次代碼合併或提交，追溯所使用數據的來源變得愈發複雜 —— 許多公開的數據集本身就是其他數據集的彙編。同樣，由於卓越性能的模型往往是在相似模型的基礎上經過層層微調得來的（可參考 Mistral 的，衍生模型樹），模型的發展歷史也變得難以梳理。在這篇摘要中，我們尚未有足夠的篇幅深入探討這一引人入勝的技術領域，但在最後，我們將簡要介紹一下它的概念。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">然而，「模型融合」 究竟是什麼意思呢？</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);"><strong style="color: black;">模型融合</strong> 是一種將不同模型的權重融合到一個單一模型中的方法，其理想目標是將每個模型的各自優勢結合在一個統一的模型中。目前已有一些技術實現了這一目標，這些技術大多在社區論壇中得到擴展和發佈，這是一個全球範圍內的去中心化研究的典型案例，涵蓋了從業者、研究人員到業餘愛好者的廣泛社區。其中一種最簡單的公開方法是平均一組具有共同架構的模型的參數（示例 1，示例 2），但還存在更復雜的參數組合方法，例如確定每個模型中對特定任務最有影響力的參數（加權平均），或者在合併前考慮模型間參數的相互幹擾，從而選擇保留哪些參數（關聯融合）。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">這些技術使任何人都能輕鬆地生成模型的組合，而且由於大多數現代模型都是基於同一架構的變體，這一過程變得尤為簡便。這也是 Open LLM leaderboard 上一些模型名稱如 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">llama2-zephyr-orca-ultra</code> 的原因。這個特定的例子很可能是將 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">llama2</code> 和 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">zephyr</code> 模型合併後，再在 orca 和 ultra 數據集上進行微調的結果。通常，更多的細節可以在 Hugging Face 中心的相應模型卡片上找到。</p><span id="OSC_h3_9"></span><h3 data-tool="mdnice 編輯器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">參數高效微調：觸手可及的個性化體驗</span><span style="display: none;"></span></h3><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">有時候，你可能需要進行更為細緻的個性化調整，但受限於硬件顯存大小，無法加載完整模型進行微調。其實，你知道嗎？微調時並不必須要用到模型的全部。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">你或許想嘗試一種叫做 <strong style="color: black;">參數高效微調</strong>（Parameter-Efficient Fine-Tuning，PEFT）的方法。這項技術首先會凍結你所關注的預訓練模型中的參數，然後在其基礎上附加一些新的參數層，也就是我們所説的 「適配器」。接下來，你只需對這些專為你的任務設計的輕量級適配器權重進行微調，這些權重遠小於原始模型的規模。這樣，你僅需分享你的小型適配器權重（以及底層模型）即可！你可以在，這裏，探索一系列引人入勝的 PEFT 技術。</p><span id="OSC_h3_10"></span><h3 data-tool="mdnice 編輯器" style="font-weight: bold;font-size: 20px;line-height: 1.4;padding-top: 10px;margin-top: 10px;margin-bottom: 5px;"><span style="display: none;"></span><span style="color: rgb(81, 81, 81);font-size: 17px;padding-left: 1em;border-left: 3px solid rgb(249, 191, 69);">量化：模型普及於各處</span><span style="display: none;"></span></h3><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">我們已經看到，性能出色的模型現在形態各異…… 但即便如此，並不意味着它們對所有人都是觸手可及的！一個擁有 300 億參數的模型僅僅加載到內存中（還未開始使用）就可能需要超過 66GB 的 RAM，而並非社區中的每個人都有能力配備這樣的硬件。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">這就是量化技術的用武之地！量化是一種特殊的技術，它通過改變模型參數的精度來減少模型的大小。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">量化是什麼意思呢？</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">在計算機中，數字是以一定的精度存儲的，例如 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">float32</code>、<code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">float16</code>、<code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">int8</code> 等。精度不僅指明瞭數字類型（是浮點數還是整數），同時也指出了數字存儲所佔用的內存大小：例如 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">float32</code> 是在計算機上以 32 位存儲的浮點數。要了解更深入的解釋，請參見這個，鏈接。因此，數據的精度越高，它所佔用的物理內存就越多，這是因為需要更多的位來存儲這些數據。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">因此，如果你降低精度，就會減少模型參數在存儲上佔用的內存，進而減小模型的大小！這也意味着你降低了計算的實際精度，可能會降低模型的性能。然而，我們發現，在較大的模型上，這種性能下降實際上是，非常有限，的。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">回到我們之前的例子中，一個含有 300 億參數的模型，在使用 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">float16</code> 格式時需要不到 66GB 的內存。如果採用 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">8bit</code>，內存需求將減半至 33GB；若使用 <code style="font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);padding: 3px;margin: 3px;">4bit</code> 編碼，則只需大約 16GB，進一步降低了內存的要求，使得模型更易於部署和使用。</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">精度轉換有多種方法，涉及不同的 「轉換」 策略，每種策略都有其獨特的優勢和侷限。目前流行的轉換方法包括 bitsandbytes、GPTQ, 和 AWQ 等。有些開發者，例如 TheBloke，甚至正在將所有流行的模型進行轉換，以便更容易地被社區使用。所有這些方法都是相對較新並且仍在不斷髮展之中，我們期待隨着時間的推移，這些技術能夠取得更多的進步。</p><span id="OSC_h2_11"></span><h2 data-tool="mdnice 編輯器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">接下來呢？</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">年尾尚未到來！在這最後時刻，已經迎來了一些驚喜：新的架構是否終將超越簡單高效的 Transformer 模型呢？</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">最新發布包括：</p><ul data-tool="mdnice 編輯器" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      混合專家模型： 
    </section></li><ul style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;color: black;list-style-type: square;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
       Mixtral，該模型由 8 個子模型（僅解碼器的 Transformer 模型）組成，對於每個輸入，一個路由器會選擇兩個最佳子模型並將它們的輸出求和。 
     </section></li></ul><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      幾種狀態空間模型（通過潛在空間將輸入映射到輸出的模型，可以根據任務需求表達為 RNN 或 CNN）： 
    </section></li><ul style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;color: black;list-style-type: square;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
       Mamba，增加了選擇機制的狀態空間模型 
     </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
       Striped Hyena，具有快速卷積核的狀態空間模型 
     </section></li></ul></ul><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">目前來説，這些新方法是否會取代 Transformer 模型還為時尚早，但狀態空間模型確實非常有前景！</p><span id="OSC_h2_12"></span><h2 data-tool="mdnice 編輯器" style="font-weight: bold;font-size: 22px;line-height: 1.2em;margin-top: 2em;margin-bottom: 35px;color: rgb(255, 157, 0);"><span style="font-size: 18px;color: rgb(255, 157, 11);padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;display: none;"></span><span style="color: rgb(255, 157, 11);visibility: visible;display: inline-block;border-left: 5px solid rgb(255, 157, 0);padding: 2px 13px;margin-right: 3px;height: 50%;font-size: 18px;">要點回顧</span><span style="font-size: 18px;color: rgb(255, 157, 11);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(255, 157, 11);visibility: visible;"></span></h2><ul data-tool="mdnice 編輯器" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;" class="list-paddingleft-1"><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      今年，從大型企業到初創公司，再到研究實驗室，各種主體紛紛開放發佈模型，這極大地賦能了社區，使其以前所未有的速度開始進行實驗和探索。 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      模型公告的開放性呈現出起伏變化，從年初的公開發布（數據集組合、權重、架構）到年末對訓練數據守口如瓶，導致無法復現。 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      開源模型出現在包括中國在內許多新的地方，有幾個新的參與者將自己定位為語言模型競爭中的強勁競爭者。 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      個性化定製的可能性達到了前所未有的高度，新策略的出現（如強化學習優化的微調、適配器、合併技術），雖然這僅僅是個開始。 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      更小的模型尺寸和量化升級使得大型語言模型對更多人來説變得真正唾手可得！ 
    </section></li><li><section style="margin-top: 5px;margin-bottom: 5px;line-height: 26px;color: rgb(58, 58, 58);">
      新的架構也隨之出現 —— 它們是否最終會取代 Transformer 架構，仍是一個值得關注的問題。 
    </section></li></ul><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">各位朋友們，就是這樣了！</p><p data-tool="mdnice 編輯器" style="margin-bottom: 20px;line-height: 1.8em;color: rgb(58, 58, 58);">希望你喜歡我們今年的回顧，從中學到了一些知識，並且和我一樣，對於人工智能進步現在如此依賴開源和社區努力感到無比熱情！🤗</p><blockquote data-tool="mdnice 編輯器" style="border-top: none;border-right: none;border-bottom: none;font-size: 0.9em;overflow: auto;color: rgb(106, 115, 125);padding: 10px 10px 10px 20px;margin-bottom: 20px;margin-top: 20px;border-left-color: rgb(255, 177, 27);background: rgb(255, 245, 227);"><p style="font-size: 16px;line-height: 26px;color: rgb(89, 89, 89);"><span style="font-size: 14px;">英文原文:</span><url style="font-size: 14px;color: rgb(136, 136, 136);visibility: visible;display: block;"><span style="font-size: 14px;">https://huggingface.co/blog/2023-in-llms</span></url><span style="font-size: 14px;">原文作者：Clémentine Fourrier<br>譯者: Xinyu Yang (楊新宇)，字節跳動算法工程師，工作方向為通過 SFT、RL 提升大模型 Math、Reasoning 能力。</span></p></blockquote></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公眾號 - Hugging Face（gh_504339124f0f）。<br>如有侵權，請聯繫 support@oschina.cn 刪除。<br>本文參與「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源創計劃</a>」，歡迎正在閲讀的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 04:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/HuggingFace/blog/10555492</guid>
            <link>https://my.oschina.net/HuggingFace/blog/10555492</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[TinyEngine 服務端正式開源啦]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h1>背景介紹</h1><h2>TinyEngine 低代碼引擎介紹</h2><p>隨着企業對於低代碼開發平台的需求日益增長，急需一個通用的解決方案來滿足各種低代碼平台的開發需求。正是在這種情況下，低代碼引擎應運而生。它是一種通用的開發框架，通過對低代碼平台系統常用的功能進行解構，將其劃分為多個功能模塊，併為每個模塊定義了相應的協議和開發範式，使得開發者可以根據自身的業務需求，輕鬆定製開發出自己的低代碼開發平台。</p><p>TinyEngine 提供了低代碼底層能力，並集成了人工智能，從而使用戶能夠高效開發。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a> 具有強大的拖拽功能，無論是圖元還是複雜組件，都能在畫布上帶來流暢的體驗。它適用於多場景的低代碼平台開發，包括資源編排、流程編排、服務端渲染、模型驅動、移動端、大屏端以及頁面編排等低代碼平台。</p><p>TinyEngine 官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine" target="_blank">https://opentiny.design/tiny-engine</a><br> TinyEngine 源碼：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">https://github.com/opentiny/tiny-engine</a> （歡迎 star）</p><p><img src="https://oscimg.oschina.net/oscnet/up-fa7423149eca45391380663a32b595b208f.png" alt="" referrerpolicy="no-referrer"></p><h2>服務端開源介紹</h2><p>2023 年 9 月 21 日，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a> 在<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7280926568854667299" target="_blank">華為全聯接大會正式宣佈開源</a>，引發了廣泛的關注，3 個月時間收穫了 960 個 Star，組建了 4 個用戶交流社羣，成員數 772 名。</p><p>很多企業和個人開發者嘗試基於 TinyEngine 搭建自己的低代碼平台，為搭建企業 Web 應用提效，在使用過程中，大家也遇到了很多問題，比較常見的包括：如何對接服務端、如何導入第三方組件庫、如何使用插槽、如何生成代碼、如何開發自定義插件等，為此我們在 10 月 27 日策劃了一次<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7298642242116452402" target="_blank">線上直播答疑活動</a>，邀請了團隊技術專家為大家答疑解惑。</p><p>其中如何對接服務端是眾多開發者非常關注的問題，為了幫助開發者打通低代碼平台搭建的前後端整體流程，本次 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a> 低代碼引擎服務端配套代碼的開源，讓開發者能夠深入瞭解 TinyEngine 低代碼引擎的前後端運行機制，更能夠讓更多的小夥伴以更深的層次參與到產品共建，共同探討並改進系統，推動其不斷優化，帶來更高的創新潛力，使得更多的人能夠從中受益。</p><p>同時服務端的開源為自由定製和擴展提供了可能，開發者可以參考 TinyEngine 的代碼，根據自身需求對服務端進行改造創新，從而使得產品更具靈活性，能夠滿足各種複雜的業務需求，構建一個強大而健壯的 TinyEngine 生態系統。</p><h1>核心特性</h1><p>當今互聯網應用的複雜性和用戶需求的多樣性要求我們搭建一套靈活的、便於擴展的系統架構，以滿足不斷變化的業務需求。 因此我們引入了微服務的概念，將系統拆分為小而獨立的服務單元，使得每個服務單元都可以獨立開發、測試和部署。這種架構不僅提高了團隊的協作效率，還使得系統更容易擴展和維護。</p><ul><li>TinyEngine 設計器微服務選擇了<strong>基於 Node.js 的技術棧</strong>，為前端開發者提供了一致的開發體驗，無需學習額外的語言即可全棧開發，降低了開發難度和學習曲線，避免了學習新語言的困擾。更能夠從服務端的角度去理解 TinyEngine 設計器的運行原理與設計思想。</li><li>在我們的架構設計中，我們<strong>採用了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.eggjs.org%2Fzh-CN" target="_blank">Egg.js</a> 作為業務接口微服務的框架</strong>。Egg.js 優秀的設計和豐富的插件生態系統，使得我們能夠迅速構建可維護、可擴展的微服務，從而確保系統的穩定性和可維護性。</li><li>為了降低服務耦合，我們還單獨封裝了<strong>提供數據庫操作接口的數據中心微服務</strong>，在框架選型上我們選擇了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.strapi.io%2F" target="_blank">Strapi</a>，Strapi 是一個開源數據管理框架。不僅提供了強大的數據管理和查詢功能，還支持自定義內容類型和靈活的 API 構建，為我們的微服務提供了豐富的數據支持。Strapi 的易用性和可擴展性使得我們能夠高效地管理和發佈數據，確保前端業務接口始終能夠獲得及時、準確的數據支持。</li></ul><p>綜上所述，我們的技術架構旨在提供高效、可維護、可擴展的系統，充分利用 Node.js 和現代化的開源工具，使我們能夠更好地滿足不斷變化的業務需求。這種架構不僅提高了開發效率，還為未來的擴展和創新提供了堅實的基礎。</p><h1>服務端架構</h1><p>根據上面的介紹，開發者可以根據微服務這一特性，輕鬆擴展並實現自己的 TinyEngine 服務端架構。</p><ul><li>業務接口微服務（webService）：構建業務的引擎， 彙總連接其他微服務為前端提供接口。</li><li>數據中心 (data-center)： 作為數據基座，統一進行數據管理，為其他微服務提供一致性的數據支持。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-f120981dacaac81db69e9a2f113ef113e3b.png" alt="" referrerpolicy="no-referrer"></p><p>根據上述架構特點，我們可以在此基礎上，通過核心的 webService (業務接口微服務) 搭配任務隊列服務 (RabbitMq、 Kafka、 RocketMq 等等) 連接其他功能微服務， 從而拓展整體系統的功能，例如：</p><ul><li>構建服務：由 webService 收集用戶請求觸發任務隊列執行耗費機器資源的構建設計器、區塊、物料的相關服務。</li><li>爬蟲服務：單獨封裝，安裝了 puppeteer 服務器的微服務，由 webService 觸發去執行一些爬取數據、代理登錄等等操作。</li><li>AI 大模型相關服務：連接自己內部 AI 大模型， 進行設計器智能化相關的 AI 代碼生成、指令操作等等功能的。</li><li>發佈服務：封裝自己的 CI/CD 流水線微服務，結合設計器代碼產出，使代碼生產-構建-部署一條龍式運作。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-4558b19a5a930a638d800a5208bcb821d59.png" alt="" referrerpolicy="no-referrer"></p><h1>硬件配置</h1><h2>本地開發</h2><p>推薦使用 <code>windows</code> 操作系統， 推薦配置如下：</p><ul><li>64 位操作系統</li><li>12 核 CPU</li><li>32G 內存</li></ul><h2>服務容器化部署</h2><p>以下信息為支撐 50 qps 併發量的配置參考， 開發者可根據實際情況進行具體問題具體分析，配置信息僅供參考.</p><p>配置單位：</p><ul><li>U: cpu 核數</li><li>G: 內存單位</li></ul><p>在配置負載均衡的情況下推薦：</p><table><thead><tr><th>服務</th><th>配置</th><th>工作負載數量</th></tr></thead><tbody><tr><td>webService</td><td>1U+3G</td><td>4</td></tr><tr><td>data-center</td><td>1U+2G</td><td>4</td></tr></tbody></table><h1>FAQ</h1><p><strong>1、服務端開源之後，如果不想啓動 webservice 和 datacenter 兩個後端服務器，是否還能沿用原來 mockServer？</strong><br> 答：可以正常使用 mockServer，啓動方式和原先一致，直接在項目裏執行 <code>pnpm dev</code> 即可</p><p><strong>2、如果本地啓動了 webservice 和 datacenter，那麼前端本地工程是否還需要更改配置？如果需要，如何更改配置？</strong><br> 答：需要更改配置，更改流程如下： 啓動 <code>tinyengine</code></p><p>修改 <code>packages/design-core/vite.config.js</code> 中 origin 的值為自己本地 webService 項目的地址端口（webService 端口默認為 7011）</p><p>運行如下腳本並啓動</p><pre><code class="language-sh">pnpm install  # 第一次啓動項目需要
pnpm serve:frontend
</code></pre><p>啓動成功後瀏覽器會自動打開設計器頁面</p><p><img src="https://oscimg.oschina.net/oscnet/up-a0f5b0133144d2b27013c73bacbf232675f.png" alt="" referrerpolicy="no-referrer"></p><p>具體搭建流程可參考官網本地化部署文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhelp-center%2Fcourse%2Fbackend%2F51" target="_blank">TinyEngine 服務端開源部署 </a></p><h1>未來規劃</h1><p>1，人工智能：計劃將低代碼平台與 AIGC（人工智能生成內容）技術相結合，為用戶提供更加智能、高效的應用開發體驗。後續我們考慮將低代碼平台的開發流程與 AIGC 技術相結合，通過自然語言處理、機器學習和深度學習等技術，實現應用界面的自動生成、功能模塊的智能推薦和代碼的自動化生成等功能。</p><p>2，模型驅動：我們將致力於將低代碼平台與模型驅動能力相結合，為用戶提供更加高效、智能的開發體驗。深入研究各種業務模型，包括數據模型、業務流程模型等，以瞭解其特性和需求。後續，我們將低代碼平台的開發流程與模型驅動能力相結合，通過可視化建模工具和自動化技術，實現業務模型的快速構建和部署。通過這一創新性的接入方式，用戶將能夠更加高效地構建和調整業務模型，降低開發難度和成本。</p><h2><strong>關於 OpenTiny</strong></h2><p><img src="https://oscimg.oschina.net/oscnet/up-1c661a9c0916f9dabf9cf1c4aeba473fb68.png" alt="" referrerpolicy="no-referrer"></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">OpenTiny</a> 是一套企業級 Web 前端開發解決方案，提供跨端、跨框架、跨版本的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue%2Fzh-CN%2Foverview" target="_blank">TinyVue 組件庫</a>，包含基於 Angular+TypeScript 的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-ng%2Foverview" target="_blank">TinyNG 組件庫</a>，擁有靈活擴展的低代碼引擎 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a>，具備主題配置系統<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Fdesigntheme%2Fhome" target="_blank">TinyTheme</a> / 中後台模板<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Fpro%2Fhome" target="_blank"> TinyPro</a>/ <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-cli%2Fhome" target="_blank">TinyCLI </a>命令行等豐富的效率提升工具，可幫助開發者高效開發 Web 應用。</p><hr><p>歡迎加入 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">OpenTiny 開源社區</a>。添加微信小助手：opentiny-official 一起參與交流前端技術～更多視頻內容也可關注<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspace.bilibili.com%2F15284299%3Fspm_id_from%3D333.1007.0.0" target="_blank">B 站</a>、抖音、小紅書、視頻號</p><p>OpenTiny&nbsp;也在持續招募貢獻者，歡迎一起共建</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">OpenTiny 官網</a>：<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">https://opentiny.design/</a></strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">OpenTiny 代碼倉庫</a>：<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">https://github.com/opentiny/</a></strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">TinyVue 源碼</a>：<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">https://github.com/opentiny/tiny-vue</a></strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">TinyEngine 源碼</a>： <strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">https://github.com/opentiny/tiny-engine</a></strong></p><p>歡迎進入代碼倉庫 Star🌟<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">TinyEngine</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">TinyVue</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Fng" target="_blank">TinyNG</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-cli" target="_blank">TinyCLI</a>~</p><p>如果你也想要共建，可以進入代碼倉庫，找到&nbsp;good first issue 標籤，一起參與開源貢獻~</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 03:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6769809/blog/10555626</guid>
            <link>https://my.oschina.net/u/6769809/blog/10555626</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 年化收入超 16 億美元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theinformation.com%2Farticles%2Fopenais-annualized-revenue-tops-1-6-billion-as-customers-shrug-off-ceo-drama" target="_blank">The Information</a> 援引知情人士消息稱，受益於 ChatGPT 產品的強勁增長，OpenAI 最近的年化收入已經從 10 月中旬的 13 億美元增至 16 億美元。</span></p><p><span style="color:#000000">這一增長表明，「即便該公司因為 11 月份的領導層危機為競爭對手提供了搶奪客戶的機會，但其仍能保持向企業銷售人工智能產品的業務勢頭。」</span></p><p><img height="307" src="https://oscimg.oschina.net/oscnet/up-bc1feecce3c765f974f328d2a2ace13b9a6.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000">OpenAI 於 2023 年 2 月推出 ChatGPT 服務的付費版本 ChatGPT Plus 後，銷售額開始快速增長。此前，該公司主要通過應用程序接口向開發者提供 AI 模型來進行創收。數據顯示，該公司 2022 年虧損 5.4 億美元，營收僅為 2800 萬美元。</span></p><p><span style="color:#000000">路透社報道稱，OpenAI 最初預計在 2023 年完成 2 億美元的銷售額。但事實證明，ChatGPT Plus 比預期的要更受歡迎：在 8 月份，OpenAI 的營收就突破了 10 億美元，10 月達到了 13 億美元。該公司的銷售勢頭預計將持續到 2024 年。OpenAI 的一些高管認為，截至年底，其年化經常性收入將增長近四倍，達到 50 億美元。</span></p><p><span style="color:#000000">「這種樂觀的前景表明，該公司可能不會僅僅依靠現有產品的需求來維持其銷售增長。特別是，它可能計劃推出新的 AI 服務，從而創造額外的收入來源。」</span></p><p><span style="color:#000000">OpenAI 收入的快速增長也可能有助於其在來年獲得投資者更高的估值。日前曾有<a href="https://www.oschina.net/news/272549/openai-valuation-100-billion-funding-round">消息稱</a>，OpenAI 正在以 1000 億美元或以上的估值籌集新一輪融資。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 03:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273759/openais-annualized-revenue-tops-1-6b</guid>
            <link>https://www.oschina.net/news/273759/openais-annualized-revenue-tops-1-6b</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 正式加入 CNCF 雲原生計算基金會]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><strong style="outline: 0px;visibility: visible;">vivo 近期完成了新會員的 Onboarding 流程， 已正式加入 CNCF 雲原生計算基金會</strong>（<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io" textvalue="https://www.cncf.io" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.cncf.io</a>）。<strong style="letter-spacing: 0.544px;outline: 0px;visibility: visible;"></strong></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><span style="text-align: center;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"><br></span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><span style="text-align: center;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100014267" data-ratio="0.5613346418056918" data-s="300,640" src="https://oscimg.oschina.net/oscnet/d2d6894b-bacd-42d9-b2d8-05a6782d0354.png" data-type="png" data-w="1019" style="letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" referrerpolicy="no-referrer"></span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><span style="text-align: center;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span></p><p><span style="background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">C</span><span style="background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">NCF 雲原生計算基金會 （Cloud Native Computing Foundation）是 Linux 基金會的一部分，是開源、供應商中立的雲原生計算生態組織，致力於雲原生應用推廣和普及。我們希望通過加入 CNCF 基金會</span><strong style="font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">，推動雲原生技術在 vivo 內部的應用和發展，助力自身業務高效交付；同時進一步加強與全球雲原生開源社區的交流溝通和知識分享，共同推動行業雲原生技術生態的可持續發展</strong><span style="background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">。</span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;">在正式加入 CNCF 雲原生計算基金會之前，vivo 內部研發團隊積極探索與實踐雲原生技術，在多個業務場景下應用雲原生項目，助力業務發展。</p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100014268" data-ratio="0.43425925925925923" data-s="300,640" src="https://oscimg.oschina.net/oscnet/695497a4-859d-487c-b98b-7537cebc2053.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"><span style="font-size: var(--articleFontsize);letter-spacing: 0.034em;text-align: justify;"></span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">vivo 在雲原生領域的項目採納現狀</span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">截止 2023 年 12 月</span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;text-align: left;"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: right;visibility: visible;"><section style="padding: 10px;outline: 0px;display: inline-block;width: 677px;border-width: 1px;border-style: solid;border-color: transparent;background-color: rgb(239, 239, 239);height: auto;visibility: visible;"><section powered-by="xiumi.us" style="outline: 0px;font-size: 14px;text-align: justify;visibility: visible;"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p><strong style="font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(239, 239, 239);outline: 0px;visibility: visible;">應用方面：</strong><br></p><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;">在雲原生領域的應用主要包括基於 Kubernetes 的容器編排、服務發現和負載均衡、容器鏡像管理、日誌收集和分析等場景。通過使用 Openkruise、Helm、Harbor、Containerd、Dragonfly、Fluentd 等開源項目與工具，vivo 實現了基於容器平台的應用發佈和管理，提高了業務交付效率和系統可靠性。</span></p></li></ul><p style="outline: 0px;visibility: visible;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="outline: 0px;visibility: visible;"><strong><span style="font-size: 15px;">容器平台能力建設方面：</span></strong></p><p style="outline: 0px;visibility: visible;"><strong><span style="font-size: 15px;"></span></strong><span style="font-size: 15px;letter-spacing: 0.544px;">主要包括基礎設施建設、平台架構設計和運維管理等方面。通過使用 Kubernetes 等容器編排技術，vivo 構建了一套完整的容器平台，包括容器集羣運維、容器網絡、存儲管理、應用發佈、安全管理等模塊，為企業內部多個業務線提供了穩定、可靠的容</span><span style="font-size: 15px;letter-spacing: 0.544px;">器平台。</span></p></li></ul><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;"><br></span></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p><span style="font-size: 15px;"><strong>敢於探索實踐方面：</strong></span></p><p><span style="font-size: 15px;"></span><span style="font-size: 15px;letter-spacing: 0.544px;">vivo 在雲原生領域勇於探索和實踐，積極參與開源社區和代碼貢獻，持續探索並推廣新技術及其應用場景。</span><span style="font-size: 15px;letter-spacing: 0.544px;">同時有積極參與 CNCF 應用交付 TAG 旗下相關工作組的貢獻，推廣和傳播平台工程相關的白皮書、成熟度模型等相關實踐和標準。</span></p></li></ul></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br style="outline: 0px;visibility: visible;"></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;">此外，vivo 持續保持與行業交流及合作，共同探索雲原生時代的軟件工程之道。2023 年 9 月由 Linux 基金會、雲原生計算基金會（CNCF）主辦的 <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.lfasiallc.com%2Fkubecon-cloudnativecon-open-source-summit-china%2F" textvalue="KubeCon + CloudNativeCon + Open Source Summit China" linktype="text" imgurl="" tab="outerlink" data-linktype="2">KubeCon + CloudNativeCon + Open Source Summit China</a> 在上海舉行，vivo 在平台工程專題做了 2 個主題分享。同時，我們也積極支持並參與 KCD 等區域性 Meetup 活動。</p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100014269" data-ratio="1.0716981132075472" data-s="300,640" src="https://oscimg.oschina.net/oscnet/8a9a6912-227d-44eb-ac54-faf41d593727.jpg" data-type="jpeg" data-w="1060" style="" referrerpolicy="no-referrer"></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;">未來，vivo 將持續探索與實踐雲原生技術，在 CNCF 雲原生基金會積極參與和貢獻，並與各成員持續加強交流合作。</p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-wrap: wrap;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);text-align: right;visibility: visible;"><section style="padding: 10px;outline: 0px;display: inline-block;width: 677px;border-width: 1px;border-style: solid;border-color: transparent;background-color: rgb(239, 239, 239);height: auto;visibility: visible;"><section powered-by="xiumi.us" style="outline: 0px;font-size: 14px;text-align: justify;visibility: visible;"><ul class="list-paddingleft-1" style="width: 555.438px;"><li><p><strong style="font-size: 15px;letter-spacing: 0.544px;outline: 0px;visibility: visible;">生產實踐方面：</strong><br></p><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;">將繼續推進雲原生技術在企業中的應用和發展，加強容器化和微服務能力，探索和實踐最新的容器化和微服務技術，基於此實踐積極向上遊提供反饋，最終提高我們自身的業務交付效率和用戶體驗。</span></p></li></ul><p style="outline: 0px;visibility: visible;"><br></p><ul class="list-paddingleft-1" style="width: 555.438px;"><li><p style="outline: 0px;visibility: visible;"><strong><span style="font-size: 15px;">社區貢獻方面：</span></strong></p><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;">以企業中應用雲原生技術遇到的實際問題為推動力，加強與 CNCF 組織和其他企業的技術交流與合作，積極參與 CNCF 項目開發和相關工作組的貢獻並傳播雲原生技術<span style="font-size: 15px;letter-spacing: 0.544px;">。</span></span><span style="font-size: 15px;letter-spacing: 0.544px;"></span></p></li></ul></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;text-wrap: wrap;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;visibility: visible;"><section style="padding-bottom: 3px;outline: 0px;display: inline-block;vertical-align: middle;border-bottom: 1px solid rgb(65, 95, 255);border-top-color: rgb(65, 95, 255);border-right-color: rgb(65, 95, 255);border-left-color: rgb(65, 95, 255);visibility: visible;"><section style="outline: 0px;border-bottom: 3px solid rgb(65, 95, 255);border-top-color: rgb(65, 95, 255);border-right-color: rgb(65, 95, 255);border-left-color: rgb(65, 95, 255);font-size: 16px;color: rgb(65, 95, 255);visibility: visible;"><p style="outline: 0px;visibility: visible;">關於 CNCF</p></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br style="outline: 0px;letter-spacing: 0.578px;visibility: visible;"></p><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);line-height: 1.5;visibility: visible;"><p style="outline: 0px;text-align: left;visibility: visible;"><img class="rich_pages wxw-img js_insertlocalimg" data-cropselx1="0" data-cropselx2="200" data-cropsely1="0" data-cropsely2="77" data-imgfileid="100014263" data-ratio="0.16574074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/55ece88a-d979-4dbb-941c-1ed46907bd24.jpg" data-type="png" data-w="1080" style="outline: 0px;visibility: visible !important;width: 465px;height: 77px;" referrerpolicy="no-referrer"></p></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;justify-content: flex-start;display: flex;flex-flow: row;visibility: visible;"><section style="padding-left: 8px;outline: 0px;display: inline-block;width: 578px;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;align-self: flex-start;flex: 0 0 auto;visibility: visible;"><section powered-by="xiumi.us" style="outline: 0px;color: rgba(0, 0, 0, 0.5);text-align: justify;visibility: visible;"><p style="outline: 0px;visibility: visible;">使命：讓雲原生無處不在</p></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br style="outline: 0px;visibility: visible;"></p><section powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);"><p style="outline: 0px;">CNCF 雲原生計算基金會 (Cloud Native Computing Foundation, https://www.cncf.io/）成立於 2015 年 12 月，是非營利性 Linux 基金會（https://www.linuxfoundation.org/）的一部分，其使命是「讓雲原生技術無處不在」（參考 CNCF 章程 ）。</p><p style="outline: 0px;"><br style="outline: 0px;"></p><p style="outline: 0px;">CNCF 致力於培育和維護一個廠商中立的開源生態系統，來推廣雲原生技術，託管全球技術基礎設施的關鍵組件。通過將最前沿的模式民主化，讓這些創新為大眾所用。CNCF 彙集了世界頂級的開發者、最終用戶和供應商，並舉辦了最大的開源開發者大會。</p><p style="outline: 0px;"><br></p><p style="outline: 0px;"><span style="letter-spacing: 0.544px;text-align: center;">相關資料：</span></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p>Linux 基金會</p><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linuxfoundation.org%2F" textvalue="https://www.linuxfoundation.org/" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.linuxfoundation.org/</a></p></li><li><p>CNCF 雲原生計算基金會</p><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io%2F" textvalue="https://www.cncf.io/" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.cncf.io/</a></p></li><li><p>CNCF 章程</p></li></ul><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcncf%2Ffoundation%2Fblob%2Fmain%2Fcharter.md" textvalue="https://github.com/cncf/foundation/blob/main/charter.md" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://github.com/cncf/foundation/blob/main/charter.md</a></p><p><br></p></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;"><section style="padding: 3px;outline: 0px;display: inline-block;border-bottom: 1px solid rgb(65, 95, 255);color: rgb(65, 95, 255);"><p style="outline: 0px;">關注我們</p></section></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;justify-content: flex-start;display: flex;flex-flow: row;"><section style="padding: 22px;outline: 0px;display: inline-block;width: 677px;vertical-align: top;align-self: flex-start;flex: 0 0 auto;background-color: rgb(247, 247, 247);"><section powered-by="xiumi.us" style="outline: 0px;text-align: justify;"><ul class="list-paddingleft-1" style="padding-left: 40px;outline: 0px;list-style-position: outside;"><li style="outline: 0px;"><p style="outline: 0px;">【移動 OSS】</p><p style="outline: 0px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopensource.vivo.com%2F" textvalue="https://opensource.vivo.com" linktype="text" imgurl="" tab="outerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">https://opensource.vivo.com</a></p></li><li style="outline: 0px;"><p style="outline: 0px;">【互聯網 OSS】</p><p style="outline: 0px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvivo" textvalue="https://github.com/vivo&nbsp;" linktype="text" imgurl="" tab="outerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">https://github.com/vivo&nbsp;</a></p></li><li style="outline: 0px;"><p style="outline: 0px;">【<span style="outline: 0px;letter-spacing: 0.578px;">開源頻道</span>】@vivo 互聯網技術&nbsp;&nbsp;<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26action%3Dgetalbum%26album_id%3D2951473838086422533%23wechat_redirect" textvalue="#開源&nbsp;" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">#開源&nbsp;</a></p></li></ul></section></section></section><p><br></p><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互聯網技術" data-alias="vivoVMIC" data-signature="分享 vivo 互聯網技術乾貨與沙龍活動，推薦最新行業動態與熱門會議。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公眾號 - vivo 互聯網技術（vivoVMIC）。<br>如有侵權，請聯繫 support@oschina.cn 刪除。<br>本文參與「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源創計劃</a>」，歡迎正在閲讀的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 03:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10448921</guid>
            <link>https://my.oschina.net/vivotech/blog/10448921</link>
            <author>
                <![CDATA[vivo 互聯網技術]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[飛致雲開源社區月度動態報告（2023 年 12 月）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#000000; text-align:start"><span><span style="color:#000000">自 2023 年 6 月起，中國領先的開源軟件公司 FIT2CLOUD 飛致雲以月度為單位發佈《飛致雲開源社區月度動態報告》，旨在向廣大社區用戶同步飛致雲旗下系列開源軟件的發展情況，以及當月主要的產品新版本發佈、社區運營成果等相關信息。</span></span></p><p style="color:#000000; text-align:start"><span><strong><span style="color:#00355d">飛致雲開源大屏（2023 年 12 月）</span></strong></span></p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-ce20816fb99437841e5fd716dc8614c9a48.png" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:start"><span>▲圖 1 飛致雲開源大屏（2023.12.29 12:00）</span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">2023 年 12 月飛致雲開源軟件運營數據概覽（統計時間為 2023.12.1～2023.12.29）</span></span></p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-7f1d375b645d195bf7e8b90007275b91588.png" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:center"><strong><span style="color:#3370ff">2023 年 12 月產品發佈事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 開源建站工具</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 1 日，強大易用的開源建站工具 Halo 正式發佈 2.11.0 版本。在這一版本中，Halo 新增個人中心功能，將所有和用戶自身相關的功能移動到個人中心。同時，Halo 進行了 50 多項功能優化和問題修復。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ DataEase 開源數據可視化分析工具</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 11 日，DataEase 開源數據可視化分析平台正式發佈 v2.1.0 版本。</p><p style="color:#000000; text-align:start">這一版本的功能升級包括：新增模板中心，用戶可以通過模板中心的模板快速創建儀錶板和數據大屏；新增「系統設置」功能模塊，該模塊包含系統參數、認證設置、嵌入式管理、平台對接四個子模塊。在「系統參數」子模塊中，用戶可以對常用的系統設置項進行管理，「認證設置」子模塊支持 CAS（中央認證服務）、LDAP（輕量級目錄訪問協議）、OIDC（開放 ID 連接）等常用認證協議的對接，在「嵌入式管理」子模塊中用戶可以創建嵌入式應用，通過嵌入式應用將 DataEase 嵌入到第三方平台中，「平台對接」子模塊目前已支持飛書平台的接入，用戶可以通過飛書掃碼的方式快速登錄到 DataEase 平台；數據準備方面，新版 DataEase 支持數據集和數據源的複製功能，方便用戶快速創建類似的數據資源。</p><p style="color:#000000; text-align:start">此外，DataEase 開源項目組還對其他一些常用的功能進行了功能優化和問題修復。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 1Panel 開源面板</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 18 日，現代化、開源的 Linux 服務器運維管理面板 1Panel 正式發佈 v1.9.0 版本。</p><p style="color:#000000; text-align:start">在這一版本中，1Panel 引入了新的工具箱管理功能，包含 Swap 分區管理、Fail2Ban 管理等功能。此外，1Panel 針對網站證書管理功能進行了全面重構，現在支持添加 ZeroSSL、BuyPass 和 Google Cloud 等 ACME 賬戶，還新增了 GoDaddy、Name.com、NameCheap、NameSilo 等 DNS 賬戶。在申請證書時，系統支持多種加密算法，能夠創建自簽名證書，並且提供證書的上傳、下載功能，用戶還可以批量刪除證書，將證書推送至本地目錄。容器配置頁面也新增了與 IPv6 相關的配置選項。</p><p style="color:#000000; text-align:start">此外，1Panel 開源項目組還進行了 70 多項功能更新和問題修復。1Panel 應用商店新增了 10 款應用，並且更新了 20 款應用。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ JumpServer 開源堡壘機</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 25 日，JumpServer 開源堡壘機正式發佈 v3.10 LTS（Long Term Support）版本。JumpServer 開源項目組將對 v3.10 LTS 版本提供長期支持，定期迭代發佈小版本，持續進行問題修復更新並針對部分功能進行優化。歡迎廣大用戶升級使用 v3.10 LTS 版本。</p><p style="color:#000000; text-align:start">在這一版本中，JumpServer 重構了「標籤」功能，支持全局標籤管理，賦予了「標籤」更為靈活、更為強大的功能。從 JumpServer v3.10.0 版本開始，「標籤」不僅能綁定到資產上，還能夠綁定到其他資源上，讓其他資源通過「標籤」功能擁有額外的功能屬性。同時，JumpServer 新增 Chat AI 小助手功能，支持對接 ChatGPT，實現了多個用戶可以在 JumpServer 瀏覽器功能界面直接與 ChatGPT 進行對話的能力，極大地提高了用戶的使用率及工作效率。</p><p style="color:#000000; text-align:start">另外，「賬號收集」功能支持將遠程服務器中不存在的賬戶進行同步刪除；「文件管理」功能支持批量傳輸文件，將批量命令和批量傳輸文件集中到工作台界面。這樣一來，管理員可以讓資產功能以更加方便的方式直接暴露給用戶使用。</p><p style="color:#000000; text-align:start">X-Pack 增強包方面，JumpServer 支持第三方客戶端直連 SQL Server 數據庫，支持 Slack 平台的用戶認證及消息通知功能。同時，新版本 JumpServer 還支持配置備案信息至登錄頁面，支持使用 Linux 系統作為遠程應用發佈機。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ MeterSphere 開源持續測試平台</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 28 日，MeterSphere 開源持續測試平台發佈 v2.10.10 LTS 版本。</p><p style="color:#000000; text-align:start">在這一版本中，UI 測試方面，新增文件上傳限制、添加關聯文件時過濾已存在關聯關係的文件；測試跟蹤方面，在用例評審時支持左側模塊樹功能、表頭默認不顯示所屬模塊字段、本地附件轉存文件庫時排除第三方存儲庫模塊；接口測試方面，去除接口定義路徑結尾的空格、接口自動化表頭增加所屬模塊字段。此外，MeterSphere 項目組還進行了 8 項功能優化和 22 項漏洞修復工作。</p><p style="color:#000000; text-align:center"><strong><span style="color:#3370ff">其他重要事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 飛致雲與上海吉諦達成戰略合作，獲得 Gitea 企業版中國大陸地區獨家代理權</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 13 日，FIT2CLOUD 飛致雲宣佈與上海吉諦達成戰略合作，FIT2CLOUD 飛致雲獲得上海吉諦旗下代碼託管平台 Gitea 企業版中國大陸地區獨家代理權。</p><p style="color:#000000; text-align:start">在 Gitea 社區版的基礎之上，Gitea 企業版提供面向企業級應用場景的 X-Pack 增強包及企業級支持服務，有效助力企業快速構建並運營自託管的新一代代碼託管平台。</p><p style="color:#000000; text-align:start">Gitea v1.21 版本的企業版軟件已經於 2023 年 11 月正式發佈，首批開放的 X-Pack 增強包功能包括：企業微信/釘釘/飛書對接集成、供應鏈安全掃描、數據安全備份、分佈式部署架構和國產化信創適配等。</p><p style="color:#000000; text-align:start"><img alt="" height="608" src="https://oscimg.oschina.net/oscnet/up-d57c9939ebd603754752cc23d2f9e9aca95.jpg" width="1080" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:start"><span>▲ 圖 2 飛致雲與上海吉諦達成戰略合作</span></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ FIT2CLOUD 飛致雲榮膺「2023 年度 OSCHINA 優秀開源技術團隊」獎項</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 8 日，知名開源技術社區 OSCHINA（開源中國）公佈了「2023 年度 OSCHINA 優秀開源技術團隊」入選名單。憑藉在開源軟件研發和開源社區運營方面的年度優異表現，FIT2CLOUD 飛致雲再次收穫「優秀開源技術團隊」獎項。這也是繼 2021 年和 2022 年之後，FIT2CLOUD 飛致雲連續第三年榮膺該項榮譽。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ JumpServer 開源堡壘機 V2 社區版即將停止維護的通知</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 1 日，JumpServer 開源項目組發佈重要通知。如《關於 JumpServer 開源堡壘機 V2 版本產品生命週期的相關説明》所示，JumpServer 開源堡壘機 V2 版本（社區版）將於 2023 年 12 月 31 日停止維護支持。</p><p style="color:#000000; text-align:start">出於產品自身迭代和用戶需求升級的要求，2023 年 2 月 27 日，JumpServer 開源堡壘機正式發佈 v3.0 版本，目前已更新至 v3.10 LTS 版本。JumpServer 開源項目組建議社區版和企業版用戶更新至 JumpServe v3.x 版本，以使用更多的新增功能並獲取更好的軟件使用體驗。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 推出 AI 助手插件</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 15 日，Halo AI 助手插件上線。AI 助手插件通過擴展編輯器功能，為 Halo 默認編輯器帶來了豐富的 AI 輔助功能。用戶可以通過選中文字或者使用/命令的方式快速呼出 AI 對話框。AI 助手插件目前使用 OpenAI 的接口來提供 AI 能力支持，用戶可以自定義 OpenAI 接口地址，選擇切換不同的模型或者在網絡不通的情況下配置代理使用。用戶訪問 Halo 應用市場，即可下載體驗 Halo AI 助手插件。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ DataEase 漏洞通知及修復方案（DE-2023.12.19）</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 19 日，DataEase 項目組發佈了編號為「DE-2023.12.19」的漏洞通知及修復方案，請用戶儘快將 DataEase 升級至 v1.18.11 及以後的版本。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 1.x 停止維護公告</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 21 日，Halo 開源項目組發佈《Halo 1.x 停止維護公告》。為了集中資源和精力去持續改進和維護 Halo 的最新版本，Halo 1.x 版本將於 2023 年 12 月 31 日停止維護。Halo 開源項目組提供了詳細的從 1.x 版本遷移到 2.x 版本的升級指南，您可以訪問官方文檔：《從 Halo 1.x 遷移》<span style="color:#172b4d">（</span>https://docs.halo.run/getting-started/migrate-from-1.x/<span style="color:#172b4d"><span>&nbsp;</span>）</span>來瞭解詳情。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">關於飛致雲開源大屏</span></strong></p><p style="color:#000000; text-align:start">飛致雲開源大屏（https://bi.fit2cloud.com/link/6CgpMHrT）是 FIT2CLOUD 飛致雲為展示其旗下開源軟件的社區運營情況製作的數據儀錶板。該大屏使用 DataEase 開源數據可視化分析平台製作，實時呈現飛致雲開源社區近 30 日內的動態信息。</p><p style="color:#000000; text-align:start">廣大社區用戶可以通過該大屏瞭解飛致雲旗下開源項目的 GitHub Star、Fork、Issue、貢獻者等指標的數量信息，以及近 30 日內新增的 Star、Fork、下載、Issue、PR 數量等，同時該大屏還展示了飛致雲旗下開源項目的 Issue 趨勢、Commit 趨勢、PR 趨勢、Issue 生命週期等。</p><p style="color:#000000; text-align:start">除了展示所有項目的彙總信息外，該大屏還支持用戶分類別查看 JumpServer、DataEase、MeterSphere、Halo、1Panel、CloudExplorer Lite 六個開源項目的獨立運營數據。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4736111/blog/10469745</guid>
            <link>https://my.oschina.net/u/4736111/blog/10469745</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[關於編程模式的總結與思考]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;visibility: visible;" data-mpa-powered-by="yiban.io"><img class="rich_pages wxw-img __bg_gif" data-backh="96" data-backw="578" data-cropselx1="0" data-cropselx2="578" data-cropsely1="0" data-cropsely2="96" data-imgfileid="503041828" data-ratio="0.16666666666666666" src="https://oscimg.oschina.net/oscnet/7f3f91e3-bb2b-4b44-a874-fe03bc749ab0.gif" data-type="gif" data-w="636" style="outline: 0px;letter-spacing: 0.544px;font-size: var(--articleFontsize);border-radius: 8px;text-align: justify;width: 677px;visibility: visible !important;background-size: 16px !important;" referrerpolicy="no-referrer"><br style="outline: 0px;visibility: visible;"></section><section data-mpa-template="t" data-mpa-template-id="502" data-mpa-category="模板" style="outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);visibility: visible;"><section data-mpa-category="模板" data-mid="" style="padding-right: 1px;padding-left: 1px;outline: 0px;width: 677px;display: flex;justify-content: flex-start;align-items: center;flex-direction: column;visibility: visible;"><section data-mid="" style="outline: 0px;letter-spacing: 0.544px;width: 675px;display: grid;grid-template-columns: 26px auto;visibility: visible;"><section data-mid="" style="outline: 0px;width: 26px;height: 14px;display: flex;justify-content: center;align-items: center;align-self: center;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section><section data-mid="" style="padding-left: 7px;outline: 0px;display: flex;justify-content: flex-start;align-items: center;visibility: visible;"><section data-mid="" style="margin-right: 7px;outline: 0px;text-align: left;visibility: visible;"><p data-mid="" style="outline: 0px;width: 0px;font-size: 14px;font-family: PingFangSC-Semibold, &quot;PingFang SC&quot;;font-weight: bold;color: rgb(58, 92, 244);line-height: 20px;visibility: visible;"><br style="outline: 0px;visibility: visible;"></p></section><section data-mid="" style="margin-bottom: 4px;outline: 0px;width: 635px;height: 1px;border-top: 1px solid rgb(58, 92, 244);align-self: flex-end;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section></section></section><section data-mid="" style="padding: 7px 14px 9px 19px;outline: 0px;width: 675px;text-align: left;border-bottom: 1px solid rgb(58, 92, 244);visibility: visible;"><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;letter-spacing: 0.578px;text-align: justify;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;white-space-collapse: preserve;text-size-adjust: inherit;text-align: left;caret-color: rgb(23, 26, 29);letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;color: rgb(0, 0, 0);visibility: visible;font-size: 15px;">淘寶創新業務的<span style="font-size: 15px;letter-spacing: 1px;text-wrap: wrap;">優化迭代是非常高頻且迅速的，</span><span style="font-size: 15px;letter-spacing: 1px;text-wrap: wrap;">在這過程中要求技術也必須是快且穩的，而為了適應這種快速變化的節奏，我們在項目開發過程中採用了一些面向拓展以及敏捷開發的設計，</span><span style="font-size: 15px;letter-spacing: 1px;text-wrap: wrap;">本文旨在總結並思考其中一些通用的編程模式。</span></span></p></section></section></section><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;line-height: 1.75em;"><br style="outline: 0px;visibility: visible;"></p><section style="margin-bottom: 0px;outline: 0px;box-sizing: inherit;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgba(25, 26, 31, 0.9);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 16px;text-align: center;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041829" data-ratio="0.3161764705882353" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b90357ce-619d-4abb-a361-96e0ffebccdd.png" data-type="png" data-w="408" style="outline: 0px;color: rgb(34, 34, 34);font-family: system-ui, -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;visibility: visible !important;width: 113px !important;" referrerpolicy="no-referrer"></span></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(34, 34, 34);text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;color: rgb(3, 69, 255);font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;visibility: visible;">前言</span></section><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">靜心守護業務是淘寶今年 4 月份啓動的創新項目，項目的核心邏輯是通過敲木魚、冥想、盤手串等療愈玩法為用戶帶來內心寧靜的同時推動文物的保護與修復，進一步弘揚我們的傳統文化。</span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">作為創新項目，業務形態與產品方案的優化迭代是非常高頻且迅速的：項目從 4 月底投入開發到 7 月份最終外灰，整體方案經歷過大的推倒重建，也經歷過多輪小型重構優化，項目上線後也在做持續的迭代優化甚至改版升級。</span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section style="margin-bottom: 0px;outline: 0px;box-sizing: inherit;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgba(25, 26, 31, 0.9);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 16px;text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;font-size: 15px;letter-spacing: 1px;visibility: visible;"><img class="rich_pages wxw-img" data-imgfileid="503041833" data-ratio="0.3056872037914692" data-s="300,640" src="https://oscimg.oschina.net/oscnet/0f807f04-facf-4eba-bf80-54b3dc2b020a.png" data-type="png" data-w="422" style="outline: 0px;color: rgb(34, 34, 34);font-family: system-ui, -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;visibility: visible !important;width: 117px !important;" referrerpolicy="no-referrer"></span></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(34, 34, 34);text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;visibility: visible;color: rgb(0, 17, 255);">模式清單</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><span id="OSC_h4_1"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">基於 Spring 容器與反射的策略模式</span></strong></span></h4><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">策略模式是一種經典的行為設計模式，它的本質是定義一系列算法， 並將每種算法分別放入獨立的類中， 以使算法的對象能夠相互替換，後續也能根據需要靈活拓展出新的算法。這裏推薦的是一種基於 Spring 容器和反射結合的策略模式，這種模式的核心思路是：每個策略模式的實現都是一個 bean，在 Spring 容器啓動時基於反射獲取每個策略場景的接口類型，並基於該接口類型再獲取此類型的所有策略實現 bean 並記錄到一個 map（key 為該策略 bean 的唯一標識符，value 為 bean 對象）中，後續可以自定義路由策略來從該 map 中獲取 bean 對象並使用相應的策略。</span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h4_2"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">模式解構</span></h4></li></ul><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">模式具體實現方式大致如下面的 UML 類圖所描述的：</span></p><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><img class="rich_pages wxw-img" data-backh="258" data-backw="578" data-imgfileid="503041831" data-ratio="0.4462962962962963" src="https://oscimg.oschina.net/oscnet/d8f41f29-554a-49b5-b29f-5130f4805640.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></section><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">其中涉及的各個組件及作用分別為：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>Handler</strong>（<em>interface</em>）：策略的頂層接口，定義的 type 方法表示策略唯一標識的獲取方式。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>HandlerFactory</strong>（<em>abstract class</em>）：策略工廠的抽象實現，封裝了反射獲取 Spring bean 並維護策略與其標識映射的邏輯，但不感知策略的真實類型。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>AbstractHandler</strong>（<em>interface or abstracr class</em>）：各個具體場景下的策略接口定義，該接口定義了具體場景下策略所需要完成的行為。如果各個具體策略實現有可複用的邏輯，可以結合模版方法模式在該接口內定義模版方法，如果模板方法依賴外部 bean 注入，則該接口的類型需要為<em>abstract class</em>，否則為<em>interface</em>即可。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>HandlerImpl</strong>（<em>class</em>）：各個場景下策略接口的具體實現，承載主要的業務邏輯，也可以根據需要橫向拓展。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>HandlerFactoryImpl</strong>（<em>class</em>）：策略工廠的具體實現，感知具體場景策略接口的類型，如果有定製的策略路由邏輯也可以在此實現。</span></p></li></ol><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(68, 68, 68);font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(68, 68, 68);font-size: 15px;letter-spacing: 1px;">這種模式的主要優點有：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(68, 68, 68);">策略標識維護自動化</span></strong><span style="color: rgb(68, 68, 68);">：策略實現與標識之間的映射關係完全委託給 Spring 容器進行維護（在</span><em><span style="color: rgb(68, 68, 68);">HandlerFactory</span></em><span style="color: rgb(68, 68, 68);">中封裝，每個場景的策略工廠直接繼承該類即可，無需重複實現），後續新增策略不用再手動修改關係映射。</span></span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(68, 68, 68);">場景維度維護標識映射</span></strong><span style="color: rgb(68, 68, 68);">：</span><em><span style="color: rgb(68, 68, 68);">HandlerFactory</span></em><span style="color: rgb(68, 68, 68);">中在掃描策略 bean 時是按照</span><em>AbstractHandler</em>的類型來分類維護的，從而避免了不同場景的同名策略發生衝突。</span></p></li><li><section style="margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(68, 68, 68);">策略接口按場景靈活定義</span></strong><span style="color: rgb(68, 68, 68);">：具體場景的策略行為定義在</span><em><span style="color: rgb(68, 68, 68);">AbstractHandler</span></em><span style="color: rgb(68, 68, 68);">中，在這裏可以根據真實的業務需求靈活定義行為，甚至也可以結合其他設計模式做進一步抽象處理，在提供靈活拓展的同時減少重複代碼。</span></span></section></li></ol><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_3"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">實踐案例分析</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">該模式在靜心守護項目中的許多功能模塊都有使用，下面以稱號解鎖模塊為例來介紹其實際應用。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">我們先簡單瞭解下該模塊的業務背景：靜心守護的成就體系中有一類是稱號，如下圖。用戶可以通過多種行為去解鎖不同類型的稱號，比如説通過參與主玩法（敲木魚、冥想、盤手串），主玩法參與達到一定次數後即可解鎖特定類型的稱號。當然後續也可能會有其他種類的稱號：比如簽到類（按照用戶簽到天數解鎖）、捐贈類（按照用戶捐贈項目的行為解鎖），所以對於稱號的解鎖操作應該是面向未來可持續拓展的。</span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: center;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041832" data-ratio="2" src="https://oscimg.oschina.net/oscnet/62c7ac5c-2a9c-4a65-b420-4efbd4b250fb.png" data-type="png" data-w="500" referrerpolicy="no-referrer"></span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">基於這樣的思考，我選擇使用上面的策略模式去實現稱號解鎖模塊。該模塊的核心類圖組織如下：</span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><img class="rich_pages wxw-img" data-backh="259" data-backw="578" data-imgfileid="503041830" data-ratio="0.44722222222222224" src="https://oscimg.oschina.net/oscnet/5ead0c97-1223-42ec-90dc-be4c054fa964.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">下面是其中部分核心代碼的分析解讀：</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer">public interface Handler&lt;T&gt; {</span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * handler 類型</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    T type();</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><span style="color: rgb(68, 68, 68);">如上文所説，</span><em><span style="color: rgb(68, 68, 68);">Handler</span></em><span style="color: rgb(68, 68, 68);">是策略的頂層抽象，它只定義了</span><em><span style="color: rgb(68, 68, 68);">type</span></em><span style="color: rgb(68, 68, 68);">方法，該方法用於獲取策略的標識，標識的類型支持子接口定義。</span></span></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 15px;color: rgb(68, 68, 68);"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">public abstract class HandlerFactory&lt;T, H extends Handler&lt;T&gt;&gt; implements InitializingBean, ApplicationContextAware {</span></code><code><span class="code-snippet_outer">    private Map&lt;T, H&gt; handlerMap;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    private ApplicationContext appContext;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 根據 type 獲得對應的 handler</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param type</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public H getHandler(T type) {</span></code><code><span class="code-snippet_outer">        return handlerMap.get(type);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 根據 type 獲得對應的 handler，支持返回默認</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param type</span></code><code><span class="code-snippet_outer">     * @param defaultHandler</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public H getHandlerOrDefault(T type, H defaultHandler) {</span></code><code><span class="code-snippet_outer">        return handlerMap.getOrDefault(type, defaultHandler);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 反射獲取泛型參數 handler 類型</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @return handler 類型</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    @SuppressWarnings("unchecked")</span></code><code><span class="code-snippet_outer">    protected Class&lt;H&gt; getHandlerType() {</span></code><code><span class="code-snippet_outer">        Type type = ((ParameterizedType)getClass().getGenericSuperclass()).getActualTypeArguments()[1];</span></code><code><span class="code-snippet_outer">        //策略接口使用了範型參數</span></code><code><span class="code-snippet_outer">        if (type instanceof ParameterizedTypeImpl) {</span></code><code><span class="code-snippet_outer">            return (Class&lt;H&gt;) ((ParameterizedTypeImpl)type).getRawType();</span></code><code><span class="code-snippet_outer">        } else {</span></code><code><span class="code-snippet_outer">            return (Class&lt;H&gt;) type;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public void afterPropertiesSet() {</span></code><code><span class="code-snippet_outer">        // 獲取所有 H 類型的 handlers</span></code><code><span class="code-snippet_outer">        Collection&lt;H&gt; handlers = appContext.getBeansOfType(getHandlerType()).values();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        handlerMap = Maps.newHashMapWithExpectedSize(handlers.size());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        for (final H handler : handlers) {</span></code><code><span class="code-snippet_outer">            log.info("HandlerFactory {}, {}", this.getClass().getCanonicalName(), handler.type());</span></code><code><span class="code-snippet_outer">            handlerMap.put(handler.type(), handler);</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">        log.info("handlerMap:{}", JSON.toJSONString(handlerMap));</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public void setApplicationContext(@Nonnull ApplicationContext applicationContext) throws BeansException {</span></code><code><span class="code-snippet_outer">        this.appContext = applicationContext;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><em>HandlerFactory</em>在前面也提到過，是策略工廠的抽象實現，封裝了反射獲取具體場景策略接口類型，並查找策略 bean 在內存中維護策略與其標識的映射關係，後續可以直接通過標識或者對應的策略實現。這裏有二個細節：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">為什麼 HandlerFactory 是<em>abstract class</em>？其實可以看到該類並沒有任何抽象方法，直接將其定義為<em>class</em>也不會有什麼問題。這裏將其定義為<em>abstract class</em>主要是起到實例創建的約束作用，因為我們對該類的定義是工廠的抽象實現，只希望針對具體場景來創建實例，針對該工廠本身創建實例其實是沒有任何實際意義的。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><em>getHandlerType</em>方法使用了<em>@SuppressWarnings</em>註解並標記了<em>unchecked</em>。這裏也確實是存在潛在風險的，因為<em>Type</em>類型轉<em>Class</em>類型屬於向下類型轉換，是存在風險的，可能其實際類型並非<em>Class</em>而是其他類型，那麼此處強轉就會出錯。這裏處理了兩種最通用的情況：<em>AbstractHandler</em>是帶範型的<em>class</em>和最普通的<em>class</em>。</span></p></li></ol><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(68, 68, 68);font-size: 15px;letter-spacing: 1px;"><br></span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class TitleUnlockHandlerFactory</span></code><code><span class="code-snippet_outer">        extends HandlerFactory&lt;String, BaseTitleUnlockHandler&lt;BaseTitleUnlockParams&gt;&gt; {}</span></code></pre></section><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: start;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><ne-text ne-italic="true" style="font-style: italic;"><span style="font-size: 15px;letter-spacing: 1px;">TitleUnlockHandlerFactory</span></ne-text><ne-text><span style="font-size: 15px;letter-spacing: 1px;">是策略工廠的具體實現，由於不需要在此定製策略的路由邏輯，所以只聲明瞭相關的參數類型，而沒有對父類的方法做什麼覆蓋。</span></ne-text><ne-text></ne-text><span style="display: inline;min-width: 1px;vertical-align: baseline;height: 1em;user-select: none;font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: start;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><ne-text><span style="font-size: 15px;letter-spacing: 1px;"><br></span></ne-text></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">public abstract class BaseTitleUnlockHandler&lt;T extends BaseTitleUnlockParams&gt; implements Handler&lt;String&gt; {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private UserTitleTairManager userTitleTairManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private AchievementCountManager achievementCountManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private UserUnreadAchievementTairManager userUnreadAchievementTairManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 解鎖稱號</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param params</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public @CheckForNull TitleUnlockResult unlockTitles(T params) {</span></code><code><span class="code-snippet_outer">        TitleUnlockResult titleUnlockResult = this.doUnlock(params);</span></code><code><span class="code-snippet_outer">        if (null == titleUnlockResult) {</span></code><code><span class="code-snippet_outer">            return null;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        List&lt;TitleAchievementVO&gt; titleAchievements = titleUnlockResult.getUnlockedTitles();</span></code><code><span class="code-snippet_outer">        if (CollectionUtils.isEmpty(titleAchievements)) {</span></code><code><span class="code-snippet_outer">            titleUnlockResult.setUnlockedTitles(new ArrayList&lt;&gt;());</span></code><code><span class="code-snippet_outer">            return titleUnlockResult;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //基於注入的 bean 和計算出的稱號列表進行後置操作，如：更新成就計數、更新用戶稱號緩存、更新用戶未讀成就等</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        return titleUnlockResult;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 計算出要解鎖的稱號</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param param</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    protected abstract TitleUnlockResult doUnlock(T param);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public abstract String type();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: justify;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><ne-text></ne-text></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><em>BaseTitleUnlockHandler</em>定義了稱號解鎖行為，並且在此確定了策略標識的類型為<em>String</em>。此外，該類是一個<em>abstract class</em>，是因為該類定義了一個模版方法<em>unlockTitles</em>，在該方法裏封裝了稱號解鎖所要進行的一些公共操作，比如更新用戶的稱號計數、用戶的稱號緩存數據等，這些都依賴於注入的一些外部 bean，而<em>interface</em>不支持非靜態成員變量，所以該類通過<em>abstract class</em>來定義。具體的稱號解鎖行為通過<em>doUnlock</em>定義，這也是該策略的具體實現類需要實現的方法。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">另外也許你還注意到了<em>doUnlock</em>方法的行參是一個範型參數<em>T</em>，因為我們考慮到了不同類型稱號解鎖所需要的參數可能是不同的，因此在場景抽象接口側只依賴於稱號解鎖的公共參數類型，而在策略接口具體實現側才與該類型策略的具體參數類型進行耦合。</span></section><section style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: start;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><ne-text><span style="font-size: 15px;letter-spacing: 1px;"><br></span></ne-text></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class GameplayTitleUnlockHandler extends BaseTitleUnlockHandler&lt;GameplayTitleUnlockParams&gt; {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private BlessTitleAchievementDiamondConfig blessTitleAchievementDiamondConfig;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private UserTitleTairManager userTitleTairManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected TitleUnlockResult doUnlock(GameplayTitleUnlockParams params) {</span></code><code><span class="code-snippet_outer">        //獲取稱號元數據</span></code><code><span class="code-snippet_outer">        List&lt;TitleMetadata&gt; titleMetadata = blessTitleAchievementDiamondConfig.getTitleMetadata();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        if (CollectionUtils.isEmpty(titleMetadata)) {</span></code><code><span class="code-snippet_outer">            return null;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        List&lt;TitleAchievementVO&gt; titleAchievements = new ArrayList&lt;&gt;();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        Result&lt;DataEntry&gt; result = userTitleTairManager.queryRawCache(params.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //用戶稱號數據查詢異常</span></code><code><span class="code-snippet_outer">        if (null == result || !result.isSuccess()) {</span></code><code><span class="code-snippet_outer">            return null;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        if (Objects.equals(result.getRc(), ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer">            //解鎖新稱號</span></code><code><span class="code-snippet_outer">            titleAchievements = unlockNewTitles(params, titleMetadata);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } else if (Objects.equals(result.getRc(), ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer">            //初始化歷史稱號</span></code><code><span class="code-snippet_outer">            titleAchievements = initHistoricalTitles(params, titleMetadata);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        TitleUnlockResult titleUnlockResult = new TitleUnlockResult();</span></code><code><span class="code-snippet_outer">        titleUnlockResult.setUserTitleCache(result);</span></code><code><span class="code-snippet_outer">        titleUnlockResult.setUnlockedTitles(titleAchievements);</span></code><code><span class="code-snippet_outer">        return titleUnlockResult;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public String type() {</span></code><code><span class="code-snippet_outer">        return TitleType.GAMEPLAY;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ......</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">上面是一個策略的具體實現類的大致示例，可以看到該實現類核心明確了以下信息：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">策略標識：給出了 type 方法的具體實現，返回了一個策略標識的常量</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">策略處理邏輯：此處是玩法類稱號解鎖的業務邏輯，讀者無需關注其細節</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">稱號解鎖行參：給出了玩法類稱號解鎖所需的真實參數類型</span></p></li></ol><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><ne-text><br></ne-text></p><span id="OSC_h4_4"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">抽象疲勞度管控體系</span></strong></span></h4><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">在我們的業務需求中經常會遇到涉及疲勞度管控相關的邏輯，比如每日簽到允許用戶每天完成 1 次、首頁項目進展彈窗要求對所有用戶只彈 1 次、首頁限時回訪任務入口則要對用戶每天都展示一次，但用戶累計完成 3 次後便不再展示......因此我們設計了一套疲勞度管控的模式，以降低後續諸如上述涉及疲勞度管控相關需求的開發成本。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_5"></span><h3 style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">自頂向下的視角</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">這套疲勞度管控體系的類層次大致如下圖：</span></section><section style="min-height: 24px;margin-bottom: 8px;"><img class="rich_pages wxw-img" data-backh="360" data-backw="578" data-imgfileid="503041836" data-ratio="0.6222222222222222" src="https://oscimg.oschina.net/oscnet/f99ffd82-3d9e-4965-aa11-20ecbf3845eb.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" width="4011" referrerpolicy="no-referrer"></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">接下來我們自頂向下逐層進行介紹：</span></section><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">FatigueLimiter（<em>interface</em>）：<em>FatigueLimiter</em>是最頂層抽象的疲勞度管控接口，<span style="text-decoration: underline;">它定義了疲勞度管控相關的行為</span>，比如：疲勞度的查詢、疲勞度清空、疲勞度增加、是否達到疲勞度限制的判斷等。</span></section></li><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">BaseFatigueLdbLimiter（<em>abstract class</em>）：疲勞度數據的存儲方案可以是多種多樣的，在我們項目中主要利用 ldb 進行疲勞度存儲，而<em>BaseFatigueLdbLimiter</em>正是基於 ldb【注：阿里內部自研的一款持久化 k-v 數據庫，讀者可將其理解為類似 level db 的項目】對疲勞度數據進行管控的抽象實現，它封裝了 ldb 相關的操作，並基於 ldb 的數據操作實現了<em>FatigueLimiter</em>的疲勞度管控方法。但它並不感知具體業務的身份和邏輯，因此定義了幾個業務相關的方法交給下層去實現，分別是：</span></section></li><ul ne-level="1" class="list-paddingleft-1" style="padding-left: 23px;list-style-position: initial;list-style-image: initial;"><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">scene：標識具體業務的場景，會利用該方法返回值去構造 Ldb 存儲的 key</span></section></li><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">buildCustomKey：對 Ldb 存儲 key 的定製邏輯</span></section></li><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">getExpireSeconds：對應着 Ldb 存儲 kv 失效時間，對應着疲勞度的管控週期</span></section></li></ul><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">Ldb 週期性疲勞度管控的解決方案層（<em>abstract class</em>）：在這一層提供了多種週期的開箱即用的疲勞度管控實現類，如<em>BaseFatigueDailyLimiter</em>提供的是天級別的疲勞度管控能力，<em>BaseFatigueNoCycleLimiter</em>則表示疲勞度永不過期，而<em>BaseFatigueCycleLimiter</em>則支持用戶實現 cycle 方法定製疲勞度週期。</span></section></li><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">業務場景層：這一層則是各個業務場景對疲勞度管控的具體實現，實現類只需要實現 scene 方法來聲明業務場景的身份標識，隨後繼承對應的解決方案，即可實現快速的疲勞度管控。比如上面的 DailyWishSign<em>Limiter</em>就對應着本篇開頭我們所説的「每日簽到允許用戶每天完成 1 次」，這就要求為用戶的簽到行為以天維度構建 key 同時失效時間也為 1 天，因此直接繼承解決方案層的<em>BaseFatigueDailyLimiter</em>即可。其代碼實現非常簡單，如下：</span></section></li></ol><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class DailyWishSignLimiter extends BaseFatigueLdbDailyLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected String scene() {</span></code><code><span class="code-snippet_outer">        return LimiterScene.dailyWish;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_6"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">有一個「異類」</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">也許你注意到了上面的類層次圖中有一個「異類」——HomeEnterGuideLimiter。它其實就是我們在上文説的「首頁限時回訪任務入口則要對用戶每天都展示一次，但用戶累計完成 3 次後便不再展示」，它的邏輯其實也很簡單：因為它有 2 條管控條件，所以需要繼承 2 個管控週期的解決方案——天維度和永久維度，最後實際使用的類再聚合了天維度和永久維度的實現類（每個實現類對應 ldb 的一類 key）並實現了頂層的疲勞度管控接口，標識這也是一個疲勞度管理器。它們的代碼如下：</span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 首頁入口引導限時任務-天級疲勞度管控</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class HomeEnterGuideDailyLimiter extends BaseFatigueLdbDailyLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected String scene() {</span></code><code><span class="code-snippet_outer">        return LimiterScene.homeEnterGuide;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 首頁入口引導限時任務-總次數疲勞度管控</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class HomeEnterGuideNoCycleLimiter extends BaseFatigueLdbNoCycleLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected String scene() {</span></code><code><span class="code-snippet_outer">        return LimiterScene.homeEnterGuide;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected int maxSize() {</span></code><code><span class="code-snippet_outer">        return 3;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 首頁入口引導限時任務-疲勞度服務</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class HomeEnterGuideLimiter implements FatigueLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private FatigueLimiter homeEnterGuideDailyLimiter;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private FatigueLimiter homeEnterGuideNoCycleLimiter;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public boolean isLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        return homeEnterGuideNoCycleLimiter.isLimit(customKey) || homeEnterGuideDailyLimiter.isLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public Integer incrLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        homeEnterGuideDailyLimiter.incrLimit(customKey);</span></code><code><span class="code-snippet_outer">        return homeEnterGuideNoCycleLimiter.incrLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public boolean isLimit(Integer fatigue) {</span></code><code><span class="code-snippet_outer">        throw new UnsupportedOperationException();</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public Map&lt;String, Integer&gt; batchQueryLimit(List&lt;String&gt; keys) {</span></code><code><span class="code-snippet_outer">        throw new UnsupportedOperationException();</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public void removeLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        homeEnterGuideDailyLimiter.removeLimit(customKey);</span></code><code><span class="code-snippet_outer">        homeEnterGuideNoCycleLimiter.removeLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public Integer queryLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        throw new UnsupportedOperationException();</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 查詢首頁限時任務的每日疲勞度</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param customKey 用戶自定義 key</span></code><code><span class="code-snippet_outer">     * @return 疲勞度計數</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public Integer queryDailyLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        return homeEnterGuideDailyLimiter.queryLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 查詢首頁限時任務的全週期疲勞度</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param customKey 用戶自定義 key</span></code><code><span class="code-snippet_outer">     * @return 疲勞度計數</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public Integer queryNoCycleLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        return homeEnterGuideNoCycleLimiter.queryLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><span id="OSC_h4_7"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">函數式行為參數化</span></strong></span></h4><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"></h4><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">Java 21 在今年 9 月份發佈了，而距離 Java 8 發佈已經過去 9 年多了，但也許，我是説也許......我們有些同學對 Java 8 還是不太熟悉......</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_8"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">再談行為參數化</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">最早聽到「行為參數化」這個詞是在經典的 Java 技術書籍《Java 8 實戰》中。在此書中，作者以一個篩選蘋果的案例，基於行為參數化的思維一步步優化重構代碼，在提升代碼抽象能力的同時，保證了代碼的簡潔性和可讀性，而其中的祕密武器就是 Java 8 所引入的 Lambda 表達式和函數式接口。Java 8 發佈已經 9 年，對於 Lambda 表達式，大多數同學都已經耳熟能詳，但函數式接口也許有同學不知道代表着什麼。簡單來説，如果一個接口，它只有一個沒有被實現的方法，那它就是函數式接口。java.lang.function 包下定義 JDK 提供的一系列函數式接口。如果一個接口是函數式接口，推薦用@FunctionalInterface 註解來顯式標明。那函數式接口有什麼用呢？如果一個方法的行參裏有函數式接口，那麼函數式接口對應的參數可以支持傳遞 Lambda 表達式或者方法引用。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">那何為「行為參數化」？直觀地來説就是將行為作為方法/函數的參數來進行傳遞。在 Java 8 之前，這可以通過匿名類實現，而在 Java 8 以後，可以基於函數式特性來實現行為參數化，即方法參數定義為函數式接口，在具體傳參時使用 Lambda 表達式/方法。相比匿名類，後者在簡潔性上有極大的提升。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">在我們的日常開發中，如果我們看到兩個方法的結構十分相似，只有其中部分行為存在差別，那麼就可以考慮採用函數式的行為參數化來重構優化這段代碼，將其中存在差異的行為抽象成參數，從而減少重複代碼。</span></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_9"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">從實踐中來，到代碼中去</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">下面給出一個例子。在靜心守護項目中，我們基於 ldb 維護了用戶未讀成就的列表，在用戶進入到個人成就頁時，會查詢未讀成就數據，並對未讀的成就在成就列表進行置頂以及加紅點展示。下面是對用戶未讀成就列表進行新增和清除的兩個方法：</span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 清除未讀成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid             用戶 ID</span></code><code><span class="code-snippet_outer"> * @param achievementType 需要清除未讀成就列表的成就類型</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean clearUnreadAchievements(long uid, Set&lt;String&gt; achievementTypes) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (CollectionUtils.isEmpty(achievementTypes)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    Result&lt;DataEntry&gt; ldbRes = super.rawGet(buildKey(uid), false);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //用戶稱號數據查詢失敗</span></code><code><span class="code-snippet_outer">    if (Objects.isNull(ldbRes)) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">        return false;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    boolean success = false;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ResultCode resultCode = ldbRes.getRc();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //不存在用戶稱號數據則進行初始化</span></code><code><span class="code-snippet_outer">    if (Objects.equals(resultCode, ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer">    UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">        achievementTypes.forEach(type -&gt; clearCertainTypeIds(userUnreadAchievementsCache, type));</span></code><code><span class="code-snippet_outer">        success = putCache(uid, userUnreadAchievementsCache, DEFAULT_VERSION);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    } else if (Objects.equals(resultCode, ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        DataEntry ldbEntry = ldbRes.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //存在新數據則對其進行更新</span></code><code><span class="code-snippet_outer">        if (Objects.nonNull(ldbEntry)) {</span></code><code><span class="code-snippet_outer">            Object data = ldbEntry.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            if (data instanceof String) {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = JSON.parseObject(String.valueOf(data), UserUnreadAchievementsCache.class);</span></code><code><span class="code-snippet_outer">                achievementTypes.forEach(type -&gt; clearCertainTypeIds(userUnreadAchievementsCache, type))</span></code><code><span class="code-snippet_outer">                success = putCache(uid, userUnreadAchievementsCache, ldbEntry.getVersion());</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    //緩存解鎖的稱號失敗</span></code><code><span class="code-snippet_outer">    if (!success) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    return success;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 寫入新的未讀成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid                  用戶 ID</span></code><code><span class="code-snippet_outer"> * @param achievementTypeIdMap 需要新增的成就類型和成就 ID 列表的映射</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean writeUnreadAchievements(long uid, Map&lt;String, List&lt;String&gt;&gt; achievementTypeIdMap) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (MapUtils.isEmpty(achievementTypeIdMap)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    Result&lt;DataEntry&gt; ldbRes = super.rawGet(buildKey(uid), false);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //用戶稱號數據查詢失敗</span></code><code><span class="code-snippet_outer">    if (Objects.isNull(ldbRes)) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">        return false;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    boolean success = false;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ResultCode resultCode = ldbRes.getRc();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //不存在用戶稱號數據則進行初始化</span></code><code><span class="code-snippet_outer">    if (Objects.equals(resultCode, ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer">    UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">        achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(userUnreadAchievementsCache, key, value));</span></code><code><span class="code-snippet_outer">        success = putCache(uid, userUnreadAchievementsCache, DEFAULT_VERSION);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    } else if (Objects.equals(resultCode, ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        DataEntry ldbEntry = ldbRes.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //存在新數據則對其進行更新</span></code><code><span class="code-snippet_outer">        if (Objects.nonNull(ldbEntry)) {</span></code><code><span class="code-snippet_outer">            Object data = ldbEntry.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            if (data instanceof String) {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = JSON.parseObject(String.valueOf(data), UserUnreadAchievementsCache.class);</span></code><code><span class="code-snippet_outer">                achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(oldCache, key, value));</span></code><code><span class="code-snippet_outer">                success = putCache(uid, userUnreadAchievementsCache, ldbEntry.getVersion());</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    //緩存解鎖的稱號失敗</span></code><code><span class="code-snippet_outer">    if (!success) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    return success;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">從結構上看，上面兩段代碼其實是非常類似的：整個結構都是先判空，然後查詢歷史的未讀成就數據，如果數據未初始化，則進行初始化，如果已經初始化，則對數據進行更新。只不過寫入/清除對數據的初始化和更新邏輯並不相同。因此可以將數據初始化和更新抽象為行為參數，將剩餘部分提取為公共方法，基於這樣的思路重構後的代碼如下：</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 創建 or 更新緩存</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid               用戶 ID</span></code><code><span class="code-snippet_outer"> * @param initCacheSupplier 緩存初始化策略</span></code><code><span class="code-snippet_outer"> * @param updater           緩存更新策略</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">private boolean upsertCache(long uid, Supplier&lt;UserUnreadAchievementsCache&gt; initCacheSupplier,</span></code><code><span class="code-snippet_outer">                            Function&lt;UserUnreadAchievementsCache, UserUnreadAchievementsCache&gt; updater) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    Result&lt;DataEntry&gt; ldbRes = super.rawGet(buildKey(uid), false);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //用戶稱號數據查詢失敗</span></code><code><span class="code-snippet_outer">    if (Objects.isNull(ldbRes)) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">        return false;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    boolean success = false;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ResultCode resultCode = ldbRes.getRc();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //不存在用戶稱號數據則進行初始化</span></code><code><span class="code-snippet_outer">    if (Objects.equals(resultCode, ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        UserUnreadAchievementsCache userUnreadAchievementsCache = initCacheSupplier.get();</span></code><code><span class="code-snippet_outer">        success = putCache(uid, userUnreadAchievementsCache, DEFAULT_VERSION);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    } else if (Objects.equals(resultCode, ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        DataEntry ldbEntry = ldbRes.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //存在新數據則對其進行更新</span></code><code><span class="code-snippet_outer">        if (Objects.nonNull(ldbEntry)) {</span></code><code><span class="code-snippet_outer">            Object data = ldbEntry.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            if (data instanceof String) {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = JSON.parseObject(String.valueOf(data), UserUnreadAchievementsCache.class);</span></code><code><span class="code-snippet_outer">                userUnreadAchievementsCache = updater.apply(userUnreadAchievementsCache);</span></code><code><span class="code-snippet_outer">                success = putCache(uid, userUnreadAchievementsCache, ldbEntry.getVersion());</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    //緩存解鎖的稱號失敗</span></code><code><span class="code-snippet_outer">    if (!success) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    return success;</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 寫入新的未讀成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid                  用戶 ID</span></code><code><span class="code-snippet_outer"> * @param achievementTypeIdMap 需要新增的成就類型和成就 ID 列表的映射</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean writeUnreadAchievements(long uid, Map&lt;String, List&lt;String&gt;&gt; achievementTypeIdMap) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (MapUtils.isEmpty(achievementTypeIdMap)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    return upsertCache(uid,</span></code><code><span class="code-snippet_outer">            () -&gt; {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">                achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(userUnreadAchievementsCache, key, value));</span></code><code><span class="code-snippet_outer">                return userUnreadAchievementsCache;</span></code><code><span class="code-snippet_outer">            },</span></code><code><span class="code-snippet_outer">            oldCache -&gt; {</span></code><code><span class="code-snippet_outer">                achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(oldCache, key, value));</span></code><code><span class="code-snippet_outer">                return oldCache;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">    );</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 清除未讀成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid             用戶 ID</span></code><code><span class="code-snippet_outer"> * @param achievementType 需要清除未讀成就列表的成就類型</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean clearUnreadAchievements(long uid, Set&lt;String&gt; achievementTypes) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (CollectionUtils.isEmpty(achievementTypes)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    return upsertCache(uid,</span></code><code><span class="code-snippet_outer">            () -&gt; {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">                achievementTypes.forEach(type -&gt; clearCertainTypeIds(userUnreadAchievementsCache, type));</span></code><code><span class="code-snippet_outer">                return userUnreadAchievementsCache;</span></code><code><span class="code-snippet_outer">            },</span></code><code><span class="code-snippet_outer">            oldCache -&gt; {</span></code><code><span class="code-snippet_outer">                achievementTypes.forEach(type -&gt; clearCertainTypeIds(oldCache, type));</span></code><code><span class="code-snippet_outer">                return oldCache;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">    );</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">重構的核心是提取了 upsert 方法，該方法將緩存數據的初始化和更新策略以函數式接口進行定義，從而支持從調用側進行透傳，避免了模板方法的重複編寫。這是一個拋磚引玉的例子，在日常開發中，我們可以更多地嘗試用函數式編程的思維去思考和重構代碼，也許會發現另一個神奇的編程世界。</span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><span id="OSC_h4_10"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">切面編程的一些實踐</span></strong></span></h4><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">AOP 想必大家都已經十分熟悉了，在此便不再贅述其基本概念，而是開門見山直接分享一些 AOP 在靜心守護項目中的實際應用。</span></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_11"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">服務層異常統一收口</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">靜心守護項目採用了在阿里系統中常用的 service-manager-dao 的分層模式，其中 service 層是距離終端最近的一層。為了防止下層預期外的異常拋到終端，我們需要在 service 層對異常進行統一攔截並且記錄，同時最好將相關的錯誤碼、請求參數以及 traceId 都一併記下，便於問題排查。這個場景就非常適合使用 AOP。在引入 AOP 之前，我們需要對每個 service 中面向終端的方法都進行異常攔截和監控日誌打印的操作。比方説下面這個類，它有 3 個面向終端 mtop【注：阿里內部自研的 API 網關平台】服務的方法（api 具體參數和名稱做了模糊化處理），這 3 個方法都採用了同樣的 try-catch 結構來進行異常捕捉和監控日誌打印，其中存在大量的重複代碼，而更糟糕的事，如果後續增加新的方法，這樣的重複代碼還會不斷增加。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">@HSFProvider(serviceInterface = MtopBlessHomeService.class)</span></code><code><span class="code-snippet_outer">public class MtopBlessHomeServiceImpl implements MtopBlessHomeService {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //依賴的 bean 注入</span></code><code><span class="code-snippet_outer">  ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceAVO&gt; entranceA(EntranceARequest request) {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(request.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            //該入口下的業務邏輯</span></code><code><span class="code-snippet_outer">            ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceA", buildMethodParamsStr(request), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceA", buildMethodParamsStr(request), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceBVO&gt; entranceB(EntranceBRequest request) {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(request.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            //該入口下的業務邏輯</span></code><code><span class="code-snippet_outer">            ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceB", buildMethodParamsStr(request), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceB", buildMethodParamsStr(request), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceCVO&gt; entranceC(EntranceCRequest request) {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(query.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            //該入口下的業務邏輯</span></code><code><span class="code-snippet_outer">            ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceC", buildMethodParamsStr(request), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceC", buildMethodParamsStr(request), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }    </span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">看到這樣重複的代碼結構而只是局部行為的不同，也許我們可以考慮着用上一節的函數式行為參數化進行重構：將重複的代碼結構抽取為公共的工具方法，將對 manager 層的調用抽象為行為參數。但在上述場景下，這種做法還是存在一些弊端：</span><ne-clipboard source="https%3A%2F%2Faliyuque.antfin.com%2Flingye.jly%2Fwozrkc%2Fitpnoh733usxcgzk%3FsingleDoc%23r1wtn"></ne-clipboard></section><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">每個服務的方法還是需要顯式調用工具類方法</span></p></li><li><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">為了保證監控信息的齊全，還需要在參數裏手動透傳一些監控相關的信息</span></p></li></ol><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">而 AOP 則不存在這些問題：AOP 基於動態代理實現，在實現上述邏輯時對服務層的代碼編寫完全透明。此外，AOP 還封裝了調用端方法的各種元信息，可以輕鬆實現各種監控信息的自動化打印。下面是我們提供的 AOP 切面。其中值得注意的點是切點的選擇要儘量準確，避免增強了不必要的方法。下面我們選擇的切點是 mtop 包下所有 Impl 結尾類的 public 方法。</span></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer">@Aspect</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">public class MtopServiceAspect {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * MtopService 層服務</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    @Pointcut("execution(public com.taobao.mtop.common.MtopResult com.taobao.gaia.veyron.bless.service.mtop.*Impl.*(..))")</span></code><code><span class="code-snippet_outer">    public void mtopService(){}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 對 mtop 服務進行增強</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param pjp 接入點</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     * @throws Throwable</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    @Around("com.taobao.gaia.veyron.bless.aspect.MtopServiceAspect.mtopService()")</span></code><code><span class="code-snippet_outer">    public Object enhanceService(ProceedingJoinPoint pjp) throws Throwable {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(pjp);</span></code><code><span class="code-snippet_outer">            return pjp.proceed();</span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    AspectUtils.extractMethodName(pjp), buildMethodParamsStr(pjp), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    AspectUtils.extractMethodName(pjp), buildMethodParamsStr(pjp), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">存在這樣一個切面後，service 層的代碼就可以變得非常簡潔：只需要純粹專注於業務邏輯。同樣以剛才的 MtopBlessHomeServiceImpl 類為例，在 AOP 改寫後的代碼裏可以去除掉原先異常收口和監控相關的內容，而僅保留業務邏輯部分，代碼簡潔性大大提升。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">@HSFProvider(serviceInterface = MtopBlessHomeService.class)</span></code><code><span class="code-snippet_outer">public class MtopBlessHomeServiceImpl implements MtopBlessHomeService {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //依賴的 bean 注入</span></code><code><span class="code-snippet_outer">  ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceAVO&gt; entranceA(EntranceARequest request) {</span></code><code><span class="code-snippet_outer">        //業務邏輯</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceBVO&gt; entranceB(EntranceBRequest request) {</span></code><code><span class="code-snippet_outer">        //業務邏輯</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceCVO&gt; entranceC(EntranceCRequest request) {</span></code><code><span class="code-snippet_outer">        //業務邏輯</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_12"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">切點選擇的策略</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">除了服務層以外，我們還想對數據訪問層進行監控，監控項目中各種數據存儲工具的 RT 以及成功率相關指標，並且監控粒度要儘可能地貼近業務維度（整體的數據訪問監控直接通過 eagleeye 查看即可），便於具體問題的定位排查。這種面向層級別的邏輯定製，我們很自然而然地想到了 AOP，這也正是它可以大顯身手的場景。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">這節核心想要分享的則是切點的選擇。靜心守護項目的數據存儲主要依賴於 Tair【注：阿里內部自研的高性能 K-V 存儲系統。根據存儲介質和使用場景不同又分為 LDB、MDB、RDB】、Lindorm【注：阿里內部自研的大規模雲原生多模數據庫服務】和 Mysql，這三種存儲工具在代碼中的使用各不相同，導致切點的選擇策略也大相徑庭。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><span id="OSC_h4_13"></span><h4 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">目標對象規律分佈</span></h4><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">如果我們要選擇增強的對象在項目中分佈的非常規律，那麼我們往往可以直接利用 Spring AOP 的 PointCut 語法來選擇切點。以靜心守護項目中的 Mysql 數據訪問對象為例：我們使用的 ORM 框架是 mybatis，並且主要的用法是註解模式，所有的 SQL 邏輯都放在一個 DAO 包下，每個業務場景定義一個 DAO 結尾的 Mapper 接口，接口下的每個方法都對應着一種數據訪問的方式。因此在切點選擇時，我們可以直接選擇 DAO 包下以 DAO 結尾的類，並選擇其中 public 方法即可準確織入所有滿足條件的切點。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Pointcut("execution(public * com.taobao.gaia.serverless.veyron.bless.dao.*DAO.*(..))")</span></code><code><span class="code-snippet_outer">public void charityProjectDataAccess() {</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">這樣實現的監控粒度是具體到每個 DAO 對象-方法級別的粒度，監控效果如下：</span></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: center;margin-bottom: 8px;"><img class="rich_pages wxw-img" data-backh="240" data-backw="578" data-imgfileid="503041786" data-ratio="0.41574074074074074" src="https://oscimg.oschina.net/oscnet/353e7a8a-57f3-48a6-938b-7033c6681775.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><span id="OSC_h4_14"></span><h4 style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">一個失效案例</span></h4><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">靜心守護項目中對 tair 的使用方式是：通過一個抽象類對 tair 的各種基礎操作進行封裝（包括參數校驗、響應判空、異常處理等），但將具體 tair 實例相關的參數設置行為抽象化，由實現類決定。各個業務場景的 tair 管理類最終會基於抽象類封裝的基礎操作來對 tair 進行數據訪問</span><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">。</span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><br></span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">如下圖，AbstractLdbManager 是封裝</span></section><section style="min-height: 24px;text-align: center;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041787" data-ratio="0.8398148148148148" src="https://oscimg.oschina.net/oscnet/7d5fa225-7c35-4cf3-97cd-8a6d1de235a5.png" data-type="png" data-w="1080" referrerpolicy="no-referrer"></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">由於各個業務場景的 tair 管理實現類分散在各個業務包下，想要對它們進行統一切入比較困難。因此我們選擇對抽象類進行切入。但這樣就會遇到一個同類調用導致 AOP 失效的問題：抽象類本身不會有實例對象，因此基於 CGLIB 創建代理對象後，代理對象本質上調用的還是各個業務場景 tair 管理類的對象，而在使用這些對象時，我們不會直接調用 tair 抽象類封裝的數據訪問方法，而是調用這些業務 tair 管理對象進一步封裝的帶業務語義的方法，基於這些方法再去調用 tair 抽象類的數據訪問方法。這種同類方法間接調用最終就導致了抽象類的方法沒有如期被增強。文字描述興許有些繞，可以參考下面的圖：</span></p><p style="min-height: 24px;text-align: center;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041815" data-ratio="0.5935185185185186" src="https://oscimg.oschina.net/oscnet/a7f4daeb-a6c6-430b-9ace-50ffd3b87165.png" data-type="png" data-w="1080" style="letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" width="536" referrerpolicy="no-referrer"></span></p><section style="min-height: 24px;text-align: justify;margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">我們選擇的解決方法則是從上面的 MultiClusterTairManager 入手，這個類是 tair 為我們提供的 TairManger 的一種默認實現，我們之前的做法是為該類實例化一個 bean，然後提供給所有業務 Tair 管理類使用，也就是説所有業務 Tair 管理類使用的 TairManager 都是同一個 bean 實例（因為業務流量沒那麼大，一個 tair 實例暫時綽綽有餘）。那麼我們可以自己提供一個 TairManager 的實現，基於繼承+組合 MultiClusterTairManager 的方式，只對我們項目內用到數據訪問操作進行重寫，並委託給原先的 MultiClusterTairManager bean 進行處理。這樣我們可以在設置 AOP 切點時選擇對自己實現的 TairManager 的所有方法做增強，進而避開上面的問題。經過這樣改寫後，上面的兩張圖會演變成下面這樣：</span></p><section style="min-height: 24px;text-align: center;margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><img class="rich_pages wxw-img" data-imgfileid="503041811" data-ratio="0.5935185185185186" src="https://oscimg.oschina.net/oscnet/a7f4daeb-a6c6-430b-9ace-50ffd3b87165.png" data-type="png" data-w="1080" width="536" referrerpolicy="no-referrer"></section><p style="min-height: 24px;text-align: justify;margin-bottom: 8px;line-height: 1.75em;margin-top: 8px;"><span style="letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041816" data-ratio="0.37407407407407406" src="https://oscimg.oschina.net/oscnet/dcaa95ab-35fe-49ef-8fb6-087473b0f061.png" data-type="png" data-w="1080" referrerpolicy="no-referrer"></span><br></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><span id="OSC_h4_15"></span><h4 style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">基於註解切入</span></h4><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">還有一種場景是我們要增強的方法分佈毫無規律，可能都在同一個類中，但方法的名稱毫無規律，也無法簡單通過 private 或者 public 來區別。針對這樣的場景，我們的做法是自定義註解，專門用於標識需要做增強的方法。比如靜心守護項目中 lindorm 相關的數據操作就是這樣。我們定義註解：</span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="css"><code><span class="code-snippet_outer">@<span class="code-snippet__keyword">Target</span>({<span class="code-snippet__selector-tag">ElementType</span><span class="code-snippet__selector-class">.METHOD</span>})</span></code><code><span class="code-snippet_outer">@<span class="code-snippet__keyword">Retention</span>(<span class="code-snippet__keyword">RetentionPolicy</span>.<span class="code-snippet__keyword">RUNTIME</span>)</span></code><code><span class="code-snippet_outer">@Documented</span></code><code><span class="code-snippet_outer">public @interface VeyronJoinPoint {}</span></code></pre></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">並將該註解標識在需要增強的方法上，隨後通過下面的方式描述切點，即可獲取到所有需要增強的方法。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="css"><code><span class="code-snippet_outer">@<span class="code-snippet__keyword">Pointcut</span>("@<span class="code-snippet__keyword">annotation</span>(<span class="code-snippet__keyword">com</span>.<span class="code-snippet__keyword">taobao</span>.<span class="code-snippet__keyword">gaia</span>.<span class="code-snippet__keyword">serverless</span>.<span class="code-snippet__keyword">veyron</span>.<span class="code-snippet__keyword">aspect</span>.<span class="code-snippet__keyword">VeyronJoinPoint</span>)")</span></code><code><span class="code-snippet_outer">public void lindormDataAccess() {}</span></code></pre></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">上面的方法也有進一步改良的空間：在註解內增加屬性來描述具體的業務場景，不同的切面根據業務場景來對捕獲的方法進行過濾，只留下當前業務場景所需要的方法。不然按照現有的做法，如果新的切面也要基於註解來尋找切點，那隻能定義新的註解，否則會與原先註解產生衝突。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;visibility: visible;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><img class="rich_pages wxw-img" data-imgfileid="503041834" data-ratio="0.3056872037914692" data-s="300,640" data-type="png" data-w="422" src="https://oscimg.oschina.net/oscnet/18f51c34-a896-48a4-b5c4-e2bfd339953f.png" style="outline: 0px;letter-spacing: 0.544px;font-size: 14px;visibility: visible !important;width: 117px !important;" referrerpolicy="no-referrer"></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;visibility: visible;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;color: rgb(0, 17, 255);">總結</span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">業務需求千變萬化，對應的解法也見仁見智。在研發過程中對各種變化中不變的部分進行總結，從中提取出自己的模式與方法論進行整理沉澱，會讓我們以後跑的更快。也正應了學生時期，老師常説的那句話：「我們要把厚厚的書本讀薄才能裝進腦子裏。」</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">最後，如果大家有好的實踐模式推薦或者建議，歡迎在評論區分享交流～</span></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><p style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><img class="rich_pages wxw-img" data-imgfileid="503041835" data-ratio="0.328125" data-s="300,640" data-type="png" data-w="256" src="https://oscimg.oschina.net/oscnet/5749e182-ccf0-448e-af95-1df19ffdd6a8.png" style="outline: 0px;letter-spacing: 0.544px;font-size: 16px;visibility: visible !important;width: 122px !important;" referrerpolicy="no-referrer"></p><p style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(100, 99, 99);font-size: 15px;text-align: center;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 1px;font-size: 18px;color: rgb(0, 17, 255);">團隊介紹</span></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">我們是淘天業務技術用戶消息與社交團隊，負責淘寶消息、客服、Push、分享、我淘、關係、社交互動等業務，涵蓋淘寶 APP 中兩個一級 Tab，第三個消息 tab 和第五個我的淘寶 tab，這裏有一流的產品技術，為消費者提供更好的消息與社交服務；豐富的業務場景，為淘系業務增加助力；幾十萬 QPS 的高併發流量，可以與淘系各位技術大牛合作，思想激盪碰撞，共同提升，包含以下方向：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">在淘寶 IM 基礎上構建以用戶實時意圖感知、統一投放引擎為核心的全域觸達體系，通過跨場景的觸達方案，賦能淘系搜索、互動、用增等業務增長，每日觸達億級用戶。</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">社交域基礎平台服務，我的淘寶、淘友、互動等業務，服務上億淘寶用戶。</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">淘寶消息 tab、千牛商家消息，通過建立平台，消費者，商家之間的鏈接，提升手淘 DAU，助力商家更好的服務消費者，擁有億級電商 IM 消息即時通訊產品，可以深入掌握分佈式高可靠設計理念和架構方法論。</span></p></li></ol><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">招聘持續火熱🔥進行中，如果有興趣可將簡歷發至 lingye.jly@taobao.com，期待您的加入！</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section data-role="outer" label="Powered by 135editor.com" style="margin-bottom: 0px;outline: 0px;letter-spacing: 0.544px;visibility: visible;"><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;word-break: break-all;color: rgb(0, 0, 0);font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;text-align: center;line-height: 1.75em;"><span style="outline: 0px;color: rgb(0, 17, 255);"><strong style="outline: 0px;">¤</strong></span><span style="outline: 0px;"><strong style="outline: 0px;">&nbsp;拓展閲讀&nbsp;</strong></span><span style="outline: 0px;color: rgb(0, 17, 255);"><strong style="outline: 0px;">¤</strong></span></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;word-break: break-all;color: rgb(0, 0, 0);font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;text-align: center;line-height: 1.75em;"><br style="outline: 0px;"></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;min-height: 24px;clear: both;visibility: visible;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D2565944923443904512%23wechat_redirect" textvalue="3DXR 技術" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">3DXR 技術</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1533906991218294785%23wechat_redirect" textvalue="終端技術" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">終端技術</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1592015847500414978%23wechat_redirect" textvalue="音視頻技術" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">音視頻技術</a></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;visibility: visible;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1539610690070642689%23wechat_redirect" textvalue="服務端技術" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">服務端技術</a><span style="outline: 0px;letter-spacing: 0.544px;">&nbsp;|&nbsp;</span><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D2565883875634397185%23wechat_redirect" textvalue="技術質量" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">技術質量</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1522425612282494977%23wechat_redirect" textvalue="數據算法" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">數據算法</a></section><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;visibility: visible;"><br style="outline: 0px;"></p><section class="mp_profile_iframe_wrp" style="margin-bottom: 24px;outline: 0px;"><mp-common-profile class="custom_select_card mp_profile_iframe js_wx_tap_highlight" data-pluginname="mpprofile" data-id="MzAxNDEwNjk5OQ==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/33P2FdAnju8t5nZGhAatCrc4e2iaDfAaoInribRKxc7MOqdTGygfcLqSDxhj0trCHVEh94Sjl7zuWYzwouYtJ0VQ/300?wx_fmt=png&amp;wxfrom=19" data-nickname="大淘寶技術" data-alias="AlibabaMTT" data-signature="大淘寶技術官方賬號" data-from="2" data-index="0" data-origin_num="685" data-isban="0" data-weuitheme="light" data-biz_account_status="0" data-is_biz_ban="0"></mp-common-profile><span style="outline: 0px;color: rgb(0, 0, 0);font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 1px;"></span></section></section><section style="line-height: 1.75em;"><section style="display: none;line-height: 1.75em;"><br></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公眾號 - 大淘寶技術（AlibabaMTT）。<br>如有侵權，請聯繫 support@oschina.cn 刪除。<br>本文參與「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源創計劃</a>」，歡迎正在閲讀的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 02:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4662964/blog/10555462</guid>
            <link>https://my.oschina.net/u/4662964/blog/10555462</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[最新桌面瀏覽器市場份額排名：Edge 重回第二、Safari 跌破 10%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>知名流量監測機構 Statcounter 公佈了 2023 年&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgs.statcounter.com%2Fbrowser-market-share%2Fdesktop%2Fworldwide" target="_blank">12 月份全球桌面瀏覽器市場份額</a>：</p><p><img src="https://static.oschina.net/uploads/space/2024/0102/101516_FTqQ_2720166.png" referrerpolicy="no-referrer"></p><p>主要數據如下：</p><ul><li><strong>Chrome：65.29%</strong></li><li><strong>Edge：<span>11.89%</span></strong></li><li><strong>Safari：<span>8.92%</span></strong></li><li>Firefox：7.61%</li><li>Opera：3.8%</li><li>360 Safe：0.71%</li><li>……</li></ul><p><img height="720" src="https://oscimg.oschina.net/oscnet/up-da555d51c704e0a59cad47fb01d30a6da9f.png" width="1280" referrerpolicy="no-referrer"></p><p>2023 年 5 月，Safari <u><a href="https://www.oschina.net/news/240186/statcounter-safari-edge">以微弱優勢超過 Edge </a></u>成為全球市場份額排名第二的桌面瀏覽器。此後幾個月也一直穩坐第二，然而沒想到 Edge 在 2023 年最後一個月來了一波大反殺——要知道 11 月 Safari 的市場份額仍有 13%，比 Edge 的 11% 高出兩個點。</p><p><img src="https://oscimg.oschina.net/oscnet/up-729990e5f76ed08ac6344603617f319861c.png" referrerpolicy="no-referrer"></p><p>然而在 12 月，Safari 的市場份額急劇下降，直接跌破 10%——只剩&nbsp;<span>8.92%。</span>目前尚無信息顯示 Safari 市場份額暴跌的背後原因。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 02:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273741/statcounter-edge-202312</guid>
            <link>https://www.oschina.net/news/273741/statcounter-edge-202312</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[openKylin 1.0 成功適配 Inte l 最新 x86 平台 Raptor Lake 系列]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify">2023 年 12 月 25 日，openKylin 1.0 成功適配 Intel（英特爾）最新 x86 平台 Raptor Lake 系列，與國際 OSV 同步。</p><div><p style="text-align:center"><img alt="" height="410" src="https://oscimg.oschina.net/oscnet/up-fcdea1508a9a5937b9f83fbef89e66a1b9e.png" width="940" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">Intel 中國公司在 2023 年 11 月加入 openKylin 社區之後，成立了 Intel SIG 並與 openKylin 社區開展合作，經過 Intel SIG 團隊成員的努力，目前 openKylin 1.0 操作系統已成功適配第 13/14 代 Intel 客戶端平台，Raptor Lake 系列，以及 ADL-N（12 代 refresh）。具體機型如下所示：</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">1.支持 Intel 最新 13/14 代 CPU 型號；</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">2.支持 Intel ADL-N, RPL-S,RPL-P, RPL-U, RPL-HX 等最新平台；</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">3.支持相關 OEM 惠普，聯想等基於 Intel13 代機的相關機型。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">測試期間，openKylin 1.0 操作系統在以上 Intel 開發機平台上整體運行穩定，功能、性能及兼容性方面表現良好。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">Raptor Lake 是 Intel 基於混合架構的第 13 代和第 14 代 Intel 酷睿處理器的代號，採用 Raptor Cove 性能核心和 Gracemont 效率核心。與 Alder Lake 一樣，Raptor Lake 也是使用 Intel 的 Intel 7 工藝製造的。Raptor Lake 具有多達 24 個核心（8 個性能核心加 16 個效率核心）和 32 個線程，並且與 Alder Lake 系統（LGA 1700、BGA1744、BGA1964）兼容。與前幾代一樣，Raptor Lake 處理器也需要配套的芯片組。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">目前，Intel SIG 共完成 6.1 Kernel 合併 Intel 最新平台支持補丁 110 多個, 包括最新圖形，聲音，藍牙，無線，電源管理，網絡，串口，多媒體等硬件的支持。同時 linux-firmware 合併 Intel 最新平台支持補丁 170 多個，包括 Intel 最新顯卡，無線網卡，藍牙，聲音等的硬件固件支持。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">未來，Intel 將持續與 openKylin 社區開展深入合作，推動 openKylin 操作系統適配更多的 Intel 最新平台，並不斷優化和完善其應用體驗，共同推動 openKylin 開源操作系統的普及和國產開源生態的打造，助力 openKylin 開源生態佈局進一步完善。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 01:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273735</guid>
            <link>https://www.oschina.net/news/273735</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[回顧 30 年前的 IDE：只有 TUI、背景顏色亮瞎眼……]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>當談到 30 年前的集成開發環境 (IDE)，純文本模式大行其道。在 20 世紀 80 年代末/90 年代初，DOS 操作系統上的 IDE 都是<strong>基於文本用戶界面 (TUI)</strong>。這些 IDE 雖然沒有圖形界面，但卻提供了一些令人印象深刻的功能，讓程序員們能夠進行編碼、編譯和調試他們的程序。</p><p>比如 MS-DOS 自帶的編輯器 EDIT.COM。這是一個全屏 TUI 編輯器，提供了菜單欄、對話框、狀態欄等功能。雖然不太適合編碼，但它展示了當時的技術水平。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-5028193deeef003d71722a0e0206c7cba5a.png" referrerpolicy="no-referrer"></p><p>另一個經典的 IDE 是 Borland Turbo 系列，比如 Turbo C++。這些 IDE 提供了語法高亮、編譯器集成、調試器、項目管理等功能，甚至還有完整的參考手冊。這些功能在當時來説非常先進，讓程序員們能夠在沒有互聯網的情況下完成整個開發過程。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-88e0ddd9805e24b5d3fab4b5e6479936743.png" referrerpolicy="no-referrer"></p><p><em>（語法高亮）</em></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0b6a07d4eff9299bbe1994abb4e8e822709.png" referrerpolicy="no-referrer"></p><p><em>（集成編譯器和診斷）</em></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0d05a776e3a60a221c7cbec17db45f81932.png" referrerpolicy="no-referrer"></p><p><em>（集成項目和構建系統管理）</em></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-93863267f7c7ff62eff8100b50b2e2bd32e.png" referrerpolicy="no-referrer"></p><p><em>（包含斷點、堆棧跟蹤等功能的調試器）</em></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-bf6c8d95bd4f5f049c98cbaf4a30987ad5d.png" referrerpolicy="no-referrer"></p><p><em>（完整的使用手冊）</em></p><p>有人表示，Bordland 在當時出品的 IDE 確實十分驚豔，但在使用 Bordland Turbo C++ 一段時間後，眼睛都要被亮瞎了……</p><p>與此同時，Linux 上的 IDE 並不如 DOS 上的 IDE 那麼成熟。雖然也有一些文本模式的程序，比如 Vim 和 Emacs，但它們並不像 Borland Turbo 系列那樣提供完整的集成開發環境。這導致了在當時許多程序員還是更傾向於使用 DOS 上的 IDE 進行開發。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-affdf2cf4e49f6240d455b0ad65df6324d2.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 03:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273632/the-ides-we-had-30-years-ago</guid>
            <link>https://www.oschina.net/news/273632/the-ides-we-had-30-years-ago</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[盤點 2023 十大宕機事故「冥場面」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>名場面？冥場面！</p><p>速來圍觀 2023 十大宕機事故「冥場面」——</p><hr><h1><a href="https://www.oschina.net/news/231236" target="_blank">嗶哩嗶哩（B 站）崩了兩次</a></h1><p>2023 年 3 月 5 日晚 20:20 左右，許多網友表示在使用 B 站時，手機和電腦端都無法訪問視頻詳情頁，且手機端無法查看收藏夾與歷史記錄。還有網友表示，首頁能夠正常加載，但全部是繁體字。</p><p><img src="https://oscimg.oschina.net/oscnet/up-affa896050135c6a15c206de322a4e28acc.png" referrerpolicy="no-referrer"></p><p><u><a href="https://www.oschina.net/news/252405">8 月 4 日晚間</a></u>，距離上次事故 5 個月後，又有許多網友反饋 B 站圖片（視頻封面）無法加載、視頻無法打開、視頻一直在緩衝。</p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/236219" target="_blank">騰訊「3.29」一級事故</a></h1><p>2023 年 3 月 29 日凌晨，騰訊旗下的微信和 QQ 等業務曾出現崩潰狀況，包括微信語音對話、朋友圈、微信支付，以及 QQ 文件傳輸、QQ 空間和 QQ 郵箱在內的多個功能無法使用。</p><p>直到 29 日早間，騰訊微信團隊才回應表示，經工程師搶修，系統正在逐步恢復。</p><p><img src="https://oscimg.oschina.net/oscnet/up-127213d84c63650497a340914182c4a89f9.png" referrerpolicy="no-referrer"></p><p>本次事故由廣州電信機房冷卻系統故障導致，騰訊將它定義為公司一級事故，並對大量相關領導做出了處罰。</p><p>4 月 12 日，工業和信息化部信息通信管理局<u><a href="https://www.oschina.net/news/236943">聽取騰訊公司關於 「3・29」 微信業務異常情況彙報</a></u>，要求騰訊公司進一步健全安全生產管理制度、落實網絡運行保障措施，堅決避免發生重大安全生產事故，切實提升公眾業務安全穩定運行水平。</p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/244039" target="_blank">唯品會 329 事故處罰結果：基礎平台部負責人被免職</a></h1><p>今年 3 月 29 日，「唯品會崩了」 登上熱搜，由於崩潰時間太長，影響了很多消費者無法正常下單。唯品會官方對此迴應稱，因系統短時故障，主站 「加購」 等功能或出現異常。</p><p>6 月 5 日，唯品會發布 「關於 329 機房宕機故障處理的公告」。公告稱，3 月 29 日（00:14-12:01）南沙 IDC 冷凍系統故障，導致機房設備溫度快速升高宕機，造成線上商城停止服務。此次事故影響時間持續 12 個小時，導致唯品會業績損失超億元，影響客戶達 800 萬，唯品會將此次故障判定為 P0 級故障。據瞭解，P0 屬於最高級別事故，比如崩潰、頁面無法訪問、主流程不通、主功能未實現，或在影響面上影響很大（即使 Bug 本身不嚴重）。</p><p>公告指出，唯品會決定對此次事件嚴肅處理，對應部門的直接管理者承擔此次事故責任，基礎平台部負責人予以免職作相應處理。</p><p><img src="https://oscimg.oschina.net/oscnet/up-168b9a6041c9b94335f6c23063ef7f9ce95.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/244118/microsoft-azure-outage-brazil" target="_blank">微軟 Azure 故障，17 個生產級數據庫被刪</a></h1><p>5 月 24 日，微軟 Azure DevOps 在巴西南部地區的一處 scale-unit 發生故障，導致宕機約 10.5 個小時。後續微軟首席軟件工程經理 Eric Mattingly 出面針對此次故障事件道歉，並<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstatus.dev.azure.com%2F_event%2F392143683%2Fpost-mortem">透露了</a>導致中斷的原因：即，一個簡單的拼寫錯誤致使 17 個生產級數據庫被刪除。</p><p><img alt="up-d28b235003ee1390973397efd32e59d2ee1.png" src="https://oscimg.oschina.net/oscnet/up-d28b235003ee1390973397efd32e59d2ee1.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/244330" target="_blank">中國電信出現大規模無服務問題</a></h1><p>2023 年 6 月 8 日下午，中國電信的網絡和通信服務出現無信號等失靈現象，絕大部分反饋的用戶都在廣東區域，疑似廣東省內故障。</p><p>此後中國電信客服迴應表示，電信基站全省（廣東電信）故障，暫時不能撥打電話，請耐心等待，現在緊急加急處理中，不便之處，敬請諒解。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3ccdb0730d3b6ee9d3faf43d5d2a31c7d6e.png" referrerpolicy="no-referrer"></p><p>歷時 4 個小時左右，廣東省內電信網絡全面恢復。</p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/263266" target="_blank">語雀 10.23 重大服務故障，持續 7 小時</a></h1><p>2023 年 10 月 23 日語雀出現重大服務故障，且持續 7 個多小時才完全恢復。語雀團隊後續公佈了故障原因及處理過程：</p><p>10 月 23 日下午，服務語雀的數據存儲運維團隊在進行升級操作時，由於新的運維升級工具 bug，導致華東地區生產環境存儲服務器被誤下線。受其影響，語雀數據服務發生嚴重故障，造成大面積的服務中斷。</p><p><img src="https://oscimg.oschina.net/oscnet/up-d0d73c9d391b9afb17b5d8a1fdfe8babfa4.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/266694" target="_blank">阿里雲 11.12 重大服務故障，全線產品受影響</a></h1><p>2023 年 11 月 12 日下午，阿里雲出現嚴重故障，全線產品受影響。</p><p>後續官方確認故障原因與某個底層服務組件有關。在歷時約 5 個小時後，阿里雲宣佈受影響雲產品均已恢復，因故障影響部分雲產品的數據（如監控、賬單等）可能存在延遲推送情況，不影響業務運行。</p><p><img src="https://oscimg.oschina.net/oscnet/up-12e038da50562b9fb7806fac53534a272ac.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/268480" target="_blank">滴滴 11.27 系統服務故障，技術團隊連夜修復</a></h1><p>2023 年 11 月 27 日晚間，滴滴因系統故障導致 App 服務異常，不顯示定位且無法打車。11 月 27 日晚，滴滴出行進行了回覆：非常抱歉，由於系統故障，今天晚間滴滴 App 服務出現異常，經技術同學緊急修復，目前正陸續恢復中。</p><p>2023 年 11 月 28 日早間，滴滴出行消息稱，網約車等服務已恢復，騎車等在陸續修復中。11 月 28 日，在滴滴發出公告的同時，記者在上海、深圳等地使用滴滴呼叫網約車，發現網約車功能並未恢復使用，網絡加載異常，仍無法打車。11 月 28 日，滴滴向記者回應稱，網約車服務已恢復，司機乘客權益陸續恢復補發。</p><p><strong>11 月 29 日，滴滴再次發文致歉，稱初步確定事故起因是底層系統軟件發生故障</strong>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-de730d329966eb2d4a658c5008f11be82a7.png" referrerpolicy="no-referrer"></p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1129/113103_VOdZ_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/231624/a-single-engineer-brought-down-twitter" target="_blank">推特嚴重宕機，馬斯克暴怒</a></h1><p>2023 年 2 月，馬斯克因其關於超級碗的推文曝光度不如美國總統拜登，而深夜緊急召集約 80 人解決算法問題。</p><p>3 月份，因一名工程師修改配置導致推特出現嚴重的宕機故障，馬斯克揚言要將代碼全部進行重構。</p><p><img src="https://static.oschina.net/uploads/space/2023/0308/083022_yiJO_2720166.png" referrerpolicy="no-referrer"></p><p>7 月份，用戶反饋平台再次出現問題，無法發佈新推文，收到 「超出限制」 的錯誤提示。馬斯克則迴應稱，Twitter 正在努力應對 「極端程度的數據抓取」 和 「系統操縱」，這些新的限制是遏制這些緊迫問題的重要措施。</p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/265693" target="_blank">ChatGPT 服務中斷近 2 小時，CEO 奧特曼道歉：流量遠超預期</a></h1><p>北京時間 11 月 8 日晚 22 點左右，OpenAI 旗下 ChatGPT 以及相關 API 出現中斷故障，導致面向用戶和開發者的服務近 2 小時無法正常使用。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstatus.openai.com%2F">隨後 OpenAl 更新事故報告稱</a></u>，已確定了一個導致 API 和 ChatGPT 錯誤率高的問題，正在努力修復。</p><p><img src="https://oscimg.oschina.net/oscnet/up-9dfae5273c9fd8f249f7e5bbc7592211806.png" referrerpolicy="no-referrer"></p><p>與此同時，OpenAI CEO 山姆・奧特曼<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fsama%2Fstatus%2F1722315204242149788">公開致歉稱</a></u>，本週發佈的新功能遇到遠超預期的使用量。公司原計劃在週一為所有訂閲者啓用 GPTs 服務，但目前還無法實現。由於負載的原因，短期內可能會出現服務不穩定的情況，對此情況向用戶道歉。</p><p>&nbsp;</p><p><em>延伸閲讀：<u><a href="https://www.oschina.net/news/270052">網信辦發佈《網絡安全事件報告管理辦法（徵求意見稿）》</a></u></em></p><hr><p>更多年度重磅事件回顧，查看<strong><u><a href="https://talk.gitee.com/report/china-open-source-2023-annual-report.pdf?fr=shida_news1231" target="_blank">《2023 中國開源開發者報告》</a></u></strong>。</p><p><img height="4950" src="https://oscimg.oschina.net/oscnet/up-742bb3d98bf476a2aa6120928bae7b2ee33.png" width="3497" referrerpolicy="no-referrer"><img height="4950" src="https://oscimg.oschina.net/oscnet/up-e2e5b4d5020eec787e184044fd4f42d8c7b.png" width="3497" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 04:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273501</guid>
            <link>https://www.oschina.net/news/273501</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[惡意軟件濫用 Google OAuth 端點「恢復」cookie、劫持帳戶]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">多個信息竊取惡意軟件系列正在濫用名為「MultiLogin」的未記錄的 Google OAuth 端點來恢復過期的身份驗證 cookie 並登錄用戶帳戶（即使賬戶密碼已被重置）。</span></p><p style="color:#404040; margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">科技網站&nbsp;<span style="background-color:#ffffff"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bleepingcomputer.com%2Fnews%2Fsecurity%2Fmalware-abuses-google-oauth-endpoint-to-revive-cookies-hijack-accounts%2F" target="_blank">BleepingComputer</a> 指出，他們在今年 11 月底曾報道了兩名黑客：Lumma 和 Rhadamanthys，兩人聲稱可以恢復在攻擊中竊取的過期谷歌驗證 cookie。</span></span><span style="color:#000000"><span style="background-color:#ffffff">即使合法所有者已經註銷、重置密碼或會話過期，這些 cookie 仍可讓網絡犯罪分子在未經授權的情況下訪問谷歌賬戶。但在這一個多月來，BleepingComputer&nbsp;曾多次聯繫谷歌，詢問相關説法的真實性以及他們計劃如何緩解這一問題，卻從未收到過回覆。</span></span></p><p><span style="color:#000000">CloudSEK 研究人員日前發佈的一份報告則進一步揭示了這種零日漏洞利用的工作原理，並描繪了有關其利用規模的可怕景象。10 月 20 日，一個名為 PRISMA 的威脅行為者首次披露了這一漏洞稱，他們發現了一種恢復過期谷歌驗證 cookie 的方法。</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>對漏洞進行逆向工程後，CloudSEK 發現它使用了一個名為「MultiLogin」的未記錄的 Google OAuth 端點，該端點旨在通過接受帳戶 ID 和 auth-login&nbsp;tokens 向量來同步不同 Google 服務之間的帳戶。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>「此請求用於在多個 Google 網站（例如 YouTube）的 Google 身份驗證 cookie 中設置瀏覽器中的 Chrome 帳戶。」&nbsp; &nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>「這個請求是 Gaia Auth API 的一部分，只要 cookie 中的帳戶與瀏覽器中的帳戶不一致就會觸發。」</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>CloudSEK 表示，濫用該終端的信息竊取惡意軟件會提取登錄到谷歌賬戶的 Chrome 配置文件的 tokens 和賬戶 ID。這些被盜信息包含兩個關鍵數據：service (GAIA ID) 和 encrypted_token。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>加密令牌使用存儲在 Chrome 瀏覽器"Local State"文件中的加密密鑰進行解密。同樣的加密密鑰也用於解密瀏覽器中保存的密碼。利用竊取的 token：GAIA 與多重登錄端點配對，威脅行為者可以重新生成過期的 Google Service cookies，並保持對受損賬戶的持久訪問。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><img height="263" src="https://oscimg.oschina.net/oscnet/up-0d39112d34ae544e0bc2bc03fa265fea829.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#404040">CloudSek 研究員 Pavan Karthick 表示，他們對該漏洞進行了逆向工程，並能夠使用它來重新生成過期的 Google 身份驗證 cookie，如下所示：</span></p><p><img height="253" src="https://oscimg.oschina.net/oscnet/up-b05c5e78446b2fe30d3c88ba80361617dc5.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#404040">Karthick 解釋稱，如果用戶重置其 Google 密碼，身份驗證 cookie 只能重新生成一次。否則，它可以多次重新生成，從而提供對帳戶的持久訪問。</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Lumma stealer 於 11 月 14 日首次利用了該漏洞，</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Radamanthys 是第一個在 11 月 17 日效仿的人；</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>此後還有 12 月 1 日的 Stealc、12 月 11 日的 Medusa、12 月 12 日的 RisePro 和 12 月 26 日的 Whitesnake。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>因此，目前至少有 6 個信息竊取者聲稱能夠使用此 API 端點重新生成 Google cookie。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>此後，</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#070707">Lumma 還發布了該漏洞的更新版本：轉而使用 SOCKS 代理來逃避 Google 的濫用檢測措施，並在惡意軟件和 MultiLogin 端點之間實現加密通信；以抵消谷歌的緩解措。</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">BleepingComputer 認為，這實際上也表明，谷歌方面是知道這一漏洞的存在的。但該公司</span>尚未確認 MultiLogin 端點被濫用的這一事件，因此目前該漏洞利用的狀態及其緩解措施仍不清楚。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 03:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273500/malware-abuses-google-oauth-endpoint-cookies</guid>
            <link>https://www.oschina.net/news/273500/malware-abuses-google-oauth-endpoint-cookies</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
