<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-綜合資訊]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 19 Oct 2023 16:39:06 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[北大開源代碼大模型 CodeShell，提供了配套的 IDE 插件]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>北京大學知識計算實驗室聯合四川天府銀行 AI 團隊，正式開源 70 億參數的代碼大模型&nbsp;CodeShell，並提供了與 CodeShell 配套的部署方案與 IDE 插件，具體查看&nbsp;<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FWisdomShell%2Fcodeshell" target="_blank">CodeShell</a>&nbsp;</u></strong>代碼庫。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-78f14c27454c7f47bd89405366b1af6ca1a.png" referrerpolicy="no-referrer"></p><p>官方介紹稱，CodeShell 具有 70 億參數，採用五千億 Tokens 進行了訓練，上下文窗口長度為 8192。CodeShell 的原始訓練數據基於自己爬取的 GitHub 數據、Stack 和 StarCoder 數據集，以及少量高質量的中英文數據。</p><p>在權威的代碼評估 Benchmark（HumanEval 與 MBPP）中，CodeShell 取得同等規模最好的性能。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-78c60cbccc31a8205f373d3e9f137b44b48.png" referrerpolicy="no-referrer"></p><p>本次開源的模型如下：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FWisdomShell%2FCodeShell" target="_blank"><strong>CodeShell Base</strong></a>：CodelShell 底座模型，具有強大的代碼基礎能力。</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FWisdomShell%2FCodeShell-Chat" target="_blank"><strong>CodeShell Chat</strong></a>：CodelShell 對話模型，在代碼問答、代碼補全等下游任務重性能優異。</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FWisdomShell%2FCodeShell-Chat-int4" target="_blank"><strong>CodeShell Chat 4bit</strong></a>：CodelShell 對話模型 4bit 量化版本，在保證模型性能的前提下內存消耗更小，速度更快。</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FWisdomShell%2Fllama_cpp_for_codeshell" target="_blank"><strong>CodeShell CPP</strong></a>：CodelShell 對話模型 CPP 版本，支持開發者在沒有 GPU 的個人電腦中使用。注意，CPP 版本同樣支持量化操作，用戶可以在最小內存為 8G 的個人電腦中運行 CodeShell。</li></ul><hr><p>下圖是 CodeShell 代碼助手的 VS Code 插件截圖：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-bbb4f00f915125e1971b962f89b6171a932.png" referrerpolicy="no-referrer"></p><p>IDEA 插件：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d1b86e58fd179b1bec428a6bb3d46c2981a.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 09:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262460/codeshell-llm</guid>
            <link>https://www.oschina.net/news/262460/codeshell-llm</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[2023 年 WebAssembly 現狀：Swift、Zig 採用率顯着增加]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="color:#000000">2023 年 WebAssembly 現狀調查報告現已<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.scottlogic.com%2F2023%2F10%2F18%2Fthe-state-of-webassembly-2023.html" target="_blank">出爐</a>，一些亮點內容如下：</span></p><ul><li><span style="color:#000000">Rust 和 JavaScript 的使用量正在持續增長。與此同時，Swift 和 Zig 的採用率也都在顯着增加。</span></li><li><span style="color:#000000">開發人員對 Zig、Kotlin 和 C# 語言的使用渴望超過了當前的使用率。</span></li><li><span style="color:#000000">WebAssembly 仍然最常用於 Web 應用程序開發，但 Serverless 的使用率正在持續上升，WebAssembly 作為插件環境的使用率也在上升。</span></li><li><span style="color:#000000">線程、垃圾收集和相對較新的組件模型提案，是大家最感興趣的 WebAssembly 發展方向。</span></li><li><span style="color:#000000">對於 WASI，最受關注的是 I/O 提案（例如 HTTP、文件系統）。</span></li><li><span style="color:#000000">受訪者對 WAI 發展的滿意度明顯低於對 WebAssembly 發展的滿意度。</span></li><li><span style="color:#000000">許多受訪者表示，他們希望 WebAssembly 能夠兌現 Java 最初做出的「write once and run anywhere」承諾。</span></li></ul><p><strong>語言</strong></p><p><span style="background-color:#ffffff; color:#0a0a0a">Rust 已經連續第三年成為 WebAssembly 最常用的語言，其次是 JavaScript。</span><span><span><span><span><span><span><span style="color:#0a0a0a"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Swift 是 WebAssembly 生態系統中相對較新的成員，始於幾年前對 Apple 的 Swift 存儲庫添加 wasm 目標的拉取請求，不過該請求目前仍未被合併。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><img height="290" src="https://oscimg.oschina.net/oscnet/up-529a4a5bd1ede66a6c8897124867a6f9d68.png" width="500" referrerpolicy="no-referrer">&nbsp;<img height="290" src="https://oscimg.oschina.net/oscnet/up-124f86b04acdb4659a3e60fbd77bf7a26d7.png" width="371" referrerpolicy="no-referrer"></p><p><span style="color:#000000">調查發現，<span style="background-color:#ffffff">WebAssembly&nbsp;</span>工具開發人員對 Rust 有着強烈的偏好，並且也喜歡直接使用 WAT（WebAssembly 文本格式）對 WebAssembly 進行編程；同時還對 Go 和 Python 也有着強烈的偏好。</span></p><p><img height="261" src="https://oscimg.oschina.net/oscnet/up-367dcaf11d60128ed859b232819447af541.png" width="300" referrerpolicy="no-referrer"></p><p><span style="color:#000000">在被問及「希望將來使用哪種語言來開發使用 WebAssembly 的應用程序？」的問題時，被提及最多的依然是&nbsp;<span style="background-color:#ffffff">Rust，其次是&nbsp;JavasScript，而排在第三位的語言則是目前使用頻率較低的 Zig。</span></span></p><p><img height="290" src="https://oscimg.oschina.net/oscnet/up-6e01877e82f62682c549874e79cf3f0e558.png" width="500" referrerpolicy="no-referrer"></p><p><img height="291" src="https://oscimg.oschina.net/oscnet/up-9dc0076729ffa1bc3beb47cd6b63e4e6e5b.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><strong><span><span><span><span><span style="color:#0a0a0a"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>WebAssembly 的實際應用</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><span style="background-color:#ffffff; color:#0a0a0a">Web 應用程序開發仍然處於領先地位，但差距正在縮小。</span></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><img height="290" src="https://oscimg.oschina.net/oscnet/up-6554f8ad47d5b7a5482d251465fa5323e03.png" width="515" referrerpolicy="no-referrer">&nbsp;<img height="290" src="https://oscimg.oschina.net/oscnet/up-873833dae39174a594d8c19b45f8e627f95.png" width="399" referrerpolicy="no-referrer"></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><span style="background-color:#ffffff; color:#0a0a0a">就 WebAssembly 在組織中的採用現狀而言，41% 的受訪者透露其正在生產中使用 WebAssembly，還有 28% 的受訪者表示正在試點或計劃在明年使用。</span></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><img height="293" src="https://oscimg.oschina.net/oscnet/up-b5cc0681dcd4d5738a298eab1bf287dbfb7.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start">受訪者認為，<span style="background-color:#ffffff; color:#0a0a0a">通過 WASI 實現更好的非瀏覽器集成</span>、<span style="background-color:#ffffff; color:#0a0a0a">更好的調試支持等功能</span>可以有效的推動&nbsp;<span style="background-color:#ffffff; color:#0a0a0a">WebAssembly 的進一步採用。</span></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><img height="295" src="https://oscimg.oschina.net/oscnet/up-292329d5a3f2a7ca5d7bb9f4044150330c1.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0.5rem; margin-right:0px; text-align:start"><span style="background-color:#ffffff; color:#000000">更多詳情可</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.scottlogic.com%2F2023%2F10%2F18%2Fthe-state-of-webassembly-2023.html" target="_blank">查看完整報告</a><span style="background-color:#ffffff; color:#000000">。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 09:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262453/the-state-of-webassembly-2023</guid>
            <link>https://www.oschina.net/news/262453/the-state-of-webassembly-2023</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[AlmaLinux 不使用「紅帽代碼」，如何保持兼容 RHEL]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>科技媒體 ZDNET 資深撰稿人 Steven Vaughan-Nichols 近日發表文章"<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zdnet.com%2Farticle%2Fhow-almalinux-stays-red-hat-enterprise-linux-compatible-without-red-hat-code%2F" target="_blank"><em>How AlmaLinux stays Red Hat Enterprise Linux compatible without Red Hat code</em></a></u>"，介紹了 AlmaLinux 發行版如何在<strong><span style="background-color:#f39c12">沒有任何紅帽代碼</span>的情況下，仍保持兼容 RHEL</strong>。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1019/155002_Xj5s_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>今年 6 月份，紅帽<u><a href="https://www.oschina.net/news/246331/red-hat-centos-stream-sources" target="_blank">執行新政策</a></u>限制了 RHEL 的代碼訪問，此舉導致基於 RHEL 的衍生髮行版（比如 AlmaLinux，Rocky Linux，Oracle Linux 等）難以提供與 RHEL 100% 兼容的構建。</p><p>針對此政策，甲骨文、SUSE 和 CIQ（Rocky Linux 背後的商業實體）合作<u><a href="https://www.oschina.net/news/253319/oracle-suse-ciq-openela" target="_blank">建立了 OpenELA</a></u>&nbsp;(Open Enterprise Linux Association) —— 旨在創建兼容 RHEL 的 Linux 代碼庫，並通過提供開放和免費的 Enterprise Linux (EL) 源代碼，鼓勵開發與 RHEL 兼容的發行版。</p><p><img alt="up-29deac510fcb6941f2761d016a8e201c58a.png" src="https://oscimg.oschina.net/oscnet/up-29deac510fcb6941f2761d016a8e201c58a.png" referrerpolicy="no-referrer"></p><p>AlmaLiniux 沒有加入 OpenELA，而是選擇了另一條路。AlmaLinux OS 基金會主席 benny Vasquez <a href="https://www.oschina.net/news/249342/almalinux-no-1-1-rhel" target="_blank">原話</a>：<strong>「放棄與 RHEL 1:1 的目標，AlmaLinux 致力於兼容其應用程序二進制接口 (ABI)」</strong>。主要代碼從&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.com%2Fredhat%2Fcentos-stream" target="_blank">CentOS Stream</a>&nbsp;獲取，其他代碼則是從<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.redhat.com%2Fen%2Fblog%2Fintroducing-red-hat-universal-base-image" target="_blank"> Red Hat 通用基礎鏡像</a>和上游 Linux 代碼中獲取。</p><p>但最難的部分其實是 RHEL 的 Linux 內核更新。Vasquez 説道：「如果不違反紅帽的許可協議，就無法獲得這些內核更新。因此他們的做法就是<strong>從其他各種來源獲取安全補丁</strong>，以及在 Oracle 發佈補丁時再去溯源找到上游。」</p><p>Vasquez 表示這樣的流程帶來了好處：「AlmaLinux 不再受 RHEL 的約束，而且能夠比它更快地發佈上游安全修復程序。」比如，AlmaLinux 比 RHEL 提前一週修復了 AMD 微碼漏洞。</p><p>由於這篇文章一直在強調 AlamLinux 沒有使用「紅帽代碼」，有人對此<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D37935375" target="_blank">提出了質疑</a></u>，認為 AlamLinux 從&nbsp;CentOS Stream 獲取的代碼事實上就是「紅帽代碼」。CentOS Stream 也早已與 RHLE 兼容 ABI。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 08:39:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262448/almalinux-stays-rhel-compatible</guid>
            <link>https://www.oschina.net/news/262448/almalinux-stays-rhel-compatible</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[《全球人工智能治理倡議》發佈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>中國網信網於今日發佈《<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.cac.gov.cn%2F2023-10%2F18%2Fc_1699291032884978.htm" target="_blank">全球人工智能治理倡議</a>》，具體內容如下：</p><blockquote><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify">人工智能是人類發展新領域。當前，全球人工智能技術快速發展，對經濟社會發展和人類文明進步產生深遠影響，給世界帶來巨大機遇。與此同時，人工智能技術也帶來難以預知的各種風險和複雜挑戰。人工智能治理攸關全人類命運，是世界各國面臨的共同課題。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify">在世界和平與發展面臨多元挑戰的背景下，各國應秉持共同、綜合、合作、可持續的安全觀，堅持發展和安全並重的原則，通過對話與合作凝聚共識，構建開放、公正、有效的治理機制，促進人工智能技術造福於人類，推動構建人類命運共同體。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify">我們重申，各國應在人工智能治理中加強信息交流和技術合作，共同做好風險防範，形成具有廣泛共識的人工智能治理框架和標準規範，不斷提升人工智能技術的安全性、可靠性、可控性、公平性。我們歡迎各國政府、國際組織、企業、科研院校、民間機構和公民個人等各主體秉持共商共建共享的理念，協力共同促進人工智能治理。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify">為此，我們倡議：</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify"><strong>——</strong>發展人工智能應堅持「以人為本」理念，以增進人類共同福祉為目標，以保障社會安全、尊重人類權益為前提，確保人工智能始終朝着有利於人類文明進步的方向發展。積極支持以人工智能助力可持續發展，應對氣候變化、生物多樣性保護等全球性挑戰。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify"><strong>——</strong>面向他國提供人工智能產品和服務時，應尊重他國主權，嚴格遵守他國法律，接受他國法律管轄。反對利用人工智能技術優勢操縱輿論、傳播虛假信息，干涉他國內政、社會制度及社會秩序，危害他國主權。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify"><strong>——</strong>發展人工智能應堅持「智能向善」的宗旨，遵守適用的國際法，符合和平、發展、公平、正義、民主、自由的全人類共同價值，共同防範和打擊恐怖主義、極端勢力和跨國有組織犯罪集團對人工智能技術的惡用濫用。各國尤其是大國對在軍事領域研發和使用人工智能技術應該採取慎重負責的態度。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify"><strong>——</strong>發展人工智能應堅持相互尊重、平等互利的原則，各國無論大小、強弱，無論社會制度如何，都有平等發展和利用人工智能的權利。鼓勵全球共同推動人工智能健康發展，共享人工智能知識成果，開源人工智能技術。反對以意識形態劃線或構建排他性集團，惡意阻撓他國人工智能發展。反對利用技術壟斷和單邊強制措施製造發展壁壘，惡意阻斷全球人工智能供應鏈。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify"><strong>——</strong>推動建立風險等級測試評估體系，實施敏捷治理，分類分級管理，快速有效響應。研發主體不斷提高人工智能可解釋性和可預測性，提升數據真實性和準確性，確保人工智能始終處於人類控制之下，打造可審核、可監督、可追溯、可信賴的人工智能技術。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify"><strong>——</strong>逐步建立健全法律和規章制度，保障人工智能研發和應用中的個人隱私與數據安全，反對竊取、篡改、泄露和其他非法收集利用個人信息的行為。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify"><strong>——</strong>堅持公平性和非歧視性原則，避免在數據獲取、算法設計、技術開發、產品研發與應用過程中，產生針對不同或特定民族、信仰、國別、性別等偏見和歧視。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify"><strong>——</strong>堅持倫理先行，建立並完善人工智能倫理準則、規範及問責機制，形成人工智能倫理指南，建立科技倫理審查和監管制度，明確人工智能相關主體的責任和權力邊界，充分尊重並保障各羣體合法權益，及時迴應國內和國際相關倫理關切。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify"><strong>——</strong>堅持廣泛參與、協商一致、循序漸進的原則，密切跟蹤技術發展形勢，開展風險評估和政策溝通，分享最佳操作實踐。在此基礎上，通過對話與合作，在充分尊重各國政策和實踐差異性基礎上，推動多利益攸關方積極參與，在國際人工智能治理領域形成廣泛共識。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify"><strong>——</strong>積極發展用於人工智能治理的相關技術開發與應用，支持以人工智能技術防範人工智能風險，提高人工智能治理的技術能力。</p><p style="color:#333333; margin-left:0; margin-right:0; text-align:justify"><strong>——</strong>增強發展中國家在人工智能全球治理中的代表性和發言權，確保各國人工智能發展與治理的權利平等、機會平等、規則平等，開展面向發展中國家的國際合作與援助，不斷彌合智能鴻溝和治理能力差距。積極支持在聯合國框架下討論成立國際人工智能治理機構，協調國際人工智能發展、安全與治理重大問題。</p></blockquote><p><span style="color:#000000">&nbsp;與此同時，</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.chinastarmarket.cn%2Fdetail%2F1488456" target="_blank"><span style="color:#000000">外交部發言人也就《全球人工智能治理倡議》答記者問。</span></a></p><blockquote><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.chinastarmarket.cn%2Fdetail%2F1488456" target="_blank"><span style="color:#000000">問：10 月 18 日，習近平主席在第三屆「一帶一路」國際合作高峯論壇開幕式主旨演講中提出《全球人工智能治理倡議》，能否介紹具體內容？中方提出這一倡議有何特殊意義？<br><br> 答：人工智能是人類發展的新領域，帶來重大機遇，也伴隨着難以預知的風險挑戰，需要國際社會共同應對。今天上午，習近平主席出席第三屆「一帶一路」國際合作高峯論壇開幕式，並在主旨演講中宣佈中方將提出《全球人工智能治理倡議》。這是中方積極踐行人類命運共同體理念，落實全球發展倡議、全球安全倡議、全球文明倡議的具體行動。<br><br> 《倡議》圍繞人工智能發展、安全、治理三方面系統闡述了人工智能治理中國方案，核心內容包括：堅持以人為本、智能向善，引導人工智能朝着有利於人類文明進步的方向發展；堅持相互尊重、平等互利，反對以意識形態劃線或構建排他性集團，惡意阻撓他國人工智能發展；主張建立人工智能風險等級測試評估體系，不斷提升人工智能技術的安全性、可靠性、可控性、公平性；支持在充分尊重各國政策和實踐基礎上，形成具有廣泛共識的全球人工智能治理框架和標準規範，支持在聯合國框架下討論成立國際人工智能治理機構；加強面向發展中國家的國際合作與援助，彌合智能鴻溝和治理差距等。<br><br> 《倡議》就各方普遍關切的人工智能發展與治理問題提出了建設性解決思路，為相關國際討論和規則制定提供了藍本。中方願同各方就全球人工智能治理開展溝通交流、務實合作，推動人工智能技術造福全人類。</span></a></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 07:06:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262291</guid>
            <link>https://www.oschina.net/news/262291</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Windows 11 月活躍設備數超過 4 億台]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>根據 Windows Central 的<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.windowscentral.com%2Fsoftware-apps%2Fwindows-11%2Fexclusive-windows-11-is-active-on-almost-half-a-billion-devices-ahead-of-microsofts-expectations" target="_blank">報道</a></u>，<span style="color:#252a2d">微軟內部數據顯示，目前<strong>運行 Windows 11 的月活躍設備已超過 4 億台</strong>，並且正在穩步增長，預計到 2024 年初達到 5 億台。</span></p><p><span style="color:#252a2d">從這份數據來看，Windows 11&nbsp;</span>普及率明顯要比上一代 Windows 10 更慢。Windows 11 於 2021 年 10 月發佈，這意味着它花了大約兩年的時間才達到這一里程碑，相比 Windows 10 要慢得多，後者在一年多的時間裏就達到了同樣的水平。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3e5b147c33f77b535e10cc9655b79dceebe.png" referrerpolicy="no-referrer"></p><p>Windows Central 稱，採用率的差異可歸因於兩個操作系統不同的發佈策略。Windows 10 最初作為 Windows 7 和 Windows 8 的限時免費升級而推出，微軟一直在敦促用戶在免費升級期結束前儘快升級。</p><p>相比之下，Windows 11 的發佈較為平靜，而且由於 TPM 的要求，支持的 PC 數量較少，因此採用率較低。</p><p>雖然 Windows 11 採用率到達里程碑的速度沒有 Windows 10 快，但這也已經超出了微軟自己對 Windows 11 採用率的預期。</p><p>根據流量監測機構 StatCounter 的數據，Windows 10 仍然以 71.62% 的市場份額牢牢控制着桌面 Windows 市場。與此同時，Windows 11 佔所有 Windows 桌面安裝量的 23.64%。Windows 7 的市場份額下降到 3.33%，而 Windows XP 的市場份額僅為 0.34%。</p><p>根據微軟的內部指標，Windows 11 的勢頭很強勁。儘管最初存在爭議和兼容性問題，但微軟通過頻繁的更新和預覽選項，讓 Windows 11 對新設備和現有設備都充滿了吸引力。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 06:39:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262425/windows-11-is-active-on-almost-half-a-billion-device</guid>
            <link>https://www.oschina.net/news/262425/windows-11-is-active-on-almost-half-a-billion-device</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[8 月國內手機市場出貨量 1898.5 萬部，5G 手機佔比 82.4%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="background-color:#ffffff; color:#333333">中國信通院</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FiAHQPiCOzs1Yfa2bjgOZPQ" target="_blank">發佈</a><span style="background-color:#ffffff; color:#333333">了 2023 年 8 月國內手機市場運行分析報告，具體情況如下：</span></p><p style="margin-left:0; margin-right:0"><strong>一、國內手機市場總體情況</strong></p><p style="margin-left:0; margin-right:0">2023 年 8 月，國內市場手機出貨量 1898.5 萬部，同比增長 0.03%，其中，5G 手機 1564.5 萬部，同比增長 9.6%，佔同期手機出貨量的 82.4%。</p><p style="margin-left:0; margin-right:0">2023 年 1-8 月，國內市場手機總體出貨量累計 1.67 億部，同比下降 4.5%，其中，5G 手機出貨量 1.33 億部，同比下降 3.8%，佔同期手機出貨量的 79.5%。</p><p style="margin-left:0; margin-right:0"><img height="306" src="https://oscimg.oschina.net/oscnet/up-2c643a53dd7693f0057105e72029463071d.png" width="500" referrerpolicy="no-referrer"></p><p>2023 年 8 月，國內手機上市新機型 55 款，同比增長 14.6%，其中 5G 手機 30 款，同比增長 50.0%，佔同期手機上市新機型數量的 54.5%。</p><p style="margin-left:0; margin-right:0">2023 年 1-8 月，上市新機型累計 293 款，同比增長 8.1%，其中 5G 手機 133 款，同比下降 5.7%，佔同期手機上市新機型數量的 45.4%。</p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><img height="312" src="https://oscimg.oschina.net/oscnet/up-917be2330c145e58fc7ac99ceca87baf701.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>二、國內手機市場國內外品牌構成</strong></p><p style="margin-left:0; margin-right:0">2023 年 8 月，國產品牌手機出貨量 1684.3 萬部，同比下降 5.7%，佔同期手機出貨量的 88.7%；上市新機型 47 款，同比增長 23.7%，佔同期手機上市新機型數量的 85.5%。</p><p style="margin-left:0; margin-right:0">2023 年 1-8 月，國產品牌手機出貨量累計 1.38 億部，同比下降 8.7%，佔同期手機出貨量的 82.7%；上市新機型累計 266 款，同比增長 7.3%，佔同期手機上市新機型數量的 90.8%。</p><p style="margin-left:0; margin-right:0"><img height="251" src="https://oscimg.oschina.net/oscnet/up-d20eb80b2c4db91a395325de68931501eda.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>三、國內智能手機發展情況</strong></p><p style="margin-left:0; margin-right:0">2023 年 8 月，智能手機出貨量 1792.6 萬部，同比下降 1.2%，佔同期手機出貨量的 94.4%。2023 年 1-8 月，智能手機出貨量 1.60 億部，同比下降 6.7%，佔同期手機出貨量的 95.5%。</p><p style="margin-left:0; margin-right:0"><img height="278" src="https://oscimg.oschina.net/oscnet/up-59caa5d22c4a5db7c64c222baacfc1365a4.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0">2023 年 8 月，智能手機上市新機型 46 款，同比增長 7.0%，佔同期手機上市新機型數量的 83.6%。2023 年 1-8 月，智能手機上市新機型累計 247 款，同比增長 7.9%，佔同期上市新機型數量的 84.3%。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 06:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262420</guid>
            <link>https://www.oschina.net/news/262420</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[ScyllaDB 獲 4300 萬美元融資，NoSQL 數據庫市場再掀熱潮！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" target="_blank">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt; <img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><blockquote><p>ScyllaDB 是一家成立於 2012 年 12 月的美國公司，總部位於加利福尼亞州桑尼維爾。作為一家數據密集型應用程序數據庫供應商，ScyllaDB 生產的 NoSQL 數據庫兼容 Apache Cassandra 和 Amazon DynamoDB，具有可靠的低延遲和 10 倍的吞吐量。在 2023 年 10 月 17 日，該公司成功獲得了 4300 萬美元的融資。截至目前，ScyllaDB 已經籌集了 1.03 億美元的風險投資。</p></blockquote><h1>關於 ScyllaDB 公司</h1><p>本篇內容是根據 Kyle Wiggers 發佈在 TechCrunch 網站上的文章翻譯整理，以下是玖章算術 NineData 的工程師點評： ：</p><ul><li>&nbsp; 對於日新月異的高科技領域，NoSQL 屬於爺爺輩的技術名詞。ScyllaDB 成立在 10+年前，對標 MongoDB, Cassandra 和 DynamoDB，依然顯示其生命活力，主要的優勢在於其向雲原生的成功轉型，精簡的團隊（168 人）和成功的生態構建。</li><li>&nbsp; 在市場相對萎靡的情況下，作為一個數據庫引擎公司，獲得了投資者的青睞，説明投資方對於優質團隊的信心。當然，我們也要看到現在數據庫系統的公司暫時的困境，比如去年勉強上市的 MariaDB，從$10 跌到$0.60，最近又傳出其主力 Xpand 團隊解散的消息，讓人唏噓不已呀。另外打個廣告，如果有團隊招收數據庫內核工程師，我可以直接推薦 MariaDB 資深開發。Xpand 是基於 MySQL 類似於國內 PolarDB/OceanBase/TiDB 的分佈式 OLTP 數據庫。</li></ul><h1>ScyllaDB 新一輪融資 4300 萬美元</h1><p>投資者似乎對數據庫情有獨鍾。</p><p>10 月 17 日，ScyllaDB 宣佈在一輪融資中獲得了<strong>4300 萬美元</strong>，ScyllaDB 為需要高吞吐量和低延遲的數據密集型應用提供數據庫。本次領投方為 Eight Roads Ventures，參與投資方包括 AB Private Credit Investors、AllianceBernstein、TLV partners、Magma Ventures 和 Qualcomm Ventures 等。</p><p><img src="https://oscimg.oschina.net/oscnet/up-d54c5782f6b139a5d486d1140a2c79c6f77.png" alt="" referrerpolicy="no-referrer"></p><p>據聯合創始人兼 CEO Dor Laor 介紹，這筆新資金將用於「加速」ScyllaDB 的發展勢頭，以及擴大擁有 168 人的團隊規模。</p><p>Laor 在接受 TechCrunch 的電子郵件採訪時表示：「如今的顛覆者正在吸收前所未有的數據量，並利用它提供不同的用戶體驗，改變市場格局並取代傳統領導者，數據正在通過多個來源進行豐富、清洗、流式傳輸、輸入到 AI 和機器學習流程，並進行復制和緩存。因此，擁有一個能勝任任務的數據庫比以往任何時候都更加重要。」</p><h1>ScyllaDB 簡介</h1><p><img src="https://oscimg.oschina.net/oscnet/up-d7c6b7d347101eb1b5893015fe1dee6e332.jpg" alt="" referrerpolicy="no-referrer"></p><p>ScyllaDB 被稱為一種 NoSQL 數據庫，與在企業中曾經佔主導地位的關係型數據庫不同，它提供了不依賴於「表關係」模型的數據存儲和檢索機制。在表關係模型中，關係是兩個數據表之間的連接。但是使用 NoSQL 數據庫，關係不必遵循這種模式，這提供了更大的工程靈活性，在某些情況下還可以提高性能</p><p>NoSQL 數據庫常用於廣告投放、人工智能和機器學習、推薦和個性化引擎、欺詐檢測以及分析物聯網設備的數據等應用。</p><p>根據 Ventana 公司 2022 年的一項調查，近四分之一（22%）的企業目前正在生產中使用 NoSQL 數據庫，而超過三分之一（34%）的企業正計劃在兩年內採用 NoSQL 數據庫或評估其潛在用途。而 NoSQL 市場預計將增長到報告的規模。</p><p>現在，ScyllaDB 並不是唯一的 NoSQL 供應商。類似的產品還有 ArangoDB、Redis Labs 和 Crate.io 等等，更不用提像 MongoDB、亞馬遜的 DynamoDB 和 Couchbase 這樣的大型供應商了。</p><p>但 ScyllaDB 聲稱，它的技術具有架構優勢，比如每秒可執行數百萬次操作，延遲時間僅為 "個位數毫秒"。ScyllaDB 能在多個雲平台、混合雲環境或本地運行，並通過工作負載優先級進行 I/O 和 CPU 性能的自動調整，將工作負載放置在單個服務器集羣下。</p><p>顯然，這些聲明和能力足以吸引客戶。ScyllaDB 表示，包括 Discord、Epic Games 和 Palo Alto Networks 在內的 400 多家公司現在正在使用其數據庫，並且自 2012 年 12 月成立以來，收入已增長了 800%。</p><p>Laor 表示：「在各行各業，研發團隊越來越意識到，ScyllaDB 與眾不同的數據庫架構為數據密集型工作負載提供了更好的性能和橫向可擴展性。ScyllaDB 旨在幫助快速增長、快節奏的團隊在大規模情況下提供閃電般快速的用戶體驗... ScyllaDB 的獨特架構充分利用現代雲資源，提供令人印象深刻的效率和性價比。」</p><p>截至目前，ScyllaDB 已經籌集了 1.03 億美元的風險投資。</p><hr><p>原文鏈接： &nbsp; <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2023%2F10%2F17%2Fscylladb-raises-43m-to-scale-its-nosql-database-platform%2F" target="_blank">https://techcrunch.com/2023/10/17/scylladb-raises-43m-to-scale-its-nosql-database-platform/</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 06:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/ninedata/blog/10120349</guid>
            <link>https://my.oschina.net/ninedata/blog/10120349</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GPT 模型容易被誤導從而輸出問題內容]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>微軟研究院近日<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.microsoft.com%2Fen-us%2Fresearch%2Fblog%2Fdecodingtrust-a-comprehensive-assessment-of-trustworthiness-in-gpt-models%2F" target="_blank">發佈文章</a></u>介紹了他們對 GPT 模型可信度的研究。文章稱&nbsp;<strong>GPT 模型很容易被誤導</strong>，產生有毒和有偏見的輸出，並泄露訓練數據和對話歷史中的隱私信息。</p><p><img src="https://static.oschina.net/uploads/space/2023/1019/114921_ltu9_2720166.png" referrerpolicy="no-referrer"></p><p><em>▲&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F%2F2306.11698" target="_blank">https://arxiv.org/abs//2306.11698</a></em></p><p>微軟聯合伊利諾伊大學厄巴納-香檳分校與斯坦福大學、加州大學伯克利分校、人工智能安全中心發佈了一款面向大語言模型的綜合可信度評估平台——<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdecodingtrust.github.io%2F" target="_blank">DecodingTrust</a></u>，對大模型的毒性、刻板偏見、對抗穩健性、分佈穩健性、對抗演示穩健性、隱私、機器倫理和公平性等內容進行評估。</p><p>根據測試，研究者發現 GPT 模型很容易被誤導，產生有毒和有偏見的輸出，並泄露訓練數據和對話歷史中的隱私信息。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b61e2f5a48ca552ccf5118cfedadbffc3eb.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-7360d284e297af22f8166099304ef91191b.png" referrerpolicy="no-referrer"></p><p>研究還發現，雖然在標準基準上，GPT-4 通常比 GPT-3.5 更值得信賴，但在越獄系統或用戶提示的情況下，GPT-4 更容易受到攻擊，這些提示是惡意設計來繞過 LLM 的安全措施的，<strong>這可能是因為 GPT-4 更精確地遵循了（誤導性的）指令</strong>。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 03:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262405/trustworthiness-in-gpt-models</guid>
            <link>https://www.oschina.net/news/262405/trustworthiness-in-gpt-models</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gartner 發佈 2024 十大戰略技術趨勢]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="color:#000000"><span style="background-color:#ffffff">Gartner 最新<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.gartner.com%2Fen%2Farticles%2Fgartner-top-10-strategic-technology-trends-for-2024" target="_blank">發佈</a>了預計將在未來 36 個月內為 IT 領導者帶來重大顛覆和機遇的 10 大戰略技術趨勢。「</span>這些創新可以推動你更快地實現業務目標，尤其是在人工智能快速發展的時代。<span style="background-color:#ffffff">」</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff"><img alt="" height="407" src="https://oscimg.oschina.net/oscnet/up-5bd7ea9c5644a5ad99798146ce3593b0901.png" width="500" referrerpolicy="no-referrer"></span></span></p><p><strong><span style="color:#000000"><span style="background-color:#ffffff">十大技術趨勢具體如下：</span></span></strong></p><ol><li><span style="color:#000000">人工智能信任、風險和安全管理 (AI TRiSM)</span></li><li><span style="color:#000000">持續威脅暴露管理 (CTEM)</span></li><li><span style="color:#000000">可持續技術</span></li><li><span style="color:#000000">平台工程</span></li><li><span style="color:#000000">人工智能增強開發</span></li><li><span style="color:#000000">行業雲平台</span></li><li><span style="color:#000000">智能應用</span></li><li><span style="color:#000000">全民化的生成式人工智能</span></li><li>增強型互聯員工隊伍<span style="background-color:#ffffff; color:#333333">（Augmented-Connected Workforce）</span></li><li><span style="background-color:#ffffff; color:#000000">機器客戶</span>（<span style="color:#000000">Machine Customers</span>）</li></ol><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">該公司每年都會列出一份它認為下一年將在科技行業佔據主導地位的 10 大趨勢。每種趨勢都與企業的一個或多個關鍵主題有關：保護和保存過去和未來的投資，在正確的時間為正確的利益相關者構建正確的解決方案，以及為內部和外部客戶不斷變化的環境提供價值。</span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">在今年的清單中，其中有 5 個趨勢屬於「資產保護」的類別：人工智能信任、風險和安全管理 (AI TRiSM)，持續威脅暴露管理 (CTEM)，行業雲平台，可持續技術，</span>全民化<span style="background-color:#ffffff">的生成式人工智能。</span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">Gartner 表示，實現這種保護的關鍵在於要深思熟慮，在沒有充分指導的情況下停止無節制的試驗；要實事求是，計算項目的投資回報率；在定製創新時要考慮重複使用。「到 2026 年，生成式 AI 將顯着改變新 Web 應用程序和移動應用程序 70% 的設計和開發工作。」</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">此外，還劃分了「構建者的崛起」和「價值交付」兩個類別。其中符合「構建者的崛起」這一主題的趨勢包括：平台工程、人工智能增強開發、行業雲平台、智能應用、可持續技術和</span>全民化的<span style="background-color:#ffffff">生成人工智能。&nbsp;</span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">符合「價值交付」的包括：機器客戶、</span></span>增強型互聯員工隊伍<span style="color:#000000"><span style="background-color:#ffffff">、智能應用、可持續技術和</span>全民化的<span style="background-color:#ffffff">生成人工智能的趨勢。</span></span></p><p style="margin-left:0; margin-right:0; text-align:start">更多詳情可查看<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.gartner.com%2Fen%2Farticles%2Fgartner-top-10-strategic-technology-trends-for-2024" target="_blank">此處</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 03:55:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262404/gartner-top-10-strategic-technology-trends-for-2024</guid>
            <link>https://www.oschina.net/news/262404/gartner-top-10-strategic-technology-trends-for-2024</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度 CTO 王海峯：文心一言用戶規模已達 4500 萬]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>百度首席技術官王海峯在解讀文心大模型 4.0 背後的關鍵技術和最新進展時<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FbC1v9-xKMRbUVhM5JMT58A" target="_blank">表示</a>，文心大模型 4.0 的理解、生成、邏輯、記憶四大能力都有顯著提升。</p><p>文心大模型 4.0 在 9 月已開始小流量上線，過去一個多月效果又提升了近 30%。訓練算法效率自 3 月以來已累計提升 3.6 倍，周均的訓練有效率超過 98%。</p><p>8 月 31 日文心一言面向全社會開放至今，用戶規模已經達到 4500 萬，開發者 5.4 萬，場景 4300 個，應用 825 個，插件超過 500 個。</p><p>王海峯指出，文心大模型 4.0 的理解和生成能力的提升幅度相近，而邏輯和記憶能力的提升則更大，邏輯的提升幅度達到理解的近 3 倍，記憶的提升幅度也達到了理解的 2 倍多。百度基於文心大模型研製了智能代碼助手 Comate，從內部應用效果來看，整體的代碼採納率達到 40%，高頻用戶的代碼採納率達到 60%。</p><p><img height="281" src="https://oscimg.oschina.net/oscnet/up-856d6910a56bbb2d0ae2902d1c1c9b8247b.png" width="500" referrerpolicy="no-referrer"></p><p><img height="281" src="https://oscimg.oschina.net/oscnet/up-fdb22be35e82911409420c1314a4f74d7cb.png" width="500" referrerpolicy="no-referrer"></p><p>此外，文心大模型 4.0 在輸入和輸出階段都進行知識點增強。一方面，對用戶輸入的問題進行理解，並拆解出回答問題所需的知識點，然後在搜索引擎、知識圖譜、數據庫中查找準確知識，最後把這些找到的知識組裝進 Prompt 送入大模型，準確率好，效率也高；另一方面，對大模型的輸出進行反思，從生成結果中拆解出知識點，然後再利用搜索引擎、知識圖譜、數據庫，以及大模型本身進行確認，進而對有差錯的點進行修正。</p><p>王海峯還公佈了百度人工智能人才培養的最新數據稱，百度在 2020 年提出 5 年為全社會培養 500 萬 AI 人才，截至目前已經培養了 420 萬 AI 人才。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 03:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262394</guid>
            <link>https://www.oschina.net/news/262394</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Qt 6.5 LTS 轉為「僅面向商業客戶提供」階段]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>隨着 <u><a href="https://www.oschina.net/news/261263/qt-6-6-released" target="_blank">Qt 6.6 正式發佈</a></u>，<u><a href="https://www.oschina.net/news/235304/qt-6-5-lts-released" target="_blank">Qt 6.5 LTS</a></u>&nbsp;已轉變為<strong>僅面向商業客戶提供 (Commercial-only)</strong>。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1019/104731_bHJt_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>Qt 官方在開發者郵件列表<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flists.qt-project.org%2Fpipermail%2Fdevelopment%2F2023-October%2F044573.html" target="_blank">寫道</a></u>：</p><blockquote><p>隨着 Qt 6.6.0 的發佈和首個補丁更新 (Qt 6.6.1)&nbsp;將於 11 月發佈，Qt 6.5 LTS 也將進入「僅限商業客戶使用」的 LTS 階段。</p><p>6.5 現有的全部分支仍然公開，<strong>但它們已不再接受新的 commit 和 cherry-picks</strong>——除了 Qt WebEngine，因為它具有使用 LPGL 許可證的第三方依賴。</p><p>生效時間從 2023 年 10 月 18 日開始。在此之後，cherry-picks 將進入另一個倉庫，僅對商業許可證持有者開放。</p><p>首個僅限商業客戶使用的 Qt 6.5.4 LTS 補丁版本計劃於 11 月底發佈。</p><p>外部模塊維護者可以繼續訪問&nbsp;Qt 6.5 商業客戶專有倉庫。</p></blockquote><p><u><a href="https://www.oschina.net/news/125661/qt-5-15-lts-commercia" target="_blank">這項政策從 2020 年開始實施</a></u>。2020 年 1 月，Qt 公司宣佈對 Qt 項目的運營策略進行改革，所有用戶都需要註冊 Qt 帳戶才能獲取安裝 Qt 的二進制文件（源碼文件不受限制），同時長期支持版本 (LTS) 和離線安裝程序僅面向擁有商業許可證的大型企業用戶提供，只有最新的非穩定版本仍可供用戶免費使用。</p><p><img alt="081354_Y2Ti_4487475.png" src="https://static.oschina.net/uploads/space/2021/0106/081354_Y2Ti_4487475.png" referrerpolicy="no-referrer"></p><hr><p>延伸閲讀：</p><ul><li><a href="https://www.oschina.net/news/114828/qt-might-restrict-new-releases" target="_blank">KDE 社區稱 Qt 公司正考慮僅面向付費用戶提供新版本</a></li><li><a href="https://www.oschina.net/news/181231/qt-simplify-commercial">Qt 簡化商業授權方案</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 03:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262391/qt-6-5-lts-commercial-only</guid>
            <link>https://www.oschina.net/news/262391/qt-6-5-lts-commercial-only</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[X Editor —— 嵌入到瀏覽器的文本編輯器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="project_detail_above_text_link_1" data-tracepid="project_detail_above_text_link"><a style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" target="_blank">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt; <img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p><strong>X 編輯器</strong>是嵌入在瀏覽器中的文本編輯器。它可以訪問用戶的本地文件系統，並且預覽 Markdown 文件。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3a2387fc2caa6def043f8ee1e0e789064b9.png" referrerpolicy="no-referrer"></p><p>目前支持 Chrome、Edge 和 Opera 等基於 Chromium 的瀏覽器。</p><p><strong>運行截圖</strong></p><ul><li>預覽 Markdown 文件</li></ul><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-48a05913c04b8748b77d9c113a2f1b2e9d8.png" referrerpolicy="no-referrer"></p><ul><li>播放 MP3 文件</li></ul><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-13b162d7dc910af35cbf13dc10110cfcde2.png" referrerpolicy="no-referrer"></p><ul><li>觀看視頻</li></ul><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1d4d98955df4f8a5db0a17df183260adb2a.png" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 02:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/x-editor</guid>
            <link>https://www.oschina.net/p/x-editor</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 終端仿真軟件 quardCRT]]>
            </title>
            <description>
                <![CDATA[<p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Fwindows.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/windows.yml?branch=main&amp;logo=windows" alt="Windows ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Flinux.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/linux.yml?branch=main&amp;logo=linux" alt="Linux ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Factions%2Fworkflows%2Fmacos.yml"><img src="https://img.shields.io/github/actions/workflow/status/qqxiaoming/quardCRT/macos.yml?branch=main&amp;logo=apple" alt="Macos ci" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.codefactor.io%2Frepository%2Fgithub%2Fqqxiaoming%2FquardCRT"><img src="https://img.shields.io/codefactor/grade/github/qqxiaoming/quardCRT.svg?logo=codefactor" alt="CodeFactor" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/license/qqxiaoming/quardCRT.svg?colorB=f48041&amp;logo=gnu" alt="License" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Freleases"><img src="https://img.shields.io/github/tag/QQxiaoming/quardCRT.svg?logo=git" alt="GitHub tag (latest SemVer)" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT%2Freleases"><img src="https://img.shields.io/github/downloads/QQxiaoming/quardCRT/total.svg?logo=pinboard" alt="GitHub All Releases" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/stars/QQxiaoming/quardCRT.svg?logo=github" alt="GitHub stars" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FQQxiaoming%2FquardCRT"><img src="https://img.shields.io/github/forks/QQxiaoming/quardCRT.svg?logo=github" alt="GitHub forks" referrerpolicy="no-referrer"></a><a href="https://gitee.com/QQxiaoming/quardCRT"><img src="https://gitee.com/QQxiaoming/quardCRT/badge/star.svg?theme=dark" alt="Gitee stars" referrerpolicy="no-referrer"></a><a href="https://gitee.com/QQxiaoming/quardCRT"><img src="https://gitee.com/QQxiaoming/quardCRT/badge/fork.svg?theme=dark" alt="Gitee forks" referrerpolicy="no-referrer"></a></p><h1><a id="user-content-quardcrt" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#quardcrt"></a>quardCRT</h1><p><a href="https://gitee.com/QQxiaoming/quardCRT/blob/main/README.md">English</a> | 簡體中文</p><p>quardCRT 一款終端仿真軟件，支持多種後端協議，無依賴跨平台使用，windows/linux/mac 使用體驗完全一致，支持多標籤頁和歷史記錄管理。</p><table><thead><tr><th align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/windows.png" alt="img2" referrerpolicy="no-referrer"></th></tr></thead><tbody><tr><td align="center">Windows</td></tr><tr><td align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/macos.png" alt="img1" referrerpolicy="no-referrer"></td></tr><tr><td align="center">MacOS</td></tr><tr><td align="center"><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/linux.png" alt="img3" referrerpolicy="no-referrer"></td></tr><tr><td align="center">Linux</td></tr></tbody></table><p>其他協議選擇界面：</p><p><img src="https://gitee.com/QQxiaoming/quardCRT/raw/main/docs/img4.png" alt="img4" referrerpolicy="no-referrer"></p><h2><a id="user-content-功能描述" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E5%8A%9F%E8%83%BD%E6%8F%8F%E8%BF%B0"></a>功能描述</h2><ul><li><p>目前支持的終端協議包括：</p><ul><li>telnet (支持帶 websocket 封裝)</li><li>serial</li><li>loaclshell</li><li>rawsocket</li></ul></li><li><p>多標籤頁管理，標籤頁克隆，標籤頁拖拽排序</p></li><li><p>雙列分屏</p></li><li><p>工作目錄書籤</p></li><li><p>自動化發送</p></li><li><p>HEX 顯示</p></li><li><p>歷史記錄管理 (進行中)</p></li><li><p>終端樣式配置</p></li><li><p>自定義字體 (進行中，目前固定等寬字體，大小可配置)</p></li></ul><h2><a id="user-content-貢獻" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E8%B4%A1%E7%8C%AE"></a>貢獻</h2><p>如果您對本項目有建議或想法，歡迎在 GitHub 或 Gitee 上提交 issue 和 pull requests。</p><p>目前項目建議使用版本 Qt6.2.0 或更高版本。</p><h2><a id="user-content-感謝" class="anchor" href="https://gitee.com/QQxiaoming/quardCRT#%E6%84%9F%E8%B0%A2"></a>感謝</h2><p>本項目代碼引用或部份參考或依賴了以下開源項目，項目完全尊重原項目開源協議，並在此表示感謝。</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FColinDuquesnoy%2FQDarkStyleSheet">QDarkStyleSheet</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fdridk%2FQFontIcon">QFontIcon</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fsilderan%2FQTelnet">QTelnet</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Flxqt%2Fqtermwidget">qtermwidget</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fkafeg%2Fptyqt">ptyqt</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fbitmeal%2Fargv_split">argv_split</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmbadolato%2FiTerm2-Color-Schemes">iTerm2-Color-Schemes</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Frprichard%2Fwinpty">winpty</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FSM-nzberg%2FQtFancyTabWidget">QtFancyTabWidget</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fteknoraver%2Fqtftp">qtftp</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FJuliaStrings%2Futf8proc">utf8proc</a></li></ul>]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 02:20:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/QQxiaoming/quardCRT</guid>
            <link>https://gitee.com/QQxiaoming/quardCRT</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 架構師日記 - 聊聊開發必掌握的那些實踐技能]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" target="_blank">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt; <img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><span id="OSC_h1_1"></span><h1><span><span><span>一，引言</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>儘管軟件開發一直致力於追求高效、可讀性強、易於維護的特性，但這些特性卻像是一個不可能三角，相互交織，此消彼長。就像底層語言（如彙編和 C 語言）能夠保持高效的運行性能，但在可讀性和維護性方面卻存在短板和劣勢；而高級語言（如 Java 和 Python）在可讀性和可維護性方面表現出色，但在執行效率方面卻存在不足。</span></span></span></p><blockquote><span><span><span>構建語言生態的優勢，彌補其存在短板，始終是編程語言的一個演進方向。</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>不同編程語言，擁有不同的特性和規約，下面就以 JAVA 語言為例，細數那些開發過程中容易被人忽略，但必須掌握的知識點和實踐技能。</span></span></span></p><span id="OSC_h1_2"></span><h1><span><span><span>二，基礎篇</span></span></span></h1><blockquote><span><span><span>1999 年，美國太空總署（NASA）的火星任務失敗：在這次任務中，</span></span></span><span><span><span style="color:#191919">火星氣候探測者號上的飛行系統軟件使用公制單位牛頓計算推進器動力，而地面人員輸入的方向校正量和推進器參數則使用英制單位磅力，導致探測器進入大氣層的高度有誤，最終瓦解碎裂。</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這是由於國際標準（牛）和本土化（磅）的衝突導致的一起事故。由此引出了程序需要關注可維護性這個話題，由於軟件生產往往需要多人協作，可維護性正是協作共識裏的重要一環。關於這方面，讓人最容易想到的就是命名和註釋兩個方面了，下面就展開來探討一下。</span></span></span></p><span id="OSC_h3_3"></span><h3><span><span><span>2.1 關於命名</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>按照閲讀習慣，程序的變量命名法都需要克服單詞間的空格問題，從而把不同單詞串連起來，最終達到創造出一種易於閲讀的新「單詞」的效果。常見的命名方法有以下幾種：</span></span></span></p><ul><li><span><span><span><strong><span>蛇形命名法</span></strong></span></span><span><span><span>（snake case）：又叫下劃線命名法，使用下劃線，單詞小寫，比如：my_system;</span></span></span></span></li><li><span><span><span><strong><span>駝峯命名法</span></strong></span></span><span><span><span>（camel case）：按照單詞首字母區分大小寫，又可細分為大駝峯命名法和小駝峯命名法，比如：MySystem，mySystem;</span></span></span></span></li><li><span><span><span><strong><span>匈牙利命名法</span></strong></span></span><span><span><span>（HN case）：屬性+類型+描述，比如：nLength，</span></span></span><span><span><span style="background-color:#ffffff; color:#333333">g_cch</span></span></span><span><span><span>,</span></span></span><span><span><span style="background-color:#ffffff; color:#333333">hwnd；</span></span></span></span></li><li><span><span><span><strong><span>帕斯卡命名法</span></strong></span></span><span><span><span>（Pascal case）：全部首字母大寫，等同於大駝峯命名法，比如：MySystem；</span></span></span></span></li><li><span><span><span><strong><span>脊柱命名法</span></strong></span></span><span><span><span>（spinal case）：使用中劃線，比如：my-system；</span></span></span></span></li><li><span><span><span><strong><span>自由命名法</span></strong></span></span><span><span><span>（studly caps）：大小寫混雜，無簡明規則，比如：mySYSTEM，MYSystem；</span></span></span></span></li></ul><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>按照受眾量與知名程度排名，駝峯命名法和蛇形命名法更受到大家的歡迎，畢竟它們在可讀性，易寫性等方面比較有優勢。</span></span></span></p><span id="OSC_h4_4"></span><h4><span><span><span>2.1.1 命名字典</span></span></span></h4><blockquote><span><span><span>見名知意：好的命名就是一種註釋。</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>建議研發同學將業內常見業務場景的命名熟記，當然，已經有人幫我們總結過了，這裏不再做過多的説明。這裏摘錄如下，可供參考：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>管理類命名</span></strong></span></span><span><span><span>：Bootstrap，Starter，Processor，Manager，Holder，Factory，Provider，Registrar，Engine，Service，Task</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>傳播類命名</span></strong></span></span><span><span><span>：Context，Propagator</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>回調類命名</span></strong></span></span><span><span><span>：Handler，Callback，Trigger，Listener，Aware</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>監控類命名</span></strong></span></span><span><span><span>：Metric，Estimator，Accumulator，Tracker</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>內存管理類命名</span></strong></span></span><span><span><span>：Allocator，Chunk，Arena，Pool</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>過濾檢測類命名</span></strong></span></span><span><span><span>：Pipeline，Chain，Filter，Interceptor，Evaluator，Detector</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>結構類命名</span></strong></span></span><span><span><span>：Cache，Buffer，Composite，Wrapper，Option, Param,Attribute，Tuple，Aggregator，Iterator，Batch，Limiter</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>常見設計模式命名</span></strong></span></span><span><span><span>：Strategy，Adapter，Action，Command，Event，Delegate，Builder，Template，Proxy</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>解析類命名</span></strong></span></span><span><span><span>：Converter，Resolver，Parser，Customizer，Formatter</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>網絡類命名</span></strong></span></span><span><span><span>：Packet，Encoder、Decoder、Codec，Request，Response</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>CRUD 命名</span></strong></span></span><span><span><span>：Controller，Service，</span></span></span><span><span><span style="background-color:#ffffff; color:#4d4d4d">Repository</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>輔助類命名</span></strong></span></span><span><span><span>：Util，Helper</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><strong><span>其他類命名</span></strong></span></span><span><span><span>：Mode，Type，Invoker，Invocation，Initializer，Future，Promise，Selector，Reporter，Constants，Accessor，Generator</span></span></span></p><span id="OSC_h4_5"></span><h4><span><span><span>2.1.2 命名實踐</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>工程通用命名規則</span></span></span><span><span><span style="background-color:#ffffff; color:#4d4d4d">都有哪些呢？不同的語言可能會有不同的習慣，以 Java 語言的駝峯命名規範舉例：</span></span></span></p><div><span style="color:#4d4d4d">1.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">項目名全部小寫；</span></span></span></span></div><div><span style="color:#4d4d4d">2.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">包名全部小寫；</span></span></span></span></div><div><span style="color:#4d4d4d">3.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">類名首字母大寫,其餘組成詞首字母依次大寫；</span></span></span></span></div><div><span style="color:#4d4d4d">4.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">變量名,方法名首字母小寫,如果名稱由多個單詞組成,除首字母外的每個單詞首字母都要大寫；</span></span></span></span></div><div><span style="color:#4d4d4d">5.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">常量名全部大寫；</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span style="background-color:#ffffff; color:#4d4d4d">規範比較抽象，先來看看不好的命名有哪些呢？</span></span></span></p><div><span style="color:#4d4d4d">1.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">自帶混淆功能的變量名：String zhrmghg = "極致縮寫型";</span></span></span></span></div><div><span style="color:#4d4d4d">2.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">沒有意義的萬能變量名：String a,b,c="愛誰誰型";</span></span></span></span></div><div><span style="color:#4d4d4d">3.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">長串拼音變量名：</span></span></span><span><span><span>String </span></span></span><span><span><span style="background-color:#ffffff; color:#4d4d4d">HuaBuHua = "考古型";</span></span></span></span></div><div><span style="color:#4d4d4d">4.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">各種符號混用：String $my_first_name_ = "打死記不住型";</span></span></span></span></div><div><span style="color:#4d4d4d">5.</span><span><span><span><span style="background-color:#ffffff; color:#4d4d4d">大小寫，數字，縮寫混亂：String waitRPCResponse1 = "極易出錯型";</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span style="background-color:#ffffff; color:#4d4d4d">除了標準的規範之外，在實際的開發過程中還會有一些困擾我們的實際案例。</span></span></span></p><blockquote><span><span><span>1. 在定義一個成員變量的時候，到底是使用包裝類型還是使用基本數據類型呢？</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>包裝類和基本數據類型的默認值是不一樣的，前者是 null，後者依據不同類型其默認值也不一樣。從數據嚴謹的角度來講，包裝類的 null 值能夠表示額外信息，從而更加安全。比如可以規避基本類型的自動拆箱，導致的 NPE 風險以及業務邏輯處理異常風險。所以成員變量必須使用包裝數據類型，基本數據類型則在局部變量的場景下使用。</span></span></span></p><blockquote><span><span><span>2. 為什麼不建議布爾類型的成員變量以 is 開頭？</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>關於 Java Bean 中的 getter/setter 方法的定義其實是有明確的規定的，根據 JavaBeans(TM) Specification 規定，如果是普通的參數，命名為 propertyName，需要通過以下方式定義其 setter/getter：</span></span></span></p><pre><code><span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span>&lt;PropertyType&gt;</span></span><span><span> get</span></span><span><span>&lt;PropertyName&gt;</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span> set</span></span><span><span>&lt;PropertyName&gt;</span></span><span><span style="color:#999999">(</span></span><span><span>&lt;PropertyType&gt;</span></span><span><span> p</span></span><span><span style="color:#999999">)</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:justify"><span><span><span>但是，布爾類型的變量 propertyName 則是另外一套命名原則的：</span></span></span></p><pre><code><span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">boolean</span></span><span><span> is</span></span><span><span>&lt;PropertyName&gt;</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span> set</span></span><span><span>&lt;PropertyName&gt;</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">boolean</span></span><span><span> p</span></span><span><span style="color:#999999">)</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>由於各種 RPC 框架和對象序列化工具對於布爾類型變量的處理方式存在差異，就容易造成代碼移植性問題。最常見的 json 序列化庫 Jackson 和 Gson 之間就存在兼容性問題，前者是通過</span></span></span><span><span><span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">通過反射遍歷出該類中的所有 getter 方法，通過方法名截取獲得到對象的屬性，後者則是通過反射直接遍歷該類中的屬性。為了規避這種差異對業務的影響，建議所有成員變量都不要以 is 開頭，防止序列化結果出現不預知的情況發生。</span></span></span></p><blockquote><span><span><span>3. 看看單詞大小寫能引起的哪些副作用？</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>JAVA 語言本身是區分大小寫的，但是在用文件路徑、文件名對文件進行操作時，這裏的文件名和路徑是不區分大小寫的，這是因為文件系統不區分大小寫。典型的場景就是我們通過 git 等代碼管理平台時，將 package 路徑裏的大寫的文件名稱，修改為小寫時，git 是無法更新的，為了規避不必要的麻煩，這裏建議包路徑統一使用小寫單詞，多個單詞通過路徑層次來進行定義。</span></span></span></p><blockquote><span><span><span>4. 不同 jar 包裏的類也會出現衝突問題？</span></span></span></blockquote><div><span>1.</span><span><span><span><span>一類是同一個 jar 包出現了多個不同的版本。應用選擇了錯誤的版本導致 jvm 加載不到需要的類或者加載了錯誤版本的類；（藉助 maven 管理工具相對容易解決）</span></span></span></span></div><div><span>2.</span><span><span><span><span>另一類是不同的 jar 包出現了類路徑相同的類，同樣的類出現在不同的依賴 jar 裏，由於 jar 加載的先後順序導致了 JVM 加載了錯誤版本的類；（比較難以解決）</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這裏着重介紹第二種情況，這種情況容易出現在系統拆分重構時，將原有的項目進行了複製，然後刪減，導致部分工具或者枚舉類和原有的路徑和命名都一樣，當第三方調用方同時依賴了這兩個系統時，就容易為以後的迭代埋下坑。要規避此類問題，一定要為系統起一個獨一無二的 package 路徑。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>補充：如果依賴的都是第三方的庫，存在着類衝突時，可以通過引入第三方庫 jarjar.jar，修改其中某個衝突 jar 文件的包名，以此來解決 jar 包衝突。</span></span></span></p><blockquote><span><span><span>5. 在變量命名的可讀性和佔用資源（內存，帶寬）方面，如何去做權衡？</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>可以通過對象序列化工具為突破口，以常見的 Json（Jackson）序列化方式來舉例：</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">SkuKey</span></span><span><span></span></span><span><span style="color:#0077aa">implements</span></span><span><span></span></span><span><span style="color:#dd4a68">Serializable</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span>@JsonProperty</span></span><span><span style="color:#999999">(</span></span><span><span>value </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">"sn"</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span>@ApiModelProperty</span></span><span><span style="color:#999999">(</span></span><span><span>name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">"stationNo"</span></span><span><span style="color:#999999">,</span></span><span><span> value </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">" 門店編號"</span></span><span><span style="color:#999999">,</span></span><span><span> required </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">true</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#dd4a68">Long</span></span><span><span> stationNo</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span>@JsonProperty</span></span><span><span style="color:#999999">(</span></span><span><span>value </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">"si"</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span>@ApiModelProperty</span></span><span><span style="color:#999999">(</span></span><span><span>name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">"skuId"</span></span><span><span style="color:#999999">,</span></span><span><span> value </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#669900">" 商品編號"</span></span><span><span style="color:#999999">,</span></span><span><span> required </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">true</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#dd4a68">Long</span></span><span><span> skuId</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 省略 get/set 方法</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>其中@JsonProperty 註解的作用就是將 JavaBean 中的普通屬性在序列化的時候，重新命名成指定的新的名字。而這一實現對於業務實現沒有影響，依然以原來的命名操作為準，只在對外 RPC 需要序列化和反序列化的過程生效。如此，比較好的解決了可讀性和資源佔用的衝突問題。</span></span></span></p><blockquote><span><span><span>6. 對外提供服務的入參和出參，我們是用 class 對象，還是 Map 容器？</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>從靈活性的角度看，Map 容器穩定且更靈活。從穩定性和可讀性上來看，Map 容器是個黑盒子，不知道里面有什麼，得有輔助的詳細説明文檔才能協作，由於維護文檔的動作往往與工程代碼是分開的，這中機制就會導致信息的準確性和實時性很難得到保障。所以還是建議使用 class 結構對象維護出入參結構。</span></span></span></p><span id="OSC_h3_6"></span><h3><span><span><span>2.2 關於註釋</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>註釋是程序員和閲讀者之間交流的重要手段，是對代碼的解釋和説明，好的註釋可以提高軟件的可讀性，減少維護軟件的成本。</span></span></span></p><span id="OSC_h4_7"></span><h4><span><span><span>2.2.1 好的註釋</span></span></span></h4><blockquote><span><span><strong><span>分層次</span></strong></span></span><span><span><span>：按照系統，包，類，方法，代碼塊，代碼行等不同粒度，各有側重點的進行註釋説明。</span></span></span></blockquote><div><span>1.</span><span><span><span><strong><span>系統註釋</span></strong></span></span><span><span><span>：通過 README.md 文件體現宏觀的功能和架構實現；</span></span></span></span></div><div><span>2.</span><span><span><span><strong><span>包註釋</span></strong></span></span><span><span><span>：通過 package-info 文件體現模塊職責邊界，另外該文件也支持聲明友好類，包常量以及為標註在包上的註解（Annotation）提供便利；</span></span></span></span></div><div><span>3.</span><span><span><span><strong><span>類註釋</span></strong></span></span><span><span><span>：主要體現功能職責，版本支持，作者歸屬，應用示例等相關信息；</span></span></span></span></div><div><span>4.</span><span><span><span><strong><span>方法註釋</span></strong></span></span><span><span><span>：關注入參，出參，異常處理聲明，使用場景舉例等相關內容；</span></span></span></span></div><div><span>5.</span><span><span><span><strong><span>代碼塊和代碼行註釋</span></strong></span></span><span><span><span>：主要體現邏輯意圖，閉坑警示，規劃 TODO，放大關注點等細節內容；</span></span></span></span></div><blockquote><span><span><strong><span>有規範</span></strong></span></span><span><span><span>：好的代碼優於大量註釋，這和我們常説的「約定大於配置」是相同的道理。藉助 swagger 等三方庫實現</span></span></span><span><span><strong><span>註解即接口文檔</span></strong></span></span><span><span><span>，是一個不錯的規範方式；</span></span></span></blockquote><span id="OSC_h4_8"></span><h4><span><span><span>2.2.2 壞的註釋</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>為了能使註釋準確清晰的表達出功能邏輯，註釋的維護是有相當的維護成本的，所以註釋並不是越多，越詳細越好。下面就舉一些壞的註釋場景，輔助理解：</span></span></span></p><div><span>1.</span><span><span><span><strong><span>冗餘式</span></strong></span></span><span><span><span>：</span></span></span><span><span><span style="background-color:#ffffff; color:#404040">如果一個函數，讀者能夠很容易的就讀出來代碼要表達的意思，註釋就是多餘的；</span></span></span></span></div><div><span style="color:#404040">2.</span><span><span><span><strong><span>錯誤</span></strong></span></span><span><span><strong><span>式</span></strong></span></span><span><span><span style="background-color:#ffffff; color:#404040">：如果註釋的不清楚，甚至出現歧義，那還不如不寫；</span></span></span></span></div><div><span style="color:#404040">3.</span><span><span><span><strong><span>簽名式</span></strong></span></span><span><span><span style="background-color:#ffffff; color:#404040">：類似「add by liuhuiqing 2023-08-05」這種註釋，容易過期失效而且不太可信（不能保證所有人每次都採用這種方式註釋），其功能完全可以由 git 代碼管理工具來實現；</span></span></span></span></div><div><span style="color:#404040">4.</span><span><span><span><strong><span>長篇大論式</span></strong></span></span><span><span><span style="background-color:#ffffff; color:#404040">：代碼塊裏，夾雜了大篇幅的註釋，不僅影響代碼閲讀，而且維護困難；</span></span></span></span></div><div><span style="color:#404040">5.</span><span><span><span><strong><span>非本地註釋</span></strong></span></span><span><span><span style="background-color:#ffffff; color:#404040">：註釋應該在離代碼實現最近的地方，比如：被調用的方法註釋就由方法本身來維護，調用方無需對方法做詳細的説明；</span></span></span></span></div><div><span style="color:#404040">6.</span><span><span><span><strong><span>註釋掉的代碼</span></strong></span></span><span><span><span style="background-color:#ffffff; color:#404040">：無用的代碼應該刪除，而不是註釋。歷史記錄交給 git 等代碼管理工具來維護；</span></span></span></span></div><span id="OSC_h3_9"></span><h3><span><span><span>2.3 關於分層</span></span></span></h3><blockquote><span><span><span>系統分層設計的主要目是通過分離關注點，來降低系統的複雜度，同時提高可複用性和降低維護成本。所以懂得分層的概念，很大程度上系統的可維護性就有了骨架。</span></span></span></blockquote><span id="OSC_h4_10"></span><h4><span><span><span style="background-color:#ffffff; color:#4d4d4d">2.3.1 系統分層 </span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span style="background-color:#ffffff; color:#4d4d4d">在 ISO(（International Standardization Organization）) 於 1981 年制定網絡通信七層模型 (Open System Interconnection Reference Model，OSI/RM) 之前，計算機網絡中存在眾多的體系結構，其中以 IBM 公司的 SNA(系統網絡體系結構) 和 DEC 公司的 DNA(DigitalNetworkArchitecture) 數字網絡體系結構最為著名。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span style="background-color:#ffffff; color:#4d4d4d">最早之前，各個廠家提出的不同標準都是以自家設備為基礎的，用戶在選擇產品的時候就只能用同一家公司的，因為不同公司間大家的標準不一樣，工作方式也可能不一樣，結果就是不同廠商的網絡產品間，可能會出現不兼容的情況。如果説同一家的公司的產品都能滿足用戶的需求的話，那就看哪家公司實力強點，實力強的，用戶粘性高的，用戶自然也不會説什麼，問題是一家公司並不是對所有的產品都擅長。這就會導致廠商和用戶都面臨着痛苦的煎熬。類比一下當前手機充電接口協議（Micro USB 接口、Type- c 接口、Lightning 接口），手頭總是要備有各種充電線的場景，就能深刻理解標準的意義了。</span></span></span></p><span id="OSC_h4_11"></span><h4><span><span><span>2.3.2 軟件伸縮性</span></span></span></h4><blockquote><span><span><span>軟件伸縮性指的是軟件系統在面對負載壓力時，能夠保持原有性能並擴展以支持更多任務的能力。</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>伸縮性可以有兩個方面，垂直伸縮性和水平伸縮性，垂直伸縮性是通過在同一個業務單元中增加資源來提高系統的吞吐量，比如增加服務器 cpu 的數量，增加服務器的內存等。水平伸縮性是通過增加多個業務單元資源，使得所有的業務單元邏輯上就像是一個單元一樣。比如 ejb 分佈式組件模型，微服務組件模型等都屬於此種方式。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>軟件系統在設計時需要考慮如何進行有效的伸縮性設計，以確保在面對負載壓力時能夠提供足夠的性能支持。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>系統分層從伸縮性角度看，更多的屬於水平伸縮性的範疇。在 J2EE 系統開發當中，我們普遍採用了分層構架的方式，一般分為表現層，業務層和持久層。採用分層以後，因為層與層之間通信會引來額外的開銷，所以給我們軟件系統帶來的就是每個業務處理開銷會變大。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>既然採用分層會帶來額外的開銷，那麼我們為什麼還要進行分層呢？</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這是因為單純依靠堆硬件資源的垂直伸縮方式來提高軟件性能和吞吐是有上限的，而且隨着系統規模的擴大，垂直伸縮的代價也將變得非常昂貴。當採用了分層以後，雖然層與層之間帶來了通信開銷，但是它有利於各層的水平伸縮性，並且各個層都可以進行獨立的伸縮而不會影響到其它的層。也就是説當系統要應對更大的訪問量的時候，我們可以通過增加多個業務單元資源來增加系統吞吐量。</span></span></span></p><span id="OSC_h3_12"></span><h3><span><span><span>2.4 小結</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>本章內容主要從可讀性和可維護性方面講述了在開發過程中，要做好命名和註釋的統一共識。除了共識之外，在設計層面也需要做好關注點的隔離，這包含系統職責的拆分，模塊功能的劃分，類能力的收斂，實體結構的關係都需要做好規劃。</span></span></span></p><span id="OSC_h1_13"></span><h1><span><span><span>三，實踐篇</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>下面就從程序的擴展性，維護性，安全性以及性能等幾個重要質量指標，來學習那些經典的實踐案例。</span></span></span></p><span id="OSC_h3_14"></span><h3><span><span><span>3.1 類定義</span></span></span></h3><span id="OSC_h4_15"></span><h4><span><span><span>3.1.1 常量定義</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>常量是一種固定值，不會在程序執行期間發生改變。你可以使用枚舉（Enum）或類（Class）來定義常量。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果你需要定義一組相關的常量，那麼使用枚舉更為合適。枚舉從安全性和可操作性（支持遍歷和函數定義）上面擁有更大的優勢。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">enum</span></span><span><span></span></span><span><span style="color:#dd4a68">Color</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
 RED</span></span><span><span style="color:#999999">,</span></span><span><span> GREEN</span></span><span><span style="color:#999999">,</span></span><span><span> BLUE</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>如果你只需要定義一個或少數幾個只讀的常量，那麼使用類常量更為簡潔和方便。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">MyClass</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> MAX_VALUE </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">100</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h4_16"></span><h4><span><span><span>3.1.2 工具類</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>工具類通常包含具有通用性的、某一非業務領域內的公共方法，不需要配套的成員變量，僅僅是作為工具方法被使用。因此，將其做成靜態方法最合適，不需要實例化，能夠獲取到方法的定義並調用就行。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>工具類不實例化的原因是可以節省內存空間，因為工具類提供的是靜態方法，通過類就能調用，不需要實例化工具類對象。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">abstract</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">ObjectHelper</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">boolean</span></span><span><span></span></span><span><span style="color:#dd4a68">isEmpty</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> str</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> str </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">==</span></span><span><span></span></span><span><span style="color:#0077aa">null</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">||</span></span><span><span> str</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">length</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">==</span></span><span><span></span></span><span><span style="color:#990055">0</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>為了實現不需要實例化對象的約束，我們最好在類定義時，加上</span></span></span><span><span><strong><span>abstract</span></strong></span></span><span><span><span>關鍵字進行聲明限定，這也是為什麼 spring 等開源工具類大都使用 abstract 關鍵字修飾的原因。</span></span></span></p><span id="OSC_h4_17"></span><h4><span><span><span>3.1.3 JavaBean</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>JavaBean 的定義有兩種常見實現方式：手動編寫和自動生成。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> age</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> age</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> name</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>age </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> age</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span></span></span><span><span style="color:#dd4a68">getName</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> name</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">setName</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> name</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span></span></span><span><span style="color:#dd4a68">getAge</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> age</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">setAge</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">int</span></span><span><span> age</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>age </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> age</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>使用 lombok 插件，</span></span></span><span><span><span style="background-color:#ffffff; color:#1e1f24">通過註解方式來增強 Java 代碼的編寫，在編譯期動態生成 get 和 set 方法。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">import</span></span><span><span></span></span><span><span>lombok.</span></span><span><span style="color:#dd4a68">Data</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span>@NoArgsConstructor</span></span><span><span></span></span><span><span>@Data</span></span><span><span></span></span><span><span>@Accessors</span></span><span><span style="color:#999999">(</span></span><span><span>chain </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#990055">true</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> age</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>插件包還提供了@Builder 和@Accessors 等比較實用的鏈式編程能力，在一定程度上能提高編碼效率。</span></span></span></p><span id="OSC_h4_18"></span><h4><span><span><span>3.1.4 不可變類</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在某些場景下，類為了保證其功能和行為的穩定性和一致性，會被設計為不能被繼承和重寫的。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>定義方式就是在類上面添加 final 關鍵字，示例：</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span></span></span><span><span style="color:#0077aa">implements</span></span><span><span></span></span><span><span style="color:#dd4a68">Serializable</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">Comparable</span></span><span><span>&lt;String&gt;</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">CharSequence</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>以下是一些不能被繼承和重寫的類，這在一些底層中間件中會有應用：</span></span></span></p><pre><code><span><span><span style="color:#dd4a68">java.lang.String</span></span><span><span></span></span><span><span style="color:#dd4a68">java.lang.Math</span></span><span><span></span></span><span><span style="color:#dd4a68">java.lang.Boolean</span></span><span><span></span></span><span><span style="color:#dd4a68">java.lang.Character</span></span><span><span></span></span><span><span style="color:#dd4a68">java.util.Date</span></span><span><span></span></span><span><span style="color:#dd4a68">java.sql.Date</span></span><span><span></span></span><span><span style="color:#dd4a68">java.lang.System</span></span><span><span></span></span><span><span style="color:#dd4a68">java.lang.ClassLoader</span></span></span></code></pre><span id="OSC_h4_19"></span><h4><span><span><span>3.1.5 匿名內部類</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>匿名內部類通常用於簡化代碼，它的定義和使用通常發生在同一處，它的使用場景如下：</span></span></span></p><div><span>1.</span><span><span><span><span>直接作為參數傳遞給方法或構造函數；</span></span></span></span></div><div><span>2.</span><span><span><span><span>用於實現某個接口或抽象類的匿名實例；</span></span></span></span></div><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Example</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// 創建一個匿名內部類</span></span><span><span></span></span><span><span style="color:#dd4a68">Runnable</span></span><span><span> runnable </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Runnable</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span>@Override</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">run</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"Hello, World!"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 調用匿名內部類的方法</span></span><span><span>
        runnable</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">run</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h4_20"></span><h4><span><span><span>3.1.6 聲明類</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>聲明類是 Java 語言中的基本類型或接口，用於定義類的行為或特性，有的甚至只是個聲明，沒有具體的方法定義。</span></span></span></p><div><span>•</span><span><span><span><span>AutoCloseable：表示實現了該接口的類可以被自動關閉，通常用於資源管理。</span></span></span></span></div><div><span>•</span><span><span><span><span>Comparable：表示實現了該接口的類可以與其他實現了該接口的對象進行比較。</span></span></span></span></div><div><span>•</span><span><span><span><span>Callable：表示實現了該接口的類可以作為參數傳遞給線程池，並返回結果。</span></span></span></span></div><div><span>•</span><span><span><span><span>Cloneable：表示實現了該接口的類可以被克隆。</span></span></span></span></div><div><span>•</span><span><span><span><span>Enum：表示實現了該接口的類是一個枚舉類型。</span></span></span></span></div><div><span>•</span><span><span><span><span>Iterable：表示實現了該接口的類可以迭代。</span></span></span></span></div><div><span>•</span><span><span><span><span>Runnable：表示實現了該接口的類可以作為線程運行。</span></span></span></span></div><div><span>•</span><span><span><span><span>Serializable：表示實現了該接口的類可以被序列化和反序列化。</span></span></span></span></div><div><span>•</span><span><span><span><span>interface：表示實現了該接口的類是一個接口，可以包含方法聲明。</span></span></span></span></div><div><span>•</span><span><span><span><span>Annotation：表示實現了該接口的類是一個註解，可以用於元數據描述。</span></span></span></span></div><span id="OSC_h4_21"></span><h4><span><span><span>3.1.7 Record 類</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Record 類在 Java14 中就開始預覽，一直到 Java17 才正式發佈。根據 JEP395 的描述，Record 類是不可變數據的載體，類似於當下廣泛應用的各種 model，dto，vo 等 POJO 類，但 record 本身在構造之後不再可賦值。所有的 record 類都繼承自 java.lang.Record。</span></span></span><span><span><strong><span>Record 類默認提供了全字段的構造器，屬性的訪問，還有 equals，hashcode，toString 方法，其作用和 lombok 插件非常類似</span></strong></span></span><span><span><span>。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>定義方式</span></span></span></p><pre><code><span><span><span style="color:#708090">/**
 * 關鍵定義的類是不可變類
 * 將所有成員變量通過參數的形式定義
 * 默認會生成全部參數的構造方法
 * @param name
 * @param age
 */</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">record</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> age</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">if</span></span><span><span style="color:#999999">(</span></span><span><span>name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">==</span></span><span><span></span></span><span><span style="color:#0077aa">null</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">throw</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">IllegalArgumentException</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"提供緊湊的方式進行參數校驗"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#708090">/**
     * 定義的類中可以定義靜態方法
     * @param name
     * @return
     */</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span></span></span><span><span style="color:#dd4a68">of</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span style="color:#999999">(</span></span><span><span>name</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#990055">18</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>使用方式</span></span></span></p><pre><code><span><span><span style="color:#dd4a68">Person</span></span><span><span> person </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Person</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"John"</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#990055">30</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// Person person = Person.of("John");</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> person</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">name</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> age </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> person</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">age</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>使用場景</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>通過 Record 構建一個臨時存儲對象，將 Person 數組對象按照年齡排序。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">List</span></span><span><span>&lt;Person&gt;</span></span><span><span></span></span><span><span style="color:#dd4a68">sortPeopleByAge</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">List</span></span><span><span>&lt;Person&gt;</span></span><span><span> people</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">record</span></span><span><span></span></span><span><span style="color:#dd4a68">Data</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Person</span></span><span><span> person</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> age</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">{</span></span><span><span style="color:#999999">}</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> people</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">stream</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">map</span></span><span><span style="color:#999999">(</span></span><span><span>person </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-&gt;</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Data</span></span><span><span style="color:#999999">(</span></span><span><span>person</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">computAge</span></span><span><span style="color:#999999">(</span></span><span><span>person</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">sorted</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span>d1</span></span><span><span style="color:#999999">,</span></span><span><span> d2</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-&gt;</span></span><span><span></span></span><span><span style="color:#dd4a68">Integer</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">compare</span></span><span><span style="color:#999999">(</span></span><span><span>d2</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">age</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">,</span></span><span><span> d1</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">age</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">map</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Data</span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">::</span></span><span><span style="color:#dd4a68">person</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">collect</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">toList</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span></span></span><span><span style="color:#dd4a68">computAge</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">Person</span></span><span><span> person</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> person</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">age</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-</span></span><span><span></span></span><span><span style="color:#990055">1</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h4_22"></span><h4><span><span><span>3.1.8 </span></span></span><span><span><span style="background-color:#ffffff; color:#1e1f24">密封類</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Java 17 推出的新特性密封類（Sealed Classes），主要作用就是限制類的繼承。我們知道之前對類繼承功能的限制主要有兩種：</span></span></span></p><div><span>1.</span><span><span><span><span>final 修飾類，這樣類就無法被繼承了；</span></span></span></span></div><div><span>2.</span><span><span><span><span>package-private 類，可以控制只能被同一個包下的類繼承；</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>但很顯然，這兩種限制方式的力度都非常粗，而密封類正是對類繼承的更細粒度的控制。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">sealed</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">SealedClass</span></span><span><span></span></span><span><span style="color:#0077aa">permits</span></span><span><span></span></span><span><span style="color:#dd4a68">SubClass1</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">SubClass2</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">SubClass1</span></span><span><span></span></span><span><span style="color:#0077aa">extends</span></span><span><span></span></span><span><span style="color:#dd4a68">SealedClass</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">SubClass2</span></span><span><span></span></span><span><span style="color:#0077aa">extends</span></span><span><span></span></span><span><span style="color:#dd4a68">SealedClass</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>在上面的示例中，SealedClass 是一個密封類，它包含兩個子類 SubClass1 和 SubClass2。在 SubClass1 和 SubClass2 的定義中，必須使用 extends 關鍵字來繼承自 SealedClass，並且使用 permits 關鍵字來指定它們允許哪些子類來繼承。通過使用密封類，可以確保只有符合特定條件的子類才能繼承或實現該協議或規範。</span></span></span></p><span id="OSC_h3_23"></span><h3><span><span><span>3.2 方法定義</span></span></span></h3><span id="OSC_h4_24"></span><h4><span><span><span>3.2.1 構造方法</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>構造方法是一種特殊的方法，用於創建和初始化對象。構造方法的名稱必須與類名相同，並且沒有返回類型。在創建對象時，可以通過使用 new 關鍵字來調用構造方法。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">MyClass</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> myInt</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> myString</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 構造方法</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">MyClass</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">int</span></span><span><span> myInt</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> myString</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>myInt </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> myInt</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>myString </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> myString</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>實現單例模式的一個重要特性就是不允許用戶隨意創建（new）對象，如何做到安全控制呢？將構造方法聲明為私有（private）是必不可少的一步。</span></span></span></p><span id="OSC_h4_25"></span><h4><span><span><span>3.2.2 方法重寫</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>方法重寫是指在子類中重新定義與父類中同名的方法。方法重寫允許子類覆蓋父類中的方法實現，以便根據子類的需要實現其自己的行為。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Animal</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">makeSound</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"Animal is making a sound"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Cat</span></span><span><span></span></span><span><span style="color:#0077aa">extends</span></span><span><span></span></span><span><span style="color:#dd4a68">Animal</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span>@Override</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">makeSound</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"Meow"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Main</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">Animal</span></span><span><span> myCat </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Cat</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span>
        myCat</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">makeSound</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 輸出 "Meow"</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>面向對象的三大特性之一的多態，方法重寫是其核心。</span></span></span></p><span id="OSC_h4_26"></span><h4><span><span><span>3.2.3 方法重載</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>類中定義多個方法，它們具有相同的名稱但參數列表不同。方法重載允許我們使用同一個方法名執行不同的操作，根據傳遞給方法的參數不同來執行不同的代碼邏輯。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Calculator</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span></span></span><span><span style="color:#dd4a68">add</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">int</span></span><span><span> a</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> b</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> a </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> b</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">double</span></span><span><span></span></span><span><span style="color:#dd4a68">add</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">double</span></span><span><span> a</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#0077aa">double</span></span><span><span> b</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> a </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> b</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Main</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">Calculator</span></span><span><span> calculator </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Calculator</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span> result1 </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> calculator</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">add</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">2</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#990055">3</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">double</span></span><span><span> result2 </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> calculator</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">add</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">2.5</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#990055">3.5</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span>result1</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 輸出 5</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span>result2</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 輸出 6.0</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h4_27"></span><h4><span><span><span>3.2.4 匿名方法</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Java 8 引入了 Lambda 表達式，可以用來實現類似匿名方法的功能。Lambda 表達式是一種匿名函數，可以作為參數傳遞給方法，或者直接作為一個獨立表達式使用。</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> args</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#dd4a68">List</span></span><span><span>&lt;String&gt;</span></span><span><span> names </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">Arrays</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">asList</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"hello"</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">"world"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 使用 Lambda 表達式作為參數傳遞給 forEach 方法</span></span><span><span>
    names</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">forEach</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-&gt;</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"Name: "</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> name</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 使用 Lambda 表達式作為獨立表達式使用</span></span><span><span></span></span><span><span style="color:#dd4a68">Predicate</span></span><span><span>&lt;String&gt;</span></span><span><span> nameLengthGreaterThan5 </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span> name</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">-&gt;</span></span><span><span> name</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">length</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">&gt;</span></span><span><span></span></span><span><span style="color:#990055">5</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">boolean</span></span><span><span> isLongName </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> nameLengthGreaterThan5</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">test</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"John"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#dd4a68">System</span></span><span><span style="color:#999999">.</span></span><span><span>out</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">println</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"Is long name? "</span></span><span><span></span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">+</span></span><span><span> isLongName</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h3_28"></span><h3><span><span><span>3.3 對象定義</span></span></span></h3><span id="OSC_h4_29"></span><h4><span><span><span>3.3.1 單例對象</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>單例對象是一種可以重複使用的對象，但只有一個實例。它有以下幾個作用：</span></span></span></p><div><span>1.</span><span><span><span><span>控制資源的使用：通過線程同步來控制資源的併發訪問。</span></span></span></span></div><div><span>2.</span><span><span><span><span>控制實例產生的數量：達到節約資源的目的。</span></span></span></span></div><div><span>3.</span><span><span><span><span>作為通信媒介使用：也就是數據共享，它可以在不建立直接關聯的條件下，讓多個不相關的兩個線程或者進程之間實現通信。</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>比如，使用枚舉實現單例模式：</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">enum</span></span><span><span></span></span><span><span style="color:#dd4a68">Singleton</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span>
 INSTANCE</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">someMethod</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// ...其他代碼...</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><span id="OSC_h4_30"></span><h4><span><span><span>3.3.2 不可變對象</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Java 中的不可變對象是指那些一旦被創建，其狀態就不能被修改的對象。不可變對象是一種非常有用的對象，因為它們可以確保對象的狀態在任何時候都是一致的，從而避免了因為修改對象狀態而引發的問題。實現不可變對象有以下幾種方式：</span></span></span></p><div><span>1.</span><span><span><span><span>將對象的狀態存儲在不可變對象中：String、Integer 等就是內置的不可變對象類型；</span></span></span></span></div><div><span>2.</span><span><span><span><span>將對象的狀態存儲在 final 變量中：final 變量一旦被賦值就不能被修改；</span></span></span></span></div><div><span>3.</span><span><span><span><span>將對象的所有屬性都設為不可變對象：這樣就可以確保整個對象都是不可變的；</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>一些容器類的操作也有對應的包裝類實現容器對象的不可變，比如定義不可變數組對象：</span></span></span></p><pre><code><span><span><span style="color:#dd4a68">Collections</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">unmodifiableList</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">ArrayList</span></span><span><span>&lt;&gt;</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span></span></code></pre><blockquote><span><span><span>當領域內的對象作為入參往外傳遞時，將其定義為不可變對象，這在保持數據一致性方面非常重要，否則對象屬性變更的不可預測性，在進行問題定位時，將會非常麻煩。</span></span></span></blockquote><span id="OSC_h4_31"></span><h4><span><span><span>3.3.3 元組對象</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>元組（Tuple）是函數式編程語言中的常見概念，元組是一個不可變，並且能夠以類型安全的形式保存多個不同類型的對象。它是一種非常有用的數據結構，可以讓開發者在處理多個數據元素時更加方便和高效。但原生的 Java 標準庫並沒有提供元組的支持，需要我們自己或藉助第三方類庫來實現。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>二元組實現</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Pair</span></span><span><span>&lt;A,B&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#dd4a68">A</span></span><span><span> first</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#dd4a68">B</span></span><span><span> second</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">Pair</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">A</span></span><span><span> a</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">B</span></span><span><span> b</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>first </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> a</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>second </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> b</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">A</span></span><span><span></span></span><span><span style="color:#dd4a68">getFirst</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> first</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">B</span></span><span><span></span></span><span><span style="color:#dd4a68">getSecond</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> second</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>三元組實現</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Triplet</span></span><span><span>&lt;A,B,C&gt;</span></span><span><span></span></span><span><span style="color:#0077aa">extends</span></span><span><span></span></span><span><span style="color:#dd4a68">Pair</span></span><span><span>&lt;A,B&gt;</span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#dd4a68">C</span></span><span><span> third</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">Triplet</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">A</span></span><span><span> a</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">B</span></span><span><span> b</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#dd4a68">C</span></span><span><span> c</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">super</span></span><span><span style="color:#999999">(</span></span><span><span>a</span></span><span><span style="color:#999999">,</span></span><span><span> b</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>third </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> c</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">C</span></span><span><span></span></span><span><span style="color:#dd4a68">getThird</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> third</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// 表示姓名，性別，年齡</span></span><span><span></span></span><span><span style="color:#dd4a68">Triplet</span></span><span><span>&lt;String,String,Integer&gt;</span></span><span><span> triplet </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Triplet</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"John"</span></span><span><span style="color:#999999">,</span></span><span><span style="color:#669900">"男"</span></span><span><span style="color:#999999">,</span></span><span><span style="color:#990055">18</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 獲得姓名</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> triplet</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">getFirst</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>多元組實現</span></span></span></p><pre><code><span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">class</span></span><span><span></span></span><span><span style="color:#dd4a68">Tuple</span></span><span><span>&lt;E&gt;</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">private</span></span><span><span></span></span><span><span style="color:#0077aa">final</span></span><span><span></span></span><span><span style="color:#dd4a68">E</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> elements</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">Tuple</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">E</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#999999">.</span></span><span><span> elements</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">this</span></span><span><span style="color:#999999">.</span></span><span><span>elements </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> elements</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#dd4a68">E</span></span><span><span></span></span><span><span style="color:#dd4a68">get</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#0077aa">int</span></span><span><span> index</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> elements</span></span><span><span style="color:#999999">[</span></span><span><span>index</span></span><span><span style="color:#999999">]</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">int</span></span><span><span></span></span><span><span style="color:#dd4a68">size</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#0077aa">return</span></span><span><span> elements</span></span><span><span style="color:#999999">.</span></span><span><span>length</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#0077aa">public</span></span><span><span></span></span><span><span style="color:#0077aa">static</span></span><span><span></span></span><span><span style="color:#0077aa">void</span></span><span><span></span></span><span><span style="color:#dd4a68">main</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#dd4a68">String</span></span><span><span style="color:#999999">[</span></span><span><span style="color:#999999">]</span></span><span><span> args</span></span><span><span style="color:#999999">)</span></span><span><span></span></span><span><span style="color:#999999">{</span></span><span><span></span></span><span><span style="color:#708090">// 表示姓名，性別，年齡</span></span><span><span></span></span><span><span style="color:#dd4a68">Tuple</span></span><span><span>&lt;String&gt;</span></span><span><span> tuple </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#0077aa">new</span></span><span><span></span></span><span><span style="color:#dd4a68">Tuple</span></span><span><span>&lt;&gt;</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"John"</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">"男"</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">"18"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#708090">// 獲得姓名</span></span><span><span></span></span><span><span style="color:#dd4a68">String</span></span><span><span> name </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span> tuple</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">get</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#990055">0</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span><span><span></span></span><span><span style="color:#999999">}</span></span><span><span></span></span><span><span style="color:#999999">}</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Tuple 主要有以下幾個功能：</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>1. 存儲多個數據元素：Tuple 可以存儲多個不同類型的數據元素，這些元素可以是基本類型、對象類型、數組等；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>2. 簡化代碼：Tuple 可以使代碼更加簡潔，減少重複代碼的編寫。通過 Tuple，我們可以將多個變量打包成一個對象，從而減少了代碼量；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>3. 提高代碼可讀性：Tuple 可以提高代碼的可讀性。通過 Tuple，我們可以將多個變量打包成一個對象，從而使代碼更加易讀；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>4. 支持函數返回多個值：Tuple 可以支持函數返回多個值。在 Java 中，函數只能返回一個值，但是通過 Tuple，我們可以將多個值打包成一個對象返回；</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>除了自定義之外，實現了元組概念的第三方類庫有：Google Guava，Apache Commons Lang，JCTools，Vavr 等。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Google Guava 庫的 Tuple 提供了更多的功能，並且被廣泛使用。比如，為了使元組的含義更加明確，Guava 提供了命名元組（NamedTuple）的概念。通過給元組命名，可以更清晰地表示每個元素的意義。示例：</span></span></span></p><pre><code><span><span><span style="color:#dd4a68">NamedTuple</span></span><span><span> namedTuple </span></span><span><span style="background-color:rgba(255, 255, 255, 0.5)">=</span></span><span><span></span></span><span><span style="color:#dd4a68">Tuples</span></span><span><span style="color:#999999">.</span></span><span><span style="color:#dd4a68">named</span></span><span><span style="color:#999999">(</span></span><span><span style="color:#669900">"person"</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">"name"</span></span><span><span style="color:#999999">,</span></span><span><span></span></span><span><span style="color:#669900">"age"</span></span><span><span style="color:#999999">)</span></span><span><span style="color:#999999">;</span></span></span></code></pre><span id="OSC_h4_32"></span><h4><span><span><span>3.3.4 臨時對象</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>臨時對象是指在程序執行過程中臨時需要，但生命週期較短的對象。這些對象通常只在使用過程中短暫存在，不需要長期存儲或重複使用。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>關於臨時對象的優化建議如下：</span></span></span></p><div><span>1.</span><span><span><span><span>儘量重用對象。由於系統不僅要花時間生成對象，以後可能還需花時間對這些對象進行垃圾回收和處理，因此，生成過多的對象將會給程序的性能帶來很大的影響，重用對象的策略有緩存對象，也可以針對具體場景進行定向優化，比如使用 StringBuffer 代替字符串拼接的方式；</span></span></span></span></div><div><span>2.</span><span><span><span><span>儘量使用局部變量。調用方法時傳遞的參數以及在調用中創建的臨時變量都保存在棧中，速度較快。其他變量，如靜態變量、實例變量等，都在堆中創建，速度較慢；</span></span></span></span></div><div><span>3.</span><span><span><span><span>分代收集。分代垃圾回收策略，是基於這樣一個事實：不同的對象的生命週期是不一樣的。因此，不同生命週期的對象可以採取不同的收集方式，以便提高回收效率；</span></span></span></span></div><span id="OSC_h4_33"></span><h4><span><span><span>3.3.5 Valhalla</span></span></span></h4><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Java 作為高級語言，和更為底層的 C 語言，彙編語言在性能方面一直存在着不小的差距。為了彌補這一差距，Valhalla 項目於 2014 年啓動，目標是為基於 JVM 的語言帶來更靈活的扁平化數據類型。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>我們都知道 Java 支持原生類型和引用類型兩種。原生數據類型按值傳遞，賦值和函數傳參都會把值給複製一份，複製之後兩份之間就再無關聯； 引用類型無論什麼情況傳的都是指針，修改指針指向的內容會影響到所有的引用。而 Valhalla 又引入了值類型（value types），一種介於原生類型和引用類型之間的概念。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>由於應用程序中的大多數 Java 數據結構都是對象，因此我們可以將 Java 視為指針密集型語言。這種基於指針的對象實現用於啓用對象標識，對象標識本身用於語言特性，如多態性、可變性和鎖定。默認情況下，這些特性適用於每個對象，無論它們是否真的需要。這就是值類型（value types）發揮作用的地方。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>值類型（value types）的概念是表示純數據聚合，這會刪除常規對象的功能。因此，我們有純數據，沒有身份。當然，這意味着我們也失去了使用對象標識可以實現的功能。由於我們不再有對象標識，我們可以放棄指針，改變值類型的一般內存佈局。讓我們來比較一下對象引用和值類型內存佈局。</span></span></span></p><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-08-28-22-34ywa6eBTJAoJdQEn.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><blockquote><span><span><span>去掉了對象頭信息，在 64 位操作系統中值類型節約了對象頭 16 個字節的空間。同時，也意味着放棄對象唯一身份（Identity）和初始化安全性，之前的 wait()，notify()，synchronized(obj)，System.identityHashCode(obj) 等關鍵字或方法都將失效，無法使用。</span></span></span></blockquote><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Valhalla 在提高性能和減少泄漏的抽象方面將會顯著提高：</span></span></span></p><div><span>•</span><span><span><span><span>性能增強通過展平對象圖和移除間接來解決。這將獲得更高效的內存佈局和更少的分配和垃圾回收。</span></span></span></span></div><div><span>•</span><span><span><span><span>當用作泛型類型時，原語和對象具有更相似的行為，這是更好的抽象。</span></span></span></span></div><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>截止到 2023 年 9 月，Valhalla 項目仍在進行中，還沒有正式版本的發佈，這一創新項目值得期待的。</span></span></span></p><span id="OSC_h1_34"></span><h1><span><span><span>四，總結</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>本文總結了軟件開發過程中經常用到的基礎常識，分為基礎篇和實踐篇兩個篇章，其中基礎篇中着重講述了類，方法，變量的命名規範以及代碼註釋好壞的評判標準。實踐篇中從類，方法以及對象三個層面分析了常見的技術概念和落地實踐，希望這些常識能夠為讀者帶來一些思考和幫助。</span></span></span></p><blockquote><p>作者：京東零售&nbsp;劉慧卿</p><p>來源：京東雲開發者社區，轉載請註明來源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 02:15:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10120062</guid>
            <link>https://my.oschina.net/u/4090830/blog/10120062</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[新晉項目 X File Storage 加入 Dromara 開源社區，一站式文件存儲]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><h3><img alt="logo" height="200px" src="https://x-file-storage.xuyanwu.cn/assets/logo.svg" referrerpolicy="no-referrer"><br><span>原名 X Spring File Storage 現已捐贈至 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdromara.org%2Fzh" target="_blank">dromara</a> 開源組織</span></h3><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.dromara.org" target="_blank">x-file-storage.dromara.org</a> | <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn" target="_blank">x-file-storage.xuyanwu.cn</a> | <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspring-file-storage.xuyanwu.cn" target="_blank">spring-file-storage.xuyanwu.cn</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcentral.sonatype.com%2Fsearch%3Fq%3Dorg.dromara.x-file-storage" target="_blank"><img src="https://img.shields.io/maven-central/v/org.dromara.x-file-storage/x-file-storage-core.svg?label=Maven%20Central" referrerpolicy="no-referrer"></a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.apache.org%2Flicenses%2FLICENSE-2.0" target="_blank"><img src="https://img.shields.io/badge/license-Apache%202-green.svg" referrerpolicy="no-referrer"></a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2Fdownloads%2Findex.html" target="_blank"><img src="https://img.shields.io/badge/JDK-8+-blue.svg" referrerpolicy="no-referrer"></a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdromara%2Fx-file-storage" target="_blank"><img alt="github star" src="https://img.shields.io/github/stars/dromara/x-file-storage.svg?style=social" referrerpolicy="no-referrer"></a><a href="https://gitee.com/dromara/x-file-storage"><img alt="star" src="https://gitee.com/dromara/x-file-storage/badge/star.svg?theme=dark" referrerpolicy="no-referrer"></a><br><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3DeGfeNqka" target="_blank"><img alt="" src="https://img.shields.io/badge/QQ%E7%BE%A4-515706495-orange" referrerpolicy="no-referrer"></a></p><h1>📚簡介</h1><p>一行代碼將文件存儲到本地、FTP、SFTP、WebDAV、阿里雲 OSS、華為雲 OBS、七牛雲 Kodo、騰訊雲 COS、百度雲 BOS、又拍雲 USS、MinIO、 Amazon S3、GoogleCloud Storage、金山雲 KS3、美團雲 MSS、京東雲 OSS、天翼雲 OOS、移動，雲 EOS、沃雲 OSS、 網易數帆 NOS、Ucloud US3、青雲 QingStor、平安雲 OBS、首雲 OSS、IBM COS、其它兼容 S3 協議的存儲平台。查看 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn%2F%23%2F%25E5%25AD%2598%25E5%2582%25A8%25E5%25B9%25B3%25E5%258F%25B0" target="_blank">所有支持的存儲平台</a></p><p>💡 通過 WebDAV 連接到 Alist 後，可以使用百度網盤、天翼雲盤、阿里雲盤、迅雷網盤等常見存儲服務，查看 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Falist-doc.nn.ci%2Fdocs%2Fwebdav" target="_blank">Alist 支持的存儲平台</a></p><p>GitHub：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdromara%2Fx-file-storage" target="_blank">https://github.com/dromara/x-file-storage</a> Gitee：<a href="https://gitee.com/dromara/x-file-storage">https://gitee.com/dromara/x-file-storage</a></p><p>文檔 1：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.dromara.org" target="_blank">https://x-file-storage.dromara.org</a> 文檔 2：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn" target="_blank">https://x-file-storage.xuyanwu.cn</a> 文檔 3：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspring-file-storage.xuyanwu.cn" target="_blank">https://spring-file-storage.xuyanwu.cn</a></p><hr><h1>📜更新內容</h1><ul><li>更改項目名、更改包名、優化項目結構</li><li>新增直接讀取 HttpServletRequest 的流進行上傳，文件不落盤，速度更快</li><li>新增支持 Metadata 元數據</li><li>優化 ACL 異常處理</li><li>優化文件刪除邏輯</li><li>修復 Amazon S3 上傳文件偶現 ResetException 問題</li><li>捐贈至 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdromara.org%2Fzh" target="_blank">dromara</a> 開源社區</li></ul><h4>項目依賴的變化</h4><p>2.0.0 之前的版本</p><pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;cn.xuyanwu&lt;/groupId&gt;
    &lt;artifactId&gt;spring-file-storage&lt;/artifactId&gt;
    &lt;version&gt;1.0.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>2.0.0 及以後的版本</p><pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.dromara.x-file-storage&lt;/groupId&gt;
    &lt;artifactId&gt;x-file-storage-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4>配置參數的變化</h4><p>2.0.0 之前的版本</p><pre><code class="language-yaml">spring:
  file-storage: #文件存儲配置
    default-platform: huawei-obs-1 #默認使用的存儲平台
    thumbnail-suffix: ".min.jpg" #縮略圖後綴，例如【.min.jpg】【.png】
    #對應平台的配置寫在這裏，注意縮進要對齊
</code></pre><p>2.0.0 及以後的版本</p><pre><code class="language-yaml">dromara:
  x-file-storage: #文件存儲配置
    default-platform: huawei-obs-1 #默認使用的存儲平台
    thumbnail-suffix: ".min.jpg" #縮略圖後綴，例如【.min.jpg】【.png】
    #對應平台的配置寫在這裏，注意縮進要對齊
</code></pre><h4>包名的變化</h4><p>2.0.0 之前的版本</p><pre><code class="language-java">cn.xuyanwu.spring.file.storage
cn.xuyanwu.spring.file.storage.spring
</code></pre><p>2.0.0 及以後的版本</p><pre><code class="language-java">org.dromara.x.file.storage.core
org.dromara.x.file.storage.spring
</code></pre><hr><h1>📦使用</h1><p>點擊 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn%2F%23%2F%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8" target="_blank">快速入門</a> 查看全部存儲平台的使用方法！</p><h4>🔧 配置</h4><p>這裏以阿里雲 OSS 為例，<code>pom.xml</code> 引入本項目，這裏默認是 <code>SpringBoot</code> 環境，其它環境參考 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn%2F%23%2F%25E8%2584%25B1%25E7%25A6%25BBSpringBoot%25E5%258D%2595%25E7%258B%25AC%25E4%25BD%25BF%25E7%2594%25A8" target="_blank">脫離 SpringBoot 單獨使用</a></p><pre><code class="language-xml">&lt;!-- 引入本項目 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.dromara.x-file-storage&lt;/groupId&gt;
    &lt;artifactId&gt;x-file-storage-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 引入，阿里雲 OSS SDK，如果使用其它存儲平台，就引入對應的 SDK  --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
    &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
    &lt;version&gt;3.16.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p><code>application.yml</code> 配置文件中添加以下基礎配置</p><pre><code class="language-yaml">dromara:
  x-file-storage: #文件存儲配置
    default-platform: aliyun-oss-1 #默認使用的存儲平台
    aliyun-oss:
      - platform: aliyun-oss-1 # 存儲平台標識
        enable-storage: true  # 啓用存儲
        access-key: ??
        secret-key: ??
        end-point: ??
        bucket-name: ??
        domain: ?? # 訪問域名，注意「/」結尾，例如：https://abc.oss-cn-shanghai.aliyuncs.com/
        base-path: test/ # 基礎路徑
</code></pre><h4>🔨編碼</h4><p>在啓動類上加上<code>@EnableFileStorage</code>註解</p><pre><code class="language-java">@EnableFileStorage
@SpringBootApplication
public class SpringFileStorageTestApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringFileStorageTestApplication.class,args);
    }

}
</code></pre><h4>✨開始上傳</h4><p>支持 File、MultipartFile、byte[]、InputStream、URL、URI、String、HttpServletRequest，大文件會自動分片上傳。如果想支持更多方式，請閲讀 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn%2F%23%2F%25E6%2596%2587%25E4%25BB%25B6%25E9%2580%2582%25E9%2585%258D%25E5%2599%25A8" target="_blank">文件適配器</a> 章節</p><pre><code class="language-java">@RestController
public class FileDetailController {

    @Autowired
    private FileStorageService fileStorageService;//注入實列

    /**
     * 上傳文件
     */
    @PostMapping("/upload")
    public FileInfo upload(MultipartFile file) {
        //只需要這一行代碼即可上傳成功
        return fileStorageService.of(file).upload();
    }
    
    /**
     * 上傳文件，成功返回文件 url
     */
    @PostMapping("/upload2")
    public String upload2(MultipartFile file) {
        FileInfo fileInfo = fileStorageService.of(file)
                .setPath("upload/") //保存到相對路徑下，為了方便管理，不需要可以不寫
                .setObjectId("0")   //關聯對象 id，為了方便管理，不需要可以不寫
                .setObjectType("0") //關聯對象類型，為了方便管理，不需要可以不寫
                .putAttr("role","admin") //保存一些屬性，可以在切面、保存上傳記錄、自定義存儲平台等地方獲取使用，不需要可以不寫
                .upload();  //將文件上傳到對應地方
        return fileInfo == null ? "上傳失敗！" : fileInfo.getUrl();
    }

    /**
     * 上傳圖片，成功返回文件信息
     * 圖片處理使用的是 https://github.com/coobird/thumbnailator
     */
    @PostMapping("/upload-image")
    public FileInfo uploadImage(MultipartFile file) {
        return fileStorageService.of(file)
                .image(img -&gt; img.size(1000,1000))  //將圖片大小調整到 1000*1000
                .thumbnail(th -&gt; th.size(200,200))  //再生成一張 200*200 的縮略圖
                .upload();
    }

    /**
     * 上傳文件到指定存儲平台，成功返回文件信息
     */
    @PostMapping("/upload-platform")
    public FileInfo uploadPlatform(MultipartFile file) {
        return fileStorageService.of(file)
                .setPlatform("aliyun-oss-1")    //使用指定的存儲平台
                .upload();
    }

    /**
     * 直接讀取 HttpServletRequest 中的文件進行上傳，成功返回文件信息
     * 使用這種方式有些注意事項，請查看文檔，基礎功能-上傳，章節
     */
    @PostMapping("/upload-request")
    public FileInfo uploadPlatform(HttpServletRequest request) {
        return fileStorageService.of(request).upload();
    }
}
</code></pre><h4>🎨其它操作</h4><pre><code class="language-java">//手動構造文件信息，可用於其它操作
FileInfo fileInfo = new FileInfo()
        .setPlatform("huawei-obs-1")
        .setBasePath("test/")
        .setPath("aa/")
        .setFilename("image.png")
        .setThFilename("image.png.min.jpg");

//文件是否存在
boolean exists = fileStorageService.exists(fileInfo);
//下載
byte[] bytes = fileStorageService.download(fileInfo).bytes();
//刪除
fileStorageService.delete(fileInfo);
//其它更多操作

</code></pre><p>如果將文件記錄保存到數據庫中，還可以更方便的根據 URL 進行操作了，詳情請閲讀 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn%2F%23%2F%25E5%259F%25BA%25E7%25A1%2580%25E5%258A%259F%25E8%2583%25BD%3Fid%3D%25E4%25BF%259D%25E5%25AD%2598%25E4%25B8%258A%25E4%25BC%25A0%25E8%25AE%25B0%25E5%25BD%2595" target="_blank">保存上傳記錄</a> 章節</p><pre><code class="language-java">//直接從數據庫中獲取 FileInfo 對象，更加方便執行其它操作
FileInfo fileInfo = fileStorageService.getFileInfoByUrl("https://abc.def.com/test/aa/image.png");

//文件是否存在
boolean exists = fileStorageService.exists("https://abc.def.com/test/aa/image.png");
//下載
byte[] bytes = fileStorageService.download("https://abc.def.com/test/aa/image.png").bytes();
//刪除
fileStorageService.delete("https://abc.def.com/test/aa/image.png");
//其它更多操作
</code></pre><p>點擊 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx-file-storage.xuyanwu.cn%2F%23%2F%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8" target="_blank">快速入門</a> 查看全部存儲平台的使用方法！</p><hr></div>
                                    ]]>
            </description>
            <pubDate>Wed, 18 Oct 2023 00:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262366</guid>
            <link>https://www.oschina.net/news/262366</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌向 Linux 內核提交 mseal() syscall 補丁]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>谷歌工程師近日向 Linux 內核<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Flkml%2F20231016143828.647848-1-jeffxu%40chromium.org%2F" target="_blank">提交了一個新補丁</a></u>，希望為其添加名為 mseal() 的系統調用「<strong>mseal() syscall</strong>」。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1018/182107_uGso_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>據介紹， 谷歌這個<strong>獨立於架構的系統調用</strong>最初由 Chrome OS 上的 Chrome 瀏覽器使用。當時 Glibc 也在動態鏈接器中進行類似的實驗，以在啓動時封裝所有不可寫的段。</p><p>通過 mseal() 可<strong>防止系統調用修改虛擬地址的元數據</strong>。最初支持的是針對 mprotect/pkey_mprotect、munmap、mmap 和 mremap 調用進行封裝。為了在 Chrome 和 V8 JavaScript 引擎中提供更好的保護，開發者正在尋求使虛擬內存區域的元數據不可變。</p><p>Glibc 的方案是在動態鏈接器中添加封裝，以便在啓動時對所有不可寫段進行封裝，這也將自動使所有應用程序受益。</p><p>Linus Torvalds 對 mseal() syscall&nbsp;提出的模型表達了保留意見，目前這個提案並沒有直接被接受，需要修訂才能進化成適合上遊的形式。</p><p>Linus 表示：</p><blockquote><p>「我對添加某種’鎖定內存映射’ (lock down memory mappings) 模型沒有異議，但事實並非如此。</p><p>首先，最明顯的問題是提交信息無價值。</p><p>另外更根本的問題要嚴重得多——"ON_BEHALF_OF_KERNEL" 和 "ON_BEHALF_OF_USERSPACE" 整體完全不合邏輯，整體概念都需要重寫。因為這就是 remap_file_pages() 「字面上」的系統調用定義。」</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 17 Oct 2023 10:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262326</guid>
            <link>https://www.oschina.net/news/262326</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[報告：Web 開發崗最易受到 ChatGPT 衝擊]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="color:#000000">編程網站&nbsp;Programiz&nbsp;最新發布了一份調查<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fprogramiz.pro%2Freport" target="_blank">報告</a>，旨在揭示 ChatGPT 對編程教育領域的影響，並涉及了 ChatGPT 對職業生涯的影響。值得注意的是，此項調查是在&nbsp;GPT-4 發佈之前進行的。</span></p><p><span style="color:#000000">該報告基於來自 50 多個國家/地區的 10000 多名受訪者的見解，受訪者就 ChatGPT 如何改寫他們的學習經歷、重塑職業道路以及影響他們對 AI 未來世界的願景發表了看法。其中&nbsp;58% 的受訪者為學生，超過一半的受訪者只擁有不到一年的編程經驗。</span></p><p><span style="color:#000000">一些亮點內容包括：</span></p><ul><li><span style="color:#000000">67% 的受訪者表示使用 ChatGPT 作為主要來源或學習編程的輔助手段，大多數受訪者使用它來理解編程概念。有&nbsp;72% 的人每週多次使用 ChatGPT 來學習編程。</span></li><li><span style="color:#000000">理解編程概念、調試/改進代碼以及理解他人的代碼是 ChatGPT 在學習編程過程中的三大主要用途。</span></li></ul><p>​​​​​​​<img height="301" src="https://oscimg.oschina.net/oscnet/up-af24038b9255d20bf70aaca17423dd3694b.png" width="400" referrerpolicy="no-referrer"></p><ul><li><span style="color:#000000">77%&nbsp;的受訪者認為 ChatGPT 改善了他們的編程學習體驗。只有 6% 的受訪者表示 ChatGPT 的回答無法準確滿足他們的學習需求。</span></li><li><span style="color:#000000">不相關和不一致的回答 (54%) 是使用 ChatGPT 學習編程時面臨的主要挑戰。40% 的受訪者表示，過度依賴 ChatGPT 可能會阻礙批判性思維和解決問題的能力；還有 19% 的受訪者非常擔心會導致人際互動和個性化指導的喪失。</span></li><li><span style="color:#000000">30% 的人認為 ChatGPT 優於大學講座，超過 38% 的人更喜歡 ChatGPT 而不是 Google。</span></li></ul><p><img height="249" src="https://oscimg.oschina.net/oscnet/up-e5323cf758b8bf8b5281f2b0a820281df0b.png" width="400" referrerpolicy="no-referrer"></p><ul><li><span style="color:#000000">近 75% 的受訪者正在提高技能或計劃提高技能，為 ChatGPT 對就業市場的影響做好準備。</span></li><li><span style="color:#000000">34%&nbsp;的受訪者因 ChatGPT 而經歷了工作上的一些轉變。</span></li><li><span style="color:#000000">61% 的受訪者對 ChatGPT 在科技領域創造新就業機會的潛力持樂觀態度，51% 的受訪者認為 Web 開發最容易受到 ChatGPT 造成的工作流失的影響。</span></li><li><span style="color:#000000">17% 的受訪者認為 ChatGPT 將完全取代傳統教學方式，​​​​​​​84% 的人認為教育機構應該針對 ChatGPT 調整其編程課程。</span></li></ul><p><span style="color:#000000">報告指出，如果有效利用，ChatGPT 有能力顯著改變編程教育領域。現在採用這項技術不僅有可能提升職業生涯，還能使個人在不斷髮展的環境中保持領先地位。&nbsp;</span></p><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fprogramiz.pro%2Freport" target="_blank">查看完整報告</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 17 Oct 2023 08:31:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262310/chatgpt-programming-education-report</guid>
            <link>https://www.oschina.net/news/262310/chatgpt-programming-education-report</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[小米澎湃 OS 界面曝光]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>雷軍昨天<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FvjNBvY8Bn9Npnmisru_EKw" target="_blank">官宣</a></u>「小米澎湃 OS」正式誕生（英文命名為 Xiaomi HyperOS），稱其將接替 MIUI，並表示正式版已完成封包。</p><blockquote><p>小米澎湃 OS 基於深度進化的 Android 以及自研的 Vela 系統融合，徹底重寫底層架構。</p></blockquote><p>小米 14 系列則是第一款搭載小米澎湃 OS 的手機，目前已交付工廠開始生產。</p><p>根據網上流傳的小米澎湃 OS 界面截圖，其採用全新控制中心，相比 MIUI 14 有了很大變化，小米妙想中心位於控制界面中央，方便使用。從界面來看，澎湃 OS 線條更簡潔，視覺更清爽。</p><p><img alt="" height="931" src="https://oscimg.oschina.net/oscnet/up-680458cc567c6c4d0d978b24001e29e620d.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-5872ac15f05f2b0805dee812300aace7400.png" referrerpolicy="no-referrer"></p><p><img alt="" height="1111" src="https://oscimg.oschina.net/oscnet/up-e689790f931181126f237dbd50effd3ccb0.png" width="500" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><img alt="" height="1139" src="https://oscimg.oschina.net/oscnet/up-5cd94040c9348a532ec3a572a7323f51c0a.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="1139" src="https://oscimg.oschina.net/oscnet/up-273f391865e9d9385fbfc26780c02561a60.png" width="500" referrerpolicy="no-referrer"></p><p>有數碼博主爆料稱，小米澎湃 OS 是自 MIUI 12 以來的最大更新，擁有類似 iOS 鎖屏編輯器。此外，新系統的天氣動畫全面升級，動效更真實，比如雲的形狀和光影會微調，不像之前直接貼圖。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-8425347b93ee76ed1aab74fde880a544be7.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e03b9175314cb69350b8d966f079c3644ed.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1e1fa6cfe8f7462579ef46749af7b0b1aab.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>當然，上述截圖都沒有得到官方證實，一切請以小米官方公佈的信息為準。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 17 Oct 2023 08:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262306</guid>
            <link>https://www.oschina.net/news/262306</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[英偉達發佈 Windows 版 TensorRT-LLM 庫，為本地運行大模型提速]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://gitee.com/gitee-community/gitee-talk/blob/fe3647ff951894421dbeb6c0c1c62a0a4fdb37db/Yuanchuanghui-1024.md" _blank"="">【源創會預告】1024 程序員節（的前兩天），相約開源中國辦公室，我們一起聊 AI！&gt;&gt;&gt;<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>英偉達<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.nvidia.com%2Fblog%2F2023%2F10%2F17%2Ftensorrt-llm-windows-stable-diffusion-rtx%2F" target="_blank">發佈</a></u>了 Windows 版本的 TensorRT-LLM 庫，稱其<strong>將大模型在 RTX 上的運行速度提升 4 倍</strong>。</p><p><img src="https://static.oschina.net/uploads/space/2023/1018/153818_0cWf_2720166.png" referrerpolicy="no-referrer"></p><p>GeForce RTX 和 NVIDIA RTX GPU 配備了名為 Tensor Core 的專用 AI 處理器，正在為超過 1 億台 Windows PC 和工作站帶來原生生成式 AI 的強大功能。</p><p>TensorRT-LLM 是一個開源庫，用於提升上述 GPU 運行最新 AI 大模型（如 Llama 2 和 Code Llama）的推理性能。上個月英偉達發佈了面向數據中心的 TensorRT-LLM，現在最新發布的 TensorRT-LLM for Windows 主要是面向家用電腦，將 PC 上運行 LLM 的速度提高了 4 倍。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-bef2ad6f2d5cae9eee341fbbad7d6c337c0.png" referrerpolicy="no-referrer"></p><p>英偉達還同時發佈了幫助開發人員加速 LLM 的工具，包括使用 TensorRT-LLM 優化自定義模型的腳本、TensorRT 優化的開源模型以及展示 LLM 響應速度和質量的開發人員參考項目。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 17 Oct 2023 07:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/262298/tensorrt-llm-windows-stable-diffusion-rtx</guid>
            <link>https://www.oschina.net/news/262298/tensorrt-llm-windows-stable-diffusion-rtx</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[10.28 源創會蘇州站，歡迎大家來轟趴館——尋寶 AI]]>
            </title>
            <description>
                <![CDATA[10.28 源創會蘇州站，歡迎大家來轟趴館——尋寶 AI]]>
            </description>
            <pubDate>Tue, 17 Oct 2023 07:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/event/2331193</guid>
            <link>https://www.oschina.net/event/2331193</link>
        </item>
    </channel>
</rss>
