<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-綜合資訊]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 01 Nov 2023 08:37:47 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[優惠券 10 幾萬元，中國首款商用可重構 5G 頻射收發芯片上架淘寶]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>近日，國資委淘寶店鋪「國資小新」上架了一款售價為 999999 元的硬核商品 ——</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0c0dfda1faab2057d6c1cd71a911022e482.png" referrerpolicy="no-referrer"></p><p>根據商品圖介紹，該款芯片名為「破風 8676」，是「中國首款商用可重構 5G 頻射收發芯片」，定價 999999 元人民幣。這款芯片因獨特的用途和「硬核」的定價被網友戲稱為「雙十一」期間最「硬核」的國貨。</p><p>報道稱，該芯片由中國移動研究院自主研發。產品介紹信息顯示，「破風 8676」可重構 5G 射頻收發芯片支持 1.7GHZ~6GHz 頻段範圍，能夠適配全球主流 4/5G 頻段、WiFi 及國內車聯網頻段：支持 2 個射頻通道，通道帶寬 200MHz；集成 DPD （數字預失真） 、CFR （削峯） 、高階 FIR （有限長單位衝激響應）濾波等功能。</p><p>公開信息顯示，上架這款芯片的店鋪「國資小新」由國務院國有資產監督管理委員會下屬機構負責運營。該賬號店鋪內還上架了由中國航發研製的「太行 110」重型燃氣輪機、由中國鐵建研製的全球最大豎井掘進機、航空工業集團研製直-20 直升機以及中核集團建設的全球首個陸上小型模塊化反應堆等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-d3dff2bf8551179267c8ac2ee3cc6613cf1.png" referrerpolicy="no-referrer"></p><p>和「破風 8676」一樣，店鋪將上述產品均定價為 999999 元，並提示消費者該商品「僅展示可加購勿拍」。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 07:41:49 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264470</guid>
            <link>https://www.oschina.net/news/264470</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[openKylin Wine 助手正式上線，公測活動開啓]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify"><span>為提供用戶更好的 Windows 應用程序安裝和使用體驗，openKylin 社區 CompatWinApp SIG 組基於 Wine 開源軟件設計了一款<strong>集軟件展示、下載、安裝、管理等功能於一體</strong>的桌面軟件—<strong><span style="color:#0052ff">openKylin Wine 助手</span></strong>！</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span><span style="color:#000000">現邀請所有社區用戶參與本次公測活動，參與就有機會獲得社區定製獎品哦～</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#0b43d1">openKylin Wine 助手介紹</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>openKylin Wine 助手基於 Wine 提供的 Windows 應用運行環境，為用戶提供軟件展示、下載、安裝、管理等功能，可以讓用戶在 openKylin 系統上方便地下載、安裝和使用 Windows 應用程序。其主界面如下圖所示：</span></p><div><p style="text-align:center"><img alt="" height="1080" src="https://oscimg.oschina.net/oscnet/up-3473471a2b0b0cd75b757a441c879110017.png" width="1920" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><ul><li><span>openKylin Wine 助手首先從應用配置倉庫和依賴配置倉庫下載配置文件。隨後，將應用程序展示在窗口中，當用戶點擊應用程序後面的安裝按鈕，openKylin Wine 助手就會根據配置信息下載相應用的應用程序和依賴，並最終調用 Wine 進行安裝。</span></li><li><span>安裝後，應用程序後面的按鈕會變成啓動按鈕，點擊啓動按鈕後，openKylin Wine 助手會調用 Wine 啓動該應用。完整過程如下圖所示：</span></li></ul><div><p style="text-align:center"><img alt="" height="550" src="https://oscimg.oschina.net/oscnet/up-82094adb9094dfb452b1626fee75d859371.jpg" width="948" referrerpolicy="no-referrer"></p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#0b43d1">公測活動介紹</span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#79d7ff">活動時間</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#333333"><span style="background-color:#fffbf2">2023 年 10 月 31 日—2023 年 11 月 30 日</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#79d7ff">參與方式</span></span></strong></span></p><h1>1.下載安裝 openKylin Wine 助手</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>目前，CompatWinApp SIG 組已發佈 X86 平台的 openKylin Wine 助手，下載體驗地址如下：</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#0052ff">https://gitee.com/openkylin/compat-winapp/releases/tag/1.0.2-beta.20230928</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><em><span><span style="color:#ce2a1b">備註：安裝説明見壓縮包裏的 readme 文件</span></span></em></p><h1>2.簽署 CLA，參與公測</h1><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>參與公測的用戶請在 openKylin 系統上安裝使用 openKylin Wine 助手，將使用過程中遇到的 bug 問題或優化建議以 issue 方式提交到如下地址：</span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:left"><span><span style="color:#0052ff">https://gitee.com/openkylin/win-program/issues</span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><em><span><span style="color:#ce2a1b">注意：在參與公測前，請大家簽署 openKylin 社區貢獻者許可協議，如若未簽署，則參與成績無效。CLA 簽署網址：</span></span></em><br><span><span style="color:#0052ff"><span>https://cla.openkylin.top/</span></span></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#79d7ff">獎品設置</span></span></strong></span></p><p style="margin-left:0px; margin-right:0px; text-align:justify">CompatWinApp SIG 組會統計活動期間所有在倉庫反饋的問題和需求建議，根據每個問題和需求的重要程度進行打分，分數總和越高排名越靠前。截至 2023 年 11 月 30 日，積分排名前 10 的小夥伴可獲得 openKylin 紀念品禮包一份（polo 衫+筆本套裝），評選結果將由社區在 7 個工作日內公佈至 openKylin 論壇。</p><div><p style="text-align:center"><img alt="" height="410" src="https://oscimg.oschina.net/oscnet/up-b5c4b5d8b275e4d43d5af75c36e3b105e17.png" width="940" referrerpolicy="no-referrer"></p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:center"><span><strong><span style="color:#ffffff"><span style="background-color:#79d7ff">評分規則</span></span></strong></span></p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify"><span>由 CompatWinApp SIG 組分別從<strong>需求、問題、清晰度</strong>三個維度進行評分。</span></p><ul><li><span><strong>需求</strong>：對需求進行評級，分別為高、中、低三個等級，高等級 3 分，中等級 2 分，低等級 1 分。</span></li><li><span><strong>問題</strong>：對於遇到的問題或者 bug 進行評級，分別為嚴重、主要、次要、不重要四個等級，對應的分數分別為 3 分、2 分、1 分、0.5 分。</span></li><li><span><strong>清晰度</strong>：對需求和 bug 的清晰度進行評級，分為高中低三個等級，高清晰度會在其原分數上+0.2 分，中清晰度不做分數調整，低清晰度會在其原分數基礎上-0.2 分。</span></li></ul><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:center"><span><strong><span style="color:#000000">還在等什麼，趕快行動起來吧~</span></strong></span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 01 Nov 2023 02:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264400</guid>
            <link>https://www.oschina.net/news/264400</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[阿里雲人工智能 + 大數據平台升級發佈]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>大模型和 MaaS 概念的出現，定義了以模型為中心的一整套 AI 開發新範式，而這背後日益增長的巨大算力需求，對 AI 工程底座提出了新的挑戰。今天，大模型時代下的人工智能+大數據平台，需要具備計算效率、開發效率、處理效率為一體的高效能力，才能保障服務 AI 時代下的業務創新。10 月 31 日，2023 雲棲大會上，阿里雲副總裁、阿里雲計算平台事業部負責人汪軍華宣佈<strong>阿里雲人工智能+大數據平台升級發佈，以服務大模型時代下各行各業的業務創新</strong>。</p><h2>高性能的 AI 基礎設施，讓計算效率達到極致</h2><p>根據 OpenAI 測算，全球用於頭部 AI 模型訓練的算力需求以每年 10 倍的速度增長，計算需求處於持續爆發中。汪軍華介紹，PAI 靈駿智算集羣在網絡、存儲、調度上做了深度優化，採用 HPN 7.0 新一代 AI 集羣網絡架構，存儲計算分離架構，<strong>支持高達 10 萬卡量級的集羣可擴展規模，讓超大規模集羣像 1 台計算機般運轉</strong>。</p><p>軟硬一體的智算服務 PAI 靈駿，為大規模深度學習訓練場景提供穩定和高效的支撐，大模型訓練任務線性加速比可達到 96%，大模型訓練資源可節省超 50%。在穩定性保障方面，PAI 靈駿智算服務配置了彈性容錯訓練框架 AIMaster 和 EasyCkpt 模型自動保存與恢復能力，可讓千卡規模任務穩定運行 3 周以上。</p><p>面向大模型的推理服務場景，PAI 體系化地整合模型系統聯合優化、運行時優化、LLM 領域優化等能力，可將大語言模型推理吞吐提升 3.5 倍，大幅降低推理時延。單卡推理可支持的最大上下文長度達 280K，超長的上下文推理將進一步推動 LLM 湧現。</p><h2>多形態、更靈活的 AI 開發模式，支撐多樣化需求</h2><p>隨着需求的不斷湧現，AI 開發者和 AI 開發需求越發細分。<strong>人工智能平台 PAI 4.0 發佈，全面降低大模型 AI 開發門檻，提供完善的需求支撐，提升開發效率</strong>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3b95e15dfa6b87444fc3e282b13714f002c.jpg" alt="" referrerpolicy="no-referrer"></p><p>不論是需要定義模型結構和開發流程的深度學習開發者羣體，還是有海量大規模計算任務的羣體，亦或是需要高效快速串聯起訓練推理任務的業務算法羣體，都可以通過 PAI 來實現研發，包含各類熱門的計算框架、開源模型和開發場景，一站式地完成開發部署。</p><p>PAI 靈積為廣大開發者提供了通過雲上 API 服務，可以用於應用模型開發和開發好的模型調用，允許開發者將大模型能力迅速集成到自己的業務和應用中，在 PAI-靈積平台上，開發者不僅可以找到通義系列大模型（包括通義千問，通義萬相等等），也可以找到來自業界最優秀的頭部大模型，包括 ChatGLM，百川，Stable Diffusion 等。</p><p>汪軍華宣佈，今天這些模型都<strong>通過 PAI 靈積上統一的 API 和 SDK 對廣大開發者開放</strong>，開發者只需要幾行代碼，就能迅速把這些不同類別的大模型的能力，集成到自己的應用中去。</p><h2>高效的數據服務提升大模型效果，大數據和 AI 更深融合</h2><p>在機器學習開發過程中，80% 的研發時間有用於數據準備，數據質量決定着大模型的效果，數據處理分析的重要性更加凸顯。大數據作為 AI 基礎設施的一部分，阿里雲提供了從數據積累、清洗、建模、計算到服務的全套產品化方案，來節省 AI 開發過程中數據準備的時間。</p><p>同時，大數據和 AI 進行了更深度的融合。阿里雲自研大數據處理平台 MaxCompute 全面升級 DataFrame 能力，<strong>發佈分佈式計算框架 MaxFrame，100% 兼容 Pandas 等數據處理接口</strong>，一行代碼即可將原生 Pandas 自動轉為 MaxFrame 分佈式計算，打通數據管理、大規模數據分析、處理到 ML 開發全流程，打破大數據及 AI 開發使用邊界，大大提高開發效率。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1b1ceca672616e6e79a2adf7ef338570215.jpg" alt="" referrerpolicy="no-referrer"></p><p>大模型驅動的 AI 時代，AI 場景對數據時效性的要求也越來越高，Flink+Paimon 新一代實時湖倉方案，為用戶提供一站式數據入湖、實時加工和探查分析能力，拓展 Flink 在數據湖場景的實時計算能力，同時加速 AI 應用。</p><p>全託管向量檢索服務 DashVector 正式發佈，基於阿里雲自研 8 年的高性能向量檢索內核 Proxima，提供具備水平拓展能力的雲原生、全託管的向量檢索服務。Hologres、OpenSearch、Elasticsearch 分別升級了向量能力，滿足不同場景下性能的提升。全新發布 DataWorks Copilot，將大數據平台的一站式統一元數據、統一調度、統一數據集成、統一數據建模與 AI 大模型能力全面結合， 將 AI 與業務充分融合，創造新價值。</p><p>在面向大模型時代整體大數據 AI 產品能力升級後，汪軍華宣佈<strong>大數據 AI 產品全面完成 Serverless 化</strong>，致力於給客戶提供開箱即用、按需付費的高性價比產品。作為大模型時代 AI 的基礎設施，阿里雲人工智能+大數據平台將堅定、持續的投入研發資源，服務各行各業的業務創新。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 09:52:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5583868/blog/10140082</guid>
            <link>https://my.oschina.net/u/5583868/blog/10140082</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[飛致雲開源社區 10 月動態報告]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#000000; text-align:start"><span><span style="color:#000000">自 2023 年 6 月起，中國領先的開源軟件公司 FIT2CLOUD 飛致雲以月度為單位發佈《飛致雲開源社區月度動態報告》，旨在向廣大社區用戶同步飛致雲旗下系列開源軟件的發展情況，以及當月主要的產品新版本發佈、社區運營成果等相關信息。</span></span></p><p style="color:#000000; text-align:start"><span><strong><span style="color:#00355d">飛致雲開源大屏（2023 年 10 月）</span></strong></span></p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-a09815ae51a7ff491a27bae6b2bf1cdf0c7.png" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:start"><span>▲圖 1 飛致雲開源大屏（2023.10.31 12:00）</span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">2023 年 10 月飛致雲開源軟件運營數據概覽（統計時間為 2023.10.1～2023.10.31）：</span></span></p><p style="color:#000000; text-align:start"><img alt="" height="782" src="https://oscimg.oschina.net/oscnet/up-04d7820369e349de560cad38d0758a8c526.png" width="1388" referrerpolicy="no-referrer"></p><p style="color:#000000"><strong><span style="color:#3370ff">2023 年 10 月產品發佈事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 開源建站工具</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 10 日，Halo 開源建站工具正式發佈 v2.10.0 版本。在這個版本中，Halo 主要支持了消息通知、內置應用市場等功能，並且完成了其他 30 多項功能優化和問題修復。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 1Panel 開源面板</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 16 日，現代化、開源的 Linux 服務器運維管理面板 1Panel 正式發佈 v1.7.0 版本。</p><p style="color:#000000; text-align:start">在這個版本中，1Panel 新增 Node.js 運行環境；新增系統緩存清理功能；應用安裝時支持選擇遠程數據庫。此外，我們進行了 40 多項功能更新和問題修復。1Panel 應用商店新增了 2 款應用，並且更新了 25 款應用。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ JumpServer 開源堡壘機</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 23 日，JumpServer 開源堡壘機正式發佈 v3.8.0 版本。</p><p style="color:#000000; text-align:start">在這一版本中，JumpServer 在「用戶登錄」和「資產登錄」這兩個權限控制功能中，新增「通知」動作。目前其支持的動作包括拒絕、接受、審批以及通知四種動作，方便了管理員針對不同的用戶及資產使用需求進行配置。同時，在使用 KoKo 組件連接字符集類型的資產時，JumpServer 支持持久化主題配置，解決了用戶需要經常手動修改主題的問題。</p><p style="color:#000000; text-align:start">作業中心方面，用戶執行命令時支持自定義執行目錄，方便用戶在合適的上下文環境中執行命令。另外，在使用 Web GUI 方式連接數據庫時，用戶可以對查詢集進行保存操作，JumpServer 會對查詢集以「CSV」格式下載後提供給用戶。</p><p style="color:#000000; text-align:start">X-Pack 增強包方面，JumpServer v3.8.0 版本支持納管 DB2 數據庫（IBM 旗下關係型數據庫），方便管理員對此類數據庫進行納管，以滿足用戶在數據庫納管方面的多樣化需求。在之前的版本中，JumpServer 支持在頁面上簡單對接無認證類型的短信網關。在新版本中，JumpServer 支持用戶通過編寫自定義短信文件的方式，與用戶的短信網關環境進行交互，從而實現發送短信驗證的功能。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ MeterSphere 開源持續測試平台</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 30 日，MeterSphere 一站式開源持續測試平台正式發佈 v2.10.8 LTS 版本。自 2023 年 5 月發佈 v2.10 LTS 版本後，MeterSphere 開源項目組堅持發佈小版本，持續進行問題的修復更新，並針對部分功能進行優化。</p><p style="color:#000000; text-align:start">本次發佈的 MeterSphere v2.10.8 LTS 版本在性能測試模塊對壓測報告進行功能增強，同時測試執行機新增運行狀態和 CPU 監控。</p><p style="color:#000000"><strong><span style="color:#3370ff">其他重要事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ FIT2CLOUD 飛致雲九週年</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 21 日，FIT2CLOUD 飛致雲度過了九週歲生日。新的一年，飛致雲的口號是「只爭朝夕，成為三高」。感謝每一位用戶、客戶、合作伙伴、員工、股東，我們將加速成長，為數字經濟時代創造好軟件。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 飛致雲及其旗下 1Panel 進入 2023 年第三季度最具成長性開源初創榜單</span></strong></p><p style="color:#000000; text-align:start">2023 年 10 月 26 日，知名風險投資機構 Runa Capital 發佈了 2023 年第三季度 ROSS 指數（Runa Open Source Startup Index）。ROSS 指數按季度彙總並公佈在代碼託管平台 GitHub 上年化增長率（AGR）排名前二十位的開源初創公司和開源項目。</p><p style="color:#000000; text-align:start">在這份名為《Top trending early-stage open-source startups by GitHub star growth in Q3 2023》的榜單中，FIT2CLOUD 飛致雲及其旗下的 1Panel 開源面板項目入選。這也是 FIT2CLOUD 飛致雲及其旗下開源項目連續第二個季度進入 ROSS 指數相關榜單。</p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-4e76c989b3aaeb4b049167ebe4867d1f213.png" referrerpolicy="no-referrer"></p><p style="color:#000000">▲圖 2 《Top trending early-stage open-source startups by GitHub star growth in Q3 2023》榜單</p><p style="color:#000000; text-align:start"><span><strong><span style="color:#00355d">關於飛致雲開源大屏</span></strong></span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">飛致雲開源大屏（</span></span><em><span><span style="color:#000000">https://bi.fit2cloud.com/link/6CgpMHrT</span></span></em><span><span style="color:#000000">）</span><span style="color:#3e3e3e">是 FIT2CLOUD 飛致雲為展示其旗下開源軟件的社區運營情況製作的數據儀錶板。該大屏使用 DataEase 開源數據可視化分析平台製作，實時呈現飛致雲開源社區近 30 日內的動態信息。</span></span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">廣大社區用戶可以通過該大屏瞭解飛致雲旗下開源項目的 GitHub Star、Fork、Issue、貢獻者等指標的數量信息，以及近 30 日內新增的 Star、Fork、下載、Issue、PR 數量等，同時該大屏還展示了飛致雲旗下開源項目的 Issue 趨勢、Commit 趨勢、PR 趨勢、Issue 生命週期等。</span></span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">除了展示所有項目的彙總信息外，該大屏還支持用戶分類別查看 JumpServer、DataEase、MeterSphere、Halo、1Panel、CloudExplorer Lite 六個開源項目的獨立運營數據。</span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 08:53:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4736111/blog/10140016</guid>
            <link>https://my.oschina.net/u/4736111/blog/10140016</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[從 0 到 1 入門用戶畫像掌握大數據技術]]>
            </title>
            <description>
                <![CDATA[<h1 class="header article-title"><a href="https://www.oschina.net/question/4855753_2331281">高手問答第 308 期 ——從 0 到 1 入門用戶畫像掌握大數據技術</a><div class="ui red label horizontal" data-tooltip="置頂">頂</div></h1><div class="extra ui horizontal list meta-wrap"><div class="item"><a href="https://my.oschina.net/u/4855753" class="__user"><span>OSC 噠噠</span></a><span class="org-label org-label--simple primary" data-tooltip="認證官方賬號"><i class="oicon oicon-org"></i></span> 發佈於，昨天 12:14
                    </div><div class="item">閲讀 1K+</div><div class="item collect-btn " data-id="2331281" data-user-id="4855753" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i> 收藏 <span data-collect-count="" data-id="2331281" data-obj-type="2">5</span></div><div class="item comment-count"><a href="https://www.oschina.net/question/4855753_2331281#comments" class="normal"><i class="comment outline icon"></i> 答案 <span data-article-reply-count="">2</span></a></div></div><div class="tags"><a class="ui horizontal label" href="https://www.oschina.net/question/topic/masteronline" target="_blank"><img src="https://static.oschina.net/uploads/logo/masteronline_9WTeU.png" referrerpolicy="no-referrer">高手問答</a></div><div class="content" id="articleContent"><div><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>市面上不少公司都在做用戶畫像的相關工作，無論是電商行業、金融行業、視頻行業等等，都有這樣的產品。那到底怎麼去定義用戶畫像呢？</span></span></span></span></span></span></span></span></span></span></span></div><div>
  &nbsp; 
</div><div><strong>OSCHINA 本期高手問答 (10 月 31 日 - 11 月 6 日) 我們請來</strong><strong>了嘉賓&nbsp;</strong><strong><span style="color:#000000"><a href="https://my.oschina.net/u/4294800" rel="nofollow">諸葛子房</a>老師&nbsp;</span></strong><strong>來和大家一起探討關於從 0 到 1 入門用戶畫像掌握大數據技術的問題。</strong></div><div>
  &nbsp; 
</div><div><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>可討論的問題包括但不限於：</span></span></span></span></span></span></span></span></span></span></span></p><ul><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>想入門用戶畫像需要掌握哪些技術棧？</span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>沒有企業的大量用戶或者行為數據，普通用戶該如何真實地模擬企業級的畫像項目？</span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>程序員如何入門大數據？</span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>大數據</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>行業都有哪些職位，以及在公司中發揮的作用如何</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>？</span></span></span></span></span></span></span></span></span></span></span></li><li><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>大數據行業未來的發展如何，以 ChatGPT&nbsp;為代表的 AI 浪潮是否會讓大數據行業走向</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>沒落</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>？</span></span></span></span></span></span></span></span></span></span></span></li></ul><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>有其他相關問題，也歡迎大家積極提問！</span></span></span></span></span></span></span></span></span></span></span></p><hr><h2>嘉賓介紹</h2><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>段小秋，網名：諸葛子房，先後就職於京東和 BAT，在大數據領域有多年工作經驗，也是多個 Apache&nbsp;項目的貢獻者。藍橋杯藍橋雲課《用戶畫像案例精講》專欄作者，也是開源項目 DataCompare&nbsp;作者。</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>微信</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>：zhugezifang001，歡迎交流溝通。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>個人</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>主頁：</span></span></span></span></span></span></span></span><a href="https://gitee.com/ZhuGeZiFang" rel="nofollow"><span><span><span><u><span style="color:#1e6fff"><span><span>https://gitee.com/ZhuGeZiFang</span></span></span></u></span></span></span></a></span></span></span></p><p><img height="639" src="https://oscimg.oschina.net/oscnet/up-5e58f5cf142af8e6ec1a3b8c3dc1cef16ec.png" width="500" referrerpolicy="no-referrer"></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>為了鼓勵踴躍提問，會在問答結束後從提問者中抽取&nbsp;5&nbsp;名幸運會員贈予《</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>用戶畫像案例精講》專欄電子版！</span></span></span></span></span></span></span></span></span></span></span></p><p><img height="516" src="https://oscimg.oschina.net/oscnet/up-71771b786f7cc1bd0161793b6af70daf066.png" width="310" referrerpolicy="no-referrer"></p><p><img height="574" src="https://oscimg.oschina.net/oscnet/up-c2d9d9ce8dd66a412d3ef791ee45548dc45.png" width="311" referrerpolicy="no-referrer"></p></div><div><div><hr><h4><span><span><span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>用戶</span></span></span></span></strong></span></span></span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>畫像概念</span></span></span></span></strong></span></span></span></span></span></span></h4><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>用戶畫像，即：用標籤的方式去描述一個人或者一台手機、一台電腦，有些公司稱之為」用戶畫像「，有一些公司稱之為」用戶特徵「，其實是一個意思。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>舉個簡單的例子：</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>袁小青，性別：女，年齡：22 歲，職業：時尚編輯，愛好：音樂、拍照，居住地：北京，消費情況：年薪 10w，喜歡的 app：抖音</span></span></span></span></span></span></span></span></span></span></span></p><p><img height="310" src="https://oscimg.oschina.net/oscnet/up-d3e2ad6f2150ece5dd0882380562cb797a7.png" width="488" referrerpolicy="no-referrer"></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>因此我們概念中描述的用戶畫像，其實是用標籤的方式對於一個用戶、一個賬號、一部手機進行描述。</span></span></span></span></span></span></span></span></span></span></span></p><p><img height="368" src="https://oscimg.oschina.net/oscnet/up-adc4c1c21829279233af14e8d74631dfab4.png" width="400" referrerpolicy="no-referrer"></p><h4><span><span><span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>用戶畫像常見標籤</span></span></span></span></strong></span></span></span></span></span></span></h4><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>既然上面講到了對於用戶進行標籤化，那究竟要給用戶打哪些標籤呢？如何對標籤進行分類呢？</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>用戶</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>畫像核心標籤以及其分類：</span></span></span></span></span></span></span></span></span></span></span></p><p><img height="589" src="https://oscimg.oschina.net/oscnet/up-9efa6c4c17cb0bd2647c8d303db9def85cc.png" width="868" referrerpolicy="no-referrer"></p><h4><span><span><span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>用戶畫像的作用</span></span></span></span></strong></span></span></span></span></span></span></h4><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>1. 個性化推薦</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>在使用一些社區產品、電商產品、短視頻 app、音樂 app 的時候，經常會遇到推薦的場景，根據不同的人推薦不同的內容或者商品。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>這其實是用戶畫像其中的一個應用，根據用戶查詢用戶的標籤數據，來進行推薦用戶感興趣的內容</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>2. 營銷圈選 (短信營銷、PUSH 營銷)</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>相信不少用戶收到過類似的營銷短信，或者一些 app&nbsp;彈窗，這個也是用戶畫像常見的應用場景</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>3. 策略引擎</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>根據用戶的標籤展示不同頁面，比如説：北京地區的用戶能才能領取北京的優惠券，以及只有高消費值的用戶才有淘寶上奢侈品 Luxury 入口的界面。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>4. 算法模型</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>算法模型的訓練，比如説：推薦模型、廣告模型，需要用到畫像數據來優化推薦模型。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>5. 畫像報告</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>不少商業公司會出一些行業報告，比如説下圖的小紅書、鎖屏 app&nbsp;的行業畫像報告；還有我們經常看到的一些個人年度榜單。</span></span></span></span></span></span></span></span></span></span></span></p><h4><span><span><span><span><span style="background-color:#ffffff"><span><strong><span><span style="color:#000000"><span><span>大數據技術在用戶畫像中的實際應用</span></span></span></span></strong></span></span></span></span></span></span></h4><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>由於</span></span></span></span></span></span></span></span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>畫像涉及到的一些行為數據，包括用戶購物行為、觀影行為，一些較為大型一些的公司數據日均都涉及 PB，因此需要處理的數據量非常大。在其中就會用到一些大數據的處理和存儲技術，比如説：Hadoop、Spark、Hbase&nbsp;等等。</span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span><span style="background-color:#ffffff"><span><span><span><span style="color:#000000"><span><span>同時隨着業務發展，一些廣告和推薦場景對於實時需求也更加明顯，所以實時數據處理領域，Flink、Kafka 等實時相關技術領域也越來越重要了。</span></span></span></span></span></span></span></span></span></span></span></p><hr><div><p><span style="background-color:#ffffff; color:#27ae60">OSChina 高手問答一貫的風格，不歡迎任何與主題無關的討論和噴子。</span></p><p>下面歡迎大家就<span>用戶畫像和大數據技術相關</span>問題向&nbsp;<strong><span style="color:#000000"><a href="https://my.oschina.net/u/4294800" rel="nofollow">諸葛子房</a></span></strong><span style="color:#000000">老師</span><strong><span style="color:#000000">&nbsp;</span></strong>提問，直接回帖提問既可。</p></div></div></div></div><div class="poll-wrap"></div><div class="additional-remarks"></div><div class="ui basic center aligned segment action"><div class="ui big buttons"><a class="ui basic button collect-btn hover" data-id="2331281" data-user-id="4855753" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i>收藏 (<span data-collect-count="" data-id="2331281" data-obj-type="2">5</span>)</a><div class="ui basic dropdown share button osc-share dropdown-share" data-tag="share-question"><i class="share icon"></i><span>分享</span><div class="menu"><a class="item" data-platform="weibo" data-value="weibo"><i class="weibo icon"></i>微博</a><a class="item" data-platform="qq" data-value="qq"><i class="qq icon"></i>QQ</a><a class="item" data-platform="wechat" data-value="wechat"><i class="weixin icon"></i>微信</a></div></div></div><div class="ui basic segment"><a class="ban" ban-report="" data-id="2331281" data-obj-type="2" data-url="https://www.oschina.net/question/4855753_2331281"><i class="flag red icon"></i>舉報</a></div></div>
            ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 08:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/question/4855753_2331281</guid>
            <link>https://www.oschina.net/question/4855753_2331281</link>
        </item>
        <item>
            <title>
                <![CDATA[深秋，寒露：是時候和 Zadig 説再見了]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:center"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank"><img alt="" src="https://oscimg.oschina.net/oscnet/up-672c752071cec6bcdf28b3468d5bde60d1a.png" referrerpolicy="no-referrer"></a></p><div><div style="text-align:center"><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank">閲讀原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig">Zadig 在 Gitee</a></p><p><strong>推薦閲讀：</strong><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490415%26idx%3D1%26sn%3D1914c7fd25aac5d33b98663571bbb744%26chksm%3Dcfb457cff8c3ded9c02809aad88012fa802eac55222eebe70b8c637ca2c86a101045aa81e73a%26scene%3D21%23wechat_redirect" target="_blank">是時候和 Jenkins 説再見了</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank">Zadig vs. Jenkins 詳細比對：時代的選擇與開發者之選</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247489682%26idx%3D1%26sn%3Df4ac5ceb38547542061477a45d8dc86d%26chksm%3Dcfb45432f8c3dd24b727e0fb6db276b2d63b2751933e63a25b00b9d9fac2dd68efbd2cbd3863%26scene%3D21%23wechat_redirect" target="_blank">平台工程和 AI 時代的新 10 億開發者</a></p></div><div style="text-align:center">
   2023 年 11 月 1 日 
 </div><div style="text-align:center">
   秋風起，露成霜，正是一年最美時 
 </div><div style="text-align:center">
   Zadig 團隊踏入了 
 </div><div style="text-align:center">
   創業的第五個年頭 
 </div><div style="text-align:center">
   開源的第 888 天 
 </div><div style="text-align:center">
   然而今天 
 </div><div style="text-align:center">
   我們要向 Zadig 
 </div><div style="text-align:center">
   説再見了 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   深秋外象趨冷 
 </div><div style="text-align:center">
   實則萬物蟄伏 
 </div><div style="text-align:center">
   在孕育着新的生機 
 </div><div style="text-align:center">
   今天，我們向 Zadig 1.0 告別 
 </div><div style="text-align:center"><span style="color:#fd2968"><strong>迎來全新的 Zadig 2.0!</strong></span></div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   回顧開源的這兩年多時間裏 
 </div><div style="text-align:center">
   Zadig 1.0 已完成了 2 萬 6 千多次的企業下載 
 </div><div style="text-align:center">
   發佈了 21 個開源版本，10 個企業版本 
 </div><div style="text-align:center">
   在 2 千多家企業和團隊深度使用 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   我們創作了 157 篇原創技術和產品文章 
 </div><div style="text-align:center">
   製作了 52 個獨創的短視頻 
 </div><div style="text-align:center">
   與 100 多位國內外商業、技術和產品領域的同仁夥伴建立了深厚的鏈接 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   今天，Zadig 已不再是嬰兒 
 </div><div style="text-align:center">
   是一個堅定自信的少年 
 </div><div style="text-align:center">
   走進數千家企業和團隊的日常工作中 
 </div><div style="text-align:center">
   讓他們的工作更加高效愉悅 
 </div><div style="text-align:center">
   這段旅程，Zadig 背後的團隊和社區一起 
 </div><div style="text-align:center">
   合作共創 
 </div><div style="text-align:center">
   品味挫折 
 </div><div style="text-align:center">
   分享喜悅 
 </div><div style="text-align:center">
   追逐自由 
 </div></div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-fbb18b0ecc053068d166ea1f637149f273f.png" referrerpolicy="no-referrer"><img alt="" src="https://oscimg.oschina.net/oscnet/up-e94bae5f521bce7e3f5326d76218df7912c.png" referrerpolicy="no-referrer"></p><div><div style="text-align:center">
   今天，2023 年 11 月 1 日 
 </div><div style="text-align:center">
   我們團隊決定再度邁出一大步 
 </div><div style="text-align:center">
   正式宣佈： 
 </div><div style="text-align:center">
   開源 Zadig 與，企業版 ZadigX 產品合併！ 
 </div><div style="text-align:center">
   並全面啓用企業版功能，提供一鍵試用 
 </div><div style="text-align:center">
   與此同時，我們做出了重大的決定 
 </div><div style="text-align:center">
   全部開放服務端源代碼 
 </div><div style="text-align:center">
   接下來我們還將發佈嶄新的文檔站 
 </div><div style="text-align:center">
   並推出更加易用的新手在線教程 
 </div></div><span id="OSC_h1_1"></span><h1><span style="color:#fd2968"><em><strong>01</strong></em><strong>為何做出這一選擇？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-e6678f7e349d8523888cb8b7d3e0659b69a.png" referrerpolicy="no-referrer"></strong></p><div><div style="text-align:center">
   首先，我們希望通過更開放的方式 
 </div><div style="text-align:center">
   為這個不平凡的時代注入信心 
 </div><div style="text-align:center">
   在過去的三年中，我們共同經歷了許多挑戰 
 </div><div style="text-align:center">
   包括疫情、經濟動盪，資本衰退、互聯網紅利時代的結束，AI 時代的到來 
 </div><div style="text-align:center">
   &nbsp; 
 </div><div style="text-align:center">
   其次，我們希望通過這次開放性嘗試，帶給每位 IT 從業者更多力量！ 
 </div><div style="text-align:center">
   開源 2 年半以來，社區裏的每個人，不論是 80 後、90 後還是 00 後 
 </div><div style="text-align:center">
   都經歷了前所未有的技術和經濟週期 
 </div><div style="text-align:center">
   似乎沒有人準備好，但這些挑戰都如期而至： 
 </div><div style="text-align:center">
   互聯網大規模的裁員和失業潮影響了我們每個人和每個家庭 
 </div><div style="text-align:center">
   「IT 行業的未來在哪裏？ 
 </div><div style="text-align:center">
   IT 人的未來在何方？ 
 </div><div style="text-align:center">
   什麼是時代需要的創新？ 
 </div><div style="text-align:center">
   什麼是適閤中國特色的 IT 創新之路？ 
 </div><div style="text-align:center">
   如何用技術讓這個世界更美好？」 
 </div></div><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-7643c8b8c38bf97523b3e001c3806795bac.png" referrerpolicy="no-referrer"></p><p>作為 Zadig 的創始人，我會經常思考這些問題。顯然並沒有標準答案，有一點可以肯定：真正的創新是思想的進步和對他人帶來的積極影響。其實，開源代碼從來不是核心資產，我們希望用更開放的心態，和社區、用戶、客戶的小夥伴們更為緊密的配合，找到最佳的姿勢幫助到最需要的人，與同行者一起面對每一次成長和變化，直面每一次恐懼和不安。</p><p>同時，通過這次版本發佈和源碼開放，我們希望能夠讓更多的開發者看到 Zadig 的企業級全部功能，為希望成為客戶的用戶提供更為簡單的升級方式，從根本上提供更多安全感。通過新版本 Zadig，企業客戶可以一鍵輸入試用授權，快速實驗 Zadig 專業版能力，企業客戶更放心地嘗試新技術和新產品，助力各個行業、產業 IT 的數字化升級。</p><p>作為軟件交付和研發鏈路中重要的連接者，我們希望通過這次 Zadig V2.0.0 的開源和版本發佈，與同行的基礎軟件開發者們一起嘗試新模式，為建立新的開源商業秩序開一個頭。</p><span id="OSC_h1_2"></span><h1><span style="color:#fd2968"><em>02&nbsp;&nbsp;</em><strong>Zadig 產品具體有哪些變化？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-a6a559045246e08f1857b0e8666bab21df8.png" referrerpolicy="no-referrer"></strong></p><p>從源代碼層面上，本次產品合併以開源 Zadig v1.18.0（最新版） 為基礎，合併了原 ZadigX v1.8.0（即企業版）全部新功能代碼，統稱為 Zadig，產品版本正式定義為 Zadig v2.0.0，同時服務端代碼在 GitHub 上全部開源，產品功能差異通過授權區分基礎版和專業版。</p><p>對於已經在大規模使用 Zadig 的小夥伴，如果期待了解和親自體驗專業版功能，可以在平滑升級後免費激活並體驗專業版功能長達 30 天，到期後專業版產生的數據不刪除，原有基礎版功能仍可正常使用。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-d6ad9eba6f9b41f1d391901be2fd3ae39c0.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_3"></span><h1><span style="color:#fd2968"><em>03&nbsp;&nbsp;</em><strong>對現有用戶有哪些影響？</strong></span></h1><p style="text-align:center"><strong><img alt="" src="https://oscimg.oschina.net/oscnet/up-91c5dba9d5f03113d993ebe2fa94c7638cd.png" referrerpolicy="no-referrer"></strong></p><p>對於社區開源用戶而言，將在原有開源基礎功能上進一步獲得更多企業級功能，包括環境管理睡眠進一步做資源成本的削減，同時支持服務級測試管理、自定義工作流也一次性開放了大量企業內置最佳實踐模板。同時 Zadig v2.0.0 在過去 V1.x 架構的基礎上架構的基礎上改進了易用性和性能，優化了安全細節，顯著提高了工作流並行和複雜場景的執行效率，效率提升高達 50%，Zadig 的資源運行成本也降低了近 30%。在之後迭代中，用戶也將持續獲得產品底層能力的可靠性，這些更新將幫助到更多企業，提升開發測試階段的雲原生持續交付能力，為開發者提供更出色的體驗。</p><p>對於企業客戶，我們用 ZadigX 品牌代表包含企業級功能和專業服務的解決方案，"X"代表為企業客戶提供更高質量的服務和保障，根據企業的具體難點和需求，接下來我們會面向企業推出一系列 DevOps 專家培訓、DevOps 效能提升、雲原生轉型、IT 數字化升級等企業級解決方案。</p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-8c8a7c1737a91a1e0f819e9dcb9a3c82b9c.png" referrerpolicy="no-referrer"></p><p style="text-align:center"><img alt="" src="https://oscimg.oschina.net/oscnet/up-5b2c672b70e514e6133d7b885270d5fc71c.png" referrerpolicy="no-referrer"></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490989%26idx%3D1%26sn%3D53f771dcb0349babdc0077bd65ad52fa%26chksm%3Dcfb4510df8c3d81b11eb7a6f6ade9b4ba0b9d32f2d59e5d324eaee65487c1f83847edf1290bb%26token%3D812456402%26lang%3Dzh_CN%23rd" target="_blank">閲讀原文</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkoderover%2Fzadig" target="_blank">Zadig 在 Github</a>&nbsp;/&nbsp;<a href="https://gitee.com/koderover/zadig">Zadig 在 Gitee</a></p><p><strong>推薦閲讀</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490415%26idx%3D1%26sn%3D1914c7fd25aac5d33b98663571bbb744%26chksm%3Dcfb457cff8c3ded9c02809aad88012fa802eac55222eebe70b8c637ca2c86a101045aa81e73a%26scene%3D21%23wechat_redirect" target="_blank">是時候和 Jenkins 説再見了</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247490637%26idx%3D1%26sn%3D6e0498b37fb15f8b8903c4997e5611d8%26chksm%3Dcfb450edf8c3d9fb758d691081f09fd85d91dbb17534ba9c18c2300725462d3806581efbd237%26scene%3D21%23wechat_redirect" target="_blank">Zadig vs. Jenkins 詳細比對：時代的選擇與開發者之選</a>&nbsp;/&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NDY0NTMyNw%3D%3D%26mid%3D2247489682%26idx%3D1%26sn%3Df4ac5ceb38547542061477a45d8dc86d%26chksm%3Dcfb45432f8c3dd24b727e0fb6db276b2d63b2751933e63a25b00b9d9fac2dd68efbd2cbd3863%26scene%3D21%23wechat_redirect" target="_blank">平台工程和 AI 時代的新 10 億開發者</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 07:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/koderover/blog/10140233</guid>
            <link>https://my.oschina.net/koderover/blog/10140233</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[阿里雲推出 AI 編碼助手：通義靈碼]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">阿里雲推出了一款基於通義大模型的智能編碼輔助工具 —— <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftongyi.aliyun.com%2Flingma%2F" target="_blank">通義靈碼</a>，提供行級/函數級實時續寫、自然語言生成代碼、單元測試生成、代碼註釋生成、代碼解釋、研發智能問答、異常報錯排查等能力，並針對阿里雲 SDK/OpenAPI 的使用場景調優，助力開發者高效、流暢的編碼。</span></p><p><span style="color:#000000">根據官網介紹，通義靈碼兼容 Visual Studio Code、JetBrains IDEs 等主流 IDE；且支持 Java、Python、Go、C/C++、JavaScript、TypeScript、PHP、Ruby、Rust、Scala 等主流編程語言。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>核心場景</strong></span></h4><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代碼智能生成</strong></span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000">經過海量優秀開源代碼數據訓練，可根據當前代碼文件及跨文件的上下文，為你生成行級/函數級代碼、單元測試、代碼註釋等。沉浸式編碼心流，秒級生成速度，讓你更專注在技術設計，高質高效地完成編碼工作。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>研發智能問答</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">基於海量研發文檔、產品文檔、通用研發知識、阿里雲的雲服務文檔和 SDK/OpenAPI 文檔等進行問答訓練，為你答疑解惑，助你輕鬆解決研發問題。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>產品優勢</strong></span></h4><ul style="margin-left:0; margin-right:0"><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>跨文件感知讓代碼生成更貼合業務場景：</strong>客戶端和模型層同步優化針對代碼跨文件上下文感知能力，生成代碼更加貼合當前代碼庫的業務場景。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>阿里雲服務使用場景友好：</strong>專門針對阿里雲的雲服務使用、SDK/OpenAPI 的使用等場景調優，編碼時能夠更加便捷地使用阿里雲服務；在對阿里雲使用有疑問時，智能編碼助手的回答也將更加有效。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>適配多 IDE 的原生設計，符合開發者使用習慣：</strong>適配 IDE 原生主題、交互模式，讓開發者感受到 IDE 原生的視覺和交互體驗，更符合開發者使用習慣。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>研發問答、文檔/代碼搜索能力，打造沉浸式編碼：</strong>無需切換工具，IDE 客戶端內即可滿足開發者編碼場景中的技術資料檢索、技術難題解答的訴求，打造開發者沉浸式編碼體驗。</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000"><strong>雙模引擎，自由切換：</strong>支持極速本地模型、雲端大模型兩種代碼補全模型，支持一鍵切換，滿足不同網絡環境、不同補全強度的場景訴求。</span></p></li></ul><h2 style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><strong>功能介紹</strong></span></h2><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>行級/函數級實時續寫</strong></span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000">根據當前語法和跨文件的代碼上下文，實時生成行、函數建議代碼。</span></p><p style="color:#181818; margin-left:0px; margin-right:0px; text-align:left"><span style="color:#000000"><img alt="" height="182" src="https://oscimg.oschina.net/oscnet/up-145ecbcb5413f83c4f6512faeb7572d39ba.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>自然語言生成代碼</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">通過自然語言描述你想要的功能，可直接在編輯器區生成代碼，編碼心流不間斷。</span></p><p><span style="color:#000000"><img alt="" height="186" src="https://oscimg.oschina.net/oscnet/up-515b87e9afaf2bfb1f9200538f114663d20.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>單元測試生成</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">支持根據 JUnit、Mockito、Spring Test、unit test、pytest 等框架生成單元測試。</span></p><p><span style="color:#000000"><img alt="" height="198" src="https://oscimg.oschina.net/oscnet/up-6512237992e15393d3abbc2c8e3c77d4063.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代碼註釋生成</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">一鍵生成方法註釋及行間註釋，節省你寫代碼註釋的時間，並能夠有效提升代碼可讀性。</span></p><p><span style="color:#000000"><img alt="" height="192" src="https://oscimg.oschina.net/oscnet/up-bd96048c8e3e6d01aa66c1136d8ca7ff355.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>代碼解釋</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">支持 30 多種語言的識別，選中代碼後可自動識別編程語言並生成代碼解釋。跨越語言的邊界，讓你閲讀代碼更高效。</span></p><p><span style="color:#000000"><img alt="" height="154" src="https://oscimg.oschina.net/oscnet/up-615f625c27c7e8afe87ad83e1e7df085c76.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>研發領域自由問答</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">遇到編碼疑問、技術難題時，一鍵喚起通義靈碼，無需離開 IDE 客戶端，即可快速獲得答案和解決思路。聚焦研發領域知識的問答，幫助開發者快速解決問題。</span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><img alt="" height="214" src="https://oscimg.oschina.net/oscnet/up-70413ee56236fdc009f429692be9593d05b.png" width="500" referrerpolicy="no-referrer"></span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>異常報錯智能排查（Java）</strong></span></p><p style="color:#181818; margin-left:0; margin-right:0; text-align:start"><span style="color:#000000">當運行出現異常報錯時，一鍵啓動報錯排查的智能答疑，可結合運行代碼、異常堆棧等報錯上下文，快速給出排查思路或修復建議代碼。</span></p><p><span style="color:#000000"><img alt="" height="309" src="https://oscimg.oschina.net/oscnet/up-87d6c9327ffeb245c28f22c1c979fae8172.png" width="500" referrerpolicy="no-referrer"></span></p><h4 style="margin-left:0px; margin-right:0px; text-align:start"><span style="color:#000000"><strong>支持 IDE 及操作系統</strong></span></h4><ul style="margin-left:0; margin-right:0"><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">Windows 7 及以上、macOS、Linux</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">JetBrains IDEs （IntelliJ IDEA、PyCharm、GoLand、WebStorm 等）2020.3 及以上</span></p></li><li><p style="margin-left:0; margin-right:0"><span style="color:#000000">Visual Studio Code 1.75.1 及以上</span></p></li></ul><p><span style="color:#000000">目前，通義靈碼已面向所有開發者開放公測，各大 IDE 插件市場均已上線。</span></p><p><span style="color:#000000">更多詳情<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftongyi.aliyun.com%2Flingma%2F" target="_blank">可查看官網</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264459</guid>
            <link>https://www.oschina.net/news/264459</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 開源藍心大模型-7B：70 億參數、適閤中國開發者]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在 2023 vivo 開發者大會上，vivo 宣佈開源 70 億參數級的藍心大模型-7B，以及對應的微調框架。據稱是行業首家開源大模型的手機廠商。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-27161d355f59c839fc4c9b6bb433e37dff3.png" referrerpolicy="no-referrer"></p><p>vivo 介紹道，他們提供<strong>藍心大模型開發套件 BlueKit</strong>，讓開發者不必考慮使用成本，專注於創新產品體驗。此外，vivo 還推出藍心開發者激勵計劃，<strong>提供一億元資源支持，包含技術、運營、品牌三大方面。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-93548b2298b63f816adaa7f7c40b07b00f0.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0c711a4b9bd565a2eb78daee566e4475c80.png" referrerpolicy="no-referrer"></p><hr><p>藍心大模型-7B 是 vivo 自研通用大模型矩陣中的其中一款。</p><p><img height="646" src="https://static.oschina.net/uploads/space/2023/1101/143959_y0Ws_2720166.png" width="1834" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1101/144435_2CXR_2720166.png" referrerpolicy="no-referrer"></p><p>整體如下：</p><ul><li><p>1B：端側大模型</p></li><li><p>7B：端雲兩用模型（開源）</p></li><li><p>70B：雲端主力模型</p></li><li><p>130B：雲端大模型</p></li><li><p>175B：雲端大模型</p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264455</guid>
            <link>https://www.oschina.net/news/264455</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 發佈自研操作系統藍河 (BlueOS)，系統框架採用 Rust 編寫]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 vivo 開發者大會今天正式開始。大會上，vivo 發佈了自研操作系統<strong>藍河 (BlueOS)</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-15a70d97c2f8f3654e7d6f94c8c92df5505.png" referrerpolicy="no-referrer"></p><p>vivo 稱「藍河操作系統」是面向通用人工智能時代的自研智慧操作系統 —— 底層接入了 AI 大模型，支持基於自然交互方式的應用開發。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135537_Q43j_2720166.png" referrerpolicy="no-referrer"></p><p>vivo 還表示，藍河操作系統<strong>採用 Rust 編寫「系統框架」</strong>——從源頭避免了內存使用不當引起的安全漏洞。據稱是行業首家<strong>。</strong></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f21c3eb7d2568b66e3cebdf8f628b9bb78b.png" referrerpolicy="no-referrer"></p><p><img src="https://static.oschina.net/uploads/space/2023/1101/135659_sEFQ_2720166.png" referrerpolicy="no-referrer"></p><p>運行要求方面，在低至 200Mhz 主頻 32MB 內存，高至 4GHz 主頻 24GB 內存的各種設備上，藍河都能流暢運行。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/142454_nhO4_2720166.png" referrerpolicy="no-referrer"></p><p>據瞭解，藍河操作系統目前不會在 vivo 手機上提供，首款搭載藍河操作系統的 vivo 設備是 vivo Watch3 智能手錶。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-b5c944705e833222c61dc1c96c7713648ca.png" referrerpolicy="no-referrer"></p><p>此外，<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1668726803%2FNqydVxKTF%3Frefer_flag%3D1001030103_" target="_blank">據稱藍河操作系統是基於 Linux/RTOS 的自研架構</a></u>，因此不兼容 Android 應用。不過它兼容 hapjs，以獲得更好的生態支持。</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/152743_iniv_2720166.png" referrerpolicy="no-referrer"></p><blockquote><p>hapjs 項目是由開放原子開源基金會孵化及運營的開源項目，<strong>是快應用標準的開源實現</strong>，是基於智能硬件平台的輕型應用形態，由多智能硬件廠商組成的快應用聯盟聯合制定標準共同驅動。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-1ed767bef366be3bde87f6dbd714fdbd581.png" referrerpolicy="no-referrer"></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 06:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264444</guid>
            <link>https://www.oschina.net/news/264444</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[macOS Sonoma 黑屏 bug，影響 Asahi Linux]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Asahi Linux 發佈了一篇文檔，説明瞭近期 macOS 黑屏情況。</p><blockquote><p><span style="color:#333333">Asahi Linux 項目致力於將 Linux 操作系統移植到蘋果的 Apple Silicon Macs 系列電腦設備上。</span></p><ul><li><a href="https://www.oschina.net/news/125751/asahi-linux-set-up" target="_blank">可移植蘋果 M1 的 Asahi Linux 項目正式啓</a></li></ul></blockquote><p>Asahi 解釋，macOS Sonoma 和 macOS Ventura 13.6 在其升級和啓動過程中發佈了多個嚴重的錯誤。這些錯誤結合在一起，可以創建出一種情況，即無論使用何種電源按鈕按壓組合，機器總是啓動到黑屏。這使用戶陷入困境，唯一的解決方案就是使用 DFU 恢復。</p><p>在某些設置和特定型號下，這種情況可能會發生，即多個 macOS 版本並行安裝（一個 Sonoma，一個更早的版本）。由於 Asahi Linux 的行為就像是 macOS 12.3/12.4/13.5（取決於型號和安裝時間），所以 macOS Sonoma 和 Asahi Linux 的雙啓動安裝會產生相同的問題。對於 macOS 13.6，這種情況甚至不需要雙啓動系統，只要作為唯一安裝的操作系統就可以觸發。</p><p>目前 Asahi Linux 安裝程序已經更新，現在它可以在啓動時自動進行完整性檢查並診斷系統。要運行它，請將此命令粘貼到 macOS 的終端中：</p><p style="text-align:start"><code>curl https://alx.sh | sh</code></p><p style="text-align:start">進入主菜單，用戶可以退出安裝程序，而不對系統做任何更改。</p><p style="text-align:start">Asahi Linux 具體説明瞭 macOS 啓動失敗的原因：</p><ul><li><p>macOS Sonoma 的升級使用先前安裝的版本作為系統恢復。這在某種程度上是有道理的，但並未考慮到舊版 RecoveryOS 與新固件之間的向後兼容性問題。如果這種不匹配導致 recoveryOS 無法啓動，那麼系統恢復將無法使用。</p></li><li><p>對於 14 英寸和 16 英寸的型號：一旦系統固件更新到 macOS Sonoma 版本，如果顯示器的刷新率設置為非 ProMotion，則該系統將無法正確地啓動舊版本的 macOS 安裝程序和 Asahi Linux。這包括當這些系統被設置為默認啓動操作系統時的恢復模式，以及至少在下一次操作系統升級之前的系統恢復。</p></li></ul><p>影響設備、系統：</p><ul><li><p>配備 ProMotion 顯示屏的 MacBook Pro 型號（14 英寸和 16 英寸）受到黑屏啓動錯誤的影響。</p></li><li><p>macOS Sonoma 14.0+（截至 2023 年 10 月 31 日尚未修復）</p></li><li><p>macOS Ventura 13.6+ (使用 14.0 固件)</p></li><li><p>可能受影響：macOS Monterey 12.7（未經確認）</p></li></ul><p><strong>如果還沒升級到 Sonoma，Asahi Linux&nbsp;<span style="background-color:#ffffff; color:#1f2328">建議等到蘋果解決這些問題後再進行升級。</span></strong></p><p>更多細節查看 Asahi 發佈的説明：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAsahiLinux%2Fdocs%2Fwiki%2FmacOS-Sonoma-Boot-Failures" target="_blank">https://github.com/AsahiLinux/docs/wiki/macOS-Sonoma-Boot-Failures</a></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 04:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264432/macos-sonoma-boot-failures</guid>
            <link>https://www.oschina.net/news/264432/macos-sonoma-boot-failures</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微信 iOS 版「史詩級」更新：「發送」按鈕獨立]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>微信 iOS 版昨天發佈了 8.0.43 更新，更新日誌一如既往地是「修復了一些已知問題」。</p><blockquote><p><img height="780" src="https://static.oschina.net/uploads/space/2023/1101/121221_VGwW_2720166.png" width="1810" referrerpolicy="no-referrer"></p></blockquote><p>不過熱心網友發現的一項重要變化衝上了微博熱搜：<span style="color:#e67e22"><strong>#微信新增獨立發送按鈕#</strong></span>。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-12f6e066aebe74a1bd7440aa69ef266c4b9.png" referrerpolicy="no-referrer"></p></blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-877e90cea0d617b8694aa9a040acdc2080e.png" referrerpolicy="no-referrer"></p><p>沒錯，微信 for iOS 8.0.43 新增了「使用獨立的發送按鈕」開關。開啓後，iOS 自帶輸入法的「發送」按鍵變成「換行」按鍵，而輸入框右側增加了獨立的「發送」。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-410e4a667b0d00dcd7c363e6c756adad620.png" referrerpolicy="no-referrer"></p><p>對使用 iOS 自帶輸入法用戶來説，這屬實是「史詩級」更新。</p><p>畢竟此前在輸入文字的時候如果想換行，需要在輸入框輕點或者長按呼出換行開關。現在「換行」和「發送」終於都有了獨立按鍵，感謝 Allen Zhang : )</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 04:23:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264431</guid>
            <link>https://www.oschina.net/news/264431</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[運營商在光貓內置反詐插件？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>網友發帖稱，自己的同事參加某運營商<strong>加 1 元提速 2000m 送 fttr 1+2 活動</strong>後，由於活動要求 45 天內保持在線並且要使用路由模式，這名同事就按照要求使用路由模式。</p><blockquote><p>FTTR (Fiber to The Remote)，是指光纖敷設到遠端節點，為光纖接入的基本技術方式。</p></blockquote><p>然後他發現自建的科學上網功能出現不能連接的情況，並且訪問&nbsp; xenyth.net 網站時直接跳轉到了反詐頁面，幾分鐘之後接到反詐熱線打來的電話，詢問他有沒有訪問一個叫做 xenyth.net 的詐騙網站。工作人員告訴他這是一個網購詐騙網站，付款後不會發貨，要求不再訪問，如有需要可以安排民警上門。</p><p><span style="background-color:#ffffff; color:#000000">後面這名同事搞到超級密碼後進入光貓，發現：</span></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-9b10cd4d0019c4015f48be3f0d542493520.png" referrerpolicy="no-referrer"></p><p>最後附上卸載插件方法：</p><p><img src="https://static.oschina.net/uploads/space/2023/1101/113529_5FaL_2720166.png" referrerpolicy="no-referrer"></p><p><em>via&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.v2ex.com%2Ft%2F986550" target="_blank">https://www.v2ex.com/t/986550</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:30:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264421</guid>
            <link>https://www.oschina.net/news/264421</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[四維縱橫完成超億元 B 輪融資]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><span style="background-color:#ffffff">新一代超融合數據庫廠商四維縱橫<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fq_l-0lQ_GJxLTEXTjF30ag" target="_blank">宣佈</a>完成了上億元人民幣的 B 輪融資，本輪融資由用友、順義產業基金領投，廣州同創基金跟投。該公司表示，</span><span style="background-color:#ffffff">此次募集資金將會主要用於研發核心技術，建設商業生態鏈等方面。</span></span></p><p><span style="color:#000000"><img height="251" src="https://oscimg.oschina.net/oscnet/up-ecefb2dbc5ddf668afa56fccacfa3960e27.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">四維縱橫是一家成立於 2020 年的數據庫公司，以超融合數據庫 YMatrix 為企業提供集「分析、事務、時序」為一體的企業級數據庫產品服務。目前，四維縱橫，以 YMatrix 為核心，自研了全棧向量化執行器、分佈式數據庫災備、MARS3 存儲引擎、MatrixShift 遷移工具、MatrixGate 高性能寫入組件、MatrixUI 圖形化界面等一系列商業化套件。</span></p><p><span style="color:#000000"><img height="345" src="https://oscimg.oschina.net/oscnet/up-c609ba963a02c51a5f6c10587fc68105704.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">當前，YMatrix 已經被應用到證券、通信、銀行、保險、智能製造、車聯網等多個行業領域中，服務的客戶包括浪潮、中興、理想汽車、寧德時代、三一重工等多個頭部企業。</span></span></p><p><span style="color:#000000">公告指出，在本輪融資之後，四維縱橫將會以目前 YMatrix 產品技術能力為根基，以超融合理念為發展方向，繼續拓展新的應用領域，將 YMatrix 超融合數據庫產品應用於更多的場景中。另外，四維縱橫將進一步加快並夯實技術團隊的人員建設和技術基礎，為全球用戶提供更加全面的超融合解決方案。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264414</guid>
            <link>https://www.oschina.net/news/264414</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百度上線「文心一言」會員，開通可解鎖文心大模型 4.0]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>百度大模型文心一言現已上線會員模式，開通後可解鎖文心大模型 4.0。</p><p><strong>目前文心一言基礎版功能依舊免費開放使用</strong>，可以滿足用戶的日常需求，如交互對話、問答等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-523eef7bc90f0772422e76d8d238e5a06f5.png" referrerpolicy="no-referrer"></p><p>據介紹，文心一言會員單月購買價格為 59.9 元，<strong>連續包月價格為 49.9 元</strong>（次月以 49.9 元 / 月自動續費，可隨時取消）。此外，百度還推出了文心一言 + 文心一格（白銀）的聯合會員，價格為 99 元 / 月。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2e89f249c9e05e483bc3e37a5c145a0001d.png" referrerpolicy="no-referrer"></p><p><strong>文心一言會員權益：</strong></p><ul><li><p>模型能力：文心大模型 4.0</p></li><li><p>圖片生成：文生圖能力全面升級</p></li><li><p>插件權益 （網頁端）：高階插件</p></li><li><p>靈感值 （App 端）：單月贈送 600 靈感值</p></li></ul><p><strong>文心一格會員權益：</strong></p><ul><li><p>極速生成多尺寸高清圖像</p></li><li><p>創作海報和藝術字</p></li><li><p>白銀會員權益：AI 編輯改圖修圖</p></li></ul><hr><p><u><a href="https://www.oschina.net/news/262086">文心大模型 4.0 於上個月正式亮相</a></u>，李彥宏表示，<strong>這是迄今為止最強大的文心大模型</strong>，實現了基礎模型的全面升級，在理解、生成、邏輯和記憶能力上都有着明顯提升，綜合水平「與 GPT-4 相比毫不遜色」。</p><p><img alt="up-cb21975862a8f7b014aeea47cbab52da1df.png" src="https://oscimg.oschina.net/oscnet/up-cb21975862a8f7b014aeea47cbab52da1df.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264412</guid>
            <link>https://www.oschina.net/news/264412</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenSign —— 開源 PDF 電子簽名解決方案]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenSign 是一個開源文檔電子簽名解決方案，旨在為 DocuSign、PandaDoc、SignNow、Adobe Sign、Smartwaiver、SignRequest、HelloSign 和 Zoho Sign 等商業平台提供安全、可靠且免費的替代方案。</p><p>特性：</p><ul><li><strong>安全簽名</strong>：利用最先進的加密算法來確保文檔的安全性和完整性。</li><li><strong>用戶友好的界面</strong>：設計時考慮到可用性，使技術和非技術用戶都能輕鬆使用。</li><li><strong>多平台支持</strong>：兼容各種瀏覽器和設備。</li><li><strong>邀請和協作用戶</strong>：將團隊中的多人帶入簽名流程，所有這些都在你自己的基礎設施內進行。</li><li><strong>安全</strong>：允許使用「OpenSigDrive」輕鬆、安全和無縫地組織文檔。</li><li><strong>審計跟蹤</strong>：保留與文檔簽名過程相關的所有活動的詳細日誌，包括 IP 地址和訪問時間。</li><li><strong>完成證書</strong>：所有參與者簽署文件後立即生成安全完成證書。</li><li><strong>API 支持</strong>：提供強大的 API，用於集成到其他軟件和服務中。</li></ul><p><img alt="" height="293" src="https://static.oschina.net/uploads/space/2023/1031/154224_RLJo_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="298" src="https://static.oschina.net/uploads/space/2023/1031/154242_mhWv_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><img alt="" height="307" src="https://static.oschina.net/uploads/space/2023/1031/154356_RuMR_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 03:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/opensign</guid>
            <link>https://www.oschina.net/p/opensign</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 一站式分佈式任務調度系統 Hodor]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-hodorscheduler" class="anchor" href="https://gitee.com/dromara/hodor#hodorscheduler"></a>HodorScheduler</h1><h2><a id="user-content-介紹" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BB%8B%E7%BB%8D"></a>介紹</h2><p>Hodor 是一個專注於<strong>任務調度</strong>以及<strong>任務編排</strong>的<strong>一站式</strong>分佈式任務調度系統。</p><p>通過提供任務編程 API 和接口協議， 方便支持用戶使用不同的編程語言實現任務執行以及自定義任務類型的擴展，以滿足各種業務場景下的任務執行。</p><p>支持多種接入方式，支持 Java SDK 包方式、Java Agent 獨立進程方式接入，以及兼容 XXLJob 框架、Spring Task 框架任務無縫接入。</p><p>多語言執行器實現，計劃支持 Go 或者 Rust 語言執行器（正在設計與開發中）的接入，滿足在資源有限的執行器節點執行，比如物聯網場景下面的定時任務執行。</p><p>支持豐富的任務類型，除了支持普通的 Java、腳本任務的執行，也支持了大數據任務 Hadoop、Spark、Flink、Kettle 等主流任務的執行，滿足用戶的不同場景。</p><h2><a id="user-content-主要特性" class="anchor" href="https://gitee.com/dromara/hodor#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"></a>主要特性</h2><ol><li>支持 Cron、FixedRate、FixedDelay、OnceTime 方式配置定時任務，可以方便地實現各種定時任務需求。</li><li>支持 DAG 方式進行任務編排，使得任務之間的關係更加清晰，同時提高了系統的可擴展性和靈活性。</li><li>支持 Java 任務和大數據任務調度，兼容 XXLJob、SpringTask 調度任務，滿足不同場景下的任務調度需求。</li><li>支持可擴展執行器，用戶可以根據自己的需求自定義實現任務類型，從而更好地適應不同的業務場景。</li><li>支持任務靜態分片、動態分片、廣播、WorkFlow 等多種任務執行模式。</li><li>支持任務自動創建與手動創建以及批量創建等方式，任務的暫停、恢復、Kill 等動作，以及實時日誌查看等。</li><li>基於 CopySet 算法實現任務副本分配，提高了任務的可靠性和容錯性，從而保障了任務的高可用性。</li></ol><p>詳細文檔請查閲：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor">https://www.yuque.com/tomgs/hodor</a></p><h2><a id="user-content-架構設計" class="anchor" href="https://gitee.com/dromara/hodor#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"></a>架構設計</h2><p><img src="https://gitee.com/dromara/hodor/raw/master/docs/assets/img/hodor%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="hodor 架構設計圖" referrerpolicy="no-referrer"></p><h2><a id="user-content-快速開始" class="anchor" href="https://gitee.com/dromara/hodor#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"></a>快速開始</h2><p>項目結構：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">hodor-scheduler</span><span id="LC2" class="line">├─docs                                          # 文檔存放位置</span><span id="LC3" class="line">├─hodor-actuator                                # hodor 任務執行器</span><span id="LC4" class="line">│  ├─hodor-actuator-api                         # 執行器擴展接口</span><span id="LC5" class="line">│  ├─hodor-actuator-java                        # jar 包方式任務執行器</span><span id="LC6" class="line">│  ├─hodor-actuator-agent                       # 獨立進程方式任務執行器</span><span id="LC7" class="line">│  ├─hodor-actuator-xxljob                      # 支持 xxl-job 執行器</span><span id="LC8" class="line">│  └─hodor-actuator-springtask                  # 支持 spring task 執行器</span><span id="LC9" class="line">├─hodor-admin                                   # hodor 管理控制枱（TODO）</span><span id="LC10" class="line">├─hodor-client                                  # 提供與 hodor server 的交互 sdk</span><span id="LC11" class="line">├─hodor-common                                  # hodor 公共依賴</span><span id="LC12" class="line">├─hodor-core                                    # hodor 核心業務</span><span id="LC13" class="line">├─hodor-examples                                # hodor 測試用例</span><span id="LC14" class="line">├─hodor-cache                                   # hodor 擴展</span><span id="LC15" class="line">│  ├─hodor-cache-local                          # 基於本地內存的緩存</span><span id="LC16" class="line">│  ├─hodor-cache-embedded                       # 基於 embedded 的分佈式緩存</span><span id="LC17" class="line">│  └─hodor-cache-redis                          # 基於 redis 的分佈式緩存</span><span id="LC18" class="line">├─hodor-model                                   # hodor 公共數據模型</span><span id="LC19" class="line">├─hodor-storage                                 # hodor storage 模塊</span><span id="LC20" class="line">├─hodor-register                                # hodor 註冊中心</span><span id="LC21" class="line">│  ├─hodor-register-api</span><span id="LC22" class="line">│  ├─hodor-register-embedded                    # 基於 Raft 實現註冊中心</span><span id="LC23" class="line">│  └─hodor-register-zookeeper                   # 基於 zk 實現註冊中心</span><span id="LC24" class="line">├─hodor-remoting                                # hodor 通信框架</span><span id="LC25" class="line">│  ├─hodor-remoting-api</span><span id="LC26" class="line">│  └─hodor-remoting-netty</span><span id="LC27" class="line">├─hodor-scheduler                               # hodor 調度核心</span><span id="LC28" class="line">│  ├─hodor-scheduler-api</span><span id="LC29" class="line">│  └─hodor-scheduler-quartz</span><span id="LC30" class="line">└─hodor-server                                  # hodor 入口</span><span id="LC31" class="line"></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-本地源碼運行方式" class="anchor" href="https://gitee.com/dromara/hodor#%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"></a>本地源碼運行方式</h2><ol><li>在 mysql 下執行 docs 目錄下面的 hodor_ddl.sql。</li><li>在項目根目錄下通過 mvn package -DskipTests=true 命令編譯整個項目，因為涉及到一些代碼的自動生成。</li><li>進入到 hodor-server，啓動 HodorServer 調度器。</li><li>進入到 examples 下面的 hodor-actuator-java-example，啓動 java 任務執行器程序</li><li>java 執行器啓動完成後會自動將任務註冊到調度器裏面來</li></ol><h2><a id="user-content-任務使用説明" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"></a>任務使用説明</h2><p>詳細參考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fiqrsqxh2i2qt5ixi">執行器操作指南</a></p><h3><a id="user-content-java 任務接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#java%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>java 任務接入 demo</h3><p>詳細 demo 代碼參考 <em>hodor-examples/hodor-actuator-java-example</em> 模塊</p><blockquote><p>普通 java 任務</p></blockquote><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">group</span><span class="o">=</span><span class="s">"testGroup"</span><span class="o">,</span><span class="n">jobName</span><span class="o">=</span><span class="s">"test1"</span><span class="o">,</span><span class="n">cron</span><span class="o">=</span><span class="s">"0/30 * * * * ?"</span><span class="o">)</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="nc">String</span><span class="nf">test1</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC3" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [testGroup#test1] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC4" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC5" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job test1"</span><span class="o">);</span></span><span id="LC6" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"job argument: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getJobParameter</span><span class="o">());</span></span><span id="LC7" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executing......"</span><span class="o">);</span></span><span id="LC8" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executed"</span><span class="o">);</span></span><span id="LC9" class="line"><span class="k">return</span><span class="s">"a=123"</span><span class="o">;</span></span><span id="LC10" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><blockquote><p>動態分片任務</p></blockquote><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">// 任務動態切分</span></span><span id="LC2" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"splitStage"</span><span class="o">)</span></span><span id="LC3" class="line"><span class="kd">public</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">ShardData</span><span class="o">&gt;</span><span class="nf">split</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC4" class="line"><span class="nc">ShardData</span><span class="n">shardData</span><span class="o">=</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">id</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">params</span><span class="o">(</span><span class="s">"hello"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span></span><span id="LC5" class="line"><span class="nc">ShardData</span><span class="n">shardData1</span><span class="o">=</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">id</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">params</span><span class="o">(</span><span class="s">"world"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span></span><span id="LC6" class="line"><span class="k">return</span><span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">shardData</span><span class="o">,</span><span class="n">shardData1</span><span class="o">);</span></span><span id="LC7" class="line"><span class="o">}</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">// 任務並行執行</span></span><span id="LC10" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"parallelJob"</span><span class="o">)</span></span><span id="LC11" class="line"><span class="kd">public</span><span class="nc">String</span><span class="nf">parallelJob</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC12" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [parallelJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC13" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC14" class="line"><span class="kd">final</span><span class="nc">ShardData</span><span class="n">parentJobData</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobData</span><span class="o">(</span><span class="nc">ShardData</span><span class="o">.</span><span class="na">class</span><span class="o">);</span></span><span id="LC15" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job parallelJob, parentJobData: {}"</span><span class="o">,</span><span class="n">parentJobData</span><span class="o">);</span></span><span id="LC16" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start executor job parallelJob, parentJobData: {}"</span><span class="o">,</span><span class="n">parentJobData</span><span class="o">);</span></span><span id="LC17" class="line"><span class="k">return</span><span class="s">"a=123"</span><span class="o">;</span></span><span id="LC18" class="line"><span class="o">}</span></span><span id="LC19" class="line"></span><span id="LC20" class="line"><span class="c1">// 任務彙總執行</span></span><span id="LC21" class="line"><span class="nd">@Job</span><span class="o">(</span><span class="n">command</span><span class="o">=</span><span class="s">"reduceJob2"</span><span class="o">)</span></span><span id="LC22" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">reduceJob</span><span class="o">(</span><span class="nc">JobExecutionContext</span><span class="n">context</span><span class="o">)</span><span class="o">{</span></span><span id="LC23" class="line"><span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC24" class="line"><span class="nc">JobLogger</span><span class="n">logger</span><span class="o">=</span><span class="n">context</span><span class="o">.</span><span class="na">getJobLogger</span><span class="o">();</span></span><span id="LC25" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"job argument: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getJobParameter</span><span class="o">());</span></span><span id="LC26" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"executed"</span><span class="o">);</span></span><span id="LC27" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, context: {}"</span><span class="o">,</span><span class="n">context</span><span class="o">);</span></span><span id="LC28" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, results {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobExecuteResults</span><span class="o">()</span></span><span id="LC29" class="line"><span class="o">);</span></span><span id="LC30" class="line"><span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Job [reduceJob] execute, statues {}"</span><span class="o">,</span><span class="n">context</span><span class="o">.</span><span class="na">getParentJobExecuteStatuses</span><span class="o">());</span></span><span id="LC31" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-xxljob 任務接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#xxljob%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>xxljob 任務接入 demo</h3><p>詳細 demo 代碼參考 <em>hodor-examples/hodor-actuator-xxljob-example</em> 模塊</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="cm">/**</span></span><span id="LC2" class="line"><span class="cm"> * 1、簡單任務示例（Bean 模式）</span></span><span id="LC3" class="line"><span class="cm"> */</span></span><span id="LC4" class="line"><span class="nd">@XxlJob</span><span class="o">(</span><span class="s">"demoJobHandler"</span><span class="o">)</span></span><span id="LC5" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">demoJobHandler</span><span class="o">()</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC6" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"XXL-JOB, Hello World."</span><span class="o">);</span></span><span id="LC7" class="line"></span><span id="LC8" class="line"><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"beat at:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span></span><span id="LC10" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC11" class="line"><span class="o">}</span></span><span id="LC12" class="line"><span class="c1">// default success</span></span><span id="LC13" class="line"><span class="o">}</span></span><span id="LC14" class="line"></span><span id="LC15" class="line"><span class="cm">/**</span></span><span id="LC16" class="line"><span class="cm"> * 2、分片廣播任務</span></span><span id="LC17" class="line"><span class="cm"> */</span></span><span id="LC18" class="line"><span class="nd">@XxlJob</span><span class="o">(</span><span class="s">"shardingJobHandler"</span><span class="o">)</span></span><span id="LC19" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">shardingJobHandler</span><span class="o">()</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC20" class="line"><span class="c1">// 分片參數</span></span><span id="LC21" class="line"><span class="kt">int</span><span class="n">shardIndex</span><span class="o">=</span><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">getShardIndex</span><span class="o">();</span></span><span id="LC22" class="line"><span class="kt">int</span><span class="n">shardTotal</span><span class="o">=</span><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">getShardTotal</span><span class="o">();</span></span><span id="LC23" class="line"></span><span id="LC24" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"分片參數：當前分片序號 = {}, 總分片數 = {}"</span><span class="o">,</span><span class="n">shardIndex</span><span class="o">,</span><span class="n">shardTotal</span><span class="o">);</span></span><span id="LC25" class="line"></span><span id="LC26" class="line"><span class="c1">// 業務邏輯</span></span><span id="LC27" class="line"><span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">shardTotal</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span><span class="o">{</span></span><span id="LC28" class="line"><span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="n">shardIndex</span><span class="o">)</span><span class="o">{</span></span><span id="LC29" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"第 {} 片, 命中分片開始處理"</span><span class="o">,</span><span class="n">i</span><span class="o">);</span></span><span id="LC30" class="line"><span class="o">}</span><span class="k">else</span><span class="o">{</span></span><span id="LC31" class="line"><span class="nc">XxlJobHelper</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="s">"第 {} 片, 忽略"</span><span class="o">,</span><span class="n">i</span><span class="o">);</span></span><span id="LC32" class="line"><span class="o">}</span></span><span id="LC33" class="line"><span class="o">}</span></span><span id="LC34" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-spring-task 任務接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#spring-task%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>spring task 任務接入 demo</h3><p>詳細 demo 代碼參考 <em>hodor-examples/hodor-actuator-springtask-example</em> 模塊</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedRate</span><span class="o">=</span><span class="mi">3000</span><span class="o">)</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task1</span><span class="o">()</span><span class="kd">throws</span><span class="nc">InterruptedException</span><span class="o">{</span></span><span id="LC3" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC4" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"執行 fixedRate 任務的時間："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC5" class="line"><span class="o">}</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">fixedDelay</span><span class="o">=</span><span class="mi">4000</span><span class="o">)</span></span><span id="LC8" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task2</span><span class="o">()</span><span class="kd">throws</span><span class="nc">InterruptedException</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></span><span id="LC10" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"執行 fixedDelay 任務的時間："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC11" class="line"><span class="o">}</span></span><span id="LC12" class="line"></span><span id="LC13" class="line"><span class="nd">@Scheduled</span><span class="o">(</span><span class="n">cron</span><span class="o">=</span><span class="s">"0/5 * * * * ?"</span><span class="o">)</span></span><span id="LC14" class="line"><span class="kd">public</span><span class="kt">void</span><span class="nf">task3</span><span class="o">()</span><span class="o">{</span></span><span id="LC15" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"執行 cron 任務的時間："</span><span class="o">+</span><span class="k">new</span><span class="nc">Date</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()));</span></span><span id="LC16" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-agent-方式任務接入 demo" class="anchor" href="https://gitee.com/dromara/hodor#agent-%E6%96%B9%E5%BC%8F%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5demo"></a>agent 方式任務接入 demo</h3><p>詳細參考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fiqrsqxh2i2qt5ixi">執行器操作指南</a> 中的 agent 方式的使用。</p><h2><a id="user-content-hodor 打包部署説明" class="anchor" href="https://gitee.com/dromara/hodor#hodor%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%AF%B4%E6%98%8E"></a>hodor 打包部署説明</h2><p>詳細參考 <a href="https://gitee.com/link?target=https%3A%2F%2Fwww.yuque.com%2Ftomgs%2Fhodor%2Fgiukp9y4plqb55ng">安裝部署操作指南</a></p><h2><a id="user-content-交流學習" class="anchor" href="https://gitee.com/dromara/hodor#%E4%BA%A4%E6%B5%81%E5%AD%A6%E4%B9%A0"></a>交流學習</h2><p>目前，Hodor 仍處於建設的過程中，團隊成員只能抽出空閒時間投入其中，主要精力還是放在日常工作中。
如果有興趣的同學想要參與 Hodor 的實現或者一起學習，歡迎通過微信聯繫我們，我們非常歡迎新的成員加入！</p><p>Hodor 的未來發展方向包括以下幾個方面：</p><ol><li>前端界面和控制枱開發，為用戶提供更加友好、直觀的任務管理界面。</li><li>執行器開發工作，包括執行編程框架和大數據任務執行器的優化，以提高系統的性能和穩定性。</li><li>通信協議改造，計劃將目前自定義的協議改造為 grpc 的方式，以提高系統的可擴展性和兼容性。</li><li>優化 CopySet 算法的實現，以支持機架感知，更好地分配任務副本。</li><li>開發多語言執行器，主要放在 go 和 rust 語言，以滿足用戶不同的需求和偏好。</li></ol><p>Wechat：(備註：Hodor)</p><p><img src="https://gitee.com/dromara/hodor/raw/master/docs/assets/img/wechat.png" alt="image-20220529141555032" referrerpolicy="no-referrer"></p>]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:59:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/dromara/hodor</guid>
            <link>https://gitee.com/dromara/hodor</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | Dubbo 路由及負載均衡性能優化]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="font-size: 15px;"><section style="text-align: right;margin-top: 10px;margin-bottom: -25px;" powered-by="xiumi.us"><section style="display: inline-block;width: 35px;height: 35px;vertical-align: top;overflow: hidden;border-width: 1px;border-radius: 100%;border-style: solid;border-color: transparent;background-color: rgb(255, 255, 255);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section><section style="text-align: center;font-size: 14px;" powered-by="xiumi.us"><p><span style="color: rgb(0, 82, 255);"><span style="color: rgb(0, 82, 255);letter-spacing: 0.578px;text-align: center;text-wrap: wrap;font-size: 14px;">揭祕 vivo 互聯網海量服務的研發之路&nbsp;</span><span style="color: rgb(0, 82, 255);text-align: center;text-wrap: wrap;font-size: 14px;letter-spacing: 0.034em;">報名中👇</span></span></p></section><section style="text-align: center;margin-top: 0.5em;margin-bottom: 0.5em;padding-left: 0.5em;padding-right: 0.5em;" powered-by="xiumi.us"><section style="border-width: 5px;border-style: solid;border-color: rgb(255, 255, 255);display: inline-block;line-height: 0;box-shadow: rgb(102, 102, 102) 0.2em 0.2em 0.5em;width: 70%;height: auto;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D2%26sn%3D949ce368a94c5950749a74fec56b98fb%26chksm%3Debdb8632dcac0f24fbac44050c9605d521f9728517b311f54639e1ab3bc0422ce95391b09636%26scene%3D21%23wechat_redirect" textvalue="你已選中了添加鏈接的內容" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="1"><span class="js_jump_icon h5_image_link"><img class="rich_pages wxw-img" data-cropselx1="0" data-cropselx2="384" data-cropsely1="0" data-cropsely2="384" data-ratio="0.21944444444444444" data-s="300,640" src="https://oscimg.oschina.net/oscnet/92614968-2ae5-4624-9416-5e3659137ef6.png" data-type="jpeg" data-w="1080" style="vertical-align: middle;width: 578px;height: 127px;" referrerpolicy="no-referrer"></span></a></section><span style="font-size: 14px;letter-spacing: 0.034em;text-align: justify;"></span></section></section><section style="font-size: 15px;line-height: 1.6;"><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">作者：vivo 互聯網中間件團隊- Wang Xiaochuang</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: left;" powered-by="xiumi.us"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;color: rgb(160, 160, 160);"><p style="text-wrap: wrap;">本文主要介紹在 vivo 內部針對 Dubbo 路由模塊及負載均衡的一些優化手段，主要是異步化+緩存，可減少在 RPC 調用過程中路由及負載均衡的 CPU 消耗，極大提升調用效率。</p></section></section><section style="margin-right: 0%;margin-bottom: -5px;margin-left: 0%;text-align: right;line-height: 1;font-size: 5px;transform: translate3d(5px, 0px, 0px);" powered-by="xiumi.us"><section style="width: 0px;display: inline-block;vertical-align: top;border-bottom: 0.6em solid rgb(160, 160, 160);border-right: 0.6em solid rgb(160, 160, 160);border-top: 0.6em solid transparent !important;border-left: 0.6em solid transparent !important;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>一、概要</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">vivo 內部 Java 技術棧業務使用的是 Apache Dubbo 框架，基於開源社區 2.7.x 版本定製化開發。在海量微服務集羣的業務實踐中，我們發現 Dubbo 有一些性能瓶頸的問題會極大影響業務邏輯的執行效率，尤其是在集羣規模數量較大時 (提供方數量&gt;100)，路由及負載均衡方面有着較大的 CPU 消耗，從採集的火焰圖分析高達 30%。為此我們針對 vivo 內部常用路由策略及負載均衡進行相關優化，並取得了較好的效果。接下來主要跟大家分析一下相關問題產生的根源，以及我們採用怎樣的方式來解決這些問題。（當前 vivo 內部使用的 Dubbo 的主流版本是基於 2.7.x 進行相關定製化開發。）</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>二、背景知識</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.1 Dubbo 客戶端調用流程</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1.&nbsp;相關術語介紹</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.35069075451647186" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bac7b7d2-f9db-4eb0-9f3d-5900e79ab3fe.png" data-type="png" data-w="941" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;主要流程</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">客戶端通過本地代理 Proxy 調用 ClusterInvoker，ClusterInvoker 從服務目錄 Directory 獲取服務列表後經過路由鏈獲取新的服務列表、負載均衡從路由後的服務列表中根據不同的負載均衡策略選取一個遠端 Invoker 後再發起遠程 RPC 調用。</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.562962962962963" data-s="300,640" src="https://oscimg.oschina.net/oscnet/c2e7d8db-665a-4a4f-b704-246b9544a375.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.2 Dubbo 路由機制</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Dubbo 的路由機制實際是基於簡單的責任鏈模式實現，同時 Router 繼承了 Comparable 接口，自定義的路由可以設置不同的優先級進而定製化責任鏈上 Router 的順序。基於責任鏈模式可以支持多種路由策略串行執行如就近路由+標籤路由，或條件路由+就近路由等，且路由的配置支持基於接口級的配置也支持基於應用級的配置。常見的路由方式主要有：就近路由，條件路由，標籤路由等。具體的執行過程如下圖所示：</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.0143112701252237" data-s="300,640" src="https://oscimg.oschina.net/oscnet/de6310ef-9be0-491d-8451-14b01a37e125.png" data-type="png" data-w="559" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 核心類</strong></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">Dubbo 路由的核心類主要有：<strong>RouterChain、RouterFactory 與 Router 。</strong></p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">（1）RouterChain</p><p style="text-wrap: wrap;">RouterChain 是路由鏈的入口，其核心字段有<br></p></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: right;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: transparent;padding: 10px;background-color: rgb(239, 239, 239);height: auto;"><section style="text-align: justify;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><strong>invokers（List&lt;invoker&gt; 類型）</strong></p><p>初始服務列表由服務目錄 Directory 設置，當前 RouterChain 要過濾的 Invoker 集合<br></p></li><li><p><strong>builtinRouters（List 類型）</strong></p><p>當前 RouterChain 包含的自動激活的 Router 集合<br></p></li><li><p><strong>routers（List 類型）</strong></p><p>包括所有要使用的路由由 builtinRouters 加上通過 addRouters() 方法添加的 Router 對象</p></li></ul></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">RouterChain 核心邏輯</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">class</span><span class="code-snippet__title">RouterChain</span>&lt;<span class="code-snippet__title">T</span>&gt; </span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 註冊中心最後一次推送的服務列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers = Collections.emptyList();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 所有路由,包括原生 Dubbo 基於註冊中心的路由規則如「route://」 urls .</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> volatile <span class="code-snippet__keyword">List</span>&lt;Router&gt; routers = Collections.emptyList();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 初始化自動激活的路由</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span><span class="code-snippet__keyword">List</span>&lt;Router&gt; builtinRouters = Collections.emptyList();</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> RouterChain(URL url) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//通過 ExtensionLoader 加載可自動激活的 RouterFactory</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;RouterFactory&gt; extensionFactories = ExtensionLoader.getExtensionLoader(RouterFactory.class)</span></code><code><span class="code-snippet_outer">                .getActivateExtension(url, ROUTER_KEY);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 由工廠類生成自動激活的路由策略</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Router&gt; routers = extensionFactories.stream()</span></code><code><span class="code-snippet_outer">                .map(factory -&gt; factory.getRouter(url))</span></code><code><span class="code-snippet_outer">                .collect(Collectors.toList());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        initWithRouters(routers);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 添加額外路由</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> void addRouters(<span class="code-snippet__keyword">List</span>&lt;Router&gt; routers) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Router&gt; newRouters = <span class="code-snippet__keyword">new</span> ArrayList&lt;&gt;();</span></code><code><span class="code-snippet_outer">        newRouters.addAll(builtinRouters);</span></code><code><span class="code-snippet_outer">        newRouters.addAll(routers);</span></code><code><span class="code-snippet_outer">        Collections.sort(newRouters, comparator);</span></code><code><span class="code-snippet_outer">        this.routers = newRouters;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; route(URL url, Invocation invocation) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; finalInvokers = invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 遍歷全部的 Router 對象，執行路由規則</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (Router router : routers) {</span></code><code><span class="code-snippet_outer">            finalInvokers = router.route(finalInvokers, url, invocation);</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> finalInvokers;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）RouterFactory 為 Router 的工廠類</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">RouterFactory 接口定義</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@SPI</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">RouterFactory</span></span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Adaptive</span>(<span class="code-snippet__string">"protocol"</span>)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__function">Router <span class="code-snippet__title">getRouter</span><span class="code-snippet__params">(URL url)</span></span>;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（3）Router</p><p style="text-wrap: wrap;" powered-by="xiumi.us">Router 是真正的路由實現策略，由 RouterChain 進行調用，同時 Router 繼承了 Compareable 接口，可以根據業務邏輯設置不同的優先級。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">Router 主要接口定義</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="php"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">Router</span><span class="code-snippet__keyword">extends</span><span class="code-snippet__title">Comparable</span>&lt;<span class="code-snippet__title">Router</span>&gt; </span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     *</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers   帶過濾實例列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> url        消費方 url</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invocation 會話信息</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span> routed invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@throws</span> RpcException</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer">    &lt;T&gt; <span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; route(<span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 當註冊中心的服務列表發現變化，或有動態配置變更會觸發實例信息的變化</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 當時 2.7.x 的 Dubbo 並沒有真正使用這個方法，可基於此方法進行路由緩存</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers invoker list</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;      invoker's type</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">default</span> &lt;T&gt; void notify(<span class="code-snippet__keyword">List</span>&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;同機房優先路由的實現</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="letter-spacing: 0.034em;">為方便大家瞭解路由的實現，給大家展示一下就近路由的核心代碼邏輯</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL consumerUrl, Invocation invocation) throws RpcException {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (!<span class="code-snippet__keyword">this</span>.enabled) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 獲取本地機房信息</span></span></code><code><span class="code-snippet_outer">        String local = getSystemProperty(LOC);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers == <span class="code-snippet__literal">null</span> || invokers.size() == <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">        List&lt;Invoker&lt;T&gt;&gt; result = new ArrayList&lt;Invoker&lt;T&gt;&gt;();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (Invoker invoker: invokers) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 獲取與本地機房一致的 invoker 並加入列表中</span></span></code><code><span class="code-snippet_outer">            String invokerLoc = getProperty(invoker, invocation, LOC);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (local.equals(invokerLoc)) {</span></code><code><span class="code-snippet_outer">                result.add(invoker);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (result.size() &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (fallback){</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 開啓服務降級，available.ratio = 當前機房可用服務節點數量 ／ 集羣可用服務節點數量</span></span></code><code><span class="code-snippet_outer">                int curAvailableRatio = (int) Math.floor(result.size() * <span class="code-snippet__number">100.0</span>d / invokers.size());</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (curAvailableRatio &lt;= availableRatio) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (force) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">2.3 Dubbo 負載均衡</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">Dubbo 的負載均衡實現比較簡單基本都是繼承抽象類進行實現，主要作用就是根據具體的策略在路由之後的服務列表中篩選一個實例進行遠程 RPC 調用，默認的負載均衡策略是隨機。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">整體類圖如下所示：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.2824074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/22c30ee5-d60d-45b1-a737-bbf064f7c1cc.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">LoadBalance 接口定義</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@SPI</span>(RandomLoadBalance.NAME)</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span><span class="code-snippet__class"><span class="code-snippet__keyword">interface</span><span class="code-snippet__title">LoadBalance</span></span>{</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 從服務列表中篩選一個.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     *</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers   invokers.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> url        refer url</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invocation invocation.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span> selected invoker.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Adaptive</span>(<span class="code-snippet__string">"loadbalance"</span>)</span></code><code><span class="code-snippet_outer">    &lt;T&gt; <span class="code-snippet__function">Invoker&lt;T&gt; <span class="code-snippet__title">select</span><span class="code-snippet__params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span><span class="code-snippet__keyword">throws</span> RpcException</span>;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">隨機負載均衡核心代碼解析</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 預熱過程權重計算</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">static</span><span class="code-snippet__keyword">int</span><span class="code-snippet__title">calculateWarmupWeight</span>(<span class="code-snippet__params"><span class="code-snippet__keyword">int</span> uptime, <span class="code-snippet__keyword">int</span> warmup, <span class="code-snippet__keyword">int</span> weight</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> ww = (<span class="code-snippet__keyword">int</span>) (uptime / ((<span class="code-snippet__keyword">float</span>) warmup / weight));</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> ww &lt; <span class="code-snippet__number">1</span> ? <span class="code-snippet__number">1</span> : (Math.min(ww, weight));</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">int</span><span class="code-snippet__title">getWeight</span>(<span class="code-snippet__params">Invoker&lt;?&gt; invoker, Invocation invocation</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> weight;</span></code><code><span class="code-snippet_outer">       URL url = invoker.getUrl();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 多註冊中心場景下的，註冊中心權重獲取</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">           weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">       } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer">           weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (weight &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 獲取實例啓動時間</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">long</span> timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, <span class="code-snippet__number">0L</span>);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (timestamp &gt; <span class="code-snippet__number">0L</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">long</span> uptime = System.currentTimeMillis() - timestamp;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (uptime &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span><span class="code-snippet__number">1</span>;</span></code><code><span class="code-snippet_outer">                   }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 獲取預熱時間</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (uptime &gt; <span class="code-snippet__number">0</span> &amp;&amp; uptime &lt; warmup) {</span></code><code><span class="code-snippet_outer">                       weight = calculateWarmupWeight((<span class="code-snippet__keyword">int</span>)uptime, warmup, weight);</span></code><code><span class="code-snippet_outer">                   }</span></code><code><span class="code-snippet_outer">               }</span></code><code><span class="code-snippet_outer">           }</span></code><code><span class="code-snippet_outer">       }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> Math.max(weight, <span class="code-snippet__number">0</span>);</span></code><code><span class="code-snippet_outer">   }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">@Override</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">protected</span> &lt;T&gt; <span class="code-snippet__function">Invoker&lt;T&gt; <span class="code-snippet__title">doSelect</span>(<span class="code-snippet__params">List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Number of invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> length = invokers.size();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Every invoker has the same weight?</span></span></code><code><span class="code-snippet_outer">        boolean sameWeight = <span class="code-snippet__literal">true</span>;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// the weight of every invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span>[] weights = <span class="code-snippet__keyword">new</span><span class="code-snippet__keyword">int</span>[length];</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// the first invoker's weight</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> firstWeight = getWeight(invokers.<span class="code-snippet__keyword">get</span>(<span class="code-snippet__number">0</span>), invocation);</span></code><code><span class="code-snippet_outer">        weights[<span class="code-snippet__number">0</span>] = firstWeight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// The sum of weights</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> totalWeight = firstWeight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = <span class="code-snippet__number">1</span>; i &lt; length; i++) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> weight = getWeight(invokers.<span class="code-snippet__keyword">get</span>(i), invocation);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// save for later use</span></span></code><code><span class="code-snippet_outer">            weights[i] = weight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Sum</span></span></code><code><span class="code-snippet_outer">            totalWeight += weight;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) {</span></code><code><span class="code-snippet_outer">                sameWeight = <span class="code-snippet__literal">false</span>;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (totalWeight &gt; <span class="code-snippet__number">0</span> &amp;&amp; !sameWeight) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on totalWeight.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// Return a invoker based on the random value.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = <span class="code-snippet__number">0</span>; i &lt; length; i++) {</span></code><code><span class="code-snippet_outer">                offset -= weights[i];</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (offset &lt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers.<span class="code-snippet__keyword">get</span>(i);</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers.<span class="code-snippet__keyword">get</span>(ThreadLocalRandom.current().nextInt(length));</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>預熱解釋</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">預熱是為了讓剛啓動的實例流量緩慢增加,因為實例剛啓動時各種資源可能還沒建立連接，相關代碼可能還是處於解釋執行，仍未變為 JIT 執行，此時業務邏輯較慢，不應該加載過大的流量，否則有可能造成較多的超時。Dubbo 默認預熱時間為 10 分鐘，新部署的實例的流量會在預熱時間段內層線性增長，最終與其他實例保持一致。Dubbo 預熱機制的實現就是通過控制權重來實現。如默認權重 100，預熱時間 10 分鐘，則第一分鐘權重為 10，第二分鐘為 20，以此類推。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">具體預熱效果圖如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.45765765765765765" data-s="300,640" src="https://oscimg.oschina.net/oscnet/752bc3b5-e121-4de3-b41b-022860b2700e.png" data-type="png" data-w="555" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>三、問題分析</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">使用 Dubbo 的業務方反饋，他們通過火焰圖分析發現 Dubbo 的負載均衡模塊+路由模塊佔用 CPU 超過了 30%，框架層面的使用率嚴重影響了業務邏輯的執行效率急需進行優化。通過火焰圖分析，具體佔比如下圖，其中該機器在業務忙時的 CPU 使用率在 60% 左右，閒時在 30% 左右。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.30970873786407765" data-s="300,640" src="https://oscimg.oschina.net/oscnet/81ae8f99-a18c-4416-8f9a-b6c012a14476.png" data-type="png" data-w="1030" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通過火焰圖分析，負載均衡主要的消耗是在 getWeight 方法。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.1388888888888889" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b1d57058-f760-43c5-83bc-166c07ca9d81.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">路由的主要消耗是在 route 方法：</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">同機房優先路由</p><p style="text-wrap: wrap;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.11296296296296296" data-s="300,640" src="https://oscimg.oschina.net/oscnet/fee26d17-6eb3-4103-b12d-cc8975696932.png" data-type="png" data-w="1080" style="font-size: 15px;letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" referrerpolicy="no-referrer"></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">接口級標籤路由+應用級標籤路由</p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.14907407407407408" data-s="300,640" src="https://oscimg.oschina.net/oscnet/11c33b76-0ae1-45fe-aeef-a05793340801.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">這些方法都有一個特點，那就是遍歷執行。如負載均衡，針對每一個 invoker 都需要通過 getWeight 方法進行權重的計算；就近路由的 router 方法對於每一個 invoker 都需要通過 url 獲取及機房信息進行匹配計算。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">我們分析一下 getWeight 及 router 時間複雜度，發現是 O(n) 的時間複雜度，而且路由是由路由鏈組成的，每次每個 Router 的 route 方法調用邏輯都會遍歷實例列表，那麼當實例列表數量過大時，每次匹配的計算的邏輯過大，那麼就會造成大量的計算成本，導致佔用大量 cpu，同時也導致路由負載均衡效率低下。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">綜上所述，罪惡的的根源就是遍歷導致的，當服務提供方數量越多，影響越大。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>四、優化方案</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">知道了問題所在，我們來分析一下是否有優化空間。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.1 路由優化</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1. 優化一：關閉無效路由</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">通過火焰圖分析，我們發現有部分業務即使完全不使用應用級的標籤路由，原生的 TagRouter 也存在遍歷邏輯，原因是為了支持靜態的標籤路由，其實這部分的開銷也不少，那對於根本不會使用應用級標籤路由的可以手動進行關閉。關閉方式如下：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">客戶端統一關閉<br></p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js"><code><span class="code-snippet_outer">dubbo.consumer.router=-tag</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">服務級別關閉</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">註解方式：</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__meta">@DubboReference(parameters = {<span class="code-snippet__meta-string">"router"</span>,<span class="code-snippet__meta-string">"-tag"</span>})</span></span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">xml 方式：</p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer">&lt;dubbo:reference id=<span class="code-snippet__string">"demoService"</span> check=<span class="code-snippet__string">"false"</span><span class="code-snippet__keyword">interface</span>=<span class="code-snippet__string">"com.dubbo.study.n.api.DemoService"</span> router=<span class="code-snippet__string">"-tag"</span> /&gt;</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2. 優化二：提前計算路由結果並進行緩存</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">每次路由目前都是進行實時計算，但是在大多數情況下，我們的實例列表是穩定不變的，只有在發佈窗口或配置變更窗口內實例列表才會發生變更，那我們是否可以考慮緩存呢。如就近路由，可以以機房為 key 進行機房實例的全量緩存。針對接口級標籤路由可以緩存不同標籤值指定的實例信息。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">我們知道路由的執行過程是責任鏈模式，每一個 Router 的實例列表入參實際上是一個 Router 的結果，可參考公式：target = rn(…r3(r2(r1(src))))。那麼所有的路由可以基於註冊中心推送的原始服務列表進行路由計算並緩存，然後不同的路由結果相互取交集就能得到最終的結果，當實例信息發生變更時，緩存失效並重新計算。</p></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>3. 緩存更新時機</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">當註冊中心或者動態配置有變更時，相關通知會給到服務目錄 Directory,Directory 收到通知後會重新創建服務列表，並把服務列表同步到路由鏈 RouterChain，RouterChain 再按順序通知其鏈上的 Router,各個 Router 再進行緩存清除並重新進行路由結果的計算及進行緩存。相關時序圖如下所示：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.42962962962962964" data-s="300,640" src="https://oscimg.oschina.net/oscnet/e8b71fb8-8926-40de-abe8-147ba10fa2ea.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>4. 具體路由流程</strong></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">進入具體路由方法時，先判斷是否存在緩存的路由值，且緩存值的 epoch 必須與上一個路由的 epoch 需一致，此時緩存才生效，然後緩存值與上個 Router 的結果取交集。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">如果不存在緩存或 epoch 不一致則重新進行實時的路由計算。</p><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.7803921568627451" data-s="300,640" src="https://oscimg.oschina.net/oscnet/024bfb79-3f68-4ca5-bf7f-bfd337d6c3d0.jpg" data-type="jpeg" data-w="1020" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us">引入 epoch 的原因主要是保證各個路由策略緩存信息的一致性，保證所有的緩存計算都是基於同一份原始數據。當實例信息發生變更時，epoch 會自動進行更新。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>5. BitMap 引入</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">上文我們説到，不同的路由策略之間的結果是取交集的，然後最終的結果才送入負載均衡流程。那如何在緩存的同時，加快交集的計算呢。答案就是基於位圖：BitMap。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">BitMap 的基本原理就是用一個 bit 位來存放某種狀態，適用於大規模數據的查找及位運算操作。如在路由場景，先基於全量的推送數據進行計算緩存。如果某個實例被路由選中，則其值為 1，若兩個路由的結果要取交集，那直接對 BitMap 進行"&amp;"運行即可。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">全量緩存示意圖：</p><p style="text-wrap: wrap;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.4935185185185185" data-s="300,640" src="https://oscimg.oschina.net/oscnet/5fc6e016-b880-40ce-9d59-390fe111bfa8.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;"><br></p></section><p style="text-wrap: wrap;" powered-by="xiumi.us">路由交集計算示步驟：</p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">按照路由鏈依次計算，</p><p style="text-wrap: wrap;">tagRouter-&gt;vivoTag-&gt;vivoNearestRouter</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">（1）tagRouter 計算邏輯：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>按照 Invocation 計算出目標的 Tag,假設是 tag1</p></li><li><p>然後從緩存 Cache 根據 key:tag1,取出對應的 targetAddrPool</p></li><li><p>將原始傳入的 addrPool</p><p>與 targetAddrPool</p><p>得到結果 resultAddrPool</p></li><li><p>將 resultAddrPool 傳入 vivoTagRouter</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">（2）vivoTag 計算邏輯：</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>按照 Invocation 計算出目標的 Tag,假設是 tabB</p></li><li><p>然後從緩存 Cache 根據 key:tag1，取出對應的 targetAddrPool</p></li><li><p>將上一次傳入的 addrPool</p><p>與 targetAddrPool</p><p>得到結果 resultAddrPooll</p></li><li><p>將 resultAddrPool 傳入</p><p>vivoNearestRouter</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us">（3）vivoNearestRouter 計算邏輯</p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(160, 160, 160);padding: 10px;"><section style="text-align: justify;line-height: 1.8;padding-right: 5px;padding-left: 5px;" powered-by="xiumi.us"><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p>從環境變量取出當前機房，假設是 bj01</p></li><li><p>然後從緩存 Cache 根據 key:bj01，取出對應的 targetAddrPool</p></li><li><p>將上一次傳入的 addrPool</p><p>與 targetAddrPool</p><p>取出 resultAddrPool</p></li><li><p>將上一次傳入的 addrPool</p><p>與 targetAddrPool</p><p>得到結果 resultAddrPool</p></li><li><p>將 resultAddrPool 為最終路由結果，傳遞給 LoadBalance</p></li></ol></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.6907407407407408" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bfad5e5c-e485-4ab8-8b25-208b5ca92c3d.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>6. 基於緩存的同機房優先路由源碼解析</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">緩存刷新</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * Notify router chain of the initial addresses from registry at the first time.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * Notify whenever addresses in registry change.</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__function"><span class="code-snippet__keyword">public</span><span class="code-snippet__keyword">void</span><span class="code-snippet__title">setInvokers</span>(<span class="code-snippet__params">List&lt;Invoker&lt;T&gt;&gt; invokers</span>)</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 創建帶 epoch 的 BitList</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">this</span>.invokers = <span class="code-snippet__keyword">new</span> BitList&lt;Invoker&lt;T&gt;&gt;(invokers == <span class="code-snippet__literal">null</span> ? Collections.emptyList() : invokers,createBitListEpoch());</span></code><code><span class="code-snippet_outer">        routers.forEach(router -&gt; router.notify(<span class="code-snippet__keyword">this</span>.invokers));</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">同機房優先路由源碼解讀</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL consumerUrl, Invocation invocation) throws RpcException {</span></code><code><span class="code-snippet_outer">        …………<span class="code-snippet__comment">//省略非核心代碼</span></span></code><code><span class="code-snippet_outer">        BitList&lt;Invoker&lt;T&gt;&gt; bitList = (BitList&lt;Invoker&lt;T&gt;&gt;) invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//獲取路由結果</span></span></code><code><span class="code-snippet_outer">        BitList&lt;Invoker&lt;T&gt;&gt; result = getNearestInvokersWithCache(bitList);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (result.size() &gt; <span class="code-snippet__number">0</span>) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (fallback) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 開啓服務降級，available.ratio = 當前機房可用服務節點數量 ／ 集羣可用服務節點數量</span></span></code><code><span class="code-snippet_outer">                int curAvailableRatio = (int) Math.floor(result.size() * <span class="code-snippet__number">100.0</span>d / invokers.size());</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (curAvailableRatio &lt;= availableRatio) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">                }</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span><span class="code-snippet__keyword">if</span> (force) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">        } <span class="code-snippet__keyword">else</span> {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> invokers;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }   </span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 獲取緩存列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span></span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">private</span> &lt;T&gt; BitList&lt;Invoker&lt;T&gt;&gt; getNearestInvokersWithCache(BitList&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer">        ValueWrapper valueWrapper = getCache(getSystemProperty(LOC));</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 是否存在緩存</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (valueWrapper != <span class="code-snippet__literal">null</span>) {</span></code><code><span class="code-snippet_outer">            BitList&lt;Invoker&lt;T&gt;&gt; invokerBitList = (BitList&lt;Invoker&lt;T&gt;&gt;) valueWrapper.<span class="code-snippet__keyword">get</span>();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 緩存的 epoch 與源列表是否一致</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers.isSameEpoch(invokerBitList)) {</span></code><code><span class="code-snippet_outer">                BitList&lt;Invoker&lt;T&gt;&gt; tmp = invokers.clone();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 結果取交集</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> tmp.and(invokerBitList);</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 緩存不存在，實時計算放回</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> getNearestInvokers(invokers);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * 新服務列表通知</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__meta">@Override</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; void notify(List&lt;Invoker&lt;T&gt;&gt; invokers) {</span></code><code><span class="code-snippet_outer">        clear();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invokers != <span class="code-snippet__literal">null</span> &amp;&amp; invokers instanceof BitList) {</span></code><code><span class="code-snippet_outer">            BitList&lt;Invoker&lt;T&gt;&gt; bitList = (BitList&lt;Invoker&lt;T&gt;&gt;) invokers;</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 設置最後一次更新的服務列表</span></span></code><code><span class="code-snippet_outer">            lastNotify = bitList.clone();</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (!CollectionUtils.isEmpty(invokers) &amp;&amp; <span class="code-snippet__keyword">this</span>.enabled) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">// 獲取機房相同的服務列表並進行緩存</span></span></code><code><span class="code-snippet_outer">                setCache(getSystemProperty(LOC), getNearestInvokers(lastNotify));</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><span style="font-size: 16px;color: rgb(65, 95, 255);">4.2 負載均衡優化</span></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>1.&nbsp;優化一</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong><br></strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us">針對 getWeight 方法，我們發現有部分業務邏輯較為消耗 cpu,但是在大多數場景下業務方並不會使用到，於是進行優化。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">getWeight 方法優化</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="javascript"><code><span class="code-snippet_outer">優化前：</span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">//這裏主要要用多註冊中心場景下，註冊中心權重的獲取，絕大多數情況下並不會有這個邏輯</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">           weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">       }  </span></code><code><span class="code-snippet_outer">優化後：</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">if</span> (invoker <span class="code-snippet__keyword">instanceof</span> ClusterInvoker &amp;&amp; UrlUtils.isRegistryService(url)) {</span></code><code><span class="code-snippet_outer">            weight = url.getParameter(REGISTRY_KEY + <span class="code-snippet__string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span></code><code><span class="code-snippet_outer">   }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><strong>2.&nbsp;優化二</strong></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section powered-by="xiumi.us"><p style="text-wrap: wrap;">遍歷是罪惡的源泉，而實例的數量決定這罪惡的深淺，我們有什麼辦法減少負載均衡過程中的遍歷呢。一是根據 group 及 version 劃分不同的集羣，但是這需要涉及到業務方代碼或配置層面的改動，會帶來額外的成本。所以我們放棄了。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">二是沒有什麼是加一層解決不了的問題，為了儘量減少進入負載均衡的節點數量，考慮新增一個墊底的路由策略，在走完所有的路由策略後，若節點數量&gt;自定義數量後，進行虛擬分組，虛擬分組的策略也可進行自定義，然後隨機篩選一組進入負載均衡。此時進入負載均衡的實例數量就會有倍數的下降。</p><p style="text-wrap: wrap;"><br></p><p style="text-wrap: wrap;">需要注意的是分組路由必須保證是在路由鏈的最後一環，否則會導致其他路由計算錯誤。</p></section><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="1.37984496124031" data-s="300,640" src="https://oscimg.oschina.net/oscnet/9ad0f113-9f91-4397-9e60-71b4b03e349f.png" data-type="png" data-w="645" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">分組路由示意</p></section></section></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer"><span class="code-snippet__comment">/**</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * </span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> invokers 待分組實例列表</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> groupNum 分組數量</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@param</span> &lt;T&gt;</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     * <span class="code-snippet__doctag">@return</span></span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__comment">     */</span></span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; doGroup(List&lt;Invoker&lt;T&gt;&gt; invokers, <span class="code-snippet__keyword">int</span> groupNum) {</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> listLength = invokers.size() / groupNum;</span></code><code><span class="code-snippet_outer">        List&lt;Invoker&lt;T&gt;&gt; result = <span class="code-snippet__keyword">new</span> ArrayList&lt;&gt;(listLength);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">int</span> random = ThreadLocalRandom.current().nextInt(groupNum);</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">for</span> (<span class="code-snippet__keyword">int</span> i = random; i &lt; invokers.size(); i = i + groupNum) {</span></code><code><span class="code-snippet_outer">            result.add(invokers.get(i));</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><span class="code-snippet__keyword">return</span> result;</span></code><code><span class="code-snippet_outer">    }</span></code></pre></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>五、優化效果</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">針對優化前和優化後，我們編寫 Demo 工程分別壓測了不配置路由/配置就近+標籤路由場景。Provider 節點梯度設置 100/500/1000/2000/5000，TPS 在 1000 左右，記錄了主機的 cpu 等性能指標，並打印火焰圖。發現，配置路由後，採用相同併發，優化後的版本 tps 明顯高於優化前版本，且新版本相較於沒有配置路由時 tps 顯著提高，下游節點數大於 2000 時，tps 提升達到 100% 以上，下游節點數越多，AvgCpu 優化效果越明顯，並且路由及負載均衡 CPU 佔比明顯更低，詳細數據可見下表：</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.5994694960212201" data-s="300,640" src="https://oscimg.oschina.net/oscnet/1321713f-e488-4248-8ead-3e1db6f52543.png" data-type="png" data-w="754" style="" referrerpolicy="no-referrer"></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img js_insertlocalimg" data-ratio="0.7027777777777777" data-s="300,640" src="https://oscimg.oschina.net/oscnet/be116887-8e9c-4e6f-ba48-b83efffe2464.png" data-type="png" data-w="1080" style="" referrerpolicy="no-referrer"></p><section style="margin: 10px 0% 8px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding-left: 8px;align-self: flex-start;flex: 0 0 auto;"><section style="color: rgba(0, 0, 0, 0.5);font-size: 14px;text-align: justify;" powered-by="xiumi.us"><p style="text-wrap: wrap;">備註：-tag，表示顯式禁用原生 Dubbo 應用級標籤路由。該路由默認開啓。</p></section></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-top: 10px;margin-bottom: 10px;text-align: center;" powered-by="xiumi.us"><section style="padding: 3px;display: inline-block;border-bottom: 1px solid rgb(65, 94, 255);font-size: 17px;color: rgb(65, 94, 255);"><p>六、總結</p></section></section><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us">經過我們關閉不必要的路由邏輯、對路由緩存+異步化計算、新增分組路由等優化後，Dubbo 在負載均衡及路由模塊整體的性能有了顯著的提升，為業務方節省了不少 CPU 資源。在正常業務場景下當提供方數量達到 2000 及以上時，tps 提升可達 100% 以上，消費方平均 CPU 使用率下降約 27%，且提供方數量越多優化效果越明顯。但是我們也發現當前的隨機負載均衡依然還是會消耗一定的 CPU 資源，且只能保證流量是均衡的。當前我們的應用基本部署在虛擬機及容器上。這兩者均存在超賣的狀況，且同等配置的宿主機性能存在較大差異等問題。最終會導致部分請求超時、無法最大化利用提供方的資源。我們下一步將會引入 Dubbo 3.2 的自適應負載均衡並進行調優減少其 CPU 使用率波動較大的問題，其次我們自身也擴展了基於 CPU 負載均衡的單一因子算法，最終實現不同性能的機器 CPU 負載趨於均衡，最大程度發揮集羣整體的性能。</p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="color: rgb(65, 95, 255);" powered-by="xiumi.us"><p style="text-wrap: wrap;">參考資料：</p></section><ol class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;" powered-by="xiumi.us"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Fload-balance%2F" textvalue="Dubbo 負載均衡" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 負載均衡</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Ftraffic%2F" textvalue="Dubbo 流量管控" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 流量管控</span></a><span style="font-size: 14px;"></span></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU4NzU0MDIzOQ%3D%3D%26mid%3D2247511003%26idx%3D3%26sn%3Defdf3f42790b74226b2ed45b701a6749%26scene%3D21%23wechat_redirect" textvalue="Dubbo 3 StateRouter：下一代微服務高效流量路由" linktype="text" imgurl="" tab="outerlink" data-linktype="2"><span style="font-size: 14px;">Dubbo 3 StateRouter：下一代微服務高效流量路由</span></a></p></li></ol><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><p style="text-wrap: wrap;" powered-by="xiumi.us"><br></p><section style="margin-right: 0%;margin-bottom: 20px;margin-left: 0%;justify-content: flex-start;display: flex;flex-flow: row;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section><section style="display: inline-block;vertical-align: middle;width: 20%;align-self: center;flex: 0 0 auto;"><section style="text-align: center;color: rgb(45, 66, 87);font-size: 11px;" powered-by="xiumi.us"><p>END</p></section></section><section style="display: inline-block;vertical-align: middle;width: 40%;align-self: center;flex: 0 0 auto;"><section style="margin-top: 0.5em;margin-bottom: 0.5em;" powered-by="xiumi.us"><section style="border-top: 1px dotted rgb(90, 98, 114);"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;text-align: left;" powered-by="xiumi.us"><section style="padding-left: 1em;padding-right: 1em;display: inline-block;text-align: center;"><span style="display: inline-block;padding: 0.3em 0.5em;border-radius: 0.5em;background-color: rgb(65, 94, 255);color: rgb(255, 255, 255);" title="" opera-tn-ra-cell="_$.pages:0.layers:0.comps:159.title1"><p>猜你喜歡</p></span></section><section style="border-width: 1px;border-style: solid;border-color: transparent;margin-top: -1em;padding: 20px 10px 10px;background-color: rgb(239, 239, 239);text-align: center;"><section style="font-size: 14px;text-align: left;" powered-by="xiumi.us"><ul class="list-paddingleft-1" style="padding-left: 40px;list-style-position: outside;"><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497343%26idx%3D1%26sn%3D959b66ceb9a8c2fe060b6981b41a807e%26chksm%3Debdb86eddcac0ffb229636ec51ec94433af75c7bc58aaa5ae52b4a2bf6a2d6d2ab11583b3174%26scene%3D21%23wechat_redirect" textvalue="記一次 Redis Cluster Pipeline 導致的死鎖問題" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">記一次 Redis Cluster Pipeline 導致的死鎖問題</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497376%26idx%3D1%26sn%3D5795a683e52f70384a13b34aa3daf731%26chksm%3Debdb8632dcac0f2468a461db09d8de6219af346e51436b91e6c946ee8b37e6ae8175b2f5d55e%26scene%3D21%23wechat_redirect" textvalue="深入理解 Netty FastThreadLocal" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">深入理解 Netty FastThreadLocal</a></p></li><li><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247497336%26idx%3D1%26sn%3D777059b19e224f1a4fbb1550ad1de7e8%26chksm%3Debdb86eadcac0ffc78dc019c5685ad137fdddd6572238525d707152c102790f82917a473d52a%26scene%3D21%23wechat_redirect" textvalue="MySQL 到 TiDB：Hive Metastore 橫向擴展之路" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">MySQL 到 TiDB：Hive Metastore 橫向擴展之路</a></p></li></ul></section></section></section></section><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互聯網技術" data-alias="vivoVMIC" data-signature="分享 vivo 互聯網技術乾貨與沙龍活動，推薦最新行業動態與熱門會議。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公眾號 - vivo 互聯網技術（vivoVMIC）。<br>如有侵權，請聯繫 support@oschina.cn 刪除。<br>本文參與「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源創計劃</a>」，歡迎正在閲讀的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10136865</guid>
            <link>https://my.oschina.net/vivotech/blog/10136865</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[谷歌開放 .ing 頂級域名註冊]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Google <u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.google%2Fproducts%2Fregistry%2Fintroducing-the-ing-top-level-domain%2F" target="_blank">宣佈開放 .ing 頂級域名註冊</a></u>，即日起用戶可通過<strong>支付額外費用（費率隨時間推移降低）的方式搶先註冊</strong>，搶先體驗期 (EAP) 截至 12 月 5 日。</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1101/104932_JmaT_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>Google 表示藉助該域名企業可以註冊一些非常有趣的域名，比如在線設計和繪圖平台 Canva 註冊的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdesign.ing%2F" target="_blank">design.ing</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdraw.ing%2F" target="_blank">draw.ing</a>、Adobe Acrobat 註冊的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fedit.ing%2F" target="_blank">edit.ing</a>&nbsp;和&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsign.ing%2F" target="_blank">signing</a>&nbsp;等。</p><p>.ing 域名註冊地址：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fget.ing%2F" target="_blank">https://get.ing/</a></u></p><p><img height="1676" src="https://static.oschina.net/uploads/space/2023/1101/105256_D6p3_2720166.png" width="3310" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 31 Oct 2023 02:49:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264406/the-ing-top-level-domain</guid>
            <link>https://www.oschina.net/news/264406/the-ing-top-level-domain</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[深圳一公司獎勵程序員「黃金鍵帽」，價值近 2 萬元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 10 月 24 日，被眾多科技公司和業內人士稱為「程序員節」。當天，深圳一公司獎勵員工「<strong>黃金鍵帽</strong>」。</p><blockquote><p><img height="1658" src="https://static.oschina.net/uploads/space/2023/1031/185140_pBn0_2720166.png" width="1176" referrerpolicy="no-referrer"></p></blockquote><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.weibo.com%2F5558240479%2FNpm9Lffdj%3Fpagetype%3Dprofilefeed" target="_blank">據稱</a></u>這款空格鍵鍵帽是 40g 黃金，價值近 2 萬元。</p><p><img src="https://static.oschina.net/uploads/space/2023/1031/185850_Wq96_2720166.png" referrerpolicy="no-referrer"></p><p><em>△「黃金 C 鍵」是該公司去年的獎勵</em></p><p>獲得獎勵程序員根據代碼行數排名和部門推舉共同選出，最具分量的「黃金空格鍵」獎勵給有效代碼量最多的程序員。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 10:48:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264307</guid>
            <link>https://www.oschina.net/news/264307</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[前三季度互聯網企業利潤總額同比增 18.2%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年前三季度互聯網和相關服務業運行情況現已公佈。前三季度，互聯網業務收入增速小幅提升，利潤總額較快增長，研發經費持續下滑。</p><h4 style="margin-left:0px; margin-right:0px"><strong>一，總體運行情況</strong></h4><p><strong>互聯網業務收入增速小幅提升。</strong>前三季度，我國規模以上互聯網和相關服務企業 1（以下簡稱互聯網企業）完成互聯網業務收入 10294 億元，同比增長 3.4%。</p><p><img height="241" src="https://oscimg.oschina.net/oscnet/up-505b65f84338dd716295e76b74112009b70.png" width="500" referrerpolicy="no-referrer"></p><p><strong>利潤總額較快增長。</strong>前三季度，我國規模以上互聯網企業營業成本同比增長 7%，增速較上半年回落 0.4 個百分點。實現利潤總額 959.3 億元，同比增長 18.2%。</p><p><img height="239" src="https://oscimg.oschina.net/oscnet/up-54642fdf1ae20d26f1bc9494e46da1f4440.png" width="500" referrerpolicy="no-referrer"></p><p><strong>研發經費持續下滑。</strong>前三季度，我國規模以上互聯網企業共投入研發經費 495.9 億元，同比下降 6.1%。</p><p><img height="246" src="https://oscimg.oschina.net/oscnet/up-d14b35b6a1179d07e10ffc542ff0150925e.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px"><strong>二，分領域運行情況</strong></h4><p style="margin-left:0; margin-right:0"><strong>（一）信息服務領域企業收入小幅回落。</strong>前三季度，以信息服務為主的企業（包括新聞資訊、搜索、社交、遊戲、音樂視頻等）互聯網業務收入同比下降 2.7%。</p><p><strong>（二）生活服務領域企業收入較快增長。</strong>前三季度，以提供生活服務為主的平台企業（包括本地生活、租車約車、旅遊出行、金融服務、汽車、房屋住宅等）互聯網業務收入同比增長 9.8%。</p><p><strong>（三）網絡銷售領域企業收入增速持續提升。</strong>前三季度，主要提供網絡銷售服務的企業（包括大宗商品、農副產品、綜合電商、醫療用品、快遞等）互聯網業務收入同比增長 47.3%。</p><h4 style="margin-left:0px; margin-right:0px"><strong>三，分地區運行情況</strong></h4><p><strong>東部地區互聯網業務收入保持平穩增速。</strong>前三季度，東部地區完成互聯網業務收入 9613 億元，同比增長 4.5%，增速較上半年提升 0.7 個百分點，佔全國互聯網業務收入的比重為 93.4%。中部地區完成互聯網業務收入 329.5 億元，同比下降 9.7%，降幅較上半年擴大 2.2 個百分點。西部地區完成互聯網業務收入 325 億元，同比下降 7.5%，降幅較上半年收窄 3.2 個百分點。東北地區完成互聯網業務收入 26.5 億元，同比下降 33.3%，降幅較上半年收窄 6.4 個百分點。</p><p><img height="239" src="https://oscimg.oschina.net/oscnet/up-7b7896fe852aa2c94820a864e846f80cae2.png" width="500" referrerpolicy="no-referrer"></p><p><strong>長三角地區互聯網業務收入實現較快增長。</strong>前三季度，京津冀地區完成互聯網業務收入 3948 億元，同比增長 2.9%，增速較上半年回落 0.3 個百分點，佔全國互聯網業務收入的比重為 38.4%。長三角地區完成互聯網業務收入 4225 億元，同比增長 13.1%，增速較上半年提升 3.5 個百分點。</p><p><img height="300" src="https://oscimg.oschina.net/oscnet/up-f6cddc5c38e933857b00b43bd049054bd02.png" width="500" referrerpolicy="no-referrer"></p><p><strong>半數地區互聯網業務增速實現正增長。</strong>前三季度，互聯網業務累計收入居前 5 名的北京（增長 0.7%）、上海（增長 17.7%）、浙江（增長 5.1%）、廣東（下降 7.4%）和天津（增長 22.3%）共完成業務收入 9077 億元，同比增長 5.5%，佔全國比重達 88.2%。全國互聯網業務增速實現正增長的省（區、市）有 15 個。</p><p><img height="243" src="https://oscimg.oschina.net/oscnet/up-d691bf5c06989113a27d8f6cf4a88d4ab6e.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px"><strong>四，我國移動應用程序（APP）發展情況</strong></h4><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify">根據全國 APP 技術檢測平台統計，截至 9 月底，我國國內市場上監測到活躍的 APP 數量 2 為 261 萬款（包括安卓和蘋果商店）。移動應用開發者數量為 84 萬，其中安卓開發者為 26 萬，蘋果開發者為 58 萬。9 月份，安卓應用商店在架應用累計下載量 542 億次。</p><p><span style="color:#888888">附註：</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#888888">1.規模以上互聯網和相關服務企業口徑由上年互聯網和相關服務收入 500 萬元以上調整為 2000 萬元及以上，文中所有同比增速均按可比口徑計算。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span style="color:#888888">2.活躍的移動應用程序數量是指報告期內我國市場上經過用戶主動下載安裝的第三方移動應用的總個數，其中安卓應用數的計算方法是根據智能手機記錄的已安裝移動應用去重後獲得。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 10:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264303</guid>
            <link>https://www.oschina.net/news/264303</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
