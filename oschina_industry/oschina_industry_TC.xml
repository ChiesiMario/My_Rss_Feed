<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-綜合資訊]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 30 Oct 2023 08:30:52 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[MetaGPT 實現多智能體通信，智能體也能輕鬆狼人殺]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><h1>概述</h1><p>狼人殺遊戲是一種受歡迎的多人溝通策略遊戲。在 Xu 等人所作的 《Exploring Large Language Models for Communication Games: An Empirical Study on Werewolf》（以下簡稱「論文」）為題的論文中，展示了大型語言模型（LLM）在遊戲中的潛力。考慮到 MetaGPT 作為一個智能體框架，我們提出了這個挑戰：我們能否使用 MetaGPT 來快速複製生動的遊戲體驗？我們非常高興地宣佈，我們成功完成了這個挑戰。</p><p>遵循論文的思路，我們成功地通過 MetaGPT 實現了狼人殺遊戲智能體的開發。我們展示了以下內容：</p><ol><li>當需要構建多智能體文本遊戲，其中智能體之間需要進行精細化溝通時，MetaGPT 框架是極佳選擇。</li><li>MetaGPT 提供了直觀和自然的抽象，當恰當地使用時，有助於將強大的功能集成到智能體中，如反思、經驗學習等。</li><li>在初步實驗中，通過調整反思和經驗學習機制，我們觀察到了智能體性能的明顯提高。</li></ol><p>有關更多詳細信息，將在本文中剩下部分進行探討。完整的代碼可在<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgeekan%2FMetaGPT%2Ftree%2Fwerewolf_game" target="_blank">MetaGPT 代碼庫</a>上獲得。有關運行代碼的指南，請參閲「代碼運行指南」部分。關於 MetaGPT 的總體介紹，請參閲我們的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2308.00352" target="_blank">論文</a>。</p><h1>演示</h1><h2>狼人殺智能體遊玩演示</h2><p>在深入實現細節探討之前，讓我們先看一下智能體在狼人殺遊戲中的精彩瞬間。我們在<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwerewolf.deepwisdom.ai%2F" target="_blank">網頁</a>上展示了 5 個具有代表性的遊戲過程，並提供完整的 30 個運行的轉錄，供您探索和娛樂！</p><p>友情提示：</p><ul><li>關於這個遊戲的完整介紹可以在論文中找到。遊戲的設置是兩個村民，一個預言家，一個女巫，一個守衞和兩個狼人。我們採用了遊戲社區中更為常見的規則，即當狼人屠邊時（消除了所有特殊角色或所有村民），狼人就獲勝。</li><li>為了促進更加精彩的遊戲效果，我們在狼人智能體遊玩之前引入相關策略，以此來引導他們積極地模仿特殊角色。</li><li>當然為了實驗的簡易化的進行：當兩個狼人在晚上瞄準兩個不同的玩家時，目標默認為第二個選擇。</li><li>我們使用 GPT-4 進行遊戲運行。</li></ul><h2>智能體的精彩瞬間</h2><p>我們觀察到了各種情況，其中我們的智能體表現出邏輯甚至戰略行為。以下是一些精彩瞬間：</p><h3>合作 / 共謀</h3><p>Player5（守衞）推理出預言家，分析出當晚選擇守衞預言家可以最大化價值，因此守衞了 Player6。</p><p><img alt="" height="580" src="https://oscimg.oschina.net/oscnet/up-b5c5420da74986208482aa943dfb4e9edae.png" width="800" referrerpolicy="no-referrer"></p><p>Player1（狼人）控告 Player2 時，Player5（狼人）果斷進行了支持。</p><p><img alt="" height="369" src="https://oscimg.oschina.net/oscnet/up-10bd3f15226c0a7313c90b0442eb76537c1.png" width="800" referrerpolicy="no-referrer"></p><h2>對抗</h2><p>當 Player1（狼人）悍跳預言家時，真正的預言家 Player4 站出來反對狼人。</p><p><img alt="" height="515" src="https://oscimg.oschina.net/oscnet/up-b96b60fe0d3de2d712af304587a84838f61.png" width="800" referrerpolicy="no-referrer"></p><h2>賣隊友</h2><p>當大多數玩家對 Player3（狼人）產生懷疑時，Player6（狼人）仔細權衡了利弊，決定開始賣隊友。</p><p><img alt="" height="324" src="https://oscimg.oschina.net/oscnet/up-2fd8b8dfc02bdafdc3106c485b83b6bdd22.png" width="800" referrerpolicy="no-referrer"></p><h2>觀望</h2><p>當 Player2（狼人）聲稱自己是預言家時，Player6（村民）從過去的經驗中吸取了教訓，保留了自己的判斷，要求在採取立場之前進行更多的觀察。</p><p><img alt="" height="509" src="https://oscimg.oschina.net/oscnet/up-86bc6d3fa8dcc23a474a833b5e7b47a313e.png" width="800" referrerpolicy="no-referrer"></p><p>Player5（女巫）通過分析選擇留藥。</p><p><img alt="" height="413" src="https://oscimg.oschina.net/oscnet/up-272b1ba2775ddb394a1a2837d4623c7ee6c.png" width="800" referrerpolicy="no-referrer"></p><h2>複雜推理</h2><p>基於先前對 Player2 是狼人的判斷，Player6（村民）分析了票面等盤面情況，清楚地區分了 Player3（狼人）和其他玩家。</p><p><img alt="" height="548" src="https://oscimg.oschina.net/oscnet/up-ccaaf1318b54858160f79c4021a2b2bd6fb.png" width="800" referrerpolicy="no-referrer"></p><p>Player6（預言家）準確地通過反思辨別了每個玩家的角色，並由於其對經過驗證的村民的敵意檢測到了狼人。</p><p><img alt="" height="559" src="https://oscimg.oschina.net/oscnet/up-a5cded422bedf58bedab8bde0924bf33dda.png" width="800" referrerpolicy="no-referrer"></p><h1>實施方案</h1><h2>多智能體通信</h2><p>實現狼人遊戲的一個重要元素在於促進智能體之間的精確、細粒度的通信。讓我們考慮三種類型的消息：</p><ol><li>從主持人發送給預言家的私聊中，通知預言家或其他有關特定玩家的身份（一對一）。</li><li>從一名狼人發送的私聊中，通知狼人夥伴和主持人所選擇的襲擊目標（一對多）。</li><li>從主持人發出的公開消息，指示所有玩家醒來（一對所有）。</li></ol><p>MetaGPT 支持所有三種通信，這要歸功於關鍵的抽象概念：<code>Environment</code>（環境）和 <code>Message</code>（消息），以及 agent’s（智能體角色）通過 <code>_publish</code>（發佈）和 <code>_observe</code>（觀察）兩個函數來作為處理消息的方法。每當一個 agents 發佈一個 <code>Message</code>，它都會將 <code>Message</code><code>_publish</code> 到 <code>Environment</code> 中。反過來，接收 <code>Message</code> 的 agents 會從 <code>Environment</code> 中_observe <code>Message</code>。而我們需要做的就是填充 <code>Message</code> 屬性，如 send_to 和 restricted_to，包括預期的接收者（agents）。然後 MetaGPT 會處理剩下的工作。</p><p>綜合考慮，我們建立了一個複雜的智能體之間<strong>通信拓撲結構</strong>。有關詳細的實施信息，請隨時查看我們的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgeekan%2FMetaGPT%2Ftree%2Fwerewolf_game" target="_blank">代碼</a>。我們正在積極努力完善這一機制，並將很快發佈一個全面的指南。</p><p><img alt="" height="500" src="https://oscimg.oschina.net/oscnet/up-b7bf83b4832178c7cdbb4e5b0a39824e732.png" width="800" referrerpolicy="no-referrer"></p><h2>智能體能力</h2><p>在論文中，生成最終響應需要多個組件（下圖）。在這一部分，我們展示了從智能體的角度出發，構建包含所有這些組件的高效智能體是非常直接和簡單的。</p><p><img alt="" height="1378" src="https://oscimg.oschina.net/oscnet/up-b6d94f144c2238dbb480dcb2f9c5f90a25b.png" width="800" referrerpolicy="no-referrer"></p><p>我們採用的方法是利用 MetaGPT 的 <code>Role</code>抽象來定義一個智能體，然後為其配備適當的 <code>Action</code>（動作）。我們定義 <code>Speak</code>和 <code>NighttimeWhisper</code> 作為返回響應的最終 <code>Action</code>（動作）。關於每個準備組件發送到最終響應生成方式，如論文中所概述，請參見下表瞭解各自的實現。</p><p><img alt="" height="247" src="https://oscimg.oschina.net/oscnet/up-a191e5e9247b78baf9ce767ec61e7442877.png" width="1120" referrerpolicy="no-referrer"></p><p>我們將所有這些 <code>Action</code>（行動） 組合在 <code>Role</code>’s（智能體角色） 的 <code>_observe</code>（觀察）、 <code>_think</code>（思考） 和 <code>_act</code>（行動） 中，從而形成了一個清晰的智能體思考和行動流程（下圖）。此外，流程中的每個步驟都被模塊化，意味着在其他遊戲中更容易重用。<strong>通過這種方式，我們構建了一個擁有各種能力的智能體，能夠進行復雜的推理和言辭表達。</strong></p><p><strong><img alt="" height="1130" src="https://oscimg.oschina.net/oscnet/up-f465474544ce499d9f77b8b677866113ec7.png" width="800" referrerpolicy="no-referrer"></strong></p><h1>關於新方法的實驗</h1><p>在遵循論文的主要程序的同時，我們基於試錯的方式修改了反思和經驗學習組件的內部工作方式。我們修訂後的方法是：</p><ol><li>讓智能體展示它遊戲過程中反思的狀態，並以結構化的方式用語言進行總結。</li><li>記錄一個包含四個元素的元組（反思，靜態動作指令，來自反思和指令的動作，遊戲的最終結果），作為一種經驗，並積累成一個經驗池。</li><li>當智能體下次遇到相似的情況時，提供相關的過去經驗。這裏的相似性是根據反思嵌入的語義接近度來定義的。通過回顧類似的經驗，智能體如果在過去因為某些操作失敗了，將會改變他們的操作；如果成功了，將會增強他們對這一步操作的信心。</li></ol><p>在實踐中，我們發現這種方法相當有效。遵循論文的實驗設置，我們進行了 30 輪的實驗。在前 10 輪中，村民方沒有過去的經驗；在第 11 輪到第 20 輪中，村民方可以接觸到前 10 輪的經驗；在第 21 輪到第 30 輪中，村民方可以接觸到前 20 輪的經驗。當然，本次實驗中，我們停止了狼人獲得經驗的能力，以此更好地來觀察村民方的結果。</p><p>下面是性能提升的圖表。隨着經驗的積累，村民方對抗狼人的勝率逐漸增加。我們還檢查了村民在識別狼人方面的平均投票準確率。上升的趨勢表明，當村民擁有經驗時，他們的判斷更為準確，從而證實了他們提高的勝率不僅僅是偶然事件的結果。此外，由於投票準確率還取決於投票的難度，因此我們還評估了在一個固定情景下的準確率：在一組 6 名倖存玩家中識別 2 名狼人，這通常是在投票的第一天面臨的情況。這一趨勢與平均投票準確率的趨勢相吻合。</p><p><img alt="" height="358" src="https://oscimg.oschina.net/oscnet/up-8ffd401a7790a720a5fbaea0c72ad900e50.png" width="565" referrerpolicy="no-referrer"></p><h1>代碼運行指南</h1><pre><code class="language-python">python examples/werewolf_game/start_game.py # use default arguments</code></pre><pre><code class="language-python">python examples/werewolf_game/start_game.py \\\\
    --use_reflection True \\\\
    --use_experience False \\\\
    --use_memory_selection False \\\\
    --new_experience_version "01-10" \\\\
    --add_human False

# use_reflection: switch to False to disable reflection, this can reduce token costs 
# use_experience: switch to True to supply agents with experience, this requires recording experiences first
# use_memory_selection: switch to True to select only recent and informative messages from memory
# new_experience_version: specify a version to record the current run as experience 
# add_human: switch to True to participate in the game</code></pre><p>我們建議使用 GPT-4 運行代碼。平均而言，如果不使用反思，每次運行大約需要 1.5 美元，如果使用反思，則需要 4 美元，如果使用反思和經驗學習，則需要 7 美元。</p><h1>致謝</h1><p>這是由來自 MetaGPT 社區的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmannaandpoem" target="_blank">mannaandpoem</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdavidlee21" target="_blank">davidlee21</a>和<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fariafyy" target="_blank">ariayyy</a>作為核心貢獻者合作努力的成果。當然，我們還要十分感謝<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2F1766left" target="_blank">Elfe</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fchaleeluo" target="_blank">chaleeluo</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkevin-meng" target="_blank">kevin-meng</a>和<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Flinkedin.com%2Fin%2Fshutian-xiao-b29649241" target="_blank">Shutian</a>也提供了寶貴的見解。我們對他們的奉獻心存感激。我們熱烈邀請更多社區成員加入併為我們的 MetaGPT 項目做出貢獻！</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 30 Oct 2023 07:53:48 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264108</guid>
            <link>https://www.oschina.net/news/264108</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[百川智能發佈 Baichuan2-192K 大模型，上下文窗口全球最長]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>10 月 30 日，百川智能發佈<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FlAJh6qGG27u_qCl0kI-0lA" target="_blank">Baichuan2-192K 大模型</a></u>，其上下文窗口長度高達 192K，是目前全球最長的上下文窗口。</p><blockquote><p>上下文窗口長度是大模型的核心技術之一，通過更大的上下文窗口，模型能夠結合更多上下文內容獲得更豐富的語義信息，更好的捕捉上下文的相關性、消除歧義，進而更加準確、流暢的生成內容，提升模型能力。</p></blockquote><p>據介紹，<strong>Baichuan2-192K 能夠處理約 35 萬個漢字</strong>，是目前支持長上下文窗口最優秀大模型 Claude2（支持 100K 上下文窗口，實測約 8 萬字）的 4.4 倍，更是 GPT-4（支持 32K 上下文窗口，實測約 2.5 萬字）的 14 倍。Baichuan2-192K 不僅在上下文窗口長度上超越 Claude2，在長窗口文本生成質量、長上下文理解以及長文本問答、摘要等方面的表現也全面領先 Claude2。</p><p><img height="708" src="https://static.oschina.net/uploads/space/2023/1030/143754_9Lc3_2720166.png" width="1280" referrerpolicy="no-referrer"></p><p>Baichuan2-192K 在 Dureader、NarrativeQA、LSHT、TriviaQA 等 10 項中英文長文本問答、摘要的評測集上表現優異，有 7 項取得 SOTA，顯著超過其他長窗口模型。</p><p><img src="https://static.oschina.net/uploads/space/2023/1030/143926_8N50_2720166.png" referrerpolicy="no-referrer"></p><p>此外，LongEval 的評測結果顯示，在窗口長度超過 100K 後 Baichuan2-192K 依然能夠保持非常強勁的性能，而其他開源或者商用模型在窗口長度增長後效果都出現了近乎直線下降的情況。Claude2 也不例外，在窗口長度超過 80K 後整體效果下降非常嚴重。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e09d70b43d3d3782cda3982ae4d742587e1.png" referrerpolicy="no-referrer"></p><p>今年 9 月 25 日，百川智能已開放了 Baichuan2 的 API 接口，正式進軍企業級市場，開啓商業化進程。<strong>此次 Baichuan2-192K 將以 API 調用和私有化部署的方式提供給企業用戶</strong>，目前百川智能已經啓動 Baichuan2-192K 的 API 內測，開放給法律、媒體、金融等行業的核心合作伙伴。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 06:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264086</guid>
            <link>https://www.oschina.net/news/264086</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[華為申請註冊「遙遙領先」商標]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>近日，華為技術有限公司申請註冊「遙遙領先」商標，國際分類為運輸工具、科學儀器，當前商標狀態為等待實質審查。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2632d0767a23ab6a185920e5193ba46340f.png" referrerpolicy="no-referrer"></p><p>最近因華為 Mate60 系列手機發售，「遙遙領先」成為網絡熱詞。</p><p>「遙遙領先」一詞最先是出現在華為手機 Mate40 的發佈會上，餘承東在介紹手機的處理器、屏幕、電池、充電、攝像頭、音質等狀況時，曾經説了 14 次「遙遙領先」。去年的 Mate50 發佈，全球首發了衞星通信功能，餘承東再次提及「遙遙領先」，並稱其為捅破天的技術，又將「遙遙領先」的熱度推高。</p><p>隨後，華為的粉絲也經常在華為發佈會上喊「遙遙領先」為華為加油。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-c2112b8f18f699b1b8299410458e1811c69.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 06:06:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264078</guid>
            <link>https://www.oschina.net/news/264078</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[📙《高併發的哲學原理》紙質版書稿完全開源，共 16 萬多字]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><img alt="" height="600" src="https://oscimg.oschina.net/oscnet/up-1fb8b3621b91010af5c26e565583383ab83.png" width="1762" referrerpolicy="no-referrer"></p><p><strong>閲讀地址：</strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpphc.lvwenhan.com" target="_blank">https://pphc.lvwenhan.com</a></p><p style="color:#24292f; text-align:start"><strong>pdf 下載鏈接在網站右上角。</strong></p><h3>寫作目標</h3><p style="color:#2c3e50; text-align:start">本書的目標是在作者有限的認知範圍內，討論一下高併發問題背後隱藏的一個哲學原理——找出單點，進行拆分。</p><h3>內容梗概</h3><p style="color:#2c3e50; text-align:start">我們將從動靜分離講起，一步步深入 Apache、Nginx、epoll、虛擬機、k8s、異步非阻塞、協程、應用網關、L4/L7 負載均衡器、路由器 (網關)、交換機、LVS、軟件定義網絡 (SDN)、Keepalived、DPDK、ECMP、全冗餘架構、用戶態網卡、集中式存儲、分佈式存儲、PCIe 5.0、全村的希望 CXL、InnoDB 三級索引、內存緩存、KV 數據庫、列存儲、內存數據庫、Shared-Nothing、計算存儲分離、Paxos、微服務架構、削峯、基於地理位置拆分、高可用等等等等。並最終基於地球和人類社會的基本屬性，設計出可以服務地球全體人類的高併發架構。</p><p style="color:#2c3e50; text-align:start"><br> 全書共 167674 字。</p><h3>讀者評價</h3><blockquote><p>會上一談到架構和 I/O，我都想到你的文章。主講解答清楚和沒解答清楚的，都沒你的文章清楚。</p><p>—— 秋收，於 RubyConf 2023</p></blockquote><hr><blockquote><p>像看小説一樣把文章都看完了，全程無尿點，作者的腦袋是在哪裏開過光，知識儲備竟如此紮實</p><p>—— 觀東山</p></blockquote><hr><blockquote><p>非常棒的技術分享！深入淺出，娓娓道來，讓我想起了那本 csapp。</p><p>—— drhrchen</p></blockquote><hr><blockquote><p>寫得真好，膜拜！作者願意出書嗎，一定買！</p><p>—— bean</p></blockquote><hr><blockquote><p>拜讀了！應該算是架構頂級總結！！</p><p>—— 雨山前</p></blockquote><hr><blockquote><p>看完了，博主好厲害，學習到了各種騷技巧，和知識，膜拜</p><p>—— evanxian</p></blockquote><hr><blockquote><p>寫的太好了，不僅充滿了理工科的嚴謹較真，也充滿了文科的浪漫</p><p>—— 一秒</p></blockquote><hr><blockquote><p>寫得很好，視角也是我喜歡的，站在地球表面，述事宏大，思維自信。</p><p>—— 納秒時光</p></blockquote><hr><blockquote><p>全部看完，博主太強了，很受啓發</p><p>—— Bruce</p></blockquote><hr><blockquote><p>棒</p><p>—— JuniaWonter</p></blockquote><h2>作者信息</h2><h3>呂文翰</h3><ol><li>GitHub：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjohnlui" target="_blank">johnlui</a></li><li>職位：住範兒創始成員，CTO，監事</li></ol><h4>高併發系統處理經驗</h4><ol><li>2017 年維護的單體 CMS 系統頂住了每日兩百萬 PV 的壓力</li><li>2020 年優化一個單機 PHP 商城頂住了 QPS 1000+ 的壓力</li><li>2021 年設計的分佈式電商秒殺系統在實際業務中跑到了最高一分鐘 GMV 500 萬，QPS 10000+</li></ol><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3e128c2c71f79a9f5c551fa204024a7d6d1.jpg" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>&nbsp;</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-c1a9c97d554a8c227a53037467944206a7c.jpg" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-ce3364f3899525cd6ffc33de9d05faf6e73.jpg" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-03c79aa58b98f1f7f757bc4647cc40a81b0.jpg" referrerpolicy="no-referrer"></p><p><img alt="" height="1818" src="https://oscimg.oschina.net/oscnet/up-bbca5aa6d8d33372882757c429ad5a13815.jpg" width="3320" referrerpolicy="no-referrer"></p><p>&nbsp;</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 05:27:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264073</guid>
            <link>https://www.oschina.net/news/264073</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Windows 11 已原生支持 11 種文件存檔格式，包括 7-Zip 和 RAR]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="color:#000000">在今年 5 月份，微軟方面曾<a href="https://www.oschina.net/news/242230/windows-11-supports-rar">宣佈</a>將在&nbsp;<span style="background-color:#ffffff">Windows 11 系統中原生增加對 RAR、7-Zip 等壓縮文件格式的解壓支持。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">時至今日，該公司已通過本月的可選&nbsp;KB5031455&nbsp;預覽累積更新添加了對 11 種新文件存檔格式的支持，Windows 11 22H2 現在原生支持近十幾種附加存檔格式。</span></span><span style="color:#000000"><span style="background-color:#ffffff">Windows 11 中支持的存檔類型的更新列表現在添加了：.rar、.7z、.tar、.tar.gz、.tar.bz2、.tar.zst、.tar.xz、.tgz、.tbz2、.tzst、和 .txz。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">不過目前還不支持密碼加密文件，微軟<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bleepingcomputer.com%2Fnews%2Fmicrosoft%2Fwindows-11-adds-support-for-11-file-archives-including-7-zip-and-rar%2F" target="_blank">發言人</a>也沒有透露更多的相關信息；其後續可能還將添加對&nbsp;LZH、LZH 和 XAR 等其他格式的支持。</span></span></p><p><span style="color:#000000">「我們使用 </span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flibarchive%2Flibarchive" target="_blank">libarchive</a><span style="color:#000000"> 開源項目添加了對其他存檔格式的原生支持，包括 tar、7-Zip、RAR、gz 和許多其他格式。現在，你可以在 Windows 上的壓縮過程中獲得更高的存檔功能性能。」</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">libarchive 是一個開源的 C 庫，旨在為各種不同的壓縮格式提供讀取和寫入支持。它支持許多常見的壓縮格式，並提供了許多高級功能，例如加密、數字簽名、多卷支持等。libarchive 的主要優點是它的跨平台支持，它可以在各種操作系統上運行，包括 Linux、Windows、macOS 等。它還提供了多種語言的綁定，如 Python、Ruby、Perl 等，使得開發人員可以方便地在自己喜歡的編程語言中使用它。</span></p><p><span style="color:#000000">由於 KB5031455 是一個可選更新，Windows 用戶必須手動安裝。這項新功能還將通過計劃在 11 月份的"</span>Patch Tuesday<span style="color:#000000">"發佈的累積更新向所有 Windows 11 用戶推出。</span></p><p><img height="271" src="https://oscimg.oschina.net/oscnet/up-2a02652354dae96fd940ccc4d707d65e355.png" width="500" referrerpolicy="no-referrer"></p><p><strong>延伸閲讀：</strong></p><ul><li><a href="https://www.oschina.net/news/242230/windows-11-supports-rar" target="_blank">Windows 將原生支持解壓 RAR 和 7Z</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:44:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264054/windows-11-support-11-file-archives-7-zip-rar</guid>
            <link>https://www.oschina.net/news/264054/windows-11-support-11-file-archives-7-zip-rar</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[🎊OpenTiny Vue 3.11.0 發佈：增加富文本、ColorPicker 等 4 個新組件，迎來了貢獻者大爆發！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p>你好，我是 Kagol。</p><p>非常高興跟大家宣佈，2023 年 10 月 24 日，OpenTiny Vue 發佈了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Freleases%2Ftag%2Fv3.11.0" target="_blank">v3.11.0</a> 🎉。</p><p>OpenTiny 每次大版本發佈，都會給大家帶來一些實用的新特性，8.14 我們發佈了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Freleases%2Ftag%2Fv3.10.0" target="_blank">v3.10.0</a> 版本，增加了 4 個新組件，組件 Demo 支持在 Options 和 Composition api 之間切換。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7268207722239148044" target="_blank">🎉OpenTiny Vue 3.10.0 版本發佈：組件 Demo 支持 Composition 寫法，新增 4 個新組件</a></p><p>本次 3.11.0 版本主要增加以下新組件：</p><ul><li>RichTextEditor 富文本編輯器組件 - by <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCaesar-ch" target="_blank">Caesar-ch</a></li><li>ColorPicker 顏色選擇器組件 - by <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FGaoNeng-wWw" target="_blank">GaoNeng-wWw</a></li><li>CalendarView 日曆視圖組件 - by <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkagol" target="_blank">kagol</a></li><li>Divider 分割線組件 - by <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvaebe" target="_blank">vaebe</a></li></ul><p>本次版本共有 23 位貢獻者參與開發，其中有 14 位是新貢獻者，歡迎新朋友們👏</p><p>以下是新貢獻者：</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjack-zishan" target="_blank">@jack-zishan</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F392" target="_blank">#392</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FLinboLen" target="_blank">@LinboLen</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F478" target="_blank">#478</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvaebe" target="_blank">@vaebe</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F471" target="_blank">#471</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fallenli178" target="_blank">@allenli178</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F488" target="_blank">#488</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FBinks123" target="_blank">@Binks123</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F500" target="_blank">#500</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fyoyo201626" target="_blank">@yoyo201626</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F513" target="_blank">#513</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwkif" target="_blank">@wkif</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F512" target="_blank">#512</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fchenguang1994" target="_blank">@chenguang1994</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F518" target="_blank">#518</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FZuowendong" target="_blank">@Zuowendong</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F503" target="_blank">#503</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgweesin" target="_blank">@gweesin</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F554" target="_blank">#554</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fshonen7" target="_blank">@shonen7</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F567" target="_blank">#567</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxlearns" target="_blank">@xlearns</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F574" target="_blank">#574</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fianxinnew" target="_blank">@ianxinnew</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F617" target="_blank">#617</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FXppp0217" target="_blank">@Xppp0217</a>&nbsp;made their first contribution in&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue%2Fpull%2F610" target="_blank">#610</a></li></ul><p>也感謝老朋友們對 OpenTiny 的辛苦付出！</p><p>尤其感謝 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpe-3" target="_blank">pe-3</a> / <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCaesar-ch" target="_blank">Caesar-ch</a> / <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FGaoNeng-wWw" target="_blank">GaoNeng-wWw</a> / <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvaebe" target="_blank">vaebe</a> / <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FBinks123" target="_blank">Binks123</a>。</p><p>大家可以更新 <code>@opentiny/vue@3.11.0</code> 進行體驗！</p><h2>RichTextEditor 富文本編輯器</h2><p>該組件由 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCaesar-ch" target="_blank">Caesar-ch</a> 同學貢獻🎉</p><p>富文本編輯器雖然不是高頻組件，但在特定的領域，比如需求管理、內容編輯、文章創作等，幾乎是必備組件之一。</p><p>為了滿足這些業務的需求，我們推出了 RichTextEditor 富文本組件，目前只是初版，只包含以下基礎功能：</p><ul><li>加粗、斜體、下劃線、刪除線</li><li>引用</li><li>行內代碼、代碼塊</li><li>有序列表、無序列表、任務列表</li><li>上標、下標</li><li>撤銷、重做</li><li>左對齊、右對齊、居中對齊</li><li>段落、H1-H6 標題</li><li>字號、行間距</li><li>高亮、文本顏色、背景色</li><li>清除格式</li><li>超鏈接</li><li>上傳圖片</li><li>插入/編輯表格</li></ul><p>後續將不斷進行豐富，歡迎朋友們一起參與共建。</p><p>使用起來非常簡單：</p><pre><code class="language-html">&lt;template&gt;
  &lt;tiny-rich-text-editor&gt;&lt;/tiny-rich-text-editor&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { RichTextEditor as TinyRichTextEditor } from '@opentiny/vue'
&lt;/script&gt;
</code></pre><p>以下是效果圖：</p><p><img src="https://oscimg.oschina.net/oscnet/up-47bf70d440b55b03b73cadece12c578c878.png" alt="" referrerpolicy="no-referrer"></p><p>可以通過 custom-toolbar 配置工具欄：</p><pre><code class="language-html">&lt;template&gt;
  &lt;tiny-rich-text-editor :customToolBar="customToolBar"&gt;&lt;/tiny-rich-text-editor&gt;
&lt;/template&gt;

&lt;script setup lang="jsx"&gt;
import { ref } from 'vue'
import { RichTextEditor as TinyRichTextEditor } from '@opentiny/vue'

const customToolBar = ref(['bold', 'italic'])
&lt;/script&gt;
</code></pre><p>效果如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-1147fffec6379d22695d67e56fba4664680.png" alt="" referrerpolicy="no-referrer"></p><p>更多功能等你來體驗！</p><h2>ColorPicker 顏色選擇器</h2><p><code>ColorPicker</code> 顏色選擇組件用於在應用程序和界面中讓用戶選擇顏色。它是一個交互式的元素，通常由一個色彩光譜、色相環和顏色值輸入框組成，用戶可以通過這些元素來選擇所需的顏色。ColorPicker 的主要功能是讓用戶能夠精確地選擇特定的顏色，以便在應用程序的各種元素中使用。</p><p>該組件是由 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FGaoNeng-wWw" target="_blank">GaoNeng</a> 同學貢獻的🎉，他還寫了一篇 ColorPicker 組件開發全流程的總結文章。</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7273039565904805943" target="_blank">GaoNeng：我是如何為 OpenTiny 貢獻新組件的？</a></p><p>ColorPicker 使用方式很簡單：</p><pre><code class="language-html">&lt;template&gt;
  &lt;tiny-color-picker v-model="color" /&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref } from 'vue'
import { ColorPicker as TinyColorPicker } from '@opentiny/vue'
const color = ref('#66ccff')
&lt;/script&gt;
</code></pre><p>效果如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-b057da8b3789c696e4d08173ef282701c0f.png" alt="" referrerpolicy="no-referrer"></p><p>該組件功能非常強大，除了在色板中選擇顏色之外，還支持：</p><ul><li>透明度調節</li><li>預定義顏色</li><li>顏色歷史</li><li>顏色選擇面板單獨使用</li></ul><p>更多功能等你來體驗！</p><p>透明度調節：</p><p><img src="https://oscimg.oschina.net/oscnet/up-c350aad80432e9ca114193691533a44c539.png" alt="" referrerpolicy="no-referrer"></p><p>預定義顏色：</p><p><img src="https://oscimg.oschina.net/oscnet/up-4e263213bfaa04d89cd65b26d6cc28e4f47.png" alt="" referrerpolicy="no-referrer"></p><p>顏色歷史：</p><p><img src="https://oscimg.oschina.net/oscnet/up-84717f04236162824c078dd4b52e6d4c956.png" alt="" referrerpolicy="no-referrer"></p><p>顏色面板單獨使用：</p><p><img src="https://oscimg.oschina.net/oscnet/up-538fd1ef71f738381ec1b57677217a37339.png" alt="" referrerpolicy="no-referrer"></p><h2>CalendarView 日曆視圖</h2><p>大家都知道 DatePicker 日期選擇器，這個組件通過一個日期表格來選擇一個日期，日期表格的放大版本就是日曆表格，我們來看下對比圖。</p><p>DatePicker 日期表格：</p><p><img src="https://oscimg.oschina.net/oscnet/up-9c75f49c4563c1c34d33d83efa3bba203e5.png" alt="" referrerpolicy="no-referrer"></p><p>CalendarView 日曆表格：</p><p><img src="https://oscimg.oschina.net/oscnet/up-c3f1e361478ec9c16b89e8e5651e097945f.png" alt="" referrerpolicy="no-referrer"></p><p>歡迎體驗！</p><h2>Divider 分割線</h2><p>該組件由 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvaebe" target="_blank">vaebe</a> 同學貢獻🎉</p><p>分割線相對比較簡單，目前主要支持：</p><ul><li>橫向和豎向分割線</li><li>添加分割線文案、調整文案位置</li><li>自定義分割線樣式</li></ul><p>效果如下：</p><p><img src="https://oscimg.oschina.net/oscnet/up-1660ecf8650d5f1824c8afd9a48cf9374cb.png" alt="" referrerpolicy="no-referrer"></p><p>歡迎體驗！</p><h2>關於 OpenTiny</h2><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">OpenTiny</a> 是一套企業級 Web 前端開發解決方案，提供跨端、跨框架的 UI 組件庫，適配 PC 端 / 移動端等多端，支持 Vue2 / Vue3 / Angular 多技術棧，擁有靈活擴展的低代碼引擎，包含主題配置系統 / 中後台模板 / CLI 命令行等豐富的效率提升工具，可幫助開發者高效開發 Web 應用。</p><p><img src="https://oscimg.oschina.net/oscnet/up-668bb932353df7dbf97bc64795d640c6a25.png" alt="" referrerpolicy="no-referrer"></p><p>核心亮點：</p><ol><li><code>跨端跨框架</code>：使用 Renderless 無渲染組件設計架構，實現了一套代碼同時支持 Vue2 / Vue3，PC / Mobile 端，並支持函數級別的邏輯定製和全模板替換，靈活性好、二次開發能力強。</li><li><code>組件豐富</code>：PC 端有 100+組件，移動端有 30+組件，包含高頻組件 Table、Tree、Select 等，內置虛擬滾動，保證大數據場景下的流暢體驗，除了業界常見組件之外，我們還提供了一些獨有的特色組件，如：Split 面板分割器、IpAddress IP 地址輸入框、Calendar 日曆、Crop 圖片裁切等。</li><li><code>低代碼引擎</code>：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine" target="_blank">TinyEngine</a> 低代碼引擎使能開發者定製低代碼平台。它是低代碼平台的底座，提供可視化搭建頁面等基礎能力，既可以通過線上搭配組合，也可以通過下載源碼進行二次開發，實時定製出自己的低代碼平台。適用於多場景的低代碼平台開發，如：資源編排、服務端渲染、模型驅動、移動端、大屏端、頁面編排等。</li><li><code>配置式組件</code>：組件支持模板式和配置式兩種使用方式，適合低代碼平台，目前團隊已經將 OpenTiny 集成到內部的低代碼平台，針對低碼平台做了大量優化</li><li><code>周邊生態齊全</code>：提供了基於 Angular + TypeScript 的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-ng%2Foverview" target="_blank">TinyNG</a> 組件庫，提供包含 10+ 實用功能、20+ 典型頁面的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Fpro" target="_blank">TinyPro</a> 中後台模板，提供覆蓋前端開發全流程的 TinyCLI 工程化工具，提供強大的在線主題配置平台 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Fdesigntheme%2Fhome" target="_blank">TinyTheme</a></li></ol><hr><p>歡迎加入 OpenTiny 開源社區。</p><p>添加微信小助手：opentiny-official，一起參與共建！</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">OpenTiny</a> 官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">https://opentiny.design/</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue" target="_blank">Vue 組件庫</a>：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue" target="_blank">https://opentiny.design/tiny-vue</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine" target="_blank">低代碼引擎</a>：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine" target="_blank">https://opentiny.design/tiny-engine</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-ng" target="_blank">Angular 組件庫</a>：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-ng" target="_blank">https://opentiny.design/tiny-ng</a></p><p>OpenTiny 代碼倉庫：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">https://github.com/opentiny/</a> （歡迎 Star ⭐）</p><p>往期文章推薦</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7291598231954653240" target="_blank">OpenTiny Vue 支持 Vue2.7 啦！</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7280006603637751865" target="_blank">🖖少年，該升級 Vue3 了！</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7273039565904805943" target="_blank">✨GaoNeng：我是如何為 OpenTiny 貢獻新組件的？</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7262349502920523833" target="_blank">✨xiaoy：但因熱愛，願迎萬難，OpenTiny 社區增加一枚前端程序媛貢獻者</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7255239937170161723" target="_blank">✨貢獻者招募：前端 Vuer，請收好這份《Vue 組件單元測試》寶典，給自己多一些安全感</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7258319655285571644" target="_blank">🎉OpenTiny 前端組件庫正式開源啦！面向未來，為開發者而生</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7252198762624548924" title="從自研走向開源的 TinyVue 組件庫" target="_blank">🎉從自研走向開源的 TinyVue 組件庫</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7218926523252260923" target="_blank">🌈一個 OpenTiny，Vue2 Vue3 都支持！</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7224756843711758393" target="_blank">🌈如何啓動我的第一次開源貢獻</a>（如果你之前沒有參加過開源貢獻，請閲讀這篇文章）</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:33:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4863191/blog/10128241</guid>
            <link>https://my.oschina.net/u/4863191/blog/10128241</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[官宣｜Apache Flink 1.18 發佈公告]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p style="color:#24292e; margin-left:0px; margin-right:0px; text-align:start"><img alt="" height="383" src="https://oscimg.oschina.net/oscnet/up-3eb9414c54625e015117d61b4b0b2397619.png" width="685" referrerpolicy="no-referrer"></p><p style="color:#24292e; margin-left:0px; margin-right:0px; text-align:start">Apache Flink PMC 已正式發佈 Apache Flink 1.18.0 版本。與往常一樣，這是一個充實的版本，包含了廣泛的改進和新功能。總共有 174 人為此版本做出了貢獻，完成了 18 個 FLIPs 和 700 多個問題。感謝各位貢獻者的支持！</p><span id="OSC_h2_1"></span><h2>邁向 Streaming Lakehouse</h2><span id="OSC_h3_2"></span><h3>Flink SQL 提升</h3><span id="OSC_h4_3"></span><h4>Flink SQL Gateway 的 JDBC Driver</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Flink 1.18 版本提供了 Flink SQL Gateway 的 JDBC Driver。因此，您現在可以使用支持 JDBC 的任何 SQL 客戶端通過 Flink SQL 與您的表進行交互。以下是使用<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjulianhyde.github.io%2Fsqlline%2Fmanual.html" rel="nofollow" target="_blank">SQLLine</a><span>&nbsp;</span>的示例。</p><pre><code>sqlline version 1.12.0
sqlline&gt; !connect jdbc:flink://localhost:8083
Enter username for jdbc:flink://localhost:8083:
Enter password for jdbc:flink://localhost:8083:
0: jdbc:flink://localhost:8083&gt; CREATE TABLE T(
<span style="color:#4078f2">. </span>.)&gt;      a INT,
<span style="color:#4078f2">. </span>.)&gt;      b VARCHAR(10)
<span style="color:#4078f2">. </span>.)&gt;  ) WITH (
<span style="color:#4078f2">. </span>.)&gt;      <em>'connector'</em> = <em>'filesystem'</em>,
<span style="color:#4078f2">. </span>.)&gt;      <em>'path'</em> = <em>'file:///tmp/T.csv'</em>,
<span style="color:#4078f2">. </span>.)&gt;      <em>'format'</em> = <em>'csv'</em><span style="color:#4078f2">. </span>.)&gt;  );
No rows affected (0.122 seconds)
<span style="color:#e45649">0: jdbc:flink://localhost:8083&gt; INSERT INTO T VALUES (1, 'Hi'), (2, 'Hello');
+----------------------------------+</span><span style="color:#e45649">|              job id              |
+----------------------------------+</span><span style="color:#e45649">| fbade1ab4450fc57ebd5269fdf60dcfd |
+----------------------------------+</span>
1 row selected (1.282 seconds)
<span style="color:#e45649">0: jdbc:flink://localhost:8083&gt; SELECT * FROM T;
+---+-------+</span><span style="color:#e45649">| a |   b   |
+---+-------+</span>
| 1 | Hi    |
<span style="color:#e45649">| 2 | Hello |
+---+-------+</span>
2 rows selected (1.955 seconds)
0: jdbc:flink://localhost:8083&gt;
</code></pre><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fjdbcdriver%2F" rel="nofollow" target="_blank">文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-293%253A%2BIntroduce%2BFlink%2BJdbc%2BDriver%2BFor%2BSql%2BGateway" rel="nofollow" target="_blank">FLIP-293: Introduce Flink Jdbc Driver For Sql Gateway</a></li></ul><span id="OSC_h4_4"></span><h4>Flink 連接器的存儲過程（Stored Procedure）支持</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">存儲過程（Stored Procedure）在傳統數據庫中一直是不可或缺的工具，它提供了一種方便的方式來封裝用於數據操作和任務管理的複雜邏輯。存儲過程還提供了增強性能的潛力，因為它們可以直接在外部數據庫中觸發數據操作的處理。其他流行的數據系統如 Trino 和 Iceberg 將常見的維護任務自動化並簡化為一小組存儲過程，從而大大減輕了用戶的管理負擔。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">本次更新主要針對 Flink 連接器的開發人員，他們現在可以通過 Catalog 接口預定義自定義存儲過程到連接器中。對用戶的主要好處是，以前需要編寫自定義 Flink 代碼來實現的連接器特定任務現在可以用封裝化、標準化和潛在優化底層操作的簡單調用來替代。用戶可以使用熟悉的 CALL 語法執行存儲過程，並使用 SHOW PROCEDURES 查看連接器的可用存儲過程。連接器內的存儲過程提高了 Flink 的 SQL 和 Table API 的可擴展性，為用戶提供更順暢的數據訪問和管理能力。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">用戶可以使用 Call 語句來直接調用 catalog 內置的存儲過程（注：catalog 內置的存儲過程請參考對應 catalog 的文檔）。比如可以通過如下 Call 語句對 Paimon 表進行 compact 操作：</p><pre><code><span style="color:#a626a4">CREATE</span><span style="color:#a626a4">TABLE</span><span style="color:#50a14f">`paimon`</span>.<span style="color:#50a14f">`default`</span>.<span style="color:#50a14f">`T`</span> ( 
 <span style="color:#a626a4">id</span><span style="color:#c18401">BIGINT</span> PRIMARY <span style="color:#a626a4">KEY</span><span style="color:#a626a4">NOT</span><span style="color:#a626a4">ENFORCED</span>,  
 dt <span style="color:#a626a4">STRING</span>, <em>-- format 'yyyy-MM-dd'  </em>
 v <span style="color:#a626a4">STRING</span>
);

<em>-- use catalog before call </em>
proceduresUSE CATALOG `paimon`;

<em>-- compact the whole table using call statement</em><span style="color:#a626a4">CALL</span> sys.compact(<span style="color:#50a14f">'default.T'</span>);
</code></pre><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fprocedures%2F" rel="nofollow" target="_blank">文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-311%253A%2BSupport%2BCall%2BStored%2BProcedure" rel="nofollow" target="_blank">FLIP-311: Support Call Stored Procedure</a></li></ul><span id="OSC_h4_5"></span><h4>DDL 支持擴展</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">從 1.18 版本開始，Flink 支持以下功能：</p><ul><li>REPLACE TABLE AS SELECT</li><li>CREATE OR REPLACE TABLE AS SELECT</li></ul><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">這兩個命令以及之前支持的 CREATE TABLE AS 現在都支持原子性，前提是底層連接器也支持。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">此外，Apache Flink 現在支持在批處理模式下執行 TRUNCATE TABLE。與以前一樣，底層連接器需要實現並提供此功能。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">最後，我們還實現了通過以下方式支持添加、刪除和列出分區：</p><ul><li>ALTER TABLE ADD PARTITION</li><li>ALTER TABLE DROP PARTITION</li><li>SHOW PARTITIONS</li></ul><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fsql%2Ftruncate%2F" rel="nofollow" target="_blank">TRUNCATE 文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fsql%2Fcreate%2F%23create-or-replace-table" rel="nofollow" target="_blank">CREATE OR REPLACE 文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fsql%2Falter%2F%23alter-table" rel="nofollow" target="_blank">ALTER TABLE 文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-302%253A%2BSupport%2BTRUNCATE%2BTABLE%2Bstatement%2Bin%2Bbatch%2Bmode" rel="nofollow" target="_blank">FLIP-302: Support TRUNCATE TABLE statement in batch mode</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-303%253A%2BSupport%2BREPLACE%2BTABLE%2BAS%2BSELECT%2Bstatement" rel="nofollow" target="_blank">FLIP-303: Support REPLACE TABLE AS SELECT statement</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-305%253A%2BSupport%2Batomic%2Bfor%2BCREATE%2BTABLE%2BAS%2BSELECT%2528CTAS" rel="nofollow" target="_blank">FLIP-305: Support atomic for CREATE TABLE AS SELECT(CTAS) statement</a>+statement)</li></ul><span id="OSC_h4_6"></span><h4>時間旅行（Time Traveling）</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Flink 支持時間旅行（time travel） SQL 語法，用於查詢歷史版本的數據。用戶可以指定一個時間點，來檢索表在該時間點的數據和架構。藉助時間旅行功能，用戶可以輕鬆分析和比較數據的歷史版本。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">例如，用戶可以通過如下的語句查詢一張表指定時間點的數據；</p><pre><code><em>-- 查詢表 `paimon_tb` 在 2022 年 11 月 11 日的數據</em><span style="color:#a626a4">SELECT</span> * <span style="color:#a626a4">FROM</span> paimon_tb <span style="color:#a626a4">FOR</span> SYSTEM_TIME <span style="color:#a626a4">AS</span><span style="color:#a626a4">OF</span><span style="color:#986801">TIMESTAMP</span><span style="color:#50a14f">'2022-11-11 00:00:00'</span>；
</code></pre><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fsql%2Fqueries%2Ftime-travel%2F" rel="nofollow" target="_blank">文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-308%253A%2BSupport%2BTime%2BTravel" rel="nofollow" target="_blank">FLIP-308: Support Time Travel</a></li></ul><span id="OSC_h3_7"></span><h3>流處理提升</h3><span id="OSC_h4_8"></span><h4>Table API &amp; SQL 支持算子級別狀態保留時間（TTL）</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">從 Flink 1.18 版本開始，Table API 和 SQL 用戶可以為有狀態的算子單獨設置狀態保留時間 (TTL)。在像流 regular join 這樣的場景中，用戶現在可以為左側和右側流設置不同的 TTL。在以前的版本中，狀態保留時間只能在 pipeline 級別使用配置項 table.exec.state.ttl 進行控制。引入算子級別的狀態保留後，用戶現在可以根據其具體需求優化資源使用。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fconcepts%2Foverview%2F%23configure-operator-level-state-ttl" rel="nofollow" target="_blank">文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-292%253A%2BEnhance%2BCOMPILED%2BPLAN%2Bto%2Bsupport%2Boperator-level%2Bstate%2BTTL%2Bconfiguration" rel="nofollow" target="_blank">FLIP-292: Enhance COMPILED PLAN to support operator-level state TTL configuration</a></li></ul><span id="OSC_h4_9"></span><h4>SQL 的水印對齊（Watermark Alignment）和空閒檢測（Idleness Detection）</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">現在，您可以使用 SQL Hint 配置<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Fdatastream%2Fevent-time%2Fgenerating_watermarks%2F%23watermark-alignment" rel="nofollow" target="_blank">水印對齊</a>和<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Fdatastream%2Fevent-time%2Fgenerating_watermarks%2F%23dealing-with-idle-sources" rel="nofollow" target="_blank">數據源空閒超時</a>。之前這些功能僅在 DataStream API 中可用。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Ftable%2Fsql%2Fqueries%2Fhints%2F" rel="nofollow" target="_blank">文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-296%253A%2BExtend%2Bwatermark-related%2Bfeatures%2Bfor%2BSQL" rel="nofollow" target="_blank">FLIP-296：Extend watermark-related features for SQL</a></li></ul><span id="OSC_h3_10"></span><h3>批處理提升</h3><span id="OSC_h4_11"></span><h4>Hybrid Shuffle 支持遠程存儲</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Hybrid Shuffle 支持將 Shuffle 數據存儲在遠程存儲中。可以使用配置項 taskmanager.network.hybrid-shuffle.remote.path 配置遠程存儲路徑。Hybrid Shuffle 通過將內存用量與並行度解耦，減少了網絡內存的使用，提高了穩定性和易用性。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fops%2Fbatch%2Fbatch_shuffle%2F%23hybrid-shuffle" rel="nofollow" target="_blank">文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-301%253A%2BHybrid%2BShuffle%2Bsupports%2BRemote%2BStorage" rel="nofollow" target="_blank">FLIP-301: Hybrid Shuffle supports Remote Storage</a></li></ul><span id="OSC_h4_12"></span><h4>性能提升與 TPC-DS 基準測試</h4><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">在之前的版本中，社區投入了大量精力來改進 Flink 的批處理性能，產生了顯著的改進。在這個發佈週期中，社區的貢獻者繼續付出了重大努力，進一步改進了 Flink 的批處理性能。</p><p>Flink SQL 的運行時過濾（Runtime Filter）</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">運行時過濾（Runtime Filter）是用於優化 join 性能的常見方法。它旨在動態生成某些 join 查詢的運行時過濾條件，以減少掃描或 Shuffle 的數據量，避免不必要的 I/O 和網絡傳輸，從而加速查詢。我們在 Flink 1.18 版本引入了運行時過濾，並通過 TPC-DS 基準測試驗證了其有效性，觀察到啓用此功能後，某些查詢的速度提高了 3 倍。</p><p>Flink SQL 算子的融合代碼生成（Operator Fusion Codegen）</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">算子融合代碼生成（Operator Fusion Codegen）通過將算子 DAG 融合成一個經過優化的單算子，消除了虛函數調用，利用 CPU 寄存器進行中間數據操作，並減少指令緩存不命中的情況，從而提高了查詢的執行性能。作為一項技術優化，我們通過 TPC-DS 驗證了其有效性，部分批處理算子（Calc、HashAgg 和 HashJoin）在 1.18 版本中完成了融合代碼生成支持，很多查詢性能顯著提高。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">請注意，上述兩個功能默認情況下處於關閉狀態。可以通過使用 table.optimizer.runtime-filter.enabled 和 table.exec.operator-fusion-codegen.enabled 兩個配置項來啓用它們。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">自 Flink 1.16 以來，Apache Flink 社區一直在通過 TPC-DS 基準測試框架持續跟蹤其批處理引擎的性能。在 Flink 1.17 版本中經過重大改進（動態 join 重排序、動態 local aggregation）後，前面描述的兩項改進（算子融合、運行時過濾）在分區表 10T 數據集上，與 Flink 1.17 相比性能提高了 14%，與 Flink 1.16 相比性能提高了 54%。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><img alt="1" src="https://oscimg.oschina.net/oscnet/up-7127b4e54a13b1ffae35dd7df454a629f62.png" referrerpolicy="no-referrer"></p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-324%253A%2BIntroduce%2BRuntime%2BFilter%2Bfor%2BFlink%2BBatch%2BJobs" rel="nofollow" target="_blank">FLIP-324: Introduce Runtime Filter for Flink Batch Jobs</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-315%2BSupport%2BOperator%2BFusion%2BCodegen%2Bfor%2BFlink%2BSQL" rel="nofollow" target="_blank">FLIP-315: Support Operator Fusion Codegen for Flink SQL</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fververica%2Fflink-sql-benchmark" rel="nofollow" target="_blank">Benchmarking 代碼倉庫</a></li></ul><span id="OSC_h2_13"></span><h2>邁向雲原生彈性化</h2><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">彈性化（Elasticity）描述了系統在不中斷的情況下適應工作負載變化的能力，理想情況下是以自動方式進行。這是雲原生系統的一個定義特徵，對於長時間運行的流處理工作負載尤為重要。因此，彈性性能的改進是 Apache Flink 社區不斷投入的領域。最近的提議包括 Kubernetes<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-kubernetes-operator-docs-release-1.6%2Fdocs%2Fcustom-resource%2Fautoscaler%2F" rel="nofollow" target="_blank">自動縮放器（Autoscaler）</a>、對性能調整的眾多改進，以及<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdeployment%2Felastic_scaling%2F%23adaptive-scheduler" rel="nofollow" target="_blank">自適應調度器（Adaptive Scheduler）</a>。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">自 Flink 1.15 版本首次引入以來，自適應調度器構成了完全彈性 Apache Flink 部署的核心。在其核心功能中，它允許作業在運行時更改其資源要求和並行度。此外，它還根據集羣中可用的資源進行自適應調整，只有當集羣能夠滿足作業的最低所需資源時才會重新調整。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">在 Flink 1.18 版本之前，自適應調度器主要用於<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdeployment%2Felastic_scaling%2F%23reactive-mode" rel="nofollow" target="_blank">響應模式（Reactive Mode）</a>，根據設計，單個作業始終會使用集羣中的所有可用資源。請參閲這篇<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fflink.apache.org%2F2021%2F05%2F06%2Fscaling-flink-automatically-with-reactive-mode%2F" rel="nofollow" target="_blank">博客文章</a>，瞭解如何使用 Kubernetes 上的水平 Pod 自動縮放器自動縮放 Flink 作業。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">在 Flink 1.18 版本中，自適應調度器變得更加強大和更廣泛適用，並正在成為 Apache Flink 流處理任務的默認調度器。</p><span id="OSC_h3_14"></span><h3>通過 REST API 控制動態細粒度擴縮容</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">儘管自適應調度器具有在運行時更改作業資源需求的能力，但此功能之前一直未開放給用戶，自 Flink 1.18 起，在作業運行時，您可以通過 Flink Web UI 和 REST API 更改作業的任何 task 的並行度。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">實現細節上，Apache Flink 在獲得新並行度所需的資源後會立即執行擴縮容操作。擴縮容操作不基於 savepoint，而是基於普通的定期 checkpoint，這意味着它不會引入額外的 snapshot。對於狀態規模較小的作業，重新調整操作幾乎立即發生，且中斷時間非常短。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">與 Apache Flink Web UI 的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fops%2Fmonitoring%2Fback_pressure%2F" rel="nofollow" target="_blank">反壓監控</a>相結合，現在更容易找到並維護使每個任務高效運行、無反壓的並行度。</p><ul><li>如果一個任務非常繁忙（紅色），您可以增加並行度。</li><li>如果一個任務大部分時間處於空閒狀態（藍色），您可以減少並行度。</li></ul><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><img alt="2" src="https://oscimg.oschina.net/oscnet/up-8e76119ef7de7e31d5444226a93ec6a24b0.png" referrerpolicy="no-referrer"></p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-291%253A%2BExternalized%2BDeclarative%2BResource%2BManagement" rel="nofollow" target="_blank">FLIP-291: Externalized Declarative Resource Management</a></li></ul><span id="OSC_h3_15"></span><h3>更快地 RocksDB 擴縮容</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">使用 RocksDB 狀態後端和增量 checkpoint 的擴縮容時間在第 99 百分位數（99th percentile）上提高了約 30%。我們提升了並行下載的能力，從只並行下載狀態句柄（state handle），擴展到並行下載文件。此外，我們關閉了用於擴縮容的臨時 RocksDB 實例在批量插入時的寫前日誌（write-ahead-logging）。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><img alt="3" src="https://oscimg.oschina.net/oscnet/up-5ed594259e7e1a0189a021388cb95a0fd42.png" referrerpolicy="no-referrer"></p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-32326" rel="nofollow" target="_blank">FLINK-32326</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-32345" rel="nofollow" target="_blank">FLINK-32345</a></li></ul><span id="OSC_h2_16"></span><h2>Java 17 支持</h2><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Java 17 於 2021 年發佈，是 Java 的最新長期支持（LTS）版本，將於 2029 年終止支持。從 Flink 1.18 版本開始，您現在可以在 Java 17 上運行 Apache Flink。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhub.docker.com%2F_%2Fflink" rel="nofollow" target="_blank">官方 Docker 倉庫</a>目前已包含基於 Java 17 的鏡像:</p><pre><code>docker pull flink:<span style="color:#986801">1.18</span><span style="color:#986801">.0</span>-java17
</code></pre><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">如果您的集羣運行在 Java 17 上，您的用戶程序中也可以使用 Java 17 的功能，並將其編譯為 Java 17 版本。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdeployment%2Fjava_compatibility%2F" rel="nofollow" target="_blank">文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-15736" rel="nofollow" target="_blank">FLINK-15736</a></li></ul><span id="OSC_h2_17"></span><h2>其他改進</h2><span id="OSC_h3_18"></span><h3>生產可用的水印對齊（Watermark Alignment）功能</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">自 Flink 1.16 和 Flink 1.17 版本以來以 Beta 形式支持的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Fdatastream%2Fevent-time%2Fgenerating_watermarks%2F%23watermark-alignment" rel="nofollow" target="_blank">水印對齊</a>已在實際環境中經過大規模的充分測試。在此期間，社區已經收集並解決了發現的錯誤和性能問題。隨着這些問題的解決，我們推薦水印對齊功能供一般使用。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-32548" rel="nofollow" target="_blank">FLINK-32548</a></li></ul><span id="OSC_h3_19"></span><h3>可插拔式故障處理</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Apache Flink 作為許多公司流處理平台的基礎，也是許多商業流處理服務的基礎。因此，能夠輕鬆集成到內部和供應商平台更廣泛生態系統中的能力變得越來越重要。Catalog 修改監聽器和可插拔式故障處理程序屬於這一類改進。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdeployment%2Fadvanced%2Ffailure_enrichers%2F" rel="nofollow" target="_blank">文檔</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-304%253A%2BPluggable%2BFailure%2BEnrichers" rel="nofollow" target="_blank">FLIP-304: Pluggable Failure Enrichers</a></li></ul><span id="OSC_h3_20"></span><h3>SQL 客戶端的改進</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">在 1.18 版本中，SQL 客戶端進行了一系列的易用性改進：</p><ul><li>客戶端更加多彩，可開啓 SQL 語法突出顯示和切換 7 種不同配色方案。</li><li>更容易編輯和預覽大查詢。</li><li>可隨時關閉和打開行號。</li></ul><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcwiki.apache.org%2Fconfluence%2Fdisplay%2FFLINK%2FFLIP-189%253A%2BSQL%2BClient%2BUsability%2BImprovements" rel="nofollow" target="_blank">FLIP-189: SQL Client Usability Improvements</a></li></ul><span id="OSC_h3_21"></span><h3>Apache Pekko 代替 Akka</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">一年前，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fflink.apache.org%2F2022%2F09%2F08%2Fregarding-akkas-licensing-change%2F" rel="nofollow" target="_blank">Lightbend 宣佈</a>將 Akka 未來版本（2.7+）的許可證從 Apache 2.0 更改為 BSL，Apache Flink 使用的 Akka 2.6 版本將在 2023 年 9 月之前接收安全更新和關鍵錯誤修復。因此在 Flink 1.18 版本，我們決定從 Akka 切換到<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpekko.apache.org%2F" rel="nofollow" target="_blank">Apache Pekko</a>(Incubating)。Apache Pekko (Incubating) 基於 Akka 項目採用商業源代碼許可證之前的 Akka 2.6.x。Pekko 最近發佈了 Apache Pekko 1.0.1-incubating，我們即刻在 Flink 1.18 中進行使用。雖然我們的中期計劃是完全放棄對 Akka 或 Pekko 的依賴（參見<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-29281" rel="nofollow" target="_blank">FLINK-29281</a>），但切換到 Pekko 提供了一個良好的短期解決方案，並確保了 Apache Pekko 和 Apache Flink 社區能夠處理整個軟件供應鏈中的關鍵錯誤修復和安全漏洞。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-32468" rel="nofollow" target="_blank">FLINK-32468</a></li></ul><span id="OSC_h3_22"></span><h3>Calcite 升級</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">在 Apache Flink 1.18 中，Apache Calcite 逐漸從 1.29 版本升級到 1.32 版本。版本升級的帶來的好處包括錯誤修復、更智能的優化器和性能改進。在解析器級別，它現在允許使用括號將 join 操作分組成樹狀結構（SQL-92）。例如 SELECT * FROM a JOIN (b JOIN c ON b.x = c.x) ON a.y = c.y，請參閲<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FCALCITE-35" rel="nofollow" target="_blank">CALCITE-35</a>。此外，升級到 Calcite 1.31+ 解鎖了通過表值函數支持會話窗口（Session Windows via Table-Valued Functions，參見<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FCALCITE-4865" rel="nofollow" target="_blank">CALCITE-4865</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-24024" rel="nofollow" target="_blank">FLINK-24024</a>），並棄用舊的分組窗口聚合（Group Window Aggregations）。由於<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FCALCITE-4861" rel="nofollow" target="_blank">CALCITE-4861</a>，Flink 的強制類型轉換行為略有改變。一些邊界情況現在可能會有不同的行為：例如，從 FLOAT/DOUBLE 9234567891.12 到 INT/BIGINT 的強制類型轉換會產生 Java 的溢出行為。</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>更多信息</strong></p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-27998" rel="nofollow" target="_blank">FLINK-27998</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-28744" rel="nofollow" target="_blank">FLINK-28744</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fissues.apache.org%2Fjira%2Fbrowse%2FFLINK-29319" rel="nofollow" target="_blank">FLINK-29319</a></li></ul><span id="OSC_h2_23"></span><h2>重要 API 棄用</h2><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">為了為明年發佈的 Flink 2.0 版本做準備，社區已經決定正式棄用多個接近生命週期結束的 API。</p><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fflink%2Fblob%2Fmaster%2Fflink-streaming-java%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fflink%2Fstreaming%2Fapi%2Ffunctions%2Fsource%2FSourceFunction.java" rel="nofollow" target="_blank">SourceFunction</a>現在已經棄用。如果您仍在使用基於 SourceFunction 構建的連接器，請將其遷移到<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fflink%2Fblob%2Fmaster%2Fflink-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fflink%2Fapi%2Fconnector%2Fsource%2FSource.java" rel="nofollow" target="_blank">Source</a>。SinkFunction 目前尚未正式棄用，但它也即將接近生命週期結束，將被 SinkV2 所取代。</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-release-1.17%2Fdocs%2Fdev%2Fdatastream%2Ffault-tolerance%2Fqueryable_state%2F" rel="nofollow" target="_blank">Queryable State</a>現已棄用，將在 Flink 2.0 中移除。</li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-release-1.17%2Fdocs%2Fdev%2Fdataset%2Foverview%2F" rel="nofollow" target="_blank">DataSet API</a>現已棄用。建議用戶遷移到<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-stable%2Fdocs%2Fdev%2Fdatastream%2Fexecution_mode%2F" rel="nofollow" target="_blank">執行模式</a>設置為 BATCH 的 DataStream API。</li></ul><span id="OSC_h2_24"></span><h2>升級注意事項</h2><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Flink 社區盡力確保無縫升級。然而，某些變更可能需要用戶在升級到 1.18 版本時對程序的某些部分進行調整。請參考<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnightlies.apache.org%2Fflink%2Fflink-docs-release-1.18%2Frelease-notes%2Fflink-1.18%2F" rel="nofollow" target="_blank">發行説明</a>，以獲取升級過程中需要進行的調整和要檢查的問題的綜合列表。</p><span id="OSC_h2_25"></span><h2>貢獻者列表</h2><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Apache Flink 社區向所有為這個版本的實現做出貢獻的貢獻者表示感謝：</p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">Aitozi, Akinfolami Akin-Alamu, Alain Brown, Aleksandr Pilipenko, Alexander Fedulov, Anton Kalashnikov, Archit Goyal, Bangui Dunn, Benchao Li, BoYiZhang, Chesnay Schepler, Chris Nauroth, Colten Pilgreen, Danny Cranmer, David Christle, David Moravek, Dawid Wysakowicz, Deepyaman Datta, Dian Fu, Dian Qi, Dong Lin, Eric Xiao, Etienne Chauchot, Feng Jin, Ferenc Csaky, Fruzsina Nagy, Gabor Somogyi, Gunnar Morling, Gyula Fora, HaiYang Chen, Hang Ruan, Hangxiang Yu, Hanyu Zheng, Hong Liang Teoh, Hongshun Wang, Huston, Jacky Lau, James Hughes, Jane Chan, Jark Wu, Jayadeep Jayaraman, Jia Liu, JiangXin, Joao Boto, Junrui Lee, Juntao Hu, K.I. (Dennis) Jung, Kaiqi Dong, L, Leomax_Sun, Leonard Xu, Licho, Lijie Wang, Liu Jiangang, Lyn Zhang, Maomao Min, Martijn Visser, Marton Balassi, Mason Chen, Matthew de Detrich, Matthias Pohl, Min, Mingliang Liu, Mohsen Rezaei, Mrart, Mulavar, Nicholas Jiang, Nicolas Fraison, Noah, Panagiotis Garefalakis, Patrick Lucas, Paul Lin, Peter Vary, Piotr Nowojski, Qingsheng Ren, Ran Tao, Rich Bowen, Robert Metzger, Roc Marshal, Roman Khachatryan, Ron, Rui Fan, Ryan Skraba, Samrat002, Sergey Nuyanzin, Sergio Morales, Shammon FY, ShammonFY, Shengkai, Shuiqiang Chen, Stefan Richter, Tartarus0zm, Timo Walther, Tzu-Li (Gordon) Tai, Venkata krishnan Sowrirajan, Wang FeiFan, Weihua Hu, Weijie Guo, Wencong Liu, Xiaogang Zhou, Xintong Song, XuShuai, Yanfei Lei, Yu Chen, Yubin Li, Yun Gao, Yun Tang, Yuxin Tan, Zakelly, Zhanghao Chen, ZhengYiWeng, Zhu Zhu, archzi, baiwuchang, cailiuyang, chenyuzhi, darenwkt, dongwoo kim, eason.qin, felixzh, fengli, frankeshi, fredia, godfrey he, haishui, hehuiyuan, huangxingbo, jiangxin, jiaoqingbo, jinfeng, jingge, kevin.cyj, kristoffSC, leixin, leiyanfei, liming.1018, lincoln lee, lincoln.lil, liujiangang, liuyongvs, luoyuxia, maigeiye, mas-chen, novakov-alexey, oleksandr.nitavskyi, pegasas, sammieliu, shammon, shammon FY, shuiqiangchen, slfan1989, sunxia, tison, tsreaper, wangfeifan, wangkang, whjshj, wuqqq, xiangyu0xf, xincheng.ljr, xmzhou, xuyu, xzw, yuanweining, yuchengxin, yunfengzhou-hub, yunhong, yuxia Luo, yuxiqian, zekai-li, zhangmang, zhengyunhong.zyh, zzzzzzzs, 沈嘉琦</p><hr><span id="OSC_h3_26"></span><h3>更多內容</h3><p style="color:#24292e; margin-left:0; margin-right:0; text-align:center"><img height="910" src="https://oscimg.oschina.net/oscnet/up-43d076aa116b5d091e0d5fd64fd6cd97364.png" width="2584" referrerpolicy="no-referrer"></p><hr><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start"><strong>活動推薦</strong></p><p style="color:#24292e; margin-left:0; margin-right:0; text-align:start">阿里雲基於 Apache Flink 構建的企業級產品-實時計算 Flink 版現開啓活動：<br> 0 元試用<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffree.aliyun.com%2F%3FpipCode%3Dsc" rel="nofollow" target="_blank">實時計算 Flink 版</a>（5000CU*小時，3 個月內）<br> 瞭解活動詳情：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffree.aliyun.com%2F%3FpipCode%3Dsc" rel="nofollow" target="_blank">https://free.aliyun.com/?pipCode=sc</a></p><p style="color:#24292e; margin-left:0px; margin-right:0px; text-align:start"><img height="1280" src="https://oscimg.oschina.net/oscnet/up-f29f46119d7714c79fd0f7baf4854c960f4.png" width="2578" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:29:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/2828172/blog/10136976</guid>
            <link>https://my.oschina.net/u/2828172/blog/10136976</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Fleet 中的 Kotlin 支持：探索 JetBrains 的新 IDE]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><div class="rich_media_content js_underline_content
                       defaultNoSetting
            " id="js_content"><section style="font-size: 15px;line-height: 1.6;letter-spacing: 0px;padding-right: 5px;padding-left: 0px;color: rgb(0, 0, 0);box-sizing: border-box;font-style: normal;font-weight: 400;text-align: justify;margin-bottom: 0px;" data-mpa-powered-by="yiban.io"><section style="text-align: left;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="margin: 30px 0% 10px;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;background-color: rgb(237, 238, 242);align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="display: flex;width: 100%;flex-flow: column;box-sizing: border-box;" powered-by="xiumi.us"><section style="z-index: auto;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: flex;flex-flow: row;justify-content: flex-start;transform: translate3d(18px, 0px, 0px);-webkit-transform: translate3d(18px, 0px, 0px);-moz-transform: translate3d(18px, 0px, 0px);-o-transform: translate3d(18px, 0px, 0px);margin: -16px 0% 0px;box-sizing: border-box;"><section style="display: inline-block;vertical-align: top;width: 15%;flex: 0 0 auto;height: auto;align-self: flex-start;box-sizing: border-box;"><section style="text-align: center;margin: -16px 0px 0px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="1" data-s="300,640" src="https://oscimg.oschina.net/oscnet/d7d41ee0-255e-45b1-b525-8f3fc5d21f72.png" data-w="707" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: top;width: auto;flex: 0 0 auto;align-self: flex-start;min-width: 10%;max-width: 100%;height: auto;box-sizing: border-box;"><section style="transform: translate3d(5px, 0px, 0px);-webkit-transform: translate3d(5px, 0px, 0px);-moz-transform: translate3d(5px, 0px, 0px);-o-transform: translate3d(5px, 0px, 0px);box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;color: rgb(115, 119, 173);padding: 0px 7px;line-height: 1.2;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="box-sizing: border-box;"><strong style="box-sizing: border-box;">記得加關注， Kotlin 之路不迷路！</strong></span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: justify;font-size: 12px;line-height: 1.2;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="color: transparent;background-image: linear-gradient(to right, rgb(36, 113, 228), rgb(250, 40, 88));display: inline-block;-webkit-background-clip: text;box-sizing: border-box;">&nbsp; &nbsp; Kotlinlang.org</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section></section></section></section></section></section></section></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247486951%26idx%3D1%26sn%3Dd1bf11e8ae42331d24bc993bc2a91213%26chksm%3Dc08860b9f7ffe9af87765cb145573b765ef3543c80b72c924f6282e99b96acb04775667ad84f%26scene%3D21%23wechat_redirect" textvalue="JetBrains Fleet" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2"><strong style="box-sizing: border-box;">JetBrains Fleet</strong></a>&nbsp;是一款輕量型代碼編輯器和 IDE，使用 IntelliJ 代碼處理引擎。該產品目前處於<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNDI5NzUyMQ%3D%3D%26mid%3D2247491483%26idx%3D1%26sn%3D7ef92a11da98c89c18feb4d97185a872%26chksm%3Dc08872c5f7fffbd3da3621d9e6311bdca0e9abc325fdc537af83f282e9ee9107b62892a05c29%26scene%3D21%23wechat_redirect" textvalue="公開預覽版" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2"><strong style="box-sizing: border-box;">公開預覽版</strong></a>階段，供公眾試用。</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">目前，Fleet 允許您使用 Python、TypeScript / JavaScript、Go、Java、PHP、C# 以及 Kotlin 等流行語言進行開發。<strong>Kotlin 支持是最先進的支持之一，因為 Fleet 主要使用 Kotlin 開發而成，JetBrains 團隊也使用 Fleet 開發 Fleet。</strong>您可以查看<strong style="box-sizing: border-box;">完整的 Fleet 功能矩陣</strong><sup style="box-sizing: border-box;">1</sup>，瞭解該產品已經支持哪些語言和技術以及哪些仍在開發。藉助即將推出的插件，Fleet 也將盡快支持更多語言和技術。</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">在這篇博文中，我們想詳細介紹 Fleet 公開預覽版中 Kotlin 支持的當前狀態，包括適用於 Kotlin 項目的 IDE 功能的概述。</p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="text-align: center;justify-content: center;display: flex;flex-flow: row;margin: 10px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 48px;align-self: center;flex: 0 0 auto;height: auto;box-sizing: border-box;"><section style="margin-top: 10px;margin-bottom: 10px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;width: 80%;height: auto;box-sizing: border-box;"><img data-s="300,640" src="https://oscimg.oschina.net/oscnet/bbc93270-e7bd-4cc9-9e15-fdbbd532751e.png" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" data-ratio="1" data-w="500" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: auto;align-self: center;flex: 100 100 0%;height: auto;padding: 0px 0px 0px 10px;box-sizing: border-box;"><section style="text-align: left;margin: 10px 0px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgb(42, 8, 69);font-size: 22px;line-height: 1.2;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">為什麼選擇 Fleet？</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 2px 0px 8px;box-sizing: border-box;" powered-by="xiumi.us"><section style="background-color: rgb(120, 85, 245);height: 1px;box-sizing: border-box;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Fleet 基於我們多年的 IDE 開發經驗從頭開始構建而成。它結合了輕量型文本編輯器的簡單和速度，還有智能開發環境的變革能力。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><strong>Fleet 並不是為了取代或複製 JetBrains 的現有 IDE 而設計。</strong>Fleet 背後的主要理念是為開發者提供智能、多語言工具和工作流的新體驗，例如分佈式協作開發，以及生成式 AI 編碼。JetBrains 在開發 Fleet 的同時也在繼續開發現有 IDE。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="text-align: center;justify-content: center;display: flex;flex-flow: row;margin: 10px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 48px;align-self: center;flex: 0 0 auto;height: auto;box-sizing: border-box;"><section style="margin-top: 10px;margin-bottom: 10px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;width: 80%;height: auto;box-sizing: border-box;"><img data-s="300,640" src="https://oscimg.oschina.net/oscnet/bbc93270-e7bd-4cc9-9e15-fdbbd532751e.png" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" data-ratio="1" data-w="500" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: auto;align-self: center;flex: 100 100 0%;height: auto;padding: 0px 0px 0px 10px;box-sizing: border-box;"><section style="text-align: left;margin: 10px 0px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgb(42, 8, 69);font-size: 22px;line-height: 1.2;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;"><span style="letter-spacing: 0px;box-sizing: border-box;">Fleet Smart Mode（智能模式）</span><span style="text-align: unset;letter-spacing: 0px;box-sizing: border-box;">下</span><span style="text-align: unset;letter-spacing: 0px;box-sizing: border-box;">適用於 Kotlin 的功能</span></strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 2px 0px 8px;box-sizing: border-box;" powered-by="xiumi.us"><section style="background-color: rgb(120, 85, 245);height: 1px;box-sizing: border-box;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Fleet 開箱即支持 Kotlin，這就使得該語言的使用不僅高效簡單，並且令人愉悅。它為 Kotlin 開發者提供了簡化的體驗。需要快速深入項目、分析其結構，以及立即進行有針對性的編輯時，您可以使用 Fleet 作為編輯器。但是，如果需要更強大的功能，它可以轉換為全功能 IDE。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">如果您想在 Kotlin 中啓用代碼智能功能，則應打開<strong style="box-sizing: border-box;">&nbsp;Smart Mode（智能模式）</strong><sup style="font-size: 11px;box-sizing: border-box;">2</sup>。這些額外功能有助於避免錯誤，同時更快、更高效地編寫代碼。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.4266666666666667" data-s="300,640" src="https://oscimg.oschina.net/oscnet/1023290c-073e-42fe-9a58-15d488de05f9.gif" data-w="600" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">啓用 Smart Mode（智能模式）後，即可使用 IntelliJ IDEA 用戶熟悉和喜愛的代碼編輯功能，包括：</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><ul class="list-paddingleft-1" style="list-style-type: disc;box-sizing: border-box;padding-left: 40px;list-style-position: outside;"><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">代碼補全</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">代碼操作</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">類型信息和形參信息</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">實時模板</p></li><li style="box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">代碼生成</p></li></ul></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">我們來仔細看看這些功能以及它們將如何簡化您的編碼方式。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 18px;color: rgb(120, 85, 245);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">代碼補全</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">當您輸入時，Fleet 會根據各種因素，例如可用的代碼智能服務、項目結構、環繞代碼和符號可見性，提供代碼補全建議。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;">補全建議可以自動顯示，也可以通過按&nbsp;<em style="box-sizing: border-box;">Ctrl+空格鍵</em>手動激活。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.37222222222222223" data-s="300,640" src="https://oscimg.oschina.net/oscnet/0b462a95-7426-4984-a63f-16a07f581f31.png" data-w="1080" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 18px;color: rgb(120, 85, 245);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">代碼操作</strong></p></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">藉助持續代碼質量分析，您可以做出明智的決策並提高編碼效率。Fleet 建議的操作根據您所處的特定上下文量身定製。這些建議涵蓋從糾正錯誤到重構文本光標處的代碼等一系列操作。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.48333333333333334" data-s="300,640" src="https://oscimg.oschina.net/oscnet/d5158516-45c3-43db-8e8c-a1bc57c46a7e.gif" data-w="600" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">您可以按&nbsp;<em style="box-sizing: border-box;">Opt+Enter</em>&nbsp;(macOS) 或<em style="box-sizing: border-box;">&nbsp;Alt+Enter</em>（Windows 和 Linux）檢查文本光標處的可用操作。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">決定待使用的操作後，您可以立即應用，也可以使用快捷鍵預覽結果：macOS 為<em style="box-sizing: border-box;">&nbsp;Cmd+P</em>，Windows 和 Linux 為&nbsp;<em style="box-sizing: border-box;">Ctrl+P</em>。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.48333333333333334" data-s="300,640" src="https://oscimg.oschina.net/oscnet/45604de1-3484-4b1a-9827-d5a13a82a473.gif" data-w="600" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 18px;color: rgb(120, 85, 245);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">類型信息</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">如果您不確定當前正在處理的類型，可以按&nbsp;<em style="box-sizing: border-box;">Cmd+Shift+T</em>&nbsp;(macOS) 或&nbsp;<em style="box-sizing: border-box;">Ctrl+Shift+T</em>（Windows 和 Linux）輕鬆查找。&nbsp;</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">這將提示 Fleet 顯示有關符號或表達式的靜態類型的詳細信息。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.19189765458422176" data-s="300,640" src="https://oscimg.oschina.net/oscnet/0d0a5755-3ac2-4ce7-b2c3-ea0ab4c220ce.png" data-w="938" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 18px;color: rgb(120, 85, 245);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">形參信息</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">您是否使用具有大量重載的方法，或者需要快速找到必要形參？按<em style="box-sizing: border-box;">&nbsp;Cmd+I</em>&nbsp;(macOS) 或<em style="box-sizing: border-box;">&nbsp;Ctrl+I</em>（Windows 和 Linux）即可瀏覽可用選項。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.29814814814814816" data-s="300,640" src="https://oscimg.oschina.net/oscnet/5cefda5a-ccd1-4b0f-b0d2-09ed6d57832c.png" data-w="1080" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 18px;color: rgb(120, 85, 245);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">實時模板</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">Fleet 提供了一組 Kotlin 實時模板，您可以在代碼中插入常見結構，如循環、條件、聲明或打印語句。與 IntelliJ IDEA 不同，Fleet 不允許創建新模板。不過，您可以在 Kotlin 代碼中使用大量預製模板。Fleet 文檔包含<strong style="box-sizing: border-box;"><span style="color: rgb(62, 62, 62);box-sizing: border-box;">實時模板的完整列表</span></strong><sup style="font-size: 11px;box-sizing: border-box;">3</sup>。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.4666666666666667" data-s="300,640" src="https://oscimg.oschina.net/oscnet/8019dfa0-efe9-4f73-9736-a48bdea35fcb.gif" data-w="600" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 18px;color: rgb(120, 85, 245);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">代碼生成</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">在您開始輸入特定方法或語句時，Fleet 會根據上下文和現有代碼建議可能的補全選項。選擇一個建議即可立即生成所需代碼。您可以利用代碼補全重寫超類成員，例如 equals()、hashcode() 和其他方法。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.16018518518518518" data-s="300,640" src="https://oscimg.oschina.net/oscnet/4746b9c4-2243-447d-8f04-f5ab67797838.png" data-w="1080" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: unset;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;">使用代碼生成，您可以節省時間，並確保代碼遵循正確的語法和結構，因為 Fleet 可以幫助您生成必要的代碼段。</p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="text-align: center;justify-content: center;display: flex;flex-flow: row;margin: 10px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;vertical-align: middle;width: 48px;align-self: center;flex: 0 0 auto;height: auto;box-sizing: border-box;"><section style="margin-top: 10px;margin-bottom: 10px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;width: 80%;height: auto;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="1" data-s="300,640" src="https://oscimg.oschina.net/oscnet/bbc93270-e7bd-4cc9-9e15-fdbbd532751e.png" data-w="500" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" referrerpolicy="no-referrer"></section></section></section><section style="display: inline-block;vertical-align: middle;width: auto;align-self: center;flex: 100 100 0%;height: auto;padding: 0px 0px 0px 10px;box-sizing: border-box;"><section style="text-align: left;margin: 10px 0px 0px;box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgb(42, 8, 69);font-size: 22px;line-height: 1.2;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">試用 Fleet 並分享您的體驗</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 2px 0px 8px;box-sizing: border-box;" powered-by="xiumi.us"><section style="background-color: rgb(120, 85, 245);height: 1px;box-sizing: border-box;"><svg viewBox="0 0 1 1" style="float:left;line-height:0;width:0;vertical-align:top;"></svg></section></section></section></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">Fleet 是一款多語言代碼編輯器和 IDE，支持 Kotlin 等多種語言。您可以將 Fleet 視為一種多用途工具，並期望特定類型的項目後續獲得專屬支持。</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">如果您有興趣並且發現了新工具的好用途，我們邀請您親自上手探索 Fleet 功能！</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">下載並開始使用 Fleet 的最簡單方式是使用免費的&nbsp;<strong style="box-sizing: border-box;">JetBrains Toolbox App</strong><sup style="font-size: 11px;box-sizing: border-box;">4</sup>。</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">您也可以觀看這個簡短的 Fleet 概覽視頻幫助您入門，以及參閲<strong style="box-sizing: border-box;">文檔</strong><sup style="font-size: 11px;box-sizing: border-box;">5</sup>獲取進一步指導。</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><section class="channels_iframe_wrp"><mp-common-videosnap class="js_uneditable custom_select_card channels_iframe videosnap_video_iframe" data-pluginname="mpvideosnap" data-url="https://findermp.video.qq.com/251/20304/stodownload?encfilekey=S7s6ianIic0ia4PicKJSfB8EjyjpQibPUAXol1WXnS32s8hOA3RTibrGzhjvMNxgtTBicialbyyKKxIjbZuq53dZyNBldvbjgu2glJgFfqWrbIwNzKRlAJIATvqafA&amp;adaptivelytrans=0&amp;bizid=1023&amp;dotrans=0&amp;hy=SH&amp;idx=1&amp;m=&amp;scene=0&amp;token=x5Y29zUxcibBibbOsfyoFM1Xgzc7qHewxsqpBicZS8u7qJReXaGvg1gvG6bn1QtfmUk6th1DKGulh4" data-headimgurl="http://wx.qlogo.cn/finderhead/0nn3FBrD9a1RrlqKFBkoafxwpIL3ud40TkWcw5qOoYibKzYxvDA2hew/0" data-username="v2_060000231003b20faec8c4e48811c7dccb00ec34b077f60e877e2e3d611e57ac6b6b589aa577@finder" data-nickname="JetBrains" data-desc="#Fleet 是我們全新的分佈式多語言編輯器和 #IDE，正面向所有人開放公共預覽。它基於我們在後端的 IntelliJ 平台，並採用全新的用戶界面和分佈式架構從頭開始構建。要了解更多詳情，請至 Fleet 產品頁面：https://www.jetbrains.com.cn/fleet @JetBrains " data-nonceid="2085350396973162235" data-type="video" data-mediatype="    " data-authiconurl="https://dldir1v6.qq.com/weixin/checkresupdate/icons_filled_channels_authentication_enterprise_a2658032368245639e666fb11533a600.png" data-from="new" data-width="1920" data-height="1080" data-id="export/UzFfAgtgekIEAQAAAAAA_38x2YoPwwAAAAstQy6ubaLX4KHWvLEZgBPEt4JIOlEYX5aCzNPgMItlLEUdCyfEPAQ6EF-gJfP5" data-isdisabled="0" data-errortips=""></mp-common-videosnap></section><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">Fleet 仍處於預覽版階段，正在積極開發中。您的反饋和意見將幫助 JetBrains 團隊穩定和改進產品。如果遇到問題，請向此<strong style="box-sizing: border-box;">問題跟蹤器</strong><sup style="font-size: 11px;box-sizing: border-box;">6</sup>提交報告。您也可以發送電子郵件至&nbsp;<span style="color: rgb(51, 122, 183);box-sizing: border-box;">fleet-support@jetbrains.com</span>&nbsp;與我們聯繫。</p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;">敬請期待更多公告！</p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><br style="box-sizing: border-box;"></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="text-align: left;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="margin: 10px 0% 8px;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;padding: 0px 0px 0px 8px;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="color: rgba(0, 0, 0, 0.5);text-align: justify;font-size: 12px;box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">本博文英文原作者：</strong></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">Daria Voronina</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section></section></section></section></section><section style="margin-top: 10px;margin-bottom: 10px;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;border-width: 1px;border-style: solid;border-color: rgb(120, 85, 245);padding: 10px;box-shadow: rgb(204, 204, 204) 0.2em 0.2em 0.3em;box-sizing: border-box;"><section style="box-sizing: border-box;" powered-by="xiumi.us"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">相關鏈接：</strong></p><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: left;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">1. 完整的 Fleet 功能矩陣：</span></p><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://docs.google.com/spreadsheets/u/1/d/e/2PACX-1vTWt9RlJPfIJwD5H7Gsqbu9xHTd-K1oj_zCpP6YIQq8xvjARDYqC6OnVIVt5WPi2-B-vWHZw5qMnhvx/pubhtml</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="text-align: left;box-sizing: border-box;"><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">2. Smart Mode（智能模式）：&nbsp;</span></p><p style="margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://www.jetbrains.com.cn/en-us/help/fleet/smart-mode.html</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">3. 實時模板的完整列表：</span></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://www.jetbrains.com.cn/help/fleet/live-templates-list-kotlin.html</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">4. JetBrains Toolbox App：</span></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://www.jetbrains.com.cn/fleet/download/</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">5. 文檔：</span></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://www.jetbrains.com.cn/help/fleet/getting-started.html</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="box-sizing: border-box;" powered-by="xiumi.us"><section style="box-sizing: border-box;"><p style="text-align: left;white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;box-sizing: border-box;">6. 問題跟蹤器:&nbsp;</span></p><p style="text-align: left;white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><span style="font-size: 14px;color: rgb(51, 122, 183);box-sizing: border-box;">https://youtrack.jetbrains.com/issues/FL</span></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section></section></section><section style="margin: 10px 0% 0px;text-align: left;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;background-position: 97.529% 66.6681%;background-repeat: repeat;background-size: 171.01%;background-attachment: scroll;align-self: flex-start;flex: 0 0 auto;height: auto;background-image: url(&quot;https://oscimg.oschina.net/oscnet/6a0c66f8-0a97-4863-a1b7-e027000fd10f.png&quot;);box-sizing: border-box;"><section style="text-align: justify;justify-content: flex-start;display: flex;flex-flow: row;box-sizing: border-box;" powered-by="xiumi.us"><section style="display: inline-block;width: 100%;vertical-align: top;padding: 26px;align-self: flex-start;flex: 0 0 auto;box-sizing: border-box;"><section style="margin: -9px 0px 7px;box-sizing: border-box;" powered-by="xiumi.us"><section style="font-size: 16px;color: rgb(248, 248, 248);box-sizing: border-box;"><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">這就是 Kotlin 編程語言</strong></p><p style="white-space: normal;margin: 0px;padding: 0px;box-sizing: border-box;"><strong style="box-sizing: border-box;">簡潔、跨平台、且有趣！</strong></p></section><grazie-editor-wrapper style="box-sizing: border-box;"></grazie-editor-wrapper></section><section style="margin: 0px;box-sizing: border-box;" powered-by="xiumi.us"><section class="mp_profile_iframe_wrp" style="box-sizing: border-box;"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-id="Mzg4MzkxMzg3MQ==" data-pluginname="mpprofile" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/y4ibuu6gd7d4NyzPduLLqtqddBasicL77gAgbLQD89CyYm1n7icODFhBr3xMoloOA7yicfjR8Bv0oaRP3CJuRLIO4Q/0?wx_fmt=png" data-nickname="Kotlin 開發者" data-alias="" data-signature="現代、簡潔、安全的編程語言，由 JetBrains 打造。面向服務器、Android、Web 和原生平台，提供多種在平台間重用代碼的方式以實現高效編程。官網：kotlinlang.org" data-from="0" data-is_biz_ban="0"></mp-common-profile></section></section><section style="text-align: center;margin: 7px 0px 0px;line-height: 0;box-sizing: border-box;" powered-by="xiumi.us"><section style="max-width: 100%;vertical-align: middle;display: inline-block;line-height: 0;width: 45%;height: auto;box-sizing: border-box;"><img class="rich_pages wxw-img" data-ratio="0.4119760479041916" data-s="300,640" src="https://oscimg.oschina.net/oscnet/3fb2fe5a-fbfb-4b28-b55d-9c8dcfa3db81.png" data-w="835" style="vertical-align: middle;max-width: 100%;width: 100%;box-sizing: border-box;" width="100%" referrerpolicy="no-referrer"></section></section></section></section></section></section></section><p style="display: none;margin-bottom: 0px;"><mp-style-type data-value="10000"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公眾號 - JetBrains（JetBrainsChina）。<br>如有侵權，請聯繫 support@oschina.cn 刪除。<br>本文參與「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源創計劃</a>」，歡迎正在閲讀的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:27:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5494143/blog/10136803</guid>
            <link>https://my.oschina.net/u/5494143/blog/10136803</link>
            <author>
                <![CDATA[JetBrains 中國]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[B 站：全年「AIGC」相關視頻播放量 90 億]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p><span style="color:#000000">嗶哩嗶哩 (B 站) 日前在其首屆「bilibili 超級科學晚」會上，發佈了一個「五大科學焦點榜單」—— AIGC、室溫超導、腦機接口、黑洞、可控核聚變入選。</span></p><p><span style="color:#000000">並公佈數據稱，過去一年有 2.43 億用戶在 B 站進行學習，是中國在校大學生人數的 5.5 倍。B 站泛知識內容消費人羣中，有 72% 為 00 後。</span></p><p><span style="color:#000000">科學和知識品類佔 B 站用戶搜索排名第 2 位，相關內容播放量佔 B 站 41%，00 後正在成為科學內容消費主力。全年「AIGC」相關視頻播放量 90 億，播放時長達 140 億分鐘。全站 UP 主圍繞 ChatGPT、文心一言、盤古氣象等多個大模型發佈動向，共投稿 330 萬支視頻，是無可爭議的 2023 年熱度最高科學技術領域。</span></p><p><span style="color:#000000">截至目前，B 站累計入駐知識類 UP 主 300 餘萬人。</span></p><p><span style="color:#000000"><img alt="" height="1596" src="https://oscimg.oschina.net/oscnet/up-8324fab9d8b85f93db34425ec9fc991cf4b.jpg" width="350" referrerpolicy="no-referrer"></span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264039</guid>
            <link>https://www.oschina.net/news/264039</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[jQuery 4.0 開發進度：已完成 99%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>根據 jQuery 的 GitHub 里程碑狀態，其 4.0.0 版本的開發進度已完成 99%。</p><p><img height="1018" src="https://static.oschina.net/uploads/space/2023/1030/105430_Ecrh_2720166.png" width="2170" referrerpolicy="no-referrer"></p><p><em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjquery%2Fjquery%2Fmilestone%2F7" target="_blank">https://github.com/jquery/jquery/milestone/7</a></u></em></p><p>可以看到，目前待處理的 issue 僅剩一個，其內容是升級與 ESLint 相關的軟件包，以及修復 linting 錯誤。已經處理完畢的 issue 共計 163 個，內容包括核心變更、構建變更、與 Ajax 相關的改動等，詳情查看&nbsp;<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjquery%2Fjquery%2Fmilestone%2F7%3Fclosed%3D1" target="_blank">https://github.com/jquery/jquery/milestone/7?closed=1</a></u>。</p><p><img src="https://static.oschina.net/uploads/space/2023/1030/111012_2yQh_2720166.png" referrerpolicy="no-referrer"></p><blockquote><p>jQuery 是一個快速、小型且功能豐富的 JavaScript 庫。通過易於使用的 API（可在多種瀏覽器中使用），使 HTML 文檔的遍歷和操作、事件處理、動畫和 Ajax 等操作變得更加簡單。結合了多功能性和可擴展性，jQuery 改變了數百萬人編寫 JavaScript 的方式。</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:10:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264038/jquery-4-0-milestone-99-percent-complete</guid>
            <link>https://www.oschina.net/news/264038/jquery-4-0-milestone-99-percent-complete</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[KubeSphere 社區雙週報 | KubeKey 支持 Web UI]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p>KubeSphere 社區雙週報主要整理展示新增的貢獻者名單和證書、新增的講師證書以及兩週內提交過 commit 的貢獻者，並對近期重要的 PR 進行解析，同時還包含了線上/線下活動和佈道推廣等一系列社區動態。</p><p>本次雙週報涵蓋時間為：2023.10.13-2023.10.26。</p><h2>貢獻者名單</h2><p><img src="https://oscimg.oschina.net/oscnet/up-1a76ec80c43e7bcb348d4c83f3acd397fe2.gif" alt="" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-a1db65d7a7a9dd815a333a3f0f7cac20dde.png" alt="" referrerpolicy="no-referrer"></p><h2>新晉 KubeSphere Contributor</h2><p>兩週內共有 7 位新晉 KubeSphere Contributor，包括在社區分享最佳實踐經驗的小夥伴，感謝各位對 KubeSphere 社區的貢獻！</p><table><thead><tr><th>GitHub ID</th><th>證書</th></tr></thead><tbody><tr><td>Hanmo123</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-Hanmo123.png" target="_blank">下載證書</a></td></tr><tr><td>JoeDerby</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-JoeDerby.png" target="_blank">下載證書</a></td></tr><tr><td>SongJXin</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-SongJXin.png" target="_blank">下載證書</a></td></tr><tr><td>gunine</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-gunine.png" target="_blank">下載證書</a></td></tr><tr><td>jongwooo</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-jongwooo.png" target="_blank">下載證書</a></td></tr><tr><td>studyingwang23</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-studyingwang23.png" target="_blank">下載證書</a></td></tr><tr><td>Leirong Luo</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpek3b.qingstor.com%2Fkubesphere-community%2Fimages%2Fcontributor-2023-luoleirong.png" target="_blank">下載證書</a></td></tr></tbody></table><h2>近期更新</h2><h3>KubeSphere</h3><h4>1. 修復 K8s 1.26+ 環境中網管地址未正確展示的問題</h4><p>相關 PR：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubesphere%2Fkubesphere%2Fpull%2F5950" target="_blank">https://github.com/kubesphere/kubesphere/pull/5950</a></p><p>貢獻者：hongzhouzi</p><h4>2. 修復應用更新時間不正確的問題</h4><p>相關 PR：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubesphere%2Fkubesphere%2Fpull%2F5948" target="_blank">https://github.com/kubesphere/kubesphere/pull/5948</a></p><p>貢獻者：king-119</p><h4>3. 鏡像 tag 列表默認按名稱排序</h4><p>相關 PR：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubesphere%2Fkubesphere%2Fpull%2F5957" target="_blank">https://github.com/kubesphere/kubesphere/pull/5957</a></p><p>貢獻者：zhou1203</p><h3>KubeKey</h3><h4>1. 支持 Web UI</h4><p>相關 PR：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubesphere%2Fkubekey%2Fpull%2F2007" target="_blank">https://github.com/kubesphere/kubekey/pull/2007</a></p><p>貢獻者：shijilin0116</p><h2>社區動態</h2><ul><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NTU0MzEyMg%3D%3D%26mid%3D2247526348%26idx%3D1%26sn%3Dbc88cb295e3d769a8bf7f2f94b17dab7%26chksm%3Dcfa57e71f8d2f7670a55352fd93aafb57f990c2ab407e0996c63888aeb085aa765d61507e31c%26token%3D1638355988%26lang%3Dzh_CN%23rd" target="_blank">ARM 版 openEuler 22.03 部署 KubeSphere v3.4.0 不完全指南</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4NTU0MzEyMg%3D%3D%26mid%3D2247526431%26idx%3D1%26sn%3D035ab125b4109ab78c685b5eba12ab4d%26chksm%3Dcfa571a2f8d2f8b435a22c90e1fec21e4ebd58270e9e2ddd1d292faf77ce79c06026b2402bf0%26token%3D1638355988%26lang%3Dzh_CN%23rd" target="_blank">11 月 4 日成都站 Meetup 分享內容詳情曝光！</a></li></ul><blockquote><p>本文由博客一文多發平台 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenwrite.cn%3Ffrom%3Darticle_bottom" target="_blank">OpenWrite</a> 發佈！</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 03:03:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4197945/blog/10138824</guid>
            <link>https://my.oschina.net/u/4197945/blog/10138824</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Vercel 發佈免費開源字體 Geist]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>Vercel 公司發佈了一款免費開源字體 ——<strong>「<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvercel.com%2Ffont" target="_blank">Geist</a>」</strong>，稱專門面向設計師和開發者而設計。</p><blockquote><p><em>開源地址：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvercel%2Fgeist-font" target="_blank">https://github.com/vercel/geist-font</a></u><br> 下載地址：</em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvercel%2Fgeist-font%2Freleases%2Ftag%2F1.0.0" target="_blank">https://github.com/vercel/geist-font/releases/tag/1.0.0</a></u></p></blockquote><p>Geist 字體由 Vercel 與 Basement Studio 聯手打造，包含<strong> Geist Sans 和 Geist Mono</strong>，分別對應的是<strong>無襯線字體</strong>和<strong>等寬字體</strong>。</p><p>根據官方的介紹，Geist Sans 作為無襯線字體，其設計理念是易讀和簡潔。它是一種現代的幾何字體，基於經典的瑞士字體設計原則打造，被設計用於標題、徽標、海報和其他大尺寸顯示屏。</p><p>Geist Mono 則是 Geist Sans 的完美搭檔。作為等寬字體，它被設計用於代碼編輯器、圖表、終端和其他以文本為基礎的代碼界面。目前提供的版本優先考慮可讀性，並支持無縫集成到編碼環境中。</p><h4><strong>Geist 字體預覽效果</strong></h4><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e79e19a1fd7bb59d7c6f9780a4b6b40cefd.png" referrerpolicy="no-referrer"></p><p>此外，Geist 受到以下字體的影響和啓發：Inter、Univers、SF Mono、SF Pro、Suisse International、ABC Diatype Mono 和 ABC Diatype。</p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 02:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/264031/vercel-geist-font</guid>
            <link>https://www.oschina.net/news/264031/vercel-geist-font</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Weaviate —— 開源向量數據庫]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="project_detail_above_text_link_1" data-tracepid="project_detail_above_text_link"><a style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代 <img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p><span><span><span>Weaviate 是一個開源向量數據庫，</span></span></span><span style="background-color:#ffffff; color:#1f2328">具有強大、可擴展、雲原生且快速的特點。</span><span><span><span>可存儲對象和向量，允許將向量搜索與結構化過濾與雲原生數據庫的容錯性和可擴展性相結合，所有這些都可以通過 GraphQL、REST 和各種語言客戶端進行訪問。</span></span></span></p><p><span style="color:#000000">允許你存儲來自你最喜歡的 ML 模型的數據對象和向量嵌入，並無縫擴展到數十億個數據對象。</span></p><p style="margin-left:0px; margin-right:0px; text-align:start"><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span><strong>簡而言之</strong>：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>Weaviate 是一個開源<a href="https://weaviate.io/blog/what-is-a-vector-database" target="_blank">向量數據庫</a>。</li><li><a href="https://weaviate.io/developers/weaviate/concepts/vector-index">Weaviate 允許你通過使用向量索引</a>來根據數據對象的語義屬性來存儲和檢索數據對象。</li><li>Weaviate 可以獨立使用<span style="background-color:#ffffff; color:#000000">&nbsp;(aka<span>&nbsp;</span></span>bring your vectors<span style="background-color:#ffffff; color:#000000">)<span>&nbsp;</span></span>，也可以與各種可以為您進行向量化並擴展核心功能的<a href="https://weaviate.io/developers/weaviate/modules">模塊一起使用。</a></li><li>Weaviate 具有<a href="https://weaviate.io/developers/weaviate/api/graphql">GraphQL-API</a>，可輕鬆訪問你的數據。</li><li>Weaviate 速度很快（查看<a href="https://weaviate.io/developers/weaviate/benchmarks">開源基準測試</a>）。</li></ul><p>Weaviate 是一個低延遲向量數據庫，對不同媒體類型（文本、圖像等）提供開箱即用的支持。它提供語義搜索、問答提取、分類、可定製模型 (PyTorch/TensorFlow/Keras) 等。Weaviate 以 Go 語言從頭開始構建，同時存儲對象和向量，從而將向量搜索與結構化過濾和雲原生數據庫的容錯性結合起來。所有這些都可以通過 GraphQL、REST 和各種客戶端編程語言進行訪問。</p><p style="margin-left:0px; margin-right:0px; text-align:start"><span><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Weaviate 可以輕鬆使用最先進的 AI 模型，同時提供專用向量數據庫的可擴展性、易用性、安全性和成本效益。最為顯着地：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>快速查詢</strong><br>
Weaviate 通常在不到 100 毫秒的時間內對數百萬個對象執行最近鄰 (NN) 搜索。<a href="https://weaviate.io/developers/weaviate/benchmarks">可以在我們的基準</a>頁面上找到更多信息。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>使用 Wea​​viate 模塊攝取任何媒體類型</strong><br>
使用最先進的 AI 模型推理（例如 Transformer）在搜索和查詢時訪問數據（文本、圖像等），讓 Weaviate 管理數據矢量化過程為你 - 或提供你自己的向量。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>組合向量和標量搜索</strong><br>
Weaviate 可以進行高效的組合向量和標量搜索。例如，「過去 7 天內發表的與 COVID-19 大流行相關的文章」。Weaviate 存儲對象和向量，並確保兩者的檢索始終高效。不需要第三方對象存儲。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>實時且持久的</strong><br>
Weaviate 讓你可以搜索數據，即使當前正在導入或更新數據。此外，每次寫入都會寫入預寫日誌 (WAL)，以便立即持久寫入 - 即使發生崩潰也是如此。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>水平可擴展性</strong></span></span></span></span><br><span style="background-color:#ffffff; color:#000000">Scale</span>&nbsp;<span><span><span><span>Weaviate 滿足你的確切需求，例如最大攝取量、最大可能的數據集大小、每秒最大查詢數等。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>高可用性</strong><br>
已列入<a href="https://weaviate.io/developers/weaviate/roadmap">路線圖</a>，並計劃於今年晚些時候發佈。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>成本效益</strong><br>
非常大的數據集不需要完全保存在 Weaviate 的內存中。同時，可以利用可用內存來提高查詢速度。這樣可以有意識地進行速度/成本權衡，以適應每個用例。</span></span></span></span></p></li><li><p style="margin-left:0px; margin-right:0px"><span><span><span><span><strong>對象之間的類似圖形的連接</strong><br>
以類似圖形的方式在對象之間建立任意連接，以類似於數據點之間的真實連接。使用 GraphQL 遍歷這些連接。</span></span></span></span></p></li></ul></div>
                                                                ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 02:32:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/weaviate</guid>
            <link>https://www.oschina.net/p/weaviate</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 基於 LLM 大語言模型的知識庫問答系統 FastGPT]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-fastgpt" class="anchor" href="https://gitee.com/xindian/FastGPT#fastgpt"></a>FastGPT</h1><p>FastGPT 是一個基於 LLM 大語言模型的知識庫問答系統，提供開箱即用的數據處理、模型調用等能力。同時可以通過 Flow 可視化進行工作流編排，從而實現複雜的問答場景！</p><h2><a id="user-content--在線體驗" class="anchor" href="https://gitee.com/xindian/FastGPT#-%E5%9C%A8%E7%BA%BF%E4%BD%93%E9%AA%8C"></a>🛸 在線體驗</h2><p>🎉 <a href="https://gitee.com/link?target=https%3A%2F%2Ffastgpt.run%2F">fastgpt.run</a>（服務器在新加坡，部分地區可能無法直連）</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="https://gitee.com/xindian/FastGPT/raw/dev4/.github/imgs/intro1.png" alt="Demo" referrerpolicy="no-referrer"></td><td><img src="https://gitee.com/xindian/FastGPT/raw/dev4/.github/imgs/intro2.png" alt="Demo" referrerpolicy="no-referrer"></td></tr><tr><td><img src="https://gitee.com/xindian/FastGPT/raw/dev4/.github/imgs/intro3.png" alt="Demo" referrerpolicy="no-referrer"></td><td><img src="https://gitee.com/xindian/FastGPT/raw/dev4/.github/imgs/intro4.png" alt="Demo" referrerpolicy="no-referrer"></td></tr></tbody></table><h2><a id="user-content--開發" class="anchor" href="https://gitee.com/xindian/FastGPT#-%E5%BC%80%E5%8F%91"></a>👨‍💻 開發</h2><p>項目技術棧: NextJs + TS + ChakraUI + Mongo + Postgres（Vector 插件）<br><a href="https://gitee.com/xindian/FastGPT/blob/dev4/docSite/i18n/zh-Hans/docusaurus-plugin-content-docs/current/quick-start/dev.md">本地開發 Quick Start</a></p><h2><a id="user-content--部署" class="anchor" href="https://gitee.com/xindian/FastGPT#-%E9%83%A8%E7%BD%B2"></a>🚀 部署</h2><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fsealos.io%2Fdocs%2Fexamples%2Fai-applications%2Finstall-fastgpt-on-desktop">官方推薦 Sealos 部署</a> 無需服務器，代理和域名，高可用。</li><li><a href="https://gitee.com/xindian/FastGPT/blob/dev4/docSite/i18n/zh-Hans/docusaurus-plugin-content-docs/current/deploy/docker.md">docker-compose 部署</a> 單機版。</li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1tV4y1y7Mj%2F%3Fvd_source%3D92041a1a395f852f9d89158eaa3f61b4">由社區貢獻的寶塔部署和本地運行教程</a> 單機版。</li></ul><h2><a id="user-content--roadmap" class="anchor" href="https://gitee.com/xindian/FastGPT#-roadmap"></a><img class="emoji" alt=":point_right:" style="vertical-align: middle" src="https://cn-assets.gitee.com/assets/emoji/point_right-8d392cf32998e3bca12bb7b4ee10dae0.png" width="14" height="14" referrerpolicy="no-referrer"> RoadMap</h2><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fkjqvjse66l.feishu.cn%2Fdocx%2FRVUxdqE2WolDYyxEKATcM0XXnte">FastGpt RoadMap</a></li></ul><h2><a id="user-content-️-交流羣" class="anchor" href="https://gitee.com/xindian/FastGPT#%EF%B8%8F-%E4%BA%A4%E6%B5%81%E7%BE%A4"></a>🏘️ 交流羣</h2><p>添加 wx 進入：<br><img src="https://otnvvf-imgs.oss.laf.run/wx300.jpg" alt="Demo" referrerpolicy="no-referrer"></p><h2><a id="user-content-powered-by" class="anchor" href="https://gitee.com/xindian/FastGPT#powered-by"></a>Powered by</h2><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmsgbyte%2Ftushan">TuShan: 5 分鐘搭建後台管理系統</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Flabring%2Flaf">Laf: 3 分鐘快速接入三方應用</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Flabring%2Fsealos">Sealos: 快速部署集羣應用</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fsongquanpeng%2Fone-api">One API: 令牌管理 &amp; 二次分發，支持 Azure</a></li></ul><h2><a id="user-content--其他" class="anchor" href="https://gitee.com/xindian/FastGPT#-%E5%85%B6%E4%BB%96"></a>👀 其他</h2><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fkjqvjse66l.feishu.cn%2Fdocx%2FHtrgdT0pkonP4kxGx8qcu6XDnGh">FastGpt 常見問題</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1jo4y147fT%2F">docker 部署教程視頻</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1xh4y1t7fy%2F">公眾號接入視頻教程</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1Wo4y1p7i1%2F">FastGpt 知識庫演示</a></li></ul><h2><a id="user-content-第三方生態" class="anchor" href="https://gitee.com/xindian/FastGPT#%E7%AC%AC%E4%B8%89%E6%96%B9%E7%94%9F%E6%80%81"></a>第三方生態</h2><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fluolin-ai%2FFastGPT-Enterprise-WeChatbot">luolinAI: 企微機器人，開箱即用</a></li></ul><h2><a id="user-content--star-history" class="anchor" href="https://gitee.com/xindian/FastGPT#-star-history"></a>🌟 Star History</h2><p><a href="https://gitee.com/link?target=https%3A%2F%2Fstar-history.com%2F%23labring%2FFastGPT%26Date"><img src="https://api.star-history.com/svg?repos=labring/FastGPT&amp;type=Date" alt="Star History Chart" referrerpolicy="no-referrer"></a></p>]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 02:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/xindian/FastGPT</guid>
            <link>https://gitee.com/xindian/FastGPT</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 智能問答技術在百度搜索中的應用]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p><img src="https://oscimg.oschina.net/oscnet/up-7e074847d19344a1cd39fd61d566f8ba83b.png" alt="" referrerpolicy="no-referrer"></p><p>作者 | Xiaodong</p><blockquote><p>導讀</p><p>本文主要介紹了智能問答技術在百度搜索中的應用。包括機器問答的發展歷程、生成式問答、百度搜索智能問答應用。歡迎大家加入百度搜索團隊，共同探索智能問答技術的發展方向，文末有簡歷投遞方式。</p></blockquote><blockquote><p><em>全文 6474 字，預計閲讀時間 17 分鐘。</em></p></blockquote><h1><strong>01 什麼是機器問答</strong></h1><p>機器問答，就是讓計算機軟件系統自動回答人類提出的描述性問題。例如問：「王小丫的主持的節目叫什麼」，我們可以在百度搜索框裏輸入任意用自然語言描述的問題，並在搜索的首位結果中可以直接得相關答案，如下圖所示：</p><p><img src="https://oscimg.oschina.net/oscnet/up-963d02166a9d2429174f6b8653991ec8f94.png" alt="圖片" referrerpolicy="no-referrer"></p><p>區別於傳統搜索引擎根據多個關鍵詞反饋檢索的網頁鏈接，機器問答根據自然語言描述的問題直接獲取答案，可以極大地提高大家獲取信息的效率。機器問答在生活中無處不在，經統計，有約 40% 的搜索需求、約 30% 的對話需求都跟機器問答相關。</p><p>那麼，百度搜索的機器問答應用現狀如何？目前首條結果可以直接滿足大部分的問答需求，並且，在百度搜索中，不限定用戶問題領域，是一個開放式的問答系統，可以詢問任何信息。</p><h2><strong>1.1 機器問答的發展歷程</strong></h2><p>機器問答的發展歷程如下，與機器學習發展相吻合。</p><p><img src="https://oscimg.oschina.net/oscnet/up-9a139b0eb31cf87b33168f4ad87086aa2cd.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong>從模型方法的發展上看：</strong></p><p>2013 年以前，大家主要做一些特徵工程相關工作，即給定一個問題和一些候選答案，設計多種字面匹配特徵，並計算問題與答案之間詞的匹配度，例如 BM25 等算法。</p><p>2014~2015 年，隨着深度學習的發展，大家會使用神經網絡來計算問題和答案間表示的語義距離，例如 CNN、RNN 等。</p><p>2016~2017 年，大家會使用 Attention 網絡結構設計各類模型結構，進一步刻畫問題和答案間的深層語義匹配關係。</p><p>2018~2021 年，研究主要集中在訓練模型上，會使用一些更大、效果更好的預訓練模型來完成複雜的問答匹配任務。</p><p>自 2022 年開始，大家更多關注生成模型的應用。</p><p><strong>從數據集的發展上看：</strong></p><p>2013 年，MCTest 出現，以選擇題和完形填空形式為主。</p><p>2016 年，SQuAD 誕生，這是第一個大型閲讀理解數據信息，會根據用戶問題從提供的一篇文章中進行答案抽取。</p><p>2017 年，百度發佈了 DuReader 數據集，這是首箇中文的閲讀理解的數據集。</p><p>2018 年，HotputQA 等發佈，更加深入研究了多跳推理、常識推理等複雜的問答場景。</p><h2><strong>1.2 機器問答建模</strong></h2><p>目前的主流範式：Retriever + Reader</p><p>Retriever = 基於 query 查詢候選。即給定一個 query，獲得該 query 的相關候選，可能是網頁、視頻、表格、知識圖譜等。</p><p>Reader = 從給定候選中獲取答案信息。即在給定候選的基礎上，結合 query 進一步進行答案抽取。</p><p>百度搜索就是一個非常強的一個 Retriever ，它可以提供相關候選查詢，所以我們的研究工作更多集中在 Reader 上，即基於搜索結果如何更好地完成答案抽取。</p><p><img src="https://oscimg.oschina.net/oscnet/up-d2ba5b11127a99934c18d5825cba6ab00b1.png" alt="圖片" referrerpolicy="no-referrer"></p><p>早期的 Reader，主要基於傳統的特徵工程方法，是一個很複雜的系統化 pipeline 流程：先分析 query 獲得期望的答案類型、實體信息、問題類型等，並根據這些信息從候選庫裏檢索若干候選，並設計複雜的匹配特徵來計算 query 和候選的相關性打分，並設計排序函數進行排序，得到排序最高的答案，過程如下圖。</p><p><img src="https://oscimg.oschina.net/oscnet/up-74c5ecc4978e073d0b1799f4735a3b37278.png" alt="圖片" referrerpolicy="no-referrer"></p><p>這個流程是管道串聯的，每一步都存在誤差的積累，整個訓練流程也不可整體迭代，維護成本較高。後來，大家希望找到一種更加端到端的方法來解決以上問題，機器閲讀理解（Machine Reading Comprehension，MRC）被提出出來。</p><p>MRC 的任務的定義是：輸入 Question+Document，直接用一個模型替代複雜流程，輸出 Answer。早期的 MRC 工作會設計一些比較複雜的網絡結構，來對問題和答案之間的關係進行建模。一個比較經典的方法是 BiDAF，它的輸入層是對整個 document 和 query 分別映射到 enbedding 表示上，各自通過 LSTM 等網絡來學習問題和文檔上下文的表示，之後通過 Attention 交互層，採用雙向注意力對 query 和 document 的關係進行建模，在此基礎上再通過 LSTM 網絡獲取更豐富的上下文表示，最終輸出層預測每個位置作為答案開始和終止的概率，概率最高的片段被抽取作為答案。</p><p><img src="https://oscimg.oschina.net/oscnet/up-c79c34662eb1f0af4c7b094a66cf7656acb.png" alt="圖片" referrerpolicy="no-referrer"></p><p>早期的模型結構設計呈現百花齊放的狀態，以期更好解決問題和答案的建模。</p><p>後來，預訓練模型逐漸發展起來，大家意識到，複雜的模型結構設計並不太必要，transformer 就是目前為止最好的模型結構，這樣可以釋放更多研究精力到預訓練工作中，更多關注預訓練的任務設計、 loss 函數、預訓練的數據等。</p><p>在這種情況下，產生了多種預訓練模型，比如説最早的 BERT 和百度的<a href="https://www.oschina.net/action/visit/ad?id=1191" title="ERNIE">ERNIE</a>等，這些預訓練模型會使 MRC 更加簡單，大家會把 query 和 document 整體作為一個序列進行輸入，query 和 document 之間可以用一些特殊符號進行分割。經過預訓練模型的語義表示建模，最後依舊預測答案開始和結束的位置並進行抽取。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b91feb0c3746117307b1b707dbc9b2341c0.png" alt="圖片" referrerpolicy="no-referrer"></p><h1><strong>02 生成式問答</strong></h1><p>近期生成式技術的發展非常火熱，也有非常多的工作發表。</p><p>早期一個比較有代表性的生成式 Reader，是 2017 年的 S-NET，它是針對 MS-MARCO 數據集專門設計的，該數據集的特點是答案來自多篇文章並且與原文中詞彙不一定相同。</p><p>針對這樣的任務，很自然的想法是用生成的方式來解決這個問題。它設計了一套兩階段的流程，第一階段是答案抽取模型，跟我們上面介紹的模型非常一致，並額外引入了 passage 排序任務對候選文章進行相關性排序。第二階段是生成模型，輸入得到抽取結果，生成答案的總結，如下圖所示。</p><p><img src="https://oscimg.oschina.net/oscnet/up-eac42697ab12c4dd61e9625a1bbf3ab4bcf.png" alt="圖片" referrerpolicy="no-referrer"></p><p>可以看出，早期的這些工作跟我們現在所使用的生成式問答流程非常相似，我們還會加一個檢索模塊，就是我們剛才最早提到的 Retriever，然後就是候選抽取、排序、生成。但是，這個工作還是依賴於額外信息來做參考總結。大家會想，是不是可以有一個生成模型，直接生成答案，而不依賴於我們輸入額外的信息知識？</p><p>2019 年的 T5 模型首先解決了這個問題，當時它是採用了一種「預訓練+遷移學習」的思路，將不同 NLP 任務統一到生成範式下，來統一完成問答、機器翻譯、情感分析、對話等一系列任務，且通過百億參數量的大模型（在當時算是比較大的規模）中存儲的知識直接回答問題。它也驗證了不同生成模型的結構，包括 Encoder-Decoder 方式的、Decoder-only 的和混合式的。</p><p>但是，T5 這類模型雖然可以完成一些簡單問答，但還不足以達到可直接使用的商用狀態，它的參數量及訓練方式還存在改進空間，對於一些通用問題也不能直接取得非常好的效果。直到 ChatGPT 的出現，它會採用更大的參數規模（千億級），並有更強的人類回覆對齊能力，去理解用戶指令，從而完成更加複雜的問答。可以説，ChatGPT 是已達商用級別的對話和問答產品。</p><h1><strong>03 百度搜索的智能問答應用</strong></h1><p>百度搜索的問答場景是豐富多樣的。答案抽取方式也有多種，比如説我們可以從百科或者網頁通過信息抽取的方式得到一些知識圖譜，在知識圖譜上來進行答案提取；更通用的方式是從網頁文本中，通過閲讀理解直接抽取答案；還可以通過對一些半結構化的數據，比如表格，來進一步的提取信息，並組織成更結構化的方式展現。不止是文本，也包括對視頻內容的理解和抽取。</p><p><img src="https://oscimg.oschina.net/oscnet/up-4f1d8cf290673670a6b13f27ff8f32c76f0.png" alt="圖片" referrerpolicy="no-referrer"></p><p>面臨着這樣一個豐富多樣的問答場景，我們會有哪些挑戰呢？</p><p><strong>挑戰 1</strong>：機器問答面臨複雜語義理解、推理、上下文建模難點？</p><p><strong>挑戰 2</strong>：面對搜索的高流量和機器問答對複雜模型的需求，如何實現快速響應？</p><p><strong>挑戰 3</strong>：開放領域的搜索場景下網頁數據非常複雜，答案質量參差不齊（錯誤、片面），如何提供正確且高質量的答案？</p><p>、</p><h2><strong>3.1 解決複雜語義理解、推理、上下文建模難點</strong></h2><p>比如最開始的這個例子，如下圖所示，答案中提到一個「她」，就需要做指代消解、對上下文的理解，並且上下文篇幅可能很長，通過深層次的理解才能知道所需的是一個答題節目，而不是其他節目。這個問題的解決依賴一些很複雜的模型。</p><p><img src="https://oscimg.oschina.net/oscnet/up-b0523ebaa060da3070ea6a4d3811d62d1bd.png" alt="圖片" referrerpolicy="no-referrer"></p><p>我們採用的解決方案是「大模型+預訓練」。</p><p>在預訓練中，我們會使用非常豐富的數據，包括幾個階段：</p><ul><li><p>首先，用 T 級別通用文本進行 Pretrain 學習基礎語言模型；</p></li><li><p>並且，使用百 G 級業務日誌進行 Post-pretrain 實現領域和目標遷移；</p></li><li><p>此外，進行細緻的數據挖掘，通過 G 級人工標註數據進行 Finetune 擬合業務效果；</p></li><li><p>最後，通過遠程監督數據增強、標註數據質量識別、薄弱數據自動挖掘和定向標註、用戶行為指引，實現數據和模型的閉環反饋。</p></li></ul><p>而在大模型方面：</p><ul><li><p>使用百億級參數量模型，提升知識記憶和語言理解能力</p></li><li><p>通過長序列建模，充分理解上下文</p></li></ul><p>例如，我們正在使用的一個模型，我們稱之為 DocMRC 模型，它模擬人做閲讀理解答題，閲讀整個文章，邏輯如下圖所示。</p><p><img src="https://oscimg.oschina.net/oscnet/up-efaa14b51d1240a2fed3ef2c93b114b90d9.png" alt="圖片" referrerpolicy="no-referrer"></p><p>輸入層支持長序列建模，將整個 doc segment sents 進行切分；特別的是，我們在每句話前插入 token 表示，CLS 用來匯聚每個句子的表示，整體輸入淺層詞級模型結構來學習局部表示；基於這個表示經過層次化結構學習深層上下文關係；最後輸出 CLS 特殊 token 表示標註，輸出答案。</p><p>輸出層會有兩種輸出：一種是針對問題輸出偏摘要等多句話答案介紹，會使用句子層的輸出，然後做序列標註的輸出；另一種是強調答案中的關鍵內容，可能是幾個實體，會將 token 表示做序列標註預測。</p><h2><strong>3.2 提升整體模型的速度，實現快速響應</strong></h2><p>搜索每天的用戶流量非常大，前面也提到，我們需要用到較大或較複雜模型，整個模型的耗時以及資源消耗也是非常大的。那麼，有沒有其他方式來提升整體模型的速度，實現快速響應及資源平衡？</p><p>剛才介紹的層次化的建模，對模型結構的優化，是一種解決方案。</p><p>另外有一種通用的方式：知識蒸餾，知識蒸餾是將大模型的知識提煉給單個小模型，在效果接近的情況下提升推理速度。這裏我們採用了一種「多 teacher 多階段蒸餾」模式。</p><p>針對問答的業務場景，我們會訓練多個不同的 teacher，通過不同 teacher 的集成來提升學習目標的上限。然後對於多個 teacher 蒸餾，一種基線方案是將每個 teacher 的打分或 loss 加權直接做平均，讓 student 擬合，但是我們認為這種方式可能並不能確保達到非常極致的效果。我們期望根據不同樣本動態做出選擇（因為不同 teacher 的側重有差異），設計了一種多階段蒸餾的模式，並在其中根據數據動態選擇 teacher，如下圖所示。</p><p><strong>第一階段</strong>，Teacher 模型訓練，訓練多 teacher 提升學習上限；</p><p><strong>第二階段</strong>，無監督蒸餾，無標數據很難判斷 teacher 的好壞，所以採用 teacher 間投票的方式，依據梯度方向動態選擇 teacher，剔除可能的噪聲 teacher；</p><p><strong>第三階段</strong>，有監督蒸餾，依據標註樣本對 teacher 動態賦權。</p><p><img src="https://oscimg.oschina.net/oscnet/up-1d06f3320489bb36099a988b3c28560be5c.png" alt="圖片" referrerpolicy="no-referrer"></p><p>通過這樣一種多階段多 teacher 蒸餾的方式，我們最終得到一個效果非常好的 student 模型，甚至超過單個大模型效果。</p><h2><strong>3.3 如何提供正確且高質量的答案</strong></h2><p>搜索場景的問答數據非常複雜，答案質量也參差不齊，很多網頁中可能存在一些錯誤信息或片面介紹，如何提供正確且高質量的答案是我們面臨的第三個挑戰。</p><p>如下圖所示，是搜索中場景的複雜答案的例子。左側是冗長答案，用戶無法快速抓住重點，這種情況下需要一種方式進行總結，用戶才能快速理解的答案關鍵信息，提升滿足效率。抽取式答案提取方式已經無法滿足，我們需要用生成技術對答案進行深層次壓縮總結。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3b0cb10d8ed43151c7cfb9dba4b1f9792a7.png" alt="圖片" referrerpolicy="no-referrer"></p><p>另外，對於單篇文章中提取的答案可能不夠全面，我們需要從多篇網頁中做答案總結，也需要生成模型，如下圖所示。我們從多篇文章中總結答案，並在答案中標註來源，用戶可以清晰看到答案出處。</p><p><img src="https://oscimg.oschina.net/oscnet/up-743951b5f984c8a0ac47dc29838f43e96c9.png" alt="圖片" referrerpolicy="no-referrer"></p><p>綜上，如果要生成全面、高效、正確的答案，就需要有一個更好的生成模型。目前的大語言模型非常多，但怎樣的大語言模型才能完成搜索場景的問答任務呢？</p><h1><strong>04 檢索增強生成</strong></h1><p>目前大語言模型直接做問答還有幾個問題：</p><p><strong>第一</strong>，大預言模型難以記住所有知識，對於一些偏長尾知識可能有錯誤或者不知道的情況；</p><p><strong>第二</strong>，大語言模型的知識容易過時、更新困難，對於新知識無法及時感知；</p><p><strong>第三</strong>，大語言模型的輸出難以驗證，目前用戶的信賴感較差，我們無法完全信賴生成模型直接生成的答案。</p><p><strong>所以在這種情況下，大家希望能有一些方式來進行一些輔助的答案驗證。</strong></p><h2><strong>4.1 檢索增強生成流程</strong></h2><p>針對搜索問答場景，我們設計了檢索增強生成方案，已在百度搜索落地。檢索增強生成是基於搜索引擎補充相關信息，可有效緩解大模型幻覺，來提升答案的正確性、時效性以及可信度。整體流程分為幾個階段：</p><p>1、文檔檢索階段，會檢索得到多種參考來源；</p><p>2、答案抽取階段，會把文章抽取關鍵信息，減輕生成模型負擔；</p><p>3、prompt 組成階段，會根據獲取的參考來源來回答問題，並提供具體要求，比如説在答案內容中序號標註來源；</p><p>4、答案生成階段，將 prompt 輸入生成大模型中，最終得到搜索結果。</p><p><img src="https://oscimg.oschina.net/oscnet/up-4433c15aa52ec41c714f2962fbc7f36d8bf.png" alt="圖片" referrerpolicy="no-referrer"></p><p>如上圖所示，可以看到右側答案是總結了多篇文章的一個結果，並且也會在其中標註上參考來源，這就是我們期望給用戶提供的答案。</p><h2><strong>4.2 生成大模型訓練流程</strong></h2><p>我們生成大模型的訓練流程分為四個階段，如下圖所示，前兩個階段跟目前主流的生成大模型訓練比較接近，後兩個階段我們做了檢索增強生成問答場景下的特殊適配。</p><p><img src="https://oscimg.oschina.net/oscnet/up-2d170b5a9d03db57ccca02b3f9648bfe4a9.png" alt="圖片" referrerpolicy="no-referrer"></p><p><strong>第一階段</strong>，通用預訓練，我們會有一些通用的網頁語料以及垂類語料，比如書籍、表格、對話等，來獲得通用的預訓練基礎模型；</p><p><strong>第二階段</strong>，進行指令微調，我會提供一些通用的指令，使得模型擁有理解指令的能力；</p><p><strong>第三階段</strong>，標註業務指令，並用其做具體的微調，使其能理解搜索場景下的多結果組織的問答場景；</p><p><strong>第四階段</strong>，基於用戶行為反饋做細緻微調，以及通過強化學習等方式，提高生成答案的質量。</p><h2><strong>4.3 通過指令拆解，學習複雜指令</strong></h2><p>搜索的業務場景指令非常複雜，我們會提出非常具體的要求，並提供參考來源。那麼如何讓生成模型來理解這種複雜的指令？一種解決方案是標註很多這類複雜指令，並輸入到生成模型中，但這種方式並不一定是最佳的。如果模型學習這類指令偏多了，反而無法達到更好泛化效果，造成模型效果下降。有沒有其他的方式？</p><p><strong>這裏，我們借鑑推理鏈（CoT）的思想，提出通過指令拆解的方式，學習檢索生成場景下複雜指令。</strong></p><p>上述複雜指令通常可以通過三步簡單步驟完成：</p><p>第一步，選擇能用來回答問題的搜索結果；</p><p>第二步，根據選擇的搜索結果進行答案的組織和生成；</p><p>第三步，用編號的形式，加上參考來源。</p><p>可以看出，對於很複雜的指令，我們可以通過多步拆解變成多個簡單指令，我們會讓模型先去學習並理解簡單指令，之後可能不用太多複雜指令的數據，就能使模型在複雜指令上的表現達到一個非常好的水平。</p><h2><strong>4.4 推理加速及降低資源消耗</strong></h2><p>對於一些判別式模型，可以用蒸餾或一些其他的技術來做。但對於生成模型來説，模型尺寸小了對效果的影響較大，蒸餾並不特別適用，需要有一些其他的加速手段。近期業內有很多相關的工作研究，例如 Inference with Reference，就是針對檢索增強生成的業務場景，通過檢測固定 prefix，從參考中複製固定長度文本作為候選序列，驗證如與模型輸出一致則實現並行解碼多步，如下圖所示。</p><p><img src="https://oscimg.oschina.net/oscnet/up-78ee3ddc4ee98c5d2055bc1c54dc1d0b8d1.png" alt="圖片" referrerpolicy="no-referrer"></p><p>另外也有一些更加通用的生成加速的手段，例如可以用小模型快速生成多步，把小模型的預測結果直接輸入大模型，大模型驗證是否解碼一致，類似前一個工作也可以實現加速，但要求是儘量使我們的小模型和大模型效果接近，預測準確的概率會更大，加速比就會更大。</p><p>最後我給大家留一個問題，大家可以想一想： <strong>「下一代的搜索引擎會是什麼樣子？」</strong> 很期待你的回答，也歡迎與我們一起探討。</p><p><a href="https://www.oschina.net/action/GoToLink?url=mailto%3A%E4%BA%A4%E6%B5%81%26%E7%AE%80%E5%8E%86%E6%8A%95%E9%80%92%E9%82%AE%E7%AE%B1%EF%BC%9Asti01%40baidu.com" target="_blank">交流&amp;簡歷投遞郵箱：sti01@baidu.com</a></p><p>——END——</p><p><strong>推薦閲讀</strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247572187%26idx%3D1%26sn%3De62d1cf576fcc45232b67028321a9dd0%26chksm%3Dc03feaa7f74863b11423311a7158d1ae375b5fded421b83756d0af9cbb4db6d5dfc034ac1be4%26scene%3D21%23wechat_redirect" target="_blank">通過 Python 腳本支持 OC 代碼重構實踐（一）：模塊調用關係分析</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247571891%26idx%3D1%26sn%3De5ab3e3ad26b8e92b5387e5905d17805%26chksm%3Dc03fe9cff74860d911187fc6e1b70da54e5c9b05453ef602576d2efc03d95b6fda158003ada7%26scene%3D21%23wechat_redirect" target="_blank">CVPR2023 優秀論文 | AIGC 偽造圖像鑑別算法泛化性缺失問題分析</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247571772%26idx%3D1%26sn%3D3f9c022e989d2e8e2f7af2e6c7f7db76%26chksm%3Dc03fe940f7486056ca76cb5e0d6e1175d25ec77186ed8f7f26887ae5cb8d24c750acfafdaadb%26scene%3D21%23wechat_redirect" target="_blank">一文搞定專屬碼的設計與開發</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247571660%26idx%3D1%26sn%3D867bb1f6c7e9cb68da34a95923a06a5e%26chksm%3Dc03fe8b0f74861a6972c085bcabc20b71647b02a4b312980722ad37ac843f519432393f6b657%26scene%3D21%23wechat_redirect" target="_blank">AI 原生應用速通指南</a></p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247571596%26idx%3D1%26sn%3Dcc698b9be371c3d0316236551cf73a9d%26chksm%3Dc03fe8f0f74861e6e27850cbee6bad70d2e88f1e9fcaf474db0736232108a8a743d0223fdf40%26scene%3D21%23wechat_redirect" target="_blank">代碼理解技術應用實踐介紹</a></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 29 Oct 2023 02:21:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/10123217</guid>
            <link>https://my.oschina.net/u/4939618/blog/10123217</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[網易雲課堂 Service Worker 運用與實踐]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="news_comment_top_ad" data-tracepid="news_comment_top" style="text-align: center;"><a style="color:#A00;font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p><img src="https://oscimg.oschina.net/oscnet/up-ac820c57f42ee1b582f9a6e7a1787375e7a.png" alt="" referrerpolicy="no-referrer"></p><h1>前言</h1><p>本文首先會簡單介紹下前端的常見緩存方式，再引入 Service Worker 的概念，針對其原理和如何運用進行介紹。然後基於 google 推出的第三方庫 Workbox，在產品中進行運用實踐，並對其原理進行簡要剖析。</p><blockquote><p>作者：劉放</p></blockquote><blockquote><p>編輯：Ein</p></blockquote><h1>前端緩存簡介</h1><p>先簡單介紹一下現有的前端緩存技術方案，主要分為 http 緩存和瀏覽器緩存。</p><h2>http 緩存</h2><p>http 緩存都是第二次請求時開始的，這也是個老生常談的話題了。無非也是那幾個 http 頭的問題：</p><h3>Expires</h3><p>HTTP1.0 的內容，服務器使用 Expires 頭來告訴 Web 客戶端它可以使用當前副本，直到指定的時間為止。</p><h3>Cache-Control</h3><p>HTTP1.1 引入了 Cathe-Control，它使用 max-age 指定資源被緩存多久，主要是解決了 Expires 一個重大的缺陷，就是它設置的是一個固定的時間點，客戶端時間和服務端時間可能有誤差。 所以一般會把兩個頭都帶上，這種緩存稱為強緩存，表現形式為： <img src="https://oscimg.oschina.net/oscnet/up-5d55a7877b12164c2b7f2fe4e870e072dc2.png" alt="" referrerpolicy="no-referrer"></p><h3>Last-Modified / If-Modified-Since</h3><p>Last-Modified 是服務器告訴瀏覽器該資源的最後修改時間，If-Modified-Since 是請求頭帶上的，上次服務器給自己的該資源的最後修改時間。然後服務器拿去對比。</p><p>若資源的最後修改時間大於 If-Modified-Since，説明資源又被改動過，則響應整片資源內容，返回狀態碼 200；</p><p>若資源的最後修改時間小於或等於 If-Modified-Since，説明資源無新修改，則響應 HTTP 304，告知瀏覽器繼續使用當前版本。</p><h3>Etag / If-None-Match</h3><p>前面提到由文件的修改時間來判斷文件是否改動，還是會帶來一定的誤差，比如註釋等無關緊要的修改等。所以推出了新的方式。</p><p>Etag 是由服務端特定算法生成的該文件的唯一標識，而請求頭把返回的 Etag 值通過 If-None-Match 再帶給服務端，服務端通過比對從而決定是否響應新內容。這也是 304 緩存。</p><h2>瀏覽器緩存</h2><h3>Storage</h3><p>簡單的緩存方式有 cookie，localStorage 和 sessionStorage。這裏就不詳細介紹他們的區別了，這裏説下通過 localStorage 來緩存靜態資源的優化方案。 localStorage 通常有 5MB 的存儲空間，我們以微信文章頁為例。 查看請求發現，基本沒有 js 和 css 的請求，因為它把全部的不需要改動的資源都放到了 localStorage 中： <img src="https://oscimg.oschina.net/oscnet/up-aa2899a96564193e2509884484b4f1eb12b.png" alt="" referrerpolicy="no-referrer"> 所以微信的文章頁加載非常的快。</p><h3>前端數據庫</h3><p>前端數據庫有 WebSql 和 IndexDB，其中 WebSql 被規範廢棄，他們都有大約 50MB 的最大容量，可以理解為 localStorage 的加強版。</p><h3>應用緩存</h3><p>應用緩存主要是通過 manifest 文件來註冊被緩存的靜態資源，已經被廢棄，因為他的設計有些不合理的地方，他在緩存靜態文件的同時，也會默認緩存 html 文件。這導致頁面的更新只能通過 manifest 文件中的版本號來決定。所以，應用緩存只適合那種常年不變化的靜態網站。如此的不方便，也是被廢棄的重要原因。</p><p>PWA 也運用了該文件，不同於 manifest 簡單的將文件通過是否緩存進行分類，PWA 用 manifest 構建了自己的 APP 骨架，並運用 Servie Worker 來控制緩存，這也是今天的主角。</p><h1>Service Worker</h1><p>Service Worker 本質上也是瀏覽器緩存資源用的，只不過他不僅僅是 Cache，也是通過 worker 的方式來進一步優化。 他基於 h5 的 web worker，所以絕對不會阻礙當前 js 線程的執行，sw 最重要的工作原理就是：</p><p>1、後台線程：獨立於當前網頁線程；</p><p>2、網絡代理：在網頁發起請求時代理，來緩存文件。</p><h2>兼容性</h2><p><img src="https://oscimg.oschina.net/oscnet/up-c50376e8514a0eda4c04fcf7bf1af3f24aa.png" alt="" referrerpolicy="no-referrer"> 可以看到，基本上新版瀏覽器還是兼容滴。之前是隻有 chrome 和 firefox 支持，現在微軟和蘋果也相繼支持了。</p><h2>成熟程度</h2><p>判斷一個技術是否值得嘗試，肯定要考慮下它的成熟程度，否則過一段時間又和應用緩存一樣被規範拋棄就尷尬了。 所以這裏我列舉了幾個使用 Service Worker 的頁面：</p><ul><li>淘寶</li><li>網易新聞</li><li>考拉</li></ul><p>所以説還是可以嘗試下的。</p><h2>調試方法</h2><p>一個網站是否啓用 Service Worker，可以通過開發者工具中的 Application 來查看：</p><p><img src="https://oscimg.oschina.net/oscnet/up-b631c480eabb3662b08968b60c0466ceefd.png" alt="" referrerpolicy="no-referrer"></p><p>被 Service Worker 緩存的文件，可以在 Network 中看到 Size 項為 from Service Worker：</p><p><img src="https://oscimg.oschina.net/oscnet/up-a94d21f7c7ca175656166c4224fae4ba3c9.png" alt="" referrerpolicy="no-referrer"></p><p>也可以在 Application 的 Cache Storage 中查看緩存的具體內容：</p><p><img src="https://oscimg.oschina.net/oscnet/up-7db236cf39ff32cf4e8f86a591a08431b07.png" alt="" referrerpolicy="no-referrer"></p><p>如果是具體的斷點調試，需要使用對應的線程，不再是 main 線程了，這也是 webworker 的通用調試方法：</p><p><img src="https://oscimg.oschina.net/oscnet/up-72a1c5ec7411b0e92530a737fe53db2b158.png" alt="" referrerpolicy="no-referrer"></p><h2>使用條件</h2><p>sw 是基於 HTTPS 的，因為 Service Worker 中涉及到請求攔截，所以必須使用 HTTPS 協議來保障安全。如果是本地調試的話，localhost 是可以的。 而我們剛好全站強制 https 化，所以正好可以使用。</p><h2>生命週期</h2><p>大概可以用如下圖片來解釋：</p><p><img src="https://oscimg.oschina.net/oscnet/up-385c15f6dc80d598f67579d5c0308bb98e5.png" alt="" referrerpolicy="no-referrer"></p><h3>註冊</h3><p>要使用 Service Worker，首先需要註冊一個 sw，通知瀏覽器為該頁面分配一塊內存，然後 sw 就會進入安裝階段。 一個簡單的註冊方式：</p><pre><code>(function() {
    if('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js');
    }
})()
</code></pre><p>當然也可以考慮全面點，參考網易新聞的註冊方式：</p><pre><code>"serviceWorker" in navigator &amp;&amp; window.addEventListener("load",
    function() {
        var e = location.pathname.match(/\/news\/[a-z]{1,}\//)[0] + "article-sw.js?v=08494f887a520e6455fa";
        navigator.serviceWorker.register(e).then(function(n) {
            n.onupdatefound = function() {
                var e = n.installing;
                e.onstatechange = function() {
                    switch (e.state) {
                        case "installed":
                            navigator.serviceWorker.controller ? console.log("New or updated content is available.") : console.log("Content is now available offline!");
                            break;
                        case "redundant":
                            console.error("The installing service worker became redundant.")
                    }
                }
            }
        }).
        catch(function(e) {
            console.error("Error during service worker registration:", e)
        })
    })
</code></pre><p>前面提到過，由於 sw 會監聽和代理所有的請求，所以 sw 的作用域就顯得額外的重要了，比如説我們只想監聽我們專題頁的所有請求，就在註冊時指定路徑：</p><pre><code>navigator.serviceWorker.register('/topics/sw.js');
</code></pre><p>這樣就只會對 topics/下面的路徑進行優化。</p><h3>installing</h3><p>我們註冊後，瀏覽器就會開始安裝 sw，可以通過事件監聽：</p><pre><code>//service worker 安裝成功後開始緩存所需的資源
var CACHE_PREFIX = 'cms-sw-cache';
var CACHE_VERSION = '0.0.20';
var CACHE_NAME = CACHE_PREFIX+'-'+CACHE_VERSION;
var allAssets = [
    './main.css'
];
self.addEventListener('install', function(event) {

    //調試時跳過等待過程
    self.skipWaiting();


    // Perform install steps
    //首先 event.waitUntil 你可以理解為 new Promise，
    //它接受的實際參數只能是一個 promise，因為,caches 和 cache.addAll 返回的都是 Promise，
    //這裏就是一個串行的異步加載，當所有加載都成功時，那麼 SW 就可以下一步。
    //另外，event.waitUntil 還有另外一個重要好處，它可以用來延長一個事件作用的時間，
    //這裏特別針對於我們 SW 來説，比如我們使用 caches.open 是用來打開指定的緩存，但開啓的時候，
    //並不是一下就能調用成功，也有可能有一定延遲，由於系統會隨時睡眠 SW，所以，為了防止執行中斷，
    //就需要使用 event.waitUntil 進行捕獲。另外，event.waitUntil 會監聽所有的異步 promise
    //如果其中一個 promise 是 reject 狀態，那麼該次 event 是失敗的。這就導致，我們的 SW 開啓失敗。
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(function(cache) {
                console.log('[SW]: Opened cache');
                return cache.addAll(allAssets);
            })
    );

});
</code></pre><p>安裝時，sw 就開始緩存文件了，會檢查所有文件的緩存狀態，如果都已經緩存了，則安裝成功，進入下一階段。</p><h3>activated</h3><p>如果是第一次加載 sw，在安裝後，會直接進入 activated 階段，而如果 sw 進行更新，情況就會顯得複雜一些。流程如下：</p><p>首先老的 sw 為 A，新的 sw 版本為 B。 B 進入 install 階段，而 A 還處於工作狀態，所以 B 進入 waiting 階段。只有等到 A 被 terminated 後，B 才能正常替換 A 的工作。</p><p><img src="https://oscimg.oschina.net/oscnet/up-5d04b8ca78c8e2f2bc8f02e992c6a540426.png" alt="" referrerpolicy="no-referrer"></p><p>這個 terminated 的時機有如下幾種方式：</p><p>1、關閉瀏覽器一段時間；</p><p>2、手動清除 Service Worker；</p><p>3、在 sw 安裝時直接跳過 waiting 階段</p><pre><code>//service worker 安裝成功後開始緩存所需的資源
self.addEventListener('install', function(event) {
    //跳過等待過程
    self.skipWaiting();
});
</code></pre><p>然後就進入了 activated 階段，激活 sw 工作。</p><p>activated 階段可以做很多有意義的事情，比如更新存儲在 Cache 中的 key 和 value：</p><pre><code>var CACHE_PREFIX = 'cms-sw-cache';
var CACHE_VERSION = '0.0.20';
/**
 * 找出對應的其他 key 並進行刪除操作
 * @returns {*}
 */
function deleteOldCaches() {
    return caches.keys().then(function (keys) {
        var all = keys.map(function (key) {
            if (key.indexOf(CACHE_PREFIX) !== -1 &amp;&amp; key.indexOf(CACHE_VERSION) === -1){
                console.log('[SW]: Delete cache:' + key);
                return caches.delete(key);
            }
        });
        return Promise.all(all);
    });
}
//sw 激活階段,説明上一 sw 已失效
self.addEventListener('activate', function(event) {


    event.waitUntil(
        // 遍歷 caches 裏所有緩存的 keys 值
        caches.keys().then(deleteOldCaches)
    );
});
</code></pre><h3>idle</h3><p>這個空閒狀態一般是不可見的，這種一般説明 sw 的事情都處理完畢了，然後處於閒置狀態了。</p><p>瀏覽器會週期性的輪詢，去釋放處於 idle 的 sw 佔用的資源。</p><h3>fetch</h3><p>該階段是 sw 最為關鍵的一個階段，用於攔截代理所有指定的請求，並進行對應的操作。</p><p>所有的緩存部分，都是在該階段，這裏舉一個簡單的例子：</p><pre><code>//監聽瀏覽器的所有 fetch 請求，對已經緩存的資源使用本地緩存回覆
self.addEventListener('fetch', function(event) {
    event.respondWith(
        caches.match(event.request)
            .then(function(response) {
                //該 fetch 請求已經緩存
                if (response) {
                    return response;
                }
                return fetch(event.request);
                }
            )
    );
});
</code></pre><p>生命週期大概講清楚了，我們就以一個具體的例子來説明下原生的 serviceworker 是如何在生產環境中使用的吧。</p><h2>舉個栗子</h2><p>我們可以以網易新聞的 wap 頁為例,其針對不怎麼變化的靜態資源開啓了 sw 緩存，具體的 sw.js 邏輯和解讀如下：</p><pre><code>'use strict';
//需要緩存的資源列表
var precacheConfig = [
    ["https://static.ws.126.net/163/wap/f2e/milk_index/bg_img_sm_minfy.png",
        "c4f55f5a9784ed2093009dadf1e954f9"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/change.png",
        "9af1b102ef784b8ff08567ba25f31d95"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/icon-download.png",
        "1c02c724381d77a1a19ca18925e9b30c"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/icon-login-dark.png",
        "b59ba5abe97ff29855dfa4bd3a7a9f35"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/icon-refresh.png",
        "a5b1084e41939885969a13f8dbc88abd"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/icon-video-play.png",
        "065ff496d7d36345196d254aff027240"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/icon.ico",
        "a14e5365cc2b27ec57e1ab7866c6a228"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/iconfont_1.eot",
        "e4d2788fef09eb0630d66cc7e6b1ab79"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/iconfont_1.svg",
        "d9e57c341608fddd7c140570167bdabb"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/iconfont_1.ttf",
        "f422407038a3180bb3ce941a4a52bfa2"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/iconfont_1.woff",
        "ead2bef59378b00425779c4ca558d9bd"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/index.5cdf03e8.js",
        "6262ac947d12a7b0baf32be79e273083"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/index.bc729f8a.css",
        "58e54a2c735f72a24715af7dab757739"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/logo-app-bohe.png",
        "ac5116d8f5fcb3e7c49e962c54ff9766"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/logo-app-mail.png",
        "a12bbfaeee7fbf025d5ee85634fca1eb"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/logo-app-manhua.png",
        "b8905b119cf19a43caa2d8a0120bdd06"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/logo-app-open.png",
        "b7cc76ba7874b2132f407049d3e4e6e6"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/logo-app-read.png",
        "e6e9c8bc72f857960822df13141cbbfd"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/logo-site.png",
        "2b0d728b46518870a7e2fe424e9c0085"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/version_no_pic.png",
        "aef80885188e9d763282735e53b25c0e"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/version_pc.png",
        "42f3cc914eab7be4258fac3a4889d41d"],
    ["https://static.ws.126.net/163/wap/f2e/milk_index/version_standard.png",
        "573408fa002e58c347041e9f41a5cd0d"]
];
var cacheName = 'sw-precache-v3-new-wap-index-' + (self.registration ? self.registration.scope : '');

var ignoreUrlParametersMatching = [/^utm_/];

var addDirectoryIndex = function(originalUrl, index) {
    var url = new URL(originalUrl);
    if (url.pathname.slice(-1) === '/') {
        url.pathname += index;
    }
    return url.toString();
};
var cleanResponse = function(originalResponse) {
    // If this is not a redirected response, then we don't have to do anything.
    if (!originalResponse.redirected) {
        return Promise.resolve(originalResponse);
    }
    // Firefox 50 and below doesn't support the Response.body stream, so we may
    // need to read the entire body to memory as a Blob.
    var bodyPromise = 'body' in originalResponse ?
        Promise.resolve(originalResponse.body) :
        originalResponse.blob();
    return bodyPromise.then(function(body) {
        // new Response() is happy when passed either a stream or a Blob.
        return new Response(body, {
            headers: originalResponse.headers,
            status: originalResponse.status,
            statusText: originalResponse.statusText
        });
    });
};
var createCacheKey = function(originalUrl, paramName, paramValue,
                              dontCacheBustUrlsMatching) {
    // Create a new URL object to avoid modifying originalUrl.
    var url = new URL(originalUrl);
    // If dontCacheBustUrlsMatching is not set, or if we don't have a match,
    // then add in the extra cache-busting URL parameter.
    if (!dontCacheBustUrlsMatching ||
        !(url.pathname.match(dontCacheBustUrlsMatching))) {
        url.search += (url.search ? '&amp;' : '') +
            encodeURIComponent(paramName) + '=' + encodeURIComponent(paramValue);
    }
    return url.toString();
};
var isPathWhitelisted = function(whitelist, absoluteUrlString) {
    // If the whitelist is empty, then consider all URLs to be whitelisted.
    if (whitelist.length === 0) {
        return true;
    }
    // Otherwise compare each path regex to the path of the URL passed in.
    var path = (new URL(absoluteUrlString)).pathname;
    return whitelist.some(function(whitelistedPathRegex) {
        return path.match(whitelistedPathRegex);
    });
};
var stripIgnoredUrlParameters = function(originalUrl,
                                         ignoreUrlParametersMatching) {
    var url = new URL(originalUrl);
    // Remove the hash; see https://github.com/GoogleChrome/sw-precache/issues/290
    url.hash = '';
    url.search = url.search.slice(1) // Exclude initial '?'
        .split('&amp;') // Split into an array of 'key=value' strings
        .map(function(kv) {
            return kv.split('='); // Split each 'key=value' string into a [key, value] array
        })
        .filter(function(kv) {
            return ignoreUrlParametersMatching.every(function(ignoredRegex) {
                return !ignoredRegex.test(kv[0]); // Return true iff the key doesn't match any of the regexes.
            });
        })
        .map(function(kv) {
            return kv.join('='); // Join each [key, value] array into a 'key=value' string
        })
        .join('&amp;'); // Join the array of 'key=value' strings into a string with '&amp;' in between each
    return url.toString();
};

var hashParamName = '_sw-precache';
//定義需要緩存的 url 列表
var urlsToCacheKeys = new Map(
    precacheConfig.map(function(item) {
        var relativeUrl = item[0];
        var hash = item[1];
        var absoluteUrl = new URL(relativeUrl, self.location);
        var cacheKey = createCacheKey(absoluteUrl, hashParamName, hash, false);
        return [absoluteUrl.toString(), cacheKey];
    })
);
//把 cache 中的 url 提取出來,進行去重操作
function setOfCachedUrls(cache) {
    return cache.keys().then(function(requests) {
        //提取 url
        return requests.map(function(request) {
            return request.url;
        });
    }).then(function(urls) {
        //去重
        return new Set(urls);
    });
}
//sw 安裝階段
self.addEventListener('install', function(event) {
    event.waitUntil(
        //首先嚐試取出存在客戶端 cache 中的數據
        caches.open(cacheName).then(function(cache) {
            return setOfCachedUrls(cache).then(function(cachedUrls) {
                return Promise.all(
                    Array.from(urlsToCacheKeys.values()).map(function(cacheKey) {
                        //如果需要緩存的 url 不在當前 cache 中,則添加到 cache
                        if (!cachedUrls.has(cacheKey)) {
                            //設置 same-origin 是為了兼容舊版本 safari 中其默認值不為 same-origin,
                            //只有當 URL 與響應腳本同源才發送 cookies、 HTTP Basic authentication 等驗證信息
                            var request = new Request(cacheKey, {credentials: 'same-origin'});
                            return fetch(request).then(function(response) {
                                //通過 fetch api 請求資源
                                if (!response.ok) {
                                    throw new Error('Request for ' + cacheKey + ' returned a ' +
                                        'response with status ' + response.status);
                                }
                                return cleanResponse(response).then(function(responseToCache) {
                                    //並設置到當前 cache 中
                                    return cache.put(cacheKey, responseToCache);
                                });
                            });
                        }
                    })
                );
            });
        }).then(function() {

            //強制跳過等待階段,進入激活階段
            return self.skipWaiting();

        })
    );
});
self.addEventListener('activate', function(event) {
    //清除 cache 中原來老的一批相同 key 的數據
    var setOfExpectedUrls = new Set(urlsToCacheKeys.values());
    event.waitUntil(
        caches.open(cacheName).then(function(cache) {
            return cache.keys().then(function(existingRequests) {
                return Promise.all(
                    existingRequests.map(function(existingRequest) {
                        if (!setOfExpectedUrls.has(existingRequest.url)) {
                            //cache 中刪除指定對象
                            return cache.delete(existingRequest);
                        }
                    })
                );
            });
        }).then(function() {
            //self 相當於 webworker 線程的當前作用域
            //當一個 service worker 被初始註冊時，頁面在下次加載之前不會使用它。 claim() 方法會立即控制這些頁面
            //從而更新客戶端上的 serviceworker
            return self.clients.claim();

        })
    );
});

self.addEventListener('fetch', function(event) {
    if (event.request.method === 'GET') {
        // 標識位,用來判斷是否需要緩存
        var shouldRespond;
        // 對 url 進行一些處理,移除一些不必要的參數
        var url = stripIgnoredUrlParameters(event.request.url, ignoreUrlParametersMatching);
        // 如果該 url 不是我們想要緩存的 url,置為 false
        shouldRespond = urlsToCacheKeys.has(url);
        // 如果 shouldRespond 未 false,再次驗證
        var directoryIndex = 'index.html';
        if (!shouldRespond &amp;&amp; directoryIndex) {
            url = addDirectoryIndex(url, directoryIndex);
            shouldRespond = urlsToCacheKeys.has(url);
        }
        // 再次驗證,判斷其是否是一個 navigation 類型的請求
        var navigateFallback = '';
        if (!shouldRespond &amp;&amp;
            navigateFallback &amp;&amp;
            (event.request.mode === 'navigate') &amp;&amp;
            isPathWhitelisted([], event.request.url)) {
            url = new URL(navigateFallback, self.location).toString();
            shouldRespond = urlsToCacheKeys.has(url);
        }
        // 如果標識位為 true
        if (shouldRespond) {
            event.respondWith(
                caches.open(cacheName).then(function(cache) {
                    //去緩存 cache 中找對應的 url 的值
                    return cache.match(urlsToCacheKeys.get(url)).then(function(response) {
                        //如果找到了,就返回 value
                        if (response) {
                            return response;
                        }
                        throw Error('The cached response that was expected is missing.');
                    });
                }).catch(function(e) {
                    // 如果沒找到則請求該資源
                    console.warn('Couldn\'t serve response for "%s" from cache: %O', event.request.url, e);
                    return fetch(event.request);
                })
            );
        }
    }
});
</code></pre><p>這裏的策略大概就是優先在 Cache 中尋找資源，如果找不到再請求資源。可以看出，為了實現一個較為簡單的緩存，還是比較複雜和繁瑣的，所以很多工具就應運而生了。</p><h1>Workbox</h1><p>由於直接寫原生的 sw.js，比較繁瑣和複雜，所以一些工具就出現了，而 Workbox 是其中的佼佼者，由 google 團隊推出。</p><h2>簡介</h2><p>在 Workbox 之前，GoogleChrome 團隊較早時間推出過 sw-precache 和 sw-toolbox 庫，但是在 GoogleChrome 工程師們看來，workbox 才是真正能方便統一的處理離線能力的更完美的方案，所以停止了對 sw-precache 和 sw-toolbox 的維護。</p><h2>使用者</h2><p>有很多團隊也是啓用該工具來實現 serviceworker 的緩存，比如説：</p><ul><li>淘寶首頁</li><li>網易新聞 wap 文章頁</li><li>百度的 Lavas</li></ul><h2>基本配置</h2><p>首先，需要在項目的 sw.js 文件中，引入 Workbox 的官方 js，這裏用了我們自己的靜態資源：</p><pre><code>importScripts(
    "https://edu-cms.nosdn.127.net/topics/js/workbox_9cc4c3d662a4266fe6691d0d5d83f4dc.js"
);
</code></pre><p>其中 importScripts 是 webworker 中加載 js 的方式。</p><p>引入 Workbox 後，全局會掛載一個 Workbox 對象</p><pre><code>if (workbox) {
    console.log('workbox 加載成功');
} else {
    console.log('workbox 加載失敗');
}
</code></pre><p>然後需要在使用其他的 api 前，提前使用配置</p><pre><code>//關閉控制枱中的輸出
workbox.setConfig({ debug: false });
</code></pre><p>也可以統一指定存儲時 Cache 的名稱：</p><pre><code>//設置緩存 cachestorage 的名稱
workbox.core.setCacheNameDetails({
    prefix:'edu-cms',
    suffix:'v1'
});
</code></pre><h2>precache</h2><p>Workbox 的緩存分為兩種，一種的 precache，一種的 runtimecache。</p><p>precache 對應的是在 installing 階段進行讀取緩存的操作。它讓開發人員可以確定緩存文件的時間和長度，以及在不進入網絡的情況下將其提供給瀏覽器，這意味着它可以用於創建 Web 離線工作的應用。</p><h3>工作原理</h3><p>首次加載 Web 應用程序時，Workbox 會下載指定的資源，並存儲具體內容和相關修訂的信息在 indexedDB 中。</p><p>當資源內容和 sw.js 更新後，Workbox 會去比對資源，然後將新的資源存入 Cache，並修改 indexedDB 中的版本信息。</p><p>我們舉一個例子：</p><pre><code>workbox.precaching.precacheAndRoute([
    './main.css'
]);
</code></pre><p><img src="https://oscimg.oschina.net/oscnet/up-d8a79ba50b83bfbc538b960e07f0c707b17.png" alt="" referrerpolicy="no-referrer"></p><p>indexedDB 中會保存其相關信息</p><p><img src="https://oscimg.oschina.net/oscnet/up-b9f1c514f24a2b5121771fa9b59fb0cc82b.png" alt="" referrerpolicy="no-referrer"></p><p>這個時候我們把 main.css 的內容改變後，再刷新頁面，會發現除非強制刷新，否則 Workbox 還是會讀取 Cache 中存在的老的 main.css 內容。</p><p>即使我們把 main.css 從服務器上刪除，也不會對頁面造成影響。</p><p>所以這種方式的緩存都需要配置一個版本號。在修改 sw.js 時，對應的版本也需要變更。</p><h3>使用實踐</h3><p>當然了，一般我們的一些不經常變的資源，都會使用 cdn，所以這裏自然就需要支持域外資源了，配置方式如下：</p><pre><code>var fileList = [
    {
        url:'https://edu-cms.nosdn.127.net/topics/js/cms_specialWebCommon_js_f26c710bd7cd055a64b67456192ed32a.js'
    },
    {
        url:'https://static.ws.126.net/163/frontend/share/css/article.207ac19ad70fd0e54d4a.css'
    }
];


//precache 適用於支持跨域的 cdn 和域內靜態資源
workbox.precaching.suppressWarnings();
workbox.precaching.precacheAndRoute(fileList, {
    "ignoreUrlParametersMatching": [/./]
});
</code></pre><p>這裏需要對應的資源配置跨域允許頭，否則是不能正常加載的。且文件都要以版本文件名的方式，來確保修改後 Cache 和 indexDB 會得到更新。</p><p>理解了原理和實踐後，説明這種方式適合於上線後就不會經常變動的靜態資源。</p><h2>runtimecache</h2><p>運行時緩存是在 install 之後，activated 和 fetch 階段做的事情。</p><p>既然在 fetch 階段發送，那麼 runtimecache 往往應對着各種類型的資源，對於不同類型的資源往往也有不同的緩存策略。</p><h3>緩存策略</h3><p>Workbox 提供的緩存策劃有以下幾種，通過不同的配置可以針對自己的業務達到不同的效果：</p><h3>Stale While Revalidate</h3><p>這種策略的意思是當請求的路由有對應的 Cache 緩存結果就直接返回，</p><p>在返回 Cache 緩存結果的同時會在後台發起網絡請求拿到請求結果並更新 Cache 緩存，如果本來就沒有 Cache 緩存的話，直接就發起網絡請求並返回結果，這對用戶來説是一種非常安全的策略，能保證用戶最快速的拿到請求的結果。</p><p>但是也有一定的缺點，就是還是會有網絡請求佔用了用戶的網絡帶寬。可以像如下的方式使用 State While Revalidate 策略：</p><pre><code>workbox.routing.registerRoute(
    new RegExp('https://edu-cms\.nosdn\.127\.net/topics/'),
    workbox.strategies.staleWhileRevalidate({
        //cache 名稱
        cacheName: 'lf-sw:static',
        plugins: [
            new workbox.expiration.Plugin({
                //cache 最大數量
                maxEntries: 30
            })
        ]
    })
);
</code></pre><h3>Network First</h3><p>這種策略就是當請求路由是被匹配的，就採用網絡優先的策略，也就是優先嚐試拿到網絡請求的返回結果，如果拿到網絡請求的結果，就將結果返回給客戶端並且寫入 Cache 緩存。</p><p>如果網絡請求失敗，那最後被緩存的 Cache 緩存結果就會被返回到客戶端，這種策略一般適用於返回結果不太固定或對實時性有要求的請求，為網絡請求失敗進行兜底。可以像如下方式使用 Network First 策略：</p><pre><code>//自定義要緩存的 html 列表
var cacheList = [
    '/Hexo/public/demo/PWADemo/workbox/index.html'
];
workbox.routing.registerRoute(
    //自定義過濾方法
    function(event) {
        // 需要緩存的 HTML 路徑列表
        if (event.url.host === 'localhost:63342') {
            if (~cacheList.indexOf(event.url.pathname)) return true;
            else return false;
        } else {
            return false;
        }
    },
    workbox.strategies.networkFirst({
        cacheName: 'lf-sw:html',
        plugins: [
            new workbox.expiration.Plugin({
                maxEntries: 10
            })
        ]
    })
);
</code></pre><h3>Cache First</h3><p>這個策略的意思就是當匹配到請求之後直接從 Cache 緩存中取得結果，如果 Cache 緩存中沒有結果，那就會發起網絡請求，拿到網絡請求結果並將結果更新至 Cache 緩存，並將結果返回給客戶端。這種策略比較適合結果不怎麼變動且對實時性要求不高的請求。可以像如下方式使用 Cache First 策略：</p><pre><code>workbox.routing.registerRoute(
    new RegExp('https://edu-image\.nosdn\.127\.net/'),
    workbox.strategies.cacheFirst({
        cacheName: 'lf-sw:img',
        plugins: [
            //如果要拿到域外的資源，必須配置
            //因為跨域使用 fetch 配置了
            //mode: 'no-cors',所以 status 返回值為 0，故而需要兼容
            new workbox.cacheableResponse.Plugin({
                statuses: [0, 200]
            }),
            new workbox.expiration.Plugin({
                maxEntries: 40,
                //緩存的時間
                maxAgeSeconds: 12 * 60 * 60
            })
        ]
    })
);
</code></pre><h3>Network Only</h3><p>比較直接的策略，直接強制使用正常的網絡請求，並將結果返回給客戶端，這種策略比較適合對實時性要求非常高的請求。</p><h3>Cache Only</h3><p>這個策略也比較直接，直接使用 Cache 緩存的結果，並將結果返回給客戶端，這種策略比較適合一上線就不會變的靜態資源請求。</p><h2>舉個栗子</h2><p>又到了舉個栗子的階段了，這次我們用淘寶好了，看看他們是如何通過 Workbox 來配置 Service Worker 的：</p><pre><code>//首先是異常處理
self.addEventListener('error', function(e) {
  self.clients.matchAll()
    .then(function (clients) {
      if (clients &amp;&amp; clients.length) {
        clients[0].postMessage({ 
          type: 'ERROR',
          msg: e.message || null,
          stack: e.error ? e.error.stack : null
        });
      }
    });
});

self.addEventListener('unhandledrejection', function(e) {
  self.clients.matchAll()
    .then(function (clients) {
      if (clients &amp;&amp; clients.length) {
        clients[0].postMessage({
          type: 'REJECTION',
          msg: e.reason ? e.reason.message : null,
          stack: e.reason ? e.reason.stack : null
        });
      }
    });
})
//然後引入 workbox
importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js');
workbox.setConfig({
  debug: false,
  modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/'
});
//直接激活跳過等待階段
workbox.skipWaiting();
workbox.clientsClaim();
//定義要緩存的 html
var cacheList = [
  '/',
  '/tbhome/home-2017',
  '/tbhome/page/market-list'
];
//html 採用 networkFirst 策略，支持離線也能大體訪問
workbox.routing.registerRoute(
  function(event) {
    // 需要緩存的 HTML 路徑列表
    if (event.url.host === 'www.taobao.com') {
      if (~cacheList.indexOf(event.url.pathname)) return true;
      else return false;
    } else {
      return false;
    }
  },
  workbox.strategies.networkFirst({
    cacheName: 'tbh:html',
    plugins: [
      new workbox.expiration.Plugin({
        maxEntries: 10
      })
    ]
  })
);
//靜態資源採用 staleWhileRevalidate 策略，安全可靠
workbox.routing.registerRoute(
  new RegExp('https://g\.alicdn\.com/'),
  workbox.strategies.staleWhileRevalidate({
    cacheName: 'tbh:static',
    plugins: [
      new workbox.expiration.Plugin({
        maxEntries: 20
      })
    ]
  })
);
//圖片採用 cacheFirst 策略，提升速度
workbox.routing.registerRoute(
  new RegExp('https://img\.alicdn\.com/'),
  workbox.strategies.cacheFirst({
    cacheName: 'tbh:img',
    plugins: [
      new workbox.cacheableResponse.Plugin({
        statuses: [0, 200]
      }),
      new workbox.expiration.Plugin({
        maxEntries: 20,
        maxAgeSeconds: 12 * 60 * 60
      })
    ]
  })
);

workbox.routing.registerRoute(
  new RegExp('https://gtms01\.alicdn\.com/'),
  workbox.strategies.cacheFirst({
    cacheName: 'tbh:img',
    plugins: [
      new workbox.cacheableResponse.Plugin({
        statuses: [0, 200]
      }),
      new workbox.expiration.Plugin({
        maxEntries: 30,
        maxAgeSeconds: 12 * 60 * 60
      })
    ]
  })
);
</code></pre><p>可以看出，使用 Workbox 比起直接手擼來，要快很多，也明確很多。</p><h2>原理</h2><p>目前分析 Service Worker 和 Workbox 的文章不少，但是介紹 Workbox 原理的文章卻不多。這裏簡單介紹下 Workbox 這個工具庫的原理。</p><p>首先將幾個我們產品用到的模塊圖奉上：</p><p><img src="https://oscimg.oschina.net/oscnet/up-b22e014db049eea325d28de53c9b6b9cd76.png" alt="" referrerpolicy="no-referrer"></p><p>簡單提幾個 Workbox 源碼的亮點。</p><h3>通過 Proxy 按需依賴</h3><p>熟悉了 Workbox 後會得知，它是有很多個子模塊的，各個子模塊再通過用到的時候按需 importScript 到線程中。 <img src="https://oscimg.oschina.net/oscnet/up-12e98258edc4bd13e5ad48a74c9835ede68.png" alt="" referrerpolicy="no-referrer"></p><p>做到按需依賴的原理就是通過 Proxy 對全局對象 Workbox 進行代理：</p><pre><code>new Proxy(this, {
  get(t, s) {
    //如果 workbox 對象上不存在指定對象，就依賴注入該對象對應的腳本
    if (t[s]) return t[s];
    const o = e[s];
    return o &amp;&amp; t.loadModule(`workbox-${o}`), t[s];
  }
})
</code></pre><p>如果找不到對應模塊，則通過 importScripts 主動加載：</p><pre><code>/**
 * 加載前端模塊
 * @param {Strnig} t 
 */
loadModule(t) {
  const e = this.o(t);
  try {
    importScripts(e), (this.s = !0);
  } catch (s) {
    throw (console.error(`Unable to import module '${t}' from '${e}'.`), s);
  }
}
</code></pre><h3>通過 freeze 凍結對外暴露 api</h3><p>Workbox.core 模塊中提供了幾個核心操作模塊，如封裝了 indexedDB 操作的 DBWrapper、對 Cache Storage 進行讀取的 Cache Wrapper，以及發送請求的 fetchWrapper 和日誌管理的 logger 等等。</p><p>為了防止外部對內部模塊暴露出去的 api 進行修改，導致出現不可預估的錯誤，內部模塊可以通過 Object.freeze 將 api 進行凍結保護：</p><pre><code>var _private = /*#__PURE__*/Object.freeze({
    DBWrapper: DBWrapper,
    WorkboxError: WorkboxError,
    assert: finalAssertExports,
    cacheNames: cacheNames,
    cacheWrapper: cacheWrapper,
    fetchWrapper: fetchWrapper,
    getFriendlyURL: getFriendlyURL,
    logger: defaultExport
  });
</code></pre><h1>總結</h1><p>通過對 Service Worker 的理解和 Workbox 的應用，可以進一步提升產品的性能和弱網情況下的體驗。有興趣的同學也可以對 Workbox 的源碼細細評讀，其中還有很多不錯的設計模式和編程風格值得學習。</p><p><img src="https://oscimg.oschina.net/oscnet/up-a546d4d52ff6cdf625f4d4a4890fd454bec.png" alt="" referrerpolicy="no-referrer"></p><p><strong>-END-</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 28 Oct 2023 10:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/youdaotech/blog/5054309</guid>
            <link>https://my.oschina.net/youdaotech/blog/5054309</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Wasmer 開源 WinterJS：Rust 編寫的 Service Worker]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>Wasmer 團隊開源了一款用 Rust 編寫的<strong> JavaScript Service Worker：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwasmer.io%2Fposts%2Fannouncing-winterjs-service-workers" target="_blank">WinterJS</a></u></strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-6382fe02fb5cbb80e1cb6951156b73e1143.png" referrerpolicy="no-referrer"></p><p><em>WinterJS 開源地址：<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwasmerio%2Fwinterjs" target="_blank">https://github.com/wasmerio/winterjs</a></u></em></p><p>據介紹，WinterJS 使用 SpiderMonkey 運行時執行 JavaScript（與 Firefox 使用的運行時相同），並遵循 WinterCG 規範，目的是最大限度地兼容 Cloudflare Workers、Deno Deploy 和 Vercel 等其他服務（因此命名為 WinterJS）。</p><p>WinterJS 除了速度極快，還能通過 WASIX <strong>編譯成 WebAssembly</strong>，因此完全支持在 Wasmer 上運行。</p><ul><li><strong>使用示例</strong></li></ul><p><strong>創建<code>serviceworker.js</code>文件，並返回 "hello world"</strong></p><pre><code class="language-javascript">$ wasmer run wasmer/winterjs --net --mapdir /app:. /app/serviceworker.js</code></pre><pre><code class="language-javascript">addEventListener('fetch', (req) =&gt; {
  req.respondWith(`hello world from ${req.request.url.href}`);
});</code></pre><blockquote><p>Wasmer 是支持 WASI 和 Emscripten 的通用 WebAssembly 運行時，提供基於 WebAssembly 的超輕量級容器，專注於支持在任何平台上運行 WASM 代碼：從桌面端到雲端、以及 IoT 設備，並且能嵌入在任何編程語言中。</p><p><img alt="" src="https://static.oschina.net/uploads/space/2023/0627/173716_02s8_2720166.png" referrerpolicy="no-referrer"></p><p>Wasmer 憑藉其多樣化的支持和專注於從通用桌面應用程序到 「便攜式 ML/AI 應用程序」 的領域，目前仍然是領先的 WASM 運行時之一。</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Sat, 28 Oct 2023 10:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/263968/winterjs-service-workers</guid>
            <link>https://www.oschina.net/news/263968/winterjs-service-workers</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[libnop - C++ 本機對象協議]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><div data-traceid="project_detail_above_text_link_1" data-tracepid="project_detail_above_text_link"><a style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" target="_blank">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代 <img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div></div><p>libnop 是一個僅用於序列化和反序列化 C++數據類型的頭庫，無需外部代碼生成器或運行時支持庫。唯一的強制性要求是一個支持 C++14 標準的編譯器。</p><hr><p style="color:#1f2328; text-align:start"><strong>libnop 有以下目標：</strong></p><ul><li>使簡單的序列化任務變得容易，使複雜的任務變得易於處理。</li><li>在 C++語言中移除對代碼生成器和模式文件描述數據類型、格式和協議的依賴。</li><li>避免運行序列化操作時可能需要的額外運行時間。</li><li>提供現代功能，如雙向二進制兼容性、數據驗證、類型安全性和類型可替代性。</li><li>以最少的工作量處理內部類型、常見的 STL 類型和容器以及用戶定義的類型。</li><li>生成易於分析的代碼。</li><li>避免動態內存的分配時使用。</li></ul></div>
                                                                ]]>
            </description>
            <pubDate>Sat, 28 Oct 2023 07:36:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/libnop</guid>
            <link>https://www.oschina.net/p/libnop</link>
        </item>
        <item>
            <title>
                <![CDATA[Next.js 支持在前端代碼中寫 SQL，開倒車還是遙遙領先？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>下面這張圖來自近日舉辦的&nbsp;Next.js Conf 2023，裏面的代碼使用了名為<strong>「Server Actions」</strong>的特性——在前端代碼中使用 SQL 語句直接操作數據庫。</p><blockquote><p>Next.js 是流行的開源前端框架，其開發商是知名創業公司 Vercel。</p><p>Next.js 提供了包括服務器端渲染和為 Web 應用程序生成靜態網站在內的功能。Vercel 作為一個開放的雲平台提供了網站託管服務，讓開發者能夠在上面開發、預覽和發佈 Web 應用，同時優化了前端開發者的開發和部署體驗。</p></blockquote><p><img alt="" height="533" src="https://oscimg.oschina.net/oscnet/up-e254f1c847ae20e8c530b34f9021da3a4d0.png" width="400" referrerpolicy="no-referrer"></p><p>在最新發布的 Next.js 14 中，Server Actions 已到達穩定階段。其團隊表示，Server Actions 改進了開發者在編寫數據變更方面的體驗。</p><blockquote><p><em><u><a href="https://www.oschina.net/news/263948/next-js-14" target="_blank">Next.js 14 發佈：Server Actions 已穩定、部分預渲染進入預覽</a></u></em></p></blockquote><p>Server Actions 允許開發者定義異步服務器函數，他們可以使用 Server Actions 重新驗證緩存數據、重定向到不同的路由、設置和讀取 cookie 等等。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-77eb78e36979830a06c1f44ed2476bb4db1.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0ad921306554c0716b4b4b0a8bedb71b8ba.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-badb8152ef443eb8272d03c220e0450c723.png" referrerpolicy="no-referrer"></p><p>不過目前看來，大多數人對它的評價似乎並不太好 ——</p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1029/122449_wEe4_2720166.png" referrerpolicy="no-referrer"></p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Sat, 28 Oct 2023 04:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/263921/nextjs-server-actions</guid>
            <link>https://www.oschina.net/news/263921/nextjs-server-actions</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Linux Mint]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="ad-wrap" style="margin-bottom: 8px;"><a data-traceid="news_detail_above_text_link_1" data-tracepid="news_detail_above_text_link" style="color:#A00; font-weight:bold;" href="https://www.oschina.net/event/2331193" _blank"="">OSC 請你來轟趴啦！1028 蘇州源創會，一起尋寶 AI 時代<img src="https://www.oschina.net/img/hot3.png" align="absmiddle" style="max-height: 32px;max-width: 32px;margin-top: -4px;" referrerpolicy="no-referrer"></a></div><p>Linux Mint 團隊在最新月度報告中<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.linuxmint.com%2F%3Fp%3D4591" target="_blank">提到</a></u>，他們已經開始着手開發對 Wayland 的支持。</p><p>團隊稱這項工作是他們在很長一段時間內必須面對的主要挑戰之一，雖然他們不期待 Wayland 能很快取代 Xorg 作為默認值，無論是在 21.3 中，還是在 22.x 中，但仍然希望做好準備。</p><p>按照計劃，Cinnamon 6.0 計劃在今年的 Mint 21.3 中推出，<strong>並將提供實驗性的 Wayland 支持</strong>。用戶可以從登錄界面在默認 Cinnamon 會話（在 Xorg 上運行）和 Cinnamon on Wayland 之間進行選擇。</p><p>下圖是 Cinnamon on Wayland 的運行截圖：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-21b9daccab538fe5909df6cef6b172695f5.png" referrerpolicy="no-referrer"></p><p>Linux Mint 團隊表示，他們可能在 2026 年實現對 Wayland 的穩定支持/默認支持。鑑於 Linux Mint 堅持以 Ubuntu LTS 為基礎，因此並不指望在 Ubuntu 24.04 LTS 之前就能支持 Wayland。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 28 Oct 2023 04:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/263917/linux-mint-wayland-progress</guid>
            <link>https://www.oschina.net/news/263917/linux-mint-wayland-progress</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
    </channel>
</rss>
