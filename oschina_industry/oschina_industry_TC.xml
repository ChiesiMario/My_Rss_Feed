<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-綜合資訊]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 02 Jan 2024 04:08:20 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[TinyEngine 服務端正式開源啦]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h1>背景介紹</h1><h2>TinyEngine 低代碼引擎介紹</h2><p>隨着企業對於低代碼開發平台的需求日益增長，急需一個通用的解決方案來滿足各種低代碼平台的開發需求。正是在這種情況下，低代碼引擎應運而生。它是一種通用的開發框架，通過對低代碼平台系統常用的功能進行解構，將其劃分為多個功能模塊，併為每個模塊定義了相應的協議和開發範式，使得開發者可以根據自身的業務需求，輕鬆定製開發出自己的低代碼開發平台。</p><p>TinyEngine 提供了低代碼底層能力，並集成了人工智能，從而使用戶能夠高效開發。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a> 具有強大的拖拽功能，無論是圖元還是複雜組件，都能在畫布上帶來流暢的體驗。它適用於多場景的低代碼平台開發，包括資源編排、流程編排、服務端渲染、模型驅動、移動端、大屏端以及頁面編排等低代碼平台。</p><p>TinyEngine 官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine" target="_blank">https://opentiny.design/tiny-engine</a><br> TinyEngine 源碼：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">https://github.com/opentiny/tiny-engine</a> （歡迎 star）</p><p><img src="https://oscimg.oschina.net/oscnet/up-fa7423149eca45391380663a32b595b208f.png" alt="" referrerpolicy="no-referrer"></p><h2>服務端開源介紹</h2><p>2023 年 9 月 21 日，<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a> 在<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7280926568854667299" target="_blank">華為全聯接大會正式宣佈開源</a>，引發了廣泛的關注，3 個月時間收穫了 960 個 Star，組建了 4 個用戶交流社羣，成員數 772 名。</p><p>很多企業和個人開發者嘗試基於 TinyEngine 搭建自己的低代碼平台，為搭建企業 Web 應用提效，在使用過程中，大家也遇到了很多問題，比較常見的包括：如何對接服務端、如何導入第三方組件庫、如何使用插槽、如何生成代碼、如何開發自定義插件等，為此我們在 10 月 27 日策劃了一次<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjuejin.cn%2Fpost%2F7298642242116452402" target="_blank">線上直播答疑活動</a>，邀請了團隊技術專家為大家答疑解惑。</p><p>其中如何對接服務端是眾多開發者非常關注的問題，為了幫助開發者打通低代碼平台搭建的前後端整體流程，本次 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a> 低代碼引擎服務端配套代碼的開源，讓開發者能夠深入瞭解 TinyEngine 低代碼引擎的前後端運行機制，更能夠讓更多的小夥伴以更深的層次參與到產品共建，共同探討並改進系統，推動其不斷優化，帶來更高的創新潛力，使得更多的人能夠從中受益。</p><p>同時服務端的開源為自由定製和擴展提供了可能，開發者可以參考 TinyEngine 的代碼，根據自身需求對服務端進行改造創新，從而使得產品更具靈活性，能夠滿足各種複雜的業務需求，構建一個強大而健壯的 TinyEngine 生態系統。</p><h1>核心特性</h1><p>當今互聯網應用的複雜性和用戶需求的多樣性要求我們搭建一套靈活的、便於擴展的系統架構，以滿足不斷變化的業務需求。 因此我們引入了微服務的概念，將系統拆分為小而獨立的服務單元，使得每個服務單元都可以獨立開發、測試和部署。這種架構不僅提高了團隊的協作效率，還使得系統更容易擴展和維護。</p><ul><li>TinyEngine 設計器微服務選擇了<strong>基於 Node.js 的技術棧</strong>，為前端開發者提供了一致的開發體驗，無需學習額外的語言即可全棧開發，降低了開發難度和學習曲線，避免了學習新語言的困擾。更能夠從服務端的角度去理解 TinyEngine 設計器的運行原理與設計思想。</li><li>在我們的架構設計中，我們<strong>採用了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.eggjs.org%2Fzh-CN" target="_blank">Egg.js</a> 作為業務接口微服務的框架</strong>。Egg.js 優秀的設計和豐富的插件生態系統，使得我們能夠迅速構建可維護、可擴展的微服務，從而確保系統的穩定性和可維護性。</li><li>為了降低服務耦合，我們還單獨封裝了<strong>提供數據庫操作接口的數據中心微服務</strong>，在框架選型上我們選擇了 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.strapi.io%2F" target="_blank">Strapi</a>，Strapi 是一個開源數據管理框架。不僅提供了強大的數據管理和查詢功能，還支持自定義內容類型和靈活的 API 構建，為我們的微服務提供了豐富的數據支持。Strapi 的易用性和可擴展性使得我們能夠高效地管理和發佈數據，確保前端業務接口始終能夠獲得及時、準確的數據支持。</li></ul><p>綜上所述，我們的技術架構旨在提供高效、可維護、可擴展的系統，充分利用 Node.js 和現代化的開源工具，使我們能夠更好地滿足不斷變化的業務需求。這種架構不僅提高了開發效率，還為未來的擴展和創新提供了堅實的基礎。</p><h1>服務端架構</h1><p>根據上面的介紹，開發者可以根據微服務這一特性，輕鬆擴展並實現自己的 TinyEngine 服務端架構。</p><ul><li>業務接口微服務（webService）：構建業務的引擎， 彙總連接其他微服務為前端提供接口。</li><li>數據中心 (data-center)： 作為數據基座，統一進行數據管理，為其他微服務提供一致性的數據支持。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-f120981dacaac81db69e9a2f113ef113e3b.png" alt="" referrerpolicy="no-referrer"></p><p>根據上述架構特點，我們可以在此基礎上，通過核心的 webService (業務接口微服務) 搭配任務隊列服務 (RabbitMq、 Kafka、 RocketMq 等等) 連接其他功能微服務， 從而拓展整體系統的功能，例如：</p><ul><li>構建服務：由 webService 收集用戶請求觸發任務隊列執行耗費機器資源的構建設計器、區塊、物料的相關服務。</li><li>爬蟲服務：單獨封裝，安裝了 puppeteer 服務器的微服務，由 webService 觸發去執行一些爬取數據、代理登錄等等操作。</li><li>AI 大模型相關服務：連接自己內部 AI 大模型， 進行設計器智能化相關的 AI 代碼生成、指令操作等等功能的。</li><li>發佈服務：封裝自己的 CI/CD 流水線微服務，結合設計器代碼產出，使代碼生產-構建-部署一條龍式運作。</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-4558b19a5a930a638d800a5208bcb821d59.png" alt="" referrerpolicy="no-referrer"></p><h1>硬件配置</h1><h2>本地開發</h2><p>推薦使用 <code>windows</code> 操作系統， 推薦配置如下：</p><ul><li>64 位操作系統</li><li>12 核 CPU</li><li>32G 內存</li></ul><h2>服務容器化部署</h2><p>以下信息為支撐 50 qps 併發量的配置參考， 開發者可根據實際情況進行具體問題具體分析，配置信息僅供參考.</p><p>配置單位：</p><ul><li>U: cpu 核數</li><li>G: 內存單位</li></ul><p>在配置負載均衡的情況下推薦：</p><table><thead><tr><th>服務</th><th>配置</th><th>工作負載數量</th></tr></thead><tbody><tr><td>webService</td><td>1U+3G</td><td>4</td></tr><tr><td>data-center</td><td>1U+2G</td><td>4</td></tr></tbody></table><h1>FAQ</h1><p><strong>1、服務端開源之後，如果不想啓動 webservice 和 datacenter 兩個後端服務器，是否還能沿用原來 mockServer？</strong><br> 答：可以正常使用 mockServer，啓動方式和原先一致，直接在項目裏執行 <code>pnpm dev</code> 即可</p><p><strong>2、如果本地啓動了 webservice 和 datacenter，那麼前端本地工程是否還需要更改配置？如果需要，如何更改配置？</strong><br> 答：需要更改配置，更改流程如下： 啓動 <code>tinyengine</code></p><p>修改 <code>packages/design-core/vite.config.js</code> 中 origin 的值為自己本地 webService 項目的地址端口（webService 端口默認為 7011）</p><p>運行如下腳本並啓動</p><pre><code class="language-sh">pnpm install  # 第一次啓動項目需要
pnpm serve:frontend
</code></pre><p>啓動成功後瀏覽器會自動打開設計器頁面</p><p><img src="https://oscimg.oschina.net/oscnet/up-a0f5b0133144d2b27013c73bacbf232675f.png" alt="" referrerpolicy="no-referrer"></p><p>具體搭建流程可參考官網本地化部署文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhelp-center%2Fcourse%2Fbackend%2F51" target="_blank">TinyEngine 服務端開源部署 </a></p><h1>未來規劃</h1><p>1，人工智能：計劃將低代碼平台與 AIGC（人工智能生成內容）技術相結合，為用戶提供更加智能、高效的應用開發體驗。後續我們考慮將低代碼平台的開發流程與 AIGC 技術相結合，通過自然語言處理、機器學習和深度學習等技術，實現應用界面的自動生成、功能模塊的智能推薦和代碼的自動化生成等功能。</p><p>2，模型驅動：我們將致力於將低代碼平台與模型驅動能力相結合，為用戶提供更加高效、智能的開發體驗。深入研究各種業務模型，包括數據模型、業務流程模型等，以瞭解其特性和需求。後續，我們將低代碼平台的開發流程與模型驅動能力相結合，通過可視化建模工具和自動化技術，實現業務模型的快速構建和部署。通過這一創新性的接入方式，用戶將能夠更加高效地構建和調整業務模型，降低開發難度和成本。</p><h2><strong>關於 OpenTiny</strong></h2><p><img src="https://oscimg.oschina.net/oscnet/up-1c661a9c0916f9dabf9cf1c4aeba473fb68.png" alt="" referrerpolicy="no-referrer"></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">OpenTiny</a> 是一套企業級 Web 前端開發解決方案，提供跨端、跨框架、跨版本的&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-vue%2Fzh-CN%2Foverview" target="_blank">TinyVue 組件庫</a>，包含基於 Angular+TypeScript 的 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-ng%2Foverview" target="_blank">TinyNG 組件庫</a>，擁有靈活擴展的低代碼引擎 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-engine%23%2Fhome" target="_blank">TinyEngine</a>，具備主題配置系統<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Fdesigntheme%2Fhome" target="_blank">TinyTheme</a> / 中後台模板<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Fpro%2Fhome" target="_blank"> TinyPro</a>/ <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2Ftiny-cli%2Fhome" target="_blank">TinyCLI </a>命令行等豐富的效率提升工具，可幫助開發者高效開發 Web 應用。</p><hr><p>歡迎加入 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">OpenTiny 開源社區</a>。添加微信小助手：opentiny-official 一起參與交流前端技術～更多視頻內容也可關注<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspace.bilibili.com%2F15284299%3Fspm_id_from%3D333.1007.0.0" target="_blank">B 站</a>、抖音、小紅書、視頻號</p><p>OpenTiny&nbsp;也在持續招募貢獻者，歡迎一起共建</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">OpenTiny 官網</a>：<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopentiny.design%2F" target="_blank">https://opentiny.design/</a></strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">OpenTiny 代碼倉庫</a>：<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2F" target="_blank">https://github.com/opentiny/</a></strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">TinyVue 源碼</a>：<strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">https://github.com/opentiny/tiny-vue</a></strong></p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">TinyEngine 源碼</a>： <strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">https://github.com/opentiny/tiny-engine</a></strong></p><p>歡迎進入代碼倉庫 Star🌟<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-engine" target="_blank">TinyEngine</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-vue" target="_blank">TinyVue</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Fng" target="_blank">TinyNG</a>、<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopentiny%2Ftiny-cli" target="_blank">TinyCLI</a>~</p><p>如果你也想要共建，可以進入代碼倉庫，找到&nbsp;good first issue 標籤，一起參與開源貢獻~</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 03:45:53 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6769809/blog/10555626</guid>
            <link>https://my.oschina.net/u/6769809/blog/10555626</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 年化收入超 16 億美元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theinformation.com%2Farticles%2Fopenais-annualized-revenue-tops-1-6-billion-as-customers-shrug-off-ceo-drama" target="_blank">The Information</a> 援引知情人士消息稱，受益於 ChatGPT 產品的強勁增長，OpenAI 最近的年化收入已經從 10 月中旬的 13 億美元增至 16 億美元。</span></p><p><span style="color:#000000">這一增長表明，「即便該公司因為 11 月份的領導層危機為競爭對手提供了搶奪客戶的機會，但其仍能保持向企業銷售人工智能產品的業務勢頭。」</span></p><p><img height="307" src="https://oscimg.oschina.net/oscnet/up-bc1feecce3c765f974f328d2a2ace13b9a6.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#000000">OpenAI 於 2023 年 2 月推出 ChatGPT 服務的付費版本 ChatGPT Plus 後，銷售額開始快速增長。此前，該公司主要通過應用程序接口向開發者提供 AI 模型來進行創收。數據顯示，該公司 2022 年虧損 5.4 億美元，營收僅為 2800 萬美元。</span></p><p><span style="color:#000000">路透社報道稱，OpenAI 最初預計在 2023 年完成 2 億美元的銷售額。但事實證明，ChatGPT Plus 比預期的要更受歡迎：在 8 月份，OpenAI 的營收就突破了 10 億美元，10 月達到了 13 億美元。該公司的銷售勢頭預計將持續到 2024 年。OpenAI 的一些高管認為，截至年底，其年化經常性收入將增長近四倍，達到 50 億美元。</span></p><p><span style="color:#000000">「這種樂觀的前景表明，該公司可能不會僅僅依靠現有產品的需求來維持其銷售增長。特別是，它可能計劃推出新的 AI 服務，從而創造額外的收入來源。」</span></p><p><span style="color:#000000">OpenAI 收入的快速增長也可能有助於其在來年獲得投資者更高的估值。日前曾有<a href="https://www.oschina.net/news/272549/openai-valuation-100-billion-funding-round">消息稱</a>，OpenAI 正在以 1000 億美元或以上的估值籌集新一輪融資。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 03:21:17 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273759/openais-annualized-revenue-tops-1-6b</guid>
            <link>https://www.oschina.net/news/273759/openais-annualized-revenue-tops-1-6b</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[vivo 正式加入 CNCF 雲原生計算基金會]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><strong style="outline: 0px;visibility: visible;">vivo 近期完成了新會員的 Onboarding 流程， 已正式加入 CNCF 雲原生計算基金會</strong>（<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io" textvalue="https://www.cncf.io" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.cncf.io</a>）。<strong style="letter-spacing: 0.544px;outline: 0px;visibility: visible;"></strong></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><span style="text-align: center;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"><br></span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><span style="text-align: center;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100014267" data-ratio="0.5613346418056918" data-s="300,640" src="https://oscimg.oschina.net/oscnet/d2d6894b-bacd-42d9-b2d8-05a6782d0354.png" data-type="png" data-w="1019" style="letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" referrerpolicy="no-referrer"></span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><span style="text-align: center;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span></p><p><span style="background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">C</span><span style="background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">NCF 雲原生計算基金會 （Cloud Native Computing Foundation）是 Linux 基金會的一部分，是開源、供應商中立的雲原生計算生態組織，致力於雲原生應用推廣和普及。我們希望通過加入 CNCF 基金會</span><strong style="font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">，推動雲原生技術在 vivo 內部的應用和發展，助力自身業務高效交付；同時進一步加強與全球雲原生開源社區的交流溝通和知識分享，共同推動行業雲原生技術生態的可持續發展</strong><span style="background-color: rgb(255, 255, 255);font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;">。</span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;">在正式加入 CNCF 雲原生計算基金會之前，vivo 內部研發團隊積極探索與實踐雲原生技術，在多個業務場景下應用雲原生項目，助力業務發展。</p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100014268" data-ratio="0.43425925925925923" data-s="300,640" src="https://oscimg.oschina.net/oscnet/695497a4-859d-487c-b98b-7537cebc2053.jpg" data-type="jpeg" data-w="1080" style="" referrerpolicy="no-referrer"><span style="font-size: var(--articleFontsize);letter-spacing: 0.034em;text-align: justify;"></span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">vivo 在雲原生領域的項目採納現狀</span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;text-align: center;"><span style="color: rgb(136, 136, 136);font-size: 14px;">截止 2023 年 12 月</span></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;text-align: left;"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: right;visibility: visible;"><section style="padding: 10px;outline: 0px;display: inline-block;width: 677px;border-width: 1px;border-style: solid;border-color: transparent;background-color: rgb(239, 239, 239);height: auto;visibility: visible;"><section powered-by="xiumi.us" style="outline: 0px;font-size: 14px;text-align: justify;visibility: visible;"><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p><strong style="font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(239, 239, 239);outline: 0px;visibility: visible;">應用方面：</strong><br></p><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;">在雲原生領域的應用主要包括基於 Kubernetes 的容器編排、服務發現和負載均衡、容器鏡像管理、日誌收集和分析等場景。通過使用 Openkruise、Helm、Harbor、Containerd、Dragonfly、Fluentd 等開源項目與工具，vivo 實現了基於容器平台的應用發佈和管理，提高了業務交付效率和系統可靠性。</span></p></li></ul><p style="outline: 0px;visibility: visible;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p style="outline: 0px;visibility: visible;"><strong><span style="font-size: 15px;">容器平台能力建設方面：</span></strong></p><p style="outline: 0px;visibility: visible;"><strong><span style="font-size: 15px;"></span></strong><span style="font-size: 15px;letter-spacing: 0.544px;">主要包括基礎設施建設、平台架構設計和運維管理等方面。通過使用 Kubernetes 等容器編排技術，vivo 構建了一套完整的容器平台，包括容器集羣運維、容器網絡、存儲管理、應用發佈、安全管理等模塊，為企業內部多個業務線提供了穩定、可靠的容</span><span style="font-size: 15px;letter-spacing: 0.544px;">器平台。</span></p></li></ul><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;"><br></span></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p><span style="font-size: 15px;"><strong>敢於探索實踐方面：</strong></span></p><p><span style="font-size: 15px;"></span><span style="font-size: 15px;letter-spacing: 0.544px;">vivo 在雲原生領域勇於探索和實踐，積極參與開源社區和代碼貢獻，持續探索並推廣新技術及其應用場景。</span><span style="font-size: 15px;letter-spacing: 0.544px;">同時有積極參與 CNCF 應用交付 TAG 旗下相關工作組的貢獻，推廣和傳播平台工程相關的白皮書、成熟度模型等相關實踐和標準。</span></p></li></ul></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br style="outline: 0px;visibility: visible;"></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;">此外，vivo 持續保持與行業交流及合作，共同探索雲原生時代的軟件工程之道。2023 年 9 月由 Linux 基金會、雲原生計算基金會（CNCF）主辦的 <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.lfasiallc.com%2Fkubecon-cloudnativecon-open-source-summit-china%2F" textvalue="KubeCon + CloudNativeCon + Open Source Summit China" linktype="text" imgurl="" tab="outerlink" data-linktype="2">KubeCon + CloudNativeCon + Open Source Summit China</a> 在上海舉行，vivo 在平台工程專題做了 2 個主題分享。同時，我們也積極支持並參與 KCD 等區域性 Meetup 活動。</p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><p style="text-align: center;"><img class="rich_pages wxw-img" data-galleryid="" data-imgfileid="100014269" data-ratio="1.0716981132075472" data-s="300,640" src="https://oscimg.oschina.net/oscnet/8a9a6912-227d-44eb-ac54-faf41d593727.jpg" data-type="jpeg" data-w="1060" style="" referrerpolicy="no-referrer"></p><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;">未來，vivo 將持續探索與實踐雲原生技術，在 CNCF 雲原生基金會積極參與和貢獻，並與各成員持續加強交流合作。</p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;text-wrap: wrap;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);text-align: right;visibility: visible;"><section style="padding: 10px;outline: 0px;display: inline-block;width: 677px;border-width: 1px;border-style: solid;border-color: transparent;background-color: rgb(239, 239, 239);height: auto;visibility: visible;"><section powered-by="xiumi.us" style="outline: 0px;font-size: 14px;text-align: justify;visibility: visible;"><ul class="list-paddingleft-1" style="width: 555.438px;"><li><p><strong style="font-size: 15px;letter-spacing: 0.544px;outline: 0px;visibility: visible;">生產實踐方面：</strong><br></p><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;">將繼續推進雲原生技術在企業中的應用和發展，加強容器化和微服務能力，探索和實踐最新的容器化和微服務技術，基於此實踐積極向上遊提供反饋，最終提高我們自身的業務交付效率和用戶體驗。</span></p></li></ul><p style="outline: 0px;visibility: visible;"><br></p><ul class="list-paddingleft-1" style="width: 555.438px;"><li><p style="outline: 0px;visibility: visible;"><strong><span style="font-size: 15px;">社區貢獻方面：</span></strong></p><p style="outline: 0px;visibility: visible;"><span style="font-size: 15px;">以企業中應用雲原生技術遇到的實際問題為推動力，加強與 CNCF 組織和其他企業的技術交流與合作，積極參與 CNCF 項目開發和相關工作組的貢獻並傳播雲原生技術<span style="font-size: 15px;letter-spacing: 0.544px;">。</span></span><span style="font-size: 15px;letter-spacing: 0.544px;"></span></p></li></ul></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;text-wrap: wrap;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;background-color: rgb(255, 255, 255);visibility: visible;"><br></p><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;visibility: visible;"><section style="padding-bottom: 3px;outline: 0px;display: inline-block;vertical-align: middle;border-bottom: 1px solid rgb(65, 95, 255);border-top-color: rgb(65, 95, 255);border-right-color: rgb(65, 95, 255);border-left-color: rgb(65, 95, 255);visibility: visible;"><section style="outline: 0px;border-bottom: 3px solid rgb(65, 95, 255);border-top-color: rgb(65, 95, 255);border-right-color: rgb(65, 95, 255);border-left-color: rgb(65, 95, 255);font-size: 16px;color: rgb(65, 95, 255);visibility: visible;"><p style="outline: 0px;visibility: visible;">關於 CNCF</p></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br style="outline: 0px;letter-spacing: 0.578px;visibility: visible;"></p><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);line-height: 1.5;visibility: visible;"><p style="outline: 0px;text-align: left;visibility: visible;"><img class="rich_pages wxw-img js_insertlocalimg" data-cropselx1="0" data-cropselx2="200" data-cropsely1="0" data-cropsely2="77" data-imgfileid="100014263" data-ratio="0.16574074074074074" data-s="300,640" src="https://oscimg.oschina.net/oscnet/55ece88a-d979-4dbb-941c-1ed46907bd24.jpg" data-type="png" data-w="1080" style="outline: 0px;visibility: visible !important;width: 465px;height: 77px;" referrerpolicy="no-referrer"></p></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;justify-content: flex-start;display: flex;flex-flow: row;visibility: visible;"><section style="padding-left: 8px;outline: 0px;display: inline-block;width: 578px;vertical-align: top;border-left: 3px solid rgb(219, 219, 219);border-bottom-left-radius: 0px;align-self: flex-start;flex: 0 0 auto;visibility: visible;"><section powered-by="xiumi.us" style="outline: 0px;color: rgba(0, 0, 0, 0.5);text-align: justify;visibility: visible;"><p style="outline: 0px;visibility: visible;">使命：讓雲原生無處不在</p></section></section></section><p powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;"><br style="outline: 0px;visibility: visible;"></p><section powered-by="xiumi.us" style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);"><p style="outline: 0px;">CNCF 雲原生計算基金會 (Cloud Native Computing Foundation, https://www.cncf.io/）成立於 2015 年 12 月，是非營利性 Linux 基金會（https://www.linuxfoundation.org/）的一部分，其使命是「讓雲原生技術無處不在」（參考 CNCF 章程 ）。</p><p style="outline: 0px;"><br style="outline: 0px;"></p><p style="outline: 0px;">CNCF 致力於培育和維護一個廠商中立的開源生態系統，來推廣雲原生技術，託管全球技術基礎設施的關鍵組件。通過將最前沿的模式民主化，讓這些創新為大眾所用。CNCF 彙集了世界頂級的開發者、最終用戶和供應商，並舉辦了最大的開源開發者大會。</p><p style="outline: 0px;"><br></p><p style="outline: 0px;"><span style="letter-spacing: 0.544px;text-align: center;">相關資料：</span></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li><p>Linux 基金會</p><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linuxfoundation.org%2F" textvalue="https://www.linuxfoundation.org/" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.linuxfoundation.org/</a></p></li><li><p>CNCF 雲原生計算基金會</p><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io%2F" textvalue="https://www.cncf.io/" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://www.cncf.io/</a></p></li><li><p>CNCF 章程</p></li></ul><p><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcncf%2Ffoundation%2Fblob%2Fmain%2Fcharter.md" textvalue="https://github.com/cncf/foundation/blob/main/charter.md" linktype="text" imgurl="" tab="outerlink" data-linktype="2">https://github.com/cncf/foundation/blob/main/charter.md</a></p><p><br></p></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;"><section style="padding: 3px;outline: 0px;display: inline-block;border-bottom: 1px solid rgb(65, 95, 255);color: rgb(65, 95, 255);"><p style="outline: 0px;">關注我們</p></section></section><section powered-by="xiumi.us" style="margin-top: 10px;margin-bottom: 10px;outline: 0px;font-family: system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);text-align: left;justify-content: flex-start;display: flex;flex-flow: row;"><section style="padding: 22px;outline: 0px;display: inline-block;width: 677px;vertical-align: top;align-self: flex-start;flex: 0 0 auto;background-color: rgb(247, 247, 247);"><section powered-by="xiumi.us" style="outline: 0px;text-align: justify;"><ul class="list-paddingleft-1" style="padding-left: 40px;outline: 0px;list-style-position: outside;"><li style="outline: 0px;"><p style="outline: 0px;">【移動 OSS】</p><p style="outline: 0px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopensource.vivo.com%2F" textvalue="https://opensource.vivo.com" linktype="text" imgurl="" tab="outerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">https://opensource.vivo.com</a></p></li><li style="outline: 0px;"><p style="outline: 0px;">【互聯網 OSS】</p><p style="outline: 0px;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvivo" textvalue="https://github.com/vivo&nbsp;" linktype="text" imgurl="" tab="outerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">https://github.com/vivo&nbsp;</a></p></li><li style="outline: 0px;"><p style="outline: 0px;">【<span style="outline: 0px;letter-spacing: 0.578px;">開源頻道</span>】@vivo 互聯網技術&nbsp;&nbsp;<a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26action%3Dgetalbum%26album_id%3D2951473838086422533%23wechat_redirect" textvalue="#開源&nbsp;" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">#開源&nbsp;</a></p></li></ul></section></section></section><p><br></p><section class="mp_profile_iframe_wrp"><mp-common-profile class="js_uneditable custom_select_card mp_profile_iframe" data-pluginname="mpprofile" data-id="MzI4NjY4MTU5Nw==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png" data-nickname="vivo 互聯網技術" data-alias="vivoVMIC" data-signature="分享 vivo 互聯網技術乾貨與沙龍活動，推薦最新行業動態與熱門會議。" data-from="0" data-is_biz_ban="0"></mp-common-profile></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公眾號 - vivo 互聯網技術（vivoVMIC）。<br>如有侵權，請聯繫 support@oschina.cn 刪除。<br>本文參與「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源創計劃</a>」，歡迎正在閲讀的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 03:06:17 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/10448921</guid>
            <link>https://my.oschina.net/vivotech/blog/10448921</link>
            <author>
                <![CDATA[vivo 互聯網技術]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[飛致雲開源社區月度動態報告（2023 年 12 月）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#000000; text-align:start"><span><span style="color:#000000">自 2023 年 6 月起，中國領先的開源軟件公司 FIT2CLOUD 飛致雲以月度為單位發佈《飛致雲開源社區月度動態報告》，旨在向廣大社區用戶同步飛致雲旗下系列開源軟件的發展情況，以及當月主要的產品新版本發佈、社區運營成果等相關信息。</span></span></p><p style="color:#000000; text-align:start"><span><strong><span style="color:#00355d">飛致雲開源大屏（2023 年 12 月）</span></strong></span></p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-ce20816fb99437841e5fd716dc8614c9a48.png" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:start"><span>▲圖 1 飛致雲開源大屏（2023.12.29 12:00）</span></p><p style="color:#000000; text-align:start"><span><span style="color:#000000">2023 年 12 月飛致雲開源軟件運營數據概覽（統計時間為 2023.12.1～2023.12.29）</span></span></p><p style="color:#000000; text-align:start"><img alt="" src="https://oscimg.oschina.net/oscnet/up-7f1d375b645d195bf7e8b90007275b91588.png" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:center"><strong><span style="color:#3370ff">2023 年 12 月產品發佈事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 開源建站工具</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 1 日，強大易用的開源建站工具 Halo 正式發佈 2.11.0 版本。在這一版本中，Halo 新增個人中心功能，將所有和用戶自身相關的功能移動到個人中心。同時，Halo 進行了 50 多項功能優化和問題修復。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ DataEase 開源數據可視化分析工具</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 11 日，DataEase 開源數據可視化分析平台正式發佈 v2.1.0 版本。</p><p style="color:#000000; text-align:start">這一版本的功能升級包括：新增模板中心，用戶可以通過模板中心的模板快速創建儀錶板和數據大屏；新增「系統設置」功能模塊，該模塊包含系統參數、認證設置、嵌入式管理、平台對接四個子模塊。在「系統參數」子模塊中，用戶可以對常用的系統設置項進行管理，「認證設置」子模塊支持 CAS（中央認證服務）、LDAP（輕量級目錄訪問協議）、OIDC（開放 ID 連接）等常用認證協議的對接，在「嵌入式管理」子模塊中用戶可以創建嵌入式應用，通過嵌入式應用將 DataEase 嵌入到第三方平台中，「平台對接」子模塊目前已支持飛書平台的接入，用戶可以通過飛書掃碼的方式快速登錄到 DataEase 平台；數據準備方面，新版 DataEase 支持數據集和數據源的複製功能，方便用戶快速創建類似的數據資源。</p><p style="color:#000000; text-align:start">此外，DataEase 開源項目組還對其他一些常用的功能進行了功能優化和問題修復。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 1Panel 開源面板</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 18 日，現代化、開源的 Linux 服務器運維管理面板 1Panel 正式發佈 v1.9.0 版本。</p><p style="color:#000000; text-align:start">在這一版本中，1Panel 引入了新的工具箱管理功能，包含 Swap 分區管理、Fail2Ban 管理等功能。此外，1Panel 針對網站證書管理功能進行了全面重構，現在支持添加 ZeroSSL、BuyPass 和 Google Cloud 等 ACME 賬戶，還新增了 GoDaddy、Name.com、NameCheap、NameSilo 等 DNS 賬戶。在申請證書時，系統支持多種加密算法，能夠創建自簽名證書，並且提供證書的上傳、下載功能，用戶還可以批量刪除證書，將證書推送至本地目錄。容器配置頁面也新增了與 IPv6 相關的配置選項。</p><p style="color:#000000; text-align:start">此外，1Panel 開源項目組還進行了 70 多項功能更新和問題修復。1Panel 應用商店新增了 10 款應用，並且更新了 20 款應用。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ JumpServer 開源堡壘機</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 25 日，JumpServer 開源堡壘機正式發佈 v3.10 LTS（Long Term Support）版本。JumpServer 開源項目組將對 v3.10 LTS 版本提供長期支持，定期迭代發佈小版本，持續進行問題修復更新並針對部分功能進行優化。歡迎廣大用戶升級使用 v3.10 LTS 版本。</p><p style="color:#000000; text-align:start">在這一版本中，JumpServer 重構了「標籤」功能，支持全局標籤管理，賦予了「標籤」更為靈活、更為強大的功能。從 JumpServer v3.10.0 版本開始，「標籤」不僅能綁定到資產上，還能夠綁定到其他資源上，讓其他資源通過「標籤」功能擁有額外的功能屬性。同時，JumpServer 新增 Chat AI 小助手功能，支持對接 ChatGPT，實現了多個用戶可以在 JumpServer 瀏覽器功能界面直接與 ChatGPT 進行對話的能力，極大地提高了用戶的使用率及工作效率。</p><p style="color:#000000; text-align:start">另外，「賬號收集」功能支持將遠程服務器中不存在的賬戶進行同步刪除；「文件管理」功能支持批量傳輸文件，將批量命令和批量傳輸文件集中到工作台界面。這樣一來，管理員可以讓資產功能以更加方便的方式直接暴露給用戶使用。</p><p style="color:#000000; text-align:start">X-Pack 增強包方面，JumpServer 支持第三方客戶端直連 SQL Server 數據庫，支持 Slack 平台的用戶認證及消息通知功能。同時，新版本 JumpServer 還支持配置備案信息至登錄頁面，支持使用 Linux 系統作為遠程應用發佈機。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ MeterSphere 開源持續測試平台</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 28 日，MeterSphere 開源持續測試平台發佈 v2.10.10 LTS 版本。</p><p style="color:#000000; text-align:start">在這一版本中，UI 測試方面，新增文件上傳限制、添加關聯文件時過濾已存在關聯關係的文件；測試跟蹤方面，在用例評審時支持左側模塊樹功能、表頭默認不顯示所屬模塊字段、本地附件轉存文件庫時排除第三方存儲庫模塊；接口測試方面，去除接口定義路徑結尾的空格、接口自動化表頭增加所屬模塊字段。此外，MeterSphere 項目組還進行了 8 項功能優化和 22 項漏洞修復工作。</p><p style="color:#000000; text-align:center"><strong><span style="color:#3370ff">其他重要事件</span></strong></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ 飛致雲與上海吉諦達成戰略合作，獲得 Gitea 企業版中國大陸地區獨家代理權</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 13 日，FIT2CLOUD 飛致雲宣佈與上海吉諦達成戰略合作，FIT2CLOUD 飛致雲獲得上海吉諦旗下代碼託管平台 Gitea 企業版中國大陸地區獨家代理權。</p><p style="color:#000000; text-align:start">在 Gitea 社區版的基礎之上，Gitea 企業版提供面向企業級應用場景的 X-Pack 增強包及企業級支持服務，有效助力企業快速構建並運營自託管的新一代代碼託管平台。</p><p style="color:#000000; text-align:start">Gitea v1.21 版本的企業版軟件已經於 2023 年 11 月正式發佈，首批開放的 X-Pack 增強包功能包括：企業微信/釘釘/飛書對接集成、供應鏈安全掃描、數據安全備份、分佈式部署架構和國產化信創適配等。</p><p style="color:#000000; text-align:start"><img alt="" height="608" src="https://oscimg.oschina.net/oscnet/up-d57c9939ebd603754752cc23d2f9e9aca95.jpg" width="1080" referrerpolicy="no-referrer"></p><p style="color:#000000; text-align:start"><span>▲ 圖 2 飛致雲與上海吉諦達成戰略合作</span></p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ FIT2CLOUD 飛致雲榮膺「2023 年度 OSCHINA 優秀開源技術團隊」獎項</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 8 日，知名開源技術社區 OSCHINA（開源中國）公佈了「2023 年度 OSCHINA 優秀開源技術團隊」入選名單。憑藉在開源軟件研發和開源社區運營方面的年度優異表現，FIT2CLOUD 飛致雲再次收穫「優秀開源技術團隊」獎項。這也是繼 2021 年和 2022 年之後，FIT2CLOUD 飛致雲連續第三年榮膺該項榮譽。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ JumpServer 開源堡壘機 V2 社區版即將停止維護的通知</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 1 日，JumpServer 開源項目組發佈重要通知。如《關於 JumpServer 開源堡壘機 V2 版本產品生命週期的相關説明》所示，JumpServer 開源堡壘機 V2 版本（社區版）將於 2023 年 12 月 31 日停止維護支持。</p><p style="color:#000000; text-align:start">出於產品自身迭代和用戶需求升級的要求，2023 年 2 月 27 日，JumpServer 開源堡壘機正式發佈 v3.0 版本，目前已更新至 v3.10 LTS 版本。JumpServer 開源項目組建議社區版和企業版用戶更新至 JumpServe v3.x 版本，以使用更多的新增功能並獲取更好的軟件使用體驗。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 推出 AI 助手插件</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 15 日，Halo AI 助手插件上線。AI 助手插件通過擴展編輯器功能，為 Halo 默認編輯器帶來了豐富的 AI 輔助功能。用戶可以通過選中文字或者使用/命令的方式快速呼出 AI 對話框。AI 助手插件目前使用 OpenAI 的接口來提供 AI 能力支持，用戶可以自定義 OpenAI 接口地址，選擇切換不同的模型或者在網絡不通的情況下配置代理使用。用戶訪問 Halo 應用市場，即可下載體驗 Halo AI 助手插件。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ DataEase 漏洞通知及修復方案（DE-2023.12.19）</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 19 日，DataEase 項目組發佈了編號為「DE-2023.12.19」的漏洞通知及修復方案，請用戶儘快將 DataEase 升級至 v1.18.11 及以後的版本。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">■ Halo 1.x 停止維護公告</span></strong></p><p style="color:#000000; text-align:start">2023 年 12 月 21 日，Halo 開源項目組發佈《Halo 1.x 停止維護公告》。為了集中資源和精力去持續改進和維護 Halo 的最新版本，Halo 1.x 版本將於 2023 年 12 月 31 日停止維護。Halo 開源項目組提供了詳細的從 1.x 版本遷移到 2.x 版本的升級指南，您可以訪問官方文檔：《從 Halo 1.x 遷移》<span style="color:#172b4d">（</span>https://docs.halo.run/getting-started/migrate-from-1.x/<span style="color:#172b4d"><span>&nbsp;</span>）</span>來瞭解詳情。</p><p style="color:#000000; text-align:start"><strong><span style="color:#00355d">關於飛致雲開源大屏</span></strong></p><p style="color:#000000; text-align:start">飛致雲開源大屏（https://bi.fit2cloud.com/link/6CgpMHrT）是 FIT2CLOUD 飛致雲為展示其旗下開源軟件的社區運營情況製作的數據儀錶板。該大屏使用 DataEase 開源數據可視化分析平台製作，實時呈現飛致雲開源社區近 30 日內的動態信息。</p><p style="color:#000000; text-align:start">廣大社區用戶可以通過該大屏瞭解飛致雲旗下開源項目的 GitHub Star、Fork、Issue、貢獻者等指標的數量信息，以及近 30 日內新增的 Star、Fork、下載、Issue、PR 數量等，同時該大屏還展示了飛致雲旗下開源項目的 Issue 趨勢、Commit 趨勢、PR 趨勢、Issue 生命週期等。</p><p style="color:#000000; text-align:start">除了展示所有項目的彙總信息外，該大屏還支持用戶分類別查看 JumpServer、DataEase、MeterSphere、Halo、1Panel、CloudExplorer Lite 六個開源項目的獨立運營數據。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 03:00:17 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4736111/blog/10469745</guid>
            <link>https://my.oschina.net/u/4736111/blog/10469745</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[關於編程模式的總結與思考]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"><section style="margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;visibility: visible;" data-mpa-powered-by="yiban.io"><img class="rich_pages wxw-img __bg_gif" data-backh="96" data-backw="578" data-cropselx1="0" data-cropselx2="578" data-cropsely1="0" data-cropsely2="96" data-imgfileid="503041828" data-ratio="0.16666666666666666" src="https://oscimg.oschina.net/oscnet/7f3f91e3-bb2b-4b44-a874-fe03bc749ab0.gif" data-type="gif" data-w="636" style="outline: 0px;letter-spacing: 0.544px;font-size: var(--articleFontsize);border-radius: 8px;text-align: justify;width: 677px;visibility: visible !important;background-size: 16px !important;" referrerpolicy="no-referrer"><br style="outline: 0px;visibility: visible;"></section><section data-mpa-template="t" data-mpa-template-id="502" data-mpa-category="模板" style="outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);visibility: visible;"><section data-mpa-category="模板" data-mid="" style="padding-right: 1px;padding-left: 1px;outline: 0px;width: 677px;display: flex;justify-content: flex-start;align-items: center;flex-direction: column;visibility: visible;"><section data-mid="" style="outline: 0px;letter-spacing: 0.544px;width: 675px;display: grid;grid-template-columns: 26px auto;visibility: visible;"><section data-mid="" style="outline: 0px;width: 26px;height: 14px;display: flex;justify-content: center;align-items: center;align-self: center;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section><section data-mid="" style="padding-left: 7px;outline: 0px;display: flex;justify-content: flex-start;align-items: center;visibility: visible;"><section data-mid="" style="margin-right: 7px;outline: 0px;text-align: left;visibility: visible;"><p data-mid="" style="outline: 0px;width: 0px;font-size: 14px;font-family: PingFangSC-Semibold, &quot;PingFang SC&quot;;font-weight: bold;color: rgb(58, 92, 244);line-height: 20px;visibility: visible;"><br style="outline: 0px;visibility: visible;"></p></section><section data-mid="" style="margin-bottom: 4px;outline: 0px;width: 635px;height: 1px;border-top: 1px solid rgb(58, 92, 244);align-self: flex-end;visibility: visible;"><br style="outline: 0px;visibility: visible;"></section></section></section><section data-mid="" style="padding: 7px 14px 9px 19px;outline: 0px;width: 675px;text-align: left;border-bottom: 1px solid rgb(58, 92, 244);visibility: visible;"><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;letter-spacing: 0.578px;text-align: justify;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;white-space-collapse: preserve;text-size-adjust: inherit;text-align: left;caret-color: rgb(23, 26, 29);letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;color: rgb(0, 0, 0);visibility: visible;font-size: 15px;">淘寶創新業務的<span style="font-size: 15px;letter-spacing: 1px;text-wrap: wrap;">優化迭代是非常高頻且迅速的，</span><span style="font-size: 15px;letter-spacing: 1px;text-wrap: wrap;">在這過程中要求技術也必須是快且穩的，而為了適應這種快速變化的節奏，我們在項目開發過程中採用了一些面向拓展以及敏捷開發的設計，</span><span style="font-size: 15px;letter-spacing: 1px;text-wrap: wrap;">本文旨在總結並思考其中一些通用的編程模式。</span></span></p></section></section></section><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);visibility: visible;line-height: 1.75em;"><br style="outline: 0px;visibility: visible;"></p><section style="margin-bottom: 0px;outline: 0px;box-sizing: inherit;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgba(25, 26, 31, 0.9);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 16px;text-align: center;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041829" data-ratio="0.3161764705882353" data-s="300,640" src="https://oscimg.oschina.net/oscnet/b90357ce-619d-4abb-a361-96e0ffebccdd.png" data-type="png" data-w="408" style="outline: 0px;color: rgb(34, 34, 34);font-family: system-ui, -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;visibility: visible !important;width: 113px !important;" referrerpolicy="no-referrer"></span></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(34, 34, 34);text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;color: rgb(3, 69, 255);font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;visibility: visible;">前言</span></section><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">靜心守護業務是淘寶今年 4 月份啓動的創新項目，項目的核心邏輯是通過敲木魚、冥想、盤手串等療愈玩法為用戶帶來內心寧靜的同時推動文物的保護與修復，進一步弘揚我們的傳統文化。</span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">作為創新項目，業務形態與產品方案的優化迭代是非常高頻且迅速的：項目從 4 月底投入開發到 7 月份最終外灰，整體方案經歷過大的推倒重建，也經歷過多輪小型重構優化，項目上線後也在做持續的迭代優化甚至改版升級。</span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section style="margin-bottom: 0px;outline: 0px;box-sizing: inherit;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgba(25, 26, 31, 0.9);font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 16px;text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;font-size: 15px;letter-spacing: 1px;visibility: visible;"><img class="rich_pages wxw-img" data-imgfileid="503041833" data-ratio="0.3056872037914692" data-s="300,640" src="https://oscimg.oschina.net/oscnet/0f807f04-facf-4eba-bf80-54b3dc2b020a.png" data-type="png" data-w="422" style="outline: 0px;color: rgb(34, 34, 34);font-family: system-ui, -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;visibility: visible !important;width: 117px !important;" referrerpolicy="no-referrer"></span></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(34, 34, 34);text-align: center;visibility: visible;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;visibility: visible;color: rgb(0, 17, 255);">模式清單</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><span id="OSC_h4_1"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">基於 Spring 容器與反射的策略模式</span></strong></span></h4><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">策略模式是一種經典的行為設計模式，它的本質是定義一系列算法， 並將每種算法分別放入獨立的類中， 以使算法的對象能夠相互替換，後續也能根據需要靈活拓展出新的算法。這裏推薦的是一種基於 Spring 容器和反射結合的策略模式，這種模式的核心思路是：每個策略模式的實現都是一個 bean，在 Spring 容器啓動時基於反射獲取每個策略場景的接口類型，並基於該接口類型再獲取此類型的所有策略實現 bean 並記錄到一個 map（key 為該策略 bean 的唯一標識符，value 為 bean 對象）中，後續可以自定義路由策略來從該 map 中獲取 bean 對象並使用相應的策略。</span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h4_2"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">模式解構</span></h4></li></ul><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">模式具體實現方式大致如下面的 UML 類圖所描述的：</span></p><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><img class="rich_pages wxw-img" data-backh="258" data-backw="578" data-imgfileid="503041831" data-ratio="0.4462962962962963" src="https://oscimg.oschina.net/oscnet/d8f41f29-554a-49b5-b29f-5130f4805640.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></section><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">其中涉及的各個組件及作用分別為：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>Handler</strong>（<em>interface</em>）：策略的頂層接口，定義的 type 方法表示策略唯一標識的獲取方式。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>HandlerFactory</strong>（<em>abstract class</em>）：策略工廠的抽象實現，封裝了反射獲取 Spring bean 並維護策略與其標識映射的邏輯，但不感知策略的真實類型。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>AbstractHandler</strong>（<em>interface or abstracr class</em>）：各個具體場景下的策略接口定義，該接口定義了具體場景下策略所需要完成的行為。如果各個具體策略實現有可複用的邏輯，可以結合模版方法模式在該接口內定義模版方法，如果模板方法依賴外部 bean 注入，則該接口的類型需要為<em>abstract class</em>，否則為<em>interface</em>即可。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>HandlerImpl</strong>（<em>class</em>）：各個場景下策略接口的具體實現，承載主要的業務邏輯，也可以根據需要橫向拓展。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong>HandlerFactoryImpl</strong>（<em>class</em>）：策略工廠的具體實現，感知具體場景策略接口的類型，如果有定製的策略路由邏輯也可以在此實現。</span></p></li></ol><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(68, 68, 68);font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(68, 68, 68);font-size: 15px;letter-spacing: 1px;">這種模式的主要優點有：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(68, 68, 68);">策略標識維護自動化</span></strong><span style="color: rgb(68, 68, 68);">：策略實現與標識之間的映射關係完全委託給 Spring 容器進行維護（在</span><em><span style="color: rgb(68, 68, 68);">HandlerFactory</span></em><span style="color: rgb(68, 68, 68);">中封裝，每個場景的策略工廠直接繼承該類即可，無需重複實現），後續新增策略不用再手動修改關係映射。</span></span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(68, 68, 68);">場景維度維護標識映射</span></strong><span style="color: rgb(68, 68, 68);">：</span><em><span style="color: rgb(68, 68, 68);">HandlerFactory</span></em><span style="color: rgb(68, 68, 68);">中在掃描策略 bean 時是按照</span><em>AbstractHandler</em>的類型來分類維護的，從而避免了不同場景的同名策略發生衝突。</span></p></li><li><section style="margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><strong><span style="color: rgb(68, 68, 68);">策略接口按場景靈活定義</span></strong><span style="color: rgb(68, 68, 68);">：具體場景的策略行為定義在</span><em><span style="color: rgb(68, 68, 68);">AbstractHandler</span></em><span style="color: rgb(68, 68, 68);">中，在這裏可以根據真實的業務需求靈活定義行為，甚至也可以結合其他設計模式做進一步抽象處理，在提供靈活拓展的同時減少重複代碼。</span></span></section></li></ol><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_3"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">實踐案例分析</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">該模式在靜心守護項目中的許多功能模塊都有使用，下面以稱號解鎖模塊為例來介紹其實際應用。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">我們先簡單瞭解下該模塊的業務背景：靜心守護的成就體系中有一類是稱號，如下圖。用戶可以通過多種行為去解鎖不同類型的稱號，比如説通過參與主玩法（敲木魚、冥想、盤手串），主玩法參與達到一定次數後即可解鎖特定類型的稱號。當然後續也可能會有其他種類的稱號：比如簽到類（按照用戶簽到天數解鎖）、捐贈類（按照用戶捐贈項目的行為解鎖），所以對於稱號的解鎖操作應該是面向未來可持續拓展的。</span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: center;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041832" data-ratio="2" src="https://oscimg.oschina.net/oscnet/62c7ac5c-2a9c-4a65-b420-4efbd4b250fb.png" data-type="png" data-w="500" referrerpolicy="no-referrer"></span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">基於這樣的思考，我選擇使用上面的策略模式去實現稱號解鎖模塊。該模塊的核心類圖組織如下：</span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><img class="rich_pages wxw-img" data-backh="259" data-backw="578" data-imgfileid="503041830" data-ratio="0.44722222222222224" src="https://oscimg.oschina.net/oscnet/5ead0c97-1223-42ec-90dc-be4c054fa964.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">下面是其中部分核心代碼的分析解讀：</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer">public interface Handler&lt;T&gt; {</span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * handler 類型</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    T type();</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><span style="color: rgb(68, 68, 68);">如上文所説，</span><em><span style="color: rgb(68, 68, 68);">Handler</span></em><span style="color: rgb(68, 68, 68);">是策略的頂層抽象，它只定義了</span><em><span style="color: rgb(68, 68, 68);">type</span></em><span style="color: rgb(68, 68, 68);">方法，該方法用於獲取策略的標識，標識的類型支持子接口定義。</span></span></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 15px;color: rgb(68, 68, 68);"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">public abstract class HandlerFactory&lt;T, H extends Handler&lt;T&gt;&gt; implements InitializingBean, ApplicationContextAware {</span></code><code><span class="code-snippet_outer">    private Map&lt;T, H&gt; handlerMap;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    private ApplicationContext appContext;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 根據 type 獲得對應的 handler</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param type</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public H getHandler(T type) {</span></code><code><span class="code-snippet_outer">        return handlerMap.get(type);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 根據 type 獲得對應的 handler，支持返回默認</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param type</span></code><code><span class="code-snippet_outer">     * @param defaultHandler</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public H getHandlerOrDefault(T type, H defaultHandler) {</span></code><code><span class="code-snippet_outer">        return handlerMap.getOrDefault(type, defaultHandler);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 反射獲取泛型參數 handler 類型</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @return handler 類型</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    @SuppressWarnings("unchecked")</span></code><code><span class="code-snippet_outer">    protected Class&lt;H&gt; getHandlerType() {</span></code><code><span class="code-snippet_outer">        Type type = ((ParameterizedType)getClass().getGenericSuperclass()).getActualTypeArguments()[1];</span></code><code><span class="code-snippet_outer">        //策略接口使用了範型參數</span></code><code><span class="code-snippet_outer">        if (type instanceof ParameterizedTypeImpl) {</span></code><code><span class="code-snippet_outer">            return (Class&lt;H&gt;) ((ParameterizedTypeImpl)type).getRawType();</span></code><code><span class="code-snippet_outer">        } else {</span></code><code><span class="code-snippet_outer">            return (Class&lt;H&gt;) type;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public void afterPropertiesSet() {</span></code><code><span class="code-snippet_outer">        // 獲取所有 H 類型的 handlers</span></code><code><span class="code-snippet_outer">        Collection&lt;H&gt; handlers = appContext.getBeansOfType(getHandlerType()).values();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        handlerMap = Maps.newHashMapWithExpectedSize(handlers.size());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        for (final H handler : handlers) {</span></code><code><span class="code-snippet_outer">            log.info("HandlerFactory {}, {}", this.getClass().getCanonicalName(), handler.type());</span></code><code><span class="code-snippet_outer">            handlerMap.put(handler.type(), handler);</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">        log.info("handlerMap:{}", JSON.toJSONString(handlerMap));</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public void setApplicationContext(@Nonnull ApplicationContext applicationContext) throws BeansException {</span></code><code><span class="code-snippet_outer">        this.appContext = applicationContext;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><em>HandlerFactory</em>在前面也提到過，是策略工廠的抽象實現，封裝了反射獲取具體場景策略接口類型，並查找策略 bean 在內存中維護策略與其標識的映射關係，後續可以直接通過標識或者對應的策略實現。這裏有二個細節：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">為什麼 HandlerFactory 是<em>abstract class</em>？其實可以看到該類並沒有任何抽象方法，直接將其定義為<em>class</em>也不會有什麼問題。這裏將其定義為<em>abstract class</em>主要是起到實例創建的約束作用，因為我們對該類的定義是工廠的抽象實現，只希望針對具體場景來創建實例，針對該工廠本身創建實例其實是沒有任何實際意義的。</span></p></li><li><p style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><em>getHandlerType</em>方法使用了<em>@SuppressWarnings</em>註解並標記了<em>unchecked</em>。這裏也確實是存在潛在風險的，因為<em>Type</em>類型轉<em>Class</em>類型屬於向下類型轉換，是存在風險的，可能其實際類型並非<em>Class</em>而是其他類型，那麼此處強轉就會出錯。這裏處理了兩種最通用的情況：<em>AbstractHandler</em>是帶範型的<em>class</em>和最普通的<em>class</em>。</span></p></li></ol><p style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="color: rgb(68, 68, 68);font-size: 15px;letter-spacing: 1px;"><br></span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class TitleUnlockHandlerFactory</span></code><code><span class="code-snippet_outer">        extends HandlerFactory&lt;String, BaseTitleUnlockHandler&lt;BaseTitleUnlockParams&gt;&gt; {}</span></code></pre></section><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><section style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: start;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><ne-text ne-italic="true" style="font-style: italic;"><span style="font-size: 15px;letter-spacing: 1px;">TitleUnlockHandlerFactory</span></ne-text><ne-text><span style="font-size: 15px;letter-spacing: 1px;">是策略工廠的具體實現，由於不需要在此定製策略的路由邏輯，所以只聲明瞭相關的參數類型，而沒有對父類的方法做什麼覆蓋。</span></ne-text><ne-text></ne-text><span style="display: inline;min-width: 1px;vertical-align: baseline;height: 1em;user-select: none;font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: start;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><ne-text><span style="font-size: 15px;letter-spacing: 1px;"><br></span></ne-text></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">public abstract class BaseTitleUnlockHandler&lt;T extends BaseTitleUnlockParams&gt; implements Handler&lt;String&gt; {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private UserTitleTairManager userTitleTairManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private AchievementCountManager achievementCountManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private UserUnreadAchievementTairManager userUnreadAchievementTairManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 解鎖稱號</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param params</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public @CheckForNull TitleUnlockResult unlockTitles(T params) {</span></code><code><span class="code-snippet_outer">        TitleUnlockResult titleUnlockResult = this.doUnlock(params);</span></code><code><span class="code-snippet_outer">        if (null == titleUnlockResult) {</span></code><code><span class="code-snippet_outer">            return null;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        List&lt;TitleAchievementVO&gt; titleAchievements = titleUnlockResult.getUnlockedTitles();</span></code><code><span class="code-snippet_outer">        if (CollectionUtils.isEmpty(titleAchievements)) {</span></code><code><span class="code-snippet_outer">            titleUnlockResult.setUnlockedTitles(new ArrayList&lt;&gt;());</span></code><code><span class="code-snippet_outer">            return titleUnlockResult;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //基於注入的 bean 和計算出的稱號列表進行後置操作，如：更新成就計數、更新用戶稱號緩存、更新用戶未讀成就等</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        return titleUnlockResult;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 計算出要解鎖的稱號</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param param</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    protected abstract TitleUnlockResult doUnlock(T param);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public abstract String type();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: justify;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><ne-text></ne-text></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><em>BaseTitleUnlockHandler</em>定義了稱號解鎖行為，並且在此確定了策略標識的類型為<em>String</em>。此外，該類是一個<em>abstract class</em>，是因為該類定義了一個模版方法<em>unlockTitles</em>，在該方法裏封裝了稱號解鎖所要進行的一些公共操作，比如更新用戶的稱號計數、用戶的稱號緩存數據等，這些都依賴於注入的一些外部 bean，而<em>interface</em>不支持非靜態成員變量，所以該類通過<em>abstract class</em>來定義。具體的稱號解鎖行為通過<em>doUnlock</em>定義，這也是該策略的具體實現類需要實現的方法。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">另外也許你還注意到了<em>doUnlock</em>方法的行參是一個範型參數<em>T</em>，因為我們考慮到了不同類型稱號解鎖所需要的參數可能是不同的，因此在場景抽象接口側只依賴於稱號解鎖的公共參數類型，而在策略接口具體實現側才與該類型策略的具體參數類型進行耦合。</span></section><section style="color: rgb(0, 0, 0);font-size: medium;letter-spacing: normal;text-align: start;text-wrap: wrap;display: block;min-height: 24px;max-width: 750px;margin-left: auto;margin-right: var(--viewer-center-align-right);margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><ne-text><span style="font-size: 15px;letter-spacing: 1px;"><br></span></ne-text></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class GameplayTitleUnlockHandler extends BaseTitleUnlockHandler&lt;GameplayTitleUnlockParams&gt; {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private BlessTitleAchievementDiamondConfig blessTitleAchievementDiamondConfig;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private UserTitleTairManager userTitleTairManager;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected TitleUnlockResult doUnlock(GameplayTitleUnlockParams params) {</span></code><code><span class="code-snippet_outer">        //獲取稱號元數據</span></code><code><span class="code-snippet_outer">        List&lt;TitleMetadata&gt; titleMetadata = blessTitleAchievementDiamondConfig.getTitleMetadata();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        if (CollectionUtils.isEmpty(titleMetadata)) {</span></code><code><span class="code-snippet_outer">            return null;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        List&lt;TitleAchievementVO&gt; titleAchievements = new ArrayList&lt;&gt;();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        Result&lt;DataEntry&gt; result = userTitleTairManager.queryRawCache(params.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //用戶稱號數據查詢異常</span></code><code><span class="code-snippet_outer">        if (null == result || !result.isSuccess()) {</span></code><code><span class="code-snippet_outer">            return null;</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        if (Objects.equals(result.getRc(), ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer">            //解鎖新稱號</span></code><code><span class="code-snippet_outer">            titleAchievements = unlockNewTitles(params, titleMetadata);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } else if (Objects.equals(result.getRc(), ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer">            //初始化歷史稱號</span></code><code><span class="code-snippet_outer">            titleAchievements = initHistoricalTitles(params, titleMetadata);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        TitleUnlockResult titleUnlockResult = new TitleUnlockResult();</span></code><code><span class="code-snippet_outer">        titleUnlockResult.setUserTitleCache(result);</span></code><code><span class="code-snippet_outer">        titleUnlockResult.setUnlockedTitles(titleAchievements);</span></code><code><span class="code-snippet_outer">        return titleUnlockResult;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public String type() {</span></code><code><span class="code-snippet_outer">        return TitleType.GAMEPLAY;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ......</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">上面是一個策略的具體實現類的大致示例，可以看到該實現類核心明確了以下信息：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">策略標識：給出了 type 方法的具體實現，返回了一個策略標識的常量</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">策略處理邏輯：此處是玩法類稱號解鎖的業務邏輯，讀者無需關注其細節</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">稱號解鎖行參：給出了玩法類稱號解鎖所需的真實參數類型</span></p></li></ol><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><ne-text><br></ne-text></p><span id="OSC_h4_4"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">抽象疲勞度管控體系</span></strong></span></h4><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">在我們的業務需求中經常會遇到涉及疲勞度管控相關的邏輯，比如每日簽到允許用戶每天完成 1 次、首頁項目進展彈窗要求對所有用戶只彈 1 次、首頁限時回訪任務入口則要對用戶每天都展示一次，但用戶累計完成 3 次後便不再展示......因此我們設計了一套疲勞度管控的模式，以降低後續諸如上述涉及疲勞度管控相關需求的開發成本。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_5"></span><h3 style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">自頂向下的視角</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">這套疲勞度管控體系的類層次大致如下圖：</span></section><section style="min-height: 24px;margin-bottom: 8px;"><img class="rich_pages wxw-img" data-backh="360" data-backw="578" data-imgfileid="503041836" data-ratio="0.6222222222222222" src="https://oscimg.oschina.net/oscnet/f99ffd82-3d9e-4965-aa11-20ecbf3845eb.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" width="4011" referrerpolicy="no-referrer"></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">接下來我們自頂向下逐層進行介紹：</span></section><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">FatigueLimiter（<em>interface</em>）：<em>FatigueLimiter</em>是最頂層抽象的疲勞度管控接口，<span style="text-decoration: underline;">它定義了疲勞度管控相關的行為</span>，比如：疲勞度的查詢、疲勞度清空、疲勞度增加、是否達到疲勞度限制的判斷等。</span></section></li><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">BaseFatigueLdbLimiter（<em>abstract class</em>）：疲勞度數據的存儲方案可以是多種多樣的，在我們項目中主要利用 ldb 進行疲勞度存儲，而<em>BaseFatigueLdbLimiter</em>正是基於 ldb【注：阿里內部自研的一款持久化 k-v 數據庫，讀者可將其理解為類似 level db 的項目】對疲勞度數據進行管控的抽象實現，它封裝了 ldb 相關的操作，並基於 ldb 的數據操作實現了<em>FatigueLimiter</em>的疲勞度管控方法。但它並不感知具體業務的身份和邏輯，因此定義了幾個業務相關的方法交給下層去實現，分別是：</span></section></li><ul ne-level="1" class="list-paddingleft-1" style="padding-left: 23px;list-style-position: initial;list-style-image: initial;"><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">scene：標識具體業務的場景，會利用該方法返回值去構造 Ldb 存儲的 key</span></section></li><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">buildCustomKey：對 Ldb 存儲 key 的定製邏輯</span></section></li><li style="font-size: 15px;letter-spacing: 1px;"><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">getExpireSeconds：對應着 Ldb 存儲 kv 失效時間，對應着疲勞度的管控週期</span></section></li></ul><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">Ldb 週期性疲勞度管控的解決方案層（<em>abstract class</em>）：在這一層提供了多種週期的開箱即用的疲勞度管控實現類，如<em>BaseFatigueDailyLimiter</em>提供的是天級別的疲勞度管控能力，<em>BaseFatigueNoCycleLimiter</em>則表示疲勞度永不過期，而<em>BaseFatigueCycleLimiter</em>則支持用戶實現 cycle 方法定製疲勞度週期。</span></section></li><li><section style="margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><span style="font-size: 15px;letter-spacing: 1px;">業務場景層：這一層則是各個業務場景對疲勞度管控的具體實現，實現類只需要實現 scene 方法來聲明業務場景的身份標識，隨後繼承對應的解決方案，即可實現快速的疲勞度管控。比如上面的 DailyWishSign<em>Limiter</em>就對應着本篇開頭我們所説的「每日簽到允許用戶每天完成 1 次」，這就要求為用戶的簽到行為以天維度構建 key 同時失效時間也為 1 天，因此直接繼承解決方案層的<em>BaseFatigueDailyLimiter</em>即可。其代碼實現非常簡單，如下：</span></section></li></ol><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class DailyWishSignLimiter extends BaseFatigueLdbDailyLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected String scene() {</span></code><code><span class="code-snippet_outer">        return LimiterScene.dailyWish;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_6"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">有一個「異類」</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">也許你注意到了上面的類層次圖中有一個「異類」——HomeEnterGuideLimiter。它其實就是我們在上文説的「首頁限時回訪任務入口則要對用戶每天都展示一次，但用戶累計完成 3 次後便不再展示」，它的邏輯其實也很簡單：因為它有 2 條管控條件，所以需要繼承 2 個管控週期的解決方案——天維度和永久維度，最後實際使用的類再聚合了天維度和永久維度的實現類（每個實現類對應 ldb 的一類 key）並實現了頂層的疲勞度管控接口，標識這也是一個疲勞度管理器。它們的代碼如下：</span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 首頁入口引導限時任務-天級疲勞度管控</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class HomeEnterGuideDailyLimiter extends BaseFatigueLdbDailyLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected String scene() {</span></code><code><span class="code-snippet_outer">        return LimiterScene.homeEnterGuide;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 首頁入口引導限時任務-總次數疲勞度管控</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class HomeEnterGuideNoCycleLimiter extends BaseFatigueLdbNoCycleLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected String scene() {</span></code><code><span class="code-snippet_outer">        return LimiterScene.homeEnterGuide;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    protected int maxSize() {</span></code><code><span class="code-snippet_outer">        return 3;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 首頁入口引導限時任務-疲勞度服務</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">public class HomeEnterGuideLimiter implements FatigueLimiter {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private FatigueLimiter homeEnterGuideDailyLimiter;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Resource</span></code><code><span class="code-snippet_outer">    private FatigueLimiter homeEnterGuideNoCycleLimiter;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public boolean isLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        return homeEnterGuideNoCycleLimiter.isLimit(customKey) || homeEnterGuideDailyLimiter.isLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public Integer incrLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        homeEnterGuideDailyLimiter.incrLimit(customKey);</span></code><code><span class="code-snippet_outer">        return homeEnterGuideNoCycleLimiter.incrLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public boolean isLimit(Integer fatigue) {</span></code><code><span class="code-snippet_outer">        throw new UnsupportedOperationException();</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public Map&lt;String, Integer&gt; batchQueryLimit(List&lt;String&gt; keys) {</span></code><code><span class="code-snippet_outer">        throw new UnsupportedOperationException();</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public void removeLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        homeEnterGuideDailyLimiter.removeLimit(customKey);</span></code><code><span class="code-snippet_outer">        homeEnterGuideNoCycleLimiter.removeLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public Integer queryLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        throw new UnsupportedOperationException();</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 查詢首頁限時任務的每日疲勞度</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param customKey 用戶自定義 key</span></code><code><span class="code-snippet_outer">     * @return 疲勞度計數</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public Integer queryDailyLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        return homeEnterGuideDailyLimiter.queryLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 查詢首頁限時任務的全週期疲勞度</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param customKey 用戶自定義 key</span></code><code><span class="code-snippet_outer">     * @return 疲勞度計數</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    public Integer queryNoCycleLimit(String customKey) {</span></code><code><span class="code-snippet_outer">        return homeEnterGuideNoCycleLimiter.queryLimit(customKey);</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></section><span id="OSC_h4_7"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">函數式行為參數化</span></strong></span></h4><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"></h4><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">Java 21 在今年 9 月份發佈了，而距離 Java 8 發佈已經過去 9 年多了，但也許，我是説也許......我們有些同學對 Java 8 還是不太熟悉......</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_8"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">再談行為參數化</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">最早聽到「行為參數化」這個詞是在經典的 Java 技術書籍《Java 8 實戰》中。在此書中，作者以一個篩選蘋果的案例，基於行為參數化的思維一步步優化重構代碼，在提升代碼抽象能力的同時，保證了代碼的簡潔性和可讀性，而其中的祕密武器就是 Java 8 所引入的 Lambda 表達式和函數式接口。Java 8 發佈已經 9 年，對於 Lambda 表達式，大多數同學都已經耳熟能詳，但函數式接口也許有同學不知道代表着什麼。簡單來説，如果一個接口，它只有一個沒有被實現的方法，那它就是函數式接口。java.lang.function 包下定義 JDK 提供的一系列函數式接口。如果一個接口是函數式接口，推薦用@FunctionalInterface 註解來顯式標明。那函數式接口有什麼用呢？如果一個方法的行參裏有函數式接口，那麼函數式接口對應的參數可以支持傳遞 Lambda 表達式或者方法引用。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">那何為「行為參數化」？直觀地來説就是將行為作為方法/函數的參數來進行傳遞。在 Java 8 之前，這可以通過匿名類實現，而在 Java 8 以後，可以基於函數式特性來實現行為參數化，即方法參數定義為函數式接口，在具體傳參時使用 Lambda 表達式/方法。相比匿名類，後者在簡潔性上有極大的提升。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">在我們的日常開發中，如果我們看到兩個方法的結構十分相似，只有其中部分行為存在差別，那麼就可以考慮採用函數式的行為參數化來重構優化這段代碼，將其中存在差異的行為抽象成參數，從而減少重複代碼。</span></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_9"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">從實踐中來，到代碼中去</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">下面給出一個例子。在靜心守護項目中，我們基於 ldb 維護了用戶未讀成就的列表，在用戶進入到個人成就頁時，會查詢未讀成就數據，並對未讀的成就在成就列表進行置頂以及加紅點展示。下面是對用戶未讀成就列表進行新增和清除的兩個方法：</span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 清除未讀成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid             用戶 ID</span></code><code><span class="code-snippet_outer"> * @param achievementType 需要清除未讀成就列表的成就類型</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean clearUnreadAchievements(long uid, Set&lt;String&gt; achievementTypes) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (CollectionUtils.isEmpty(achievementTypes)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    Result&lt;DataEntry&gt; ldbRes = super.rawGet(buildKey(uid), false);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //用戶稱號數據查詢失敗</span></code><code><span class="code-snippet_outer">    if (Objects.isNull(ldbRes)) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">        return false;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    boolean success = false;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ResultCode resultCode = ldbRes.getRc();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //不存在用戶稱號數據則進行初始化</span></code><code><span class="code-snippet_outer">    if (Objects.equals(resultCode, ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer">    UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">        achievementTypes.forEach(type -&gt; clearCertainTypeIds(userUnreadAchievementsCache, type));</span></code><code><span class="code-snippet_outer">        success = putCache(uid, userUnreadAchievementsCache, DEFAULT_VERSION);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    } else if (Objects.equals(resultCode, ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        DataEntry ldbEntry = ldbRes.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //存在新數據則對其進行更新</span></code><code><span class="code-snippet_outer">        if (Objects.nonNull(ldbEntry)) {</span></code><code><span class="code-snippet_outer">            Object data = ldbEntry.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            if (data instanceof String) {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = JSON.parseObject(String.valueOf(data), UserUnreadAchievementsCache.class);</span></code><code><span class="code-snippet_outer">                achievementTypes.forEach(type -&gt; clearCertainTypeIds(userUnreadAchievementsCache, type))</span></code><code><span class="code-snippet_outer">                success = putCache(uid, userUnreadAchievementsCache, ldbEntry.getVersion());</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    //緩存解鎖的稱號失敗</span></code><code><span class="code-snippet_outer">    if (!success) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    return success;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="typescript"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 寫入新的未讀成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid                  用戶 ID</span></code><code><span class="code-snippet_outer"> * @param achievementTypeIdMap 需要新增的成就類型和成就 ID 列表的映射</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean writeUnreadAchievements(long uid, Map&lt;String, List&lt;String&gt;&gt; achievementTypeIdMap) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (MapUtils.isEmpty(achievementTypeIdMap)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    Result&lt;DataEntry&gt; ldbRes = super.rawGet(buildKey(uid), false);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //用戶稱號數據查詢失敗</span></code><code><span class="code-snippet_outer">    if (Objects.isNull(ldbRes)) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">        return false;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    boolean success = false;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ResultCode resultCode = ldbRes.getRc();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //不存在用戶稱號數據則進行初始化</span></code><code><span class="code-snippet_outer">    if (Objects.equals(resultCode, ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer">    UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">        achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(userUnreadAchievementsCache, key, value));</span></code><code><span class="code-snippet_outer">        success = putCache(uid, userUnreadAchievementsCache, DEFAULT_VERSION);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    } else if (Objects.equals(resultCode, ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        DataEntry ldbEntry = ldbRes.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //存在新數據則對其進行更新</span></code><code><span class="code-snippet_outer">        if (Objects.nonNull(ldbEntry)) {</span></code><code><span class="code-snippet_outer">            Object data = ldbEntry.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            if (data instanceof String) {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = JSON.parseObject(String.valueOf(data), UserUnreadAchievementsCache.class);</span></code><code><span class="code-snippet_outer">                achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(oldCache, key, value));</span></code><code><span class="code-snippet_outer">                success = putCache(uid, userUnreadAchievementsCache, ldbEntry.getVersion());</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    //緩存解鎖的稱號失敗</span></code><code><span class="code-snippet_outer">    if (!success) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    return success;</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">從結構上看，上面兩段代碼其實是非常類似的：整個結構都是先判空，然後查詢歷史的未讀成就數據，如果數據未初始化，則進行初始化，如果已經初始化，則對數據進行更新。只不過寫入/清除對數據的初始化和更新邏輯並不相同。因此可以將數據初始化和更新抽象為行為參數，將剩餘部分提取為公共方法，基於這樣的思路重構後的代碼如下：</span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 創建 or 更新緩存</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid               用戶 ID</span></code><code><span class="code-snippet_outer"> * @param initCacheSupplier 緩存初始化策略</span></code><code><span class="code-snippet_outer"> * @param updater           緩存更新策略</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">private boolean upsertCache(long uid, Supplier&lt;UserUnreadAchievementsCache&gt; initCacheSupplier,</span></code><code><span class="code-snippet_outer">                            Function&lt;UserUnreadAchievementsCache, UserUnreadAchievementsCache&gt; updater) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    Result&lt;DataEntry&gt; ldbRes = super.rawGet(buildKey(uid), false);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //用戶稱號數據查詢失敗</span></code><code><span class="code-snippet_outer">    if (Objects.isNull(ldbRes)) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">        return false;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    boolean success = false;</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    ResultCode resultCode = ldbRes.getRc();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //不存在用戶稱號數據則進行初始化</span></code><code><span class="code-snippet_outer">    if (Objects.equals(resultCode, ResultCode.DATANOTEXSITS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        UserUnreadAchievementsCache userUnreadAchievementsCache = initCacheSupplier.get();</span></code><code><span class="code-snippet_outer">        success = putCache(uid, userUnreadAchievementsCache, DEFAULT_VERSION);</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    } else if (Objects.equals(resultCode, ResultCode.SUCCESS)) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        DataEntry ldbEntry = ldbRes.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        //存在新數據則對其進行更新</span></code><code><span class="code-snippet_outer">        if (Objects.nonNull(ldbEntry)) {</span></code><code><span class="code-snippet_outer">            Object data = ldbEntry.getValue();</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            if (data instanceof String) {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = JSON.parseObject(String.valueOf(data), UserUnreadAchievementsCache.class);</span></code><code><span class="code-snippet_outer">                userUnreadAchievementsCache = updater.apply(userUnreadAchievementsCache);</span></code><code><span class="code-snippet_outer">                success = putCache(uid, userUnreadAchievementsCache, ldbEntry.getVersion());</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    //緩存解鎖的稱號失敗</span></code><code><span class="code-snippet_outer">    if (!success) {</span></code><code><span class="code-snippet_outer">        recordErrorCode(InteractErrorCode.UNREAD_ACHIEVEMENT_UPSERT_ERROR, ExceptionBizParams.builder().uid(uid).build());</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer">    return success;</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 寫入新的未讀成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid                  用戶 ID</span></code><code><span class="code-snippet_outer"> * @param achievementTypeIdMap 需要新增的成就類型和成就 ID 列表的映射</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean writeUnreadAchievements(long uid, Map&lt;String, List&lt;String&gt;&gt; achievementTypeIdMap) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (MapUtils.isEmpty(achievementTypeIdMap)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    return upsertCache(uid,</span></code><code><span class="code-snippet_outer">            () -&gt; {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">                achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(userUnreadAchievementsCache, key, value));</span></code><code><span class="code-snippet_outer">                return userUnreadAchievementsCache;</span></code><code><span class="code-snippet_outer">            },</span></code><code><span class="code-snippet_outer">            oldCache -&gt; {</span></code><code><span class="code-snippet_outer">                achievementTypeIdMap.forEach((key, value) -&gt; updateCertainTypeIds(oldCache, key, value));</span></code><code><span class="code-snippet_outer">                return oldCache;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">    );</span></code><code><span class="code-snippet_outer">}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">/**</span></code><code><span class="code-snippet_outer"> * 清除未讀成就</span></code><code><span class="code-snippet_outer"> *</span></code><code><span class="code-snippet_outer"> * @param uid             用戶 ID</span></code><code><span class="code-snippet_outer"> * @param achievementType 需要清除未讀成就列表的成就類型</span></code><code><span class="code-snippet_outer"> * @return</span></code><code><span class="code-snippet_outer"> */</span></code><code><span class="code-snippet_outer">public boolean clearUnreadAchievements(long uid, Set&lt;String&gt; achievementTypes) {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    if (CollectionUtils.isEmpty(achievementTypes)) {</span></code><code><span class="code-snippet_outer">        return true;</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    return upsertCache(uid,</span></code><code><span class="code-snippet_outer">            () -&gt; {</span></code><code><span class="code-snippet_outer">                UserUnreadAchievementsCache userUnreadAchievementsCache = new UserUnreadAchievementsCache();</span></code><code><span class="code-snippet_outer">                achievementTypes.forEach(type -&gt; clearCertainTypeIds(userUnreadAchievementsCache, type));</span></code><code><span class="code-snippet_outer">                return userUnreadAchievementsCache;</span></code><code><span class="code-snippet_outer">            },</span></code><code><span class="code-snippet_outer">            oldCache -&gt; {</span></code><code><span class="code-snippet_outer">                achievementTypes.forEach(type -&gt; clearCertainTypeIds(oldCache, type));</span></code><code><span class="code-snippet_outer">                return oldCache;</span></code><code><span class="code-snippet_outer">            }</span></code><code><span class="code-snippet_outer">    );</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">重構的核心是提取了 upsert 方法，該方法將緩存數據的初始化和更新策略以函數式接口進行定義，從而支持從調用側進行透傳，避免了模板方法的重複編寫。這是一個拋磚引玉的例子，在日常開發中，我們可以更多地嘗試用函數式編程的思維去思考和重構代碼，也許會發現另一個神奇的編程世界。</span></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><span id="OSC_h4_10"></span><h4 data-lake-id="ca6fa186228ff7efaa653334195896c8" data-wording="true" style="margin-top: 0.5em;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);font-family: -apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;visibility: visible;line-height: 1.75em;"><span style="outline: 0px;visibility: visible;letter-spacing: 1px;color: rgb(0, 17, 255);"><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">▐</span></strong><strong style="outline: 0px;visibility: visible;"><span style="outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">&nbsp;&nbsp;</span></strong><strong style="outline: 0px;visibility: visible;"><span style="color: rgb(0, 17, 255);outline: 0px;font-family: Optima-Regular, PingFangTC-light;visibility: visible;">切面編程的一些實踐</span></strong></span></h4><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">AOP 想必大家都已經十分熟悉了，在此便不再贅述其基本概念，而是開門見山直接分享一些 AOP 在靜心守護項目中的實際應用。</span></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_11"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">服務層異常統一收口</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">靜心守護項目採用了在阿里系統中常用的 service-manager-dao 的分層模式，其中 service 層是距離終端最近的一層。為了防止下層預期外的異常拋到終端，我們需要在 service 層對異常進行統一攔截並且記錄，同時最好將相關的錯誤碼、請求參數以及 traceId 都一併記下，便於問題排查。這個場景就非常適合使用 AOP。在引入 AOP 之前，我們需要對每個 service 中面向終端的方法都進行異常攔截和監控日誌打印的操作。比方説下面這個類，它有 3 個面向終端 mtop【注：阿里內部自研的 API 網關平台】服務的方法（api 具體參數和名稱做了模糊化處理），這 3 個方法都採用了同樣的 try-catch 結構來進行異常捕捉和監控日誌打印，其中存在大量的重複代碼，而更糟糕的事，如果後續增加新的方法，這樣的重複代碼還會不斷增加。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">@HSFProvider(serviceInterface = MtopBlessHomeService.class)</span></code><code><span class="code-snippet_outer">public class MtopBlessHomeServiceImpl implements MtopBlessHomeService {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //依賴的 bean 注入</span></code><code><span class="code-snippet_outer">  ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceAVO&gt; entranceA(EntranceARequest request) {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(request.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            //該入口下的業務邏輯</span></code><code><span class="code-snippet_outer">            ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceA", buildMethodParamsStr(request), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceA", buildMethodParamsStr(request), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceBVO&gt; entranceB(EntranceBRequest request) {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(request.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            //該入口下的業務邏輯</span></code><code><span class="code-snippet_outer">            ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceB", buildMethodParamsStr(request), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceB", buildMethodParamsStr(request), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceCVO&gt; entranceC(EntranceCRequest request) {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(query.getUserId());</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">            //該入口下的業務邏輯</span></code><code><span class="code-snippet_outer">            ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceC", buildMethodParamsStr(request), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    "MtopBlessHomeServiceImpl.entranceC", buildMethodParamsStr(request), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }    </span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">看到這樣重複的代碼結構而只是局部行為的不同，也許我們可以考慮着用上一節的函數式行為參數化進行重構：將重複的代碼結構抽取為公共的工具方法，將對 manager 層的調用抽象為行為參數。但在上述場景下，這種做法還是存在一些弊端：</span><ne-clipboard source="https%3A%2F%2Faliyuque.antfin.com%2Flingye.jly%2Fwozrkc%2Fitpnoh733usxcgzk%3FsingleDoc%23r1wtn"></ne-clipboard></section><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">每個服務的方法還是需要顯式調用工具類方法</span></p></li><li><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">為了保證監控信息的齊全，還需要在參數裏手動透傳一些監控相關的信息</span></p></li></ol><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">而 AOP 則不存在這些問題：AOP 基於動態代理實現，在實現上述邏輯時對服務層的代碼編寫完全透明。此外，AOP 還封裝了調用端方法的各種元信息，可以輕鬆實現各種監控信息的自動化打印。下面是我們提供的 AOP 切面。其中值得注意的點是切點的選擇要儘量準確，避免增強了不必要的方法。下面我們選擇的切點是 mtop 包下所有 Impl 結尾類的 public 方法。</span></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="kotlin"><code><span class="code-snippet_outer">@Aspect</span></code><code><span class="code-snippet_outer">@Component</span></code><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">public class MtopServiceAspect {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * MtopService 層服務</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    @Pointcut("execution(public com.taobao.mtop.common.MtopResult com.taobao.gaia.veyron.bless.service.mtop.*Impl.*(..))")</span></code><code><span class="code-snippet_outer">    public void mtopService(){}</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    /**</span></code><code><span class="code-snippet_outer">     * 對 mtop 服務進行增強</span></code><code><span class="code-snippet_outer">     *</span></code><code><span class="code-snippet_outer">     * @param pjp 接入點</span></code><code><span class="code-snippet_outer">     * @return</span></code><code><span class="code-snippet_outer">     * @throws Throwable</span></code><code><span class="code-snippet_outer">     */</span></code><code><span class="code-snippet_outer">    @Around("com.taobao.gaia.veyron.bless.aspect.MtopServiceAspect.mtopService()")</span></code><code><span class="code-snippet_outer">    public Object enhanceService(ProceedingJoinPoint pjp) throws Throwable {</span></code><code><span class="code-snippet_outer">        try {</span></code><code><span class="code-snippet_outer">            startDiagnose(pjp);</span></code><code><span class="code-snippet_outer">            return pjp.proceed();</span></code><code><span class="code-snippet_outer">        } catch (InteractBizException e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, errorCode:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    AspectUtils.extractMethodName(pjp), buildMethodParamsStr(pjp), e.getErrCode(), EagleEye.getTraceId());</span></code><code><span class="code-snippet_outer">            recordErrorCode(e);</span></code><code><span class="code-snippet_outer">            return MtopUtils.errMtopResult(e.getErrCode(), e.getErrMsg());</span></code><code><span class="code-snippet_outer">        } catch (Exception e) {</span></code><code><span class="code-snippet_outer">            log.error("Service invoke fail. Method name:{}, params:{}, trace:{}",</span></code><code><span class="code-snippet_outer">                    AspectUtils.extractMethodName(pjp), buildMethodParamsStr(pjp), EagleEye.getTraceId(), e);</span></code><code><span class="code-snippet_outer">            recordErrorCode(InteractErrorCode.SYSTEM_ERROR, ExceptionBizParams.builder().build());</span></code><code><span class="code-snippet_outer">            return MtopUtils.sysErrMtopResult();</span></code><code><span class="code-snippet_outer">        } finally {</span></code><code><span class="code-snippet_outer">            DiagnoseClient.end();</span></code><code><span class="code-snippet_outer">        }</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">存在這樣一個切面後，service 層的代碼就可以變得非常簡潔：只需要純粹專注於業務邏輯。同樣以剛才的 MtopBlessHomeServiceImpl 類為例，在 AOP 改寫後的代碼裏可以去除掉原先異常收口和監控相關的內容，而僅保留業務邏輯部分，代碼簡潔性大大提升。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Slf4j</span></code><code><span class="code-snippet_outer">@HSFProvider(serviceInterface = MtopBlessHomeService.class)</span></code><code><span class="code-snippet_outer">public class MtopBlessHomeServiceImpl implements MtopBlessHomeService {</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    //依賴的 bean 注入</span></code><code><span class="code-snippet_outer">  ......</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceAVO&gt; entranceA(EntranceARequest request) {</span></code><code><span class="code-snippet_outer">        //業務邏輯</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceBVO&gt; entranceB(EntranceBRequest request) {</span></code><code><span class="code-snippet_outer">        //業務邏輯</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">    @Override</span></code><code><span class="code-snippet_outer">    public MtopResult&lt;EntranceCVO&gt; entranceC(EntranceCRequest request) {</span></code><code><span class="code-snippet_outer">        //業務邏輯</span></code><code><span class="code-snippet_outer">        ......</span></code><code><span class="code-snippet_outer">    }</span></code><code><span class="code-snippet_outer"><br></span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><ul class="list-paddingleft-1" style="list-style-type: disc;"><li style="color: rgb(0, 17, 255);"><span id="OSC_h3_12"></span><h3 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">切點選擇的策略</span></h3></li></ul><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">除了服務層以外，我們還想對數據訪問層進行監控，監控項目中各種數據存儲工具的 RT 以及成功率相關指標，並且監控粒度要儘可能地貼近業務維度（整體的數據訪問監控直接通過 eagleeye 查看即可），便於具體問題的定位排查。這種面向層級別的邏輯定製，我們很自然而然地想到了 AOP，這也正是它可以大顯身手的場景。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">這節核心想要分享的則是切點的選擇。靜心守護項目的數據存儲主要依賴於 Tair【注：阿里內部自研的高性能 K-V 存儲系統。根據存儲介質和使用場景不同又分為 LDB、MDB、RDB】、Lindorm【注：阿里內部自研的大規模雲原生多模數據庫服務】和 Mysql，這三種存儲工具在代碼中的使用各不相同，導致切點的選擇策略也大相徑庭。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><span id="OSC_h4_13"></span><h4 style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">目標對象規律分佈</span></h4><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">如果我們要選擇增強的對象在項目中分佈的非常規律，那麼我們往往可以直接利用 Spring AOP 的 PointCut 語法來選擇切點。以靜心守護項目中的 Mysql 數據訪問對象為例：我們使用的 ORM 框架是 mybatis，並且主要的用法是註解模式，所有的 SQL 邏輯都放在一個 DAO 包下，每個業務場景定義一個 DAO 結尾的 Mapper 接口，接口下的每個方法都對應着一種數據訪問的方式。因此在切點選擇時，我們可以直接選擇 DAO 包下以 DAO 結尾的類，並選擇其中 public 方法即可準確織入所有滿足條件的切點。</span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="java"><code><span class="code-snippet_outer">@Pointcut("execution(public * com.taobao.gaia.serverless.veyron.bless.dao.*DAO.*(..))")</span></code><code><span class="code-snippet_outer">public void charityProjectDataAccess() {</span></code><code><span class="code-snippet_outer">}</span></code></pre></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><p style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">這樣實現的監控粒度是具體到每個 DAO 對象-方法級別的粒度，監控效果如下：</span></p><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: center;margin-bottom: 8px;"><img class="rich_pages wxw-img" data-backh="240" data-backw="578" data-imgfileid="503041786" data-ratio="0.41574074074074074" src="https://oscimg.oschina.net/oscnet/353e7a8a-57f3-48a6-938b-7033c6681775.png" data-type="png" data-w="1080" style="width: 100%;height: auto;" referrerpolicy="no-referrer"></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;margin-bottom: 8px;line-height: 1.75em;"><br></p><span id="OSC_h4_14"></span><h4 style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">一個失效案例</span></h4><section style="margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">靜心守護項目中對 tair 的使用方式是：通過一個抽象類對 tair 的各種基礎操作進行封裝（包括參數校驗、響應判空、異常處理等），但將具體 tair 實例相關的參數設置行為抽象化，由實現類決定。各個業務場景的 tair 管理類最終會基於抽象類封裝的基礎操作來對 tair 進行數據訪問</span><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">。</span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><br></span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">如下圖，AbstractLdbManager 是封裝</span></section><section style="min-height: 24px;text-align: center;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041787" data-ratio="0.8398148148148148" src="https://oscimg.oschina.net/oscnet/7d5fa225-7c35-4cf3-97cd-8a6d1de235a5.png" data-type="png" data-w="1080" referrerpolicy="no-referrer"></span></section><section style="min-height: 24px;margin-top: 8px;line-height: 1.75em;text-align: justify;margin-bottom: 8px;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">由於各個業務場景的 tair 管理實現類分散在各個業務包下，想要對它們進行統一切入比較困難。因此我們選擇對抽象類進行切入。但這樣就會遇到一個同類調用導致 AOP 失效的問題：抽象類本身不會有實例對象，因此基於 CGLIB 創建代理對象後，代理對象本質上調用的還是各個業務場景 tair 管理類的對象，而在使用這些對象時，我們不會直接調用 tair 抽象類封裝的數據訪問方法，而是調用這些業務 tair 管理對象進一步封裝的帶業務語義的方法，基於這些方法再去調用 tair 抽象類的數據訪問方法。這種同類方法間接調用最終就導致了抽象類的方法沒有如期被增強。文字描述興許有些繞，可以參考下面的圖：</span></p><p style="min-height: 24px;text-align: center;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041815" data-ratio="0.5935185185185186" src="https://oscimg.oschina.net/oscnet/a7f4daeb-a6c6-430b-9ace-50ffd3b87165.png" data-type="png" data-w="1080" style="letter-spacing: 0.578px;text-align: center;text-wrap: wrap;" width="536" referrerpolicy="no-referrer"></span></p><section style="min-height: 24px;text-align: justify;margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">我們選擇的解決方法則是從上面的 MultiClusterTairManager 入手，這個類是 tair 為我們提供的 TairManger 的一種默認實現，我們之前的做法是為該類實例化一個 bean，然後提供給所有業務 Tair 管理類使用，也就是説所有業務 Tair 管理類使用的 TairManager 都是同一個 bean 實例（因為業務流量沒那麼大，一個 tair 實例暫時綽綽有餘）。那麼我們可以自己提供一個 TairManager 的實現，基於繼承+組合 MultiClusterTairManager 的方式，只對我們項目內用到數據訪問操作進行重寫，並委託給原先的 MultiClusterTairManager bean 進行處理。這樣我們可以在設置 AOP 切點時選擇對自己實現的 TairManager 的所有方法做增強，進而避開上面的問題。經過這樣改寫後，上面的兩張圖會演變成下面這樣：</span></p><section style="min-height: 24px;text-align: center;margin-bottom: 8px;margin-top: 8px;line-height: 1.75em;"><img class="rich_pages wxw-img" data-imgfileid="503041811" data-ratio="0.5935185185185186" src="https://oscimg.oschina.net/oscnet/a7f4daeb-a6c6-430b-9ace-50ffd3b87165.png" data-type="png" data-w="1080" width="536" referrerpolicy="no-referrer"></section><p style="min-height: 24px;text-align: justify;margin-bottom: 8px;line-height: 1.75em;margin-top: 8px;"><span style="letter-spacing: 1px;"><img class="rich_pages wxw-img" data-imgfileid="503041816" data-ratio="0.37407407407407406" src="https://oscimg.oschina.net/oscnet/dcaa95ab-35fe-49ef-8fb6-087473b0f061.png" data-type="png" data-w="1080" referrerpolicy="no-referrer"></span><br></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><span id="OSC_h4_15"></span><h4 style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;color: rgb(0, 17, 255);">基於註解切入</span></h4><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">還有一種場景是我們要增強的方法分佈毫無規律，可能都在同一個類中，但方法的名稱毫無規律，也無法簡單通過 private 或者 public 來區別。針對這樣的場景，我們的做法是自定義註解，專門用於標識需要做增強的方法。比如靜心守護項目中 lindorm 相關的數據操作就是這樣。我們定義註解：</span></section><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="css"><code><span class="code-snippet_outer">@<span class="code-snippet__keyword">Target</span>({<span class="code-snippet__selector-tag">ElementType</span><span class="code-snippet__selector-class">.METHOD</span>})</span></code><code><span class="code-snippet_outer">@<span class="code-snippet__keyword">Retention</span>(<span class="code-snippet__keyword">RetentionPolicy</span>.<span class="code-snippet__keyword">RUNTIME</span>)</span></code><code><span class="code-snippet_outer">@Documented</span></code><code><span class="code-snippet_outer">public @interface VeyronJoinPoint {}</span></code></pre></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">並將該註解標識在需要增強的方法上，隨後通過下面的方式描述切點，即可獲取到所有需要增強的方法。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section class="code-snippet__fix code-snippet__js"><pre class="code-snippet__js" data-lang="css"><code><span class="code-snippet_outer">@<span class="code-snippet__keyword">Pointcut</span>("@<span class="code-snippet__keyword">annotation</span>(<span class="code-snippet__keyword">com</span>.<span class="code-snippet__keyword">taobao</span>.<span class="code-snippet__keyword">gaia</span>.<span class="code-snippet__keyword">serverless</span>.<span class="code-snippet__keyword">veyron</span>.<span class="code-snippet__keyword">aspect</span>.<span class="code-snippet__keyword">VeyronJoinPoint</span>)")</span></code><code><span class="code-snippet_outer">public void lindormDataAccess() {}</span></code></pre></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">上面的方法也有進一步改良的空間：在註解內增加屬性來描述具體的業務場景，不同的切面根據業務場景來對捕獲的方法進行過濾，只留下當前業務場景所需要的方法。不然按照現有的做法，如果新的切面也要基於註解來尋找切點，那隻能定義新的註解，否則會與原先註解產生衝突。</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></p><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;visibility: visible;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><img class="rich_pages wxw-img" data-imgfileid="503041834" data-ratio="0.3056872037914692" data-s="300,640" data-type="png" data-w="422" src="https://oscimg.oschina.net/oscnet/18f51c34-a896-48a4-b5c4-e2bfd339953f.png" style="outline: 0px;letter-spacing: 0.544px;font-size: 14px;visibility: visible !important;width: 117px !important;" referrerpolicy="no-referrer"></section><section style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;visibility: visible;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 18px;letter-spacing: 1px;color: rgb(0, 17, 255);">總結</span></section><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">業務需求千變萬化，對應的解法也見仁見智。在研發過程中對各種變化中不變的部分進行總結，從中提取出自己的模式與方法論進行整理沉澱，會讓我們以後跑的更快。也正應了學生時期，老師常説的那句話：「我們要把厚厚的書本讀薄才能裝進腦子裏。」</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">最後，如果大家有好的實踐模式推薦或者建議，歡迎在評論區分享交流～</span></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><br></section><p style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;color: rgb(34, 34, 34);background-color: rgb(255, 255, 255);text-align: center;line-height: normal;"><img class="rich_pages wxw-img" data-imgfileid="503041835" data-ratio="0.328125" data-s="300,640" data-type="png" data-w="256" src="https://oscimg.oschina.net/oscnet/5749e182-ccf0-448e-af95-1df19ffdd6a8.png" style="outline: 0px;letter-spacing: 0.544px;font-size: 16px;visibility: visible !important;width: 122px !important;" referrerpolicy="no-referrer"></p><p style="margin-bottom: 0px;outline: 0px;font-family: system-ui, -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 0.544px;text-wrap: wrap;background-color: rgb(255, 255, 255);color: rgb(100, 99, 99);font-size: 15px;text-align: center;line-height: normal;"><span style="outline: 0px;font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;letter-spacing: 1px;font-size: 18px;color: rgb(0, 17, 255);">團隊介紹</span></p><section style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: var(--articleFontsize);letter-spacing: 0.034em;"></span><br></section><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">我們是淘天業務技術用戶消息與社交團隊，負責淘寶消息、客服、Push、分享、我淘、關係、社交互動等業務，涵蓋淘寶 APP 中兩個一級 Tab，第三個消息 tab 和第五個我的淘寶 tab，這裏有一流的產品技術，為消費者提供更好的消息與社交服務；豐富的業務場景，為淘系業務增加助力；幾十萬 QPS 的高併發流量，可以與淘系各位技術大牛合作，思想激盪碰撞，共同提升，包含以下方向：</span></p><ol class="list-paddingleft-1" style="list-style-type: decimal;"><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">在淘寶 IM 基礎上構建以用戶實時意圖感知、統一投放引擎為核心的全域觸達體系，通過跨場景的觸達方案，賦能淘系搜索、互動、用增等業務增長，每日觸達億級用戶。</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">社交域基礎平台服務，我的淘寶、淘友、互動等業務，服務上億淘寶用戶。</span></p></li><li><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">淘寶消息 tab、千牛商家消息，通過建立平台，消費者，商家之間的鏈接，提升手淘 DAU，助力商家更好的服務消費者，擁有億級電商 IM 消息即時通訊產品，可以深入掌握分佈式高可靠設計理念和架構方法論。</span></p></li></ol><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;">招聘持續火熱🔥進行中，如果有興趣可將簡歷發至 lingye.jly@taobao.com，期待您的加入！</span></p><p style="min-height: 24px;text-align: justify;margin-top: 8px;line-height: 1.75em;margin-bottom: 8px;"><span style="font-size: 15px;letter-spacing: 1px;"><br></span></p><section data-role="outer" label="Powered by 135editor.com" style="margin-bottom: 0px;outline: 0px;letter-spacing: 0.544px;visibility: visible;"><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;word-break: break-all;color: rgb(0, 0, 0);font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;text-align: center;line-height: 1.75em;"><span style="outline: 0px;color: rgb(0, 17, 255);"><strong style="outline: 0px;">¤</strong></span><span style="outline: 0px;"><strong style="outline: 0px;">&nbsp;拓展閲讀&nbsp;</strong></span><span style="outline: 0px;color: rgb(0, 17, 255);"><strong style="outline: 0px;">¤</strong></span></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;letter-spacing: 0.544px;word-break: break-all;color: rgb(0, 0, 0);font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;text-align: center;line-height: 1.75em;"><br style="outline: 0px;"></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;min-height: 24px;clear: both;visibility: visible;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D2565944923443904512%23wechat_redirect" textvalue="3DXR 技術" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">3DXR 技術</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1533906991218294785%23wechat_redirect" textvalue="終端技術" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">終端技術</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1592015847500414978%23wechat_redirect" textvalue="音視頻技術" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">音視頻技術</a></section><section style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;visibility: visible;"><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1539610690070642689%23wechat_redirect" textvalue="服務端技術" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">服務端技術</a><span style="outline: 0px;letter-spacing: 0.544px;">&nbsp;|&nbsp;</span><a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D2565883875634397185%23wechat_redirect" textvalue="技術質量" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">技術質量</a>&nbsp;|&nbsp; 
   <a target="_blank" href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fmp%2Fappmsgalbum%3F__biz%3DMzAxNDEwNjk5OQ%3D%3D%26action%3Dgetalbum%26album_id%3D1522425612282494977%23wechat_redirect" textvalue="數據算法" linktype="text" imgurl="" imgdata="null" tab="innerlink" data-linktype="2" style="outline: 0px;color: var(--weui-LINK);-webkit-user-drag: none;cursor: pointer;">數據算法</a></section><p style="margin-top: 8px;margin-bottom: 8px;outline: 0px;min-height: 24px;font-family: -apple-system, &quot;system-ui&quot;, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 0.544px;text-indent: 0em;text-align: center;line-height: 1.75em;visibility: visible;"><br style="outline: 0px;"></p><section class="mp_profile_iframe_wrp" style="margin-bottom: 24px;outline: 0px;"><mp-common-profile class="custom_select_card mp_profile_iframe js_wx_tap_highlight" data-pluginname="mpprofile" data-id="MzAxNDEwNjk5OQ==" data-headimg="http://mmbiz.qpic.cn/mmbiz_png/33P2FdAnju8t5nZGhAatCrc4e2iaDfAaoInribRKxc7MOqdTGygfcLqSDxhj0trCHVEh94Sjl7zuWYzwouYtJ0VQ/300?wx_fmt=png&amp;wxfrom=19" data-nickname="大淘寶技術" data-alias="AlibabaMTT" data-signature="大淘寶技術官方賬號" data-from="2" data-index="0" data-origin_num="685" data-isban="0" data-weuitheme="light" data-biz_account_status="0" data-is_biz_ban="0"></mp-common-profile><span style="outline: 0px;color: rgb(0, 0, 0);font-family: mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size: 15px;letter-spacing: 1px;"></span></section></section><section style="line-height: 1.75em;"><section style="display: none;line-height: 1.75em;"><br></section></section><p style="display: none;"><mp-style-type data-value="3"></mp-style-type></p></div><p style="color: #858585; font-size: 13px;">本文分享自微信公眾號 - 大淘寶技術（AlibabaMTT）。<br>如有侵權，請聯繫 support@oschina.cn 刪除。<br>本文參與「<a href="https://www.oschina.net/sharing-plan" target="_blank">OSC 源創計劃</a>」，歡迎正在閲讀的你也加入，一起分享。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 02 Jan 2024 02:59:17 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4662964/blog/10555462</guid>
            <link>https://my.oschina.net/u/4662964/blog/10555462</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[最新桌面瀏覽器市場份額排名：Edge 重回第二、Safari 跌破 10%]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>知名流量監測機構 Statcounter 公佈了 2023 年&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgs.statcounter.com%2Fbrowser-market-share%2Fdesktop%2Fworldwide" target="_blank">12 月份全球桌面瀏覽器市場份額</a>：</p><p><img src="https://static.oschina.net/uploads/space/2024/0102/101516_FTqQ_2720166.png" referrerpolicy="no-referrer"></p><p>主要數據如下：</p><ul><li><strong>Chrome：65.29%</strong></li><li><strong>Edge：<span>11.89%</span></strong></li><li><strong>Safari：<span>8.92%</span></strong></li><li>Firefox：7.61%</li><li>Opera：3.8%</li><li>360 Safe：0.71%</li><li>……</li></ul><p><img height="720" src="https://oscimg.oschina.net/oscnet/up-da555d51c704e0a59cad47fb01d30a6da9f.png" width="1280" referrerpolicy="no-referrer"></p><p>2023 年 5 月，Safari <u><a href="https://www.oschina.net/news/240186/statcounter-safari-edge">以微弱優勢超過 Edge </a></u>成為全球市場份額排名第二的桌面瀏覽器。此後幾個月也一直穩坐第二，然而沒想到 Edge 在 2023 年最後一個月來了一波大反殺——要知道 11 月 Safari 的市場份額仍有 13%，比 Edge 的 11% 高出兩個點。</p><p><img src="https://oscimg.oschina.net/oscnet/up-729990e5f76ed08ac6344603617f319861c.png" referrerpolicy="no-referrer"></p><p>然而在 12 月，Safari 的市場份額急劇下降，直接跌破 10%——只剩&nbsp;<span>8.92%。</span>目前尚無信息顯示 Safari 市場份額暴跌的背後原因。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 02:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273741/statcounter-edge-202312</guid>
            <link>https://www.oschina.net/news/273741/statcounter-edge-202312</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[openKylin 1.0 成功適配 Inte l 最新 x86 平台 Raptor Lake 系列]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#222222; margin-left:0px; margin-right:0px; text-align:justify">2023 年 12 月 25 日，openKylin 1.0 成功適配 Intel（英特爾）最新 x86 平台 Raptor Lake 系列，與國際 OSV 同步。</p><div><p style="text-align:center"><img alt="" height="410" src="https://oscimg.oschina.net/oscnet/up-fcdea1508a9a5937b9f83fbef89e66a1b9e.png" width="940" referrerpolicy="no-referrer"></p><p style="margin-left:0px; margin-right:0px">&nbsp;</p></div><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">Intel 中國公司在 2023 年 11 月加入 openKylin 社區之後，成立了 Intel SIG 並與 openKylin 社區開展合作，經過 Intel SIG 團隊成員的努力，目前 openKylin 1.0 操作系統已成功適配第 13/14 代 Intel 客戶端平台，Raptor Lake 系列，以及 ADL-N（12 代 refresh）。具體機型如下所示：</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">1.支持 Intel 最新 13/14 代 CPU 型號；</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">2.支持 Intel ADL-N, RPL-S,RPL-P, RPL-U, RPL-HX 等最新平台；</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">3.支持相關 OEM 惠普，聯想等基於 Intel13 代機的相關機型。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">測試期間，openKylin 1.0 操作系統在以上 Intel 開發機平台上整體運行穩定，功能、性能及兼容性方面表現良好。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">&nbsp;</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">Raptor Lake 是 Intel 基於混合架構的第 13 代和第 14 代 Intel 酷睿處理器的代號，採用 Raptor Cove 性能核心和 Gracemont 效率核心。與 Alder Lake 一樣，Raptor Lake 也是使用 Intel 的 Intel 7 工藝製造的。Raptor Lake 具有多達 24 個核心（8 個性能核心加 16 個效率核心）和 32 個線程，並且與 Alder Lake 系統（LGA 1700、BGA1744、BGA1964）兼容。與前幾代一樣，Raptor Lake 處理器也需要配套的芯片組。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">目前，Intel SIG 共完成 6.1 Kernel 合併 Intel 最新平台支持補丁 110 多個, 包括最新圖形，聲音，藍牙，無線，電源管理，網絡，串口，多媒體等硬件的支持。同時 linux-firmware 合併 Intel 最新平台支持補丁 170 多個，包括 Intel 最新顯卡，無線網卡，藍牙，聲音等的硬件固件支持。</p><p style="color:#222222; margin-left:0; margin-right:0; text-align:justify">未來，Intel 將持續與 openKylin 社區開展深入合作，推動 openKylin 操作系統適配更多的 Intel 最新平台，並不斷優化和完善其應用體驗，共同推動 openKylin 開源操作系統的普及和國產開源生態的打造，助力 openKylin 開源生態佈局進一步完善。</p></div>
                                    ]]>
            </description>
            <pubDate>Mon, 01 Jan 2024 01:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273735</guid>
            <link>https://www.oschina.net/news/273735</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[盤點 2023 十大宕機事故「冥場面」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>名場面？冥場面！</p><p>速來圍觀 2023 十大宕機事故「冥場面」——</p><hr><h1><a href="https://www.oschina.net/news/231236" target="_blank">嗶哩嗶哩（B 站）崩了兩次</a></h1><p>2023 年 3 月 5 日晚 20:20 左右，許多網友表示在使用 B 站時，手機和電腦端都無法訪問視頻詳情頁，且手機端無法查看收藏夾與歷史記錄。還有網友表示，首頁能夠正常加載，但全部是繁體字。</p><p><img src="https://oscimg.oschina.net/oscnet/up-affa896050135c6a15c206de322a4e28acc.png" referrerpolicy="no-referrer"></p><p><u><a href="https://www.oschina.net/news/252405">8 月 4 日晚間</a></u>，距離上次事故 5 個月後，又有許多網友反饋 B 站圖片（視頻封面）無法加載、視頻無法打開、視頻一直在緩衝。</p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/236219" target="_blank">騰訊「3.29」一級事故</a></h1><p>2023 年 3 月 29 日凌晨，騰訊旗下的微信和 QQ 等業務曾出現崩潰狀況，包括微信語音對話、朋友圈、微信支付，以及 QQ 文件傳輸、QQ 空間和 QQ 郵箱在內的多個功能無法使用。</p><p>直到 29 日早間，騰訊微信團隊才回應表示，經工程師搶修，系統正在逐步恢復。</p><p><img src="https://oscimg.oschina.net/oscnet/up-127213d84c63650497a340914182c4a89f9.png" referrerpolicy="no-referrer"></p><p>本次事故由廣州電信機房冷卻系統故障導致，騰訊將它定義為公司一級事故，並對大量相關領導做出了處罰。</p><p>4 月 12 日，工業和信息化部信息通信管理局<u><a href="https://www.oschina.net/news/236943">聽取騰訊公司關於 「3・29」 微信業務異常情況彙報</a></u>，要求騰訊公司進一步健全安全生產管理制度、落實網絡運行保障措施，堅決避免發生重大安全生產事故，切實提升公眾業務安全穩定運行水平。</p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/244039" target="_blank">唯品會 329 事故處罰結果：基礎平台部負責人被免職</a></h1><p>今年 3 月 29 日，「唯品會崩了」 登上熱搜，由於崩潰時間太長，影響了很多消費者無法正常下單。唯品會官方對此迴應稱，因系統短時故障，主站 「加購」 等功能或出現異常。</p><p>6 月 5 日，唯品會發布 「關於 329 機房宕機故障處理的公告」。公告稱，3 月 29 日（00:14-12:01）南沙 IDC 冷凍系統故障，導致機房設備溫度快速升高宕機，造成線上商城停止服務。此次事故影響時間持續 12 個小時，導致唯品會業績損失超億元，影響客戶達 800 萬，唯品會將此次故障判定為 P0 級故障。據瞭解，P0 屬於最高級別事故，比如崩潰、頁面無法訪問、主流程不通、主功能未實現，或在影響面上影響很大（即使 Bug 本身不嚴重）。</p><p>公告指出，唯品會決定對此次事件嚴肅處理，對應部門的直接管理者承擔此次事故責任，基礎平台部負責人予以免職作相應處理。</p><p><img src="https://oscimg.oschina.net/oscnet/up-168b9a6041c9b94335f6c23063ef7f9ce95.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/244118/microsoft-azure-outage-brazil" target="_blank">微軟 Azure 故障，17 個生產級數據庫被刪</a></h1><p>5 月 24 日，微軟 Azure DevOps 在巴西南部地區的一處 scale-unit 發生故障，導致宕機約 10.5 個小時。後續微軟首席軟件工程經理 Eric Mattingly 出面針對此次故障事件道歉，並<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstatus.dev.azure.com%2F_event%2F392143683%2Fpost-mortem">透露了</a>導致中斷的原因：即，一個簡單的拼寫錯誤致使 17 個生產級數據庫被刪除。</p><p><img alt="up-d28b235003ee1390973397efd32e59d2ee1.png" src="https://oscimg.oschina.net/oscnet/up-d28b235003ee1390973397efd32e59d2ee1.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/244330" target="_blank">中國電信出現大規模無服務問題</a></h1><p>2023 年 6 月 8 日下午，中國電信的網絡和通信服務出現無信號等失靈現象，絕大部分反饋的用戶都在廣東區域，疑似廣東省內故障。</p><p>此後中國電信客服迴應表示，電信基站全省（廣東電信）故障，暫時不能撥打電話，請耐心等待，現在緊急加急處理中，不便之處，敬請諒解。</p><p><img src="https://oscimg.oschina.net/oscnet/up-3ccdb0730d3b6ee9d3faf43d5d2a31c7d6e.png" referrerpolicy="no-referrer"></p><p>歷時 4 個小時左右，廣東省內電信網絡全面恢復。</p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/263266" target="_blank">語雀 10.23 重大服務故障，持續 7 小時</a></h1><p>2023 年 10 月 23 日語雀出現重大服務故障，且持續 7 個多小時才完全恢復。語雀團隊後續公佈了故障原因及處理過程：</p><p>10 月 23 日下午，服務語雀的數據存儲運維團隊在進行升級操作時，由於新的運維升級工具 bug，導致華東地區生產環境存儲服務器被誤下線。受其影響，語雀數據服務發生嚴重故障，造成大面積的服務中斷。</p><p><img src="https://oscimg.oschina.net/oscnet/up-d0d73c9d391b9afb17b5d8a1fdfe8babfa4.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/266694" target="_blank">阿里雲 11.12 重大服務故障，全線產品受影響</a></h1><p>2023 年 11 月 12 日下午，阿里雲出現嚴重故障，全線產品受影響。</p><p>後續官方確認故障原因與某個底層服務組件有關。在歷時約 5 個小時後，阿里雲宣佈受影響雲產品均已恢復，因故障影響部分雲產品的數據（如監控、賬單等）可能存在延遲推送情況，不影響業務運行。</p><p><img src="https://oscimg.oschina.net/oscnet/up-12e038da50562b9fb7806fac53534a272ac.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/268480" target="_blank">滴滴 11.27 系統服務故障，技術團隊連夜修復</a></h1><p>2023 年 11 月 27 日晚間，滴滴因系統故障導致 App 服務異常，不顯示定位且無法打車。11 月 27 日晚，滴滴出行進行了回覆：非常抱歉，由於系統故障，今天晚間滴滴 App 服務出現異常，經技術同學緊急修復，目前正陸續恢復中。</p><p>2023 年 11 月 28 日早間，滴滴出行消息稱，網約車等服務已恢復，騎車等在陸續修復中。11 月 28 日，在滴滴發出公告的同時，記者在上海、深圳等地使用滴滴呼叫網約車，發現網約車功能並未恢復使用，網絡加載異常，仍無法打車。11 月 28 日，滴滴向記者回應稱，網約車服務已恢復，司機乘客權益陸續恢復補發。</p><p><strong>11 月 29 日，滴滴再次發文致歉，稱初步確定事故起因是底層系統軟件發生故障</strong>。</p><p><img src="https://oscimg.oschina.net/oscnet/up-de730d329966eb2d4a658c5008f11be82a7.png" referrerpolicy="no-referrer"></p><blockquote><p><img src="https://static.oschina.net/uploads/space/2023/1129/113103_VOdZ_2720166.png" referrerpolicy="no-referrer"></p></blockquote><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/231624/a-single-engineer-brought-down-twitter" target="_blank">推特嚴重宕機，馬斯克暴怒</a></h1><p>2023 年 2 月，馬斯克因其關於超級碗的推文曝光度不如美國總統拜登，而深夜緊急召集約 80 人解決算法問題。</p><p>3 月份，因一名工程師修改配置導致推特出現嚴重的宕機故障，馬斯克揚言要將代碼全部進行重構。</p><p><img src="https://static.oschina.net/uploads/space/2023/0308/083022_yiJO_2720166.png" referrerpolicy="no-referrer"></p><p>7 月份，用戶反饋平台再次出現問題，無法發佈新推文，收到 「超出限制」 的錯誤提示。馬斯克則迴應稱，Twitter 正在努力應對 「極端程度的數據抓取」 和 「系統操縱」，這些新的限制是遏制這些緊迫問題的重要措施。</p><p>&nbsp;</p><h1><a href="https://www.oschina.net/news/265693" target="_blank">ChatGPT 服務中斷近 2 小時，CEO 奧特曼道歉：流量遠超預期</a></h1><p>北京時間 11 月 8 日晚 22 點左右，OpenAI 旗下 ChatGPT 以及相關 API 出現中斷故障，導致面向用戶和開發者的服務近 2 小時無法正常使用。</p><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstatus.openai.com%2F">隨後 OpenAl 更新事故報告稱</a></u>，已確定了一個導致 API 和 ChatGPT 錯誤率高的問題，正在努力修復。</p><p><img src="https://oscimg.oschina.net/oscnet/up-9dfae5273c9fd8f249f7e5bbc7592211806.png" referrerpolicy="no-referrer"></p><p>與此同時，OpenAI CEO 山姆・奧特曼<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftwitter.com%2Fsama%2Fstatus%2F1722315204242149788">公開致歉稱</a></u>，本週發佈的新功能遇到遠超預期的使用量。公司原計劃在週一為所有訂閲者啓用 GPTs 服務，但目前還無法實現。由於負載的原因，短期內可能會出現服務不穩定的情況，對此情況向用戶道歉。</p><p>&nbsp;</p><p><em>延伸閲讀：<u><a href="https://www.oschina.net/news/270052">網信辦發佈《網絡安全事件報告管理辦法（徵求意見稿）》</a></u></em></p><hr><p>更多年度重磅事件回顧，查看<strong><u><a href="https://talk.gitee.com/report/china-open-source-2023-annual-report.pdf?fr=shida_news1231" target="_blank">《2023 中國開源開發者報告》</a></u></strong>。</p><p><img height="4950" src="https://oscimg.oschina.net/oscnet/up-742bb3d98bf476a2aa6120928bae7b2ee33.png" width="3497" referrerpolicy="no-referrer"><img height="4950" src="https://oscimg.oschina.net/oscnet/up-e2e5b4d5020eec787e184044fd4f42d8c7b.png" width="3497" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 04:02:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273501</guid>
            <link>https://www.oschina.net/news/273501</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[回顧 30 年前的 IDE：只有 TUI、背景顏色亮瞎眼……]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>當談到 30 年前的集成開發環境 (IDE)，純文本模式大行其道。在 20 世紀 80 年代末/90 年代初，DOS 操作系統上的 IDE 都是<strong>基於文本用戶界面 (TUI)</strong>。這些 IDE 雖然沒有圖形界面，但卻提供了一些令人印象深刻的功能，讓程序員們能夠進行編碼、編譯和調試他們的程序。</p><p>比如 MS-DOS 自帶的編輯器 EDIT.COM。這是一個全屏 TUI 編輯器，提供了菜單欄、對話框、狀態欄等功能。雖然不太適合編碼，但它展示了當時的技術水平。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-5028193deeef003d71722a0e0206c7cba5a.png" referrerpolicy="no-referrer"></p><p>另一個經典的 IDE 是 Borland Turbo 系列，比如 Turbo C++。這些 IDE 提供了語法高亮、編譯器集成、調試器、項目管理等功能，甚至還有完整的參考手冊。這些功能在當時來説非常先進，讓程序員們能夠在沒有互聯網的情況下完成整個開發過程。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-88e0ddd9805e24b5d3fab4b5e6479936743.png" referrerpolicy="no-referrer"></p><p><em>（語法高亮）</em></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0b6a07d4eff9299bbe1994abb4e8e822709.png" referrerpolicy="no-referrer"></p><p><em>（集成編譯器和診斷）</em></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0d05a776e3a60a221c7cbec17db45f81932.png" referrerpolicy="no-referrer"></p><p><em>（集成項目和構建系統管理）</em></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-93863267f7c7ff62eff8100b50b2e2bd32e.png" referrerpolicy="no-referrer"></p><p><em>（包含斷點、堆棧跟蹤等功能的調試器）</em></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-bf6c8d95bd4f5f049c98cbaf4a30987ad5d.png" referrerpolicy="no-referrer"></p><p><em>（完整的使用手冊）</em></p><p>有人表示，Bordland 在當時出品的 IDE 確實十分驚豔，但在使用 Bordland Turbo C++ 一段時間後，眼睛都要被亮瞎了……</p><p>與此同時，Linux 上的 IDE 並不如 DOS 上的 IDE 那麼成熟。雖然也有一些文本模式的程序，比如 Vim 和 Emacs，但它們並不像 Borland Turbo 系列那樣提供完整的集成開發環境。這導致了在當時許多程序員還是更傾向於使用 DOS 上的 IDE 進行開發。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-affdf2cf4e49f6240d455b0ad65df6324d2.png" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 03:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273632/the-ides-we-had-30-years-ago</guid>
            <link>https://www.oschina.net/news/273632/the-ides-we-had-30-years-ago</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[惡意軟件濫用 Google OAuth 端點「恢復」cookie、劫持帳戶]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">多個信息竊取惡意軟件系列正在濫用名為「MultiLogin」的未記錄的 Google OAuth 端點來恢復過期的身份驗證 cookie 並登錄用戶帳戶（即使賬戶密碼已被重置）。</span></p><p style="color:#404040; margin-left:0; margin-right:0; text-align:justify"><span style="color:#000000">科技網站&nbsp;<span style="background-color:#ffffff"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bleepingcomputer.com%2Fnews%2Fsecurity%2Fmalware-abuses-google-oauth-endpoint-to-revive-cookies-hijack-accounts%2F" target="_blank">BleepingComputer</a> 指出，他們在今年 11 月底曾報道了兩名黑客：Lumma 和 Rhadamanthys，兩人聲稱可以恢復在攻擊中竊取的過期谷歌驗證 cookie。</span></span><span style="color:#000000"><span style="background-color:#ffffff">即使合法所有者已經註銷、重置密碼或會話過期，這些 cookie 仍可讓網絡犯罪分子在未經授權的情況下訪問谷歌賬戶。但在這一個多月來，BleepingComputer&nbsp;曾多次聯繫谷歌，詢問相關説法的真實性以及他們計劃如何緩解這一問題，卻從未收到過回覆。</span></span></p><p><span style="color:#000000">CloudSEK 研究人員日前發佈的一份報告則進一步揭示了這種零日漏洞利用的工作原理，並描繪了有關其利用規模的可怕景象。10 月 20 日，一個名為 PRISMA 的威脅行為者首次披露了這一漏洞稱，他們發現了一種恢復過期谷歌驗證 cookie 的方法。</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>對漏洞進行逆向工程後，CloudSEK 發現它使用了一個名為「MultiLogin」的未記錄的 Google OAuth 端點，該端點旨在通過接受帳戶 ID 和 auth-login&nbsp;tokens 向量來同步不同 Google 服務之間的帳戶。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>「此請求用於在多個 Google 網站（例如 YouTube）的 Google 身份驗證 cookie 中設置瀏覽器中的 Chrome 帳戶。」&nbsp; &nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>「這個請求是 Gaia Auth API 的一部分，只要 cookie 中的帳戶與瀏覽器中的帳戶不一致就會觸發。」</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>CloudSEK 表示，濫用該終端的信息竊取惡意軟件會提取登錄到谷歌賬戶的 Chrome 配置文件的 tokens 和賬戶 ID。這些被盜信息包含兩個關鍵數據：service (GAIA ID) 和 encrypted_token。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>加密令牌使用存儲在 Chrome 瀏覽器"Local State"文件中的加密密鑰進行解密。同樣的加密密鑰也用於解密瀏覽器中保存的密碼。利用竊取的 token：GAIA 與多重登錄端點配對，威脅行為者可以重新生成過期的 Google Service cookies，並保持對受損賬戶的持久訪問。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><img height="263" src="https://oscimg.oschina.net/oscnet/up-0d39112d34ae544e0bc2bc03fa265fea829.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#404040">CloudSek 研究員 Pavan Karthick 表示，他們對該漏洞進行了逆向工程，並能夠使用它來重新生成過期的 Google 身份驗證 cookie，如下所示：</span></p><p><img height="253" src="https://oscimg.oschina.net/oscnet/up-b05c5e78446b2fe30d3c88ba80361617dc5.png" width="700" referrerpolicy="no-referrer"></p><p><span style="color:#404040">Karthick 解釋稱，如果用戶重置其 Google 密碼，身份驗證 cookie 只能重新生成一次。否則，它可以多次重新生成，從而提供對帳戶的持久訪問。</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Lumma stealer 於 11 月 14 日首次利用了該漏洞，</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Radamanthys 是第一個在 11 月 17 日效仿的人；</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>此後還有 12 月 1 日的 Stealc、12 月 11 日的 Medusa、12 月 12 日的 RisePro 和 12 月 26 日的 Whitesnake。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>因此，目前至少有 6 個信息竊取者聲稱能夠使用此 API 端點重新生成 Google cookie。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="margin-left:0; margin-right:0; text-align:start"><span><span><span style="color:#070707"><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>此後，</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#070707">Lumma 還發布了該漏洞的更新版本：轉而使用 SOCKS 代理來逃避 Google 的濫用檢測措施，並在惡意軟件和 MultiLogin 端點之間實現加密通信；以抵消谷歌的緩解措。</span></p><p style="margin-left:0; margin-right:0; text-align:start"><span style="color:#000000"><span style="background-color:#ffffff">BleepingComputer 認為，這實際上也表明，谷歌方面是知道這一漏洞的存在的。但該公司</span>尚未確認 MultiLogin 端點被濫用的這一事件，因此目前該漏洞利用的狀態及其緩解措施仍不清楚。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 03:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273500/malware-abuses-google-oauth-endpoint-cookies</guid>
            <link>https://www.oschina.net/news/273500/malware-abuses-google-oauth-endpoint-cookies</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[1-11 月我國規上互聯網企業完成業務收入 15668 億元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="background-color:#ffffff; color:#000000"><span style="background-color:#ffffff">工信部最新</span></span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fgxsj%2Ftjfx%2Fhlw%2Fart%2F2023%2Fart_e133fb8083b84cc5993dfe7ae5eb32d0.html" target="_blank">發佈</a><span style="background-color:#ffffff; color:#000000"><span style="background-color:#ffffff">的&nbsp;2023 年 1-11 月份互聯網和相關服務業運行情況指出，</span></span><span style="color:#070707">1-11 月份，互聯網業務收入增速持續提升，利潤總額增勢放緩，研發經費持續下滑。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:justify"><strong><span>一、總體情況</span></strong></h4><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>互聯網業務收入</span></strong><strong><span>增速持續提升</span></strong><strong><span>。</span></strong></span><span>1－11</span><span>月份</span><span><span>，我國規模以上互聯網和相關服務企業</span><span><span>1</span></span><span>（以下簡稱互聯網企業）完成互聯網業務收入</span></span><span>15668 億元，同比增長 6.1%</span><span>。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><img height="249" src="https://oscimg.oschina.net/oscnet/up-207c3b83268b47a98ecb744cb5cdb7b82fb.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>利潤</span></strong><strong><span>總額</span></strong><strong><span>增勢放緩</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，我國規模以上互聯網企業營業成本同比增長</span></span><span>9.7%，增速較</span><span>1</span><span>－10 月份回落 0.1</span><span><span>個百分點。實現利潤總額</span></span><span>1189 億元，同比增長 2.5</span><span>%。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><img height="252" src="https://oscimg.oschina.net/oscnet/up-593de36ec44bc8dd102524f5b7a772b98b3.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>研發經費</span></strong><strong><span>持續下滑</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，我國規模以上互聯網企業共投入研發經費</span></span><span>822.7 億元，同比下降 4.5</span><span>%。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><img height="249" src="https://oscimg.oschina.net/oscnet/up-6fa68b7451c0f67c4ed961f6c2559e4f35a.png" width="500" referrerpolicy="no-referrer"></p><h4 style="margin-left:0px; margin-right:0px; text-align:justify"><strong><span>二、分領域情況</span></strong></h4><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>（一）信息服務領域企業</span></strong><strong><span>收入實現正增長</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，以信息服務為主的企業（包括新聞資訊、搜索、社交、遊戲、音樂視頻等）互聯網業務收入同比</span></span><span>增長 0.4</span><span>%。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>（二）生活服務領域企業收入</span></strong><strong><span>保持快速增長</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，以提供生活服務為主的平台企業（包括本地生活、租車約車、旅遊出行、金融服務、汽車、房屋住宅等）互聯網業務收入同比增長</span></span><span>22.1%。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>（三）網絡銷售領域企業收入</span></strong><strong><span>增速有所回落</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，主要提供網絡銷售服務的企業（包括大宗商品、農副產品、綜合電商、醫療用品、快遞等）互聯網業務收入同比增長</span></span><span>23.7%。</span></p><h4 style="margin-left:0px; margin-right:0px; text-align:justify"><strong><span>三、分地區情況</span></strong></h4><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>中</span></strong><strong><span>部地區互聯網業務收入增</span></strong><strong><span>速持續提升</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，東部地區完成互聯網業務收入</span></span><span>14016 億元，同比增長 6.5</span><span>%，增速與 1</span><span>－10 月份持平</span><span><span>，高於全國增速</span></span><span>0.4 個百分點，佔全國互聯網業務收入的比重為 89.5%。中部地區完成互聯網業務收入</span><span><span>701</span></span><span>億元，同比增長 10.5%，</span><span>增速</span><span>較 1－10 月份提升 4</span><span><span>個百分點，</span></span><span>高於全國增速 4.4 個百分點。西部地區完成互聯網業務收入 915.9 億元，同比下降 1.6</span><span>%，降幅較 1</span><span>－10 月份擴大 0.2</span><span><span>個百分點。東北地區完成互聯網業務收入</span></span><span>35.3 億元，同比下降 25.9</span><span>%，降幅較 1</span><span>－10 月份收窄 3.2</span><span><span>個百分點。</span></span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><img height="246" src="https://oscimg.oschina.net/oscnet/up-f13b705f77044296551c3a3d3f3473ce1a2.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>長三角</span></strong><strong><span>地區互聯網業務收入</span></strong><strong><span>增速領先</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span><span>，</span></span><span>京津冀地區完成互聯網業務收入 6000 億元，同比增長 5.6%，增速較</span><span>1</span><span>－10 月份提升 0.6 個百分點，佔全國互聯網業務收入的比重為 38.3%。</span><span>長三角</span><span>地區完成互聯網業務收入 5242 億元，同比增長 12.8%，增速較</span><span>1</span><span>－10 月份回落 0.4</span><span><span>個百分點，佔全國互聯網業務收入的比重為</span></span><span>37.5%。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><img height="307" src="https://oscimg.oschina.net/oscnet/up-ba7cb957eefa1894ad7636e89bb0f561fa4.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><span><strong><span>半數</span></strong><strong><span>地區互聯網業務</span></strong><strong><span>增速實現正增長</span></strong><strong><span>。</span></strong><span>1</span></span><span>－11 月份</span><span>，互聯網業務累計收入居前</span><span>5 名的</span><span>北京</span><span>（增長 3.2</span><span>%）、上海</span><span>（增長 17.4</span><span>%）、浙江</span><span>（增長 4.8%）、</span><span>廣東</span><span>（下降 6.6%）和天津（增長</span><span><span>19.1</span></span><span>%）共完成業務收入</span><span>13075</span><span>億元，同比增長 6.6</span><span>%，佔全國比重達</span><span>83.</span><span><span>5</span></span><span>%。全國互聯網業務增速實現正增長的省（區、市）有 16 個。</span></p><p style="color:#070707; margin-left:0; margin-right:0; text-align:justify"><img height="242" src="https://oscimg.oschina.net/oscnet/up-196ef056da869e93a9d75c6e816c15b64ef.png" width="500" referrerpolicy="no-referrer"></p><p style="color:#070707; margin-left:2px; margin-right:0; text-align:justify"><span><strong><span>附註：</span></strong>1.規模以上互聯網和相關服務企業口徑由上年互聯網和相</span><span style="color:#070707">關服務收入 500 萬元以上調整為 2000 萬元及以上，文中所有同比增速均按可比口徑計算。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 03:00:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273491</guid>
            <link>https://www.oschina.net/news/273491</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Shiori —— Go 編寫的書籤管理器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Shiori 是一個用 Go 語言編寫的簡單書籤管理器。旨在作為 Pocket&nbsp;的簡單克隆。你可以將其用作命令行應用程序或 Web 應用程序。該應用程序作為單個二進制文件分發，這意味着它可以輕鬆安裝和使用。</p><p><img height="244" src="https://static.oschina.net/uploads/space/2023/0816/150851_4oPv_4252687.png" width="500" referrerpolicy="no-referrer"></p><p><strong>特性：</strong></p><ul><li>基本書籤管理，即添加、編輯、刪除和搜索。</li><li>從 Netscape 書籤文件導入和導出書籤。</li><li>從 Pocket 導入書籤。</li><li>簡單幹淨的命令行界面。</li><li>簡單而漂亮的網絡界面，適合那些不想使用命令行應用程序的人。</li><li>由於其單一二進制格式，因此可移植。</li><li>支持 sqlite3、PostgreSQL 和 MySQL 作為其數據庫。</li><li>如果可能，默認情況下<code>shiori</code>將解析可讀內容並創建網頁的離線存檔。</li><li>[BETA]對 Firefox 和 Chrome 的<a href="https://github.com/go-shiori/shiori-web-ext">網絡擴展支持。</a></li></ul><p><img height="406" src="https://static.oschina.net/uploads/space/2023/0816/151010_pUOz_4252687.png" width="500" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 02:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/shiori</guid>
            <link>https://www.oschina.net/p/shiori</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 領先的開源數據庫自治運維平台 openGauss-DBMind]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-dbmind" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#dbmind"></a>DBMind</h1><p><a href="https://gitee.com/opengauss/openGauss-DBMind#dbmind-%E4%B8%AD%E6%96%87">中文</a> | <a href="https://gitee.com/opengauss/openGauss-DBMind#dbmind-engish">English</a></p><p>Maintainer: <a href="mailto:ai@opengauss.org">openGauss AI-SIG</a></p><h1><a id="user-content-dbmind-中文" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#dbmind-%E4%B8%AD%E6%96%87"></a>DBMind-中文</h1><p>DBMind 作為 openGauss 數據庫的一部分，為 openGauss 數據庫提供了自動駕駛能力，是一款領先的開源數據庫自治運維平台。通過 DBMind, 您可以很容易地發現數據庫的問題，同時可以實現秒級的數據庫問題根因分析。</p><p>DBMind 的特點：</p><ul><li>DBMind 採用了先進的插件化的架構形式，支持海量插件擴展；</li><li>支持多種運行模式，具備命令行交互式運行、服務式運行；</li><li>面向雲原生進行設計，支持 Prometheus，並提供多種豐富的 exporter 插件；</li><li>提供豐富的對接模式，可以很容易地與現有管理系統進行對接，支持 RESTful API、Python SDK、命令行、Prometheus 協議等模式；</li><li>支持端到端全流程的數據庫自治運維能力，包括慢 SQL 根因分析、workload 索引推薦、多指標關聯挖掘、故障自修復、異常檢測與根因分析等功能；</li></ul><p>DBMind 支持的主要能力：</p><ul><li>索引推薦</li><li>異常檢測與分析</li><li>多指標關聯分析</li><li>慢 SQL 根因分析</li><li>時序預測</li><li>參數調優與推薦</li><li>SQL 改寫與優化</li><li>故障自動修復</li></ul><p><img src="https://gitee.com/opengauss/openGauss-DBMind/raw/master/docs/dbmind.png" alt="DBMind 架構圖" referrerpolicy="no-referrer"></p><h2><a id="user-content-開始使用 dbmind" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8dbmind"></a>開始使用 DBMind</h2><h3><a id="user-content-下載並安裝 dbmind" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85dbmind"></a>下載並安裝 DBMind</h3><p>DBMind 基於 Python 語言實現，在使用 DBMind 時，需要運行環境具備 Python 虛擬機，同時安裝好所需的第三方依賴。</p><h4><a id="user-content-方式一直接下載代碼部署" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E6%96%B9%E5%BC%8F%E4%B8%80%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%A0%81%E9%83%A8%E7%BD%B2"></a>方式一：直接下載代碼部署</h4><p>DBMind 主要使用 Python 語言進行編寫，因此，可以在下載獲取 DBMind 的源代碼後，使用操作系統上安裝的 Python 虛擬機直接運行，不過該過程中的第三方依賴需要用戶手動安裝。</p><p>用戶可以通過 <code>git clone</code> 命令從 Gitee 或者 Github 上下載代碼，例如：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">git clone --depth 1 https://gitee.com/opengauss/openGauss-DBMind.git</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>也可以通過 Gitee 或者 Github 提供的 zip 包下載路徑進行下載，而後解壓縮該 zip 包即可。</p><p>下載 DBMind 後，會產生一個名為 <code>openGauss-DBMind</code> 的目錄， 將該目錄的路徑添加到環境變量<code>PATH</code>中，即可調用該目錄中的可執行文件。例如可以執行下述命令完成：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">chmod +x openGauss-DBMind/gs_dbmind</span><span id="LC2" class="line"></span><span id="LC3" class="line">echo PATH=`pwd`/openGauss-DBMind:'$PATH' &gt;&gt; ~/.bashrc</span><span id="LC4" class="line">echo 'export PATH' &gt;&gt; ~/.bashrc</span><span id="LC5" class="line"></span><span id="LC6" class="line">source ~/.bashrc</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-方式二使用安裝包進行部署" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E6%96%B9%E5%BC%8F%E4%BA%8C%E4%BD%BF%E7%94%A8%E5%AE%89%E8%A3%85%E5%8C%85%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2"></a>方式二：使用安裝包進行部署</h4><p>DBMind 會定期在 openGauss-DBMind 項目的 release 頁面發佈 DBMind 的安裝包，可以通過下載該 DBMind 安裝包進行安裝部署。該安裝包會自動將 DBMind 解壓到指定目錄，並配置好環境變量。</p><p>安裝包和校驗碼的下載地址為：</p><table><thead><tr><th>Name</th><th>Download</th><th>Remarks</th></tr></thead><tbody><tr><td>DBMind X86</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fopengauss.obs.cn-south-1.myhuaweicloud.com%2Flatest%2Fdbmind%2Fx86%2Fdbmind-installer-x86_64-python3.11.sh.tar.gz">dbmind-installer-x86_64-python3.11.sh.tar.gz</a></td><td>X86 架構下 DBMind 安裝包</td></tr><tr><td>DBMind X86 SHA256</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fopengauss.obs.cn-south-1.myhuaweicloud.com%2Flatest%2Fdbmind%2Fx86%2Fdbmind-installer-x86_64-python3.11.sh.tar.gz.sha256">dbmind-installer-x86_64-python3.11.sh.tar.gz.sha256</a></td><td>DBMind X86 安裝包 SHA256 校驗文件</td></tr><tr><td>DBMind ARM</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fopengauss.obs.cn-south-1.myhuaweicloud.com%2Flatest%2Fdbmind%2Farm%2Fdbmind-installer-aarch64-python3.11.sh.tar.gz">dbmind-installer-aarch64-python3.11.sh.tar.gz</a></td><td>ARM 架構下 DBMind 安裝包</td></tr><tr><td>DBMind ARM SHA256</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fopengauss.obs.cn-south-1.myhuaweicloud.com%2Flatest%2Fdbmind%2Farm%2Fdbmind-installer-aarch64-python3.11.sh.tar.gz.sha256">dbmind-installer-aarch64-python3.11.sh.tar.gz.sha256</a></td><td>DBMind ARM 安裝包 SHA256 校驗文件</td></tr></tbody></table><p>安裝包使用：</p><p>  解壓：tar zxvf dbmind-installer-x86_64-python3.11.sh.tar.gz</p><p>  DBMind 安裝: sh dbmind-installer-x86_64-python3.11.sh</p><h4><a id="user-content-關於 python 運行環境" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%85%B3%E4%BA%8Epython%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"></a>關於 Python 運行環境</h4><p>需要至少為 Python3.7 的版本。雖然在 DBMind 的實現中對 Python3.7 以下的環境儘可能地進行了兼容，但是這些低版本的 Python 環境疏於測試，可能會引發意料之外的異常。同時，在 DBMind 啓動時，也會嘗試校驗 Python 版本，如果 Python 版本不符合要求，則默認不會繼續執行後續的動作。</p><p><em>DBMind 的 Python 版本由根目錄下的 constant 文件中的變量做約束</em></p><p>如果您的環境需要安裝多個版本的 Python 運行時，並且它們可能會引起衝突，那麼我們建議您將 DBMind 所需的 Python 運行環境安裝到 DBMind 根目錄下的 <code>python</code> 目錄中，DBMind 會優先選擇使用在其根目錄下 <code>python</code> 目錄中的環境。即 <code>gs_dbmind</code> 命令會首先在<code>python/bin</code> 目錄下尋找 <code>python3</code> 命令執行後續的 Python 功能。</p><h4><a id="user-content-關於第三方依賴" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%85%B3%E4%BA%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96"></a>關於第三方依賴</h4><p>DBMind 所使用的第三方依賴通過 DBMind 根目錄下的 <code>requirements-xxx.txt</code> 文件指定。對於 x86 架構（amd64）以及 ARM 架構（aarch64），使用了不同的文件名進行標識。這是因為 ARM 平台對於某些第三方依賴並不友好，必須指定特定的版本才可以安裝。</p><p>可以使用 pip 工具對第三方依賴進行安裝。與前文所述的情況類似，如果您當前的操作系統不得不安裝多個 Python 運行環境，那麼，DBMind 也支持對第三方依賴進行優先選擇。即可以將第三方依賴庫存儲到 DBMind 根目錄下的 <code>3rd</code> 目錄中。 在通過 <code>gs_dbmind</code> 命令使用 DBMind 功能時，會優先選擇該目錄下的 <code>3rd</code> 目錄中的第三方依賴庫進行加載。</p><p>以 x86 環境為例，可以使用下述<code>pip</code>命令安裝 DBMind 的第三方依賴庫：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">python3 -m pip install -r requirements-x86.txt</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如果希望指定下載的第三方依賴庫地址，則可以通過 <code>--target</code> 或 <code>-t</code> 選項進行指定，例如</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">python3 -m pip install -r requirements-x86.txt -t 3rd</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-使用 dbmind" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E4%BD%BF%E7%94%A8dbmind"></a>使用 DBMind</h3><h4><a id="user-content-部署 prometheus" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E9%83%A8%E7%BD%B2prometheus"></a>部署 Prometheus</h4><p>可以通過 <a href="https://gitee.com/link?target=https%3A%2F%2Fprometheus.io%2F">Prometheus</a> 官方網站獲取下載方式，下載並部署 Prometheus，以便彙集對 openGauss 實例的監控結果。</p><h4><a id="user-content-部署 node-exporter" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E9%83%A8%E7%BD%B2node-exporter"></a>部署 Node Exporter</h4><p>下載並啓動 <a href="https://gitee.com/link?target=https%3A%2F%2Fprometheus.io%2Fdownload%2F%23node_exporter">Prometheus node exporter</a>.</p><p>Node exporter 可以用於監控 Linux 系統，因此每個 Linux 環境（或容器內）只需要部署一個實例即可。</p><h3><a id="user-content-啓動-dbmind-組件" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%90%AF%E5%8A%A8-dbmind-%E7%BB%84%E4%BB%B6"></a>啓動 DBMind 組件</h3><p>如果希望將 DBMind 作為後台服務運行，則下面的 DBMind 組件是必須安裝的，否則獲取不到數據庫的監控信息。為了獲得更高的安全機制，DBMind 提供的 exporter 默認是使用 Https 協議的，如果您覺得您的場景中不需要使用 Https 協議，則可以通過 <code>--disable-https</code> 選項禁用。</p><h4><a id="user-content-opengauss-exporter" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#opengauss-exporter"></a>openGauss Exporter</h4><p>openGauss exporter 從 openGauss 數據庫中讀取系統表（或系統視圖）的數據，並通過 Prometheus 存儲起來。由於 openGauss exporter 需要讀取監控數據庫的系統表信息，因此至少應該具備 <strong>monadmin</strong> 權限。例如，可以通過下述 SQL 語句為名為 <code>dbmind_monitor</code> 用戶賦予權限：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">ALTER USER dbmind_monitor monadmin;</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>使用 <code>gs_dbmind component opengauss_exporter ...</code> 命令即可啓動該 openGauss exporter 組件。例如，可以通過下述命令監控某個數據庫，通過 <code>--url</code> 參數指定被監控的數據庫實例地址：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component opengauss_exporter --url postgresql://username:password@host:port/database --web.listen-address 0.0.0.0 --web.listen-port 9187 --log.level warn --disable-https ...</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p><code>--url</code> 表示的是數據庫的 DSN 地址，其格式可以<a href="https://gitee.com/opengauss/openGauss-DBMind#dsn%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E">參考此處</a>。</p><p>可以通過下述命令檢查 openGauss exporter 是否已經啓動：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">curl -vv http://localhost:9187/metrics</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-reprocessing-exporter" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#reprocessing-exporter"></a>Reprocessing Exporter</h4><p>reprocessing exporter 是一個用於二次加工處理數據的 exporter. 由於 node exporter、openGauss exporter 保存到 Prometheus 中的數據是即時的監控信息，而只通過這些信息是無法反應某些指標的瞬時增量信息的，例如 TPS、iops 信息等。因此，reprocessing exporter 可以用來計算增量信息或者聚合結果等。</p><p>由於 reprocessing 是從 Prometheus 中獲取指標數據，進行二次加工處理後再返回給 Prometheus. 因此，它與 Prometheus 是一一對應的，即如果只有一個 Prometheus 服務，則只需要一個 reprocessing exporter 即可。例如，可以通過下述命令啓動 reprocessing exporter:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component reprocessing_exporter 127.0.0.1 9090 --web.listen-address 0.0.0.0 --web.listen-port 9189</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>如果您的 Prometheus 使用了<code>basic authorization</code>方式進行登錄校驗，則需要額外指定 <code>--prometheus-auth-user</code> 以及 <code>--prometheus-auth-password</code> 選項的值。</p><h3><a id="user-content-配置以及啓動" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%90%AF%E5%8A%A8"></a>配置以及啓動</h3><p>DBMind 後台服務是常駐內存的。因此，您需要首先配置一個配置文件目錄，在該目錄中保存多個 DBMind 的配置文件。可以通過 <code>gs_dbmind service</code> 命令來進行配置文件目錄的生成以及服務的啓動。該命令的使用説明為：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ gs_dbmind service --help</span><span id="LC2" class="line">usage:  service [-h] -c DIRECTORY [--only-run {...}] [--interactive | --initialize] {setup,start,stop}</span><span id="LC3" class="line"></span><span id="LC4" class="line">positional arguments:</span><span id="LC5" class="line">  {setup,start,stop}    perform an action for service</span><span id="LC6" class="line"></span><span id="LC7" class="line">optional arguments:</span><span id="LC8" class="line">  -h, --help            show this help message and exit</span><span id="LC9" class="line">  -c DIRECTORY, --conf DIRECTORY</span><span id="LC10" class="line">                        set the directory of configuration files</span><span id="LC11" class="line">  --only-run {slow_query_diagnosis,forecast}</span><span id="LC12" class="line">                        explicitly set a certain task running in the backend</span><span id="LC13" class="line">  --interactive         configure and initialize with interactive mode</span><span id="LC14" class="line">  --initialize          initialize and check configurations after configuring.</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>下面，分別介紹配置文件目錄生成，以及服務的啓停操作。</p><h4><a id="user-content-配置 dbmind" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E9%85%8D%E7%BD%AEdbmind"></a>配置 DBMind</h4><p>DBMind 提供兩種方式進行配置文件的生成。一種是交互式的，通過 <code>--interactive</code> 選項指定；另一種則需要用戶自己手動來修改，這也是默認方式。</p><p><strong>交互式配置方式</strong></p><p>下面是一些使用示例，這裏我們用 <code>CONF_DIRECTORY</code> 標識我們的配置文件目錄：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service setup -c CONF_DIRECTORY --interactive</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>通過上述命令，用戶可以在交互式界面中，根據提示信息輸入需要監控的 openGauss 實例信息和參數。</p><p><strong>手動配置方式</strong></p><p>下面的命令演示瞭如何通過手動方式進行 DBMind 配置：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service setup -c CONF_DIRECTORY</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>在執行完上述命令後，會生成一個名為 <code>CONF_DIRECTORY</code> 的目錄，這個目錄裏麪包含有很多的配置文件。不過，用戶需要配置 <code>CONF_DIRECTORY/dbmind.conf</code> 文件即可。當用戶配置完該文件後，則需要執行一下下述命令，DBMind 會根據用戶剛剛配置的信息初始化 DBMind 系統：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service setup -c CONF_DIRECTORY --initialize</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-啓動與停止 dbmind 服務" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%81%9C%E6%AD%A2dbmind%E6%9C%8D%E5%8A%A1"></a>啓動與停止 DBMind 服務</h4><p>當用戶配置完 DBMind 數據庫後，則可以直接通過下述命令啓動 DBMind 後台服務：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service start -c CONF_DIRECTORY</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>通過下述命令關閉 DBMind 服務：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service stop -c CONF_DIRECTORY</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-dbmind 的組件" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#dbmind%E7%9A%84%E7%BB%84%E4%BB%B6"></a>DBMind 的組件</h3><p>如前文所述，DBMind 基於一種插件化設計，這個組件（component）即為 DBMind 提供的插件（plugin）。通過插件式設計，DBMind 可以任意進行功能擴展。如果想要使用某個組件的功能，則需要執行<code>component</code>子命令。例如某個名為<code>xtuner</code>的組件可以進行數據的參數調優，那麼可以執行下述命令來使用<code>xtuner</code>的功能。</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component xtuner --help</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-使用 docker 運行 dbmind" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E4%BD%BF%E7%94%A8docker%E8%BF%90%E8%A1%8Cdbmind"></a>使用 Docker 運行 DBMind</h3><p>DBMind 支持 Docker, 同時也會在 Docker Hub 上定期發佈 openGauss-DBMind 的 docker 鏡像，鏡像的地址是：</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Fhub.docker.com%2Fr%2Fdbmind%2Fopengauss_dbmind">https://hub.docker.com/r/dbmind/opengauss_dbmind</a></p><p>可以通過下述命令拉取該鏡像：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker pull dbmind/opengauss_dbmind</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-創建 docker 鏡像" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%88%9B%E5%BB%BAdocker%E9%95%9C%E5%83%8F"></a>創建 Docker 鏡像</h4><p>在某些情況下，您可能希望手動創建 DBMind 的 docker 鏡像，例如想要創建基於最新代碼的鏡像時。那麼，可以通過 DBMind 代碼根目錄下的 Dockerfile 文件創建。例如在 DBMind 的根目錄中執行下述命令，即可創建名為 <code>opengauss_dbmind</code> 的鏡像：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker build -t opengauss_dbmind .</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-docker-鏡像的使用" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#docker-%E9%95%9C%E5%83%8F%E7%9A%84%E4%BD%BF%E7%94%A8"></a>Docker 鏡像的使用</h4><p>DBMind 的 docker 鏡像的默認執行文件是 <code>docker_run.py</code>，該啓動腳本可以在容器中啓動 DBMind 所需的大多數依賴服務，包括 Prometheus, openGauss exporter, reprocessing exporter. 但是，卻無法在該鏡像容器內運行 node exporter 來監控遠端服務器上的信息。</p><p>用戶可以通過下述環境變量，將需要監控的 openGauss 服務信息傳遞給 DBMind 的 docker 鏡像：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">OPENGAUSS_DSNS: 需要監控的 openGauss 數據庫實例的 DSN 信息，多個 DSN 信息用逗號 (,) 隔開</span><span id="LC2" class="line">NODE_EXPORTERS: openGauss 數據庫實例所在機器的 node exporter 地址，多個地址用逗號 (,) 隔開</span><span id="LC3" class="line">METADATABASE: 可選，將 DBMind 的離線計算結果存儲起來的位置，用 DSN 形式標識數據庫的連接信息；若為空，則默認使用 SQLite 進行存儲</span><span id="LC4" class="line">SCRAPE_INTERVAL: 可選，指標信息的採集間隔，單位是秒；默認為 15 秒</span><span id="LC5" class="line">MASTER_USER: 可選，具有管理員權限的數據庫用戶名，可以用來執行某些數據庫變更動作或者查詢當前數據庫的即時狀態信息；若為空，則採用 OPENGAUSS_DSNS 中提供的用戶</span><span id="LC6" class="line">MASTER_USER_PWD: 可選，上述 MASTER_USER 對應的用戶密碼</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>注：DSN 的配置格式可以參考<a href="https://gitee.com/opengauss/openGauss-DBMind#dsn%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E">常見問題</a>中的説明。</p><p>使用<code>docker run</code>的<code>-v</code>參數可以將路徑進行映射，docker 容器內的日誌統一寫到 <code>/log</code> 目錄中，持久化的數據統一存放在 <code>/data</code> 目錄中。使用 <code>-p</code> 參數可以將容器內的端口號進行映射，Prometheus 的容器內端口是 9090, DBMind 的 web 服務則使用 8080 端口。下面是個啓動 docker 服務的例子：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker run -it \</span><span id="LC2" class="line">    -e OPENGAUSS_DSNS="dbname=postgres user=dbmind_monitor password=DBMind@123 port=6789 host=192.168.1.100, dbname=postgres user=dbmind_monitor password=DBMind@123 port=6789 host=192.168.1.101, dbname=postgres user=dbmind_monitor password=DBMind@123 port=6789 host=192.168.1.102" \</span><span id="LC3" class="line">    -e NODE_EXPORTERS="http://192.168.1.100:9100,http://192.168.1.101:9100,http://192.168.1.102:9100" \</span><span id="LC4" class="line">    -e METADATABASE='postgresql://dbmind_metadb:DBMind%40123@192.168.1.100:6789/dbmind_metadb' \</span><span id="LC5" class="line">    -e MASTER_USER='dbmind_sys' \</span><span id="LC6" class="line">    -e MASTER_USER_PWD='DBMind@123' \</span><span id="LC7" class="line">    -e SCRAPE_INTERVAL=30 \</span><span id="LC8" class="line">    -p 38080:8080 -p 39090:9090 \</span><span id="LC9" class="line">    -v `pwd`/data:/data -v `pwd`/log:/log \</span><span id="LC10" class="line">    dbmind/opengauss_dbmind </span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>上面的例子是一主二備節點的部署形態，他們的 IP 地址分別是<code>192.168.1.100</code>、<code>192.168.1.101</code>以及<code>192.168.1.102</code>，數據庫的端口號都是 6789. 上面我們使用了三個用戶，為了方便演示，它們的密碼都設置為<code>DBMind@123</code>。其中<code>dbmind_monitor</code>負責從 openGauss 數據庫中抓取指標監控，需要具備 <code>monitor admin</code>權限；<code>dbmind_sys</code> 至少需要具備 <code>monitor admin</code>權限，以便可以獲取數據庫的即時狀態，如果具備<code>sysadmin</code>權限，則可以完成一些數據庫變更動作，如慢 SQL 查殺；<code>dbmind_metadb</code> 只是負責數據保存，具備指定數據庫的使用權限即可；同時，這裏也進行了端口和目錄的映射。</p><p>如果希望使用命令行的形式運行 DBMind，則可以直接在該 docker 鏡像內調用 <code>gs_dbmind</code> 命令即可，Python 運行時和第三方依賴等都已經打包在 docker 鏡像中了，無需再次安裝。例如，希望使用 DBMind 的參數調優組件提供的功能，則可以執行下述命令：</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker run -it dbmind/opengauss_dbmind \</span><span id="LC2" class="line">   gs_dbmind component xtuner recommend \</span><span id="LC3" class="line">   --database tpcds \</span><span id="LC4" class="line">   --db-host 192.168.1.100 \</span><span id="LC5" class="line">   --host-user omm \</span><span id="LC6" class="line">   --db-user tpcds \</span><span id="LC7" class="line">   --db-port 16000</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>注：在使用<code>docker run</code> 命令運行 <code>gs_dbmind</code> 時，需要指定 <code>-it</code> 參數，以便創建一個 tty.</p><h2><a id="user-content-常見問題" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"></a>常見問題</h2><h3><a id="user-content-dsn 的格式説明" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#dsn%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E"></a>DSN 的格式説明</h3><p>DSN 是 Database Source Name 的縮寫，這裏支持兩種格式，一種是 K-V 格式，如<code>dbname=postgres user=username password=password_value port=6789 host=127.0.0.1</code>；另一種是 URL 形式，例如<code>postgresql://username:password_value@127.0.0.1:6789/postgres</code>；對於採用 URL 格式的 DSN，由於<code>@</code>等特殊字符用來分割 URL 串中各個部分的內容，故需要 URL 編碼（URL encode）。例如某個用戶<code>dbmind</code>的密碼為<code>DBMind@123</code>，則 URL 形式的 DSN 可以是<code>postgresql://dbmind:DBMind%40123@127.0.0.1:6789</code>，即將<code>@</code>字符編碼為<code>%40</code>. 類似地，需要編碼的字符還包括其他可能引起歧義的字符，如<code>/</code>, <code>\</code>, <code>?</code>, <code>&amp;</code>.</p><h2><a id="user-content-相關資料" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99"></a>相關資料</h2><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fdocs.opengauss.org%2Fzh%2Fdocs%2Flatest%2Fdocs%2FDeveloperguide%2FAI4DB-%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E8%2587%25AA%25E6%25B2%25BB%25E8%25BF%2590%25E7%25BB%25B4.html">openGauss 在線手冊</a></li><li><a href="https://gitee.com/opengauss/openGauss-DBMind/wikis">DBMind wiki</a></li><li><a href="mailto:ai@opengauss.org">openGauss AI-SIG</a></li></ul><hr><h1><a id="user-content-dbmind-engish" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#dbmind-engish"></a>DBMind-Engish</h1><p>DBMind is a part of openGauss, which empowers openGauss to carry the autonomous operations and maintenance capabilities. DBMind is leading and open-source. Through DBMind, users can easily discover database problems and the root causes of the problems in seconds.</p><p><img src="https://gitee.com/opengauss/openGauss-DBMind/raw/master/docs/dbmind.png" alt="DBMind overview" referrerpolicy="no-referrer"></p><h2><a id="user-content-getting-started" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#getting-started"></a>Getting Started</h2><h3><a id="user-content-prerequisites" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#prerequisites"></a>Prerequisites</h3><p>In order to run DBMind, the following components should be configured and running.</p><h4><a id="user-content-python-runtime" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#python-runtime"></a>Python Runtime</h4><p>At least Python 3.7.</p><h4><a id="user-content-third-party-dependencies" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#third-party-dependencies"></a>Third-party Dependencies</h4><p>Use <code>pip3 install</code> to install the python dependencies.
Type the <code>pip3 install</code> command with dependencies according to the environment you are running:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">pip install -r requirements-aarch64.txt | requirements-x86.txt</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-prometheus-up-and-running" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#prometheus-up-and-running"></a>Prometheus up and Running</h4><p>Download and run the <a href="https://gitee.com/link?target=https%3A%2F%2Fprometheus.io%2F">Prometheus</a> time-series database.</p><h4><a id="user-content-node-exporter" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#node-exporter"></a>Node Exporter</h4><p>Download and run the <a href="https://gitee.com/link?target=https%3A%2F%2Fprometheus.io%2Fdownload%2F%23node_exporter">Prometheus node exporter</a>. Node-exporter is to monitor the Linux system. Hence, one Linux environment only needs to deploy one node-exporter.</p><h3><a id="user-content-dbmind-components" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#dbmind-components"></a>DBMind Components</h3><p>The following DBMind components are required:</p><p><strong>Note: If you want to get higher security, you should use the HTTPS scheme.</strong></p><h4><a id="user-content-opengauss-exporter-1" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#opengauss-exporter-1"></a>openGauss Exporter</h4><p>The openGauss-exporter reads data from the database and places it on the Prometheus time-series database.
OpenGauss-exporter is to monitor only one database instance. So if your deployment environment has not only one instance, you should start multiple openGauss-exporters to correspond to monitor multiple database instances.
It needs database access with a user having the role of at least <strong>monadmin</strong> (monitoring administrator) granted to run it. For example, you can grant monadmin privilege to role dbmind as below:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">ALTER USER dbmind monadmin;</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>Use the following command with the parameters below:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component opengauss_exporter ...</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>You can get detailed explanations of this component through passing <code>--help</code>:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component opengauss_exporter --help</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>For example, the following command starts it:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component opengauss_exporter --url postgresql://username:password@host:port/database --web.listen-address 0.0.0.0 --web.listen-port 9187 --log.level warn --disable-https ...</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>To test that the exporter is up, type the following command on its host (or use change the localhost to the server address):</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">curl -vv http://localhost:9187/metrics</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-reprocessing-exporter-1" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#reprocessing-exporter-1"></a>Reprocessing Exporter</h4><p>Reprocessing-exporter is a re-processing module for metrics stored in the Prometheus server. It helps Prometheus to reprocess the metric data then dump the new data into Prometheus. Therefore, only one needs to be started in a deployment environment.
To run it use the command below:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component reprocessing_exporter ...</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>Users can see usage by using <code>--help</code> too.</p><p>See this example for running the exporter in a single machine development environment:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component reprocessing_exporter 127.0.0.1 9090 --web.listen-address 0.0.0.0 --web.listen-port 9189</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>Use the following command to check that the service is up:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">curl http://127.0.0.1:9189/metrics</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-configure-start-and-stop-the-dbmind-service" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#configure-start-and-stop-the-dbmind-service"></a>Configure, Start and Stop the DBMind Service</h3><p>DBMind service is a memory-resident backend service. Therefore, users should configure it first then start or stop the service by using the configuration.</p><p>Service usages:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">$ gs_dbmind service --help</span><span id="LC2" class="line">usage:  service [-h] -c DIRECTORY [--only-run {slow_query_diagnosis,forecast,anomaly_detection,alarm_log_diagnosis,index_recommendation,knob_recommendation}] [--dry-run] [-f]</span><span id="LC3" class="line">                [--interactive | --initialize]</span><span id="LC4" class="line">                {setup,start,stop,restart}</span><span id="LC5" class="line"></span><span id="LC6" class="line">positional arguments:</span><span id="LC7" class="line">  {setup,start,stop,restart}</span><span id="LC8" class="line">                        perform an action for service</span><span id="LC9" class="line"></span><span id="LC10" class="line">optional arguments:</span><span id="LC11" class="line">  -h, --help            show this help message and exit</span><span id="LC12" class="line">  -c DIRECTORY, --conf DIRECTORY</span><span id="LC13" class="line">                        set the directory of configuration files</span><span id="LC14" class="line">  --only-run {slow_query_diagnosis,forecast,anomaly_detection,alarm_log_diagnosis,index_recommendation,knob_recommendation}</span><span id="LC15" class="line">                        explicitly set a certain task running in the backend</span><span id="LC16" class="line">  --dry-run             run the backend task(s) once. the task to run can be specified by the --only-run argument</span><span id="LC17" class="line">  -f, --force           force to stop the process and cancel all in-progress tasks</span><span id="LC18" class="line">  --interactive         configure and initialize with interactive mode</span><span id="LC19" class="line">  --initialize          initialize and check configurations after configuring.</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-configure" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#configure"></a>Configure</h4><p>DBMind offers two methods to configure. The one is an interactive mode by using <code>--interactive</code> argument, the other is a modification by hands.</p><p>See this example for configuring in the interactive mode:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service setup -c CONF_DIRECTORY --interactive</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>Then users can type parameters into the shell terminal.</p><p>See the following example for configuring by hands:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service setup -c CONF_DIRECTORY</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p>After executing the above command, the directory <code>CONF_DIRECTORY</code> will generate too many configuration files. Therefore, users should modify these parameters in the <code>CONF_DIRECTORY/dbmind.conf</code>. While users finish configuring, this command needs to be run to initialize DBMind according to the <code>CONF_DIRECTORY/dbmind.conf</code>.</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service setup -c CONF_DIRECTORY --initialize</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h4><a id="user-content-start-or-stop-the-dbmind-service" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#start-or-stop-the-dbmind-service"></a>Start or Stop the DBMind Service</h4><p>After configuring, specify your CONF_DIRECTORY, users can start or stop the service directly.</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind service start/stop -c CONF_DIRECTORY</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-component" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#component"></a>Component</h3><p>If users want to use a specific component offline. They can use the sub-command <code>component</code>:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component xxx ...</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><p><code>xxx</code> is the name of a component. Users can also get the component list by using the <code>--help</code> argument.</p><p>For example, use the following component to tune the knobs of a database:</p><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">gs_dbmind component xtuner --help</span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h1><a id="user-content-license" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#license"></a>LICENSE</h1><p>Mulan PSL v2</p><h1><a id="user-content-reference" class="anchor" href="https://gitee.com/opengauss/openGauss-DBMind#reference"></a>Reference</h1><ol><li><a href="https://gitee.com/link?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPercent-encoding">https://en.wikipedia.org/wiki/Percent-encoding</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fdba.stackexchange.com%2Fquestions%2F243219%2Fin-postgresql-url-i-cant-use-a-password-containing-special-characters">https://dba.stackexchange.com/questions/243219/in-postgresql-url-i-cant-use-a-password-containing-special-characters</a></li></ol>]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 02:37:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/opengauss/openGauss-DBMind</guid>
            <link>https://gitee.com/opengauss/openGauss-DBMind</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 反向 Debug 瞭解一下？揭祕 Java DEBUG 的基本原理]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Debug 的時候，都遇到過手速太快，直接跳過了自己想調試的方法、代碼的時候吧……</p><p>一旦跳過，可能就得重新執行一遍，準備數據、重新啓動可能幾分鐘就過去了。</p><p><img alt="Untitled.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-08oleiHOrAlh8kTie.png" referrerpolicy="no-referrer"></p><p>好在 IDE 們都很強大，還給你後悔的機會，可以直接刪除某個 Stack Frame，直接返回到之前的狀態，確切的説是返回到之前的某個 Stack Frame，從而實現讓程序「逆向運行」。</p><p><img alt="Untitled 1.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-08tZjMjyHSbNdpAu8.png" referrerpolicy="no-referrer"></p><p>這個 Reset Frame 的能力，可不只是返回上一步，上 N 步也是可以的；選中你期望的那個幀，直接 Reset Frame/Drop Frame，可以直接回到調用棧上的某個棧幀，時間反轉！</p><p>可惜這玩意也不是那麼萬能，畢竟是通過 stack pop 這種操作實現，實際上只是給調用棧棧頂的 N 個 frame pop 出來而已，還談不上是真正的「反向 DEBUG」。</p><p>相比之下， GDB 的<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sourceware.org%2Fgdb%2Fnews%2Freversible.html" rel="nofollow" target="_blank">Reverse Debugging</a>就比較強大，真正的 「反向」 DEBUG，逆向運行，實現回放。</p><p>所以吧在運行過程中，已經修改的數據，比如引用傳遞的方法參數、變量，一旦修改肯定回退不了，不然真的成時光機了。</p><p>這些亂七八糟的調試功能，都是基於 Java 內置的 Debug 體系來實現的。</p><span id="OSC_h1_1"></span><h1>JAVA DEBUG 體系</h1><p>Java 提供了一個完整的 Debug 體系<strong>JPDA</strong>(Java Platform Debugger Architecture)，這個 JPDA 架構體系由 3 部分組成：</p><ol><li><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Ftechnotes%2Fguides%2Fjvmti%2Findex.html" rel="nofollow" target="_blank">JVM TI</a>- Java VM Tool Interface</p></li><li><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Ftechnotes%2Fguides%2Fjpda%2Fjdwp-spec.html" rel="nofollow" target="_blank">JDWP</a>- Java Debug Wire Protocol</p></li><li><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Fjdk%2Fapi%2Fjpda%2Fjdi%2Findex.html" rel="nofollow" target="_blank">JDI</a>- Java Debug Interface</p></li></ol><p>如果結合 IDE 來看，那麼一個完整的 Debug 功能看起來就是這個樣子：</p><p><img alt="Untitled 2.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-08129VuqLlh19HeCExh.png" referrerpolicy="no-referrer"></p><p>解釋一下這個體系：</p><p>JVM TI 是一個 JVM 提供的一個調試接口，提供了一系列控制 JVM 行為的功能，比如分析、調試、監控、線程分析等等。也就是説，這個接口定義了一系列調試分析功能，而 JVM 實現了這個接口，從而提供調試能力。</p><p>不過吧，這個接口畢竟是 C++的，調用起來確實不方便，所以 Java 還提供了 JDI 這麼個 Java 接口。</p><p>JDI 接口使用 JDWP 這個私有的應用層協議，通過 TCP 和目標 VM 的 JVMTI 接口進行交互。</p><p>也可以把簡單這個 JDWP 協議理解為 JSF/Dubbo 協議；相當於 IDE 裏通過 JDI 這個 SDK，使用 JDWP 協議調用遠程 JVMTI 的 RPC 接口，來傳輸調試時的各種斷點、查看操作。</p><p>可能有人會問，搞什麼套殼！要什麼 JDWP，我直接 JVMTI 調試不是更香，鏈路越短性能越高！</p><p>當然可以，比如 Arthas 裏的部分功能，就直接使用了 JVMTI 接口，要什麼 JDI！直接 JVMTI 幹就完了。</p><p>開個玩笑，Arthas 畢竟不是 Debug 工具，人家根本就不用 JDI 接口。而且 JVMTI 的能力也不只是斷點，它的功能非常多：</p><p><img alt="Untitled 3.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-0819od43PdyVrEOjtTP.png" referrerpolicy="no-referrer"></p><p>左邊的功能類，提供了各種亂七八糟的功能，比如我們常用的添加一個斷點：</p><pre><code>jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)

</code></pre><p>右邊的事件類，可以簡單的理解為回調；還是拿斷點舉例，如果我用上面的 SetBreakpoint 添加了一個斷點，那麼當執行到該位置時，就會觸發這個事件:</p><pre><code>void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)

</code></pre><p>JVMTI 的功能非常之多，而 JDI 只是實現了部分 JVMTI 的方法，所以某些專業的 Profiler 工具，可能會直接使用 JVMTI，從而實現更豐富的診斷分析功能。</p><span id="OSC_h1_2"></span><h1>遠程調試與本地調試</h1><p>不知道大家有沒有留意過本地 Debug 啓動時的日誌：</p><p><img alt="Untitled 4.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-08UAIUfwqu8mWHWTH.png" referrerpolicy="no-referrer"></p><p>第一行是隱藏了後半段的啓動命令，展開後是這個樣子：</p><pre><code>/path/to/java -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:53631,suspend=y,server=n -javaagent:/path/to/jetbrains/debugger-agent.jar ...

</code></pre><p>第二行是一個 Connected 日誌，意思是使用 socket 連接到遠程 VM 的 53631 端口</p><p>上一段説到，IDE 通過 JDI 接口，使用 JDWP 協議和目標 VM 的 JVMTI 交互。這裏的 53631 端口，就是目標 JVM 暴露出的 JVM TI 的 server 端口。</p><p>而第一行裏，IDEA 自動給我們加上了<code>-agentlib:jdwp=transport=dt_socket,address=127.0.0.1:53631</code>這麼一段，這個參數的意思就是，讓 jvm 以 53631 暴露 jdwp 協議</p><p>小知識，這個 agentlib 可不只是為 jvmti 提供的。它還可以讓 JVM 加載其他的 native lib 包，直接「外掛」到你的 jvm 上，下面是「外掛」的參數格式：</p><p><img alt="Untitled 5.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-08Vy0912rKBUuOBMye.png" referrerpolicy="no-referrer"></p><p>所以吧，上面的描述其實不太嚴謹，更專業的説法是：</p><p>讓 JVM 加載 JDWP 這個 agent 庫，參數為<code>transport=dt_socket,address=127.0.0.1:53631</code>，這個 jdwp agent 庫以 53631 端口提供了 jdwp 協議的 server。只不過這個 jdwp 是 jvm 內部的庫，不需要額外的 so/dylib/dll 文件。</p><p>如有需要，你完全可以弄個 「datupiao」 的 agentlib，「外掛」到這個 jvm 上，然後在這個 lib 裏調用 JVMTI 接口，然後暴露個端口提供服務和遠程交互，實現自己的 jdwp！</p><p>可能某些老闆們注意到了，本地調試還要 127.0.0.1 走 tcp 交互一遍，那遠程調試呢？</p><p>基於上面的解釋，本地調試和遠程調試真的沒啥區別！或者説，在目前 IDEA/Eclipse 的實現下，不存在本地調試，都是遠程！只不過一個是 127.0.0.1，一個是遠程的 IP 而已。</p><p>在本地調試時，IDEA 會自動給我們的 JVM 增加<code>agent</code>參數，隨機指定一個端口，然後通過 JDI 接口連接，代碼大概長這樣（JDI 的 SDK 在 JDK_HOME/lib/tools.jar ）：</p><pre><code>Map&lt;String, Connector.Argument&gt; env = connector.defaultArguments();
env.get("hostname").setValue(hostname);
env.get("port").setValue(port);

VirtualMachine vm = connector.attach(env);

</code></pre><p>瞅瞅， VirtualMachine 裏的就這點方法，能力上比 JVMTI 還是差遠了</p><pre><code>List&lt;ReferenceType&gt; classesByName(String className);

List&lt;ReferenceType&gt; allClasses();

void redefineClasses(Map&lt;? extends ReferenceType, byte[]&gt; classToBytes);

List&lt;ThreadReference&gt; allThreads();

void suspend();

void resume();

List&lt;ThreadGroupReference&gt; topLevelThreadGroups();

EventQueue eventQueue();

EventRequestManager eventRequestManager();

VoidValue mirrorOfVoid();

Process process();

</code></pre><p>再回來看看 IDEA 中獨立的遠程調試，配置好之後，紅框裏的信息會提示你 ，遠程的 JVM 需增加這一段啓動參數，而且支持多個版本 JDK 的格式，CV 大法就能直接用。</p><p><img alt="Untitled 6.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-09aZdTrWaGxcoBVtI.png" referrerpolicy="no-referrer"></p><span id="OSC_h1_3"></span><h1>-agentlib 和 -javaagent</h1><p>有些細心的同學可能發現了，IDEA 默認的啓動腳本里，同時配置了 -agentlib 和 -javaagent。</p><pre><code>-javaagent:/path/to/jetbrains/debugger-agent.jar 

</code></pre><p>這個 debugger-agent 吧，其實也沒幹啥事，只是對 JDK 內置的一些線程做了些增強，輔助 IDEA 的 debug 功能，支持一些異步的調試。</p><p><img alt="Untitled 7.png" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-19-12-09uMEzNf19FBA12z11N.png" referrerpolicy="no-referrer"></p><p>agentlib、javaagent 這倆兄弟，定位其實很像，都是加載自定義的代碼。</p><p>不過區別在於，agentlib 是加載 native lib，需要 c/cpp 去寫，相當於外掛自己的代碼在 jvm 上，可以為所欲為，比如在 agentlib 裏調用上面説的 JVMTI 。</p><p>而 javaagent 是用 java 寫的，可以直接用上層的 Instrumentation API，做一些類的增強轉換之類，這也是大多數 APM Agent、Profiler Agent 實現的基本原理。</p><span id="OSC_h1_4"></span><h1>Arthas 的玩法</h1><p>Arthas 的核心入口，其實還是 javaagent，支持靜態加載和動態加載兩種玩法。</p><p>靜態沒啥好説的，啓動腳本里增加一個<code>-javaagent:/tmp/test/arthas-agent.jar</code>，然後為所欲為。</p><p>動態的叫 attach，使用 Java 提供的<code>VirtualMachine</code>就可以實現運行時添加 -javaagent，效果一樣：</p><pre><code>VirtualMachine virtualMachine = VirtualMachine.attach(virtualMachineDescriptor);
virtualMachine.loadAgent(agentPath, agentArgs);

</code></pre><p>這個 Agent 在 JVM 裏啓動了一個 TCP server，用於收發 Arthas Client 的各種 trace、watch 、Dashboard 等指令，然後通過 Instrumentation 增強 Class 插入代碼、或者直接調用某些 Java API，實現各種功能。</p><p>注意到了嗎？Arthas 可以直接下載一個 jar 包，java -jar 就能連上。</p><p>其實吧，它這個直接啓動的 jar 包，是一個 boot 包，啓動之後把亂七八糟的 jar 都下載下來。接着動態 attach 的方式，連接到本機指定進程號的 JVM，然後再為所欲為。</p><p>在 3.5 版本之後，Arthas 還新增了一個<strong><strong>vmtool</strong></strong>命令，這個命令可以直接獲取內存中的指定對象實例。</p><pre><code>$ vmtool --action getInstances --className java.lang.String --limit 10
@String[][
    @String[com/taobao/arthas/core/shell/session/Session],
    @String[com.taobao.arthas.core.shell.session.Session],
    @String[com/taobao/arthas/core/shell/session/Session],
    @String[com/taobao/arthas/core/shell/session/Session],
    @String[com/taobao/arthas/core/shell/session/Session.class],
    @String[com/taobao/arthas/core/shell/session/Session.class],
    @String[com/taobao/arthas/core/shell/session/Session.class],
    @String[com/],
    @String[java/util/concurrent/ConcurrentHashMap$ValueIterator],
    @String[java/util/concurrent/locks/LockSupport],
]

</code></pre><p>直接獲取內存對象，這玩意只靠 Instrumentation API 可做不到。Arthas 搞了個騷操作，直接 JNI 調用自定義 lib，用過 cpp 直接調用了 JVMTI 的 API，融合了 Instrumentation 和 JVMTI 的能力，這下是真的為所欲為了！</p><pre><code>#include &lt;stdio.h&gt;
#include &lt;jni.h&gt;
#include &lt;jni_md.h&gt;
#include &lt;jvmti.h&gt;
#include "arthas_VmTool.h" // under target/native/javah/

static jvmtiEnv *jvmti;

...

extern "C"
JNIEXPORT jobjectArray JNICALL
Java_arthas_VmTool_getInstances0(JNIEnv *env, jclass thisClass, jclass klass, jint limit) {
    jlong tag = getTag();
    limitCounter.init(limit);
    jvmtiError error = jvmti-&gt;IterateOverInstancesOfClass(klass, JVMTI_HEAP_OBJECT_EITHER,
                                               HeapObjectCallback, &amp;tag);
    if (error) {
        printf("ERROR: JVMTI IterateOverInstancesOfClass failed!%u\n", error);
        return NULL;
    }

    jint count = 0;
    jobject *instances;
    error = jvmti-&gt;GetObjectsWithTags(1, &amp;tag, &amp;count, &amp;instances, NULL);
    if (error) {
        printf("ERROR: JVMTI GetObjectsWithTags failed!%u\n", error);
        return NULL;
    }

    jobjectArray array = env-&gt;NewObjectArray(count, klass, NULL);
    //添加元素到數組
    for (int i = 0; i &lt; count; i++) {
        env-&gt;SetObjectArrayElement(array, i, instances[i]);
    }
    jvmti-&gt;Deallocate(reinterpret_cast&lt;unsigned char *&gt;(instances));
    return array;
}

</code></pre><span id="OSC_h1_5"></span><h1>總結</h1><ol><li><p>Debug 基於 JDPA 體系</p><ol><li><p>IDE 直接接入 JDPA 體系中的 JDI 接口完成</p></li><li><p>JDI 通過 JDWP 協議，調用遠程 VM 的 JVMTI 接口</p></li><li><p>JDWP 是通過 agentlib 加載的，agentlib 算是一個 native 的靜態「外掛」接口</p></li></ol></li><li><p>javaagent 是 JAVA 層面的「外掛」接口，用過 Instrumentation API（Java）實現各種功能，主要用於 APM、Profiler 工具</p></li><li><p>如果你想，在 javaagent 裏調用功能更豐富的 JVMTI 也不是不行。</p></li></ol><blockquote><p>作者：京東保險，蔣信</p><p>來源：京東雲開發者社區，轉載請註明來源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Sun, 31 Dec 2023 02:32:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10388524</guid>
            <link>https://my.oschina.net/u/4090830/blog/10388524</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[致敬過去，迎接未來：DataCap 感恩有您的 2023，翹首期盼 2024 的精進與共創]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>親愛的 <code>DataCap</code> 軟件用戶，開發者：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;時光荏苒，<code>2023</code> 年即將成為過去，我們深感榮幸與感慨地站在這個時刻，對您們表達我們最深切的感謝。在過去的一年中，我們一直感受到了您們對我們軟件的不離不棄和堅定支持，這是我們最寶貴的動力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>2023</code> 年是我們 <code>DataCap</code> 軟件發展的關鍵一年。我們榮幸地宣佈，預定支持的大部分功能在這一年裏得以實現。然而，我們也要坦誠地承認，雖然這些功能在某些方面還存在不足和改進的空間，但正是在這個過程中，您們對我們軟件的寬容與理解成為我們前行路上最強大的支持。無論是在社交媒體上的反饋，還是通過郵件和客服的溝通以及 <code>GitHub</code> 和 <code>Gitee</code> 反饋，您們的每一次建議和反饋都是我們前進的明燈，是我們改進的方向。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在這個感恩的季節，我們要向每一位 <code>DataCap</code> 用戶致以最衷心的感謝。是你們的熱情使用和持續支持，讓我們能夠不斷髮展、完善軟件。每一個新的用戶，每一個老用戶，都是我們成長曆程中不可或缺的一部分。感謝您們的信任，讓我們得以在軟件開發的道路上越走越遠。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;隨着 <code>2023</code> 年即將謝幕，我們更加興奮地展望着 <code>2024</code> 年。我們承諾，為了回饋您們的信任，我們將不遺餘力地投入到軟件的不斷完善中。我們將不懈努力，以確保軟件在穩定性、安全性和用戶友好性方面取得更大的進步。我們也將持續關注用戶反饋，不斷優化用戶體驗，確保軟件在您們手中能夠發揮最大的價值。同時也希望您在使用軟件中遇到的任何問題以及技術與我們溝通，我們將會以最大能力去解決並修復它。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在此，我們要特別感謝那些默默為軟件發展貢獻的開發者們 (<strong>排名不分先後，開發者的列表為 github 中的 id</strong>，如果您有興趣可以關注他 (她) 們)。<code>mlboy</code>、<code>why198852</code>、<code>javalover123</code>、<code>pan3793</code>、<code>GtoCm</code>、<code>Smilewh888</code>、<code>chenwenming-zj</code>、<code>Stacey1018</code>、<code>hometownglory</code>、<code>shuangzishuai</code> 等等，感謝你們的辛勤付出和無私奉獻。正是有了你們的技術支持，軟件才能不斷創新、不斷進步。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;感謝 <code>GitHub</code>，<code>Gitee</code> 對軟件的託管和支持，在此向他們所有的工作人員致敬。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;感謝 <code>OpenTiny</code> 對我們的支持。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;最後，讓我們向新老用戶們表達最真摯的感激之情。是你們的陪伴，讓我們在軟件的道路上走得更加堅定。在新的一年裏，我們期許能夠為您們帶來更多的驚喜和便捷。無論您是一位新用戶，還是一位老用戶，都請相信，您的支持是我們前行的最大動力。</p><p><code>2024</code> 年，願我們繼續攜手，共同創造更加美好、更加智能的未來。</p><p>再次感謝您們的支持！</p><p>DataCap 軟件團隊 (Devlive 開源組織)</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 30 Dec 2023 11:01:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273459/datacap-news</guid>
            <link>https://www.oschina.net/news/273459/datacap-news</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Farewell to Pika, Embracing the Arrival of PikiwiDB in 2024]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>今年 (2023 年)&nbsp;3&nbsp;月份於某接手項目時，OpenAtom&nbsp;基金會&nbsp;Pika&nbsp;項目（ <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FOpenAtomFoundation%2Fpika" target="_blank">https://github.com/OpenAtomFoundation/pika</a> ）對接人告訴我，OpenAtom&nbsp;基金會旗下的多個項目都面臨了一個共同問題：項目名稱被第三方註冊為商標。出於合規要求，餘三月份重點工作之一就是給項目重新申請一個全新的名稱。</p><p>在與&nbsp;Pika&nbsp;老團隊的成員進行商討後，結合了&nbsp;「兔子哥」&nbsp;和&nbsp;「YYJ」&nbsp;的建議，我決定將其命名為&nbsp;"Pi-kiwi-DB"：</p><ol><li>"Pi"&nbsp;念派 2.&nbsp;"Pik"&nbsp;恰好保留了&nbsp;"Pika"&nbsp;的前三個字母 3.&nbsp;"kiwi"&nbsp;音同&nbsp;"KV"，寓意幾維鳥</li></ol><p><img src="https://oscimg.oschina.net/oscnet/up-d73a02aed0d881c1ab72b620a395aac8a55.png" alt="" referrerpolicy="no-referrer"></p><p>Kiwi&nbsp;鳥孵化的鳥蛋佔據身體容量的一半，象徵着計算機大部分數據存儲在磁盤上，代表着&nbsp;「極大容量」；Kiwi&nbsp;鳥羽翼退化，身體小巧，雙腿強壯佔體重&nbsp;1/3，跑速快如人類，象徵着&nbsp;「極致性能」。所以，這一命名的選擇充分考慮了項目的發展方向和原有名稱的延續。</p><p>在&nbsp;2023&nbsp;年&nbsp;7&nbsp;月底，PikiwiDB（前身為&nbsp;Pika）發佈了自&nbsp;2021&nbsp;年加入&nbsp;OpenAtom&nbsp;基金會以來的首個生產可用版本&nbsp;v3.5.0。該版本通過採用&nbsp;C++17&nbsp;對整個代碼進行了重構，顯著提升了項目的代碼質量。全新的全量同步機製取代了備受詬病的&nbsp;Rsync&nbsp;方案，該方案在過去的&nbsp;8&nbsp;年裏一直在使用。此外，升級了&nbsp;RocksDB&nbsp;版本、引入新的集羣方案、增強了可觀測性、跨平台支持&nbsp;Mac&nbsp;等方面都取得了顯著的改進。</p><p>在接下來的半年中，PikiwiDB&nbsp;陸續發佈了&nbsp;v3.5.1&nbsp;和&nbsp;v3.5.2&nbsp;兩個版本，並計劃在不久的將來發布&nbsp;v3.5.3。這些版本的更新實現了數據的冷熱分離、命令的快慢分離、Redis&nbsp;事務、雲原生&nbsp;K8s&nbsp;Operator&nbsp;以及&nbsp;Go&nbsp;測試集的集成。這一系列的改進將讀性能提升到了微秒級別，單機讀取&nbsp;QPS&nbsp;翻倍，可達&nbsp;60&nbsp;萬&nbsp;/s。在穩定性和性能方面都取得了顯著的提升。社區活躍度方面，貢獻者數量增加了近&nbsp;3&nbsp;倍，達到&nbsp;121&nbsp;人（包括&nbsp;PikiwiDB&nbsp;和&nbsp;Pika），同時&nbsp;PR&nbsp;和&nbsp;Issue&nbsp;的總量也翻番，許多老用戶紛紛迴歸。</p><p>到&nbsp;12&nbsp;月，OpenAtom&nbsp;基金會告知：Pika&nbsp;新名稱&nbsp;PikiwiDB&nbsp;已經在政府相關部門獲得批准，商標也已審批下來。這標誌着整個過程的順利完成。</p><p>回顧&nbsp;2023&nbsp;年&nbsp;12&nbsp;月份，社會第三方機構對&nbsp;PikiwiDB&nbsp;(原&nbsp;Pika)&nbsp;的評價：</p><p>這一過程展示了&nbsp;PikiwiDB&nbsp;對項目的持續改進，不僅在技術上取得了顯著的進步，而且在品牌命名和合規性方面也取得了圓滿成功。</p><p><img src="https://oscimg.oschina.net/oscnet/up-dddcab84de08ed2d058294f472911e37f90.png" alt="" referrerpolicy="no-referrer"></p><ul><li>12&nbsp;月&nbsp;08&nbsp;日，Pika&nbsp;社區和&nbsp;dubbogo&nbsp;社區雙雙榮獲&nbsp;Oschina&nbsp;「2023 年度優秀開源技術團隊」</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-3d425b37dbb7dcd23e4cdf3d273695db0ad.png" alt="" referrerpolicy="no-referrer"></p><blockquote></blockquote><ul><li>12&nbsp;月&nbsp;13&nbsp;日，Pika[已更名&nbsp;PikiwiDB]&nbsp;被第三方獨立機構&nbsp;艾瑞諮詢研究院&nbsp;列為&nbsp;2023&nbsp;年&nbsp;&nbsp;「中國基礎軟件開源產業主要參與者」【DUBBO&nbsp;亦列其中】</li></ul><p><img src="https://oscimg.oschina.net/oscnet/up-846de83809b0b9fbab55bee81a04e84f452.png" alt="" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-89332cd585fca59db07e2cedcb162bbf7b3.png" alt="" referrerpolicy="no-referrer"></p><ul><li>12&nbsp;月&nbsp;29&nbsp;日，PikiwiDB(Pika)&nbsp;第一次以&nbsp;PikiwiDB&nbsp;的身份亮相&nbsp;Oschina&nbsp;2023&nbsp;年《中國開源開發者報告》</li></ul><p>展望&nbsp;2024&nbsp;年，PikiwiDB&nbsp;將重點發力於&nbsp;<a href="">雲原生方向</a>，繼續在&nbsp;「極大容量、極高性能、極致彈性」&nbsp;方向上進行探索。誠邀&nbsp;PikiwiDB（原&nbsp;Pika）社區的用戶積極參與共建，共同推動&nbsp;PikiwiDB（原&nbsp;Pika）在雲計算時代的發展。</p><p><img src="https://oscimg.oschina.net/oscnet/up-708fbac71201d8d036a6f6efa9fb2e1ed79.png" alt="" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 30 Dec 2023 04:32:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/dubbogo/blog/10475258</guid>
            <link>https://my.oschina.net/dubbogo/blog/10475258</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Vue 2 生命週期即將結束]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>在新的一年即將到來之際，尤雨溪於日前<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.vuejs.org%2Fposts%2Fvue-2-eol" target="_blank">發文</a>提醒 Vue 社區稱，Vue 2 將於 2023 年 12 月 31 日達到生命週期結束 (EOL)；並呼籲還在使用 Vue 2 的開發團隊考慮遷移至最新的&nbsp;Vue 3 版本。</p><p>Vue 2.0 於 2016 年發佈，距今已有 7 年多的時間。尤雨溪表示，2.0 版本是 Vue 成為主流框架歷程中的一個重要里程碑。「然而，並行地主動維護兩個主要版本對我們來説是不可持續的。隨着 Vue 3 及其生態系統的成熟，團隊是時候繼續前進並將精力集中在最新的主要版本上。」</p><p><img height="303" src="https://oscimg.oschina.net/oscnet/up-624c109953c0efc8aa6cc403c47e6b21d3b.png" width="700" referrerpolicy="no-referrer"></p><p>隨着&nbsp;Vue 2.0 版本 EOL 日期的臨近，他建議&nbsp;Vue 社區應該為 Vue 2 的棄用做好準備。12 月 31 日，Vue 團隊將在 npm 上將以下軟件包標記為已棄用：</p><ul><li>Vue 2 核心的所有主要和次要版本</li><li>專門支持 Vue 2 的 vue-router 版本（3.x 及更低版本）</li><li>專門支持 Vue 2 的 vuex&nbsp;版本（3.x 及更低版本）</li></ul><p>2023 年 12 月 31 日之後，Vue 2 將不再接收新功能、更新或修復，但仍可在所有現有分發渠道（CDN、包管理器、GitHub 等）上使用。<span style="color:#374151">換句話説，用戶的應用程序可以繼續工作，但會從包管理器中收到棄用警告，提醒其 Vue 2 不再是受支持的版本。</span></p><p><span style="color:#374151">Vue 3 自 2022 年 2 月 7 日以來就一直是 Vue 的默認版本。尤雨溪表示，遷移後的用戶將可以享受：</span></p><p>&nbsp;</p><ul style="margin-left:0; margin-right:0"><li>更小的包尺寸和更快的渲染帶來更好的性能。</li><li>增強的 TypeScript 支持，更輕鬆地進行大規模應用程序開發。</li><li>更高效的基於代理的反應系統。</li><li>新的內置組件，如 Fragment、Teleport 和 Suspense。</li><li>改進了構建工具支持和 Vue Devtools 體驗，等等。</li></ul><p>對於暫時無法遷移或者步向前一的用戶，他也提供了一些其他建議：<span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--tw-prose-headings)"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>更新到 Vue 2 的最終版本、或購買 Vue 2 的擴展支持，以及和用戶分享相關的</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>&nbsp;Vue 2 EOL 計劃</span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:var(--tw-prose-headings)"><span><span><span><span><span><span><span><span><span><span><span><span><span><span>。於 12 月 24 日發佈的&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="background-color:#ffffff; color:#333333">2.7.16 是 Vue 2 的最終版本，包括了對 2.7 功能的一些最終修復，並改進了與 Vue 3 的類型對齊。</span></p><p><span style="background-color:#ffffff; color:#333333">「Vue 2 的結束僅標誌着一個新的開始——2024 年對 Vue 來説將是激動人心的一年！」</span></p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 30 Dec 2023 03:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273400/vue-2-eol</guid>
            <link>https://www.oschina.net/news/273400/vue-2-eol</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[GitHub Copilot Chat 普遍可用]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>今年早些時候，GitHub 推出了 Copilot Chat；一個類似於 ChatGPT 的以編程為中心的聊天機器人，適用於訂閲 Copilot for Business 的組織。前不久，Copilot Chat 的測試版也面向 Copilot 個人用戶推出，每月收費 10 美元。</p><p>時至今日，GitHub 發文<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.blog%2F2023-12-29-github-copilot-chat-now-generally-available-for-organizations-and-individuals%2F" target="_blank">宣佈</a>，GitHub Copilot Chat 現已普遍適用於 Visual Studio Code 和 Visual Studio，經過驗證的教師、學生和流行開源項目的維護人員也可以免費使用。</p><p><img alt="" height="266" src="https://oscimg.oschina.net/oscnet/up-a3b881ee5bc1674182cfdc6412c6fab4398.webp" width="500" referrerpolicy="no-referrer"></p><p>「所有 GitHub Copilot 個人用戶現在都可使用 GitHub Copilot Chat 功能。企業和組織管理員可通過為其用戶啓用 Copilot Chat 設置，授予開發團隊訪問 Copilot Chat 的權限。如果你已經在測試版中使用了 Copilot Chat，或者已經為你的開發團隊提供了訪問權限，則無需進行其他操作。」</p><p>GitHub Copilot Chat 由 GPT-4 提供支持，並專門針對開發場景進行了微調。開發人員可以用自然語言提示 Copilot Chat，以獲得實時指導，例如要求 Copilot Chat 解釋概念、檢測漏洞或編寫單元測試。</p></div>
                                    ]]>
            </description>
            <pubDate>Sat, 30 Dec 2023 03:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/273397/github-copilot-chat-now-generally-available</guid>
            <link>https://www.oschina.net/news/273397/github-copilot-chat-now-generally-available</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Infinigen —— 無限高質量 3D 數據生成器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Infinigen 是無限高質量 3D 數據生成器，使用程序生成的無限逼真世界。這些數據 100% 通過程序化生成，不需要外部資產，也不依賴 AI，並且是免費開源的，生成質量非常高，據稱可以達到以假亂真的地步，甚至是花瓣上的皺紋都可定製。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-89f0a56c9b3a6cc8ff8cedb7501aecff0e0.png" referrerpolicy="no-referrer"></p><p>Infinigen 由普林斯頓視覺和學習實驗室開發：</p><ul><li>基於 Blender 編寫</li><li>每個小細節都是隨機的和可定製的，甚至是花瓣上的皺紋</li><li>自然界中多樣的物體和場景：植物、動物、地形；火、雲、雨和雪</li><li>Groundtruth 自動標註：光流、3D 場景流、深度、表面法線、全景分割、遮擋邊界</li></ul><p>其主要特性和功能包括：</p><p>1. 程序化：Infinigen 是一個程序生成器，它完全使用隨機的數學規則來創建所有的形狀和材料，從宏觀結構到微觀細節。Infinigen 可以創建無限的變化。用戶可以通過覆蓋隨機化的默認參數來完全控制資產的生成。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f9d8159ed3837b185ace5578b1e2d6b0973.png" referrerpolicy="no-referrer"></p><p>2. 多樣化：Infinigen 為自然世界中的多樣化對象和場景提供生成器，包括植物、動物、地形，以及火、雲、雨、雪等自然現象。當前對自然的關注是由於觀察到哺乳動物的視覺在自然世界中進化。然而，預計 Infinigen 將隨着時間的推移擴展到覆蓋建築環境和人造物體。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-e4874348efa3dd1ae71f5d170027ed35b43.png" referrerpolicy="no-referrer"></p><p>3. 真實的幾何形狀：Infinigen 針對計算機視覺研究進行了優化，特別是 3D 視覺。Infinigen 不使用 bump/normal-maps、全透明度或其他偽造幾何細節的技術。Infinigen 的所有細微的幾何細節都是真實的，確保了精確的 3D 地面真實性。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-2579dc0164572ce5aa1add312a321e16803.png" referrerpolicy="no-referrer"></p><p>4. 自動註釋：Infinigen 可以自動生成各種計算機視覺任務的高質量註釋，包括光流、3D 場景流、深度、表面法線、全景分割、遮擋邊界。因為用戶可以完全訪問渲染過程，所以註釋很容易定製。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-cbb0ac43739fd281ebc6ccdd23cead6aff3.png" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Sat, 30 Dec 2023 02:40:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/infinigen</guid>
            <link>https://www.oschina.net/p/infinigen</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 嵌入式軟件平台框架 VSF]]>
            </title>
            <description>
                <![CDATA[<h1><a id="user-content-vsf----versaloon-software-framework" class="anchor" href="https://gitee.com/vsfteam/vsf#vsf----versaloon-software-framework"></a>VSF -- Versaloon Software Framework</h1><p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fvsfteam%2Fvsf%2Fblob%2Fmaster%2FLICENSE"><img src="https://img.shields.io/github/license/vsfteam/vsf.svg" alt="GitHub" referrerpolicy="no-referrer"></a></p><p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fvsfteam%2Fvsf%2Factions%2Fworkflows%2Fwindows-build.yml"><img src="https://github.com/vsfteam/vsf/actions/workflows/windows-build.yml/badge.svg" alt="windows-build" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fvsfteam%2Fvsf%2Factions%2Fworkflows%2Fcmake-native-build.yml"><img src="https://github.com/vsfteam/vsf/actions/workflows/cmake-native-build.yml/badge.svg" alt="cmake-native-build" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fvsfteam%2Fvsf%2Factions%2Fworkflows%2Fcmake-arm-cross-build.yml"><img src="https://github.com/vsfteam/vsf/actions/workflows/cmake-arm-cross-build.yml/badge.svg" alt="cmake-arm-cross-build" referrerpolicy="no-referrer"></a></p><p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fvsf-linux%2Fvsf.linux%2Factions%2Fworkflows%2Fwindows-build.yml"><img src="https://github.com/vsf-linux/vsf.linux/actions/workflows/windows-build.yml/badge.svg?branch=vsf-sync" alt="vsf.linux windows build" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fvsf-linux%2Fvsf.linux%2Factions%2Fworkflows%2Fcmake-arm-cross-build.yml"><img src="https://github.com/vsf-linux/vsf.linux/actions/workflows/cmake-arm-cross-build.yml/badge.svg?branch=vsf-sync" alt="cmake-arm-cross-build" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fvsf-linux%2Fvsf.linux%2Factions%2Fworkflows%2Fcmake-native-build.yml"><img src="https://github.com/vsf-linux/vsf.linux/actions/workflows/cmake-native-build.yml/badge.svg?branch=vsf-sync" alt="cmake-native-build" referrerpolicy="no-referrer"></a></p><p><a href="https://gitee.com/vsfteam/vsf/blob/master/README.md">English</a> |</p><p>VSF 全稱是 Versaloon Software Framework，是一個基於 Apache2.0 協議的開源嵌入式軟件平台框架。包含了從底層硬件的 hal 驅動、搶佔式多任務內核、各種服務和組件。全部代碼使用 C 語言，以及面向對象的方式實現。</p><h2><a id="user-content-整體框架" class="anchor" href="https://gitee.com/vsfteam/vsf#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"></a>整體框架</h2><h2><a id="user-content-目錄" class="anchor" href="https://gitee.com/vsfteam/vsf#%E7%9B%AE%E5%BD%95"></a>目錄</h2><table><thead><tr><th>目錄名</th><th>描述</th></tr></thead><tbody><tr><td>document</td><td>文檔</td></tr><tr><td>doxygen</td><td>doxygen 配置</td></tr><tr><td>example</td><td>示例代碼</td></tr><tr><td>hardware</td><td>VSF 開發板硬件資料</td></tr><tr><td>patch</td><td>一些補丁（第三方庫補丁等等）</td></tr><tr><td>script</td><td>一些工具腳本</td></tr><tr><td> cmake</td><td>cmake 工具腳本</td></tr><tr><td>source</td><td>VSF 源代碼</td></tr><tr><td> component</td><td>組件（文件系統、協議棧、UI、外部芯片驅動）</td></tr><tr><td> hal</td><td>硬件抽象層（芯片 arch 支持、芯片驅動）</td></tr><tr><td> kernel</td><td>內核</td></tr><tr><td> osa_service</td><td>依賴內核的軟件服務組件</td></tr><tr><td> service</td><td>軟件服務組件</td></tr><tr><td> shell</td><td>「皮膚」</td></tr><tr><td> utilities</td><td>基礎軟件工具（一些預處理功能、編譯器支持、列表等等）</td></tr></tbody></table><h2><a id="user-content-內核" class="anchor" href="https://gitee.com/vsfteam/vsf#%E5%86%85%E6%A0%B8"></a>內核</h2><p>基於事件驅動的搶佔式多任務內核，支持 51、8bit MCU、32/64 bit arm、riscv、x86 等等各種構架的芯片。</p><ul><li>事件驅動，有事件運行，沒事件休眠</li><li>搶佔模式下，任務切換由硬件實現，任務優先級就是硬件 swi（software interrupt）的優先級</li><li>不同優先級搶佔，同一優先級協作</li><li>可以運行在其他系統或者 RTOS 中，也可以運行在一個或者幾個 SWI 中斷中（和其他 RTOS 並存）。</li><li>多種任務形式
<ul><li>事件處理任務 -- 最小資源佔用，最簡配置下佔用 20 字節 ram，常用配置下佔用 40 字節 ram</li><li>pt 任務 -- 接近獨立堆棧任務開發方式的共享堆棧任務</li><li>獨立堆棧任務 -- 依賴 libc 中的 setjmp 庫</li><li>fsm 狀態機任務</li><li>「皮膚」中的其他任務封裝形式，比如 pthread</li></ul></li><li>信號量、互斥量、觸發器、隊列等等常用 IPC 工具</li></ul><h2><a id="user-content-組件" class="anchor" href="https://gitee.com/vsfteam/vsf#%E7%BB%84%E4%BB%B6"></a>組件</h2><ul><li>合理的框架設計，軟件高度可以複用</li><li>儘可能提供申明式的開發方式</li><li>標準化接口，第三方軟件一次性移植，全平台適配</li><li>軟件組件/框架
<ul><li>distbus -- 分佈式總線框架</li><li>fifo</li><li>heap</li><li>json</li><li>pool -- 內存池</li><li>stream -- 流接口</li><li>trace</li></ul></li><li>組件
<ul><li>fs -- 文件系統，支持 VFS（可使用第三方的文件系統）</li><li>input -- 輸入系統</li><li>mal -- 塊設備</li><li>scsi -- SCSI 設備</li><li>tcpip -- TCPIP 協議棧以及 netdrv 網絡設備（可使用第三方的 TCPIP 協議棧）</li><li>ui -- UI 以及顯示設備（可使用第三方的 GUI）</li><li>usb -- USB 主從機協議棧</li><li>bt -- 藍牙協議棧（使用第三方的 btstack）</li></ul></li></ul><h2><a id="user-content-硬件抽象層" class="anchor" href="https://gitee.com/vsfteam/vsf#%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82"></a>硬件抽象層</h2><ul><li>標準 hal 接口，統一 API -- 比如：vsf_spi_init 可以用於所有 VSF 中支持的 SPI，包括芯片自帶 SPI、GPIO 模擬的 SPI、通過 USB 外擴的 SPI，通過分佈式總線訪問的遠端 SPI</li><li>簡化開發的 IP 核驅動 -- 移植僅需要實現時鐘、復位、中斷等等 IP 核心之外的功能</li><li>各種接口封裝模板</li><li>接口
<ul><li>PM</li><li>GPIO</li><li>SPI</li><li>I2C</li><li>PWM</li><li>ADC</li><li>SWI</li><li>USART</li><li>FLASH</li><li>USB</li><li>ethernet</li></ul></li></ul><h2><a id="user-content-皮膚" class="anchor" href="https://gitee.com/vsfteam/vsf#%E7%9A%AE%E8%82%A4"></a>「皮膚」</h2><p>「皮膚」可以把 VSF「偽裝」成其他系統，使得可以直接使用基於其他系統的應用代碼。</p><ul><li>SDL -- 可以直接使用一些基於 SDL 的應用層代碼</li><li>linux -- 可以直接使用一些基於 linux 的應用層代碼
<ul><li>posix</li><li>devfs</li><li>socket</li><li>console</li><li>一些 lib 庫的實現
<ul><li>libusb</li><li>libgen</li></ul></li></ul></li></ul><h2><a id="user-content-第三方" class="anchor" href="https://gitee.com/vsfteam/vsf#%E7%AC%AC%E4%B8%89%E6%96%B9"></a>第三方</h2><table><thead><tr><th>名字</th><th>路徑</th><th>許可</th><th>鏈接</th></tr></thead><tbody><tr><td>btstack</td><td>source/component/3rd-party/btstack/raw</td><td>Other</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fbluekitchen%2Fbtstack">https://github.com/bluekitchen/btstack</a></td></tr><tr><td>coremark</td><td>source/component/3rd-party/coremark/raw</td><td>Apache</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Feembc%2Fcoremark">https://github.com/eembc/coremark</a></td></tr><tr><td>freetype</td><td>source/component/3rd-party/freetype/raw</td><td>FreeType</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Ffreetype.org%2F">https://freetype.org/</a></td></tr><tr><td>zlib</td><td>source/component/3rd-party/zlib/raw</td><td>zlib</td><td><a href="https://gitee.com/link?target=http%3A%2F%2Fzlib.net%2F">http://zlib.net/</a></td></tr><tr><td>nuklear</td><td>source/component/3rd-party/nuklear/raw</td><td>MTI</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FImmediate-Mode-UI%2FNuklear">https://github.com/Immediate-Mode-UI/Nuklear</a></td></tr><tr><td>nnom</td><td>source/component/3rd-party/nnom/raw</td><td>Apache 2.0</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fmajianjia%2Fnnom">https://github.com/majianjia/nnom</a></td></tr><tr><td>lua</td><td>source/component/3rd-party/lua/raw</td><td>MIT</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.lua.org%2F">https://www.lua.org/</a></td></tr><tr><td>lwip</td><td>source/component/3rd-party/lwip/raw</td><td>BSD</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fsavannah.nongnu.org%2Fprojects%2Flwip%2F">https://savannah.nongnu.org/projects/lwip/</a></td></tr><tr><td>libpng</td><td>source/component/3rd-party/libpng/raw</td><td>PNG2</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Flibpng.sf.net">https://libpng.sf.net</a></td></tr><tr><td>libjpeg-turbo</td><td>source/component/3rd-party/libjpeg-turbo/raw</td><td>BSD</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Flibjpeg-turbo.org%2F">https://libjpeg-turbo.org/</a></td></tr><tr><td>SDL_ttf</td><td>source/shell/media/sdl2/3rd-party/SDL_ttf</td><td>zlib</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fhg.libsdl.org%2FSDL_ttf%2F">https://hg.libsdl.org/SDL_ttf/</a></td></tr><tr><td>SDL_image</td><td>source/shell/media/sdl2/3rd-party/SDL_image</td><td>zlib</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fhg.libsdl.org%2FSDL_image%2F">https://hg.libsdl.org/SDL_image/</a></td></tr><tr><td>lvgl</td><td>source/component/3rd-party/lvgl/raw/lvgl</td><td>MIT</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Flvgl.io%2F">https://lvgl.io/</a></td></tr><tr><td>lv_lib_freetype</td><td>source/component/3rd-party/lvgl/extension/lv_lib_freetype/raw</td><td>MIT</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Flvgl.io%2F">https://lvgl.io/</a></td></tr><tr><td>CMSIS</td><td>source/utilities/compiler/arm/3rd-party/CMSIS</td><td>Apache 2.0</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FARM-software%2FCMSIS_5">https://github.com/ARM-software/CMSIS_5</a></td></tr><tr><td>evm</td><td>source/component/3rd-party/evm/raw</td><td>Apache 2.0</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fscriptiot%2Fevm">https://github.com/scriptiot/evm</a></td></tr><tr><td>LingLongGUI</td><td>source/component/3rd-party/LingLongGUI/raw</td><td>Apache 2.0</td><td><a href="https://gitee.com/gzbkey/LingLongGUI">https://gitee.com/gzbkey/LingLongGUI</a></td></tr><tr><td>PLOOC</td><td>source/utilities/3rd-party/PLOOC/raw</td><td>Apache 2.0</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FGorgonMeducer%2FPLOOC">https://github.com/GorgonMeducer/PLOOC</a></td></tr><tr><td>mbedtls</td><td>source/component/3rd-party/mbedtls/raw</td><td>Apache 2.0</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Ftls.mbed.org%2F">https://tls.mbed.org/</a></td></tr><tr><td>GuiLite</td><td>source/component/3rd-party/GuiLite/raw</td><td>Apache 2.0</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fidea4good%2FGuiLite">https://github.com/idea4good/GuiLite</a></td></tr><tr><td>Segger_RTT</td><td>source/component/3rd-party/segger/raw/RTT</td><td>segger</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fwiki.segger.com%2FRTT">https://wiki.segger.com/RTT</a></td></tr><tr><td>Segger_SystemView</td><td>source/component/3rd-party/segger/raw/SystemView</td><td>segger</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fwiki.segger.com%2FSystemView">https://wiki.segger.com/SystemView</a></td></tr><tr><td>nuconsole</td><td>source/component/3rd-party/nuconsole/raw</td><td>nuvoton</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.nuvoton.com.cn%2F">https://www.nuvoton.com.cn/</a></td></tr><tr><td>AIC8800M_SDK</td><td>source/hal/driver/AIC/AIC8800/vendor</td><td>aic</td><td><a href="https://gitee.com/link?target=http%3A%2F%2Fwww.aicsemi.com%2F">http://www.aicsemi.com/</a></td></tr><tr><td>awtk</td><td></td><td>LGPL 2.1</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.zlg.cn%2Findex%2Fpub%2Fawtk.html">https://www.zlg.cn/index/pub/awtk.html</a></td></tr><tr><td>littlefs</td><td>source/component/3rd-party/littlefs/raw</td><td>BSD</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Flittlefs-project%2Flittlefs">https://github.com/littlefs-project/littlefs</a></td></tr><tr><td>getopt_long</td><td>source/shell/sys/linux/lib/3rd-party/getopt</td><td>OpenBSD</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fopenbsd%2Fsrc">https://github.com/openbsd/src</a></td></tr><tr><td>regex</td><td>source/shell/sys/linux/lib/3rd-party/regex</td><td>OpenBSD</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fopenbsd%2Fsrc">https://github.com/openbsd/src</a></td></tr><tr><td>fnmatch</td><td>source/shell/sys/linux/lib/3rd-party/fnmatch</td><td>BSD</td><td><a href="https://gitee.com/link?target=http%3A%2F%2Fwww.jbox.dk%2Fsanos%2Fsource%2Flib%2Ffnmatch.c.html">http://www.jbox.dk/sanos/source/lib/fnmatch.c.html</a></td></tr><tr><td>glob</td><td>source/shell/sys/linux/lib/3rd-party/glob</td><td>BSD</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fcloudius-systems%2Fmusl">https://github.com/cloudius-systems/musl</a></td></tr><tr><td>setjmp</td><td>source/hal/arch/x86/win</td><td>BSD</td><td></td></tr><tr><td>libtuv</td><td>source/shell/sys/linux/lib/3rd-party/libtuv/raw</td><td>Apache 2.0</td><td><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FSamsung%2Flibtuv">https://github.com/Samsung/libtuv</a></td></tr></tbody></table><h2><a id="user-content-文檔" class="anchor" href="https://gitee.com/vsfteam/vsf#%E6%96%87%E6%A1%A3"></a><a href="https://gitee.com/vsfteam/vsf/blob/master/document/README_zh.md">文檔</a></h2>]]>
            </description>
            <pubDate>Sat, 30 Dec 2023 02:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/vsfteam/vsf</guid>
            <link>https://gitee.com/vsfteam/vsf</link>
        </item>
    </channel>
</rss>
