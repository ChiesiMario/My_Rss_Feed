<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-綜合資訊]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 30 Nov 2023 06:47:03 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[Roundcube 與 Nextcloud 合併]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">開源電子郵件項目&nbsp;Roundcube 已與 Nextcloud 完成合並。公告<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnextcloud.com%2Fblog%2Fopen-source-email-pioneer-roundcube-comes-aboard-nextcloud%2F" target="_blank">指出</a>，合併完成後的</span><span style="background-color:#ffffff; color:#121212">短期內計劃是改進集成和加速開發，包括</span>擴展 Roundcube 團隊，以及支持和​​發展貢獻社區，邀請新人才來促進項目的發展和健康。</p><p><span style="background-color:#ffffff; color:#121212">除此之外，Roundcube 和 Nextcloud </span><span style="background-color:#ffffff; color:#050404">之間的直接合並尚未計劃</span><span style="background-color:#ffffff; color:#121212">。</span><span style="color:#000000">Roundcube 不會取代 Nextcloud Mail，反之亦然。Nextcloud Mail 將按原計劃發展，專注於在 Nextcloud 中的使用；Roundcube 則將繼續作為獨立的安全郵件客戶端為其活躍用戶和新用戶提供服務。</span></p><p><span style="background-color:#ffffff; color:#121212">2024 年，Nextcloud 將持續投資<span>&nbsp;</span>Roundcube，對該項目進行調整和改進，以創建適合廣大用戶的完整產品。</span></p><p><span style="background-color:#ffffff; color:#121212"><img alt="" height="313" src="https://oscimg.oschina.net/oscnet/up-97ca74865ebcea22f7fe4d93ba5e30eb8af.webp" width="500" referrerpolicy="no-referrer"></span></p><blockquote><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">Roundcube 是一款多語言 IMAP 客戶端，具有類似應用程序的用戶界面，支持 MIME、地址簿、文件夾、郵件搜索和拼寫檢查。提供充分的安全和隱私保護，包括 PGP、XSS 抵禦和暴力保護。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">Nextcloud&nbsp;是一套用於創建網絡硬盤的客戶端－服務器軟件。其功能與 Dropbox 相近，但 Nextcloud 是自由及開放源代碼軟件，每個人都可以在私人服務器上安裝並運行它。</span></p></blockquote><p><span style="color:#000000">Nextcloud 創始人&nbsp;Frank Karlitschek 稱，「此次合併不僅彰顯了開源社區的集體力量，還突出了我們對隱私、安全和用戶授權的持久承諾。」</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnextcloud.com%2Fblog%2Fopen-source-email-pioneer-roundcube-comes-aboard-nextcloud%2F" target="_blank">查看官方公告</a>。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 06:20:45 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268830/roundcube-comes-aboard-nextcloud</guid>
            <link>https://www.oschina.net/news/268830/roundcube-comes-aboard-nextcloud</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[為什麼會有人去 DDoS 攻擊 Blender？]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#000000">Blender 上週發佈</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.blender.org%2Fnews%2Fcyberattack-november-2023%2F" target="_blank">公告稱</a><span style="background-color:#ffffff; color:#000000">，blender.org 網站在 2023 年 11 月 18 日至 23 日期間持續受到 DDoS 攻擊，攻擊者通過不斷髮送請求致使網站服務器超載而癱瘓，導致網站運營嚴重中斷。除了 blender.org 主網站外，其他一些服務也無法使用。</span></p><blockquote><p><strong><em><u><a href="https://www.oschina.net/news/267990/blender-cyberattack-2023" target="_blank">Blender 連續 5 天遭受大規模 DDoS 攻擊</a></u></em></strong></p></blockquote><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">該攻擊由具有數百個 IP 地址的殭屍網絡執行，發送超過 15 億個惡意請求，峯值速率為 10 萬 rps（每秒請求）。網站斷斷續續的可用了幾天，但即使在攻擊者暫停攻擊的短時間內，Blender 的基礎設施仍然因大量待處理的合法請求而超載，導致服務器難以跟上。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><span style="color:#000000">在經過四天的抵禦攻擊之後 (11 月 21 日) 後，Blender 決定將其網站轉移到了 CloudFlare，以減少攻擊的影響。目前尚未有人聲稱對這次襲擊負責，動機也未知。</span></p><p style="color:#333333; margin-left:0; margin-right:0; text-align:left"><img alt="up-affc1ae024c2e2724c7542ba5f0d983081b.png" src="https://oscimg.oschina.net/oscnet/up-affc1ae024c2e2724c7542ba5f0d983081b.png" referrerpolicy="no-referrer"></p><p>問題來了，為什麼像 Blender 這樣沒有商業價值的網站也會遭遇 DDoS 攻擊？</p><p>HN 上的一名網友<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D38454048" target="_blank">發表了自己的看法</a></u><strong>：提供 DDoS 服務的攻擊者需要向黑市「展示」能力</strong>，以證明它們自己的能力。恰好，Blender 是一個理想的目標——知名度高，團隊有技術專家，而且擁有足夠的技術專業知識來發布和覆盤 DDoS 的詳細信息。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-3b538a86727834eae0b853e70980a29a231.png" referrerpolicy="no-referrer"></p><p>所以，並不是有人想要傷害 Blender 本身，只是 DDoS 服務供應商/駭客組織想要公開展示自己並宣傳他們的服務。剛好這次 Blender 被選中了。</p><p>對於「無辜」的開源項目（如 Blender）受到無端攻擊，各位有什麼看法？歡迎在評論區討論交流。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 06:13:45 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268827</guid>
            <link>https://www.oschina.net/news/268827</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[工信部印發《2023 年 5G 工廠名錄》]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#333333">工業和信息化部近日印發《</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fzwgk%2Fzcwj%2Fwjfb%2Ftz%2Fart%2F2023%2Fart_53532488d3394047b85116f5b29b3e32.html" target="_blank">2023 年 5G 工廠名錄</a><span style="background-color:#ffffff; color:#333333">》。</span></p><blockquote><p><span style="color:#070707">為深入推進「5G+工業互聯網」創新發展，打造 5G 工廠中國品牌，各地依據《5G 全連接工廠建設指南》（工信廳信管〔2022〕23 號）加快推動 5G 工廠建設，取得積極成效。經省級工業和信息化主管部門、通信管理局推薦，工業互聯網戰略諮詢專家委評審以及公示等程序，確定了 2023 年 5G 工廠名錄，現予以公佈。</span></p></blockquote><p><span style="color:#070707"><img alt="" height="4404" src="https://oscimg.oschina.net/oscnet/up-5a849aef64cd677596498f4b34767f9b5b8.jpg" width="500" referrerpolicy="no-referrer"></span></p><hr><h4 style="margin-left:0px; margin-right:0px"><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.miit.gov.cn%2Fzwgk%2Fzcjd%2Fart%2F2023%2Fart_1741388b2be2476b819199c8b1127b5e.html" target="_blank"><strong>一圖讀懂《2023 年 5G 工廠名錄》</strong></a></h4><p style="margin-left:0px; margin-right:0px"><strong><img alt="" height="5541" src="https://oscimg.oschina.net/oscnet/up-3998b1700458d5f0a87e0f258eb9f38c9dc.jpg" width="500" referrerpolicy="no-referrer"></strong></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 03:38:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268811</guid>
            <link>https://www.oschina.net/news/268811</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[蘋果每台設備的 Arm 專利費比塑料薄膜還便宜]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theinformation.com%2Farticles%2Fhow-a-lopsided-apple-deal-got-under-arms-skin">根據 The Information 的報道</a></u>，蘋果每年銷售數億部 iPhone、iPad、Mac 和 Apple Watch 和其他使用 Arm 芯片的智能設備，但每台設備只向 Arm 支付不到 30 美分（約合人民幣 2.15 元）的版權專利費用。</p><blockquote><p><img height="736" src="https://static.oschina.net/uploads/space/2023/1130/105919_wrxb_2720166.png" width="1768" referrerpolicy="no-referrer"></p></blockquote><p><strong>在所有獲得 Arm 授權的芯片設計公司裏，蘋果支付的費率最低，每年支付的費用不到 Arm 收入的 5%。相比之下，Arm 最大的兩個客戶高通和聯發科，支付的費用比蘋果高一倍</strong>。</p><p>這種不平衡的交易對於 Arm 來説是一個問題，因為它無法從蘋果這個重要客戶那裏獲得足夠的收入。文章提到，軟銀首席執行官孫正義曾在 2017 年的一次會議上向 Arm 的高管們抱怨蘋果的低費用，並以 iPhone 上的塑料保護膜來強調這一觀點——孫正義告訴與會者，<strong>蘋果為保護新 iPhone 屏幕的塑料薄膜支付的費用比為 Arm 知識產權授權的費用還要高</strong>。</p><p>然而，多年過去了，這個問題仍然存在。</p><p>據瞭解，軟銀集團在 2016 年收購 Arm 時，首席執行官孫正義希望能重新談判並提高費率，不過並沒有成功。Arm 最初是由多家科技公司投資的合資企業，蘋果是其創始成員之一，未來雙方也沒有分開的打算。</p><p>Arm 遞交的美國 IPO 文件顯示：蘋果公司與 Arm 就芯片技術簽署新版長期性協議，「雙邊合作關係將延續至 2040 年之後」。遠遠超過科技領域通常的五年期限。</p><p>除了 Arm 架構外，蘋果也在研究開源的 RISC-V 架構，過往曾有發佈相關的招聘信息。一方面 RISC-V 架構不需要支付任何專利費，可進一步降低成本，另一方面可以作為與 Arm 等其他公司合作的籌碼。從目前情況來看，蘋果和 Arm 複雜的合作關係可能會持續數十年。</p><ul><li><u><em><a href="https://www.oschina.net/news/158746/apple-looking-for-risc-v-programmers">蘋果正在招聘 RISC-V 開發者</a></em></u></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:54:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268797</guid>
            <link>https://www.oschina.net/news/268797</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[幻方量化旗下 DeepSeek 發佈 67B 開源大模型]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">知名私募巨頭幻方量化<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FZj7gPGqJ8UTTxp1umfWjKQ" target="_blank">宣佈</a>，其探索 AGI（通用人工智能）的新組織「深度求索（DeepSeek）」繼 11 月初發布 Coder 代碼模型之後，正式發佈通用大語言模型：DeepSeek LLM 67B。模型已完全開源，同時服務已經全面開放內測。</span></p><p><span style="color:#000000">目前 DeepSeek 已同時開源 7B 和 67B 的兩種規模模型，均含基礎模型（base）和指令微調模型（chat）。無需申請，免費商用。同時，項目團隊還將訓練中途的 9 個模型 checkpoints 開放下載。</span></p><p><span style="color:#000000">相比開源的同級別模型 LLaMA2 70B，DeepSeek LLM 67B 在近 20 箇中英文的公開評測榜單上表現更佳。尤其突出的是推理、數學、編程等能力（如：HumanEval、MATH、CEval、CMMLU）。</span></p><p><img height="412" src="https://oscimg.oschina.net/oscnet/up-90b96f11cad1cebc1a6f8ed065af941752e.png" width="500" referrerpolicy="no-referrer"></p><p><img height="418" src="https://oscimg.oschina.net/oscnet/up-b18e003f54e25e5fcb9112b2733d0c1afc3.png" width="500" referrerpolicy="no-referrer">&nbsp;</p><p><img height="418" src="https://oscimg.oschina.net/oscnet/up-ae3911e345f12b177ff22551b6f2adfd615.png" width="500" referrerpolicy="no-referrer"></p><p><img height="432" src="https://oscimg.oschina.net/oscnet/up-fb75c7324ae7131702fad2abdc8a6f96af6.png" width="500" referrerpolicy="no-referrer"></p><p><img height="288" src="https://oscimg.oschina.net/oscnet/up-2f23eeacbc701e424120f6c2507412d23de.png" width="500" referrerpolicy="no-referrer"></p><p><img height="418" src="https://oscimg.oschina.net/oscnet/up-4e497e6c1d9e0cb35dfd6f064c7ad2f7ea0.png" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:25:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268792</guid>
            <link>https://www.oschina.net/news/268792</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[助力 AI 開發，openKylin AI 框架安裝助手正式發佈！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0; margin-right:0; text-align:justify"><span>當前，以大模型為代表的人工智能技術迅猛發展，成為全球技術焦點，越來越多的開發者投入到人工智能技術的學習和應用中。AI 框架是 AI 算法模型設計、訓練和驗證的一套標準接口、特性庫和工具包，集成了算法的封裝、數據的調用以及計算資源的使用，同時面向開發者提供了開發界面和高效的執行平台，是現階段 AI 算法開發的必備工具。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span>目前在操作系統上安裝 AI 框架並不是件容易的事情，需要安裝合適的顯卡驅動、加速工具、依賴軟件以及配置系統環境等。每一個環節出問題都會導致 AI 框架安裝失敗。</span><strong><span>為了讓 AI 開發者能夠更快的投入到算法設計和 AI 開發當中，openKylin 社區 AI4OS SIG 組開發了 AI 框架安裝助手</span></strong><strong><span>，助力 AI 開發者實現一鍵安裝 AI 框架</span></strong><span>。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span>AI 框架安裝助手採用前後端分離架構：前端負責檢測系統硬件，自動推薦安裝方式，提供安裝選擇，獲取安裝選項，顯示安裝信息及進度；後端執行具體任務並向前端及時反饋信息。該架構提高了開發效率、可維護性和可擴展性，同時也提供了更好的用戶體驗。</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><strong><span>openKylin AI 框架安裝助手具有以下特點：</span></strong></p><ol><li><span style="color:#0052ff"><strong>智能推薦</strong></span>，用戶只需選擇需要安裝的 AI 框架，應用根據系統硬件智能推薦最佳安裝方式，同時支持用戶選擇。</li><li><span style="color:#0052ff"><strong>一鍵自動</strong></span>，軟件自動安裝最適合的硬件驅動，加速工具，依賴軟件，並且配置好系統環境。免去了繁複的安裝過程和系統環境配置。</li><li><span style="color:#0052ff"><strong>無需值守</strong></span>，由於網絡等原因造成的安裝失敗，能自動恢復繼續安裝。</li><li><span style="color:#0052ff"><strong>過程可見</strong></span><span>，軟件顯示安裝的各個步驟，以及各個步驟的進度等信息。</span></li><li><span style="color:#0052ff"><strong>節省資源</strong></span><span>，支持資源斷點繼續下載，過程斷點繼續安裝。</span></li><li><span style="color:#0052ff"><strong><span>支持</span>熱更新</strong></span><span>，確保能及時更新 AI 框架版本以及安裝方式，同時能以最快的速度解決軟件可能存在的 BUG。</span></li><li><span style="color:#0052ff"><strong>界面友好</strong></span><span>，採用簡潔、直觀的 AI 框架選項，並提供良好的安裝過程反饋。</span></li></ol><p style="text-align:center"><img alt="" height="1800" src="https://oscimg.oschina.net/oscnet/up-e6dc32eede425550f426b66a8c26400aaee.png" width="2880" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>目前，openKylin AI 框架安裝助手已上架至軟件商店。後續，AI4OS SIG 也將持續開發，優化 openKylin AI 框架安裝助手交互界面、支持更多主流 AI 框架及其套件等等，緊跟人工智能技術發展的潮流，更好地助力 AI 開發者！</span></p><p><span>AI4OS SIG 致力於為 openKylin 社區適配主流的 AI 框架，同時將人工智能（AI）與操作系統（OS）相結合，以實現 openKylin 操作系統的智能化和性能優化，歡迎感興趣的小夥伴加入！</span></p><ul><li><p style="margin-left:0; margin-right:0; text-align:justify"><span>項目地址：</span></p><p style="margin-left:0; margin-right:0; text-align:justify"><span style="color:#0052ff">https://gitee.com/openkylin/ai-frame-installer</span></p></li><li><p><span>AI4OS SIG 主頁：</span></p><p><span style="color:#0052ff">https://gitee.com/openkylin/community/tree/master/sig/AI4OS</span></p></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:19:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268789</guid>
            <link>https://www.oschina.net/news/268789</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[OpenAI 正式宣佈 Sam Altman 迴歸擔任 CEO]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>OpenAI 今天<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Fblog%2Fsam-altman-returns-as-ceo-openai-has-a-new-initial-board">正式宣佈</a></u>，Sam Altman 迴歸 OpenAI 擔任 CEO 一職。與此同時，Mira Murati 仍將繼續擔任 CTO 一職，Greg Brockman 也將繼續擔任 OpenAI 總裁。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-a1347c1ff57c70bc945b594b050d3a5203b.png" referrerpolicy="no-referrer"></p><p>此外，OpenAI 成立全新董事會，董事會主席由 Bret Taylor 擔任。其他的董事會成員還包括 Larry Summers 以及 Adam D'Angelo。</p><p>Ilya Sutskever 、Tasha McCauley 以及 Helen Toner 將退出董事會。不過 Sam Altman 表示，<strong>正在討論如何讓 Ilya Sutskever 繼續在 OpenAI 工作</strong>。</p><p>OpenAI 還讓微軟以「<strong>無投票權觀察員</strong>」的身份加入董事會，他們將有更多機會瞭解公司的內部運作，但在重大決策中沒有正式投票權。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:17:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268788/altman-returns-as-ceo-openai-has-a-new-initial-board</guid>
            <link>https://www.oschina.net/news/268788/altman-returns-as-ceo-openai-has-a-new-initial-board</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[MobSlide —— 將智能手機變成演示文稿遙控器]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>MobSlide 是一個可將你的將智能手機變成演示文稿遙控器的工具。</p><p><img alt="" height="225" src="https://static.oschina.net/uploads/space/2023/1122/142007_UPpG_4252687.png" width="300" referrerpolicy="no-referrer">&nbsp;<img alt="" height="225" src="https://static.oschina.net/uploads/space/2023/1122/142018_XS3R_4252687.png" width="300" referrerpolicy="no-referrer"></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>適用於 MacOS 和 Windows。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>Tauri for Linux 不支持 webrtc，因此目前不支持 Linux</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>用法</strong></p><p><span style="background-color:#ffffff; color:#1f2328">使用智能手機掃描二維碼並打開鏈接。</span></p><p><img alt="" height="225" src="https://static.oschina.net/uploads/space/2023/1122/141937_4l9Z_4252687.png" width="300" referrerpolicy="no-referrer"></p><p><strong>特性：</strong></p><ul><li>掃描二維碼。無需安裝</li><li>輕量級應用程序<code>~2.5M</code></li><li>簡約而有效的設計</li></ul></div>
                                                                ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:16:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/mobslide</guid>
            <link>https://www.oschina.net/p/mobslide</link>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 內存型消息中間件 FolkMQ]]>
            </title>
            <description>
                <![CDATA[<h1 align="center"><a id="user-content---folkmq" class="anchor" href="https://gitee.com/noear/folkmq#--folkmq"></a>
  FolkMQ
</h1><p align="center"><strong>一個內存型消息中間件（支持快照持久化、Broker 集羣），目前為預覽階段</strong></p><p align="center"><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fsearch.maven.org%2Fartifact%2Forg.noear%2Ffolkmq"><img src="https://img.shields.io/maven-central/v/org.noear/folkmq.svg?label=Maven%20Central" alt="Maven" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.apache.org%2Flicenses%2FLICENSE-2.0.txt"><img src="https://img.shields.io/:license-Apache2-blue.svg" alt="Apache 2" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjavase-jdk8-downloads.html"><img src="https://img.shields.io/badge/JDK-8-green.svg" alt="jdk-8" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk11-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-11-green.svg" alt="jdk-11" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk17-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-17-green.svg" alt="jdk-17" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2Fjdk21-archive-downloads.html"><img src="https://img.shields.io/badge/JDK-21-green.svg" alt="jdk-21" referrerpolicy="no-referrer"></a><br><a target="_blank" href="https://gitee.com/noear/folkmq/stargazers"><img src="https://gitee.com/noear/folkmq/badge/star.svg" alt="gitee star" referrerpolicy="no-referrer"></a><a target="_blank" href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fnoear%2Ffolkmq%2Fstargazers"><img src="https://img.shields.io/github/stars/noear/folkmq.svg?logo=github" alt="github star" referrerpolicy="no-referrer"></a></p><br><p align="center"><a href="https://gitee.com/link?target=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3DkjB5JNiC"><img src="https://img.shields.io/badge/QQ%E4%BA%A4%E6%B5%81%E7%BE%A4-870505482-orange" referrerpolicy="no-referrer"></a></p><hr><h2><a id="user-content-簡介" class="anchor" href="https://gitee.com/noear/folkmq#%E7%AE%80%E4%BB%8B"></a>簡介</h2><ul><li>採用，類似 Redis 的策略（內存運行 + 快照持久化）</li><li>功能，訂閲、取消訂閲、發佈消息、發佈定時消息、ACK，自動重試、延時策略、Qos0、Qos1</li><li>集羣，採用 Socket.D Broker 集羣模式</li><li>支持，使用 ws,udp 通訊（或許，也可用於物聯網）</li></ul><h2><a id="user-content-特點" class="anchor" href="https://gitee.com/noear/folkmq#%E7%89%B9%E7%82%B9"></a>特點</h2><ul><li>快、是真的快（大約 100_000 TPS）。有點像 Redis 之於 MySql。</li></ul><img src="https://gitee.com/noear/folkmq/raw/main/DEV-TEST.png" width="600" referrerpolicy="no-referrer"><p>//使用 MacBook pro 2020 + JDK8 本機測試，單客戶端發與收（跑分難免有波動，我是選了好看點的）</p><ul><li>簡單的管理後台</li></ul><img src="https://gitee.com/noear/folkmq/raw/main/DEV-PREVIEW.png" width="600" referrerpolicy="no-referrer"><h3><a id="user-content-加入到社區交流羣" class="anchor" href="https://gitee.com/noear/folkmq#%E5%8A%A0%E5%85%A5%E5%88%B0%E7%A4%BE%E5%8C%BA%E4%BA%A4%E6%B5%81%E7%BE%A4"></a>加入到社區交流羣</h3><table><thead><tr><th>QQ 交流羣：316697724</th><th>微信交流羣（申請時輸入：FolkMQ）</th></tr></thead><tbody><tr><td></td><td><img src="https://gitee.com/noear/folkmq/raw/main/group_wx.png" width="120" referrerpolicy="no-referrer"></td></tr></tbody></table><h2><a id="user-content-開發過程視頻記錄" class="anchor" href="https://gitee.com/noear/folkmq#%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%A7%86%E9%A2%91%E8%AE%B0%E5%BD%95"></a>開發過程視頻記錄</h2><ul><li>開發過程視頻：<a href="https://gitee.com/noear/folkmq/blob/main/DEV-RECORD.md">《DEV-RECORD.md》</a></li><li>成果展示：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1mc411D7pY%2F">《[FolkMQ] 一個新的內存型消息隊列（快，特別的快）》</a></li><li>快速入門：<a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1Yj411L7fB%2F">《FolkMQ - Helloworld 入門》</a></li></ul><h2><a id="user-content-服務端容器鏡像" class="anchor" href="https://gitee.com/noear/folkmq#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F"></a>服務端容器鏡像</h2><table><thead><tr><th>鏡像</th><th>説明</th></tr></thead><tbody><tr><td>noearorg/folkmq-server:1.0.10</td><td>服務端（主端口：8602，消息端口：18602）</td></tr><tr><td>noearorg/folkmq-broker:1.0.10</td><td>服務端（主端口：8602，消息端口：18602）</td></tr></tbody></table><p>當使用 broker 集羣時，把 folkmq-server 端口改成：8601</p><ul><li>可選配置</li></ul><table><thead><tr><th>屬性或環境變量</th><th>默認值</th><th></th></tr></thead><tbody><tr><td><code>server.port</code></td><td>8602</td><td>主端口 (http，管理用)</td></tr><tr><td></td><td>18602</td><td>消息端口 (tcp)，等於主端口+10000</td></tr><tr><td><code>folkmq.admin</code></td><td>admin</td><td>管理密碼</td></tr></tbody></table><ul><li>添加消息訪問賬號：</li></ul><p>添屬性或環境變量，例： <code>folkmq.access.ak1=sk1</code>，<code>folkmq.access.ak2=sk2</code></p><h2><a id="user-content-helloworld" class="anchor" href="https://gitee.com/noear/folkmq#helloworld"></a>Helloworld</h2><h3><a id="user-content-1 啓動服務-更多部署參考部署説明" class="anchor" href="https://gitee.com/noear/folkmq#1%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1-%E6%9B%B4%E5%A4%9A%E9%83%A8%E7%BD%B2%E5%8F%82%E8%80%83%E9%83%A8%E7%BD%B2%E8%AF%B4%E6%98%8E"></a>1、啓動服務 (更多部署參考：<a href="https://gitee.com/noear/folkmq/blob/main/deploy">部署説明</a>)</h3><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line">docker run -p 18602:18602 -p 8602:8602 noearorg/folkmq-server:1.0.10 </span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h3><a id="user-content-2 編寫客戶端代碼" class="anchor" href="https://gitee.com/noear/folkmq#2%E7%BC%96%E5%86%99%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"></a>2、編寫客戶端代碼</h3><ul><li>maven import</li></ul><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="nt">&lt;dependencies&gt;</span></span><span id="LC2" class="line"><span class="c">&lt;!-- 可選包：java-tcp（90kb 左右）, smartsocket（260Kb 左右）, netty（2.5Mb 左右） --&gt;</span></span><span id="LC3" class="line"><span class="nt">&lt;dependency&gt;</span></span><span id="LC4" class="line"><span class="nt">&lt;groupId&gt;</span>org.noear<span class="nt">&lt;/groupId&gt;</span></span><span id="LC5" class="line"><span class="nt">&lt;artifactId&gt;</span>folkmq-transport-java-tcp<span class="nt">&lt;/artifactId&gt;</span></span><span id="LC6" class="line"><span class="nt">&lt;version&gt;</span>1.0.10<span class="nt">&lt;/version&gt;</span></span><span id="LC7" class="line"><span class="nt">&lt;/dependency&gt;</span></span><span id="LC8" class="line"><span class="nt">&lt;/dependencies&gt;</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><ul><li>client(consumer + producer) use</li></ul><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="kd">public</span><span class="kd">class</span><span class="nc">ClientDemo1</span><span class="o">{</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kd">static</span><span class="kt">void</span><span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span><span class="n">args</span><span class="o">)</span><span class="kd">throws</span><span class="nc">Exception</span><span class="o">{</span></span><span id="LC3" class="line"><span class="c1">//客戶端（鑑權為可選。服務端，不添加則不鑑權）</span></span><span id="LC4" class="line"><span class="nc">MqClient</span><span class="n">client</span><span class="o">=</span><span class="nc">FolkMQ</span><span class="o">.</span><span class="na">createClient</span><span class="o">(</span><span class="s">"folkmq://127.0.0.1:18602?ak=folkmq&amp;sk=YapLHTx19RlsEE16"</span><span class="o">)</span></span><span id="LC5" class="line"><span class="o">.</span><span class="na">connect</span><span class="o">();</span></span><span id="LC6" class="line"></span><span id="LC7" class="line"><span class="c1">//訂閲（consumer = ip or cluster name）</span></span><span id="LC8" class="line"><span class="n">client</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="s">"demo"</span><span class="o">,</span><span class="s">"demoapp"</span><span class="o">,</span><span class="n">message</span><span class="o">-&gt;</span><span class="o">{</span></span><span id="LC9" class="line"><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">);</span></span><span id="LC10" class="line"><span class="o">});</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">//發佈</span></span><span id="LC13" class="line"><span class="n">client</span><span class="o">.</span><span class="na">publish</span><span class="o">(</span><span class="s">"demo"</span><span class="o">,</span><span class="s">"helloworld!"</span><span class="o">).</span><span class="na">get</span><span class="o">();</span></span><span id="LC14" class="line"><span class="o">}</span></span><span id="LC15" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div><h2><a id="user-content-自動重試與延時策略" class="anchor" href="https://gitee.com/noear/folkmq#%E8%87%AA%E5%8A%A8%E9%87%8D%E8%AF%95%E4%B8%8E%E5%BB%B6%E6%97%B6%E7%AD%96%E7%95%A5"></a>自動重試與延時策略</h2><table><thead><tr><th>派發次數</th><th>自動延時</th><th></th></tr></thead><tbody><tr><td>0</td><td>0s</td><td>相當於馬上發</td></tr><tr><td>1</td><td>5s</td><td></td></tr><tr><td>2</td><td>30s</td><td></td></tr><tr><td>3</td><td>3m</td><td></td></tr><tr><td>4</td><td>9m</td><td></td></tr><tr><td>5</td><td>15m</td><td></td></tr><tr><td>6</td><td>30m</td><td></td></tr><tr><td>7</td><td>1h</td><td></td></tr><tr><td>n..</td><td>2h</td><td>第 8 次之後都是 2 小時</td></tr></tbody></table><h2><a id="user-content-客戶端接口字典" class="anchor" href="https://gitee.com/noear/folkmq#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%8F%A3%E5%AD%97%E5%85%B8"></a>客戶端接口字典</h2><div class="white"><div class="highlight markdown-code-block"><pre><span id="LC1" class="line"><span class="c1">//消息客戶端接口</span></span><span id="LC2" class="line"><span class="kd">public</span><span class="kd">interface</span><span class="nc">MqClient</span><span class="o">{</span></span><span id="LC3" class="line"><span class="c1">//連接</span></span><span id="LC4" class="line"><span class="nc">MqClient</span><span class="nf">connect</span><span class="o">()</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC5" class="line"></span><span id="LC6" class="line"><span class="c1">//斷開連接</span></span><span id="LC7" class="line"><span class="kt">void</span><span class="nf">disconnect</span><span class="o">()</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC8" class="line"></span><span id="LC9" class="line"><span class="c1">//客戶端配置</span></span><span id="LC10" class="line"><span class="nc">MqClient</span><span class="nf">config</span><span class="o">(</span><span class="nc">ClientConfigHandler</span><span class="n">configHandler</span><span class="o">);</span></span><span id="LC11" class="line"></span><span id="LC12" class="line"><span class="c1">//自動回執</span></span><span id="LC13" class="line"><span class="nc">MqClient</span><span class="nf">autoAcknowledge</span><span class="o">(</span><span class="kt">boolean</span><span class="n">auto</span><span class="o">);</span></span><span id="LC14" class="line"></span><span id="LC15" class="line"><span class="c1">//訂閲主題</span></span><span id="LC16" class="line"><span class="kt">void</span><span class="nf">subscribe</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">consumer</span><span class="o">,</span><span class="nc">MqConsumeHandler</span><span class="n">consumerHandler</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC17" class="line"></span><span id="LC18" class="line"><span class="c1">//取消訂閲主題</span></span><span id="LC19" class="line"><span class="kt">void</span><span class="nf">unsubscribe</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">consumer</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC20" class="line"></span><span id="LC21" class="line"><span class="c1">//發佈消息</span></span><span id="LC22" class="line"><span class="k">default</span><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">{</span></span><span id="LC23" class="line"><span class="k">return</span><span class="nf">publish</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span><span class="n">content</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span></span><span id="LC24" class="line"><span class="o">}</span></span><span id="LC25" class="line"></span><span id="LC26" class="line"><span class="c1">//發佈消息</span></span><span id="LC27" class="line"><span class="k">default</span><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">,</span><span class="kt">int</span><span class="n">qos</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">{</span></span><span id="LC28" class="line"><span class="k">return</span><span class="nf">publish</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span><span class="n">content</span><span class="o">,</span><span class="kc">null</span><span class="o">,</span><span class="n">qos</span><span class="o">);</span></span><span id="LC29" class="line"><span class="o">}</span></span><span id="LC30" class="line"></span><span id="LC31" class="line"><span class="c1">//發佈消息</span></span><span id="LC32" class="line"><span class="k">default</span><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">,</span><span class="nc">Date</span><span class="n">scheduled</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">{</span></span><span id="LC33" class="line"><span class="k">return</span><span class="nf">publish</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span><span class="n">content</span><span class="o">,</span><span class="n">scheduled</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span></span><span id="LC34" class="line"><span class="o">}</span></span><span id="LC35" class="line"></span><span id="LC36" class="line"><span class="c1">//發佈消息</span></span><span id="LC37" class="line"><span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span><span class="n">publish</span><span class="o">(</span><span class="nc">String</span><span class="n">topic</span><span class="o">,</span><span class="nc">String</span><span class="n">content</span><span class="o">,</span><span class="nc">Date</span><span class="n">scheduled</span><span class="o">,</span><span class="kt">int</span><span class="n">qos</span><span class="o">)</span><span class="kd">throws</span><span class="nc">IOException</span><span class="o">;</span></span><span id="LC38" class="line"><span class="o">}</span></span></pre><div class="markdown-code-block-copy-btn"></div></div></div>]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/noear/folkmq</guid>
            <link>https://gitee.com/noear/folkmq</link>
        </item>
        <item>
            <title>
                <![CDATA[關於 deepin V23 的發熱、續航問題，我們做了電源配置優化]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>之前一些用戶反饋，在使用 deepin （深度）操作系統過程中遇到了 CPU 功耗過高導致的設備發熱、續航較差情況，而在這些負載場景下，CPU 的佔用往往不高。為瞭解決這個痛點，deepin 團隊特別成立專項計劃，對於 deepin 的電源進行專項優化。</p><p>在對電源進行專項優化之前，首先對 deepin （深度）操作系統進行了深入調查和分析，以瞭解其在負載場景下的實際運行情況。</p><p>經過對 CPU 使用率和功耗的監測，我們發現了一個令人驚訝的事實：儘管在高負載場景下 CPU 的佔用率不高，但其功耗卻持續升高，最終導致設備發熱並影響續航。也就是説，我們前期做的省電優化工作，不僅無效，還起了反作用。那麼到底該如何解決這一問題呢？</p><p>在剛剛結束的 DDUC 2023 上，deepin（深度）社區用戶 fslong 從社區參與共創的角度，分享了幫助 deepin 團隊一起完成優化工作的故事。那麼，本文就讓我們從 deepin 團隊研發工程師的角度來回顧解決這一問題的歷程吧！</p><h2><strong>&nbsp;找到問題的根源&nbsp;</strong></h2><p><strong>1.內核</strong><br> 最開始發現問題的地方在內核。有用戶將 deepin 的內核和 Ubuntu 的內核進行對比後發現，雖然二者性能相差無幾，但是在發熱和續航上，較 Ubuntu 落後較多。有用戶在 deepin （深度）操作系統上使用 Ubuntu 和其他開源 Linux 發行版的配置文件分別編譯內核，發現 deepin 的主要問題在於發熱控制上。deepin 團隊的測試夥伴高度重視這一社區反饋，對該問題進行復現，佐證了這一現象。</p><p>於是，我們立即聯繫了內核研發的夥伴，並邀請部分對內核配置有一定研究的社區用戶共同參與，合力排查後發現，deepin V23 中提供的 HWE 內核存在部分 debug 和無用的內核選項被開啓的情況，並且部分節電功能實際未能獲得啓用，這些都在一定程度上導致了 deepin V23 的續航表現不佳。</p><p><strong>2. 系統</strong><br> 系統層面，重新審視了 dde-daemon 提供的電源調度模塊，並且對比內核文檔提供的文件接口，分析用戶使用的電源模式，發現其中存在可以優化的空間。這是本文着重講解的內容之一。</p><h2><strong>一些前置知識&nbsp;</strong></h2><h3><strong>1.ACPI</strong></h3><p>ACPI（Advanced Configuration and Power Interface）是一種計算機硬件和操作系統之間交換能源相關信息的接口規範。它定義了計算機硬件的能源相關信息，如電源供應器狀態、設備功耗、設備功率因數等。ACPI 是操作系統控制計算機硬件能源管理的標準，同時也是硬件廠商和操作系統之間通信的標準。<br> 在 deepin （深度）操作系統中，ACPI 負責處理計算機硬件的能源管理，與電源管理模塊進行交互，以實現對計算機硬件的能源管理。</p><p>在分析系統層面的問題時，需要了解 ACPI 和電源管理模塊的作用和功能，以及它們是如何協同工作的。本文將會詳細講解 ACPI 的工作原理以及 deepin （深度）操作系統中的電源調度模塊工作模式，並提出可行優化建議。</p><p>ACPI 的工作原理是：當計算機硬件發生電源變化時，ACPI 會收集硬件信息，並向操作系統發送電源請求。操作系統收到電源請求後，會根據用戶配置自動調整各個硬件的電源策略。</p><p>deepin （深度）操作系統的電源模塊則是幫助用戶生成配置來調整 ACPI 的行為。所以在這一方面，我們能做的就是向 ACPI 提供合理的電源策略，在保證性能的同時，降低設備溫度並提升續航表現。</p><h3><strong>2.平台電源配置</strong></h3><p>相關內核文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.kernel.org%2Fuserspace-api%2Fsysfs-platform_profile.html" target="_blank">https://docs.kernel.org/userspace-api/sysfs-platform_profile.html</a></p><p>UEFI ACPI 文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fuefi.org%2Fhtmlspecs%2FACPI_Spec_6_4_html%2Findex.html" target="_blank">https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/index.html</a></p><p>平台電源配置是電源管理模塊的重要組成部分，用於管理計算機平台硬件（指所有支持 ACPI 的設備）的電源狀態。CPU 也屬於 ACPI 設備的一部分，不過 CPU 是計算機的核心發熱大戶，對於其使用平台電源管理可能粒度較粗，所以 APCI 引入了一些 CPU 獨有的性能管理方式，在下一小節將詳細説明。</p><p>平台電源配置提供了三種可選模式：performance（性能模式），balance（平衡模式），low-power（節能模式）。一般情況下，用戶使用平衡模式就可以。在台式機和 mini 主機類（對於功耗和發熱沒有任何要求）設備上默認提供性能模式，在筆記本等移動設備上默認提供平衡模式。默認不提供節能模式，因為某些 ACPI 設備在節能模式工作過程中可能出現「睡死現象」，所以為了避免此問題，默認不提供 low-power 節電模式。</p><h3><strong>3.CPU 電源配置</strong></h3><p>傳統電源模式（SCalling）內核文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.kernel.org%2Fdoc%2Fhtml%2Fv6.1%2Fadmin-guide%2Fpm%2Fcpufreq.html" target="_blank">https://www.kernel.org/doc/html/v6.1/admin-guide/pm/cpufreq.html</a></p><p>Intel PState 內核文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.kernel.org%2Fdoc%2Fhtml%2Fv6.1%2Fadmin-guide%2Fpm%2Fintel_pstate.html" target="_blank">https://www.kernel.org/doc/html/v6.1/admin-guide/pm/intel_pstate.html</a></p><p>AMD PState 內核文檔：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.kernel.org%2Fadmin-guide%2Fpm%2Famd-pstate.html" target="_blank">https://docs.kernel.org/admin-guide/pm/amd-pstate.html</a></p><p>如果有時間，可以自行研讀上述電源文檔，就很容易理解 CPU 電源配置相關內容。作者在這裏的講述將忽略大量技術細節和實現方式，僅表述如何調整 CPU 的電源模式。</p><p>在 /sys/devices/system/cpu/cpufreq 目錄下有許多文件名為 policy&lt;x&gt;（x 代表核心編號），這些文件對應着電腦上的 CPU 核心，而 CPU 的電源調度細節就在這些文件夾裏。在 policy&lt;x&gt; 目錄下有一個文件`scaling_driver`，使用 cat 或其他方式訪問它，得到的結果就是當前使用的調度器：</p><ul><li>intel_cpufreq / acpi_cpufreq : 使用 scaling freq 調度；</li><li>intel_pastate : 使用 Intel PState 調度；</li><li>amd-pstate : 使用 AMD PState 調度。</li></ul><p><strong>&nbsp;scalling freq 調度</strong></p><p>這是最傳統的 CPU 調度方式，可以在 policy 文件夾下的 scaling_available_governors 獲取可選電源模式：</p><p style="text-align:center"><img height="742" src="https://oscimg.oschina.net/oscnet/up-30d23181f6f0f60ab32af9f63d163238aa5.png" width="765" referrerpolicy="no-referrer"></p><p>其實這些平衡模式的作用都是是一樣的：平衡性能和續航，不過使用的算法可能不同。</p><p><strong>Intel PState</strong></p><p>這是 Intel 近幾代 CPU 獨享的 moment，內核開啓 Intel PState 後（deepin V23 內核默認開啓），在 policy 文件夾下多了幾個文件：</p><p>我們只需要關注：</p><ul><li>energy_performance_available_perference : 可用的 PState 電源調度；</li><li>energy_performance_perference：當前選定的 PState 電源調度，可以更改此文件內容來更改電源調度。</li></ul><p>在 Intel PState 中出現了兩個新的調度方案：</p><ul><li>balance_performance : 平衡偏性能，平時工作頻率不高，在負載增大時能快速響應；</li><li>balance_power : 平衡偏節能，電源策略較為保守，在部分電腦上還有 default 方案，此方案就是經過 PState 優化過的 balance 策略。具體 PState 使用的黑魔法以及主動模式和被動模式的調度策略，可以參照內核文檔進行分析。</li></ul><p><strong>AMD PState</strong></p><p>這是 AMD ZEN2 以上用戶，以及支持 kernel 6.4.x 用戶獨享的 moment。其實 AMD 在 6.1 內核已經做了 PState 的支持，不過是被動模式。</p><ul><li>（Actvie Mode）主動模式</li></ul><p>Active Mode 僅在內核版本大於 6.4 以上，且內核選項打開 AMD PState 時可用。可能需要在 grub 內加入啓動參數以打開此功能：amd_pstate=active，也可以修改文件實現 Active Mode 的電源策略和 Intel PStatewi 類似。</p><ul><li>（Passive Mode）被動模式</li></ul><p>Passtive Mode 僅在內核大於 6.1 以上，且內核選項打開 AMD PState 時可用。可能需要在 grub 加入啓動參數開啓此功能：amd_pstate=passive，也可修改文件實現。</p><p>Passive Mode 提供兩種電源模式，在/sys/device/system/cpu/cpufreq/scaling_governor 文件進行調整：</p><p>（1）performance 使用 platform_profile 進行配置，調度積極性較高；<br> （2）scheutils 在/sys/device/system/cpu/cpufreq/schedutil/rate_limit_us 文件中調整調度粒度（兩次調度的間隔時間）和 ACPI 的 scheutils 類 &nbsp;/sys/device/system/cpu/cpufreq/scaling_governor 。</p><ul><li>（Guided Mode）引導模式</li></ul><p>Guided Mode 僅在內核大於 6.1 以上，且內核選項打開 AMD PState 時可用。可能需要在 grub 加入啓動參數開啓此功能：amd_pstate=guided，也可修改文件實現。這就類似汽車的自動擋，驅動程序請求最低和最大性能級別，平台自動選擇此範圍內適合當前工作負荷的性能級別。</p><h3><strong>4.GPU 電源管理部分</strong></h3><p><strong>&nbsp;AMD GPU</strong></p><p>如果是 AMD GPU 則需要更改兩個文件（使用 tee 命令進行寫入）：</p><ul><li>/sys/class/drm/card0/device/power_dpm_state（這是一個遺留接口，目的是向後兼容）；</li><li>performance 高性能模式；</li><li>balance 平衡模式；</li><li>battery 節能模式；</li><li>/sys/class/drm/card0/device/power_dpm_force_performance_level 。</li></ul><p>以下設置來自 AMD 官方驅動文檔：</p><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdri.freedesktop.org%2Fdocs%2Fdrm%2Fgpu%2Famdgpu.html%23power-dpm-force-performance-level" target="_blank">https://dri.freedesktop.org/docs/drm/gpu/amdgpu.html#power-dpm-force-performance-level</a></p><pre><code>power_dpm_force_performance_level:</code></pre><p>AMD GPU 驅動程序提供了一個 sysfs API，用於調整某些與功率相關的參數。文件 power-dpm-force-performance-level 將用於執行此操作。它接受以下參數：</p><ul><li>auto：當選擇 auto 時，設備將嘗試針對驅動中的當前條件動態選擇最佳功率曲線；</li><li>low：當選擇低時，GPU 被強制到最低功率狀態；</li><li>high：當選擇高時，GPU 被強制到最高功率狀態；</li><li>manual：當選擇手動時，用戶可以通過 sysfs pp_dpm_mclk、pp_dpm_sclk 和 pp_dpm_pcie 文件手動調整每個時鐘域啓用的電源狀態，並通過 pp_power_profile_mode sysfs 文件調整電源狀態轉換方式；</li><li>profile_standard 固定時鐘級別分析模式。此模式將時鐘設置為固定級別，該級別因 ASIC 而異。這對於分析特定工作負載很有用（不常用）；</li><li>profile_min_sclk 最小 SCLK 分析模式。此模式將 SCLK 強制設置為最低級別。這對於分析最小功耗的場景很有用（不常用）；</li><li>profile_min_mclk 最小 MCLK 分析模式。此模式將 MCLK 強制設置為最低級別。這對於分析最小功耗的場景很有用（不常用）；</li><li>profile_peak 峯值分析模式。此模式將所有時鐘（MCLK、SCLK、PCIe）設置為最高級別。這對於分析最大性能的場景很有用（不常用）。</li></ul><p><strong>測試：</strong></p><ul><li>Low 模式的跑分</li></ul><p style="text-align:center"><img height="527" src="https://oscimg.oschina.net/oscnet/up-a7c7db000560426ab1a9b7c748e27c0a1b7.png" width="905" referrerpolicy="no-referrer"></p><ul><li>Auto 模式的跑分</li></ul><p style="text-align:center"><img height="368" src="https://oscimg.oschina.net/oscnet/up-5bb4cd6ed50bbcdc27d0be3b221b6393b32.png" width="715" referrerpolicy="no-referrer"></p><ul><li><p>High 模式的跑分</p></li></ul><p><img height="482" src="https://oscimg.oschina.net/oscnet/up-34be1d83b01eab80986cba3af73de7fbe2d.png" width="885" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><strong>Intel GPU</strong></p><p>Intel GPU 使用的 i915 驅動，並不希望你對其做出調整，因為其驅動自帶的電源策略已經足夠聰明。不過你也可以通過 Intel 提供的 intel-gpu-tools 進行調整和獲取信息。</p><pre><code>sudo apt install intel-gpu-tools &nbsp; </code></pre><p>然後使用</p><pre><code>sudo intel_gpu_frequency</code></pre><p>來獲取當前頻率（當前使用的是 Intel A750）。</p><p style="text-align:center"><img height="133" src="https://oscimg.oschina.net/oscnet/up-8f915468117bd14d8fe8cefa8f8035b08d6.png" width="594" referrerpolicy="no-referrer"></p><p>可以看到 Intel 的顯卡驅動是在 600 MHz 到 2400 MHz 之間動態調整（如上圖）。</p><p>測試筆記本下 Intel 核顯跑分如下：</p><p style="text-align:center"><img height="490" src="https://oscimg.oschina.net/oscnet/up-97908337d81f9e30651c110d9dddbf88129.png" width="732" referrerpolicy="no-referrer"></p><p><strong>NVIDIA</strong></p><p>由於 NVIDIA 驅動不開源，所以在系統層面無法對其做控制。</p><h2><strong>應用級別的省電&nbsp;</strong></h2><p>應用級別的省電，應該就是在保證用戶使用流暢度的情前提下節省性能。之前也有用戶提出過，是否能參照某手機廠商的不公平調度算法來實現優化，畢竟安卓系統的底層也是 Linux，理論上實現難度不大。</p><p>Cgroups，全稱 Control Groups，是 Linux 內核提供的一種資源管理機制，用於對進程分組並對其資源進行限制和隔離。Cgroups 可以用於限制進程的 CPU、內存、磁盤、網絡等資源，也可以用於限制進程的優先級和 IO 權限。利用其提供的能力，很容易實現類似不公平調度算法（新的 AM 天然支持 Cgroups 的操作），但是還有一些顧慮：</p><ul><li>不同於手機操作系統，計算機操作系統是多任務並行的，在多數窗口管理器下，我們並沒有一個明顯的前台應用，此時使用不公平調度可能存在隱患；</li><li>容易引發人機對抗。在我的觀念裏面，計算機是為人服務的，那麼用戶的意志必定是第一優先級，所以我們不應改變用戶的行為，如果使用不平衡調度和用戶預期不一致，會極大降低用戶體驗；</li><li>使用前後台區分應用，可能導致開銷和收益比下降，性價比不高。Linux 桌面不像安卓設備有明顯前後台，用戶頻繁切換應用的操作將導致調度器頻繁切換調度，使得開銷過大。最佳的解決方案是：提供能力，但不提供方案。可以提供基於 Cgroups 方式修改應用組的優先級，然後讓用戶自己選擇什麼應用優先級更高，什麼應用優先級低，以實現調度（比如在 dock 上右鍵選擇優先級）或提供一套配置以供用戶自由選擇。</li></ul><p>如果一個電腦需要使用不平衡調度來保證使用流暢性，可能這並不是一個操作系統能解決的問題，而更應該考慮硬件是否需要更換，以保證多任務使用的流暢性。</p><h4><strong>附錄——常用的調試測試工具</strong></h4><p>1. S-tui</p><p>可以看到 CPU 頻率變化，配合 stress 可以對 CPU 進行壓力測試。</p><p style="text-align:center"><img height="553" src="https://oscimg.oschina.net/oscnet/up-9035dd7df12eda9d831c879f89d1e2f3230.png" width="1025" referrerpolicy="no-referrer"></p><p>2. intel-gpu-tools</p><p>可以使用 intel_gpu_frequency 來獲取和調整 i965 的驅動頻率。</p><p>3. GLMark2</p><p>GPU 跑分軟件。</p><p>4. stress-ng</p><p>CPU 壓力測試軟件。</p><p>5. PowerTOP</p><p>電源測試軟件，可以看到電源的功耗和使用情況。</p></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268783</guid>
            <link>https://www.oschina.net/news/268783</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | Promise 規範與原理解析]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><span><span>摘要</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>Promise 對象用於清晰的處理異步任務的完成，返回最終的結果值，本次分享主要介紹 Promise 的基本屬性以及 Promise 內部的基礎實現，能夠幫我們更明確使用場景、更快速定位問題。</span></span></span></p><span id="OSC_h1_2"></span><h1><span><span><span>Promise 出現的原因</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>首先我們先來看一段代碼：異步請求的層層嵌套</span></span></span></p><pre><code><span><span><span>function fn1(params) {
  const xmlHttp = new XMLHttpRequest();
  xmlHttp.onreadystatechange = function(){
    if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
      const fn1Data = {name: 'fn1'}
      console.log(fn1Data, 'fn1Data');
      // 請求 2
      (function fn2() {
        xmlHttp.onreadystatechange = function(){
        if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
          const fn2Data = {name: `${fn1Data.name}-fn2`}
          console.log(fn2Data, 'fn2Data');
          // 請求 3
          (function fn2() {
            xmlHttp.onreadystatechange = function(){
            if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
              const fn3Data = {name: `${fn2Data.name}-fn3`}
              console.log(fn3Data, 'fn3Data');
            }
          }
          xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
          xmlHttp.send();
          })()
        }
      }
      xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
      xmlHttp.send();
      })()
    }
  }
  xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
  xmlHttp.send();
}

fn1()

</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>或者我們可以將上面的代碼優化為下面這樣</span></span></span></p><pre><code><span><span><span>function fn1(params) {
  console.log(`我是 fn1，我在函數${params}中執行！！！`);
}
  
function fn2(params) {
  try {
    const xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function(){
      if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
        console.log(`我是 fn2，我在函數${params}中執行！！！結果是：`,params.data);
        fn1('fn2')
      }
    }
    xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
    xmlHttp.send();
  } catch (error) {
    console.error(error);
  }
}
  
function fn3() {
  try {
    const xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function(){
      if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
          console.log('fn3 請求已完成');
          fn2('fn3')
      }
    }
    xmlHttp.open("GET","https://v0.yiketianqi.com/api?unescape=1&amp;version=v61", true);
    xmlHttp.send();
    console.log('我是 f3 函數呀');
  } catch (error) {
    console.error(error);
  }
}
  
fn3()

</span></span></span></code></pre><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>由上面的兩種寫法的請求可見，在 promise 之前，為了進行多個異步請求並且依賴上一個異步請求的結果時，我們必須進行層層嵌套，大多數情況下，我們又對異步結果進行數據處理，這樣使得我們的代碼非常難看，並且難以維護，這就形成了回調地獄，由此 Promise 開始出現了。</span></span></span></p><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>回調地獄缺點</span></span></span></p><ul><li><span><span><span><span>代碼臃腫</span></span></span></span></li><li><span><span><span><span>可讀性差</span></span></span></span></li><li><span><span><span><span>耦合性高</span></span></span></span></li><li><span><span><span><span>不好進行異常處理</span></span></span></span></li></ul><span id="OSC_h1_3"></span><h1><span><span><span>Promise 的基本概念</span></span></span></h1><span id="OSC_h3_4"></span><h3><span><span><span>含義</span></span></span></h3><ol><li><span><span><span><span>ES6 將其寫進了語言標準裏統一了用法，是一個構造函數，用來生成 Promise 實例</span></span></span></span></li><li><span><span><span><span>參數為一個執行器函數 (執行器函數是立即執行的),該函數有兩個函數作為參數，第一個參數是成功時的回調,第二個參數是失敗時的回調</span></span></span></span></li><li><span><span><span><span>函數的方法有 resolve(可以處理成功和失敗)、reject(只處理失敗)、all 等方法</span></span></span></span></li><li><span><span><span><span>then、catch、finally 方法為 Promise 實例上的方法</span></span></span></span></li></ol><span id="OSC_h3_5"></span><h3><span><span><span>狀態</span></span></span></h3><ol><li><span><span><span><span>pending --- 等待狀態</span></span></span></span></li><li><span><span><span><span>Fulfilled --- 執行狀態 （resolve 回調函數，then）</span></span></span></span></li><li><span><span><span><span>Rejected --- 拒絕狀態 (reject 回調函數，catch)</span></span></span></span></li><li><span><span><span><span>狀態一旦改變就不會再變，狀態只可能是兩種改變，從 pending-&gt;Fulfilled，pending-&gt;Rejected</span></span></span></span></li><li><span><span><span><span>有兩個關鍵的屬性：PromiseState --- 狀態改變，PromiseResult --- 結果數據改變</span></span></span></span></li></ol><pre><code><span><span><span>const p1 = Promise.resolve(64)
const p2 = Promise.reject('我錯了')
const p3 = Promise.then()
const p4 = Promise.catch()

// 狀態改變 PromiseState 結果改變 PromiseResult
console.log(new Promise(()=&gt;{}), 'Promise');  // PromiseState='pending' PromiseResult=    
console.log(p1,'p1');  // PromiseState='Fulfilled' PromiseResult=64
console.log(p2,'p2');  // PromiseState="Rejected" PromiseResult='我錯了'
console.log(p3, 'p3'); // then 為實例上的方法，報錯
console.log(p4, 'p4');  // catch 為實例上的方法，報錯
</span></span></span></code></pre><div><img alt="" height="457" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-14-14-59d8dPWcg59hoiOwx59.png" width="705" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h3_6"></span><h3><span><span><span>特點</span></span></span></h3><div><span>1.</span><span><span><span><span>錯誤信息清晰定位：可以在外層捕獲異常信息（網絡錯誤、語法錯誤都可以捕獲），有「冒泡」性質，會一直向後傳遞，直到被捕獲，所以在最後寫一個 catch 就可以了</span></span></span></span></div><div><span>2.</span><span><span><span><span>鏈式調用：每一個 then 和 catch 都會返回一個新的 Promise，把結果傳遞到下一個 then/catch 中，因此可以進行鏈式調用 --- 代碼簡潔清晰</span></span></span></span></div><span id="OSC_h3_7"></span><h3><span><span><span>結果由什麼決定</span></span></span></h3><span id="OSC_h4_8"></span><h4><span><span><span>resolve</span></span></span></h4><ol><li><span><span><span><span>如果傳遞的參數是非 Promise 類型的對象，則返回的結果是成功狀態的 Promise 對象，進入下一個 then 裏面</span></span></span></span></li><li><span><span><span><span>如果傳遞的參數是 Promise 類型的對象，則返回的結果由返回的 Promise 決定，如果返回的是 resolve 則是成功的狀態，進入下一個 then 裏，如果返回的是 reject 則是失敗的狀態，進入下一個 catch 裏</span></span></span></span></li></ol><span id="OSC_h4_9"></span><h4><span><span><span>reject</span></span></span></h4><ol><li><span><span><span><span>如果傳遞的參數是非 Promise 類型的對象，則返回的結果是拒絕狀態的 Promise 對象，進入下一個 catch 裏面或者是下一個 then 的第二個參數 reject 回調裏面</span></span></span></span></li><li><span><span><span><span>如果傳遞的參數是 Promise 類型的對象，則返回的結果由返回的 Promise 決定，如果返回的是 resolve 則是成功的狀態，進入下一個 then 裏，如果返回的是 reject 則是拒絕的狀態，進入下一個 catch 裏面或者是下一個 then 的第二個參數 reject 回調裏面</span></span></span></span></li></ol><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>這在我們自己封裝的 API 裏面也有體現：為什麼 code 為 1 時都是 then 接收，其他都是 catch 接收，就是因為在 then 裏面也就是 resolve 函數中對 code 碼進行了判斷，如果是 1 則返回 Promise.resolve()，進入 then 裏處理，如果是非 1 則返回 Promise.reject()，進入 catch 裏處理。</span></span></span></p><span id="OSC_h3_10"></span><h3><span><span><span>流程圖</span></span></span></h3><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-14-14-59rKXgoFvRLU89IXE.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h3_11"></span><h3><span><span><span>簡單使用</span></span></span></h3><pre><code><span><span><span>// 模擬一個 promise 的 get 請求
let count = 0
function customGet(url){
    count += 1
    return new Promise((resolve, reject)=&gt;{
        const xmlHttp = new XMLHttpRequest();
        xmlHttp.open("GET",url, true);
        xmlHttp.onload = ()=&gt;{
          console.log(xmlHttp, 'xmlHttp---onload');
          if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
            console.log('customGet 請求成功了');
            // 返回非 Promise，結果為成功狀態
            resolve({data:`第${count}次請求獲取數據成功`})

            // 返回 Promise，結果由 Promise 決定
            // resolve(Promise.reject('resolve 中返回 reject'))
          } else {
            reject('customGet 請求錯誤了')
          }
        }

        // Promise 狀態改變就不會再變
        // onreadystatechange 方法會被執行四次
        // 當地次進來的時候，readyState 不等於 4，執行 else 邏輯，執行 reject，狀態變為 Rejected，所以即使再執行 if，狀態之後不會再改變
        // xmlHttp.onreadystatechange = function(){
        //   console.log(xmlHttp,'xmlHttp---onreadystatechange')
        //   if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
        //     console.log('customGet 請求成功了');
        //     resolve({data:`第${count}次請求獲取數據成功`})
        //   } else {
        //     reject('customGet 請求錯誤了')
        //   }
        // }
        xmlHttp.send();
      })
 }

// 使用 Promise，並且進行鏈式調用
customGet('https://v0.yiketianqi.com/api/cityall?appid=&amp;appsecret=').then((res)=&gt;{
   console.log(res.data);
   return '第一次請求處理後的數據'
}).then((data)=&gt;{
   console.log(data)
   // console.log(data.toFixed());
   return customGet('https://v0.yiketianqi.com/api/cityall?appid=&amp;appsecret=')
}).then((res)=&gt;{
   console.log(res.data);
}).catch((err)=&gt;{
    // 以類似'冒泡'的性質再外層捕獲所有的錯誤
   console.error(err, '這是 catch 裏的錯誤信息');
})

</span></span></span></code></pre><span id="OSC_h3_12"></span><h3><span><span><span>手寫實現簡單的 Promise</span></span></span></h3><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>通過上面的回顧，我們已經瞭解了 Promise 的關鍵屬性和特點，下面我們一起來實現一個簡單的 Promise 吧</span></span></span></p><pre><code><span><span><span>  // 1、封裝一個 Promise 構造函數，有一個函數參數
  function Promise(executor){
    // 7、添加對象屬性 PromiseState PromiseResult
    this.PromiseState = 'pending'
    this.PromiseResult = null

    // 14、創建一個保存成功失敗回調函數的屬性
    this.callback = null

    // 8、this 指向問題
    const that = this

    // 4、executor 有兩個函數參數（resolve，reject）
    function resolve(data){
      // 10、Promise 狀態只能修改一次（同時記得處理 reject 中的狀態）
      if(that.PromiseState !== 'pending') return

      // console.log(this, 'this');
      // 5、修改對象的狀態 PromiseState
      that.PromiseState = 'Fulfilled'

      // 6、修改對象的結果 PromiseResult
      that.PromiseResult = data

      // 15、異步執行 then 裏的回調函數
      if(that.callback?.onResolve){
        that.callback.onResolve(that.PromiseResult)
      }
    }
    function reject(data){
      console.log(that.PromiseState, 'that.PromiseState');
      if(that.PromiseState !== 'pending') return

      // 9、處理失敗函數狀態
      that.PromiseState = 'Rejected'
      that.PromiseResult = data
      console.log(that.PromiseResult, 'that.PromiseResult');
      console.log(that.PromiseState, 'that.PromiseState');

      // 16、異步執行 then 裏的回調函數
      if(that.callback?.onReject){
        that.callback.onReject(that.PromiseResult)
      }
    }
    // 3、執行器函數是同步調用的，並且有兩個函數參數
    executor(resolve,reject)
  }
  // 2、函數的實例上有方法 then
  Promise.prototype.then = function(onResolve,onReject){
    // 20、處理 onReject 沒有的情況
    if(typeof onReject !== 'function'){
      onReject = reason =&gt; {
        throw reason
      }
    }
    // 21、處理 onResolve 沒有的情況
    if(typeof onResolve !== 'function'){
      onResolve = value =&gt; value
    }
    // 17、每一個 then 方法都返回一個新的 Promise，並且把上一個 then 返回的結果傳遞出去
    return new Promise((nextResolve,nextReject)=&gt;{
      // 11、處理成功或失敗
      if(this.PromiseState === 'Fulfilled'){
        // 12、將結果傳遞給函數
        // onResolve(this.PromiseResult)

        // 18、拿到上一次執行完後返回的結果,判斷是不是 Promise
        const result = onResolve(this.PromiseResult)
        if(result instanceof Promise){
          result.then((v)=&gt;{
            nextResolve(v)
          },(r)=&gt;{
            nextReject(r)
          })
        } else {
          nextResolve(result)
        }
      }
      // 當你一步步寫下來的時候有沒有懷疑過為什麼不用 else
       if(this.PromiseState === 'Rejected'){
            // 第 12 步同時處理此邏輯
            // onReject(this.PromiseResult)

            // 22、處理 catch 異常穿透捕獲錯誤
            try {
              const result = onReject(this.PromiseResult)
              if(result instanceof Promise){
                result.then((v)=&gt;{
                  nextResolve(v)
                }).catch((r)=&gt;{
                  nextReject(r)
                })
              } else {
                nextReject(result)
              }
            } catch (error) {
              nextReject(this.PromiseResult)
            }
         }
  
      // 13、異步任務時處理成功或失敗,想辦法等異步任務執行完成後才去執行這兩個函數
      if(this.PromiseState === 'pending'){
        this.callback = {
          onResolve,
          onReject
        }
        console.log(this.callback, 'this.callback');
      }
    })
  }
  // 19、函數實例上有方法 catch
  Promise.prototype.catch = function(onReject) {
    return this.then(null,onReject)
  }

  // 使用自定義封裝的 Promise
  const customP = new Promise((resolve,reject)=&gt;{
    // 模擬異步執行請求
    // const xmlHttp = new XMLHttpRequest();
    // xmlHttp.open("GET",'https://v0.yiketianqi.com/api/cityall?appid=&amp;appsecret=', true);
    // xmlHttp.onload = ()=&gt;{
    //   if (xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status === 200) {
    //     resolve('success')
    //   } else {
    //     reject('error')
    //   }
    // }
    // xmlHttp.send();

    // 同步執行
    resolve('success')
    // reject('error')
  })

  console.log(customP, 'customP');
  customP.then((res)=&gt;{
    console.log(res, 'resolve 回調');
    return '第一次回調'
    // return new Promise((resolve,reject)=&gt;{
    //   reject('錯錯錯')
    // })
  },(err)=&gt;{
    console.error(err, 'reject 回調');
    return '2121'
  }).then(()=&gt;{
    console.log('then 裏面輸出');
  }).then().catch((err)=&gt;{
    console.error(err, 'catch 裏的錯誤');
  })

</span></span></span></code></pre><span id="OSC_h4_13"></span><h4><span><span><span>針對 resolve 中返回 Promise 對象時的內部執行順序</span></span></span></h4><div><img alt="" src="https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-11-14-15-00IiDMseqfyk0DroM.png" referrerpolicy="no-referrer"></div><p><span style="color:transparent"><span><span><span>﻿</span></span></span></span><span><span><span>﻿</span></span></span></p><span id="OSC_h1_14"></span><h1><span><span><span>總結</span></span></span></h1><p style="color:#393c5a; margin-left:0; margin-right:0; text-align:start"><span><span><span>以上就是我們常用的 Promise 基礎實現，在實現過程中對比了 Promise 和函數嵌套處理異步請求的優缺點，Promise 仍存在缺點，但是的確方便很多，同時更清晰的理解到錯誤處理如何進行異常穿透的，也能幫助我們更規範的使用 Promise 以及快速定位問題所在。</span></span></span></p><blockquote><p>作者：京東物流&nbsp;孫琦</p><p>來源：京東雲開發者社區，自猿其説 Tech 轉載請註明來源</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Thu, 30 Nov 2023 02:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/10150936</guid>
            <link>https://my.oschina.net/u/4090830/blog/10150936</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Go 語言微服務框架重磅升級：dubbo-go v3.2.0 -alpha 版本預覽]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:justify">隨着 Dubbo3 在雲原生微服務方向的快速發展，Dubbo 的 go 語言實現迎來了 Dubbo3 版本以來最全面、最大幅度的一次升級，這次升級是全方位的，涉及 API、協議、流量管控、可觀測能力等。總的來説，新版本的 dubbo-go：</p><ul><li><strong>全面升級 Triple 協議，</strong>兼容 gRPC、標準 HTTP 客戶端，提供簡單明瞭的 API 用於編寫 RPC server 與 client，解決組件間的基本通信問題。</li><li><strong>針對微服務場景，提供了完善的服務治理能力，</strong>這包括配置管理、可觀測性、流量管控規則、生態集成與適配等的全面升級。</li></ul><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-c4c6b5317adb83a4b234eb8fcd15d8c9_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h3_1"></span><h3>全新升級的 Triple 協議</h3><p style="text-align:justify">基於 dubbo-go 實現的 Triple 協議，你可以輕鬆編寫瀏覽器、gRPC 兼容的 RPC 服務，並讓這些服務同時運行在 HTTP/1 和 HTTP/2 上。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-8146beb5d33000f7180c25928e62fba0_720w.webp" referrerpolicy="no-referrer"></p><p>如上圖所示，你可以使用 "http+json" 的標準形式訪問 dubbo-go 發佈的後端 triple 服務，基於這一特性， 我們可以在 dubbo 客戶端在瀏覽器頁面、移動設備上訪問後端服務，使用標準 cURL 工具訪問服務，也可以讓比如 Spring 體系的應用輕鬆的調通 Dubbo 服務。</p><p style="text-align:justify">由於 Triple 協議完全兼容 gRPC 協議，Dubbo 後端服務有可以直接調通標準的 gRPC 服務，它們之間可以無縫的互通，不論是 unary 還是 streaming 通信模式。</p><span id="OSC_h4_2"></span><h4>發佈一個 triple rpc 服務</h4><p style="text-align:justify">為了體驗升級後的 triple 協議，我們接下來會嘗試啓動一個 dubbo-go server，併發佈一個基於 triple 協議的服務。</p><p style="text-align:justify">創建一個新的 server 並啓動 server，它將在指定的端口監聽 triple 協議請求。</p><pre><code>func main() {
  srv, err := server.NewServer(
    server.WithServerProtocol(
      protocol.WithTriple(),
      protocol.WithPort(50051),
    ),
  )
  if err != nil {
    panic(err)
  }
  if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
  }
  if err := srv.Serve(); err != nil {
    panic(err)
  }
}</code></pre><span id="OSC_h4_3"></span><h4>cURL 訪問服務</h4><p style="text-align:justify">Triple 服務啓動完成之後，最簡單方式是使用 HTTP/1.1 POST 訪問服務，參數則作以標準 JSON 格式作為 HTTP 負載傳遞。如下是使用 cURL 命令的訪問示例：</p><pre><code>curl \
    --header "Content-Type: application/json" \
    --data '{"name": "Dubbo"}' \
    http://localhost:50051/greet.GreetService/Greet</code></pre><p style="text-align:justify">Triple 協議的一項重大升級是支持標準 http 工具直接訪問，通過 cURL 可以極大的降低 dubbo-go 服務的測試驗證、前端接入成本。</p><span id="OSC_h3_4"></span><h3>簡單明瞭的 API</h3><p style="text-align:justify">Dubbo Go SDK 支持使用 IDL 或編程語言特有的方式定義服務，並提供一套輕量的 API 來發布或調用這些服務。在上一節的示例中，我們已經看到了部分 dubbo-go API 的使用方式，接下來，讓我們更仔細全面的看一下新版本的 API 設計。</p><span id="OSC_h4_5"></span><h4>RPC Server 與 Client</h4><p style="text-align:justify">對於一些 RPC 通信的場景，開發者只需要使用 dubbo-go 編寫一個最簡單的 RPC server 或者 RPC client，這在新版本 dubbo-go 中只需要幾行代碼即可完成。</p><p style="text-align:justify">通常，我們會使用 Protocol Buffer (IDL) 來定義一個 Dubbo 服務。</p><pre><code>syntax = "proto3";
package greet;

message GreetRequest {
  string name = 1;
}

message GreetResponse {
  string greeting = 1;
}

service GreetService {
  rpc Greet(GreetRequest) returns (GreetResponse) {}
}</code></pre><p style="text-align:justify">使用 Protocol Buffers Compiler 從 IDL 生成 stub 代碼（篇幅關係，我們不在此展示，具體請參見官網 dubbo-go 快速開始）。接下來，我們實現 greettriple.GreeterClient 接口並提供自定義服務實現。</p><pre><code>type GreeterServer struct {
}

func (s *GreeterServer) SayHello(ctx context.Context, in *greet.HelloRequest) (*greet.User, error) {
  return &amp;greet.User{Name: "Hello " + in.Name, Id: "12345", Age: 21}, nil
}</code></pre><p style="text-align:justify">以下是一個簡單的 RPC server 示例，執行協議信息，並註冊服務到 server 中：</p><pre><code>func main() {
  srv, err := server.NewServer(
    server.WithServer_Protocol(
      protocol.WithTriple(),
      protocol.WithPort(50052),
    ),
  )
  if err != nil {
    panic(err)
  }
  if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
  }
  if err := srv.Serve(); err != nil {
    panic(err)
  }
}</code></pre><p style="text-align:justify">如前面 Triple 協議一節所述，你可以使用 cURL 直接測試以上 server 服務運行正常。與此同時，對應的 RPC client 示例如下：</p><pre><code>func main() {
  // for the most brief RPC case
  cli, err := client.NewClient(
    client.WithURL("tri://127.0.0.1:50052"),
  )
  if err != nil {
    panic(err)
  }
  svc, err := greettriple.NewGreetService(cli)
  if err != nil {
    panic(err)
  }

  common.TestClient(svc)
}</code></pre><span id="OSC_h4_6"></span><h4>微服務開發</h4><p style="text-align:justify">如果你正在開發微服務應用，那麼除了 RPC 通信之外，你通常還需要為應用配置一些服務治理能力，比如 retistry 註冊中心、配置中心、可觀測能力等。</p><p style="text-align:justify">以下展示瞭如何使用 dubbo-go 開發一個微服務應用。</p><p style="text-align:justify">首先，創建一個代表微服務的應用 Server，將服務註冊給它，添加註冊中心等服務治理配置。</p><pre><code>func main() {
  // configure global configurations and common modules
  ins, err := dubbo.NewInstance(
    dubbo.WithName("dubbo_test"),
    dubbo.WithRegistry(
      registry.WithZookeeper(),
      registry.WithAddress("127.0.0.1:2181"),
    ),
    dubbo.WithProtocol(
      protocol.WithTriple(),
      protocol.WithPort(50052),
    ),
  )
    // create a server with registry and protocol set above
  srv, err := ins.NewServer()
  if err != nil {
    panic(err)
  }
    // register a service to server
  if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
  }
    // start the server
  if err := srv.Serve(); err != nil {
    panic(err)
  }
}</code></pre><p style="text-align:justify">其中，Instance 是我們在新版本中引入的全局配置，你可以將所有微服務全局配置在這裏進行初始化。這裏，我們設置了微服務通信協議 protocol 和註冊中心 registry，如以下代碼片段所示：</p><pre><code>ins, err := dubbo.NewInstance(
    dubbo.WithName("dubbo_test"),
    dubbo.WithRegistry(
        registry.WithZookeeper(),
        registry.WithAddress("127.0.0.1:2181"),
    ),
    dubbo.WithProtocol(
        protocol.WithTriple(),
        protocol.WithPort(50052),
    ),
)</code></pre><p style="text-align:justify">接下來的操作就非常簡單明瞭了，我們創建一個 server，將服務註冊給它並啓動，如下所示。如果有更多的服務，則可以依次註冊到 server 後再啓動。</p><pre><code>// create a server with registry and protocol set above
srv, err := ins.NewServer()
// register a service to server
if err := greettriple.RegisterGreetServiceHandler(srv, &amp;api.GreetTripleServer{}); err != nil {
    panic(err)
}
// start the server
if err := srv.Serve(); err != nil {
    panic(err)
}</code></pre><p style="text-align:justify">以上就是一個微服務應用的基本開發過程，如果你的微服務應用要調用一些遠程 Dubbo 服務，那麼你只需要參照以下方式創建一個 client 就行了。</p><p style="text-align:justify">下面的代碼示例創建了一個 client，緊接着生成了一個 GreetService 遠程服務代理，之後，就可以像調用本地方法一樣調用遠端 Dubbo 服務了。client 將基於註冊中心實現 server 實例的自動發現並自動為流量應用負載均衡策略。</p><pre><code>func main() {
  // configure global configurations and common modules
  ins, err := dubbo.NewInstance(
    dubbo.WithName("dubbo_test"),
    dubbo.WithRegistry(
      registry.WithZookeeper(),
      registry.WithAddress("127.0.0.1:2181"),
    ),
  )
  
  // configure the params that only client layer cares
  cli, err := ins.NewClient()
  if err != nil {
    panic(err)
  }

  svc, err := greettriple.NewGreetService(cli)
  if err != nil {
    panic(err)
  }

  resp, err := svc.Greet(context.Background(), &amp;greet.GreetRequest{Name: "triple"})
  if err != nil {
    return err
  }
  logger.Infof("TRIPLE unary call resp: %s", resp.Greeting)
}</code></pre><span id="OSC_h3_7"></span><h3>企業級服務治理能力</h3><span id="OSC_h4_8"></span><h4>動態配置</h4><p style="text-align:justify">除了 API 模式之外，Dubbo-go 支持基於配置文件驅動的編碼方式，這對於一些更大規模的微服務開發場景非常適用。在這種模式下，我們將 registry、protocol 等組件配置，甚至包括服務聲明等都放在 dubbogo.yml 文件中，框架會在啓動過程中完成配置文件加載。</p><p style="text-align:justify">以下是一個基於 dubbogo.yml 的微服務應用的開發示例：</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-7420aaf1df69816f650d9fafc20a94e5_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">其中，server.go 定義如下：</p><pre><code>func main() {
  greettriple.SetProviderService(&amp;GreeterServiceImpl{})
  if err := dubbo.Load(); err != nil {
    panic(err)
  }
}</code></pre><p style="text-align:justify">dubbogo.yml 示例內容如下：</p><pre><code>dubbo:
  application: # 應用信息，服務啓動後會將相關信息註冊到註冊中心，可被客戶端從 url 中識別
    name: myApp
  registries:
    nacos:
      protocol: nacos # 註冊中心選擇 nacos 
      address: 127.0.0.1:8848 # nacos ip
      group: DEFAULT_GROUP # nacos group, 默認 DEFAULT_GROUP
      namespace: 9fb00abb-278d-42fc-96bf-e0151601e4a1 # nacos namespaceID, should be created before. 默認 public
      username: abc
      password: abc
  protocols:
    dubbo:
      name: tri
      port: 20000
  provider:
    services:
      UserProviderWithCustomGroupAndVersion: # 接口三元組：接口名、版本號、分組。client 和 server 需要保持一致。
        interface: org.apache.dubbo.UserProvider.Test # 接口名必填
        version: myInterfaceVersion # 默認為空
        group: myInterfaceGroup # 默認為空</code></pre><p style="text-align:justify">可以看到相比於之前的 API 編碼方式，這裏的 server.go 只有兩行代碼，dubbo.Load() 會完成所有配置的自動組裝並啓動相關組件，我們只需要在啓動應用時指定 export DUBBO_GO_CONFIG_PATH=$ABSOLUTE_PATH/conf/dubbogo.yml 即可。</p><span id="OSC_h4_9"></span><h4>可觀測性</h4><p style="text-align:justify">自 3.2.0 版本開始，dubbo-go 重點升級了內置 metrics 指標採集能力，提供 RPC 調用（RT、QPS、調用量、請求成功數、請求失敗數、併發請求數等）、註冊中心、元數據中心、配置中心交互統計等豐富的內置採集埋點，支持多維度的指標聚合。</p><p style="text-align:justify">dubbo-go 內置 metrics 指標導出到 Prometheus + Grafana 體系的能力，以下是 dubbo-go v3.2.0 示例在 Grafana 的監控效果圖，具體示例我們將與隨後發佈在 dubbo-go-samples/metrics。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-b4ec54c1891c2d1f09b91227746c751e_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h4_10"></span><h4>流量管控</h4><p style="text-align:justify">Dubbo 提供了豐富的流量管控策略：</p><ul><li><strong>地址發現與負載均衡，</strong>地址發現支持服務實例動態上下線，負載均衡確保流量均勻的分佈到每個實例上。</li><li><strong>基於路由規則的流量管控，</strong>路由規則對每次請求進行條件匹配，並將符合條件的請求路由到特定的地址子集。</li></ul><p style="text-align:justify">服務發現保證調用方看到最新的提供方實例地址，服務發現機制依賴註冊中心 (Zookeeper、Nacos、Istio 等) 實現。在消費端，Dubbo 提供了多種負載均衡策略，如隨機負載均衡策略、一致性哈希負載、基於權重的輪詢、最小活躍度優先、P2C 等。</p><p style="text-align:justify">Dubbo 的流量管控規則可以基於應用、服務、方法、參數等粒度精準的控制流量走向，根據請求的目標服務、方法以及請求體中的其他附加參數進行匹配，符合匹配條件的流量會進一步的按照特定規則轉發到一個地址子集。以下是 dubbo-go 流量管控規則可以實現的一些具體管控場景示例：</p><ul><li>基於權重的比例流量分發</li><li>灰度驗證</li><li>金絲雀發佈</li><li>按請求參數的路由</li><li>同區域優先</li><li>超時時間調整</li><li>重試</li><li>限流降級</li></ul><p style="text-align:justify">以下是一個基於 dubbo-go 實現的全鏈路灰度示例：</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-d3af29d517bd1d38914a8b7df29c0384_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">以下是一個基於 dubbo-go 實現的按比例流量轉發示例：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-4688342e32359c6fa7e25ef3bc3c22b6_720w.webp" referrerpolicy="no-referrer"></p><p>關於 dubbo-go 流量管控，我們以一個商城系統提供了一個完整的 demo 示例，感興趣的讀者可以參考詳細信息：</p><ul><li>流量管控規則詳情<strong>[1]</strong></li><li>流量管控商場示例解讀<strong>[2]</strong></li></ul><span id="OSC_h4_11"></span><h4>生態</h4><p style="text-align:justify">dubbo-go 總體上遵循框架內核+插件的的設計理念，左側的框架內覈定義了 dubbo-go 作為微服務框架的一些核心概念，右側的插件部分則提供了核心概念擴展實現。</p><p style="text-align:center"><img src="https://pic2.zhimg.com/80/v2-c4c6b5317adb83a4b234eb8fcd15d8c9_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">框架內核，可分為 4 個層次，從上到下依次為：</p><ul><li><strong>API 層</strong></li></ul><p style="text-align:justify">dubbo-go 同時支持基於 IDL、interface/struct 的服務契約定義，兼顧跨語言與易用性訴求；支持基於純 yaml 文件的微服務配置模式；提供了同步、異步、單次 (unary)、流式 (streaming) 等 RPC 通信與編碼模型。</p><ul><li><strong>服務治理層</strong></li></ul><p style="text-align:justify">dubbo-go 內置了多維度的服務治理能力抽象，確保滿足微服務開發與集羣治理的核心訴求，這包括地址發現（Service Discovery）、負載均衡（Load Balancing）、可觀測指標（Metrics）、流量管控（Traffic Management）、全鏈路追蹤（Tracing）等。</p><ul><li><strong>RPC 協議層</strong></li></ul><p style="text-align:justify">dubbo-go 實現的最核心的 RPC 協議是 - triple 協議，triple 可同時工作在 http1/2 之上 (支持 CURL 直接訪問)，兼容 gRPC；從設計上，dubbo-go 還提供了多協議發佈服務的支持，你可以在一個進程內同時發佈 triple、dubbo2、rest、jsonRPC 等多種不同通信協議的服務。</p><ul><li><strong>傳輸層</strong></li></ul><p style="text-align:justify">支持 HTTP1/2、TCP 傳輸層，兼顧性能與通用性，同時支持多種序列化方式。</p><p style="text-align:justify">插件體系極大的豐富了 dubbo-go 功能與生態，社區內置提供了大量的內置擴展實現，同時，開發者可以非常容易的根據需求增加擴展實現。以下是一些典型的插件定義：</p><ul><li><strong>Protocol</strong></li></ul><p style="text-align:justify">dubbo-go 基於 protocol 插件內置提供了 triple、dubbo2、rest 等協議支持，通過擴展 protocol 可以為 dubbo-go 擴展更多協議。</p><ul><li><strong>Service Discovery</strong></li></ul><p style="text-align:justify">支持 Nacos、Zookeeper、Polaris 等主流注冊中心集成。</p><ul><li><strong>Traffic Management</strong></li></ul><p style="text-align:justify">dubbo-go 支持 Dubbo 體系定義的流量規則，可以實現在運行期動態的調整服務行為如超時時間、重試次數、限流參數等，通過控制流量分佈可以實現 A/B 測試、金絲雀發佈、多版本按比例流量分配、條件匹配路由、黑白名單等。</p><ul><li><strong>Metrics</strong></li></ul><p style="text-align:justify">提供 RPC 調用（RT、QPS、調用量、請求成功數、請求失敗數、併發請求數等）、註冊中心、元數據中心、配置中心交互統計等豐富的內置採集埋點，支持多維度的指標聚合。</p><ul><li><strong>Logging</strong></li></ul><p style="text-align:justify">提供通用的日誌採集接口定義，內置 Zap、Logrus 支持</p><ul><li><strong>Tracing</strong></li></ul><p style="text-align:justify">提供分佈式鏈路追蹤能力，通過此插件擴展可接入 Zipkin、Jaeger、Skywalking 等鏈路追蹤系統。</p><span id="OSC_h3_12"></span><h3>總結</h3><p style="text-align:justify">dubbo-go 3.2.0 的首個 alpha 版本將於 11 月底發佈，本文是發版前的搶先預覽，感興趣的讀者也可以訪問源碼嚐鮮：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fapache%2Fdubbo-go%2Ftree%2Ffeature-triple%2Fprotocol%2Ftriple%2Finternal%253Fspm%253Da2c6h.13046898.publish-article.3.79d66ffahA9acR" target="_blank">https://github.com/apache/dubbo-go/tree/feature-triple/protocol/triple/internal</a></em></u></p><p style="text-align:justify">接下來，我們將持續推進 3.2.0 版本迭代並計劃與 2 月份發佈正式穩定版本，詳細 Roadmap 請關注項目倉庫：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fapache%2Fdubbo-go%253Fspm%253Da2c6h.13046898.publish-article.4.79d66ffahA9acR" target="_blank">https://github.com/apache/dubbo-go</a></em></u></p><p style="text-align:justify"><strong>相關鏈接：</strong></p><p style="text-align:justify">[1] 流量管控規則詳情</p><p style="text-align:justify"><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Fcore-features%2Ftraffic%2F%253Fspm%253Da2c6h.13046898.publish-article.5.79d66ffahA9acR" target="_blank">https://cn.dubbo.apache.org/zh-cn/overview/core-features/traffic/</a></em></u></p><p style="text-align:justify">[2] 流量管控商場示例解讀</p><p style="text-align:justify"><u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fcn.dubbo.apache.org%2Fzh-cn%2Foverview%2Ftasks%2Ftraffic-management%2F%253Fspm%253Da2c6h.13046898.publish-article.6.79d66ffahA9acR" target="_blank">https://cn.dubbo.apache.org/zh-cn/overview/tasks/traffic-management/</a></em></u></p><p style="text-align:justify"><em>作者：王宇軒， Apache Dubbo Committer</em></p><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1380725%3Futm_content%3Dg_1000384715" target="_blank">原文鏈接</a></strong></p><p style="text-align:justify"><strong>本文為阿里雲原創內容，未經允許不得轉載。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 09:26:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10314426</guid>
            <link>https://my.oschina.net/yunqi/blog/10314426</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[國內首個農業開源鴻蒙操作系統]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="margin-left:0px; margin-right:0px; text-align:start">11 月 29 日，在全球首個以供應鏈為主題的國家級展會——中國國際供應鏈促進博覽會上，中信農業科技股份有限公司（簡稱「中信農業」）聯合深圳開鴻數字產業發展有限公司（簡稱「深開鴻」）、華為技術有限公司（簡稱「華為」）正式對外發布了<strong>國內首個自主可控的農業開源鴻蒙操作系統。</strong></p><p style="margin-left:0px; margin-right:0px; text-align:start">據介紹，農業開源鴻蒙是致力於維護農業數據安全，打造自主可控的農業操作系統。</p><p><img src="https://static.oschina.net/uploads/space/2023/1129/170904_6My8_2720166.png" referrerpolicy="no-referrer"></p><p>下圖是農業開源鴻蒙操作系統的演示：</p><p><img height="906" src="https://static.oschina.net/uploads/space/2023/1129/171101_l9cl_2720166.png" width="2232" referrerpolicy="no-referrer"></p><p><img height="928" src="https://static.oschina.net/uploads/space/2023/1129/171017_86bC_2720166.png" width="2226" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-116c65e954d843c9b90f6fb5ba8f83258c5.png" referrerpolicy="no-referrer"></p><p><img src="https://oscimg.oschina.net/oscnet/up-c8e4bc96284803ab6547db6797684372387.png" referrerpolicy="no-referrer"></p><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fj4EIO_8RPUdwqLJBhsozAQ" target="_blank">https://mp.weixin.qq.com/s/j4EIO_8RPUdwqLJBhsozAQ</a></u></em></p><p>深開鴻 CEO 王成錄博士介紹道，農業開源鴻蒙操作系統是基於 KaihongOS 的新一代面向數字農業領域的萬物智聯操作系統，為大小不一、類型多樣設備的互聯和協同提供統一的數字底座，讓所有農業設備都用統一的操作系統，講同一種語言，而且全棧關鍵核心技術均為國產自主研發，從底層操作系統源頭上保證了數據的安全可靠。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 09:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268706</guid>
            <link>https://www.oschina.net/news/268706</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微軟開源 Azure RTOS，更名為 Eclipse ThreadX]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">微軟<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcommunity.microsoft.com%2Ft5%2Finternet-of-things-blog%2Fmicrosoft-contributes-azure-rtos-to-open-source%2Fba-p%2F3986318" target="_blank">宣佈</a>將 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fazure-rtos" target="_blank">Azure RTOS</a> 託管至&nbsp;<span style="background-color:#ffffff">Eclipse 基金會，並更名為&nbsp;Eclipse ThreadX。</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Azure RTOS 是一個帶有 ThreadX 實時操作系統（RTOS）的嵌入式開發套件。ThreadX 是一個普及性很高的小型 RTOS，</span>可為資源受限的設備提供可靠、超快的性能；<span style="background-color:#ffffff">目前已部署在全球超過 120 億台設備上。除了作為 RTOS 內核的 Azure RTOS ThreadX 之外，Azure RTOS 還提供了一組系統組件來加速構建嵌入式系統和物聯網應用程序。</span></span></p><p><span style="color:#000000">在基金會管理下，<span style="background-color:#ffffff">Eclipse ThreadX 項目計劃將於 2024 年第一季度在 MIT 協議下開源提供。「</span><span style="background-color:#ffffff">ThreadX 將成為世界上第一個開源實時操作系統。</span><span style="background-color:#ffffff">」</span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff"><img alt="" height="374" src="https://oscimg.oschina.net/oscnet/up-70e9a7d446ccf867ef9551516c458a9610d.png" width="700" referrerpolicy="no-referrer"></span></span></p><p><span style="color:#000000"><span style="background-color:#ffffff">公告稱，Eclipse ThreadX 為實時應用提供了一個供應商中立、開放源代碼、安全認證的操作系統。它是第一個也是唯一一個具有這種獨特混合屬性的實時操作系統，可滿足廣泛的需求，使行業採用者、開發人員和最終用戶都能從中受益。</span><span style="background-color:#ffffff">主要優點包括：</span></span></p><ul><li><span style="color:#000000">不間斷訪問：更廣泛、持續地訪問 ThreadX 技術</span></li><li><span style="color:#000000">加速創新：通過社區參與提供更快的更新和改進</span></li><li><span style="color:#000000">開放且可預測：透明的開發流程以增強社區協作</span></li><li><span style="color:#000000">更廣泛的覆蓋範圍：對於各種應用來説更易於訪問和通用</span></li></ul><p><span style="color:#000000">「這一變革性合作為嵌入式 RTOS 技術的空前發展鋪平了道路，並將在新成立的 </span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fprojects.eclipse.org%2Fproposals%2Feclipse-threadx" target="_blank">Eclipse ThreadX Project</a>&nbsp;<span style="color:#000000"><span style="background-color:#ffffff">和</span></span>&nbsp;<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fprojects.eclipse.org%2Finterest-groups%2Fthreadx-interest-group" target="_blank">Eclipse ThreadX Interest Group</a><span style="color:#4c4d4e">&nbsp;</span><span style="color:#000000">的框架內展開。<span style="background-color:#ffffff">與我們一起塑造嵌入式系統的未來並利用開源的力量促進創新！</span>」&nbsp;</span></p><p><span style="color:#000000"><span style="background-color:#ffffff">Eclipse 基金會<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Feclipse-foundation.blog%2F2023%2F11%2F21%2Fintroducing-eclipse-threadx%2F" target="_blank">認為</a>，</span></span><span style="background-color:#ffffff"><span style="color:#222222">ThreadX 將憑藉其全面的屬性，迅速擴大在航空航天、汽車、物聯網、醫療、交通、自動化和消費可穿戴設備等廣泛用例中的採用。「Eclipse ThreadX 為行業帶來了改變遊戲規則的機會。」</span></span></p><p><strong><span style="background-color:#ffffff"><span style="color:#222222">項目官網：</span></span></strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthreadx.io%2F" target="_blank">https://threadx.io/</a></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 09:11:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268705/microsoft-azure-rtos-eclipse-threadx</guid>
            <link>https://www.oschina.net/news/268705/microsoft-azure-rtos-eclipse-threadx</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[1 - 10 月我國電子信息製造業生產持續回升]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>2023 年 1-10 月份電子信息製造業運行情況已<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F-NlHIDx-kRamtsv2EoBppQ" target="_blank">公佈</a>。1-10&nbsp;<span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)">月份，我國電子信息製造業生產持續回升，出口降幅收窄，效益持續改善，投資穩定增長，地區間營收分化明顯。</span></p><p style="margin-left:0; margin-right:0"><strong>一、生產持續回升</strong></p><p style="margin-left:0; margin-right:0">1—10 月份，規模以上電子信息製造業增加值同比增長 1.7%，增速較前三季度提高 0.3 個百分點；<span>增速分別比同期工業、高技術製造業低 2.4 個和 0.2 個百分點。10 月份，規模以上電子信息製造業增加值同比增長 4.8%，較同期工業高 0.2 個百分點。</span></p><p><img height="284" src="https://oscimg.oschina.net/oscnet/up-c7e8347b11afa929069846f119706440564.png" width="500" referrerpolicy="no-referrer"></p><p>1—10 月份，主要產品中，手機產量 12.5 億台，同比增長 1.6%，其中智能手機產量 9.06 億台，同比下降 4.8%；微型計算機設備產量 2.81 億台，同比下降 20.8%；集成電路產量 2765 億塊，同比增長 0.9%；光電子器件產量 11753 億隻，同比增長 9.3%。</p><p style="margin-left:0; margin-right:0"><strong>二、出口降幅收窄</strong></p><p>1—10 月份，規模以上電子信息製造業出口交貨值同比下降 6.9%，降幅較前三季度收窄 1.2 個百分點，比同期工業降幅深 2.7 個百分點。10 月份，規模以上電子信息製造業出口交貨值與去年同期持平。</p><p><img height="278" src="https://oscimg.oschina.net/oscnet/up-8fddcd7d4c558e2d88e81617b79a9576a58.png" width="500" referrerpolicy="no-referrer"></p><p>據海關統計，1—10 月份，我國出口筆記本電腦 11774 萬台，同比下降 18%；出口手機 6.42 億台，同比下降 6.5%；出口集成電路 2218 億個，同比下降 4.1%。</p><p style="margin-left:0; margin-right:0"><strong>三、效益持續改善</strong></p><p style="margin-left:0px; margin-right:0px; text-align:justify">1—10 月份，規模以上電子信息製造業實現營業收入 12.1 萬億元，同比下降 2.9%，較前三季度降幅收窄 0.5 個百分點；營業成本 10.5 萬億元，同比下降 2.6%；實現利潤總額 4826 億元，同比下降 18.2%，較前三季度降幅收窄 0.4 個百分點；營業收入利潤率為 4%，較前三季度持平。</p><p><img height="280" src="https://oscimg.oschina.net/oscnet/up-8fb3765349827aa46ce821c7b2ef59dfc32.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>四、投資穩定增長</strong></p><p style="margin-left:0; margin-right:0">1—10 月份，電子信息製造業固定資產投資同比增長 9.6%，比同期工業投資增速高 0.7 個百分點，但比高技術製造業投資增速低 1.7 個百分點。</p><p><img height="274" src="https://oscimg.oschina.net/oscnet/up-ed620009a27ece0de52f59079cdf61d17da.png" width="500" referrerpolicy="no-referrer"></p><p style="margin-left:0; margin-right:0"><strong>五、地區間營收分化明顯</strong></p><p>1—10 月份，規模以上電子信息製造業東部地區實現營業收入 82003 億元，同比下降 3%，較前三季度降幅收窄 0.8 個百分點；中部地區實現營業收入 19834 億元，同比下降 3.9%，較前三季度降幅收窄 1.3 個百分點；西部地區實現營業收入 17982 億元，同比下降 1.9%，較前三季度降幅加深 1.8 個百分點；東北地區實現營業收入 823 億元，同比增加 9%，較前三季度回落 0.5 個百分點。四個地區電子信息製造業營業收入佔全國比重分別為 68.0%、16.4%、14.9% 和 0.7%。</p><p><img height="310" src="https://oscimg.oschina.net/oscnet/up-b0043b1d7c4585093e396d4d7d5f544fe2a.png" width="500" referrerpolicy="no-referrer"></p><p>1—10 月份，規模以上電子信息製造業京津冀地區實現營業收入 5995 億元、同比下降 6.3%，較前三季度降幅持平，營收佔全國比重 5%；長三角地區實現營業收入 33990 億元、同比下降 3.8%，較前三季度降幅收窄 1.1 個百分點，營收佔全國比重 28.2%。</p><p><span style="color:#888888">（注：1.文中統計數據除註明外，其餘均為國家統計局數據或據此測算。2.文中「電子信息製造業」與國民經濟行業分類中的「計算機、通信和其他電子設備製造業」為同一口徑。）</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 08:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268691</guid>
            <link>https://www.oschina.net/news/268691</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[滴滴向所有用戶補償 10 元無門檻打車通用券]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>滴滴出行今日就 11 月 27 日夜間發生的系統故障進行了説明，並再一次道歉。同時，滴滴還為所有用戶派發了一張「致歉補償券」，無門檻使用，立減 10 元。</p><blockquote><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-f2fd281711327e482dba21d9ff535b24145.png" referrerpolicy="no-referrer"></p></blockquote><p>掃碼領取：</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-28207da7bde2ec3598e23358e58cbbeaafd.png" referrerpolicy="no-referrer"></p><p>滴滴表示，目前滴滴 App 的所有服務已經全部恢復。初步確定，這起事故的起因是底層系統軟件發生故障，並非網傳的「遭受攻擊」，後續將深入開展技術風險隱患排查和升級工作，全面保障服務穩定性。</p><hr><p><strong>事件回顧</strong></p><ul><li><a href="https://www.oschina.net/news/268635" target="news">滴滴史上最嚴重服務故障，罪魁禍首是底層軟件 or 「降本增笑」？</a></li><li><a href="https://www.oschina.net/news/268480" target="news">滴滴昨晚系統服務故障，技術團隊連夜修復</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 07:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268677</guid>
            <link>https://www.oschina.net/news/268677</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[AWS 推出 AI 聊天機器人 Amazon Q]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">AWS 正式加入聊天機器人賽道，宣佈推出一款名為 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Faws.amazon.com%2Fcn%2Fblogs%2Faws%2Famazon-q-brings-generative-ai-powered-assistance-to-it-pros-and-developers-preview%2F" target="_blank">Amazon Q</a> 的生成式 AI 助手；可以幫助用戶完成工作中的各種任務，如聊天、生成內容和採取行動。</span></p><p><span style="color:#000000">根據介紹，Amazon Q 主要面向企業提供，旨在幫助員工完成日常任務，例如總結文檔、填寫內部文件以及回答有關公司政策的問題。其可供企業使用多種功能，包括開發應用程序、轉換代碼、生成商業智能、充當業務應用程序的生成式 AI 助手以及幫助客戶通過 Amazon Connect 產品的服務代理。</span></p><p><span style="color:#000000"><img alt="" height="260" src="https://oscimg.oschina.net/oscnet/up-1f94a6a3ef5eecb740529e810e21d309130.png" width="700" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">AWS 首席執行官 Adam Selipsky 介紹稱，Amazon Q 可以利用來自各種應用程序的業務數據，包括辦公軟件 Microsoft 365、企業協作軟件 Slack、客戶服務軟件 Salesforce、網絡儲存應用 Dropbox 和 Amazon S3。目前開箱即用地支持 40 多種應用程序和服務。</span></p><p><span style="color:#000000">他還強調了安全和隱私的重要性，並表示 Amazon Q 尊重用戶現有的身份、角色和權限，不會使用用戶的內容來訓練其底層模型。</span></p><p><span style="color:#000000">Selipsky 表示，AWS 已將許多功能融入 Amazon Q 中以幫助開發人員，其中包括允許程序員在構建應用程序時提出問題的自然語言對話功能。與此同時，該公司還在將 Amazon Q 集成到 Visual Studio Code 和 IntelliJ IDEA 等 IDE 中。</span></p><p><span style="color:#000000">Amazon Q 目前處於預覽階段，部分功能免費對外提供。亞馬遜計劃未來將面向企業用戶收取每人每月 20 美元的費用，為開發人員和 IT 人員提供功能的版本則將收取每人每月 25 美元。</span></p><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Faws.amazon.com%2Fcn%2Fblogs%2Faws%2Famazon-q-brings-generative-ai-powered-assistance-to-it-pros-and-developers-preview%2F" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 06:58:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268675/amazon-q</guid>
            <link>https://www.oschina.net/news/268675/amazon-q</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[AI 生成圖片著作權侵權第一案宣判：被告構成侵權，賠償 500 元]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>11 月 29 日消息，近日，北京互聯網法院針對<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrdzctOfPu9zQaKO4ZVDCwQ" target="_blank">人工智能生成圖片（AI 繪畫圖片）著作權侵權糾紛</a></u>作出一審判決，據悉該案為 AI 生成圖片相關領域著作權第一案。</p><p>法院最終判決，<strong>被告構成侵權，需向原告公開道歉，並賠償 500 元</strong>。</p><p>據悉，原告李某使用 AI 生成涉案圖片後發佈於小紅書平台；被告系百家號博主，發佈文章配圖使用了原告該 AI 生成的圖片，原告遂起訴。</p><p>北互審理認為涉案人工智能生成圖片（AI 繪畫圖片）具備「獨創性」要件，體現了人的獨創性智力投入，應當被認定為作品，受到著作權法保護等。</p><p><img alt="1701225443968.png" src="https://static.oschina.net/uploads/img/202311/29143541_fABc.png" referrerpolicy="no-referrer"></p><p><img alt="圖片" src="https://static.oschina.net/uploads/img/202311/29143541_3GlB.png" referrerpolicy="no-referrer"></p><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FWu3-GuFvMJvJKJobqqq7vQ" target="_blank">https://mp.weixin.qq.com/s/Wu3-GuFvMJvJKJobqqq7vQ</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 06:35:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268672</guid>
            <link>https://www.oschina.net/news/268672</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[恭喜 Devlive DataCap 新晉一位 Committer]]>
            </title>
            <description>
                <![CDATA[<div class="content"><blockquote><p>非常感謝所有對 DataCap 項目的支持和貢獻，我們迎來了新的一位來自互聯網行業的大數據資深運維工程師，感謝他對 DataCap 的支持以及代碼的貢獻。</p></blockquote><h3>關於 DataCap</h3><hr><p>DataCap 是數據轉換、集成和可視化的集成軟件。支持多種數據源，文件類型，大數據相關數據庫，關係型數據庫，NoSQL 數據庫等。通過軟件可以實現管理多種數據源，對該源下的數據進行各種操作轉換，製作數據圖表，監控數據源等各種功能。</p><h3>DataCap 喜迎一位 Committer 成員</h3><hr><table><tbody><tr><th>名字</th><th>職業</th><th>GitHub ID</th></tr></tbody><tbody><tr><td>陳文明</td><td>大數據資深運維工程師</td><td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fchenwenming-zj" target="_blank">chenwenming-zj</a></td></tr></tbody></table><h4>個人描述</h4><hr><p>有多年大數據組件維護經驗，對 Hadoop 集羣有豐富的經驗，同時對 Apache Kafka 以及各個大數據組件有一定的經驗。</p><ol><li>優化過億 Blocks 的 NameNode，優化解決集羣小文件問題，減少 NameNode RPC 壓力</li><li>遷移並運維過 PB 級別的 Hadoop 集羣</li><li>維護管理萬級別 Topic 的 Kafka 集羣，自動化腳本實現分區均衡遷移，Reassignment 限速等</li></ol><h4>對 DataCap 的認識</h4><hr><p>在做公司 Clickhouse 遷移時，從 GitHub 中搜索，發現 datacap 項目，結合公司內部業務，經過一段時間運行後發現缺失，服務功能缺失 JVM 動態加載功能，因為我對 Shell 比較熟悉且做過 JVM 優化工作，特意在源碼中支持了服務啓動讀取 JVM 配置功能。</p><h4>代碼提交之路</h4><hr><ol><li>在 datacap 上提交了相關代碼 (commit 57473faf4f45616a96962b7f84b9b5b81ecfbc42(HEAD-&gt;dev_get_jvm, origin/dev_get_jvm)</li></ol><h4>得到的收穫</h4><hr><ol><li>作為大數據運維,很少參與工程項目，非常榮幸能在 datacap 上貢獻自己微薄的代碼</li><li>這次參與也體會到團隊協助的力量，希望 datacap 做的越來越好</li></ol><h4>對新人的建議</h4><hr><ol><li>上線前整理 checklist</li><li>一定要寫好註釋，方便以後維護，要寫好註釋，可以寫某個方法是做什麼的，主要步驟是什麼</li><li>測試！一定要多測試，先上測試環境，再上線</li><li>新參與項目時，可以多參考官方文檔</li></ol><h4>如何參與 DataCap</h4><hr><ul><li>參考官網 <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdatacap.devlive.org%2Fdeveloper_guide%2Fenv.html" target="_blank">開發者文檔</a></li><li>通過 Issues 列表參與 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdevlive-community%2Fdatacap%2Fissues" target="_blank">GitHub</a>&nbsp;&amp;&nbsp; <a href="https://gitee.com/devlive-community/datacap/issues">Gitee</a></li><li>加入我們的微信羣&amp;釘釘羣（在代碼倉庫中可以看到二維碼）</li><li>微信公眾號後台留言（搜索微信公公眾號 <code>devlive-sf</code> 關注，標記 DataCap 項目給我們留言即可）</li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 04:27:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268646</guid>
            <link>https://www.oschina.net/news/268646</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[兩名玩家利用 DNF 漏洞獲利近 1 億元人民幣，已被公訴]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>日前，南京市玄武區人民檢察院依法對 2 名涉嫌非法獲取計算機信息系統數據罪被告人提起公訴。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-22fa6166d578719921e446311de49657bc3.png" referrerpolicy="no-referrer"></p><p>2022 年 8 月以來，被告人唐某利用深圳市騰訊計算機系統有限公司運營的網絡遊戲《地下城與勇士》個人揹包和倉庫程序的漏洞，使用被告人蔡某某提供的腳本，利用遊戲漏洞非法複製出「矛盾的結晶體」「扭曲的次元結晶」 「無瑕的金綠柱石」 等八種遊戲道具，將所複製的遊戲道具放在多個遊戲公會倉庫內，再進行出售。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-078b174cef4e6dae71ce7917a7f3ddb43e1.png" referrerpolicy="no-referrer"></p><p>2022 年 8 月起，被告人唐某先後向王某某、王某、周某出售非法獲取的遊戲道具，獲利人民幣 9163 萬餘元。被告人蔡某某將被告人唐某複製的遊戲道具出售給王某某，獲利人民幣 182 萬餘元。</p><p><img src="https://oscimg.oschina.net/oscnet/up-855b94f09d04a42b9687726b3241276edaa.jpg" referrerpolicy="no-referrer"></p><hr><p>DNF 昨日在官網迴應了此事：</p><blockquote><p><img height="1284" src="https://oscimg.oschina.net/oscnet/up-d04269bfc1d55a0b8914d959668a5eccc08.png" width="1506" referrerpolicy="no-referrer"></p></blockquote><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdnf.qq.com%2Fwebplat%2Finfo%2Fnews_version3%2F119%2F495%2F498%2Fm21449%2F202311%2F944229.shtml" target="_blank">https://dnf.qq.com/webplat/info/news_version3/119/495/498/m21449/202311/944229.shtml</a></u></em></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 29 Nov 2023 03:45:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/268643</guid>
            <link>https://www.oschina.net/news/268643</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
