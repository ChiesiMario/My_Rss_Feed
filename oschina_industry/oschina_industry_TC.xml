<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"


>
    <channel>
        <title>
            <![CDATA[開源中國-綜合資訊]]>
        </title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="https://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml" />
        <description>
            <![CDATA[開源中國-綜合資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)]]>
        </description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 13 Dec 2023 10:15:54 GMT</lastBuildDate>
        <ttl>120</ttl>
        <item>
            <title>
                <![CDATA[麟卓發佈多平台軟件安裝包構建系統，支持 Windows 和 Linux]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>北京麟卓<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F9I8Xo7H_LLHPmSy_HMY24A" target="_blank">宣佈推出</a></u>「多平台軟件安裝包構建系統」，用於解決 Windows 和 Linux 系統中傳統軟件封裝、安裝過程繁瑣、平台差異嚴重等諸多問題。</p><p>據介紹，該工具提供「一站式構建、安裝」功能，讓用戶能夠輕鬆製作軟件安裝包程序，提升工作效率，簡化軟件封裝、安裝以及卸載流程。</p><blockquote><strong>下載地址：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linzhuotech.com%2FProduct%2FDownLoadWindows" target="_blank">https://www.linzhuotech.com/Product/DownLoadWindows</a></u></em></strong></blockquote><p>「多平台軟件安裝包構建系統」是利用統一交互界面和配置機制生成多平台軟件安裝包的系統，支持在 Windows、Linux 平台上進行目標軟件的多層級模塊化封裝以及安裝功能，主要具備以下優勢：</p><ul><li>軟件安裝便捷：簡化傳統軟件安裝流程中的解壓、拷貝以及配置環境等繁瑣操作。</li><li>人機交互統一：在不同的操作系統平台上，具備統一人機交互，方便用戶進行多平台封裝。</li><li>功能操作簡單：具備多層級可選控制、安裝信息配置、自定義安裝腳本、環境配置等豐富功能的同時保證軟件操作簡潔，易學易用。</li></ul><p><img height="779" src="https://oscimg.oschina.net/oscnet/up-346f799048871759324d7ded950e159fa0d.png" width="1280" referrerpolicy="no-referrer"><img src="https://static.oschina.net/uploads/space/2023/1213/174623_Cjur_2720166.png" referrerpolicy="no-referrer"><img src="https://oscimg.oschina.net/oscnet/up-401cdffba4679c3bdb8ae9bb0feea96f222.png" referrerpolicy="no-referrer"></p><ul></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 09:48:47 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270878</guid>
            <link>https://www.oschina.net/news/270878</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[微軟推出小模型 Phi-2，性能優於 Llama 2/Mistral 7B]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">微軟<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.microsoft.com%2Fen-us%2Fresearch%2Fblog%2Fphi-2-the-surprising-power-of-small-language-models%2F" target="_blank">宣佈</a>推出一個 27 億參數的語言模型 Phi-2，並聲稱其性能可與大 25 倍的模型相匹配或優於。「展示了出色的推理和語言理解能力，展示了參數少於 130 億的基礎語言模型中最先進的性能。」</span></p><p><span style="color:#000000">其基準測試結果表明，只需 27 億個參數，Phi-2 就能在各種綜合基準測試中超越 Mistral 和 Llama-2 模型在 7B 和 13B 參數下的性能。與大 25 倍的 Llama-2-70B 模型相比，Phi-2 在多步推理任務（即編碼和數學）上實現了更好的性能。</span></p><p><span style="color:#000000">此外，Phi-2 的性能與最近發佈的 Google Gemini Nano 2 不相上下，甚至更勝一籌。</span></p><p><img height="179" src="https://oscimg.oschina.net/oscnet/up-195920a0bfb4c87cd5ca00cc5d3edd0c25d.png" width="500" referrerpolicy="no-referrer"></p><p><img height="101" src="https://oscimg.oschina.net/oscnet/up-00457009ea9fb83c5e5802e175d784bd463.png" width="500" referrerpolicy="no-referrer"></p><p>且<span style="background-color:#ffffff; color:#000000">與經過調整的現有開源模型相比，</span><span style="color:#000000">Phi-2 </span><span style="color:#1a202c">響應中的「毒性」和偏差也要更少。</span></p><p><span style="color:#1a202c"><img alt="" height="243" src="https://oscimg.oschina.net/oscnet/up-36ec3b182b6104dcd29d01e7b450d2cb42c.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">此前，谷歌發佈的 Gemini 演示視頻曾展示了其解決複雜物理問題，以及對學生進行糾錯的能力。微軟研究人員也將&nbsp;Phi-2 進行了同樣的測試，並表示它同樣能夠正確回答問題，和使用相同的提示糾錯。</span></p><p><img height="282" src="https://oscimg.oschina.net/oscnet/up-11a57788ae91ebd7277cc00ee2b3ab55339.png" width="500" referrerpolicy="no-referrer"></p><p><span style="color:#000000">Phi-2 是微軟「小語言模型（SLM）」系列中的最新版本。第一個版本是擁有 13 億參數的 Phi-1，針對基本的 Python 編碼任務進行了微調。9 月，該公司將重點擴展到常識推理和語言理解，推出了一個新的 13 億參數模型 Phi-1.5，性能可與大 5 倍的模型相媲美。</span></p><p><span style="color:#000000">微軟表示，Phi-2 的效率使其成為想要探索增強人工智能安全性、可解釋性和語言模型道德發展等領域的研究人員的理想平台。目前，</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fml.azure.com%2Fregistries%2Fazureml-msr%2Fmodels%2Fmicrosoft-phi-2%2Fversion%2F3%3Ftid%3D72f988bf-86f1-41af-91ab-2d7cd011db47%23overview" target="_blank">Phi-2</a><span style="color:#000000"> 現已通過 Microsoft Azure AI Studio 的模型目錄發佈。</span></p><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.microsoft.com%2Fen-us%2Fresearch%2Fblog%2Fphi-2-the-surprising-power-of-small-language-models%2F" target="_blank">查看官方博客</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 06:43:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270831/microsoft-phi-2-small-language-model</guid>
            <link>https://www.oschina.net/news/270831/microsoft-phi-2-small-language-model</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Wi-Fi 7 將於 2024 年初全面登場，速度比 Wi-Fi 6 提升 5 倍]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#262626">WiFi 聯盟<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wi-fi.org%2Fdiscover-wi-fi%2Fwi-fi-certified-7" target="_blank">宣佈</a></u>將在明年 1 月 9 日至 12 日參加 CES 2024，並確認基於 IEEE 802.11be 的 Wi-Fi CERTIFIED 7 認證標準將於第一季度末之前正式推出。</span>與目前的 Wi-Fi 6 標準相比，該標準有望提供千兆位速度和其他改進。</p><p><img src="https://oscimg.oschina.net/oscnet/up-bf8bb1d4062d6abcdd5bde367ecbe4cc108.png" referrerpolicy="no-referrer"></p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0cc0e98c02c1b0b058bc6ac02b0b37ea771.png" referrerpolicy="no-referrer"></p><p>英特爾（Intel）和博通（Broadcom）去年展示的 Wi-Fi 7（也稱 802.11be）速度高達 5 Gbps，大大超過了 Wi-Fi 6 的典型最高速度約 1.7 Gbps。<strong>Wi-Fi 7 允許在 2.4GHz、5GHz 和 6GHz 頻率之間無縫切換</strong>，兼容設備可同時使用這些頻率，從而實現了這一目標。</p><p>此外，6GHz 頻譜可提供 320MHz 的超寬信道，吞吐量比 Wi-Fi 6 翻了一番，這是速度提升的關鍵因素。通過從 1024 QAM 升級到 4K QAM，新標準還將傳輸速率提高了 20%。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-68acdc34185024028d7aabf4f9b688fd47e.png" referrerpolicy="no-referrer"></p><p>Wi-Fi 7 連接也有望比以前的規格更加穩定。多鏈路操作可智能平衡流量，使網絡能有效容納更多設備。聯盟表示，新標準將非常適合增強現實和虛擬現實應用。美國聯邦通信委員會（FCC）最近初步批准了 6GHz 頻譜上的超高速 Wi-Fi 關聯，這是使 VR 和 AR 設備能夠利用 Wi-Fi 7 的重要一步。</p><p>2024 年的推出日期與英特爾 2022 年的預測基本吻合。該公司計劃從明年開始推出支持 Wi-Fi 7 的個人電腦，並於 2025 年在市場上普及。高通公司也對 Wi-Fi 7 持樂觀態度，並將其與 5G 一起納入了 FastConnect 計劃。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 05:55:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270823/wi-fi-certified-7</guid>
            <link>https://www.oschina.net/news/270823/wi-fi-certified-7</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Log4Shell 兩週年，仍有不少項目使用包含漏洞的版本]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Log4Shell 是 Log4j 2.0（Log4J2）的一個 0day 遠程代碼執行漏洞，被定性為「過去十年來最大、最關鍵的漏洞」，最早由阿里巴巴集團於 2021 年 11 月 24 日發現並報告給 Apache 軟件基金會。</p><p>儘管已經過去了兩年，<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.veracode.com%2Fblog%2Fresearch%2Fstate-log4j-vulnerabilities-how-much-did-log4shell-change" target="_blank">但根據安全公司 Veracode 的報告</a></u></strong>，該漏洞的影響仍然存在。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-73861b3642e119baf3ccca3f3a037679b4f.png" referrerpolicy="no-referrer"></p><p>Veracode 分析了 2023 年 8 月 15 日至 11 月 15 日期間 90 天內的軟件掃描數據，針對 3,866 個組織運行 Log4j 版本 1.1 至 3.0.0-alpha1 的 38,278 個獨特應用程序。</p><p>在 Log4j 1.1 到 3.0.0-alpha1 版本中，有超過三分之一的應用程序使用了存在漏洞的 Log4j 版本。具體來説：</p><ul><li>2.8% 的應用程序仍在使用 Log4j2 2.0-beta9 到 2.15.0 之間的版本，這些版本存在 Log4Shell 漏洞。</li><li>另外 3.8% 的應用程序使用的是 Log4j2 2.17.0 版本，雖然該版本已修復了 Log4Shell 漏洞，但仍然存在 CVE-2021-44832 漏洞，這是一個高危的遠程代碼執行漏洞。</li><li>還有 32% 的應用程序使用的是 Log4j2 1.2.x 版本，這個版本在 2015 年 8 月已經停止維護，但在 2022 年 1 月 ASF 宣佈了三個影響該版本的關鍵漏洞。</li></ul><p>這些數據表明，儘管各方對 Log4Shell 漏洞進行了大規模的修復工作，但仍然存在許多應用程序使用了存在漏洞的 Log4j 版本。</p><p>Veracode 的研究還發現，許多開發者在將第三方庫引入到代碼後從未更新過這些庫。這也解釋了為什麼有如此大比例的應用程序在運行已經停止維護的 Log4j 版本。</p><p>此外，研究還發現，一旦開發者通過掃描發現了漏洞，他們通常會相對迅速地進行修復。但是，一些外部因素會拖慢開發人員的修復速度，例如缺乏信息或資源。</p><hr><p>延伸閲讀</p><ul><li><a href="https://www.oschina.net/news/173273/log4j-maintainer-response" target="_blank">Log4j 維護者：為向後兼容沒移除導致漏洞的舊功能</a></li><li><a href="https://www.oschina.net/news/174752/impact-of-apache-log4j" target="_blank">Apache Log4j 漏洞的影響規模</a></li><li><a href="https://www.oschina.net/news/203874/log4j-the-pain-just-keeps-going-and-going" target="_blank">「核彈級」 Log4j 漏洞仍普遍存在，並造成持續影響</a></li></ul></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 03:34:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270803/state-log4j-vulnerabilities-2023</guid>
            <link>https://www.oschina.net/news/270803/state-log4j-vulnerabilities-2023</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Windows 11 記事本的底部狀態欄將顯示「字符數統計」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>Windows 11 內置的文本編輯器「記事本」添加了一項重要功能：在底部狀態欄顯示<strong>字符數統計</strong>。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-876aae8d39e39c30417766c1912f6ab4e65.png" referrerpolicy="no-referrer"></p><p>該功能會顯示使用者輸入的<strong>字符總數</strong>，包括字母、數字、符號、空格、標點符號等。「字符統計」與「字數統計」不一樣，字數統計僅計算文檔中的單詞總數，有人會覺得它比字符數統計更有用。</p><p>根據微軟的<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ghacks.net%2F2023%2F12%2F08%2Fwindows-11s-notepad-is-getting-a-character-count-on-the-status-bar%2F" target="_blank">公告</a></u>，記事本中的字符數統計有兩種工作方式。默認情況下，文本編輯器將在窗口底部的狀態欄上顯示文檔的字符數。如果使用者在文檔中選擇了文本，記事本將分別顯示所選文本的字符數和文檔的總計數。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 03:12:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270799/windows-11s-notepad-character-count-on-the-status-bar</guid>
            <link>https://www.oschina.net/news/270799/windows-11s-notepad-character-count-on-the-status-bar</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[國產數據庫的出現和消失，都不是技術問題]]>
            </title>
            <description>
                <![CDATA[<div class="content"><div><blockquote><p>最近，關於數據庫國產化替代的話題甚是熱門。OSCHINA 開源中國特別邀請了<strong>歐冶雲商股份有限公司數據庫首席薛曉剛</strong>就這一話題發表看法。</p></blockquote><span id="OSC_h2_1"></span><h2><span style="color:#2980b9">為什麼要替代 Oracle?</span></h2><p>去 IOE 的背景，要從阿里巴巴去 IOE 談起，I 是 IBM 小型機大型機，O 是 Oracle 數據庫，E 是 EMC 存儲。這幾個搭配起來使得阿里輕鬆走過了最初的技術發展階段。這個配置組合也是當年這條街最靚的仔。這個穿搭在大型銀行和運營商中也很常見。這種組合的好處是就穩定，而且非常穩定。<strong>缺點可能只有一個，就是貴。</strong></p><p>隨着阿里業務的增加，阿里人考慮繼續這樣使用的成本很高。再加上阿里開始了雲計算的規劃，所以提出了去 IOE 的口號。這個在其他互聯網公司是不可能有的。因為其他互聯網公司一開始就沒有 IOE 所以不需要去。只有阿里一開始的架構是這樣的。所以只有阿里提出了。</p><p>阿里做阿里雲，希望用戶上雲。上雲的核心就是數據上雲。數據上雲後存在哪裏？自然是數據庫中，如果用的數據庫是 Oracle 的，那麼可能要分給 Oracle 利潤（要採購許可）。所以阿里打算用 MySQL 以及後來自研替代 Oracle。</p><p>從最開始的去 IOE，直到現在還經常看到各種大會上提到去 O，這用了十幾年，去掉了 I 和 E。有些企業完成了去 O，而有些企業還在使用 O。</p><p><strong>那麼為什麼只提去 O，那不用去 DB2 和 SQLServer 嗎？本質上也要去的。</strong>只是其他的數據庫不如 Oracle 的使用廣泛，例如現在使用和維護 DB2 的人是很少了。之所以沒人提去 DB2，是因為從總體來説 DB2，已經被去掉了。所以狹義去 O 是去掉 Oracle 數據庫，而廣義的去 O 其實可以擴大為去 M（美國化）。</p><p>在今天不少人觀點認為用 MySQL 去替代 Oracle 是無意義的。因為 MySQL 和 Oracle 同屬於甲骨文公司。甚至在有的場閤中還會提到要去掉 MySQL。</p><span id="OSC_h2_2"></span><h2><span style="color:#2980b9">當前數據庫國產化進程情況如何?</span></h2><p>當前在信創和安可這些趨勢下，國產數據庫如雨後春筍般出現。在國內某權威數據庫排行榜上，已經有 280 多個數據庫了。實際上的數字可能比這個還要多一點。</p><p>在一些政府、金融、運營商行業都有一些國產化替換。這些替換其實不僅僅是數據庫了，還包括服務器、CPU、操作系統等等。從宣傳上看有些是全棧替換，有些是部分替換。也還有一些公司或者企業沒有替換。然而這些都是國產廠商的宣傳，至於實際的替換情況只有用戶自己知道。而即使替換的用戶也沒有進行相關的宣傳，這就使得整個情況非常的模糊。不過這個過程還在繼續，還是會有一些系統從 Oracle、DB2、SQLServer 等數據庫切換到國產化上來的。只是現在不確定因素太多了。</p><p>今年年初，TiDB、TDengine、TDSQL、OceanBase 四位數據庫界掌門人在一場直播中大致達成一致，三年後在中國健康運營的數據庫不超過 20 家。所謂健康運營是，企業能有正常營收，員工發薪正常。目前國產數據庫有 280 多個產品，有的一個公司有幾個產品。即使這樣也是有絕大部分產品或者公司會因為無法盈利而退出舞台。用戶現在也意識到了這一點，也在等情況明朗後再去選擇。沒有企業願意看到花了很大代價切換的數據庫無人維護了，不得不繼續再次替換。</p><p>國產數據庫有完全自研的，例如達夢、OceanBase 等，也有一些是基於 MySQL 做改造的，還有一些事基於 PostgreSQL 改造的，還有購買外國源碼然後進行修改的。</p><span id="OSC_h2_3"></span><h2><span style="color:#2980b9">替代 Oracle 的難點在哪裏?</span></h2><p>技術上，Oracle 確實領先，在數據庫領域是一個標杆一樣的存在。即使我們國產數據庫的頭部企業都認為自己和 Oracle 有較大的差距，作為學習者不斷地在向 Oracle 學習。</p><p>Oracle 領先的其實不僅僅是技術，還有設計理念和前瞻性。2020 年信通院發佈的白皮書中寫了數據庫的未來幾大趨勢，而在那時候這幾個趨勢當時 Oracle 已經部分實現和深度實現了。其實 Oracle 產品線很多，不僅僅是數據庫。其中間件、硬件、操作系統等等是全方面的輸出。</p><p><strong>具體到幾個方面：</strong></p><p><strong>兼容性</strong><strong>。</strong>對於替換國產數據庫，兼容性是一件繞不開的話題，特別是對於存量系統來説，大多數重要系統是運行在 Oracle 數據庫上的，那麼對於 Oracle 的<strong>基本</strong><strong>SQL</strong><strong>語法、</strong><strong>PL</strong><strong>/SQL、存儲過程、觸發器等</strong>的兼容性肯定是十分重要的，畢竟這涉及代碼變更的問題。如果在國產數據庫替換過程中出現業務適配新數據庫代碼變更量太大、數據庫功能缺失需要業務側代碼補充、適配分佈式數據庫過程中對數據庫設計和業務邏輯變更等現象的話，開發層面對國產數據庫的牴觸會非常大。</p><p><strong>性能。</strong>性能和硬件以及優化器都有很大的關係。優化器這方面目前沒有能超過 Oracle 優化器的。因為這些底層都是數學算法。2021 年信通院發佈的數據庫發展白皮書顯示，我國數據庫企業針對數據庫領域的平均專利數量（含國內外專利）為 38 個，最高為 500 個左右規模，數量為 0 的企業個數是 19 個，佔比 24%。擁有專利數 0-4 個的企業佔比最高為 51%，專利數 5-10 個的企業次之，佔比 14%，專利數 21-50 個的企業數量排名第三，佔比 12%。從企業專利數量上看，Oracle 以 1.4 萬個全球領先，SAP 居次席。</p><p><strong>穩定性。</strong>Oracle 的穩定性還是毋庸置疑的，這也就是為什麼在過去那麼多年中，其一直佔據着領導地位，以及使用如此廣泛。企業負責人都不希望看到自己的數據庫經常出問題，每次數據庫的問題都可能導致故障，從而影響到在線業務。不僅僅要面對直接和間接的經濟損失，還有問責的壓力。</p><p>Oracle 等國外數據庫有足夠的全球市場，專心在技術上投入做數據庫，而國產數據庫廠商只能在國內有限的數據庫市場內卷，需要投入大量的內卷、惡性競爭和關係處理上，無法專心把全部精力放在做數據庫上。甚至還是為瞭如何生存而謀劃。</p><p>國產數據庫的出現並不是技術問題，而是其他因素。</p><p>數據庫領域的人都知道，在信創活動結束之後就沒有替換動力了。而最終國內市場無法容得下幾百家供應商，所以大部分國產數據庫的消失也不是技術問題。</p><span id="OSC_h2_4"></span><h2><span style="color:#2980b9"><strong>有哪些能夠替代 Oracle 的國產數據庫？</strong></span></h2><p>這個替代要講清楚是怎麼替代？如果説就是把系統關停，然後把數據導過來，然後再修改數據庫的連接字符串就可以和之前一樣正常使用而且穩定的。目前沒見過也沒聽説過。</p><p>如果説換了一個國產數據庫，然後把鏈接這個數據庫的所有業務系統的軟件代碼進行修改（這個修改可能是 30-100%），即軟件重寫適配數據庫或者部分需求和功能放棄，那麼這樣的替換還是有一些的。OceanBase、TiDB、TDSQL 等都有在不同程度上有，具體的都是應實際情況而定。</p><p>這些替換的優勢，可能在於滿足了政治要求。</p><p><strong>這些替換的劣勢，有多方面：</strong></p><p>由於同等硬件下不如 Oracle 的性能，所以增加硬件導致成本的上升。或者分佈式數據庫的硬件就是比集中式硬件的多導致的硬件成本上升。</p><p>由於數據庫特性和功能的缺失，所以應用程序需要改造的成本上升。這部分可能佔替換總成本的 60%-80%。因為這是調動大量應用開發人員重寫適配的過程。</p><p>由於穩定性上不如 Oracle，所以需要增加大量運維人員，導致運維的成本上升。</p><p>由於部分國產數據庫需要許可才可以運行，所以增加了大量的許可費用。相比較之前很少採購 Oracle 許可或者甚至不採購許可來説，這部分採購費用佔比很大。</p><p>以上這些成本可能會是使用 Oracle 數據庫的數倍甚至幾十倍甚至上百倍。而很多計算中都忽略了第二和第三項的成本。</p><span id="OSC_h2_5"></span><h2><span style="color:#2980b9">現有國產數據庫跟 Oracle 相比，有多大的差距?</span></h2><p>從技術上來説，我們和 Oracle 相比有代差。</p><p>可能不同的人有不同的見解。我個人感覺有以下多方面的差距（但是不限於此）：</p><p><strong>數據庫的</strong><strong>優化器</strong><strong>上：</strong>有人説為什麼 Oracle 快，你可能不知道多少滿頭白髮的數學教授在那裏研究着這些。有人説：你別逼我，逼急了我什麼都做的出來。」 「是嗎？，那你把這道數學題給做做？」 人被逼急了還真不是什麼都做的出來，起碼數學就不是。各種複雜查詢的核心是優化器和統計信息。而這全部都是數學問題。沒有在數學上的基礎投入是無法在這個領域攻堅克難的。</p><p><strong>體系架構上：</strong>如今越來越多的國產數據庫考慮 RAC 架構。在經歷了互聯網的分佈式數據庫的洗禮後，越來越多的用戶覺得集中式更加適合自己。所以才有了各種國產數據庫廠商開始實現 RAC 的計劃，達夢、優炫等。即使分佈式數據庫廠商在研發過程中發現 Oracle 的各種體系設計，沒有一個是多餘的，都是設計極其精妙的。而這些很多設計都是 30 年前甚至更早就已經設計到位的。</p><p><strong>與</strong><strong>操作系統</strong><strong>的融合上：</strong>數據庫是運行在操作系統之上的，如何與 CPU 打交道？SQL 調用指令集的多少都是有講究的。甚至有些操作是繞過操作系統直接操作的。這些都是需要深耕操作系統才能解決的。</p><p><strong>與硬件的融合上：</strong>數據庫必然要和存儲設備打交道。數據庫的優化幾乎等同於 IO 優化。所以 Oracle 直接做出來自己的存儲。這些存儲上都是帶有 CPU 的，更好的存儲和讀取數據上發揮了很大的作用。做數據庫是從上至下的深入解決。</p><p><strong>趨勢把握上：</strong>數據庫的多模和超融合這些都是 Oracle 在引領着數據庫技術的前進方向。我們定義為趨勢的，Oracle 基本都是已經實現的。而很多理念從設計到實現需要 8-10 年的過程。</p><span id="OSC_h2_6"></span><h2><span style="color:#2980b9"><strong>國產數據庫未來要怎麼走?</strong></span></h2><p>我個人角度認為，應該靜下心來踏實的做技術。</p><p>最好是沒有政治因素的幹擾去市場上競爭，避免大躍進式的百家齊放，而是規範市場，讓國內外數據庫廠商同台競爭。用戶結合自己的預算進行抉擇，是選擇廉價的還是性價比高的，讓一切迴歸到技術本身來。而不能用政策限制其他產品進入，只能強制使用國產。這樣會導致自我封閉和外部的排斥。既然我們用政策限制其他人，那麼對等的就會出現別人限制我們。從而更加無法走出去。</p><p>如果真正能走出去，在國外用得起來，那麼就是國產數據庫的成功。中國的高鐵就是因為走出去了才成為了中國的一張名片。</p><blockquote><p><strong>作者簡介：</strong></p><p>薛曉剛，現任歐冶雲商股份有限公司數據庫首席。曾服務於政府、公安、交通、安防行業，從事過大型項目管理，設計和運維多個單表 100 億，單機 100TB 的數據庫。目前負責高可用、業務連續性和高併發數據架構設計和運維管理。</p><p>Oracle ACE-Pro（Oracle 和 MySQL 方向），Oracle OCP/MySQL OCP 及 OCP 講師。PostgreSQL 的 PGCE 和 PCP 認證，PostgreSQL ACE Partner。墨天輪 MVP，TiDB MVA，ITPUB 論壇內存數據庫版主、核心專家、金牌顧問，墨天輪社區特聘金牌講師，機械工業出版社專家委員會委員。</p><p><img height="483" src="https://oscimg.oschina.net/oscnet/up-db67ea17186e0146cd30e998dbd09b31b55.png" width="500" referrerpolicy="no-referrer"></p><p><strong>聯繫作者：</strong></p><p><img height="249" src="https://oscimg.oschina.net/oscnet/up-783ed80bb94f3f8e33fb256e9e56a3413e6.png" width="500" referrerpolicy="no-referrer"></p></blockquote><p>&nbsp;</p></div></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 03:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/3859945/blog/10321019</guid>
            <link>https://my.oschina.net/u/3859945/blog/10321019</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[FFmpeg CLI 支持多線程 —— 數十年來「最複雜的重構」]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>FFmpeg CLI 近日迎來重大改進 —— 合併了<strong><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fffmpeg.org%2Fpipermail%2Fffmpeg-devel%2F2023-November%2F316552.html" target="_blank">多線程轉碼管道</a></u>&nbsp;</strong>(multi-threaded transcoding pipelines)，預計在明年發佈的&nbsp;FFmpeg 7.0 中提供。</p><p><img src="https://oscimg.oschina.net/oscnet/up-69e8f13ce3a5ed36727e8f9c13a6d4cf9a0.png" referrerpolicy="no-referrer"></p><p>來源：<u><em><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fffmpeg.org%2Findex.html%23cli_threading" target="_blank">https://ffmpeg.org/index.html#cli_threading</a></em></u></p><p>其開發團隊表示，這項工作是「數十年來 FFmpeg CLI 最複雜的重構之一」，主要內容包括添加了線程感知的轉碼調度基礎設施、將編碼任務移動到獨立線程，以及各種其他底層更改。這意味着 FFmpeg 現在可以實現並行處理任務，這將提高吞吐量和 CPU 利用率，降低延遲。</p><p><img alt="" src="https://oscimg.oschina.net/oscnet/up-0f082465774090329fe668d4160939f9c33.png" referrerpolicy="no-referrer"></p><p>來源：<em><u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fup.khirnov.net%2F7m.pdf" target="_blank">https://up.khirnov.net/7m.pdf</a></u></em></p><p>據介紹，這次更新並不是針對編解碼器本身進行多線程處理，因為現代編解碼器通常已經支持多線程處理。相反，FFmpeg 決定並行化的是 ffmpeg 本身，包括過濾器等。這意味着 FFmpeg CLI 現在可以更高效地處理視頻轉碼任務。</p><p>Hacker News 上有開發者提出了一些關於視頻編碼的<u><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D38613219" target="_blank">想法</a></u>，例如將關鍵幀分段獨立處理，以實現更好的多核性能。這種方法可以在一定程度上提高編碼效率，但也需要考慮內存和編碼邏輯的複雜性。</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:29:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270790/ffmpeg-cli-multi-threading-merged</guid>
            <link>https://www.oschina.net/news/270790/ffmpeg-cli-multi-threading-merged</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[開源之夏 2023 圓滿落幕，共同點亮開源新星]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><strong><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#494949">1</span></span></span><span><span><span style="color:#494949">2</span></span></span><span><span><span style="color:#494949">月</span></span></span><span><span><span style="color:#494949">8</span></span></span><span><span><span style="color:#494949">日，隨着年度優秀學生名單的公示，開源之夏 2</span></span></span><span><span><span style="color:#494949">023</span></span></span><span><span><span style="color:#494949">圓滿落幕。從 3 月到 1</span></span></span><span><span><span style="color:#494949">2</span></span></span><span><span><span style="color:#494949">月，伴隨着四季推進，開源之夏 2</span></span></span><span><span><span style="color:#494949">023</span></span></span><span><span><span style="color:#494949">見證了數百位高校開發者如星星之火閃爍在眾多開源項目中以及他們在漫長開源之旅中留下的足跡，也見證了更多優秀的開源貢獻者和開源項目的應運而生。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p><p><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#494949">開源之夏&nbsp;2023&nbsp;由中國科學院軟件研究所與&nbsp;openEuler&nbsp;社區聯合主辦，</span></span></span><span><span><span style="color:#494949">中科南京軟件技術研究院承辦，旨在</span></span></span><span><span><span style="color:#494949">鼓勵在校學生積極參與開源軟件的開發維護，促進優秀開源軟件社區的蓬勃發展，助力開源軟件供應鏈建設，讓開源的力量薪火相傳</span></span></span><span><span><span style="color:#494949">，是中國科學院軟件研究所「開源軟件供應鏈點亮計劃」指導下的重點年度活動。</span></span></span><span><span><span style="color:#494949">本屆</span></span></span><span><span><span style="color:#494949">開源之夏</span></span></span><span><span><span style="color:#494949">聯合</span></span></span><span><span><span style="color:#494949">1</span></span></span><span><span><span style="color:#494949">33</span></span></span><span><span><span style="color:#494949">家國內外活躍的開源社區，</span></span></span><span><span><span style="color:#494949">針對其重要開源軟件的開發與維護任務，面向全球高校學生髮布項目 593 個</span></span></span><span><span><span style="color:#494949">，</span></span></span><span><span><span style="color:#494949">覆蓋操作系統、人工智能、大數據、web、內核與編譯器、分佈式、雲原生、RISC-V 等熱門技術方向。</span></span></span><span><span><span style="color:#494949">時至第四屆，</span></span></span><span><span><span style="color:#494949">開源之夏吸引了</span></span></span><span><span><span style="color:#494949">越來越多遍佈國內外</span></span></span><span><span><span style="color:#494949">的年輕開發者參與開源社區、貢獻開源。2023</span></span></span><span><span><span style="color:#494949">年，來自海內外 5</span></span></span><span><span><span style="color:#494949">92</span></span></span><span><span><span style="color:#494949">所高校的 3</span></span></span><span><span><span style="color:#494949">000</span></span></span><span><span><span style="color:#494949">多位學生參與開源之夏，</span></span></span><span><span><span style="color:#494949">504&nbsp;名學生</span></span></span><span><span><span style="color:#494949">成功</span></span></span><span><span><span style="color:#494949">中選，開啓開源之旅。歷經&nbsp;3&nbsp;個月的項目開發時間，最終，418&nbsp;份項目成果通過結項考覈，累計產出併合並 1236 個 PR，成果陸續納入社區主線並上線發佈</span></span></span><span><span><span style="color:#494949">，隨着版本更新在華為、阿里、字節、京東、騰訊、網易等企業落地應用。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#494949">為了鼓勵同學們，</span></span></span><span><span><span style="color:#494949">經開源社區和導師推薦，本年度</span></span></span><span><span><span style="color:#494949">組委會</span></span></span><span><span><span style="color:#494949">繼續</span></span></span><span><span><span style="color:#494949">從&nbsp;4&nbsp;個方向評選出具有代表性的&nbsp;20&nbsp;位優秀學生。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p><strong><span><span><span style="color:#494949">最佳質量獎為項目角度的評選獎項，側重項目完成質量、代碼的可讀性、文檔的完整度使得項目具有可延續性。</span></span></span></strong></p></li><li><p><strong><span><span><span style="color:#494949">突出貢獻獎為社區角度的評選獎項，側重學生對社區的貢獻度、完成項目對社區的重要性等。</span></span></span></strong></p></li><li><p><strong><span><span><span style="color:#494949">最快進步獎為學生角度的評選獎項，側重學生參與活動的進步程度和快速學習能力。</span></span></span></strong></p></li><li><p><strong><span><span><span style="color:#494949">最具潛力獎為開源角度的評選獎項，側重學生展現出未來持續貢獻開源的潛力和意願。</span></span></span></strong></p></li></ul><p>&nbsp;</p><p><img alt="" height="539" src="https://oscimg.oschina.net/oscnet/up-76644ac7087ce5b6c9b434dfb2567ba28a3.png" width="1252" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><img alt="" height="517" src="https://oscimg.oschina.net/oscnet/up-53e663e573fe0f8ad1bd9fae6d3e99e51f5.png" width="1216" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><img alt="" height="496" src="https://oscimg.oschina.net/oscnet/up-5f9ee24a1414766db22103aff87af28ef7b.png" width="1235" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><span><span><span><span style="color:#000000"><span><span><span><span><span><span><span><span><span><span><span><span><span style="color:#494949">一年活動的結束並不意味着開源參與的結束</span></span></span><span><span><span style="color:#494949">，大批新生的開源力量</span></span></span><span><span><span style="color:#494949">不斷湧現並持續貢獻</span></span></span><span><span><span style="color:#494949">。</span></span></span><span><span><span style="color:#494949">開源之夏 2</span></span></span><span><span><span style="color:#494949">023 調研結果顯示，結項後繼續留在開源社區參與開發貢獻的學生</span></span></span><span><span><span style="color:#494949">高達 8</span></span></span><span><span><span style="color:#494949">0%</span></span></span><span><span><span style="color:#494949">。</span></span></span><span><span><span style="color:#494949">這些高校開發者在已有項目成果的基礎上不斷擴展貢獻範圍，有效保證</span></span></span><span><span><span style="color:#494949">了</span></span></span><span><span><span style="color:#494949">相關成果的連續性與維護性，並</span></span></span><span><span><span style="color:#494949">逐漸</span></span></span><span><span><span style="color:#494949">成長為開源項目的核心開發者。</span></span></span><span><span><span style="color:#494949">學生在開源之夏參與高質量工業化的開源項目實踐，瞭解最前沿的技術趨勢，與社區導師、資深開發者建立聯繫，獲取更多的實踐經驗，為自己的職業發展打下堅實基礎。同時開源社區也在活動中發掘、培養優秀開發者，完善社區建設，助力開源生態繁榮發展。讓我們共同期待未來星光熠熠的開源之天空！</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:27:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270788</guid>
            <link>https://www.oschina.net/news/270788</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[院士領銜，Linux 操作系統多語言支撐技術研討會在成都成功舉行！]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>2023 年 12 月 10 日，由西藏大學、內蒙古大學、青海師範大學、四川大學、電子科技大學、國防科技大學、麒麟軟件有限公司、成都聯圖科技有限公司等單位聯合舉辦，openKylin 社區承辦的《Linux 操作系統多語言支撐技術研討會》在成都召開！本次會議由中國工程院院士、openKylin 社區諮詢委員會委員尼瑪扎西教授擔任主席，openKylin 社區祕書長餘傑研究員擔任主持。參會專家圍繞 Linux 操作系統的多語言支持現狀、不足和未來規劃等進行深入探討，並研討操作系統如何助力國家更好地實現一帶一路戰略。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:center"><img alt="" height="517" src="https://oscimg.oschina.net/oscnet/up-7d7650099c002fecddf0ea48dc0d0aeae2f.jpg" width="853" referrerpolicy="no-referrer"></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>首先，openKylin 社區技術委員會委員李劍峯就 openKylin 操作系統多語言版本情況向與會專家進行彙報，介紹了多語言操作系統的發佈情況、版本特性、平台架構以及未來規劃。未來，openKylin 操作系統將繼續擴展多語言支持，包括外語拓展、少數民族語言擴展，進一步優化多語言框架，研製國內領先、國際先進的多語言支撐平台，提升我國信息領域技術核心競爭力。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>隨後，參會專家圍繞當前 Linux 操作系統多語言版本進行了發言。他們主要表示了要完善操作系統生態的必要性，包括辦公軟件的完善，集成當前主流的智能 AI 框架和大語言模型，以掌握 AI 操作系統的話語權。此外，他們還提出了進一步優化翻譯平台和翻譯機制的建議，並強調加強推廣多語言操作系統版本的重要性。</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"><span>最後，尼瑪扎西院士就本次會議進行總結髮言。他強調，提高我國基礎軟件競爭力需採取有效策略，充分利用豐富的語言文字資源，積極響應國家需求，開發實用、好用的多語言操作系統，推動我國科技創新和發展。</span><span>我國 Linux 操作系統要紮根中國、</span><span>揚帆出海！</span></p><p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:center"><img alt="" height="855" src="https://oscimg.oschina.net/oscnet/up-b67751709c8cc8e9f16b3e4e388f03eaff0.jpg" width="1280" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:18:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270783</guid>
            <link>https://www.oschina.net/news/270783</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[HyperDX —— 開發者友好的 Datadog 替代品]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>HyperDX&nbsp;是<span style="background-color:#ffffff; color:#1f2328">一個</span>基於雲的生產監控和調試工具<span style="background-color:#ffffff; color:#1f2328">，統一會話重放、日誌、指標、跟蹤和錯誤。</span>通過將日誌、指標、跟蹤、異常和會話重播集中並關聯到一處，幫助工程師更快地找出生產中斷的原因。Datadog 和 New Relic 的開源且開發人員友好的替代方案。</p><ul><li>端到端關聯，只需點擊幾下即可從瀏覽器會話重放到日誌和跟蹤</li><li>由 Clickhouse 提供支持的極快性能</li><li>直觀的全文搜索和屬性搜索語法（例如<code>level:err</code>）</li><li>自動對數十億個事件中的事件模式進行聚類</li><li>儀錶板高基數事件，無需複雜的查詢語言</li><li>只需點擊幾下即可設置警報</li><li>自動解析 JSON/結構化日誌</li><li>OpenTelemetry native</li></ul><p><img height="702" src="https://static.oschina.net/uploads/space/2023/0920/163847_4VuB_4252687.png" width="1220" referrerpolicy="no-referrer"></p></div>
                                                                ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:08:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/hyperdx</guid>
            <link>https://www.oschina.net/p/hyperdx</link>
        </item>
        <item>
            <title>
                <![CDATA[小米迴應餘承東「龍骨轉軸」抄襲華為言論]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p>「小米公司發言人」官方微博近日發佈聲明，就餘承東所述「龍骨轉軸」抄襲華為言論做出澄清稱：</p><blockquote><p>近日，餘承東先生無端針對我司龍骨轉軸技術發佈不實言論，與事實嚴重不符。我們請餘承東先生遵循「科學與嚴謹」的基本規則，請勿再抹黑同行、誤導公眾。</p></blockquote><p>聲明指出，無論是設計思路還是機械結構，小米自研的龍骨轉軸與餘承東所宣稱的所謂雙旋水滴較鏈都完全不同。</p><p>且龍骨轉軸於 2020 年 9 月 18 日申請專利，並於 2021 年 1 月 5 日獲得專利授權，在 2023 年 8 月於 XiaomiMIXFold 了上首發應用。雙旋水滴較鏈則於 2019 年 12 月 13 日申請的專利，2021 年 6 月 18 日才公開。「由此可知，餘承東先生的言論，完全不符合事實。」</p><p><img alt="" height="1349" src="https://oscimg.oschina.net/oscnet/up-31b05e591ed808bedd4150f1214bc51f38d.jpg" width="500" referrerpolicy="no-referrer"></p><p>專利圖：</p><p><img alt="" height="368" src="https://static.oschina.net/uploads/space/2023/1213/100457_fh3o_4252687.jpg" width="500" referrerpolicy="no-referrer"></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 02:04:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270776</guid>
            <link>https://www.oschina.net/news/270776</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[Gitee 推薦 | 物聯網智能網關係統，物聯大師]]>
            </title>
            <description>
                <![CDATA[<h1><a id="物聯大師" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E7%89%A9%E8%81%94%E5%A4%A7%E5%B8%88"></a>物聯大師</h1><p><strong>注意，[V3.0]版本與<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Ftree%2Fv2">V2.0</a>
和<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Ftree%2Fv1">V1.0</a>有較大差異，不可以直接升級！！！</strong></p><h3><a id="説明文檔--演示 demo-賬號密碼-admin-123456" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3--%E6%BC%94%E7%A4%BAdemo-%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81-admin-123456"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fiot-master.com%2Fmanual">説明文檔</a><a href="https://gitee.com/link?target=http%3A%2F%2Fdemo.iot-master.com%3A8080%2F">演示 demo</a> 賬號密碼 admin 123456</h3><p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Factions%2Fworkflows%2Fgo.yml"><img src="https://github.com/zgwit/iot-master/actions/workflows/go.yml/badge.svg" alt="Go" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Factions%2Fworkflows%2Fcodeql-analysis.yml"><img src="https://github.com/zgwit/iot-master/actions/workflows/codeql-analysis.yml/badge.svg" alt="Go" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fcodecov.io%2Fgh%2Fzgwit%2Fiot-master"><img src="https://codecov.io/gh/zgwit/iot-master/branch/main/graph/badge.svg?token=AK5TD8KQ5C" alt="codecov" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fpkg.go.dev%2Fgithub.com%2Fzgwit%2Fiot-master"><img src="https://pkg.go.dev/badge/github.com/zgwit/iot-master.svg" alt="Go Reference" referrerpolicy="no-referrer"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fgoreportcard.com%2Freport%2Fgithub.com%2Fzgwit%2Fiot-master"><img src="https://goreportcard.com/badge/github.com/zgwit/iot-master" alt="Go Report Card" referrerpolicy="no-referrer"></a></p><p>物聯大師是<a href="https://gitee.com/link?target=https%3A%2F%2Flabs.zgwit.com">無錫真格智能科技有限公司</a>
推出的開源且免費的物聯網操作系統，內置 MQTT、TCP Server/Client、UDP Server/Client、串口等接入服務，
系統集成標準 Modbus，水務（SL651、SZY206），電力（DL/T645、IEC101、102、103、104、61850）以及一些主流 PLC 協議，
系統可以通過插件支持數據採集、公式計算、定時控制、異常報警、自動控制策略、流量監控、遠程調試、Web 組態等功能，
適用於大部分物聯網或工業互聯網應用場景。
系統採用 Golang 編程實現，支持多種操作系統和 CPU 架構，可以運行在智能網關上，也可以安裝在現場的電腦或工控機上，還能部署到雲端服務器。</p><p>項目摒棄複雜的平台架構思維，遠離微服務，從真實需求出發，注重用戶體驗，做到簡捷而不簡單，真正解決物聯網缺乏靈魂的問題。</p><p>我們的宗旨是：<strong>讓物聯網實施變成一件簡單的事情!!!</strong></p><h2><a id="項目的優勢" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BC%98%E5%8A%BF"></a>項目的優勢</h2><ul><li>開源免費，商業應用也不限制</li><li>單一程序文件，不需要配置運行環境，不依賴第三方服務，放服務器上就能跑</li><li>極小內存佔用，對於一百節點以內的物聯網項目，只需要幾十兆內存足夠了，<del>比起隔壁 Java 動輒大幾百兆內存簡直太省了</del></li><li>支持工控機和智能網關，邊緣計算也沒問題</li><li>支持大屏展示，Web 組態，3D 數據孿生 <del>畢竟很多物聯網項目都是面子工程</del></li><li>在線產品庫、模板庫、組件庫，小白也能分分鐘搞得有模有樣【還在努力建設中】</li></ul><h2><a id="項目示例" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E9%A1%B9%E7%9B%AE%E7%A4%BA%E4%BE%8B"></a>項目示例</h2><p><img src="https://iot-master.com/web1.jpg" alt="web" referrerpolicy="no-referrer"><img src="https://iot-master.com/hmi-editor.png" alt="scada" referrerpolicy="no-referrer"></p><h2><a id="諮詢服務" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E5%92%A8%E8%AF%A2%E6%9C%8D%E5%8A%A1"></a>諮詢服務</h2><p><strong>本公司目前提供免費的物聯網方案諮詢服務，結合我們十多年的行業經驗，給您提供最好的建議，請聯繫 15161515197（微信同號）</strong></p><blockquote><p>PS. 提供此服務的主要目的是讓用戶少走彎路，為物聯網行業的健康發展盡綿薄之力。
總結一下常見的彎路：</p><ol><li>前期使用某個物聯網雲平台，後期沒辦法繼續，二次開發受限</li><li>花了幾千元買了工業網關，用着一百元 DTU 的功能</li><li>找多個外包公司，低價拿單，結果做出屎一樣的東西</li><li>盲目使用開源項目，最終被開源項目所累</li><li>硬件選型失敗，效果差強人意</li><li>自身技術人員能力有限，架構設計有問題</li><li>不支持高併發量，市場爆發了，平台反而跟不上</li><li>等等</li></ol></blockquote><h2><a id="聯繫方式" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F"></a>聯繫方式</h2><ul><li>郵箱：<a href="mailto:jason@zgwit.com">jason@zgwit.com</a></li><li>手機：<a>15161515197</a>(微信同號)</li></ul><table><thead><tr><th>技術交流羣</th><th>微信</th></tr></thead><tbody><tr><td><img src="https://iot-master.com/tech.png" alt="微信羣" referrerpolicy="no-referrer"></td><td><img src="https://iot-master.com/jason.jpg" alt="微信" referrerpolicy="no-referrer"></td></tr></tbody></table><h2><a id="開源協議" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE"></a>開源協議</h2><p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fzgwit%2Fiot-master%2Fblob%2Fmain%2FLICENSE">GPL v3</a></p><p>補充：任何組織或個人都可以免費使用或做二次開發，但不得用於商業售賣，如有需求請聯繫我們。</p><h3><a id="官方插件" class="anchor" href="https://gitee.com/zgwit_labs/iot-master#%E5%AE%98%E6%96%B9%E6%8F%92%E4%BB%B6"></a>官方插件</h3><p><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Forgs%2Fiot-master-contrib%2Frepositories">插件庫</a></p><table><thead><tr><th>插件</th><th>完成</th><th>正式版</th></tr></thead><tbody><tr><td>歷史統計【內置】</td><td>✅</td><td>⬜</td></tr><tr><td>異常報警【內置】</td><td>✅</td><td>⬜</td></tr><tr><td>Influxdb 時序數據庫</td><td>✅</td><td>⬜</td></tr><tr><td>Modbus 通訊協議</td><td>✅</td><td>⬜</td></tr><tr><td>WebRTC 接入攝像頭</td><td>✅</td><td>⬜</td></tr><tr><td>Web 組態</td><td>✅</td><td>⬜</td></tr><tr><td>3D 數據孿生</td><td>⬜</td><td>⬜</td></tr><tr><td>阿里雲通知</td><td>✅</td><td>⬜</td></tr><tr><td>DLT645-2007，電力規約</td><td>⬜</td><td>⬜</td></tr><tr><td>西門子 PLC，S7 系統，PPI，MPI，FetchWrite</td><td>✅</td><td>⬜</td></tr><tr><td>三菱 PLC</td><td>✅</td><td>⬜</td></tr><tr><td>歐姆龍 PLC，Hostlink，Fins</td><td>✅</td><td>⬜</td></tr><tr><td>TDEngine</td><td>⬜</td><td>⬜</td></tr><tr><td>OpenTSDB</td><td>⬜</td><td>⬜</td></tr><tr><td>流式計算</td><td>⬜</td><td>⬜</td></tr><tr><td>報表引擎</td><td>⬜</td><td>⬜</td></tr></tbody></table>]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 01:57:00 GMT</pubDate>
            <guid isPermaLink="false">https://gitee.com/zgwit_labs/iot-master</guid>
            <link>https://gitee.com/zgwit_labs/iot-master</link>
        </item>
        <item>
            <title>
                <![CDATA[每日一博 | 雙十一彈性能力支撐 - ECI 穩定性建設]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h3_1"></span><h3>一、關於 ECI</h3><p style="text-align:justify">背景從 2018 年正式發佈，<strong>ECI 已經打磨了整整 4 個年頭</strong>，如今也已經快速成長為了阿里雲 serverless 容器的基礎設施，服務着阿里內外眾多的公有云客戶與雲產品，每天承接着數百萬的彈性容器創建。</p><p style="text-align:justify">然而，ECI 這些年卻未參與到集團雙十一大促，雙十一可以説是阿里技術人的閲兵，能不能承接住雙十一的流量成為了檢驗一個產品是否穩定可靠的重要標準。但一切都是水到渠成，就在今年，ASI 開始與 ECI 對接，嘗試讓 ECI 承接雙十一大促的彈性的 30W 覈算力，我們都知道雙十一大促對於整個阿里集團的意義，使命將至，我們必將全身心地投入到對接、壓測、護航的工作中。經過長達兩個多月的業務適配、壓測、備戰，最終完成了雙十一大促的彈性容器的圓滿交付。這背後，離不開 ASI、ECI 以及參與到其中的每一位腳踏實地、用心鑽研、保駕護航的同學的努力。ECI 今年首次作為集團大促彈性基礎設施，根據線上數據統計，大促期間 ECI 彈性資源使用共計約 400W 核，從資源的瞬時彈性、保有規模、系統穩定性等多方面對雲原生系統都是一次巨大的考驗。作為底層的計算單元，ECI 此次也成功頂住了雙十一彈性流量洪峯的考驗，在感嘆 serverless、容器這些技術發展迅猛的同時，對於全新的系統架構穩定性的考驗也不小。</p><p style="text-align:justify">如今再回過頭來看 ECI 的第一次雙十一，我們有必要做一次全面的總結，我們為集團彈性保障做了哪些工作，哪些是將來可以複用的工作，哪些是可以給其他的團隊作為借鑑的技術和經驗，以及哪些地方還可以做的更好，為下一次大促做準備。</p><p style="text-align:justify">本文我們將為大家介紹，<strong>ECI 這些年在穩定性方面做了哪些工作，以及是如何來為集團雙十一保駕護航的。</strong></p><span id="OSC_h3_2"></span><h3>二、遇到的挑戰</h3><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-484afd33bc5b8c5f4774ab7fddf53a98_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">大規模併發帶來的穩定性挑戰遇到的最大挑戰首先是大規模併發帶來的。容器保有量增多之後，從容器實例生產方面來看對於雲管控系統是不小的考驗，尤其是對於彈性場景來講，需要在極短的時間進行實例的生產，鏡像的大規模拉取，進而保障容器的成功啓動。</p><p style="text-align:justify"><strong>如何能保障實例的大規模成功生產</strong>，如何先於線上發現問題，以及即使出現了問題如何第一時間止血並進行故障恢復，這對於集團雙十一期間的業務重保都是尤為重要的。除此之外，對於公有云環境來講，不能影響到其他的公有云客戶也是需要重點關注的，因此需要具備一套完整的穩定性保障體系以及故障應對方案以確保雙十一期間的業務能夠順利進行。實例生產系統穩定性 ECI 和 ECS 共用一套資源調度系統，相對於 ECS 容忍度為分鐘級別的應用來講，ECI 實例頻繁的創建刪除對調度系統的要求更為苛刻，對系統容量以及穩定性保障方面提了更高的要求。服務可用性保障 ECI 安全沙箱由於某種原因異常（OOM/物理機宕機/kernel panic），導致不健康情況。這種情況下，k8s 層面如果不從 endpoint 上摘除這個 ECI Pod，會導致請求通過負載均衡依然可以路由到這台不健康的 ECI 上，會導致業務請求成功率下降，因此對於集團業務服務可用性保障也是尤為重要的。</p><span id="OSC_h3_3"></span><h3>三、ECI 穩定性技術建設</h3><p style="text-align:justify">穩定性保障從需求收集準備階段開始，雙十一大促持續兩個月之久，為了配合集團全鏈路驗收，ECI 自身的穩定性保障工作也隨之緊鑼密鼓地進行。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-353460c616617e11f187c76359272f10_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">穩定性的保障貫穿了整個大促過程，大促前慎重/減少系統變更以排除人為因素的幹擾，敬畏發佈，多次壓測演預案確保系統穩定性，不斷提升系統抵抗力穩定性和系統恢復力穩定性，以保障大促的順利進行，最後通過問題覆盤沉澱出可複製的大客戶重保策略，這對於未經過雙十一實戰演練具有積極的意義。</p><p style="text-align:justify">因此我們梳理出了整個大促期間圍繞穩定性方面做的主要工作，主要包括風險控制、關鍵業務依賴梳理、技術保障、壓測預案、運行時保障、故障運維能力、以及最後的覆盤優化，希望以此能對今後的大促工作作為指導，並沉澱出穩定性治理的經驗。接下來我們對此次大促涉及到的主要穩定性保障方法以及如何應用進行介紹。</p><p style="text-align:justify">實例生產保障 VM 複用技術實例生產行為的保障是集團彈性使用 ECI 的重中之重。一個典型的實例生產過程如圖所示，<strong>ECS 和 ECI 在控制面共用一套管控系統，</strong>ECI 管控側調用資源調度系統之後會分配計算資源之後會調用 pync（阿里雲單機管控組件），進而調用 avs(阿里雲單機網絡組件) 和 tdc(阿里雲單機存儲組件) 分別生產網卡與磁盤。在此過程中，對於調用 ECS 依賴的 open api 接口較重，在大規模創建刪除場景很快成為系統瓶頸，此前我們專門針對容器實例高頻創建刪除場景開發了 VM 複用功能，對於高頻場景刪除容器實例的場景，延遲 vm 的回收，並複用容器實例的網卡、鏡像、計算資源，降低對管控系統整體的衝擊，以此來保障實例生產系統的穩定性，從此次雙十一的實戰演練效果來看，vm 複用取得了很好的效果，管控系統容量整體處於正常水位，保障了集團雙十一實例穩定的彈性能力。</p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-dcd697c3f23312c91e09c0272f34fbd8_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">重調度機制對於庫存不足或者遠程服務調用超時等情況，為了保障實例生產的最終一致性，對於 ECI 實例生產我們設計了相應的故障處理策略策略，取值如下：fail-back：失敗自動恢復。即 Pod 創建失敗後自動嘗試重新創建 fail-over：失敗轉移。效果等同於 fail-backfail-fast：快速失敗。即 Pod 創建失敗後直接報錯故障處理策略本質上是一種重調度的策略。原生的 k8s 調度支持重調度，即調度失敗後會將 pod 重新放入調度隊列等待下次調度，類比 k8s 的重調度行為，當 eci 管控系統收到創建請求的時候，首先會進入一個隊列，然後有個異步定時任務會將創建從隊列中撈起，提交到異步工作流進行實際的資源生產、以及容器的啓動等。即便是結合了多可用區和多規格的優化，異步工作流依然有可能失敗的，比如資源的爭搶、內網 ip 不足、啓動失敗等，這時候就需要將創建請求再次重回隊列，等待被重新調度生產。</p><p style="text-align:justify">我們目前對於<strong>故障處理策略</strong>：</p><p style="text-align:justify">1、失敗的任務會一直重試，但是我們會計算每個任務的執行週期，重試次數越多，執行週期越長，以達到退避效果。</p><p style="text-align:justify">2、優先級策略會考慮用戶級別、任務類型、任務上次失敗的原因等因素，優先級高的任務優先提交執行。</p><p style="text-align:justify">3、每次調度失敗的原因都會以標準事件的方式通知到 k8s 集羣。隊列裏的任務的整個執行流程的狀態機如下：</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-e09200aea1a82cf515617f061a7bb54a_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">所有執行失敗的任務都會重新進入隊列，等待被再次調度。由於任務會在任何一步失敗，所以所有生產出來的資源都會回滾，回滾結束後，進入初始狀態。初始狀態的任務會被拉起執行，然後提交到異步生產。如果生產失敗，就會再次回到等待調度的狀態。如果生產成功，任務就結束，到達終態。基於我們的重調度機制，可以極大的減少由於生產系統抖動造成實例生產失敗的情況，對於容器啓動成功率要求高的場景可以保障實例生產的最終一致性，對於容器啓動成功率要求不那麼嚴格的場景可以快速失敗，由上層業務進行處理。</p><p style="text-align:justify">服務容錯降級對於故障場景，系統依賴服務的降級也是十分重要的。大多數進行限流降級的方案主要關注點在服務的穩定性，當調用鏈路中某個資源依賴出現異常，例如，表現為 timeout，異常比例升高的時候，則對這個資源的調用進行限制，並讓請求快速失敗或返回預設靜態值，避免影響到其它的資源，最終產生雪崩的效果。ECI 目前實現了基於歷史日誌自學習進行無損降級、本地 cache 降級、流控降級 3 級降級機制框架，ECS/ECI openapi 全面接入，內部依賴 200+接口接入，根據每個接口的調用頻率、RT 分佈、超時時間設置來單獨分析，選擇合適的降級策略，設置合理的閥值，能讓系統出問題時，智能降級從而進行系統保護。<strong>一個典型的降級機制實現過程如圖：</strong></p><p style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-1239ddaa0f4eab60e7996e6fec9fe364_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>當有非資源類核心 API 新請求進入</strong>，如果歷史緩存數據未過期則直接返回緩存數據，結束業務邏輯反之則請求遠程接口。如果請求成功，返回數據，對數據進行緩存，同時將緩存數據以日誌方式存入 sls cache log 日誌用於未來降級，結束業務邏輯當遠程請求失敗時觸發降級策略：如果失敗指標（例如指定時間內異常比例）在預設時間窗口內未達到配置的降級策略閾值，則直接拋出相應業務異常，結束業務邏輯如達到降級策略閾值則按以下順序實行降級策略：從 sls 緩存日誌查找歷史日誌數據作為降級返回值，同時將返回值重新寫入緩存，結束業務邏輯如果 sls 緩存日誌沒有相應日誌則返回：預設靜態值或空值，結束業務邏輯對於一些跟用戶資源無關，更新少，屬於全局參數的服務/接口，以上通用降級策略和方案可能因為降級規則閾值難以界定而無法有效執行。</p><p style="text-align:justify">針對這些接口採用 dubbo 異常直接降級的策略涉及到降級或熔斷的條件：自動降級 (可選利用 Sentinal 進行自動降級)： 超時，異常，限流手動開關支持核心非資源 api 直接進行 openapi 本地降級 cache 對於嚴重的系統故障，可以將核心幾個 describe api 進行 openapi 本地 cache，發生故障，或有雪崩出現時，全部切到 openapi 本地 cache，在降級影響面的同時，也能減輕對下層服務的調用壓力來贏取恢復時間。</p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-0ce94b0355dad7e7cbc7463c70e8ad87_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify">依賴服務非創建鏈路 dubbo 或 http 請求進行本地 moc 對於幾乎不會頻繁變化的依賴服務，通過每日 sls 分析進行 kv 的存儲，當故障發生時，降級為備用，讓降級影響面趨向於 0。其他服務降級機制大分頁流控 cache 創建類 api 進行依賴 dubbo 或 http 服務降級，<strong>異步補償操作類 api 進行鏈路降級，</strong>取消非必需依賴數據庫降級 ro 庫流量降級隔離，用戶級別流量切到灰度 api 級別流量切到灰度/獨立線程池日誌 debug 及調用鏈路跟蹤使用 apicontext 實現詳細日誌 debug 及調用全鏈路跟蹤能力核心 api debug 日誌建設，支持按用戶開啓 debug 日誌打印 requestId 貫穿到 dao，支持隨時採樣，及時發現 dao 異常調用服務依賴降級容錯機制可以在保障服務穩定性的前提上，利用相關接口的歷史緩存數據，基於 SLS 日誌無損降級，當 SLS 無數據的時候也可以採用本地靜態數據兜底，構建有效返回值，在服務觸發流控降級熔斷後，大部分用戶不會感知到服務異常。</p><p style="text-align:justify">在內部的多次故障演練中，服務降級機制可以有效保護系統由於發生故障帶來的系統癱瘓。服務可用性保障在傳統的 Kubernetes 集羣中，如果 Node 變得不可用且達到時間閾值，那麼會將 Node 上的 Pod 進行驅逐，重新在其他 Node 上拉起新的 Pod。而在 Serverless 場景下，ECI 管控會通過異步檢測機制檢測不健康 ECI，修改狀態為不可用，同時增加導致不可用的事件，告知 ECI 用戶，之後 ECI 會通過主動運維的手段治癒不健康 ECI，之後觸發控制面將 ECI 恢復為 Ready 狀態，<strong>主要過程如圖所示：</strong></p><p style="text-align:center"><img src="https://pic4.zhimg.com/80/v2-790b2ccc925edb4964dede90b43256af_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>處理不健康 ECI 的流程：</strong></p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-4e6eaa3bddc8488957271e480923d34a_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:justify"><strong>恢復 Ready ECI 流程預案&amp;壓測除了技術方面的保障，故障注入、應急預案、壓測演練在穩定性建設中也尤為重要。</strong>在雙十一活動期間我們內部進行了多次壓測演練，對系統中常見的性能瓶頸進行故障注入，用以模擬故障的發生，同時制定應急預案，以此應對故障已經發生時的場景。通過多次的壓測摸高，一方面可以評估系統容量的承載上限，另一方面可以藉此機會進行大規模壓測演練，驗證系統降級方案並對系統穩定性進行評估。預警&amp;監控大促進行時，預警和監控是保證系統運行時穩定性的重要措施。通過監控和預警可以及時發現系統故障，進而快速進行恢復。</p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-bfb30f596763e9976d35e307e15d74a2_720w.webp" referrerpolicy="no-referrer"></p><p style="text-align:center"><img src="https://pic3.zhimg.com/80/v2-c27bfedd2fd094067dc495bbdab8340a_720w.webp" referrerpolicy="no-referrer"></p><span id="OSC_h3_4"></span><h3>四、系統的健壯性</h3><p style="text-align:justify">思考沉澱一個健壯的系統不僅需要減少問題的發生，同時要具備故障發現以及故障快速恢復的能力。除了預警和監控，運維能力建設也十分重要。</p><p style="text-align:justify"><strong>一個系統的健壯性體現在系統的容量，</strong>系統的容錯能力以及系統依賴的各個資源的 sla，尤其是在雲上覆雜的資源環境下，由於「木桶效應」，某一項依賴資源的很可能造成整個系統的直接不可用。因此，隨着系統不斷完善，我們需要通過混沌工程等方法來找出當前系統的「弱點」進而對其進行專項優化，進而提升整個系統的健壯性；其二對於系統的故障恢復以及降級能力也很重要，歷史上 ECS/ECI 管控多次由於單用戶或系統某個環節變慢，導致系統全鏈路雪崩，最終導致 P1P2 故障，ECS/ECI 管控是阿里雲最複雜的管控系統，複雜的業務邏輯，內部系統依賴，非常多的環節出問題都有可能導致全鏈路某個應用雪崩進而全局不可用，因此，對於故障已經來臨時，依賴降級能力能非常有效的保護我們的系統，這也是穩定性建設的一個十分重要的方向。</p><span id="OSC_h3_5"></span><h3>五、總結</h3><p style="text-align:justify">未來展望隨着雙十一最後一波流量高峯結束，ECI 順利通過了對阿里人最嚴苛的技術考驗--雙十一，本文圍繞此次參與雙十一活動的經歷做出總結，希望可以為今後 ECI 穩定性方面的建設積累經驗，當然，這對 ECI 來説也僅僅是一步試金石，作為雲原生時代的基礎設施，ECI 任重而道遠，共勉！</p><p style="text-align:justify">本文出品及鳴謝： 柳密、羽雲、景奇、存誠、 煜楓、景止、皓瑜、月懸、佐井、尚哲、湧泉、十刀、 木名、秉辰、易觀、冬島、不物、瀟洛、 懷歡、 嘗君、寒亭、伯琰。</p><p style="text-align:justify"><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1389034%3Futm_content%3Dg_1000385342" target="_blank">原文鏈接</a></strong></p><p style="text-align:justify"><strong>本文為阿里雲原創內容，未經允許不得轉載。</strong></p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 01:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/yunqi/blog/10319647</guid>
            <link>https://my.oschina.net/yunqi/blog/10319647</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[AutoMQ 社區雙週精選第二期（11.20-12.01）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>本期概要</h2><p>在開源的第二個雙週裏，作為一個成長中的開源項目，AutoMQ 做了很多的優化和重構，以下是相關重點動態的總結。<br> AutoMQ Kafka：寫鏈路耗時優化、快慢讀隔離、Spot 實例強制回收容災。<br> AutoMQ RocketMQ：歷史數據冷讀優化、LogCache 讀寫耗時優化、發佈 v0.0.3-alpha 版本、發佈 Helm Chart、發佈文檔站。</p><h2>AutoMQ Kafka 精選動態</h2><h3>寫鏈路耗時優化</h3><p>原來所有的寫入和回調都會放到一個單線程線程池去進行處理來確保數據安全，該方式存在線程上下文切換通信、單線程處理排隊兩個問題。本次優化將寫入流程中的數據結構改造成線程併發安全模式，使得不同 stream 之間可以併發進行寫入，AutoMQ Kafka 客戶端平均寫入耗時<strong>下降 0.3ms</strong>。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F728" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/728</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F729" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/729</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F743" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/743</a></p><h3>快慢讀隔離</h3><p>隔離從 Cache 讀取的快讀和從 S3 的讀取的慢讀，避免慢讀佔滿快讀的線程池影響快讀。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-kafka%2Fpull%2F472" target="_blank">https://github.com/AutoMQ/automq-for-kafka/pull/472</a></p><p><strong>Spot 實例強制回收容災</strong></p><p>在上期精選中提及進度的 Spot 實例強制回收容災已經完成。Spot（競價實例）相比按需實例可以便宜至多 90 %，但問題是它可能不經通知就強制回收。該特性支持 Spot 實例強制回收的情況下，仍舊可以將數據卷掛載到存活的機器，進行<strong>秒級容災恢復</strong>。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-kafka%2Fissues%2F447" target="_blank">https://github.com/AutoMQ/automq-for-kafka/issues/447</a></p><h2>AutoMQ RocketMQ 精選動態</h2><h3>Stream 模塊性能優化</h3><h4>歷史數據冷讀優化</h4><p>歷史數據追趕讀優化，Fetch 請求（50MB &amp; 50 stream）冷讀穿透到 S3 場景，單次 Fetch 耗時從 4s 優化到 100ms。即使是完全穿透冷讀，S3 讀取吞吐效率也是很高的。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F766" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/766</a></p><h4>LogCache 讀寫耗時優化</h4><p>增加上次 Cache 讀取位點記錄，避免每次從 LogCache 讀取數據都需要二分查找定位，10W 個消息下 10W 次查詢時間從 71s 優化到 86ms。<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F731" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/731</a> 通過讀寫鎖，將 LogCache 升級成線程併發安全的數據結構，提升 LogCache 讀取併發效率。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F701" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/701</a></p><h3>發佈 v0.0.3-alpha 版本</h3><p>這個版本包含了以下功能和優化： 1）穩定性與性能提升：修復了潛在的 OOM 問題以及提升 stream 模塊性能，詳見 Changelog：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fcompare%2Fv0.0.2-alpha...v0.0.3-alpha" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/compare/v0.0.2-alpha...v0.0.3-alpha</a> 2）工程化建設：引入 Nightly build 和&nbsp;E2E test CI <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhub.docker.com%2Fr%2Fautomqinc%2Fautomq-for-rocketmq%2Ftags" target="_blank">https://hub.docker.com/r/automqinc/automq-for-rocketmq/tags</a><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Factions%2Fworkflows%2Fbuild-ci.yml" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/actions/workflows/build-ci.yml</a> 3）可觀測性提升：為 stream 模塊引入 Metrics；為 Proxy、Store 模塊引入 Trace <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-rocketmq%2Fpull%2F766" target="_blank">https://github.com/AutoMQ/automq-for-rocketmq/pull/766</a></p><h3>發佈 Helm Chart</h3><p>現在可以使用 Helm Chart 快速在 Kubernetes 中創建 AutoMQ RocketMQ 集羣。</p><pre><code class="language-cs">$ helm repo add automq https://charts.automq.com
$ helm search repo automq                                                                                                                                                            
NAME                            CHART VERSION   APP VERSION     DESCRIPTION                                                                                                           
automq/automq-for-rocketmq      0.0.4           v0.0.3-alpha    A Helm chart for automq-for-rocketmq
</code></pre><p>部署該 Chart 會創建一個 AutoMQ RocketMQ Broker 以及依賴的 MySQL 與 Minio 組件。後續會陸續加入可選的可觀測性依賴組件。</p><h3>發佈文檔站</h3><p>介紹了 AutoMQ RocketMQ 基本使用方式，包含：本地構建、使用 docker compose 部署、在 Kubernetes 上部署。以及使用 CLI 運維集羣模式，管理 Topic 等資源。 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.automq.com%2Fzh%2Fdocs%2Fautomq-rocketmq%2FRmuXwhb5Xi9zjCkrInRcCz0UnTe" target="_blank">https://docs.automq.com/zh/docs/automq-rocketmq/RmuXwhb5Xi9zjCkrInRcCz0UnTe</a></p><h2>More Things</h2><p>與小紅書的同學共創對象存儲跨地域容災方案 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ%2Fautomq-for-kafka%2Fissues%2F477" target="_blank">https://github.com/AutoMQ/automq-for-kafka/issues/477</a></p><p>以上是第二期《雙週精選》的內容，歡迎關注我們的公眾號，我們會定期更新 AutoMQ 社區的進展。同時，也誠邀各位開源愛好者持續關注我們社區，跟我們一起構建雲原生消息中間件！</p><p><strong>END</strong></p><h3>關於我們</h3><p>AutoMQ 是一家專業的消息隊列和流存儲軟件服務供應商。AutoMQ 開源的 AutoMQ Kafka 和 AutoMQ RocketMQ 基於雲對 Apache Kafka、Apache RocketMQ 消息引擎進行重新設計與實現，在充分利用雲上的競價實例、對象存儲等服務的基礎上，兌現了雲設施的規模化紅利，帶來了下一代更穩定、高效的消息引擎。此外，AutoMQ 推出的 RocketMQ Copilot 專家系統也重新定義了 RocketMQ 消息運維的新範式，賦能消息運維人員更好的管理消息集羣。&nbsp;</p><p>🌟&nbsp;GitHub 地址：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FAutoMQ" target="_blank">https://github.com/AutoMQ</a></p><p>💻&nbsp;官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.automq.com" target="_blank">https://www.automq.com</a></p><p>👀&nbsp;B 站：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspace.bilibili.com%2F3546572478482870" target="_blank">AutoMQ 官方賬號</a></p><p>🔍&nbsp;視頻號：AutoMQ&nbsp;</p><p><strong>👉 掃二維碼</strong>加入我們的社區羣</p><p><img src="https://oscimg.oschina.net/oscnet/up-c4c6b2be9441c750e268dd2d48294131af7.png" alt="" referrerpolicy="no-referrer"></p><p>關注我們，一起學習更多雲原生乾貨</p></div>
                                    ]]>
            </description>
            <pubDate>Wed, 13 Dec 2023 01:46:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/6990971/blog/10320900</guid>
            <link>https://my.oschina.net/u/6990971/blog/10320900</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[雲原生週刊：Kubernetes v1.29 新特性一覽]]>
            </title>
            <description>
                <![CDATA[<div class="content"><h2>開源項目推薦</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwerf%2Fkubedog" title="kubedog" target="_blank">kubedog</a></h3><p>Kubedog 是一個用於在 CI/CD 部署管道中監視和跟蹤 Kubernetes 資源的庫。</p><p>這個庫被用於 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fwerf%2Fwerf" title="werf CI/CD" target="_blank">werf CI/CD</a> 工具中，在部署過程中跟蹤資源。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frunwhen-contrib%2Frunwhen-local" title="RunWhen Local" target="_blank">RunWhen Local</a></h3><p>runwhen-local 是一個工具，用於在本地環境中運行 runwhen 腳本。runwhen 是一個靈活的任務調度工具，可以根據條件和時間表來執行任務。通過 runwhen-local，開發者可以在本地測試和調試 runwhen 腳本，以確保其正確運行。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubewharf%2Fkubegateway" title="KubeGateway" target="_blank">KubeGateway</a></h3><p>kube-gateway 是字節跳動內部管理海量 kubernetes 集羣的最佳實踐。 它是為 kube-apiserver 的 HTTP2 流量專門設計並定製的七層負載均衡代理。 目標是為海量的大規模 kubernetes 集羣（千級 node 以上）提供靈活的穩定的流量治理方案。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fflannel-io%2Fflannel" title="flannel" target="_blank">flannel</a></h3><p>Flannel 是為 Kubernetes 設計的一種簡單且易於配置的第三層網絡結構的解決方案。</p><h2>文章推薦</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmoelove.info%2F2023%2F12%2F10%2FKubernetes-v1.29-%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7%25E4%25B8%2580%25E8%25A7%2588%2F" target="_blank">Kubernetes v1.29 新特性一覽</a></h3><p>這篇文章介紹了 Kubernetes v1.29 版本的新特性。該版本包含了 49 個主要的更新，其中有 19 個增強功能進入 Alpha 階段，19 個升級到 Beta 階段，還有 11 個升級到穩定版。</p><p>文章重點介紹了兩個重要的特性：基於 CEL 的 CRD 規則校驗和為動態和靜態分配預留 NodePort 端口範圍。基於 CEL 的 CRD 規則校驗是一種在 CRD 聲明中編寫校驗規則的方式，簡化了開發和維護成本。而為動態和靜態分配預留 NodePort 端口範圍的特性解決了在創建 NodePort 時可能產生的端口衝突問題。總體而言，Kubernetes v1.29 版本的新特性為用戶提供了更好的功能擴展和更可靠的輸入校驗。</p><h3>[Kubernetes：Pod 和 WorkerNodes – 控制 Pod 在節點上的放置</h3><p>](<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frtfm.co.ua%2Fen%2Fkubernetes-pods-and-workernodes-control-the-placement-of-the-pods-on-the-nodes%2F" target="_blank">https://rtfm.co.ua/en/kubernetes-pods-and-workernodes-control-the-placement-of-the-pods-on-the-nodes/</a>)</p><p>這篇文章介紹了在 Kubernetes 中如何控制 Pods 在 WorkerNodes 上的部署位置。它提供了四種主要的方法來實現這種控制：</p><ul><li>配置節點</li><li>Taints 和 Tolerations</li><li>配置 Pod 本身</li><li>Pod 親和性和反親和性</li></ul><p>此外，文章還提到了 Pod 拓撲分佈約束（Pod Topology Spread Constraints），即根據失敗域（regions、可用區或節點）的規則來放置 Pod。</p><p>文章還提供了一些使用 kubectl explain 命令來查看相關參數和資源文檔的技巧。</p><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmedium.com%2F%40geoffrey.muselli%2Fargocd-multi-tenancy-strategy-94d72183c94" title="ArgoCD：多租戶策略" target="_blank">ArgoCD：多租戶策略</a></h3><p>這篇文章介紹了使用 ArgoCD 實現多租戶策略的方法。在使用 ArgoCD 時，通常會允許所有用戶自由操作，直到進入生產環境後才意識到某個人通過刪除應用程序而刪除了命名空間或 CRD。為瞭解決這個問題，需要使用訪問控制和多租戶策略。文章詳細介紹瞭如何利用 ArgoCD 的原生功能實現多租戶策略，並提供了一個示例來演示如何在大型組織中使用企業敏捷框架（例如 SAFe）來實施。文章還討論了 ArgoCD 中的 AppProject、RBAC 和命名空間等概念，以及如何配置和使用它們來實現多租戶策略。最後，文章提供了一個具體的示例，展示瞭如何根據團隊和項目的需求來配置 AppProject 和 RBAC。</p><h2>雲原生動態</h2><h3><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io%2Fblog%2F2023%2F12%2F05%2Fkyverno-completes-third-party-security-audit%2F" title="Kyverno 完成第三方安全審計" target="_blank">Kyverno 完成第三方安全審計</a></h3><p>Kyverno 項目宣佈完成了第三方安全審計。該審計是由 Ada Logics 與 Kyverno 維護人員、開源技術改進基金合作進行，由 CNCF 資助。</p><p>該安全審計是一個全面的安全審計，有以下四個目標：</p><ul><li>為 Kyverno 定義一個正式的威脅模型。</li><li>對代碼進行手動安全漏洞審計。</li><li>根據威脅模型評估 Kyverno 的模糊測試套件。</li><li>針對 SLSA 評估 Kyverno 的供應鏈風險。</li></ul><blockquote><p>本文由博客一文多發平台 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenwrite.cn%3Ffrom%3Darticle_bottom" target="_blank">OpenWrite</a> 發佈！</p></blockquote></div>
                                    ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 11:05:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/4197945/blog/10320847</guid>
            <link>https://my.oschina.net/u/4197945/blog/10320847</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[.NET 8 極致性能優化 - Reflection（反射）]]>
            </title>
            <description>
                <![CDATA[<div class="content"><span id="OSC_h1_1"></span><h1><span><strong><span style="color:#3c70c6">前言</span></strong></span></h1><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>反射一直是性能的瓶頸，所以無論哪個.NET 版本反射的優化必然少不了。主要是集中在兩個方面優化，分配和緩存。.NET8 自然也不例外。本篇看下。</span></p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">原文:<u><strong><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5NDYwNjU4MA%3D%3D%26mid%3D2247485722%26idx%3D1%26sn%3Da126d8687afbc4b980533ec7fd239026%26chksm%3Dc01c4481f76bcd97a92c031859b0327a4460f7b4c73dad11cb0f45fa9c283954e5c95f442eec%26token%3D322944710%26lang%3Dzh_CN%23rd" rel="nofollow" target="_blank">.NET8 極致性能優化 Reflection</a></strong></u></p><span id="OSC_h1_2"></span><h1><span><strong><span style="color:#3c70c6">概述</span></strong></span></h1><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>比如針對 GetCustomAttributes 通過反射獲取屬性的優化，以下例子</span></p><pre><code><span><em>// dotnet run -c Release -f net7.0 --filter "*" --runtimes net7.0 net8.0</em></span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">Tests</span></span></code><code><span>{</span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">object</span>[] <span style="color:#dd1144">GetCustomAttributes</span>()</span> =&gt; <span style="color:#ca7d37">typeof</span>(C).GetCustomAttributes(<span style="color:#ca7d37">typeof</span>(MyAttribute), inherit: <span style="color:#0e9ce5">true</span>);</span></code><code><span>    [<span style="color:#afafaf">My(Value1 = 1, Value2 = 2)</span>]</span></code><code><span><span style="color:#ca7d37">class</span><span style="color:#dd1144">C</span> { }</span></code><code><span>    [<span style="color:#afafaf">AttributeUsage(AttributeTargets.All)</span>]</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">MyAttribute</span> : <span style="color:#dd1144">Attribute</span></span></code><code><span>    {</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">int</span> Value1 { <span style="color:#ca7d37">get</span>; <span style="color:#ca7d37">set</span>; }</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">int</span> Value2 { <span style="color:#ca7d37">get</span>; <span style="color:#ca7d37">set</span>; }</span></code><code><span>    }</span></code><code><span>}</span></code></pre><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>.NET7 和.NET8 明顯的差異，它主要是優化了</span><span>避免分配一個 object[1]數組來設置屬性的值</span></p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,BlinkMacSystemFont,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:17px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:676.989px; word-spacing:0px"><tbody><tr><th>方法</th><th>運行時</th><th>平均值</th><th>比率</th><th>分配</th><th>分配比率</th></tr></tbody><tbody><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">GetCustomAttributes</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1,287.1 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">296 B</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">GetCustomAttributes</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">994.0 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.77</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">232 B</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.78</td></tr></tbody></table><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">其它的比如減少反射堆棧中的分配，比如通過更自由的 spans。改進了 Type 上的泛型處理，從而提升各種與泛型相關的成員性能，比如 GetGenericTypeDefinition，它的結果現在被緩存在了 Type 對象上​​​​​​​</p><pre><code><span><em>// dotnet run -c Release -f net7.0 --filter "*" --runtimes net7.0 net8.0</em></span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">Tests</span></span></code><code><span>{</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span> Type _type = <span style="color:#ca7d37">typeof</span>(List&lt;<span style="color:#ca7d37">int</span>&gt;);</span></code><code><span>&nbsp;&nbsp;&nbsp;&nbsp;<span><span style="color:#ca7d37">public</span>&nbsp;Type&nbsp;<span style="color:#dd1144">GetGenericTypeDefinition</span>()</span>&nbsp;=&gt;&nbsp;_type.GetGenericTypeDefinition();</span></code><code><span>}</span></code></pre><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>.NET7 和.NET8 如下</span></p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,BlinkMacSystemFont,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:17px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:676.989px; word-spacing:0px"><tbody><tr><th>方法</th><th>運行時</th><th>平均值</th><th>比</th></tr></tbody><tbody><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">GetGenericTypeDefinition</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">47.426 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">GetGenericTypeDefinition</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">3.289 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.07</td></tr></tbody></table><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span><span style="background-color:#ffffff">這</span>些<span style="background-color:#ffffff">都是細枝末節，影響反射性能最大的一塊是 MethodBase.Invoke。</span><span style="background-color:#ffffff">當在編譯的時候，知道方法的簽名並且通過反射來調用方法。</span><span style="background-color:#ffffff">就可以通過使用</span></span><span style="background-color:#ffffff">CreateDelegate</span><span>來獲取和緩存該方法的委託，然後通過該委託執行所有的調用。從而實現性</span><span>能最佳化，但是如果在編譯的時候你不知道</span><span>方法的簽名，則需要依賴動態的方法。比如 MethodBase.Invoke，這個方法降低性能並且更耗</span><span>時。一些比較瞭解.NET 開</span><span>發的人員會用 emit 避免這種開銷。.NET7 裏面採用這種方式。.NET8 裏面，為許多這樣的情況進行了改進，以前，emitter 總是生成可以容納 ref/out 參數的代碼，但許多方法不提供這樣的參數，當不需要考慮這些因素時，生成的代碼可以更高效。</span>​​​​​​​</p><pre><code><span><em>// If you have .NET 6 installed, you can update the csproj to include a net6.0 in the target frameworks, and then run:</em></span></code><code><span><em>//     dotnet run -c Release -f net6.0 --filter "*" --runtimes net6.0 net7.0 net8.0</em></span></code><code><span><em>// Otherwise, you can run:</em></span></code><code><span><em>//     dotnet run -c Release -f net7.0 --filter "*" --runtimes net7.0 net8.0</em></span></code><code><span><span style="color:#ca7d37">using</span> BenchmarkDotNet.Attributes;</span></code><code><span><span style="color:#ca7d37">using</span> BenchmarkDotNet.Running;</span></code><code><span><span style="color:#ca7d37">using</span> System.Reflection;</span></code><code><span>BenchmarkSwitcher.FromAssembly(<span style="color:#ca7d37">typeof</span>(Tests).Assembly).Run(args);</span></code><code><span>[<span style="color:#afafaf">HideColumns(<span>"Error"</span>, <span>"StdDev"</span>, <span>"Median"</span>, <span>"RatioSD"</span>)</span>]</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">Tests</span></span></code><code><span>{</span></code><code><span><span style="color:#ca7d37">private</span> MethodInfo _method0, _method1, _method2, _method3;</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span>[] _args1 = <span style="color:#ca7d37">new</span><span style="color:#ca7d37">object</span>[] { <span style="color:#0e9ce5">1</span> };</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span>[] _args2 = <span style="color:#ca7d37">new</span><span style="color:#ca7d37">object</span>[] { <span style="color:#0e9ce5">2</span>, <span style="color:#0e9ce5">3</span> };</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span>[] _args3 = <span style="color:#ca7d37">new</span><span style="color:#ca7d37">object</span>[] { <span style="color:#0e9ce5">4</span>, <span style="color:#0e9ce5">5</span>, <span style="color:#0e9ce5">6</span> };</span></code><code><span>    [<span style="color:#afafaf">GlobalSetup</span>]</span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Setup</span>()</span></span></code><code><span>    {</span></code><code><span>        _method0 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod0"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>        _method1 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod1"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>        _method2 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod2"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>        _method3 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod3"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>    }</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>] <span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Method0</span>()</span> =&gt; _method0.Invoke(<span style="color:#0e9ce5">null</span>, <span style="color:#0e9ce5">null</span>);</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>] <span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Method1</span>()</span> =&gt; _method1.Invoke(<span style="color:#0e9ce5">null</span>, _args1);</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>] <span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Method2</span>()</span> =&gt; _method2.Invoke(<span style="color:#0e9ce5">null</span>, _args2);</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>] <span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Method3</span>()</span> =&gt; _method3.Invoke(<span style="color:#0e9ce5">null</span>, _args3);</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod0</span>()</span> { }</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod1</span>(<span><span style="color:#ca7d37">int</span> arg1</span>)</span> { }</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod2</span>(<span><span style="color:#ca7d37">int</span> arg1, <span style="color:#ca7d37">int</span> arg2</span>)</span> { }</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod3</span>(<span><span style="color:#ca7d37">int</span> arg1, <span style="color:#ca7d37">int</span> arg2, <span style="color:#ca7d37">int</span> arg3</span>)</span> { }</span></code><code><span>}</span></code></pre><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>.NET6 以及 7 和 8 的情況分別如下：</span></p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,BlinkMacSystemFont,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:17px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:676.989px; word-spacing:0px"><tbody><tr><th>方法</th><th>運行時</th><th>平均值</th><th>比率</th></tr></tbody><tbody><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 6.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">91.457 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">7.205 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.08</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">5.719 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.06</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method1</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 6.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">132.832 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method1</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">26.151 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.20</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method1</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">21.602 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.16</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method2</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 6.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">172.224 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method2</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">37.937 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.22</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method2</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">26.951 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.16</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method3</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 6.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">211.247 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method3</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 7.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">42.988 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.20</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">Method3</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">.NET 8.0</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">34.112 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.16</td></tr></tbody></table><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">這裏有一些問題，每次調用都會涉及到一些性能開銷，每次調用都會重複。如果我們可以提取這些重複性的工作，對它們進行緩存。就可以實現更好的性能。.NET8 裏面通過 MethodInvoker 和 ConstructorInvoker 類型中實現了這些功能。這些並沒有包含所有 MethodBase.Invoke 處理的不常見錯誤（如特別識別和處理 Type.Missing），但對於其他所有情況，它為優化在構建時未知簽名的方法的重複調用提供了一個很好的解決方案。​​​​​​​</p><pre><code><span><em>// dotnet run -c Release -f net8.0 --filter "*"</em></span></code><code><span><span style="color:#ca7d37">using</span> BenchmarkDotNet.Attributes;</span></code><code><span><span style="color:#ca7d37">using</span> BenchmarkDotNet.Running;</span></code><code><span><span style="color:#ca7d37">using</span> System.Reflection;</span></code><code><span>BenchmarkSwitcher.FromAssembly(<span style="color:#ca7d37">typeof</span>(Tests).Assembly).Run(args);</span></code><code><span>[<span style="color:#afafaf">HideColumns(<span>"Error"</span>, <span>"StdDev"</span>, <span>"Median"</span>, <span>"RatioSD"</span>)</span>]</span></code><code><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">class</span><span style="color:#dd1144">Tests</span></span></code><code><span>{</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span> _arg0 = <span style="color:#0e9ce5">4</span>, _arg1 = <span style="color:#0e9ce5">5</span>, _arg2 = <span style="color:#0e9ce5">6</span>;</span></code><code><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">readonly</span><span style="color:#ca7d37">object</span>[] _args3 = <span style="color:#ca7d37">new</span><span style="color:#ca7d37">object</span>[] { <span style="color:#0e9ce5">4</span>, <span style="color:#0e9ce5">5</span>, <span style="color:#0e9ce5">6</span> };</span></code><code><span><span style="color:#ca7d37">private</span> MethodInfo _method3;</span></code><code><span><span style="color:#ca7d37">private</span> MethodInvoker _method3Invoker;</span></code><code><span>    [<span style="color:#afafaf">GlobalSetup</span>]</span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">Setup</span>()</span></span></code><code><span>    {</span></code><code><span>        _method3 = <span style="color:#ca7d37">typeof</span>(Tests).GetMethod(<span style="color:#dd1144">"MyMethod3"</span>, BindingFlags.NonPublic | BindingFlags.Static);</span></code><code><span>        _method3Invoker = MethodInvoker.Create(_method3);</span></code><code><span>    }</span></code><code><span>    [<span style="color:#afafaf">Benchmark(Baseline = true)</span>] </span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MethodBaseInvoke</span>()</span> =&gt; _method3.Invoke(<span style="color:#0e9ce5">null</span>, _args3);</span></code><code><span>    [<span style="color:#afafaf">Benchmark</span>]</span></code><code><span><span><span style="color:#ca7d37">public</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MethodInvokerInvoke</span>()</span> =&gt; _method3Invoker.Invoke(<span style="color:#0e9ce5">null</span>, _arg0, _arg1, _arg2);</span></code><code><span><span><span style="color:#ca7d37">private</span><span style="color:#ca7d37">static</span><span style="color:#ca7d37">void</span><span style="color:#dd1144">MyMethod3</span>(<span><span style="color:#ca7d37">int</span> arg1, <span style="color:#ca7d37">int</span> arg2, <span style="color:#ca7d37">int</span> arg3</span>)</span> { }</span></code><code><span>}</span></code></pre><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>.NET8 的情況如下</span></p><table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:system-ui,-apple-system,BlinkMacSystemFont,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei UI&quot;,&quot;Microsoft YaHei&quot;,Arial,sans-serif; font-size:17px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:100%; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:676.989px; word-spacing:0px"><tbody><tr><th>方法</th><th>平均值</th><th>比率</th></tr></tbody><tbody><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">MethodBaseInvoke</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">32.42 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">1.00</td></tr><tr><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">MethodInvokerInvoke</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">11.47 ns</td><td style="border-collapse:collapse; border-color:#c0c0c0; border-style:solid; border-width:1px">0.35</td></tr></tbody></table><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span>這些類型被 Microsoft.Extensions.DependencyInjection.Abstractions 中的 ActivatorUtilities.CreateFactory 方法使用，以進一步提高 DI 服務構建性能。通過添加額外的緩存層進一步改進，進一步避免每次構建時的反射。</span></p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">&nbsp;</p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left">作者:jianghupt</p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><strong>歡迎關注公眾號 (jianghupt），文章首發地。</strong></p><p style="color:#4a4a4a; margin-left:0; margin-right:0; text-align:left"><span><img alt="" height="430" src="https://oscimg.oschina.net/oscnet/up-3243ba74c89867eabc4277de83aa83aa7bb.png" width="430" referrerpolicy="no-referrer"></span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 09:50:00 GMT</pubDate>
            <guid isPermaLink="false">https://my.oschina.net/u/5407571/blog/10320411</guid>
            <link>https://my.oschina.net/u/5407571/blog/10320411</link>
            <author>
                <![CDATA[原創]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[FastUI —— 更快地構建更好的 UI]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>FastUI 是一種構建由聲明式 Python 代碼來構建 Web 應用程序用戶界面的新方法。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>這意味着：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><strong>如果你是一名 Python 開發人員</strong>，可以使用 React 構建響應式 Web 應用程序，而無需編寫任何 JavaScript 代碼，也無需接觸<code>npm</code>。</li><li><strong>如果你是前端開發人員</strong>，可以專注於構建真正可重用的神奇組件，無需為每個視圖複製粘貼組件。</li><li><strong>對於每個人來説&nbsp;</strong>—— 真正的關注點分離，後端定義了整個應用程序；而前端可以自由地僅實現用戶界面</li></ul><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>FastUI 的核心是一組匹配的&nbsp;<a href="https://docs.pydantic.dev/">Pydantic</a>&nbsp;模型和 TypeScript </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>interfaces<span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>，允許你定義用戶界面。其在構建時由 TypeScript 和 Pyright/mypy 進行驗證，並在運行時由 Pydantic 進行驗證。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>FastUI 由 4 部分組成：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><a href="https://pypi.python.org/pypi/fastui"><code>fastui</code>PyPI 包</a>— UI 組件的 Pydantic 模型和一些實用程序。雖然它與<a href="https://fastapi.tiangolo.com/">FastAPI</a>配合良好，但它不依賴於 FastAPI，並且其中大部分可以與任何 Python Web 框架一起使用。</li><li><a href="https://www.npmjs.com/package/@pydantic/fastui"><code>@pydantic/fastui</code>npm 包</a>— 一個 React TypeScript 包，讓你在實現自己的組件時重用 FastUI 的機制和類型</li><li><a href="https://www.npmjs.com/package/@pydantic/fastui-bootstrap"><code>@pydantic/fastui-bootstrap</code>npm 包</a> — 使用&nbsp;<a href="https://getbootstrap.com/">Bootstrap</a>&nbsp;實現/定製所有 FastUI 組件</li><li><a href="https://www.jsdelivr.com/package/npm/@pydantic/fastui-prebuilt"><code>@pydantic/fastui-prebuilt</code>npm 包</a>（在&nbsp;<a href="https://www.jsdelivr.com/package/npm/@pydantic/fastui-prebuilt">jsdelivr.com CDN</a>&nbsp;上提供）提供了 FastUI React 應用程序的預構建版本，因此你無需安裝任何 npm 包或自行構建任何內容即可使用它。Python 包提供了一個簡單的 HTML 頁面來服務此應用程序。</li></ul><p style="text-align:start"><span><span><span><span style="color:#1f2328"><span><span><span><span><span><span><span><span><span><span><span><span style="background-color:#ffffff"><span><span><span>以下是一個簡單但完整的 FastAPI 應用程序，它使用 FastUI 來顯示一些用戶配置文件：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><pre><code>from datetime import date

from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse
from fastui import FastUI, AnyComponent, prebuilt_html, components as c
from fastui.components.display import DisplayMode, DisplayLookup
from fastui.events import GoToEvent, BackEvent
from pydantic import BaseModel, Field

app = FastAPI()


class User(BaseModel):
    id: int
    name: str
    dob: date = Field(title='Date of Birth')


# define some users
users = [
    User(id=1, name='John', dob=date(1990, 1, 1)),
    User(id=2, name='Jack', dob=date(1991, 1, 1)),
    User(id=3, name='Jill', dob=date(1992, 1, 1)),
    User(id=4, name='Jane', dob=date(1993, 1, 1)),
]


@app.get("/api/", response_model=FastUI, response_model_exclude_none=True)
def users_table() -&gt; list[AnyComponent]:
    """
    Show a table of four users, `/api` is the endpoint the frontend will connect to
    when a user fixes `/` to fetch components to render.
    """
    return [
        c.Page(  # Page provides a basic container for components
            components=[
                c.Heading(text='Users', level=2),  # renders `&lt;h2&gt;Users&lt;/h2&gt;`
                c.Table[User](  # c.Table is a generic component parameterized with the model used for rows
                    data=users,
                    # define two columns for the table
                    columns=[
                        # the first is the users, name rendered as a link to their profile
                        DisplayLookup(field='name', on_click=GoToEvent(url='/user/{id}/')),
                        # the second is the date of birth, rendered as a date
                        DisplayLookup(field='dob', mode=DisplayMode.date),
                    ],
                ),
            ]
        ),
    ]


@app.get("/api/user/{user_id}/", response_model=FastUI, response_model_exclude_none=True)
def user_profile(user_id: int) -&gt; list[AnyComponent]:
    """
    User profile page, the frontend will fetch this when the user visits `/user/{id}/`.
    """
    try:
        user = next(u for u in users if u.id == user_id)
    except StopIteration:
        raise HTTPException(status_code=404, detail="User not found")
    return [
        c.Page(
            components=[
                c.Heading(text=user.name, level=2),
                c.Link(components=[c.Text(text='Back')], on_click=BackEvent()),
                c.Details(data=user),
            ]
        ),
    ]


@app.get('/{path:path}')
async def html_landing() -&gt; HTMLResponse:
    """Simple HTML page which serves the React app, comes last as it matches all paths."""
    return HTMLResponse(prebuilt_html(title='FastUI Demo'))</code></pre></div>
                                                                ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 09:29:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/p/fastui</guid>
            <link>https://www.oschina.net/p/fastui</link>
        </item>
        <item>
            <title>
                <![CDATA[🎁有獎問答 | 聊聊 NGINX 向雲原生演進那點兒事]]>
            </title>
            <description>
                <![CDATA[<h1 class="header article-title"><a href="https://www.oschina.net/question/4700705_2331501">高手問答第 311 期 —— 聊聊 NGINX 向雲原生演進那點兒事</a><div class="ui red label horizontal" data-tooltip="置頂">頂</div></h1><div class="extra ui horizontal list meta-wrap"><div class="item"><a href="https://my.oschina.net/u/4700705" class="__user"><span>小白兔愛吃大灰狼</span></a> 發佈於，昨天 11:35
                    </div><div class="item">閲讀 789</div><div class="item collect-btn " data-id="2331501" data-user-id="4700705" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i> 收藏 <span data-collect-count="" data-id="2331501" data-obj-type="2">3</span></div><div class="item comment-count"><a href="https://www.oschina.net/question/4700705_2331501#comments" class="normal"><i class="comment outline icon"></i> 答案 <span data-article-reply-count="">12</span></a></div></div><div class="tags"><a class="ui horizontal label" href="https://www.oschina.net/question/topic/masteronline" target="_blank"><img src="https://static.oschina.net/uploads/logo/masteronline_9WTeU.png" referrerpolicy="no-referrer">高手問答</a></div><div class="content" id="articleContent"><p><span><span>據 Gartner 預測，到 2025 年，雲原生架構將成為超過 95% 的新數字計劃基礎，高於 2021 年的不到 40%，雲原生架構市場佔有率不斷提高。而如今，全球半數以上（55%） 的網站都基於 NGINX 運行，差不多相同比例 (53.7%) 的中國網站在 NGINX 開源版上運行。而 NGINX 存在難於動態配置、管理功能影響業務等問題，為瞭解決這些問題，OpenNJet 由此誕生。</span></span></p><p><span><span>OpenNJet 基於 NGINX1.19 基礎 fork 並獨立演進，具有高性能、穩定、易擴展的特點，通過數據面與控制面的隔離，能夠在不重啓進程的情況下基於動態配置能力進行配置的實時更新。最近還推出了 OpenNJet K8s Ingress Controller 1.0，基於 OpenNJet 的動態特性、高性能實現，彌補了 NGINX 在雲原生場景中不足，而且提供了豐富的流量管理功能，如動態 location、host/path 路由、負載均衡、動態 upstream、金絲雀發佈、SNI 等。</span></span></p><p><strong><span><span>OSCHINA 本期高手問答（12 月 13 日 - 12 月 19 日）我們請來了嘉賓<a href="https://my.oschina.net/u/6606114" rel="nofollow">單雷老師</a>和大家一起聊聊 NGINX 向雲原生演進那點兒事。</span></span></strong></p><p><strong><span><span>可討論的問題包括但不限於</span></span></strong><strong><span><span>：</span></span></strong></p><ul><li><span><span style="background-color:white"><span>OpenNJet 和 NGINX 是什麼關係？</span></span></span></li><li><span><span style="background-color:white"><span>什麼是雲原生應用引擎？OpenNJet 的有哪些優勢</span></span></span></li><li><span><span style="background-color:white"><span>我們如何解決數據面控制面隔離、國密、動態配置等問題？</span></span></span></li><li><span><span style="background-color:white"><span>讀 NGINX/OpenNJet 源碼的建議</span></span></span></li><li><span><span style="background-color:white"><span>如何上手開發一個開源項目？</span></span></span></li></ul><p><span><span style="background-color:white"><span>其他關於 NGINX、OpenNJet 的更多內容，也歡迎積極提問。</span></span></span></p><h2><span><span style="background-color:white"><span><strong>嘉賓介紹</strong></span></span></span></h2><p><img alt="" height="534" src="https://oscimg.oschina.net/oscnet/up-774dc1b75df829000896339c602574ff319.jpg" width="400" referrerpolicy="no-referrer"></p><p><span><span><strong><span><span style="color:#7030a0">通明智雲產品總監，單雷</span></span></strong></span></span></p><p><span><span>20 年的 IT 行業經驗，精通雲原生以及高性能應用引擎技術。曾在亞信科技歷任研發主管、首席架構師等職務，並主導多個雲原生、高性能應用網關項目的設計開發工作，現任公司應用引擎產品總監。</span></span></p><hr><p><span><span style="background-color:white"><span><span>🎁</span> 為了鼓勵踴躍提問，下一代雲原生應用引擎 OpenNJet 開源社區會在問答結束後從提問者中抽取 5 名幸運會員，贈予精美棉馬甲一件。</span></span></span></p><p><img alt="" height="436" src="https://oscimg.oschina.net/oscnet/up-6f9dfb1df3b4d3c9f22f9a02a21c1be62d5.jpg" width="400" referrerpolicy="no-referrer"></p><blockquote><p><span><span>OpenNJet&nbsp;應用引擎是基於 NGINX 的面向互聯網和<strong>雲原生</strong>應用提供的運行時組態服務程序，作為底層引擎，OpenNJet 實現了 NGINX 雲原生功能增強、安全加固和代碼重構，利用<strong>動態加載機制</strong>可以實現不同的產品形態，如 Web 服務器、流媒體服務器、負載均衡、代理 (Proxy)、應用中間件、API 網關、消息隊列等產品形態等等。OpenNJet 在雲原生架構中作為數據平面，除了提供南北向通信網關的功能以外，還提供了服務網格中東西向通信能力。在原有功能基礎上增加了透明流量劫持、熔斷、遙測與故障注入等新功能特性。</span></span></p><p><span><span>Gitee：<a href="https://gitee.com/njet-rd/njet" rel="nofollow"><span><span>https://gitee.com/njet-rd/njet</span></span></a></span></span></p><p><span><span>官網：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnjet.org.cn%2F" rel="nofollow" target="_blank">https://njet.org.cn/</a></span></span></p></blockquote><p><span style="background-color:#ffffff; color:#27ae60">OSChina 高手問答一貫的風格，不歡迎任何與主題無關的討論和噴子。</span></p><p>下面歡迎大家就 「<span><span>NGINX 向雲原生演進</span></span>」<span><span>&nbsp;</span>相關</span>問題向<span>&nbsp;<a href="https://my.oschina.net/u/6606114" rel="nofollow">單雷老師</a></span><a href="https://my.oschina.net/klblog" rel="nofollow"><strong><span style="color:#000000">&nbsp;</span></strong></a>提問，直接回帖提問既可。</p></div><div class="poll-wrap"></div><div class="additional-remarks"></div><div class="ui basic center aligned segment action"><div class="ui big buttons"><a class="ui basic button collect-btn hover" data-id="2331501" data-user-id="4700705" data-obj-type="2" data-max="99" data-tag-required="" data-current-user-id="" data-recommend-tags=""><i class="star outline icon"></i>收藏 (<span data-collect-count="" data-id="2331501" data-obj-type="2">3</span>)</a><div class="ui basic dropdown share button osc-share dropdown-share" data-tag="share-question"><i class="share icon"></i><span>分享</span><div class="menu"><a class="item" data-platform="weibo" data-value="weibo"><i class="weibo icon"></i>微博</a><a class="item" data-platform="qq" data-value="qq"><i class="qq icon"></i>QQ</a><a class="item" data-platform="wechat" data-value="wechat"><i class="weixin icon"></i>微信</a></div></div></div><div class="ui basic segment"><a class="ban" ban-report="" data-id="2331501" data-obj-type="2" data-url="https://www.oschina.net/question/4700705_2331501"><i class="flag red icon"></i>舉報</a></div></div>
            ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 09:28:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/question/4700705_2331501</guid>
            <link>https://www.oschina.net/question/4700705_2331501</link>
        </item>
        <item>
            <title>
                <![CDATA[新技術 LINT 可強制 LLM 回答有毒問題]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="color:#000000">美國普渡大學（Purdue University）的研究人員發佈了，一篇名為《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2312.04782" target="_blank"><span style="background-color:#ffffff">Make Them Spill the Beans! Coercive Knowledge Extraction from (Production) LLMs</span></a>》的論文。描述了他們通過利用大模型廠商傾向於公開與提示響應相關的概率數據的特點，設計出了一種可以打破現有 LLM 規則，使其給出「有害」回答的新穎方法。</span></p><p><span style="color:#000000">研究人員使用了一種名為 LINT (LLM interrogation) 的技術，與繞過安全提示的一般越獄方式不同的是，這種技術更具強制性。它涉及到對概率值（logits）或軟標籤（soft labels）的理解 —— 從統計學上講，其可以有效區分安全響應與有害響應。</span></p><blockquote><p><span style="color:#000000">「在我們的研究中，我們揭示了當不良行為者可以訪問模型的輸出 logits 時，LLM alignment 面臨的的一種新威脅，這是開源 LLM 和許多商業 LLM API（如某些 GPT 模型）的共同特徵。它並不依賴於製作特定的提示。相反，它利用了這樣一個事實：即使 LLM 拒絕了有毒請求，有害響應也往往隱藏在輸出 logits 的深處。通過在自動迴歸生成過程中在幾個關鍵輸出位置強行選擇排名較低的輸出&nbsp;tokens，我們可以迫使模型揭示這些隱藏的響應。我們將這一過程稱為模型審訊（model interrogation）。」</span></p></blockquote><p><span style="color:#000000">具體<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theregister.com%2F2023%2F12%2F11%2Fchatbot_models_harmful_content%2F" target="_blank">表現為</a>，LINT 使用 LLM-based classifier 向 LLM 提出一個有害的問題：比如"説明如何將槍改裝成全自動的"。然後，對響應中的前九個 tokens（如 "It's"、"It"、"We"和 "I"）進行排序，並用這些詞組創建新句子，這樣該 LLM 就會不斷生成回覆。</span></p><p><span style="color:#000000"><img alt="" height="263" src="https://oscimg.oschina.net/oscnet/up-a4cca4832d0d4ac8918b03eacf880f3455b.png" width="500" referrerpolicy="no-referrer"></span></p><p><span style="color:#000000">研究人員在創建 LINT 原型時，在一個包含 50 個有毒問題的數據集上詢問了 7 個開源 LLM 和 3 個商業 LLM。他們稱：「當模型只被審訊一次時，ASR（攻擊成功率）達到 92%，當被詢問五次時，ASR 可以達到達到 98%。」</span></p><p><span style="color:#000000">這種方法與越獄方法不同，但性能要<span style="background-color:#ffffff">遠遠優於目前最先進的兩種越獄技術：GCG 和 GPTFuzzer。</span>相比之下越獄方法的 ASR 僅為 62%，且運行時間要長&nbsp;10 到 20 倍。「通過我們的方法揭露的有害內容更加相關、完整、清晰。此外，它可以補充越獄策略，從而進一步提高攻擊性能。」</span></p><p><span style="color:#000000">更重要的是，這種技術甚至適用於根據特定任務（如代碼生成）的基礎模型定製的 LLM。研究人員還聲稱，這種技術可以用來損害隱私和安全，迫使模型公開電子郵件地址和猜測弱密碼。</span></p><p><span style="color:#000000">因此，研究人員警告稱，AI&nbsp;界在考慮是否開源 LLM 時應謹慎；並建議最好的解決方案是確保有毒內容被清除，而不是將其隱藏起來。</span></p><p><span style="color:#000000">更多詳情可<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2312.04782" target="_blank">查看完整論文</a>。</span></p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 09:24:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270686/lint-llm-harmful-content</guid>
            <link>https://www.oschina.net/news/270686/lint-llm-harmful-content</link>
            <author>
                <![CDATA[來源: OSCHINA]]>
            </author>
        </item>
        <item>
            <title>
                <![CDATA[鎧俠向 Linux 基金會捐贈 Software-Enabled Flash SDK]]>
            </title>
            <description>
                <![CDATA[<div class="content"><p><span style="background-color:#ffffff; color:#121212">幾年前從東芝分離出來的存儲公司 Kioxia（</span>鎧俠<span style="background-color:#ffffff; color:#121212">）向 Linux 基金會捐贈了一個軟件開發工具包 (SDK)，用於建立 Software-Enabled Flash SDK。</span></p><p><span style="background-color:#ffffff; color:#121212">Linux 基金會發布<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linuxfoundation.org%2Fpress%2Fsoftware-enabled-flash-announces-software-development-kit-sdk" target="_blank">公告稱</a>，「SEF SDK 的發佈是存儲技術領域的一個重要里程碑......SEF 項目對 KIOXIA 突破性地捐贈軟件定義閃存原生 SDK 表示熱烈歡迎，這將為開發人員提供前所未有的能力，使他們能夠為閃存存儲（flash storage）應用開發定製的獨特軟件。」</span></p><p><img alt="" height="228" src="https://oscimg.oschina.net/oscnet/up-67690b065c2207474d1a67124aa3ef403da.png" width="300" referrerpolicy="no-referrer">&nbsp; &nbsp;<img alt="" height="228" src="https://oscimg.oschina.net/oscnet/up-1056c78ed4258dcb84497a6e896204821c0.jpg" width="300" referrerpolicy="no-referrer"></p><p>該 SEF SDK 包括示例代碼和文檔，以充分利用 flash media control 的潛力；包括 WAF 減少、延遲控制、對 ZNS 和 FDP 或 Block 等多種協議的支持等。</p><p>SEF 項目旨在通過加強對驅動器的管理、增強工作負載隔離、加強延遲控制以及實現對閃存管理的更多&nbsp;host-control，在現代數據中心中開闢新的用途並最大限度地發揮基於閃存的存儲潛力。</p></div>
                                    ]]>
            </description>
            <pubDate>Tue, 12 Dec 2023 03:09:00 GMT</pubDate>
            <guid isPermaLink="false">https://www.oschina.net/news/270608/software-enabled-flash-sdk</guid>
            <link>https://www.oschina.net/news/270608/software-enabled-flash-sdk</link>
            <author>
                <![CDATA[來源: 投稿]]>
            </author>
        </item>
    </channel>
</rss>
